<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一个逗比的碎碎念"><title>Python 编程思想 | 小土刀</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Python 编程思想</h1><a id="logo" href="/.">小土刀</a><p class="description">Agony is my triumph</p></div><div id="nav-menu"><a href="/." class="current"><i class="icon-home"> 首页</i></a><a href="/about/"><i class="icon-power-cord"> 技术</i></a><a href="/life/"><i class="icon-pacman"> 生活</i></a><a href="/portfolio/"><i class="icon-infinite"> 作品</i></a><a href="/archives/"><i class="icon-floppy-disk"> 归档</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">Python 编程思想</h1><div class="post-meta">2016-03-24 | <span class="categories">分类于<a href="/categories/Technique/"> Technique</a></span></div><span data-thread-key="2016/03/24/thinking-in-python/" class="ds-thread-count"></span><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#u6D45_u8C08_Python__u7684_with__u8BED_u53E5"><span class="toc-number">1.</span> <span class="toc-text">浅谈 Python 的 with 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u672F_u8BED"><span class="toc-number">1.1.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u57FA_u672C_u8BED_u6CD5_u548C_u5DE5_u4F5C_u539F_u7406"><span class="toc-number">1.2.</span> <span class="toc-text">基本语法和工作原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python_u7A0B_u5E8F_u7684_u6267_u884C_u539F_u7406"><span class="toc-number">2.</span> <span class="toc-text">Python程序的执行原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u5206_u6790_u5B57_u8282_u7801"><span class="toc-number">2.1.</span> <span class="toc-text">分析字节码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6267_u884C_u5B57_u8282_u7801"><span class="toc-number">2.2.</span> <span class="toc-text">执行字节码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python__u9ED1_u9B54_u6CD5"><span class="toc-number">3.</span> <span class="toc-text">Python 黑魔法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Python__u591A_u7EE7_u627F"><span class="toc-number">3.1.</span> <span class="toc-text">Python 多继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5217_u8868_u7684+_u548C+_3D_2C_append_u548Cextend"><span class="toc-number">3.2.</span> <span class="toc-text">列表的+和+=, append和extend</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#datetime_u4E5F_u6709_u5E03_u5C14_u503C"><span class="toc-number">3.3.</span> <span class="toc-text">datetime也有布尔值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u2019_3D_3D_u2019__u548C_is__u7684_u533A_u522B"><span class="toc-number">3.4.</span> <span class="toc-text">’==’ 和 is 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bool_u5176_u5B9E_u662Fint_u7684_u5B50_u7C7B"><span class="toc-number">3.5.</span> <span class="toc-text">bool其实是int的子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5143_u7EC4_u662F_u4E0D_u662F_u771F_u7684_u4E0D_u53EF_u53D8_3F"><span class="toc-number">3.6.</span> <span class="toc-text">元组是不是真的不可变?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5F02_u5E38_u5904_u7406_u52A0_else"><span class="toc-number">3.7.</span> <span class="toc-text">异常处理加 else</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u6DF1_u62F7_u8D1D_u4E0E_u6D45_u62F7_u8D1D"><span class="toc-number">4.</span> <span class="toc-text">深拷贝与浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u5BF9_u8C61_u8D4B_u503C"><span class="toc-number">4.1.</span> <span class="toc-text">对象赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6D45_u62F7_u8D1D"><span class="toc-number">4.2.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6DF1_u62F7_u8D1D"><span class="toc-number">4.3.</span> <span class="toc-text">深拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u62F7_u8D1D_u7684_u7279_u6B8A_u60C5_u51B5"><span class="toc-number">4.4.</span> <span class="toc-text">拷贝的特殊情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python__u4E2D_self__u7684_u542B_u4E49"><span class="toc-number">5.</span> <span class="toc-text">Python 中 self 的含义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#self_u4EE3_u8868_u7C7B_u7684_u5B9E_u4F8B_uFF0C_u800C_u975E_u7C7B_u3002"><span class="toc-number">5.1.</span> <span class="toc-text">self代表类的实例，而非类。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#self_u4E0D_u5FC5_u975E_u5199_u6210self"><span class="toc-number">5.2.</span> <span class="toc-text">self不必非写成self</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#self_u53EF_u4EE5_u4E0D_u5199_u5417"><span class="toc-number">5.3.</span> <span class="toc-text">self可以不写吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u603B_u7ED3"><span class="toc-number">5.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python_u7684_u5185_u5B58_u7BA1_u7406"><span class="toc-number">6.</span> <span class="toc-text">Python的内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u5BF9_u8C61_u7684_u5185_u5B58_u4F7F_u7528"><span class="toc-number">6.1.</span> <span class="toc-text">对象的内存使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5783_u573E_u56DE_u6536"><span class="toc-number">6.2.</span> <span class="toc-text">垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u603B_u7ED3-1"><span class="toc-number">6.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u5B57_u5178_u63A8_u5BFC_28Dictionary_comprehensions_29_u548C_u96C6_u5408_u63A8_u5BFC_28Set_comprehensions_29"><span class="toc-number">7.</span> <span class="toc-text">字典推导(Dictionary comprehensions)和集合推导(Set comprehensions)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python_u8C03_u7528_u7CFB_u7EDF_u547D_u4EE4_u6216_u8005_u811A_u672C"><span class="toc-number">8.</span> <span class="toc-text">Python调用系统命令或者脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python__u6355_u83B7_u7528_u6237_Ctrl+C__2CCtrl+D__u4E8B_u4EF6"><span class="toc-number">9.</span> <span class="toc-text">Python 捕获用户 Ctrl+C ,Ctrl+D 事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python__u8BFB_u5199_u6587_u4EF6"><span class="toc-number">10.</span> <span class="toc-text">Python 读写文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u88C5_u9970_u5668"><span class="toc-number">11.</span> <span class="toc-text">装饰器</span></a></li></ol></div></div><div class="post-content"><p>这里收集了一些深入 python 机制的内容。</p>
<a id="more"></a>
<hr>
<h2 id="u6D45_u8C08_Python__u7684_with__u8BED_u53E5"><a href="#u6D45_u8C08_Python__u7684_with__u8BED_u53E5" class="headerlink" title="浅谈 Python 的 with 语句"></a>浅谈 Python 的 with 语句</h2><p>with 语句是从 Python 2.5 开始引入的一种与异常处理相关的功能（2.5 版本中要通过 <code>from __future__ import with_statement</code> 导入后才可以使用），从 2.6 版本开始缺省可用（参考 What’s new in Python 2.6? 中 with 语句相关部分介绍）。with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。</p>
<h3 id="u672F_u8BED"><a href="#u672F_u8BED" class="headerlink" title="术语"></a>术语</h3><p>要使用 with 语句，首先要明白上下文管理器这一概念。有了上下文管理器，with 语句才能工作。</p>
<p>下面是一组与上下文管理器和with 语句有关的概念。</p>
<p>上下文管理协议（Context Management Protocol）：包含方法 <code>__enter__()</code> 和 <code>__exit__()</code>，支持该协议的对象要实现这两个方法。</p>
<p>上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了<br><code>__enter__()</code> 和 <code>__exit__()</code> 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。</p>
<p>运行时上下文（runtime context）：由上下文管理器创建，通过上下文管理器的 <code>__enter__()</code> 和 <code>__exit__()</code> 方法实现，<code>__enter__()</code> 方法在语句体执行之前进入运行时上下文，<code>__exit__()</code> 在语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。</p>
<p>上下文表达式（Context Expression）：with 语句中跟在关键字 with 之后的表达式，该表达式要返回一个上下文管理器对象。</p>
<p>语句体（with-body）：with 语句包裹起来的代码块，在执行语句体之前会调用上下文管<br>理器的 <code>__enter__()</code> 方法，执行完语句体之后会执行 <code>__exit__()</code> 方法。</p>
<h3 id="u57FA_u672C_u8BED_u6CD5_u548C_u5DE5_u4F5C_u539F_u7406"><a href="#u57FA_u672C_u8BED_u6CD5_u548C_u5DE5_u4F5C_u539F_u7406" class="headerlink" title="基本语法和工作原理"></a>基本语法和工作原理</h3><p>with 语句的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> context_expression [<span class="keyword">as</span> target(s)]:</span><br><span class="line">    <span class="keyword">with</span>-body</span><br></pre></td></tr></table></figure>
<p>这里 context_expression 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 target(s) ，如果指定了 as 子句的话，会将上下文管理器的 <code>__enter__()</code> 方法的返回值赋值给 target(s)。target(s) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）。</p>
<p>Python 对一些内建对象进行改进，加入了对上下文管理器的支持，可以用于 with 语句中，比如可以自动关闭文件、线程锁的自动获取和释放等。假设要对一个文件进行操作，使用 with 语句可以有如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">r'somefileName'</span>) <span class="keyword">as</span> somefile:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> somefile:</span><br><span class="line">        <span class="keyword">print</span> line</span><br><span class="line">        <span class="comment"># ...more code</span></span><br></pre></td></tr></table></figure>
<p>这里使用了 with 语句，不管在处理文件过程中是否发生异常，都能保证 with 语句执行完毕后已经关闭了打开的文件句柄。如果使用传统的 try/finally 范式，则要使用类似如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">somefile = open(<span class="string">r'somefileName'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> somefile:</span><br><span class="line">        <span class="keyword">print</span> line</span><br><span class="line">        <span class="comment"># ...more code</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    somefile.close()</span><br></pre></td></tr></table></figure>
<p>比较起来，使用 with 语句可以减少编码量。已经加入对上下文管理协议支持的还有模块 threading、decimal 等。</p>
<p>PEP 0343 对 with 语句的实现进行了描述。with 语句的执行过程类似如下代码块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">context_manager = context_expression</span><br><span class="line">exit = type(context_manager).__exit__  </span><br><span class="line">value = type(context_manager).__enter__(context_manager)</span><br><span class="line">exc = <span class="keyword">True</span>   <span class="comment"># True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        target = value  <span class="comment"># 如果使用了 as 子句</span></span><br><span class="line">        <span class="keyword">with</span>-body     <span class="comment"># 执行 with-body</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># 执行过程中有异常发生</span></span><br><span class="line">        exc = <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常</span></span><br><span class="line">        <span class="comment"># 由外层代码对异常进行处理</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exit(context_manager, *sys.exc_info()):</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出</span></span><br><span class="line">    <span class="comment"># 或者忽略异常退出</span></span><br><span class="line">    <span class="keyword">if</span> exc:</span><br><span class="line">        exit(context_manager, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line">    <span class="comment"># 缺省返回 None，None 在布尔上下文中看做是 False</span></span><br></pre></td></tr></table></figure>
<ol>
<li>执行 context_expression，生成上下文管理器 context_manager</li>
<li>调用上下文管理器的 <code>__enter__()</code> 方法；如果使用了 as 子句，则将 <code>__enter__()</code> 方法的返回值赋值给 as 子句中的 target(s)</li>
<li>执行语句体 with-body</li>
<li>不管是否执行过程中是否发生了异常，执行上下文管理器的 <code>__exit__()</code> 方法，<code>__exit__()</code> 方法负责执行“清理”工作，如释放资源等。如果执行过程中没有出现异常，或者语句体中执行了语句 break/continue/return，则以 None 作为参数调用 <code>__exit__(None, None, None)</code> ；如果执行过程中出现异常，则使用 sys.exc_info 得到的异常信息为参数调用 <code>__exit__(exc_type, exc_value, exc_traceback)</code></li>
<li>出现异常时，如果 <code>__exit__(type, value, traceback)</code> 返回 False，则会重新抛出异常，让with 之外的语句逻辑来处理异常，这也是通用做法；如果返回 True，则忽略异常，不再对异常进行处理</li>
</ol>
<h2 id="Python_u7A0B_u5E8F_u7684_u6267_u884C_u539F_u7406"><a href="#Python_u7A0B_u5E8F_u7684_u6267_u884C_u539F_u7406" class="headerlink" title="Python程序的执行原理"></a>Python程序的执行原理</h2><p>Python先把代码(.py文件)编译成字节码，交给字节码虚拟机，然后虚拟机一条一条执行字节码指令，从而完成程序的执行。</p>
<p>字节码在Python虚拟机程序里对应的是PyCodeObject对象。</p>
<p>.pyc文件是字节码在磁盘上的表现形式。</p>
<p>PyCodeObject对象的创建时机是模块加载的时候，即import。</p>
<p>Python test.py会对test.py进行编译成字节码并解释执行，但是不会生成test.pyc。</p>
<p>如果test.py加载了其他模块，如import util，Python会对util.py进行编译成字节码，生成util.pyc，然后对字节码解释执行。</p>
<p>如果想生成test.pyc，我们可以使用Python内置模块py_compile来编译。</p>
<p>加载模块时，如果同时存在.py和.pyc，Python会尝试使用.pyc，如果.pyc的编译时间早于.py的修改时间，则重新编译.py并更新.pyc。</p>
<p>Python代码的编译结果就是PyCodeObject对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    int co_argcount;        /* 位置参数个数 */</span><br><span class="line">    int co_nlocals;         /* 局部变量个数 */</span><br><span class="line">    int co_stacksize;       /* 栈大小 */</span><br><span class="line">    int co_flags;   </span><br><span class="line">    PyObject *co_code;      /* 字节码指令序列 */</span><br><span class="line">    PyObject *co_consts;    /* 所有常量集合 */</span><br><span class="line">    PyObject *co_names;     /* 所有符号名称集合 */</span><br><span class="line">    PyObject *co_varnames;  /* 局部变量名称集合 */</span><br><span class="line">    PyObject *co_freevars;  /* 闭包用的的变量名集合 */</span><br><span class="line">    PyObject *co_cellvars;  /* 内部嵌套函数引用的变量名集合 */</span><br><span class="line">    /* The rest doesn’t count <span class="keyword">for</span> hash/cmp */</span><br><span class="line">    PyObject *co_filename;  /* 代码所在文件名 */</span><br><span class="line">    PyObject *co_name;      /* 模块名|函数名|类名 */</span><br><span class="line">    int co_firstlineno;     /* 代码块在文件中的起始行号 */</span><br><span class="line">    PyObject *co_lnotab;    /* 字节码指令和行号的对应关系 */</span><br><span class="line">    void *co_zombieframe;   /* <span class="keyword">for</span> optimization only (see frameobject.c) */</span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>
<p>加载模块时，模块对应的PyCodeObject对象被写入.pyc文件，格式如下：</p>
<p><img src="/images/14588486364401.jpg" alt=""></p>
<h3 id="u5206_u6790_u5B57_u8282_u7801"><a href="#u5206_u6790_u5B57_u8282_u7801" class="headerlink" title="分析字节码"></a>分析字节码</h3><p>Python提供了内置函数compile可以编译Python代码和查看PyCodeObject对象，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = ”hello”</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> s</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure>
<p>在Python交互式shell里编译代码得到PyCodeObject对象:</p>
<p><img src="/images/14588486530973.jpg" alt=""></p>
<p>dir(co)已经列出co的各个域，想查看某个域直接在终端输出即可：</p>
<p><img src="/images/14588486595605.jpg" alt=""></p>
<p>test.py的PyCodeObject</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">co.co_argcount    0</span><br><span class="line">co.co_nlocals     0</span><br><span class="line">co.co_names       (‘s’, ’func’)</span><br><span class="line">co.co_varnames    (‘s’, ’func’)</span><br><span class="line">co.co_consts      (‘hello’, &lt;code object func at 0x2aaeeec57110, file ”test.py”, line 3&gt;, None)</span><br><span class="line">co.co_code        ’d<span class="command">\x</span>00<span class="command">\x</span>00Z<span class="command">\x</span>00<span class="command">\x</span>00d<span class="command">\x</span>01<span class="command">\x</span>00<span class="command">\x</span>84<span class="command">\x</span>00<span class="command">\x</span>00Z<span class="command">\x</span>01<span class="command">\x</span>00e<span class="command">\x</span>01<span class="command">\x</span>00<span class="command">\x</span>83<span class="command">\x</span>00<span class="command">\x</span>00<span class="command">\x</span>01d<span class="command">\x</span>02<span class="command">\x</span>00S’</span><br></pre></td></tr></table></figure>
<p>Python解释器会为函数也生成的字节码PyCodeObject对象，见上面的co_consts[1]</p>
<p>func的PyCodeObject</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_argcount</span>   0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_nlocals</span>    0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_names</span>      <span class="params">(‘s’,)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_varnames</span>   <span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_consts</span>     <span class="params">(None,)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_code</span>       ‘<span class="title">t</span>\<span class="title">x00</span>\<span class="title">x00GHd</span>\<span class="title">x00</span>\<span class="title">x00S</span>’</span></span><br></pre></td></tr></table></figure>
<h3 id="u6267_u884C_u5B57_u8282_u7801"><a href="#u6267_u884C_u5B57_u8282_u7801" class="headerlink" title="执行字节码"></a>执行字节码</h3><p>Python虚拟机的原理就是模拟可执行程序再X86机器上的运行，X86的运行时栈帧如下图：</p>
<p><img src="/images/14588486859304.jpg" alt=""></p>
<p>假如test.py用C语言来实现，会是下面这个样子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s = “hello”;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(“%s\n”, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python虚拟机的原理就是模拟上述行为。当发生函数调用时，创建新的栈帧，对应Python的实现就是PyFrameObject对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _frame &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    struct _frame *f_back;    /* 调用者的帧 */</span><br><span class="line">    PyCodeObject *f_code;     /* 帧对应的字节码对象 */</span><br><span class="line">    PyObject *f_builtins;     /* 内置名字空间 */</span><br><span class="line">    PyObject *f_globals;      /* 全局名字空间 */</span><br><span class="line">    PyObject *f_locals;       /* 本地名字空间 */</span><br><span class="line">    PyObject **f_valuestack;  /* 运行时栈底 */</span><br><span class="line">    PyObject **f_stacktop;    /* 运行时栈顶 */</span><br><span class="line">    …….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么对应Python的运行时栈就是这样子：</p>
<p><img src="/images/14588486997857.jpg" alt=""></p>
<p>执行test.py的字节码时，会先创建一个栈帧，以下用f表示当前栈帧，执行过程注释如下：</p>
<p>test.py的符号名集合和常量集合</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">co<span class="class">.co_names</span>   (‘s’, ’func’)</span><br><span class="line">co<span class="class">.co_consts</span>  (‘hello’, &lt;<span class="tag">code</span> <span class="tag">object</span> func at <span class="number">0</span>x2aaeeec57110, file ”test.py”, line <span class="number">3</span>&gt;, None)</span><br></pre></td></tr></table></figure>
<p>如果你想查看当前栈帧，Python提供了<code>sys._getframe()</code>方法可以获取当前栈帧，你只需要在代码里加入代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    frame = sys._getframe()</span><br><span class="line">    <span class="keyword">print</span> frame.f_locals</span><br><span class="line">    <span class="keyword">print</span> frame.f_globals</span><br><span class="line">    <span class="keyword">print</span> frame.f_back.f_locals</span><br><span class="line">    <span class="comment">#你可以打印frame的各个域</span></span><br><span class="line">    <span class="keyword">print</span> s</span><br></pre></td></tr></table></figure>
<h2 id="Python__u9ED1_u9B54_u6CD5"><a href="#Python__u9ED1_u9B54_u6CD5" class="headerlink" title="Python 黑魔法"></a>Python 黑魔法</h2><h3 id="Python__u591A_u7EE7_u627F"><a href="#Python__u591A_u7EE7_u627F" class="headerlink" title="Python 多继承"></a>Python 多继承</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class A(object):</span><br><span class="line">   ...:         def foo(self):</span><br><span class="line">   ...:                 print("class A")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [2]: class B(object):</span><br><span class="line">   ...:         def foo(self):</span><br><span class="line">   ...:                 print("class B")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [3]: class C(A, B):</span><br><span class="line">   ...:         pass</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [4]: C().foo()</span><br><span class="line">class A # 例子很好懂, C继承了A和B，从左到右,发现A有foo方法,返回了</span><br></pre></td></tr></table></figure>
<p>看起来都是很简单, 有次序的从底向上,从前向后找,找到就返回. 再看例子:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [5]: class A(object):</span><br><span class="line">   ...:        def foo(self):</span><br><span class="line">   ...:               print("class A")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [6]: class B(A):</span><br><span class="line">   ...:        pass</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [7]: class C(A):</span><br><span class="line">   ...:        def foo(self):</span><br><span class="line">   ...:               print("class C")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [8]: class D(B,C):</span><br><span class="line">   ...:        pass</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [9]: D().foo()</span><br><span class="line">class C # ? 按道理, 顺序是 D-&gt;B-&gt;A,为什么找到了C哪去了</span><br></pre></td></tr></table></figure>
<p>这也就涉及了MRO(Method Resolution Order):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: D.__mro__</span><br><span class="line">Out[<span class="number">10</span>]: (__main__.D, __main__.B, __main__.C, __main__.A, object)</span><br></pre></td></tr></table></figure>
<p>简单的理解其实就是新式类是广度优先了， D-&gt;B, 但是发现C也是继承A，就先找C，最后再去找A</p>
<h3 id="u5217_u8868_u7684+_u548C+_3D_2C_append_u548Cextend"><a href="#u5217_u8868_u7684+_u548C+_3D_2C_append_u548Cextend" class="headerlink" title="列表的+和+=, append和extend"></a>列表的+和+=, append和extend</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: print(<span class="string">'ID:'</span>, id(a_list))</span><br><span class="line">(<span class="string">'ID:'</span>, <span class="number">4481323592</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: a_list += [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: print(<span class="string">'ID (+=):'</span>, id(a_list))</span><br><span class="line">(<span class="string">'ID (+=):'</span>, <span class="number">4481323592</span>) <span class="comment"># 使用+= 还是在原来的列表上操作</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: a_list = a_list + [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: print(<span class="string">'ID (list = list + ...):'</span>, id(a_list))</span><br><span class="line">(<span class="string">'ID (list = list + ...):'</span>, <span class="number">4481293056</span>) <span class="comment"># 简单的+其实已经改变了原有列表</span></span><br><span class="line">In [<span class="number">28</span>]: a_list = []</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: id(a_list)</span><br><span class="line">Out[<span class="number">29</span>]: <span class="number">4481326976</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: a_list.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: id(a_list)</span><br><span class="line">Out[<span class="number">31</span>]: <span class="number">4481326976</span> <span class="comment"># append 是在原有列表添加</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: a_list.extend([<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: id(a_list)</span><br><span class="line">Out[<span class="number">33</span>]: <span class="number">4481326976</span> <span class="comment"># extend 也是在原有列表上添加</span></span><br></pre></td></tr></table></figure>
<h3 id="datetime_u4E5F_u6709_u5E03_u5C14_u503C"><a href="#datetime_u4E5F_u6709_u5E03_u5C14_u503C" class="headerlink" title="datetime也有布尔值"></a>datetime也有布尔值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">34</span>]: <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: print(<span class="string">'"datetime.time(0,0,0)" (Midnight) -&gt;'</span>, bool(datetime.time(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)))</span><br><span class="line">(<span class="string">'"datetime.time(0,0,0)" (Midnight) -&gt;'</span>, <span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: print(<span class="string">'"datetime.time(1,0,0)" (1 am) -&gt;'</span>, bool(datetime.time(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)))</span><br><span class="line">(<span class="string">'"datetime.time(1,0,0)" (1 am) -&gt;'</span>, <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="u2019_3D_3D_u2019__u548C_is__u7684_u533A_u522B"><a href="#u2019_3D_3D_u2019__u548C_is__u7684_u533A_u522B" class="headerlink" title="’==’ 和 is 的区别"></a>’==’ 和 is 的区别</h3><p>我的理解是”is”是判断2个对象的身份, ==是判断2个对象的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">37</span>]: a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: print(<span class="string">'a is b'</span>, bool(a <span class="keyword">is</span> b))</span><br><span class="line">(<span class="string">'a is b'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: c = <span class="number">999</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: d = <span class="number">999</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: print(<span class="string">'c is d'</span>, bool(c <span class="keyword">is</span> d))</span><br><span class="line">(<span class="string">'c is d'</span>, <span class="keyword">False</span>) <span class="comment"># 原因是python的内存管理,缓存了-5 - 256的对象</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: print(<span class="string">'256 is 257-1'</span>, <span class="number">256</span> <span class="keyword">is</span> <span class="number">257</span>-<span class="number">1</span>)</span><br><span class="line">(<span class="string">'256 is 257-1'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: print(<span class="string">'257 is 258-1'</span>, <span class="number">257</span> <span class="keyword">is</span> <span class="number">258</span> - <span class="number">1</span>)</span><br><span class="line">(<span class="string">'257 is 258-1'</span>, <span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: print(<span class="string">'-5 is -6+1'</span>, -<span class="number">5</span> <span class="keyword">is</span> -<span class="number">6</span>+<span class="number">1</span>)</span><br><span class="line">(<span class="string">'-5 is -6+1'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: print(<span class="string">'-7 is -6-1'</span>, -<span class="number">7</span> <span class="keyword">is</span> -<span class="number">6</span>-<span class="number">1</span>)</span><br><span class="line">(<span class="string">'-7 is -6-1'</span>, <span class="keyword">False</span>)</span><br><span class="line">In [<span class="number">47</span>]: a = <span class="string">'hello world!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: b = <span class="string">'hello world!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: print(<span class="string">'a is b,'</span>, a <span class="keyword">is</span> b)</span><br><span class="line">(<span class="string">'a is b,'</span>, <span class="keyword">False</span>) <span class="comment"># 很明显 他们没有被缓存,这是2个字段串的对象</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: print(<span class="string">'a == b,'</span>, a == b)</span><br><span class="line">(<span class="string">'a == b,'</span>, <span class="keyword">True</span>) <span class="comment"># 但他们的值相同</span></span><br><span class="line"><span class="comment"># But, 有个特例</span></span><br><span class="line">In [<span class="number">51</span>]: a = float(<span class="string">'nan'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: print(<span class="string">'a is a,'</span>, a <span class="keyword">is</span> a)</span><br><span class="line">(<span class="string">'a is a,'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: print(<span class="string">'a == a,'</span>, a == a)</span><br><span class="line">(<span class="string">'a == a,'</span>, <span class="keyword">False</span>) <span class="comment"># 亮瞎我眼睛了~</span></span><br></pre></td></tr></table></figure>
<h3 id="bool_u5176_u5B9E_u662Fint_u7684_u5B50_u7C7B"><a href="#bool_u5176_u5B9E_u662Fint_u7684_u5B50_u7C7B" class="headerlink" title="bool其实是int的子类"></a>bool其实是int的子类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">97</span>]: isinstance(<span class="keyword">True</span>, int)</span><br><span class="line">Out[<span class="number">97</span>]: <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: <span class="keyword">True</span> + <span class="keyword">True</span></span><br><span class="line">Out[<span class="number">98</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: <span class="number">3</span> * <span class="keyword">True</span> + <span class="keyword">True</span></span><br><span class="line">Out[<span class="number">99</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: <span class="number">3</span> * <span class="keyword">True</span> - <span class="keyword">False</span></span><br><span class="line">Out[<span class="number">100</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: <span class="keyword">True</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">Out[<span class="number">104</span>]: <span class="number">1024</span></span><br></pre></td></tr></table></figure>
<h3 id="u5143_u7EC4_u662F_u4E0D_u662F_u771F_u7684_u4E0D_u53EF_u53D8_3F"><a href="#u5143_u7EC4_u662F_u4E0D_u662F_u771F_u7684_u4E0D_u53EF_u53D8_3F" class="headerlink" title="元组是不是真的不可变?"></a>元组是不是真的不可变?</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [111]: tup = ([],)</span><br><span class="line"></span><br><span class="line">In [112]: tup[0] += [1]</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-112-d4f292cf35de&gt; in &lt;module&gt;()</span><br><span class="line">----&gt; 1 tup[0] += [1]</span><br><span class="line"></span><br><span class="line">TypeError: 'tuple' object does not support item assignment</span><br><span class="line"></span><br><span class="line">In [113]: tup</span><br><span class="line">Out[113]: ([1],) # 我靠 又是亮瞎我眼睛,明明抛了异常 还能修改?</span><br><span class="line"></span><br><span class="line">In [114]: tup = ([],)</span><br><span class="line"></span><br><span class="line">In [115]: tup[0].extend([1])</span><br><span class="line"></span><br><span class="line">In [116]: tup[0]</span><br><span class="line">Out[116]: [1] # 好吧,我有点看明白了, 虽然我不能直接操作元组，但是不能阻止我操作元组中可变的子对象(list)</span><br></pre></td></tr></table></figure>
<p>+= 是一个特例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">117</span>]: my_tup = (<span class="number">1</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: my_tup += (<span class="number">4</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: my_tup = my_tup + (<span class="number">5</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: my_tup</span><br><span class="line">Out[<span class="number">120</span>]: (<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment"># ? 嗯 不是不能操作元组嘛?</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: my_tup = (<span class="number">1</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: print(id(my_tup))</span><br><span class="line"><span class="number">4481317904</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: my_tup += (<span class="number">4</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: print(id(my_tup))</span><br><span class="line"><span class="number">4480606864</span> <span class="comment"># 操作的不是原来的元组 所以可以</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: my_tup = my_tup + (<span class="number">5</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">126</span>]: print(id(my_tup))</span><br><span class="line"><span class="number">4474234912</span></span><br></pre></td></tr></table></figure>
<h3 id="u5F02_u5E38_u5904_u7406_u52A0_else"><a href="#u5F02_u5E38_u5904_u7406_u52A0_else" class="headerlink" title="异常处理加 else"></a>异常处理加 else</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">150</span>]: <span class="keyword">try</span>:</span><br><span class="line">   .....:     print(<span class="string">'third element:'</span>, a_list[<span class="number">2</span>])</span><br><span class="line">   .....: <span class="keyword">except</span> IndexError:</span><br><span class="line">   .....:     print(<span class="string">'raised IndexError'</span>)</span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:     print(<span class="string">'no error in try-block'</span>) <span class="comment"># 只有在try里面没有异常的时候才会执行else里面的表达式</span></span><br><span class="line">   .....:</span><br><span class="line">raised IndexError <span class="comment"># 抛异常了 没完全完成</span></span><br><span class="line">In [<span class="number">153</span>]: i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">154</span>]: <span class="keyword">while</span> i &lt; <span class="number">2</span>:</span><br><span class="line">   .....:     print(i)</span><br><span class="line">   .....:     i += <span class="number">1</span></span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:     print(<span class="string">'in else'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> <span class="keyword">else</span> <span class="comment"># while也支持哦~</span></span><br><span class="line">In [<span class="number">155</span>]: i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: <span class="keyword">while</span> i &lt; <span class="number">2</span>:</span><br><span class="line">   .....:         print(i)</span><br><span class="line">   .....:         i += <span class="number">1</span></span><br><span class="line">   .....:         <span class="keyword">break</span></span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:         print(<span class="string">'completed while-loop'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span> <span class="comment"># 被break了 没有完全执行完 就不执行else里面的了</span></span><br><span class="line">In [<span class="number">158</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">   .....:         print(i)</span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:         print(<span class="string">'completed for-loop'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">completed <span class="keyword">for</span>-loop</span><br><span class="line"></span><br><span class="line">In [<span class="number">159</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">   .....:         print(i)</span><br><span class="line">   .....:         <span class="keyword">break</span></span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:         print(<span class="string">'completed for-loop'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span> <span class="comment"># 也是因为break了</span></span><br></pre></td></tr></table></figure>
<h2 id="u6DF1_u62F7_u8D1D_u4E0E_u6D45_u62F7_u8D1D"><a href="#u6DF1_u62F7_u8D1D_u4E0E_u6D45_u62F7_u8D1D" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><h3 id="u5BF9_u8C61_u8D4B_u503C"><a href="#u5BF9_u8C61_u8D4B_u503C" class="headerlink" title="对象赋值"></a>对象赋值</h3><p>Python中，对象的赋值，拷贝（深/浅拷贝）之间是有差异的，如果使用的时候不注意，就可能产生意外的结果。</p>
<p>直接看一段代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">will = [<span class="string">"Will"</span>, <span class="number">28</span>, [<span class="string">"Python"</span>, <span class="string">"C#"</span>, <span class="string">"JavaScript"</span>]]</span><br><span class="line">wilber = will</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">"Wilber"</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">"CSS"</span>)</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br></pre></td></tr></table></figure>
<p><img src="/media/14521096832549/tip1.png" alt="tip1"></p>
<p>下面来分析一下这段代码：</p>
<ul>
<li>首先，创建了一个名为will的变量，这个变量指向一个list对象，从第一张图中可以看到所有对象的地址（每次运行，结果可能不同）</li>
<li>然后，通过will变量对wilber变量进行赋值，那么wilber变量将指向will变量对应的对象（内存地址），也就是说”wilber is will”，”wilber[i] is will[i]”</li>
<li>可以理解为，Python中，对象的赋值都是进行对象引用（内存地址）传递</li>
</ul>
<p>第三张图中，由于will和wilber指向同一个对象，所以对will的任何修改都会体现在wilber上<br>这里需要注意的一点是，str是不可变类型，所以当修改的时候会替换旧的对象，产生一个新的地址39758496</p>
<p><img src="/images/14588487955418.jpg" alt=""></p>
<h3 id="u6D45_u62F7_u8D1D"><a href="#u6D45_u62F7_u8D1D" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>下面就来看看浅拷贝的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">will = [<span class="string">"Will"</span>, <span class="number">28</span>, [<span class="string">"Python"</span>, <span class="string">"C#"</span>, <span class="string">"JavaScript"</span>]]</span><br><span class="line">wilber = copy.copy(will)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">"Wilber"</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">"CSS"</span>)</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br></pre></td></tr></table></figure>
<p>代码结果为：</p>
<p><img src="/images/14588488054814.jpg" alt=""></p>
<p>分析一下这段代码：</p>
<ul>
<li>首先，依然使用一个will变量，指向一个list类型的对象</li>
<li>然后，通过copy模块里面的浅拷贝函数copy()，对will指向的对象进行浅拷贝，然后浅拷贝生成的新对象赋值给wilber变量<ul>
<li>浅拷贝会创建一个新的对象，这个例子中”wilber is not will”</li>
<li>但是，对于对象中的元素，浅拷贝就只会使用原始元素的引用（内存地址），也就是说”wilber[i] is will[i]”</li>
</ul>
</li>
<li>当对will进行修改的时候<ul>
<li>由于list的第一个元素是不可变类型，所以will对应的list的第一个元素会使用一个新的对象39758496</li>
<li>但是list的第三个元素是一个可变类型，修改操作不会产生新的对象，所以will的修改结果会相应的反应到wilber上</li>
</ul>
</li>
</ul>
<p><img src="/images/14588488145630.jpg" alt=""></p>
<p>总结一下，当我们使用下面的操作的时候，会产生浅拷贝的效果：</p>
<ul>
<li>使用切片[:]操作</li>
<li>使用工厂函数（如list/dir/set）</li>
<li>使用copy模块中的copy()函数</li>
</ul>
<h3 id="u6DF1_u62F7_u8D1D"><a href="#u6DF1_u62F7_u8D1D" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>最后来看看深拷贝：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">will = [<span class="string">"Will"</span>, <span class="number">28</span>, [<span class="string">"Python"</span>, <span class="string">"C#"</span>, <span class="string">"JavaScript"</span>]]</span><br><span class="line">wilber = copy.deepcopy(will)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">"Wilber"</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">"CSS"</span>)</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br></pre></td></tr></table></figure>
<p>代码的结果为：</p>
<p><img src="/images/14588488380987.jpg" alt=""></p>
<p>分析一下这段代码：</p>
<ul>
<li>首先，同样使用一个will变量，指向一个list类型的对象</li>
<li>然后，通过copy模块里面的深拷贝函数deepcopy()，对will指向的对象进行深拷贝，然后深拷贝生成的新对象赋值给wilber变量<ul>
<li>跟浅拷贝类似，深拷贝也会创建一个新的对象，这个例子中”wilber is not will”</li>
<li>但是，对于对象中的元素，深拷贝都会重新生成一份（有特殊情况，下面会说明），而不是简单的使用原始元素的引用（内存地址）</li>
<li>例子中will的第三个元素指向39737304，而wilber的第三个元素是一个全新的对象39773088，也就是说，”wilber[2] is not will[2]”</li>
</ul>
</li>
<li>当对will进行修改的时候<ul>
<li>由于list的第一个元素是不可变类型，所以will对应的list的第一个元素会使用一个新的对象39758496</li>
<li>但是list的第三个元素是一个可变类型，修改操作不会产生新的对象，但是由于”wilber[2] is not will[2]”，所以will的修改不会影响wilber</li>
</ul>
</li>
</ul>
<p><img src="/images/14588488493152.jpg" alt=""></p>
<h3 id="u62F7_u8D1D_u7684_u7279_u6B8A_u60C5_u51B5"><a href="#u62F7_u8D1D_u7684_u7279_u6B8A_u60C5_u51B5" class="headerlink" title="拷贝的特殊情况"></a>拷贝的特殊情况</h3><p>其实，对于拷贝有一些特殊情况：</p>
<ul>
<li>对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有拷贝这一说<ul>
<li>也就是说，对于这些类型，”obj is copy.copy(obj)” 、”obj is copy.deepcopy(obj)”</li>
</ul>
</li>
<li>如果元组变量只包含原子类型对象，则不能深拷贝，看下面的例子</li>
</ul>
<p><img src="/images/14588488582446.jpg" alt=""></p>
<p>总结</p>
<p>本文介绍了对象的赋值和拷贝，以及它们之间的差异：</p>
<ul>
<li>Python中对象的赋值都是进行对象引用（内存地址）传递</li>
<li>使用copy.copy()，可以进行对象的浅拷贝，它复制了对象，但对于对象中的元素，依然使用原始的引用.</li>
<li>如果需要复制一个容器对象，以及它里面的所有元素（包含元素的子元素），可以使用copy.deepcopy()进行深拷贝</li>
<li>对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有被拷贝一说</li>
<li>如果元组变量只包含原子类型对象，则不能深拷贝，看下面的例子</li>
</ul>
<h2 id="Python__u4E2D_self__u7684_u542B_u4E49"><a href="#Python__u4E2D_self__u7684_u542B_u4E49" class="headerlink" title="Python 中 self 的含义"></a>Python 中 self 的含义</h2><p>刚开始学习Python的类写法的时候觉得很是麻烦，为什么定义时需要而调用时又不需要，为什么不能内部简化从而减少我们敲击键盘的次数？</p>
<h3 id="self_u4EE3_u8868_u7C7B_u7684_u5B9E_u4F8B_uFF0C_u800C_u975E_u7C7B_u3002"><a href="#self_u4EE3_u8868_u7C7B_u7684_u5B9E_u4F8B_uFF0C_u800C_u975E_u7C7B_u3002" class="headerlink" title="self代表类的实例，而非类。"></a>self代表类的实例，而非类。</h3><p>实例来说明</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line">        print(self.__class__)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Test object at <span class="number">0x000000000284E080</span>&gt;</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Test</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的例子中可以很明显的看出，self代表的是类的实例。而self.class则指向类。</p>
<h3 id="self_u4E0D_u5FC5_u975E_u5199_u6210self"><a href="#self_u4E0D_u5FC5_u975E_u5199_u6210self" class="headerlink" title="self不必非写成self"></a>self不必非写成self</h3><p>有很多童鞋是先学习别的语言然后学习Python的，所以总觉得self怪怪的，想写成this，可以吗？</p>
<p>当然可以，还是把上面的代码改写一下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(this)</span>:</span></span><br><span class="line">        print(this)</span><br><span class="line">        print(this.__class__)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure>
<p>改成this后，运行结果完全一样。</p>
<p>当然，最好还是尊重约定俗成的习惯，使用self。</p>
<h3 id="self_u53EF_u4EE5_u4E0D_u5199_u5417"><a href="#self_u53EF_u4EE5_u4E0D_u5199_u5417" class="headerlink" title="self可以不写吗"></a>self可以不写吗</h3><p>在Python的解释器内部，当我们调用t.prt()时，实际上Python解释成Test.prt(t)，也就是说把self替换成类的实例。</p>
<p>有兴趣的童鞋可以把上面的t.prt()一行改写一下，运行后的实际结果完全相同。</p>
<p>实际上已经部分说明了self在定义时不可以省略，如果非要试一下，那么请看下面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">()</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure>
<p>运行时提醒错误如下：prt在定义时没有参数，但是我们运行时强行传了一个参数。<br>由于上面解释过了t.prt()等同于Test.prt(t)，所以程序提醒我们多传了一个参数t。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"h.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    t.<span class="function"><span class="title">prt</span><span class="params">()</span></span></span><br><span class="line">TypeError: <span class="function"><span class="title">prt</span><span class="params">()</span></span> takes <span class="number">0</span> positional arguments but <span class="number">1</span> was given</span><br></pre></td></tr></table></figure>
<p>当然，如果我们的定义和调用时均不传类实例是可以的，这就是类方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">()</span>:</span></span><br><span class="line">        print(__class__)</span><br><span class="line">Test.prt()</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<pre><code>&lt;class &apos;__main__.Test&apos;&gt;
</code></pre><p>在继承时，传入的是哪个实例，就是那个传入的实例，而不是指定义了self的类的实例。<br>先看代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pprt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cprt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line">c = Child()</span><br><span class="line">c.cprt()</span><br><span class="line">c.pprt()</span><br><span class="line">p = Parent()</span><br><span class="line">p.pprt()</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__<span class="class">.Child</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A47080&gt;</span><br><span class="line">&lt;__main__<span class="class">.Child</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A47080&gt;</span><br><span class="line">&lt;__main__<span class="class">.Parent</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A47240&gt;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>运行c.cprt()时应该没有理解问题，指的是Child类的实例。</p>
<p>但是在运行c.pprt()时，等同于Child.pprt(c)，所以self指的依然是Child类的实例，由于self中没有定义pprt()方法，所以沿着继承树往上找，发现在父类Parent中定义了pprt()方法，所以就会成功调用。</p>
<p>在描述符类中，self指的是描述符类的实例</p>
<p>不太容易理解，先看实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desc</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, ins, cls)</span>:</span></span><br><span class="line">        print(<span class="string">'self in Desc: %s '</span> % self )</span><br><span class="line">        print(self, ins, cls)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    x = Desc()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'self in Test: %s'</span> % self)</span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br><span class="line">t.x</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self <span class="keyword">in</span> Test: &lt;__main__<span class="class">.Test</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A570B8&gt;</span><br><span class="line">self <span class="keyword">in</span> Desc: &lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000283E208&gt;</span><br><span class="line">&lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000283E208&gt; &lt;__main__<span class="class">.Test</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A570B8&gt; &lt;class <span class="string">'__main__.Test'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>大部分童鞋开始有疑问了，为什么在Desc类中定义的self不是应该是调用它的实例t吗？怎么变成了Desc类的实例了呢？</p>
<p>注意：此处需要睁大眼睛看清楚了，这里调用的是t.x，也就是说是Test类的实例t的属性x，由于实例t中并没有定义属性x，所以找到了类属性x，而该属性是描述符属性，为Desc类的实例而已，所以此处并没有顶用Test的任何方法。</p>
<p>那么我们如果直接通过类来调用属性x也可以得到相同的结果。</p>
<p>下面是把t.x改为Test.x运行的结果。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self <span class="keyword">in</span> Test: &lt;__main__<span class="class">.Test</span> <span class="tag">object</span> at <span class="number">0</span>x00000000022570B8&gt;</span><br><span class="line">self <span class="keyword">in</span> Desc: &lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000223E208&gt;</span><br><span class="line">&lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000223E208&gt; None &lt;class <span class="string">'__main__.Test'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>题外话：由于在很多时候描述符类中仍然需要知道调用该描述符的实例是谁，所以在描述符类中存在第二个参数ins，用来表示调用它的类实例，所以t.x时可以看到第三行中的运行结果中第二项为<main.test object="" at="" 0x0000000002a570b8="">。而采用Test.x进行调用时，由于没有实例，所以返回None。</main.test></p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>self在定义时需要定义，但是在调用时会自动传入。</li>
<li>self的名字并不是规定死的，但是最好还是按照约定是用self</li>
<li>self总是指调用时的类的实例。</li>
</ul>
<h2 id="Python_u7684_u5185_u5B58_u7BA1_u7406"><a href="#Python_u7684_u5185_u5B58_u7BA1_u7406" class="headerlink" title="Python的内存管理"></a>Python的内存管理</h2><p>以Python语言为例子，说明一门动态类型的、面向对象的语言的内存管理方式。</p>
<h3 id="u5BF9_u8C61_u7684_u5185_u5B58_u4F7F_u7528"><a href="#u5BF9_u8C61_u7684_u5185_u5B58_u4F7F_u7528" class="headerlink" title="对象的内存使用"></a>对象的内存使用</h3><p>赋值语句是语言最常见的功能了。但即使是最简单的赋值语句，也可以很有内涵。Python的赋值语句就很值得研究。</p>
<pre><code>a = 1
</code></pre><p>整数1为一个对象。而a是一个引用。利用赋值语句，引用a指向对象1。Python是动态类型的语言(参考动态类型)，对象与引用分离。Python像使用“筷子”那样，通过引用来接触和翻动真正的食物——对象。</p>
<p>为了探索对象在内存的存储，我们可以求助于Python的内置函数id()。它用于返回对象的身份(identity)。其实，这里所谓的身份，就是该对象的内存地址。</p>
<pre><code>a = 1
print(id(a))
print(hex(id(a)))
</code></pre><p>在我的计算机上，它们返回的是:</p>
<pre><code>11246696
’0xab9c68′
</code></pre><p>分别为内存地址的十进制和十六进制表示。</p>
<p>在Python中，整数和短小的字符，Python都会缓存这些对象，以便重复使用。当我们创建多个等于1的引用时，实际上是让所有这些引用指向同一个对象。</p>
<pre><code>a = 1
b = 1
print(id(a))
print(id(b))
</code></pre><p>上面程序返回</p>
<pre><code>11246696
11246696
</code></pre><p>可见a和b实际上是指向同一个对象的两个引用。</p>
<p>为了检验两个引用指向同一个对象，我们可以用is关键字。is用于判断两个引用所指的对象是否相同。</p>
<pre><code># True
a = 1
b = 1
print(a is b)

# True
a = &quot;good&quot;
b = &quot;good&quot;
print(a is b)

# False
a = &quot;very good morning&quot;
b = &quot;very good morning&quot;
print(a is b)

# False
a = []
b = []
print(a is b)
</code></pre><p>上面的注释为相应的运行结果。可以看到，由于Python缓存了整数和短字符串，因此每个对象只存有一份。比如，所有整数1的引用都指向同一对象。即使使用赋值语句，也只是创造了新的引用，而不是对象本身。长的字符串和其它对象可以有多个相同的对象，可以使用赋值语句创建出新的对象。</p>
<p>在Python中，每个对象都有存有指向该对象的引用总数，即引用计数(reference count)。</p>
<p>我们可以使用sys包中的getrefcount()，来查看某个对象的引用计数。需要注意的是，当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的多1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(getrefcount(a))</span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line">print(getrefcount(b))</span><br></pre></td></tr></table></figure>
<p>由于上述原因，两个getrefcount将返回2和3，而不是期望的1和2。</p>
<p>Python的一个容器对象(container)，比如表、词典等，可以包含多个对象。实际上，容器对象中包含的并不是元素对象本身，是指向各个元素对象的引用。</p>
<p>我们也可以自定义一个对象，并引用其它对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">from_obj</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, to_obj)</span>:</span></span><br><span class="line">        self.to_obj = to_obj</span><br><span class="line"></span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a = from_obj(b)</span><br><span class="line">print(id(a.to_obj))</span><br><span class="line">print(id(b))</span><br></pre></td></tr></table></figure>
<p>可以看到，a引用了对象b。</p>
<p>对象引用对象，是Python最基本的构成方式。即使是a = 1这一赋值方式，实际上是让词典的一个键值”a”的元素引用整数对象1。该词典对象用于记录所有的全局引用。该词典引用了整数对象1。我们可以通过内置函数globals()来查看该词典。</p>
<p>当一个对象A被另一个对象B引用时，A的引用计数将增加1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(getrefcount(a))</span><br><span class="line"></span><br><span class="line">b = [a, a]</span><br><span class="line">print(getrefcount(a))</span><br></pre></td></tr></table></figure>
<p>由于对象b引用了两次a，a的引用计数增加了2。</p>
<p>容器对象的引用可能构成很复杂的拓扑结构。我们可以用objgraph包来绘制其引用关系，比如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [x, dict(key1=x)]</span><br><span class="line">z = [y, (x, y)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> objgraph</span><br><span class="line">objgraph.show_refs([z], filename=<span class="string">'ref_topo.png'</span>)</span><br></pre></td></tr></table></figure>
<p>objgraph是Python的一个第三方包。安装之前需要安装xdot。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="keyword">install</span> xdot</span><br><span class="line">sudo pip <span class="keyword">install</span> objgraph</span><br></pre></td></tr></table></figure>
<p>两个对象可能相互引用，从而构成所谓的引用环(reference cycle)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">b = [a]</span><br><span class="line">a.append(b)</span><br></pre></td></tr></table></figure>
<p>即使是一个对象，只需要自己引用自己，也能构成引用环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">a.append(a)</span><br><span class="line">print(getrefcount(a))</span><br></pre></td></tr></table></figure>
<p>引用环会给垃圾回收机制带来很大的麻烦，我将在后面详细叙述这一点。</p>
<p>某个对象的引用计数可能减少。比如，可以使用del关键字删除某个引用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">print(getrefcount(b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line">print(getrefcount(b))</span><br></pre></td></tr></table></figure>
<p>del也可以用于删除容器元素中的元素，比如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> a[<span class="number">0</span>]</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>如果某个引用指向对象A，当这个引用被重新定向到某个其他对象B时，对象A的引用计数减少:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">print(getrefcount(b))</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">print(getrefcount(b))</span><br></pre></td></tr></table></figure>
<h3 id="u5783_u573E_u56DE_u6536"><a href="#u5783_u573E_u56DE_u6536" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>吃太多，总会变胖，Python也是这样。当Python中的对象越来越多，它们将占据越来越大的内存。不过你不用太担心Python的体形，它会乖巧的在适当的时候“减肥”，启动垃圾回收(garbage collection)，将没用的对象清除。在许多语言中都有垃圾回收机制，比如Java和Ruby。尽管最终目的都是塑造苗条的提醒，但不同语言的减肥方案有很大的差异。</p>
<p>从基本原理上，当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如某个新建对象，它被分配给某个引用，对象的引用计数变为1。如果引用被删除，对象的引用计数为0，那么该对象就可以被垃圾回收。比如下面的表:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> a</span><br></pre></td></tr></table></figure>
<p>del a后，已经没有任何引用指向之前建立的[1, 2, 3]这个表。用户不可能通过任何方式接触或者动用这个对象。这个对象如果继续待在内存里，就成了不健康的脂肪。当垃圾回收启动时，Python扫描到这个引用计数为0的对象，就将它所占据的内存清空。</p>
<p>然而，减肥是个昂贵而费力的事情。垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要总启动垃圾回收。所以，Python只会在特定条件下，自动启动垃圾回收。当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。</p>
<p>我们可以通过gc模块的get_threshold()方法，查看该阈值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">print(gc.get_threshold())</span><br></pre></td></tr></table></figure>
<p>返回(700, 10, 10)，后面的两个10是与分代回收相关的阈值，后面可以看到。700即是垃圾回收启动的阈值。可以通过gc中的set_threshold()方法重新设置。</p>
<p>我们也可以手动启动垃圾回收，即使用gc.collect()。</p>
<p>Python同时采用了分代(generation)回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。</p>
<p>小家伙要多检查</p>
<p>Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。</p>
<p>这两个次数即上面get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。</p>
<p>同样可以用set_threshold()来调整，比如对2代对象进行更频繁的扫描。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">gc.set_threshold(<span class="number">700</span>, <span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>引用环的存在会给上面的垃圾回收机制带来很大的困难。这些引用环可能构成无法使用，但引用计数不为0的一些对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">b = [a]</span><br><span class="line">a.append(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"><span class="keyword">del</span> b</span><br></pre></td></tr></table></figure>
<p>上面我们先创建了两个表对象，并引用对方，构成一个引用环。删除了a，b引用之后，这两个对象不可能再从程序中调用，就没有什么用处了。但是由于引用环的存在，这两个对象的引用计数都没有降到0，不会被垃圾回收。</p>
<p>为了回收这样的引用环，Python复制每个对象的引用计数，可以记为gc_ref。假设，每个对象i，该计数为gc_ref_i。Python会遍历所有的对象i。对于每个对象i引用的对象j，将相应的gc_ref_j减1。</p>
<p>在结束遍历后，gc_ref不为0的对象，和这些对象引用的对象，以及继续更下游引用的对象，需要被保留。而其它的对象则被垃圾回收。</p>
<h3 id="u603B_u7ED3-1"><a href="#u603B_u7ED3-1" class="headerlink" title="总结"></a>总结</h3><p>Python作为一种动态类型的语言，其对象和引用分离。这与曾经的面向过程语言有很大的区别。为了有效的释放内存，Python内置了垃圾回收的支持。Python采取了一种相对简单的垃圾回收机制，即引用计数，并因此需要解决孤立引用环的问题。Python与其它语言既有共通性，又有特别的地方。对该内存管理机制的理解，是提高Python性能的重要一步。</p>
<h2 id="u5B57_u5178_u63A8_u5BFC_28Dictionary_comprehensions_29_u548C_u96C6_u5408_u63A8_u5BFC_28Set_comprehensions_29"><a href="#u5B57_u5178_u63A8_u5BFC_28Dictionary_comprehensions_29_u548C_u96C6_u5408_u63A8_u5BFC_28Set_comprehensions_29" class="headerlink" title="字典推导(Dictionary comprehensions)和集合推导(Set comprehensions)"></a>字典推导(Dictionary comprehensions)和集合推导(Set comprehensions)</h2><p>大多数的Python程序员都知道且使用过列表推导(list comprehensions)。如果你对list comprehensions概念不是很熟悉——一个list comprehension就是一个更简短、简洁的创建一个list的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>some_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>another_list = [ x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> some_list ]</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>another_list</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>自从python 3.1 (甚至是Python 2.7)起，我们可以用同样的语法来创建集合和字典表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="comment"># Set Comprehensions</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>some_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>even_set = &#123; x <span class="keyword">for</span> x <span class="keyword">in</span> some_list <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>even_set</span><br><span class="line">set([<span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="comment"># Dict Comprehensions</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d = &#123; x: x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="number">1</span>: <span class="keyword">False</span>, <span class="number">2</span>: <span class="keyword">True</span>, <span class="number">3</span>: <span class="keyword">False</span>, <span class="number">4</span>: <span class="keyword">True</span>, <span class="number">5</span>: <span class="keyword">False</span>, <span class="number">6</span>: <span class="keyword">True</span>, <span class="number">7</span>: <span class="keyword">False</span>, <span class="number">8</span>: <span class="keyword">True</span>, <span class="number">9</span>: <span class="keyword">False</span>, <span class="number">10</span>: <span class="keyword">True</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个例子里，我们以some_list为基础，创建了一个具有不重复元素的集合，而且集合里只包含偶数。而在字典表的例子里，我们创建了一个key是不重复的1到10之间的整数，value是布尔型，用来指示key是否是偶数。</p>
<p>这里另外一个值得注意的事情是集合的字面量表示法。我们可以简单的用这种方法创建一个集合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>my_set</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>而不需要使用内置函数set()。</p>
<h2 id="Python_u8C03_u7528_u7CFB_u7EDF_u547D_u4EE4_u6216_u8005_u811A_u672C"><a href="#Python_u8C03_u7528_u7CFB_u7EDF_u547D_u4EE4_u6216_u8005_u811A_u672C" class="headerlink" title="Python调用系统命令或者脚本"></a>Python调用系统命令或者脚本</h2><p>使用 os.system() 调用系统命令 , 程序中无法获得到输出和返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>os.system(<span class="string">'ls -l /proc/cpuinfo'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>os.system(<span class="string">"ls -l /proc/cpuinfo"</span>)</span><br><span class="line">  -r--r--r-- <span class="number">1</span> root root <span class="number">0</span>  <span class="number">3</span>月 <span class="number">29</span> <span class="number">16</span>:<span class="number">53</span> /proc/cpuinfo</span><br><span class="line">  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>使用 os.popen() 调用系统命令, 程序中可以获得命令输出，但是不能得到执行的返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>out = os.popen(<span class="string">"ls -l /proc/cpuinfo"</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> out.read()</span><br><span class="line">  -r--r--r-- <span class="number">1</span> root root <span class="number">0</span>  <span class="number">3</span>月 <span class="number">29</span> <span class="number">16</span>:<span class="number">59</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure>
<p>使用 commands.getstatusoutput() 调用系统命令, 程序中可以获得命令输出和执行的返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> commands</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>commands.getstatusoutput(<span class="string">'ls /bin/ls'</span>)</span><br><span class="line">  (<span class="number">0</span>, <span class="string">'/bin/ls'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Python__u6355_u83B7_u7528_u6237_Ctrl+C__2CCtrl+D__u4E8B_u4EF6"><a href="#Python__u6355_u83B7_u7528_u6237_Ctrl+C__2CCtrl+D__u4E8B_u4EF6" class="headerlink" title="Python 捕获用户 Ctrl+C ,Ctrl+D 事件"></a>Python 捕获用户 Ctrl+C ,Ctrl+D 事件</h2><p>有些时候，需要在程序中捕获用户键盘事件，比如ctrl+c退出，这样可以更好的安全退出程序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    do_some_func()</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"User Press Ctrl+C,Exit"</span></span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"User Press Ctrl+D,Exit"</span></span><br></pre></td></tr></table></figure>
<h2 id="Python__u8BFB_u5199_u6587_u4EF6"><a href="#Python__u8BFB_u5199_u6587_u4EF6" class="headerlink" title="Python 读写文件"></a>Python 读写文件</h2><p>一次性读入文件到列表，速度较快，适用文件比较小的情况下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">track_file = <span class="string">"track_stock.conf"</span></span><br><span class="line">fd = open(track_file)</span><br><span class="line">content_list = fd.readlines()</span><br><span class="line">fd.close()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> content_list:</span><br><span class="line">    <span class="keyword">print</span> line</span><br></pre></td></tr></table></figure>
<p>逐行读入，速度较慢,适用没有足够内存读取整个文件(文件太大)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fd = open(file_path)</span><br><span class="line">fd.seek(<span class="number">0</span>)</span><br><span class="line">title = fd.readline()</span><br><span class="line">keyword = fd.readline()</span><br><span class="line">uuid = fd.readline()</span><br><span class="line">fd.close()</span><br></pre></td></tr></table></figure>
<p>写文件 write 与 writelines 的区别   </p>
<ul>
<li>Fd.write(str) : 把str写到文件中，write()并不会在str后加上一个换行符</li>
<li>Fd.writelines(content) : 把content的内容全部写到文件中,原样写入，不会在每行后面加上任何东西</li>
</ul>
<h2 id="u88C5_u9970_u5668"><a href="#u88C5_u9970_u5668" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器使一个函数或方法包装在另一个函数里头，可以在被包装的函数添加一些额外的功能，比如日志，还可以对参数、返回结果进行修改。装饰器有点类似Java中的AOP。下面这个例子是打印被装饰的函数里面的参数的装饰器，  </p>
<pre><code>&gt;&gt;&gt; def print_args(function):
&gt;&gt;&gt;     def wrapper(*args, **kwargs):
&gt;&gt;&gt;         print &apos;Arguments:&apos;, args, kwargs
&gt;&gt;&gt;         return function(*args, **kwargs)
&gt;&gt;&gt;     return wrapper

&gt;&gt;&gt; @print_args
&gt;&gt;&gt; def write(text):
&gt;&gt;&gt;     print text

&gt;&gt;&gt; write(&apos;foo&apos;)
Arguments: (&apos;foo&apos;,) {}
foo
</code></pre><p>@是语法糖，它等价于：  </p>
<pre><code>&gt;&gt;&gt; write = print_args(write)
&gt;&gt;&gt; write(&apos;foo&apos;)
arguments: (&apos;foo&apos;,) {}
foo
</code></pre></div><div class="tags"><a href="/tags/Python/">Python</a><a href="/tags/编程/">编程</a></div><div class="post-nav"><a href="/2016/03/24/visual-code-guide/" class="pre"><i class="icon-previous">VS Code 指南</i></a><a href="/2016/03/24/self-knowledge-management/" class="next">个人知识管理指南<i class="icon-next"></i></a></div><div data-thread-key="2016/03/24/thinking-in-python/" data-title="Python 编程思想" data-url="http://wdxtub.com/2016/03/24/thinking-in-python/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/03/24/thinking-in-python/" data-title="Python 编程思想" data-url="http://wdxtub.com/2016/03/24/thinking-in-python/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="http://wdxtub.com"/></form></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Game/">Game</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Gossip/">Gossip</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Memory/">Memory</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Movie/">Movie</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Reading/">Reading</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Story/">Story</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Technique/">Technique</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Thinking/">Thinking</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Traveling/">Traveling</a></li></ul></div><div class="widget"><div class="comments-title">最近评论</div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title">友情链接</div><ul></ul><a href="http://jackqdyulei.github.io" title="Lei YU" target="_blank">Lei YU</a><ul></ul><a href="http://wdxtub.com/bookclips/" title="我的书摘" target="_blank">我的书摘</a><ul></ul><a href="http://wdxtub.com/interview/" title="刷题笔记" target="_blank">刷题笔记</a></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">小土刀.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script>
<script src="/js/jquery.fancybox.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"><script>var duoshuoQuery = {short_name:'wdxblog'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script></div></body></html>