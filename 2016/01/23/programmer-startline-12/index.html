<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一个逗比的碎碎念"><title>编程起跑线 第 12 课 其他知识 | 小土刀</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">编程起跑线 第 12 课 其他知识</h1><a id="logo" href="/.">小土刀</a><p class="description">Agony is my triumph</p></div><div id="nav-menu"><a href="/." class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/about/"><i class="icon-about"> 关于</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">编程起跑线 第 12 课 其他知识</h1><div class="post-meta">2016-01-23 | <span class="categories">分类于<a href="/categories/Technique/"> Technique</a></span></div><span data-thread-key="2016/01/23/programmer-startline-12/" class="ds-thread-count"></span><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#u7F51_u7EDC"><span class="toc-number">1.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u8DEF_u7531"><span class="toc-number">1.1.</span> <span class="toc-text">路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5E38_u7528_u7F51_u7EDC_u7EDF_u8BA1_u6307_u6807"><span class="toc-number">1.2.</span> <span class="toc-text">常用网络统计指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transmission_Control_Protocol_uFF0CTCP"><span class="toc-number">1.3.</span> <span class="toc-text">Transmission Control Protocol，TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#User_Datagram_Protocol_uFF0CUDP"><span class="toc-number">1.4.</span> <span class="toc-text">User Datagram Protocol，UDP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u6570_u636E_u5E93"><span class="toc-number">2.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u4E8B_u52A1_u7684_u7279_u6027_uFF08ACID_uFF09"><span class="toc-number">2.1.</span> <span class="toc-text">事务的特性（ACID）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u4E8B_u52A1_u7684_u9694_u79BB_u7EA7_u522B"><span class="toc-number">2.2.</span> <span class="toc-text">事务的隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u4E8B_u52A1_u9694_u79BB_u7684_u5B9E_u73B0_u2014_u2014_u9501"><span class="toc-number">2.3.</span> <span class="toc-text">事务隔离的实现——锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u7D22_u5F15"><span class="toc-number">2.4.</span> <span class="toc-text">索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u6D4B_u8BD5"><span class="toc-number">3.</span> <span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u6D4B_u8BD5_u73B0_u5B9E_u4E16_u754C_u7684_u7269_u4F53_u3001_u8F6F_u4EF6_u6216_u51FD_u6570"><span class="toc-number">3.1.</span> <span class="toc-text">测试现实世界的物体、软件或函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6545_u969C_u6392_u9664_28Troubleshooting_29"><span class="toc-number">3.2.</span> <span class="toc-text">故障排除(Troubleshooting)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6D4B_u8BD5_u7684_u65B9_u6CD5"><span class="toc-number">3.3.</span> <span class="toc-text">测试的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5DE5_u4E1A_u754C_u6D4B_u8BD5_u6D41_u7A0B"><span class="toc-number">3.4.</span> <span class="toc-text">工业界测试流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u64CD_u4F5C_u7CFB_u7EDF"><span class="toc-number">4.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u8FDB_u7A0B"><span class="toc-number">4.1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u8FDB_u7A0B_u7684_u57FA_u672C_u72B6_u6001"><span class="toc-number">4.1.1.</span> <span class="toc-text">进程的基本状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u8FDB_u7A0B_u8C03_u5EA6"><span class="toc-number">4.2.</span> <span class="toc-text">进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u8C03_u5EA6_u79CD_u7C7B"><span class="toc-number">4.2.1.</span> <span class="toc-text">调度种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u975E_u62A2_u5360_u5F0F_u8C03_u5EA6_u4E0E_u62A2_u5360_u5F0F_u8C03_u5EA6"><span class="toc-number">4.2.2.</span> <span class="toc-text">非抢占式调度与抢占式调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u8C03_u5EA6_u7B56_u7565_u7684_u8BBE_u8BA1"><span class="toc-number">4.2.3.</span> <span class="toc-text">调度策略的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u8C03_u5EA6_u7B97_u6CD5"><span class="toc-number">4.2.4.</span> <span class="toc-text">调度算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u8FDB_u7A0B_u540C_u6B65"><span class="toc-number">4.3.</span> <span class="toc-text">进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u4E34_u754C_u8D44_u6E90_u4E0E_u4E34_u754C_u533A"><span class="toc-number">4.3.1.</span> <span class="toc-text">临界资源与临界区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u7EBF_u7A0B"><span class="toc-number">4.4.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u534F_u7A0B"><span class="toc-number">4.5.</span> <span class="toc-text">协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u8FDB_u7A0B_vs-__u7EBF_u7A0B"><span class="toc-number">4.6.</span> <span class="toc-text">进程 vs. 线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u4E0A_u4E0B_u6587_u5207_u6362"><span class="toc-number">4.7.</span> <span class="toc-text">上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u7CFB_u7EDF_u8C03_u7528"><span class="toc-number">4.8.</span> <span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore/Mutex"><span class="toc-number">4.9.</span> <span class="toc-text">Semaphore/Mutex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6B7B_u9501"><span class="toc-number">4.10.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u751F_u4EA7_u8005_u6D88_u8D39_u8005"><span class="toc-number">4.11.</span> <span class="toc-text">生产者消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u8FDB_u7A0B_u95F4_u901A_u4FE1"><span class="toc-number">4.12.</span> <span class="toc-text">进程间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6587_u4EF6_u7CFB_u7EDF"><span class="toc-number">4.13.</span> <span class="toc-text">文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5B9E_u65F6_vs-_u5206_u65F6_u64CD_u4F5C_u7CFB_u7EDF"><span class="toc-number">4.14.</span> <span class="toc-text">实时 vs.分时操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u7F16_u8BD1_u5668"><span class="toc-number">4.15.</span> <span class="toc-text">编译器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u4E2D_u65AD"><span class="toc-number">4.16.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO_u591A_u8DEF_u590D_u7528"><span class="toc-number">4.17.</span> <span class="toc-text">IO多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u57FA_u672C_u6982_u5FF5"><span class="toc-number">4.17.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u5E38_u89C1_u7684IO_u590D_u7528_u5B9E_u73B0"><span class="toc-number">4.17.2.</span> <span class="toc-text">常见的IO复用实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5185_u5B58_u5206_u914D"><span class="toc-number">4.18.</span> <span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u865A_u62DF_u5185_u5B58"><span class="toc-number">4.19.</span> <span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u9875_u9762_u7F6E_u6362_u7B97_u6CD5"><span class="toc-number">4.20.</span> <span class="toc-text">页面置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u78C1_u76D8_u8C03_u5EA6"><span class="toc-number">4.21.</span> <span class="toc-text">磁盘调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u78C1_u76D8_u8C03_u5EA6_u7B97_u6CD5"><span class="toc-number">4.22.</span> <span class="toc-text">磁盘调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5206_u533A_u8868"><span class="toc-number">4.23.</span> <span class="toc-text">分区表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID__u6280_u672F"><span class="toc-number">4.24.</span> <span class="toc-text">RAID 技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u5E38_u89C1_u6587_u4EF6_u7CFB_u7EDF"><span class="toc-number">4.24.1.</span> <span class="toc-text">常见文件系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux_u6587_u4EF6_u6743_u9650"><span class="toc-number">4.25.</span> <span class="toc-text">Linux文件权限</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#chmod_u547D_u4EE4"><span class="toc-number">4.25.1.</span> <span class="toc-text">chmod命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chgrp_u547D_u4EE4"><span class="toc-number">4.25.2.</span> <span class="toc-text">chgrp命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chown_u547D_u4EE4"><span class="toc-number">4.25.3.</span> <span class="toc-text">chown命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u9644_u5F55"><span class="toc-number">5.</span> <span class="toc-text">附录</span></a></li></ol></div></div><div class="post-content"><p>这一章包括剩余一些比较基本的常识性知识，具体可能是以聊天的形式来进行交流，关键就在于理解，不要死记硬背。其实计算机学科的各种概念联系都比较紧密，梳理清晰自然就记住了。</p>
<a id="more"></a>
<hr>
<h2 id="u7F51_u7EDC"><a href="#u7F51_u7EDC" class="headerlink" title="网络"></a>网络</h2><p>计算机之间的交互模型通常是指Open Systems Interconnection model (OSI)，该模型将网络通信系统抽象成了七层</p>
<h3 id="u8DEF_u7531"><a href="#u8DEF_u7531" class="headerlink" title="路由"></a>路由</h3><p>从用户角度来看，路由(Routing)是指将数据从一个用户终端，通过网络节点(例如路由器，交换机等)，发送到另一个用户节点的过程。理论上说，对于一个拥有多个节点的拓扑网络而言，路由是指在Network Layer(OSI model的第三层)，将数据包(data packet)从一个节点以最优路径发送到目标节点的实现方法。其核心包括：如何获得邻近节点的信息，如何估计链路质量，如何寻址，如何构建网络拓扑结构“等等。 通过路由器之间的路由协议(routing protocol)，可以实现两个网络节点之间信息(包括网络域名，邻近节点，链路质量等)的交换和散布，通过不断重复该过程，每个节点都会获得足够多关于所在网络的拓扑信息。当有数据包需要传送时，路由器再通过路由算法(routing algorithm)计算传递当前数据包的最优路径，并把数据包发送给下一个邻近节点。许多路由算法基于图理论，实现了最小生成树，最短路径等等经典的拓扑算法。关于路由算法的进一步讨论，请参考“工具箱”中提到的参考教材。</p>
<p>网络中，所谓的地址是指IP地址，IPv4规定利用32bits作为IP地址。但随着网络设备的增多，IPv4已经不能满足人们的需求，故互联网逐渐向IPv6进行演进，IPv6利用128bits作为IP地址。</p>
<p>事实上，直观而言，network routing的过程就相当于传统意义上的邮包寄送，IP地址可以类比于邮政编码，路由器就相当于邮局，通过目的地邮政编码与邮局系统中的递送路径进行比较，由此确定下一步应该把当前包裹传递到哪里。</p>
<h3 id="u5E38_u7528_u7F51_u7EDC_u7EDF_u8BA1_u6307_u6807"><a href="#u5E38_u7528_u7F51_u7EDC_u7EDF_u8BA1_u6307_u6807" class="headerlink" title="常用网络统计指标"></a>常用网络统计指标</h3><p>衡量网络质量通常有下面两个指标：</p>
<p>1) 带宽/速率(Bandwidth/Rate)</p>
<p>所谓的带宽是指一个网络节点能以多快的速度将数据接收／发送出去，单位是bits per second(bps)。对于对实时性要求不高的数据，例如下载等，带宽是影响用户体验的主要因素。两个终端节点之间的带宽由路径中所有节点的最小带宽决定。同时，终端的数据发送速度不应该超过当前的上载带宽，否则会对网络造成压力导致拥堵(congestion)。</p>
<p>2) One-way Delay / Round Trip Time (RTT)</p>
<p>One-way Delay用以衡量网络的延迟。假设在时间点A从一个节点发送数据到另一个节点，目的地节点在时间点B收到数据，则两个时间点之差即为One-way Delay。类似地，RTT则是数据完成一个Round Trip回到始发节点的时间差，一般RTT可以近似估计为One-way Delay的两倍。对于网络会议，IP电话等等，延迟是影响用户体验的主要因素。延迟可能是由网络中某个节点处理数据速度慢，突然有大规模数据需要传输，或者某条链路不断重传数据造成的。延迟与带宽有一定的相关性，但没有必然联系：可以类比某个路口，假设每秒可以有一辆车通过该路口，但现在突然来了100辆车，路口的通过效率并没有变化(即带宽不变)，但每辆车通过路口的等待时间却变长了(延迟增加)。</p>
<h3 id="Transmission_Control_Protocol_uFF0CTCP"><a href="#Transmission_Control_Protocol_uFF0CTCP" class="headerlink" title="Transmission Control Protocol，TCP"></a>Transmission Control Protocol，TCP</h3><p><strong>Reliable Protocol</strong></p>
<p>TCP是一种可靠的传输协议，即在网络条件正常的情况下，TCP协议能够保证接收端收到所有数据，并且接收到的数据顺序与发送端一致。TCP通过在发送端给每个数据包分配单调递增的sequence number，以及在接受端发送ACK(acknowledgement)实现可靠传输。每个发送的数据包都包含序列号，当接收端收到数据包时，会发送ACK告诉发送端当前自己期待的下一个序列号是多少。例如，发送端分别发送了序列号为99，100，101，102的四个数据包，接收端收到数据包99后，会发送ACK100，意味着接收端期待下一个数据包编号100。如果由于某些原因，数据包100没有到达接收端，但数据包101，102到达了，那么接收端会继续发送ACK100。当发送端发现当前发送的数据包编号超过了100，但接收端仍然期望收到100，那么发送端就会重新发送数据包100。“如果接收端收到了重新发送的数据包100，那么接收端会回复ACK103，继续进行剩下的数据传输，并且把数据包99，100，101，102按顺序传递给上一层。</p>
<p><strong>Flow Control</strong></p>
<p>TCP使用了end-to-end flow control以避免发送端发送数据过快导致接收端无法处理。TCP采用了滑动窗口(sliding window)实现流量控制。接收端通过ACK告诉发送端自己还能够接收多少数据，发送端不能发送超过该值的数据量。当接收端返回的窗口大小为0时，发送端停止发送数据，直到窗口大小被更新。由于ACK是由发送端发送的数据触发，可能接收端窗口已经打开，但是由于发送端已经停止发送，故接收端没有机会通过ACK告知发送端新的窗口大小，在这种情况下会造成死锁。在实际实现中，发送端会设置一个timer，如果timer到期，发送端会尝试发送小数据包，以触发接收端的ACK。</p>
<p><strong>Congestion Control</strong></p>
<p>为了控制传输速度防止堵塞网络，并且在网络容量允许的范围内尽可能多地传输数据，TCP引入congestion control，用以判断当前的网络负荷，并且调整传输速率。TCP通常采用additive increase，multiplicative decrease的算法，即如果按时收到对应的ACK，则下一次传输速率线性增加，否则则视为发生了网络堵塞，下一次传输的比特数折半。所谓的“按时”基于RTT：发送端会估计RTT，并且期望当数据包发送以后，在RTT时间内收到对应的ACK。“现代TCP需要分别实现Slow-start，congestion avoidance，fast retransmit和fast recovery，以达到最高的效率。具体请参考“工具箱”给出的资料。</p>
<h3 id="User_Datagram_Protocol_uFF0CUDP"><a href="#User_Datagram_Protocol_uFF0CUDP" class="headerlink" title="User Datagram Protocol，UDP"></a>User Datagram Protocol，UDP</h3><p>相比于TCP，UDP简单许多：连接建立时不需要经过类似于TCP的三次握手，只需要知道接收端的IP和端口，发送端就可以直接发送数据。同时，UDP也没有ACK，flow control和congestion control，故UDP本身不能保证传输是可靠的。由于UDP本身只负责把数据传输到目的地，故可扩展性比较强。有些应用可以实现基于UDP 的特定算法，使得传输效率高于TCP。例如，当发生丢包时，TCP会重传该数据包，但该操作增加了传输延时。对于某些实时性要求较高的应用，可能继续传输新的数据更为重要，故基于UDP的传输方式可以更好地满足该要求。</p>
<p>通常而言，如果需要满足可靠性，有序接收，自适应带宽等要求，应该优先考虑TCP，因为其协议本身确保了这点。如果对实时性要求较高，或者应用需要特定的网络传输特性，则可以实现基于UDP的传输协议。往往，这样的协议需要实现congestion control，flow control，retransmission等机制，故通常情况下都可以直接采用TCP以减小开发成本。</p>
<h2 id="u6570_u636E_u5E93"><a href="#u6570_u636E_u5E93" class="headerlink" title="数据库"></a>数据库</h2><p>事务的概念来自于两个独立的需求：并发数据库访问，系统错误恢复。</p>
<p>一个事务是可以被看作一个单元的一系列SQL语句的集合。</p>
<h3 id="u4E8B_u52A1_u7684_u7279_u6027_uFF08ACID_uFF09"><a href="#u4E8B_u52A1_u7684_u7279_u6027_uFF08ACID_uFF09" class="headerlink" title="事务的特性（ACID）"></a>事务的特性（ACID）</h3><ul>
<li>A, atomacity 原子性 事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。</li>
<li>C, consistency 一致性。事务将数据库从一种一致状态转变为下一种一致状态。也就是说，事务在完成时，必须使所有的数据都保持一致状态（各种 constraint 不被破坏）。</li>
<li>I, isolation 隔离性 由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。换句话说，一个事务的影响在该事务提交前对其他事务都不可见。</li>
<li>D, durability 持久性。事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。</li>
</ul>
<h3 id="u4E8B_u52A1_u7684_u9694_u79BB_u7EA7_u522B"><a href="#u4E8B_u52A1_u7684_u9694_u79BB_u7EA7_u522B" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>如果不对数据库进行并发控制，可能会产生异常情况：</p>
<ol>
<li>脏读(Dirty Read)<ul>
<li>当一个事务读取另一个事务尚未提交的修改时，产生脏读。</li>
<li>同一事务内不是脏读。 一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险的，因为很可能所有的操作都被回滚，也就是说读取出的数据其实是错误的。</li>
</ul>
</li>
<li>非重复读(Nonrepeatable Read) 一个事务对同一行数据重复读取两次，但是却得到了不同的结果。同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生非重复读。</li>
<li>幻像读(Phantom Reads) 事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。<ul>
<li>当对某行执行插入或删除操作，而该行属于某个事务正在读取的行的范围时，会发生幻像读问题。</li>
</ul>
</li>
<li>丢失修改(Lost Update)<ul>
<li>第一类：当两个事务更新相同的数据源，如果第一个事务被提交，第二个却被撤销，那么连同第一个事务做的更新也被撤销。</li>
<li>第二类：有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。</li>
</ul>
</li>
</ol>
<p>为了兼顾并发效率和异常控制，在标准SQL规范中，定义了4个事务隔离级别，（ Oracle 和 SQL Server 对标准隔离级别有不同的实现 ）</p>
<ol>
<li>未提交读(Read Uncommitted)<ul>
<li>直译就是”读未提交”，意思就是即使一个更新语句没有提交，但是别的事务可以读到这个改变。</li>
<li>Read Uncommitted允许脏读。</li>
</ul>
</li>
<li>已提交读(Read Committed)<ul>
<li>直译就是”读提交”，意思就是语句提交以后，即执行了 Commit 以后别的事务就能读到这个改变，只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别。</li>
<li>Read Commited 不允许脏读，但会出现非重复读。</li>
</ul>
</li>
<li>可重复读(Repeatable Read)：<ul>
<li>直译就是”可以重复读”，这是说在同一个事务里面先后执行同一个查询语句的时候，得到的结果是一样的。</li>
<li>Repeatable Read 不允许脏读，不允许非重复读，但是会出现幻象读。</li>
</ul>
</li>
<li>串行读(Serializable)<ul>
<li>直译就是”序列化”，意思是说这个事务执行的时候不允许别的事务并发执行。完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。</li>
<li>Serializable 不允许不一致现象的出现。</li>
</ul>
</li>
</ol>
<h3 id="u4E8B_u52A1_u9694_u79BB_u7684_u5B9E_u73B0_u2014_u2014_u9501"><a href="#u4E8B_u52A1_u9694_u79BB_u7684_u5B9E_u73B0_u2014_u2014_u9501" class="headerlink" title="事务隔离的实现——锁"></a>事务隔离的实现——锁</h3><ol>
<li>共享锁(S锁)<ul>
<li>用于只读操作(SELECT)，锁定共享的资源。共享锁不会阻止其他用户读，但是阻止其他的用户写和修改。</li>
</ul>
</li>
<li>更新锁(U锁)<ul>
<li>用于可更新的资源中。防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。</li>
</ul>
</li>
<li>独占锁(X锁，也叫排他锁)<ul>
<li>一次只能有一个独占锁用在一个资源上，并且阻止其他所有的锁包括共享缩。写是独占锁，可以有效的防止“脏读”。</li>
</ul>
</li>
</ol>
<p>Read Uncommited 如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。</p>
<p>Read Committed 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。可以通过“瞬间共享读锁”和“排他写锁”实现。</p>
<p>Repeatable Read 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。可以通过“共享读锁”和“排他写锁”实现。</p>
<p>Serializable 读加共享锁，写加排他锁，读写互斥。</p>
<h3 id="u7D22_u5F15"><a href="#u7D22_u5F15" class="headerlink" title="索引"></a>索引</h3><p>数据库创建索引能够大大提高系统的性能。</p>
<ol>
<li>通过创建唯一性的索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度，这也使创建索引的最主要的原因。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著的减少查询中查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ol>
<p>增加索引也有许多不利的方面。</p>
<ol>
<li>创建索引和维护索引需要消耗时间，这种时间随着数量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占据数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要额空间就会更大。</li>
<li>当对表中的数据进行增加，删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ol>
<p>应该对如下的列建立索引</p>
<ol>
<li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构。</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度。</li>
<li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的。</li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li>在经常使用在where子句中的列上面创建索引，加快条件的判断速度。</li>
</ol>
<p>有些列不应该创建索引</p>
<ol>
<li>在查询中很少使用或者作为参考的列不应该创建索引。</li>
<li>对于那些只有很少数据值的列也不应该增加索引（比如性别，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度）。</li>
<li>对于那些定义为text，image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li>
<li>当修改性能远远大于检索性能时，不应该创建索引，因为修改性能和检索性能是矛盾的。</li>
</ol>
<p>创建索引的方法：直接创建和间接创建（在表中定义主键约束或者唯一性约束时，同时也创建了索引）。</p>
<p>索引的特征：</p>
<p>唯一性索引和复合索引。唯一性索引保证在索引列中的全部数据是唯一的，不会包含冗余数据。复合索引就是一个索引创建在两个列或者多个列上。可以减少一在一个表中所创建的索引数量。</p>
<h2 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h2><p>在面试软件开发的过程中，面试官可能也会询问关于软件开发流程以及测试方法相关的问题。在大多数互联网公司，许多部门不一定配有专门的QA(Quality Assurance)，在这种情况下，程序员本身需要对自己开发的模块和系统进行测试。另一方面，程序员在开发过程中测试自己的程序也是非常好的习惯，这样可以确保开发效率。基于上述原因，面试软件开发职位但遇到测试相关的问题并不少见。</p>
<h3 id="u6D4B_u8BD5_u73B0_u5B9E_u4E16_u754C_u7684_u7269_u4F53_u3001_u8F6F_u4EF6_u6216_u51FD_u6570"><a href="#u6D4B_u8BD5_u73B0_u5B9E_u4E16_u754C_u7684_u7269_u4F53_u3001_u8F6F_u4EF6_u6216_u51FD_u6570" class="headerlink" title="测试现实世界的物体、软件或函数"></a>测试现实世界的物体、软件或函数</h3><p>三者并无本质的差别，问题的核心均在于：测试对象在不同的输入下，能否实现预计的功能，提供恰当的输出。 一般情况下，总是需要考虑以下几个方面，以全面测试对象对于不同类型输入的效果：</p>
<p>(1) 常规情况(Normal cases)</p>
<p>输入不同类型的合法数据，主要用以判断对象的功能性：在给定输入的情况下能否给出期望的输出，由此判断功能的实现是否正确。比如，测试银行账户的转账功能：假设账户中有1000元，可以输入100，2000等并判断余额及转出钱数是否符合期望。</p>
<p>(2) 极端情况(Extreme cases)</p>
<p>测试一些边界条件或极端情况。所谓的极端情况包括多用户或多线程情况下频繁地访问／更新数据。比如，继续测试银行账户的转账功能：假设账户中有1000元，可以测试边界条件，取出1000元等。或者测试极端情况，假设用户开了多个页面，并在每个页面上几乎同时都尝试转出1000元，或者用户通过ATM机和手机APP同时进行转账操作等。</p>
<p>(3) 非法情况(Invalid case)</p>
<p>主要测试用户输入非法数据时系统不会崩溃，并且能够给出恰当的反馈。比如，测试银行账户的转账功能：当用户输入大于账户余额的数字时，或者当接收人账户错误时，系统能否给出错误提示等。</p>
<h3 id="u6545_u969C_u6392_u9664_28Troubleshooting_29"><a href="#u6545_u969C_u6392_u9664_28Troubleshooting_29" class="headerlink" title="故障排除(Troubleshooting)"></a>故障排除(Troubleshooting)</h3><p>另一大类的常见问题是给出一个有问题的测试现象，让面试者判断问题出现在哪里。对于这类问题，首先考虑测试对象由生成，到运行，到产生最终结果的完整流程，其次判断每一步执行了什么，需要依赖哪些参数，该步骤的异常是否会导致最终的测试现象，并且考虑如何验证自己的判断。 例如，测试用户无法访问你开发的网站。首先考虑主要流程，简述如下：用户连接到网络，发送HTTP请求到网站，网站发送数据包给用户，用户浏览器显示页面。在此例中，每一步都有可能导致无法访问网站的情况，具体描述如下：</p>
<p>(1) 用户连接到网络：这一步用户需要获得有效的IP，获取访问互联网的权限。需要依赖用户的网卡是否工作正常，是否能够被分配到有效的IP，是否能够从路由器或者服务器获得互联网访问权限等等。检验方式可以是：可以打开终端用ping命令，尝试建立与大型网站的连接。或者直接用浏览器尝试访问其他大型网站。如果不能建立与其他网站的连接，则网络接入有问题。</p>
<p>(2) 发送HTTP请求到网站：用户首先会通过DNS获取服务器地址，然后发送HTTP请求到对应的IP。需要依赖用户能否正确获取网站IP地址。检验方式可以是：在用户端利用抓包软件，例如WireShark，tcpdump等，观察是否有HTTP请求发送到网站服务器。如果没有发送HTTP请求或目的地IP有问题，则DNS可能有错。</p>
<p>(3) 网站发送数据包给用户：这一步需要网站接收到HTTP请求，并且将对应数据传回给用户。需要依赖网站能否收到HTTP请求以及对于HTTP请求的处理是否正确。检验方式可以是：在服务器端通过log判断是否有新用户接入，接入请求的处理是否正确，以及发送给用户的数据是什么。如果网站没有收到请求，则服务器端的网络可能有问题。如果服务器无法处理HTTP请求或抛出异常，则服务器的实现可能有问题。</p>
<p>(4) 用户浏览器显示页面： 这一步需要用户接收到网站发回的数据，浏览器解析数据并显示页面。需要依赖于用户能否收到数据，以及收到的数据是否能够被浏览器正确解析及显示。检验方式可以是：在用户端利用抓包软件，观察是否有来自服务器的数据。一般来说，如果用户用的是商用浏览器，即能够正确解析数据。故如果能收到服务器数据但是不能正常显示，我们可以认为服务器的数据有问题。</p>
<h3 id="u6D4B_u8BD5_u7684_u65B9_u6CD5"><a href="#u6D4B_u8BD5_u7684_u65B9_u6CD5" class="headerlink" title="测试的方法"></a>测试的方法</h3><p><strong>AB Testing</strong></p>
<p>AB测试是一种对比测试方案。测试人员对于不同用户随机生成两种方案，例如，某些用户看到的网页按钮是圆形的，其他用户看到的网页按钮是方形的。通过用户对于不同测试方案的反应，来决定最终部署哪种方案。具体请参考：<br><a href="http://en.wikipedia.org/wiki/A/B_testing" target="_blank" rel="external">http://en.wikipedia.org/wiki/A/B_testing</a></p>
<p><strong>Black Box Testing</strong></p>
<p>黑箱测试主要用于测试程序的功能，而不是内部结构或运作。测试者秩序知道输入以及对应的输出，就可以生成测试数据。黑箱测试的目的在于快速检测程序的功能性。特别地，黑箱测试还应该包括非法的输入数据，以确保程序不会崩溃。</p>
<p><strong>White Box Testing</strong></p>
<p>与黑箱测试相对，白箱测试主要用于测试程序的内部结构或运作。测试人员需要从程序设计的角度生成测试案例：输入测试数据并验证程序按照既定的流程执行。</p>
<h3 id="u5DE5_u4E1A_u754C_u6D4B_u8BD5_u6D41_u7A0B"><a href="#u5DE5_u4E1A_u754C_u6D4B_u8BD5_u6D41_u7A0B" class="headerlink" title="工业界测试流程"></a>工业界测试流程</h3><p><strong>Unit Test</strong></p>
<p>优良的软件设计强调模块化，即模块之间通过API进行交互，每个模块负责实现相对独立的功能。单元测试的目的在于对于每个模块设计相应的测试数据，用以检验模块的功能。通常，单元测试采用黑箱测试，通过运行脚本完成。测试人员将测试数据输入脚本，将输出结果与期望的输出数据进行比较。单元测试不仅仅可以用于新模块的开发，还可以用于对于已有模块的更新，维护。对于模块的每次更改都应该运行相应的单元测试以确保功能的完整性。</p>
<p><strong>Alpha Test</strong></p>
<p>Alpha测试通常是阶段性开发完成后开始进行。主要是面向内部开发人员，在模拟环境中输入模拟的数据进行测试，以验证系统符合使用者以及设计者的需求。</p>
<p><strong>Beta Test</strong></p>
<p>当Alpha阶段完成后，可以进入由公众参与的beta测试阶段。Beta测试通常使用真实的运行环境，并且使用实际数据进行测试，以确认系统效率。测试的主要目的在于进一步测试及完善功能。</p>
<h2 id="u64CD_u4F5C_u7CFB_u7EDF"><a href="#u64CD_u4F5C_u7CFB_u7EDF" class="headerlink" title="操作系统"></a>操作系统</h2><p>大部分互联网公司的软件开发职位面试可能不会直接涉及这一层面的知识，但并不意味着这部分知识不重要。对于计算机底层实现的深入理解，能帮助你了解计算机的运行原理，能够更好地设计高效的架构，并且有助于调试、判断错误。特别地，对于多线程的理解尤为重要：现今的程序架构都需要并发处理，如何协调不同线程之间的分工协作，避免死锁、同步出错等等问题，是程序员应当具备的技能。对于后端工程师而言，良好的操作系统知识基础更是深刻理解并实现复杂分布式系统的前提条件。</p>
<h3 id="u8FDB_u7A0B"><a href="#u8FDB_u7A0B" class="headerlink" title="进程"></a>进程</h3><p>进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。</p>
<p>进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。</p>
<h4 id="u8FDB_u7A0B_u7684_u57FA_u672C_u72B6_u6001"><a href="#u8FDB_u7A0B_u7684_u57FA_u672C_u72B6_u6001" class="headerlink" title="进程的基本状态"></a>进程的基本状态</h4><ol>
<li>等待态：等待某个事件的完成；</li>
<li>就绪态：等待系统分配处理器以便运行；</li>
<li>运行态：占有处理器正在运行。</li>
<li>运行态→等待态 往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。</li>
</ol>
<p>等待态→就绪态 则是等待的条件已满足，只需分配到处理器后就能运行。</p>
<p>运行态→就绪态 不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。</p>
<p>就绪态→运行态 系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态</p>
<h3 id="u8FDB_u7A0B_u8C03_u5EA6"><a href="#u8FDB_u7A0B_u8C03_u5EA6" class="headerlink" title="进程调度"></a>进程调度</h3><h4 id="u8C03_u5EA6_u79CD_u7C7B"><a href="#u8C03_u5EA6_u79CD_u7C7B" class="headerlink" title="调度种类"></a>调度种类</h4><p>高级、中级和低级调度作业从提交开始直到完成，往往要经历下述三级调度：</p>
<ul>
<li>高级调度：(High-Level Scheduling)又称为作业调度，它决定把后备作业调入内存运行；</li>
<li>低级调度：(Low-Level Scheduling)又称为进程调度，它决定把就绪队列的某进程获得CPU；</li>
<li>中级调度：(Intermediate-Level Scheduling)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。</li>
</ul>
<h4 id="u975E_u62A2_u5360_u5F0F_u8C03_u5EA6_u4E0E_u62A2_u5360_u5F0F_u8C03_u5EA6"><a href="#u975E_u62A2_u5360_u5F0F_u8C03_u5EA6_u4E0E_u62A2_u5360_u5F0F_u8C03_u5EA6" class="headerlink" title="非抢占式调度与抢占式调度"></a>非抢占式调度与抢占式调度</h4><ul>
<li>非抢占式<ul>
<li>分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度进程调度某事件而阻塞时，才把处理机分配给另一个进程。</li>
</ul>
</li>
<li>抢占式<ul>
<li>操作系统将正在运行的进程强行暂停，由调度程序将CPU分配给其他就绪进程的调度方式。</li>
</ul>
</li>
</ul>
<h4 id="u8C03_u5EA6_u7B56_u7565_u7684_u8BBE_u8BA1"><a href="#u8C03_u5EA6_u7B56_u7565_u7684_u8BBE_u8BA1" class="headerlink" title="调度策略的设计"></a>调度策略的设计</h4><p>响应时间: 从用户输入到产生反应的时间</p>
<p>周转时间: 从任务开始到任务结束的时间</p>
<p>CPU任务可以分为交互式任务和批处理任务，调度最终的目标是合理的使用CPU，使得交互式任务的响应时间尽可能短，用户不至于感到延迟，同时使得批处理任务的周转时间尽可能短，减少用户等待的时间。</p>
<h4 id="u8C03_u5EA6_u7B97_u6CD5"><a href="#u8C03_u5EA6_u7B97_u6CD5" class="headerlink" title="调度算法"></a>调度算法</h4><ol>
<li>FIFO或First Come, First Served (FCFS)<ul>
<li>调度的顺序就是任务到达就绪队列的顺序。</li>
<li>公平、简单(FIFO队列)、非抢占、不适合交互式。未考虑任务特性，平均等待时间可以缩短</li>
</ul>
</li>
<li>Shortest Job First (SJF)<ul>
<li>最短的作业(CPU区间长度最小)最先调度。</li>
<li>可以证明，SJF可以保证最小的平均等待时间。</li>
<li>Shortest Remaining Job First (SRJF)</li>
<li>SJF的可抢占版本，比SJF更有优势。</li>
<li>SJF(SRJF): 如何知道下一CPU区间大小？根据历史进行预测: 指数平均法。</li>
</ul>
</li>
<li>优先权调度<ul>
<li>每个任务关联一个优先权，调度优先权最高的任务。</li>
<li>注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象。</li>
<li>FCFS是RR的特例，SJF是优先权调度的特例。这些调度算法都不适合于交互式系统。</li>
</ul>
</li>
<li>Round-Robin(RR)<ul>
<li>设置一个时间片，按时间片来轮转调度（“轮叫”算法）</li>
<li>优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多；</li>
<li>如何确定时间片？</li>
<li>时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为FCFS。</li>
</ul>
</li>
<li>多级队列调度<ul>
<li>按照一定的规则建立多个进程队列</li>
<li>不同的队列有固定的优先级（高优先级有抢占权）</li>
<li>不同的队列可以给不同的时间片和采用不同的调度方法</li>
<li>存在问题1：没法区分I/O bound和CPU bound；</li>
<li>存在问题2：也存在一定程度的“饥饿”现象；</li>
</ul>
</li>
<li>多级反馈队列<ul>
<li>在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务。</li>
<li>可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”。</li>
<li>最通用的调度算法，多数OS都使用该方法或其变形，如UNIX、Windows等。</li>
</ul>
</li>
</ol>
<h3 id="u8FDB_u7A0B_u540C_u6B65"><a href="#u8FDB_u7A0B_u540C_u6B65" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="u4E34_u754C_u8D44_u6E90_u4E0E_u4E34_u754C_u533A"><a href="#u4E34_u754C_u8D44_u6E90_u4E0E_u4E34_u754C_u533A" class="headerlink" title="临界资源与临界区"></a>临界资源与临界区</h4><p>在操作系统中，进程是占有资源的最小单位（线程可以访问其所在进程内的所有资源，但线程本身并不占有资源或仅仅占有一点必须资源）。但对于某些资源来说，其在同一时间只能被一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源。典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等(如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题)。</p>
<p>对于临界资源的访问，必须是互斥进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。而进程内访问临界资源的代码被成为临界区。</p>
<p>对于临界区的访问过程分为四个部分：</p>
<ol>
<li>进入区:查看临界区是否可访问，如果可以访问，则转到步骤二，否则进程会被阻塞</li>
<li>临界区:在临界区做操作</li>
<li>退出区:清除临界区被占用的标志</li>
<li>剩余区：进程与临界区不相关部分的代码</li>
</ol>
<p>解决临界区问题可能的方法：</p>
<ol>
<li>一般软件方法</li>
<li>关中断方法</li>
<li>硬件原子指令方法</li>
<li>信号量方法</li>
</ol>
<h3 id="u7EBF_u7A0B"><a href="#u7EBF_u7A0B" class="headerlink" title="线程"></a>线程</h3><p>线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。</p>
<p>线程具有以下属性：</p>
<ol>
<li>轻型实体 线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。TCB包括以下信息：<ul>
<li>线程状态。</li>
<li>当线程不运行时，被保存的现场资源。</li>
<li>一组执行堆栈。</li>
<li>存放每个线程的局部变量主存区。</li>
<li>访问同一个进程中的主存和其它资源。</li>
<li>用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。</li>
</ul>
</li>
<li>独立调度和分派的基本单位。<ul>
<li>在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。</li>
</ul>
</li>
<li>可并发执行。 在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。</li>
<li>共享进程资源。 在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。 线程共享的环境包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</li>
</ol>
<h3 id="u534F_u7A0B"><a href="#u534F_u7A0B" class="headerlink" title="协程"></a>协程</h3><p>协程，又称微线程，纤程。英文名Coroutine。</p>
<p>协程可以理解为用户级线程，协程和线程的区别是：线程是抢占式的调度，而协程是协同式的调度，协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。</p>
<p>使用协程改写生产者-消费者问题：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import <span class="tag">time</span></span><br><span class="line"></span><br><span class="line">def <span class="function"><span class="title">consumer</span><span class="params">()</span></span>:</span><br><span class="line">    r = <span class="string">''</span></span><br><span class="line">    while True:</span><br><span class="line">        n = yield r</span><br><span class="line">        <span class="keyword">if</span> not n:</span><br><span class="line">            return</span><br><span class="line">        <span class="function"><span class="title">print</span><span class="params">(<span class="string">'[CONSUMER] Consuming %s...'</span> % n)</span></span></span><br><span class="line">        <span class="tag">time</span>.<span class="function"><span class="title">sleep</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line">        r = <span class="string">'200 OK'</span></span><br><span class="line"></span><br><span class="line">def <span class="function"><span class="title">produce</span><span class="params">(c)</span></span>:</span><br><span class="line">    c.<span class="function"><span class="title">next</span><span class="params">()</span></span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    while n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="title">print</span><span class="params">(<span class="string">'[PRODUCER] Producing %s...'</span> % n)</span></span></span><br><span class="line">        r = c.<span class="function"><span class="title">send</span><span class="params">(n)</span></span></span><br><span class="line">        <span class="function"><span class="title">print</span><span class="params">(<span class="string">'[PRODUCER] Consumer return: %s'</span> % r)</span></span></span><br><span class="line">    c.<span class="function"><span class="title">close</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    c = <span class="function"><span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="title">produce</span><span class="params">(c)</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到，使用协程不再需要显式地对锁进行操作</p>
<h3 id="u8FDB_u7A0B_vs-__u7EBF_u7A0B"><a href="#u8FDB_u7A0B_vs-__u7EBF_u7A0B" class="headerlink" title="进程 vs. 线程"></a>进程 vs. 线程</h3><p>进程(process)与线程(thread)最大的区别是进程拥有自己的地址空间，某进程内的线程对于其他进程不可见，即进程A不能通过传地址的方式直接读写进程B的存储区域。进程之间的通信需要通过进程间通信(Inter-process communication，IPC)。与之相对的，同一进程的各线程间之间可以直接通过传递地址或全局变量的方式传递信息。</p>
<p>此外，进程作为操作系统中拥有资源和独立调度的基本单位，可以拥有多个线程。通常操作系统中运行的一个程序就对应一个进程。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。相比进程切换，线程切换的开销要小很多。线程于进程相互结合能够提高系统的运行效率。</p>
<p>线程可以分为两类：</p>
<p>一类是用户级线程(user level thread)。对于这类线程，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。在应用程序启动后，操作系统分配给该程序一个进程号，以及其对应的内存空间等资源。应用程序通常先在一个线程中运行，该线程被成为主线“程。在其运行的某个时刻，可以通过调用线程库中的函数创建一个在相同进程中运行的新线程。 用户级线程的好处是非常高效，不需要进入内核空间，但并发效率不高。</p>
<p>另一类是内核级线程(kernel level thread)。对于这类线程，有关线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只能调用内核线程的接口。内核维护进程及其内部的每个线程，调度也由内核基于线程架构完成。内核级线程的好处是，内核可以将不同线程更好地分配到不同的CPU，以实现真正的并行计算。</p>
<p>事实上，在现代操作系统中，往往使用组合方式实现多线程，即线程创建完全在用户空间中完成，并且一个应用程序中的多个用户级线程被映射到一些内核级线程上，相当于是一种折中方案。</p>
<h3 id="u4E0A_u4E0B_u6587_u5207_u6362"><a href="#u4E0A_u4E0B_u6587_u5207_u6362" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>对于单核单线程CPU而言，在某一时刻只能执行一条CPU指令。上下文切换(Context Switch)是一种将CPU资源从一个进程分配给另一个进程的机制。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。</p>
<h3 id="u7CFB_u7EDF_u8C03_u7528"><a href="#u7CFB_u7EDF_u8C03_u7528" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用(System call)是程序向系统内核请求服务的方式。可以包括硬件相关的服务(例如，访问硬盘等)，或者创建新进程，调度其他进程等。系统调用是程序和操作系统之间的重要接口。</p>
<p>在讲系统调用之前，先说下进程的执行在系统上的两个级别：用户级和核心级，也称为用户态和系统态(user mode and kernel mode)。</p>
<p>程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件等，就需要向操作系统发出调用服务的请求，这就是系统调用。</p>
<p>Linux系统有专门的函数库来提供这些请求操作系统服务的入口，这个函数库中包含了操作系统所提供的对外服务的接口。当进程发出系统调用之后，它所处的运行状态就会由用户态变成核心态。但这个时候，进程本身其实并没有做什么事情，这个时候是由内核在做相应的操作，去完成进程所提出的这些请求。</p>
<p>系统调用和中断的关系就在于，当进程发出系统调用申请的时候，会产生一个软件中断。产生这个软件中断以后，系统会去对这个软中断进行处理，这个时候进程就处于核心态了。</p>
<p>那么用户态和核心态之间的区别是什么呢？（以下区别摘至《UNIX操作系统设计》）</p>
<ol>
<li>用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据）。然而，核心态下的进程能够存取内核和用户地址</li>
<li>某些机器指令是特权指令，在用户态下执行特权指令会引起错误</li>
</ol>
<p>对此要理解的一个是，在系统中内核并不是作为一个与用户进程平行的估计的进程的集合，内核是为用户进程运行的。</p>
<h3 id="Semaphore/Mutex"><a href="#Semaphore/Mutex" class="headerlink" title="Semaphore/Mutex"></a>Semaphore/Mutex</h3><p>当用户创立多个线程／进程时，如果不同线程／进程同时读写相同的内容，则可能造成读写错误，或者数据不一致。此时，需要通过加锁的方式，控制核心区域(critical section)的访问权限。对于semaphore而言，在初始化变量的时候可以控制允许多少个线程／进程同时访问一个critical section，其他的线程／进程会被堵塞，直到有人解锁。</p>
<p>Mutex相当于只允许一个线程／进程访问的semaphore。此外，根据实际需要，人们还实现了一种读写锁(read-write lock)，它允许同时存在多个阅读者(reader)，但任何时候至多只有一个写者(writer)，且不能于读者共存。</p>
<p>信号量是一个确定的二元组（s，q），其中s是一个具有非负初值的整形变量，q是一个初始状态为空的队列，整形变量s表示系统中某类资源的数目：</p>
<ul>
<li>当其值 ≥ 0 时，表示系统中当前可用资源的数目</li>
<li>当其值 ＜ 0 时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目</li>
</ul>
<p>除信号量的初值外，信号量的值仅能由P操作和V操作更改，操作系统利用它的状态对进程和资源进行管理</p>
<p><strong>P操作</strong></p>
<p>P 操作记为P(s)，其中s为一信号量，它执行时主要完成以下动作：</p>
<pre><code>s.value = s.value - 1；  /*可理解为占用1个资源，若原来就没有则记帐“欠”1个*/
</code></pre><p>若s.value ≥ 0，则进程继续执行，否则（即s.value &lt; 0），则进程被阻塞，并将该进程插入到信号量s的等待队列s.queue中</p>
<p>说明：实际上，P操作可以理解为分配资源的计数器，或是使进程处于等待状态的控制指令</p>
<p><strong>V操作</strong></p>
<p>V 操作记为V(s)，其中s为一信号量，它执行时，主要完成以下动作：</p>
<pre><code>s.value = s.value + 1；/*可理解为归还1个资源，若原来就没有则意义是用此资源还1个欠帐*/
</code></pre><p>若s.value &gt; 0，则进程继续执行，否则（即s.value ≤ 0）,则从信号量s的等待队s.queue中移出第一个进程，使其变为就绪状态，然后返回原进程继续执行</p>
<p>说明：实际上，V操作可以理解为归还资源的计数器，或是唤醒进程使其处于就绪状态的控制指令</p>
<p>信号量方法实现：生产者 − 消费者互斥与同步控制</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore fullBuffers = 0; /<span class="keyword">*</span>仓库中已填满的货架个数<span class="keyword">*</span>/</span><br><span class="line">semaphore emptyBuffers = BUFFER_SIZE;/<span class="keyword">*</span>仓库货架空闲个数<span class="keyword">*</span>/</span><br><span class="line">semaphore mutex = 1; /<span class="keyword">*</span>生产-消费互斥信号<span class="keyword">*</span>/</span><br><span class="line"></span><br><span class="line">Producer()</span><br><span class="line">&#123;</span><br><span class="line">    while(True)</span><br><span class="line">    &#123;</span><br><span class="line">       /<span class="keyword">*</span>生产产品item<span class="keyword">*</span>/</span><br><span class="line">       emptyBuffers.P();</span><br><span class="line">       mutex.P();</span><br><span class="line">       /<span class="keyword">*</span>item存入仓库buffer<span class="keyword">*</span>/</span><br><span class="line">       mutex.V();</span><br><span class="line">       fullBuffers.V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer()</span><br><span class="line">&#123;</span><br><span class="line">    while(True)</span><br><span class="line">    &#123;</span><br><span class="line">        fullBuffers.P();</span><br><span class="line">        mutex.P();</span><br><span class="line">        /<span class="keyword">*</span>从仓库buffer中取产品item<span class="keyword">*</span>/</span><br><span class="line">        mutex.V();</span><br><span class="line">        emptyBuffers.V();</span><br><span class="line">        /<span class="keyword">*</span>消费产品item<span class="keyword">*</span>/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用pthread实现的生产者－消费者模型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BUFFER_SIZE <span class="number">10</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> buffer[BUFFER_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> consumer, producer;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond_producer, cond_consumer;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consume</span><span class="params">(<span class="keyword">void</span>* _)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"empty buffer, wait producer\n"</span>);</span><br><span class="line">      pthread_cond_wait(&amp;cond_consumer, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"consume a item\n"</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_cond_signal(&amp;cond_producer);</span><br><span class="line">    <span class="comment">//pthread_mutex_unlock(&amp;mutex);</span></span><br><span class="line">  &#125;</span><br><span class="line">  pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">produce</span><span class="params">(<span class="keyword">void</span>* _)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span>(count == BUFFER_SIZE)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"full buffer, wait consumer\n"</span>);</span><br><span class="line">      pthread_cond_wait(&amp;cond_producer, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"produce a item.\n"</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_cond_signal(&amp;cond_consumer);</span><br><span class="line">    <span class="comment">//pthread_mutex_unlock(&amp;mutex);</span></span><br><span class="line">  &#125;</span><br><span class="line">  pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">  pthread_cond_init(&amp;cond_consumer, <span class="literal">NULL</span>);</span><br><span class="line">  pthread_cond_init(&amp;cond_producer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> err = pthread_create(&amp;consumer, <span class="literal">NULL</span>, consume, (<span class="keyword">void</span>*)<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"consumer thread created failed\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err = pthread_create(&amp;producer, <span class="literal">NULL</span>, produce, (<span class="keyword">void</span>*)<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"producer thread created failed\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pthread_join(producer, <span class="literal">NULL</span>);</span><br><span class="line">  pthread_join(consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//sleep(1000);</span></span><br><span class="line"></span><br><span class="line">  pthread_cond_destroy(&amp;cond_consumer);</span><br><span class="line">  pthread_cond_destroy(&amp;cond_producer);</span><br><span class="line">  pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u6B7B_u9501"><a href="#u6B7B_u9501" class="headerlink" title="死锁"></a>死锁</h3><p>在引入锁的同时，我们遇到了一个新的问题：死锁(Deadlock)。死锁是指两个或多个线程／进程之间相互阻塞，以至于任何一个都不能继续运行，因此也不能解锁其他线程／进程。例如，线程A占有lock A，并且尝试获取lock B；而线程2占有lock B，尝试获取lock A。此时，两者相互阻塞，都无法继续运行。</p>
<p>总结产生死锁的四个条件(只有当四个条件同时满足时才会产生死锁)：</p>
<ol>
<li>Mutual Exclusion – Only one process may use a resource at a time</li>
<li>Hold-and-Wait – Process holds resource while waiting for another</li>
<li>No Preemption – Can’t take a resource away from a process</li>
<li>Circular Wait – The waiting processes form a cycle</li>
</ol>
<h3 id="u751F_u4EA7_u8005_u6D88_u8D39_u8005"><a href="#u751F_u4EA7_u8005_u6D88_u8D39_u8005" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><p>生产者消费者模型是一种常见的通信模型：生产者和消费者共享一个数据管道，生产者将数据写入buffer，消费者从另一头读取数据。对于数据管道，需要考虑为空和溢出的情况。同时，通常还需要将这部分共享内存用mutex加锁。在只有一个生产者一个消费者的情况下，可以设计无锁队列(lockless queue)，线程安全地直接读写数据。</p>
<h3 id="u8FDB_u7A0B_u95F4_u901A_u4FE1"><a href="#u8FDB_u7A0B_u95F4_u901A_u4FE1" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>本地进程间通信的方式有很多，可以总结为下面四类：</p>
<ul>
<li>消息传递（管道、FIFO、消息队列）</li>
<li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li>
<li>共享内存（匿名的和具名的）</li>
<li>远程过程调用（Solaris门和Sun RPC）</li>
</ul>
<p>在介绍进程的时候，我们提起过一个进程不能直接读写另一个进程的数据，两者之间的通信需要通过进程间通信(inter-process communication, IPC)进行。进程通信的方式通常遵从生产者消费者模型，需要实现数据交换和同步两大功能。</p>
<p>1) Shared-memory + semaphore</p>
<p>不同进程通过读写操作系统中特殊的共享内存进行数据交换，进程之间用semaphore实现同步。</p>
<p>2) Message passing</p>
<p>进程在操作系统内部注册一个port，并且监测有没有数据，其他进程直接写数据到该port。该通信方式更加接近于网络通信方式。事实上，网络通信也是一种IPC，只是进程分布在不同机器上而已。</p>
<p>逻辑地址/物理地址/虚拟内存</p>
<p>所谓的逻辑地址，是指计算机用户(例如程序开发者)，看到的地址。例如，当创建一个长度为100的整型数组时，操作系统返回一个逻辑上的连续空间：指针指向数组第一个元素的内存地址。由于整型元素的大小为4个字节，故第二个元素的地址时起始地址加4，以此类推。事实上，逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址(在内存条中所处的位置)，并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维。</p>
<p>另一个重要概念是虚拟内存。操作系统读写内存的速度可以比读写磁盘的速度快几个量级。但是，内存价格也相对较高，不能大规模扩展。于是，操作系统可以通过将部分不太常用的数据移出内存，“存放到价格相对较低的磁盘缓存，以实现内存扩展。操作系统还可以通过算法预测哪部分存储到磁盘缓存的数据需要进行读写，提前把这部分数据读回内存。虚拟内存空间相对磁盘而言要小很多，因此，即使搜索虚拟内存空间也比直接搜索磁盘要快。唯一慢于磁盘的可能是，内存、虚拟内存中都没有所需要的数据，最终还需要从硬盘中直接读取。这就是为什么内存和虚拟内存中需要存储会被重复读写的数据，否则就失去了缓存的意义。</p>
<p>现代计算机中有一个专门的转译缓冲区(Translation Lookaside Buffer，TLB)，用来实现虚拟地址到物理地址的快速转换。</p>
<p>与内存／虚拟内存相关的还有如下两个概念：</p>
<p>1) Resident Set</p>
<p>当一个进程在运行的时候，操作系统不会一次性加载进程的所有数据到内存，只会加载一部分正在用，以及预期要用的数据。其他数据可能存储在虚拟内存，交换区和硬盘文件系统上。被加载到内存的部分就是resident set。</p>
<p>2) Thrashing</p>
<p>由于resident set包含预期要用的数据，理想情况下，进程运行过程中用到的数据都会逐步加载进resident set。但事实往往并非如此：每当需要的内存页面(page)不在resident set中时，操作系统必须从虚拟内存或硬盘中读数据，这个过程被称为内存页面错误(page faults)。当操作系统需要花费大量时间去处理页面错误的情况就是thrashing。</p>
<h3 id="u6587_u4EF6_u7CFB_u7EDF"><a href="#u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="文件系统"></a>文件系统</h3><p>Unix风格的文件系统利用树形结构管理文件。每个节点有多个指针，指向下一层节点或者文件的磁盘存储位置。文件节点还附有文件的操作信息(metadata)，包括修改时间，访问权限等等。</p>
<p>用户的访问权限通过访问控制表(Access Control List)和能力表(Capability List)实现。前者从文件角度出发，标注了每个用户可以对该文件进行何种操作。后者从用户角度出发，标注了某用户可以以什么权限操作哪些文件。</p>
<p>Unix的文件权限分为读、写和执行，用户组分为文件拥有者，组和所有用户。可以通过命令对三组用户分别设置权限。</p>
<h3 id="u5B9E_u65F6_vs-_u5206_u65F6_u64CD_u4F5C_u7CFB_u7EDF"><a href="#u5B9E_u65F6_vs-_u5206_u65F6_u64CD_u4F5C_u7CFB_u7EDF" class="headerlink" title="实时 vs.分时操作系统"></a>实时 vs.分时操作系统</h3><p>操作系统可以分为实时操作系统(Real-time system)，和分时操作系统(Sharing time system)。通常计算机采用的是sharing time，即多个进程／用户之间共享CPU，从形势上实现多任务。各个用户／进程之间的调度并非精准度特别高，如果一个进程被锁住，可以给它分配更多的时间。而实时操作系统则不同，软件和硬件必须遵从严格的deadline，超过时限的进程可能直接被终止。在这样的操作系统中，每次加锁都需要仔细考虑。</p>
<h3 id="u7F16_u8BD1_u5668"><a href="#u7F16_u8BD1_u5668" class="headerlink" title="编译器"></a>编译器</h3><p>对于高级语言来说，代码需要通过编译才能够运行。编译通过编译器(compiler)实现，是一个将程序源代码转换成二进制机器码的过程。计算机可以直接执行二进制代码。在编译的过程中，编译器需要进行词法分析(lexical analysis)，解析(parsing)和过渡代码生成(intermediate code generation)。编译器的好坏可以直接影响最终代码的执行效率。</p>
<h3 id="u4E2D_u65AD"><a href="#u4E2D_u65AD" class="headerlink" title="中断"></a>中断</h3><p>所谓的中断就是在计算机执行程序的过程中，由于出现了某些特殊事情，使得CPU暂停对程序的执行，转而去执行处理这一事件的程序。等这些特殊事情处理完之后再回去执行之前的程序。中断一般分为三类：</p>
<ol>
<li>由计算机硬件异常或故障引起的中断，称为内部异常中断；</li>
<li>由程序中执行了引起中断的指令而造成的中断，称为软中断（这也是和我们将要说明的系统调用相关的中断）；</li>
<li>由外部设备请求引起的中断，称为外部中断。简单来说，对中断的理解就是对一些特殊事情的处理。</li>
</ol>
<p>与中断紧密相连的一个概念就是中断处理程序了。当中断发生的时候，系统需要去对中断进行处理，对这些中断的处理是由操作系统内核中的特定函数进行的，这些处理中断的特定的函数就是我们所说的中断处理程序了。</p>
<p>另一个与中断紧密相连的概念就是中断的优先级。中断的优先级说明的是当一个中断正在被处理的时候，处理器能接受的中断的级别。中断的优先级也表明了中断需要被处理的紧急程度。每个中断都有一个对应的优先级，当处理器在处理某一中断的时候，只有比这个中断优先级高的中断可以被处理器接受并且被处理。优先级比这个当前正在被处理的中断优先级要低的中断将会被忽略。</p>
<p>典型的中断优先级如下所示：</p>
<p>机器错误 &gt; 时钟 &gt; 磁盘 &gt; 网络设备 &gt;  终端 &gt; 软件中断</p>
<p>当发生软件中断时，其他所有的中断都可能发生并被处理；但当发生磁盘中断时，就只有时钟中断和机器错误中断能被处理了。</p>
<p>系统调用</p>
<p>在讲系统调用之前，先说下进程的执行在系统上的两个级别：用户级和核心级，也称为用户态和系统态(user mode and kernel mode)。</p>
<p>程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件等，就需要向操作系统发出调用服务的请求，这就是系统调用。</p>
<p>Linux系统有专门的函数库来提供这些请求操作系统服务的入口，这个函数库中包含了操作系统所提供的对外服务的接口。当进程发出系统调用之后，它所处的运行状态就会由用户态变成核心态。但这个时候，进程本身其实并没有做什么事情，这个时候是由内核在做相应的操作，去完成进程所提出的这些请求。</p>
<p>系统调用和中断的关系就在于，当进程发出系统调用申请的时候，会产生一个软件中断。产生这个软件中断以后，系统会去对这个软中断进行处理，这个时候进程就处于核心态了。</p>
<p>那么用户态和核心态之间的区别是什么呢？（以下区别摘至《UNIX操作系统设计》）</p>
<ol>
<li>用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据）。然而，核心态下的进程能够存取内核和用户地址</li>
<li>某些机器指令是特权指令，在用户态下执行特权指令会引起错误</li>
</ol>
<p>对此要理解的一个是，在系统中内核并不是作为一个与用户进程平行的估计的进程的集合，内核是为用户进程运行的。</p>
<h3 id="IO_u591A_u8DEF_u590D_u7528"><a href="#IO_u591A_u8DEF_u590D_u7528" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><h4 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h4><p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：</p>
<ol>
<li>当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。</li>
<li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li>
<li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</li>
<li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</li>
<li>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</li>
</ol>
<p>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</p>
<h4 id="u5E38_u89C1_u7684IO_u590D_u7528_u5B9E_u73B0"><a href="#u5E38_u89C1_u7684IO_u590D_u7528_u5B9E_u73B0" class="headerlink" title="常见的IO复用实现"></a>常见的IO复用实现</h4><p>select(Linux/Windows/BSD Unix), epoll(Linux)，kqueue(BSD/Mac OS X)</p>
<h3 id="u5185_u5B58_u5206_u914D"><a href="#u5185_u5B58_u5206_u914D" class="headerlink" title="内存分配"></a>内存分配</h3><ul>
<li>虚拟地址：用户编程时将代码（或数据）分成若干个段，每条代码或每个数据的地址由段名称 + 段内相对地址构成，这样的程序地址称为虚拟地址</li>
<li>逻辑地址：虚拟地址中，段内相对地址部分称为逻辑地址</li>
<li>物理地址：实际物理内存中所看到的存储地址称为物理地址</li>
<li>逻辑地址空间：在实际应用中，将虚拟地址和逻辑地址经常不加区分，通称为逻辑地址。逻辑地址的集合称为逻辑地址空间</li>
<li>线性地址空间：CPU地址总线可以访问的所有地址集合称为线性地址空间</li>
<li>物理地址空间：实际存在的可访问的物理内存地址集合称为物理地址空间</li>
<li>MMU(Memery Management Unit内存管理单元)：实现将用户程序的虚拟地址（逻辑地址） → 物理地址映射的CPU中的硬件电路</li>
<li>基地址：在进行地址映射时，经常以段或页为单位并以其最小地址（即起始地址）为基值来进行计算</li>
<li>偏移量：在以段或页为单位进行地址映射时，相对于基地址的地址值</li>
</ul>
<p>虚拟地址先经过分段机制映射到线性地址，然后线性地址通过分页机制映射到物理地址。</p>
<h3 id="u865A_u62DF_u5185_u5B58"><a href="#u865A_u62DF_u5185_u5B58" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>请求调页，也称按需调页，即对不在内存中的“页”，当进程执行时要用时才调入，否则有可能到程序结束时也不会调入</p>
<h3 id="u9875_u9762_u7F6E_u6362_u7B97_u6CD5"><a href="#u9875_u9762_u7F6E_u6362_u7B97_u6CD5" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ul>
<li>FIFO算法<ul>
<li>先入先出，即淘汰最早调入的页面。</li>
</ul>
</li>
<li>OPT(MIN)算法<ul>
<li>选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。</li>
<li>可惜，MIN需要知道将来发生的事，只能在理论中存在，实际不可应用。</li>
</ul>
</li>
<li>LRU(Least-Recently-Used)算法<ul>
<li>用过去的历史预测将来，选最近最长时间没有使用的页淘汰(也称最近最少使用)。</li>
<li>LRU准确实现：计数器法，页码栈法。</li>
<li>由于代价较高，通常不使用准确实现，而是采用近似实现，例如Clock算法。</li>
</ul>
</li>
</ul>
<p><strong>内存抖动现象</strong>：页面的频繁更换，导致整个系统效率急剧下降，这个现象称为内存抖动（或颠簸）。抖动一般是内存分配算法不好，内存太小引或者程序的算法不佳引起的。</p>
<p><strong>Belady现象</strong>：对有的页面置换算法，页错误率可能会随着分配帧数增加而增加。</p>
<p>FIFO会产生Belady异常。</p>
<p>栈式算法无Belady异常，LRU，LFU（最不经常使用），OPT都属于栈式算法。</p>
<h3 id="u78C1_u76D8_u8C03_u5EA6"><a href="#u78C1_u76D8_u8C03_u5EA6" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><p>磁盘访问延迟 = 队列时间 + 控制器时间 + 寻道时间 + 旋转时间 + 传输时间</p>
<p>磁盘调度的目的是减小延迟，其中前两项可以忽略，寻道时间是主要矛盾。</p>
<h3 id="u78C1_u76D8_u8C03_u5EA6_u7B97_u6CD5"><a href="#u78C1_u76D8_u8C03_u5EA6_u7B97_u6CD5" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><ul>
<li>FCFS<ul>
<li>先进先出的调度策略，这个策略具有公平的优点，因为每个请求都会得到处理，并且是按照接收到的顺序进行处理。</li>
</ul>
</li>
<li>SSTF(Shortest-seek-time First 最短寻道时间优先)<ul>
<li>选择使磁头从当前位置开始移动最少的磁盘I/O请求，所以 SSTF 总是选择导致最小寻道时间的请求。</li>
<li>总是选择最小寻找时间并不能保证平均寻找时间最小，但是能提供比 FCFS 算法更好的性能，会存在饥饿现象。</li>
</ul>
</li>
<li>SCAN<ul>
<li>SSTF+中途不回折，每个请求都有处理机会。</li>
<li>SCAN 要求磁头仅仅沿一个方向移动，并在途中满足所有未完成的请求，直到它到达这个方向上的最后一个磁道，或者在这个方向上没有其他请求为止。</li>
<li>由于磁头移动规律与电梯运行相似，SCAN 也被称为电梯算法。</li>
<li>SCAN 算法对最近扫描过的区域不公平，因此，它在访问局部性方面不如 FCFS 算法和 SSTF 算法好。</li>
</ul>
</li>
<li>C-SCAN<ul>
<li>SCAN+直接移到另一端，两端请求都能很快处理。</li>
<li>把扫描限定在一个方向，当访问到某个方向的最后一个磁道时，磁道返回磁盘相反方向磁道的末端，并再次开始扫描。</li>
<li>其中“C”是Circular（环）的意思。</li>
</ul>
</li>
<li>LOOK 和 C-LOOK<ul>
<li>釆用SCAN算法和C-SCAN算法时磁头总是严格地遵循从盘面的一端到另一端，显然，在实际使用时还可以改进，即磁头移动只需要到达最远端的一个请求即可返回，不需要到达磁盘端点。这种形式的SCAN算法和C-SCAN算法称为LOOK和C-LOOK调度。这是因为它们在朝一个给定方向移动前会查看是否有请求。</li>
</ul>
</li>
</ul>
<h3 id="u5206_u533A_u8868"><a href="#u5206_u533A_u8868" class="headerlink" title="分区表"></a>分区表</h3><ul>
<li>MBR：支持最大卷为2 TB（Terabytes）并且每个磁盘最多有4个主分区（或3个主分区，1个扩展分区和无限制的逻辑驱动器）</li>
<li>GPT：支持最大卷为18EB（Exabytes）并且每磁盘的分区数没有上限，只受到操作系统限制（由于分区表本身需要占用一定空间，最初规划硬盘分区时，留给分区表的空间决定了最多可以有多少个分区，IA-64版Windows限制最多有128个分区，这也是EFI标准规定的分区表的最小尺寸。另外，GPT分区磁盘有备份分区表来提高分区数据结构的完整性。</li>
</ul>
<h3 id="RAID__u6280_u672F"><a href="#RAID__u6280_u672F" class="headerlink" title="RAID 技术"></a>RAID 技术</h3><p>磁盘阵列（Redundant Arrays of Independent Disks，RAID），独立冗余磁盘阵列之。原理是利用数组方式来作磁盘组，配合数据分散排列的设计，提升数据的安全性。</p>
<ul>
<li>RAID 0<ul>
<li>RAID 0是最早出现的RAID模式，需要2块以上的硬盘，可以提高整个磁盘的性能和吞吐量。</li>
<li>RAID 0没有提供冗余或错误修复能力，其中一块硬盘损坏，所有数据将遗失。</li>
</ul>
</li>
<li>RAID 1<ul>
<li>RAID 1就是镜像，其原理为在主硬盘上存放数据的同时也在镜像硬盘上写一样的数据。</li>
<li>当主硬盘（物理）损坏时，镜像硬盘则代替主硬盘的工作。因为有镜像硬盘做数据备份，所以RAID 1的数据安全性在所有的RAID级别上来说是最好的。</li>
<li>但无论用多少磁盘做RAID 1，仅算一个磁盘的容量，是所有RAID中磁盘利用率最低的。</li>
</ul>
</li>
<li>RAID 2<ul>
<li>这是RAID 0的改良版，以汉明码（Hamming Code）的方式将数据进行编码后分区为独立的比特，并将数据分别写入硬盘中。因为在数据中加入了错误修正码（ECC，Error Correction Code），所以数据整体的容量会比原始数据大一些，RAID2最少要三台磁盘驱动器方能运作。</li>
</ul>
</li>
<li>RAID 3<ul>
<li>采用Bit－interleaving（数据交错存储）技术，它需要通过编码再将数据比特分割后分别存在硬盘中，而将同比特检查后单独存在一个硬盘中，但由于数据内的比特分散在不同的硬盘上，因此就算要读取一小段数据资料都可能需要所有的硬盘进行工作，所以这种规格比较适于读取大量数据时使用。</li>
</ul>
</li>
<li>RAID 4<ul>
<li>它与RAID 3不同的是它在分区时是以区块为单位分别存在硬盘中，但每次的数据访问都必须从同比特检查的那个硬盘中取出对应的同比特数据进行核对，由于过于频繁的使用，所以对硬盘的损耗可能会提高。（块交织技术，Block interleaving）</li>
</ul>
</li>
</ul>
<p><strong>RAID 2/3/4 在实际应用中很少使用</strong></p>
<ul>
<li>RAID 5<ul>
<li>RAID Level 5是一种储存性能、数据安全和存储成本兼顾的存储解决方案。它使用的是Disk Striping（硬盘分区）技术。</li>
<li>RAID 5至少需要三块硬盘，RAID 5不是对存储的数据进行备份，而是把数据和相对应的奇偶校验信息存储到组成RAID5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上。</li>
<li>RAID 5 允许一块硬盘损坏。</li>
<li>实际容量 Size = (N-1) * min(S1, S2, S3 … SN)</li>
</ul>
</li>
<li>RAID 6<ul>
<li>与RAID 5相比，RAID 6增加第二个独立的奇偶校验信息块。两个独立的奇偶系统使用不同的算法，数据的可靠性非常高，即使两块磁盘同时失效也不会影响数据的使用。</li>
<li>RAID 6 至少需要4块硬盘。</li>
<li>实际容量 Size = (N-2) * min(S1, S2, S3 … SN)</li>
</ul>
</li>
<li>RAID 10/01（RAID 1+0，RAID 0+1）<ul>
<li>RAID 10是先镜射再分区数据，再将所有硬盘分为两组，视为是RAID 0的最低组合，然后将这两组各自视为RAID 1运作。</li>
<li>RAID 01则是跟RAID 10的程序相反，是先分区再将数据镜射到两组硬盘。它将所有的硬盘分为两组，变成RAID 1的最低组合，而将两组硬盘各自视为RAID 0运作。</li>
<li>当RAID 10有一个硬盘受损，其余硬盘会继续运作。RAID 01只要有一个硬盘受损，同组RAID 0的所有硬盘都会停止运作，只剩下其他组的硬盘运作，可靠性较低。如果以六个硬盘建RAID 01，镜射再用三个建RAID 0，那么坏一个硬盘便会有三个硬盘脱机。因此，RAID 10远较RAID 01常用，零售主板绝大部份支持RAID 0/1/5/10，但不支持RAID 01。</li>
<li>RAID 10 至少需要4块硬盘，且硬盘数量必须为偶数。</li>
</ul>
</li>
</ul>
<h4 id="u5E38_u89C1_u6587_u4EF6_u7CFB_u7EDF"><a href="#u5E38_u89C1_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="常见文件系统"></a>常见文件系统</h4><ul>
<li>Windows: FAT, FAT16, FAT32, NTFS</li>
<li>Linux: ext2/3/4, btrfs, ZFS</li>
<li>Mac OS X: HFS+</li>
</ul>
<h3 id="Linux_u6587_u4EF6_u6743_u9650"><a href="#Linux_u6587_u4EF6_u6743_u9650" class="headerlink" title="Linux文件权限"></a>Linux文件权限</h3><p>Linux文件采用10个标志位来表示文件权限，如下所示：</p>
<pre><code>-rw-r--r--  1 skyline  staff    20B  1 27 10:34 1.txt
drwxr-xr-x   5 skyline  staff   170B 12 23 19:01 ABTableViewCell
</code></pre><p>第一个字符一般用来区分文件和目录，其中：</p>
<ul>
<li>d：表示是一个目录，事实上在ext2fs中，目录是一个特殊的文件。</li>
<li>－：表示这是一个普通的文件。</li>
<li>l: 表示这是一个符号链接文件，实际上它指向另一个文件。</li>
<li>b、c：分别表示区块设备和其他的外围设备，是特殊类型的文件。</li>
<li>s、p：这些文件关系到系统的数据结构和管道，通常很少见到。</li>
</ul>
<p>第2～10个字符当中的每3个为一组，左边三个字符表示所有者权限，中间3个字符表示与所有者同一组的用户的权限，右边3个字符是其他用户的权限。</p>
<p>这三个一组共9个字符，代表的意义如下：</p>
<ul>
<li>r(Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限</li>
<li>w(Write,写入)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。</li>
<li>x(eXecute，执行)：对文件而言，具有执行文件的权限；对目录来说该用户具有进入目录的权限。</li>
</ul>
<p>权限的掩码可以使用十进制数字表示：</p>
<ul>
<li>如果可读，权限是二进制的100，十进制是4；</li>
<li>如果可写，权限是二进制的010，十进制是2；</li>
<li>如果可运行，权限是二进制的001，十进制是1；</li>
</ul>
<p><strong>具备多个权限，就把相应的 4、2、1 相加就可以了：</strong></p>
<pre><code>若要 rwx 则 4+2+1=7 若要 rw- 则 4+2=6 若要 r-x 则 4+1=5 若要 r-- 则 =4 若要 -wx 则 2+1=3 若要 -w- 则 =2 若要 --x 则 =1 若要 --- 则 =0
</code></pre><p>默认的权限可用umask命令修改，用法非常简单，只需执行umask 777命令，便代表屏蔽所有的权限，因而之后建立的文件或目录，其权限都变成000，</p>
<p>依次类推。通常root帐号搭配umask命令的数值为022、027和 077，普通用户则是采用002，这样所产生的权限依次为755、750、700、775。</p>
<h4 id="chmod_u547D_u4EE4"><a href="#chmod_u547D_u4EE4" class="headerlink" title="chmod命令"></a>chmod命令</h4><p>chmod命令非常重要，用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。</p>
<p>该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。</p>
<ol>
<li>文字设定法<ul>
<li>chmod ［who］ ［+ | - | =］ ［mode］ 文件名</li>
<li>命令中各选项的含义为：</li>
<li>操作对象who可是下述字母中的任一个或者它们的组合：<ul>
<li>u 表示“用户（user）”，即文件或目录的所有者。</li>
<li>g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。</li>
<li>o 表示“其他（others）用户”。</li>
<li>a 表示“所有（all）用户”。它是系统默认值。</li>
</ul>
</li>
<li>操作符号可以是：<ul>
<li>添加某个权限。</li>
<li>取消某个权限。</li>
<li>= 赋予给定权限并取消其他所有权限（如果有的话）。</li>
</ul>
</li>
<li>设置mode所表示的权限可用下述字母的任意组合：<ul>
<li>r 可读。</li>
<li>w 可写。</li>
<li>x 可执行。</li>
<li>X 只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性。</li>
<li>s 在文件执行时把进程的属主或组ID置为该文件的文件属主。方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位。</li>
<li>t 保存程序的文本到交换设备上。</li>
<li>u 与文件属主拥有一样的权限。</li>
<li>g 与和文件属主同组的用户拥有一样的权限。</li>
<li>o 与其他用户拥有一样的权限。</li>
</ul>
</li>
<li>文件名：以空格分开的要改变权限的文件列表，支持通配符。</li>
<li>在一个命令行中可给出多个权限方式，其间用逗号隔开。例如：chmod g+r，o+r example 使同组和其他用户对文件example 有读权限。</li>
</ul>
</li>
<li>数字设定法<ul>
<li>直接使用数字表示的权限来更改：</li>
<li>例： $ chmod 644 mm.txt</li>
</ul>
</li>
</ol>
<h4 id="chgrp_u547D_u4EE4"><a href="#chgrp_u547D_u4EE4" class="headerlink" title="chgrp命令"></a>chgrp命令</h4><ul>
<li>功能：改变文件或目录所属的组。</li>
<li>语法：chgrp ［选项］ group filename</li>
<li>例：$ chgrp - R book /opt/local /book</li>
<li>改变/opt/local /book/及其子目录下的所有文件的属组为book。</li>
</ul>
<h4 id="chown_u547D_u4EE4"><a href="#chown_u547D_u4EE4" class="headerlink" title="chown命令"></a>chown命令</h4><ul>
<li>功能：更改某个文件或目录的属主和属组。这个命令也很常用。例如root用户把自己的一个文件拷贝给用户xu，为了让用户xu能够存取这个文件，root用户应该把这个文件的属主设为xu，否则，用户xu无法存取这个文件。</li>
<li>语法：chown ［选项］ 用户或组 文件</li>
<li>说明：chown将指定文件的拥有者改为指定的用户或组。用户可以是用户名或用户ID。组可以是组名或组ID。文件是以空格分开的要改变权限的文件列表，支持通配符。</li>
<li>例：把文件shiyan.c的所有者改为wang。</li>
<li><code>chown wang shiyan.c</code></li>
</ul>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://wdxtub.com/interview/14520603814585.html">After URL</a></li>
<li><a href="http://wdxtub.com/interview/14520603814632.html">Reliable UDP</a></li>
<li><a href="http://wdxtub.com/interview/14520603814674.html">TCP or UDP</a></li>
<li><a href="http://wdxtub.com/interview/14520607787127.html">Test Binary Search</a></li>
<li><a href="http://wdxtub.com/interview/14520607787180.html">Test a Login System</a></li>
<li><a href="http://wdxtub.com/interview/14520607787230.html">Test a Pen</a></li>
<li><a href="http://wdxtub.com/interview/14520607787281.html">Web Browser debug</a></li>
</ul>
</div><div class="tags"><a href="/tags/思维/">思维</a><a href="/tags/技能/">技能</a><a href="/tags/操作系统/">操作系统</a><a href="/tags/数据库/">数据库</a><a href="/tags/程序员/">程序员</a><a href="/tags/网络/">网络</a></div><div class="post-nav"><a href="/2016/01/23/programmer-startline-13/" class="pre"><i class="icon-previous">编程起跑线 第 13 课 总结</i></a><a href="/2016/01/23/programmer-startline-11/" class="next">编程起跑线 第 11 课 面向对象<i class="icon-next"></i></a></div><div data-thread-key="2016/01/23/programmer-startline-12/" data-title="编程起跑线 第 12 课 其他知识" data-url="http://wdxtub.com/2016/01/23/programmer-startline-12/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/01/23/programmer-startline-12/" data-title="编程起跑线 第 12 课 其他知识" data-url="http://wdxtub.com/2016/01/23/programmer-startline-12/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="http://wdxtub.com"/></form></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Game/">Game</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Gossip/">Gossip</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Memory/">Memory</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Movie/">Movie</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Reading/">Reading</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Story/">Story</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Technique/">Technique</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Thinking/">Thinking</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Traveling/">Traveling</a></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/今何在/" style="font-size: 15px;">今何在</a> <a href="/tags/氐惆/" style="font-size: 15px;">氐惆</a> <a href="/tags/回头无岸/" style="font-size: 15px;">回头无岸</a> <a href="/tags/电影/" style="font-size: 15px;">电影</a> <a href="/tags/动画/" style="font-size: 15px;">动画</a> <a href="/tags/孙悟空/" style="font-size: 15px;">孙悟空</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/记录/" style="font-size: 15px;">记录</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/思考/" style="font-size: 15px;">思考</a> <a href="/tags/论道/" style="font-size: 15px;">论道</a> <a href="/tags/精选/" style="font-size: 15px;">精选</a> <a href="/tags/早起/" style="font-size: 15px;">早起</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/抱怨/" style="font-size: 15px;">抱怨</a> <a href="/tags/生活/" style="font-size: 15px;">生活</a> <a href="/tags/自尊/" style="font-size: 15px;">自尊</a> <a href="/tags/CMU/" style="font-size: 15px;">CMU</a> <a href="/tags/周记/" style="font-size: 15px;">周记</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/改变/" style="font-size: 15px;">改变</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/教育/" style="font-size: 15px;">教育</a> <a href="/tags/家庭/" style="font-size: 15px;">家庭</a> <a href="/tags/环境/" style="font-size: 15px;">环境</a> <a href="/tags/回合制/" style="font-size: 15px;">回合制</a> <a href="/tags/格子/" style="font-size: 15px;">格子</a> <a href="/tags/模拟经营/" style="font-size: 15px;">模拟经营</a> <a href="/tags/COC/" style="font-size: 15px;">COC</a> <a href="/tags/美剧/" style="font-size: 15px;">美剧</a> <a href="/tags/苏州/" style="font-size: 15px;">苏州</a> <a href="/tags/旅行/" style="font-size: 15px;">旅行</a> <a href="/tags/醒醒/" style="font-size: 15px;">醒醒</a> <a href="/tags/笔记/" style="font-size: 15px;">笔记</a> <a href="/tags/知识管理/" style="font-size: 15px;">知识管理</a> <a href="/tags/英语学习/" style="font-size: 15px;">英语学习</a> <a href="/tags/透析/" style="font-size: 15px;">透析</a> <a href="/tags/蝴蝶效应/" style="font-size: 15px;">蝴蝶效应</a> <a href="/tags/步行/" style="font-size: 15px;">步行</a> <a href="/tags/Kindle/" style="font-size: 15px;">Kindle</a> <a href="/tags/口译/" style="font-size: 15px;">口译</a> <a href="/tags/徐州/" style="font-size: 15px;">徐州</a> <a href="/tags/原创/" style="font-size: 15px;">原创</a> <a href="/tags/童话/" style="font-size: 15px;">童话</a> <a href="/tags/感情/" style="font-size: 15px;">感情</a> <a href="/tags/心智/" style="font-size: 15px;">心智</a> <a href="/tags/时间/" style="font-size: 15px;">时间</a> <a href="/tags/自我/" style="font-size: 15px;">自我</a> <a href="/tags/感恩节/" style="font-size: 15px;">感恩节</a> <a href="/tags/朋友/" style="font-size: 15px;">朋友</a> <a href="/tags/纽约/" style="font-size: 15px;">纽约</a> <a href="/tags/成绩/" style="font-size: 15px;">成绩</a> <a href="/tags/多看/" style="font-size: 15px;">多看</a> <a href="/tags/访谈/" style="font-size: 15px;">访谈</a> <a href="/tags/游戏/" style="font-size: 15px;">游戏</a> <a href="/tags/英雄联盟/" style="font-size: 15px;">英雄联盟</a> <a href="/tags/笔试/" style="font-size: 15px;">笔试</a> <a href="/tags/改进/" style="font-size: 15px;">改进</a> <a href="/tags/旅途/" style="font-size: 15px;">旅途</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/英雄/" style="font-size: 15px;">英雄</a> <a href="/tags/将军/" style="font-size: 15px;">将军</a> <a href="/tags/回忆/" style="font-size: 15px;">回忆</a> <a href="/tags/清醒思考的艺术/" style="font-size: 15px;">清醒思考的艺术</a> <a href="/tags/明智行动的艺术/" style="font-size: 15px;">明智行动的艺术</a> <a href="/tags/科幻/" style="font-size: 15px;">科幻</a> <a href="/tags/预言/" style="font-size: 15px;">预言</a> <a href="/tags/顽皮狗/" style="font-size: 15px;">顽皮狗</a> <a href="/tags/PS4/" style="font-size: 15px;">PS4</a> <a href="/tags/写作/" style="font-size: 15px;">写作</a> <a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/开篇/" style="font-size: 15px;">开篇</a> <a href="/tags/新参者/" style="font-size: 15px;">新参者</a> <a href="/tags/小说/" style="font-size: 15px;">小说</a> <a href="/tags/死亡/" style="font-size: 15px;">死亡</a> <a href="/tags/Swift-千金方/" style="font-size: 15px;">Swift 千金方</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/斯坦福-CS193p/" style="font-size: 15px;">斯坦福 CS193p</a> <a href="/tags/教程/" style="font-size: 15px;">教程</a> <a href="/tags/闭包/" style="font-size: 15px;">闭包</a> <a href="/tags/技巧/" style="font-size: 15px;">技巧</a> <a href="/tags/Apple/" style="font-size: 15px;">Apple</a> <a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/Overview/" style="font-size: 15px;">Overview</a> <a href="/tags/概览/" style="font-size: 15px;">概览</a> <a href="/tags/ARC/" style="font-size: 15px;">ARC</a> <a href="/tags/扩展/" style="font-size: 15px;">扩展</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/泛型/" style="font-size: 15px;">泛型</a> <a href="/tags/访问控制/" style="font-size: 15px;">访问控制</a> <a href="/tags/运算符重载/" style="font-size: 15px;">运算符重载</a> <a href="/tags/类型/" style="font-size: 15px;">类型</a> <a href="/tags/元组/" style="font-size: 15px;">元组</a> <a href="/tags/运算符/" style="font-size: 15px;">运算符</a> <a href="/tags/控制/" style="font-size: 15px;">控制</a> <a href="/tags/函数/" style="font-size: 15px;">函数</a> <a href="/tags/属性/" style="font-size: 15px;">属性</a> <a href="/tags/继承/" style="font-size: 15px;">继承</a> <a href="/tags/TOC/" style="font-size: 15px;">TOC</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/01/24/sad-r2/">软件架构与设计 习题课 2 不同架构风格应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/23/programmer-startline-13/">编程起跑线 第 13 课 总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/23/programmer-startline-12/">编程起跑线 第 12 课 其他知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/23/programmer-startline-11/">编程起跑线 第 11 课 面向对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/23/programmer-startline-10/">编程起跑线 第 10 课 位操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/23/programmer-startline-9/">编程起跑线 第 9 课 数学</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/23/programmer-startline-8/">编程起跑线 第 8 课 排序和搜索</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/23/programmer-startline-7/">编程起跑线 第 7 课 树和图</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/23/programmer-startline-6/">编程起跑线 第 6 课 递归与动态规划</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/22/programmer-startline-5/">编程起跑线 第 5 课 链表</a></li></ul></div><div class="widget"><div class="comments-title">最近评论</div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title">友情链接</div><ul></ul><a href="http://wdxtub.com/library/" title="我的笔记" target="_blank">我的笔记</a><ul></ul><a href="http://wdxtub.com/bookclips/" title="我的书摘" target="_blank">我的书摘</a><ul></ul><a href="http://wdxtub.com/interview/" title="刷题笔记" target="_blank">刷题笔记</a></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">小土刀.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script>
<script src="/js/jquery.fancybox.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"><script>var duoshuoQuery = {short_name:'wdxblog'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script></div></body></html>