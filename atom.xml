<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-01-23T22:52:22.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[编程起跑线 第 13 课 总结]]></title>
    <link href="http://wdxtub.com/2016/01/23/programmer-startline-13/"/>
    <id>http://wdxtub.com/2016/01/23/programmer-startline-13/</id>
    <published>2016-01-23T22:48:13.000Z</published>
    <updated>2016-01-23T22:52:22.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
<hr>
 公式 
]]>
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="总结" scheme="http://wdxtub.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 12 课 其他知识]]></title>
    <link href="http://wdxtub.com/2016/01/23/programmer-startline-12/"/>
    <id>http://wdxtub.com/2016/01/23/programmer-startline-12/</id>
    <published>2016-01-23T22:48:09.000Z</published>
    <updated>2016-01-23T22:52:07.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
<hr>
 公式 
]]>
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="操作系统" scheme="http://wdxtub.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据库" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="网络" scheme="http://wdxtub.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 11 课 面向对象]]></title>
    <link href="http://wdxtub.com/2016/01/23/programmer-startline-11/"/>
    <id>http://wdxtub.com/2016/01/23/programmer-startline-11/</id>
    <published>2016-01-23T22:48:04.000Z</published>
    <updated>2016-01-23T22:51:55.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
<hr>
 公式 
]]>
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="面向对象" scheme="http://wdxtub.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 10 课 位操作]]></title>
    <link href="http://wdxtub.com/2016/01/23/programmer-startline-10/"/>
    <id>http://wdxtub.com/2016/01/23/programmer-startline-10/</id>
    <published>2016-01-23T22:48:01.000Z</published>
    <updated>2016-01-23T22:51:49.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
<hr>
 公式 
]]>
    </summary>
    
      <category term="位操作" scheme="http://wdxtub.com/tags/%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 9 课 数学]]></title>
    <link href="http://wdxtub.com/2016/01/23/programmer-startline-9/"/>
    <id>http://wdxtub.com/2016/01/23/programmer-startline-9/</id>
    <published>2016-01-23T21:30:05.000Z</published>
    <updated>2016-01-23T22:47:41.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
<hr>
 公式 
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://wdxtub.com/interview/14520604913655.html">Kth Permuation</a></li>
<li><a href="http://wdxtub.com/interview/14520595470004.html">Check Permutation</a></li>
<li><a href="http://wdxtub.com/interview/14520604917011.html">Nth Prime</a></li>
<li><a href="http://wdxtub.com/interview/14520604918229.html">Pow(x, n)</a></li>
<li><a href="http://wdxtub.com/interview/14520604911732.html">Combinations</a></li>
<li><a href="http://wdxtub.com/interview/14520604910652.html">All Permutation</a></li>
<li><a href="http://wdxtub.com/interview/14520604910607.html">All Permutations II</a></li>
<li><a href="http://wdxtub.com/interview/14520606004545.html">Sqrt(x)</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
<hr>
 公式 
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://wd]]>
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="数学" scheme="http://wdxtub.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 8 课 排序和搜索]]></title>
    <link href="http://wdxtub.com/2016/01/23/programmer-startline-8/"/>
    <id>http://wdxtub.com/2016/01/23/programmer-startline-8/</id>
    <published>2016-01-23T14:20:57.000Z</published>
    <updated>2016-01-23T22:46:57.000Z</updated>
    <content type="html"><![CDATA[<p>排序和搜索其实比较相似，最重要的就是理解好二分的思想。无论是稍微复杂一点的排序算法，还是搜索，实际上都是分而治之思想的体现。</p>
<a id="more"></a>
<hr>
<h2 id="u89E3_u9898_u7B56_u7565"><a href="#u89E3_u9898_u7B56_u7565" class="headerlink" title="解题策略"></a>解题策略</h2> 公式 
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://wdxtub.com/interview/14520606004678.html">Stream Integer</a></li>
<li><a href="http://wdxtub.com/interview/14520606004412.html">Sparse Search</a></li>
<li><a href="http://wdxtub.com/interview/14520606004279.html">Sorted Search, No Size</a></li>
<li><a href="http://wdxtub.com/interview/14520606004147.html">Sort Colors</a></li>
<li><a href="http://wdxtub.com/interview/14520606003957.html">Sort Colors II</a></li>
<li><a href="http://wdxtub.com/interview/14520606003704.html">Sort Age</a></li>
<li><a href="http://wdxtub.com/interview/14520606003582.html">Social Network</a></li>
<li><a href="http://wdxtub.com/interview/14520606003458.html">Search Rotated Array</a></li>
<li><a href="http://wdxtub.com/interview/14520606003336.html">Search Range</a></li>
<li><a href="http://wdxtub.com/interview/14520606003219.html">Search Insert Position</a></li>
<li><a href="http://wdxtub.com/interview/14520606003106.html">Search 2D matrix</a></li>
<li><a href="http://wdxtub.com/interview/14520606002879.html">Nuts &amp; Bolts Problem</a></li>
<li><a href="http://wdxtub.com/interview/14520606002777.html">Missing Number</a></li>
<li><a href="http://wdxtub.com/interview/14520606002660.html">Find Minimum in Rotated Sorted Array</a></li>
<li><a href="http://wdxtub.com/interview/14520606002549.html">Median of Two Sorted Array</a></li>
<li><a href="http://wdxtub.com/interview/14520606002445.html">Maximum Gap</a></li>
<li><a href="http://wdxtub.com/interview/14520606002338.html">Kth Smallest Number</a></li>
<li><a href="http://wdxtub.com/interview/14520606002263.html">Kth Largest in Sorted Matrix</a></li>
<li><a href="http://wdxtub.com/interview/14520606002197.html">Kth Largest Element</a></li>
<li><a href="http://wdxtub.com/interview/14520606002136.html">Inverted Index</a></li>
<li><a href="http://wdxtub.com/interview/14520606002077.html">Index Equals to Value</a></li>
<li><a href="http://wdxtub.com/interview/14520606002015.html">Hit Counter</a></li>
<li><a href="http://wdxtub.com/interview/14520606001958.html">Group Anagrams</a></li>
<li><a href="http://wdxtub.com/interview/14520606001885.html">Group Anagrams List</a></li>
<li><a href="http://wdxtub.com/interview/14520606001824.html">First Missing Positive Number</a></li>
<li><a href="http://wdxtub.com/interview/14520606001769.html">First Error Version</a></li>
<li><a href="http://wdxtub.com/interview/14520606001720.html">Find Peak Element</a></li>
<li><a href="http://wdxtub.com/interview/14520606001667.html">名人问题</a></li>
<li><a href="http://wdxtub.com/interview/14520606001623.html">Count Plane</a></li>
<li><a href="http://wdxtub.com/interview/14520606001575.html">Binary Search</a></li>
<li><a href="http://wdxtub.com/interview/14520607214993.html">Cut Wood</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>排序和搜索其实比较相似，最重要的就是理解好二分的思想。无论是稍微复杂一点的排序算法，还是搜索，实际上都是分而治之思想的体现。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="排序" scheme="http://wdxtub.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="搜索" scheme="http://wdxtub.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 7 课 树和图]]></title>
    <link href="http://wdxtub.com/2016/01/23/programmer-startline-7/"/>
    <id>http://wdxtub.com/2016/01/23/programmer-startline-7/</id>
    <published>2016-01-23T14:20:51.000Z</published>
    <updated>2016-01-23T22:46:41.000Z</updated>
    <content type="html"><![CDATA[<p>树和图的问题，说难也难，说简单也简单。难在思路和理解，简单在很多时候可以利用递归得到非常优雅的解法。</p>
<a id="more"></a>
<hr>
<h2 id="u89E3_u9898_u7B56_u7565"><a href="#u89E3_u9898_u7B56_u7565" class="headerlink" title="解题策略"></a>解题策略</h2> 公式 
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://wdxtub.com/interview/14520607221934.html">Zigzag Level Order Traversal</a></li>
<li><a href="http://wdxtub.com/interview/14520607221747.html">Word Ladder</a></li>
<li><a href="http://wdxtub.com/interview/14520607221562.html">Word Ladder II</a></li>
<li><a href="http://wdxtub.com/interview/14520607221359.html">Valid Binary Search Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607221154.html">Unique Binary Search Trees</a></li>
<li><a href="http://wdxtub.com/interview/14520607220949.html">Unique Binary Search Trees II</a></li>
<li><a href="http://wdxtub.com/interview/14520607220765.html">Implement Trie (Prefix Tree)</a></li>
<li><a href="http://wdxtub.com/interview/14520607220590.html">Topological Sort</a></li>
<li><a href="http://wdxtub.com/interview/14520607220397.html">Convert Sorted List to Binary Search Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607220201.html">Sorted Array to Binary Search Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607220001.html">Serialize and Deserialize</a></li>
<li><a href="http://wdxtub.com/interview/14520607219827.html">Search Range</a></li>
<li><a href="http://wdxtub.com/interview/14520607219664.html">Scramble String</a></li>
<li><a href="http://wdxtub.com/interview/14520607219495.html">Route Between Nodes</a></li>
<li><a href="http://wdxtub.com/interview/14520607219333.html">Root Path Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520607219173.html">Binary Tree Right Side View</a></li>
<li><a href="http://wdxtub.com/interview/14520607219009.html">Reverse Binary Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607218845.html">Recover Binary Search Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607218687.html">Preorder Traversal</a></li>
<li><a href="http://wdxtub.com/interview/14520607218530.html">Postorder Traversal</a></li>
<li><a href="http://wdxtub.com/interview/14520607218372.html">Node Path Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520607218218.html">Paths with Sum II</a></li>
<li><a href="http://wdxtub.com/interview/14520607218066.html">Populating Next Right Pointers in Each Node</a></li>
<li><a href="http://wdxtub.com/interview/14520607217915.html">Next Node without Parent</a></li>
<li><a href="http://wdxtub.com/interview/14520607217765.html">Next Node</a></li>
<li><a href="http://wdxtub.com/interview/14520607217620.html">Next Node in BST</a></li>
<li><a href="http://wdxtub.com/interview/14520607217464.html">Neighbor Node</a></li>
<li><a href="http://wdxtub.com/interview/14520607217318.html">Minimum Path Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520607217172.html">Min Height of Binary Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607217172.html">Min Height of Binary Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607217030.html">Maximum Path Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520607216892.html">Height of Binary Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607216756.html">Level Order Traversal</a></li>
<li><a href="http://wdxtub.com/interview/14520607216621.html">Level Order Traversal II</a></li>
<li><a href="http://wdxtub.com/interview/14520607216488.html">Leaf Path Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520607216345.html">Kth Smallest Element in a BST</a></li>
<li><a href="http://wdxtub.com/interview/14520607216180.html">Is Subtree</a></li>
<li><a href="http://wdxtub.com/interview/14520607216053.html">Insert node to BST</a></li>
<li><a href="http://wdxtub.com/interview/14520607215936.html">Inorder Traversal</a></li>
<li><a href="http://wdxtub.com/interview/14520607215811.html">Flatten Binary Tree to Linked List</a></li>
<li><a href="http://wdxtub.com/interview/14520607215690.html">First Common Ancestor</a></li>
<li><a href="http://wdxtub.com/interview/14520607215576.html">First Common Ancestor of a Binary Search Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607215459.html">Different BST</a></li>
<li><a href="http://wdxtub.com/interview/14520607215341.html">Different BST II</a></li>
<li><a href="http://wdxtub.com/interview/14520607214882.html">Course Schedule</a></li>
<li><a href="http://wdxtub.com/interview/14520607214780.html">Course Schedule II</a></li>
<li><a href="http://wdxtub.com/interview/14520607214651.html">Connected Nodes in Undirected Graph</a></li>
<li><a href="http://wdxtub.com/interview/14520607214579.html">Complete Tree Node Count</a></li>
<li><a href="http://wdxtub.com/interview/14520607214515.html">Clone Graph</a></li>
<li><a href="http://wdxtub.com/interview/14520607214451.html">Symmetric Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607214387.html">Same Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607214326.html">Build Order</a></li>
<li><a href="http://wdxtub.com/interview/14520607214254.html">BST Sequences</a></li>
<li><a href="http://wdxtub.com/interview/14520607214194.html">Binary Tree to Linked List</a></li>
<li><a href="http://wdxtub.com/interview/14520607214136.html">Construct Binary Tree from Preorder and Inorder Traversal</a></li>
<li><a href="http://wdxtub.com/interview/14520607214067.html">Construct Binary Tree from Inorder and Postorder Traversal</a></li>
<li><a href="http://wdxtub.com/interview/14520607214003.html">Binary Tree Depth</a></li>
<li><a href="http://wdxtub.com/interview/14520607213955.html">Binary Search Tree Iterator</a></li>
<li><a href="http://wdxtub.com/interview/14520607213899.html">Balance Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607213899.html">Balance Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607213844.html">All Path</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>树和图的问题，说难也难，说简单也简单。难在思路和理解，简单在很多时候可以利用递归得到非常优雅的解法。</p>]]>
    
    </summary>
    
      <category term="图" scheme="http://wdxtub.com/tags/%E5%9B%BE/"/>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="树" scheme="http://wdxtub.com/tags/%E6%A0%91/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 6 课 递归与动态规划]]></title>
    <link href="http://wdxtub.com/2016/01/23/programmer-startline-6/"/>
    <id>http://wdxtub.com/2016/01/23/programmer-startline-6/</id>
    <published>2016-01-23T14:20:47.000Z</published>
    <updated>2016-01-23T22:47:02.000Z</updated>
    <content type="html"><![CDATA[<p>递归和动态规划应该算是算法问题中的难点。核心解法很简单，就是要找到状态转移方程，也就是如何把原问题分解成子问题，然后分而治之。所以说，更多像是一种思维方式，而不是具体的步骤技巧。</p>
<a id="more"></a>
<hr>
<h2 id="u89E3_u9898_u7B56_u7565"><a href="#u89E3_u9898_u7B56_u7565" class="headerlink" title="解题策略"></a>解题策略</h2> 公式 
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li>动态规划<ul>
<li><a href="http://wdxtub.com/interview/14520604921847.html">Word Break</a></li>
<li><a href="http://wdxtub.com/interview/14520604921620.html">Word Break II</a></li>
<li><a href="http://wdxtub.com/interview/14520604921399.html">Wildcard Matching</a></li>
<li><a href="http://wdxtub.com/interview/14520604918826.html">Regular Expression Matching</a></li>
<li><a href="http://wdxtub.com/interview/14520604921164.html">Unique Path</a></li>
<li><a href="http://wdxtub.com/interview/14520604920947.html">Unique Path II</a></li>
<li><a href="http://wdxtub.com/interview/14520604920730.html">Ugly Number</a></li>
<li><a href="http://wdxtub.com/interview/14520604920507.html">Ugly Number II</a></li>
<li><a href="http://wdxtub.com/interview/14520604920305.html">Trap Water</a></li>
<li><a href="http://wdxtub.com/interview/14520595472823.html">Longest Consecutive Sequence</a></li>
<li><a href="http://wdxtub.com/interview/14520604919653.html">Continuous Subarray Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520604919436.html">Subarray Sum to K</a></li>
<li><a href="http://wdxtub.com/interview/14520604918412.html">Product of Array Except Self</a></li>
<li><a href="http://wdxtub.com/interview/14520604917885.html">Palindrom Partition</a></li>
<li><a href="http://wdxtub.com/interview/14520604918057.html">Palindrome Partitioning II</a></li>
<li><a href="http://wdxtub.com/interview/14520604917521.html">Package Problem</a></li>
<li><a href="http://wdxtub.com/interview/14520604917350.html">Package Problem II</a></li>
<li><a href="http://wdxtub.com/interview/14520604916850.html">N Queen</a></li>
<li><a href="http://wdxtub.com/interview/14520604916662.html">N-Queens II</a></li>
<li><a href="http://wdxtub.com/interview/14520604916164.html">Min Sum Subarray</a></li>
<li><a href="http://wdxtub.com/interview/14520604916010.html">Min Adjustment Cost</a></li>
<li><a href="http://wdxtub.com/interview/14520604915856.html">Maximum Subarray</a></li>
<li><a href="http://wdxtub.com/interview/14520604915702.html">Max Sum Subarray Index</a></li>
<li><a href="http://wdxtub.com/interview/14520604915546.html">Max Sum 2 Subarray</a></li>
<li><a href="http://wdxtub.com/interview/14520604915394.html">Max Square</a></li>
<li><a href="http://wdxtub.com/interview/14520604915232.html">Maximal Rectangle</a></li>
<li><a href="http://wdxtub.com/interview/14520604915082.html">Max Product Subarray</a></li>
<li><a href="http://wdxtub.com/interview/14520595474431.html">Min Difference 2 Array</a></li>
<li><a href="http://wdxtub.com/interview/14520604914933.html">Max Difference 2 Subarray</a></li>
<li><a href="http://wdxtub.com/interview/14520604914337.html">Longest Increasing Sequence</a></li>
<li><a href="http://wdxtub.com/interview/14520604914202.html">Longest Increasing Consecutive Sequence</a></li>
<li><a href="http://wdxtub.com/interview/14520604914067.html">Longest Common Substring</a></li>
<li><a href="http://wdxtub.com/interview/14520604913939.html">Longest Common Subsequence</a></li>
<li><a href="http://wdxtub.com/interview/14520604913809.html">Largest Rectangle in Histogram</a></li>
<li><a href="http://wdxtub.com/interview/14520604913528.html">Jump Game</a></li>
<li><a href="http://wdxtub.com/interview/14520604913406.html">Jump Game II</a></li>
<li><a href="http://wdxtub.com/interview/14520604913280.html">Interleaving String</a></li>
<li><a href="http://wdxtub.com/interview/14520604913150.html">House Robbery</a></li>
<li><a href="http://wdxtub.com/interview/14520604912979.html">House Robbery II</a></li>
<li><a href="http://wdxtub.com/interview/14520604912743.html">Gas Station</a></li>
<li><a href="http://wdxtub.com/interview/14520604912625.html">Fibonacci</a></li>
<li><a href="http://wdxtub.com/interview/14520604912393.html">Edit Distance</a></li>
<li><a href="http://wdxtub.com/interview/14520604912043.html">Different Subsequence</a></li>
<li><a href="http://wdxtub.com/interview/14520604911938.html">Decode Ways</a></li>
<li><a href="http://wdxtub.com/interview/14520604911834.html">Container with Most Water</a></li>
<li><a href="http://wdxtub.com/interview/14520604911320.html">Coin</a></li>
<li><a href="http://wdxtub.com/interview/14520604911261.html">Coin Game</a></li>
<li><a href="http://wdxtub.com/interview/14520604911204.html">Coin Game II</a></li>
<li><a href="http://wdxtub.com/interview/14520604911145.html">Climb Stairs</a></li>
<li><a href="http://wdxtub.com/interview/14520604911084.html">Climb Stairs - Triple Step</a></li>
<li><a href="http://wdxtub.com/interview/14520604911019.html">Boggle Game - Word Search</a></li>
<li><a href="http://wdxtub.com/interview/14520604910956.html">Boggle Game: Word Search II</a></li>
<li><a href="http://wdxtub.com/interview/14520604910906.html">Best Time to Buy and Sell Stock</a></li>
<li><a href="http://wdxtub.com/interview/14520604910739.html">Best Time to Buy and Sell Stock II</a></li>
<li><a href="http://wdxtub.com/interview/14520604910785.html">Best Time to Buy and Sell Stock III</a></li>
<li><a href="http://wdxtub.com/interview/14520604910834.html">Best Time to Buy and Sell Stock IV</a></li>
</ul>
</li>
<li>递归<ul>
<li><a href="http://wdxtub.com/interview/14520604920091.html">Towers of Hanoi</a></li>
<li><a href="http://wdxtub.com/interview/14520604919872.html">Surrounded Regions</a></li>
<li><a href="http://wdxtub.com/interview/14520604919240.html">Stack of Box</a></li>
<li><a href="http://wdxtub.com/interview/14520604919038.html">Restore IP Addresses</a></li>
<li><a href="http://wdxtub.com/interview/14520604918618.html">Recursive Multiply</a></li>
<li><a href="http://wdxtub.com/interview/14520604917714.html">Paint Fill</a></li>
<li><a href="http://wdxtub.com/interview/14520604917181.html">Number of Island</a></li>
<li><a href="http://wdxtub.com/interview/14520604912864.html">Generate Parentheses</a></li>
<li><a href="http://wdxtub.com/interview/14520604912510.html">Expression Add Operators</a></li>
<li><a href="http://wdxtub.com/interview/14520604912257.html">Dungeon Game</a></li>
<li><a href="http://wdxtub.com/interview/14520604912153.html">Different Ways to Add Parentheses</a></li>
<li><a href="http://wdxtub.com/interview/14520604911617.html">Combination Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520604911420.html">Combination Sum II</a></li>
<li><a href="http://wdxtub.com/interview/14520604911516.html">Combination Sum III</a></li>
<li><a href="http://wdxtub.com/interview/14520604910695.html">All Subsets</a></li>
<li><a href="http://wdxtub.com/interview/14520606002989.html">Recursive Integer Traversal</a></li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>递归和动态规划应该算是算法问题中的难点。核心解法很简单，就是要找到状态转移方程，也就是如何把原问题分解成子问题，然后分而治之。所以说，更多像是一种思维方式，而不是具体的步骤技巧。</p>]]>
    
    </summary>
    
      <category term="动态规划" scheme="http://wdxtub.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="递归" scheme="http://wdxtub.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 5 课 链表]]></title>
    <link href="http://wdxtub.com/2016/01/22/programmer-startline-5/"/>
    <id>http://wdxtub.com/2016/01/22/programmer-startline-5/</id>
    <published>2016-01-22T20:51:05.000Z</published>
    <updated>2016-01-23T22:42:12.000Z</updated>
    <content type="html"><![CDATA[<p>链表，作为在内存中非连续分配的数据结构，因为其灵活性往往容易出错，这里我们会通过深入理解来教大家一些解决链表问题的基本方法。</p>
<a id="more"></a>
<hr>
<h2 id="u89E3_u9898_u7B56_u7565"><a href="#u89E3_u9898_u7B56_u7565" class="headerlink" title="解题策略"></a>解题策略</h2><p>链表(linked list)是一种常见的线性数据结构。对于单向链表(singly linked list)，每个节点有一个 next 指针指向后一个节点，还有一个成员变量用以存储数值；对于双向链表(doubly Linked List)，还有一个 prev 指针指向前一个节点。与数组类似，搜索链表需要O(n)的时间复杂度，但是链表不能通过常数时间 O(1) 读取第k个数据。链表的优势在于能够以较高的效率在任意位置插入或删除一个节点。</p>
<ul>
<li>当涉及对头节点的操作，我们不妨考虑创建哑节点</li>
<li>由于题目涉及在链表中寻找特定位置，我们用两个指针变量以不同的速度遍历该链表</li>
<li>实现链表的逆转时，循环遍历链表, 每次只处理当前指针的 next 变量</li>
</ul>
<h3 id="u94FE_u8868_u7684_u57FA_u672C_u64CD_u4F5C"><a href="#u94FE_u8868_u7684_u57FA_u672C_u64CD_u4F5C" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h3><p>凡是修改单向链表的操作，只需考虑：</p>
<ol>
<li>哪个节点的next指针会受到影响，则需要修正该指针；</li>
<li>如果待删除节点是动态开辟的内存空间，则需要释放这部分空间(C/C++)</li>
</ol>
<p>毕竟，一个链表节点，无非是包含value和next这两个成员变量的数据结构而已。对于双向链表，类似的，则只需额外考虑谁的prev指针会受到影响。</p>
<p>举例如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void delNode(<span class="constant">ListNode </span>*prev) &#123;</span><br><span class="line">  <span class="constant">ListNode </span>*curr = prev-&gt;<span class="keyword">next</span>;</span><br><span class="line">  <span class="regexp">//</span> 删除curr节点只会使prev节点的<span class="keyword">next</span>受到影响</span><br><span class="line">  prev-&gt;<span class="keyword">next</span> = curr-&gt;<span class="keyword">next</span>;    </span><br><span class="line">  delete curr;    <span class="regexp">//</span> 清理trash指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：操作链表时务必注意边界条件：curr == head, curr == tail 或者 curr == NULL</p>
<ul>
<li><strong>两种存储方式</strong><ul>
<li>顺序存储结构：随机读取，访问时是 O(1)</li>
<li>链式存储结构：插入和删除 O(1)，访问时最坏是 O(n)</li>
</ul>
</li>
<li>分类（根据指针域）<ul>
<li>单向链表</li>
<li>双向链表</li>
<li>循环链表</li>
</ul>
</li>
</ul>
<h3 id="u53CD_u8F6C_u94FE_u8868"><a href="#u53CD_u8F6C_u94FE_u8868" class="headerlink" title="反转链表"></a>反转链表</h3><ul>
<li>访问某个节点 <code>curt.next</code> 时，要检验 <code>curt</code> 是否为 <code>null</code></li>
<li>要把反转后的最后一个节点（即第一个节点）指向 <code>null</code></li>
</ul>
<h3 id="u5220_u9664_u67D0_u4E2A_u8282_u70B9"><a href="#u5220_u9664_u67D0_u4E2A_u8282_u70B9" class="headerlink" title="删除某个节点"></a>删除某个节点</h3><ul>
<li>由于需要知道前继节点的信息，而前继节点可能会导致表头产生变化，所以需要一些技巧 <code>Dummy Node</code></li>
<li>链表指针的鲁棒性<ul>
<li>访问某个节点 <code>curt.next</code> 时，要检验 <code>curt</code> 是否为 <code>null</code></li>
<li>全部操作结束后，判断是否有环；若有，则置其中一端为 <code>null</code></li>
</ul>
</li>
</ul>
<h3 id="Dummy_Node"><a href="#Dummy_Node" class="headerlink" title="Dummy Node"></a>Dummy Node</h3><ul>
<li>是一个虚拟节点 <code>dummy.next = head</code></li>
<li>针对单向链表没有前向指针的问题，保证链表的 <code>head</code> 不会在删除操作中丢失</li>
<li>也可以用来进行 <code>head</code> 节点（但比较少见）</li>
<li>当链表的 <code>head</code> 可能有变化时，使用 dummy node 可以简化代码，最后返回 <code>dummy.next</code> 即可</li>
</ul>
<h3 id="u5FEB_u6162_u6307_u9488"><a href="#u5FEB_u6162_u6307_u9488" class="headerlink" title="快慢指针"></a>快慢指针</h3><ul>
<li>快慢指的是指针向前移动的步长，一般来说，快指针每次移动 2，慢指针每次移动 1</li>
<li>主要有两个应用<ul>
<li><strong>快速找出未知长度单链表的中间节点</strong><ul>
<li>设置两个指针 <code>*fast</code> 和 <code>*slow</code> 都指向头节点</li>
<li><code>*fast</code> 移动速度是 <code>*slow</code> 的两倍</li>
<li><code>*fast</code> 指向末尾节点时，<code>*slow</code> 正好就在中间</li>
</ul>
</li>
<li><strong>判断单链表是否有环</strong><ul>
<li>设置两个指针 <code>*fast</code> 和 <code>*slow</code> 都指向头节点</li>
<li><code>*fast</code> 移动速度是 <code>*slow</code> 的两倍</li>
<li>如果 <code>*fast == null</code> 说明该单链表不是循环链表</li>
<li>如果 <code>*fast == *slow</code> 说明该链表是循环链表</li>
</ul>
</li>
</ul>
</li>
<li>其他应用<ul>
<li><strong>找倒数第 N 个节点</strong><ul>
<li>设置两个指针 <code>*fast</code> 和 <code>*slow</code> 都指向头节点</li>
<li><code>*fast</code> 先移动 N 步，然后两个指针一起前进</li>
<li><code>*fast</code> 到达末尾时，<code>*slow</code> 即为倒数第 N 个节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://wdxtub.com/interview/14520597852720.html">Swap Adjacent Node</a></li>
<li><a href="http://wdxtub.com/interview/14520597852604.html">Start of Circle</a></li>
<li><a href="http://wdxtub.com/interview/14520597852502.html">Sort List</a></li>
<li><a href="http://wdxtub.com/interview/14520597852382.html">Rotate List</a></li>
<li><a href="http://wdxtub.com/interview/14520597852276.html">Reversely List Traverse</a></li>
<li><a href="http://wdxtub.com/interview/14520597852177.html">Reverse Nodes in k-Group</a></li>
<li><a href="http://wdxtub.com/interview/14520597852065.html">Reverse List</a></li>
<li><a href="http://wdxtub.com/interview/14520597851968.html">Reverse List Range</a></li>
<li><a href="http://wdxtub.com/interview/14520597851880.html">Reorder List</a></li>
<li><a href="http://wdxtub.com/interview/14520597851782.html">Remove Linked List Elements</a></li>
<li><a href="http://wdxtub.com/interview/14520597851695.html">Remove Duplicates from Unsorted List</a></li>
<li><a href="http://wdxtub.com/interview/14520597851601.html">Remove Duplicates from Sorted List</a></li>
<li><a href="http://wdxtub.com/interview/14520597851549.html">Remove Duplicates from Sorted List II</a></li>
<li><a href="http://wdxtub.com/interview/14520597851500.html">Partition Linked List</a></li>
<li><a href="http://wdxtub.com/interview/14520597851449.html">Partitiom List Sorted</a></li>
<li><a href="http://wdxtub.com/interview/14520597851399.html">Middle of List</a></li>
<li><a href="http://wdxtub.com/interview/14520597851346.html">Merge Two Lists</a></li>
<li><a href="http://wdxtub.com/interview/14520597851075.html">Merge K Linked List</a></li>
<li><a href="http://wdxtub.com/interview/14520597851031.html">Kth to Last</a></li>
<li><a href="http://wdxtub.com/interview/14520597850990.html">Insertion Sort List</a></li>
<li><a href="http://wdxtub.com/interview/14520597850946.html">Copy List with Random Pointer</a></li>
<li><a href="http://wdxtub.com/interview/14520597850907.html">Palindrome Linked List</a></li>
<li><a href="http://wdxtub.com/interview/14520597850871.html">Check Intersection</a></li>
<li><a href="http://wdxtub.com/interview/14520597850832.html">Check Cycle</a></li>
<li><a href="http://wdxtub.com/interview/14520597850789.html">Add Two Numbers</a></li>
<li><a href="http://wdxtub.com/interview/14520607215217.html">Delete Node in a Linked List</a></li>
<li><a href="http://wdxtub.com/interview/14520607215107.html">Delete Middle Node</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>链表，作为在内存中非连续分配的数据结构，因为其灵活性往往容易出错，这里我们会通过深入理解来教大家一些解决链表问题的基本方法。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="链表" scheme="http://wdxtub.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 4 课 栈和队列]]></title>
    <link href="http://wdxtub.com/2016/01/22/programmer-startline-4/"/>
    <id>http://wdxtub.com/2016/01/22/programmer-startline-4/</id>
    <published>2016-01-22T20:51:02.000Z</published>
    <updated>2016-01-23T05:22:52.000Z</updated>
    <content type="html"><![CDATA[<p>栈和队列，因为其特殊的性质，如果巧妙利用，可以解决许多原本比较复杂的问题，而且还是 BFS 和 DFS 的基础，这一讲我们就来看看对于栈和队列的相关知识。</p>
<a id="more"></a>
<hr>
<h2 id="u89E3_u9898_u7B56_u7565"><a href="#u89E3_u9898_u7B56_u7565" class="headerlink" title="解题策略"></a>解题策略</h2><p>对于栈和队列的题目，一定要意识到这两个数据结构背后所代表的含义。</p>
<p>比方说，有一类问题有这样的特性：当前节点的解依赖后驱节点。也就是说，对于某个当前节点，如果不能获知后驱节点，就无法得到有意义的解。这类问题可以通过栈(或等同于栈的若干个临时变量)解决：先将当前节点入栈，然后看其后继节点的值，直到其依赖的所有节点都完备时，再从栈中弹出该节点求解。某些时候，甚至需要反复这个过程：将当前节点的计算结果再次入栈，直到其依赖的后继节点完备。</p>
<p>更进一步来看，只要是利用递归的过程，其实都可以去用栈来模拟，毕竟递归实际上就是一个隐式的栈调用。</p>
<p>具体解题的时候，从最基本的情况出发，根据题意推倒整个计算流程。这样做的好处是：</p>
<ol>
<li>确保自己正确地理解了题目 </li>
<li>从简单的情况出发，找找解题思路。该方法特别适用于递归，动态编程等题目类型</li>
</ol>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://wdxtub.com/interview/14520595470575.html">Evaluate Reverse Polish Notation</a></li>
<li><a href="http://wdxtub.com/interview/14520606685840.html">Implement Stack using Queues</a></li>
<li><a href="http://wdxtub.com/interview/14520606685720.html">Stack of Plates</a></li>
<li><a href="http://wdxtub.com/interview/14520606685665.html">Sort Stack</a></li>
<li><a href="http://wdxtub.com/interview/14520606685606.html">Queue of Stack</a></li>
<li><a href="http://wdxtub.com/interview/14520606685544.html">Min Stack</a></li>
<li><a href="http://wdxtub.com/interview/14520606685475.html">Max Stack</a></li>
<li><a href="http://wdxtub.com/interview/14520606685419.html">Longest Valid Parentheses</a></li>
<li><a href="http://wdxtub.com/interview/14520606685367.html">In Order Travesal with Stack</a></li>
<li><a href="http://wdxtub.com/interview/14520606685319.html">Hanoi Tower with Stack</a></li>
<li><a href="http://wdxtub.com/interview/14520606685269.html">Basic Calculator</a></li>
<li><a href="http://wdxtub.com/interview/14520606685216.html">Basic Calculator II</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>栈和队列，因为其特殊的性质，如果巧妙利用，可以解决许多原本比较复杂的问题，而且还是 BFS 和 DFS 的基础，这一讲我们就来看看对于栈和队列的相关知识。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="栈" scheme="http://wdxtub.com/tags/%E6%A0%88/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="队列" scheme="http://wdxtub.com/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 3 课 数组和字符串]]></title>
    <link href="http://wdxtub.com/2016/01/22/programmer-startline-3/"/>
    <id>http://wdxtub.com/2016/01/22/programmer-startline-3/</id>
    <published>2016-01-22T20:50:55.000Z</published>
    <updated>2016-01-23T21:47:35.000Z</updated>
    <content type="html"><![CDATA[<p>数组和字符串作为最基本的元素，涉及的知识点非常多，许多高级的应用如堆，栈，队列，动态规划等都可以基于数组，这一讲我们主要还是集中在数组本身性质的习题上。</p>
<a id="more"></a>
<hr>
<h2 id="u9898_u76EE_u5206_u7C7B_u4E0E_u89E3_u9898_u7B56_u7565"><a href="#u9898_u76EE_u5206_u7C7B_u4E0E_u89E3_u9898_u7B56_u7565" class="headerlink" title="题目分类与解题策略"></a>题目分类与解题策略</h2><p>原本以为这一章内容不会很多，但是整理资料的时候发现，我把不少稍微有些『难度』的题目，也放到了这个类别下，不过也没有问题，万事开头难，熬过这一波就好了。</p>
<p>我们先来分析一下具体的题目类型，因为很多题目万变不离其宗，只要抓住解题思路，剩下的就是时间问题了（具体的题目列表在最后的附录中），下面是几个大类的问题及对应的思路：</p>
<h3 id="u6B21_u6570_u7EDF_u8BA1"><a href="#u6B21_u6570_u7EDF_u8BA1" class="headerlink" title="次数统计"></a>次数统计</h3><p>这类题目就是哈希表大显身手的时候了，比方说找唯一出现的字母或数字，或者是统计元素出现的次数，都可以用哈希表来快速完成。因为哈希表可以做到 O(1) 时间的检索，所以效率会很高。看一次这个分类下的题目就会发现，问题的突破口往往就是找到对应的建立哈希表的方式。</p>
<p>哈希表(Hash Table)几乎是最为重要的数据结构，主要用于基于“键(key)”的查找，存储的基本元素是键-值对(key-value pair)。逻辑上，数组可以作为哈希表 的一个特例：键是一个非负整数。注意，通常哈希表会假设键是数据的唯一标识，相同的键默认表示同一个基本存储元素。</p>
<p>哈希表的本质是当使用者提供一个键，根据哈希表自身定义的哈希函数(hash function)，映射出一个下标，根据这个下标决定需要把当前的元素存储在什么位置。在一些合理的假设情况下，查找一个元素的平均时间复杂度是O(1)，插入一个元素的平摊(amortized)时间复杂度是O(1)。</p>
<p>当对于不同的键，哈希函数提供相同的存储地址时，哈希表就遇到了所谓的冲突(collision)。解决冲突的方式有链接法(chaining)和开放地址法(open addressing)两种。简单来说，链接法相当于利用辅助数据结构(比如链表)，将哈希函数映射出相同地址的那些元素链接起来。而开放地址法是指以某种持续的哈希方式继续哈希，直到产生的下标对应尚未被使用的存储地址，然后把当前元素存储在这个地址里。</p>
<p>通常而言，链接法实现相对简便，但是可能需要附加空间，并且利用当前空间的效率不如开放地址法高。开放地址法更需要合理设计的连续哈希函数，但是可以获得更好的空间使用效率。需要注意的是，过于频繁的冲突会降低哈希表的搜索效率，此时需要哈希表的扩张。</p>
<p>比较有特点的题目是：</p>
<ul>
<li><a href="http://wdxtub.com/interview/14520595478736.html">01 相等的串</a></li>
<li><a href="http://wdxtub.com/interview/14520595469735.html">Check Duplicate</a></li>
</ul>
<h3 id="u7279_u5B9A_u6A21_u5F0F"><a href="#u7279_u5B9A_u6A21_u5F0F" class="headerlink" title="特定模式"></a>特定模式</h3><p>这个类型的题目比较多变化，比方说，找回文串，子串匹配，或者是两个数组中相差最小的两个元素，又或者是字符串按照一定规则变成数字。这类问题有一个特点，就是可以很容易想出暴力解法，但是暴力解法会有很多重复运算，效率不高，于是需要进一步进行优化。具体的优化方式有很多，比方说找回文串，如果比较复杂一点的 manacher 算法没办法保证百分百写对的话，那么以每个字符为中心开始延展的方式，也是不错的做法。</p>
<p>具体来说，就是一定要清楚地知道，具体在操作的元素是哪个，以及对应的匹配关系，一开始可能会比较慢，但是熟悉了之后就好了。比较有特点的题目是：</p>
<ul>
<li><a href="http://wdxtub.com/interview/14520595479135.html">Shortest Palindrome</a></li>
<li><a href="http://wdxtub.com/interview/14520595475576.html">One Away</a></li>
<li><a href="http://wdxtub.com/interview/14520595471113.html">Gray Code</a></li>
</ul>
<h3 id="u533A_u95F4_u95EE_u9898"><a href="#u533A_u95F4_u95EE_u9898" class="headerlink" title="区间问题"></a>区间问题</h3><p>区间问题的复杂性在于，需要处理多种情况，如果不事先想好的话，很容易出错。另外就是处理区间取数的问题，会涉及到一些动态规划的思想，当然，有些问题也可以用哈希表来解决。解决问题的关键在于，一定要意识到多种情况的可能，并且在代码中做对应的处理。比较有特点的题目是：</p>
<ul>
<li><a href="http://wdxtub.com/interview/14520595473642.html">最大间隔问题</a></li>
<li><a href="http://wdxtub.com/interview/14520595476141.html">Peaks and Valleys</a></li>
<li><a href="http://wdxtub.com/interview/14520595469247.html">2 Sum</a></li>
</ul>
<h3 id="u77E9_u9635_u76F8_u5173"><a href="#u77E9_u9635_u76F8_u5173" class="headerlink" title="矩阵相关"></a>矩阵相关</h3><p>矩阵就是二维数组，具体来说，难度在于，怎么处理好两个维度的问题。具体来说，就是要看题目中有没有给出一些明显的信息，比方说排好序。写关键代码的时候，一定要列好前条件和后条件，保证不出问题。比较有特点的题目是：</p>
<ul>
<li><a href="http://wdxtub.com/interview/14520595478930.html">Set Matrix Zero</a></li>
<li><a href="http://wdxtub.com/interview/14520595479796.html">Spiral Matrix</a></li>
<li><a href="http://wdxtub.com/interview/14520595474607.html">Min Triangle Path Sum</a></li>
</ul>
<h3 id="u903B_u8F91_u64CD_u4F5C"><a href="#u903B_u8F91_u64CD_u4F5C" class="headerlink" title="逻辑操作"></a>逻辑操作</h3><p>这个类别包括的题目千奇百怪，理论上来说很难总结一个普适的规律，因为实际上就是根据特定的逻辑规则来进行操作。比方说以特定格式输出，旋转，排序，交换，合并，堆等等。因为变化太多，所以这里只能给出一个比较通用的建议：列出前条件后条件，注意每一步操作及可能带来的副作用，善于利用数据结构本身的能力。比较有特点的题目有：</p>
<ul>
<li><a href="http://wdxtub.com/interview/14520595480445.html">String Compression</a></li>
<li><a href="http://wdxtub.com/interview/14520595474265.html">Merge Two Sorted Array</a></li>
<li><a href="http://wdxtub.com/interview/14520595472329.html">Largest Number</a></li>
<li><a href="http://wdxtub.com/interview/14520595471461.html">Heapify</a></li>
</ul>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li>次数统计（唯一性，是否出现，个数相等）<ul>
<li><a href="http://wdxtub.com/interview/14520595481622.html">Unique Character</a></li>
<li><a href="http://wdxtub.com/interview/14520595480211.html">String Composition</a></li>
<li><a href="http://wdxtub.com/interview/14520595479999.html">String Comparison</a></li>
<li><a href="http://wdxtub.com/interview/14520595481118.html">Substring with Concatenation of All Words</a></li>
<li><a href="http://wdxtub.com/interview/14520595478736.html">01 相等的串</a></li>
<li><a href="http://wdxtub.com/interview/14520595477318.html">Repeated DNA Sequences</a></li>
<li><a href="http://wdxtub.com/interview/14520595476547.html">Remove Duplicates from Sorted Array</a></li>
<li><a href="http://wdxtub.com/interview/14520595476340.html">Remove Duplicates from Sorted Array II</a></li>
<li><a href="http://wdxtub.com/interview/14520595473349.html">Majority Element</a></li>
<li><a href="http://wdxtub.com/interview/14520595473082.html">Majority Element II</a></li>
<li><a href="http://wdxtub.com/interview/14520595473216.html">Majority Element III</a></li>
<li><a href="http://wdxtub.com/interview/14520595472951.html">Longest Word in Dictionary</a></li>
<li><a href="http://wdxtub.com/interview/14520595470900.html">Find Anagram</a></li>
<li><a href="http://wdxtub.com/interview/14520595470471.html">Determine String Permutation</a></li>
<li><a href="http://wdxtub.com/interview/14520595469735.html">Check Duplicate</a></li>
<li><a href="http://wdxtub.com/interview/14520595469566.html">Check Duplicate II</a></li>
<li><a href="http://wdxtub.com/interview/14520595469610.html">Check Duplicate III</a></li>
<li><a href="http://wdxtub.com/interview/14520595469690.html">Find Duplicates</a></li>
</ul>
</li>
<li>特定模式（回文串，子串，相差最少）<ul>
<li><a href="http://wdxtub.com/interview/14520595479135.html">Shortest Palindrome</a></li>
<li><a href="http://wdxtub.com/interview/14520595480652.html">Implement strStr()</a></li>
<li><a href="http://wdxtub.com/interview/14520595477901.html">Roman to Integer</a></li>
<li><a href="http://wdxtub.com/interview/14520595471853.html">Integer to Roman</a></li>
<li><a href="http://wdxtub.com/interview/14520595475576.html">One Away</a></li>
<li><a href="http://wdxtub.com/interview/14520595479365.html">Simplify File Path</a></li>
<li><a href="http://wdxtub.com/interview/14520595472570.html">Letter Combinations of a Phone Number</a></li>
<li><a href="http://wdxtub.com/interview/14520595472084.html">Isomorphic Strings</a></li>
<li><a href="http://wdxtub.com/interview/14520595471113.html">Gray Code</a></li>
<li><a href="http://wdxtub.com/interview/14520595469921.html">Palindrome Permutation</a></li>
<li><a href="http://wdxtub.com/interview/14520595469833.html">Check Palindrome</a></li>
<li><a href="http://wdxtub.com/interview/14520595469782.html">Palindrome Number</a></li>
<li><a href="http://wdxtub.com/interview/14520604914478.html">Longest Palindromic Substring</a></li>
</ul>
</li>
<li>区间问题<ul>
<li><a href="http://wdxtub.com/interview/14520595473959.html">Merge Range</a></li>
<li><a href="http://wdxtub.com/interview/14520595473642.html">最大间隔问题</a></li>
<li><a href="http://wdxtub.com/interview/14520595476141.html">Peaks and Valleys</a></li>
<li><a href="http://wdxtub.com/interview/14520595475403.html">奇偶调序</a></li>
<li><a href="http://wdxtub.com/interview/14520595474923.html">Move Zeroes</a></li>
<li><a href="http://wdxtub.com/interview/14520595471966.html">Interleaving Array</a></li>
<li><a href="http://wdxtub.com/interview/14520595472695.html">Longest Common Prefix</a></li>
<li><a href="http://wdxtub.com/interview/14520595471570.html">Insert Range</a></li>
<li><a href="http://wdxtub.com/interview/14520595469247.html">2 Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520595469329.html">3 Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520595469298.html">3 Sum Closest</a></li>
<li><a href="http://wdxtub.com/interview/14520595469361.html">4 Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520595472209.html">K Sum II</a></li>
<li><a href="http://wdxtub.com/interview/14520604916479.html">Minimum Subarray for Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520604916322.html">Minimum Window Substring</a></li>
<li><a href="http://wdxtub.com/interview/14520604914788.html">Longest Substring Without Repeating Characters</a></li>
<li><a href="http://wdxtub.com/interview/14520604914642.html">Longest Substring with K Unique Characters</a></li>
</ul>
</li>
<li>矩阵相关<ul>
<li><a href="http://wdxtub.com/interview/14520595478930.html">Set Matrix Zero</a></li>
<li><a href="http://wdxtub.com/interview/14520595479796.html">Spiral Matrix</a></li>
<li><a href="http://wdxtub.com/interview/14520595479570.html">Spiral Matrix II</a></li>
<li><a href="http://wdxtub.com/interview/14520595480877.html">Submatrix Sum Zero</a></li>
<li><a href="http://wdxtub.com/interview/14520595478302.html">Rotate Image</a></li>
<li><a href="http://wdxtub.com/interview/14520595475941.html">Pascal’s Triangle</a></li>
<li><a href="http://wdxtub.com/interview/14520595475767.html">Pascal’s Triangle II</a></li>
<li><a href="http://wdxtub.com/interview/14520595475237.html">二进制矩阵中 1 的个数</a></li>
<li><a href="http://wdxtub.com/interview/14520595474607.html">Min Triangle Path Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520595473495.html">Matrix ZigZag Traversal</a></li>
<li><a href="http://wdxtub.com/interview/14520595471005.html">Game of Life</a></li>
<li><a href="http://wdxtub.com/interview/14520595470188.html">Check Valid Sudoku</a></li>
</ul>
</li>
<li>逻辑操作（特定格式，旋转，排序，特定元素交换，合并，堆）<ul>
<li><a href="http://wdxtub.com/interview/14520595481874.html">ZigZag Conversion</a></li>
<li><a href="http://wdxtub.com/interview/14520595481376.html">Text Justification</a></li>
<li><a href="http://wdxtub.com/interview/14520595480445.html">String Compression</a></li>
<li><a href="http://wdxtub.com/interview/14520595478523.html">Rotate String</a></li>
<li><a href="http://wdxtub.com/interview/14520595478107.html">Rotate Array</a></li>
<li><a href="http://wdxtub.com/interview/14520595477695.html">Reverse Sentence</a></li>
<li><a href="http://wdxtub.com/interview/14520595477503.html">Reverse Integer</a></li>
<li><a href="http://wdxtub.com/interview/14520595477117.html">Reorder String by Case</a></li>
<li><a href="http://wdxtub.com/interview/14520595476933.html">Reorder Rotated Array</a></li>
<li><a href="http://wdxtub.com/interview/14520595476748.html">Remove Element</a></li>
<li><a href="http://wdxtub.com/interview/14520595475077.html">Multiply Strings</a></li>
<li><a href="http://wdxtub.com/interview/14520595474770.html">Modify String</a></li>
<li><a href="http://wdxtub.com/interview/14520595474265.html">Merge Two Sorted Array</a></li>
<li><a href="http://wdxtub.com/interview/14520595474103.html">Sorted Two Sorted Array II</a></li>
<li><a href="http://wdxtub.com/interview/14520595473794.html">Median of Unsorted Array</a></li>
<li><a href="http://wdxtub.com/interview/14520595472449.html">Length of Last Word</a></li>
<li><a href="http://wdxtub.com/interview/14520595472329.html">Largest Number</a></li>
<li><a href="http://wdxtub.com/interview/14520595471740.html">Integer to English Words</a></li>
<li><a href="http://wdxtub.com/interview/14520595471461.html">Heapify</a></li>
<li><a href="http://wdxtub.com/interview/14520595471345.html">H-Index</a></li>
<li><a href="http://wdxtub.com/interview/14520595471233.html">H-Index II</a></li>
<li><a href="http://wdxtub.com/interview/14520595470785.html">Excel Sheet Column Title</a></li>
<li><a href="http://wdxtub.com/interview/14520595470670.html">Excel Sheet Column Number</a></li>
<li><a href="http://wdxtub.com/interview/14520595470378.html">Count and Say</a></li>
<li><a href="http://wdxtub.com/interview/14520595470276.html">Compare Version Numbers</a></li>
<li><a href="http://wdxtub.com/interview/14520595470088.html">Check Valid Number</a></li>
<li><a href="http://wdxtub.com/interview/14520595469517.html">Candy</a></li>
<li><a href="http://wdxtub.com/interview/14520595469475.html">Binary to String</a></li>
<li><a href="http://wdxtub.com/interview/14520595469437.html">Add One</a></li>
<li><a href="http://wdxtub.com/interview/14520595469400.html">Add Binary</a></li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>数组和字符串作为最基本的元素，涉及的知识点非常多，许多高级的应用如堆，栈，队列，动态规划等都可以基于数组，这一讲我们主要还是集中在数组本身性质的习题上。</p>]]>
    
    </summary>
    
      <category term="字符串" scheme="http://wdxtub.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="数组" scheme="http://wdxtub.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 2 课 Big O 分析]]></title>
    <link href="http://wdxtub.com/2016/01/22/programmer-startline-2/"/>
    <id>http://wdxtub.com/2016/01/22/programmer-startline-2/</id>
    <published>2016-01-22T20:50:51.000Z</published>
    <updated>2016-01-22T23:08:08.000Z</updated>
    <content type="html"><![CDATA[<p>前一讲大概了解了这个系列会涉及的内容，这一讲就从最重要的概念，Big O 开始讲起。既然我们要找到效率更高的算法，首先就得知道，怎么样才是高效率。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u672C_u6CD5_u5219"><a href="#u57FA_u672C_u6CD5_u5219" class="headerlink" title="基本法则"></a>基本法则</h2><p>我们先来了解一下程序分析的基本法则。一般来说，常见的输入输出以及简单的赋值语句，可以认为时间复杂度是 O(1)。在算复杂度的时候乘以一个常数复杂度不变，即 $O(Cf(n)) = O(f(n))$，其中C是一个正常数。</p>
<p>我们知道，程序设计中无非是三种形态：顺序，选择和循环，只要能够算清楚这三种形态的复杂度，那么整个算法的复杂度也就不在话下了。</p>
<p>先来看看顺序结构，因为是顺序执行，所以可以通过求和法则来进行计算。若算法的 2 个部分时间复杂度分别为 $T1(n)=O(f(n))$ 和 $T2(n)=O(g(n))$,则 $T1(n)+T2(n)=O(max(f(n), g(n)))$。如果这两个部分的参数不一样的话，即 $T1(m)=O(f(m))$ 和 $T2(n)=O(g(n))$,则 $T1(m)+T2(n)=O(f(m) + g(n))$</p>
<p>然后是选择结构，选择本身判断是耗费 O(1) 时间的，但是主要时间还是在执行不同的子句上，所以转换为分析子句的时间复杂度。</p>
<p>最后来看看循环结构，一般来说可能包括多次循环，所以使用乘法法则。若算法的2个部分时间复杂度分别为 $T1(n)=O(f(n))$ 和 $T2(n)=O(g(n))$,则 $T1 \times T2=O(f(n) \times g(n))$ 。</p>
<p>基本上理解了什么时候用求和法则，什么时候用乘法法则，再加上一点点运算，就可以推算出时间复杂度了。</p>
<h2 id="u9012_u5F52"><a href="#u9012_u5F52" class="headerlink" title="递归"></a>递归</h2><p>递归问题应该算是求复杂度问题中比较麻烦的了，并不像其他非递归的算法可以用上面提到的基本法则来进行分析。一般来说，遇到递归问题，有两种做法：</p>
<ol>
<li>主定理法</li>
<li>递归树法</li>
</ol>
<p>实际上主定理法可以看作是递归树法的一个总结，这里用一个例子来说明，假设我们的递归函数是：$T(n) = T(\frac{n}{3}) + T(\frac{2n}{3}) + n$，那么画出递归树就是：</p>
<p><img src="/images/14535025616030.jpg" alt=""></p>
<p>每层都会多出来一个 n，而从根到叶节点的最长路径是：$n \to \frac{2}{3}n \to (\frac{2}{3})^2n \to \dots \to 1$，假设一共有 k 层，因为 $(\frac{2}{3})^kn = 1$，所以  $k=log_{3/2}n$ ，也就是说  $T(n) \le \sum_{i=0}^k n = (k+1)n = n(log_{3/2}n+1 )$  ，即 $T(n) = O(nlog\;n)$</p>
<p>我们来看看用主定理方法的话，这个复杂度要怎么算。首先我们要把递推公式转换为如下形式：</p>
<p>$$f(n)=af(\frac{n}{b}) + d(n)$$</p>
<p>然后分情况进行讨论：</p>
<p><img src="/images/14535029849534.jpg" alt=""></p>
<p>而这题中 $T(n) = T(\frac{n}{3}) + T(\frac{2n}{3}) + n$，化简之后相当于 $a=3,b=3$，于是在第二种情况中找到 $a=b$ 的情况，就得到了最后的结果 $O(nlog\; n)$</p>
<h2 id="u4F8B_u9898"><a href="#u4F8B_u9898" class="headerlink" title="例题"></a>例题</h2><p>这里主要是提及一些容易出错的地方。</p>
<blockquote>
<p>不是出现了树结构，就一定会产生 log 的复杂度</p>
</blockquote>
<p>假设代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum(node.left) + node.value + sum(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为实际上是遍历所有的节点一次，于是复杂度是 O(n)</p>
<blockquote>
<p>有的时候可以通过这个代码的做用来进行复杂度判断</p>
</blockquote>
<p>来看看下面这两个代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 片段 1</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">2</span>; x * x &lt;= n; x++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % x == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permuation</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    permutation(str, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(String str, String prefix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">            String rem = str.substring(<span class="number">0</span>,i) + str.substring(i+<span class="number">1</span>);</span><br><span class="line">            permutation(rem, prefix + str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一题比较简单，因为是求质数，在 $\sqrt n$ 时间就可以完成，对应的时间复杂也就是出来了。</p>
<p>第二题做得是一个全排列，可以从两个思路：What It Means 和 What It Does。</p>
<ul>
<li>What It Means：因为是求排列，如果一个字符串有n个字符，那么所有的可能为 <code>n*(n-1)*...*2*1 -&gt; O(n!)</code></li>
<li>What It Does：设一共有 n 个字符，第一次循环，有 n 次递归调用，第二次有 n-1 次，到最后一共有 <code>n*(n-1)*...*2*1 -&gt; O(n!)</code></li>
</ul>
<p>最后再举一个递归的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里每一次递归，都会由原来的一个分成两个，而一共有 n 层，于是时间复杂度为 $O(2^N)$</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>当然，很多时候还需要具体问题具体分析，最关键的，是对算法过程的清晰理解和掌握，有了这个，哪怕从头开始一点一点分析，也可以推导出正确答案。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前一讲大概了解了这个系列会涉及的内容，这一讲就从最重要的概念，Big O 开始讲起。既然我们要找到效率更高的算法，首先就得知道，怎么样才是高效率。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第二周 - Welcome]]></title>
    <link href="http://wdxtub.com/2016/01/22/welcome/"/>
    <id>http://wdxtub.com/2016/01/22/welcome/</id>
    <published>2016-01-22T17:48:32.000Z</published>
    <updated>2016-01-22T20:35:00.000Z</updated>
    <content type="html"><![CDATA[<p>Ain’t no way to shut me down. Or to take the path I’ve taken.</p>
<a id="more"></a>
<hr>
<p>第二周算是完全进入了状态，各项工作都在有条不紊地推进中，去西雅图和三藩的行程确定了下来，准备加入一个 Swift 的翻译小组，甚至还申请当助教，加上之前所说的『微小的工作』，这个学期真的算是有史以来最火力全开的了。</p>
<p>按照以往的经验，这种高强度的工作通常持续不了太久，不过这周去吃了一次海鲜自助餐，算是大大满足了一番，真是无论如何，美酒美食，不能停止了供应。</p>
<p>很让自己高兴的一点是慢慢开始从更长远的角度去考虑问题和指定计划了。比方说，高中时候写日志大多是流水账，之后可能稍微有一些主题，但是比较零散，但是现在开始谋划一个大主题，然后分成不同的小主题，逐个写完，组合起来能发挥比以前单篇文章更大的效果。而一个个主题又是为了更大的目标而努力，这种垒积木居然还蛮有意思的。感觉像是散兵游勇终于凑到一起，训练了一两年，成了正规军了。</p>
<p>但是正规军也不是啥都好，少了些灵气，就我现在来说，还是更喜欢李云龙独立团那种血性，年轻人还是要敢打敢拼一点，可能欠缺些考虑甚至有点鲁莽，那也要比永远留在安全舒适区来得好。</p>
<p>想做的能做的事情还有很多，摩拳擦掌，蓄势待发。（因为本周末的寒潮+大雪，估计只能在家多发文章了，哈哈）</p>
<p>And maybe I’ve been left out. Never let this be mistaken.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Ain’t no way to shut me down. Or to take the path I’ve taken.</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="改变" scheme="http://wdxtub.com/tags/%E6%94%B9%E5%8F%98/"/>
    
      <category term="面试" scheme="http://wdxtub.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 1 课 总览]]></title>
    <link href="http://wdxtub.com/2016/01/22/programmer-startline-1/"/>
    <id>http://wdxtub.com/2016/01/22/programmer-startline-1/</id>
    <published>2016-01-22T14:35:39.000Z</published>
    <updated>2016-01-23T00:59:34.000Z</updated>
    <content type="html"><![CDATA[<p>学了这么多年计算机和编程，在快要步入社会之前，在不断地碰壁和尝试之后，终于摸到了一点门路。这个系列的文章，更接近于编程入门指南，讲的是从数据结构到算法最终到解决问题的方法和思路。</p>
<a id="more"></a>
<hr>
<p>我想，对于大多数经历过或者正在经历从校园转入社会的人来说，找工作本身就是一个很好的学习过程。如果想要成为一个程序员，尤其是在北美的话，那么刷题（也就是做各种数据结构算法的题目）就是必不可少的了，颇有应试教育的味道。</p>
<p>学习并不是为了考试，可是分数是简单粗暴评判学习效果的方法；编程并不是为了刷题，可是能否给出解答是简单粗暴评判编程水平的方法。虽然不合理不科学，但是在人力物力有限的条件下，这就是游戏规则。</p>
<p>在这个过程中，你会发现，聪明人，或者说善于学习的人，很快就会从应试模式转变为探索模式。题目背后是知识，不同的知识点交织成为学科，死记硬背只能解决见过的问题，但是如果在这个过程中培养了逻辑推理的能力，哪怕遇到一个『新』问题，也能通过类比，找到用『旧』方法稍微变化就可以解决的途径。</p>
<p>如果了解了计算机发展的历史，就会发现，所有现在看起来非常复杂的东西，都是建立在非常简单的基础——零和一——之上的。从最简单的基本类型，到数据结构和算法，通通都是为了解决实际问题而产生的高效解决方案。的确，无论是计算机科学，还是编程，都是非常大的话题，但是并不意味着起跑会很难。在我看来，需要了解的内容，大概有下面这几类（这里参考了 Google 面试指南的部分内容）：</p>
<ol>
<li>掌握一门基本的编程语言。最好是强类型，支持面向对象编程（比如 C++/Java/C#）的语言。这里说的掌握，不仅仅是语法，而是对语言本身的一些设计特点和具体实现方式的理解。</li>
<li>能够以 Big O 的方式去分析一个算法的时间/空间复杂度，这样才有一个标准的方式去分析算法的效率。</li>
<li>基本数据结构的理解和使用，比如<ul>
<li>哈希表 Hashtable，及其背后所代表的哈希的思想是如何应用的不同问题的，如果只能用数组来实现，要如何实现</li>
<li>树 Tree，    树的构建(trie)，遍历和修改。遍历包括 BFS 和 DFS（前序中序后序），及其对应的思想。如果了解至少一种平衡树（及实现方式）就更好了。</li>
<li>图 Graph，图的三种表达方式及优缺点，基本的遍历算法（还是 BFS 和 DFS），知道这些算法的复杂度以及权衡利弊。如果了解一些如 Dijkstra 和 A* 算法就更好了。</li>
<li>其他的数据结构：堆栈队列链表</li>
</ul>
</li>
<li>基本算法的理解和使用，比如排序和搜索，以及递归和动态规划。nlogn 时间的排序，logn 时间的搜索。以及了解什么是 NP 问题（旅行商等等）。</li>
<li>基本的数学知识，排列组合及概率，和一些公式化简。这里可能还可以算上正则表达式。</li>
<li>操作系统，编译器，及计算机系统的基本知识。比如说进程线程，互斥锁信号量，死锁出现的条件及如何避免，进程线程的资源和上下文切换，多核处理的相关知识。重要的是对计算机相关工具的理解，除了上面提到的，还有 shell 之类的用法。</li>
<li>基本的设计能力。面向对象设计，代码风格及优化。</li>
<li>如何清晰表达自己的想法，去快速构建一个问题的解决方案。</li>
</ol>
<p>还是那句话，刷题仅仅只是一个效率很低的练习过程，真正的学习是进行『刻意练习』，也是我这个系列文章中想要强调的内容。</p>
<p>一通百通，悟道之后就会发现，一招一式固然重要，但那些都是基础，更重要的是解决问题的方法和思路，这，可能就需要多动一点脑子了。</p>
<p>最后说一下大概的写作内容的范围：</p>
<ul>
<li>正文部分力争简明扼要，说重点，说思想，注意语言逻辑和风格</li>
<li>不贴大段的代码，而是会在文章最后给出题目分类及对应链接</li>
<li>会挑选重点，经典题目进行思路讲解</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>学了这么多年计算机和编程，在快要步入社会之前，在不断地碰壁和尝试之后，终于摸到了一点门路。这个系列的文章，更接近于编程入门指南，讲的是从数据结构到算法最终到解决问题的方法和思路。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 9 课 Machine Advanced]]></title>
    <link href="http://wdxtub.com/2016/01/21/csapp-9/"/>
    <id>http://wdxtub.com/2016/01/21/csapp-9/</id>
    <published>2016-01-22T00:16:21.000Z</published>
    <updated>2016-01-22T20:35:42.000Z</updated>
    <content type="html"><![CDATA[<p>这一讲是机器代码的最后一部分，会介绍一些『高级』话题，比如程序在内存中的组织，缓冲区溢出引起的攻防大战，以及 Union 的具体实现方式。</p>
<a id="more"></a>
<hr>
<p>我们先来看看程序在内存中是如何组织的（x86-64 Linux）：</p>
<p><img src="/images/14534337498107.jpg" alt=""></p>
<p>最上面是运行时栈，有 8MB 的大小限制，一般用来保存局部变量。然后是堆，动态的内存分配会在这里处理，例如 <code>malloc()</code>, <code>calloc()</code>, <code>new()</code> 等。然后是数据，指的是静态分配的数据，比如说全局变量，静态变量，常量字符串。最后是共享库等可执行的机器指令，这一部分是只读的。</p>
<p>看个具体分配的例子：</p>
<p><img src="/images/14534340388277.jpg" alt=""></p>
<p>经过观察大概是这样的：</p>
<p><img src="/images/14534340592122.jpg" alt=""></p>
<p>这里注意一点，分配堆的时候是两头分配的，到中间相遇的时候就说明没有空间了，具体是怎么在两头分配的呢？老师也表示不知道。</p>
<h2 id="Buffer_Overflow"><a href="#Buffer_Overflow" class="headerlink" title="Buffer Overflow"></a>Buffer Overflow</h2><p>缓冲区溢出需要注意两个方面，一是为什么会产生这种情况，二是在黑客利用这种漏洞来进行攻击时，能够怎么防范。</p>
<p>先看看之前提到过的例子：</p>
<p><img src="/images/14534345803640.jpg" alt=""></p>
<p>之所以会产生这种错误，是因为访问内存的时候跨过了数组本身的界限修改了 d 的值：</p>
<p><img src="/images/14534346212614.jpg" alt=""></p>
<p>你没看错，这是个大问题！#1 technical cause of security vulnerabilities! #1 overall cause is social enginnering / user ignorance!</p>
<p>如果不检查输入字符串的长度，就很容易出现这种问题，尤其是针对在栈上有界限的字符数组。</p>
<p>在 Unix 中，<code>gets()</code> 函数的实现是这样的：</p>
<p><img src="/images/14534348853894.jpg" alt=""></p>
<p>可以看到并没有去检测最多能读入多少字符（于是很容易出问题），类似的情况还在 <code>strcpy</code>, <code>strcat</code>, <code>scanf</code>, <code>fscanf</code>, <code>sscanf</code> 中出现。比如说</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">4</span>]; <span class="comment">// 太小</span></span><br><span class="line">	gets(buf);</span><br><span class="line">	<span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_echo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	echo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们输入一长串，可以看到：</p>
<p><img src="/images/14534352714657.jpg" alt=""></p>
<p>为什么命名只给了 4 个 char，居然一开始输入这么多都没问题？我们到汇编代码里去看看：</p>
<p><img src="/images/14534354107024.jpg" alt=""></p>
<p>可以看到实际上是给 %rsp 分配了 0x18 的空间的。</p>
<p><img src="/images/14534362980014.jpg" alt=""></p>
<p>在调用之前，可以看到内存的摆放是这样的，但是调用了 <code>call_echo</code> 之后，就变成：</p>
<p><img src="/images/14534363898271.jpg" alt=""></p>
<p>虽然缓冲区溢出了，但是并没有损害当前的状态，程序还是可以继续运行（也就是没有出现段错误），但是如果再多一点的话：</p>
<p><img src="/images/14534366083059.jpg" alt=""></p>
<p>就把返回地址给覆盖掉了，但是段错误之后发现还可以继续运行，是因为返回代码会返回到 <code>main</code> 中，和具体的地址无关：</p>
<p><img src="/images/14534367016302.jpg" alt=""></p>
<p>在这个例子中没有问题，但是在下面的例子中，就会出问题了</p>
<p><img src="/images/14534367347277.jpg" alt=""></p>
<p>原本函数 P 的返回地址是 A，但是因为 Buffer 一直在被写，直接改到了 P 的栈帧，那么之后跳转就会跳转到奇怪的地方了。</p>
<p>那么我们现在来看看，怎么处理缓冲区溢出攻击，有几种方式：</p>
<ol>
<li>好好写代码，尽量不让缓冲区异常</li>
<li>程序容易出问题，那么提供系统层级的保护</li>
<li>编译器也可以来个认证(stack canaries)</li>
</ol>
<p>第一种，避免缓冲区溢出，我们用更安全的方法，如：<code>fgets</code>, <code>strncpy</code> 等等。</p>
<p>第二种，栈的位置不确定，让缓冲区溢出没办法影响到，并且每次位置都不一样，就不怕被暴力破解：</p>
<p><img src="/images/14534373336480.jpg" alt=""></p>
<p>并且也可以把一段内存标记为只读，那么就避免因为缓冲区溢出而导致的重写。</p>
<p>第三种，使用 Stack Canaries。简单来说，就是在超出缓冲区的位置加一个特殊的值，如果发现这个值变化了，那么就知道出问题了。</p>
<p>但是，除了缓冲区溢出，还有另一种攻击的方式，就是把返回的位置给改了。可以利用修改已有的代码，来绕过系统和编译器的保护机制。这里就不详细展开了。</p>
<h2 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h2><p>和结构体对应的一种结构，但是其实我在编程的时候感觉不是非常常见，这里简单了解下实现原理：</p>
<p><img src="/images/14534375732251.jpg" alt=""></p>
<p>具体的拜访可以是：</p>
<p><img src="/images/14534376064591.jpg" alt=""></p>
<p>下面是三种不同系统上的排布：</p>
<p><img src="/images/14534376440995.jpg" alt=""></p>
<p><img src="/images/14534376568110.jpg" alt=""></p>
<p><img src="/images/14534376658164.jpg" alt=""></p>
<p>这一讲的内容就到这里，下一讲是非常有趣的关于如何优化代码的内容，我自己都很期待。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一讲是机器代码的最后一部分，会介绍一些『高级』话题，比如程序在内存中的组织，缓冲区溢出引起的攻防大战，以及 Union 的具体实现方式。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 8 课 Machine Data]]></title>
    <link href="http://wdxtub.com/2016/01/21/csapp-8/"/>
    <id>http://wdxtub.com/2016/01/21/csapp-8/</id>
    <published>2016-01-21T16:16:14.000Z</published>
    <updated>2016-01-22T20:35:47.000Z</updated>
    <content type="html"><![CDATA[<p>上一讲我们了解了过程调用是如何用机器代码实现的，这一讲我们来看看基本的数据是如何存储在计算机中的。</p>
<a id="more"></a>
<hr>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>数组其实就是连续分配的地址空间，比如说 <code>T A[L]</code>，意思就是类型 T 且长度为 L 的数组，需要分配 <code>L*sizeof(T)</code> 个字节的空间。</p>
<p><img src="/images/14534188845612.jpg" alt=""></p>
<p>既然是连续的地址空间，就有很多不同的访问方式，举个例子：</p>
<p><img src="/images/14534189454190.jpg" alt=""></p>
<p>那么对应的一些访问方式为：</p>
<p><img src="/images/14534189637879.jpg" alt=""></p>
<p>再举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> ZLEN <span class="number">5</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> zip_dig[ZLEN];</span><br><span class="line"></span><br><span class="line">zip_dig cmu = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/14534198336930.jpg" alt=""></p>
<p>假设我们要取数组中的某一位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_digit</span><span class="params">(zip_dig z, <span class="keyword">int</span> digit)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> z[digit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码是：</p>
<p><img src="/images/14534198966151.jpg" alt=""></p>
<p>这里寄存器 %rdi 中存着数组的起始地址，寄存器 %rsi 存着序号，我们要访问的地址等价于 <code>%rdi + 4*%rsi</code>，用内存引用的方式就是 <code>(%rdi, %rsi, 4)</code>。</p>
<p>再看一个数组循环的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zincr</span><span class="params">(zip_dig z)</span></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ZLEN; i++)</span><br><span class="line">		z[i]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编是，注意红字的部分，相当于等价实现了 <code>++</code> 操作</p>
<p><img src="/images/14534201884816.jpg" alt=""></p>
<p>对于多维的数组，基本形式是 <code>T A[R][C]</code>，R 是行，C 是列，如果类型 T 占 K 个字节的话，那么数组所需要的内存是 <code>R*C*K</code> 字节。具体在内存里的排列方式如下：</p>
<p><img src="/images/14534202945733.jpg" alt=""></p>
<p>多维数组的第一维可以看作是每行起始的地址：</p>
<p><img src="/images/14534203418848.jpg" alt=""></p>
<p>因为如此，所以访问可以是这样的：</p>
<p><img src="/images/14534205890785.jpg" alt=""></p>
<p>这里 <code>pgh[index][dig]</code> 是 int 类型。地址 <code>pgh + 20*index + 4*dig = pgh + 4*(5*index + dig)</code>。</p>
<p>还有另外一种组合数组的方式，不是连续分配，而是存储每个数组的起始地址，例如：</p>
<p><img src="/images/14534208481488.jpg" alt=""></p>
<p><img src="/images/14534208616228.jpg" alt=""></p>
<p>获取具体某个元素的地址其实就是计算时的起始地址有变换，对应的代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_univ_digit</span><span class="params">(size_t index, size_t digit)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> univ[index][digit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编为：</p>
<p><img src="/images/14534209862505.jpg" alt=""></p>
<p>这里等同于进行两次内存访问 <code>Mem[Mem[univ+8*index]+4*digit]</code>，</p>
<p>对比一下</p>
<p><img src="/images/14534218752318.jpg" alt=""></p>
<p>在 C 语言中看起来差不多，但是实际上差别很大：</p>
<p><code>Mem[pgh+20*index+4*digit]</code> vs <code>Mem[Mem[univ+8*index]+4*digit]</code></p>
<h2 id="Structures"><a href="#Structures" class="headerlink" title="Structures"></a>Structures</h2><p>结构体是如何表示的呢，大概是这样：</p>
<p><img src="/images/14534222886026.jpg" alt=""></p>
<p>这里我们发现刚好都是 4 的倍数，如果换一种方式来组合，会是怎么样的呢？会像下图这样吗？</p>
<p><img src="/images/14534225034162.jpg" alt=""></p>
<p>答案是，并不会，会在内存中进行对齐：</p>
<p><img src="/images/14534225338581.jpg" alt=""></p>
<p>具体对齐的原则是，如果 primitive data type 需要 K 个字节，那么地址都必须是 K 的倍数。为什么要这样呢，因为内存访问通常来说是 4 或者 8 个字节位单位的，不对齐的话访问起来效率不高。具体来看的话，是这样：</p>
<ul>
<li>1 字节：char, …<ul>
<li>没有地址的限制</li>
</ul>
</li>
<li>2 字节：short, …<ul>
<li>地址最低的 1 比特必须是 $0_2$</li>
</ul>
</li>
<li>4 字节：int, float, …<ul>
<li>地址最低的 2 比特必须是 $00_2$</li>
</ul>
</li>
<li>8 字节：double, long, char *, …<ul>
<li>地址最低的 3 比特必须是 $000_2$</li>
</ul>
</li>
<li>16 字节：long double (GCC on Linux)<ul>
<li>地址最低的 4 比特必须是 $0000_2$</li>
</ul>
</li>
</ul>
<p>对于一个结构体来说，所占据的内存空间必须是最大的类型所需字节的倍数，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> S2 &#123;</span><br><span class="line">	<span class="keyword">double</span> v;</span><br><span class="line">	<span class="keyword">int</span> i[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure>
<p><img src="/images/14534232756482.jpg" alt=""></p>
<p>如果是结构体数组的话，那就是像这样：</p>
<p><img src="/images/14534233087461.jpg" alt=""></p>
<p>具体到访问结构体中的例子，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> S3 &#123;</span><br><span class="line">	<span class="keyword">short</span> i;</span><br><span class="line">	<span class="keyword">float</span> v;</span><br><span class="line">	<span class="keyword">short</span> j;</span><br><span class="line">&#125; a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p><img src="/images/14534233625482.jpg" alt=""></p>
<p>那么根据这种特点，就有一些技巧了。例如，要把大的数据类型放到前面，看这个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> S4 &#123;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> d;</span><br><span class="line">&#125; *p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> S5 &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">char</span> d;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure>
<p>那么这两种的对应排列就是：</p>
<p><img src="/images/14534240460958.jpg" alt=""></p>
<p>可以看到，下面那种省了 4 个字节。</p>
<h2 id="Floating_Point"><a href="#Floating_Point" class="headerlink" title="Floating Point"></a>Floating Point</h2><p>浮点数的部分在课上介绍的不是很多，这里简要介绍一下。</p>
<p>最开始是 x87 FP（比较丑陋），之后是 SSE FP（利用了向量指令），然后是 AVX FP（类似与 SSE）。</p>
<p>SSE3 对于 XMM 寄存器一共有 16 个，每个 16 字节：</p>
<p><img src="/images/14534252071793.jpg" alt=""></p>
<p>下面是对标量和 SIMD 操作的描述：</p>
<p><img src="/images/14534254596599.jpg" alt=""></p>
<p>具体的机制也是类似的，传入的参数存储在 %xmm0, %xmm1，返回参数在 %xmm0，所有的 XMM 寄存器都会被保存在调用者的栈帧中：</p>
<p><img src="/images/14534255846801.jpg" alt=""></p>
<p>这一讲到此结束，之后会进入更深入的话题（因为作业大概两到三周一次，所以可能先把重点放在概念的理解上）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一讲我们了解了过程调用是如何用机器代码实现的，这一讲我们来看看基本的数据是如何存储在计算机中的。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 7 课 Machine Procedures]]></title>
    <link href="http://wdxtub.com/2016/01/21/csapp-7/"/>
    <id>http://wdxtub.com/2016/01/21/csapp-7/</id>
    <published>2016-01-21T16:15:37.000Z</published>
    <updated>2016-01-22T20:35:51.000Z</updated>
    <content type="html"><![CDATA[<p>之前我们学习了机器是如何利用跳转实现流程控制的，这一讲我们来看一个更加复杂的机制：过程调用（也就是调用函数）具体在 CPU 和内存中是怎么实现了。理解之后，对于递归会有更加清晰的认识。</p>
<a id="more"></a>
<hr>
<p>在过程调用中主要涉及三个重要的方面：</p>
<ol>
<li>传递控制：包括如何开始执行过程代码，以及如何返回到开始的地方</li>
<li>传递数据：包括过程需要的参数以及过程的返回值</li>
<li>内存管理：如何在过程执行的时候分配内存，以及在返回之后释放内存</li>
</ol>
<p>以上这三点，都是凭借机器指令实现的</p>
<h2 id="Stack_Structure"><a href="#Stack_Structure" class="headerlink" title="Stack Structure"></a>Stack Structure</h2><p>在 x86-64 中，所谓的栈，实际上一块内存区域，这个区域的数据进出满足先进后出的原则。越新入栈的数据，地址越低，所以栈顶的地址是最小的。下图中箭头所指的就是寄存器 %rsp 的值，这个寄存器是栈指针，用来记录栈顶的位置。</p>
<p><img src="/images/14533820160341.jpg" alt=""></p>
<p>对于 <code>push</code> 操作，对应的是 <code>pushq Src</code> 指令，具体会完成下面三个步骤：</p>
<ol>
<li>从地址 <code>Src</code> 中取出操作数</li>
<li>把 %rsp 中的地址减去 8（也就是到下一个位置）</li>
<li>把操作数写入到 %rsp 的新地址中 </li>
</ol>
<p>如下图所示：</p>
<p><img src="/images/14533823825128.jpg" alt=""></p>
<p>对于 <code>pop</code> 操作，对应的是 <code>popq Dest</code> 指令，具体会完成下面三个步骤：</p>
<ol>
<li>从 %rsp 中存储的地址中读入数据</li>
<li>把 %rsp 中的地址增加 8（回到上一个位置）</li>
<li>把刚才取出来的值放到 <code>Dest</code> 中（这里必须是一个寄存器）</li>
</ol>
<p>如下图所示：</p>
<p><img src="/images/14533826092815.jpg" alt=""></p>
<h2 id="Calling_Conventions"><a href="#Calling_Conventions" class="headerlink" title="Calling Conventions"></a>Calling Conventions</h2><p>了解了栈的结构之后，我们先通过一个函数调用的例子，来感受一下（代码中有详细注释，请理解后再继续）：</p>
<p><img src="/images/14533827066202.jpg" alt=""></p>
<p>可以看到，过程调用是利用栈来进行的，通过 <code>call label</code> 来进行调用（先把返回地址入栈，然后跳转到对应的 label），返回的地址，将是下一条指令的地址，通过 <code>ret</code> 来进行返回（把地址从栈中弹出，然后跳转到对应地址）</p>
<p>用上面的代码来做说明：</p>
<p><img src="/images/14533831060878.jpg" alt=""></p>
<p>在执行到 400544 那一行的时候 %rsp 指向栈顶（存储着栈顶的地址），%rip 指向当前要执行的指令（也就是 400544）</p>
<p><img src="/images/14533832007622.jpg" alt=""></p>
<p>在上一步操作完成之后，因为跳转的关系，%rip 指向 mult2 函数开始的地方（也就是 400550），之前的压栈操作也使得栈顶改变（返回值的位置），于是 %rsp 对应进行改变。</p>
<p><img src="/images/14533833724077.jpg" alt=""></p>
<p>接着执行到了 <code>retq</code> 那句，这个时候要做的就是从栈中取出栈顶位置（这样就可以从跳转处继续了），然后对寄存器做对应的修改，最后得到下图：</p>
<p><img src="/images/14533834735407.jpg" alt=""></p>
<p>具体的传值我们可以发现，是利用 %rax 来保存过程调用的返回值，以便程序继续运行的。这就是基本的过程调用的控制流程。</p>
<p>那么过程调用的参数会放在哪里呢？</p>
<p>如果参数没有超过六个，那么会放在：%rdi, %rsi, %rdx, %rcx, %r8, %r9 中。如果超过了，会另外放在一个栈中。而返回值会放在 %rax 中。</p>
<p>还是刚才的例子，看看数据的存放：</p>
<p><img src="/images/14533838086805.jpg" alt=""></p>
<p>既然是利用栈来进行函数调用，自然而然就可以推广到递归的情况，而对于每个过程调用来说，都会在栈中分配一个帧 Frames。每一帧里需要包含：</p>
<ul>
<li>返回信息</li>
<li>本地存储（如果需要）</li>
<li>临时空间（如果需要）</li>
</ul>
<p>整一帧会在过程调用的时候进行空间分配，然后在返回时进行回收，如下图所示（箭头所指位栈顶）：</p>
<p><img src="/images/14533842524928.jpg" alt=""></p>
<p>这里是一个调用的例子：</p>
<p><img src="/images/14533843491372.jpg" alt=""></p>
<p>在 x86-64/Linux 中，栈帧的结构是固定的，当前的要执行的栈中包括：</p>
<ul>
<li>Argument Build: 需要使用的参数</li>
<li>如果不能保存在寄存器中，会把一些本地变量放在这里</li>
<li>已保存的寄存器上下文</li>
<li>老的栈帧的指针（可选）</li>
</ul>
<p>而调用者的栈帧则包括：</p>
<ul>
<li>返回地址（因为 <code>call</code> 指令被压入栈的）</li>
<li>调用所需的参数</li>
</ul>
<p>具体如下图所示：</p>
<p><img src="/images/14533846615880.jpg" alt=""></p>
<p>下面用一个程序来说明一下，就比较清晰了：</p>
<p><img src="/images/14533847155070.jpg" alt=""></p>
<p>在函数调用前，需要移动 %rsp 指针存入调用者的变量压入栈中</p>
<p><img src="/images/14533848182706.jpg" alt=""></p>
<p>具体调用的时候，会根据返回值对应修改地址和数据。</p>
<p>寄存器保存数值的时候也有一些习惯的用法，这里也举个例子说明：</p>
<p><img src="/images/14533849340898.jpg" alt=""></p>
<p>这里的 <code>yoo</code> 被称为调用者 caller，<code>who</code> 被称为被调用者 callee。于是就有一个问题，能不能用寄存器（这里是 %rdx）来保存临时变量呢？</p>
<p>似乎不大可以，因为在两个函数中都进行了修改，所以在这之前需要做一些额外的操作。对于调用者来说，需要把临时变量保存在栈帧中，然后进行调用；对于被调用者来说，可以在栈帧中保存临时变量，但是在返回的时候需要恢复成原来的样子（让调用者继续工作）</p>
<p>一般来说用法是这样的：</p>
<p><img src="/images/14533857001617.jpg" alt=""></p>
<p>这里的变量都会被保存到 caller 的栈帧中（因为可能之后会被修改）</p>
<p><img src="/images/14533857595809.jpg" alt=""></p>
<p>除了 %rsp 外，这里都会保存在 callee 的栈帧中，并且在调用完成之后需要恢复成原来的数值。</p>
<h2 id="u9012_u5F52_u7684_u63CF_u8FF0"><a href="#u9012_u5F52_u7684_u63CF_u8FF0" class="headerlink" title="递归的描述"></a>递归的描述</h2><p>有了前面的的基础，要理解递归就简单很多了，直接上例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pcount_r</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> (x &amp; <span class="number">1</span>) + pcount_r(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码为：</p>
<p><img src="/images/14533859204097.jpg" alt=""></p>
<p>实际执行的过程中，会不停进行压栈，知道最后返回，所以递归本身就是一个隐式的栈实现，但是系统一般对于栈的深度有限制（每次一都需要保存当前栈帧的各种数据），所以一般来说会把递归转换成显式栈来进行处理以防溢出。</p>
<p>这一讲的内容就这么多，需要好好理解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前我们学习了机器是如何利用跳转实现流程控制的，这一讲我们来看一个更加复杂的机制：过程调用（也就是调用函数）具体在 CPU 和内存中是怎么实现了。理解之后，对于递归会有更加清晰的认识。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 第 9 课 Sequential Programming]]></title>
    <link href="http://wdxtub.com/2016/01/20/cc-9/"/>
    <id>http://wdxtub.com/2016/01/20/cc-9/</id>
    <published>2016-01-20T20:05:54.000Z</published>
    <updated>2016-01-22T20:35:15.000Z</updated>
    <content type="html"><![CDATA[<p>这一讲我们就要开始实际接触一个真实的项目——处理一个大文本数据集了。在云上编程和平时学习的可能有一些不同，这里会尽量写得详细一些。</p>
<a id="more"></a>
<hr>
<p>先来具体说说这节课的任务：</p>
<ol>
<li>用顺序执行的程序在云上处理一个大文本数据集。</li>
<li>在这个过程中了解顺序方法的限制</li>
</ol>
<p>这次我们会在特定的 AMI(可以理解为系统镜像)上进行操作，注意不能用外部依赖（也就是不能 <code>sudo apt-get install</code> 任何软件或库，即使装了在测试的时候也没办法运行）</p>
<p>数据集来自维基的<a href="http://dumps.wikimedia.org/other/pagecounts-raw/" target="_blank" rel="external">页面访问统计数据 hourly page view statistics</a></p>
<h2 id="u5173_u4E8E_u6570_u636E_u96C6"><a href="#u5173_u4E8E_u6570_u636E_u96C6" class="headerlink" title="关于数据集"></a>关于数据集</h2><p><code>Wikimedia</code> 会维护所有保存在服务器的对象的每小时页面访问数据并以开放数据集的形式给大家使用。我们会使用这些数据来分析一定时间内页面浏览的趋势。</p>
<p><img src="/images/14532371430507.jpg" alt=""><br>A simplified diagram of a page access form Wikimedia. <a href="http://en.wikipedia.org/wiki/Wikimedia_Foundation#Hardware" target="_blank" rel="external">More information</a></p>
<p>每个对于维基服务器的请求会被当做一个 <a href="http://en.wikipedia.org/wiki/Squid_%28software%29" target="_blank" rel="external">squid cache proxy</a> 来进行处理，同时也会把这些请求记录到日志中。这些日志每个小时更新，大家都可以访问。文件里的每一行对应着一次访问记录，格式如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[项目名称] [页面标题] [访问次数] [总共返回的字节数]</span><br></pre></td></tr></table></figure>
<p><code>[项目名称]</code>包括两个部分，一个是语言标识符和一个子项目后缀，具体如下：</p>
<ul>
<li><code>(no suffix)</code> : wikipedia</li>
<li><code>.b</code> : wikibooks</li>
<li><code>.d</code> : wiktionary</li>
<li><code>.m</code> : wikimedia</li>
<li><code>.mw</code> : wikipedia mobile</li>
<li><code>.n</code> : wikinews</li>
<li><code>.q</code> : wikiquote</li>
<li><code>.s</code> : wikisource</li>
<li><code>.v</code> : wikiversity</li>
<li><code>.w</code> : mediawiki</li>
</ul>
<p>举个例子，假设有一行是这样的：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fr.b <span class="constant">Special</span><span class="symbol">:Recherche/All_Mixed_Up</span> <span class="number">1</span> <span class="number">730</span></span><br></pre></td></tr></table></figure>
<p>就说明这条记录的产生是因为有人访问了 <code>French Wikibooks</code> 中的 <code>Special:Recherche/All_Mixed_Up</code> 页面 1 次，并且总共传输了 730 个字节。</p>
<p>这个项目中，我们主要会分析 2015 年 12 月的数据。不过现在我们只需要处理 12 月 1 日的第一个小时的数据。数据在 <code>s3://cmucc-datasets/wikipediatraf/201512/pagecounts-20151201-000000.gz</code>。可以使用 <code>aws-cli</code>, <code>s3cmd</code> 或者 S3 查看器来了解。但是在服务器上，就需要用 <code>wget</code> 来下载了，具体的地址是 <a href="https://cmucc-datasets.s3.amazonaws.com/wikipediatraf/201512/pagecounts-20151201-000000.gz" target="_blank" rel="external">https://cmucc-datasets.s3.amazonaws.com/wikipediatraf/201512/pagecounts-20151201-000000.gz</a></p>
<p>命令为 <code>wget https://cmucc-datasets.s3.amazonaws.com/wikipediatraf/201512/pagecounts-20151201-000000.gz</code></p>
<p>如果不是很了解如何访问 Amazon S3，可以回头看看<a href="http://wdxtub.com/2016/01/15/cc-2/">云计算 第 2 课 AWS 简介</a></p>
<h2 id="Data_Filtering"><a href="#Data_Filtering" class="headerlink" title="Data Filtering"></a>Data Filtering</h2><p>简单来说，我们要从维基的访问数据中，用各类数据分析的方法，看看能不能找到些什么有意思的东西。</p>
<p>我们会先从第一个小时的维基流量日志开始分析，主要关注英文维基的内容。这种从完整数据的一个子集开始测试起并最终应用到全部数据的方法，在之后的项目中会很有用。</p>
<p>我们先使用 <code>ami-95e9cdff</code>（社区 AMI 中）来创建一个 <code>t1.micro</code> 实例，记得在右上角把地区切换为 <code>弗吉尼亚北部</code>。允许 SSH 和 HTTP 连接（可以使用之前的安全组）。像下面这样：</p>
<p><img src="/images/14533207601658.jpg" alt=""></p>
<p>这里我选择的是竞价型实例（因为会便宜一点），但需要注意的是申请成功之后一定要注意重新打上标签：<code>{&quot;Key&quot;:&quot;Project&quot;,&quot;Value&quot;:&quot;1.1&quot;}</code>。</p>
<p>然后我们耐心等待实例创建，然后使用 <code>ssh -i demo.pem ubuntu@ec2-54-165-218-37.compute-1.amazonaws.com</code> 来进行连接，如下图：</p>
<p><img src="/images/14533217554276.jpg" alt=""></p>
<p>然后进入 <code>Project1_1</code> 文件夹，先把第一个小时的日志文件下载下来，命令为：<code>wget https://cmucc-datasets.s3.amazonaws.com/wikipediatraf/201512/pagecounts-20151201-000000.gz</code></p>
<p>下载速度还是很快的(20MB/s)，然后是一些注意事项：</p>
<p><strong>需要过滤的内容 1</strong></p>
<p>有些行只有 3 个（或更少）元素，需要过滤掉，如 </p>
<p><code>en 1282 10636194</code></p>
<p><strong>需要过滤的内容 2</strong></p>
<p>那些不是来自英文维基的页面访问需要过滤掉，也就是说，如果某一行不是以 <code>en</code> 开始的（大小写敏感），就需要过滤</p>
<p><strong>需要过滤的内容 3</strong></p>
<p>维基的特殊页面在这里不需要考虑，排除那些以如下字段开始的标题（大小写敏感）：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">Media:</span></span><br><span class="line"><span class="label">Special:</span></span><br><span class="line"><span class="label">Talk:</span></span><br><span class="line"><span class="label">User:</span></span><br><span class="line"><span class="label">User_talk:</span></span><br><span class="line"><span class="label">Project:</span></span><br><span class="line"><span class="label">Project_talk:</span></span><br><span class="line"><span class="label">File:</span></span><br><span class="line"><span class="label">File_talk:</span></span><br><span class="line"><span class="label">MediaWiki:</span></span><br><span class="line"><span class="label">MediaWiki_talk:</span></span><br><span class="line"><span class="label">Template:</span></span><br><span class="line"><span class="label">Template_talk:</span></span><br><span class="line"><span class="label">Help:</span></span><br><span class="line"><span class="label">Help_talk:</span></span><br><span class="line"><span class="label">Category:</span></span><br><span class="line"><span class="label">Category_talk:</span></span><br><span class="line"><span class="label">Portal:</span></span><br><span class="line"><span class="label">Wikipedia:</span></span><br><span class="line"><span class="label">Wikipedia_talk:</span></span><br></pre></td></tr></table></figure>
<p><strong>需要过滤的内容 4</strong></p>
<p>维基的政策规定所有的英文文章都必须以大写字母开头，过滤掉那些以小写字母开头的访问记录。注意，有些页面的标题是非英文字符，应该保留。</p>
<p><strong>需要过滤的内容 5</strong></p>
<p>还有一些记录是引用图片文件的，同样需要过滤掉标题以下列扩展名结尾的记录</p>
<p><code>.jpg, .gif, .png, .JPG, .GIF, .PNG, .txt, .ico</code></p>
<p><strong>需要过滤的内容 6</strong></p>
<p>还有一些无关的页面记录需要移除，如果页面标题是如下内容（大小写敏感），需要过滤掉：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">404</span>_error/</span><br><span class="line">Main_Page</span><br><span class="line">Hypertext_Transfer_Protocol</span><br><span class="line">Search</span><br></pre></td></tr></table></figure>
<p>这些都完成之后，把剩余的记录用下面的格式输出：</p>
<p><code>[page title]\t[number of accesses]</code></p>
<p>注意：</p>
<ul>
<li>你可能会发现语言包括 <code>en</code>, <code>EN</code> 和 <code>EN</code>，只对 <code>en</code> 的部分进行处理</li>
<li>输出应该根据访问次数降序排列</li>
</ul>
<p>接下来会用几种不同的方式来完成，我们先解压文件 <code>gzip -d pagecounts-20151201-000000.gz</code></p>
<h3 id="awk__u7248_u672C"><a href="#awk__u7248_u672C" class="headerlink" title="awk 版本"></a>awk 版本</h3><p>因为第一步只是做简单的文字处理，所以用命令行自带的 awk 应用就可以完成。awk 的用法这里不详细介绍，在 <code>runner.sh</code> 中的 <code>answer_0()</code> 函数中填写下面代码：</p>
<p><img src="/images/14533240490475.jpg" alt=""></p>
<p>然后执行 <code>./runner.sh</code>，就可以看到：</p>
<p><img src="/images/14533240848416.jpg" alt=""></p>
<p>我们现在来试着提交一下：</p>
<p><code>./submitter -a dawang -l bash</code></p>
<p>如果引用了其他的内容，需要把对应的资料放到 <code>reference</code> 文件夹中，不然抄袭后果很严重。</p>
<p>因为这一问不评分，所以并没有结果。</p>
<p>这里我又用 java 重写了一次，这里建议大家最好在本地测试运行一下再上传到 AWS 上。考虑到 python 性能比较差，所以从一开始就用 java。</p>
<h3 id="Data_Analysis"><a href="#Data_Analysis" class="headerlink" title="Data Analysis"></a>Data Analysis</h3><p>接下来就是完成 <code>runner.sh</code> 中的各项任务了，具体任务如下：</p>
<ol>
<li>输出过滤前所有的行数</li>
<li>输出过滤前所有的访问数的总和</li>
<li>过滤之后有还剩多少行</li>
<li>过滤后的最受欢迎的文章是什么，输出标题即可</li>
<li>在过滤后的数据集中，包含『cloud』和『computing』的文章有多少个，这里注意是精确匹配，也不区分大小写</li>
<li>过滤后的数据集中最受欢迎的电影的次数，注意，电影的话标题里会有『film』</li>
<li>过滤后的数据集中访问次数在 2500~3000 之间的有多少个</li>
<li>以一个数字开头，之后是字母的页面有多少次访问（注意是开头，正则表达式要匹配上）</li>
<li>是 2014 年的电影更热门还是 2015 年的更热门，搜索『2014_film』和『2015_film』，注意大小写敏感</li>
</ol>
<p>这里需要注意的是，因为在 <code>runner.sh</code> 中分成了九个不同的函数来做，而其实这些都可以一次处理完，所以我会把结果存在临时文件里，然后用 bash 输出。</p>
<p>如果不想在命令行里编程，可以把文件弄到本地来进行编写，命令如下：</p>
<p>远程到本地 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo scp -i demo.pem ubuntu@ec2-<span class="number">54</span>-<span class="number">165</span>-<span class="number">218</span>-<span class="number">37</span>.compute-<span class="number">1</span>.amazonaws.com:~/Project1_1/SeqProg.java ./</span><br><span class="line"></span><br><span class="line">sudo scp -i demo.pem ubuntu@ec2-<span class="number">54</span>-<span class="number">165</span>-<span class="number">218</span>-<span class="number">37</span>.compute-<span class="number">1</span>.amazonaws.com:~/Project1_1/runner.sh ./</span><br></pre></td></tr></table></figure>
<p>本地到远程 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo scp -i demo.pem ./SeqProg.java ubuntu@ec2-<span class="number">54</span>-<span class="number">165</span>-<span class="number">218</span>-<span class="number">37</span>.compute-<span class="number">1</span>.amazonaws.com:~/Project1_1/</span><br><span class="line"></span><br><span class="line">sudo scp -i demo.pem ./runner.sh ubuntu@ec2-<span class="number">54</span>-<span class="number">165</span>-<span class="number">218</span>-<span class="number">37</span>.compute-<span class="number">1</span>.amazonaws.com:~/Project1_1/</span><br></pre></td></tr></table></figure>
<p>提交用：</p>
<p><code>./submitter -a dawang -l java</code></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>一定要认真看题</li>
<li>一定要认真看题</li>
<li>一定要认真看题</li>
<li>AWS 上有时候 java 表现会很奇怪，暂时未知</li>
</ol>
<p>本来打算两种语言都写一下的，但是因为踩了太多坑已经阵亡，最后就只用 Java 实现了（毕竟是会快一点）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一讲我们就要开始实际接触一个真实的项目——处理一个大文本数据集了。在云上编程和平时学习的可能有一些不同，这里会尽量写得详细一些。</p>]]>
    
    </summary>
    
      <category term="AWS" scheme="http://wdxtub.com/tags/AWS/"/>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="文本处理" scheme="http://wdxtub.com/tags/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 6 课 Machine Control]]></title>
    <link href="http://wdxtub.com/2016/01/20/csapp-6/"/>
    <id>http://wdxtub.com/2016/01/20/csapp-6/</id>
    <published>2016-01-20T16:15:32.000Z</published>
    <updated>2016-01-22T20:35:54.000Z</updated>
    <content type="html"><![CDATA[<p>上一讲我们了解了关于机器代码，汇编和 CPU 相关的基础知识，这一讲要来说一下具体机器是怎么实现代码中常见的流程控制的。这一部分涉及的代码和思路稍微有些不容易理解，我会尽量写得详细一些。</p>
<a id="more"></a>
<hr>
<p>我们先来回顾一下 x86-64 处理器中不同的寄存器，这一部分很重要，务必要弄明白：</p>
<p><img src="/images/14533022194673.jpg" alt=""></p>
<p>首先要理解的是，寄存器中存储着当前正在执行的程序的相关信息：</p>
<ul>
<li>临时数据存放在 (%rax, …)</li>
<li>运行时栈的地址存储在 (%rsp) 中</li>
<li>目前的代码控制点存储在 (%rip, …) 中</li>
<li>目前测试的状态放在 CF, ZF, SF, OF 中</li>
</ul>
<h2 id="Condition_Codes"><a href="#Condition_Codes" class="headerlink" title="Condition Codes"></a>Condition Codes</h2><p>最后的四个寄存器（CF, ZF, SF, OF）就是用来辅助程序的流程控制的，意思是：</p>
<ul>
<li>CF: Carry Flag (for unsigned)</li>
<li>ZF: Zero Flag</li>
<li>SF: Sign Flag (for signed)</li>
<li>OF: Overflow Flag (for signed)</li>
</ul>
<p>可以看到以上这四个寄存器，表示四种不同的状态，举个例子，假如我们有一条诸如 <code>t = a + b</code> 的语句，汇编之后假设用的是 <code>addq Src, Dest</code>，那么根据这个操作结果的不同，会相应设置上面提到的四个寄存器，而因为这个是执行类似操作时顺带尽心设置的，称为隐式设置，例如：</p>
<ul>
<li>如果两个数相加，在最高位还需要进位（也就是溢出了），那么 CF 寄存器就会被设置</li>
<li>如果 t 等于 0，那么 ZF 寄存器会被设置</li>
<li>如果 t 小于 0，那么 SF 寄存器会被设置</li>
<li>如果 2’s complement 溢出，那么 OF 寄存器会被设置为 1（溢出的情况是 <code>(a&gt;0 &amp;&amp; b &gt; 0 &amp;&amp; t &lt;0) || (a&lt;0 &amp;&amp; b&lt;0 &amp;&amp; t&gt;=0)</code>）</li>
</ul>
<p>这就发现了，其实这四个条件代码，是用来标记上一条命令的结果的各种可能的，是自动会进行设置的。注意，使用 <code>leaq</code> 指令的话不会进行设置。</p>
<p>除了隐形设置，还可以显式进行设置，具体的方法是使用 <code>cmpq</code> 指令，这里的 q 指的是 64 位的地址。具体来说 <code>cmpq Src2(b), Src1(a)</code> 等同于计算 <code>a-b</code>（注意 a b 顺序是颠倒的），然后利用 <code>a-b</code> 的结果来对应进行条件代码的设置：</p>
<ul>
<li>如果在最高位还需要进位（也就是溢出了），那么 CF 寄存器就会被设置</li>
<li>a 和 b 相等时，也就是 <code>a-b</code> 等于零时，ZF 寄存器会被设置</li>
<li>如果 a &lt; b，也就是 <code>(a-b)&lt;0</code> 时，那么 SF 寄存器会被设置</li>
<li>如果 2’s complement 溢出，那么 OF 寄存器会被设置（溢出的情况是 <code>(a&gt;0 &amp;&amp; b &gt; 0 &amp;&amp; t &lt;0) || (a&lt;0 &amp;&amp; b&lt;0 &amp;&amp; t&gt;=0)</code>）</li>
</ul>
<p>另一种进行显式设置的方法是使用 <code>testq</code> 指令，具体来说 <code>testq Src2(b), Src1(a)</code> 等同于计算 <code>a&amp;b</code>（注意 a b 顺序是颠倒的），然后利用 <code>a-b</code> 的结果来对应进行条件代码的设置，通常来说会把其中一个操作数作为 mask：</p>
<ul>
<li>当 <code>a&amp;b == 0</code> 时，ZF 寄存器会被设置</li>
<li>当 <code>a&amp;b &lt; 0</code> 时，SF 寄存器会被设置</li>
</ul>
<p>有了这四个条件码，就可以通过不同的组合方式，来产生不同的条件判断，例如：</p>
<p><img src="/images/14533038073018.jpg" alt=""></p>
<p>具体来说只会设置最右边的一个 byte（也就是 %al 的部分），其他的都不会改变（通过下面的例子会更清晰）</p>
<p><img src="/images/14533038709749.jpg" alt=""></p>
<p>举个例子，假设我们有一条这样的语句，用来判断 x 和 y 的大小，转换成汇编之后，有几个需要注意的地方，一是 %rsi 存的是 y，%rdi 存的是 x，这个就是前面说的顺序问题。然后我们设置最右边的一个 byte（也就是 %al 的部分，见上图），最后利用 <code>movzbl</code> 指令把返回值复制到 %eax 寄存器中。</p>
<p><img src="/images/14533041584630.jpg" alt=""></p>
<p>这里有一点要进行说明，到底 %eax 寄存器在哪里呢？图上怎么没有？其实 %eax 就是 %rax 寄存器的后 32 位的名称。</p>
<p>那为什么我们要用 32 位的指令呢，剩下的高位怎么办？这是因为在 x86-64 的架构设计中有一条规则『如果对 64 位寄存器设置 32 位数据，那么高位会被设置为 0』，所以可以通过 32 位的指令对 %eax 进行操作处理（如果忽略这个很容易让人困惑），相当于是处理好了 64 位的 %rax 寄存器。</p>
<h2 id="Condition_Branch"><a href="#Condition_Branch" class="headerlink" title="Condition Branch"></a>Condition Branch</h2><p>介绍完了条件代码，就可以来看看具体的跳转了，跳转实际上就是根据条件代码的不同，来进行跳转，具体如下：</p>
<p><img src="/images/14533045268420.jpg" alt=""></p>
<p>我们先来看一个比较原始的例子（编译器没有进行主要优化）：</p>
<p><img src="/images/14533045995659.jpg" alt=""></p>
<p>这里我们是要给出两个数的绝对值的差，所以需要判断谁大谁小，蓝色和红色的部分就分别代表两条分支。考虑到汇编不算特别直观，这里我们用 goto 语句重写一次，基本上就和汇编出来的代码逻辑类似了，方便之后的讲解：</p>
<p><img src="/images/14533047116967.jpg" alt=""></p>
<p>我们再看另一种条件语句要如何翻译，比如 <code>val = Test ? Then_Expr : Else_Expr;</code>，重写上面的函数就是：<code>val = x&gt;y ? x-y : y-x;</code></p>
<p>转换成 goto 形式就是：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	ntest = <span class="comment">!Test;</span></span><br><span class="line">	<span class="keyword">if</span> (ntest) <span class="keyword">goto</span> <span class="keyword">Else</span>;</span><br><span class="line">	<span class="keyword">value</span> = Then_Expr;</span><br><span class="line">	<span class="keyword">goto</span> Done;</span><br><span class="line"><span class="keyword">Else</span>:</span><br><span class="line">	val = Else_Expr;</span><br><span class="line">Done:</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>但是实际上汇编出来的代码，并不是这样的，会采用另一种方法来加速分支语句的执行。现在我们先来说一说，为什么分支语句会对性能造成很大的影响。</p>
<p>我们知道现在的 CPU 都是依靠流水线工作的，比方说执行一系列操作需要 ABCDE 五个步骤，那么在执行 A 的时候，实际上执行 B 所需的数据会在执行 A 的同时加载到寄存器中，这样运算器执行外 A，就可以立刻执行 B 而无须等待数据载入。如果程序一直是顺序的，那么这个过程就可以一直进行下去，效率会很高。但是一旦遇到分支，那么可能执行完 A 下一步要执行的是 C，但是载入的数据是 B，这时候就要把流水线清空（因为后面载入的东西都错了），然后重新载入 C 所需要的数据，这就带来了很大的性能影响。为此人们常常用『分支预测』这一技术来解决（分支预测是另一个话题这里不展开），但是对于这类只需要判断一次的条件语句来说，其实有更好的方法。</p>
<p>处理器有一条指令支持 <code>if(Test) Dest &lt;- Src</code> 的操作，也就是说可以不用跳转，利用条件代码来进行赋值，于是编译器在可能的时候会把上面的 goto 程序改成如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = Then_Expr;</span><br><span class="line">eval = Else_Expr;</span><br><span class="line">nt = !Test;</span><br><span class="line"><span class="keyword">if</span> (nt) result = eval;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>具体的做法是：反正一共就两个分支，我都算出行不行，然后利用上面的条件指令来进行赋值，这样就完美避免了因为分支可能带来的性能问题（需要清空流水线），像下面这样：</p>
<p><img src="/images/14533057292618.jpg" alt=""></p>
<p>这个方法好是好，但是也有一些情况并不适用于：</p>
<ul>
<li>因为会把两个分支的运算都提前算出来，如果这两个值都需要大量计算的话，就得不偿失了，所以需要分支中的计算尽量简单。</li>
<li>另外在涉及指针操作的时候，如 <code>val = p ? *p : 0;</code>，因为两个分支都会被计算，所以可能导致奇怪问题出现</li>
<li>最后一种就是如果分支中的计算是有副作用的，那么就不能这样弄 <code>val = x &gt; 0 ? x*= 7 : x+= 3;</code>，这种情况下，因为都计算了，那么 x 的值肯定就不是我们想要的了。</li>
</ul>
<h2 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h2><p>先来看看并不那么常用的 Do-While 语句：</p>
<p><img src="/images/14533062342446.jpg" alt=""></p>
<p>这个函数计算参数 x 中有多少位是 1，翻译成汇编如下：</p>
<p><img src="/images/14533063334333.jpg" alt=""></p>
<p>其中 %rdi 中存储的是参数 x，%rax 存储的是返回值。换成更通用的形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C Code</span></span><br><span class="line"><span class="function"><span class="keyword">do</span></span><br><span class="line">	Body</span><br><span class="line">	<span class="title">while</span> <span class="params">(Test)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Goto Version</span></span><br><span class="line">loop:</span><br><span class="line">	<span class="function">Body</span><br><span class="line">	<span class="title">if</span> <span class="params">(Test)</span></span><br><span class="line">		<span class="keyword">goto</span> loop</span></span><br></pre></td></tr></table></figure>
<p>而对于 While 语句的转换，会直接跳到中间，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C While version</span></span><br><span class="line"><span class="keyword">while</span> (Test)</span><br><span class="line">	Body</span><br><span class="line"></span><br><span class="line"><span class="comment">// Goto Version</span></span><br><span class="line">	<span class="keyword">goto</span> test;</span><br><span class="line">loop:</span><br><span class="line">	Body</span><br><span class="line">test:</span><br><span class="line">	<span class="keyword">if</span> (Test)</span><br><span class="line">		<span class="keyword">goto</span> loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<p>举个具体的例子：</p>
<p><img src="/images/14533065773830.jpg" alt=""></p>
<p>如果在编译器中开启 <code>-O1</code> 优化，那么会把 While 先翻译成 Do-While，然后再转换成对应的 Goto 版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C While version</span></span><br><span class="line"><span class="keyword">while</span> (Test)</span><br><span class="line">	Body</span><br><span class="line"></span><br><span class="line"><span class="comment">// C Do-While Version</span></span><br><span class="line">	<span class="keyword">if</span> (!Test)</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	<span class="function"><span class="keyword">do</span></span><br><span class="line">		Body</span><br><span class="line">		<span class="title">while</span><span class="params">(Test)</span></span>;</span><br><span class="line">done:</span><br><span class="line"></span><br><span class="line"><span class="comment">// Goto Version</span></span><br><span class="line">	<span class="keyword">if</span> (!Test)</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">loop:</span><br><span class="line">	<span class="function">Body</span><br><span class="line">	<span class="title">if</span> <span class="params">(Test)</span></span><br><span class="line">		<span class="keyword">goto</span> loop</span>;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<p>具体的例子是：</p>
<p><img src="/images/14533068824241.jpg" alt=""></p>
<p>为什么要这样做呢，因为 Do-While 语句执行起来更快，更符合 CPU 的运算模型。</p>
<p>然后来看看最常用的 For 循环，也可以一步一步转换成 While 的形式，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For</span></span><br><span class="line"><span class="keyword">for</span> (Init; Test; Update)</span><br><span class="line">	Body</span><br><span class="line">	</span><br><span class="line"><span class="comment">// While Version</span></span><br><span class="line">Init;</span><br><span class="line"><span class="keyword">while</span> (Test) &#123;</span><br><span class="line">	Body</span><br><span class="line">	Update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在具体转换成 Do-While 模式的时候，会把最初的测试优化去除</p>
<p><img src="/images/14533070757433.jpg" alt=""></p>
<h2 id="Switch_Statement"><a href="#Switch_Statement" class="headerlink" title="Switch Statement"></a>Switch Statement</h2><p>最后我们来看看最复杂的 switch 语句，这种类型的语句一次判断会有多种可能的跳转路径（知道 CPU 的分支预测会多抓狂吗）。这里用一个具体的例子来进行讲解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">switch_eg</span> <span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y, <span class="keyword">long</span> z)</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> w = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">switch</span> (x) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			w = y*z;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			w = y/z;</span><br><span class="line">			<span class="comment">// fall through</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			w += z;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">			w -= z;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			w = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中包含了大部分比较特殊的情况：</p>
<ul>
<li>共享的条件：5 和 6</li>
<li>fall through：2 也会执行 3 的部分（这个要小心，一般来说不这么搞，如果确定要用，务必写上注释）</li>
<li>缺失的条件：4</li>
</ul>
<p>具体怎么办呢？简单来说，使用跳转表（你会发现表的解决方式在很多地方都有用：虚函数，继承甚至动态规划），如下所示：</p>
<p><img src="/images/14533075034521.jpg" alt=""></p>
<p>转换出来如下：</p>
<p><img src="/images/14533079929851.jpg" alt=""></p>
<p>这里需要注意，我们先跟 6 进行比较（因为 6 是最大的），然后利用 <code>ja</code> 指令进行跳转，为什么，因为如果是负数的话，<code>ja</code> 是处理无符号数的，所以负数情况肯定大于 6，于是直接利用 <code>ja</code> 跳转到 default 的分支。</p>
<p><img src="/images/14533081508060.jpg" alt=""></p>
<p>然后下一句 <code>jmp *.L4(,%rdi, 8) # goto *JTab[x]</code>，是一个间接跳转，通过看上面的跳转列表来进行跳转。</p>
<p>比如说，直接跳转 <code>jmp .L8</code>，就直接跳到 <code>.L8</code> 所在的标签，也就是 x = 0</p>
<p>如果是 <code>jmp *.L4(,%rdi,8)</code> 那么就先找到 <code>.L4</code> 然后往后找 8 个字节（或 8 的倍数），于是就是 0~6 的范围。具体的对应关系如下：</p>
<p><img src="/images/14533122886722.jpg" alt=""></p>
<p>处理 fall through 的方式：</p>
<p><img src="/images/14533123220172.jpg" alt=""></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这节课我们学到了</p>
<ul>
<li>C 语言的控制流程<ul>
<li>if-then-else</li>
<li>do-while</li>
<li>while, for</li>
<li>switch</li>
</ul>
</li>
<li>汇编的控制流程<ul>
<li>条件跳转</li>
<li>条件转移</li>
<li>间接跳转（通过跳转表）</li>
<li>编译器会生成代码序列来实现更加复杂的控制</li>
</ul>
</li>
<li>标准技术<ul>
<li>把循环转换位 do-while 的形式或者 jump-to-middle 形式</li>
<li>大的 switch 语句会用跳转表</li>
<li>处理 switch 语句可能会用到决策树（if-elseif-elseif-else）</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一讲我们了解了关于机器代码，汇编和 CPU 相关的基础知识，这一讲要来说一下具体机器是怎么实现代码中常见的流程控制的。这一部分涉及的代码和思路稍微有些不容易理解，我会尽量写得详细一些。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一点微小的工作]]></title>
    <link href="http://wdxtub.com/2016/01/19/a-little-work/"/>
    <id>http://wdxtub.com/2016/01/19/a-little-work/</id>
    <published>2016-01-20T04:40:52.000Z</published>
    <updated>2016-01-20T05:35:16.000Z</updated>
    <content type="html"><![CDATA[<p>可能很久之后回忆这段留学的时光，让自己开心的不是绩点和景点，而是朋友，和一点微小的工作。</p>
<a id="more"></a>
<hr>
<p>先说主题：我在把这个学期上的课程以及自己的学习经历以日志的形式记录并共享出来，一是督促自己更深刻理解所学知识，二是让更多人能够接触到高质量的教学课程。希望能以这一点微小的工作，帮助更多人。也希望大家也能更多地把自己学习和思考的东西写出来分享出来，真正去创造些高质量的可以传承的东西。</p>
<p>（以下是目前正在进行的三门课程的文章列表）</p>
<p><img src="/images/list.jpg" alt="list"></p>
<p>为什么在做这样一件事情呢？</p>
<p>本科在中山大学读完之后（还度过了一段研究生时光），来到 CMU，才真切地感受到国内外教育质量的差距。高兴的是能有机会接触到最顶尖的教育，惭愧的是只能独善吾身，却不能兼济天下。即使心里想着做些什么去改变这种状况，却迟迟没有动手。每每念及高中同学向芯，除了佩服她（以及她的小伙伴）多年如一日勉力经营青草（『让中国青少年成为有爱，有思想，有行动力的人』，参考<a href="http://www.douban.com/note/258430473/" target="_blank" rel="external">这里</a>），还在想，作为我这样一个资质平平也没有治国平天下理想的普通青年，能做些什么。</p>
<p>至少我能把我所学所想写下来，让更多人能通过我的文字，来了解『教育也可以是这样的』。南非前总统曼德拉曾经说：“如果你隐藏自己，不敢让别人看到你如何做自己喜欢的事，别人就会认为，他们也不能做到。但如果你让他们看见，就等于允许他们像你一样去做自己喜欢的事，就等于解放了他们的愿望。这并不是说要让他们去做和你一样的事，而是让每一个都做最适合自己、自己最希望做的事。”</p>
<p>这也是为什么，我想要把这些写下来的原因。</p>
<p>本来是打算等学期结束再整理分享，但是想到早一些分享，可能就会多一些人参与。虽然可能目前有各种各样的错漏，但是相信在大家的监督点拨下，我们都能做得更好。</p>
<p>我不大会起那些特别吸引眼球的标题，更多是想踏踏实实把一件事情坚持下来，如果可能的话，做得尽量好一些。也希望能用自己这一点微小的工作，让大家看到，即使是小小的贡献，积累起来也能是大大的改变。</p>
<p>具体的文章目录可以在<a href="http://wdxtub.com/about/">这里</a>查看，欢迎加我的个人微信交流讨论</p>
<p>更希望能帮忙转发一下，让更多人能看到并参与进来。</p>
<p><img src="/images/me.jpeg" alt="me"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>可能很久之后回忆这段留学的时光，让自己开心的不是绩点和景点，而是朋友，和一点微小的工作。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="分享" scheme="http://wdxtub.com/tags/%E5%88%86%E4%BA%AB/"/>
    
      <category term="学习" scheme="http://wdxtub.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="课程" scheme="http://wdxtub.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
</feed>
