<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-03-26T19:38:34.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[烤箱指南]]></title>
    <link href="http://wdxtub.com/2016/03/26/oven-guide/"/>
    <id>http://wdxtub.com/2016/03/26/oven-guide/</id>
    <published>2016-03-26T19:23:14.000Z</published>
    <updated>2016-03-26T19:38:34.000Z</updated>
    <content type="html"><![CDATA[<p>在美国学会的技能之一就是用烤箱做懒人食品，但烤箱也是有门道的，尤其是各种香料，这里收集了一些基本知识和技巧，分享给大家。</p>
<a id="more"></a>
<hr>
<p>刀工和颠勺两样，前者关乎食材的准备，后者关乎火候，这两样学会了，大抵就错不了。再后来我发现，除了这两样之外，还需要两样东西，就是对食材的感觉，和对自己的信心。</p>
<p>每次看到一个菜谱后自己做时，我不会纠结我手头的材料和菜谱不是一模一样，我不会纠结具体的制作时间和放多少调料这些细节，因为我对自己有信心，因为我对自己对食材的感觉有信心。</p>
<p>食材好，做出来的东西一般不会有大问题，所以在战术上要重视食材，再好的技术，没有好食材也做不出美食来。</p>
<p>但是不能被食材所左右，真正在操作的是自己，美味的界限由自己来拓展，好食材只是工具，这就是在战略上藐视食材。</p>
<h2 id="u70E4_u8089_u5668_u5177"><a href="#u70E4_u8089_u5668_u5177" class="headerlink" title="烤肉器具"></a>烤肉器具</h2><p><strong>器材</strong></p>
<ul>
<li>一个大烤盘。这是你最基本的烤箱器材，用来烤大批东西用，而且在其它器材不足的情况下可以勉强代替使用</li>
<li>一个带烤架的深盘。有些东西烤的时候要考虑到各个方位均匀加热，用烤架架着隔空烤更加合适。而且这个深盘平常可以用来烤别的东西</li>
<li>一个中号的玻璃或者陶瓷烤皿。用来焗东西，或者用来烤小批的东西</li>
<li>几个小号的烤皿。用来做些快速方便的吃食，或者做开胃菜</li>
<li>一个可以进烤箱的铸铁煎锅/铁板。有些肉类需要先煎然后再进烤箱烤，这个时候如果能整个锅放进烤箱就方便好多</li>
<li>肉类温度计。烤大块肉的之后，要知道肉的内部有没有熟就要靠肉类温度计了，具体样子上面的图已经出现过了</li>
<li>其它小配件。比如烤串用的竹签，烤箱手套，锡纸，注射用的针管等等</li>
</ul>
<p><strong>调料</strong></p>
<ul>
<li>基本：盐，黑胡椒</li>
<li>香料：罗勒、迷迭香、百里香、孜然和王守义十三香（具体参见香料详解）</li>
<li>其它调料：蜂蜜（有时候烤肉时能刷），洋葱，蒜，烤肉酱，番茄酱</li>
</ul>
<h2 id="u7B80_u6613_u83DC_u8C31"><a href="#u7B80_u6613_u83DC_u8C31" class="headerlink" title="简易菜谱"></a>简易菜谱</h2><h3 id="u7ECF_u5178_u871C_u6C41_u9E21_u7FC5"><a href="#u7ECF_u5178_u871C_u6C41_u9E21_u7FC5" class="headerlink" title="经典蜜汁鸡翅"></a>经典蜜汁鸡翅</h3><ul>
<li>难度★★</li>
<li>腌一腌：鸡翅用味极鲜酱油、蚝油、五香粉腌一晚上。番茄酱什么的也可以随意放，反正怎么都好吃。</li>
<li>烤一烤：上烤架，为了防粘，烤架上面铺锡纸，用叉子戳洞，方便滴油。下面放烤盘接油。200℃ 10分钟，拿出来刷蜂蜜，继续10分钟。再拿出来翻面刷蜂蜜，10分钟。</li>
</ul>
<h3 id="u7EAF_u7237_u4EEC_u7F8A_u8089_u4E32"><a href="#u7EAF_u7237_u4EEC_u7F8A_u8089_u4E32" class="headerlink" title="纯爷们羊肉串"></a>纯爷们羊肉串</h3><ul>
<li>难度★★★★</li>
<li>切一切：无骨的净羊肉切大块。</li>
<li>腌一腌：用大量孜然粉、大量辣椒粉、一点盐抓匀，有的话还可以放一点蒜粉和葱粉。</li>
<li>串一串：就是串竹签。</li>
<li>烤一烤：烤架+烤盘接油，220℃ 10分钟，翻面再8分钟。</li>
</ul>
<h3 id="u778E_u70E4_u9E21_u8089_u4E32"><a href="#u778E_u70E4_u9E21_u8089_u4E32" class="headerlink" title="瞎烤鸡肉串"></a>瞎烤鸡肉串</h3><ul>
<li>难度★★★★</li>
<li>切一切：鸡腿肉切块。蔬菜（青红辣椒、洋葱、大蒜之类的，随意）等腌好鸡腿肉再切块。</li>
<li>腌一腌：切好的鸡腿肉用蒜末、味极鲜、蜂蜜腌半天。</li>
<li>串一串：就是串竹签。</li>
<li>烤一烤：220℃正反面各6分钟，中间刷点番茄酱、辣椒酱什么的。</li>
</ul>
<h3 id="u5965_u5C14_u826F_u70E4_u91CC_u810A_u8089"><a href="#u5965_u5C14_u826F_u70E4_u91CC_u810A_u8089" class="headerlink" title="奥尔良烤里脊肉"></a>奥尔良烤里脊肉</h3><ul>
<li>难度★★★★</li>
<li>切一切：里脊肉切片。</li>
<li>腌一腌：网上买奥尔良腌肉料，按照说明腌三小时以上。</li>
<li>串一串：就是串竹签。</li>
<li>烤一烤：200℃正反面各8分钟。</li>
</ul>
<h3 id="u9500_u9B42_u626D_u8170_u867E"><a href="#u9500_u9B42_u626D_u8170_u867E" class="headerlink" title="销魂扭腰虾"></a>销魂扭腰虾</h3><ul>
<li>难度★★★</li>
<li>切一切：大虾从背部切开，取出虾线，</li>
<li>腌一腌：橄榄油+蒜末+小米辣+鸡精做成酱汁，一只虾塞一小勺。</li>
<li>烤一烤：烤盘铺锡纸，200℃ 10分钟。虾壳脆扑扑也能吃。</li>
<li>如果不想要扭腰效果就用竹签串起来烤。</li>
</ul>
<h3 id="u70E4_u4E32"><a href="#u70E4_u4E32" class="headerlink" title="烤串"></a>烤串</h3><ol>
<li>猪肩肉</li>
<li>腌料，一个柠檬，柠檬皮刨丝，柠檬汁挤出来，按照柠檬汁橄榄油1:3的比例加橄榄油，放入海盐、现磨黑椒、蒜头碎、花椒、小茴香籽、孜然籽、罗勒、百里香和王守义十三香粉，一点老抽上色用。手边香料不全的话不要太过于纠结，少几味就少几味吧。</li>
<li>肉切成块，然后用竹签在肉上面戳几个洞，取几个台湾小香肠，也戳几个洞，把肉和香肠放到腌料里面拌匀，腌制半个小时。没香肠也行，不影响肉的味道。</li>
<li>各种颜色甜椒去籽切片，洋葱去皮切块</li>
<li>串起来</li>
<li>放进预热的烤箱里面（最好用烤架），200摄氏度，烤30-40分钟，熟了就能吃</li>
</ol>
<h3 id="u70E4_u7F8A_u817F"><a href="#u70E4_u7F8A_u817F" class="headerlink" title="烤羊腿"></a>烤羊腿</h3><p>零基础能做出来的大菜。</p>
<ol>
<li>买一块羊腿，前腿、后腿做法一样，你看着买</li>
<li>在脂肪比较厚的地方随便切几刀，这是为了方便入味</li>
<li>然后弄点干腌料。想吃羊肉原味的只用盐和黑胡椒就够了（我还用了干迷迭香、孜然和辣椒粉，其它料你看着加）</li>
<li>把混好的腌料均匀的抹在羊腿表面</li>
<li>拿个容器装起来，用保鲜膜包住。放冰箱里一晚上入味</li>
</ol>
<p>第二天</p>
<ol>
<li>搞定洋葱和蒜，表面洗干净就好了，然后洋葱切大块，蒜掰成瓣，不需要去皮</li>
<li>把羊腿从冰箱拿出来，表面抹一层油。不要怕油多不健康，最后这些油都会流到下面去的</li>
<li>用锡纸把烤盘包严实了。因为是低温慢烤，如果不包严实最后会烤干掉</li>
<li>然后烤箱里160摄氏度烤四个小时</li>
<li>把垫底的料和油留在烤盘里，羊腿装盘就能上桌吃了</li>
</ol>
<p>Q&amp;A</p>
<blockquote>
<p>问：为什么蒜不用剥皮</p>
</blockquote>
<p>答：因为这个蒜是为了调味，不是为了吃的，烤四个小时候剥不剥皮都一样</p>
<blockquote>
<p>问：为什么要烤四个小时，能不能烤短一点</p>
</blockquote>
<p>答：如果肉比较小的话可以适当缩短时间，但是低温长时间是用烤箱把肉烤烂的必要过程</p>
<blockquote>
<p>问：烤盘底部烤焦的油很难洗的样子啊</p>
</blockquote>
<p>答：烤盘倒满水，泡一个晚上，第二天早上一抹就抹掉了。</p>
<h2 id="u5982_u4F55_u7528_u70E4_u7BB1_u70E4_u51FA_u597D_u5403_u7684_u9C7C_u7C7B_uFF08_u6D77_u9C9C_uFF09_u6599_u7406"><a href="#u5982_u4F55_u7528_u70E4_u7BB1_u70E4_u51FA_u597D_u5403_u7684_u9C7C_u7C7B_uFF08_u6D77_u9C9C_uFF09_u6599_u7406" class="headerlink" title="如何用烤箱烤出好吃的鱼类（海鲜）料理"></a>如何用烤箱烤出好吃的鱼类（海鲜）料理</h2><p>西餐中，鱼肉的处理使用烤箱是非常常见的，因为鱼肉相比其它肉类来说比较脆弱，易碎，比较难处理，鱼肉也比较适合低温处理，不会一下控制不好火候，烤过头，进烤箱的话，对于那些比较薄的鱼肉、全鱼或是鱼排来说都是非常好处理方法，干燥的烤箱也起到很好的浓缩鱼肉和调料香气的作用。</p>
<p>用烤箱烤鱼基本有以下几种方法：</p>
<h3 id="u9AD8_u6E29_u70D8_u70E4"><a href="#u9AD8_u6E29_u70D8_u70E4" class="headerlink" title="高温烘烤"></a>高温烘烤</h3><p><strong>1.烤箱‘油炸’法</strong></p>
<p>为了防止鱼变老，这里我们需要给”鱼“穿上一层”外衣“再进烤箱，最简单的方法，我们可以裹上：蛋黄酱、黑胡椒、柠檬汁、洋葱粉、再撒满面包屑和一些黄油或橄榄油，大概220度，烤制20分钟</p>
<p><strong>2.先煎再烤</strong></p>
<p>这个方法很像中国人做鱼的方法，先煎炸再炖煮，西方人是先煎炸再进烤箱，这样可以使鱼肉的表皮能有很好的酥脆度还有焦香，我们可以用铁平底锅煎制，煎制的时候将带皮的面朝下。</p>
<p>大概5-6分钟后，鱼皮开始出现焦香，之后将其放入烤箱，烤个6-7分钟，有了解西餐料理的朋友们，应该对此做法不陌生，这种先煎再烤的方法可以运用在各种肉类的烹调里，比如大名鼎鼎的 Beef Wellington。</p>
<p>从烤箱拿出来后，我们将另一面再稍微煎制十几秒钟，烤好之后可以撒一些 Parsley</p>
<h3 id="u4F4E_u6E29_u70D8_u70E4"><a href="#u4F4E_u6E29_u70D8_u70E4" class="headerlink" title="低温烘烤"></a>低温烘烤</h3><p>烤箱温度基本在100度-120度，烤出的鱼肉整体都非常嫩滑，这种方式基本是通过烤制过程中的水分蒸发对流将鱼肉”蒸熟“</p>
<h3 id="u5305_u88F9_u70D8_u70E4"><a href="#u5305_u88F9_u70D8_u70E4" class="headerlink" title="包裹烘烤"></a>包裹烘烤</h3><p>我们可以用油纸、锡纸、或酥皮，东南亚喜欢用芭蕉叶等味道不影响主食材味道的材料。这种方法主要是不让鱼肉直接受热、这种方法可以使鱼肉受热均匀，这种做法最大程度的保留了所有食材的味道。这种方法类似于低温烘烤。</p>
<h2 id="u897F_u9910_u5E38_u7528_u9999_u6599"><a href="#u897F_u9910_u5E38_u7528_u9999_u6599" class="headerlink" title="西餐常用香料"></a>西餐常用香料</h2><p>植物香料太多，世界各地的加起来估计能有个上百种吧，光罗勒就有很多不同的分类，香味和味道都不一样。还有地域性分别，比如柠檬草，在东南亚菜肴中很常见，别的地方就不多。再有一些植物可做观赏可入菜，比如薰衣草、茉莉花之类。</p>
<p>香料的使用没有硬性规定，通常的建议是味道和香气淡的香料配白肉和鱼，味道辛辣、香味重的配红肉，不同香料混搭很多，可以自己多尝试。当然不按着常规用法来用问题也不大，自己怎么喜欢就怎么来，吃的开心最重要。</p>
<p>说几种西餐常见的吧，按照字母顺序来：</p>
<blockquote>
<p>多香果（All Spice）</p>
</blockquote>
<p>运用广泛，从腌鱼、烧烤酱、德国香肠、印度咖喱等等都有用。我自己有时候拿来卤肉吃，不是常见用法，但是效果普遍不错，比传统的中式红卤更添一层味道。</p>
<blockquote>
<p>罗勒(Basil)</p>
</blockquote>
<p>罗勒大概是各种香草里面最常见的了，干罗勒基本和各种肉都百搭。新鲜罗勒经常用来点缀菜肴和增加香气，用法和香菜类似。我的各种烤肉里面用颇多的罗勒，新鲜罗勒在上次做洛林糕的时候也有用到</p>
<blockquote>
<p>香叶（Bay Leaf）</p>
</blockquote>
<p>这个东西中餐西餐都有用，西餐里面香叶一般是不摆上桌的，也就是说上桌前会从锅里拿走。主要是在汤类和各种肉类食物准备和烹调过程中增加香味的。</p>
<blockquote>
<p>小葱（Chives）</p>
</blockquote>
<p>这个东西中餐西餐都用的很多，不同种类味道略有差别，但基本都是葱。西餐主要用来沙拉上，也常用来和海鲜、鱼肉调味，和各种芝士搭配也多。</p>
<blockquote>
<p>肉桂(Cinnamon)</p>
</blockquote>
<p>也是中西通用，也分很多不同的种类，和香叶一样一般不摆上桌。适合红肉类的烹调。</p>
<blockquote>
<p>丁香（Clove)</p>
</blockquote>
<p>欧洲菜不太用，一般也不摆上桌，适合红肉类的烹调，和其它红肉类香料比如肉桂、八角什么搭配很好。</p>
<blockquote>
<p>香菜(Coriander)</p>
</blockquote>
<p>西餐里面常用这个，和什么肉都很搭。我一般用来拌凉菜吃，沙拉也可以用。</p>
<blockquote>
<p>莳萝（Dill）</p>
</blockquote>
<p>味道淡，一般放很多才有味道，适合配鱼和白肉。我用来用来腌三文鱼，泡橄榄油，炒鸡胸肉吃。下面这个我腌的gravlax里面用到了上面提到多香果。</p>
<blockquote>
<p>蒜（Garlic）</p>
</blockquote>
<p>蒜整个烤、切丁炒、做成蒜泥烤都行，和各种肉类都很搭，主要看自己的口味，之前做牛排的时候也抹蒜来着</p>
<blockquote>
<p>姜（Ginger）</p>
</blockquote>
<p>各种肉去腥什么的，就不多说了</p>
<blockquote>
<p>墨角兰（Majoram）</p>
</blockquote>
<p>一般用来给汤和酱料调味</p>
<blockquote>
<p>薄荷（Mint）</p>
</blockquote>
<p>薄荷清凉味，一般配饮料，如Mojito之类，或者甜点。做菜可以配一些味道淡的肉、鱼、蔬菜</p>
<blockquote>
<p>肉豆蔻（Nutmeg）</p>
</blockquote>
<p>一般配蔬菜，比如土豆什么的</p>
<blockquote>
<p>洋葱（Onion）</p>
</blockquote>
<p>洋葱种类很多，单独炒菜、烤肉、熬汤都行，是西餐的基本食材和基本配料之一。我一般用黄葱</p>
<blockquote>
<p>牛至（Oregano）</p>
</blockquote>
<p>香中带微苦，意大利菜尤多。我一般不单独用，都是和别的香料混着用。</p>
<blockquote>
<p>欧芹（Parsley）</p>
</blockquote>
<p>这个东西主要就是点缀用，本身味道太淡了。</p>
<blockquote>
<p>迷迭香（Rosemary)</p>
</blockquote>
<p>香味浓郁，略带苦味，配鸡肉和羊肉最佳。</p>
<blockquote>
<p>番红花（Saffron)</p>
</blockquote>
<p>最常见的是西班牙海鲜饭，主要为了染色，可以用姜黄粉代替，效果差点。番红花种植难收成少，特别贵，都是按克卖。</p>
<blockquote>
<p>鼠尾草（Sage）</p>
</blockquote>
<p>法国菜常见，微辣，适合配猪肉</p>
<blockquote>
<p>龙蒿（Tarragon）</p>
</blockquote>
<p>法国菜常见，清香微甜，适合白肉和鱼。</p>
<blockquote>
<p>百里香（Thyme）</p>
</blockquote>
<p>法国菜常见，香味浓郁，配鸡肉、猪肉都合适。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在美国学会的技能之一就是用烤箱做懒人食品，但烤箱也是有门道的，尤其是各种香料，这里收集了一些基本知识和技巧，分享给大家。</p>]]>
    
    </summary>
    
      <category term="烤箱" scheme="http://wdxtub.com/tags/%E7%83%A4%E7%AE%B1/"/>
    
      <category term="美食" scheme="http://wdxtub.com/tags/%E7%BE%8E%E9%A3%9F/"/>
    
      <category term="菜谱" scheme="http://wdxtub.com/tags/%E8%8F%9C%E8%B0%B1/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[租房手册]]></title>
    <link href="http://wdxtub.com/2016/03/26/rent-room-guide/"/>
    <id>http://wdxtub.com/2016/03/26/rent-room-guide/</id>
    <published>2016-03-26T18:46:57.000Z</published>
    <updated>2016-03-26T19:17:23.000Z</updated>
    <content type="html"><![CDATA[<p>对于不在家乡工作的人来说，找房子算是相当麻烦的事情，这里是我收集的一些资料，希望给大家一些参考。</p>
<a id="more"></a>
<hr>
<h2 id="u623F_u5B50_u7C7B_u578B"><a href="#u623F_u5B50_u7C7B_u578B" class="headerlink" title="房子类型"></a>房子类型</h2><ul>
<li>地下室<ul>
<li>每个小区都有地下室，并且大都出租，自己去小区转转就能找到，因为房东大都会在地下室前面立个牌子写上出租。价位不等，租客鱼龙混杂，洗刷间男女共用。如果不是十分的困难不建议住，尤其是女生。不同小区价位不等，环境也有很大差别，冬天住还可以，夏天就十分热。还要注意冬天的时候有的没有暖气。对于大多数初到北京的北漂，大都住过，我住过，那种感觉怎么说呢，如果一个人住会有很孤独压抑的感觉，后来租了一个有窗户的，略微有光，还好一点。</li>
</ul>
</li>
<li>平房<ul>
<li>我把一、二层的放到一起来写吧，同区的价位也就比地下室贵个一到两百（不同地区不同），但是好歹在地上，环境也稍微好一些。</li>
</ul>
</li>
<li>群租房、床位<ul>
<li>群租房就是很多人一起租，本质也属于合租房，但是由于跟合租差别还是很大，所以跟合租房分开说。群租房分两种，一种是打了很多隔断的，这种一般是小中介代理的。一种是做成宿舍那种的床位，人很多，一般也是中介代理。</li>
</ul>
</li>
<li>合租房<ul>
<li>指没有打过隔断或者只在客厅打过一间隔断的房子。这种房子还是比较推荐大家来住的，因为确实人少并且住着也舒服。并且价位也不贵，适合收入尚可的学生和白领。后面会着重介绍。</li>
</ul>
</li>
<li>普通住房<ul>
<li>开间就是客厅和卧室在一起，即一室0厅一厨一卫。标准一居室就是一室一厅一厨一卫。室指卧室，厅指客厅，厨指厨房，卫指卫生间。</li>
<li>四居五居比较少有（不包括隔断），一般是豪宅会有，比如说山水文园、观湖国际等。</li>
<li>三居室以上要注意有的三居室是两卫，即在主卧室多出一个卫生间，有的没有。</li>
</ul>
</li>
<li>商住两用住房<ul>
<li>一般公司需要注册的，又不需要在底商的，会要租这种房子。童鞋们一般不用考虑这类住房，或者应该避开一些商住两用的，为什么？同环境同户型价位比一般住房要贵一到两千，而且水电要比普通的住房要贵。但是这类的装修都还不错，比较有代表性的是林达海渔广场。</li>
<li>有需要办公而租住这类房子的要注意要问这房子之前是否被注册过，如果注册过的话可以先去销一下。</li>
</ul>
</li>
<li>写字楼，底商<ul>
<li>写字楼是办公、这大家都知道。底商就是指那些底层的一楼商铺。这类房子报价通常是说几块钱，比如说3块钱，这里指的是3块钱/平/天。</li>
</ul>
</li>
</ul>
<h2 id="u627E_u623F_u6B65_u9AA4"><a href="#u627E_u623F_u6B65_u9AA4" class="headerlink" title="找房步骤"></a>找房步骤</h2><h3 id="u5468_u671F"><a href="#u5468_u671F" class="headerlink" title="周期"></a>周期</h3><p>至少提前一周，看房两次到三次，每次至少两套。</p>
<p>理想状态是半个月吧，但是记住这时间只是个参考，如果立刻遇到自己满意的房子要马上交订金，尤其是在3-4月和6-8月，因为这是租房高峰期，尤其是好房子，大家都在抢（因为房东一般都是多家中介报盘，客户比较多）。有时候只要耽搁半天好房子马上就没了~在租房高峰尤其常见。</p>
<p>此外有一个叫做租房低峰，大概就是指年前一个月左右。租房是其实没有低峰的，年前一个月客户少一点是确实但是绝对不是淡出鸟那种，因为精明的人都会在那个时候出来先看看房。</p>
<p>不要以为在临近过年大家都在退房房子很好租还会降价，北京的房价不曾降过的亲~你要是不傻绝对不要在过年的时候退房，因为回来之后马上就是返京高峰，知道前后的房子价格差多少吗？年后的第一个月两到三居室房价一般都会小涨100~500多。</p>
<p>我知道大家都想租便宜的，租金低的，位置好的，朝向户型优越，家具家电全齐，性价比高的房子~~~别想了，那种房子一般不存在。</p>
<p>豪宅除外，一般同个区域同个小区相同户型同等装修的房子差价不会超过200块钱~大家都不是傻子，能租到跟自己要求符合百分之七十的就差不多了，百分之百的很难找到，除非你找房的周期很长。</p>
<p>有时你会听到某人现在租的房租很便宜的，但人家一般那是租住了好多年的房子，北京房价涨的很快，现在确实很变态。</p>
<p>外环的房子要比内环的便宜的很多，京南的房子要比京北的房子便宜。所以沿着地铁找还是比较合适的。</p>
<p>北京的房子中介费大都是客户出的，但是也有业主出的情况，让中介帮你争取，在中介带你看房子的时候，中介一般都会跟你说业主不出，所以在中介说出这话之前，你要透漏给他你不想出的意思，这样可以诱导中介回去跟业主提这件事。否则一般中介都不会提。</p>
<p>在网上看房，有时看好的打电话问却被说是房子没了。有两个原因，一是你看的是钓鱼贴，中介用来钓客户的。二是这房子确实是被租了，中介还没来得及下架。第一个原因多一点。</p>
<p>跟中介看房子，除非是年后一个月的那段时间，尽量第一次不要定，尤其不要交钱。</p>
<h3 id="u9009_u5B9A_u533A_u57DF"><a href="#u9009_u5B9A_u533A_u57DF" class="headerlink" title="选定区域"></a>选定区域</h3><p>选小区两种方法：</p>
<ol>
<li>找中介</li>
<li>自己百度地图</li>
</ol>
<p>百度地图的三种方法：</p>
<ol>
<li>找工作地点近的小区。</li>
<li>工作地点一两到两站公交左右范围内的小区。</li>
<li>如果工作地点距离地铁近的话，沿着地铁站找。当然如果在北京的话个人还是建议第三条，虽然路上费点时间，但是省钱。</li>
</ol>
<p>了解价位的方法：</p>
<ol>
<li>问中介，不想去店里面的话可以在网络上留言，比如58、赶集等。</li>
<li>在网络上查，在北京的推荐链家在线，很权威，不过有些地区你要在此基础上减一到两百，百分之七八十还是很靠谱的</li>
</ol>
<p>选择哪个网站查询：</p>
<p>链家在线的原因：虽然有点做广告的嫌疑，但是这个确实很牛逼，链家花大价钱请IBM做的。</p>
<p>链家在线的数据与其经纪人用的内网se系统是对接的，se系统则全是当前公司全部房源的内部报价。相比其他的网站。比如58或者赶集安居客更准确——因为经纪人只会把好的房子往那些网站发，而不会发差的房子。此外现在这个网站上有很多房评，也有一些借鉴价值。</p>
<p>除了豪宅（上万的月租前后可谈价位空间大都在一到两千浮动）外，房子前后差价不会多于200。并且上面的房源百分之90多都是真的——个别可能业主通过其他中介租出去了没有销。所以看房价还是很靠谱的，尤其是买房。</p>
<h3 id="u67E5_u8BE2_u623F_u6E90"><a href="#u67E5_u8BE2_u623F_u6E90" class="headerlink" title="查询房源"></a>查询房源</h3><ol>
<li>公司如果给提供是最好不过了，遇到这种公司你就嫁了吧</li>
<li>如果人脉够宽广，最好是找熟人介绍，这种一般还是比较靠谱的，还能免去中介费神马的，最方便，并且租金还便宜。</li>
<li>找中介。</li>
<li>网络上慢慢翻业主自己发的贴</li>
<li>街边小广告，这是一种找房的方法，就是比较费时间，并且有些也不靠谱。</li>
<li>有些小区的物业也会做做，但是大部分还是做卖的房子的，比如御景园，但是费用照样收的。</li>
</ol>
<p>网站上大部分都是中介发的房子，所以挑个顺眼的公司顺眼的经纪人就行。</p>
<p>有一些有区别的是大一些的中介公司比如链家、丽姿行等房源是内部共享的，新老经纪人的差距就是讲价的能力，房源优势是一样的。</p>
<p>而有一些小公司他们的经纪人会藏房源，建议找个老经纪人，但是如果你涉世未深，也更容易被忽悠，摆脱不掉。</p>
<p>网上发的房源超过半个月的就不要给他打电话了。</p>
<p>链家在线（链家独有的），58同城，赶集，安居客，搜房网这些是租赁经纪人常用的网络端口，房源多且新。</p>
<p>新浪、焦点网、搜狐，这些是买房的人必看的几个，租赁房源不如前几个。</p>
<blockquote>
<p>什么样的房子是好房子？</p>
</blockquote>
<ol>
<li>精装修，家具家电全齐</li>
<li>朝向：即主卧室窗户的朝向，南北通透或者东南向、西南向、南向</li>
<li>主要建筑类型按照舒适度和人的密度排名：<ul>
<li>板楼：简单说就是分单元的长条楼，人均密度比较低，一般是6层（例如十里河周庄家园），不带电梯。当然也有带电梯的高板（小高层，参考十里河山水文园）。板楼的南北通透户型比较多。</li>
<li>塔楼：人均密度比较高吧，其他的也都还可以。（参考御景园）</li>
<li>板塔结合：一般是出现在小区四个角上的楼型（例如十里河美景东方拐角的四个楼）。</li>
</ul>
</li>
<li>集中供暖</li>
<li>不把边：一般是相对于板楼来说的，就是不靠楼的最边上的意思，听说冬天会有一些问题，不过我觉得还好吧。</li>
<li>地铁房：其实我觉得步行在十分钟左右的房子都可以算。</li>
<li>不临街：在小区中间的房子，不吵。</li>
<li>人车分流：一般高档小区才会这样，一般租房不需要考虑这个。代表十里河的山水文园。</li>
<li>1000米内没有六类嫌恶设施（这个很重要）：飞机场（1000米）、加油站50米、高压电站（15米，这个说明一下，主要是要看看窗外是否有，孕妇要远离这样的房子，有辐射）、垃圾处理场（500米）、工厂（200米）、墓地/殡仪馆</li>
</ol>
<h3 id="u8054_u7CFB_u4E2D_u4ECB"><a href="#u8054_u7CFB_u4E2D_u4ECB" class="headerlink" title="联系中介"></a>联系中介</h3><p>首先给各个中介公司按照好感度排下号</p>
<p>链家地产（北京最大的中介公司）、丽姿行（专做高端豪宅的，普通住宅业务不涉及，有想租豪宅的可以去）、麦田房产、中原、21世纪（一般是加盟店，其实人员素质也是参差不齐，一般也不要找）、顺驰……我爱我家。</p>
<p>我爱我家还是比较没好感的，因为同事出现过被枪单还被威胁的，这仇真记一辈子啊made。</p>
<p>前三家还是不错的，虽然是竞争对手但是觉得麦田和丽姿行还是不错的。但是链家和丽姿行中介费不打折（只有小部分情况下会略有小折扣。），其他的中介公司折扣就比较大，做私单的也比较多，比如我爱我家。</p>
<p>关于跟中介打交道几个事项</p>
<ol>
<li>中介电话都是24小时开机，随便什么时间打都行。不建议在在网页上聊天，因为北京中介们大部分时间不会守着电脑的。建议电话联系。</li>
<li>尽可能完善的把你的需求告诉中介，北京的中介行业相对成熟，服务也还不错（当然收费也高），他会给你筛选，以促进成交。</li>
<li>一定要守时。经纪人倒是无所谓，其实关键是给房东留下好印象。大家都很忙，有些房东很在意时间问题。</li>
<li>如果选定了某个小区，一般看两~三次房再定。因为一般中介带你看房子，会给你准备三套房一套最差，一套最好，一套居中的房子，这是中介最常用的ABC法则，一般看完第一次房子中介就会逼定，就是逼你交订金，一定要挺住。</li>
</ol>
<p>原因：第一次中介带你看房，其实也是在试探你的需求，所以如果开始对房子有什么需求，一定要跟经纪人说（当然不要当着业主的面说，因为会伤到业主。）</p>
<p>你第一次没定之后，他会根据你的需求信息再一次的筛选更优质的房源，而且有时候好房的房主不一定有时间。</p>
<p>另外中介第一次带你去看的房子一般都是有钥匙的房子，房源不一定优质，而第二次或者第三次则是更精心选的。</p>
<h3 id="u770B_u623F"><a href="#u770B_u623F" class="headerlink" title="看房"></a>看房</h3><p>一般一次两三套就行了，具体参考前面好房子的特点，但是这几个特别注意：</p>
<ul>
<li>房主是否是本人。</li>
<li>嫌恶设施。</li>
<li>中介费谁出。</li>
<li>水电燃气取暖费和物业费谁来出。</li>
<li>家具家电是否齐全（床、空调、冰箱、洗衣机，缺什么跟房东说好了。）</li>
<li>卫生间。</li>
<li>朝向，房间的朝向指的是主卧的朝向。</li>
<li>如果是塔楼，问问是否是管道层。</li>
</ul>
<p>普及知识：其实一般的中介会在报价的时候藏价，但是也有一些是真的给你谈下来的。主导价格的因素主要有两个：经纪人能力和客户形象</p>
<p>在客户挑房子的时候其实业主也在挑客户。业主都是很爱惜自己的房子的。特别注意以下几点：</p>
<ul>
<li>进房之前要穿鞋套，中介会为您准备的。</li>
<li>如果业主在，热情的跟业主打声招呼，离开后问好，给业主留下好印象。</li>
<li>跟业主简单交流时注意把以下几点“透露给业主”：工作稳定，住的人少，爱干净，爱惜房子等</li>
<li>进门后如果业主在，不要说房子破旧不好，乱挑毛病来自己压价。不要跟业主起冲突。</li>
<li>有什么不满或者要求等出门以后再说，把自己理想的价位跟经纪人说让他去谈</li>
</ul>
<h3 id="u7F34_u7EB3_u610F_u5411_u91D1_u6216_u8005_u8BA2_u91D1"><a href="#u7F34_u7EB3_u610F_u5411_u91D1_u6216_u8005_u8BA2_u91D1" class="headerlink" title="缴纳意向金或者订金"></a>缴纳意向金或者订金</h3><p>想说一个叫做意向金的，其他公司不知道，在链家这个意向金还是挺好用的（其他公司不太清楚），尤其是在租房高峰时。意向金不是订金，没有法律效益，可以收回，中介拿这个意向金有四个作用：</p>
<ol>
<li>拿着这个钱去跟业主谈价（对，一般的房子是可以谈价格的，浮动大概在200~300左右。浮动的原因大概有两个：1因为中介会藏一些价格。2中介没有藏价而是后期跟业主谈判砍下来的。），意向金代表你的诚意，如果中介砍价成功那么中介就会将意向金交给业主变成订金，就拥有法律效益，业主违约归还订金加违约金，你违约会没收订金。</li>
<li>禁止同公司的人竞争，先交意向金或者订金的人可以先谈房子。</li>
<li>把控客户。</li>
<li>还有一个小小的擦边作用就是利用2中所说的禁止竞争占房子，在高峰期时自己还不确定是否租这个房子时候用。</li>
</ol>
<p>注：如果房子不满意不要随便交钱，还有这些个金其实也没有一定规定要交多少，通常中介会说一个月房租，但其实500—1000的都可以，当然如果对房子真的有意向那建议交齐。还有要对经纪人说非常重要的一点：我让你交你才交。但是小公司不要随便交钱，会扣压。</p>
<p>交意向金后会有一个单据，要收好。</p>
<h3 id="u7B7E_u7EA6"><a href="#u7B7E_u7EA6" class="headerlink" title="签约"></a>签约</h3><blockquote>
<p>三方到场</p>
</blockquote>
<p>（中介公司代理房除外，避免吃差价），签约时长大概需要2-4个小时，合同期限一般是一年。</p>
<p>所需材料</p>
<ul>
<li>客户需要带的材料：<ul>
<li>本人身份证原件，</li>
<li>钱（中介费、房租和订金）</li>
</ul>
</li>
<li>如果你是替朋友租房或者签合同，那么需要带上：<ul>
<li>你自己的身份证原件</li>
<li>你朋友的身份证原件或者复印件</li>
<li>你朋友手写的授权委托书（如果是打印的需要有签字和手印）</li>
</ul>
</li>
<li>业主需要的资料（客户最好仔细看一下）：<ul>
<li>业主身份证原件</li>
<li>房本，没有房本的需要购房合同</li>
</ul>
</li>
<li>如果签约人非房主本人：<ul>
<li>签约人身份证原件</li>
<li>房主的身份证原件或者复印件</li>
<li>房主手写或者打印的委托书，</li>
<li>房本,无房本的需要购房合同</li>
<li>如果房主为两个人，一位没有到场的话需要他的同意出租证明。</li>
</ul>
</li>
</ul>
<p><strong>起租期：</strong>这个要注意，就是开始计算房租的日期，一般是签约的第二天。但是呢，如果你房子还没到期，可以协商把起租期定的晚一点。你就说给个搬家的时间，房东一般都会同意。一般可以争取到三天到一个周（所以周天看房，最好周一二晚上签合同，拿钥匙做物业交割然后白住一个周，哈哈），按照北京的房价，可以省下好几百。</p>
<blockquote>
<p>付款方式</p>
</blockquote>
<p>押金+支付的月租金。押金和租金全部交给业主，押金在房子到期后返还。</p>
<p>一般分为：押一付一（即押一个月租金付一个月的租金），押一付三（也就是季付），押一付六（半年付），年付。当然个别情况还有押金交两个月的。</p>
<p>大多数情况都是季付，当然付款方式越好，越有利于中介砍价，押两个月的租金和半年付、年付都属于比较好的付款方式，这样一般的业主也都乐于把价格再低个100—200。</p>
<blockquote>
<p>一般中介费标准</p>
</blockquote>
<p>一般是一个月房租，不同公司会有不同，具体询问。</p>
<blockquote>
<p>押金问题</p>
</blockquote>
<p>代理房押金是交给中介的，如果不是代理房那么押金是交给业主的，注意区分，给业主的一般都会退，交给中介的不一定。可能会克扣。</p>
<blockquote>
<p>续租缴费</p>
</blockquote>
<p>中介的代理房，看情况。跟业主签约的房子不需要再给中介缴纳中介费，中介费一次性付清。</p>
<blockquote>
<p>发票问题</p>
</blockquote>
<p>好多人提到发票问题，说不给开，倒不是想要偷税漏税或者很难开什么的，在这里给大家略为科普一下：</p>
<p>租房用到的发票有两个：服务费发票和房租发票。</p>
<p>服务费发票：即中介费发票，中介可以给你开服务费发票，时间一般是半个月到一个月的时间。</p>
<p>房租发票：中介不给提供。原因是无权提供。在北京在租房需要到当地街道办事处登记，是需要缴5%的税，所以大部分业主不想登记。</p>
<p>现在一般是客户拿着公司的证明文件（这个应该还分个人租房和企业用房，具体的文件问经纪人）自己到当地街道办事处开取，自己付税费。</p>
<p>负责的经纪人会代你去开取。所以这些问题都应该提前说明白，否则有些经纪人在收了钱后根本不鸟你，因为开这个发票也要一些时间。</p>
<blockquote>
<p>优先购买权</p>
</blockquote>
<p>你住的房子如果要卖，现租客享有优先购买权。</p>
<blockquote>
<p>物业交割</p>
</blockquote>
<p>仔细仔细再仔细</p>
<ol>
<li>检查各种电器，看看是否能用，不能用的要换。</li>
<li>要把水电燃气的表数抄在合同上。</li>
<li>墙体，水管等地方。</li>
<li>业主的家具以及贵重物品等级，要细化到牌子型号。 </li>
</ol>
<h2 id="u6311_u9009_u81EA_u4F4F_u623F_u768416_u5927_u5173_u952E_u8BCD"><a href="#u6311_u9009_u81EA_u4F4F_u623F_u768416_u5927_u5173_u952E_u8BCD" class="headerlink" title="挑选自住房的16大关键词"></a>挑选自住房的16大关键词</h2><blockquote>
<p>地段</p>
</blockquote>
<p>这个已经在『只谈房事』第一期用整个专栏的时间说过了，对于地段的选择，无论是自住型还是投资型，都是同样重要的。</p>
<blockquote>
<p>小环境</p>
</blockquote>
<p>就是指小区周边和小区内的环境，有点楼盘地段很好，但是小环境不敢恭维，一定要注意周边是否有高压电线，工厂，发电站等污染源，另外周边紧靠城中村的楼盘也要打折扣。</p>
<blockquote>
<p>容积率</p>
</blockquote>
<p>如果你去售楼处看盘的时候，很随口地问一句，这楼盘的容积率是多少，实用率是多少，售楼小姐肯定不敢忽悠你，因为一听就知道你是个行家。其实这个概念很简单，容积率是建筑总面积与建筑用地面积的比。容积率是越小越好，根据经验，豪宅的容积率通常都会在1.5以下。</p>
<blockquote>
<p>实用率</p>
</blockquote>
<p>上面说到这也是个专有名词，意思就是你实际的使用面积和建筑面积之比，通常不带电梯的多层的实用率会高达92%以上，带电梯的小高层在85%以上，超过15层的高层在80%以上都属于正常。有些楼盘的实用率会低的离谱，例如“信和自由广场”的房子的实用率只有70%多点，实在让人想不通面积都分摊到哪里去了。因为买房是根据建筑面积来算价的，所以买这样的房子是很不划算的。买商铺的更要注意这个，有的商铺的实用率能高达100%，“海印长城”下面的商铺，实用率才只有40%。所以买房算价格不仅仅是看单价那么简单，里面的猫腻还是很多的。</p>
<blockquote>
<p>建筑质量</p>
</blockquote>
<p>这个需要在楼盘在建的阶段就去工地实地考察，而且具有一定的专业性才能看出来。如果楼盘已经封顶了，或者买二手楼，如何判断呢？很久很久以前有个叫半球的房事达人，对每个楼盘都会亲自考察，并写一篇详细的调查报告，不过半球先生早已蜕变成职业写软文的托了。浑浑的水还有一个绝招，在每个新楼盘在销售的时候，都会在知名房产网站（如搜房网，房地产信息网）建立一个业主联系论坛，去翻一下论坛的历史内容，就能对楼盘的缺点有个最直观的了解。你能想象“学林雅院”居然没有打地基吗？你能想象“名家富居”居然没有设计排烟管吗？我也不能想象，但是我能从业主论坛了解这些信息。</p>
<blockquote>
<p>噪音</p>
</blockquote>
<p>这是浑浑的水特别重视的一个因素，这可能严重影响到睡眠的质量。不要听经纪说这个房子装了真空隔音玻璃，关上窗就特别安静这样的鬼话，不开窗的房子是没法住的。要特别注意，靠近高速路，立交桥的楼盘，是无论如何都不会安静的，即使你买的是背靠噪音源的方向也不行，不信可以去问问住“滨海之窗”，或者“创世纪滨海花园”的业主。</p>
<blockquote>
<p>楼层</p>
</blockquote>
<p>一楼通常会很潮湿，因为出入方便，安全性也差一点，有架空层的会好一些。一般楼层越高，采光和通风越好，如果旁边是马路的话，因为声波衍射的关系噪音高层的反而会比低层的要大一些。对于有电梯的高层来说，楼层越高，价格越贵，对于无电梯的多层只要记得“金三银四”就可以了。</p>
<blockquote>
<p>朝向</p>
</blockquote>
<p>这也是浑浑的水很在意的一个因素。在深圳，最好的朝向是南北通，卧室和客厅都朝南。其次依次是朝正南，东南，西南，东西通，朝东，朝西，东北，西北，正北。朝南还是朝北，对于居住的感受差异非常大。朝北的房子夏天会暴晒，冬天一点都晒不到太阳，夏天没有风，冬天的北风那个吹啊。西晒的房子一般都比较热，会让你花更多的空调费。</p>
<blockquote>
<p>通风</p>
</blockquote>
<p>通风跟设计有关，通风必须要对流，只有单面朝向开窗的房子是不可能通风的。有一些的楼盘对通风的设计很有问题，完全不通风，这样的房子对健康很不好，要慎重考虑。</p>
<blockquote>
<p>采光</p>
</blockquote>
<p>假如生活缺少了阳光，你自己衡量吧，浑浑的水觉得比较重要。</p>
<blockquote>
<p>住宅性质</p>
</blockquote>
<p>住宅性质分住宅和商住楼，房产证上面就有写。通常，商住楼里是可以作为注册地开公司的，而住宅不允许，所以一般商住楼里都有几家是开公司的，例如“青春家园”里有美容院，“金钟大厦”有家政公司等等，而“海王大厦”里基本很少住家了，大部分都是开公司的。住在这样的楼盘，来来往往的人员会很杂，所以要综合考虑。如何辨别住宅性质，最直接的是看房产证，或者还有个简单的办法，通常裙楼是商铺的住宅，性质都是商住楼。还有一个问题要特别注意，就是商住楼商铺的营业性质，如果是餐饮业的话是最糟糕的，小心可能会被油烟污染，最好能避开。</p>
<blockquote>
<p>学位</p>
</blockquote>
<p>浑浑的水特别提出学位的重要性，每个房子都有划分的小学和中学，如果划分的学校好，那么是一定会有溢价的，这个很容易理解，家长对子女的教育，都是愿意花费血本的！。例如深圳的老片区“园岭小区”，从1栋到75栋的是划分到园岭小学第一分部，75栋以上划分到第二分部，仅因为第一分部的房子就会比第二分部的房子每平方贵1000元以上。</p>
<blockquote>
<p>批地时间</p>
</blockquote>
<p>也就是地皮被批准可以建房子的时间，这个影响到房子的使用年限。目前住宅的使用年限都是70年，从批地时间开始计算。有些楼盘虽然是新楼盘，但是批地很早，使用年限是要打折扣的，例如“半岛城邦”的批地时间是1996年，入伙是2007年，这里就少了11年的使用年限。不过这个因素也不用太在意，根据新的物权法，对于这个年限到期后怎么办，根据浑浑的水的理解，只要该地皮不另作其他用途，则会自动续期，业主需要补交土地使用费，就可以继续拥有房产。</p>
<blockquote>
<p>户型</p>
</blockquote>
<p>户型的要点就是两个字“方正”。浑浑的水有个朋友精通风水，他跟我说过一句话，如果不找人看风水的话，那么就记住选择户型方正的房子，房子只要是方方正正的，风水问题都不会很大。另外就是要看浪费的空间多不多，有些房子的走廊啊，拐角都会占用过多的面积。</p>
<blockquote>
<p>开发商和建筑商</p>
</blockquote>
<p>如果在了解上面的因素后还有精力，可以再去查一下楼盘的开发商和建筑商的资历，和过往开发过的楼盘的业主论坛。像招商地产，华侨城地产这样的开发商的楼盘，通常都是有质量保证的。</p>
<blockquote>
<p>价格</p>
</blockquote>
<p>没错，浑浑的水故意把价格放在最后来讲。这里先讲一个故事，去年某天浑浑的水跟朋友聊一款车，这款车带天窗的要加2万块，他很喜欢天窗，但是觉得这个价格太不划算了，后来知道他还是买了带天窗的版本，问他为什么，他说了一句很经典的话，“我后来想通了，如果买带天窗的，我最多只心疼这2万块，如果买了不带天窗的，我会心疼整台车的价钱。”对自住房最大的感触就是，对于自己很在乎的因素，一定不要太在意价格，最关键的还是看你和这个房子的缘分。而且因为贷款的关系，其实首付价格的差别并没有你想象的大。</p>
<h2 id="u4E2D_u4ECB_u9632_u5751"><a href="#u4E2D_u4ECB_u9632_u5751" class="headerlink" title="中介防坑"></a>中介防坑</h2><p>话入正题，今天我们来聊一下和房地产中介打交道的实战技巧。其实浑浑的水并不是像你们想象的那样对中介恨之入骨，只是跟他们浑久了，对中介的黑比一般人有更深一层的了解而已。事实上，浑浑的水有一些朋友不巧就是在地产中介上班的，黑只是他们工作必须的态度而已，而并非都是他们的本性。说白了，房客和中介的关系，不过是相互利用的关系而已，尔虞我诈是不可避免的。在国内由于相关的规范和法律很不健全，所以中介基本上全部是没有诚信的。这个跟劣币驱逐良币的原理一样，当大部分地产公司都足够黑的时候，不够黑的地产公司是一定会最先倒闭的。</p>
<p>当中介带你看房的时候，会让你签一份看楼书，假如将来你买下了这套房而没通过这个中介的时候，麻烦就来了，你将会受到最恶毒的骚扰，还会威胁跟你打官司，直到你受不了给他们一些钱为止，这绝不是浑浑的水在恐吓你，这种事情非常多见。可能的话，我会尽量不一个人去，而带一个不真正参与交易的朋友或家人去签这份看楼书，就算自己签，也会用个假的名字和电话号码。这样的好处是，你可以委托多家中介帮你谈价格，假如你能直接跟业主达成协议，完全可以随便找一家中介帮你办手续，通常给2，3千块手续费就够了，否则就要支付高达房价3%的佣金，当然，这样做也要考验你做人的道德标准，浑浑的水认为对待本来就不讲道德的地产公司，根本不需要有道德的顾虑。</p>
<p>当你表示对一套房子感兴趣的时候，中介通常会用各种手段让你交一笔定金，说明谈到什么价格之后就必须签约，如果到时你想不买，定金是不退的，即使这单谈不拢，有些黑地产公司也一样不肯乖乖退款，他们会让你继续看其他的房子，直到成交为止。特别注意的是，这个价格不单单只约定单价的价格，还必须约定各种手续费，中介费，赎楼费，税费等由哪一方支付，中介通常会故意不告诉你这些，然后用最不利于你的价格来判断这个约定是否成立。浑浑的水在签约之前，是从来不交任何费用的，因为即使你不交，中介为了促成这单，也一样会去跟卖家谈价格，如果交了定金，只会让你更被动，如果中介实在不配合，完全可以换一家地产公司继续谈。记住，在交钱之前，你还是爷们，一旦交了第一笔定金，你就变成孙子了。在交钱之前，一定一定要考虑的非常清楚，真正抢手的笋盘不是那么容易碰到的，不要担心今天不签明天就被别人签了，中介通常会虚构其他的买家来促使你尽快交定金，当然这招我在卖房的时候也经常用，而且通常都很管用。</p>
<p>在和中介交谈的时候，对他说的话一定不要太相信，一切都以眼见为实。例如看房的时候说一套房子有100平方，而看到房产证的时候通常就只有90多平方，只要相差不太多，很多买家也就认了。还有很多例如是他亲戚的房子啊，独家代理啊之类的话，绝对是假话。除了假话，中介对迫使你签约都是很有一套的，所以跟中介交往一定要脸皮够厚，不好意思的人往往就直接签约交钱了，这种买家还是不少的，如果你实在脸皮很薄，强烈建议你带一个买衣服砍价很厉害的朋友来帮忙。</p>
<p>签合同之后，定金是必须支付给卖家的，假如中介代收的话，也一定要开具定金收据给你。而首付款，你一定要委托银行做资金托管，不要怕麻烦交给地产公司，这里有很大的风险，中天置业事件和创辉事件就是实例。大的地产公司通常会正规一些，而很多小地产公司会千方百计的让你把首付款打入他公司的账户甚至是个人的账户中，遇到这种公司要学会拒绝。签合同的时候一定要买方，卖方和中介三方同时在场，如果卖家跟中介交易进行了委托公证的话，一定要核实清楚委托人是否跟房产证的业主是同一人，否则你很可能被骗或者被吃差价了。</p>
<p>最后谈一个关于打印房地产交易合同的事情。为了保证交易合同的合法性，市政府管理部门拟定了一份标准的合同，这份合同可以在任何一家地产公司打印，也可以在房地产交易中心打印，是免费的。但是后来房协管理之后，取消了在房地产交易中心的打印，这样就必须要在地产公司打印合同。这样地产公司之间就建立了一条潜规则，打印合同必须交纳高达上千元的打印费，前段时间在深圳台第一现场也报道了这个黑幕。浑浑的水教你一招，遇到这种情况，不要轻易交费，直接跟中介声明要打电话到房协投诉，投诉电话是83785630，83785851，这招通常都能搞定。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于不在家乡工作的人来说，找房子算是相当麻烦的事情，这里是我收集的一些资料，希望给大家一些参考。</p>]]>
    
    </summary>
    
      <category term="找房" scheme="http://wdxtub.com/tags/%E6%89%BE%E6%88%BF/"/>
    
      <category term="租房" scheme="http://wdxtub.com/tags/%E7%A7%9F%E6%88%BF/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[买车养车开车指南]]></title>
    <link href="http://wdxtub.com/2016/03/26/car-guide/"/>
    <id>http://wdxtub.com/2016/03/26/car-guide/</id>
    <published>2016-03-26T18:46:43.000Z</published>
    <updated>2016-03-26T19:00:06.000Z</updated>
    <content type="html"><![CDATA[<p>估计以后工作了，在所难免需要买车，这里是平时收集的一些经验技巧。最重要的，安全第一。</p>
<a id="more"></a>
<hr>
<h2 id="u9009_u8F66"><a href="#u9009_u8F66" class="headerlink" title="选车"></a>选车</h2><h3 id="u4E00_u3001_u9884_u7B97_u8303_u56F4"><a href="#u4E00_u3001_u9884_u7B97_u8303_u56F4" class="headerlink" title="一、预算范围"></a>一、预算范围</h3><p>划分选车范围最简单也是最直接的条件就是钱。一般的预算分为两种，一种叫做落地预算，一种叫做裸车预算。</p>
<p>落地预算你可以理解为这一辆车从购买到能够正式上路行驶所需要的总共花费的预算，包括了买车之后所需要交纳的各种税费保险等费用：</p>
<p>裸车预算你可以理解为单独对车辆的售价所做的预算，不包括买车之后所需要交纳的各种税费保险等费用。</p>
<p>相信大部分人的购车预算都是前者，但是用这个预算来选车则很容易出现实际预算超标的情况，因为 20 万预算实际上是不够买下一辆 18 万出头的车的，在天朝各种税费再加上保险成本还是非常高的。因此我建议大家都把自己的购车预算折合为裸车预算，同时提供一个经验化的、粗略的换算公式：</p>
<pre><code>裸车预算 ≈ 购车预算 * 0.85
</code></pre><p>实际上如果完全最佳按流程来，真实的裸预算车会比这个数值高一些，但是考虑到有些 4s 还有绑定条款如必须在店内买一年保险等，再考虑到很多车主会去选择做一些全车坐垫脚垫、贴膜这样汽车装潢，适当的留下一点机动空间是有必要的。</p>
<p>这么一来，我们候选车辆范围就从和太平洋一样大的一千多个车系缩减成了一般不超过 300 款了——不过还是有北冰洋那么大。</p>
<h3 id="u4E8C_u3001_u8F66_u578B_u9009_u62E9"><a href="#u4E8C_u3001_u8F66_u578B_u9009_u62E9" class="headerlink" title="二、车型选择"></a>二、车型选择</h3><p>这里的车型指的是：三厢轿车（包括掀背车）/ 两厢轿车 / SUV / MPV / 旅行车 / 跑车 /（后面还有皮卡货车啊客车专业车辆啊之类的等等等等）。对于大部分的普通消费者而言，都是在前面的 5 种车型 （三厢轿车 / 两厢轿车 / SUV / MPV / 旅行车）中进行选择，后面的由于比较小众同时购车群体一般目的性比较明确，就不作为重点来描述了。</p>
<p>那么我们的这一步的任务就是，在这 4-5 种车中选出一种（至多两种——由衷希望你没看见这个括号里面的内容）车型作为自己的目标。那么下面就按照一个一个问题的顺序，来做车型的排除法。</p>
<h4 id="u7B2C_u4E00_u4E2A_u95EE_u9898_uFF1A_u8FD9_u8F66_u6B63_u5E38_u60C5_u51B5_u4E0B_u6700_u591A_u8981_u5750_u51E0_u4E2A_u4EBA_uFF1F"><a href="#u7B2C_u4E00_u4E2A_u95EE_u9898_uFF1A_u8FD9_u8F66_u6B63_u5E38_u60C5_u51B5_u4E0B_u6700_u591A_u8981_u5750_u51E0_u4E2A_u4EBA_uFF1F" class="headerlink" title="第一个问题：这车正常情况下最多要坐几个人？"></a>第一个问题：这车正常情况下最多要坐几个人？</h4><p>如果不会超过 4 人的话 MPV 就可以划掉了，如果正常情况下需要带上的人数达到了 6-7 人，那么你只需要保留下来 MPV 和 SUV 这两种车型，当然，我是把杰德这样的“另类”直接当做 MPV 来看的，只不过这是只能坐 6 个人的 MPV。（至于超过 7 人的情况，本人对所有 C<br>照不能驾驶的车都无法提供任何有用的选车帮助）。</p>
<p>在此我只强调一点： 假如你的车长时间需要乘坐 5 个人（如夫妻父母加上一个孩子），并且这五个人块头都不小的话，那么我建议你多考虑一下六座七座车型，因为目前大部分的 A/B 级轿车在后排坐三个人的时候，长时间的乘坐体验都是非常差的 。</p>
<h4 id="u7B2C_u4E8C_u4E2A_u95EE_u9898_uFF1A_u4F60_u9700_u8981_u8D70_u4EC0_u4E48_u6837_u7684_u8DEF_uFF1F"><a href="#u7B2C_u4E8C_u4E2A_u95EE_u9898_uFF1A_u4F60_u9700_u8981_u8D70_u4EC0_u4E48_u6837_u7684_u8DEF_uFF1F" class="headerlink" title="第二个问题：你需要走什么样的路？"></a>第二个问题：你需要走什么样的路？</h4><p>也就是你对于通过性的需要。为了方便分类先定义了一个通过等级。以下的定义无法做到准确分类，但是具有宏观上的参考价值。</p>
<ul>
<li>零级通过性 ：纯正跑车；</li>
<li>一级通过性 ：普通的轿车（两厢三厢和轿跑均包括在内）；</li>
<li>二级通过性 ：城市 SUV；</li>
<li>三级通过性 ：越野 SUV（也可以理解为“真正的越野车”）。</li>
</ul>
<p>同理，我也对不同的道路路况等级进行了一个定义（路况等级具有向上兼容的特性，即高等级的路况包含了低等级路况的全部内容）：</p>
<ul>
<li>零级路况 ：高速公路，较好的城市道路；</li>
<li>一级路况 ：高速公路，所有的城市道路，大部分的乡村道路，部分有道路的山路，部分工地道路；</li>
<li>二级路况 ：高速公路，所有的城市道路，所有的乡村道路，大部分有道路的山路，大部分的工地道路，极少量没有道路的复杂路况；</li>
<li>三级路况 ：高速公路，所有的城市道路，所有的乡村道路，所有的有道路的山路，有的工地道路，较多的没有道路的复杂路况。</li>
</ul>
<p>基本上而言，几级的通过性就代表了能应付的几级路况，并且通过性高的车辆都向上兼容各种低级路况。比如一般而言通过性为零级的各种法拉利兰博基尼是根本无法到二级路况中的山路去撒欢的，但是你开个牧马人在跑跑高速则是一点儿问题也没有。</p>
<p>那么是不是通过性越高的车型就一定越好呢？——当然不是！如果那样的话，我还是推荐大家都去买 jeep 牧马人——因为一般而言越高的通过性往往意味着相同类似的空间、动力级别下更差的操控性、更贵的价格、更高的油耗（当然价格和油耗这两条对零级的超跑到一级的轿车的过渡时不成立，物极必反嘛！）。做个比喻，类似空间和动力系统（强调一下：仅仅是宏观上的类似）的高尔夫 GTI 和途观 2.0T，前者属于典型的一级通过性，后者则属于典型的二级通过性。GTI的动力能力、操控水平远远超过途观 2.0T，而途观 2.0T 则更贵、油耗更高。</p>
<p>因此我给大家的建议是： 尽量根据自己所面对的道路等级去挑选对应级别通过性的车型，假如因为自己的喜好的原因希望扩大范围，那么也请务必将误差幅度控制在一级之内。</p>
<p>此外，原则上不建议所选择的车辆通过性等级低于自己的所需求的等级——除非是预算真的有限 。</p>
<p>举个例子，如果你就是城市道路通勤偶尔自驾，我建议你去购买轿车，可是如果你真的很喜欢坐得高高的感觉，那么选个城市 SUV 也可以，但是你如果你非得去买什么帕杰罗、普拉多之类的——我真的觉得有必要拉住你。反过来，如果你是一个越野爱好者，我觉得买一辆 A4L 绝对不是一个正确的选择——哪怕销售一再和你鼓吹这是一辆四驱的 A4L。</p>
<h4 id="u7B2C_u4E09_u4E2A_u95EE_u9898_uFF1A_u8FD9_u8F66_u4F60_u662F_u5F00_u6765_u505A_u4EC0_u4E48_u7684_uFF1F"><a href="#u7B2C_u4E09_u4E2A_u95EE_u9898_uFF1A_u8FD9_u8F66_u4F60_u662F_u5F00_u6765_u505A_u4EC0_u4E48_u7684_uFF1F" class="headerlink" title="第三个问题：这车你是开来做什么的？"></a>第三个问题：这车你是开来做什么的？</h4><p>这一点很好理解。如果你是做生意的或者是一家三四口家用的，那么三厢轿车绝对是你两厢轿车来得实用。可是如果你是小年轻一个人自己用的，那么两厢车的灵活和时尚则成为了加分项。喜欢旅游？SUV 和旅行车呀！</p>
<p>总之， 每一种车型的存在都是有其设计的出发点的，尽量让其的特色有用。不要让你的旅行车的超大后备箱始终只是一个孤零零的摆设，或者是让你的两厢车后备箱装不下的行李长期只能放在后排乘客的腿上。当作商务使用的时候我也真的不觉得一辆A3 DS5 之类的车会比一辆老老实实的帕萨特雅阁好——哪怕其实你对后备箱实际上是没什么需求的。</p>
<p>好的，三个问题结束，相信大家都已经有了自己的答案了。当然，可能有的同学就要问了：我这三个问题的答案有些是冲突的怎么办？比如我需要坐六七个人需要一辆七座的MPV 或者是 SUV，可又是做生意的，按说可能三厢车更合适，咋办？</p>
<p>请注意：以上三个问题是有排序的，当前后的问题答案出现冲突之时，以前面问题的答案为准。因为这三个问题的刚需程度是依次下降的。</p>
<p>希望此事已经确定了一种（至多两种——好吧，再次由衷希望你没看见这个括号里面的内容）车型作为自己的目标。那么再把这个也填写到你的选车条件里面去吧。</p>
<p>说明：在很多选车工具中，轿车的分类是微型车(A00 级，代表如 Smart)、小型车 (A0 级，代表如 POLO)、紧凑型车 (A 级，代表如速腾)、中型车 (B 级，代表如帕萨特)、中大型车 (C 级，代表如奥迪 A6L)、豪华车（D 级，代表如宝马 7 系），选车目标是两厢轿车 / 三厢轿车 / 旅行车可以按照你自己预算和空间要求选择 1-2 个作为大小范围。两厢车和三厢车是在【结构】一栏中进行选择的。不建议通过”座位数“进行选车，因为大部分的网站数据都有一些问题。</p>
<p>我们的选车范围总算从三位数降低到了两位数，一般情况下这里还剩下不到 50 款的候选车型，再也不像是大洋一样大了——不过依然多得让人没欲望一个一个看。</p>
<h3 id="u4E09_u3001_u52A8_u529B_u9009_u62E9"><a href="#u4E09_u3001_u52A8_u529B_u9009_u62E9" class="headerlink" title="三、动力选择"></a>三、动力选择</h3><p>其实想单纯的从账面的动力系统去看一个车的动力都是非常难的。因为每款发动机的标示参数不一样，每个厂商标示的真实性不一样，不同发动机动力输出区间不一样，匹配的变速箱型号不一样，相同型号不同车型变速箱的调教不一样。因此如果我们想从一个非常科学研究的角度来研究这个问题，会显得非常力不从心。但是如果我们跳开这些微观上的细节，本着正态分布 2σ的偏差来看，也就是 95.4%的可靠度来看——一般而言，一款车的排量大小基本上可以反映出来这辆车的性能水平。</p>
<p>我定义三种人：</p>
<pre><code>第①类：对动力基本没啥需求的，够用就行；
第②类：在够用的基础上希望动力别太肉，可以偶尔撒撒欢，想超车时无压力；
第③类：对动力要求较高，希望可以跑赢大部分的车，动力储备充足甚至过剩
</code></pre><p>对于这些人所需要的排量，按照 6 类进行分类讨论，以下①代表第①类人，以此类推，自吸代表自然吸气，增压代表涡轮 / 机械增压.</p>
<p>A 级车：</p>
<p>①自吸≤1.8L，增压≤1.6T；②自吸 1.6-2.0，增压 1.4T-1.8T；③自吸≥1.8，增压≥1.6T</p>
<p>B 级车 / 大部分家用 MPV/ 旅行车：</p>
<p>①自吸≤2.0L，增压≤1.8T；②自吸 2.0-2.4，增压 1.6T-2.0T；③自吸≥2.4，增压≥2.0T</p>
<p>C 级车及以上 / 大型 MPV：</p>
<p>①自吸≤3.0L，增压≤2.0T；②自吸 2.5-3.7，增压 2.0T-3.0T；③自吸≥3.5，增压≥3.0T</p>
<p>紧凑型 / 小型城市 SUV：</p>
<p>①自吸≤2.0L，增压≤1.8T；②自吸 1.8-2.5，增压 1.4T-2.0T；③自吸≥2.4，增压≥2.0T</p>
<p>中型城市 SUV：</p>
<p>①自吸≤2.4L，增压≤2.0T；②自吸 2.4-3.7，增压 2.0T-3.0T；③自吸≥3.0，增压≥2.5T</p>
<p>中型以上 SUV 级越野 SUV：</p>
<p>①自吸≤3.0L，增压≤2.5T；②自吸 3.0-4.0，增压 2.0T-3.0T；③自吸≥3.5，增压≥3.0T</p>
<p>以上的动力配置基本上都是比较靠谱，且范围算是比较大的，避免了大部分的误杀情况。当然，因为一些妖孽一样的发动机的存在（如上面提到的雷克萨斯 CT200 的那台 1.8L，还有反过来的例子如全新一代沃尔沃 XC90T6 上的那台 320 马力的 2.0T 以及高尔夫 R400 上面的那台 400 马力的 2.0T），所以在不远的未来难免会有一些极端情况的出现。不过对于大部分的位于中间部分的普通消费者而言，这些变化对于他们的影响并不大。</p>
<p>一般而言更强的动力系统也意味着更高的价格和更大的油耗（注：混合动力、油电混合算是价格上的例外，不过换来的一般都是更低油耗；除此之外小马拉大车和更高科技的发动机也可能导致动力更高的实际油耗更低，不过一般还会带来更贵的价格）。并且绝大部分驾驶员都不太可能完全发挥一辆车的动力潜能——也就是俗话说的没有肉车只有肉人。因此除非不差钱，否则我不建议动力配置过剩，适合自己的才最重要 。</p>
<h3 id="u56DB_u3001_u4E2A_u4EBA_u559C_u597D_u9009_u62E9"><a href="#u56DB_u3001_u4E2A_u4EBA_u559C_u597D_u9009_u62E9" class="headerlink" title="四、个人喜好选择"></a>四、个人喜好选择</h3><p>这里，大家总算是可以开始轻松愉快地完全按照自己的对于汽车喜好进行一些筛选了。在很多人的选车过程中往往都把这个放到了第一步第二步，而我则放到了第四步——没错，我的选车范围的划分顺序也是按照需求的重要性来排列的，当一个人还不够足够地了解车的时候（如果一个人可以已经“足够地了解车”，无论是真懂是假懂，他应该都不会再需要什么“购车推荐”了吧？），我个人认为其的很多“个人喜好”的优先级的重要性应该是低于价格、实用性的，甚至应该是低于动力配置的选择的。</p>
<p>在这个环节，大家所需要做的就是开始完善选车工具中的各个选项。比如手动还是自动，汽油还是混动亦或是干脆电动（补充说明一下，本人暂时不建议大家购家用型柴油车），国产品牌、合资品牌还是进口车，当然还可以选择一下哪个国家哪个品牌的车要哪个国家哪个品牌的车不要（嗯，派系粉们在这里总算可以把自己所痛恶的东西干掉了）。</p>
<p>此外在可以选择配置的地方，大家也可以把自己非常在意的一些配置选上去，如有些人无天窗不买，有些人没倒车雷达不考虑，有些人没有定速巡航不考虑，诸如此类的。我仅仅给大家提出一个建议： 在预算超过 10 万元的情况下，请记得选上 ESP 。在此顺带强烈鄙视一些无良厂家在 ESP 这样的基础安全配置上面偷工减料。</p>
<p>这里强调一点，请务必确定被自己拉黑的选项是自己绝对不考虑的，否则建议大家还是尽量少的在这一步做过多的选择，因为这里不是在列优先级、列权重，而是在做一票否决权，请慎用你的否决权，尤其是对某个车系的拉黑——虽然我依然会尊重你的选择，但是毕竟这样是很狭隘的！</p>
<p>没错，在这个什么都要看脸（和身材）的社会，车和对象一样，虽然实用性很重要，但是长得自己满意（起码不恶心）也是非常重要的。大家得辛苦一下，把所有候选车辆逐一打开，看看它的前脸，腰线，车位，中控。然后把自己 完全不能接受的 默默从名单中划掉。温柔的阿姨们总算可以把各种蒙迪欧阿特兹 CC 去掉了，年轻小伙也总算可以把各种君越天籁凯美瑞给去掉了。据说外形和内饰丑哭了一片人的斯巴鲁和长得个性得没朋友的欧宝雷诺在这一环节被大量评委直接淘汰——反正这一环节你的审美（或者说是眼缘）是唯一的标准。</p>
<p>如果在上面一个环节时你比较“博爱”剩余的车型比较多，那么我建议你在“看脸”这个环节的时候稍微严格一点儿，好好得做一些删减。而如果你在上一个环节已经把目标锁定到了三五辆车，那么我觉得你还是别苛求太多了，毕竟选着选着选没了可不好。</p>
<h2 id="u4E70_u8F66"><a href="#u4E70_u8F66" class="headerlink" title="买车"></a>买车</h2><p>如果车子只是随意挑选或是临时被销售人员说服但还想退、改的，写订金；</p>
<ul>
<li>如果车子是自己很喜欢确定了的型号或确定了的颜色非要不可的，写定金。</li>
<li>车辆是期货，一定写双方都能达成的交付时间并留有余地，这一点和销售人员协商并确认。</li>
<li>车辆有现货，交付期写今天或者自定的黄道吉日皆可；无论如何，一定要写。</li>
<li>逛车行，经常都能在经销店看到某某经典版，某某科技版等在厂家型录之外的型号，从杀价角度，不要参考这些加装的车型，要看厂家指导价。</li>
<li>如果你不在北上广，那北上广的价格对你基本没有参考作用，就算你在北上广，你在网上看到的北上广的价格对你也还是没有参考作用。</li>
<li>询价最好、最简单的办法，同城同品牌不同店询价，店不多的话，那就找同价位但更便宜一些的竞品车型做幌子。议价是情报战和心理战，娴熟的销售顾问能够了解到竞争店的库存和优惠，所以扯幌子尺度大了，比如要价过高，人家很可能认为你没真实购买意向没诚意；不了解库存，你说的车型只有他店有的话，他就吃定你了。</li>
<li>议价一定要快，不能被销售人员认为是意向级别不高的，要不人家电话都懒得给你打，得自己觉着这几天就下单了，言语间那种焦急和迫切的心态，一两天内几家内反复询价，坐在一家经销店给另一家店里销售打电话的紧迫感，一般的销售顾问都受不了就把底价报出去了。</li>
<li>车型选择上，一般的车款最低配都是拉低售价区间，配置惨不忍睹，最高配都是起营销作用，配置华而不实，中配的才是实在款。让利最多的型号很多时候不一定是最高配，而是库存压力最大的配置，什么型号库存压力最大？销售人员会主动推荐的，通常这也是卖得最好的配置（厂家压货），库存压力大的车型，通常比其他型号再便宜一些经销店都愿意（红蓝绿黄冷门颜色招手ing）。</li>
<li>前装车一般都是在车辆运输过程中局部部件损坏，按道理说这种车就不是新车了，而是事故车了，应该要返厂的，但是这其中的运输费用就摊在了4S店上，为了避免这种损失，聪明的领导们发明了「前装车」，用一些局部零件的更换来遮掩以前的损伤，通常前装车都是补过漆的，如果你购买的话相当于新车的价格买了个二手车。</li>
<li>每次你走进4S店销售顾问，都会热情地向你介绍车型，他们一般都优先介绍高配车，因为高配车的利润高，从而销售人员的提成也高，所以对于他们说自己的原装导航/真皮座椅/BOSE音箱/多功能方向盘等全部屏蔽之，你要看的是车不是附属电子，原车上面的配置所多出来的钱，你用一半就可以在汽配城买到，低配车永远是最高性价比，然后怎么砍价，很简单，去看车，然后试驾，满意了直接问销售顾问价格，此时他会让你留电话，你一定要装出一副不情愿的样子说「我觉得XX（竞争对手）也挺好的」然后给他留个电话，第二天他绝逼会给你打电话回访，你就说你现在正往XX（竞争对手）公司去准备去试驾，好的话就买了。</li>
<li>接下来的两个小时你会接到他无数个电话，压了给发个短信，直接报一个他们想都不敢想的低价，比如「二十万的车你说十六万能拿我就考虑去你们那里」，然后他们会给你报一个价格，但是现在价格还没有到底，去他们店里，然后找销售总监，就说这个价格可以，但是你还得送我一个全车镀膜／底盘装甲／原装脚垫什么的，他肯定会表现得特别为难，说「我们底盘装甲闹下来要三千多，全车镀膜六千多，原车脚垫两千多……」什么什么的，他说的这个价格除以十就是市场上的价格，他答应你一个就说明价格还有这么大的余地，话锋一转说算了，这个东西我不要了，你再给我便宜（他说那个配置的价格除以十）元吧，嗯……你成功地把销售总监闹潮了，他现在会表现得超级不耐烦，然后现在这个价格就是全市最低价了……想买车砍价还是蛮费工夫的，祝你们幸福。</li>
</ul>
<h2 id="u517B_u8F66"><a href="#u517B_u8F66" class="headerlink" title="养车"></a>养车</h2><ol>
<li>车子和人一样是要保养的，请根据说明书的指示定期或定里程进行保养和检查。4S当然可以保养保修，但是出保后如果能找到一家信得过的汽修厂更好，省钱也放心。</li>
<li>给轮胎打气的时候，别忘了车里还有个备胎，要定期检查备胎气压是否在正常范围内。</li>
<li>轮胎的厂家推荐气压一般都标在油箱盖或驾驶侧车门上，满载与空载情况下需要打的气都是不一样的。走高速胎压宜高不宜低，因为偏低的胎压反而会增加高速爆胎的危险，胎压稍微高一些还可以省些油。爆胎这件事可大可小，或许车子不至于失控，但是我相信你也不想在大热天搬动十多公斤的备胎吧？</li>
<li>机械式胎压表误差在0.1左右，实际使用的时候影响并不大。标准胎压是厂家经过测试后平衡了性能及经济性的一个参数，适当高一点的确偏离了这个平衡。但轮胎在高胎压状况下，温度和压力上升都比低胎压时要慢。新手可能疏于检查胎压，适当的高我认为会更稳妥一些。现在轿车轮胎都是低压胎，不是货车使用的高压胎。低压胎大部分情况是因为缺气而胎壁变形被碾坏，而很难因为胎压过高而炸开。每条轮胎都会在胎壁上标示出允许的最高压力，一般轿车轮胎是常温态3.0左右。只要胎压不远超这个数值，是不会因为压力过大爆开的。</li>
<li>轮胎尽量换好些的，不管是夏利、吉利还是宾利，汽车动力再大也得通过四个脚才能发挥出来，用好些的轮胎能减少安全隐患。平时勤检测，磨损到警戒线就该买新的了</li>
<li>汽油标号按照说明书的指示就好，加高标号的汽油对发动机没有坏处，而且油耗会稍微低一点点，省油不省钱。</li>
<li>更高辛烷值的汽油不代表油品更好，国内有些油站的97号汽油是通过添加剂来帮助达到标准的，油品甚至没有正规油站的93号汽油好。</li>
<li>按照压缩比选择燃油是以往化油器车的经验，如今的发动机都是电喷的，会根据燃烧状况进行相应调节，只要燃油标号不低于推荐值就不会出问题。</li>
<li>加油尽量去大公司的直营油站，不要去小油站或者大公司的挂靠民营油站。如果当地有外资的加油站也比较放心。</li>
<li>机油大致分三种：矿物油、半合成和全合成。4S店保养通常用的矿物油或者半合成油，同等使用状况下用全合成或半合成机油可以延长机油寿命，可以通过机油试纸来判断机油衰减情况。</li>
</ol>
<p>另外：</p>
<ol>
<li>会换轮胎。我以前的状态是在有起落架的情况下30秒一只轮胎，一般来说后备厢应该常备一个千斤顶和套筒，在需要的时候能独立拆卸和安装轮胎，免得出现有设备没本事搞的尴尬状态，好比我表哥上礼拜轮胎没气还开了好远，最后车胎爆了，然后一个电话害我老爸开了50多公里去帮他换轮胎（感觉好弱！），另外实习生刚进去最先开始做的就是给轮胎打气，按照我小半个月的经验来说，轮胎气打到轮胎硬，踢上去能有轻微凹痕为宜，太满的话开高速容易爆胎！</li>
<li>知道机油汽油制动油和防冻液的使用。没事机油尺拉出来瞧瞧，看看油线的位置和油的颜色，随时补充机油，如果颜色实在太黑记得去维修点更换机油，油箱尽量不要出现空油状态，制动油的颜色和刻度线位置要熟知，如果缺少太多记得及时补充，防冻液不仅起着防冻作用，也起着防止爆沸的作用，因此平时要保持水箱中防冻液和水的补充，别到了大冬天才想着加，大热天也是很需要的，如果你只用水的话100摄氏度就开始沸腾了！你的车开在路上会冒烟的哈哈哈！</li>
<li>刹车和油门的问题。可能有人会觉得我小题大做，我前东家是上海一家著名的上牌点（以按排量分别收取服务费用而出名），最让我无力吐槽的是当时有个老板带着司机来上牌，是辆百万的雷克萨斯，上完牌后老板很开心，要求自己开车回去，然后出了咱们店门，左转，加速，撞墙，四个气囊全部弹出来……好吧，你牛B你有钱，NO ZUO NO DIE的最好体现……然后老生常谈一句：开车时右脚平时放在刹车上，要加速再轰油门，轰完油门请高抬贵脚放回刹车上，谢谢！！另外如果刹车和油门感觉有黏滞的话请马上前去维修，制动系的问题都是大问题，一定要重视！</li>
<li>如果想要学习的话，最简单的就是跑4S店的维修区域找那些维修师傅去唠唠，切记不要跑到维修接待（汽车售后维护顾问）那里去，说真的这些维修接待除非有维修经验，否则基本都是些没学历没水平的。不是我个人吐槽或者鄙视啥，在4S店里除了老师傅，新进的维修工基本都有大专或本科学历且为相关专业有相关证书，这些都是硬指标；而负责维修接待的那些人反而只有中专职校级别，这工作不需要特定证书和技能，只要你会忽悠！比如打方向盘有异响是明显的转向轴问题，他们的报修单上竟然会写：左转右转方向盘会发出嘎吱嘎吱的声音，我们这些搞维修的除了orz真是无力了……但是不得不说，他们装得会比较专业，所以有问题找维修师傅问会比较靠谱，而你问维修接待多半会让先让你进保，这是本质上的区别。这里我插两句，你可以试试问这些维修接待：1.车辆保养要做的轮胎动平衡，具体是为了什么目的才做的，怎么做？指标是什么？2.刚才楼上说的所谓的燃油添加剂，添加燃油添加剂主要目的是什么？润滑？去积碳？那么积碳主要的成因是什么？为什么现在的车辆会有积碳？难道仅仅是因为油品不好？</li>
</ol>
<p>首先，对于车辆的日常保养请务必用心</p>
<ol>
<li>每两周校准车胎压，高端车型记得给胎压做初始化。这要求你记得胎压值，或者能识别左前门上的胎压值标签。胎压不准确的后果，直观地说有两个：其一，容易使车辆跑偏。一腿长，一腿短，这个应该比较容易理解。其二，会吃胎。胎压过高吃中间，胎压过低吃两边。再往大了说，操控性、油耗、胎噪都会影响到。</li>
<li>定期打开车辆的前盖，看看里面有没有小喵、小汪、小吱（老鼠）的脚印。猫猫狗狗最多在里面取暖，小吱可就没有那么客气啦，它们会咬线哦！会嘘嘘哦！会在里面修房子哦！运气好的话，你还能看见它们的宝宝哦！如果有脚印了怎么办？请先反思一下你的停车位，是不是在老鼠王国——地下停车场？还是在垃圾桶的旁边？你从来没有打开过发动机的下护板，所以你不知道里面会有煎鸡蛋水果核编织袋鼠便便……</li>
<li>如果是高端车，建议使用燃油添加剂。它是发动机的保养品，就像女孩子的面霜一样，不一定能让你返老还童，至少让你衰老得慢一点。国内的油品质检我不做评价，我是见过很多加完汽油后发动机故障灯亮的汽车。那什么，您都打算买了，就还是买4S店里的吧，有点贵，但是你的发动机会更喜欢一点。加油站的……我没用过，不做推荐。</li>
<li>洗车时请注意保护你的雷达、摄像头：它们有点娇弱，不耐高压水枪的折磨。还有你的软顶敞篷也是哟～</li>
<li>你再洗车时，要记得清洁雨刮片和前挡玻璃。玻璃上团状的水痕主要是油渍引起的，汽车尾气里的油液、路边烧烤摊的油液都会附着在玻璃上，所以清洁玻璃不光是去砂石，还有去油渍哦！</li>
</ol>
<p>在雨刮条和玻璃之间，会藏着很多细小的沙石。如果你不清理掉它们，它们就一直躲在那里，你一动雨刮，玻璃和雨刮都会受到磨损。还有雨刮是橡胶制品，不耐晒，老化以后刮动会有声音，会抖动，所以请给它防晒！宝马给出的建议是每六个月更换一次雨刮片，仅供参考啦！雨刮片是安全件，它们还是很重要的啦！</p>
<p>雨刮水壶的位置一般位于叶子板的位置，所以它的盖盖也比较边缘化，统一的标识是一个蓝色的盖子，就像这样（手机传不上图片，请原谅T_T，大家打开前盖自己找找吧）保养它的时候，请你：</p>
<ol>
<li>使用专用的雨刮水。不要用洗衣粉、洗洁精……</li>
<li>定期加水。有些质量不过关的雨刮水在缺水情况下会变成果冻，然后它们会堵在管道和喷头处，然后就堵上了，堵、上、了……</li>
<li>加水请加干净的水。理由同上，避免堵塞。</li>
<li>请阅读车辆的使用说明，知道雨刮液位低的报警标志。（我一定不会告诉你，有客人给我打电话说是花盆里面冒出烟花的那个灯……）</li>
<li>没有水的时候强迫雨刮喷水，驱动马达会烧掉的！</li>
</ol>
<p>然后我们来说说冷却液（先说重点的）</p>
<ol>
<li>发动机的整个冷却系统都是带压的！！！我们可以把它理解为：热车状态下的冷却液，就像是被狠狠摇过的可乐——一旦被打开就会成喷射状往外冒（请脑补……脑补不来请实验）。而且它的温度很高哟，看看你的水温表，它指几度水就几度。</li>
<li>冷却液是有颜色的，或者红色，或者蓝色。如果有天你看见车子下面有水，先分辨它是油还是水，如果是水，看看它有没有颜色。没颜色的是空调水，有颜色的是冷却液。确定是冷却液泄露以后，直接叫拖车，不要启动发动机！因为你是新手司机，你能做的只有求助场外观众。</li>
<li>如果冷却液没有明显泄露，只是有一点点减少（你目测它少了），可能只是冷却系统压力比较大，把它压瘦了一点，释放掉压力后液位会回升。</li>
<li>冷却液的液位一般在Min和Max之间就可以了，不要像处女座那样较真╮(╯▽╰)╭</li>
<li>如果非要添加冷却液，请只！加！一！种！在4S店里买一瓶，备用就可以了，不要红的蓝的绿的看着是冷却液通通往里加。</li>
<li>如果你决定加水，请加纯！净！水！不要认真地说：我特地给它加了农夫山泉……发动机不缺钙铁锌硒维生素，它要的是液体良好的循环性，且不容易产生水垢，所以各大品牌矿泉水可以留着您自己喝哈~</li>
</ol>
<h2 id="u5F00_u8F66"><a href="#u5F00_u8F66" class="headerlink" title="开车"></a>开车</h2><ol>
<li>汽车能开多快，它对人造成的伤害就能有多大。无论如何人的血肉之躯是无法与具有钢铁车身的汽车抗衡的。ABS、ESP等只能辅助你避险，而汽车往哪里开、开多快最终是由驾驶者决定的。所以需要永远把安全放在第一位，时刻注意安全，自己不要去撞其他的人和车，也尽量避免其他车或人撞到自己。商业保险当然也是必需的，特别是强制的第三者责任险，最好能买50万以上额度的，国内一线城市请尽量买一百万以上的。</li>
<li>车子是一件工业产品，所以使用它之前，请认真阅读它的使用说明书。不仅要了解车子有什么功能，还要把这些功能发挥到极致，这才是一个好的使用者。况且你为这些功能付了钱却不用也是一种浪费。</li>
<li>不要把东西放在阻碍视线的地方，例如前挡风玻璃下面或者后尾厢的搁板上面。汽车工程师为了改善驾驶者的视野下了很大的工夫，不要让他们的心血因为车内花花绿绿的挂饰而白费。而且视线被遮挡会造成行车安全问题，这是最致命的，也是你最不希望看到的。</li>
<li>车子的行驶证是需要随车携带的，所以最好在车上找个隐蔽的地方把它藏起来，保险等车辆相关证件也是如此。但驾驶证是身份证件，需要随身携带，不要放在车上。</li>
<li>在车子的储物格里面放一些现金、手电筒、创可贴和胶带等备用物品，以备不时之需。</li>
<li>「对于借车这种事情需要慎重考虑，因为发生重大交通事故的话车主要承担连带责任，所以车子轻易不外借，要借也得给那些你愿意为他们承担责任的人。」简单来说，从《侵权责任法》颁布以来，就没有机动车所有人承担连带责任这一说了。</li>
<li>认得路上的常见车型，这样你就可以在发生交通事故的时候准确地向警察描述车辆特征，比如「一辆银色奥德赛与一辆浅蓝色马自达5在滨河大道西行方向赤尾人行天桥附近发生擦碰逃逸」。另外一个办法就是使用手机拍照或者在车内安装行车记录仪，这些措施都有助于事故的处理，同时还能防碰瓷。</li>
<li>一定会为新车的第一道划痕、第一次擦碰而懊恼。但车只是个工具，人身安全才是最重要的。小划痕不要太着急处理，注意一年内的出保次数，尽量不要超过三次，以免因此影响下年的保费。</li>
</ol>
<h3 id="u9A7E_u9A76_u7BC7"><a href="#u9A7E_u9A76_u7BC7" class="headerlink" title="驾驶篇"></a>驾驶篇</h3><ol>
<li>上车前，注意观察车子的外观和车轮状况，留意车周围有没有小孩或者宠物狗在玩耍，车轮气压是否在正常范围内。</li>
<li>开车前调整好座椅位置和后视镜的位置。一脚把刹车和离合器踩到底时膝盖还能适当弯曲的坐姿是比较合理的，方向盘应调至双手手腕能自然落在其顶端的位置。</li>
<li>挂P挡或从P挡挂到其他挡位的顿挫感是因为变速箱的P挡卡锁的锁紧或释放，挂到D挡的顿挫可能是因为冷车时的转速差异，N挡转D挡的顿挫也有可能是变速箱的匹配没有做得很好。</li>
<li>挂挡时从P挡挂到D挡，快速通过R挡时是不会执行换挡动作的。因为现在的变速箱都是电子信号控制的，短时间通过R挡并不会触发换挡动作。</li>
<li>高跟鞋不是用来开车的，女性驾驶员可以在车上备一双平底鞋。</li>
<li>让车上的每一个人都系上安全带，包括第二排和第三排的乘客，12岁以下的儿童乘车要正确使用安全座椅。安全气囊、车身结构和吸能区在乘客没有系好安全带的时候都是没有用的。</li>
<li>方向打死之后要记得回一点，长期打死方向会导致液压助力转向系统处于最大输出功率，容易减少助力转向系统寿命。电动助力转向系统不存在这个问题。</li>
<li>车子启动以后要经常注意刹车是否正常，车辆满载时要比平时提早刹车。</li>
<li>有机会的时候试试大力刹车，体验一下ABS顶脚的感觉。知道自己的车子在极限情况下的动态表现，大力刹车是每一个驾驶者都需要懂的技巧。当然大力刹车的时候要通过后视镜注意后车动态，最好在急刹车的同时开启双闪灯提醒后车注意，以免被追尾，如果后面跟着大货车还是别急刹了，保证安全的情况下赶紧换个车道保命要紧。</li>
<li>驾驶的过程中经常注意看左中右三块后视镜，变线的时候更要多注意后视镜。</li>
<li>变线前记得打转向灯，提醒他人自己要变线了。</li>
<li>变道时要通过第二块侧窗观察自己的侧后方，看看盲区里有没有车辆。自己行车时也尽量避免在其他车的盲区范围内长时间行驶。</li>
<li>变线的时候尽量比别人快，让后车踩刹车的变线不是安全的变线，如果变线条件不足应该放弃变线。</li>
<li>从匝道转入主道时一定要注意主道的车子，必要时减速让行。并入主线时一定要尽快加速到车流均速，成功并线的标准就是不让主道的车子刹车减速。我觉得欧洲一部分国家的做法很好：每次主道的车辆路过匝道时都会变线到快车道，给右边车辆充足的空间并入主道。</li>
<li>每一次上路其实是一次占用道路资源的行为，在不超速的情况下请尽量把车开快些，这样交通会畅顺很多。不要在城市快速道上慢行，路上最危险的不是绝对速度，而是相对速度。车流速度80，自己只开40也是一种非常危险的情况。</li>
<li>学会防御性驾驶，眼光放远一些，预判路上可能会出现的各种突发情况，同时心中要及时想到合理、有效的对应方案。</li>
<li>在路上尽量远离大货车与大客车，尾随大货车的话有可能会被货斗内掉落的石头砸坏挡风玻璃，大货车后轮卷起的碎石也能把前挡风玻璃刮花。被大车尾随也是很危险的，国内的大车安全标准不够高，超载严重，紧急刹车的时候距离要比小车多不少，容易引起追尾。</li>
<li>行车的时候不要与其他车辆并排，这样会使得你的注意力分散到两侧，忽视前方的状况，也会阻碍后面的车辆超车，没有公德。</li>
<li>车灯不光能照亮道路，也能让别人看到你的车子，所以天色灰暗，看不清其他车辆的时候就应该打开前车灯了。深色车辆尤其要注意。</li>
<li>市区夜晚会车时不要开远光灯，前面有车的时候也不要开远光灯，变线提前打灯。雨雾天能见度差的时候打开前后雾灯，紧急情况下开双闪灯。夜晚超车时，如果前车没有注意到你偏离了车道，可以适当闪动远/近光灯并鸣喇叭。</li>
<li>如果有人在你正后方闪动远光灯的话那应该是你开得太慢了，有条件的话可以变道让行；有人在你侧后方闪动远光灯的话那就是要超车了，这个时候要保持行车路线，不要变线。</li>
<li>通过任何路口的时候，脚永远要放在刹车上而不是油门上，毕竟你不知道路口会冲出来什么，非机动车和不守规矩的车辆随时都有可能出现。</li>
<li>等红灯的时候如果时间较短建议踩住刹车踏板，如果时间较长的话可以挂空挡拉手刹，自己可以放松一下右脚，后面的司机也不会被明亮的刹车灯晃到眼睛。</li>
<li>绿灯起步排在第一位的时候，如果周围视野良好，没有行人冲出来的话，请不要吝啬那一点汽油，果断大脚油门起步，这样一个信号周期可以多过几辆车，后面的人会感激你的。但如果车子两边都是大巴或者视线不好的话那起步就要小心，因为你不知道大巴车头会不会突然出现一个闯红灯的冒失鬼。</li>
<li>作为司机要照顾好车上的每一位乘客，告诉不熟悉车内设备的他们哪些开关是干什么用的，行车时要锁住全车车门，有儿童的时候记得锁上儿童锁。下车的时候，乘客必须听从司机指挥，不要自行打开车门，司机要通过后视镜确认后方安全后才能让乘客下车。</li>
<li>开在小路上也要留意路边停着的汽车，它们随时都有可能打开车门，所以有条件的话尽量和它们保持一定距离。如果避让不开则尽快减速。另外注意它们的车头，面对突然冲出来的行人或者自行车要有心理准备。</li>
<li>下雨天为了确保安全，可以打开后视镜电加热开关蒸干后视镜上的小水珠。下小雨的情况下如果侧窗玻璃有些模糊，可以通过升降玻璃这个动作来刮掉玻璃上的积水。</li>
<li>雨天开高速要遵守雨天建议限速，避免急刹车与急打方向。上次我在深汕高速亲眼看到一辆还没上牌的凯美瑞在暴雨中因为急打方向失控撞护栏。在市区压过路边积水的时候尽量慢点开，避免溅到路人。若看见前方有深的水坑尽量绕开。涉水时最好换到手动换挡模式，保持油门使得水不会通过排气管倒灌进去。如果发动机进水熄火则不应再次尝试启动，否则发动机需要拆开大修，这个修复费用可就贵了。</li>
<li>不幸在路上抛锚的时候，一定要在车子后方足够远的地方立起警示牌。所有人应尽快离开车辆，在公路护栏后相对安全的地方等候道路救援服务。</li>
<li>对路况不熟悉的时候不要随意掉头、变道或者倒车，很多事故发生就是因为司机不认路的时候鲁莽处理，后车躲避不及撞上。去陌生的地方事先查看地图，在路上使用导航，力求做到心中有数。错过路口时千万不要紧急停车，应该直接往前走，在前面路口掉头或者下了出口重新上反方向的高速。</li>
</ol>
<h3 id="u505C_u8F66_u7BC7"><a href="#u505C_u8F66_u7BC7" class="headerlink" title="停车篇"></a>停车篇</h3><ol>
<li>停车前可以把后视镜往下翻15度，方便观察地面标线及路沿。现在很多车也自带这个功能，非常实用。</li>
<li>停好车注意观察一下车子有没有停正，有没有占用多个车位，有没有给旁边的车子留下开车门的空间。不注意这些容易被别人刮碰，给别人方便也是给自己方便。</li>
<li>如果可能的话在车辆左边留多一些空间，副驾驶一般没有司机细心，猛一下开门容易碰到旁车。</li>
<li>车驶入地下室请开启近光灯，不要因为地下室灯光够亮就偷懒，开灯是为了让别人注意你。倒车的时候要把音响关掉，车窗打开，不然音乐会分散注意力，甚至让你错过倒车雷达的警示声音。</li>
<li>倒车时可以利用刹车灯和前后灯光进行距离估算，有的时候比倒车雷达还好用。</li>
<li>MPV和旅行车的尾厢门开启角度非常大，尾厢门会升得很高，在地下室打开尾厢的时候要防止尾厢门碰撞到地下室的通风管道。</li>
<li>下车的时候，记得确认所有门窗都关闭了，尤其是天窗，不然下起雨来就惨了；同时还要确认所有电器、灯光是否关闭，否则电池会很快没电，就会打不着火。停车时车内不要放显眼的财物。</li>
</ol>
<p>写了这么多，概括起来就是开车给人方便，别人就会给己方便。处处为人着想就会少很多不必要的麻烦。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>估计以后工作了，在所难免需要买车，这里是平时收集的一些经验技巧。最重要的，安全第一。</p>]]>
    
    </summary>
    
      <category term="安全" scheme="http://wdxtub.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="车" scheme="http://wdxtub.com/tags/%E8%BD%A6/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[北美二手车购买指南]]></title>
    <link href="http://wdxtub.com/2016/03/26/na-second-hand-car/"/>
    <id>http://wdxtub.com/2016/03/26/na-second-hand-car/</id>
    <published>2016-03-26T18:46:27.000Z</published>
    <updated>2016-03-26T18:52:15.000Z</updated>
    <content type="html"><![CDATA[<p>这里是之前收集的一些在美国买二手车的注意事项和相关技巧，分享给大家。</p>
<a id="more"></a>
<hr>
<h2 id="u6982_u8981"><a href="#u6982_u8981" class="headerlink" title="概要"></a>概要</h2><h3 id="u7B80_u5199_u540D_u8BCD_u6CE8_u91CA"><a href="#u7B80_u5199_u540D_u8BCD_u6CE8_u91CA" class="headerlink" title="简写名词注释"></a>简写名词注释</h3><ol>
<li>Kbb，指著名的二手车估计网站 www.kbb.com 。其中给出了具体年份里程车的参考价格。</li>
<li>Craigslist，简称 CL，著名的二手物品交易网站，美国的 58 同城。</li>
<li>Sedan，SUV，coupe 等等都是指车的类型，或者车的结构是怎么样的。比如 coupe 是特指两门或者三门的 跑车/运动型轿车  类型。具体细分，还有 full size，medium size，compact sedan。</li>
<li>MPG，miles per gallon，借代指车子的经济性价比，即省不省 gas。</li>
<li>Make/model，make 是指车的生产厂商，比如 本田/丰田/宝马/奔驰/奥迪/…，model 是指具体车的型号，比如 野马/3 series/A6/CTS 等等。结合起来，就是 Audi A6，Ford 等等。</li>
<li>DFBB，指北美四大神车，分别 Toyota Camry，Toyota Corolla，Honda Civic，Honda Accord，排名不分先后。在2000 年左右在北美华人论坛上很火，一直到现在。这四种车以保值性高，可靠性强，誉为神车。</li>
<li>Vin，是每辆车独有的号码，独一无二，相当于车的身份证号码。查车的历史就是通过 Vin 来查的，只有两个公司提供的报告可靠，一是 Carfax，另一个是 Autocheck。</li>
<li>DMV，即美国的车管所。车辆注册买卖，驾照什么的都在这里办。</li>
<li>Title，即车子的归属权。一般有 clean/clear title，salvage title，duplicate title 等等。其中，salvage title 是属于出过重大事故，车子被total了，即维修的估算超过了车的价值。出过事故的车也可能有 clean/clear title。有一种 title 是属于没有还清贷款的 title，忘了叫啥。总之，买车只买 clean/clear title 的车，尤其当你是车盲的时候。</li>
<li>Registration，指车辆的注册，在车牌会有一个小贴纸，写明了过期的年份月份，比如 08/15。如果过期需要去 DMV renew，过期不算犯法，但上路会被警察 pull over。如果你要买的车的 registration 过期了，去 renew 就可以了，不要紧的。</li>
<li>Smog check/emission test，指年检，没通过就不能  renew registration。各州法律不同，一般十年以上车龄的车需要做。在加州，如果卖家没有做好 smog check 就卖车，是违法的。</li>
</ol>
<h3 id="u4E70_u4E8C_u624B_u8F66_u7684_u539F_u5219"><a href="#u4E70_u4E8C_u624B_u8F66_u7684_u539F_u5219" class="headerlink" title="买二手车的原则"></a>买二手车的原则</h3><ol>
<li>车子必须CleanTitle。CleanTitle 说明不仅车子不是报废车，还说明车子的所有产权都是title上面的主人。没有欠银行贷款。</li>
<li>车子可以容忍大修的历史，撞过的历史，或者租过的历史。当然没有最好。</li>
<li>一手交钱一手交title，title需要车主的signature。</li>
<li>朋友/熟人/师生/情侣之间不做买卖，道理你懂的。</li>
</ol>
<h3 id="u4E70_u4E8C_u624B_u8F66_u7684_u57FA_u672C_u8FC7_u7A0B"><a href="#u4E70_u4E8C_u624B_u8F66_u7684_u57FA_u672C_u8FC7_u7A0B" class="headerlink" title="买二手车的基本过程"></a>买二手车的基本过程</h3><p>(在这里只谈CL即Craigslist的途径，其他情况可借鉴)</p>
<ol>
<li>找个一个合适的Post，打电话联系卖家。</li>
<li>要VIN#，利用Carfax或者AutoCheck的账户查车的历史。</li>
<li>确定见面看车时间地点，试车。</li>
<li>去一个修车厂找个mechanic做个inspection。</li>
<li>一手交钱一手交title。</li>
<li>去DMV办手续，也可以让AutoRegistration Company 代办，手续费大概40刀。</li>
<li>一番折腾后，终于拿到了带有你的名字的title。你落泪情绪飘零，来地里发经验求大米。</li>
</ol>
<h3 id="u9664_u53BB_u8F66_u4EF7_u5916_uFF0C_u517B_u8F66_u7684_u82B1_u9500"><a href="#u9664_u53BB_u8F66_u4EF7_u5916_uFF0C_u517B_u8F66_u7684_u82B1_u9500" class="headerlink" title="除去车价外，养车的花销"></a>除去车价外，养车的花销</h3><ol>
<li>去 DMV 注册的费用以及交易税。这部分费用一般不能减免，另外最好不要把交易的价格填得很低，这样虽然能省一点税，但对你不利。当然，各州情况不同，我这里是 CA 的情况，在 AZ 买车是没有交易税的。至于多少，一般 registration 的费用大概 100 刀左右，交易税是 8% 左右吧，不好估计。</li>
<li>保险。保险有得是按月份，有的是按年。我在大农村的地方，用的最低保险，300 刀管半年。保险这个因人而异。</li>
<li>油费。这个可以自己计算。利用车子的 MPG 和自己平时走的路程。保守点算。</li>
<li>维修与保养。其实很多活自己可以 DIY 做的，我也写了一些帖子介绍。比如换 brake pads，前后八片用中上档次的牌子，自己换的话一共用不了 80 刀。看到版上有人1000多刀换了这些，感到心痛。可见 dealer 有多黑，放血是往死里放。咳咳。</li>
<li>停车费用，自己看看学校 parking lot 的收费标准。</li>
<li>罚单。我平均6个月会收到一次停车的罚单，最近一次是在 Downtown LA 停车的时候，没有把咪表给的回执放到车窗前面。两个月后罚单寄到家里了。童鞋们要吸取教训，以后有在咪表的地方停车，需要把缴费的小单放到前窗显眼的位置。</li>
</ol>
<h2 id="u660E_u786E_u4E70_u8F66_u7684_u76EE_u7684_28WHY_29"><a href="#u660E_u786E_u4E70_u8F66_u7684_u76EE_u7684_28WHY_29" class="headerlink" title="明确买车的目的(WHY)"></a>明确买车的目的(WHY)</h2><p>主要是这两个方面</p>
<h3 id="u901A_u52E4"><a href="#u901A_u52E4" class="headerlink" title="通勤"></a>通勤</h3><p>包括上下学上下班什么的，每天至少10mile的来回。</p>
<p>主要特征：每天必须用车，车如果坏了的话基本生活大受影响(&gt;80%)。一年的里程数应该能到5000 miles。其实一年5000 miles 不算多了，如果在LA 这种大地方通勤，一年20000 miles也很正常。全美国汽车的平均年里程是10000 miles左右。如果你买车是来通勤，就可以稍微算算到时候卖车的里程数，看看值不值当。</p>
<p>评价：车子如同是鞋子，天天要用，reliability非常重要。另外如果往返距离比较长(超过30mile)，需要考虑一下车子的MPG (Mileage Per Gallon)。</p>
<h3 id="u8212_u9002"><a href="#u8212_u9002" class="headerlink" title="舒适"></a>舒适</h3><p>包括方便买菜、方便出去玩、住得不远(5mile来回或者有公交站)但有车方便。</p>
<p>主要特征：一周用2-3次，不是天天开，车如果坏了生活略受影响(&lt;30%)。一年的里程数有3000 miles就不错了，可能主要是去华人超市或者小长途(往返500miles)。这时候，比较高里程但年份新的车子就比较适合你了。等到resale的时候，虽然你的车买来时里程比较高，但由于你没怎么开，自然就和年份平衡了。</p>
<p>评价：车是提高生活质量的东西，所以没有必要上cheap used car。这时候可以重点考虑resale 的情况。</p>
<h2 id="u786E_u5B9A_u9884_u7B97"><a href="#u786E_u5B9A_u9884_u7B97" class="headerlink" title="确定预算"></a>确定预算</h2><p>根据你买车的目的，确定自己的预算。或者，由你的预算，确定你买什么车。(以下都是USD不是人刀)</p>
<ol>
<li>Tier 1。10k以上</li>
<li>Tier 2。8k- 10k</li>
<li>Tier 3。6k- 8k</li>
<li>Tier 4。4k- 6k</li>
<li>Tier 5。4k以下</li>
</ol>
<p>这里有一个很重要的前提，就是你的预算决定了你和什么人打交道。永远记住：如果车主不是个好人，那么他要卖给你的车肯定不值得买。社会有三教九流，而不同社会地位的人由于收入不一致，开的车档次当然不一致。这里粗略分了五个档次，大概说说：(四大神车不在讨论范围之内，DFBB)</p>
<ol>
<li>最顶层的人，卖的车子都在10k以上。一般来说，这样的人不太会缺钱，所以砍价比较好砍。另外，这些人也是有着好的收入，不会为了自己的二手车而浪费太多精力。所以，绝大部分这样的车都是trade-in给dealer了，能留到CL上面的这部分车不多。一般车主都是白富美或者高富帅学生，上完大学4年以后新车变老车便卖掉走人。值得注意的是，这类车由于价格高，其实在CL上面买家没有多少的，所以很多车主也就trade-in了。买这一类车，只要你的offer高于dealer给车主的trade-in价格2k以上，估计就十拿九稳了。</li>
<li>最下面的人，卖的车子都不超过4k。这部分人，相当的鱼龙混杂。相当大的几率你会遇上curbdealer，属于自己做car business 靠坑蒙拐骗赚黑心钱，这类人一般心狠手辣，专骗不会开车看车的新手。有前辈指出怎么分辨curb dealer，最简单就是直接问车况，不说 make 和 model。如果对方说 which one?，那么99%是curb dealer。其次，如果是 title 不是卖家的名字，但是却签好名了，那么也90%是curb dealer。剩下的基本都是收入低下的红脖、尼哥、莫莫或者是穷学生。对于要买这一类车的人，必须要有强大的汽修知识，开车熟练，方能在剩下的这一部分卖家的破烂里面找到适合自己的车。当然这里面也有好车的，可是买这一类车难度很大，跟赌博一样，如果你连车都开不稳，又没有预算，那就算了吧。</li>
<li>其余档次的人。这里的就是普通人了，无非是中产阶级家里长大的伪白富美或者小红脖。没有什么特别注意的地方，不过卖家一般都不会轻易松价，得一口口吃，别妄想一下砍1k以上。</li>
</ol>
<h2 id="u9009_u62E9_u5408_u9002_u7684_u6E20_u9053_28HOW_29"><a href="#u9009_u62E9_u5408_u9002_u7684_u6E20_u9053_28HOW_29" class="headerlink" title="选择合适的渠道(HOW)"></a>选择合适的渠道(HOW)</h2><ol>
<li>二手车行，即 dealer。车行的车比较全，而且买来方便，也会有 Warranty。在车行买车是可以讲价的，但别期望能讲得很低。Sales 们都是人精，会使用各种手脚胁迫你买车，一般人不好对付他们。所以，如果在车行买车，那么你肯定是不差钱的了。</li>
<li>租车公司，如 enterprise，hertz 等等。租车公司的车特点是新，一般是 2012年，2013年的车，迈数都很大，每年迈数在 30k 左右。二手车的价格是固定的，不能讲价。讲价的特例也就是除去运输费。比如说你想在 LA买一辆红色的 Camry，但不幸全洛杉矶都没有，只有 San Diego 有这样一辆车。而租车公司运车过来就要收运输费。这里的运输费可以讲下去，但是例子很少。Hertz 卖的车有三天的试驾时间，就是说如果你三天内想退车，可以退而且只会收你三天的租车费用。值得注意的是，租车公司是资本家，具有吸血的自带天赋，能 15000.01 刀卖你的车绝对不会 15000 就卖你，所以也算是一分钱一分货，价格比 Kbb 的 good 略微低一点点。</li>
<li>特殊的组织卖二手车，比如说学校、教会等等。比如说，campus police department 有一批退役的警车，就会定价在学校或者社会公开卖。可能价格是 fixed，也可能是拍卖的形式或者 best offer 的形式，因学校而异。而教会呢，这些二手车的来源可能是 donation，而且教会为了省事，会订出比较低的价格卖这些车变现。这种买车机会可遇不可求，一般情况下是遇不到的。</li>
<li>拍卖会，即 auction。拍卖，是获取大量二手车的主要途径。在拍卖行里面有很多的私人 dealer 或者是本地非著名的中型 dealer，很少私人买家。</li>
<li>在北美省钱快报上面买其他小留的二手车。这是个买二手车的新途径，而且很多车都是豪车或者是特别新的车。不过最近有华人 dealer 冒充卖家卖车，需要提高警惕性。缺点就是地理位置限制，另外数量也不多。</li>
<li>在二手网站 craigslist 上面买二手车。这种方法是本文提倡的，也是重点讲解的。</li>
</ol>
<p>总结一下，如果你想买豪车或者是很新的二手车，那么可以去车行、租车公司或者北美省钱快报，其他途径90%的情况下都没有你想要的车，你也没必要看这篇文章了；其他情况建议去craigslist。</p>
<h2 id="u9009_u62E9_u5408_u9002_u81EA_u5DF1_u7684_u4E8C_u624B_u8F66_28WHICH_ONE_29"><a href="#u9009_u62E9_u5408_u9002_u81EA_u5DF1_u7684_u4E8C_u624B_u8F66_28WHICH_ONE_29" class="headerlink" title="选择合适自己的二手车(WHICH ONE)"></a>选择合适自己的二手车(WHICH ONE)</h2><p>这节内容是假设你已经决定在craigslist上买车了，其内容也同样适用于其他买车途径。这里介绍我选车的方法，如果按照这种方法选车，相信最后在你面前出现的是好车的几率会大幅上升。做任何事情都有相对合适的方法，而如果方法得当，那么最后完成事情的成功率会比方法不正确的完成要高。我一直认为其实买二手车是很需要方法的，具体的技巧甚至是车型都是其次的。他们的区别在于，方法是战略，而mechanics或者make/model都是战术，在战略面前显得太过不重要了。不禁想起了当年校长的“以空间换时间”的战略，即便国家贫瘠，战斗力低下，但只要战略正确，还是可以有相对高的成功率的。废话有点多，还请见谅。Let’s do this, yo！参考在第一节里的“买二手车的基本过程”，下面参照其基本过程给出详细操作步骤。只有两大步，选车和见面。</p>
<h3 id="1-_u5728_CL__u7684_u521D_u6B65_u9009_u8F66/_u5E7F_u544A"><a href="#1-_u5728_CL__u7684_u521D_u6B65_u9009_u8F66/_u5E7F_u544A" class="headerlink" title="1.在 CL 的初步选车/广告"></a>1.在 CL 的初步选车/广告</h3><p>在 CL 上面选车是件长期的事情，要做好艰苦抗战的准备。一般没有30天每天1小时的间隔地刷，是找不到自己想到的车的，所以不要着急。另外，有些看似是Deal 的Post 会被卖家delete掉，也就是卖掉了，也没必要伤感。因为买二手车并不是抢Deal这么简单，它是要陪伴你好几年的坐骑咳，着急不得。邪恶一下，说不定这种Deal有个什么隐形的毛病，一时半会看不出来。比如高速堵车时水温容易过高的毛病，就需要高速20分钟以上同时堵车才能出现，所以说是隐形的。抢了车的人很可能事后后悔不已呢，咳咳。</p>
<p>如何有效地浏览各种 Post</p>
<p>打开 CL 你所在的城市，比如 Phoenix。如果你住的地方比较大，比如 Los Angeles，那么还可以选 Long Beach/Santa Monica 等等的各种郡。当然如果觉得太远的话就可以只看离自己地点近的地方，因人而异。点击 Cars/Trucks for Sale by Owners，进入各种 Post 的页面。然后选择 gallery 的方式， newest first 的排序，选必须有 pic。选好之后，再去 research 栏里面填期望的价格。注意一定要填一个最低价，以筛选掉很多陷阱或者垃圾。比如你预算是 6000 USD，那么价格可以填 min:4000，max:7000。之所以 max 比自己的预算高，那是因为最后的成交价一般会比卖家 Post  的低。好了，这样一来，很多无效的 Post 都已经被过滤掉了，下面进入第二步。</p>
<p>点开 Post 后的再次筛选</p>
<p>a. 首先看 Post 的日期，指第一次 Post 的日期。如果这个 Post 之前 Post 过，那么你应该有印象是好是坏，可以凭感觉甚至图片关掉。本着群众的眼睛是雪亮的道理，好 deal 是轮不到你猥琐男的，一出来就会被抢掉的。所以呢，剩下来的车一般都不是性价比最好的，好车况的车需要降降价。超过3天的 Post 一律不要看了，除非是由于卖家主动降价导致的 Repost，不然都不要看了。</p>
<p>b. 其次看车是不是 Auto Transmission 自动挡，手动车就直接略过 ctrl+W 吧，当然如果你会开或者不介意那没关系。没写的话默认它是自动挡。</p>
<p>c. 接着看 Year/Make/Model 和 Odometer。这里争议比较大，一般年份10年左右的也可以接受了，但是 Odometer 最好不要超过 130k。在这里还是要俗套地说一下：我觉得如果是德国车，超过 100k 的话就不要了吧；美国车，超过110k 就不要了吧；日本车，超过 120k 就不要了吧。当然只是大概，楼主我可能会被喷，不过各位看官权当看看，了解个大概就好了。<br>d. 然后看卖家写的介绍。几个关键词：clean/clear title(必须有，如果是 salvage title 那么最好不要)，1st owner(有最好，没有也行)，有没有电话(没有电话的一律假设是骗纸)，有没有 leaks，换过什么东西(验车的时候要重点查除了这几个之外的大件)。</p>
<p>e. 最后结合所有情况，决定要不要给卖家打电话。</p>
<p>打电话干什么</p>
<p>打电话问广告里面没有的内容，特别是没有给出的特别重要的信息。一般来说，没有给出关键信息说明卖家对这个信息持消极态度。也就是说，这个关键信息对车价的影响是不良/负面的。比如，如果原文没有给出 VIN，那么需要索要 VIN#，查一下看看有没有不良的记录。又例如，没有给出里程数，那么基本可以确定车的里程特别的高，因为里程数是很明显不可能 miss 的关键信息。然后根据纸面车况和历史，把价格初步砍一砍。最后如果不错，那么就约个时间见面试车吧！哎？等等，怎么个见面，也是有学问的！</p>
<p>见面的时间地点选择</p>
<p>时间选择，最好是工作日工作时间，比如3p mon Monday。原因很简单，一是如果要去做inspection，那么得在车行工作时间可以做。可以提前预约，也可以不预约排队。二是如果要交易，写check银行能马上出钱，同时银行有人可以开证明。当然，当天办title这个不是必须。如果你当天因为这些原因不能验车或者交易，那卖家第二天把车卖给别人了就很可惜了。地点选择，最好在餐厅，比如麦当劳之类的地方。一是有wifi，如果卖家没给你VIN，你可以过去后抄下来当场查；二是公共场合，能保证安全。三是麦当劳一般靠近所在地的主要干道，附近的公交车站密集，方便你回家。</p>
<h3 id="2-_u89C1_u9762_u51B3_u5B9A_u662F_u5426_u4EA4_u6613"><a href="#2-_u89C1_u9762_u51B3_u5B9A_u662F_u5426_u4EA4_u6613" class="headerlink" title="2.见面决定是否交易"></a>2.见面决定是否交易</h3><p>a. 根据卖家的表现，确定他|她卖车的真实目的。<br>凡事都有个因果。卖家之所以卖车，也无非是有原因的：</p>
<ol>
<li>修好破车或者倒卖车辆赚钱</li>
<li>避免trade-in给dealer或者贱卖junkyard 损失更多钱</li>
<li>甩掉包袱，破车修不好了，投入的钱太多了</li>
<li>升官发财后，猛将配好马，屌丝逆袭换车了</li>
<li>其他</li>
</ol>
<p>这里的1.&amp; 4. 是主动性卖车，2.&amp;3.　是被动性卖车。所谓主动，是车主并不着急，主动权在他|她手上；所谓被动，是车主不得不卖车，有他|她自己的个人小原因，可能是搬家横跨美国了，可能是老车毛病太多，不值得修了。如何得知卖家的真实意图呢？直接问就可以了。从卖家的言语神态还是可以捕捉到蛛丝马迹的，这里就看你的察言观色能力了。结合卖家的回答，再利用下面介绍的一些trick，揣摩卖家的真实意图。</p>
<p>Tips</p>
<ol>
<li>Why do you want to sell your vehicle?如果回答是说换车了，接2；如果回答是说搬家要卖车，接3；如果是其他回答，那么卖家基本说的实话，因为所有原因里面只有前两个最好，或者说最合理最有逻辑。</li>
<li>Cool, bro. Got a new car? Can I have a look at it?如果确实看到新车了，车主还打开车门让你看看的话，基本原因就属实。啰嗦几句，如果说是因为有孩儿换了大车(SUV，minivan)，那么看看有没有专门的儿童座椅，如果有的话，这肯定是实话了。又或者是老婆怀孕，那看她肚子就行了..</li>
<li>Move to where? What time will you leave? 如果你是在他|她house或者Apartment里面，随便问问有没有其他|她不需要的或者搬不走的东西，说不定还有好deal呢。应该能观察到房间里打包的行李什么的，而且如果卖家说什么家具都不卖，从而推测出卖家是否在说谎。当然，如果地点支支吾吾的最后说了个近的，比如住在LA说要搬去LasVegas 或者Phoenix，那么可疑了，这么短的距离为何不开车去呢？如果说要回国了，那么无解了。不过说回国的，那也出现一个优势，就是砍价的时候可以尽情往下去，直到比dealer给的trade-in价格高些就行了。因为如果回国，车子肯定要卖，卖谁都一样，给bestoffer 就会卖的。而且这种回国的人，随着时间的拖延，卖车欲望会指数增长。也就是说，如果你看到之前这个回国的卖家隔了几天又把车post出来了，那么就是急了。把价格稍微压一压就可以拿下了。</li>
</ol>
<p>下面分析，针对各种真实卖车原因：</p>
<ol>
<li>赚钱赚钱赚钱！这一条卖家卖车就只是为了赚钱。无论是修好的破车还是倒卖的车辆也好，如果卖家卖车是为了赚钱，那么这动机不纯洁，什么伤天害理的事情都会发生的。车子坚决不要！靠卖车赚钱的人通常车的title都会有问题，这是很明显的证据。比如说，title上面不是他的名字，但却签好字了，说明卖家在倒卖车；title的日期很近，比如说一个月之前卖家买了这辆车，这样就很不正常。</li>
<li>避免损失更多钱，指的是卖家不希望只得到dealer的lowball offer，想卖多一点钱，这时候车子的情况可能还是不错的，就是价格可能坚挺，毕竟主动权在卖家手上。</li>
<li>修不好的破车，无论到谁手上都是烫手的山芋。一般这样的车，有明显的缺陷。比如CheckEngine Light 亮着，或者是出了车祸前bumper破烂不堪Coolant洒了满地的。车况劣等。</li>
<li>发财换车，是件好事。一来卖家手上宽裕，买了新车心里高兴，砍价好些；二来旧车不是由于机械故障才出售的，所以车况一般不错。值得注意的是，由于一般买新车dealer都会主动要求trade-in客户的旧车，所以可以说这卖家是当时拒绝了dealer的lowball offer 的。当然也可能有其他原因，比如生了小BB，家里需要SUV而不是Sedan了。</li>
<li>情况比较复杂。这里不展开。</li>
</ol>
<p>b. 验车<br>验车可以分成两个部分：一是自己试开车或者朋友试开，一是去mechanicshop 做inspection。下面展开来说：</p>
<p>试开车。<br>以后自己的坐骑，如果试开就不爽，那以后可能天天不爽。试开呢，是很重要的，你需要了解这辆二手车。试开，可以查查下面几个部分：</p>
<ol>
<li>方向盘的轻重。如果非 pickup/truck 而方向盘很重的话，可能转向液 (power steering fluid) 寿命已过，车主没有及时保养。</li>
<li>刹车性能。如果刹车有尖锐的叫声从 rim 传来，说明刹车差不多磨没了，需要更换。</li>
<li>轮胎寿命。拿个5美分的硬币塞入轮胎的缝隙中，如果林肯的头能埋进去，说明寿命还够；如果没有，说明需要换轮胎了。</li>
<li>避震器。把车子的四个角往下使劲摁，如果几下恢复原状说明性能不错。</li>
<li>加速时有没有变速箱的 slipping。就是说，加速提档位的时候，有没有一种一格一格的感觉。老车自然会有一点这种 slipping，但如果很严重，变速箱液(ATF) 颜色味道又很烂，说明其寿命不长了。</li>
<li>开完车后，趴在车底下看看有没有什么液体漏在地上了。</li>
<li>如果在冬天验车，最好在车还没热起来的时候去点火。有些车冬天点火很不容易着，但如果提前热过车后，会很容易点火。</li>
<li>试试空调和收音机喇叭什么的是不是好的。</li>
<li>各种灯，大灯远光灯转向灯日行灯倒车灯刹车灯等等..</li>
<li>还会继续补充..</li>
</ol>
<p>去mechanicshop 做inspection。</p>
<p>原则上来说，不能去任何与卖家有瓜葛的店里做检查。可以选择些著名的黑店，比如说firestone..之所以选黑店，是因为黑店对很多车的小毛病都不放过，想骗你去修。而我们做inspection就是尽可能地找出这些毛病，用来砍价。所以，你懂的。当然，如果有什么很重大的毛病，车行说要很多钱修的话，你既可以于卖家商量把价格压低，也可以不买这辆车了。</p>
<p>交易</p>
<p>记得一手交钱，一手拿带有卖家签名的title。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里是之前收集的一些在美国买二手车的注意事项和相关技巧，分享给大家。</p>]]>
    
    </summary>
    
      <category term="二手车" scheme="http://wdxtub.com/tags/%E4%BA%8C%E6%89%8B%E8%BD%A6/"/>
    
      <category term="北美" scheme="http://wdxtub.com/tags/%E5%8C%97%E7%BE%8E/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Latex 常用符号表]]></title>
    <link href="http://wdxtub.com/2016/03/26/latex-notation-table/"/>
    <id>http://wdxtub.com/2016/03/26/latex-notation-table/</id>
    <published>2016-03-26T16:37:43.000Z</published>
    <updated>2016-03-26T16:44:18.000Z</updated>
    <content type="html"><![CDATA[<p>这里记录了常用的 Latex 符号及用法</p>
<a id="more"></a>
<hr>
<h2 id="u5B57_u4F53"><a href="#u5B57_u4F53" class="headerlink" title="字体"></a>字体</h2><ul>
<li><code>\mathrm{}</code>，正常字体</li>
<li><code>\mathit{}</code>，斜体</li>
<li><code>\mathbf{}</code>，粗体符号boldfont</li>
<li><code>\mathbb{}</code>，空心粗体blackboard</li>
<li><code>\mathnormal{}</code>，正常字体</li>
</ul>
<h2 id="u6570_u5B66_u516C_u5F0F"><a href="#u6570_u5B66_u516C_u5F0F" class="headerlink" title="数学公式"></a>数学公式</h2><p><img src="/images/14590103911299.jpg" alt=""></p>
<h2 id="u6392_u7248"><a href="#u6392_u7248" class="headerlink" title="排版"></a>排版</h2><ul>
<li><code>\quad</code> 生成一个空格（相当于大写’M’的宽度）</li>
<li><code>\qquad</code> 生成一个大空格</li>
<li><code>\,</code> 相当于3/18个\quad</li>
<li><code>:</code> 相当于4/18个\quad</li>
<li><code>\;</code> 相当于5/18个\quad</li>
<li><code>!</code> 生成一个负空格-3/18个\quad</li>
<li>将 <code>\left</code> 放在分隔符前，tex会自动调整分隔符的大小</li>
<li>但是每个 <code>\left</code> 必须要用一个<code>\right</code>关闭</li>
<li>如果分隔符仅有左括号则用<code>\right.</code>关闭</li>
</ul>
<p>$$\left{ x^2 \right}$$</p>
<h2 id="u7B26_u53F7_u8868"><a href="#u7B26_u53F7_u8868" class="headerlink" title="符号表"></a>符号表</h2><p><img src="/images/14590105384037.jpg" alt=""></p>
<p><img src="/images/14590105424692.jpg" alt=""></p>
<p><img src="/images/14590105464309.jpg" alt=""></p>
<p><img src="/images/14590105502032.jpg" alt=""></p>
<p><img src="/images/14590105541907.jpg" alt=""></p>
<p><img src="/images/14590105592350.jpg" alt=""></p>
<p><img src="/images/14590105659095.jpg" alt=""></p>
<p><img src="/images/14590105709311.jpg" alt=""></p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://hustlei.tk/2014/08/latex-math-equation.html" target="_blank" rel="external">latex数学公式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里记录了常用的 Latex 符号及用法</p>]]>
    
    </summary>
    
      <category term="Latex" scheme="http://wdxtub.com/tags/Latex/"/>
    
      <category term="符号" scheme="http://wdxtub.com/tags/%E7%AC%A6%E5%8F%B7/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google 搜索技巧]]></title>
    <link href="http://wdxtub.com/2016/03/26/google-tip/"/>
    <id>http://wdxtub.com/2016/03/26/google-tip/</id>
    <published>2016-03-26T16:15:16.000Z</published>
    <updated>2016-03-26T16:16:19.000Z</updated>
    <content type="html"><![CDATA[<p>这里记录一些非常有用的搜索技巧，熟练运用后可以有效提升自己的效率。</p>
<a id="more"></a>
<hr>
<h2 id="u64CD_u4F5C_u7B26"><a href="#u64CD_u4F5C_u7B26" class="headerlink" title="操作符"></a>操作符</h2><p><code>+</code> 强制搜索</p>
<p>由于Google会忽略和过滤一些常用词（称为stop words / common words），如and、how等。使用+可以让搜索引擎强制包括这些词。使用+还可以强制过滤关键词变体形式（不让搜索结果出现关键词的其它形式），如单复数、动词时态、ing形式等等。</p>
<p><code>-</code>  逻辑非</p>
<p>用于过滤-号后面的关键词。如：MP3 -MP4，表示只搜索MP3而不要MP4的搜索结果。 -号后面没有空格。</p>
<p><code>~</code> 同义词</p>
<p>关键词前加波浪线。如：~table 。</p>
<p><code>*</code> 通配符</p>
<p>如：Google was founded in * 。</p>
<p><code>**</code> 指数</p>
<p>作用同  ^ ，如：2**10 。</p>
<p><code>&quot; &quot;</code> 引号</p>
<p>用引号精确搜索，有时可只用左侧引号。如：”Google hacking” = “Google hacking 。</p>
<p><code>|</code> 逻辑或</p>
<p>作用同 OR ，如：Google hacking | hacks 。</p>
<p><code>..</code> 数字范围</p>
<p>用于限定数值范围，如：spring festival logo 2002..2009 。</p>
<p><code>^</code> 指数</p>
<p>作用同  ** ，如：2^10 。</p>
<h2 id="u64CD_u4F5C_u547D_u4EE4"><a href="#u64CD_u4F5C_u547D_u4EE4" class="headerlink" title="操作命令"></a>操作命令</h2><p><code>OR</code>  逻辑或</p>
<p>作用同 | ，如：Google hacking OR hacks 。</p>
<p><code>define:</code>  关键词定义</p>
<p>查询关键词的网络释义。如： define:google 。</p>
<p><code>ext:</code>  限定搜索指定文件类型</p>
<p>作用同 filetype:</p>
<p><code>filetype:</code>  限定搜索指定文件类型<br>    作用同 ext: 如：filetype:pdf = ext:pdf 。目前文件类型支持如下格式：<br>    Adobe Acrobat PDF (.pdf)<br>    Adobe Postscript (.ps)<br>    Autodesk DWF (.dwf)<br>    Google地球 KML (.kml)<br>    Google地球 KMZ (.kmz)<br>    Lotus 1-2-3（wk1、wk2、wk3、wk4、wk5、wki、wks、wku）<br>    Lotus WordPro (.lwp)<br>    MacWrite (.mw)<br>    Microsoft Excel (.xls)<br>    Microsoft Powerpoint (.ppt)<br>    Microsoft Word (.doc)<br>    Microsoft Works（wks、wps、wdb）<br>    Microsoft Write (.wri)<br>    Rich Text Format富文本格式 (.rtf)<br>    Shockwave Flash (.swf)<br>    纯文本（ans、txt）</p>
<p><code>intitle:</code>  限定搜索标题中含指定关键词的网页</p>
<p>如： intitle:google search guide 。限定多个关键词用 allintitle:</p>
<p><code>inurl:</code>  限定搜索url中含指定关键词的网页</p>
<p>如： inurl:google search guide 。通过inurl:view.shtml 你可以找到在线的网络摄像头。 限定多个关键词用 allinurl:</p>
<p><code>inanchor:</code>  限定搜索页面链接锚文本中含指定关键词的网页</p>
<p>如： inanchor:google search guide 。限定多个关键词用 allinanchor:</p>
<p><code>intext:</code>  限定搜索正文文本（不含标题和链接）中含指定关键词的网页</p>
<p>如： intext:google vs mircosoft。</p>
<h2 id="u7F51_u7AD9_u7F51_u9875_u547D_u4EE4"><a href="#u7F51_u7AD9_u7F51_u9875_u547D_u4EE4" class="headerlink" title="网站网页命令"></a>网站网页命令</h2><p><code>site:</code>  限定搜索某网站的网页</p>
<p>如： site:www.google.com 。</p>
<p><code>link:</code>  搜索链向某网站/网址的网页</p>
<p>如： link:www.google.com 。</p>
<p><code>related:</code>  搜索与某网页相似或相关的页面</p>
<p>如： related:www.google.com 。</p>
<p><code>cache:</code>  搜索某网页在Google缓存（网页快照）中的旧版本</p>
<p>如： cache:www.google.com 。</p>
<p><code>info:</code>  综合查询某网页的信息，即列出上述四个命令</p>
<p>如： info:www.google.com 。作用同 id:</p>
<h2 id="u56FE_u7247_u641C_u7D22_u4E0E_u5F71_u89C6_u641C_u7D22"><a href="#u56FE_u7247_u641C_u7D22_u4E0E_u5F71_u89C6_u641C_u7D22" class="headerlink" title="图片搜索与影视搜索"></a>图片搜索与影视搜索</h2><p>filetype: 限定搜索指定文件类型的图片，支持如下格式：</p>
<ul>
<li>filetype:jpg</li>
<li>filetype:gif</li>
<li>filetype:png</li>
<li>filetype:bmp</li>
</ul>
<p>imagesize: 限定搜索指定尺寸的图片，如: imagesize:800x600</p>
<p>URL 参数：加在图片搜索网页的 URL 后面，可以实现更精细的搜索</p>
<ul>
<li>&amp;imgtype=news 资讯</li>
<li>&amp;imgtype=face 脸部特写</li>
<li>&amp;imgtype=clipart 剪贴画</li>
<li>&amp;imgtype=lineart 素描</li>
<li>&amp;imgtype=photo 照片</li>
<li>&amp;imgc=gray 黑白图片</li>
<li>&amp;imgc=mono 灰阶图片</li>
<li>&amp;imgc=color 全彩图片</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里记录一些非常有用的搜索技巧，熟练运用后可以有效提升自己的效率。</p>]]>
    
    </summary>
    
      <category term="Google" scheme="http://wdxtub.com/tags/Google/"/>
    
      <category term="搜索" scheme="http://wdxtub.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux 的概念与体系]]></title>
    <link href="http://wdxtub.com/2016/03/26/linux-basic/"/>
    <id>http://wdxtub.com/2016/03/26/linux-basic/</id>
    <published>2016-03-26T15:17:06.000Z</published>
    <updated>2016-03-26T15:38:33.000Z</updated>
    <content type="html"><![CDATA[<p>这篇日志来自 <a href="http://www.cnblogs.com/vamei" target="_blank" rel="external">Vamei 博客</a> 中的系列文章，把一些基本的内容做了整合，方便查阅。</p>
<a id="more"></a>
<hr>
<h2 id="Linux_u7B80_u4ECB_u4E0E_u5382_u5546_u7248_u672C"><a href="#Linux_u7B80_u4ECB_u4E0E_u5382_u5546_u7248_u672C" class="headerlink" title="Linux简介与厂商版本"></a>Linux简介与厂商版本</h2><p><strong>Linux简介</strong></p>
<p>Linux可以有狭义和广义两种定义。狭义来说，Linux实际上指Linux kernel (内核)。内核负责管理硬件，并为上层应用提供接口。而广义来说，是指以Linux kernel为基础的，包括OS和各种应用在内的各个Linux版本(distribution)。尽管看起来版本眼花缭乱，但实际上，各个版本之间也只是大同小异，其差别往往体现在客户群、升级维护和界面等方面。</p>
<p>Linus Torvalds是Linux之父。他根据Minix系统的代码，参照UNIX系统的设计，写出了第一给Linux内核。Linus的创举在于将Linux内核的代码开源。后来，Linux内核和一套开源的应用软件GNU结合，共同采取开源协议，并迅速发展成熟。我们可以随意地使用和修改开源代码，但以此为基础开发的程序也要根据开源协议公开。Linux和GNU的开源性吸引了大批优秀的程序员参与到Linux相关的开发中。</p>
<p>从哲学和设计理念上，Linux与其他的UNIX版本相类似，并使用类似的接口。我们可以通过学习Linux的基本概念和机制来了解其它UNIX系统，比如Solaris, FreeBSD，还有基于FreeBSD的苹果公司的Mac OS。曾经Windows的兴起曾经让许多人认为UNIX将最终被Windows取代，但如今看到Linux和苹果产品的兴盛，我很感慨于UNIX体系的力量。</p>
<p>Linux的有如下比较重要的机制: 用于储存数据以及管理权限的文件系统，用于IO的文本操作API，用于管理操作的进程，用于实现多任务运行的多线程，以及进程间通信(我将信号和网络也都归入这一类中)。</p>
<p>特别推荐下面的一些文章，以便你对Linux有一个概观：</p>
<p><a href="http://www.catb.org/~esr/writings/cathedral-bazaar/introduction/" target="_blank" rel="external">大教堂和市集（The Cathedral and the Bazaar）</a>，作者Eric Raymond</p>
<p>可以说是为Linux正名的一篇文章，深入分析Linux成功的原因。你也可以通过名字来搜索中文翻译版本。</p>
<p>该作者的<a href="http://www.catb.org/~esr/writings/" target="_blank" rel="external">其他文章</a>也非常值得一读。</p>
<p>UNIX传奇，来自酷壳，作者陈皓</p>
<ul>
<li>上篇：<a href="http://coolshell.cn/articles/2322.html" target="_blank" rel="external">http://coolshell.cn/articles/2322.html</a></li>
<li>下篇：<a href="http://coolshell.cn/articles/2324.html" target="_blank" rel="external">http://coolshell.cn/articles/2324.html</a></li>
</ul>
<p>(作者博客内容丰富，又容易读，非常值得订阅。)</p>
<p><strong>Linux的厂商版本</strong></p>
<p>在Linux内核基础上，我们还有许多厂商版本。即使有了内核和GNU软件，Linux的安装和编译并不是简单的工作，Linux厂商就是瞄准了这个市场。这些厂商会在Linux内核的基础上，结合自己开发的软件，帮助用户安装和使用Linux，并提供技术支持。由于在服务器领域，Linux操作系统远远领先于Windows系统，而这些被政府部门、银行或者大学拥有的服务器往往承担很重要的信息处理和IO (input/outpt) 工作，所以尽管Linux开源，厂商还是可以根据其提供的商用软件和技术支持获得丰厚的利润。</p>
<p>(IBM是Linux设备最大的供应商，同时它的咨询业务很大一部份也来源于提供Linux相关的支持。我们所熟知的Android操作系统，也算是Google提供的一个厂商版本。)</p>
<p>我们这里主要介绍在PC上比较流行的Linux厂商版本:</p>
<p><strong>红帽系列</strong></p>
<ul>
<li>Red Hat linux: 大名鼎鼎的红帽，现在已经完结。以此为基础有以下分支:</li>
<li>Red Hat Enterprise: (www.redhat.com) 这个是企业级的linux，主要面向服务器。作为商业版，有比较好的配套软件和技术支持。RH的教材也堪称经典。</li>
<li>Fedora: (<a href="http://fedoraproject.org" target="_blank" rel="external">http://fedoraproject.org</a>) 由社区维护，去除了一些商业软件。红帽实际上赞助了这个项目，以便以此作为技术测试平台。</li>
<li>CentOS: (www.centos.org) 这个版本不来自红帽的公司，是收集红帽公开的源码组成的免费版本，由社区维护，和红帽完全兼容。版本号升级较慢，但有持续的技术支持，所以适合于不愿意频繁升级的情形，鸟哥中就推荐以CentOS来建站。</li>
</ul>
<p><strong>SUSE系列</strong></p>
<ul>
<li>SUSE Linux Enterprise: (www.suse.com) 和红帽商业版类似，是德国公司制作的，据说在欧洲比较流行，但我欧洲的朋友表示没怎么听说过。SUSE系列比较有特色的是YAST2，就是用来设置Linux的界面，对初级管理员比较方便。</li>
<li>openSUSE: (www.opensuse.org) SUSE的免费版本。以前SUSE不是很推这个免费版本，支持不好。现在似乎态度大大转变。就我个人的使用体验来说，还是觉得社区支持不足。</li>
</ul>
<p><strong>Debian系列</strong></p>
<ul>
<li>Debian: (www.debian.org) 完全免费，社区维护的Linux版本，有很大的用户群，所以遇到问题，基本都可以找到社区用户的支持。</li>
<li>Ubuntu: (www.ubuntu.com) 由一个基金提供支持的免费Linux版本。 继承自Debian。界面很友好。发邮件过去，还会送你免费安装CD (不知道现在还有没有)。现在的版本加载的东西有些多，速度有些慢。写《大教堂和市集》的Eric Raymond说它是最好的Linux。</li>
<li>Mint (<a href="http://www.linuxmint.com" target="_blank" rel="external">http://www.linuxmint.com</a>), 基于ubuntu。它提供了更加丰富的预装应用，以减少用户搜索并安装应用的麻烦。其使用的应用版本比较新，可能不是很稳定。</li>
</ul>
<p>此外，还有如下一些版本：</p>
<ul>
<li>Gentoo (www.gentoo.org) 基于源码的版本，提供给用户很大的自由度。为用户提供大量应用程序的源码，可以在用户的系统上重新编译建造。需要一定的系统配置的知识。</li>
<li>ArchLinux (www.archlinux.org)，推崇简洁，避免不必要和复杂的修改，是一个轻便灵活的版本。其配置文件有良好注释。</li>
<li>Mandriva (www.mandriva.com) 一个很方便用户使用的版本，其目标是使得新用户更容易使用linux。</li>
<li>Slackware (www.slackware.com) 稳定，基本。它的只包含稳定版本的应用程序。对于初级用户不是很友好。</li>
<li>TurboLinux (www.turbolinux.com) 在亚洲比较流行。商业版本，提供技术支持和咨询服务。</li>
</ul>
<h2 id="Linux_u5F00_u673A_u542F_u52A8"><a href="#Linux_u5F00_u673A_u542F_u52A8" class="headerlink" title="Linux开机启动"></a>Linux开机启动</h2><p>计算机开机是一个神秘的过程。我们只是按了开机键，就看到屏幕上的进度条或者一行行的输出，直到我们到达登录界面。然而，计算机开机又是个异常脆弱的过程，我们满心期望的登录界面可能并不会出现，而是一个命令行或者错误信息。了解计算机开机过程有助于我们修复开机可能出现的问题。</p>
<p><strong>最初始阶段</strong></p>
<p>当我们打开计算机电源，计算机会自动从主板的BIOS(Basic Input/Output System)读取其中所存储的程序。这一程序通常知道一些直接连接在主板上的硬件(硬盘，网络接口，键盘，串口，并口)。现在大部分的BIOS允许你从软盘、光盘或者硬盘中选择一个来启动计算机。</p>
<p>下一步，计算机将从你所选择的存储设备中读取起始的512 bytes(比如光盘一开是的512 bytes，如果我们从光盘启动的话)。这512 bytes叫做主引导记录MBR (master boot record)。MBR会告诉电脑从该设备的某一个分区(partition)来装载引导加载程序(boot loader)。Boot loader储存有操作系统(OS)的相关信息，比如操作系统名称，操作系统内核 (kernel)所在位置等。常用的boot loader有GRUB和LILO。</p>
<p>随后，boot loader会帮助我们加载kernel。kernel实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过kernel传达给硬件。Windows和Linux各自有自己kernel。狭义的操作系统就是指kernel，广义的操作系统包括kernel以及kernel之上的各种应用。</p>
<p>（Linus Torvalds与其说是Linux之父，不如说是Linux kernel之父。他依然负责Linux kernel的开发和维护。至于Ubuntu, Red Hat, 它们都是基于相同的kernel之上，囊括了不同的应用和界面构成的一个更加完整的操作系统版本。)</p>
<p>实际上，我们可以在多个分区安装boot loader，每个boot loader对应不同的操作系统，在读取MBR的时候选择我们想要启动的boot loader。这就是多操作系统的原理。</p>
<p>小结：BIOS -&gt; MBR -&gt; boot loader -&gt; kernel</p>
<p><strong>kernel</strong></p>
<p>如果我们加载的是Linux kernel，Linux kernel开始工作。kernel会首先预留自己运行所需的内存空间，然后通过驱动程序(driver)检测计算机硬件。这样，操作系统就可以知道自己有哪些硬件可用。随后，kernel会启动一个init进程。它是Linux系统中的1号进程(Linux系统没有0号进程)。到此，kernel就完成了在计算机启动阶段的工作，交接给init来管理。</p>
<p>小结: kernel -&gt; init process</p>
<p><strong>init process</strong></p>
<p>(根据boot loader的选项，Linux此时可以进入单用户模式(single user mode)。在此模式下，初始脚本还没有开始执行，我们可以检测并修复计算机可能存在的错误)</p>
<p>随后，init会运行一系列的初始脚本(startup scripts)，这些脚本是Linux中常见的shell scripts。这些脚本执行如下功能：</p>
<p>设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络……</p>
<p>当这些初始脚本，操作系统已经完全准备好了，只是，还没有人可以登录！！！init会给出登录(login)对话框，或者是图形化的登录界面。</p>
<p>输入用户名(比如说vamei)和密码，DONE！</p>
<p>在此后的过程中，你将以用户(user)vamei的身份操作电脑。此外，根据你创建用户时的设定，Linux还会将你归到某个组(group)中，比如可以是stupid组，或者是vamei组。</p>
<p>所以你将是用户vamei， 同时是vamei组的组员。(注意，组vamei和用户vamei只是重名而已，就好想你可以叫Dell, 同时还是Dell公司的老板一样。你完全也可以是用户vamei，同时为stupid组的组员)</p>
<p><strong>总结</strong></p>
<p>BIOS -&gt; MBR -&gt; boot loader -&gt; kernel -&gt; init process -&gt; login</p>
<p>用户，组。</p>
<h2 id="Linux_u6587_u4EF6_u7BA1_u7406"><a href="#Linux_u6587_u4EF6_u7BA1_u7406" class="headerlink" title="Linux文件管理"></a>Linux文件管理</h2><p>对于计算机来说，所谓的数据就是0和1的序列。这样的一个序列可以存储在内存中，但内存中的数据会随着关机而消失。为了将数据长久保存，我们把数据存储在光盘或者硬盘中。根据我们的需要，我们通常会将数据分开保存到文件这样一个个的小单位中(所谓的小，是相对于所有的数据而言)。但如果数据只能组织为文件的话，而不能分类的话，文件还是会杂乱无章。每次我们搜索某一个文件，就要一个文件又一个文件地检查，太过麻烦。文件系统(file system)是就是文件在逻辑上组织形式，它以一种更加清晰的方式来存放各个文件。</p>
<p><strong>路径与文件简介</strong></p>
<p>文件被组织到文件系统(file system)中，通常会成为一个树状(tree)结构。Linux有一个根目录/, 也就是树状结构的最顶端。这个树的分叉的最末端都代表一个文件，而这个树的分叉处则是一个目录(directory, 相当于我们在windows界面中看到的文件夹)。在图1中看到的是整个的一个文件树。如果我们从该树中截取一部分，比如说从目录vamei开始往下，实际上也构成一个文件系统。</p>
<p>要找到一个文件，除了要知道该文件的文件名，还需要知道从树根到该文件的所有目录名。从根目录开始的所有途径的目录名和文件名构成一个路径(path)。比如说，我们在Linux中寻找一个文件file.txt，不仅要知道文件名(file.txt)，还要知道完整路径，也就是绝对路径(/home/vamei/doc/file.txt)。从根目录录/, 也就是树状结构的最顶端出发，经过目录home, vamei, doc，最终才看到文件file.txt。整个文件系统层层分级(hierarchy)，vamei是home的子目录，而home是vamei的父目录。</p>
<p>在Linux中，我们用ls命令来显示目录下的所有文件，比如 $ls /home/vamei/doc</p>
<p><strong>目录</strong></p>
<p>在Linux系统中，目录也是一种文件。所以/home/vamei是指向目录文件vamei的绝对路径。</p>
<p>这个文件中至少包含有以下条目:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">.       </span>指向当前目录</span><br><span class="line"><span class="bullet">..      </span>指向父目录</span><br></pre></td></tr></table></figure>
<p>除此之外，目录文件中还包含有属于该目录的文件的文件名，比如vamei中就还要有如下条目，指向属于该目录的文件:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">doc</span></span><br><span class="line"><span class="keyword">movie</span><br><span class="line"></span><span class="label">photo</span></span><br></pre></td></tr></table></figure>
<p>Linux解释一个绝对路径的方式如下：先找到根目录文件，从该目录文件中读取home目录文件的位置，然后从home文件中读取vamei的位置……直到找到目录doc中的file.txt的位置。</p>
<p>由于目录文件中都有.和..的条目，我们可以在路径中加入.或者..来表示当前目录或者父目录，比如/home/vamei/doc/..与/home/vamei等同。</p>
<p>此外，Linux会在进程中，维护一个工作目录(present working directory)的变量。在shell中，你可以随时查询到到工作目录(在命令行输入<code>$pwd</code>)。这是为了省去每次都输入很长的绝对路径的麻烦。比如说我们将工作目录更改为/home/vamei (<code>$cd /home/vamei</code>)，那么此时我们再去找file.txt就可以省去/home/vamei/ (<code>$ls doc/file.txt</code>)，这样得到的路径叫相对路径(relative path)，上面的doc/file.txt就是这样一个相对路径。</p>
<p>当文件出现在一个目录文件中时，我们就把文件接入到文件系统中，我们称建立一个到文件的硬链接(hard link)。一个文件允许出现在多个目录中，这样，它就有多个硬链接。当硬链接的数目(link count)降为0时，文件会被Linux删除。所以很多时候，unlink与remove在Linux操作系统中是一个意思。由于软链接(soft link)的广泛使用(soft link不会影响link count，而且可以跨越文件系统)，现在较少手动建立硬连接。</p>
<p><strong>文件操作</strong></p>
<p>对于文件，我们可以读取(read)，写入(write)和运行(execute)。读取是从已经存在的文件中获得数据。写入是向新的文件或者旧的文件写入数据。如果文件储存的是可执行的二进制码，那么它可以被载入内存，作为一个程序运行。在Linux的文件系统中，如果某个用户想对某个文件执行某一种操作，那么该用户必须拥有对该文件进行这一操作的权限。文件权限的信息保存在文件信息(metadata)中, 见下一节。</p>
<p><strong>文件附加信息 (metadata)</strong></p>
<p>文件自身包含的只有数据。文件名实际上储存在目录文件。除了这些之外，还有操作系统维护的文件附加信息，比如文件类型，文件尺寸，文件权限，文件修改时间，文件读取时间等。可以用ls命令查询文件信息($ls -l file.txt)，得到如下结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- <span class="number">1</span> vamei vamei <span class="number">8445</span> Sep  <span class="number">8</span> <span class="number">07</span>:<span class="number">33</span> file1.txt</span><br></pre></td></tr></table></figure>
<p>各个部分的含义如下：</p>
<ul>
<li>我们先介绍最开始的-，它表示文件类型，说明file1.txt是常规文件(如果是目录文件，则应显示d)。</li>
<li>随后有九个字符，为rw-r–r–，它们用于表示文件权限。这九个字符分为三组，rw-, r–, r–，分别对应拥有者(owner)，拥有组(owner group)和所有其他人(other)。回顾Linux开机启动，登录后，我会有一个用户身份和一个组身份, 相当于我的名片。第一组表示，如果我的名片上的用户身份证明我是该文件的拥有者，那么我就可以对该文件有读取(r)，写入(w)该文件的权限，但不拥有执行(-，如果拥有执行权限，则为x)该文件的权限。第二组表示，如果我的名片上的组身份证明我所在的组是该文件的拥有组的一员，那么我有从该文件读入的权限。第三组表示，如果我的名片显示我既不是拥有者，也不是拥有组的一员，那么我只有读入的权限。当我想要进行一个读取操作时，Linux会先看我是否是拥有者下文会进一步解释拥有者和拥有组。</li>
<li>后面的1是硬连接(hard link)数目(link count)。</li>
<li>之后的vamei表示用户vamei是文件的拥有者(owner)，文件的拥有者有权更改文件权限(比如改为rwxrwxrwx)。而后面的vamei文件的拥有组是组vamei。文件的拥有者和拥有组在文件创建时就附加在文件上(相当于给文件上锁，只有有合适名片的用户才能打开操作)。要注意，Linux有一个超级用户root (也叫做根用户)，该用户拥有所有的文件。</li>
<li>随后的8445表示文件大小，单位为字节(byte)。</li>
<li>Sep 8 07:33表示文件的上一次写入的时间(modification time)。实际上在文件附加信息中还包含有文件的上一次读取时间(access time)，没有显示出来。</li>
</ul>
<p><strong>软链接 (soft link, or symbolic link)</strong></p>
<p>如上讨论硬链接时说到的，软链接不会影响文件的link count。如果还记得windows系统的快捷方式的话，Linux的软链接(soft link，也叫做symbolic link)就是linux的快捷方式。软链接本质上是一个文件，它的文件类型是symbolic link。在这个文件中，包含有链接指向的文件的绝对路径。当你从这个文件读取数据时，linux会把你导向所指向的文件，然后从那个文件中读取（就好像你双击快捷方式的效果一样）。软链接可以方便的在任何地方建立，并指向任何一个绝对路径。</p>
<p>软链接本身也是一个文件，也可以执行文件所可以进行的操作。当我们对软链接操作时，要注意我们是对软链接本身操作，还是对软链接指向的目标操作。如果是后者，我们就说该操作跟随链接指引(follow the link)。</p>
<p>umask</p>
<p>当我们创建文件的时候，比如使用touch，它会尝试将新建文件创建为权限666，也就是rw-rw-rw-。但操作系统要参照权限mask来看是否真正将文件创建为666。权限mask表示操作系统不允许设置的权限位，比如说037(—-wxrwx)的权限mask意味着不允许设置设置group的wx位和other的rwx位。如果是这个权限mask的话，最终的文件权限是rw-r—– (group的w位和other的rw位被mask)。</p>
<p>我们可以通过</p>
<pre><code>$umask 022
</code></pre><p>的方式改变权限mask。</p>
<p><strong>总结</strong></p>
<p>计算机本质上是对数据进行处理的工具，而文件是数据储存的逻辑载体，所以了解Linux文件系统很重要。对于文件系统的了解要结合Linux的其他方面(比如用户管理)进行有机的学习。</p>
<p>文件权限，拥有者，拥有组，超级用户root</p>
<p>硬链接，软链接，follow the link</p>
<h2 id="Linux_u7684_u67B6_u6784"><a href="#Linux_u7684_u67B6_u6784" class="headerlink" title="Linux的架构"></a>Linux的架构</h2><p>我以下图为基础，说明Linux的架构(architecture)。(该图参考《Advanced Programming in Unix Environment》)</p>
<p><img src="/images/14590055441877.jpg" alt=""></p>
<p>最内层是硬件，最外层是用户常用的应用，比如说firefox浏览器，evolution查看邮件，一个计算流体模型等等。硬件是物质基础，而应用提供服务。但在两者之间，还要经过一番周折。</p>
<p>还记得Linux启动。Linux首先启动内核 (kernel)，内核是一段计算机程序，这个程序直接管理管理硬件，包括CPU、内存空间、硬盘接口、网络接口等等。所有的计算机操作都要通过内核传递给硬件。</p>
<p>为了方便调用内核，Linux将内核的功能接口制作成系统调用(system call)。系统调用看起来就像C语言的函数。你可以在程序中直接调用。Linux系统有两百多个这样的系统调用。用户不需要了解内核的复杂结构，就可以使用内核。系统调用是操作系统的最小功能单位。一个操作系统，以及基于操作系统的应用，都不可能实现超越系统调用的功能。一个系统调用函数就像是汉字的一个笔画。任何一个汉字都要由基本的笔画（点、横、撇等等）构成。我不能臆造笔画。</p>
<p>在命令行中输入<code>$man 2 syscalls</code>可以查看所有的系统调用。你也可以通过<code>$man 2 read</code>来查看系统调用read()的说明。在这两个命令中的2都表示我们要在2类(系统调用类)中查询 (具体各个类是什么可以通过<code>$man man</code>看到)。</p>
<p>系统调用提供的功能非常基础，所以使用起来很麻烦。一个简单的给变量分配内存空间的操作，就需要动用多个系统调用。Linux定义一些库函数(library routine)来将系统调用组合成某些常用的功能。上面的分配内存的操作，可以定义成一个库函数(像malloc()这样的函数)。再比如说，在读取文件的时候，系统调用要求我们设置好所需要的缓冲。我可以使用Standard IO库中的读取函数。这个读取函数既负责设置缓冲，又负责使用读取的系统调用函数。使用库函数对于机器来说并没有效率上的优势，但可以把程序员从细节中解救出来。库函数就像是汉字的偏旁部首，它由笔画组成，但使用偏旁部首更容易组成字，比如”铁”。当然，你也完全可以不使用库函数，而直接调用系统函数，就像“人”字一样，不用偏旁部首。</p>
<p>(实际上，一个操作系统要称得上是UNIX系统，必须要拥有一些库函数，比如ISO C标准库，POSIX标准等。)</p>
<p>shell是一个特殊的应用。很多用户将它称为命令行。shell是一个命令解释器(interpreter)，当我们输入“ls -l”的时候，它将此字符串解释为</p>
<ol>
<li>在默认路径找到该文件(/bin/ls)，</li>
<li>执行该文件，并附带参数”-l”。</li>
</ol>
<p>我之前用&gt;表示重新定向，用|表示管道，也是通过shell解释&amp;或者|的含义。Shell接着通过系统调，用指挥内核，实现具体的重定向或者管道。在没有图形界面之前，shell充当了用户的界面，当用户要运行某些应用时，通过shell输入命令，来运行程序。shell是可编程的，它可以执行符合shell语法的文本。这样的文本叫做shell脚本(script)。可以在架构图中看到，shell下通系统调用，上通各种应用，同时还有许多自身的小工具可以使用。Shell脚本可以在寥寥数行中，实现复杂的功能。</p>
<p>UNIX的一条哲学是让每个程序尽量独立的做好一个小的功能。而shell充当了这些小功能之间的”胶水”，让不同程序能够以一个清晰的接口(文本流)协同工作，从而增强各个程序的功能。这也是Linux老鸟鼓励新手多用shell，少用图形化界面的原因之一。</p>
<p>(shell也有很多种，最常见的是bash, 另外还有sh, csh, tcsh, ksh。它们出现的年代不同，所支持的功能也有差异。)</p>
<p>一个shell对应一个终端 (terminal)。曾经来说，终端是一个硬件设备，用来输入并显示输出。如今，由于图形化界面的普及，终端往往就像上图一样，是一个图形化的窗口。你可以通过这个窗口输入或者输出文本。这个文本直接传递给shell进行分析解释，然后执行。</p>
<p>最后，我们进入一般的应用。应用是一个程序，它可以</p>
<ol>
<li>直接调用系统函数</li>
<li>调用库函数</li>
<li>运行shell脚本</li>
</ol>
<p>这些应用可以由多种语言开发。最常见的是C语言。</p>
<p><strong>总结</strong></p>
<p>Linux利用内核实现软硬件的对话。</p>
<p>通过系统调用的这个接口，Linux将上层的应用与下层的内核分离，隐藏了底层的复杂性，也提高了上层应用的可移植性。</p>
<p>库函数利用系统调用创造出模块化的功能，</p>
<p>Shell则提供了一个用户界面，并让我们可以利用shell的语法编写脚本，以整合程序。</p>
<h2 id="Linux_u547D_u4EE4_u884C_u4E0E_u547D_u4EE4"><a href="#Linux_u547D_u4EE4_u884C_u4E0E_u547D_u4EE4" class="headerlink" title="Linux命令行与命令"></a>Linux命令行与命令</h2><p>Linux的命令是很重要的工具，也往往是初学者最大的瓶颈。有朋友用了很长时间的Linux图形界面，基本不使用命令行输入命令执行，所以装的Linux最终成了摆设。这里总结一些命令行下常使用的命令，希望能有用。</p>
<p><strong>什么是命令</strong></p>
<p>我们通常所说的Linux命令行是运行在终端(terminal)的shell (阅读Linux架构以了解什么是shell以及它在Linux系统中的位置)</p>
<p>所谓的命令，是我们在命令行输入的一串字符。shell负责理解并执行这些字符串。shell命令可以分为如下几类 1）可执行文件(executable file) 2）shell内建函数(built-in function) 3) 别名(alias)。可执行文件为经过编译的程序文件，我们输入这些文件的路径来让shell运行，比如<code>$/bin/ls</code>。有些可执行文件被放在特殊的目录(默认路径)下面，从而使得操作系统可以通过文件名找到，而不用总是输入该文件的绝对路径(absolute path)。比如说<code>$ls</code>(实际上，shell自动帮我们补齐ls的路径)。随后，这些可执行文件中包含的程序运行，并成为进程。shell的内建函数与上面类似，只是其对应的程序被保存在shell的内部。别名是指我们给以上两种命令起一个简称，以便减少输入的工作量。</p>
<p>我们可以通过type命令来了解命令的类型：</p>
<ul>
<li><code>$type ls</code></li>
<li><code>$type cd</code></li>
</ul>
<p>命令的构成</p>
<p>当我们在命令行输入命令的时候，往往由以下方式构成:</p>
<pre><code>$ls -l /home
</code></pre><p>整个一行命令由空格分为三个部分（注意, $是自动出现的提示符，有时还会在此之前出现计算机名）。第一个为命令的名字ls，这个命令ls的功能是列出目录中所有文件，第二个-l是关键字，它告诉ls要列出每个文件的详细信息，第三个/home为参数，表示我所要列出的目录是/home。实际上关键字是一种特殊的参数，大部分情况下用来开关程序的某些特殊功能 （用来选择做出的是拿铁咖啡还是黑咖啡）。而参数是用来传递给程序的一般的变量。ls经过处理之后，将在终端输出/home下面包含的各个文件名 (该文件系统见:<a href="http://www.cnblogs.com/vamei/archive/2012/09/09/2676792.html)：" target="_blank" rel="external">http://www.cnblogs.com/vamei/archive/2012/09/09/2676792.html)：</a></p>
<pre><code>vamei another
</code></pre><p>关键字和参数可以不止有一个，比如:</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ls</span> -l -a /home /bin</span><br><span class="line"><span class="variable">$ls</span> -la /home /bin</span><br><span class="line">(上面两个命令等价)</span><br></pre></td></tr></table></figure>
<p>列出/home和/bin目录下的文件，-a表示列出全部文件(即使是隐藏文件也要列出)， -l表示列出每个文件的详细信息。</p>
<p>(如果命令没有被放在默认路径中，你也可以输入绝对路径来执行)</p>
<p>回忆Linux文件管理背景知识，我们知道，每个文件能否被执行要根据用户所拥有的权限。命令实际上是可执行文件，也是如此。系统相关的命令，或者某个命令中的定义的操作，往往会要求超级用户root的身份才能使用。如果你是用户vamei，那么你就无法使用这些命令。但以root的身份登录是个糟糕的想法。为了解决这一矛盾，你可以以vamei的身份登录，但在执行命令之前加上sudo， 以便临时以root的身份执行某条命令。比如<code>$sudo ls .</code></p>
<p>对于大多数的shell来说，都有命令补齐的功能。当你在<code>$</code>的后面输入命令的一部分时，比如rmdir的rmd的时候，按Tab键，Linux会帮你打剩下的字符，补充成为rmdir。不止是命令，如果你输入的是文件名，Linux也可以帮你补齐。比如说, <code>$ls a.txt</code>。当你输入到<code>$ls a.t</code>的时候，按Tab键，Linux会帮你补齐该文件名，成为<code>$ls a.txt</code>。当然，这样做的前提是你输入到rmd的时候，默认路径下能和它相符的命令只有一个rmdir了。如果有多个相符的命令，连按两下Tab，Linux会显示所有的相符的命令。</p>
<p><strong>多使用命令的好处</strong></p>
<p>实际上，许多命令的功能都可以通过图形化界面来实现，学习这些命令的意义在哪里呢？</p>
<p>在UNIX发育的大部分历史上，用户都是通过shell来工作的。大部分命令都已经经过了几十年的发展和改良，功能强大，性能稳定。Linux继承自UNIX，自然也是如此。此外Linux的图形化界面并不好，并不是所有的命令都有对应的图形按钮。更别说在图形化界面崩溃的情况下，你就要靠shell输入命令来恢复计算机了。</p>
<p>命令本身是一个函数 (function)，是一个小的功能模块。当我们想要让计算机做很复杂的事情 (比如说: 在晚上12:00下载某个页面的所有链接，然后复制到移动硬盘)的时候，不断地去按各个图形化按钮并不是个很聪明的事情 (1. 要点很多下，2. 必须等到12:00)。我们通常是通过shell编程来实现这样一些复杂任务，这时，就可以把命令作为函数，嵌入到我们的shell程序中, 从而让不同命令协同工作 (比如使用date来查询时间，再根据时间来使用wget下载等等)。</p>
<p><strong>如何了解一个陌生的命令</strong>？</p>
<p>有一些命令可以用来了解某个命令本身的情况，比如这个命令的绝对路径。</p>
<pre><code>$which ls
</code></pre><p>which 在默认路径中搜索命令，返回该命令的绝对路径。</p>
<pre><code>$whereis ls
</code></pre><p>whereis 在相对比较大的范围搜索命令，返回该命令的绝对路径。</p>
<pre><code>$whatis ls
</code></pre><p>whatis 用很简短的一句话来介绍命令。</p>
<pre><code>$man ls
</code></pre><p>man 查询简明的帮助手册。对于大部分的Linux自带的命令来说，当作者编写它的时候，都会带有一个帮助文档，告诉用户怎么使用这个命令。</p>
<p>(man可以说是我们了解Linux最好的百科全书，它不但可以告诉你Linux自带的命令的功能，还可以查询Linux的系统文件和系统调用。如果想要深入学习Linux，就必须要懂得如何用man来查询相关文档。)</p>
<pre><code>$info ls
</code></pre><p>info 查询更详细的帮助信息</p>
<p>此外，在shell中，你还可以用向上箭头来查看之前输入运行的命令。</p>
<p>你也可以用</p>
<pre><code>$history
</code></pre><p>来查询之前在命令行的操作。</p>
<p>当一个命令运行时，你中途想要停止它时，可以用Ctrl + c。如果你只是想暂时停止，使用Ctrl + z。具体机制与信号(signal)有关，我们将在以后介绍</p>
<p><strong>总结</strong></p>
<p>命令行: 使用shell解释输入的字符串，以运行程序</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span></span><br><span class="line">sudo</span><br><span class="line"><span class="keyword">which</span>, whereis, whatis, <span class="keyword">man</span>, info</span><br></pre></td></tr></table></figure>
<p>使用Tab自动补齐，向上箭头查询历史，history</p>
<pre><code>Ctrl + c, Ctrl + z
</code></pre><h2 id="Linux_u6587_u4EF6_u7BA1_u7406_u76F8_u5173_u547D_u4EE4"><a href="#Linux_u6587_u4EF6_u7BA1_u7406_u76F8_u5173_u547D_u4EE4" class="headerlink" title="Linux文件管理相关命令"></a>Linux文件管理相关命令</h2><p>在了解了Linux文件管理背景知识之后， 我们可以学习一些命令来管理我们的文件。</p>
<p><strong>文件操作相关</strong></p>
<p>有一些命令可以帮助我们”修剪”之前看到的文件树。</p>
<pre><code>$touch a.txt
</code></pre><p>如果a.txt不存在，生成一个新的空文档a.txt。如果a.txt存在，那么只更改该文档的时间信息。(这个命令实际上用得并不广泛，但可以帮我们创建一个空文件来实验下面操作)</p>
<pre><code>$ls .
</code></pre><p>是list的简写，列出当前目录下的所有文件名</p>
<pre><code>$ls -l a.txt
</code></pre><p>列出文件的详细信息</p>
<pre><code>$cp a.txt b.txt 
</code></pre><p>cp是copy的简写，用来复制文件。在工作目录下，将a.txt复制到文件b.txt</p>
<pre><code>$cp a.txt ..
</code></pre><p>将a.txt复制到父目录的a.txt</p>
<pre><code>$mv a.txt c.txt
</code></pre><p>mv是move的简写，用来移动文件。将a.txt移动成为c.txt (相当于重命名rename)</p>
<pre><code>$mv c.txt /home/vamei
</code></pre><p>将c.txt移动到/home/vamei目录</p>
<pre><code>$rm a.txt
</code></pre><p>rm是remove的缩写，用于删除文件。删除a.txt</p>
<pre><code>$rm -r /home/vamei 
</code></pre><p>删除从/home/vamei向下的整个子文件系统。-r表示recursive， 是指重复删除的操作，/home/vamei文件夹为空，然后删除/home/vamei文件夹本身。</p>
<p>(程序员总是对这个命令很感兴趣,   <code>$rm -rf /</code>   它会删除整个文件树。f的目的是告诉rm放心干，不用再确认了…… 一般情况下，应该没有人会用这个命令。)</p>
<pre><code>$mkdir /home/vamei/good
</code></pre><p>创建一个新的目录</p>
<pre><code>$rmdir /home/vamei/good
</code></pre><p>删除一个空的目录</p>
<p><strong>文件权限相关</strong></p>
<pre><code>$chmod 755 a.txt
</code></pre><p>(你必须是文件a.txt的拥有者才能运行此命令。或者以$sudo chmod 755 a.txt的方式，以超级用户的身份运行该命令。)</p>
<p>change mode 改变a.txt的读、写以及执行权限。还记得每个文件都有九位的读写执行权限(参看 Linux文件管理背景知识)，分为三组，分别对应拥有者(owner)，拥有组(owner group)中的用户和所有其他用户(other)。在这里，我们也有三个数字，755，对应三个组。7被分配给拥有者，5被分配给拥有组，最后一个5分配给其它用户。Linux规定: 4为有读取的权利，2为有写入的权利，1为有执行的权利。我们看到的7实际上是4 + 2 + 1，表示拥有者有读、写、执行三项权利。(想想5 意味着什么)</p>
<p>这时，运行<code>$ls -l a.txt</code>, 你应该看到九位的权限变成了rwxr-xr-x。根据自己的需要，你可以用比如444, 744代替755，来让文件有不同的权限。</p>
<pre><code>$sudo chown root a.txt
</code></pre><p>change owner 改变文件的拥有者为root用户。这个命令需要有超级用户权限才能执行，所以我们在命令之前加上sudo。</p>
<pre><code>$sudo chgrp root a.txt
</code></pre><p>change group 改变文件的拥有组为root组</p>
<p><strong>Linux文件名通配表达式</strong></p>
<p>(wild card, 也叫filename pattern matching)</p>
<p>之前所讲的命令，比如ls, mv, cp都可以接收多个参数，比如:</p>
<pre><code>$ls -l a.txt b.txt c.txt
</code></pre><p>就可以列出这三个文件的所有信息。</p>
<p>有时候，我们想列出工作目录下所有的以.txt结尾的文件的信息，可以用下面的方式:</p>
<pre><code>$ls -l *.txt
</code></pre><p><code>*.txt</code>的写法就运用了Linux通配表达式。它与正则表达式相类似，但语法有所不同。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Filename Pattern Matching</th>
<th style="text-align:center">对应含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">任意多个任意字符</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">任意一个字符</td>
</tr>
<tr>
<td style="text-align:center">[kl]</td>
<td style="text-align:center">字符k或者字符l</td>
</tr>
<tr>
<td style="text-align:center">[0-4]</td>
<td style="text-align:center">数字0到4字符中的一个</td>
</tr>
<tr>
<td style="text-align:center">[b-e]</td>
<td style="text-align:center">b到e字符中的一个</td>
</tr>
<tr>
<td style="text-align:center">[^mnp]</td>
<td style="text-align:center">一个字符，这个字符不是m,n,p</td>
</tr>
</tbody>
</table>
<p>Linux会找到符合表达式的文件名，然后用这些文件名作为参数传递给命令。注意，当使用rm的时候，要格外小心。下面两个命令，只相差一个空格，但效果大为不同:</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$rm</span> * .txt</span><br><span class="line"><span class="variable">$rm</span> *.txt</span><br></pre></td></tr></table></figure>
<p>第一个命令会删除当前目录下所有文件！</p>
<p><strong>总结</strong></p>
<p>touch, ls, mv, cp, rm, mkdir, rmdir</p>
<p>chmod, chown, chgrp</p>
<p>wild card</p>
<h2 id="Linux_u6587_u672C_u6D41"><a href="#Linux_u6587_u672C_u6D41" class="headerlink" title="Linux文本流"></a>Linux文本流</h2><p><strong>文本流</strong></p>
<p>文件用于数据的存储，相当于一个个存储数据的房子。我们之前说，所谓的数据是0或者1的序列，但严格来说，Linux以字节(byte)来作为数据的单位，也就是说这个序列每八位(bit)为一个单位(八位二进制对应的十进制范围为0到255)。使用ASCII编码，可以将这样一个字节转换成为字符。所以，在Linux中，我们所说的数据，完全可以用字符表达出来，也就是说文本(text)的形式。</p>
<p>实际上，如果以bit为单位处理字符的话，机器会更容易读懂和传输，效率会更高。但为什么Linux依然以字节为单位进行处理呢？原因在于，相对于以bit为单位处理数据，以byte为单位可以更容易将数据转化为字符。相对于枯燥的0和1，字符更容易被人读懂 (human readable)。然而，并不是所有的数据都是设计来让人读懂的，比如可执行文件包含的各种字符对于人来说并没有什么意义 (因为可执行文件是为了让机器读懂的)。但Linux依然以字节为单位处理所有文件，这是为了让所有文件能够共用一套接口 (virtual file system)，从而减少Linux设计的复杂度。</p>
<p>(“everything is a file”是通常所流传的UNIX设计的哲学之一，但Linus对此作出纠正，改为”everything is a stream of bytes”。)</p>
<p>然而，数据不是在找到了自己的房子(file)之后就永远的定居下来。它往往要被读入到内存 (就像是到办公室上班)，或者被传送到外部设备(好像去酒店休假)，或者搬到别的房子中。在这样的搬迁过程中，数据像是一个个排着队走路的人流，我们叫它文本流(text stream，或者byte stream)。然而，计算机不同设备之间的连接方法差异很大，从内存到文件的连接像是爬山，从内存到外设像是游过一条河。为此，Linux还定义了流 (stream)，以此作为修建连接各处的公路的标准。Stream的好处在于，无论你是从内存到外设，还是从内存到文件，所有的公路都是相同的 (至于公路下面是石头还是土地，都可以不用操心)。</p>
<p>我们再回味一下“everything is a stream of bytes”这句话。信息包含在文本流中，不断在计算机的各个组件之间流动，不断地接受计算机的加工，最终成为用户所需要的某种服务。</p>
<p>标准输入，标准输出，标准错误与重新定向</p>
<p>当Linux执行一个程序的时候，会自动打开三个流，标准输入(standard input)，标准输出(standard output)，标准错误(standard error)。比如说你打开命令行的时候，默认情况下，命令行的标准输入连接到键盘，标准输出和标准错误都连接到屏幕。对于一个程序来说，尽管它总会打开这三个流，但它会根据需要使用，并不是一定要使用。</p>
<p>想象一下敲击一个</p>
<pre><code>$ls
</code></pre><p>键盘敲击的文本流(“ls\n”，\n是回车时输入的字符，表示换行)命令行 (命令行实际上也是一个程序)。命令行随后调用/bin/ls得到结果(“a.txt”)，最后这个输出的文本流(“a.txt”)流到屏幕，显示出来，比如说：</p>
<pre><code>a.txt
</code></pre><p>假设说我们不想让文本流流到屏幕，而是流到另一个文件，我们可以采用重新定向(redirect)的机制。</p>
<pre><code>$ls &gt; a.txt
</code></pre><p>重新定向标准输出。这里的&gt;就是提醒命令行，让它知道我现在想变换文本流的方向了，我们不让标准输出输出到屏幕，而是要到a.txt这个文件 (好像火车轨道换轨)。此时，计算机会新建一个a.txt的文件，并将命令行的标准输出指向这个文件。</p>
<p>有另一个符号:</p>
<pre><code>$ls &gt;&gt; a.txt
</code></pre><p>这里&gt;&gt;的作用也是重新定向标准输出。如果a.txt已经存在的话，ls产生的文本流会附加在a.txt的结尾，而不会像&gt;那样每次都新建a.txt。</p>
<p>我们下面介绍命令echo：</p>
<pre><code>$echo IamVamei
</code></pre><p>echo的作用是将文本流导向标准输出。在这里，echo的作用就是将IamVamei输出到屏幕上。如果是</p>
<pre><code>$echo IamVamei &gt; a.txt
</code></pre><p>a.txt中就会有IamVamei这个文本。</p>
<p>我们也可以用&lt;符号来改变标准输入。比如cat命令，它可以从标准输入读入文本流，并输出到标准输出:</p>
<pre><code>$cat &lt; a.txt
</code></pre><p>我们将cat标准输入指向a.txt，文本会从文件流到cat，然后再输出到屏幕上。当然，我们还可以同时重新定向标准输出:</p>
<pre><code>$cat &lt; a.txt &gt; b.txt
</code></pre><p>这样，a.txt的内容就复制到了b.txt中。</p>
<p>我们还可以使用&gt;&amp;来同时重新定向标准输出和标准错误。假设我们并没有一个目录void。那么</p>
<pre><code>$cd void &gt; a.txt
</code></pre><p>会在屏幕上返回错误信息。因为此时标准错误依然指向屏幕。当我们使用:</p>
<pre><code>$cd void &gt;&amp; a.txt
</code></pre><p>错误信息被导向a.txt。</p>
<p>如果只想重新定向标准错误，可以使用2&gt;:</p>
<pre><code>$cd void 2&gt; a.txt &gt; b.txt
</code></pre><p>标准错误对应的总是2号，所以有以上写法。标准错误输出到a.txt，标准输出输出到b.txt。</p>
<p><strong>管道 (pipe)</strong></p>
<p>理解了以上的内容之后，管道的概念就易如反掌。管道可以将一个命令的输出导向另一个命令的输入，从而让两个(或者更多命令)像流水线一样连续工作，不断地处理文本流。在命令行中，我们用|表示管道：</p>
<pre><code>$cat &lt; a.txt | wc 
</code></pre><p>wc命令代表word count，用于统计文本中的行、词以及字符的总数。a.txt中的文本先流到cat，然后从cat的标准输出流到wc的标准输入，从而让wc知道自己要处理的是a.txt这个字符串。</p>
<p>Linux的各个命令实际上高度专业化，并尽量相互独立。每一个都只专注于一个小的功能。但通过pipe，我们可以将这些功能合在一起，实现一些复杂的目的。</p>
<p><strong>总结</strong></p>
<p>文本流，标准输入，标准输出，标准错误</p>
<p>cat, echo, wc</p>
<p><code>&gt;, &gt;&gt;, &lt;, |</code></p>
<h2 id="Linux_u8FDB_u7A0B_u57FA_u7840"><a href="#Linux_u8FDB_u7A0B_u57FA_u7840" class="headerlink" title="Linux进程基础"></a>Linux进程基础</h2><p>计算机实际上可以做的事情实质上非常简单，比如计算两个数的和，再比如在内存中寻找到某个地址等等。这些最基础的计算机动作被称为指令 (instruction)。所谓的程序(program)，就是这样一系列指令的所构成的集合。通过程序，我们可以让计算机完成复杂的操作。程序大多数时候被存储为可执行的文件。这样一个可执行文件就像是一个菜谱，计算机可以按照菜谱作出可口的饭菜。</p>
<p>那么，程序和进程(process)的区别又是什么呢?</p>
<p>进程是程序的一个具体实现。只有食谱没什么用，我们总要按照食谱的指点真正一步步实行，才能做出菜肴。进程是执行程序的过程，类似于按照食谱，真正去做菜的过程。同一个程序可以执行多次，每次都可以在内存中开辟独立的空间来装载，从而产生多个进程。不同的进程还可以拥有各自独立的IO接口。</p>
<p>操作系统的一个重要功能就是为进程提供方便，比如说为进程分配内存空间，管理进程的相关信息等等，就好像是为我们准备好了一个精美的厨房。</p>
<p><strong>看一眼进程</strong></p>
<p>首先，我们可以使用<code>$ps</code>命令来查询正在运行的进程，比如<code>$ps -eo pid,comm,cmd</code>，下图为执行结果:</p>
<p>(-e表示列出全部进程，-o pid,comm,cmd表示我们需要PID，COMMAND，CMD信息)</p>
<p><img src="/images/14590055629919.jpg" alt=""></p>
<p>每一行代表了一个进程。每一行又分为三列。第一列PID(process IDentity)是一个整数，每一个进程都有一个唯一的PID来代表自己的身份，进程也可以根据PID来识别其他的进程。第二列COMMAND是这个进程的简称。第三列CMD是进程所对应的程序以及运行时所带的参数。</p>
<p>(第三列有一些由中括号[]括起来的。它们是kernel的一部分功能，被打扮成进程的样子以方便操作系统管理。我们不必考虑它们。)</p>
<p>我们看第一行，PID为1，名字为init。这个进程是执行/bin/init这一文件(程序)生成的。当Linux启动的时候，init是系统创建的第一个进程，这一进程会一直存在，直到我们关闭计算机。这一进程有特殊的重要性，我们会不断提到它。</p>
<p><strong>如何创建一个进程</strong></p>
<p>实际上，当计算机开机的时候，内核(kernel)只建立了一个init进程。Linux kernel并不提供直接建立新进程的系统调用。剩下的所有进程都是init进程通过fork机制建立的。新的进程要通过老的进程复制自身得到，这就是fork。fork是一个系统调用。进程存活于内存中。每个进程都在内存中分配有属于自己的一片空间 (address space)。当进程fork的时候，Linux在内存中开辟出一片新的内存空间给新的进程，并将老的进程空间中的内容复制到新的空间中，此后两个进程同时运行。</p>
<p>老进程成为新进程的父进程(parent process)，而相应的，新进程就是老的进程的子进程(child process)。一个进程除了有一个PID之外，还会有一个PPID(parent PID)来存储的父进程PID。如果我们循着PPID不断向上追溯的话，总会发现其源头是init进程。所以说，所有的进程也构成一个以init为根的树状结构。</p>
<p>如下，我们查询当前shell下的进程：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@vamei:~# ps -o pid,ppid,cmd&#10;  PID  PPID CMD&#10;16935  3101 sudo -i&#10;16939 16935 -bash&#10;23774 16939 ps -o pid,ppid,cmd</span><br></pre></td></tr></table></figure>
<p>我们可以看到，第二个进程bash是第一个进程sudo的子进程，而第三个进程ps是第二个进程的子进程。</p>
<p>还可以用$pstree命令来显示整个进程树：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init&#9472;&#9516;&#9472;NetworkManager&#9472;&#9516;&#9472;dhclient&#10;     &#9474;                &#9492;&#9472;2*[&#123;NetworkManager&#125;]&#10;     &#9500;&#9472;accounts-daemon&#9472;&#9472;&#9472;&#123;accounts-daemon&#125;&#10;     &#9500;&#9472;acpid&#10;     &#9500;&#9472;apache2&#9472;&#9516;&#9472;apache2&#10;     &#9474;         &#9492;&#9472;2*[apache2&#9472;&#9472;&#9472;26*[&#123;apache2&#125;]]&#10;     &#9500;&#9472;at-spi-bus-laun&#9472;&#9472;&#9472;2*[&#123;at-spi-bus-laun&#125;]&#10;     &#9500;&#9472;atd&#10;     &#9500;&#9472;avahi-daemon&#9472;&#9472;&#9472;avahi-daemon&#10;     &#9500;&#9472;bluetoothd&#10;     &#9500;&#9472;colord&#9472;&#9472;&#9472;2*[&#123;colord&#125;]&#10;     &#9500;&#9472;console-kit-dae&#9472;&#9472;&#9472;64*[&#123;console-kit-dae&#125;]&#10;     &#9500;&#9472;cron&#10;     &#9500;&#9472;cupsd&#9472;&#9472;&#9472;2*[dbus]&#10;     &#9500;&#9472;2*[dbus-daemon]&#10;     &#9500;&#9472;dbus-launch&#10;     &#9500;&#9472;dconf-service&#9472;&#9472;&#9472;2*[&#123;dconf-service&#125;]&#10;     &#9500;&#9472;dropbox&#9472;&#9472;&#9472;15*[&#123;dropbox&#125;]&#10;     &#9500;&#9472;firefox&#9472;&#9472;&#9472;27*[&#123;firefox&#125;]&#10;     &#9500;&#9472;gconfd-2&#10;     &#9500;&#9472;geoclue-master&#10;     &#9500;&#9472;6*[getty]&#10;     &#9500;&#9472;gnome-keyring-d&#9472;&#9472;&#9472;7*[&#123;gnome-keyring-d&#125;]&#10;     &#9500;&#9472;gnome-terminal&#9472;&#9516;&#9472;bash&#10;     &#9474;                &#9500;&#9472;bash&#9472;&#9472;&#9472;pstree&#10;     &#9474;                &#9500;&#9472;gnome-pty-helpe&#10;     &#9474;                &#9500;&#9472;sh&#9472;&#9472;&#9472;R&#9472;&#9472;&#9472;&#123;R&#125;&#10;     &#9474;                &#9492;&#9472;3*[&#123;gnome-terminal&#125;]</span><br></pre></td></tr></table></figure>
<p>fork通常作为一个函数被调用。这个函数会有两次返回，将子进程的PID返回给父进程，0返回给子进程。实际上，子进程总可以查询自己的PPID来知道自己的父进程是谁，这样，一对父进程和子进程就可以随时查询对方。</p>
<p>通常在调用fork函数之后，程序会设计一个if选择结构。当PID等于0时，说明该进程为子进程，那么让它执行某些指令,比如说使用exec库函数(library function)读取另一个程序文件，并在当前的进程空间执行 (这实际上是我们使用fork的一大目的: 为某一程序创建进程)；而当PID为一个正整数时，说明为父进程，则执行另外一些指令。由此，就可以在子进程建立之后，让它执行与父进程不同的功能。</p>
<p><strong>子进程的终结(termination)</strong></p>
<p>当子进程终结时，它会通知父进程，并清空自己所占据的内存，并在kernel里留下自己的退出信息(exit code，如果顺利运行，为0；如果有错误或异常状况，为&gt;0的整数)。在这个信息里，会解释该进程为什么退出。父进程在得知子进程终结时，有责任对该子进程使用wait系统调用。这个wait函数能从kernel中取出子进程的退出信息，并清空该信息在kernel中所占据的空间。但是，如果父进程早于子进程终结，子进程就会成为一个孤儿(orphand)进程。孤儿进程会被过继给init进程，init进程也就成了该进程的父进程。init进程负责该子进程终结时调用wait函数。</p>
<p>当然，一个糟糕的程序也完全可能造成子进程的退出信息滞留在kernel中的状况（父进程不对子进程调用wait函数），这样的情况下，子进程成为僵尸（zombie）进程。当大量僵尸进程积累时，内存空间会被挤占。</p>
<p><strong>进程与线程(thread)</strong></p>
<p>尽管在UNIX中，进程与线程是有联系但不同的两个东西，但在Linux中，线程只是一种特殊的进程。多个线程之间可以共享内存空间和IO接口。所以，进程是Linux程序的唯一的实现方式。</p>
<p><strong>总结</strong></p>
<p>程序，进程，PID，内存空间</p>
<p>子进程，父进程，PPID，fork， wait</p>
<h2 id="Linux_u4FE1_u53F7_u57FA_u7840"><a href="#Linux_u4FE1_u53F7_u57FA_u7840" class="headerlink" title="Linux信号基础"></a>Linux信号基础</h2><p>Linux进程基础一文中已经提到，Linux以进程为单位来执行程序。我们可以将计算机看作一个大楼，内核(kernel)是大楼的管理员，进程是大楼的房客。每个进程拥有一个独立的房间(属于进程的内存空间)，而每个房间都是不允许该进程之外的人进入。这样，每个进程都只专注于自己干的事情，而不考虑其他进程，同时也不让别的进程看到自己的房间内部。这对于每个进程来说是一种保护机制。(想像一下几百个进程总是要干涉对方，那会有多么混乱，或者几百个进程相互偷窥……)</p>
<p>然而，在一些情况，我们需要打破封闭的房间，以便和进程交流信息。比如说，内核发现有一个进程在砸墙(硬件错误)，需要让进程意识到这样继续下去会毁了整个大楼。再比如说，我们想让多个进程之间合作。这样，我们就需要一定的通信方式。信号(signal)就是一种向进程传递信息的方式。我们可以将信号想象成大楼的管理员往房间的信箱里塞小纸条。随后进程取出小纸条，会根据纸条上的内容来采取一定的行动，比如灯坏了，提醒进程使用手电。(当然，也可以完全无视这张纸条，然而在失火这样紧急的状况下，无视信号不是个好的选择)。相对于其他的进程间通信方式(interprocess communication， 比如说pipe, shared memory)来说，信号所能传递的信息比较粗糙，只是一个整数。但正是由于传递的信息量少，信号也便于管理和使用。信号因此被经常地用于系统管理相关的任务，比如通知进程终结、中止或者恢复等等。</p>
<p>信号是由内核(kernel)管理的。信号的产生方式多种多样，它可以是内核自身产生的，比如出现硬件错误(比如出现分母为0的除法运算，或者出现segmentation fault)，内核需要通知某一进程；也可以是其它进程产生的，发送给内核，再由内核传递给目标进程。内核中针对每一个进程都有一个表存储相关信息(房间的信箱)。当内核需要将信号传递给某个进程时，就在该进程相对应的表中的适当位置写入信号(塞入纸条)，这样，就生成(generate)了信号。当该进程执行系统调用时，在系统调用完成后退出内核时，都会顺便查看信箱里的信息。如果有信号，进程会执行对应该信号的操作(signal action, 也叫做信号处理signal disposition)，此时叫做执行(deliver)信号。从信号的生成到信号的传递的时间，信号处于等待(pending)状态(纸条还没有被查看)。我们同样可以设计程序，让其生成的进程阻塞(block)某些信号，也就是让这些信号始终处于等待的状态，直到进程取消阻塞(unblock)或者无视信号。</p>
<p><strong>常见信号</strong></p>
<p>信号所传递的每一个整数都被赋予了特殊的意义，并有一个信号名对应该整数。常见的信号有SIGINT, SIGQUIT, SIGCONT, SIGTSTP, SIGALRM等。这些都是信号的名字。你可以通过</p>
<pre><code>$man 7 signal
</code></pre><p>来查阅更多的信号。</p>
<p>上面几个信号中，</p>
<ul>
<li><code>SIGINT</code>   当键盘按下CTRL+C从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是中断 (INTERRUPT) 该进程。</li>
<li><code>SIGQUIT</code>  当键盘按下CTRL+\从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是退出 (QUIT) 该进程。</li>
<li><code>SIGTSTP</code>  当键盘按下CTRL+Z从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是暂停 (STOP) 该进程。</li>
<li><code>SIGCONT</code>  用于通知暂停的进程继续。</li>
<li><code>SIGALRM</code>  起到定时器的作用，通常是程序在一定的时间之后才生成该信号。</li>
</ul>
<p><strong>在shell中使用信号</strong></p>
<p>下面我们实际应用一下信号。我们在shell中运行ping：</p>
<pre><code>$ping localhost
</code></pre><p>此时我们可以通过CTRL+Z来将SIGTSTP传递给该进程。shell中显示：</p>
<pre><code>[1]+  Stopped                 ping localhost
</code></pre><p>我们使用<code>$ps</code>来查询ping进程的PID (PID是ping进程的房间号), 在我的机器中为27397</p>
<p>我们可以在shell中通过$kill命令来向某个进程发出信号:</p>
<pre><code>$kill -SIGCONT  27397
</code></pre><p>来传递SIGCONT信号给ping进程。</p>
<p><strong>信号处理 (signal disposition)</strong></p>
<p>在上面的例子中，所有的信号都采取了对应信号的默认操作。但这并不绝对。当进程决定执行信号的时候，有下面几种可能：</p>
<ol>
<li>无视(ignore)信号，信号被清除，进程本身不采取任何特殊的操作</li>
<li>默认(default)操作。每个信号对应有一定的默认操作。比如上面SIGCONT用于继续进程。</li>
<li>自定义操作。也叫做获取 (catch) 信号。执行进程中预设的对应于该信号的操作。</li>
</ol>
<p>进程会采取哪种操作，要根据该进程的程序设计。特别是获取信号的情况，程序往往会设置一些比较长而复杂的操作(通常将这些操作放到一个函数中)。</p>
<p>信号常常被用于系统管理，所以它的内容相当庞杂。深入了解信号，需要一定的Linux环境编程知识。</p>
<p><strong>总结</strong></p>
<p>信号机制; generate, deliver, pending, blocking</p>
<p>signal action/dispositon; ignore, default action, catch signal</p>
<p><code>$kill</code></p>
<h2 id="Linux_u8FDB_u7A0B_u5173_u7CFB"><a href="#Linux_u8FDB_u7A0B_u5173_u7CFB" class="headerlink" title="Linux进程关系"></a>Linux进程关系</h2><p>Linux的进程相互之间有一定的关系。比如说，在Linux进程基础中，我们看到，每个进程都有父进程，而所有的进程以init进程为根，形成一个树状结构。我们在这里讲解进程组和会话，以便以更加丰富的方式了管理进程。</p>
<p><strong>进程组 (process group)</strong></p>
<p>每个进程都会属于一个进程组(process group)，每个进程组中可以包含多个进程。进程组会有一个进程组领导进程 (process group leader)，领导进程的PID (PID见Linux进程基础)成为进程组的ID (process group ID, PGID)，以识别进程组。</p>
<pre><code>$ps -o pid,pgid,ppid,comm | cat
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  PID  PGID  PPID COMMAND</span><br><span class="line"><span class="number">17763</span> <span class="number">17763</span> <span class="number">17751</span> bash</span><br><span class="line"><span class="number">18534</span> <span class="number">18534</span> <span class="number">17763</span> ps</span><br><span class="line"><span class="number">18535</span> <span class="number">18534</span> <span class="number">17763</span> cat</span><br></pre></td></tr></table></figure>
<p>PID为进程自身的ID，PGID为进程所在的进程组的ID， PPID为进程的父进程ID。从上面的结果，我们可以推测出如下关系：</p>
<p><img src="/images/14590055773563.jpg" alt=""></p>
<p>图中箭头表示父进程通过fork和exec机制产生子进程。ps和cat都是bash的子进程。进程组的领导进程的PID成为进程组ID。领导进程可以先终结。此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。</p>
<p>我们将一些进程归为进程组的一个重要原因是我们可以将信号发送给一个进程组。进程组中的所有进程都会收到该信号。我们会在下一部分深入讨论这一点。</p>
<p><strong>会话 (session)</strong></p>
<p>更进一步，在shell支持工作控制(job control)的前提下，多个进程组还可以构成一个会话 (session)。bash(Bourne-Again shell)支持工作控制，而sh(Bourne shell)并不支持。</p>
<p>会话是由其中的进程建立的，该进程叫做会话的领导进程(session leader)。会话领导进程的PID成为识别会话的SID(session ID)。会话中的每个进程组称为一个工作(job)。会话可以有一个进程组成为会话的前台工作(foreground)，而其他的进程组是后台工作(background)。每个会话可以连接一个控制终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。由终端产生的信号，比如CTRL+Z， CTRL+\，会传递到前台进程组。</p>
<p>会话的意义在于将多个工作囊括在一个终端，并取其中的一个工作作为前台，来直接接收该终端的输入输出以及终端信号。 其他工作在后台运行。</p>
<p>一个命令可以通过在末尾加上&amp;方式让它在后台运行:</p>
<pre><code>$ping localhost &gt; log &amp;
</code></pre><p>此时终端显示:</p>
<pre><code>[1] 10141
</code></pre><p>括号中的1表示工作号，而10141为PGID</p>
<p>我们通过如下方式查询更加详细的信息:</p>
<pre><code>$ps -o pid,pgid,ppid,sid,tty,comm
(tty表示控制终端）
</code></pre><p>信号可以通过kill</p>
<pre><code>$kill -SIGTERM -10141
</code></pre><p>或者</p>
<pre><code>$kill -SIGTERM %1
</code></pre><p>的方式来发送给工作组。上面的两个命令，一个是发送给PGID(通过在PGID前面加-来表示是一个PGID而不是PID)，一个是发送给工作1(%1)，两者等价。</p>
<p>一个工作可以通过$fg从后台工作变为前台工作:</p>
<pre><code>$cat &gt; log &amp;
$fg %1
</code></pre><p>当我们运行第一个命令后，由于工作在后台，我们无法对命令进行输入，直到我们将工作带入前台，才能向cat命令输入。在输入完成后，按下CTRL+D来通知shell输入结束。</p>
<p>进程组(工作)的概念较为简单易懂。而会话主要是针对一个终端建立的。当我们打开多个终端窗口时，实际上就创建了多个终端会话。每个会话都会有自己的前台工作和后台工作。这样，我们就为进程增加了管理和运行的层次。在没有图形化界面的时代，会话允许用户通过shell进行多层次的进程发起和管理。比如说，我可以通过shell发起多个后台工作，而此时标准输入输出并不被占据，我依然可以继续其它的工作。如今，图形化界面可以帮助我们解决这一需求，但工作组和会话机制依然在Linux的许多地方应用。</p>
<p><strong>总结</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process group, pgid</span><br><span class="line">session, sid, job, forground, background</span><br><span class="line"><span class="built_in">fg</span>, <span class="built_in">kill</span> -pid, &amp;, %</span><br></pre></td></tr></table></figure>
<h2 id="Linux_u7528_u6237"><a href="#Linux_u7528_u6237" class="headerlink" title="Linux用户"></a>Linux用户</h2><p>Linux的用户在登录(login)之后，就带有一个用户身份(user ID, UID)和一个组身份(group ID, GID)。在Linux文件管理背景知识中，我们又看到，每个文件又有九位的权限说明，用来指明该文件允许哪些用户执行哪些操作(读、写或者执行)。</p>
<p><strong>进程权限</strong></p>
<p>但是，在Linux中，用户的指令是在进程的范围内进行的。当我们向对某个文件进行操作的时候，我们需要在进程中运行一个程序，在进程中对文件打开，并进行读、写或者执行的操作。因此，我们需要将用户的权限传递给进程，以便进程真正去执行操作。例如我们有一个文件a.txt, 文件中为一个字符串:</p>
<pre><code>Hello world!
</code></pre><p>我以用户Vamei的身份登录，并在shell中运行如下命令：</p>
<pre><code>$cat a.txt
</code></pre><p>整个运行过程以及文件读取如下:</p>
<p><img src="/images/14590055890788.jpg" alt=""></p>
<p>我们可以看到，整个过程中我们会有两个进程，一个是shell本身(2256)，一个是shell复制自身，再运行/bin/cat (9913)。图中的fork, exec, PID可参看Linux进程基础。第二个进程总共对文件系统进行了两次操作，一次是执行(x)文件/bin/cat，另外一次是读取(r)文件a.txt。使用<code>$ls -l</code> 查看这两个文件的权限:</p>
<pre><code>$ls -l /bin/cat
-rwxr-xr-x 1 root root 46764 Apr  1  2012 /bin/cat

$ls -l a.txt
-rw-rw-r-- 1 Vamei Vamei 14 Oct  7 09:14 a.txt
</code></pre><p>从上面可以看到(参考Linux文件管理背景知识)，/bin/cat让所有用户都享有执行的权利，而Vamei作为a.txt的拥有者，对a.txt享有读取的权利。</p>
<p>让我们进入更多的细节 (The devil is in the details)。在进行这两次操作的时候，尽管用户Vamei拥有相应的权限，但我们发现，真正做工作的是进程9913。我们要让这个进程得到相应的权限。实际上，每个进程会维护有如下6个ID：</p>
<p>真实身份: real UID,       real GID</p>
<p>有效身份: effective UID,  effective GID</p>
<p>存储身份: saved UID,      saved GID</p>
<p>其中，真实身份是我们登录使用的身份，有效身份是当该进程真正去操作文件时所检查的身份，存储身份较为特殊，我们等一下再深入。当进程fork的时候，真实身份和有效身份都会复制给子进程。大部分情况下，真实身份和有效身份都相同。当Linux完成开机启动之后，init进程会执行一个login的子进程。我们将用户名和密码传递给login子进程。login在查询了/etc/passwd和/etc/shadow，并确定了其合法性之后，运行(利用exec)一个shell进程，shell进程真实身份被设置成为该用户的身份。由于此后fork此shell进程的子进程都会继承真实身份，所以该真实身份会持续下去，直到我们登出并以其他身份再次登录(当我们使用su成为root的时候，实际上就是以root身份再次登录，此后真实身份成为root)。</p>
<p><strong>最小权限原则</strong></p>
<p>每个进程为什么不简单地只维护真实身份，却选择费尽麻烦地去维护有效身份和存储身份呢？这牵涉到Linux的“最小特权”(least priviledge)的原则。Linux通常希望进程只拥有足够完成其工作的特权，而不希望赋予更多的特权给它。从设计上来说，最简单的是赋予每个进程以super user的特权，这样进程就可以想做什么做什么。然而，这对于系统来说是一个巨大的安全漏洞，特别是在多用户环境下，如果每个用户都享有无限制的特权，就很容易破坏其他用户的文件或者系统本身。“最小特权”就是收缩进程所享有的特权，以防进程滥用特权。</p>
<p>然而，进程的不同阶段可能需要不同的特权。比如一个进程最开始的有效身份是真实身份，但运行到中间的时候，需要以其他的用户身份读入某些配置文件，然后再进行其他的操作。为了防止其他的用户身份被滥用，我们需要在操作之前，让进程的有效身份变更回来成为真实身份。这样，进程需要在两个身份之间变化。</p>
<p>存储身份就是真实身份之外的另一个身份。当我们将一个程序文件执行成为进程的时候，该程序文件的拥有者(owner)和拥有组(owner group)可以被，存储成为进程的存储身份。在随后进程的运行过程中，进程就将可以选择将真实身份或者存储身份复制到有效身份，以拥有真实身份或者存储身份的权限。并不是所有的程序文件在执行的过程都设置存储身份的。需要这么做的程序文件会在其九位(bit)权限的执行位的x改为s。这时，这一位(bit)叫做set UID bit或者set GID bit。</p>
<pre><code>$ls -l /usr/bin/uuidd
-rwsr-sr-x 1 libuuid libuuid 17976 Mar 30  2012 /usr/sbin/uuidd
</code></pre><p>当我以root(UID), root(GID)的真实身份运行这个程序的时候，由于拥有者(owner)有s位的设定，所以saved UID被设置成为libuuid，saved GID被设置成为libuuid。这样，uuidd的进程就可以在两个身份之间切换。</p>
<p>我们通常使用chmod来修改set-UID bit和set-GID bit:</p>
<pre><code>$chmod 4700 file
</code></pre><p>我们看到，这里的chmod后面不再只是三位的数字。最前面一位用于处理set-UID bit/set-GID bit，它可以被设置成为4/2/1以及或者上面数字的和。4表示为set UID bit, 2表示为set GID bit，1表示为sticky bit (暂时不介绍)。必须要先有x位的基础上，才能设置s位。</p>
<p>作为一个Linux用户来说，我们并不需要特别关心上面的机制。但是，当我们去编写一个Linux应用程序的时候，就要注意在程序中实现以上切换(有必要的前提下)，以便让我们的程序符合”最小权限”的原则，不给系统留下可能的安全隐患</p>
<h2 id="Linux_u4ECE_u7A0B_u5E8F_u5230_u8FDB_u7A0B"><a href="#Linux_u4ECE_u7A0B_u5E8F_u5230_u8FDB_u7A0B" class="headerlink" title="Linux从程序到进程"></a>Linux从程序到进程</h2><p>计算机如何执行进程呢？这是计算机运行的核心问题。即使已经编写好程序，但程序是死的。只有活的进程才能产出。我们已经从Linux进程基础中了解了进程。现在我们看一下从程序到进程的漫漫征程。</p>
<p><strong>一段程序</strong></p>
<p>下面是一个简单的C程序，假设该程序已经编译好</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> glob=<span class="number">0</span>;                                             <span class="comment">/*global variable*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> main1=<span class="number">5</span>;                                          <span class="comment">/*local variable of main()*/</span></span><br><span class="line">  <span class="keyword">int</span> main2;                                            <span class="comment">/*local variable of main()*/</span></span><br><span class="line">  main2 = inner(main1);                                 <span class="comment">/* call inner() function */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"From Main: glob: %d \n"</span>, glob);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"From Main: main2: %d \n"</span>, main2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inner</span><span class="params">(<span class="keyword">int</span> inner1)</span> </span>&#123;                                 <span class="comment">/*inner1 is an argument, also local to inner()*/</span></span><br><span class="line">  <span class="keyword">int</span> inner2=<span class="number">10</span>;                                        <span class="comment">/*local variable of inner()*/</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"From inner: glob: %d \n"</span>, glob);</span><br><span class="line">  <span class="keyword">return</span>(inner1+inner2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(选取哪一个语言或者具体的语法并不是关键，大部分语言都可以写出类似上面的程序。在看Python教程的读者也可以利用Python的函数结构和print写一个类似的python程序。当然，还可以是C++，Java，Objective-C等等。选用C语言的原因是：它是为UNIX而生的语言。)</p>
<p>main()函数中调用了inner()函数。inner()中调用一次printf()以输出。最后，在main()中进行了两次printf()。</p>
<p>注意变量的作用范围。简单地说，变量可以分为全局变量和局部变量。在所有函数之外声明的变量为全局变量，比如glob，在任何时候都可以使用。在函数内定义的变量为局部变量，只能在该函数的作用域(range)内使用，比如说我们在inner()工作的时候不能使用main()函数中声明的main1变量，而在main()中我们无法使用inner()函数中声明的inner2变量。</p>
<p>不用太过在意这个程序的具体功能。要点是这个程序的运行过程。下图为该程序的运行过程，以及各个变量的作用范围：</p>
<p><img src="/images/14590056061703.jpg" alt=""></p>
<p><strong>进程空间</strong></p>
<p>为了进一步了解上面程序的运行，我们还需要知道，进程如何使用内存。当程序文件运行为进程时，进程在内存中获得空间。这个空间是进程自己的小屋子。</p>
<p>每个进程空间按照如下方式分为不同区域:</p>
<p><img src="/images/14590056162054.jpg" alt=""></p>
<p>Text区域用来储存指令(instruction)，说明每一步的操作。Global Data用于存放全局变量，栈(Stack)用于存放局部变量，堆(heap)用于存放动态变量 (dynamic variable. 程序利用malloc系统调用，直接从内存中为dynamic variable开辟空间)。Text和Global data在进程一开始的时候就确定了，并在整个进程中保持固定大小。</p>
<p>栈(Stack)以帧(stack frame)为单位。当程序调用函数的时候，比如main()函数中调用inner()函数，stack会向下增长一帧。帧中存储该函数的参数和局部变量，以及该函数的返回地址(return address)。此时，计算机将控制权从main()转移到inner()，inner()函数处于激活(active)状态。位于栈最下方的帧，和全局变量一起，构成了当前的环境(context)。激活函数可以从环境中调用需要的变量。典型的编程语言都只允许你使用位于stack最下方的帧 ，而不允许你调用其它的帧 (这也符合stack结构“先进后出”的特征。但也有一些语言允许你调用栈的其它部分，相当于允许你在运行inner()函数的时候调用main()中声明的局部变量，比如Pascal)。当函数又进一步调用另一个函数的时候，一个新的帧会继续增加到栈的下方，控制权转移到新的函数中。当激活函数返回的时候，会从栈中弹出(pop，读取并从栈中删除)该帧，并根据帧中记录的返回地址，将控制权交给返回地址所指向的指令(比如从inner()函数中返回，继续执行main()中赋值给main2的操作)。</p>
<p>下图是栈在运行过程中的变化。箭头表示栈的增长方向。每个方块代表一帧。开始的时候我们有一个为main()服务的帧，随着调用inner()，我们为inner()增加一个帧。在inner()返回时，我们再次只有main()的帧，直到最后main()返回，其返回地址为空，所以进程结束。</p>
<p><img src="/images/14590056276526.jpg" alt=""></p>
<p>在进程运行的过程中，通过调用和返回函数，控制权不断在函数间转移。进程可以在调用函数的时候，原函数的帧中保存有在我们离开时的状态，并为新的函数开辟所需的帧空间。在调用函数返回时，该函数的帧所占据的空间随着帧的弹出而清空。进程再次回到原函数的帧中保存的状态，并根据返回地址所指向的指令继续执行。上面过程不断继续，栈不断增长或减小，直到main()返回的时候，栈完全清空，进程结束。</p>
<p>当程序中使用malloc的时候，堆(heap)会向上增长，其增长的部分就成为malloc从内存中分配的空间。malloc开辟的空间会一直存在，直到我们用free系统调用来释放，或者进程结束。一个经典的错误是内存泄漏(memory leakage), 就是指我们没有释放不再使用的堆空间，导致堆不断增长，而内存可用空间不断减少。</p>
<p>栈和堆的大小则会随着进程的运行增大或者变小。当栈和堆增长到两者相遇时候，也就是内存空间图中的蓝色区域(unused area)完全消失的时候，再无可用内存。进程会出现栈溢出(stack overflow)的错误，导致进程终止。在现代计算机中，内核一般会为进程分配足够多的蓝色区域，如果清理及时，栈溢出很容易避免。即便如此，内存负荷过大，依然可能出现栈溢出的情况。我们就需要增加物理内存了。</p>
<p>Stack overflow可以说是最出名的计算机错误了，所以才有IT网站(stackoverflow.com)以此为名。</p>
<p><strong>进程附加信息</strong></p>
<p>除了上面的信息之外，每个进程还要包括一些进程附加信息，包括PID，PPID，PGID(参考Linux进程基础以及Linux进程关系)等，用来说明进程的身份、进程关系以及其它统计信息。这些信息并不保存在进程的内存空间中。内核会为每个进程在内核自己的空间中分配一个变量(task_struct结构体)以保存上述信息。内核可以通过查看自己空间中的各个进程的附加信息就能知道进程的概况，而不用进入到进程自身的空间 (就好像我们可以通过门牌就可以知道房间的主人是谁一样，而不用打开房门)。每个进程的附加信息中有位置专门用于保存接收到的信号(正如我们在Linux信号基础中所说的“信箱”)。</p>
<p><strong>fork &amp; exec</strong></p>
<p>现在，我们可以更加深入地了解fork和exec(参考Linux进程基础)的机制了。当一个程序调用fork的时候，实际上就是将上面的内存空间，包括text, global data, heap和stack，又复制出来一个，构成一个新的进程，并在内核中为改进程创建新的附加信息 (比如新的PID，而PPID为原进程的PID)。此后，两个进程分别地继续运行下去。新的进程和原有进程有相同的运行状态(相同的变量值，相同的instructions…)。我们只能通过进程的附加信息来区分两者。</p>
<p>程序调用exec的时候，进程清空自身内存空间的text, global data, heap和stack，并根据新的程序文件重建text, global data, heap和stack (此时heap和stack大小都为0)，并开始运行。</p>
<p>(现代操作系统为了更有效率，改进了管理fork和exec的具体机制，但从逻辑上来说并没有差别。具体机制请参看Linux内核相关书籍)</p>
<p>这一篇写了整合了许多东西，所以有些长。这篇文章主要是概念性的，许多细节会根据语言和平台乃至于编译器的不同而有所变化，但大体上，以上的概念适用于所有的计算机进程(无论是Windows还是UNIX)。更加深入的内容，包括线程(thread)、进程间通信(IPC)等，都依赖于这里介绍的内容。</p>
<p><strong>总结</strong></p>
<p>函数，变量的作用范围，global/local/dynamic variables</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">global data, text,</span><br><span class="line"><span class="built_in">stack</span>, <span class="built_in">stack</span> frame, <span class="keyword">return</span> address, <span class="built_in">stack</span> overflow</span><br><span class="line">heap, <span class="built_in">malloc</span>, <span class="built_in">free</span>, memory leakage</span><br><span class="line">进程附加信息, task_struct</span><br><span class="line">fork &amp; exec</span><br></pre></td></tr></table></figure>
<h2 id="Linux_u591A_u7EBF_u7A0B_u4E0E_u540C_u6B65"><a href="#Linux_u591A_u7EBF_u7A0B_u4E0E_u540C_u6B65" class="headerlink" title="Linux多线程与同步"></a>Linux多线程与同步</h2><p>典型的UNIX系统都支持一个进程创建多个线程(thread)。在Linux进程基础中提到，Linux以进程为单位组织操作，Linux中的线程也都基于进程。尽管实现方式有异于其它的UNIX系统，但Linux的多线程在逻辑和使用上与真正的多线程并没有差别。</p>
<p><strong>多线程</strong></p>
<p>我们先来看一下什么是多线程。在Linux从程序到进程中，我们看到了一个程序在内存中的表示。这个程序的整个运行过程中，只有一个控制权的存在。当函数被调用的时候，该函数获得控制权，成为激活(active)函数，然后运行该函数中的指令。与此同时，其它的函数处于离场状态，并不运行。如下图所示:</p>
<p><img src="/images/14590056454901.jpg" alt=""></p>
<p>我们看到，各个方块之间由箭头连接。各个函数就像是连在一根线上一样，计算机像一条流水线一样执行各个函数中定义的操作。这样的一个程序叫做单线程程序。</p>
<p>多线程就是允许一个进程内存在多个控制权，以便让多个函数同时处于激活状态，从而让多个函数的操作同时运行。即使是单CPU的计算机，也可以通过不停地在不同线程的指令间切换，从而造成多线程同时运行的效果。如下图所示，就是一个多线程的流程:</p>
<p><img src="/images/14590056551293.jpg" alt=""></p>
<p>main()到func3()再到main()构成一个线程，此外func1()和func2()构成另外两个线程。操作系统一般都有一些系统调用来让你将一个函数运行成为一个新的线程。</p>
<p>回忆我们在Linux从程序到进程中提到的栈的功能和用途。一个栈，只有最下方的帧可被读写。相应的，也只有该帧对应的那个函数被激活，处于工作状态。为了实现多线程，我们必须绕开栈的限制。为此，创建一个新的线程时，我们为这个线程建一个新的栈。每个栈对应一个线程。当某个栈执行到全部弹出时，对应线程完成任务，并收工。所以，多线程的进程在内存中有多个栈。多个栈之间以一定的空白区域隔开，以备栈的增长。每个线程可调用自己栈最下方的帧中的参数和变量，并与其它线程共享内存中的Text，heap和global data区域。对应上面的例子，我们的进程空间中需要有3个栈。</p>
<p>(要注意的是，对于多线程来说，由于同一个进程空间中存在多个栈，任何一个空白区域被填满都会导致stack overflow的问题。)</p>
<p><strong>并发</strong></p>
<p>多线程相当于一个并发(concunrrency)系统。并发系统一般同时执行多个任务。如果多个任务可以共享资源，特别是同时写入某个变量的时候，就需要解决同步的问题。比如说，我们有一个多线程火车售票系统，用全局变量i存储剩余的票数。多个线程不断地卖票(i = i - 1)，直到剩余票数为0。所以每个都需要执行如下操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*mu is a global mutex*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;                        <span class="comment">/*infinite loop*/</span></span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) i = i -<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"no more tickets"</span>);</span><br><span class="line">      <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只有一个线程执行上面的程序的时候(相当于一个窗口售票)，则没有问题。但如果多个线程都执行上面的程序(相当于多个窗口售票), 我们就会出现问题。我们会看到，其根本原因在于同时发生的各个线程都可以对i读取和写入。</p>
<p>我们这里的if结构会给CPU两个指令, 一个是判断是否有剩余的票(i != 0), 一个是卖票 (i = i -1)。某个线程会先判断是否有票(比如说此时i为1)，但两个指令之间存在一个时间窗口，其它线程可能在此时间窗口内执行卖票操作(i = i -1)，导致该线程卖票的条件不再成立。但该线程由于已经执行过了判断指令，所以无从知道i发生了变化，所以继续执行卖票指令，以至于卖出不存在的票 (i成为负数)。对于一个真实的售票系统来说，这将成为一个严重的错误 (售出了过多的票，火车爆满)。</p>
<p>在并发情况下，指令执行的先后顺序由内核决定。同一个线程内部，指令按照先后顺序执行，但不同线程之间的指令很难说清除哪一个会先执行。如果运行的结果依赖于不同线程执行的先后的话，那么就会造成竞争条件(race condition)，在这样的状况下，计算机的结果很难预知。我们应该尽量避免竞争条件的形成。最常见的解决竞争条件的方法是将原先分离的两个指令构成不可分隔的一个原子操作(atomic operation)，而其它任务不能插入到原子操作中。</p>
<p><strong>多线程同步</strong></p>
<p>对于多线程程序来说，同步(synchronization)是指在一定的时间内只允许某一个线程访问某个资源 。而在此时间内，不允许其它的线程访问该资源。我们可以通过互斥锁(mutex)，条件变量(condition variable)和读写锁(reader-writer lock)来同步资源。</p>
<p><strong>1) 互斥锁</strong></p>
<p>互斥锁是一个特殊的变量，它有锁上(lock)和打开(unlock)两个状态。互斥锁一般被设置成全局变量。打开的互斥锁可以由某个线程获得。一旦获得，这个互斥锁会锁上，此后只有该线程有权打开。其它想要获得互斥锁的线程，会等待直到互斥锁再次打开的时候。我们可以将互斥锁想像成为一个只能容纳一个人的洗手间，当某个人进入洗手间的时候，可以从里面将洗手间锁上。其它人只能在互斥锁外面等待那个人出来，才能进去。在外面等候的人并没有排队，谁先看到洗手间空了，就可以首先冲进去。</p>
<p>上面的问题很容易使用互斥锁的问题解决，每个线程的程序可以改为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*mu is a global mutex*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;                <span class="comment">/*infinite loop*/</span></span><br><span class="line">  mutex_lock(mu);           <span class="comment">/*aquire mutex and lock it, if cannot, wait until mutex is unblocked*/</span></span><br><span class="line">  <span class="keyword">if</span> (i != <span class="number">0</span>) i = i - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"no more tickets"</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_unlock(mu);         <span class="comment">/*release mutex, make it unblocked*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个执行mutex_lock()的线程会先获得mu。其它想要获得mu的线程必须等待，直到第一个线程执行到mutex_unlock()释放mu，才可以获得mu，并继续执行线程。所以线程在mutex_lock()和mutex_unlock()之间的操作时，不会被其它线程影响，就构成了一个原子操作。</p>
<p>需要注意的时候，如果存在某个线程依然使用原先的程序 (即不尝试获得mu，而直接修改i)，互斥锁不能阻止该程序修改i，互斥锁就失去了保护资源的意义。所以，互斥锁机制需要程序员自己来写出完善的程序来实现互斥锁的功能。我们下面讲的其它机制也是如此。</p>
<p><strong>2) 条件变量</strong></p>
<p>条件变量是另一种常用的变量。它也常常被保存为全局变量，并和互斥锁合作。</p>
<p>假设这样一个状况: 有100个工人，每人负责装修一个房间。当有10个房间装修完成的时候，老板就通知相应的十个工人一起去喝啤酒。</p>
<p>我们如何实现呢？老板让工人在装修好房间之后，去检查已经装修好的房间数。但多线程条件下，会有竞争条件的危险。也就是说，其他工人有可能会在该工人装修好房子和检查之间完成工作。采用下面方式解决：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*mu: global mutex, cond: global codition variable, num: global int*/</span></span><br><span class="line">mutex_lock(mu)</span><br><span class="line"></span><br><span class="line">num = num + <span class="number">1</span>;                      <span class="comment">/*worker build the room*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num &lt;= <span class="number">10</span>) &#123;                     <span class="comment">/*worker is within the first 10 to finish*/</span></span><br><span class="line">    cond_wait(mu, cond);            <span class="comment">/*wait*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"drink beer"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num = <span class="number">11</span>) &#123;                <span class="comment">/*workder is the 11th to finish*/</span></span><br><span class="line">  cond_broadcast(mu, cond);         <span class="comment">/*inform the other 9 to wake up*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutex_unlock(mu);</span><br></pre></td></tr></table></figure>
<p>上面使用了条件变量。条件变量除了要和互斥锁配合之外，还需要和另一个全局变量配合(这里的num, 也就是装修好的房间数)。这个全局变量用来构成各个条件。</p>
<p>具体思路如下。我们让工人在装修好房间(num = num + 1)之后，去检查已经装修好的房间数( num &lt; 10 )。由于mu被锁上，所以不会有其他工人在此期间装修房间(改变num的值)。如果该工人是前十个完成的人，那么我们就调用cond_wait()函数。<br>cond_wait()做两件事情，一个是释放mu，从而让别的工人可以建房。另一个是等待，直到cond的通知。这样的话，符合条件的线程就开始等待。</p>
<p>当有通知(第十个房间已经修建好)到达的时候，condwait()会再次锁上mu。线程的恢复运行，执行下一句prinft(“drink beer”) (喝啤酒！)。从这里开始，直到mutex_unlock()，就构成了另一个互斥锁结构。</p>
<p>那么，前面十个调用cond_wait()的线程如何得到的通知呢？我们注意到elif if，即修建好第11个房间的人，负责调用cond_broadcast()。这个函数会给所有调用cond_wait()的线程放送通知，以便让那些线程恢复运行。</p>
<p>条件变量特别适用于多个线程等待某个条件的发生。如果不使用条件变量，那么每个线程就需要不断尝试获得互斥锁并检查条件是否发生，这样大大浪费了系统的资源。</p>
<p><strong>3) 读写锁</strong></p>
<p>读写锁与互斥锁非常相似。r、RW lock有三种状态: 共享读取锁(shared-read), 互斥写入锁(exclusive-write lock), 打开(unlock)。后两种状态与之前的互斥锁两种状态完全相同。</p>
<p>一个unlock的RW lock可以被某个线程获取R锁或者W锁。</p>
<p>如果被一个线程获得R锁，RW lock可以被其它线程继续获得R锁，而不必等待该线程释放R锁。但是，如果此时有其它线程想要获得W锁，它必须等到所有持有共享读取锁的线程释放掉各自的R锁。</p>
<p>如果一个锁被一个线程获得W锁，那么其它线程，无论是想要获取R锁还是W锁，都必须等待该线程释放W锁。</p>
<p>这样，多个线程就可以同时读取共享资源。而具有危险性的写入操作则得到了互斥锁的保护。</p>
<p>我们需要同步并发系统，这为程序员编程带来了难度。但是多线程系统可以很好的解决许多IO瓶颈的问题。比如我们监听网络端口。如果我们只有一个线程，那么我们必须监听，接收请求，处理，回复，再监听。如果我们使用多线程系统，则可以让多个线程监听。当我们的某个线程进行处理的时候，我们还可以有其他的线程继续监听，这样，就大大提高了系统的利用率。在数据越来越大，服务器读写操作越来越多的今天，这具有相当的意义。多线程还可以更有效地利用多CPU的环境。</p>
<p>(就像做饭一样，不断切换去处理不同的菜。)</p>
<p>本文中的程序采用伪C的写法。不同的语言有不同的函数名(比如mutex_lock)。这里关注的是逻辑上的概念，而不是具体的实现和语言规范。</p>
<p><strong>总结</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">multiple </span>threads, <span class="keyword">multiple </span>stacks</span><br><span class="line"><span class="label">race</span> condition</span><br><span class="line"><span class="label">mutex</span>, condition variable, RW lock</span><br></pre></td></tr></table></figure>
<h2 id="Linux_u8FDB_u7A0B_u95F4_u901A_u4FE1"><a href="#Linux_u8FDB_u7A0B_u95F4_u901A_u4FE1" class="headerlink" title="Linux进程间通信"></a>Linux进程间通信</h2><p>我们在Linux信号基础中已经说明，信号可以看作一种粗糙的进程间通信(IPC, interprocess communication)的方式，用以向进程封闭的内存空间传递信息。为了让进程间传递更多的信息量，我们需要其他的进程间通信方式。这些进程间通信方式可以分为两种:</p>
<ul>
<li>管道(PIPE)机制。在Linux文本流中，我们提到可以使用管道将一个进程的输出和另一个进程的输入连接起来，从而利用文件操作API来管理进程间通信。在shell中，我们经常利用管道将多个进程连接在一起，从而让各个进程协作，实现复杂的功能。</li>
<li>传统IPC (interprocess communication)。我们主要是指消息队列(message queue)，信号量(semaphore)，共享内存(shared memory)。这些IPC的特点是允许多进程之间共享资源，这与多线程共享heap和global data相类似。由于多进程任务具有并发性 (每个进程包含一个进程，多个进程的话就有多个线程)，所以在共享资源的时候也必须解决同步的问题 (参考Linux多线程与同步)。</li>
</ul>
<p><strong>管道与FIFO文件</strong></p>
<p>一个原始的IPC方式是所有的进程通过一个文件交流。比如我在纸(文件)上写下我的名字和年纪。另一个人读这张纸，会知道我的名字和年纪。他也可以在同一张纸上写下他的信息，而当我读这张纸的话，同样也可以知道别人的信息。但是，由于硬盘读写比较慢，所以这个方式效率很低。那么，我们是否可以将这张纸放入内存中以提高读写速度呢？</p>
<p>在Linux文本流中，我们已经讲解了如何在shell中使用管道连接多个进程。同样，许多编程语言中，也有一些命令用以实现类似的机制，比如在Python子进程中使用Popen和PIPE，在C语言中也有popen库函数来实现管道 (shell中的管道就是根据此编写的)。管道是由内核管理的一个缓冲区(buffer)，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。</p>
<p><img src="/images/14590056730715.jpg" alt=""></p>
<p>从原理上，管道利用fork机制建立(参考Linux进程基础和Linux从程序到进程），从而让两个进程可以连接到同一个PIPE上。最开始的时候，上面的两个箭头都连接在同一个进程Process 1上(连接在Process 1上的两个箭头)。当fork复制进程的时候，会将这两个连接也复制到新的进程(Process 2)。随后，每个进程关闭自己不需要的一个连接 (两个黑色的箭头被关闭; Process 1关闭从PIPE来的输入连接，Process 2关闭输出到PIPE的连接)，这样，剩下的红色连接就构成了如上图的PIPE。</p>
<p><img src="/images/14590056811596.jpg" alt=""></p>
<p><strong>传统IPC</strong></p>
<p>这几种传统IPC实际上有很悠久的历史，所以其实现方式也并不完善 (比如说我们需要某个进程负责删除建立的IPC)。一个共同的特征是它们并不使用文件操作的API。对于任何一种IPC来说，你都可以建立多个连接，并使用键值(key)作为识别的方式。我们可以在一个进程中中通过键值来使用的想要那一个连接 (比如多个消息队列，而我们选择使用其中的一个)。键值可以通过某种IPC方式在进程间传递(比如说我们上面说的PIPE，FIFO或者写入文件)，也可以在编程的时候内置于程序中。</p>
<p>在几个进程共享键值的情况下，这些传统IPC非常类似于多线程共享资源的方式(参看Linux多线程与同步):</p>
<ul>
<li>semaphore与mutex类似，用于处理同步问题。我们说mutex像是一个只能容纳一个人的洗手间，那么semaphore就像是一个能容纳N个人的洗手间。其实从意义上来说，semaphore就是一个计数锁(我觉得将semaphore翻译成为信号量非常容易让人混淆semaphore与signal)，它允许被N个进程获得。当有更多的进程尝试获得semaphore的时候，就必须等待有前面的进程释放锁。当N等于1的时候，semaphore与mutex实现的功能就完全相同。许多编程语言也使用semaphore处理多线程同步的问题。一个semaphore会一直存在在内核中，直到某个进程删除它。</li>
<li>共享内存与多线程共享global data和heap类似。一个进程可以将自己内存空间中的一部分拿出来，允许其它进程读写。当使用共享内存的时候，我们要注意同步的问题。我们可以使用semaphore同步，也可以在共享内存中建立mutex或其它的线程同步变量来同步。由于共享内存允许多个进程直接对同一个内存区域直接操作，所以它是效率最高的IPC方式。</li>
</ul>
<p>消息队列(message queue)与PIPE相类似。它也是建立一个队列，先放入队列的消息被最先取出。不同的是，消息队列允许多个进程放入消息，也允许多个进程取出消息。每个消息可以带有一个整数识别符(message_type)。你可以通过识别符对消息分类 (极端的情况是将每个消息设置一个不同的识别符)。某个进程从队列中取出消息的时候，可以按照先进先出的顺序取出，也可以只取出符合某个识别符的消息(有多个这样的消息时，同样按照先进先出的顺序取出)。消息队列与PIPE的另一个不同在于它并不使用文件API。最后，一个队列不会自动消失，它会一直存在于内核中，直到某个进程删除该队列。</p>
<p>多进程协作可以帮助我们充分利用多核和网络时代带来的优势。多进程可以有效解决计算瓶颈的问题。互联网通信实际上也是一个进程间通信的问题，只不过这多个进程分布于不同的电脑上。网络连接是通过socket实现的。由于socket内容庞大，所以我们不在这里深入。一个小小的注解是，socket也可以用于计算机内部进程间的通信。</p>
<p><strong>总结</strong></p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PIPE, FIFO</span><br><span class="line">semaphore, message queue, <span class="keyword">shared</span> memory; <span class="keyword">key</span></span><br></pre></td></tr></table></figure>
<h2 id="Linux_u6587_u4EF6_u7CFB_u7EDF_u7684_u5B9E_u73B0"><a href="#Linux_u6587_u4EF6_u7CFB_u7EDF_u7684_u5B9E_u73B0" class="headerlink" title="Linux文件系统的实现"></a>Linux文件系统的实现</h2><p>Linux文件管理从用户的层面介绍了Linux管理文件的方式。Linux有一个树状结构来组织文件。树的顶端为根目录(/)，节点为目录，而末端的叶子为包含数据的文件。当我们给出一个文件的完整路径时，我们从根目录出发，经过沿途各个目录，最终到达文件。</p>
<p>我们可以对文件进行许多操作，比如打开和读写。在Linux文件管理相关命令中，我们看到许多对文件进行操作的命令。它们大都基于对文件的打开和读写操作。比如cat可以打开文件，读取数据，最后在终端显示：</p>
<pre><code>$cat test.txt
</code></pre><p>对于Linux下的程序员来说，了解文件系统的底层组织方式，是深入进行系统编程所必备的。即使是普通的Linux用户，也可以根据相关的内容，设计出更好的系统维护方案。</p>
<p><strong>存储设备分区</strong></p>
<p>文件系统的最终目的是把大量数据有组织的放入持久性(persistant)的存储设备中，比如硬盘和磁盘。这些存储设备与内存不同。它们的存储能力具有持久性，不会因为断电而消失；存储量大，但读取速度慢。</p>
<p>观察常见存储设备。最开始的区域是MBR，用于Linux开机启动(参考Linux开机启动)。剩余的空间可能分成数个分区(partition)。每个分区有一个相关的分区表(Partition table)，记录分区的相关信息。这个分区表是储存在分区之外的。分区表说明了对应分区的起始位置和分区的大小。</p>
<p><img src="/images/14590056923433.jpg" alt=""></p>
<p>我们在Windows系统常常看到C分区、D分区等。Linux系统下也可以有多个分区，但都被挂载在同一个文件系统树上。</p>
<p>数据被存入到某个分区中。一个典型的Linux分区(partition)包含有下面各个部分:</p>
<p><img src="/images/14590056997684.jpg" alt=""></p>
<p>分区的第一个部分是启动区(Boot block)，它主要是为计算机开机服务的。Linux开机启动后，会首先载入MBR，随后MBR从某个硬盘的启动区加载程序。该程序负责进一步的操作系统的加载和启动。为了方便管理，即使某个分区中没有安装操作系统，Linux也会在该分区预留启动区。</p>
<p>启动区之后的是超级区(Super block)。它存储有文件系统的相关信息，包括文件系统的类型，inode的数目，数据块的数目。</p>
<p>随后是多个inodes，它们是实现文件存储的关键。在Linux系统中，一个文件可以分成几个数据块存储，就好像是分散在各地的龙珠一样。为了顺利的收集齐龙珠，我们需要一个“雷达”的指引：该文件对应的inode。每个文件对应一个inode。这个inode中包含多个指针，指向属于该文件各个数据块。当操作系统需要读取文件时，只需要对应inode的”地图”，收集起分散的数据块，就可以收获我们的文件了。</p>
<p>最后一部分，就是真正储存数据的数据块们(data blocks)了。</p>
<p><strong>inode简介</strong></p>
<p>上面我们看到了存储设备的宏观结构。我们要深入到分区的结构，特别是文件在分区中的存储方式。</p>
<p>文件是文件系统对数据的分割单元。文件系统用目录来组织文件，赋予文件以上下分级的结构。在硬盘上实现这一分级结构的关键，是使用inode来虚拟普通文件和目录文件对象。</p>
<p>在Linux文件管理中，我们知道，一个文件除了自身的数据之外，还有一个附属信息，即文件的元数据(metadata)。这个元数据用于记录文件的许多信息，比如文件大小，拥有人，所属的组，修改日期等等。元数据并不包含在文件的数据中，而是由操作系统维护的。事实上，这个所谓的元数据就包含在inode中。我们可以用$ls -l filename来查看这些元数据。正如我们上面看到的，inode所占据的区域与数据块的区域不同。每个inode有一个唯一的整数编号(inode number)表示。</p>
<p>在保存元数据，inode是“文件”从抽象到具体的关键。正如上一节中提到的，inode储存由一些指针，这些指针指向存储设备中的一些数据块，文件的内容就储存在这些数据块中。当Linux想要打开一个文件时，只需要找到文件对应的inode，然后沿着指针，将所有的数据块收集起来，就可以在内存中组成一个文件的数据了。</p>
<p><img src="/images/14590057101211.jpg" alt=""></p>
<p>inode并不是组织文件的唯一方式。最简单的组织文件的方法，是把文件依次顺序的放入存储设备，DVD就采取了类似的方式。但如果有删除操作，删除造成的空余空间夹杂在正常文件之间，很难利用和管理。</p>
<p>复杂的方式可以使用链表，每个数据块都有一个指针，指向属于同一文件的下一个数据块。这样的好处是可以利用零散的空余空间，坏处是对文件的操作必须按照线性方式进行。如果想随机存取，那么必须遍历链表，直到目标位置。由于这一遍历不是在内存进行，所以速度很慢。</p>
<p>FAT系统是将上面链表的指针取出，放入到内存的一个数组中。这样，FAT可以根据内存的索引，迅速的找到一个文件。这样做的主要问题是，索引数组的大小与数据块的总数相同。因此，存储设备很大的话，这个索引数组会比较大。</p>
<p>inode既可以充分利用空间，在内存占据空间不与存储设备相关，解决了上面的问题。但inode也有自己的问题。每个inode能够存储的数据块指针总数是固定的。如果一个文件需要的数据块超过这一总数，inode需要额外的空间来存储多出来的指针。</p>
<p><strong>inode示例</strong></p>
<p>在Linux中，我们通过解析路径，根据沿途的目录文件来找到某个文件。目录中的条目除了所包含的文件名，还有对应的inode编号。当我们输入$cat /var/test.txt时，Linux将在根目录文件中找到var这个目录文件的inode编号，然后根据inode合成var的数据。随后，根据var中的记录，找到text.txt的inode编号，沿着inode中的指针，收集数据块，合成text.txt的数据。整个过程中，我们参考了三个inode：根目录文件，var目录文件，text.txt文件的inodes。</p>
<p>在Linux下，可以使用$stat filename，来查询某个文件对应的inode编号。</p>
<p><img src="/images/14590057224870.jpg" alt=""></p>
<p>在存储设备中实际上存储为：</p>
<p><img src="/images/14590057295211.jpg" alt=""></p>
<p>当我们读取一个文件时，实际上是在目录中找到了这个文件的inode编号，然后根据inode的指针，把数据块组合起来，放入内存供进一步的处理。当我们写入一个文件时，是分配一个空白inode给该文件，将其inode编号记入该文件所属的目录，然后选取空白的数据块，让inode的指针指像这些数据块，并放入内存中的数据。</p>
<p><strong>文件共享</strong></p>
<p>在Linux的进程中，当我们打开一个文件时，返回的是一个文件描述符。这个文件描述符是一个数组的下标，对应数组元素为一个指针。有趣的是，这个指针并没有直接指向文件的inode，而是指向了一个文件表格，再通过该表格，指向加载到内存中的目标文件的inode。如下图，一个进程打开了两个文件。</p>
<p><img src="/images/14590057435416.jpg" alt=""></p>
<p>可以看到，每个文件表格中记录了文件打开的状态(status flags)，比如只读，写入等，还记录了每个文件的当前读写位置(offset)。当有两个进程打开同一个文件时，可以有两个文件表格，每个文件表格对应的打开状态和当前位置不同，从而支持一些文件共享的操作，比如同时读取。</p>
<p>要注意的是进程fork之后的情况，子进程将只复制文件描述符的数组，而和父进程共享内核维护的文件表格和inode。此时要特别小心程序的编写。</p>
<p><strong>总结</strong></p>
<p>这里概括性的总结了Linux的文件系统。Linux以inode的方式，让数据形成文件。</p>
<p>了解Linux的文件系统，是深入了解操作系Linux原理的重要一步。</p>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/03/03/2871198.html" target="_blank" rel="external">Linux 常用命令</a></li>
<li><a href="http://www.cnblogs.com/peida/archive/2012/12/05/2803591.html" target="_blank" rel="external">每天一个linux命令目录</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇日志来自 <a href="http://www.cnblogs.com/vamei">Vamei 博客</a> 中的系列文章，把一些基本的内容做了整合，方便查阅。</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://wdxtub.com/tags/Linux/"/>
    
      <category term="Vamei" scheme="http://wdxtub.com/tags/Vamei/"/>
    
      <category term="概念" scheme="http://wdxtub.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第十一周 - 声律启蒙]]></title>
    <link href="http://wdxtub.com/2016/03/25/rhythm-inspiration/"/>
    <id>http://wdxtub.com/2016/03/25/rhythm-inspiration/</id>
    <published>2016-03-25T10:04:09.000Z</published>
    <updated>2016-03-25T10:59:31.000Z</updated>
    <content type="html"><![CDATA[<p>云对雨，雪对风，晚照对晴空。天浩浩，日融融，弯月对长虹。</p>
<a id="more"></a>
<hr>
<p>这周的状态不是特别好，睡了八个月的帐篷终于开始有些不习惯了，再加上早早做完了作业，反而是有了更多『想干嘛就干嘛』的时间。周二买了无论是质量还是设计都不走洗的毕业礼服，周三和同学边吃饭边聊天，其他时间不是在睡觉，就是在准备睡觉的路上。</p>
<p>当然也有好消息，总算是确定了自己毕业后要落脚的地方。经过这么长时间的逡巡，应该说找到的双方都比较满意的工作，既不用一轮轮刷题（总有种摇尾乞怜的感觉），也没有太多的不信任感（不需要花时间自证）。工作嘛，双向选择，适合自己的，有广阔发展前景的，可能才是最好的选择。</p>
<p>于我，机会在哪里，我就愿意在哪里，而不是为了所谓『光环』，去当一颗螺丝钉。不想当将军的厨子不是好士兵，不过话说回来，人各有志，喜欢就好。</p>
<p>我不知道用战术勤奋掩盖战略懒惰是不是身边同学的『习惯』，经常在群里能看到三四点还在问作业相关问题，又或者告诉大家自己三四十个小时没有合眼。</p>
<p>我不大理解，也并不觉得真的需要这么『拼』，或者都不能说是『拼』，只能说是用低效率乘以长时间最后感动了自己。一天能做完的事情做一周，这根本不是什么值得骄傲或者感动的地方吧。说什么『现在的泪是选课时脑子进的水』，估计不是选课时进的，是本来就是水，不多去想想怎么提高效率，遇到简单问题就到处问，怎么进步呢？</p>
<p>我个人是很讨厌大半夜二话不说就甩作业问题来的人的，即使很多时候就是一句话的事儿，但是我也不想看这个头，不然以后就没完没了了。既然只是一句话的事儿，为什么不自己看看文档资料研究一下呢？</p>
<p>反而是有一些工作经验的同学，无论是相处还是聊天，都自在得多，至少不会出现『沟通障碍』。学校的学习是很重要，但是更重要的可能是培养自己去观察去思考的能力，作业是一种方式，但绝不是最好的方式。</p>
<p>我有我的冷漠无情，我有我的满腔热血。只索取不给予的人，离我远点，谢谢。</p>
<p>两鬓霜，一客行，新绿衬酒红。七颗星，一袍风，佛陀对苍生。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>云对雨，雪对风，晚照对晴空。天浩浩，日融融，弯月对长虹。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="平淡" scheme="http://wdxtub.com/tags/%E5%B9%B3%E6%B7%A1/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写文章]]></title>
    <link href="http://wdxtub.com/2016/03/24/write-an-article/"/>
    <id>http://wdxtub.com/2016/03/24/write-an-article/</id>
    <published>2016-03-25T00:47:12.000Z</published>
    <updated>2016-03-25T01:50:11.000Z</updated>
    <content type="html"><![CDATA[<p>在这个风云千樯的夜晚，我们来聊聊写文章。</p>
<a id="more"></a>
<hr>
<p>从高中开始写博客，转眼也快写了十年了。当然前七年都是瞎折腾，最近几年，随着阅读量的增加，写作慢慢才有了点起色。不由得想起这么一句话『Garbage in, Garbage out』，有高质量的『输入』，高质量的『输出』才成为可能。</p>
<p>这篇日志是我对于写文章这个事儿的一点感悟，比较零碎。</p>
<p>动笔之前，腹稿是很重要的，中心思想是什么，怎么组织文章来表达自己的想法，可能由于天资的问题我没办法一边写一边完成，所以我通常都会在纸上写关键字列提纲，这样不至于写着写着都不知道自己在写什么。浪费读者时间就是砸自己招牌，这种事情，给钱也不应该做。</p>
<p>写故事是另一种风格，真的是需要一些灵感，强求不来，对于故事本身来说，也许一开始不设定套路，反而是最好的套路，不然很容易落入俗套。另外一定要控制好『描述』、『说理』和『传情』的比例。描述太多累赘，说理太多教条，传情太多矫情。</p>
<p>那些让自己不开心不爽的事情，其实最有写下来的价值，这种内心的冲突，最难写，但是也最能出彩，试着去观察自己，并描述出来，既是很好的发泄，也是绝佳的训练。</p>
<p>另外值得写的就是各种光怪陆离的梦境，对于有些违背常理的东西，想要说清楚是很难的，但是这种训练的目的，只是去练习表达而已，多写就有不一样的收获。</p>
<p>从某种角度来说，写作是一种肌肉记忆，比方说写周记，我通常就会在周四或周五的晚上写作，慢慢形成习惯之后，到时间自然而然就会进入状态，几乎不会出现不知道写啥的情况，几乎都是自然而然流淌出来的文字。</p>
<p>时不时需要看自己以前的文字，用现在的标准去审视，有没有个人的风格，有没有词汇的不恰当，慢慢去培养自己的感觉。很多时候进入写作状态之后，出来的文字是比较『原生态』的，如果想要更进一步，就需要仔细打磨。观察自己的写作特点，并据此决定之后的方向。</p>
<blockquote>
<p>生气、嫉妒和沮丧是你灵感之源的毒药，你把这些处于萌芽状态的迹象消灭得越早，你的写作就会越好。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这个风云千樯的夜晚，我们来聊聊写文章。</p>]]>
    
    </summary>
    
      <category term="写作" scheme="http://wdxtub.com/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="阅读" scheme="http://wdxtub.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[看电影]]></title>
    <link href="http://wdxtub.com/2016/03/24/see-a-movie/"/>
    <id>http://wdxtub.com/2016/03/24/see-a-movie/</id>
    <published>2016-03-25T00:46:45.000Z</published>
    <updated>2016-03-25T01:15:13.000Z</updated>
    <content type="html"><![CDATA[<p>在这个风云千樯的夜晚，我们来聊聊看电影。</p>
<a id="more"></a>
<hr>
<p>我不算一个电影爱好者，看得不多，写得不多，想得也不多。但作为一种艺术表达形式，其实很多东西都是相通的。总体来说，依然可以按照《人间词话》中的三层来划分。</p>
<blockquote>
<p>昨夜西风凋碧树，独上高楼，望尽天涯路</p>
</blockquote>
<p>第一层很简单，就是两个字——『代入』。喜剧片大笑，言情片大哭，动作片大叫。不同的电影像是不同的楼，走到楼顶，去看这栋楼给你的风景。</p>
<blockquote>
<p>衣带渐宽终不悔，为伊消得人憔悴</p>
</blockquote>
<p>第二层需要加入一些『思考』，主题、道理、文化、知识，虽然有一定的局限性，但是至少自己觉得这些『思考』是有价值的（实际不一定，因为电影毕竟是艺术表现，可能得到的所谓『经验』并没有什么用）。</p>
<p>之所以比第一层要高，是因为已经开始『加工』电影本身，夹带『私货』，从『体验』变成了『参与』。</p>
<blockquote>
<p>众里寻他千百度，回首蓦见，那人正在灯火阑珊处</p>
</blockquote>
<p>第三层的关键词，恐怕是『抽离』，以一个局外人的角度，去观察电影的表达形式，去挖掘镜头的细节和深度。也就是说，要以电影为起点，去追根溯源，找到作者当初灵感迸发的瞬间，并研究为什么要用这样那样的形式去表现。</p>
<p>也许得到的答案，也就是平时自己忽略的细小瞬间罢了。</p>
<p>或者可以这么说，电影是起点，终点则是生活本身。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这个风云千樯的夜晚，我们来聊聊看电影。</p>]]>
    
    </summary>
    
      <category term="欣赏" scheme="http://wdxtub.com/tags/%E6%AC%A3%E8%B5%8F/"/>
    
      <category term="电影" scheme="http://wdxtub.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[广州美食地图]]></title>
    <link href="http://wdxtub.com/2016/03/24/guangzhou-food-map/"/>
    <id>http://wdxtub.com/2016/03/24/guangzhou-food-map/</id>
    <published>2016-03-25T00:13:02.000Z</published>
    <updated>2016-03-25T00:25:38.000Z</updated>
    <content type="html"><![CDATA[<p>这里记录一下网上比较出名的广州美食，非常适合『按图索骥』，口味比较个人化。</p>
<a id="more"></a>
<hr>
<h2 id="u5C0F_u5403"><a href="#u5C0F_u5403" class="headerlink" title="小吃"></a>小吃</h2><h3 id="u4E1C_u5DDD_u8DEF_u7A57_u94F6_u80A0_u7C89_u5E97"><a href="#u4E1C_u5DDD_u8DEF_u7A57_u94F6_u80A0_u7C89_u5E97" class="headerlink" title="东川路穗银肠粉店"></a>东川路穗银肠粉店</h3><p>猪腰肠或者牛肉肠。只要过去那边一定吃一次。反正是我个人认为的最好吃的肠粉</p>
<h3 id="u9648_u6DFB_u8BB0"><a href="#u9648_u6DFB_u8BB0" class="headerlink" title="陈添记"></a>陈添记</h3><p>过了宝华面店斜对面有条小巷叫十五甫三巷，拐进去就能看到“陈添记”的招牌，  此店绝对是广州的老字号，陈添记有三宝：爽滑鱼皮、艇仔粥、猪肠粉，招牌鱼皮：里面有花生粒、葱、姜、辣椒丝、香菜、芹菜，用特制酱油来调配，味道够足且各种滋味分明~</p>
<h3 id="u65B0_u8054_u7C89_u80A0_u5E97"><a href="#u65B0_u8054_u7C89_u80A0_u5E97" class="headerlink" title="新联粉肠店"></a>新联粉肠店</h3><p>地址：荔湾区多宝路88号  营业时间:7:00–14:30 二十多年的老店，门面超小，人气却火爆。拉肠3块一碟，粥4块一碗，十分大众化兼符合西关人省钱观念。拉肠口感香滑，配上自制酱油，非常美味。要注意的是，店铺之营业到下午两点半，要吃就要趁早了！</p>
<h3 id="u963F_u5A46_u725B_u6742"><a href="#u963F_u5A46_u725B_u6742" class="headerlink" title="阿婆牛杂"></a>阿婆牛杂</h3><p>地址：陆居路陆居肉菜市场牌坊内  开档时间：下午4时  价格：1元/串</p>
<p>网传是人气最强牛杂  仅仅在牛杂汤里滚两下已经可以吃得人满口香。觉得最能尝出阿婆牛杂真味的是豆卜串，饱吸酱汁浓味香口。而且阿婆这里也是全市少见的卖牛杂兼卖鱼蛋和牛丸的。不过略嫌汤底味道重，容易口渴。</p>
<h3 id="u897F_u5173_u5C0F_u98DF_u5E97_u2014_u2014_u798F_u6765_u9601"><a href="#u897F_u5173_u5C0F_u98DF_u5E97_u2014_u2014_u798F_u6765_u9601" class="headerlink" title="西关小食店——福来阁"></a>西关小食店——福来阁</h3><p>荔湾区泮塘路(仁威庙对面)  招牌就是传统瀬粉——粘米粉+人工压制.还有就是用料十足的萝卜糕，还有好多好味的小吃.</p>
<h3 id="u6F6E_u5B9D"><a href="#u6F6E_u5B9D" class="headerlink" title="潮宝"></a>潮宝</h3><p>多宝路221号，地铁长寿路站E出口的恒宝华庭出来以后，从中国银行方向往上下九方向走，就会看到一间不显眼的小店。小吃店真的很不起眼，还是很陋室那种。但是毕竟姜是老的辣——买午餐的人排了一条长队。</p>
<h3 id="u5E99_u524D_u76F4_u8857_u4E91_u541E_u9762_u4E16_u5BB6"><a href="#u5E99_u524D_u76F4_u8857_u4E91_u541E_u9762_u4E16_u5BB6" class="headerlink" title="庙前直街云吞面世家"></a>庙前直街云吞面世家</h3><p>越秀区庙前直街10号(近7中)</p>
<p>推荐美食：蟹子云吞面（汤底很好，不放味精，云吞也好味，面是竹升面）</p>
<h3 id="u5468_u751F_u8BB0_u592A_u7237_u9E21"><a href="#u5468_u751F_u8BB0_u592A_u7237_u9E21" class="headerlink" title="周生记太爷鸡"></a>周生记太爷鸡</h3><p>龟岗大马路江岭东路4号龟岗市场第二档</p>
<p>推荐美食：太爷鸡、猪手</p>
<p>注：是一间烧腊店，在文明路和寺右新马路都有分店，是烟熏味的食品。这是间起码开了二十年的老字号，在北京吃过烤鸭的同学们请注意了，周生记太爷熏鸡在家禽烹饪界绝对不落烤鸭下风。今天你吃了几斤？</p>
<h3 id="u8FBE_u6768_u7096_u54C1"><a href="#u8FBE_u6768_u7096_u54C1" class="headerlink" title="达杨炖品"></a>达杨炖品</h3><p>广州越秀区文明路160号-1(近北京路)</p>
<p>推荐美食：炖鹌鹑、椰子炖乌鸡。不用说，绝对值得一赞</p>
<h3 id="u4E5D_u7237_u9E21"><a href="#u4E5D_u7237_u9E21" class="headerlink" title="九爷鸡"></a>九爷鸡</h3><p>广州越秀区文明路103号(近106车站)</p>
<p>推荐美食：油鸡、叉烧、烧鸭、白切鸡</p>
<h3 id="u8001_u897F_u5173_u6FD1_u7C89"><a href="#u8001_u897F_u5173_u6FD1_u7C89" class="headerlink" title="老西关濑粉"></a>老西关濑粉</h3><p>广州越秀区文明路216号(近中山图书馆)</p>
<p>推荐美食：濑粉、斋烧鹅、水菱角</p>
<h3 id="u534E_u5174_u80A0_u7C89_u5E97"><a href="#u534E_u5174_u80A0_u7C89_u5E97" class="headerlink" title="华兴肠粉店"></a>华兴肠粉店</h3><p>越秀区文明路(中山图书馆对面)</p>
<p>每次路过总看到无数当地人在津津有味的吃着，怎么能够错过。。</p>
<p>推荐美食：煲仔猪肠粉</p>
<h3 id="u80A5_u5988_u725B_u9AA8_u6C64"><a href="#u80A5_u5988_u725B_u9AA8_u6C64" class="headerlink" title="肥妈牛骨汤"></a>肥妈牛骨汤</h3><p>广州市惠福东路中街2号(大佛寺旁)</p>
<p>推荐美食：牛骨汤、大碗粉</p>
<h3 id="u5DE7_u7F8E_u4E91_u541E_u9762"><a href="#u5DE7_u7F8E_u4E91_u541E_u9762" class="headerlink" title="巧美云吞面"></a>巧美云吞面</h3><p>广州越秀区惠福东路401-403号(近起义路)</p>
<p>推荐美食：五宝云吞、五宝云吞面</p>
<p>这家面店据说是老字号！而且是因为蔡澜一直捧场过来吃！所以变得很有名气！</p>
<p>点了最有名的五宝云吞面！里面有五种不同的云吞 ！包括蟹子 鲜虾 鲜虾蟹子 鲍鱼仔 元贝五种！</p>
<p>扎实的馅料再加上打得又细又韧的竹升面！加上熬制很长时间的鲜美汤头！</p>
<h3 id="u98CE_u5473_u9986"><a href="#u98CE_u5473_u9986" class="headerlink" title="风味馆"></a>风味馆</h3><p>广州越秀区越秀南路161号</p>
<p>推荐美食：牛三星汤</p>
<p>门口的小妹妹，多少年如一日。现在终于有空调了。但是，无论它的环境如何，它的出品总是一如既往的有保证。如果没有去过的食客，请记住暗语“大汤”=大碗牛三星汤，“细汤”=小碗牛三星汤，粉只需要点大小就行，因为要去里面拿的，那个时候再选牛腩、牛杂也行。汤点完之后，拿着牌子在座位上面乖乖坐好即可。</p>
<h3 id="u8354_u6E7E_u540D_u98DF_u5BB6"><a href="#u8354_u6E7E_u540D_u98DF_u5BB6" class="headerlink" title="荔湾名食家"></a>荔湾名食家</h3><p>荔湾区第十甫路99号1楼</p>
<p>推荐美食：德昌咸煎饼</p>
<p>这里的拉肠都是传统的布拉肠啊，特别的薄。酱汁做得味道很好，有点甜甜的，让人很有食欲。</p>
<p>为了搭配拉肠，我都会要个艇仔粥或者及第粥。很喜欢把油炸鬼和粥一起吃得感觉，又脆又滑</p>
<h3 id="u5B9D_u534E_u9762_u5E97"><a href="#u5B9D_u534E_u9762_u5E97" class="headerlink" title="宝华面店"></a>宝华面店</h3><p>荔湾区宝华路117号</p>
<p>推荐美食：鲜虾云吞面、金牌猪手面</p>
<p>刚从广州回来的时候，每每到了晚上想吃东西的时候，都有想买张机票飞广州吃宝华面店的冲动，朋友回来嘴上也是常常念叨着要去吃宝华面店，从小到大从来不吃云吞，结果这一习惯被终结了。。。</p>
<h3 id="u897F_u5173_u4EBA_u5BB6"><a href="#u897F_u5173_u4EBA_u5BB6" class="headerlink" title="西关人家"></a>西关人家</h3><p>荔湾区德星路9号荔湾广场南塔4楼(近下九路)</p>
<p>很喜欢这里的老广州味道……好吃,环境是那种不讨厌的热闹.</p>
<h3 id="u4F0D_u6E5B_u8BB0"><a href="#u4F0D_u6E5B_u8BB0" class="headerlink" title="伍湛记"></a>伍湛记</h3><p>荔湾区第十甫路99号1楼荔湾名食家内</p>
<p>推荐美食：及第粥、艇仔粥</p>
<h3 id="u6797_u6797_u725B_u6742"><a href="#u6797_u6797_u725B_u6742" class="headerlink" title="林林牛杂"></a>林林牛杂</h3><p>荔湾区第十甫路188号十甫假日酒店1楼</p>
<p>推荐美食：萝卜牛杂</p>
<h3 id="u559C_u54E5_u751F_u869D"><a href="#u559C_u54E5_u751F_u869D" class="headerlink" title="喜哥生蚝"></a>喜哥生蚝</h3><p>地址:越秀区沿江路江湾酒店对面</p>
<p>湛江海鲜日日到，烧烤，砂锅粥令人食指大动，再也不用去天河立交底下吃没品位的大排档了，沙虫刺身好味道。</p>
<h2 id="u98CE_u5473"><a href="#u98CE_u5473" class="headerlink" title="风味"></a>风味</h2><h3 id="u5927_u54E5_u9910_u5385"><a href="#u5927_u54E5_u9910_u5385" class="headerlink" title="大哥餐厅"></a>大哥餐厅</h3><p>地址: 番禺市桥西丽南路</p>
<p>大哥餐厅的出品没人说过有差池，黑色的牛河，公主城堡，相信爱情，每一样东西都值得每日大量开二三十公里车来到番禺市桥就为了吃个茶餐厅的逼格食货们。老板是香港虔诚基督徒，用心做好每个细节，细节做到洗手间都充满港式文化。</p>
<h3 id="u591A_u5229_u6765_u9910_u5385"><a href="#u591A_u5229_u6765_u9910_u5385" class="headerlink" title="多利来餐厅"></a>多利来餐厅</h3><p>地址:越秀区八旗二马路</p>
<p>一间有着几十年历史的餐厅，功夫鲈鱼拿过不少大奖，老板亲自喂养回春鸽，谁吃谁知道，老餐厅自有老味道，来过说的出来的食客已经可以令专业吃货报以赏识表情！</p>
<h3 id="u82AD_u91CC_u9910_u5385"><a href="#u82AD_u91CC_u9910_u5385" class="headerlink" title="芭里餐厅"></a>芭里餐厅</h3><p>地址:番禺沙湾大桥底草河村</p>
<p>在沙湾大桥底下，稍微有点远，但是风情很好，不是农庄又生存在农村中，回头客很多，螃蟹焖飞鸭，榴莲炒饭，出品很具创意。来了不会有人说介绍错。</p>
<h3 id="MIX_u89C5_u98DF_u9910_u5385"><a href="#MIX_u89C5_u98DF_u9910_u5385" class="headerlink" title="MIX觅食餐厅"></a>MIX觅食餐厅</h3><p>地址:白云区万达广场金街出口背后母米粥旁</p>
<p>影视大红人，绝世好老公榜样文章是合伙人之一，MIX混搭风格装修，餐具都有爱情的味道，装修精致有情调，价格公道好味道，松茸鸡煲是口感有追求的食客最爱，香辣虾，香辣鲍鱼更是令好辣一族疯狂，冬天来了，去吃个娘惹羊排煲，最重要现在去不用等位，还门口还有免费停车场，有情人去到绝对有惊艳感觉。一间去签到过，会令资深食家们刮目相看的餐厅。</p>
<h3 id="u9EC4_u6C99_u6C34_u4EA7_u5E02_u573A_u697C_u4E0A_u6D77_u73CD_u822B_u5927_u9152_u697C_u3002"><a href="#u9EC4_u6C99_u6C34_u4EA7_u5E02_u573A_u697C_u4E0A_u6D77_u73CD_u822B_u5927_u9152_u697C_u3002" class="headerlink" title="黄沙水产市场楼上海珍舫大酒楼。"></a>黄沙水产市场楼上海珍舫大酒楼。</h3><p>去过七八次，虽然远了一些，但有空还是专程去吃吃吃。【海珍舫出品三个词可概括：「新鲜，大件，美味」。最最推荐超级无敌虾饺皇，每只有数整粒虾仁，不点多两笼都可惜。招牌珍味冻猪手皮脆肉爽，调出的酱油味道极美，淘饭亦佳。至尊烧麦皇、鲜竹牛肉球肉厚味香，一口咬下去幸福感爆棚。免费停车两小时，还够去黄沙市场逛一圈，拎几斤冰鲜三文鱼返屋企</p>
<h3 id="u4E1C_u5703_u4E2D_u5C71_u5927_u9E3D_u996D"><a href="#u4E1C_u5703_u4E2D_u5C71_u5927_u9E3D_u996D" class="headerlink" title="东圃中山大鸽饭"></a>东圃中山大鸽饭</h3><p>平均一周至少一次。从最早的特价6.8元/只到现在的19.8元/只，我不知为这家老板贡献了多少银纸。盐焗乳鸽优于红烧乳鸽，另外好吃的还包括油渣鸽杂炒菜心，酸辣藕尖，椰子煲鸽，拆骨猪手，以及萝卜条。</p>
<h3 id="u5927_u5934_u867E"><a href="#u5927_u5934_u867E" class="headerlink" title="大头虾"></a>大头虾</h3><p>广州越秀区西湖路63号光明广场8楼801铺(近北京路)</p>
<p>咖喱虾正宗，香茅豆腐口味独树一帜（豆腐还很嫩很滑喔！），麻油鸡和猪颈肉让口味挑剔的人都脱口称赞~</p>
<h3 id="u5929_u6CB3_u6C47_u6E58_u4E4B_u56ED"><a href="#u5929_u6CB3_u6C47_u6E58_u4E4B_u56ED" class="headerlink" title="天河汇湘之园"></a>天河汇湘之园</h3><p>剁椒鱼头。新鲜热辣，细嫩入味。去了大概十次以上吧。我一个常年呆在长沙的，推荐广州的剁椒鱼头，你知道有多美味了。</p>
<h3 id="u963F_u5F3A_u9178_u83DC_u9C7C"><a href="#u963F_u5F3A_u9178_u83DC_u9C7C" class="headerlink" title="阿强酸菜鱼"></a>阿强酸菜鱼</h3><p>广州天河北，阿强酸菜鱼。不夸张地说，88元/条（开发票加10元）的酸菜鱼，两个人可以干完。鱼肉十分之软嫩，酸麻鲜辣拿捏得很有水平，浇饭都算一绝。有预感以后要经常在这儿刷了。</p>
<h3 id="u7EA2_u57CE_u98CE_u5473"><a href="#u7EA2_u57CE_u98CE_u5473" class="headerlink" title="红城风味"></a>红城风味</h3><p>地址：西华路475号（南海中学对面）爱吃辣的童鞋一定会大爱的川菜馆，推荐：酸菜鱼、水煮牛肉、毛血旺、凉面，菜式好吃又正宗，价格都不贵，环境就一般，不适合约会，但适合同学聚会或同事聚餐；人均30元左右</p>
<h3 id="u7C73_u5E02_u8DEF_u6CD7_u5DF7_u7684_u6912_u76D0_u6FD1_u5C3F_u867E"><a href="#u7C73_u5E02_u8DEF_u6CD7_u5DF7_u7684_u6912_u76D0_u6FD1_u5C3F_u867E" class="headerlink" title="米市路泗巷的椒盐濑尿虾"></a>米市路泗巷的椒盐濑尿虾</h3><p>一间好小的大拍档，每款菜式都不会超过20元，除了必点的椒盐濑尿虾外，咸蛋黄炒云南小瓜，豆豉陈皮蒸鉗鱼，炒滑蛋等等都好吃到爆！五点半左右开档，超过六点就会有超多人排队，不会天天开档，所以去之前最好打个电话问下~电话：83372343</p>
<h3 id="u9648_u5BB6_u7960_u7684_u80A5_u4F6C_u7F8E_u98DF"><a href="#u9648_u5BB6_u7960_u7684_u80A5_u4F6C_u7F8E_u98DF" class="headerlink" title="陈家祠的肥佬美食"></a>陈家祠的肥佬美食</h3><p>陈家祠隔离的一条叫龙塘西尾的巷，康王北路公交车站就系巷口，行入巷到尾转右，过两三间屋就到，门牌号系6号，88259926  ，这个比米市路贵，但虾全都大只的，而且新鲜，至于味道就各有千秋，有盐水同椒盐两种味，无膏35元一例一斤左右，有膏就45元。其他菜色20左右，椒盐多春鱼，白灼墨鱼仔青口等都份大味道好。环境一般，折叠木台+矮凳，不过这样又有另一番风味~</p>
<h3 id="u548C_u98CE_u4E2D_u534E_u5C45_u9152_u5C4B"><a href="#u548C_u98CE_u4E2D_u534E_u5C45_u9152_u5C4B" class="headerlink" title="和风中华居酒屋"></a>和风中华居酒屋</h3><p>盘福路转入解放北右手边  这里的牛肉火锅很好味，豆腐很滑很香，入口即溶，牛肉煮得不老，刚刚好，分量足卖相好，价钱又不贵（25元）。另一推荐海鲜饼（25元）份量大，虽然没有海鲜在里面，但是铺了很多木鱼，很香口很满足。中午有特价便当送汤，15元左右，份量很足，味道不过不失</p>
<h3 id="u73AF_u7403_u6E14_u592B"><a href="#u73AF_u7403_u6E14_u592B" class="headerlink" title="环球渔夫"></a>环球渔夫</h3><p>地址:番禺美丽华酒店一楼展云轩</p>
<p>要吃到最新鲜的世界海产，这里有齐，刺身一绝，不是日本餐厅更多单纯海鲜的品味，还有两斤重的南非鲍鱼，绝对是土豪的隐蔽好去处，并且不失一个嘴刁食客的身份！</p>
<h3 id="u4E03_u7EAC_u7F18_u519C_u5E84"><a href="#u4E03_u7EAC_u7F18_u519C_u5E84" class="headerlink" title="七纬缘农庄"></a>七纬缘农庄</h3><p>地址：番禺金山大道</p>
<p>一大片的火龙果庄园，红肉的火龙果还可以做出各种菜式，农庄里有吃火龙果大的猪，鸡，鱼，周末一家大小可以耗一天的好去处，钓鱼，采摘，赶猪，吃全生态农庄菜，吃得放心，玩得开心！</p>
<h2 id="u7CA4_u83DC"><a href="#u7CA4_u83DC" class="headerlink" title="粤菜"></a>粤菜</h2><h3 id="u4EBA_u6C11_u4E2D_u8DEF_u51E4_u53A8_u987A_u5FB7_u79C1_u623F_u83DC"><a href="#u4EBA_u6C11_u4E2D_u8DEF_u51E4_u53A8_u987A_u5FB7_u79C1_u623F_u83DC" class="headerlink" title="人民中路凤厨顺德私房菜"></a>人民中路凤厨顺德私房菜</h3><p>这家的大师傅水准还是不错的。招牌凤厨鸡，鱼腐竹笙鱼肚浸时蔬，豉汁蒸大鱼头，煎焗骨腩，（以我偏淡的口味来说）除了稍咸半分外，基本无可挑剔。饭后来份双皮奶，边饮茶边吃南乳花生， 甚是惬意。说到美食，在广州的满意度确是要超过绝大多数城市。</p>
<h3 id="u4E91_u9999_u9152_u697C"><a href="#u4E91_u9999_u9152_u697C" class="headerlink" title="云香酒楼"></a>云香酒楼</h3><p>推荐理由：百年老字号，食客里好多都是公公婆婆，颇有几分怀旧的调调。点心款式不太多，但胜在分量超足，味道也可以;粤菜都是家常口味，价格几实惠，有几个特价菜好好味。环境就不咋样了，挺邋遢挺破旧的。</p>
<p>推荐菜式：冰花鸡蛋散，蛋挞，烧鹅，萝卜包，葱头鸡</p>
<p>人均消费：￥30</p>
<p>联系电话：020-37638057 020-83818661</p>
<p>详细地址：越秀区东华东路342号(近东川路)</p>
<h3 id="u798F_u65B0_u660C_u83DC_u9986"><a href="#u798F_u65B0_u660C_u83DC_u9986" class="headerlink" title="福新昌菜馆"></a>福新昌菜馆</h3><p>推荐理由：好火爆的一家粤菜馆，从没见过那么多桌子排得那么密集，还有好多人在等位。菜肴大众化，味道几靓，陈皮骨、牛肉丸尤其值得推荐，埋单更是便到出乎意料。环境就认真麻麻，岂是吵字可以形容。</p>
<p>推荐菜式：黄鳝煲，凉伴鱼皮，冰镇鳝片，陈皮骨，隔水蒸鸡，金牌甜薄撑，沙地金针浸牛滑，牛肉丸，煎面，乳鸽，烧鹅，香煎咸鲈鱼</p>
<p>人均消费：￥30-50</p>
<p>联系电话：020-84476298</p>
<p>详细地址：海珠区基立北街2号</p>
<h3 id="u5BCC_u4E34_u98DF_u5E9C"><a href="#u5BCC_u4E34_u98DF_u5E9C" class="headerlink" title="富临食府"></a>富临食府</h3><p>推荐理由：惠福东路上的一家“超正又实惠”的酒楼，是老饕街坊的聚脚点，位置很隐蔽，店面浅窄，位于一排灯饰店的中间。虽然环境一般，店面的装修和气氛，却有着毫不造作的朴实。而且出品好抵，碟头大，味道也好，招牌菜是脆皮猪手，简直是人间美味;饭后送的红豆沙也绝对比得起糖水铺的出品，服务态度又好，一家人吃饭就最 适合了。</p>
<p>推荐菜式：脆皮猪手，白灼牛肉，沙拉猪扒，德国咸猪手，葱油鸡，上汤苋菜，新味骨，姜酒鸡什煮鸡蛋，白切鸡，冰镇鳝片，丹青黄金条，叉烧，红烧乳鸽，水晶牛尾，煎面，红豆沙</p>
<p>人均消费：￥30-50</p>
<p>联系电话：020-83302789</p>
<p>详细地址：越秀区惠福东路417号(近教育路)</p>
<h3 id="u5411_u7FA4_u996D_u5E97_28_u9F99_u6D25_u8DEF_u603B_u5E97_29"><a href="#u5411_u7FA4_u996D_u5E97_28_u9F99_u6D25_u8DEF_u603B_u5E97_29" class="headerlink" title="向群饭店(龙津路总店)"></a>向群饭店(龙津路总店)</h3><p>推荐理由：向群的总店，出品很家常的住家菜式，而且价格普遍都非常实惠，位少人多，必需预先订位。推荐招牌豉油王葱油淋鸡，用料是“走地鸡”，皮爽脆，肉质嫩滑，味道很有家的感觉;其实要品尝有广州特色的粤菜，要在这些老字号的餐厅才算是正宗的。</p>
<p>推荐菜式：葱油淋鸡，酿炸面，捞肚尖，豉油皇鹅肠，肥叉鸡杂炒菜心，葱头鸡，煎鹅，果汁猪扒，酿油炸鬼，鲈鱼丁，让炸面，干炒牛河</p>
<p>人均消费：￥30-50</p>
<p>联系电话：020-81885146</p>
<p>详细地址：越秀区龙津东路853-857号</p>
<h3 id="u5229_u534E_u996D_u5E97"><a href="#u5229_u534E_u996D_u5E97" class="headerlink" title="利华饭店"></a>利华饭店</h3><p>推荐理由：老字号粤菜馆，出品地道的粤式风味，招牌陈皮骨、七彩捞蟮片、红葱头淋鸡、豉油鹅肠等，味道的确正宗，分量够大，价格又实惠，一家大小聚餐就最适合，老字号的环境与服务，自然就一般了，人多拥挤且嘈杂，但架不住出品的味道好，每天饭点都很多人排队等号;想一饱口福，又不太计较环境的，可以来试试。</p>
<p>推荐菜式：陈皮骨，红葱头鸡，鹅肠，七彩捞蟮片，冰浸鳝片，豉油皇鹅肠，茶叶虾，冰浸芥兰，羊肉煲，铁板烧汁鲈鱼，牛肉丸，捞起蟮片，咸蛋黄炒蟹，冬瓜盅。</p>
<p>人均消费：￥30-50</p>
<p>联系电话：020-83308399</p>
<p>详细地址：越秀区德政中路329号</p>
<h3 id="u5357_u56ED_u9152_u5BB6"><a href="#u5357_u56ED_u9152_u5BB6" class="headerlink" title="南园酒家"></a>南园酒家</h3><p>推荐理由：远近闻名的老字号餐厅，是广州四大园林酒家之一，环境气派，有种古色古香的岭南园林风格，以潮菜粤点而闻名;点心即点即蒸，味道正宗，尤其推荐虾饺;粤菜也做得精致，味道一流，价格合理，适合百姓人家常去，人非常多，去之前一定要先订位;也很适合宴请、婚宴等讲求排场的喜庆日子。</p>
<p>推荐菜式：佛跳墙，潮州烧雁鹅，潮州豆酱鸡，潮州扒大翅，护国菜，海南椰子盅，琼山豆腐，竹园椰奶鸡，三色马蹄糕，椰酱蛋角，生炸象生虾，虾饺，蛋挞，XO酱萝卜糕，顺德猪杂粥，奶皇包，流沙包，叉烧酥，拉肠，春卷，烧鹅</p>
<p>人均消费：￥50-100</p>
<p>联系电话：020-84448380</p>
<p>详细地址：海珠区前进路142号</p>
<h3 id="u9676_u9676_u5C45_u9152_u5BB6"><a href="#u9676_u9676_u5C45_u9152_u5BB6" class="headerlink" title="陶陶居酒家"></a>陶陶居酒家</h3><p>推荐理由：广州剩余为数不多的百年老字号，是广州市最著名最古老的大型酒家，创建于清光绪六年(1880年)，装修具广州风情，充满西关特色，是体验老广州生活的首选之地，也是外地人品尝地道广州美食的绝佳选择;出品的点心，可谓便宜实在，口味地道，还有各式粤式名菜，服务到位，人就非常多，所以经常看到有人等位。</p>
<p>推荐菜式：猪脑鱼羹、五彩鲜虾仁、姜葱炒肉蟹、西湖菊花鱼、手撕盐焗鸡、片皮挂炉鸭、云腿爽肚、雪里藏珍</p>
<p>人均消费：￥30-50</p>
<p>联系电话：020-81389632 020-81396111</p>
<p>详细地址：荔湾区第十甫路20号</p>
<h3 id="u53CB_u8054_u83DC_u9986"><a href="#u53CB_u8054_u83DC_u9986" class="headerlink" title="友联菜馆"></a>友联菜馆</h3><p>推荐理由：以吃清平鸡为特色的老字号粤菜。大排挡式，环境可以说非常的一般。鸡很不错， 也不贵，20多就半只，还是正宗的清平鸡，其他菜比如蒸肉丸都非常好吃，各类粤菜都很好，性价比超高!喜欢吃鸡的朋友不能错过，但喜欢环境舒服的，就不太合适了。原清平饭店以“友联菜馆”的名字从现江湖!饭店继续由原清平饭店“清平鸡”唯一传人及原清平饭店的大厨主理。经实践证明，主打的清平鸡果真是皮爽肉滑。</p>
<p>推荐菜式：清平鸡，猪手，鸡杂炒菜心，生炒骨，生炒菜心，葱茜捞肚尖，鱼肠煎蛋，桂花扎，道窖肉丸，钵仔鸡红。</p>
<p>人均消费：￥30-50</p>
<p>联系电话：020-81876751</p>
<p>详细地址：荔湾区杉木栏路163号</p>
<h2 id="u751C_u54C1"><a href="#u751C_u54C1" class="headerlink" title="甜品"></a>甜品</h2><h3 id="u73AB_u7470_u751C_u54C1_u5E97"><a href="#u73AB_u7470_u751C_u54C1_u5E97" class="headerlink" title="玫瑰甜品店"></a>玫瑰甜品店</h3><p>越秀区文明路218号(中山图书馆斜对面)  招牌芒果西米露，粒粒西米晶莹通透，好浓的芒果味；杏仁豆腐香甜爽滑，一个实在是爽啊</p>
<h3 id="GANSO"><a href="#GANSO" class="headerlink" title="GANSO"></a>GANSO</h3><p>彩虹桥店  电话：020-81369696  地址：荔湾区荔湾路100号新大新百货一楼</p>
<p>江燕店  电话：020-34368119  地址：海珠区江燕路245号</p>
<p>说实话我不喜欢吃太甜的东西，不过这个好可爱，38元6个，冰淇淋口味一个10元，店里还有其他日本点心，感觉嘛，有点小贵，喜欢倒是可以试一下</p>
<h3 id="u7F8E_u5229_u6743_u51B0_u5BA4"><a href="#u7F8E_u5229_u6743_u51B0_u5BA4" class="headerlink" title="美利权冰室"></a>美利权冰室</h3><p>越秀区北京路344号太平馆1楼  83197141  广州老字号的传统冰室，装修有点西餐厅的风格，出品的雪糕还保持着传统的手工做法，便宜又好吃;而特色的硬雪糕，在广州更几乎是独此一家！心水推荐：棉花雪糕，炸雪糕，椰子雪糕，焗雪山！</p>
<h3 id="u767E_u82B1_u751C_u54C1"><a href="#u767E_u82B1_u751C_u54C1" class="headerlink" title="百花甜品"></a>百花甜品</h3><p>广州越秀区文明路210号(近中山图书馆)</p>
<p>推荐美食：红豆沙、芝麻糊、凤凰奶糊等</p>
<h3 id="u5357_u4FE1"><a href="#u5357_u4FE1" class="headerlink" title="南信"></a>南信</h3><p>推荐美食：双皮奶、牛三星汤</p>
<h3 id="u987A_u8BB0_u51B0_u5BA4"><a href="#u987A_u8BB0_u51B0_u5BA4" class="headerlink" title="顺记冰室"></a>顺记冰室</h3><p>荔湾区宝华路85号</p>
<p>推荐美食：香芒雪糕</p>
<p>这是一个可以找到小时候感觉的冰室。浓浓的椰子雪糕，传统的配方，带着略粗野的口感，一样撩拨人的味蕾。芒果雪糕也不错，芒果肉很多，很香！</p>
<h3 id="u5F00_u8BB0_u7CD6_u6C34"><a href="#u5F00_u8BB0_u7CD6_u6C34" class="headerlink" title="开记糖水"></a>开记糖水</h3><p>荔湾区多宝路219号</p>
<p>推荐美食：绿豆沙、芝麻糊</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里记录一下网上比较出名的广州美食，非常适合『按图索骥』，口味比较个人化。</p>]]>
    
    </summary>
    
      <category term="广州" scheme="http://wdxtub.com/tags/%E5%B9%BF%E5%B7%9E/"/>
    
      <category term="美食" scheme="http://wdxtub.com/tags/%E7%BE%8E%E9%A3%9F/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简易 Shell 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/shell-guide/"/>
    <id>http://wdxtub.com/2016/03/24/shell-guide/</id>
    <published>2016-03-25T00:06:21.000Z</published>
    <updated>2016-03-25T00:07:50.000Z</updated>
    <content type="html"><![CDATA[<p>Shell 可以说是程序员最好的帮手了，这里简单记录一些常用的技巧，包括 shell 脚本与常用的命令。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u672C_u64CD_u4F5C"><a href="#u57FA_u672C_u64CD_u4F5C" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>脚本的第一行叫 shebang，用来告知系统如何执行该脚本 <code>#!/bin/bash</code></li>
<li>输出内容 <code>echo &quot;Hello world!&quot;</code></li>
<li>每一句指令用换行或分号隔开</li>
<li>声明一个变量(不能有空格) <code>VARIABLE=&quot;Some string&quot;</code></li>
<li>使用变量 <code>echo $VARIABLE</code>, <code>echo &quot;$VARIABLE&quot;</code>, <code>echo &#39;$VARIABLE&#39;</code></li>
<li>当赋值和 export 时，或者以其他方式使用变量时，变量名前不加 $</li>
<li>如果要使用变量的值，则要加 $</li>
<li>带你引号不会展开变量</li>
<li>在变量内部进行字符串替换 <code>echo ${VARIABLE/Some/A}</code> 会把 VARIABLE 中首次出现的 Some 替换成 A</li>
<li>内置变量 <code>$?</code>, <code>$$</code>, <code>$#</code>, <code>$@</code></li>
</ul>
<p>例子</p>
<pre><code>echo &quot;Last program return value: $?&quot;
echo &quot;Script&apos;s PID: $$&quot;
echo &quot;Number of arguments: $#&quot;
echo &quot;Scripts arguments: $@&quot;
echo &quot;Scripts arguments separated in different variables: $1 $2&quot;
</code></pre><ul>
<li>读取输入 <code>read NAME</code> 不需要声明新变量</li>
</ul>
<h2 id="u6761_u4EF6_u6D41_u7A0B"><a href="#u6761_u4EF6_u6D41_u7A0B" class="headerlink" title="条件流程"></a>条件流程</h2><p>通常的 IF</p>
<pre><code>if [ $NAME -ne $USER ]
then
    echo &quot;Your name is your username&quot;
else
    echo &quot;Your name isn&apos;t your username&quot;
fi
</code></pre><p>Bash 的 case 语句与 Java 和 C++ 中的 switch 语句类似:</p>
<pre><code>case &quot;$VARIABLE&quot; in
    # 列出需要匹配的字符串
    0) echo &quot;There is a zero.&quot;;;
    1) echo &quot;There is a one.&quot;;;
    *) echo &quot;It is not null.&quot;;;
esac
</code></pre><h2 id="u8868_u8FBE_u5F0F"><a href="#u8868_u8FBE_u5F0F" class="headerlink" title="表达式"></a>表达式</h2><ul>
<li>格式 <code>echo $(( 10 + 5 ))</code></li>
</ul>
<h2 id="u4E0A_u4E0B_u6587_u4F9D_u8D56"><a href="#u4E0A_u4E0B_u6587_u4F9D_u8D56" class="headerlink" title="上下文依赖"></a>上下文依赖</h2><ul>
<li>bash 运行时依赖上下文</li>
<li><code>ls</code> 列出当前目录</li>
<li><code>ls -l</code> 列出文件和目录的详细信息，指令可以带有选项</li>
<li>前一个指令的输出可以当做后一个指令的输入。<code>grep</code> 用来匹配字符串</li>
<li>用下面的指令列出当前目录下所有的 txt 文件 <code>ls -l | grep &quot;\.txt&quot;</code></li>
<li>重定向可以到输出，输入和错误输出。 &gt; 会覆盖已存在的文件，&gt;&gt; 会以累加的方式输出文件中</li>
</ul>
<p>例如</p>
<pre><code>python hello.py &lt; &quot;input.in&quot;
python hello.py &gt; &quot;output.out&quot;
python hellp.py &gt;&gt; &quot;error.err&quot;
</code></pre><ul>
<li>一个指令可用 <code>$()</code> 嵌套在另一个指令内部，如 <code>echo &quot;There are $(ls | wc -l) items here.&quot;</code></li>
</ul>
<h2 id="u5176_u4ED6"><a href="#u5176_u4ED6" class="headerlink" title="其他"></a>其他</h2><p>循环遍历给定的参数序列:变量$VARIABLE 的值会被打印 3 次。注意 ` ` 和 $( ) 等价。seq 返回长度为 3 的数组。</p>
<pre><code>for VARIABLE in `seq 3`
do
    echo &quot;$VARIABLE&quot;
done
</code></pre><p>你也可以使用函数，定义函数：</p>
<pre><code>function foo ()
{
    echo &quot;Arguments work just like script arguments: $@&quot;
    echo &quot;And: $1 $2...&quot;
    echo &quot;This is a function&quot;
    return 0
}
</code></pre><p>更简单的方法</p>
<pre><code>bar ()
{
    echo &quot;Another way to declare functions!&quot;
    return 0
}
</code></pre><p>调用函数</p>
<pre><code>foo &quot;My name is&quot; $NAME
</code></pre><p>有很多有用的指令需要学习:</p>
<pre><code>tail -n 10 file.txt
</code></pre><p>打印 file.txt 的最后 10 行</p>
<pre><code>head -n 10 file.txt
</code></pre><p>打印 file.txt 的前 10 行</p>
<pre><code>sort file.txt
</code></pre><p>将 file.txt 按行排序</p>
<pre><code>uniq -d file.txt
</code></pre><p>报告或忽略重复的行，用选项 -d 打印重复的行</p>
<pre><code>cut -d &apos;,&apos; -f 1 file.txt
</code></pre><p>打印每行中 ‘,’ 之前内容</p>
<h2 id="u57FA_u7840"><a href="#u57FA_u7840" class="headerlink" title="基础"></a>基础</h2><ul>
<li>学习 Bash 的基础知识。具体来说，输入 <code>man bash</code> 并至少全文浏览一遍; 它很简单并且不长。其他的 shell 可能很好用，但 Bash 功能强大且几乎所有情况下都是可用的 （ <em>只</em>学习 zsh，fish 或其他的 shell 的话，在你自己的电脑上会显得很方便，但在很多情况下会限制你，比如当你需要在服务器上工作时）。</li>
<li>学习并掌握至少一个基于文本的编辑器。通常 Vim （<code>vi</code>） 会是你最好的选择，因为在终端里进行随机编辑 Vim 真的毫无敌手，哪怕是 Emacs、某大型 IDE 甚至时下非常流行的编辑器。</li>
<li>学会如何使用 <code>man</code> 命令去阅读文档。学会使用 <code>apropos</code> 去查找文档。了解有些命令并不对应可执行文件，而是Bash内置的，可以使用 <code>help</code> 和 <code>help -d</code> 命令获取帮助信息。</li>
<li>学会使用 <code>&gt;</code> 和 <code>&lt;</code> 来重定向输出和输入，学会使用 <code>|</code> 来重定向管道。明白 <code>&gt;</code> 会覆盖了输出文件而 <code>&gt;&gt;</code> 是在文件未添加。了解标准输出 stdout 和标准错误 stderr。</li>
<li>学会使用通配符 <code>*</code> （或许再算上 <code>?</code> 和 <code>[</code>…<code>]</code>） 和引用以及引用中 <code>&#39;</code> 和 <code>&quot;</code> 的区别。</li>
<li>熟悉 Bash 任务管理工具：<code>&amp;</code>，<strong>ctrl-z</strong>，<strong>ctrl-c</strong>，<code>jobs</code>，<code>fg</code>，<code>bg</code>，<code>kill</code> 等。</li>
<li>了解 <code>ssh</code>，以及学会通过使用 <code>ssh-agent</code>，<code>ssh-add</code> 等命令来实现基本的无密码认证。</li>
<li>学会基本的文件管理：<code>ls</code> 和 <code>ls -l</code> （了解 <code>ls -l</code> 中每一列代表的意义），<code>less</code>，<code>head</code>，<code>tail</code> 和 <code>tail -f</code> （甚至 <code>less +F</code>），<code>ln</code> 和 <code>ln -s</code> （了解硬链接与软链接的区别），<code>chown</code>，<code>chmod</code>，<code>du</code> （硬盘使用情况概述：<code>du -hs *</code>）。 关于文件系统的管理，学习 <code>df</code>，<code>mount</code>，<code>fdisk</code>，<code>mkfs</code>，<code>lsblk</code>。知道 inode 是什么（与 <code>ls -i</code> 和 <code>df -i</code> 等命令相关）。</li>
<li>学习基本的网络管理：<code>ip</code> 或 <code>ifconfig</code>，<code>dig</code>。</li>
<li>熟悉正则表达式，以及 <code>grep</code>／<code>egrep</code> 里不同参数的作用，例如 <code>-i</code>，<code>-o</code>，<code>-v</code>，<code>-A</code>，<code>-B</code> 和 <code>-C</code>，这些参数是值得学习并掌握的。</li>
<li>学会使用 <code>apt-get</code>，<code>yum</code>，<code>dnf</code> 或 <code>pacman</code> （取决于你使用的 Linux 发行版）来查找或安装软件包。并确保你的环境中有 <code>pip</code> 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 <code>pip</code> 来安装会很方便）。</li>
</ul>
<h2 id="u65E5_u5E38_u4F7F_u7528"><a href="#u65E5_u5E38_u4F7F_u7528" class="headerlink" title="日常使用"></a>日常使用</h2><ul>
<li>在 Bash 中，可以使用 <strong>Tab</strong> 自动补全参数，使用 <strong>ctrl-r</strong> 搜索命令行历史（在按下之后，键入便可以搜索，重复按下 <strong>ctrl-r</strong> 会在更多匹配中循环，按下 <strong>Enter</strong> 会执行找到的命令，按下右方向键会将结果放入当前行中，使你可以进行编辑）。</li>
<li>在 Bash 中，可以使用 <strong>ctrl-w</strong> 删除你键入的最后一个单词，使用 <strong>ctrl-u</strong> 删除整行，使用 <strong>alt-b</strong> 和 <strong>alt-f</strong> 以单词为单位移动光标，使用 <strong>ctrl-a</strong> 将光标移至行首，使用 <strong>ctrl-e</strong> 将光标移至行尾，使用 <strong>ctrl-k</strong> 删除光标至行尾的所有内容，使用 <strong>ctrl-l</strong> 清屏。键入 <code>man readline</code> 查看 Bash 中的默认快捷键，内容很多。例如 <strong>alt-.</strong> 循环地移向前一个参数，以及 <strong>alt-*</strong> 展开通配符。</li>
<li>你喜欢的话，可以键入 <code>set -o vi</code> 来使用 vi 风格的快捷键，而 <code>set -o emacs</code> 可以把它改回来。</li>
<li>为了方便地键入长命令，在设置你的编辑器后（例如 <code>export EDITOR=vim</code>），键入 <strong>ctrl-x</strong> <strong>ctrl-e</strong> 会打开一个编辑器来编辑当前命令。在 vi 模式下则键入 <strong>escape-v</strong> 实现相同的功能。</li>
<li>键入 <code>history</code> 查看命令行历史记录。其中有许多缩写，例如 <code>!$</code>（最后键入的参数）和 <code>!!</code>（最后键入的命令），尽管通常被 <strong>ctrl-r</strong> 和 <strong>alt-.</strong> 取代。</li>
<li>回到上一个工作路径：<code>cd -</code></li>
<li>如果你输入命令的时候改变了主意，按下 <strong>alt-#</strong> 来在行首添加 <code>#</code>，或者依次按下 <strong>ctrl-a</strong>， <strong>#</strong>， <strong>enter</strong>。这样做的话，之后你可以很方便的利用命令行历史回到你刚才输入到一半的命令。</li>
<li><p>使用 <code>xargs</code> （ 或 <code>parallel</code>）。他们非常给力。注意到你可以控制每行参数个数（<code>-L</code>）和最大并行数（<code>-P</code>）。如果你不确定它们是否会按你想的那样工作，先使用 <code>xargs echo</code> 查看一下。此外，使用 <code>-I{}</code> 会很方便。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">'*.py'</span> | xargs grep some_<span class="keyword">function</span></span><br><span class="line">cat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>pstree -p</code> 有助于展示进程树。</p>
</li>
<li>使用 <code>pgrep</code> 和 <code>pkill</code> 根据名字查找进程或发送信号（<code>-f</code> 参数通常有用）。</li>
<li>了解你可以发往进程的信号的种类。比如，使用 <code>kill -STOP [pid]</code> 停止一个进程。使用 <code>man 7 signal</code> 查看详细列表。</li>
<li>使用 <code>nohup</code> 或 <code>disown</code> 使一个后台进程持续运行。</li>
<li>使用 <code>netstat -lntp</code> 或 <code>ss -plat</code> 检查哪些进程在监听端口（默认是检查 TCP 端口; 使用参数 <code>-u</code> 检查 UDP 端口）。</li>
<li>有关打开套接字和文件，请参阅 <code>lsof</code>。</li>
<li>使用 <code>uptime</code> 或 <code>w</code> 来查看系统已经运行多长时间。</li>
<li>使用 <code>alias</code> 来创建常用命令的快捷形式。例如：<code>alias ll=&#39;ls -latr&#39;</code> 使你可以方便地执行<code>ls -latr</code>命令。</li>
<li><p>在 Bash 脚本中，使用 <code>set -x</code> 去调试输出，尽可能的使用严格模式，使用 <code>set -e</code> 令脚本在发生错误时退出而不是继续运行，使用 <code>set -u</code> 来检查是否使用了未赋值的变量，使用 <code>set -o pipefail</code> 严谨地对待错误（尽管问题可能很微妙）。当牵扯到很多脚本时，使用 <code>trap</code>。一个好的习惯是在脚本文件开头这样写，这会使它检测一些错误，并在错误发生时中断程序并输出信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -euo pipefail</span><br><span class="line"><span class="built_in">trap</span> <span class="string">"echo 'error: Script failed: see failed command above'"</span> ERR</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Bash 脚本中，子 shell（使用括号 <code>(...)</code>）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># do something in current dir</span></span><br><span class="line">(<span class="built_in">cd</span> /some/other/dir &amp;&amp; other-command)</span><br><span class="line"><span class="comment"># continue in original dir</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Bash 中，要注意其中有许多形式的扩展。检查变量是否存在：<code>${name:?error message}</code>。例如，当 Bash 脚本需要一个参数时，可以使用这样的代码 <code>input_file=${1:?usage: $0 input_file}</code>。数学表达式：<code>i=$(( (i + 1) % 5 ))</code>。序列：<code>{1..10}</code>。截断字符串：<code>${var%suffix}</code> 和 <code>${var#prefix}</code>。例如，假设 <code>var=foo.pdf</code>，那么 <code>echo ${var%.pdf}.txt</code> 将输出 <code>foo.txt</code>。</p>
</li>
<li><p>使用括号扩展（<code>{</code>…<code>}</code>）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 <code>mv foo.{txt,pdf} some-dir</code>（同时移动两个文件），<code>cp somefile{,.bak}</code>（会被扩展成 <code>cp somefile somefile.bak</code>）或者 <code>mkdir -p test-{a,b,c}/subtest-{1,2,3}</code>（会被扩展成所有可能的组合，并创建一个目录树）。</p>
</li>
<li><p>通过使用 <code>&lt;(some command)</code> 可以将输出视为文件。例如，对比本地文件 <code>/etc/hosts</code> 和一个远程文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)</span><br></pre></td></tr></table></figure>
</li>
<li><p>了解 Bash 中的“here documents”，例如 <code>cat &lt;&lt;EOF ...</code>。</p>
</li>
<li><p>在 Bash 中，同时重定向标准输出和标准错误，<code>some-command &gt;logfile 2&gt;&amp;1</code>。通常，为了保证命令不会在标准输入里残留一个打开了的文件句柄导致你当前所在的终端无法操作，添加 <code>&lt;/dev/null</code> 是一个好习惯。</p>
</li>
<li><p>使用 <code>man ascii</code> 查看具有十六进制和十进制值的ASCII表。<code>man unicode</code>，<code>man utf-8</code>，以及 <code>man latin1</code> 有助于你去了解通用的编码信息。</p>
</li>
<li><p>使用 <code>screen</code> 或 <a href="https://tmux.github.io/" target="_blank" rel="external"><code>tmux</code></a> 来使用多个屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。另一个轻量级的解决方案是 <code>dtach</code>。</p>
</li>
<li><p>ssh 中，了解如何使用 <code>-L</code> 或 <code>-D</code>（偶尔需要用 <code>-R</code>）去开启隧道是非常有用的，例如当你需要从一台远程服务器上访问 web。</p>
</li>
<li><p>对 ssh 设置做一些小优化可能是很有用的，例如这个 <code>~/.ssh/config</code> 文件包含了防止特定环境下断开连接、压缩数据、多通道等选项：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TCPKeepAlive=<span class="literal">yes</span></span><br><span class="line">ServerAliveInterval=<span class="number">15</span></span><br><span class="line">ServerAliveCountMax=<span class="number">6</span></span><br><span class="line">Compression=<span class="literal">yes</span></span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath <span class="regexp">/tmp/</span>%r@%<span class="attribute">h</span>:%p</span><br><span class="line">ControlPersist <span class="literal">yes</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>部分其他的关于 ssh 的选项是安全敏感且应当小心启用的。例如在可信任的网络中：<code>StrictHostKeyChecking=no</code>，<code>ForwardAgent=yes</code></p>
</li>
<li><p>考虑使用 <a href="https://mosh.mit.edu/" target="_blank" rel="external"><code>mosh</code></a> 作为 ssh 的替代品，它使用 UDP 协议。</p>
</li>
<li><p>获取文件的八进制格式权限，使用类似如下的代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> -c <span class="string">'%A %a %n'</span> /etc/timezone</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <a href="https://github.com/mooz/percol" target="_blank" rel="external"><code>percol</code></a> 或者 <a href="https://github.com/junegunn/fzf" target="_blank" rel="external"><code>fzf</code></a> 可以交互式地从另一个命令输出中选取值。</p>
</li>
<li><p>使用 <code>fpp</code>（<a href="https://github.com/facebook/PathPicker" target="_blank" rel="external">PathPicker</a>）可以与基于另一个命令(例如 <code>git</code>）输出的文件交互。</p>
</li>
<li><p>将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：<br><code>python -m SimpleHTTPServer 7777</code> （使用端口 7777 和 Python 2）或<code>python -m http.server 7777</code> （使用端口 7777 和 Python 3）。</p>
</li>
<li><p>以某种权限执行命令，使用<code>sudo</code>（root 权限）或<code>sudo -u</code>（其他用户）。使用<code>su</code>或者<code>sudo bash</code>来启动一个以对应用户权限运行的 shell。使用<code>su -</code>模拟其他用户的登录。</p>
</li>
</ul>
<h2 id="u6587_u4EF6_u53CA_u6570_u636E_u5904_u7406"><a href="#u6587_u4EF6_u53CA_u6570_u636E_u5904_u7406" class="headerlink" title="文件及数据处理"></a>文件及数据处理</h2><ul>
<li><p>在当前路径下通过文件名定位一个文件，<code>find . -iname &#39;*something*&#39;</code>（或类似的）。在所有路径下通过文件名查找文件，使用 <code>locate something</code> （但请记住 <code>updatedb</code> 可能没有对最近新建的文件建立索引）。</p>
</li>
<li><p>使用 <a href="https://github.com/ggreer/the_silver_searcher" target="_blank" rel="external"><code>ag</code></a> 在源代码或数据文件里检索（比 <code>grep -r</code> 更好）。</p>
</li>
<li><p>将 HTML 转为文本：<code>lynx -dump -stdin</code></p>
</li>
<li><p>Markdown，HTML，以及所有文档格式之间的转换，试试 <a href="http://pandoc.org/" target="_blank" rel="external"><code>pandoc</code></a>。</p>
</li>
<li><p>如果你不得不处理 XML，<code>xmlstarlet</code> 宝刀未老。</p>
</li>
<li><p>使用 <a href="http://stedolan.github.io/jq/" target="_blank" rel="external"><code>jq</code></a> 处理 JSON。</p>
</li>
<li><p>使用 <a href="https://github.com/0k/shyaml" target="_blank" rel="external"><code>shyaml</code></a> 处理 YAML。</p>
</li>
<li><p>Excel 或 CSV 文件的处理，<a href="https://github.com/onyxfish/csvkit" target="_blank" rel="external">csvkit</a> 提供了 <code>in2csv</code>，<code>csvcut</code>，<code>csvjoin</code>，<code>csvgrep</code> 等工具。</p>
</li>
<li><p>关于 Amazon S3，<a href="https://github.com/s3tools/s3cmd" target="_blank" rel="external"><code>s3cmd</code></a> 很方便而 <a href="https://github.com/bloomreach/s4cmd" target="_blank" rel="external"><code>s4cmd</code></a> 更快。Amazon 官方的 <a href="https://github.com/aws/aws-cli" target="_blank" rel="external"><code>aws</code></a> 以及  <a href="https://github.com/donnemartin/saws" target="_blank" rel="external"><code>saws</code></a> 是其他 AWS 相关工作的基础。</p>
</li>
<li><p>了解如何使用 <code>sort</code> 和 <code>uniq</code>，包括 uniq 的 <code>-u</code> 参数和 <code>-d</code> 参数，详见后文单行脚本节。另外可以了解一下 <code>comm</code>。</p>
</li>
<li><p>了解如何使用 <code>cut</code>，<code>paste</code> 和 <code>join</code> 来更改文件。很多人都会使用 <code>cut</code>，但几乎都不会使用 <code>join</code>。</p>
</li>
<li><p>了解如何运用 <code>wc</code> 去计算新行数（<code>-l</code>），字符数（<code>-m</code>），单词数（<code>-w</code>）以及字节数（<code>-c</code>）。</p>
</li>
<li><p>了解如何使用 <code>tee</code> 将标准输入复制到文件甚至标准输出，例如 <code>ls -al | tee file.txt</code>。</p>
</li>
<li><p>了解语言环境对许多命令行工具的微妙影响，包括排序的顺序和性能。大多数 Linux 的安装过程会将 <code>LANG</code> 或其他有关的变量设置为符合本地的设置。意识到当你改变语言环境时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降<em>许多倍</em>。某些情况下（例如集合运算）你可以放心的使用 <code>export LC_ALL=C</code> 来忽略掉国际化并使用基于字节的顺序。</p>
</li>
<li><p>了解 <code>awk</code> 和 <code>sed</code> 关于数据的简单处理的用法。例如，将文本文件中第三列的所有数字求和：<code>awk &#39;{ x += $3 } END { print x }&#39;</code>. 这可能比同等作用的 Python 代码快三倍且代码量少三倍。</p>
</li>
<li><p>替换一个或多个文件中出现的字符串：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pi.bak <span class="operator">-e</span> <span class="string">'s/old-string/new-string/g'</span> my-files-*.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <a href="https://github.com/jlevy/repren" target="_blank" rel="external"><code>repren</code></a> 来批量重命名，或是在多个文件中搜索替换。（有些时候 <code>rename</code> 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Full rename of filenames, directories, and contents foo -&gt; bar:</span></span><br><span class="line">repren --full --preserve-case --from foo --to bar .</span><br><span class="line"><span class="comment"># Recover backup files whatever.bak -&gt; whatever:</span></span><br><span class="line">repren --renames --from <span class="string">'(.*)\.bak'</span> --to <span class="string">'\1'</span> *.bak</span><br><span class="line"><span class="comment"># Same as above, using rename, if available:</span></span><br><span class="line">rename <span class="string">'s/\.bak$//'</span> *.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据 man 页面的描述，<code>rsync</code> 真的是一个快速且非常灵活的文件复制工具。它通常被用于机器间的同步，但在本地也同样有用。它同时也是删除大量文件的<a href="https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html" target="_blank" rel="external">最快方法</a>之一：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>shuf</code> 从一个文件中随机选取多行。</p>
</li>
<li><p>了解 <code>sort</code> 的参数。处理数字方面，使用 <code>-n</code> 或者 <code>-h</code> 来处理可读性数字（例如 <code>du -h</code> 的输出）。明白键的工作原理（<code>-t</code> 和 <code>-k</code>）。例如，注意到你需要 <code>-k1，1</code> 来仅按第一个域来排序，而 <code>-k1</code> 意味着按整行排序。稳定排序（<code>sort -s</code>）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 <code>sort -k1，1 | sort -s -k2，2</code>。</p>
</li>
<li><p>如果你想在 Bash 命令行中写 tab 制表符，按下 <strong>ctrl-v</strong> <strong>[Tab]</strong> 或键入 <code>$&#39;\t&#39;</code> （后者可能更好，因为你可以复制粘贴它）。</p>
</li>
<li><p>标准的源代码对比及合并工具是 <code>diff</code> 和 <code>patch</code>。使用 <code>diffstat</code> 查看变更总览数据。注意到 <code>diff -r</code> 对整个文件夹有效。使用 <code>diff -r tree1 tree2 | diffstat</code> 查看变更总览数据。</p>
</li>
<li><p>对于二进制文件，使用 <code>hd</code> 使其以十六进制显示以及使用 <code>bvi</code> 来编辑二进制。</p>
</li>
<li><p>同样对于二进制文件，<code>strings</code>（包括 <code>grep</code> 等等）允许你查找一些文本。</p>
</li>
<li><p>二进制文件对比（Delta 压缩），使用 <code>xdelta3</code>。</p>
</li>
<li><p>使用 <code>iconv</code> 更改文本编码。而更高级的用法，可以使用 <code>uconv</code>，它支持一些高级的 Unicode 功能。例如，这条命令将所有元音字母转为小写并移除了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uconv <span class="operator">-f</span> utf-<span class="number">8</span> -t utf-<span class="number">8</span> -x <span class="string">'::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; '</span> &lt; input.txt &gt; output.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>拆分文件，查看 <code>split</code>（按大小拆分）和 <code>csplit</code>（按模式拆分）。</p>
</li>
<li><p>用 <a href="http://www.fresse.org/dateutils/" target="_blank" rel="external"><code>dateutils</code></a> 中的 <code>dateadd</code>, <code>datediff</code>, <code>strptime</code> 等工具操作日期和时间表达式。</p>
</li>
<li><p>使用 <code>zless</code>，<code>zmore</code>，<code>zcat</code> 和 <code>zgrep</code> 对压缩过的文件进行操作。</p>
</li>
</ul>
<h2 id="u7CFB_u7EDF_u8C03_u8BD5"><a href="#u7CFB_u7EDF_u8C03_u8BD5" class="headerlink" title="系统调试"></a>系统调试</h2><ul>
<li><p><code>curl</code> 和 <code>curl -I</code> 可以便捷地被应用于 web 调试中，它们的好兄弟 <code>wget</code> 也可以，或者是更潮的 <a href="https://github.com/jakubroztocil/httpie" target="_blank" rel="external"><code>httpie</code></a>。</p>
</li>
<li><p>使用 <code>iostat</code>、<code>netstat</code>、<code>top</code> （<code>htop</code> 更佳）和 <code>dstat</code> 去获取硬盘、cpu 和网络的状态。熟练掌握这些工具可以使你快速的对系统的当前状态有一个大概的认识。</p>
</li>
<li><p>使用 <code>netstat</code> 和 <code>ss</code> 查看网络连接的细节。</p>
</li>
<li><p>若要对系统有一个深度的总体认识，使用 <a href="https://github.com/nicolargo/glances" target="_blank" rel="external"><code>glances</code></a>。它在一个终端窗口中向你提供一些系统级的数据。这对于快速的检查各个子系统非常有帮助。</p>
</li>
<li><p>若要了解内存状态，运行并理解 <code>free</code> 和 <code>vmstat</code> 的输出。尤其注意“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，因此它与空闲内存无关。</p>
</li>
<li><p>Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 <code>kill -3 &lt;pid&gt;</code> 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准输出/日志文件。JDK 中的 <code>jps</code>，<code>jstat</code>，<code>jstack</code>，<code>jmap</code> 很有用。<a href="https://github.com/aragozin/jvm-tools" target="_blank" rel="external">SJK tools</a> 更高级.</p>
</li>
<li><p>使用 <code>mtr</code> 去跟踪路由，用于确定网络问题。</p>
</li>
<li><p>用 <code>ncdu</code> 来查看磁盘使用情况，它比常用的命令，如 <code>du -sh *</code>，更节省时间。</p>
</li>
<li><p>查找正在使用带宽的套接字连接或进程，使用 <code>iftop</code> 或 <code>nethogs</code>。</p>
</li>
<li><p><code>ab</code> 工具（捆绑于 Apache）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 <code>siege</code>。</p>
</li>
<li><p><code>wireshark</code>，<code>tshark</code> 和 <code>ngrep</code> 可用于复杂的网络调试。</p>
</li>
<li><p>了解 <code>strace</code> 和 <code>ltrace</code>。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（<code>-c</code>）和附加到一个运行的进程参数 （<code>-p</code>）。</p>
</li>
<li><p>了解使用 <code>ldd</code> 来检查共享库。</p>
</li>
<li><p>了解如何运用 <code>gdb</code> 连接到一个运行着的进程并获取它的堆栈轨迹。</p>
</li>
<li><p>学会使用 <code>/proc</code>。它在调试正在出现的问题的时候有时会效果惊人。比如：<code>/proc/cpuinfo</code>，<code>/proc/meminfo</code>，<code>/proc/cmdline</code>，<code>/proc/xxx/cwd</code>，<code>/proc/xxx/exe</code>，<code>/proc/xxx/fd/</code>，<code>/proc/xxx/smaps</code>（这里的 <code>xxx</code> 表示进程的 id 或 pid）。</p>
</li>
<li><p>当调试一些之前出现的问题的时候，<code>sar</code> 非常有用。它展示了 cpu、内存以及网络等的历史数据。</p>
</li>
<li><p>关于更深层次的系统分析以及性能分析，看看 <code>stap</code>（<a href="https://sourceware.org/systemtap/wiki" target="_blank" rel="external">SystemTap</a>），<a href="http://en.wikipedia.org/wiki/Perf_(Linux" target="_blank" rel="external"><code>perf</code></a>)，以及<a href="https://github.com/draios/sysdig" target="_blank" rel="external"><code>sysdig</code></a>。</p>
</li>
<li><p>查看你当前使用的系统，使用 <code>uname</code> ， <code>uname -a</code> （Unix／kernel 信息） 或者 <code>lsb_release -a</code> （Linux 发行版信息）。</p>
</li>
<li><p>无论什么东西工作得很欢乐时试试 <code>dmesg</code>（可能是硬件或驱动问题）。</p>
</li>
</ul>
<h2 id="u5355_u884C_u811A_u672C"><a href="#u5355_u884C_u811A_u672C" class="headerlink" title="单行脚本"></a>单行脚本</h2><p>一些命令组合的例子：</p>
<ul>
<li><p>当你需要对文本文件做集合交、并、差运算时，结合使用 <code>sort</code>/<code>uniq</code> 很有帮助。假设 <code>a</code> 与 <code>b</code> 是两内容不同的文件。这种方式效率很高，并且在小文件和上G的文件上都能运用 （<code>sort</code> 不被内存大小约束，尽管在 <code>/tmp</code> 在一个小的根分区上时你可能需要 <code>-T</code> 参数），参阅前文中关于 <code>LC_ALL</code> 和 <code>sort</code> 的 <code>-u</code> 参数的部分。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat a b | sort | uniq &gt; c   <span class="comment"># c is a union b</span></span><br><span class="line">cat a b | sort | uniq <span class="operator">-d</span> &gt; c   <span class="comment"># c is a intersect b</span></span><br><span class="line">cat a b b | sort | uniq -u &gt; c   <span class="comment"># c is set difference a - b</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>grep . *</code>（每行都会附上文件名）或者 <code>head -100 *</code>（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 <code>/sys</code>、<code>/proc</code>、<code>/etc</code>）时特别好用。</p>
</li>
<li><p>计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123; x += $3 &#125; END &#123; print x &#125;'</span> myfile</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你想在文件树上查看大小/日期，这可能看起来像递归版的 <code>ls -l</code> 但比 <code>ls -lR</code> 更易于理解：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -ls</span><br></pre></td></tr></table></figure>
</li>
<li><p>假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 <code>acct_id</code> 参数在URI中。如果你想计算出每个 <code>acct_id</code> 值有多少次请求，使用如下代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | egrep -o <span class="string">'acct_id=[0-9]+'</span> | cut <span class="operator">-d</span>= <span class="operator">-f</span>2 | sort | uniq -c | sort -rn</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">taocl</span></span>() &#123;</span><br><span class="line">  curl <span class="operator">-s</span> https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |</span><br><span class="line">    pandoc <span class="operator">-f</span> markdown -t html |</span><br><span class="line">    xmlstarlet fo --html --dropdtd |</span><br><span class="line">    xmlstarlet sel -t -v <span class="string">"(html/body/ul/li[count(p)&gt;0])[<span class="variable">$RANDOM</span> mod last()+1]"</span> |</span><br><span class="line">    xmlstarlet unesc | fmt -<span class="number">80</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="u51B7_u95E8_u4F46_u6709_u7528"><a href="#u51B7_u95E8_u4F46_u6709_u7528" class="headerlink" title="冷门但有用"></a>冷门但有用</h2><ul>
<li><p><code>expr</code>：计算表达式或正则匹配</p>
</li>
<li><p><code>m4</code>：简单地宏处理器</p>
</li>
<li><p><code>yes</code>：多次打印字符串</p>
</li>
<li><p><code>cal</code>：漂亮的日历</p>
</li>
<li><p><code>env</code>：执行一个命令（脚本文件中很有用）</p>
</li>
<li><p><code>printenv</code>：打印环境变量（调试时或在使用脚本文件时很有用）</p>
</li>
<li><p><code>look</code>：查找以特定字符串开头的单词</p>
</li>
<li><p><code>cut</code>、<code>paste</code> 和 <code>join</code>：数据修改</p>
</li>
<li><p><code>fmt</code>：格式化文本段落</p>
</li>
<li><p><code>pr</code>：将文本格式化成页/列形式</p>
</li>
<li><p><code>fold</code>：包裹文本中的几行</p>
</li>
<li><p><code>column</code>：将文本格式化成多列或表格</p>
</li>
<li><p><code>expand</code> 和 <code>unexpand</code>：制表符与空格之间转换</p>
</li>
<li><p><code>nl</code>：添加行号</p>
</li>
<li><p><code>seq</code>：打印数字</p>
</li>
<li><p><code>bc</code>：计算器</p>
</li>
<li><p><code>factor</code>：分解因数</p>
</li>
<li><p><a href="https://gnupg.org/" target="_blank" rel="external"><code>gpg</code></a>：加密并签名文件</p>
</li>
<li><p><code>toe</code>：terminfo entries 列表</p>
</li>
<li><p><code>nc</code>：网络调试及数据传输</p>
</li>
<li><p><code>socat</code>：套接字代理，与 <code>netcat</code> 类似</p>
</li>
<li><p><a href="https://github.com/mattthias/slurm" target="_blank" rel="external"><code>slurm</code></a>：网络可视化</p>
</li>
<li><p><code>dd</code>：文件或设备间传输数据</p>
</li>
<li><p><code>file</code>：确定文件类型</p>
</li>
<li><p><code>tree</code>：以树的形式显示路径和文件，类似于递归的 <code>ls</code></p>
</li>
<li><p><code>stat</code>：文件信息</p>
</li>
<li><p><code>time</code>：执行命令，并计算执行时间</p>
</li>
<li><p><code>lockfile</code>：使文件只能通过 <code>rm -f</code> 移除</p>
</li>
<li><p><code>logrotate</code>: 切换、压缩以及发送日志文件</p>
</li>
<li><p><code>watch</code>：重复运行同一个命令，展示结果并高亮有更改的部分</p>
</li>
<li><p><code>tac</code>：反向输出文件</p>
</li>
<li><p><code>shuf</code>：文件中随机选取几行</p>
</li>
<li><p><code>comm</code>：一行一行的比较排序过的文件</p>
</li>
<li><p><code>pv</code>：监视通过管道的数据</p>
</li>
<li><p><code>hd</code>，<code>hexdump</code>，<code>xxd</code>，<code>biew</code> 和 <code>bvi</code>：保存或编辑二进制文件</p>
</li>
<li><p><code>strings</code>：从二进制文件中抽取文本</p>
</li>
<li><p><code>tr</code>：转换字母</p>
</li>
<li><p><code>iconv</code> 或 <code>uconv</code>：简易的文件编码</p>
</li>
<li><p><code>split</code> 和 <code>csplit</code>：分割文件</p>
</li>
<li><p><code>sponge</code>：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 <code>grep -v something some-file | sponge some-file</code></p>
</li>
<li><p><code>units</code>：将一种计量单位转换为另一种等效的计量单位（参阅 <code>/usr/share/units/definitions.units</code>）</p>
</li>
<li><p><code>apg</code>：随机生成密码</p>
</li>
<li><p><code>7z</code>：高比例的文件压缩</p>
</li>
<li><p><code>ldd</code>：动态库信息</p>
</li>
<li><p><code>nm</code>：提取 obj 文件中的符号</p>
</li>
<li><p><code>ab</code>：性能分析 web 服务器</p>
</li>
<li><p><code>strace</code>：系统调用调试</p>
</li>
<li><p><code>mtr</code>：更好的网络调试跟踪工具</p>
</li>
<li><p><code>cssh</code>：可视化的并发 shell</p>
</li>
<li><p><code>rsync</code>：通过 ssh 或本地文件系统同步文件和文件夹</p>
</li>
<li><p><code>wireshark</code> 和 <code>tshark</code>：抓包和网络调试工具</p>
</li>
<li><p><code>ngrep</code>：网络层的 grep</p>
</li>
<li><p><code>host</code> 和 <code>dig</code>：DNS 查找</p>
</li>
<li><p><code>lsof</code>：列出当前系统打开文件的工具以及查看端口信息</p>
</li>
<li><p><code>dstat</code>：系统状态查看</p>
</li>
<li><p><a href="https://github.com/nicolargo/glances" target="_blank" rel="external"><code>glances</code></a>：高层次的多子系统总览</p>
</li>
<li><p><code>iostat</code>：硬盘使用状态</p>
</li>
<li><p><code>mpstat</code>: CPU 使用状态</p>
</li>
<li><p><code>vmstat</code>: 内存使用状态</p>
</li>
<li><p><code>htop</code>：top 的加强版</p>
</li>
<li><p><code>last</code>：登入记录</p>
</li>
<li><p><code>w</code>：查看处于登录状态的用户</p>
</li>
<li><p><code>id</code>：用户/组 ID 信息</p>
</li>
<li><p><code>sar</code>：系统历史数据</p>
</li>
<li><p><code>iftop</code> 或 <code>nethogs</code>：套接字及进程的网络利用</p>
</li>
<li><p><code>ss</code>：套接字数据</p>
</li>
<li><p><code>dmesg</code>：引导及系统错误信息</p>
</li>
<li><p><code>sysctl</code>: 在内核运行时动态地查看和修改内核的运行参数</p>
</li>
<li><p><code>hdparm</code>：SATA/ATA 磁盘更改及性能分析</p>
</li>
<li><p><code>lsb_release</code>：Linux 发行版信息</p>
</li>
<li><p><code>lsblk</code>：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息</p>
</li>
<li><p><code>lshw</code>，<code>lscpu</code>，<code>lspci</code>，<code>lsusb</code> 和 <code>dmidecode</code>：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等</p>
</li>
<li><p><code>lsmod</code> 和 <code>modinfo</code>：列出内核模块，并显示其细节</p>
</li>
<li><p><code>fortune</code>，<code>ddate</code> 和 <code>sl</code>：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用”</p>
</li>
</ul>
<h2 id="u4EC5_u9650_MacOS_X__u7CFB_u7EDF"><a href="#u4EC5_u9650_MacOS_X__u7CFB_u7EDF" class="headerlink" title="仅限 MacOS X 系统"></a>仅限 MacOS X 系统</h2><p>以下是<em>仅限于</em> MacOS 系统的技巧</p>
<ul>
<li><p>用 <code>brew</code> （Homebrew）或者 <code>port</code> （MacPorts）进行包管理。这些可以用来在 Mac 系统上安装以上的大多数命令。</p>
</li>
<li><p>用 <code>pbcopy</code> 复制任何命令的输出到桌面应用，用 <code>pbpaste</code> 粘贴输入。</p>
</li>
<li><p>若要在 Mac OS 终端中将 Option 键视为 alt 键（例如在上面介绍的 <strong>alt-b</strong>, <strong>alt-f</strong> 等命令中用到），打开 偏好设置 -&gt; 描述文件 -&gt; 键盘 并勾选“使用 Option 键作为 Meta 键”。</p>
</li>
<li><p>用 <code>open</code> 或者 <code>open -a /Applications/Whatever.app</code> 使用桌面应用打开文件。</p>
</li>
<li><p>Spotlight： 用 <code>mdfind</code> 搜索文件，用 <code>mdls</code> 列出元数据（例如照片的 EXIF 信息）。</p>
</li>
<li><p>注意 MacOS 系统是基于 BSD UNIX 的，许多命令（例如 <code>ps</code>，<code>ls</code>，<code>tail</code>，<code>awk</code>，<code>sed</code>）都和 Linux 中有些微的不同，这些极大的被 System V-style Unix 和 GNU 工具影响。你可以通过标题为 “BSD General Commands Manual” 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 <code>gawk</code> 和 <code>gsed</code> 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 <code>perl</code> ）或者经过仔细的测试。</p>
</li>
<li><p>用 <code>sw_vers</code> 获取 MacOS 的版本信息。</p>
</li>
</ul>
<h2 id="u66F4_u591A_u8D44_u6E90"><a href="#u66F4_u591A_u8D44_u6E90" class="headerlink" title="更多资源"></a>更多资源</h2><ul>
<li><a href="https://github.com/alebcay/awesome-shell" target="_blank" rel="external">awesome-shell</a>：一份精心组织的命令行工具及资源的列表。</li>
<li><a href="https://github.com/herrbischoff/awesome-osx-command-line" target="_blank" rel="external">awesome-osx-command-line</a>：一份针对 Mac OS 命令行的更深入的指南。</li>
<li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/" target="_blank" rel="external">Strict mode</a>：为了编写更好的脚本文件。</li>
<li><a href="https://github.com/koalaman/shellcheck" target="_blank" rel="external">shellcheck</a>：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。</li>
<li><a href="http://www.dwheeler.com/essays/filenames-in-shell.html" target="_blank" rel="external">Filenames and Pathnames in Shell</a>：有关如何在 shell 脚本里正确处理文件名的细枝末节。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Shell 可以说是程序员最好的帮手了，这里简单记录一些常用的技巧，包括 shell 脚本与常用的命令。</p>]]>
    
    </summary>
    
      <category term="命令行" scheme="http://wdxtub.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="技巧" scheme="http://wdxtub.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SVN 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/svn-guide/"/>
    <id>http://wdxtub.com/2016/03/24/svn-guide/</id>
    <published>2016-03-24T20:34:47.000Z</published>
    <updated>2016-03-24T20:35:18.000Z</updated>
    <content type="html"><![CDATA[<p>国内不少云平台都只支持 SVN，所以还是需要了解基本的操作的。和 Git 的思路不大一样，SVN 等于是总-分结构，虽然可能不如 git 灵活，但是还是比较方便的。</p>
<a id="more"></a>
<hr>
<h2 id="u64CD_u4F5C_u6D41_u7A0B"><a href="#u64CD_u4F5C_u6D41_u7A0B" class="headerlink" title="操作流程"></a>操作流程</h2><p>常见的操作如下：</p>
<ul>
<li>checkout（检出）项目</li>
<li>增加文件或目录 — add(增加)，commit(提交)</li>
<li>修改文件或目录 — commit(提交)</li>
<li>删除文件或目录 — commit(提交)</li>
<li>更新文件或目录 — update(更新)</li>
</ul>
<p>其中，checkout只进行一次，以后使用update更新即可。update、commit、add操作根据需要会经常使用。</p>
<p>简单来说可以这样理解：</p>
<ul>
<li>项目中增加了文件或目录，需要先通知服务器要增加，所以首先要 add</li>
<li>然后如果要让服务器知道这些变动，就 commit，具体参加下面的命令</li>
<li>如果要从服务器获取最新的代码，就 update</li>
</ul>
<p>首先checkout出$appname的svn仓库。</p>
<pre><code>$ svn checkout https://svn.sinacloud.com/$appname
</code></pre><p>进入代码目录，创建一个新的子目录 <code>1</code> 作为版本1的代码目录。</p>
<pre><code>$ mkdir 1
</code></pre><p>进入版本1的代码目录，编辑代码并版本1的代码部署到线上。</p>
<pre><code>$ svn add .
$ svn commit -m &quot;make it better&quot;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>国内不少云平台都只支持 SVN，所以还是需要了解基本的操作的。和 Git 的思路不大一样，SVN 等于是总-分结构，虽然可能不如 git 灵活，但是还是比较方便的。</p>]]>
    
    </summary>
    
      <category term="版本控制" scheme="http://wdxtub.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim 基本操作]]></title>
    <link href="http://wdxtub.com/2016/03/24/vim-basic-op/"/>
    <id>http://wdxtub.com/2016/03/24/vim-basic-op/</id>
    <published>2016-03-24T20:23:06.000Z</published>
    <updated>2016-03-24T20:31:14.000Z</updated>
    <content type="html"><![CDATA[<p>虽然我还是喜欢图形化界面编辑器，但是有的时候登录到远程机器，不得不使用 vim 来编辑文件，这里记录下基本的操作。</p>
<a id="more"></a>
<hr>
<ul>
<li><code>i</code> 进入 Insert 模式</li>
<li><code>x</code> 删除当前光标所在的字符</li>
<li><code>:w</code> 存盘(后面可以跟文件名) </li>
<li><code>:q</code> 退出</li>
<li><code>:wq</code> 存盘并退出</li>
<li><code>dd</code> 删除当前行，并存到剪贴板里</li>
<li><code>p</code> 粘贴剪贴板</li>
<li><code>:help &lt;command&gt;</code> 要 :q 退出帮助</li>
</ul>
<p>如何浏览帮助呢？请牢记如下秘籍：</p>
<ul>
<li>移动: 使用光标键，或者用 h 向左，j 向下，k 向上，l 向右。</li>
<li>退出: 使用 :q<enter>。</enter></li>
<li>跳转到一个主题: 将光标置于标签 (例如 usr_01.txt) 上然后输入 CTRL-]。</li>
<li>跳回: 键入 CTRL-T。</li>
<li>翻页：键入 CTRL-F/B</li>
</ul>
<h2 id="u63D2_u5165_u6A21_u5F0F"><a href="#u63D2_u5165_u6A21_u5F0F" class="headerlink" title="插入模式"></a>插入模式</h2><ul>
<li><code>a</code> 在光标后插入</li>
<li><code>o</code> 在当前行后插入一个新行</li>
<li><code>O</code> 在当前行前插入一个新行</li>
<li><code>cw</code> 替换从光标所在位置后到一个单词结尾的字符</li>
</ul>
<h2 id="u79FB_u52A8_u5149_u6807"><a href="#u79FB_u52A8_u5149_u6807" class="headerlink" title="移动光标"></a>移动光标</h2><ul>
<li><code>0</code> 数字零，到行头</li>
<li><code>^</code> 到本行第一个不是blank字符的位置</li>
<li><code>$</code> 到本行行尾</li>
<li><code>g_</code> 到本行最后一个不是blank字符的位置。</li>
<li><code>/pattern</code> 搜索 pattern 的字符串(按n到下一个)</li>
<li><code>w b</code> 词移动</li>
</ul>
<h2 id="u62F7_u8D1D/_u7C98_u8D34"><a href="#u62F7_u8D1D/_u7C98_u8D34" class="headerlink" title="拷贝/粘贴"></a>拷贝/粘贴</h2><ul>
<li><code>p</code> 在当前位置之后粘贴</li>
<li><code>P</code> 在当前位置之前粘贴</li>
<li><code>yy</code> 拷贝当前行，相当于 ddP</li>
</ul>
<h2 id="u64A4_u9500/_u91CD_u505A"><a href="#u64A4_u9500/_u91CD_u505A" class="headerlink" title="撤销/重做"></a>撤销/重做</h2><ul>
<li><code>u</code> undo</li>
<li><code>&lt;C-r&gt;</code> redo</li>
</ul>
<h2 id="u6253_u5F00/_u4FDD_u5B58/_u9000_u51FA/_u6539_u53D8_u6587_u4EF6_28Buffer_29"><a href="#u6253_u5F00/_u4FDD_u5B58/_u9000_u51FA/_u6539_u53D8_u6587_u4EF6_28Buffer_29" class="headerlink" title="打开/保存/退出/改变文件(Buffer)"></a>打开/保存/退出/改变文件(Buffer)</h2><ul>
<li><code>:e &lt;path/to/file&gt;</code> 打开一个文件</li>
<li><code>:w</code> 存盘</li>
<li><code>:saveas &lt;path/to/file&gt;</code> 另存为 <code>&lt;path/to/file&gt;</code></li>
<li><code>:x</code>, <code>ZZ</code> 或 <code>:wq</code> 保存并退出</li>
<li><code>:q!</code> 退出不保存 </li>
<li><code>:qa!</code> 强行退出所有文件。</li>
<li><code>:bn</code> 和 <code>:bp</code> 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。</li>
</ul>
<h2 id="u6280_u5DE7"><a href="#u6280_u5DE7" class="headerlink" title="技巧"></a>技巧</h2><ol>
<li>打开 Vim之后，可以用 <code>:split filename</code>或 <code>:vsplit filename</code> 或 <code>new filename</code> 横向或纵向切割窗口，使用 <code>ctrl + w</code> 可以在个窗口之间跳转，使用 <code>ctrl + 方向键</code> 可以按照方向切换窗口。</li>
<li>用 Vim 打开一个文件，如果我们想实现所有文本行翻转，那么可以执行如下命令：<code>:g/^/m 0</code></li>
<li>在 Vim 中统计文本行数和当前光标的位置，可以使用 <code>ctrl + g</code>，统计字节数，可以使用 <code>g + ctrl + g</code></li>
<li>对文本进行简单排序：用 <code>shift v</code> 选中多行文本，输入 <code>:!sort</code>，看看效果如何</li>
<li>如果你想把当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么依次执行如下命令： 在当前目录下执行：</li>
</ol>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim</span><br><span class="line">:n <span class="keyword">*</span><span class="keyword">*</span>/<span class="keyword">*</span>.java</span><br><span class="line">:argdo %s/apache/eclipse/ge |<span class="string"> update</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然我还是喜欢图形化界面编辑器，但是有的时候登录到远程机器，不得不使用 vim 来编辑文件，这里记录下基本的操作。</p>]]>
    
    </summary>
    
      <category term="编辑器" scheme="http://wdxtub.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gradle 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/gradle-guide/"/>
    <id>http://wdxtub.com/2016/03/24/gradle-guide/</id>
    <published>2016-03-24T20:14:58.000Z</published>
    <updated>2016-03-24T20:18:40.000Z</updated>
    <content type="html"><![CDATA[<p>Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。它提供灵活的通用构建工具，就像ant。同时完美兼容Maven或Ivy仓库</p>
<a id="more"></a>
<hr>
<p>Gradle的特点：</p>
<ul>
<li>一个像Ant一样非常灵活的通用构建工具</li>
<li>一种可切换的，像Maven一样基于约定的构建框架，约定优于配置</li>
<li>强大的对于多工程构建的支持</li>
<li>完全支持现有的Maven和lvy仓库</li>
<li>支持传递性依赖管理，而不需要远程仓库或者是pom.xml和ivy.xml文件</li>
<li>非常适合构建Ant tasks和build</li>
<li>支持Groovy构建脚本</li>
<li>非常丰富的域模型来描述你的构建</li>
</ul>
<p>2009年7月20日发行第一个版本0.7，到现在已经发行了20个大版本，目前最新版本是2.3。从2.0版本开始，Gradle提供了C和C++的支持，使得Gradle的构建、测试和提交工作不仅限于基于JVM的系统。</p>
<p>从2012年6月发布1.0以来，Gradle一直以八周一个新版本的速率稳步升级，从1.0到2.0，Gradle也逐渐成熟。现在越来越多的Java开发者开始使用Gradle进行项目的自动化构建 </p>
<h2 id="u5B89_u88C5Gradle"><a href="#u5B89_u88C5Gradle" class="headerlink" title="安装Gradle"></a>安装Gradle</h2><p>安装一个 Java JDK 或者 JRE. 而且 Java 版本必须至少是 6 以上<br>从 Gradle网站<a href="http://www.gradle.org/downloads下载任意一个已经发布的版本，并解压到任意目录" target="_blank" rel="external">http://www.gradle.org/downloads下载任意一个已经发布的版本，并解压到任意目录</a></p>
<p>添加一个 GRADLE_HOME 环境变量来指明 Gradle 的安装路径<br>添加 GRADLE_HOME/bin 到您的 PATH 环境变量中</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux:</span><br><span class="line">export GRADLE_HOME=&#123;your gradle path&#125;</span><br><span class="line">export PATH=<span class="variable">$PATH</span>:GRADLE_HOME/bin</span><br></pre></td></tr></table></figure>
<h2 id="Gradle_u7684_u57FA_u672C_u7EC4_u6210"><a href="#Gradle_u7684_u57FA_u672C_u7EC4_u6210" class="headerlink" title="Gradle的基本组成"></a>Gradle的基本组成</h2><p>项目(Project) 和 任务(tasks)，Gradle 里的任何东西都是基于这两个基础概念。</p>
<ul>
<li>项目是指我们的构建产物（比如Jar包）或实施产物（将应用程序部署到生产环境）。</li>
<li>任务是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）。</li>
<li>每一个构建都是由一个或多个 projects 构成的，每一个 project 是由一个或多个 tasks 构成的，一个 task是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）</li>
</ul>
<p><img src="/images/14588506801339.jpg" alt=""></p>
<p>一个工程的Build，是由多个Project组成，而一个Project又是由task组成的</p>
<h2 id="Gradle_u6784_u5EFA_u7CFB_u7EDF_u7684_u7EC4_u6210"><a href="#Gradle_u6784_u5EFA_u7CFB_u7EDF_u7684_u7EC4_u6210" class="headerlink" title="Gradle构建系统的组成"></a>Gradle构建系统的组成</h2><p>任何一个构建系统都是由多个构建文件组成，如Ant是由build.xml组成，Maven是由pom.xml组成，Make是由makefile组成。这些构建脚本定义了一系列的规则来指定项目编译流程。</p>
<p>Gradle的构建系统是由以下几个文件组成</p>
<ul>
<li>build.gradle 我们称这个文件为一个构建脚本，这个脚本定义了一个模块和编译用的tasks，它一般是放在项目的模块中，也可以放在项目的根目录用来作为编译结构全局设置，它是必须的</li>
<li>settings.gradle 它描述了哪一个模块需要参与构建。每一个多模块的构建都必须在项目结构的根目录中加入这个设置文件，它也是必须的</li>
<li>gradle.properties 用来配置构建属性，这个不是必须的</li>
</ul>
<p>settings.gradle和gradle.properties的用法都十分简单，这里就不再多加说明，后面会给出示例，看示例就能明白其用法，现在主要对build.gradle的进行说明。</p>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>Gradle是基于Groovy语言的构建系统（这里并不会详细解释Groovy语法的使用，有需要请参考Groovy的官方文档 — <a href="http://groovy-lang.org/single-page-documentation.html" target="_blank" rel="external">Groovy语法</a>），所以在构建脚本中可以使用Groovy语言来执行一些任务。</p>
<p>下面编写一个简单的build.gradle文件，定义一个task来打印hello world，如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> hello &#123; <span class="comment">//先定义一个hello的task</span></span><br><span class="line">    <span class="keyword">doLast</span> &#123; <span class="comment">//实现doLast方法</span></span><br><span class="line">        <span class="keyword">println</span> <span class="string">'Hello world!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在终端中运行gradle hello命令来执行这个task,就会看到以下输入内容：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">gradle</span> <span class="tag">hello</span></span><br><span class="line"><span class="pseudo">:hello</span></span><br><span class="line"><span class="tag">Hello</span> <span class="tag">world</span>!</span><br></pre></td></tr></table></figure>
<p>对于hello这个task，还可以使用更简单的定义方式，如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> hello &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello world!'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;&lt;</code> 就等价于 doLast，doLast 是gradle提供访问task任务的一个API，类似的还有 doFirst，当一个task被执行的时候，可以通过 doFirst 和 doLast 向task中动态添加操作。doFirst 和 doLast 会在task本身被执行之后才会被执行。例如：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> hello &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Earth'</span></span><br><span class="line">&#125;</span><br><span class="line">hello.<span class="keyword">doFirst</span> &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Venus'</span></span><br><span class="line">&#125;</span><br><span class="line">hello.<span class="keyword">doFirst</span> &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Mercury'</span></span><br><span class="line">&#125;</span><br><span class="line">hello.<span class="keyword">doLast</span> &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Mars'</span></span><br><span class="line">&#125;</span><br><span class="line">hello &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Jupiter'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入如下所示：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">Hello</span> Earth</span><br><span class="line">:hello</span><br><span class="line"><span class="label">Hello</span> Mercury</span><br><span class="line"><span class="label">Hello</span> Venus</span><br><span class="line"><span class="label">Hello</span> <span class="keyword">Mars</span><br><span class="line"></span><span class="label">Hello</span> Jupiter</span><br></pre></td></tr></table></figure>
<h2 id="Task_u4F9D_u8D56"><a href="#Task_u4F9D_u8D56" class="headerlink" title="Task依赖"></a>Task依赖</h2><p>上面示例展示了如何编写一个hello world的task，在Gradle中各个task并不是孤立的，它们可以是相互依赖的。要让一个task依赖另外一个task，只需要在task定义时加入 dependsOn: 说明即可，被依赖的task会优先依赖者被执行，例如：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> hello &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello world!'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">task</span> intro(dependsOn: hello) &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">"I'm Gradle"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行gradle intro命令后可以看到以下输出：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="blockquote">&gt; gradle intro</span></span><br><span class="line">Hello world!</span><br><span class="line">I'm Gradle</span><br></pre></td></tr></table></figure>
<h2 id="Gradle_u63D2_u4EF6"><a href="#Gradle_u63D2_u4EF6" class="headerlink" title="Gradle插件"></a>Gradle插件</h2><p>Gradle的设计理念是，所有有用的特性都由Gradle插件提供，例如编写一个Java项目时，需要使用到 Java 插件， 它会将许多任务自动的加入到你项目里。Gradle本身提供了一系列的标准插件，无需多余配置只需要在你的build.gradle文件中加入 <code>apply plugin: &#39;java&#39;</code></p>
<p>这样就可以引入许多task，只需要使用相应的task命令就可以进行项目构建。例如下列一些task:</p>
<ul>
<li>gradle build：编译整个项目，它会执行代码编译、代码检测和单元测试等</li>
<li>gradle assemble：编译并打包你的代码, 但是并不运行代码检测和单元测试</li>
<li>gradle clean：删除 build 生成的目录和所有生成的文件</li>
<li>gradle check：编译并测试你的代码。其它的插件会加入更多的检查步骤，如使用 checkstyle、pmd、findbugs</li>
</ul>
<p>Gradle各个task的关系图：</p>
<p><img src="/images/14588507104558.jpg" alt=""></p>
<p>从上图可以看出，我们通常在执行一个build命令时其实是将一些零散的命令批量执行了，我们也可以根据自己的需求执行其中某一个命令。</p>
<h2 id="u5916_u90E8_u4F9D_u8D56"><a href="#u5916_u90E8_u4F9D_u8D56" class="headerlink" title="外部依赖"></a>外部依赖</h2><p>通常, 一个 Java 项目将有许多外部的依赖, 既指向外部的 JAR 文件. 为了在项目里引用这些 JAR 文件, 你需要告诉 Gradle 去哪里找它们. 在 Gradle 中, JAR 文件位于一个仓库中，这里的仓库类似于 maven 的仓库。</p>
<p>首先，指定maven的仓库地址：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mavenCentral() 是Gradle内置的一个maven仓库地址，加入maven仓库后，就可以直接加入maven仓库中的外部依赖，如果这个外部依赖不存在，gradle会联网去maven仓库中自动下载它，并将它缓存到本地，下次再使用时会优先从本地缓存中查找该依赖。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">group</span>: <span class="string">'commons-collections'</span>, name: <span class="string">'commons-collections'</span>, version: <span class="string">'3.2'</span></span><br><span class="line">    <span class="comment">// 简化写法</span></span><br><span class="line">    <span class="comment">// compile 'commons-collections:commons-collections:3.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用一个外部依赖需要指定使用的group, name 和 version 属性，三者缺一不可。那从哪里得知JAR包的这三个属性呢？我们可以从mvnrepository中搜索到。</p>
<h2 id="u672C_u5730_u4F9D_u8D56"><a href="#u672C_u5730_u4F9D_u8D56" class="headerlink" title="本地依赖"></a>本地依赖</h2><p>Gradle也可以从本地目录中引入JAR包依赖，可以单一引入指定的某一JAR包，也可以引入某目录下所有的JAR包</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> files(<span class="string">'dir/file.jar'</span>)</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: <span class="string">'*.jar'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u9879_u76EE_u4F9D_u8D56"><a href="#u9879_u76EE_u4F9D_u8D56" class="headerlink" title="项目依赖"></a>项目依赖</h2><p>往往一个完整的项目由多个子项目构成。在Gradle中，使用文件settings.gradle定义当前项目的子项目。默认情况下，每个子项目的名称对应着当前操作系统目录下的一个子目录。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="symbol">'sub</span>-project1', <span class="symbol">'sub</span>-project2', <span class="symbol">'sub</span>-project3'</span><br></pre></td></tr></table></figure>
<p>如sub-project1依赖sub-project2，则在sub-project1的build.gradle中加入以下配置即可：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':sub-project2'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u4F9D_u8D56_u5173_u7CFB_u7BA1_u7406"><a href="#u4F9D_u8D56_u5173_u7CFB_u7BA1_u7406" class="headerlink" title="依赖关系管理"></a>依赖关系管理</h2><p>从宏观上说，依赖关系管理分为两个方面。首先，gradle需要知道你要构建或者运行的项目，以便找到它们。我们将这些导入的文件视为项目的依赖。第二，gradle需要构建或者打包你的项目产品。我们将这些导出的文件视为项目的发布。</p>
<p>例如在编译源码时项目需要Hibernate的某些jar包被加入到工程中，而在进行单元测试时还另需要Junit的某些jar被加入。这些被引入的jar包就是项目的依赖。Gradle允许对依赖进行相应的配置，通过不同的配置可以形成不同的依赖效果。例如：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'org.hibernate'</span>, <span class="string">name:</span> <span class="string">'hibernate-core'</span>, <span class="string">version:</span> <span class="string">'3.6.7.Final'</span></span><br><span class="line">    testCompile <span class="string">group:</span> <span class="string">'junit'</span>, <span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目编译时期，junit的jar包不会被引入，只有在单元测试时才会被引入。这样，就可以在不同的场景下加入相应的依赖关系，非常的灵活</p>
<p>Java 插件中定义了许多标准的配置，例如如下：</p>
<ul>
<li>compile: 用来编译项目源代码的依赖</li>
<li>runtime: 在运行时被生成的类使用的依赖。 默认的, 也包含了compile时的依赖。</li>
<li>testCompile: 编译测试代码的依赖。 默认的, 包含runtime时的依赖和compile时的依赖。</li>
<li>testRuntime: 运行测试所需要的依赖。 默认的, 包含上面三个依赖。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。它提供灵活的通用构建工具，就像ant。同时完美兼容Maven或Ivy仓库</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://wdxtub.com/tags/Android/"/>
    
      <category term="包管理" scheme="http://wdxtub.com/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sublime 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/sublime-guide/"/>
    <id>http://wdxtub.com/2016/03/24/sublime-guide/</id>
    <published>2016-03-24T20:08:06.000Z</published>
    <updated>2016-03-24T20:10:02.000Z</updated>
    <content type="html"><![CDATA[<p>Sublime 基本算是我的主力代码编辑器，这里简要介绍一些插件和技巧。</p>
<a id="more"></a>
<hr>
<h2 id="u63D2_u4EF6"><a href="#u63D2_u4EF6" class="headerlink" title="插件"></a>插件</h2><ol>
<li><a href="https://github.com/emmetio/emmet" target="_blank" rel="external">Emmet Git</a>，<a href="http://docs.emmet.io/" target="_blank" rel="external">Document</a>原名为：<code>Zencoding, 快速生成html,css</code>，默认扩展快捷为<code>tab</code>，如果<code>tab</code>按钮损坏，<code>ctrl+e</code>替换。 生成规则在：<code>Preferences -&gt; Browser packages -&gt; Emment -&gt; emment -&gt; snippets.json</code>中修改。<a href="http://www.iteye.com/news/27580" target="_blank" rel="external">@ Emmet 中文版文档</a></li>
<li><a href="https://github.com/titoBouzout/SideBarEnhancements" target="_blank" rel="external">Side Bar</a><code>增强的侧边栏</code></li>
<li><a href="https://github.com/spadgos/sublime-jsdocs" target="_blank" rel="external">Docblockr</a><code>增强js注释</code></li>
<li><a href="https://github.com/wbond/sublime_alignment" target="_blank" rel="external">Alignment</a><code>等号对齐</code>。在<code>Preferences -&gt; package settings -&gt; Alignment -&gt; Settings User</code>添加冒号对齐。<code>{ &quot;align_indent&quot;: false, &quot;alignment_chars&quot;: [&quot;=&quot;, &quot;:&quot;], &quot;alignment_space_chars&quot;: [&quot;=&quot;, &quot;:&quot;] }</code></li>
<li><a href="https://github.com/BoundInCode/AutoFileName" target="_blank" rel="external">AutoFileName</a>: <code>文件路径自动提示</code></li>
<li><a href="https://github.com/akira-cn/sublime-gbk" target="_blank" rel="external">gbk支持 GBK Encoding Support</a></li>
<li><a href="http://www.welefen.com/keymapmanager-add-check-plugins-keymap-conflict-feature.html" target="_blank" rel="external">检测快捷键冲突</a></li>
<li><a href="https://github.com/revolunet/sublimetext-markdown-preview" target="_blank" rel="external">markdown</a> <a href="http://www.tcreator.info/social/experience/markdown-to-pdf.html" target="_blank" rel="external">markdown 转为 pdf</a></li>
<li><a href="https://github.com/SublimeText/LineEndings" target="_blank" rel="external">LineEndings 设置换行符</a></li>
<li><a href="https://sublime.wbond.net/" target="_blank" rel="external">SublimeText插件列表</a></li>
<li><a href="https://github.com/rehorn/sublime-htmlbeautify" target="_blank" rel="external">html美化插件</a></li>
<li><a href="http://www.fantxi.com/blog/archives/sublime-template-engine-sublimetmpl/" target="_blank" rel="external">Sublime Text 新建文件的模版插件: SublimeTmpl</a></li>
<li><a href="http://www.cnblogs.com/liu-l/p/3902100.html" target="_blank" rel="external">前端自动化神器LiveReload配合浏览器和less/sass使用方法</a></li>
<li><a href="http://www.cnblogs.com/yili16438/p/3721896.html" target="_blank" rel="external">使用 Sublime Text 2 开发 Unity3D 项目</a></li>
<li><a href="http://www.cnblogs.com/lhb25/p/10-essential-sublime-text-plugins.html" target="_blank" rel="external">全栈开发必备的10款 Sublime Text 插件</a></li>
</ol>
<h2 id="u8BBE_u7F6E"><a href="#u8BBE_u7F6E" class="headerlink" title="设置"></a>设置</h2><ol>
<li>Font 推荐使用 <a href="http://code.google.com/p/uigroupcode/downloads/detail?name=YaHei.Consolas.1.12.zip&amp;can=2&amp;q=#makechanges" target="_blank" rel="external">YaHei.Consolas.1.12.ttf</a>，即为上图中所示字体。</li>
<li>Theme<ul>
<li>code style: 推荐使用这款<a href="http://code.google.com/p/uigroupcode/downloads/detail?name=Monokai.rar&amp;can=2&amp;q=#makechanges" target="_blank" rel="external">marktheme</a></li>
<li><a href="https://gist.github.com/1854721" target="_blank" rel="external">更换sidebar皮肤</a></li>
<li><a href="http://jamiewilson.io/predawn/" target="_blank" rel="external">分享一个sublime 主题 </a></li>
<li><a href="http://colorsublime.com/" target="_blank" rel="external">颜色配色</a></li>
</ul>
</li>
<li>Preferences -&gt; Settings - User</li>
<li><a href="http://baelabs.duapp.com/Sublime/indentation.html" target="_blank" rel="external">定制缩进</a></li>
<li><a href="http://baelabs.duapp.com/Sublime/spell_checking.html" target="_blank" rel="external">拼写检查</a></li>
<li><a href="http://baelabs.duapp.com/Sublime/distraction_free.html" target="_blank" rel="external">全屏模式，自由模式的定制</a></li>
<li><a href="http://www.cnblogs.com/jikey/archive/2013/03/12/2955230.html" target="_blank" rel="external">浏览器中预览</a></li>
<li><a href="http://baelabs.duapp.com/Sublime/settings.html" target="_blank" rel="external">其它配置</a></li>
</ol>
<h2 id="u7279_u6B8A_u64CD_u4F5C"><a href="#u7279_u6B8A_u64CD_u4F5C" class="headerlink" title="特殊操作"></a>特殊操作</h2><ol>
<li>按住 <code>ctrl</code> 键，鼠标单击就是多重选择。</li>
<li><a href="http://baelabs.duapp.com/Sublime/multiple_selection_with_the_keyboard.html" target="_blank" rel="external">键盘多重选择</a></li>
<li>根据选择文本自动添加 ‘, “”,(),[] 匹配。</li>
<li>搜索按钮的功能说明 (<a href="http://hi.baidu.com/chaoxinggsc/item/904a471aa937bc35f6625c42" target="_blank" rel="external">冷风贡献</a>)</li>
</ol>
<h2 id="u5FEB_u6377_u952E"><a href="#u5FEB_u6377_u952E" class="headerlink" title="快捷键"></a>快捷键</h2><ol>
<li>Ctrl+L             选择整行（按住-继续选择下行）</li>
<li>Ctrl+Shift+K(shhift+del)     删除整行，  ctrl + KK 从光标处删之行尾，Ctrl+K Backspace 从光标处删除至行首</li>
<li>Ctrl+Shift+D       复制光标所在整行，插入在该行之前</li>
<li>Ctrl+D             选词 （按住-继续选择下个相同的字符串，再按，可跳到相应的方法定义处</li>
<li>Ctrl+Shift+M       选择括号内的内容（按住-继续选择父括号）</li>
<li>Ctrl+/             注释整行（如已选择内容，同“Ctrl+Shift+/”效果）</li>
<li>Ctrl + alt + /     取消注释</li>
<li>Ctrl+Shift+UP      与上行互换  ctrl + shift + up: 列模式编辑</li>
<li>Ctrl + R           跳转当前页的目标方法</li>
<li>Ctrl+K + U        大写</li>
<li>Ctrl+K + L        小写</li>
<li>鼠标中间           列模式编辑</li>
<li>Ctrl+Shift+[]     代码折叠</li>
<li>ctrl+k ctrl+1:    折叠所有代码</li>
<li>Ctrl + K,B        打开侧边栏</li>
<li>ctrl + 回车：　　   光标后插入行，　Ctrl+Shift+Enter 光标前插入行</li>
<li>ctrl + m:         匹配括号</li>
<li>vim mode下        查找上一个下一个的快捷键是 是* #</li>
<li>ctrl +z, y:       撤销，恢复撤销</li>
<li>alt + .:          闭合当前标签</li>
<li>Ctrl+F2:          设置书签</li>
<li>F2:               下一个书签</li>
<li>Shift+F2:         上一个书签</li>
<li>ctrl + p:         即时的文件切换</li>
<li>ctrl + shift + a: 选择标签内的内容</li>
<li>ctrl + 单击：      多行随意位置添加光标</li>
<li>alt + F3( mac: ctrl + command + g): 选择页面中所有相同的词</li>
<li>ctrl + F3:        跳转到下一个选中的词</li>
<li>Ctrl+Shift+P Set Syntax:html : 设置文件类型</li>
<li>Shift + 右键:     连续多行光标选中 (by Gary Gauh)</li>
</ol>
<ul>
<li>非官方文档：<a href="https://sublime-text-unofficial-documentation.readthedocs.org/en/latest/" target="_blank" rel="external">Unofficial Document英文版</a></li>
<li><a href="http://baelabs.duapp.com/Sublime_unofficial/" target="_blank" rel="external">Unofficial Document中文版</a></li>
<li>sublime <a href="http://www.feelcss.com/sublime-text-2-settings.html" target="_blank" rel="external">配置详解</a></li>
<li>sublime <a href="http://baelabs.duapp.com/Sublime/" target="_blank" rel="external">其它文档</a></li>
</ul>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>如何删除安装的插件？</p>
<ol>
<li>ctr+shift+P,输入package</li>
<li>查找remove package</li>
<li>输入你要删除的package</li>
<li>回车，OK</li>
</ol>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/martomo/SublimeTextXdebug" target="_blank" rel="external">xdebug调试</a></li>
<li><a href="http://baelabs.duapp.com/Sublime%20text3" target="_blank" rel="external">sublimetext 3.0文档</a></li>
<li><a href="http://www.cnblogs.com/bananaplan/p/Sublime-Text-3-Powerful.html" target="_blank" rel="external">Sublime Text 3 绝对神器</a></li>
<li><a href="http://docs.sublimetext.tw/" target="_blank" rel="external">SublimeText手册-tw</a></li>
<li><a href="http://code-tech.diandian.com/post/2012-11-10/40041273125" target="_blank" rel="external">怎样从直接Github的repository安装Sublime Text插件</a></li>
<li><a href="http://code-tech.diandian.com/post/2012-11-14/40041132753" target="_blank" rel="external">Sublime text2的ThinkPHP插件</a></li>
<li><a href="http://code-tech.diandian.com/post/2012-11-21/40042403501" target="_blank" rel="external">sublime text 左侧菜单美化1</a></li>
<li><a href="http://zh.lucida.me/blog/sublime-text-complete-guide/" target="_blank" rel="external">Sublime Text 全程指南</a></li>
<li><a href="http://www.zhihu.com/question/24896283" target="_blank" rel="external">sublime 有哪些使用技巧</a></li>
<li><a href="http://www.html-js.com/article/The-frontend-tool-Megamix" target="_blank" rel="external">前端工程师手中的Sublime Text</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Sublime 基本算是我的主力代码编辑器，这里简要介绍一些插件和技巧。</p>]]>
    
    </summary>
    
      <category term="编辑器" scheme="http://wdxtub.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[VS Code 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/visual-code-guide/"/>
    <id>http://wdxtub.com/2016/03/24/visual-code-guide/</id>
    <published>2016-03-24T20:03:14.000Z</published>
    <updated>2016-03-24T20:08:33.000Z</updated>
    <content type="html"><![CDATA[<p>Visual Studio 终于把触角伸到了全平台，在加入了插件功能之后，VSC 事实上已经对各种老牌新生编辑器造成了强大的压力，为了紧跟时代脚步，还是要熟悉和了解一下 VSC 的。</p>
<p>这里基本上是官方教程的总结和翻译。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u7840_u77E5_u8BC6"><a href="#u57FA_u7840_u77E5_u8BC6" class="headerlink" title="基础知识"></a>基础知识</h2><p>归根到底 VSC 是一个代码编辑器，所以和其他的代码编辑器一样，基本的该有的甚至不该有的功能，都有。下面会简要介绍一下</p>
<h3 id="u6587_u4EF6_u3001_u6587_u4EF6_u5939_u548C_u9879_u76EE"><a href="#u6587_u4EF6_u3001_u6587_u4EF6_u5939_u548C_u9879_u76EE" class="headerlink" title="文件、文件夹和项目"></a>文件、文件夹和项目</h3><p>随意打开一个文件或者文件夹，就可以进行编辑，如果文件夹里包含 <code>package.json</code>, <code>project.json</code>, <code>tsconfig.json</code> 或者其他 ASP.NET 5 的 sln 文件，VSC 可以自动读取项目结构并且高亮显示出来</p>
<h3 id="u57FA_u7840_u89C6_u56FE"><a href="#u57FA_u7840_u89C6_u56FE" class="headerlink" title="基础视图"></a>基础视图</h3><p>Editor, Side Bar, Status Bar 和 View Bar 这里基本的标配都有</p>
<blockquote>
<p>Tip: 可以用 command+B 来切换显示侧边栏</p>
</blockquote>
<h3 id="u591A_u680F_u7F16_u8F91"><a href="#u591A_u680F_u7F16_u8F91" class="headerlink" title="多栏编辑"></a>多栏编辑</h3><p>只需要记住一些快捷键即可</p>
<ul>
<li>command+\ 分成多栏</li>
<li>command+1/2/3 通过数字键选择当前激活的文件</li>
<li>可以自由调整和重新排序</li>
</ul>
<h3 id="u6587_u4EF6_u6D4F_u89C8_u5668"><a href="#u6587_u4EF6_u6D4F_u89C8_u5668" class="headerlink" title="文件浏览器"></a>文件浏览器</h3><p>文件浏览器中可以进行基本的文件操作，对着文件点击右键即可，甚至还可以直接在 terminal 中打开！</p>
<blockquote>
<p>Tip: command+p 可以通过文件名快速查找并打开文件</p>
</blockquote>
<p>默认来说，VSC 会排除显示一些文件夹(例如 <code>.git</code>)，当然也可以在 user setting 中配置 <code>files.exclude</code> 来自定义排除规则（是支持通配符的如<code>\*.meta</code>）</p>
<h3 id="u5DF2_u6253_u5F00_u6587_u4EF6"><a href="#u5DF2_u6253_u5F00_u6587_u4EF6" class="headerlink" title="已打开文件"></a>已打开文件</h3><p>已打开文件会在边栏的上方显示，如果需要自定义，可以设置下面一些属性：</p>
<ul>
<li><code>explorer.workingFiles.maxVisible</code></li>
<li><code>explorer.workingFiles.dynamicHeight</code></li>
</ul>
<h3 id="u8DE8_u6587_u4EF6_u641C_u7D22"><a href="#u8DE8_u6587_u4EF6_u641C_u7D22" class="headerlink" title="跨文件搜索"></a>跨文件搜索</h3><p>快捷键 shift+command+f，支持全文搜索，中文英文都可以！简直爆炸！而且还支持正则表达式！</p>
<p>如果需要更高级的搜索，可以使用 shift+command+j</p>
<p>下面列出基本的正则表示：</p>
<ul>
<li><code>*</code> to match one or more characters in a path segment</li>
<li><code>?</code> to match on one character in a path segment</li>
<li><code>**</code> to match any number of path segments ,including none</li>
<li><code>{}</code> to group conditions (e.g. <code>{**/*.html,**/*.txt}</code> matches all html and txt files)</li>
<li><code>[]</code> to declare a range of characters to match (e.g., example.[0-9] to match on example.0, example.1, …</li>
</ul>
<p>注意可以自定义搜索范围，在设置中设定</p>
<ul>
<li><code>files.exclude</code></li>
<li><code>search.exclude</code></li>
</ul>
<h3 id="u547D_u4EE4_u677F"><a href="#u547D_u4EE4_u677F" class="headerlink" title="命令板"></a>命令板</h3><p>按 F1 就可以调出 Command Palette，这里可以快速输入各种命令，一些基本技巧</p>
<ul>
<li>command+p: 通过文件名找文件</li>
<li>control+tab: 可以循环切换之前打开的文件</li>
<li>shift+command+o: 可以导航到文件中的指定符号</li>
<li>control+g: 导航到指定行</li>
</ul>
<p>在 Command Palette 中输入 <code>?</code> 可以显示当前可用的操作</p>
<h3 id="u6587_u4EF6_u7F16_u7801_u652F_u6301"><a href="#u6587_u4EF6_u7F16_u7801_u652F_u6301" class="headerlink" title="文件编码支持"></a>文件编码支持</h3><p>在 <code>files.encoding</code> 设置中设置具体的编码，可以在 右下角的状态栏中看到。点击状态栏中的编码可以用指定编码打开或者保存文件(还需要选择具体的编码格式)</p>
<h2 id="u7F16_u8F91_u529F_u80FD"><a href="#u7F16_u8F91_u529F_u80FD" class="headerlink" title="编辑功能"></a>编辑功能</h2><p>理论上来说，基本上该有的功能都有，这里只列出一些超赞的功能</p>
<h3 id="u62EC_u53F7_u5339_u914D"><a href="#u62EC_u53F7_u5339_u914D" class="headerlink" title="括号匹配"></a>括号匹配</h3><p>括号会自动高亮匹配，可以用 <code>shift+command+]</code> 来跳到匹配的括号位置</p>
<h3 id="u591A_u884C_u9009_u62E9"><a href="#u591A_u884C_u9009_u62E9" class="headerlink" title="多行选择"></a>多行选择</h3><p>利用 <code>alt+click</code> 来激活多行选择，每个光标都是独立的，另一个比较方便添加光标的方式是 <code>option+command+↓</code> 和 <code>option+command+↑</code>，这会在正下方或上方添加光标</p>
<p><code>command+D</code> 选择当前单词，或者是当前单词下一次出现的位置，<code>command+K command+D</code> 会选择单词最后一次出现的位置</p>
<p>其他一些添加光标的方式是</p>
<ul>
<li><code>shift+command+l</code>: 在单词下一次出现处添加光标</li>
<li><code>command+f2</code>: 在下一个单词前添加光标</li>
</ul>
<h3 id="u7F29_u8FDB/_u6269_u5C55_u9009_u62E9"><a href="#u7F29_u8FDB/_u6269_u5C55_u9009_u62E9" class="headerlink" title="缩进/扩展选择"></a>缩进/扩展选择</h3><p>选择缩进/扩展，快捷键 <code>control+shift+command+←</code> / <code>control+shift+command+→</code></p>
<p><img src="/images/14588498234616.jpg" alt=""></p>
<h3 id="u667A_u80FD_u63D0_u793A"><a href="#u667A_u80FD_u63D0_u793A" class="headerlink" title="智能提示"></a>智能提示</h3><p>对于 JavaScript, JSON, HTML, CSS, Less, Sass, C#, TypeScript 都有智能提示，也可以用 <code>control+space</code> 手动激活，用 <code>.</code>, <code>tab</code>, <code>Enter</code> 来选择</p>
<p>默认会在输入的时候进行智能提示，即所谓 24x7 IntelliSense，可以在 <code>editor.quickSuggestions</code> 和 <code>editor.suggestOnTriggerCharacters</code> 中进行设置</p>
<h3 id="u53C2_u6570_u63D0_u793A"><a href="#u53C2_u6570_u63D0_u793A" class="headerlink" title="参数提示"></a>参数提示</h3><p>在 JavaScript, TypeScript 和 C# 中，会自动提示函数的参数，可以用方向键进行导航</p>
<h3 id="u4EE3_u7801_u7247_u6BB5"><a href="#u4EE3_u7801_u7247_u6BB5" class="headerlink" title="代码片段"></a>代码片段</h3><p>可以在 <code>User Snippets</code> (<code>File | Preferences</code>) 中设定自己的 snippet</p>
<h3 id="u8DF3_u8F6C_u5230_u5B9A_u4E49"><a href="#u8DF3_u8F6C_u5230_u5B9A_u4E49" class="headerlink" title="跳转到定义"></a>跳转到定义</h3><p>如果语言支持的话，可以用 <code>F12</code> 来跳转到定义。如果按着 <code>ctrl</code> 并把指针放到一个符号上，会有一个简单的预览框。如果需要跳转到定义处可以使用 <code>ctrl+click</code>。如果需要在另外一侧的窗口打开定义，使用 <code>ctrol+alt+click</code></p>
<h2 id="u6269_u5C55"><a href="#u6269_u5C55" class="headerlink" title="扩展"></a>扩展</h2><p>支持扩展是使编辑器更加强大的方法，这里简要介绍一些目前我觉得比较有用的扩展</p>
<h3 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h3><p>安装方法非常简单，用 <code>F1</code> 打开 命令行，然后输入 <code>ext inst</code> 来进行操作</p>
<p><a href="https://marketplace.visualstudio.com/#VSCode" target="_blank" rel="external">MarketPlace</a></p>
<ul>
<li>Markdown Theme Kit</li>
<li>Markdown 预览 <code>command+k v</code></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Visual Studio 终于把触角伸到了全平台，在加入了插件功能之后，VSC 事实上已经对各种老牌新生编辑器造成了强大的压力，为了紧跟时代脚步，还是要熟悉和了解一下 VSC 的。</p>
<p>这里基本上是官方教程的总结和翻译。</p>]]>
    
    </summary>
    
      <category term="编辑器" scheme="http://wdxtub.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python 编程思想]]></title>
    <link href="http://wdxtub.com/2016/03/24/thinking-in-python/"/>
    <id>http://wdxtub.com/2016/03/24/thinking-in-python/</id>
    <published>2016-03-24T19:36:15.000Z</published>
    <updated>2016-03-24T19:52:07.000Z</updated>
    <content type="html"><![CDATA[<p>这里收集了一些深入 python 机制的内容。</p>
<a id="more"></a>
<hr>
<h2 id="u6D45_u8C08_Python__u7684_with__u8BED_u53E5"><a href="#u6D45_u8C08_Python__u7684_with__u8BED_u53E5" class="headerlink" title="浅谈 Python 的 with 语句"></a>浅谈 Python 的 with 语句</h2><p>with 语句是从 Python 2.5 开始引入的一种与异常处理相关的功能（2.5 版本中要通过 <code>from __future__ import with_statement</code> 导入后才可以使用），从 2.6 版本开始缺省可用（参考 What’s new in Python 2.6? 中 with 语句相关部分介绍）。with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。</p>
<h3 id="u672F_u8BED"><a href="#u672F_u8BED" class="headerlink" title="术语"></a>术语</h3><p>要使用 with 语句，首先要明白上下文管理器这一概念。有了上下文管理器，with 语句才能工作。</p>
<p>下面是一组与上下文管理器和with 语句有关的概念。</p>
<p>上下文管理协议（Context Management Protocol）：包含方法 <code>__enter__()</code> 和 <code>__exit__()</code>，支持该协议的对象要实现这两个方法。</p>
<p>上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了<br><code>__enter__()</code> 和 <code>__exit__()</code> 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。</p>
<p>运行时上下文（runtime context）：由上下文管理器创建，通过上下文管理器的 <code>__enter__()</code> 和 <code>__exit__()</code> 方法实现，<code>__enter__()</code> 方法在语句体执行之前进入运行时上下文，<code>__exit__()</code> 在语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。</p>
<p>上下文表达式（Context Expression）：with 语句中跟在关键字 with 之后的表达式，该表达式要返回一个上下文管理器对象。</p>
<p>语句体（with-body）：with 语句包裹起来的代码块，在执行语句体之前会调用上下文管<br>理器的 <code>__enter__()</code> 方法，执行完语句体之后会执行 <code>__exit__()</code> 方法。</p>
<h3 id="u57FA_u672C_u8BED_u6CD5_u548C_u5DE5_u4F5C_u539F_u7406"><a href="#u57FA_u672C_u8BED_u6CD5_u548C_u5DE5_u4F5C_u539F_u7406" class="headerlink" title="基本语法和工作原理"></a>基本语法和工作原理</h3><p>with 语句的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> context_expression [<span class="keyword">as</span> target(s)]:</span><br><span class="line">    <span class="keyword">with</span>-body</span><br></pre></td></tr></table></figure>
<p>这里 context_expression 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 target(s) ，如果指定了 as 子句的话，会将上下文管理器的 <code>__enter__()</code> 方法的返回值赋值给 target(s)。target(s) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）。</p>
<p>Python 对一些内建对象进行改进，加入了对上下文管理器的支持，可以用于 with 语句中，比如可以自动关闭文件、线程锁的自动获取和释放等。假设要对一个文件进行操作，使用 with 语句可以有如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">r'somefileName'</span>) <span class="keyword">as</span> somefile:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> somefile:</span><br><span class="line">        <span class="keyword">print</span> line</span><br><span class="line">        <span class="comment"># ...more code</span></span><br></pre></td></tr></table></figure>
<p>这里使用了 with 语句，不管在处理文件过程中是否发生异常，都能保证 with 语句执行完毕后已经关闭了打开的文件句柄。如果使用传统的 try/finally 范式，则要使用类似如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">somefile = open(<span class="string">r'somefileName'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> somefile:</span><br><span class="line">        <span class="keyword">print</span> line</span><br><span class="line">        <span class="comment"># ...more code</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    somefile.close()</span><br></pre></td></tr></table></figure>
<p>比较起来，使用 with 语句可以减少编码量。已经加入对上下文管理协议支持的还有模块 threading、decimal 等。</p>
<p>PEP 0343 对 with 语句的实现进行了描述。with 语句的执行过程类似如下代码块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">context_manager = context_expression</span><br><span class="line">exit = type(context_manager).__exit__  </span><br><span class="line">value = type(context_manager).__enter__(context_manager)</span><br><span class="line">exc = <span class="keyword">True</span>   <span class="comment"># True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        target = value  <span class="comment"># 如果使用了 as 子句</span></span><br><span class="line">        <span class="keyword">with</span>-body     <span class="comment"># 执行 with-body</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># 执行过程中有异常发生</span></span><br><span class="line">        exc = <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常</span></span><br><span class="line">        <span class="comment"># 由外层代码对异常进行处理</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exit(context_manager, *sys.exc_info()):</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出</span></span><br><span class="line">    <span class="comment"># 或者忽略异常退出</span></span><br><span class="line">    <span class="keyword">if</span> exc:</span><br><span class="line">        exit(context_manager, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line">    <span class="comment"># 缺省返回 None，None 在布尔上下文中看做是 False</span></span><br></pre></td></tr></table></figure>
<ol>
<li>执行 context_expression，生成上下文管理器 context_manager</li>
<li>调用上下文管理器的 <code>__enter__()</code> 方法；如果使用了 as 子句，则将 <code>__enter__()</code> 方法的返回值赋值给 as 子句中的 target(s)</li>
<li>执行语句体 with-body</li>
<li>不管是否执行过程中是否发生了异常，执行上下文管理器的 <code>__exit__()</code> 方法，<code>__exit__()</code> 方法负责执行“清理”工作，如释放资源等。如果执行过程中没有出现异常，或者语句体中执行了语句 break/continue/return，则以 None 作为参数调用 <code>__exit__(None, None, None)</code> ；如果执行过程中出现异常，则使用 sys.exc_info 得到的异常信息为参数调用 <code>__exit__(exc_type, exc_value, exc_traceback)</code></li>
<li>出现异常时，如果 <code>__exit__(type, value, traceback)</code> 返回 False，则会重新抛出异常，让with 之外的语句逻辑来处理异常，这也是通用做法；如果返回 True，则忽略异常，不再对异常进行处理</li>
</ol>
<h2 id="Python_u7A0B_u5E8F_u7684_u6267_u884C_u539F_u7406"><a href="#Python_u7A0B_u5E8F_u7684_u6267_u884C_u539F_u7406" class="headerlink" title="Python程序的执行原理"></a>Python程序的执行原理</h2><p>Python先把代码(.py文件)编译成字节码，交给字节码虚拟机，然后虚拟机一条一条执行字节码指令，从而完成程序的执行。</p>
<p>字节码在Python虚拟机程序里对应的是PyCodeObject对象。</p>
<p>.pyc文件是字节码在磁盘上的表现形式。</p>
<p>PyCodeObject对象的创建时机是模块加载的时候，即import。</p>
<p>Python test.py会对test.py进行编译成字节码并解释执行，但是不会生成test.pyc。</p>
<p>如果test.py加载了其他模块，如import util，Python会对util.py进行编译成字节码，生成util.pyc，然后对字节码解释执行。</p>
<p>如果想生成test.pyc，我们可以使用Python内置模块py_compile来编译。</p>
<p>加载模块时，如果同时存在.py和.pyc，Python会尝试使用.pyc，如果.pyc的编译时间早于.py的修改时间，则重新编译.py并更新.pyc。</p>
<p>Python代码的编译结果就是PyCodeObject对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    int co_argcount;        /* 位置参数个数 */</span><br><span class="line">    int co_nlocals;         /* 局部变量个数 */</span><br><span class="line">    int co_stacksize;       /* 栈大小 */</span><br><span class="line">    int co_flags;   </span><br><span class="line">    PyObject *co_code;      /* 字节码指令序列 */</span><br><span class="line">    PyObject *co_consts;    /* 所有常量集合 */</span><br><span class="line">    PyObject *co_names;     /* 所有符号名称集合 */</span><br><span class="line">    PyObject *co_varnames;  /* 局部变量名称集合 */</span><br><span class="line">    PyObject *co_freevars;  /* 闭包用的的变量名集合 */</span><br><span class="line">    PyObject *co_cellvars;  /* 内部嵌套函数引用的变量名集合 */</span><br><span class="line">    /* The rest doesn’t count <span class="keyword">for</span> hash/cmp */</span><br><span class="line">    PyObject *co_filename;  /* 代码所在文件名 */</span><br><span class="line">    PyObject *co_name;      /* 模块名|函数名|类名 */</span><br><span class="line">    int co_firstlineno;     /* 代码块在文件中的起始行号 */</span><br><span class="line">    PyObject *co_lnotab;    /* 字节码指令和行号的对应关系 */</span><br><span class="line">    void *co_zombieframe;   /* <span class="keyword">for</span> optimization only (see frameobject.c) */</span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>
<p>加载模块时，模块对应的PyCodeObject对象被写入.pyc文件，格式如下：</p>
<p><img src="/images/14588486364401.jpg" alt=""></p>
<h3 id="u5206_u6790_u5B57_u8282_u7801"><a href="#u5206_u6790_u5B57_u8282_u7801" class="headerlink" title="分析字节码"></a>分析字节码</h3><p>Python提供了内置函数compile可以编译Python代码和查看PyCodeObject对象，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = ”hello”</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> s</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure>
<p>在Python交互式shell里编译代码得到PyCodeObject对象:</p>
<p><img src="/images/14588486530973.jpg" alt=""></p>
<p>dir(co)已经列出co的各个域，想查看某个域直接在终端输出即可：</p>
<p><img src="/images/14588486595605.jpg" alt=""></p>
<p>test.py的PyCodeObject</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">co.co_argcount    0</span><br><span class="line">co.co_nlocals     0</span><br><span class="line">co.co_names       (‘s’, ’func’)</span><br><span class="line">co.co_varnames    (‘s’, ’func’)</span><br><span class="line">co.co_consts      (‘hello’, &lt;code object func at 0x2aaeeec57110, file ”test.py”, line 3&gt;, None)</span><br><span class="line">co.co_code        ’d<span class="command">\x</span>00<span class="command">\x</span>00Z<span class="command">\x</span>00<span class="command">\x</span>00d<span class="command">\x</span>01<span class="command">\x</span>00<span class="command">\x</span>84<span class="command">\x</span>00<span class="command">\x</span>00Z<span class="command">\x</span>01<span class="command">\x</span>00e<span class="command">\x</span>01<span class="command">\x</span>00<span class="command">\x</span>83<span class="command">\x</span>00<span class="command">\x</span>00<span class="command">\x</span>01d<span class="command">\x</span>02<span class="command">\x</span>00S’</span><br></pre></td></tr></table></figure>
<p>Python解释器会为函数也生成的字节码PyCodeObject对象，见上面的co_consts[1]</p>
<p>func的PyCodeObject</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_argcount</span>   0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_nlocals</span>    0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_names</span>      <span class="params">(‘s’,)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_varnames</span>   <span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_consts</span>     <span class="params">(None,)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_code</span>       ‘<span class="title">t</span>\<span class="title">x00</span>\<span class="title">x00GHd</span>\<span class="title">x00</span>\<span class="title">x00S</span>’</span></span><br></pre></td></tr></table></figure>
<h3 id="u6267_u884C_u5B57_u8282_u7801"><a href="#u6267_u884C_u5B57_u8282_u7801" class="headerlink" title="执行字节码"></a>执行字节码</h3><p>Python虚拟机的原理就是模拟可执行程序再X86机器上的运行，X86的运行时栈帧如下图：</p>
<p><img src="/images/14588486859304.jpg" alt=""></p>
<p>假如test.py用C语言来实现，会是下面这个样子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s = “hello”;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(“%s\n”, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python虚拟机的原理就是模拟上述行为。当发生函数调用时，创建新的栈帧，对应Python的实现就是PyFrameObject对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _frame &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    struct _frame *f_back;    /* 调用者的帧 */</span><br><span class="line">    PyCodeObject *f_code;     /* 帧对应的字节码对象 */</span><br><span class="line">    PyObject *f_builtins;     /* 内置名字空间 */</span><br><span class="line">    PyObject *f_globals;      /* 全局名字空间 */</span><br><span class="line">    PyObject *f_locals;       /* 本地名字空间 */</span><br><span class="line">    PyObject **f_valuestack;  /* 运行时栈底 */</span><br><span class="line">    PyObject **f_stacktop;    /* 运行时栈顶 */</span><br><span class="line">    …….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么对应Python的运行时栈就是这样子：</p>
<p><img src="/images/14588486997857.jpg" alt=""></p>
<p>执行test.py的字节码时，会先创建一个栈帧，以下用f表示当前栈帧，执行过程注释如下：</p>
<p>test.py的符号名集合和常量集合</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">co<span class="class">.co_names</span>   (‘s’, ’func’)</span><br><span class="line">co<span class="class">.co_consts</span>  (‘hello’, &lt;<span class="tag">code</span> <span class="tag">object</span> func at <span class="number">0</span>x2aaeeec57110, file ”test.py”, line <span class="number">3</span>&gt;, None)</span><br></pre></td></tr></table></figure>
<p>如果你想查看当前栈帧，Python提供了<code>sys._getframe()</code>方法可以获取当前栈帧，你只需要在代码里加入代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    frame = sys._getframe()</span><br><span class="line">    <span class="keyword">print</span> frame.f_locals</span><br><span class="line">    <span class="keyword">print</span> frame.f_globals</span><br><span class="line">    <span class="keyword">print</span> frame.f_back.f_locals</span><br><span class="line">    <span class="comment">#你可以打印frame的各个域</span></span><br><span class="line">    <span class="keyword">print</span> s</span><br></pre></td></tr></table></figure>
<h2 id="Python__u9ED1_u9B54_u6CD5"><a href="#Python__u9ED1_u9B54_u6CD5" class="headerlink" title="Python 黑魔法"></a>Python 黑魔法</h2><h3 id="Python__u591A_u7EE7_u627F"><a href="#Python__u591A_u7EE7_u627F" class="headerlink" title="Python 多继承"></a>Python 多继承</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class A(object):</span><br><span class="line">   ...:         def foo(self):</span><br><span class="line">   ...:                 print("class A")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [2]: class B(object):</span><br><span class="line">   ...:         def foo(self):</span><br><span class="line">   ...:                 print("class B")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [3]: class C(A, B):</span><br><span class="line">   ...:         pass</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [4]: C().foo()</span><br><span class="line">class A # 例子很好懂, C继承了A和B，从左到右,发现A有foo方法,返回了</span><br></pre></td></tr></table></figure>
<p>看起来都是很简单, 有次序的从底向上,从前向后找,找到就返回. 再看例子:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [5]: class A(object):</span><br><span class="line">   ...:        def foo(self):</span><br><span class="line">   ...:               print("class A")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [6]: class B(A):</span><br><span class="line">   ...:        pass</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [7]: class C(A):</span><br><span class="line">   ...:        def foo(self):</span><br><span class="line">   ...:               print("class C")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [8]: class D(B,C):</span><br><span class="line">   ...:        pass</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [9]: D().foo()</span><br><span class="line">class C # ? 按道理, 顺序是 D-&gt;B-&gt;A,为什么找到了C哪去了</span><br></pre></td></tr></table></figure>
<p>这也就涉及了MRO(Method Resolution Order):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: D.__mro__</span><br><span class="line">Out[<span class="number">10</span>]: (__main__.D, __main__.B, __main__.C, __main__.A, object)</span><br></pre></td></tr></table></figure>
<p>简单的理解其实就是新式类是广度优先了， D-&gt;B, 但是发现C也是继承A，就先找C，最后再去找A</p>
<h3 id="u5217_u8868_u7684+_u548C+_3D_2C_append_u548Cextend"><a href="#u5217_u8868_u7684+_u548C+_3D_2C_append_u548Cextend" class="headerlink" title="列表的+和+=, append和extend"></a>列表的+和+=, append和extend</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: print(<span class="string">'ID:'</span>, id(a_list))</span><br><span class="line">(<span class="string">'ID:'</span>, <span class="number">4481323592</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: a_list += [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: print(<span class="string">'ID (+=):'</span>, id(a_list))</span><br><span class="line">(<span class="string">'ID (+=):'</span>, <span class="number">4481323592</span>) <span class="comment"># 使用+= 还是在原来的列表上操作</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: a_list = a_list + [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: print(<span class="string">'ID (list = list + ...):'</span>, id(a_list))</span><br><span class="line">(<span class="string">'ID (list = list + ...):'</span>, <span class="number">4481293056</span>) <span class="comment"># 简单的+其实已经改变了原有列表</span></span><br><span class="line">In [<span class="number">28</span>]: a_list = []</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: id(a_list)</span><br><span class="line">Out[<span class="number">29</span>]: <span class="number">4481326976</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: a_list.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: id(a_list)</span><br><span class="line">Out[<span class="number">31</span>]: <span class="number">4481326976</span> <span class="comment"># append 是在原有列表添加</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: a_list.extend([<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: id(a_list)</span><br><span class="line">Out[<span class="number">33</span>]: <span class="number">4481326976</span> <span class="comment"># extend 也是在原有列表上添加</span></span><br></pre></td></tr></table></figure>
<h3 id="datetime_u4E5F_u6709_u5E03_u5C14_u503C"><a href="#datetime_u4E5F_u6709_u5E03_u5C14_u503C" class="headerlink" title="datetime也有布尔值"></a>datetime也有布尔值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">34</span>]: <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: print(<span class="string">'"datetime.time(0,0,0)" (Midnight) -&gt;'</span>, bool(datetime.time(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)))</span><br><span class="line">(<span class="string">'"datetime.time(0,0,0)" (Midnight) -&gt;'</span>, <span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: print(<span class="string">'"datetime.time(1,0,0)" (1 am) -&gt;'</span>, bool(datetime.time(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)))</span><br><span class="line">(<span class="string">'"datetime.time(1,0,0)" (1 am) -&gt;'</span>, <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="u2019_3D_3D_u2019__u548C_is__u7684_u533A_u522B"><a href="#u2019_3D_3D_u2019__u548C_is__u7684_u533A_u522B" class="headerlink" title="’==’ 和 is 的区别"></a>’==’ 和 is 的区别</h3><p>我的理解是”is”是判断2个对象的身份, ==是判断2个对象的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">37</span>]: a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: print(<span class="string">'a is b'</span>, bool(a <span class="keyword">is</span> b))</span><br><span class="line">(<span class="string">'a is b'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: c = <span class="number">999</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: d = <span class="number">999</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: print(<span class="string">'c is d'</span>, bool(c <span class="keyword">is</span> d))</span><br><span class="line">(<span class="string">'c is d'</span>, <span class="keyword">False</span>) <span class="comment"># 原因是python的内存管理,缓存了-5 - 256的对象</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: print(<span class="string">'256 is 257-1'</span>, <span class="number">256</span> <span class="keyword">is</span> <span class="number">257</span>-<span class="number">1</span>)</span><br><span class="line">(<span class="string">'256 is 257-1'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: print(<span class="string">'257 is 258-1'</span>, <span class="number">257</span> <span class="keyword">is</span> <span class="number">258</span> - <span class="number">1</span>)</span><br><span class="line">(<span class="string">'257 is 258-1'</span>, <span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: print(<span class="string">'-5 is -6+1'</span>, -<span class="number">5</span> <span class="keyword">is</span> -<span class="number">6</span>+<span class="number">1</span>)</span><br><span class="line">(<span class="string">'-5 is -6+1'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: print(<span class="string">'-7 is -6-1'</span>, -<span class="number">7</span> <span class="keyword">is</span> -<span class="number">6</span>-<span class="number">1</span>)</span><br><span class="line">(<span class="string">'-7 is -6-1'</span>, <span class="keyword">False</span>)</span><br><span class="line">In [<span class="number">47</span>]: a = <span class="string">'hello world!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: b = <span class="string">'hello world!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: print(<span class="string">'a is b,'</span>, a <span class="keyword">is</span> b)</span><br><span class="line">(<span class="string">'a is b,'</span>, <span class="keyword">False</span>) <span class="comment"># 很明显 他们没有被缓存,这是2个字段串的对象</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: print(<span class="string">'a == b,'</span>, a == b)</span><br><span class="line">(<span class="string">'a == b,'</span>, <span class="keyword">True</span>) <span class="comment"># 但他们的值相同</span></span><br><span class="line"><span class="comment"># But, 有个特例</span></span><br><span class="line">In [<span class="number">51</span>]: a = float(<span class="string">'nan'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: print(<span class="string">'a is a,'</span>, a <span class="keyword">is</span> a)</span><br><span class="line">(<span class="string">'a is a,'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: print(<span class="string">'a == a,'</span>, a == a)</span><br><span class="line">(<span class="string">'a == a,'</span>, <span class="keyword">False</span>) <span class="comment"># 亮瞎我眼睛了~</span></span><br></pre></td></tr></table></figure>
<h3 id="bool_u5176_u5B9E_u662Fint_u7684_u5B50_u7C7B"><a href="#bool_u5176_u5B9E_u662Fint_u7684_u5B50_u7C7B" class="headerlink" title="bool其实是int的子类"></a>bool其实是int的子类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">97</span>]: isinstance(<span class="keyword">True</span>, int)</span><br><span class="line">Out[<span class="number">97</span>]: <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: <span class="keyword">True</span> + <span class="keyword">True</span></span><br><span class="line">Out[<span class="number">98</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: <span class="number">3</span> * <span class="keyword">True</span> + <span class="keyword">True</span></span><br><span class="line">Out[<span class="number">99</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: <span class="number">3</span> * <span class="keyword">True</span> - <span class="keyword">False</span></span><br><span class="line">Out[<span class="number">100</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: <span class="keyword">True</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">Out[<span class="number">104</span>]: <span class="number">1024</span></span><br></pre></td></tr></table></figure>
<h3 id="u5143_u7EC4_u662F_u4E0D_u662F_u771F_u7684_u4E0D_u53EF_u53D8_3F"><a href="#u5143_u7EC4_u662F_u4E0D_u662F_u771F_u7684_u4E0D_u53EF_u53D8_3F" class="headerlink" title="元组是不是真的不可变?"></a>元组是不是真的不可变?</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [111]: tup = ([],)</span><br><span class="line"></span><br><span class="line">In [112]: tup[0] += [1]</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-112-d4f292cf35de&gt; in &lt;module&gt;()</span><br><span class="line">----&gt; 1 tup[0] += [1]</span><br><span class="line"></span><br><span class="line">TypeError: 'tuple' object does not support item assignment</span><br><span class="line"></span><br><span class="line">In [113]: tup</span><br><span class="line">Out[113]: ([1],) # 我靠 又是亮瞎我眼睛,明明抛了异常 还能修改?</span><br><span class="line"></span><br><span class="line">In [114]: tup = ([],)</span><br><span class="line"></span><br><span class="line">In [115]: tup[0].extend([1])</span><br><span class="line"></span><br><span class="line">In [116]: tup[0]</span><br><span class="line">Out[116]: [1] # 好吧,我有点看明白了, 虽然我不能直接操作元组，但是不能阻止我操作元组中可变的子对象(list)</span><br></pre></td></tr></table></figure>
<p>+= 是一个特例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">117</span>]: my_tup = (<span class="number">1</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: my_tup += (<span class="number">4</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: my_tup = my_tup + (<span class="number">5</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: my_tup</span><br><span class="line">Out[<span class="number">120</span>]: (<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment"># ? 嗯 不是不能操作元组嘛?</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: my_tup = (<span class="number">1</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: print(id(my_tup))</span><br><span class="line"><span class="number">4481317904</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: my_tup += (<span class="number">4</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: print(id(my_tup))</span><br><span class="line"><span class="number">4480606864</span> <span class="comment"># 操作的不是原来的元组 所以可以</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: my_tup = my_tup + (<span class="number">5</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">126</span>]: print(id(my_tup))</span><br><span class="line"><span class="number">4474234912</span></span><br></pre></td></tr></table></figure>
<h3 id="u5F02_u5E38_u5904_u7406_u52A0_else"><a href="#u5F02_u5E38_u5904_u7406_u52A0_else" class="headerlink" title="异常处理加 else"></a>异常处理加 else</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">150</span>]: <span class="keyword">try</span>:</span><br><span class="line">   .....:     print(<span class="string">'third element:'</span>, a_list[<span class="number">2</span>])</span><br><span class="line">   .....: <span class="keyword">except</span> IndexError:</span><br><span class="line">   .....:     print(<span class="string">'raised IndexError'</span>)</span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:     print(<span class="string">'no error in try-block'</span>) <span class="comment"># 只有在try里面没有异常的时候才会执行else里面的表达式</span></span><br><span class="line">   .....:</span><br><span class="line">raised IndexError <span class="comment"># 抛异常了 没完全完成</span></span><br><span class="line">In [<span class="number">153</span>]: i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">154</span>]: <span class="keyword">while</span> i &lt; <span class="number">2</span>:</span><br><span class="line">   .....:     print(i)</span><br><span class="line">   .....:     i += <span class="number">1</span></span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:     print(<span class="string">'in else'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> <span class="keyword">else</span> <span class="comment"># while也支持哦~</span></span><br><span class="line">In [<span class="number">155</span>]: i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: <span class="keyword">while</span> i &lt; <span class="number">2</span>:</span><br><span class="line">   .....:         print(i)</span><br><span class="line">   .....:         i += <span class="number">1</span></span><br><span class="line">   .....:         <span class="keyword">break</span></span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:         print(<span class="string">'completed while-loop'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span> <span class="comment"># 被break了 没有完全执行完 就不执行else里面的了</span></span><br><span class="line">In [<span class="number">158</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">   .....:         print(i)</span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:         print(<span class="string">'completed for-loop'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">completed <span class="keyword">for</span>-loop</span><br><span class="line"></span><br><span class="line">In [<span class="number">159</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">   .....:         print(i)</span><br><span class="line">   .....:         <span class="keyword">break</span></span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:         print(<span class="string">'completed for-loop'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span> <span class="comment"># 也是因为break了</span></span><br></pre></td></tr></table></figure>
<h2 id="u6DF1_u62F7_u8D1D_u4E0E_u6D45_u62F7_u8D1D"><a href="#u6DF1_u62F7_u8D1D_u4E0E_u6D45_u62F7_u8D1D" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><h3 id="u5BF9_u8C61_u8D4B_u503C"><a href="#u5BF9_u8C61_u8D4B_u503C" class="headerlink" title="对象赋值"></a>对象赋值</h3><p>Python中，对象的赋值，拷贝（深/浅拷贝）之间是有差异的，如果使用的时候不注意，就可能产生意外的结果。</p>
<p>直接看一段代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">will = [<span class="string">"Will"</span>, <span class="number">28</span>, [<span class="string">"Python"</span>, <span class="string">"C#"</span>, <span class="string">"JavaScript"</span>]]</span><br><span class="line">wilber = will</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">"Wilber"</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">"CSS"</span>)</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br></pre></td></tr></table></figure>
<p><img src="/media/14521096832549/tip1.png" alt="tip1"></p>
<p>下面来分析一下这段代码：</p>
<ul>
<li>首先，创建了一个名为will的变量，这个变量指向一个list对象，从第一张图中可以看到所有对象的地址（每次运行，结果可能不同）</li>
<li>然后，通过will变量对wilber变量进行赋值，那么wilber变量将指向will变量对应的对象（内存地址），也就是说”wilber is will”，”wilber[i] is will[i]”</li>
<li>可以理解为，Python中，对象的赋值都是进行对象引用（内存地址）传递</li>
</ul>
<p>第三张图中，由于will和wilber指向同一个对象，所以对will的任何修改都会体现在wilber上<br>这里需要注意的一点是，str是不可变类型，所以当修改的时候会替换旧的对象，产生一个新的地址39758496</p>
<p><img src="/images/14588487955418.jpg" alt=""></p>
<h3 id="u6D45_u62F7_u8D1D"><a href="#u6D45_u62F7_u8D1D" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>下面就来看看浅拷贝的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">will = [<span class="string">"Will"</span>, <span class="number">28</span>, [<span class="string">"Python"</span>, <span class="string">"C#"</span>, <span class="string">"JavaScript"</span>]]</span><br><span class="line">wilber = copy.copy(will)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">"Wilber"</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">"CSS"</span>)</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br></pre></td></tr></table></figure>
<p>代码结果为：</p>
<p><img src="/images/14588488054814.jpg" alt=""></p>
<p>分析一下这段代码：</p>
<ul>
<li>首先，依然使用一个will变量，指向一个list类型的对象</li>
<li>然后，通过copy模块里面的浅拷贝函数copy()，对will指向的对象进行浅拷贝，然后浅拷贝生成的新对象赋值给wilber变量<ul>
<li>浅拷贝会创建一个新的对象，这个例子中”wilber is not will”</li>
<li>但是，对于对象中的元素，浅拷贝就只会使用原始元素的引用（内存地址），也就是说”wilber[i] is will[i]”</li>
</ul>
</li>
<li>当对will进行修改的时候<ul>
<li>由于list的第一个元素是不可变类型，所以will对应的list的第一个元素会使用一个新的对象39758496</li>
<li>但是list的第三个元素是一个可变类型，修改操作不会产生新的对象，所以will的修改结果会相应的反应到wilber上</li>
</ul>
</li>
</ul>
<p><img src="/images/14588488145630.jpg" alt=""></p>
<p>总结一下，当我们使用下面的操作的时候，会产生浅拷贝的效果：</p>
<ul>
<li>使用切片[:]操作</li>
<li>使用工厂函数（如list/dir/set）</li>
<li>使用copy模块中的copy()函数</li>
</ul>
<h3 id="u6DF1_u62F7_u8D1D"><a href="#u6DF1_u62F7_u8D1D" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>最后来看看深拷贝：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">will = [<span class="string">"Will"</span>, <span class="number">28</span>, [<span class="string">"Python"</span>, <span class="string">"C#"</span>, <span class="string">"JavaScript"</span>]]</span><br><span class="line">wilber = copy.deepcopy(will)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">"Wilber"</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">"CSS"</span>)</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br></pre></td></tr></table></figure>
<p>代码的结果为：</p>
<p><img src="/images/14588488380987.jpg" alt=""></p>
<p>分析一下这段代码：</p>
<ul>
<li>首先，同样使用一个will变量，指向一个list类型的对象</li>
<li>然后，通过copy模块里面的深拷贝函数deepcopy()，对will指向的对象进行深拷贝，然后深拷贝生成的新对象赋值给wilber变量<ul>
<li>跟浅拷贝类似，深拷贝也会创建一个新的对象，这个例子中”wilber is not will”</li>
<li>但是，对于对象中的元素，深拷贝都会重新生成一份（有特殊情况，下面会说明），而不是简单的使用原始元素的引用（内存地址）</li>
<li>例子中will的第三个元素指向39737304，而wilber的第三个元素是一个全新的对象39773088，也就是说，”wilber[2] is not will[2]”</li>
</ul>
</li>
<li>当对will进行修改的时候<ul>
<li>由于list的第一个元素是不可变类型，所以will对应的list的第一个元素会使用一个新的对象39758496</li>
<li>但是list的第三个元素是一个可变类型，修改操作不会产生新的对象，但是由于”wilber[2] is not will[2]”，所以will的修改不会影响wilber</li>
</ul>
</li>
</ul>
<p><img src="/images/14588488493152.jpg" alt=""></p>
<h3 id="u62F7_u8D1D_u7684_u7279_u6B8A_u60C5_u51B5"><a href="#u62F7_u8D1D_u7684_u7279_u6B8A_u60C5_u51B5" class="headerlink" title="拷贝的特殊情况"></a>拷贝的特殊情况</h3><p>其实，对于拷贝有一些特殊情况：</p>
<ul>
<li>对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有拷贝这一说<ul>
<li>也就是说，对于这些类型，”obj is copy.copy(obj)” 、”obj is copy.deepcopy(obj)”</li>
</ul>
</li>
<li>如果元组变量只包含原子类型对象，则不能深拷贝，看下面的例子</li>
</ul>
<p><img src="/images/14588488582446.jpg" alt=""></p>
<p>总结</p>
<p>本文介绍了对象的赋值和拷贝，以及它们之间的差异：</p>
<ul>
<li>Python中对象的赋值都是进行对象引用（内存地址）传递</li>
<li>使用copy.copy()，可以进行对象的浅拷贝，它复制了对象，但对于对象中的元素，依然使用原始的引用.</li>
<li>如果需要复制一个容器对象，以及它里面的所有元素（包含元素的子元素），可以使用copy.deepcopy()进行深拷贝</li>
<li>对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有被拷贝一说</li>
<li>如果元组变量只包含原子类型对象，则不能深拷贝，看下面的例子</li>
</ul>
<h2 id="Python__u4E2D_self__u7684_u542B_u4E49"><a href="#Python__u4E2D_self__u7684_u542B_u4E49" class="headerlink" title="Python 中 self 的含义"></a>Python 中 self 的含义</h2><p>刚开始学习Python的类写法的时候觉得很是麻烦，为什么定义时需要而调用时又不需要，为什么不能内部简化从而减少我们敲击键盘的次数？</p>
<h3 id="self_u4EE3_u8868_u7C7B_u7684_u5B9E_u4F8B_uFF0C_u800C_u975E_u7C7B_u3002"><a href="#self_u4EE3_u8868_u7C7B_u7684_u5B9E_u4F8B_uFF0C_u800C_u975E_u7C7B_u3002" class="headerlink" title="self代表类的实例，而非类。"></a>self代表类的实例，而非类。</h3><p>实例来说明</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line">        print(self.__class__)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Test object at <span class="number">0x000000000284E080</span>&gt;</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Test</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的例子中可以很明显的看出，self代表的是类的实例。而self.class则指向类。</p>
<h3 id="self_u4E0D_u5FC5_u975E_u5199_u6210self"><a href="#self_u4E0D_u5FC5_u975E_u5199_u6210self" class="headerlink" title="self不必非写成self"></a>self不必非写成self</h3><p>有很多童鞋是先学习别的语言然后学习Python的，所以总觉得self怪怪的，想写成this，可以吗？</p>
<p>当然可以，还是把上面的代码改写一下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(this)</span>:</span></span><br><span class="line">        print(this)</span><br><span class="line">        print(this.__class__)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure>
<p>改成this后，运行结果完全一样。</p>
<p>当然，最好还是尊重约定俗成的习惯，使用self。</p>
<h3 id="self_u53EF_u4EE5_u4E0D_u5199_u5417"><a href="#self_u53EF_u4EE5_u4E0D_u5199_u5417" class="headerlink" title="self可以不写吗"></a>self可以不写吗</h3><p>在Python的解释器内部，当我们调用t.prt()时，实际上Python解释成Test.prt(t)，也就是说把self替换成类的实例。</p>
<p>有兴趣的童鞋可以把上面的t.prt()一行改写一下，运行后的实际结果完全相同。</p>
<p>实际上已经部分说明了self在定义时不可以省略，如果非要试一下，那么请看下面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">()</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure>
<p>运行时提醒错误如下：prt在定义时没有参数，但是我们运行时强行传了一个参数。<br>由于上面解释过了t.prt()等同于Test.prt(t)，所以程序提醒我们多传了一个参数t。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"h.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    t.<span class="function"><span class="title">prt</span><span class="params">()</span></span></span><br><span class="line">TypeError: <span class="function"><span class="title">prt</span><span class="params">()</span></span> takes <span class="number">0</span> positional arguments but <span class="number">1</span> was given</span><br></pre></td></tr></table></figure>
<p>当然，如果我们的定义和调用时均不传类实例是可以的，这就是类方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">()</span>:</span></span><br><span class="line">        print(__class__)</span><br><span class="line">Test.prt()</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<pre><code>&lt;class &apos;__main__.Test&apos;&gt;
</code></pre><p>在继承时，传入的是哪个实例，就是那个传入的实例，而不是指定义了self的类的实例。<br>先看代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pprt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cprt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line">c = Child()</span><br><span class="line">c.cprt()</span><br><span class="line">c.pprt()</span><br><span class="line">p = Parent()</span><br><span class="line">p.pprt()</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__<span class="class">.Child</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A47080&gt;</span><br><span class="line">&lt;__main__<span class="class">.Child</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A47080&gt;</span><br><span class="line">&lt;__main__<span class="class">.Parent</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A47240&gt;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>运行c.cprt()时应该没有理解问题，指的是Child类的实例。</p>
<p>但是在运行c.pprt()时，等同于Child.pprt(c)，所以self指的依然是Child类的实例，由于self中没有定义pprt()方法，所以沿着继承树往上找，发现在父类Parent中定义了pprt()方法，所以就会成功调用。</p>
<p>在描述符类中，self指的是描述符类的实例</p>
<p>不太容易理解，先看实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desc</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, ins, cls)</span>:</span></span><br><span class="line">        print(<span class="string">'self in Desc: %s '</span> % self )</span><br><span class="line">        print(self, ins, cls)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    x = Desc()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'self in Test: %s'</span> % self)</span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br><span class="line">t.x</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self <span class="keyword">in</span> Test: &lt;__main__<span class="class">.Test</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A570B8&gt;</span><br><span class="line">self <span class="keyword">in</span> Desc: &lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000283E208&gt;</span><br><span class="line">&lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000283E208&gt; &lt;__main__<span class="class">.Test</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A570B8&gt; &lt;class <span class="string">'__main__.Test'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>大部分童鞋开始有疑问了，为什么在Desc类中定义的self不是应该是调用它的实例t吗？怎么变成了Desc类的实例了呢？</p>
<p>注意：此处需要睁大眼睛看清楚了，这里调用的是t.x，也就是说是Test类的实例t的属性x，由于实例t中并没有定义属性x，所以找到了类属性x，而该属性是描述符属性，为Desc类的实例而已，所以此处并没有顶用Test的任何方法。</p>
<p>那么我们如果直接通过类来调用属性x也可以得到相同的结果。</p>
<p>下面是把t.x改为Test.x运行的结果。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self <span class="keyword">in</span> Test: &lt;__main__<span class="class">.Test</span> <span class="tag">object</span> at <span class="number">0</span>x00000000022570B8&gt;</span><br><span class="line">self <span class="keyword">in</span> Desc: &lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000223E208&gt;</span><br><span class="line">&lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000223E208&gt; None &lt;class <span class="string">'__main__.Test'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>题外话：由于在很多时候描述符类中仍然需要知道调用该描述符的实例是谁，所以在描述符类中存在第二个参数ins，用来表示调用它的类实例，所以t.x时可以看到第三行中的运行结果中第二项为<main.test object="" at="" 0x0000000002a570b8="">。而采用Test.x进行调用时，由于没有实例，所以返回None。</main.test></p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>self在定义时需要定义，但是在调用时会自动传入。</li>
<li>self的名字并不是规定死的，但是最好还是按照约定是用self</li>
<li>self总是指调用时的类的实例。</li>
</ul>
<h2 id="Python_u7684_u5185_u5B58_u7BA1_u7406"><a href="#Python_u7684_u5185_u5B58_u7BA1_u7406" class="headerlink" title="Python的内存管理"></a>Python的内存管理</h2><p>以Python语言为例子，说明一门动态类型的、面向对象的语言的内存管理方式。</p>
<h3 id="u5BF9_u8C61_u7684_u5185_u5B58_u4F7F_u7528"><a href="#u5BF9_u8C61_u7684_u5185_u5B58_u4F7F_u7528" class="headerlink" title="对象的内存使用"></a>对象的内存使用</h3><p>赋值语句是语言最常见的功能了。但即使是最简单的赋值语句，也可以很有内涵。Python的赋值语句就很值得研究。</p>
<pre><code>a = 1
</code></pre><p>整数1为一个对象。而a是一个引用。利用赋值语句，引用a指向对象1。Python是动态类型的语言(参考动态类型)，对象与引用分离。Python像使用“筷子”那样，通过引用来接触和翻动真正的食物——对象。</p>
<p>为了探索对象在内存的存储，我们可以求助于Python的内置函数id()。它用于返回对象的身份(identity)。其实，这里所谓的身份，就是该对象的内存地址。</p>
<pre><code>a = 1
print(id(a))
print(hex(id(a)))
</code></pre><p>在我的计算机上，它们返回的是:</p>
<pre><code>11246696
’0xab9c68′
</code></pre><p>分别为内存地址的十进制和十六进制表示。</p>
<p>在Python中，整数和短小的字符，Python都会缓存这些对象，以便重复使用。当我们创建多个等于1的引用时，实际上是让所有这些引用指向同一个对象。</p>
<pre><code>a = 1
b = 1
print(id(a))
print(id(b))
</code></pre><p>上面程序返回</p>
<pre><code>11246696
11246696
</code></pre><p>可见a和b实际上是指向同一个对象的两个引用。</p>
<p>为了检验两个引用指向同一个对象，我们可以用is关键字。is用于判断两个引用所指的对象是否相同。</p>
<pre><code># True
a = 1
b = 1
print(a is b)

# True
a = &quot;good&quot;
b = &quot;good&quot;
print(a is b)

# False
a = &quot;very good morning&quot;
b = &quot;very good morning&quot;
print(a is b)

# False
a = []
b = []
print(a is b)
</code></pre><p>上面的注释为相应的运行结果。可以看到，由于Python缓存了整数和短字符串，因此每个对象只存有一份。比如，所有整数1的引用都指向同一对象。即使使用赋值语句，也只是创造了新的引用，而不是对象本身。长的字符串和其它对象可以有多个相同的对象，可以使用赋值语句创建出新的对象。</p>
<p>在Python中，每个对象都有存有指向该对象的引用总数，即引用计数(reference count)。</p>
<p>我们可以使用sys包中的getrefcount()，来查看某个对象的引用计数。需要注意的是，当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的多1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(getrefcount(a))</span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line">print(getrefcount(b))</span><br></pre></td></tr></table></figure>
<p>由于上述原因，两个getrefcount将返回2和3，而不是期望的1和2。</p>
<p>Python的一个容器对象(container)，比如表、词典等，可以包含多个对象。实际上，容器对象中包含的并不是元素对象本身，是指向各个元素对象的引用。</p>
<p>我们也可以自定义一个对象，并引用其它对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">from_obj</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, to_obj)</span>:</span></span><br><span class="line">        self.to_obj = to_obj</span><br><span class="line"></span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a = from_obj(b)</span><br><span class="line">print(id(a.to_obj))</span><br><span class="line">print(id(b))</span><br></pre></td></tr></table></figure>
<p>可以看到，a引用了对象b。</p>
<p>对象引用对象，是Python最基本的构成方式。即使是a = 1这一赋值方式，实际上是让词典的一个键值”a”的元素引用整数对象1。该词典对象用于记录所有的全局引用。该词典引用了整数对象1。我们可以通过内置函数globals()来查看该词典。</p>
<p>当一个对象A被另一个对象B引用时，A的引用计数将增加1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(getrefcount(a))</span><br><span class="line"></span><br><span class="line">b = [a, a]</span><br><span class="line">print(getrefcount(a))</span><br></pre></td></tr></table></figure>
<p>由于对象b引用了两次a，a的引用计数增加了2。</p>
<p>容器对象的引用可能构成很复杂的拓扑结构。我们可以用objgraph包来绘制其引用关系，比如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [x, dict(key1=x)]</span><br><span class="line">z = [y, (x, y)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> objgraph</span><br><span class="line">objgraph.show_refs([z], filename=<span class="string">'ref_topo.png'</span>)</span><br></pre></td></tr></table></figure>
<p>objgraph是Python的一个第三方包。安装之前需要安装xdot。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="keyword">install</span> xdot</span><br><span class="line">sudo pip <span class="keyword">install</span> objgraph</span><br></pre></td></tr></table></figure>
<p>两个对象可能相互引用，从而构成所谓的引用环(reference cycle)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">b = [a]</span><br><span class="line">a.append(b)</span><br></pre></td></tr></table></figure>
<p>即使是一个对象，只需要自己引用自己，也能构成引用环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">a.append(a)</span><br><span class="line">print(getrefcount(a))</span><br></pre></td></tr></table></figure>
<p>引用环会给垃圾回收机制带来很大的麻烦，我将在后面详细叙述这一点。</p>
<p>某个对象的引用计数可能减少。比如，可以使用del关键字删除某个引用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">print(getrefcount(b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line">print(getrefcount(b))</span><br></pre></td></tr></table></figure>
<p>del也可以用于删除容器元素中的元素，比如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> a[<span class="number">0</span>]</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>如果某个引用指向对象A，当这个引用被重新定向到某个其他对象B时，对象A的引用计数减少:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">print(getrefcount(b))</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">print(getrefcount(b))</span><br></pre></td></tr></table></figure>
<h3 id="u5783_u573E_u56DE_u6536"><a href="#u5783_u573E_u56DE_u6536" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>吃太多，总会变胖，Python也是这样。当Python中的对象越来越多，它们将占据越来越大的内存。不过你不用太担心Python的体形，它会乖巧的在适当的时候“减肥”，启动垃圾回收(garbage collection)，将没用的对象清除。在许多语言中都有垃圾回收机制，比如Java和Ruby。尽管最终目的都是塑造苗条的提醒，但不同语言的减肥方案有很大的差异。</p>
<p>从基本原理上，当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如某个新建对象，它被分配给某个引用，对象的引用计数变为1。如果引用被删除，对象的引用计数为0，那么该对象就可以被垃圾回收。比如下面的表:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> a</span><br></pre></td></tr></table></figure>
<p>del a后，已经没有任何引用指向之前建立的[1, 2, 3]这个表。用户不可能通过任何方式接触或者动用这个对象。这个对象如果继续待在内存里，就成了不健康的脂肪。当垃圾回收启动时，Python扫描到这个引用计数为0的对象，就将它所占据的内存清空。</p>
<p>然而，减肥是个昂贵而费力的事情。垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要总启动垃圾回收。所以，Python只会在特定条件下，自动启动垃圾回收。当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。</p>
<p>我们可以通过gc模块的get_threshold()方法，查看该阈值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">print(gc.get_threshold())</span><br></pre></td></tr></table></figure>
<p>返回(700, 10, 10)，后面的两个10是与分代回收相关的阈值，后面可以看到。700即是垃圾回收启动的阈值。可以通过gc中的set_threshold()方法重新设置。</p>
<p>我们也可以手动启动垃圾回收，即使用gc.collect()。</p>
<p>Python同时采用了分代(generation)回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。</p>
<p>小家伙要多检查</p>
<p>Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。</p>
<p>这两个次数即上面get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。</p>
<p>同样可以用set_threshold()来调整，比如对2代对象进行更频繁的扫描。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">gc.set_threshold(<span class="number">700</span>, <span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>引用环的存在会给上面的垃圾回收机制带来很大的困难。这些引用环可能构成无法使用，但引用计数不为0的一些对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">b = [a]</span><br><span class="line">a.append(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"><span class="keyword">del</span> b</span><br></pre></td></tr></table></figure>
<p>上面我们先创建了两个表对象，并引用对方，构成一个引用环。删除了a，b引用之后，这两个对象不可能再从程序中调用，就没有什么用处了。但是由于引用环的存在，这两个对象的引用计数都没有降到0，不会被垃圾回收。</p>
<p>为了回收这样的引用环，Python复制每个对象的引用计数，可以记为gc_ref。假设，每个对象i，该计数为gc_ref_i。Python会遍历所有的对象i。对于每个对象i引用的对象j，将相应的gc_ref_j减1。</p>
<p>在结束遍历后，gc_ref不为0的对象，和这些对象引用的对象，以及继续更下游引用的对象，需要被保留。而其它的对象则被垃圾回收。</p>
<h3 id="u603B_u7ED3-1"><a href="#u603B_u7ED3-1" class="headerlink" title="总结"></a>总结</h3><p>Python作为一种动态类型的语言，其对象和引用分离。这与曾经的面向过程语言有很大的区别。为了有效的释放内存，Python内置了垃圾回收的支持。Python采取了一种相对简单的垃圾回收机制，即引用计数，并因此需要解决孤立引用环的问题。Python与其它语言既有共通性，又有特别的地方。对该内存管理机制的理解，是提高Python性能的重要一步。</p>
<h2 id="u5B57_u5178_u63A8_u5BFC_28Dictionary_comprehensions_29_u548C_u96C6_u5408_u63A8_u5BFC_28Set_comprehensions_29"><a href="#u5B57_u5178_u63A8_u5BFC_28Dictionary_comprehensions_29_u548C_u96C6_u5408_u63A8_u5BFC_28Set_comprehensions_29" class="headerlink" title="字典推导(Dictionary comprehensions)和集合推导(Set comprehensions)"></a>字典推导(Dictionary comprehensions)和集合推导(Set comprehensions)</h2><p>大多数的Python程序员都知道且使用过列表推导(list comprehensions)。如果你对list comprehensions概念不是很熟悉——一个list comprehension就是一个更简短、简洁的创建一个list的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>some_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>another_list = [ x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> some_list ]</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>another_list</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>自从python 3.1 (甚至是Python 2.7)起，我们可以用同样的语法来创建集合和字典表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="comment"># Set Comprehensions</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>some_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>even_set = &#123; x <span class="keyword">for</span> x <span class="keyword">in</span> some_list <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>even_set</span><br><span class="line">set([<span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="comment"># Dict Comprehensions</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d = &#123; x: x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="number">1</span>: <span class="keyword">False</span>, <span class="number">2</span>: <span class="keyword">True</span>, <span class="number">3</span>: <span class="keyword">False</span>, <span class="number">4</span>: <span class="keyword">True</span>, <span class="number">5</span>: <span class="keyword">False</span>, <span class="number">6</span>: <span class="keyword">True</span>, <span class="number">7</span>: <span class="keyword">False</span>, <span class="number">8</span>: <span class="keyword">True</span>, <span class="number">9</span>: <span class="keyword">False</span>, <span class="number">10</span>: <span class="keyword">True</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个例子里，我们以some_list为基础，创建了一个具有不重复元素的集合，而且集合里只包含偶数。而在字典表的例子里，我们创建了一个key是不重复的1到10之间的整数，value是布尔型，用来指示key是否是偶数。</p>
<p>这里另外一个值得注意的事情是集合的字面量表示法。我们可以简单的用这种方法创建一个集合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>my_set</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>而不需要使用内置函数set()。</p>
<h2 id="Python_u8C03_u7528_u7CFB_u7EDF_u547D_u4EE4_u6216_u8005_u811A_u672C"><a href="#Python_u8C03_u7528_u7CFB_u7EDF_u547D_u4EE4_u6216_u8005_u811A_u672C" class="headerlink" title="Python调用系统命令或者脚本"></a>Python调用系统命令或者脚本</h2><p>使用 os.system() 调用系统命令 , 程序中无法获得到输出和返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>os.system(<span class="string">'ls -l /proc/cpuinfo'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>os.system(<span class="string">"ls -l /proc/cpuinfo"</span>)</span><br><span class="line">  -r--r--r-- <span class="number">1</span> root root <span class="number">0</span>  <span class="number">3</span>月 <span class="number">29</span> <span class="number">16</span>:<span class="number">53</span> /proc/cpuinfo</span><br><span class="line">  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>使用 os.popen() 调用系统命令, 程序中可以获得命令输出，但是不能得到执行的返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>out = os.popen(<span class="string">"ls -l /proc/cpuinfo"</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> out.read()</span><br><span class="line">  -r--r--r-- <span class="number">1</span> root root <span class="number">0</span>  <span class="number">3</span>月 <span class="number">29</span> <span class="number">16</span>:<span class="number">59</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure>
<p>使用 commands.getstatusoutput() 调用系统命令, 程序中可以获得命令输出和执行的返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> commands</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>commands.getstatusoutput(<span class="string">'ls /bin/ls'</span>)</span><br><span class="line">  (<span class="number">0</span>, <span class="string">'/bin/ls'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Python__u6355_u83B7_u7528_u6237_Ctrl+C__2CCtrl+D__u4E8B_u4EF6"><a href="#Python__u6355_u83B7_u7528_u6237_Ctrl+C__2CCtrl+D__u4E8B_u4EF6" class="headerlink" title="Python 捕获用户 Ctrl+C ,Ctrl+D 事件"></a>Python 捕获用户 Ctrl+C ,Ctrl+D 事件</h2><p>有些时候，需要在程序中捕获用户键盘事件，比如ctrl+c退出，这样可以更好的安全退出程序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    do_some_func()</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"User Press Ctrl+C,Exit"</span></span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"User Press Ctrl+D,Exit"</span></span><br></pre></td></tr></table></figure>
<h2 id="Python__u8BFB_u5199_u6587_u4EF6"><a href="#Python__u8BFB_u5199_u6587_u4EF6" class="headerlink" title="Python 读写文件"></a>Python 读写文件</h2><p>一次性读入文件到列表，速度较快，适用文件比较小的情况下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">track_file = <span class="string">"track_stock.conf"</span></span><br><span class="line">fd = open(track_file)</span><br><span class="line">content_list = fd.readlines()</span><br><span class="line">fd.close()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> content_list:</span><br><span class="line">    <span class="keyword">print</span> line</span><br></pre></td></tr></table></figure>
<p>逐行读入，速度较慢,适用没有足够内存读取整个文件(文件太大)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fd = open(file_path)</span><br><span class="line">fd.seek(<span class="number">0</span>)</span><br><span class="line">title = fd.readline()</span><br><span class="line">keyword = fd.readline()</span><br><span class="line">uuid = fd.readline()</span><br><span class="line">fd.close()</span><br></pre></td></tr></table></figure>
<p>写文件 write 与 writelines 的区别   </p>
<ul>
<li>Fd.write(str) : 把str写到文件中，write()并不会在str后加上一个换行符</li>
<li>Fd.writelines(content) : 把content的内容全部写到文件中,原样写入，不会在每行后面加上任何东西</li>
</ul>
<h2 id="u88C5_u9970_u5668"><a href="#u88C5_u9970_u5668" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器使一个函数或方法包装在另一个函数里头，可以在被包装的函数添加一些额外的功能，比如日志，还可以对参数、返回结果进行修改。装饰器有点类似Java中的AOP。下面这个例子是打印被装饰的函数里面的参数的装饰器，  </p>
<pre><code>&gt;&gt;&gt; def print_args(function):
&gt;&gt;&gt;     def wrapper(*args, **kwargs):
&gt;&gt;&gt;         print &apos;Arguments:&apos;, args, kwargs
&gt;&gt;&gt;         return function(*args, **kwargs)
&gt;&gt;&gt;     return wrapper

&gt;&gt;&gt; @print_args
&gt;&gt;&gt; def write(text):
&gt;&gt;&gt;     print text

&gt;&gt;&gt; write(&apos;foo&apos;)
Arguments: (&apos;foo&apos;,) {}
foo
</code></pre><p>@是语法糖，它等价于：  </p>
<pre><code>&gt;&gt;&gt; write = print_args(write)
&gt;&gt;&gt; write(&apos;foo&apos;)
arguments: (&apos;foo&apos;,) {}
foo
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这里收集了一些深入 python 机制的内容。</p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://wdxtub.com/tags/Python/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[个人知识管理指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/self-knowledge-management/"/>
    <id>http://wdxtub.com/2016/03/24/self-knowledge-management/</id>
    <published>2016-03-24T14:14:42.000Z</published>
    <updated>2016-03-24T15:06:19.000Z</updated>
    <content type="html"><![CDATA[<p>经过一年时间打磨，我的个人知识管理体系终于成型，在这里跟大家分享一下。</p>
<a id="more"></a>
<hr>
<p>在这个碎片化的时代，如何『聚合』是有门道的，甚至可以认为是『刚需』。各类门户各类新闻聚合各类资讯文章层出不穷，但是问题在于，作为个人，如何真正把看到的『信息』转化为『知识』呢？</p>
<p>在我之前的文章<a href="http://wdxtub.lofter.com/post/1a7a1d_5d46742" target="_blank" rel="external">《信息极简之道》</a>中，粗略介绍了基于七个不同组件的信息管理工作流，经过大半年的改进，最终形成了<a href="http://wdxtub.com/2016/01/02/cloud-workflow/">《极简解构工作流》</a>中介绍的方法。</p>
<blockquote>
<p>这套工作流的核心，在于『流』，也就是说，所有的一切，都是为了让信息在尽可能少的依赖和限制下自由流动。无论是不同的设备，不同的应用还是不同的形式，信息都应该能以最简单最自然的方式进行流动。并且，我也不希望整套工作流过分依赖某个步骤或者某个应用。</p>
</blockquote>
<p>前面的文章主要说的是思路，这篇文章中会结合实际应用详细介绍具体的工作流程（当然也有一些更新）。</p>
<h2 id="u8BBE_u8BA1_u54F2_u5B66"><a href="#u8BBE_u8BA1_u54F2_u5B66" class="headerlink" title="设计哲学"></a>设计哲学</h2><p>设计哲学主要有四点：极简、GTD、Unix 以及沉淀</p>
<ul>
<li>极简：所用工具简单，适应性稳定性强，对环境的依赖少，关注信息本身，自动完成琐碎繁杂工作，与此同时保持高可拓展性</li>
<li>GTD：规则化任务处理，尽量减少任务选择和切换时的消耗，断舍离，不陷入任务堆积的恶性循环中</li>
<li>Unix：所有信息通过文本文件的方式进行流动，减少了不同步骤和模块间的耦合，每一个步骤和模块都可以根据自己的喜好进行定制</li>
<li>沉淀：提取主题，写系列博客，把知识组织并分享出去</li>
</ul>
<p>根据这样的设计哲学，具体的设计和功能有：</p>
<ul>
<li>文件同步：Dropbox / Box / 百度云 / 金山云盘 / …<ul>
<li>不同文件夹表示不同笔记的类别，不同的笔记保存在不同的文本文件中</li>
<li>采用跨平台的文件同步服务，可以在不同电脑、手机上方便访问自己的笔记</li>
</ul>
</li>
<li>文本编辑：MWeb / Sublime / Atom / Visual Studio Code / Vim / Emacs / …<ul>
<li>基于 Markdown 语法的记录方式，利用文本文件实现不同的逻辑标记</li>
<li>任何文本编辑器都可以，只是显示效果可能有所差别</li>
</ul>
</li>
<li>信息导入：主要是 Kindle <ul>
<li>因为通常在使用 Kindle 进行阅读的时候会记录大量书摘，利用自己编写的信息导入插件，可以方便导出 kindle 书摘（成为文本文件），并无缝对接到知识管理系统中</li>
</ul>
</li>
<li>博客：Hexo / WordPress / …<ul>
<li>博客主要是用于记录和沉淀，并且能够把自己的思考分享出去</li>
</ul>
</li>
<li>随处访问：Github / Web / 手机 / 电脑<ul>
<li>因为基于简单的文件同步机制，所以在不同的平台上，都可以集成各种服务。比如说用 Github 进行版本控制，利用支持云盘同步的 APP 即可在手机上随时查看，博客内容也只需浏览器就可以方便浏览</li>
</ul>
</li>
</ul>
<h2 id="u5E94_u7528_u63A8_u8350"><a href="#u5E94_u7528_u63A8_u8350" class="headerlink" title="应用推荐"></a>应用推荐</h2><p>下面是我用着觉得比较顺手应用，推荐给大家（部分需要付费）</p>
<h3 id="MWeb"><a href="#MWeb" class="headerlink" title="MWeb"></a><a href="http://www.mweb.im/" target="_blank" rel="external">MWeb</a></h3><p><img src="/images/14588310376887.jpg" alt=""></p>
<ul>
<li>平台：Mac</li>
<li>功能：文件夹/文件管理，跨文件检索，即时预览，快捷插入图片，一键生成网站</li>
<li>简介：非常强大美观，可以说一次满足所有愿望，还是国人开发者的作品，良心</li>
</ul>
<h3 id="1Writer"><a href="#1Writer" class="headerlink" title="1Writer"></a><a href="http://1writerapp.com/" target="_blank" rel="external">1Writer</a></h3><p><img src="/images/14588312196908.jpg" alt=""></p>
<ul>
<li>平台：iPhone / iPad</li>
<li>功能：Markdown 支持，Dropbox 同步，文件夹/文件管理，导出 PDF，各种分享方式</li>
<li>简介：当之无愧的最佳，具体可以参考 <a href="http://wdxtub.com/2015/12/08/md-editor-ios/">iOS 上 Markdown 编辑器简评</a></li>
</ul>
<h2 id="Draft"><a href="#Draft" class="headerlink" title="Draft"></a><a href="https://play.google.com/store/apps/details?id=com.mvilla.draft" target="_blank" rel="external">Draft</a></h2><p><img src="/images/14588315888356.jpg" alt=""></p>
<ul>
<li>平台：Android</li>
<li>功能：Markdown 支持，Dropbox 同步，文件夹/文件管理，导出 PDF，各种分享方式</li>
<li>简介：因为小插件的缘故，甚至比 iOS 平台上的体验都好得多</li>
</ul>
<h3 id="Kindle_Voyage"><a href="#Kindle_Voyage" class="headerlink" title="Kindle Voyage"></a>Kindle Voyage</h3><p><img src="/images/14588317350582.jpg" alt=""></p>
<p>没啥好说的，还没买赶紧买买买啊！</p>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a><a href="https://hexo.io/" target="_blank" rel="external">Hexo</a></h3><p><img src="/images/14588317944639.jpg" alt=""></p>
<p>静态网站生成器，可以和 Github 完美对接（免费搭建自己的独立博客），相比其他的平台简单很多，我的博客就是由 hexo 搭建的</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这套工作流基本和工具解耦，能够很方便地根据自己的需要进行配置</p>
<ul>
<li>打通了各个设备的界限。微信订阅号的文章可以统一发送到 Kindle 上，在Kindle 上阅读批注后可以统一导入到电脑中</li>
<li>对操作系统和软件没有要求。整个工作流哪怕在一台全新的电脑上都可以快速展开，文件和文件夹是现代操作系统都有，系统也会自带编辑器和查找功能。唯一的区别就是，自己的电脑可以根据喜好进行配置，但是即使没有这些配置，整个工作流依然可以进行（比方说手头上没有自己电脑的时候）</li>
<li>所有的信息可以通过网络进行访问，无论是 Github 还是 Dropbox 或者是其他的云盘服务，都可以在线查看，只要有网，无论是手机还是电脑，都可以随时访问全部的信息</li>
<li>所有的内容保存在云端，可以方便进行场景的切换，比方说可以在手机上查看和编辑笔记，会自动同步到电脑上，随时可以切换到电脑继续刚才的工作</li>
<li>自动备份冗余：版本控制，更新时间等等都由云端处理，无须自己费心</li>
</ul>
<p>相信大家在具体的实践和摸索中，能找到最适合自己的方式。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>经过一年时间打磨，我的个人知识管理体系终于成型，在这里跟大家分享一下。</p>]]>
    
    </summary>
    
      <category term="信息" scheme="http://wdxtub.com/tags/%E4%BF%A1%E6%81%AF/"/>
    
      <category term="效率" scheme="http://wdxtub.com/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="自由" scheme="http://wdxtub.com/tags/%E8%87%AA%E7%94%B1/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[架与构 1 缘起]]></title>
    <link href="http://wdxtub.com/2016/03/22/arch-build-1/"/>
    <id>http://wdxtub.com/2016/03/22/arch-build-1/</id>
    <published>2016-03-22T19:09:02.000Z</published>
    <updated>2016-03-22T19:58:37.000Z</updated>
    <content type="html"><![CDATA[<p>做架构师是我从刚开始接触计算机科学时的梦想，现在，是时候为了这个梦想而做一些沉淀了。这个系列会写不同的架构概念，写不同的实际系统分析，写自己的想法和思考。</p>
<a id="more"></a>
<hr>
<p>大二的时候，我走到老师的办公室，问了这样一个问题：</p>
<blockquote>
<p>我要怎么样成为一个游戏制作人，或者是一个架构师呢？</p>
</blockquote>
<p>老师当时的反应我还记得，他说这俩职位的差别还是挺大的（中间省略一万字）但是有一点是相同的，就是都要 think different。</p>
<p>这年头，传统意义上的『好』，不如『特别』。所谓『特别』，意味着去想去做别人没想过或者不敢做的事儿，而不是在大家都知道要做的事情上做得最好。</p>
<p>比如说写博客，我不是懂最多的，也不是做得最快的，但是我却是最先开始写课程相关博客的。虽然主要目的其实是强迫自己认真思考所学知识，但是能够给大家提供一点方便，做一个交流和讨论的平台，甚至让有些同学也开始写博客。我觉得这是特别好的事情，可能我自己做不到一百分，但是能让大家都学到八九十分，也许比自己的一百分更重要。</p>
<p>回到正题，这个系列到底要写什么呢？主要分两大部分，一个是架构相关的基本概念介绍（<a href="http://parlab.eecs.berkeley.edu/wiki/patterns/patterns" target="_blank" rel="external">来源</a>），另一个就是结合各大公司公开出来的资料来分析不同业务背后对应的不同架构（主要来源于『聊聊架构』微信公众号）。</p>
<p>具体涉及的知识点主要有：</p>
<p><img src="/images/14586760521793.jpg" alt=""></p>
<p>具体涉及的业务分析有：</p>
<ul>
<li>58 同城架构优化</li>
<li>Etsy 研发体系构建</li>
<li>豆瓣研发管理</li>
<li>蘑菇街运维体系</li>
<li>Qzone 架构设计</li>
<li>当当网架构优化</li>
<li>携程异步消息系统架构设计</li>
<li>支付宝红包高并发</li>
<li>eBay 微服务生态系统</li>
<li>Twitter 高性能分布式日志</li>
<li>LinkedIn 架构演进</li>
<li>Uber 架构重构经验</li>
<li>京东商品搜索系统架构设计</li>
<li>IFTTT 的数据架构</li>
<li>美团架构</li>
<li>Spotify 运维监控体系</li>
<li>酷狗大数据平台重构</li>
<li>魅族云同步架构</li>
<li>微博推荐系统架构</li>
<li>1 号店分布式搜索引擎架构</li>
<li>Airbnb 架构</li>
</ul>
<p>我个人是很希望能写好这个系列的，因为在不断的学习和思考的过程中，能够慢慢培养自己的架构思考模式。另外之所以把这个系列取名为『架与构』，是为了提醒自己设计和实现是不可分割的部分，『架』得再好，『构』不出来也没用。所谓『脚踏实地，仰望星空』，大概就是这个道理。</p>
<p>与诸君共勉。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>做架构师是我从刚开始接触计算机科学时的梦想，现在，是时候为了这个梦想而做一些沉淀了。这个系列会写不同的架构概念，写不同的实际系统分析，写自己的想法和思考。</p>]]>
    
    </summary>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
