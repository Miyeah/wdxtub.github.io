<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-03-09T04:37:59.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[云计算 Twitter 语料分析 4 Heartbeat 与 Authetication]]></title>
    <link href="http://wdxtub.com/2016/03/08/cc-p4/"/>
    <id>http://wdxtub.com/2016/03/08/cc-p4/</id>
    <published>2016-03-09T01:44:19.000Z</published>
    <updated>2016-03-09T04:37:59.000Z</updated>
    <content type="html"><![CDATA[<p>前面两课我们已经配置好了基本的环境，之后的任务都会在前面的基础上完成。因为主要会使用 undertow，所以我们制作了自己的镜像，用于对比的 vertx 则仍旧会以手动的方式进行配置。</p>
<a id="more"></a>
<hr>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>因为没有制作对应的镜像，所以需要重新配置一次，不过这次为了性能考虑，直接开启一个 <code>m4.large</code>，注意需要打上 <code>15619project:phase1</code> 标签。正常开启（记得要用小组的帐号）之后我们用<a href="http://wdxtub.com/2016/03/01/cc-p3/">Vert.x 配置部署</a>的步骤配置好基本的环境并检测运行，确认无误后可以继续。</p>
<p>这一部分的任务比较简单：每个请求都包含 key <code>Y</code> 和一段由 key <code>Z</code> 加密的文本，我们进行解密之后返回指定格式的内容（具体可以参考<a href="http://wdxtub.com/2016/02/25/cc-p1/#Query_1__28Heartbeat_and_Authentication_29">这里</a>）</p>
<h2 id="u9879_u76EE_u65E5_u5FD7"><a href="#u9879_u76EE_u65E5_u5FD7" class="headerlink" title="项目日志"></a>项目日志</h2><p>大概说一下步骤以及需要注意的地方：</p>
<p>要弄清楚 vert.x 如何处理诸如 <code>address/q1?key=40845969093821&amp;message=URYEXYBJB</code> 的请求，并在代码中获取到这两个参数：</p>
<p><img src="/images/14574935033615.jpg" alt="获取参数"></p>
<p>然后需要生成一个时间戳，并按照<a href="http://wdxtub.com/2016/02/25/cc-p1/#Query_1__28Heartbeat_and_Authentication_29">这里</a> 介绍的解密步骤还原出具体信息。</p>
<p>我们组把这部分功能代码封装成了一个类，使用的时候只需要传入 key 和 message 即可，而不用操心具体的算法问题（其实就类似于一个面试的算法题）。</p>
<p>然后我们按照具体的返回格式返回即可，类似下图</p>
<p><img src="/images/14574936621579.jpg" alt="返回结果"></p>
<p>这里有一点需要注意，每次会发送两次 GET 请求（其中一次是请求 favicon 的），要注意做一下错误处理，不然会报错，这还挺奇怪的，我用 safari 就没事，但是用 chrome 就不行，chrome 第二次请求就不带参数了，但是 safari 会带。</p>
<p>后来这个问题改成 80 端口即可，不过需要先 <code>sudo su</code> 才能监听。</p>
<p>因为这部分只是用来对比评测，所以没有进一步优化，大概能跑到 2W RPS 左右，而且是纯单线程，延迟会比较大，不过之后主要会在 undertow 上做，所以这里就不进一步优化了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面两课我们已经配置好了基本的环境，之后的任务都会在前面的基础上完成。因为主要会使用 undertow，所以我们制作了自己的镜像，用于对比的 vertx 则仍旧会以手动的方式进行配置。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Vertx" scheme="http://wdxtub.com/tags/Vertx/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="服务" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 习题课 5 Shelllab]]></title>
    <link href="http://wdxtub.com/2016/03/08/csapp-lab5/"/>
    <id>http://wdxtub.com/2016/03/08/csapp-lab5/</id>
    <published>2016-03-08T18:47:44.000Z</published>
    <updated>2016-03-09T18:43:40.000Z</updated>
    <content type="html"><![CDATA[<p>这次的作业，我们需要自己完成一个简单的 shell 程序，通过具体的实现，我们可以更加深入地计算机运行的机制（尤其是 Exceptional Control Flow 和进程）。</p>
<a id="more"></a>
<hr>
<p>在具体开始这次的试验之前，最好先复习一下基本概念（具体的细节可以参考前面的几课），这里放在文末的附录中。</p>
<p>这次的任务不简单！但是老师提供了很多辅助函数，确定先读懂已有代码再开始（注意代码风格），需要仔细查看的 man pages：</p>
<ul>
<li><code>sigemptyset()</code></li>
<li><code>sigaddset()</code></li>
<li><code>sigprocmask()</code></li>
<li><code>sigsuspend()</code></li>
<li><code>waitpid()</code></li>
<li><code>open()</code></li>
<li><code>dup2()</code></li>
<li><code>setpgid()</code></li>
<li><code>kill()</code></li>
</ul>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>先把文件上传到学校的机器中 <code>scp tshlab-handout.tar dawang@shark.ics.cs.cmu.edu:~/513</code>，然后登录上去 <code>ssh -X dawang@shark.ics.cs.cmu.edu</code>，登录成功后解压 <code>tar xvf tshlab-handout.tar</code></p>
<p>因为我比较习惯在本地写代码，所以把文件复制回来：</p>
<ul>
<li>服务器至本地<ul>
<li>scp -r dawang@shark.ics.cs.cmu.edu:~/513/tshlab-handout/* ./</li>
</ul>
</li>
<li>本地至服务器<ul>
<li>scp -r ./ dawang@shark.ics.cs.cmu.edu:~/513/tshlab-handout/* </li>
</ul>
</li>
</ul>
<p>然后需要在 <code>tsh.c</code> 中填写 Andrew ID，这个文件中已经包含了一个基本的 shell 程序，但是还有很多东西没有完成，我们的任务是补全下列空函数：</p>
<ul>
<li><code>void eval(char *cmdline)</code>：解析命令与执行，约 300 行</li>
<li><code>void sigchld_handler(int sig)</code>：捕获 SIGCHLD 信号</li>
<li><code>void sigtstp_handler(int sig)</code>：捕获 SIGTSTP(ctrl-z) 信号</li>
<li><code>void sigint_handler(int sig)</code>：捕获 SIGINT(ctrl-c) 信号</li>
</ul>
<p>测试的时候先 <code>make</code> 然后 <code>./tsh</code> 即可，不过一开始好像没办法退出</p>
<h2 id="Shell__u7B80_u4ECB"><a href="#Shell__u7B80_u4ECB" class="headerlink" title="Shell 简介"></a>Shell 简介</h2><p>简单来说，shell 有两种执行模式：</p>
<ol>
<li>如果用户输入的命令是内置命令，那么 shell 会直接在当前进程执行（例如 <code>jobs</code>）</li>
<li>如果用户输入的是一个可执行程序的路径，那么 shell 会 fork 出一个新进程，并且在这个子进程中执行该程序（例如 <code>/bin/ls -l -d</code>）</li>
</ol>
<p>第二种情况中，每个子进程称为一个 job（当然也可以不止一个，通过管道机制，不过我们这里的实现不需要考虑管道）</p>
<p>如果命令以 <code>&amp;</code> 结束，那么这个 job 会在后台执行（比如 <code>/bin/ls -l -d &amp;</code>），也就是说 shell 本身不会等待 job 执行完成，直接可以继续输入其他命令；而在其他情况下，则是在前台运行，shell 会等待 job 完成，用户才可以继续输入命令。也就是说同一个时间只可能有一个前台任务，但是后台任务可以有任意多个。</p>
<p>程序的入口是 <code>int main(int argc, char *argv[])</code>，对于 <code>/bin/ls -l -d</code> 来说，我们有：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">argc</span> == <span class="number">3</span></span><br><span class="line"><span class="built_in">argv</span>[<span class="number">0</span>] == <span class="string">''</span>/bin/<span class="keyword">ls</span><span class="string">''</span></span><br><span class="line"><span class="built_in">argv</span>[<span class="number">1</span>] == <span class="string">''</span>-<span class="keyword">l</span><span class="string">''</span></span><br><span class="line"><span class="built_in">argv</span>[<span class="number">2</span>] == <span class="string">''</span>-<span class="keyword">d</span><span class="string">''</span></span><br></pre></td></tr></table></figure>
<p>另外两个需要支持功能是：</p>
<ul>
<li>job control：允许用户更改进程的前台/后台状态以及京城的状态(running, stopped, or terminated)<ul>
<li>ctrl-c 会触发 SIGINT 信号并发送给每个前台进程，默认的动作是终止该进程</li>
<li>ctrl-z 会触发 SIGTSTP 信号并发送给每个前台进程，默认的动作是挂起该进程，直到再收到 SIGCONT 信号才继续</li>
<li><code>jobs</code> 命令会列出正在执行和被挂起的后台任务</li>
<li><code>bg job</code> 命令可以让一个被挂起的后台任务继续执行</li>
<li><code>fg job</code> 命令可以让一个被挂起的前台任务继续执行</li>
</ul>
</li>
<li>I/O redirection：重定向输入输出<ul>
<li><code>tsh&gt; /bin/ls &gt; foo</code></li>
<li><code>tsh&gt; /bin/cat &lt; foo</code></li>
</ul>
</li>
</ul>
<h2 id="u4EFB_u52A1_u76EE_u6807"><a href="#u4EFB_u52A1_u76EE_u6807" class="headerlink" title="任务目标"></a>任务目标</h2><p>我们正在使用的 shell 其实包含很多复杂的功能，不过我们自己写的 shell 就简单很多，这里总结一下具体的实现规格：</p>
<ul>
<li>每一行会输出一个 <code>tsh&gt;</code>，然后等待用户输入</li>
<li>用户的输入包括 <code>name</code> 加上零个或多个参数，这些参数之间用一个或多个空格分隔。如果 <code>name</code> 是内置命令，那么直接执行，否则需要新建一个子进程，并在子进程中完成具体的工作</li>
<li>不需要支持管道，但是需要支持输入输出重定向，如 <code>tsh&gt; /bin/cat &lt; foo &gt; bar</code>（必须支持在同一行重定向输入以及输出）<ul>
<li>也需要支持内置命令的重定向，如 <code>tsh&gt; jobs &gt; foo</code> </li>
</ul>
</li>
<li>输入 <code>ctrl-c</code> 或 <code>ctrl-z</code> 会给当前的前台进程（包括其子进程）发送 SIGINT(SIGTSTP) 信号，如果没有前台任务，那么这俩信号没有任何效果</li>
<li>如果输入的命令以 <code>&amp;</code> 结尾，那么就要以后台任务的方式执行，否则按照前台执行</li>
<li>每个 job 都有其进程 ID(PID) 和 job ID(JID)，都是由 tsh 指定的正整数，JID 以 <code>%</code> 开头（如 <code>%5</code> 表示 JID 为 5，而 <code>5</code> 则表示 PID 为 5），这部分已提供了辅助函数</li>
<li>支持的内置命令有<ul>
<li><code>quit</code> 退出 shell</li>
<li><code>jobs</code> 列出所有的后台任务</li>
<li><code>bg job</code> 给后台 <code>job</code> 发送 SIGCONT 信号来继续执行该任务，具体的 <code>job</code> 数值可以是 PID 或 JID</li>
<li><code>fg job</code> 给前台 <code>job</code> 发送 SIGCONT 信号来继续执行该任务，具体的 <code>job</code> 数值可以是 PID 或 JID</li>
</ul>
</li>
<li>tsh 应该回收所有的僵尸进程，如果任何 job 因为接收了没有 catch 的信号而终止，tsh 应该识别出这个时间并且打印出 JID 和相关信号的信息</li>
</ul>
<h2 id="u6D4B_u8BD5_u65B9_u6CD5"><a href="#u6D4B_u8BD5_u65B9_u6CD5" class="headerlink" title="测试方法"></a>测试方法</h2><p>最简单（也是首先应该做的）是直接运行 tsh，然后输入命令试试看。如果需要参考，可以试试 <code>tshref</code> 这个程序。确定无误之后可以进行完整测试。</p>
<p>这里我们用 trace 文件来测试，具体使用命令 <code>./runtrace</code> 来测试，具体用法如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">./runtrace -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试某个特性</span></span><br><span class="line">./runtrace <span class="operator">-f</span> trace05.txt <span class="operator">-s</span> ./tsh</span><br></pre></td></tr></table></figure>
<p>如果想要进行完整的测试，可以使用 <code>./sdriver</code>，具体用法如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">./sdriver -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般来说可以直接使用默认设置测试</span></span><br><span class="line">./sdriver</span><br></pre></td></tr></table></figure>
<p>只需要提交 <code>tsh.c</code> 即可，系统会自动评分，具体每个文件在测试的内容是：</p>
<p><img src="/images/14575490108688.jpg" alt="trace 文件内容"></p>
<h2 id="u63D0_u793A"><a href="#u63D0_u793A" class="headerlink" title="提示"></a>提示</h2><ul>
<li>不要使用 <code>sleep()</code> 来同步</li>
<li>不要使用忙等待 <code>while(1);</code></li>
<li>使用 <code>sigsuspend</code> 来同步</li>
<li>竞争条件</li>
<li>僵尸进程回收（注意竞争条件以及正确处理信号）</li>
<li>等待前台任务（仔细思考怎么样才是好的方式）</li>
<li>不要假定进程的执行顺序</li>
<li>子进程挂掉的时候应该在一个限定时间内被回收</li>
<li>不要在多个地方调用 <code>waitpid</code>，很容易造成竞争条件，也会造成程序过分复杂</li>
<li>不要使用任何系统调用来管理 terminal group</li>
<li><code>waitpid</code>, <code>kill</code>, <code>fork</code>, <code>execve</code>, <code>setpgid</code>, <code>sigprocmask</code> 和 <code>sigsuspend</code> 都非常有用，<code>waitpid</code> 中的 WUNTRACED 和 WNOHANG 选项也是如此。</li>
<li>遇到不清晰的用 <code>man</code> 来查看细节</li>
<li>实现 signal handler 的时候注意给全部的前台进程组发送 SIGINT 和 SIGTSTP 信号</li>
<li>在 <code>kill</code> 函数中使用 <code>-pid</code> 的格式作为参数</li>
<li>在 shell 等待前台工作完成时，需要决定在 <code>eval</code> 及 <code>sigchold handler</code> 具体的分配，这里有一定技巧</li>
<li>在函数 <code>eval</code> 中，在 fork 出子进程之前，必须使用 <code>sigprocmask</code> 来阻塞 SIGCHLD, SIGINT 和 SIGTSTP 信号，完成之后再取消阻塞。调用 <code>addjob</code> 的时候也需要如此。注意，因为子进程也继承了之前的各种状态，所以在子进程中调用 <code>exec</code> 执行新程序的时候注意需要取消阻塞，同样也需要恢复默认的 handler（shell 本身已经忽略了这些信号），具体可以看书本的 8.5.6 节</li>
<li>不要使用 <code>top</code>, <code>less</code>, <code>vi</code>, <code>emacs</code> 之类的复杂程序，使用简单的文本程序如：<code>/bin/cat</code>, <code>/bin/ls</code>, <code>/bin/ps</code>, <code>/bin/echo</code></li>
<li>因为毕竟不是真正的 shell，所以在 fork 之后，execve 之前，子进程需要调用 <code>setpgid(0, 0)</code>，这样就把子进程放到一个新的进程组里。这样就保证我们的 shell 前台进程组中唯一的进程，当按下 ctrl-c 时，应该捕获 SIGINT 信号并发送给对应的前台进程组中。</li>
</ul>
<p>同样提供一个 <code>tshref</code> 参考程序来作为比对输出（除了进程 id 之外其他需要一模一样），具体是通过 <code>runtrace</code> 文件来测试，每个 trace 文件会测试一个特性</p>
<h2 id="u9644_u5F55_uFF1A_u57FA_u7840_u77E5_u8BC6"><a href="#u9644_u5F55_uFF1A_u57FA_u7840_u77E5_u8BC6" class="headerlink" title="附录：基础知识"></a>附录：基础知识</h2><p>开始之前需要理解的内容</p>
<h3 id="u5F02_u6B65_u5F02_u5E38_28_u4E2D_u65AD_29"><a href="#u5F02_u6B65_u5F02_u5E38_28_u4E2D_u65AD_29" class="headerlink" title="异步异常(中断)"></a>异步异常(中断)</h3><p><img src="/images/14574791971112.jpg" alt="Asynchronous Exceptions(Interrupts)"></p>
<h3 id="u540C_u6B65_u5F02_u5E38"><a href="#u540C_u6B65_u5F02_u5E38" class="headerlink" title="同步异常"></a>同步异常</h3><p><img src="/images/14574792452633.jpg" alt="Synchronous Exceptions"></p>
<h3 id="u8FDB_u7A0B"><a href="#u8FDB_u7A0B" class="headerlink" title="进程"></a>进程</h3><p><img src="/images/14574793369863.jpg" alt="Definition"></p>
<p><img src="/images/14574793444040.jpg" alt="Four basic States"></p>
<p><img src="/images/14574793738605.jpg" alt="Control States"></p>
<p>fork 函数详细介绍：</p>
<p><img src="/images/14574794567977.jpg" alt="fork"></p>
<p><img src="/images/14574794700303.jpg" alt="fork"></p>
<p>exec 函数详细介绍</p>
<p><img src="/images/14574794860146.jpg" alt="exec"></p>
<p>exit 函数详细介绍</p>
<p><img src="/images/14574795006407.jpg" alt=""></p>
<p>wait 函数详细介绍</p>
<p><img src="/images/14574795185122.jpg" alt=""></p>
<h3 id="u7B80_u5355_u7684_u8FDB_u7A0B_u4F8B_u5B50"><a href="#u7B80_u5355_u7684_u8FDB_u7A0B_u4F8B_u5B50" class="headerlink" title="简单的进程例子"></a>简单的进程例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (child_pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 这部分只有子进程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Child!\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 父进程通过下面这句等待子进程完成，才继续执行</span></span><br><span class="line">    waitpid(child_pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Parent!\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个使用 execvc 的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"><span class="keyword">char</span>* argv[] = &#123;<span class="string">"/bin/ls"</span>, <span class="string">"-l"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="keyword">char</span>* env[] = &#123;..., <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (child_pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 这部分只有子进程执行</span></span><br><span class="line">    execve(<span class="string">"/bin/ls"</span>, argv, env);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为已经被取代，所以 execve 之后的语句将不会被执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 父进程通过下面这句等待子进程完成，才继续执行</span></span><br><span class="line">    waitpid(child_pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 等待子进程结束之后继续执行父线程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Parent!\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u4FE1_u53F7"><a href="#u4FE1_u53F7" class="headerlink" title="信号"></a>信号</h3><p><img src="/images/14574798651564.jpg" alt="Three possible ways to react"></p>
<p><img src="/images/14574798879407.jpg" alt="Ohter Reaction Options"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这次的作业，我们需要自己完成一个简单的 shell 程序，通过具体的实现，我们可以更加深入地计算机运行的机制（尤其是 Exceptional Control Flow 和进程）。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Shelllab" scheme="http://wdxtub.com/tags/Shelllab/"/>
    
      <category term="习题课" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98%E8%AF%BE/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 15 课 System Level I/O]]></title>
    <link href="http://wdxtub.com/2016/03/06/csapp-15/"/>
    <id>http://wdxtub.com/2016/03/06/csapp-15/</id>
    <published>2016-03-06T12:47:39.000Z</published>
    <updated>2016-03-08T18:45:12.000Z</updated>
    <content type="html"><![CDATA[<p>了解完了 Exceptional Control Flow，我们再来看看系统级 IO 的相关内容，完成这一课之后，就可以开始写我们自己的 shell 程序了。</p>
<a id="more"></a>
<hr>
<h2 id="Unix_I/O"><a href="#Unix_I/O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p>在 Linux 中，文件实际上可以看做是字节的序列。更有意思的是，所有的 I/O 设备也是用文件来表示的，比如：</p>
<ul>
<li><code>./dev/sda2</code> (<code>/usr</code> disk partition)</li>
<li><code>/dev/tty2</code> (terminal)</li>
</ul>
<p>甚至连内核也是用文件来表示的：</p>
<ul>
<li><code>/boot/vmlinuz-3.13.0-55-generic</code> (kernel image)</li>
<li><code>/proc</code> (kernel data structures)</li>
</ul>
<p>因为 I/O 设备也是文件，所以内核可以利用称为 Unix I/O 的简单接口来处理输入输出，比如：</p>
<p><img src="/images/14574522789531.jpg" alt="Unix I/O Overview"></p>
<p>为了区别不同文件的类型，会有一个 <code>type</code> 来进行区别：</p>
<ul>
<li>普通文件：包含任意数据</li>
<li>目录：相关一组文件的索引</li>
<li>Socket：和另一台机器上的进程通信的类型</li>
</ul>
<p>其实还有一些比较特别的类型，但是这里提一下，不深入了解：</p>
<ul>
<li>Named pipes(FIFOs)</li>
<li>Symbolic links</li>
<li>Character and block devices</li>
</ul>
<h3 id="Regular_File"><a href="#Regular_File" class="headerlink" title="Regular File"></a>Regular File</h3><p>普通的文件包含任意数据，应用一般来说需要区分出 text files 和 binary files。文本文件只包含 ASCII 或 Unicode 字符。除此之外的都是 binary files(object files, JPEG images, etc)。对于内核来说其实并不能区分出个中的区别。</p>
<p>文本文件就是一系列的文本行，每行以 <code>\n</code> 结尾，新的一行是 <code>0xa</code>，和 ASCII 码中的 line feed 字符(LF) 一样。不同系统用用判断一行结束的符号不同(End of line, EOL)，如：</p>
<ul>
<li>Linux &amp; Mac OS: <code>\n</code>(0xa)<ul>
<li>line feed(LF) </li>
</ul>
</li>
<li>Windows &amp; Internet protocols: <code>\r\n</code> (0xd 0xa)<ul>
<li>Carriage return(CR) followed by line feed(LF)</li>
</ul>
</li>
</ul>
<h3 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a>目录</h3><p>目录包含一个 link 数组，并且每个目录至少包含两条记录：</p>
<ul>
<li><code>.</code>(dot) 当前目录</li>
<li><code>..</code>(dot dot) 上一层目录</li>
</ul>
<p>用来操作目录的命令主要有 <code>mkdir</code>, <code>ls</code>, <code>rmdir</code></p>
<p>目录是以树装结构组织的，跟目录是 <code>/</code>(slash)</p>
<p><img src="/images/14574529458797.jpg" alt="Directory Hierarchy"></p>
<p>内核会为每个进程保存 current working directory (cwd)，可以用 <code>cd</code> 命令来进行更改。</p>
<p>我们通过路径名来确定文件的位置，一般分为绝对路径和相对路径。</p>
<h3 id="u64CD_u4F5C_u6587_u4EF6"><a href="#u64CD_u4F5C_u6587_u4EF6" class="headerlink" title="操作文件"></a>操作文件</h3><p>接下来我们了解一下基本的文件操作。</p>
<p>在使用文件之前需要通知内核打开该文件：</p>
<p><img src="/images/14574530910656.jpg" alt="Opening Files"></p>
<p>返回值是一个小的整型称为 file descriptor（如果这个值等于 -1 则说明发生了错误）。每个由 Linux sheel 创建的进程都会默认打开三个文件：</p>
<ul>
<li>0: standard input(stdin)</li>
<li>1: standard output(stdout)</li>
<li>2: standar error(stderr)</li>
</ul>
<p>使用完毕之后同样需要通知内核关闭文件：</p>
<p><img src="/images/14574532174613.jpg" alt="Closing Files"></p>
<p>如果在此关闭已经关闭了的文件，会出大问题。所以一定要检查返回值，哪怕是 <code>close()</code> 函数（如上面的例子所示）</p>
<p>在打开和关闭之间就是读取文件，实际上就是把文件中对应的字节复制到内存中，并更新文件指针：</p>
<p><img src="/images/14574533193683.jpg" alt="Reading Files"></p>
<p>返回值是读取的字节数量，是一个 <code>ssize_t</code> 类型（其实就是一个 signed integer），如果 <code>nbytes &lt; 0</code> 那么表示出错。<code>nbytes &lt; sizeof(buf)</code> 这种情况(short counts) 是可能发生的，而且并不是错误。</p>
<p>写入文件是把内存中的数据复制到文件中，并更新文件指针：</p>
<p><img src="/images/14574534505640.jpg" alt="Wrting Files"></p>
<p>返回值是写入的字节数量，如果 <code>nbytes &lt; 0</code> 那么表示出错。<code>nbytes &lt; sizeof(buf)</code> 这种情况(short counts) 是可能发生的，而且并不是错误。</p>
<p>综合上面的操作，我们可以来看看 Unix I/O 的例子：</p>
<p><img src="/images/14574535145592.jpg" alt="Copying stdin to stdout, one byte at a time"></p>
<p>前面提到的 short count 会在下面的情形下发生：</p>
<ul>
<li>在读取的时候遇到 EOF(end-of-file)</li>
<li>从终端中读取文本行</li>
<li>读取和写入网络 sockets</li>
</ul>
<p>但是在下面的情况下不会发生</p>
<ul>
<li>从磁盘文件中读取（除 EOF 外）</li>
<li>写入到磁盘文件中</li>
</ul>
<p>最好总是允许 short count，这样就可以避免处理这么多不同的情况。</p>
<h2 id="Robust_I/O"><a href="#Robust_I/O" class="headerlink" title="Robust I/O"></a>Robust I/O</h2><p>RIO 实际上就是一个包装，用来在不同的应用中提供强壮的 IO 接口，主要有一下两类：</p>
<p><img src="/images/14574544870012.jpg" alt="The RIO Package"></p>
<p>可以从<a href="http://csapp.cs.cmu.edu/3e/code.html" target="_blank" rel="external">这里</a> 中下载（<code>src/csapp.c</code> 和  <code>include/csapp.h</code>）</p>
<p>无缓存的输入输出和 Unix 的 <code>read</code> 和 <code>write</code> 接口一致，如果要通过 network sockets 来传输数据，就非常拥有了：</p>
<p><img src="/images/14574546347971.jpg" alt="Unbuffered ROI Input and Output"></p>
<p>具体的实现是：</p>
<p><img src="/images/14574547191767.jpg" alt="Implementation of `rio_readn`"></p>
<p>有缓存的输入在从文件中读取数据的时候通过内置的内存缓冲区提高效率：</p>
<p><img src="/images/14574547952581.jpg" alt="Buffered RIO Input Functions"></p>
<p><img src="/images/14574548277481.jpg" alt=""></p>
<p>具体的实现如下：</p>
<p><img src="/images/14574548545398.jpg" alt="Buffered I/O: Implementation"></p>
<p>对应的结构体是：</p>
<p><img src="/images/14574549507104.jpg" alt=""></p>
<p>这是一个对应的例子：</p>
<p><img src="/images/14574549871674.jpg" alt="Copying the lines of a text file from standar input to standard output"></p>
<h2 id="Metadata_2C_Sharing__26amp_3B_Redirection"><a href="#Metadata_2C_Sharing__26amp_3B_Redirection" class="headerlink" title="Metadata, Sharing &amp; Redirection"></a>Metadata, Sharing &amp; Redirection</h2><p>元数据是用来描述数据的数据，由内核维护，可以通过 <code>stat</code> 和 <code>fstat</code> 函数来访问，其结构是：</p>
<p><img src="/images/14574550707059.jpg" alt="File Metadata"></p>
<p>对应的访问例子：</p>
<p><img src="/images/14574551947810.jpg" alt="Example of Accessing File Metadata"></p>
<p>了解了具体的结构之后，我们来看看内核是如何表示打开的文件的。其实过程很简单，每个进程都有自己的 Descriptor table，然后 Descriptor 1 指向终端，Descriptor 4 指向磁盘文件，如下图所示：</p>
<p><img src="/images/14574553689850.jpg" alt="How the Unix Kernel Represents Open Files"></p>
<p>两个不同的 descriptors 通过两个不同的 open file 记录来共享同一个磁盘文件（对应指向同一个 v-noe table）。</p>
<p>这里有一个需要说明的情况，就是使用 <code>fork</code>。子进程实际上是会继承父进程打开的文件，在调用 <code>fork</code> 之前，我们假设情况是这样的：</p>
<p><img src="/images/14574555865284.jpg" alt="Before fork call"></p>
<p>在 fork 之后，子进程实际上和父进程的指向是一样的，这里需要注意的是会把 <code>refcnt</code> 加上 1（也就是引用计数加 1）</p>
<p><img src="/images/14574556597788.jpg" alt="After fork"></p>
<p>了解了这个，我们我们就可以知道所谓的重定向是怎么实现的了。其实很简单，只要调用 <code>dup2(oldfd, newfd)</code> 函数即可。具体如下：</p>
<p><img src="/images/14574609050965.jpg" alt="I/O Redirection"></p>
<p>Step #1: open file to which stdout should be redirected(happends in child executing shell code, before <code>exec</code>)</p>
<p><img src="/images/14574609981392.jpg" alt="Step #1: open file to which stdout should be redirected"></p>
<p>Step #2: call <code>dup2(4,1)</code> -&gt; cause fd=1(stdout) to refer to disk file pointed at fd=4</p>
<p><img src="/images/14574613741105.jpg" alt="Step #2: call `dup2(4,1)`"></p>
<h2 id="Standar_I/O"><a href="#Standar_I/O" class="headerlink" title="Standar I/O"></a>Standar I/O</h2><p>C 标准库中包含一系列高层的标准 IO 函数，一些具体的函数：</p>
<p><img src="/images/14574614463046.jpg" alt="Examples of standard I/O functions"></p>
<p>标准 IO 会用流的形式打开文件，所谓流(stream)实际上是 file descriptor 和 buffer 在内存中的抽象。C 程序一般以三个流开始，如下所示：</p>
<p><img src="/images/14574615606437.jpg" alt="Standard I/O Streams"></p>
<p>接下来我们详细了解一下为什么需要使用缓冲区，程序经常会一次读入或者写入一个字符，比如 <code>getc</code>, <code>putc</code>, <code>ungetc</code>，同时也会一次读入或者写入一行，比如 <code>gets</code>, <code>fgets</code>。如果用 Unix I/O 的方式来进行调用，是非常昂贵的，比如说 <code>read</code> 和 <code>write</code> 因为需要内核调用，需要大于 10000 个时钟周期。</p>
<p>解决的办法就是利用 <code>read</code> 函数一次读取一块数据，然后再由高层的接口，一次从缓冲区读取一个字符（当缓冲区用完的时候需要重新填充），例如：</p>
<p><img src="/images/14574622326310.jpg" alt="Buffering in Standard I/O"></p>
<p>具体来看看这个例子：</p>
<p><img src="/images/14574622882078.jpg" alt="Standard I/O Buffering in Action"></p>
<p>注意右边的输出，实际上只写入了一次，一次六个字符，而不是程序中写的六次（这里好好感受下）</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>前面介绍了几种不同的 IO，它们的层级如下所示：</p>
<p><img src="/images/14574624849987.jpg" alt="Unix I/O vs. Standard I/O vs. RIO"></p>
<p>Unix I/O 的优劣：</p>
<p><img src="/images/14574625259926.jpg" alt="Pros and Cons of Unix I/O"></p>
<p>Standard I/O 的优劣：</p>
<p><img src="/images/14574625620916.jpg" alt="Pros and Cons of Standard I/O"></p>
<p>具体的选择建议为：</p>
<p><img src="/images/14574626154586.jpg" alt="Choosing I/O Functions"></p>
<p>最后是处理 binary files 的守则：</p>
<p><img src="/images/14574626867246.jpg" alt="Working with Binary Files"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解完了 Exceptional Control Flow，我们再来看看系统级 IO 的相关内容，完成这一课之后，就可以开始写我们自己的 shell 程序了。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="IO" scheme="http://wdxtub.com/tags/IO/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 14 课 Signals and Nonlocal Jumps]]></title>
    <link href="http://wdxtub.com/2016/03/06/csapp-14/"/>
    <id>http://wdxtub.com/2016/03/06/csapp-14/</id>
    <published>2016-03-06T12:47:36.000Z</published>
    <updated>2016-03-07T21:53:55.000Z</updated>
    <content type="html"><![CDATA[<p>了解完了异常与进程，异常处理中另外两个很重要的部分是信号和非局部跳转，也就是我们这节课要介绍的内容。</p>
<a id="more"></a>
<hr>
<p>Linux 的进程树，可以通过 <code>pstree</code> 命令查看，如下：</p>
<p><img src="/images/14573806185809.jpg" alt="Linux Process Hierarchy"></p>
<p>我们以 shell 为例子，来看看整个过程是如何实现的：</p>
<p><img src="/images/14573806718703.jpg" alt="Shell: Execution is a sequence of read/evaluate steps"></p>
<p><img src="/images/14573807472000.jpg" alt="Simple Shell eval Function"></p>
<p>如果只有前台进程的话，我们的 shell 可以在前台工作完成之后进行回收。但是后台进程则会在终止之后成为僵尸进程，不会被回收并且造成内存泄露。</p>
<p>这怎么办呢？同样可以利用 Exceptional control flow，当后台进程完成时，内核会中断常规执行并通知我们，具体的通知机制就是『信号』(signal)。</p>
<h2 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h2><blockquote>
<p>A signal is a small message that notifies a process that an event of some type has occurred in the system</p>
</blockquote>
<p>这样看来，其实是类似于 exception 和 interrupt 的，是由内核（在其他进程的请求下）向当前进程发出的。信号的类型由 1-30 的整数定义，信号所能携带的信息极少，一是对应的编号，二就是信号到达这个事实。下面是几个比较常用的信号的编号及简介：</p>
<p><img src="/images/14573811635888.jpg" alt=""></p>
<blockquote>
<p>Kernel sends a signal to a destination process by updating some state in the context of the destination process</p>
</blockquote>
<p>在下面两个场景中，内核会发送信号：</p>
<ul>
<li>内核检测到了如除以零(SIGFPE)或子进程终止(SIGCHLD)的系统事件</li>
<li>另一个进程调用了 <code>kill</code> 指令来请求内核发送信号给指定的进程</li>
</ul>
<blockquote>
<p>A destination process receives a signal when it is forced by the kernel to react in some way to the delivery of the signal</p>
</blockquote>
<p>一个进程在接收到了信号之后，可以有几种不同的操作：</p>
<ul>
<li><strong>忽略</strong>这个型号</li>
<li><strong>终止</strong>进程</li>
<li><strong>捕获</strong>信号，通过执行 signal handler 完成（类似于异步中断中的 exception handler）</li>
</ul>
<p>具体的过程如下：</p>
<p><img src="/images/14573814877982.jpg" alt=""></p>
<blockquote>
<p>A signal is pending if sent but not yet received</p>
</blockquote>
<p>同类型的信号至多只会有一个 pending signal，一定要注意这个特性，因为内部实现机制不可能提供较复杂的数据结构，所以信号的接收并不是一个队列。(If a process has a pending signal of type k, then subsequent signals of type k that are sent to that process are discarded)</p>
<p>一个 pending signal 至多只能被收到一次。</p>
<blockquote>
<p>A process can block the receipt of certain signals</p>
</blockquote>
<p>被阻塞的信号仍然可以发送，但是知道不阻塞之后才能被接收</p>
<p>内核用 pending 位向量 和 blocked 位向量来维护每个进程的信号相关状态</p>
<ul>
<li>pending: represents the set of pending signals<ul>
<li>Kernel sets bit k in <strong>pending</strong> when a signal of type k is delivered</li>
<li>Kernel clears bit k in <strong>pending</strong> when a signal of type k is received </li>
</ul>
</li>
<li>blocked: represent the set of blocked signals<ul>
<li>Can be set and cleared by using <code>sigprocmask</code> 函数</li>
<li>Also referred to as the <strong>signal mask</strong></li>
</ul>
</li>
</ul>
<p><strong>进程组</strong></p>
<p>每个进程都只属于一个进程组，如下图所示：</p>
<p><img src="/images/14573820359900.jpg" alt=""></p>
<p>我们可以据此指定一个进程组或者一个单独的进程，如：</p>
<p><img src="/images/14573821103841.jpg" alt="Sending Signals with `/bin/kill` Program"></p>
<p>这里可以看到，第一个命令只会杀掉编号为 24818 的进程，但是第二个命令，因为有两个进程都属于进程组 24817，所以会杀掉进程组中的每个进程。</p>
<p>键盘同样可以让内核向每个前台进程发送 SIGINT(SIGTSTP) 信号</p>
<ul>
<li>SIGINT - default action is to terminate each process</li>
<li>SIGTSTP - default action is to stop(suspend) each process</li>
</ul>
<p><img src="/images/14573823408948.jpg" alt="Example of ctrl-c and ctrl-z"></p>
<p>我们可以可以通过 <code>kill</code> 函数来发送信号：</p>
<p><img src="/images/14573824038965.jpg" alt="Sending Signals with kill Function"></p>
<h2 id="u63A5_u6536_u4FE1_u53F7"><a href="#u63A5_u6536_u4FE1_u53F7" class="headerlink" title="接收信号"></a>接收信号</h2><p>所有的上下文切换都是通过调用某个 exception handler 完成的，内核会计算对易于某个进程 p 的 pnb 值：<code>pnb = pending &amp; ~blocked</code></p>
<ul>
<li>如果 <code>pnb == 0</code><ul>
<li>那么就把控制交给进程 p 的逻辑流中的下一条指令</li>
</ul>
</li>
<li>否则<ul>
<li>选择 <code>pnb</code> 中最小的非零位 k，并强制进程 p 接收信号 k</li>
<li>接收到信号之后，进程 p 会执行对应的动作</li>
<li>对 <code>pnb</code> 中所有的非零位进行这个操作</li>
<li>最后把控制交给进程 p 的逻辑流中的下一条指令</li>
</ul>
</li>
</ul>
<p><strong>默认动作</strong></p>
<p>每个信号类型都有一个预定义的『默认动作』，可能是以下的情况：</p>
<ul>
<li>终止进程</li>
<li>终止进程并 dump core</li>
<li>停止进程，收到 <code>SIGCONT</code> 信号之后重启</li>
<li>忽略信号</li>
</ul>
<p><code>signal</code> 函数可以修改默认的动作：<code>handler_t *signal(int signum, handler_t *handler)</code>，具体来说：</p>
<p><img src="/images/14573845678378.jpg" alt="Different values for handler"></p>
<p>我们再通过具体的代码来感受下：</p>
<p><img src="/images/14573846209836.jpg" alt="Signal Handling Example"></p>
<p>可以这么理解 signal handler：</p>
<blockquote>
<p>A signal handler is a separate logical flow(not process) that runs concurrently with the main program</p>
</blockquote>
<p>如下图所示：</p>
<p><img src="/images/14573846875850.jpg" alt="Signals Handlers as Concurrent Flows"></p>
<p><img src="/images/14573847143072.jpg" alt="Another View of Signal Handlers as Concurrent Flows"></p>
<p>还是有一个需要注意的是，handler 也可以被其他的 handler 中断，控制流如下图所示：</p>
<p><img src="/images/14573848399013.jpg" alt="Nested Signal Handlers"></p>
<h2 id="u963B_u585E/_u4E0D_u963B_u585E_u4FE1_u53F7"><a href="#u963B_u585E/_u4E0D_u963B_u585E_u4FE1_u53F7" class="headerlink" title="阻塞/不阻塞信号"></a>阻塞/不阻塞信号</h2><p>隐式的机制是，内核会阻塞与当前在处理的信号同类型的其他 pending signal，也就是说，一个 SIGINT handler 是不能被另一个 SIGINT 信号中断的。</p>
<p>如果想要显式阻塞，就需要使用 <code>sigprocmask</code> 函数了，以及其他一些辅助函数：</p>
<ul>
<li><code>sigemptyset</code> - Create empty set</li>
<li><code>sigfillset</code> - Add every signal number to set</li>
<li><code>sigaddset</code> - Add signal number to set</li>
<li><code>sigdelset</code> - Delete signal number from set</li>
</ul>
<p>我们可以用下面折断代码来临时阻塞特定的信号：</p>
<p><img src="/images/14573850645959.jpg" alt="Temporarily Blocking Signals"></p>
<h2 id="u5B89_u5168_u5730_u5904_u7406_u4FE1_u53F7"><a href="#u5B89_u5168_u5730_u5904_u7406_u4FE1_u53F7" class="headerlink" title="安全地处理信号"></a>安全地处理信号</h2><blockquote>
<p>Handlers are tricky because they are concurrent with main program and share the same global data structures</p>
</blockquote>
<p>尤其要注意因为并行访问可能导致的数据损坏的问题，这里提供一些基本的指南（后面的课程会详细介绍）</p>
<p><img src="/images/14573852332585.jpg" alt="Guidelines for Writing Safe Handlers"></p>
<p>另外一个需要注意的问题是 Async-Signal-Safety。</p>
<blockquote>
<p>Function is async-signal-safe if either reentrant(all variables sotred on stack frame) or non-interruptible by signals</p>
</blockquote>
<p>Posix 标准指定了 117 个 async-signal-safe 的函数（可以通过 <code>man 7 signal</code> 查看）</p>
<p><img src="/images/14573853746526.jpg" alt="许多常用的函数都不是 async-signal-safe 的"></p>
<p>因为输出函数不是 async-signal-safe 的，所以最好使用课本中提供的 <code>csapp.c</code> 中的相关 handler</p>
<ul>
<li><code>ssize_t sio_puts(char s[])</code> - Put string</li>
<li><code>ssize_t sio_putl(long v)</code> - Put long</li>
<li><code>void sio_error(char s[])</code> - Put msg &amp; exit</li>
</ul>
<p><img src="/images/14573854667518.jpg" alt=""></p>
<p>正确的信号处理方法：</p>
<ul>
<li>You can’t use signals to count events, such as children terminating</li>
<li>Must wait for all terminated child processes.</li>
</ul>
<p><img src="/images/14573856728934.jpg" alt="Put `wait` in a loop to reap all terminated children"></p>
<p>还有一个问题，不同 Unix 版本有不同的 signal handling semantics，我们给出的解决方案是使用 <code>sigaction</code>，如下：</p>
<p><img src="/images/14573860066787.jpg" alt="Portable Signal Handling"></p>
<h2 id="u907F_u514D_u8FDB_u7A0B_u7ADE_u4E89"><a href="#u907F_u514D_u8FDB_u7A0B_u7ADE_u4E89" class="headerlink" title="避免进程竞争"></a>避免进程竞争</h2><p>我们之前的 shell 代码会出现微妙的同步错误，因为我们假设父进程会在子进程之前执行，代码如下：</p>
<p><img src="/images/14573866195444.jpg" alt=""></p>
<p><img src="/images/14573866343912.jpg" alt=""></p>
<p>我们需要在循环中添加同步条件，确保父进程和子进程的顺序（注意比较）</p>
<p><img src="/images/14573867961969.jpg" alt="Corrected Shell Program without Race"></p>
<h2 id="u663E_u5F0F_u7B49_u5F85_u4FE1_u53F7"><a href="#u663E_u5F0F_u7B49_u5F85_u4FE1_u53F7" class="headerlink" title="显式等待信号"></a>显式等待信号</h2><p>我们也可以用类似与等待前台任务执行的方式来等待子进程，方法如下：</p>
<p><img src="/images/14573869619954.jpg" alt="Handlers for program explicitly waiting for SIGCHLD to arrive"></p>
<p><img src="/images/14573869910604.jpg" alt="Handlers for program explicitly waiting for SIGCHLD to arrive"></p>
<p>这里的代码是正确的，但是我们注意 <code>while(!pid)</code> 这一句，通过忙等待的方式实现同步，非常浪费资源，而其他方式看起来也不行：</p>
<p><img src="/images/14573870533166.jpg" alt="Other options"></p>
<p>怎么办呢？我们的解决办法是 <code>sigsuspend</code>，函数为：</p>
<p><code>int sigsuspend(const sigset_t *mask)</code></p>
<p>等同于 atomic 版本的：</p>
<p><img src="/images/14573871178306.jpg" alt=""></p>
<p>所以代码如下：</p>
<p><img src="/images/14573871346551.jpg" alt="Wating for Signals with sigsuspend"></p>
<h2 id="Nonlocal_Jump"><a href="#Nonlocal_Jump" class="headerlink" title="Nonlocal Jump"></a>Nonlocal Jump</h2><p>这一部分比较简单，主要是使用 <code>setjmp</code> 与 <code>longjmp</code></p>
<p><img src="/images/14573872756594.jpg" alt="NoNonlocal Jumps: setjmp/longjmp"></p>
<p><img src="/images/14573873026532.jpg" alt="NoNonlocal Jumps: setjmp/longjmp"></p>
<p>我们可以利用这种方式，来跳转到其他的栈帧中，比方说在嵌套函数中，我们可以利用这个快速返回栈底的函数：</p>
<p><img src="/images/14573874602644.jpg" alt=""></p>
<p>但是也有限制，必须在栈中（也就是还没完成）才可以进行跳转，下面的例子中，因为 P2 已经返回，所以不能跳转了：</p>
<p><img src="/images/14573875130970.jpg" alt=""></p>
<p>最后是一个非常清晰的例子：</p>
<p><img src="/images/14573875598038.jpg" alt="A Program that restarts itself when ctrl-c"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这两个基本说完了 exceptional control flow 的全部内容，可能会稍微有点难以理解，我会在后面的习题课中尽可能详细说明。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解完了异常与进程，异常处理中另外两个很重要的部分是信号和非局部跳转，也就是我们这节课要介绍的内容。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="异常" scheme="http://wdxtub.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 13 课 Exceptions and Processes]]></title>
    <link href="http://wdxtub.com/2016/03/06/csapp-13/"/>
    <id>http://wdxtub.com/2016/03/06/csapp-13/</id>
    <published>2016-03-06T12:47:32.000Z</published>
    <updated>2016-03-06T23:16:54.000Z</updated>
    <content type="html"><![CDATA[<p>了解完了链接，我们来看看在程序出错的时候会发生什么事情，这一课我们主要来了解异常与进程。</p>
<a id="more"></a>
<hr>
<p>从开机到关机，CPU 做的工作其实很简单，就是不断读取并执行指令，每次执行一条，整个指令执行的序列，称为 CPU 的控制流。到目前为止，我们已经学过了两种改变控制流的方式：</p>
<ul>
<li>跳转和分支</li>
<li>调用和返回</li>
</ul>
<p>这对应于 program state 的改变。但是这实际上仅仅局限于程序的控制，没有办法去应对更加复杂的情况，比方说 system state 变化的时候：</p>
<ul>
<li>数据从磁盘或者网络适配器到达</li>
<li>指令除以了零</li>
<li>用户按下 ctrl+c</li>
<li>系统的计时器到时间</li>
</ul>
<p>所以我们这里会介绍另一种机制，称为 exceptional control flow。</p>
<h2 id="Exceptional_Control_Flow"><a href="#Exceptional_Control_Flow" class="headerlink" title="Exceptional Control Flow"></a>Exceptional Control Flow</h2><p>Exceptional Control Flow 存在于系统的每个层级：</p>
<p><img src="/images/14572937620861.jpg" alt=""></p>
<p>本节课我们先介绍前两种，下节课介绍后面两种。</p>
<h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><p>An <strong>exception</strong> is a transfer of control to the OS kernel in response to some event (i.e., change in processor state)</p>
<ul>
<li>Kernel 是操作系统常驻内存的一部分</li>
<li>Event: Divide by 0, arithmetic overflow, page fault, I/O request completes, typing ctrl-c</li>
</ul>
<p>具体的过程可以用下图表示：</p>
<p><img src="/images/14572946534326.jpg" alt="Exception 流程"></p>
<p>系统会通过 Exception Table 来确定跳转的位置，每种事件都有对应的唯一的异常编号，发生对应异常时就会调用对应的异常处理代码：</p>
<p><img src="/images/14572947301161.jpg" alt="Exception Table"></p>
<h3 id="Asynchronous_Exceptions__28Interrupts_29"><a href="#Asynchronous_Exceptions__28Interrupts_29" class="headerlink" title="Asynchronous Exceptions (Interrupts)"></a>Asynchronous Exceptions (Interrupts)</h3><p>异步异常称之为中断，是有处理器外面发生的事情引起的，这种情况下：</p>
<ul>
<li>需要设置处理器的 interrupt pin</li>
<li>处理完成后会返回之前控制流中的『下一条』指令</li>
</ul>
<p><img src="/images/14572948483518.jpg" alt="中断的两个例子"></p>
<h3 id="Synchronous_Exceptions"><a href="#Synchronous_Exceptions" class="headerlink" title="Synchronous Exceptions"></a>Synchronous Exceptions</h3><p>同步异常是因为执行某条指令所导致的事件，分为 Traps, Faults 和 Aborts 三种情况：</p>
<p><img src="/images/14572949405706.jpg" alt="同步异常的三种类型"></p>
<p>这里需要注意三种不同类型的处理方式，比方说 Traps 和终端一样，会返回执行『下一条』指令；而 Faults 会重新执行之前触发事件的指令；Aborts 则是直接退出当前的程序。</p>
<p><strong>System Call Example</strong></p>
<p>这里我们来了解一下系统调用 System Calls，系统调用看起来像是函数调用，但其实是走异常控制流的，在 x86-64 系统中，每个系统调用都有一个唯一的 ID，如：</p>
<p><img src="/images/14572951617051.jpg" alt=""></p>
<p>而具体的的调用过程如下所示：</p>
<p><img src="/images/14572951831475.jpg" alt=""></p>
<p><strong>Fault Example</strong></p>
<p>这里卫门以 Page Fault 为例，来说明 Fault 的机制。Page Fault 发生的条件是：</p>
<ul>
<li>用户写入内存位置</li>
<li>但该位置目前还不在内存中</li>
</ul>
<p>比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    a[<span class="number">500</span>] = <span class="number">13</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么系统会通过 Page Fault 把对应的部分载入到内存中，然后重新执行赋值语句：</p>
<p><img src="/images/14572953320001.jpg" alt=""></p>
<p>但是如果代码改为这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    a[<span class="number">5000</span>] = <span class="number">13</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是引用非法地址的时候，整个流程就会变成：</p>
<p><img src="/images/14572953822399.jpg" alt=""></p>
<p>具体来说会像用户进程发送 <code>SIGSEGV</code> 信号，用户进程会以 segmentation fault 的标记退出。</p>
<p>从上面我们就可以看到异常是非常底层的机制。</p>
<h2 id="Process__u8FDB_u7A0B"><a href="#Process__u8FDB_u7A0B" class="headerlink" title="Process 进程"></a>Process 进程</h2><blockquote>
<p>A process is an instance of a running program</p>
</blockquote>
<p>进程是计算机可续中最为重要的思想之一，注意，和 “program” 或 “processor” 都不一样。</p>
<p><img src="/images/14572960158600.jpg" alt="进程示意图"></p>
<p>进程给每个应用提供了两个非常关键的抽象：</p>
<p><img src="/images/14572959919795.jpg" alt="两个关键抽象"></p>
<p>计算机会同时运行多个进程，比如说不同的前台应用，或者后台任务，比方说在 Mac 下输入 <code>top</code>，可以看到如下的进程信息：</p>
<p><img src="/images/14572961362662.jpg" alt="我的电脑当前的状态"></p>
<p>具体的多线程模型如下所示：</p>
<p><img src="/images/14572962685162.jpg" alt="多线程模型（单核）"></p>
<ul>
<li>CPU 交替执行不同的进程</li>
<li>虚拟内存系统会负责管理地址空间</li>
<li>没有执行的进程的寄存器值会被保存在内存中</li>
</ul>
<p><img src="/images/14572963666951.jpg" alt="切换到另一个进程执行，会载入原先的寄存器值(context switch)"></p>
<p>而现代处理器一般有多个核心，所以可以真正同时执行多个进程：</p>
<p><img src="/images/14572964493864.jpg" alt="现代处理器执行模型"></p>
<p>进程之间，也分并行与串行的关系：</p>
<ul>
<li>Two processes run <strong>concurrently</strong> if their flows overlap in time</li>
<li>Otherwise, they are <strong>sequential</strong></li>
</ul>
<p>比方说下图中：</p>
<p><img src="/images/14572965827499.jpg" alt=""></p>
<ul>
<li>Concurrent: A&amp;B, A&amp;C</li>
<li>Sequential: B&amp;C</li>
</ul>
<p>不过在用户看来，执行的感觉是这样的：</p>
<p><img src="/images/14572966466237.jpg" alt=""></p>
<h3 id="Context_Switching"><a href="#Context_Switching" class="headerlink" title="Context Switching"></a>Context Switching</h3><p>具体切换进程时，kernel 会负责具体的调度。</p>
<blockquote>
<p>The kernel is not a separate process, but rather runs as part of some existing process</p>
</blockquote>
<p>控制流通过上下文切换的方式从一个进程到另一个进程，如下图所示：</p>
<p><img src="/images/14572967455790.jpg" alt="上下文切换 Context Switching"></p>
<h2 id="Process_Control__u8FDB_u7A0B_u63A7_u5236"><a href="#Process_Control__u8FDB_u7A0B_u63A7_u5236" class="headerlink" title="Process Control 进程控制"></a>Process Control 进程控制</h2><h3 id="System_Call_Error_Handling"><a href="#System_Call_Error_Handling" class="headerlink" title="System Call Error Handling"></a>System Call Error Handling</h3><p>在遇到错误的时候，Linux 系统级函数通常会返回 -1 并且设置 <code>errno</code> 这个全局变量来表示错误的原因。使用的时候记住两个规则：</p>
<ol>
<li>You must check the return status of every system-level function</li>
<li>Only exception is the handful of functions that return void</li>
</ol>
<p>例如，对于 <code>fork()</code> 函数，我们应该这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"fork error: %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果觉得这样写太麻烦，可以利用一个辅助函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unix_error</span><span class="params">(<span class="keyword">char</span> *msg)</span> <span class="comment">/* Unix-style error */</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: %s\n"</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的片段可以写为</span></span><br><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">"fork error"</span>);</span><br></pre></td></tr></table></figure>
<p>我们甚至可以更进一步，把整个 <code>fork()</code> 包装起来，就可以自带错误处理，比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> Fork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">"Fork error"</span>);</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的时候直接使用 <code>pid = Fork();</code> 即可（注意这里是大写的 F）</p>
<h3 id="u83B7_u53D6_u8FDB_u7A0B_u4FE1_u606F"><a href="#u83B7_u53D6_u8FDB_u7A0B_u4FE1_u606F" class="headerlink" title="获取进程信息"></a>获取进程信息</h3><ul>
<li><code>pid_t getpid(void)</code> - 返回当前进程的 PID</li>
<li><code>pid_t getppid(void)</code> - 返回当前进程的父进程的 PID</li>
</ul>
<p>我们可以认为，进程有三个状态：</p>
<ul>
<li>Running<ul>
<li>正在被执行、正在等待执行或者最终将会被执行</li>
</ul>
</li>
<li>Stopped<ul>
<li>执行被挂起，在进一步通知前不会计划执行</li>
</ul>
</li>
<li>Terminated<ul>
<li>进程被永久停止</li>
</ul>
</li>
</ul>
<p><strong>终止进程</strong></p>
<p>在下面三种情况时，进程会被终止：</p>
<ol>
<li>接收到一个终止信号</li>
<li>返回到 <code>main</code> </li>
<li>调用了 <code>exit</code> 函数</li>
</ol>
<p><img src="/images/14573038632263.jpg" alt="exit is called once but never returns"></p>
<p><strong>创建进程</strong></p>
<p>调用 <code>fork</code> 来创造新进程</p>
<p><img src="/images/14573039229956.jpg" alt="fork is interesting becasue it is called once but returns twice"></p>
<p>下面我们来看一个简单的例子：</p>
<p><img src="/images/14573039725814.jpg" alt=""></p>
<p>有以下几点需要注意：</p>
<ul>
<li>调用一次，但是会有两个返回值</li>
<li>并行执行，不能预计父进程和子进程的执行顺序</li>
<li>拥有自己独立的地址空间（也就是变量都是独立的），除此之外其他都相同</li>
<li>在父进程和子进程中 <code>stdout</code> 是一样的</li>
</ul>
<h3 id="u8FDB_u7A0B_u56FE"><a href="#u8FDB_u7A0B_u56FE" class="headerlink" title="进程图"></a>进程图</h3><p>进程图是一个很好的帮助我们理解进程执行的工具：</p>
<ul>
<li>每个节点代表一条执行的语句</li>
<li>a -&gt; b 表示 a 在 b 前面执行</li>
<li>边可以用当前变量的值来标记</li>
<li><code>printf</code> 节点可以用输出来进行标记</li>
<li>每个图由一个入度为 0 的节点作为起始</li>
</ul>
<p>对于进程图来说，只要满足拓扑排序，就是可能的输出。我们还是用刚才的例子：</p>
<p><img src="/images/14573044246995.jpg" alt=""></p>
<p>我们再来看三个稍微复制一点的例子：</p>
<p><img src="/images/14573045555520.jpg" alt="Two consecutive forks"></p>
<p><img src="/images/14573045862749.jpg" alt="Nested forks in parent"></p>
<p><img src="/images/14573046274270.jpg" alt="Nested forks in children"></p>
<h3 id="Reaping_Child_Processes"><a href="#Reaping_Child_Processes" class="headerlink" title="Reaping Child Processes"></a>Reaping Child Processes</h3><p>即使进程已经终止，也还在消耗系统资源，我们称之为『僵尸』。为了『打僵尸』，就可以采用『收割』(Reaping) 的方法。父进程利用 <code>wait</code> 或 <code>waitpid</code> 回收已终止的子进程，然后给系统提供相关信息，kernel 就会把 zombie child process 给删除。</p>
<p>如果父进程不『收割』的话，通常来说会被 <code>init</code> 进程(pid == 1)回收，所以一般不必显式回收。但是在长期运行的进程中，就需要显式回收（例如 shell 和 server）。下面是几个僵尸进程的例子：</p>
<p><img src="/images/14573049855888.jpg" alt="这里，子进程可以成功被回收"></p>
<p><img src="/images/14573050208627.jpg" alt="这里，因为子进程没有调用 `exit`，所以需要显式回收"></p>
<p><strong>wait: Synchronizing with Children</strong></p>
<p>父进程通过调用 <code>wait</code> 函数来『收割』子进程</p>
<p><img src="/images/14573055666401.jpg" alt=""></p>
<p>下面是一个具体的例子，同样用进程图来描述：</p>
<p><img src="/images/14573056037360.jpg" alt="wait: Synchronizing with Children"></p>
<p><img src="/images/14573056447947.jpg" alt="If multiple children completed, will take in arbitrary order. Can use macros WIFEXITED and WEXITSTATUS to get information about exit status"></p>
<p><strong>waitpid: Waiting for a Specific Process</strong></p>
<p>直接看例子：</p>
<p><img src="/images/14573057138513.jpg" alt=""></p>
<p><strong>execve: Loading and Running Programs</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span></span><br></pre></td></tr></table></figure>
<p>具体的行为是：</p>
<p><img src="/images/14573057856048.jpg" alt=""></p>
<p>为了理解 <code>execve</code> 的行为，我们要先理解程序在栈中的布局：</p>
<p><img src="/images/14573058581756.jpg" alt="栈的结构"></p>
<p>一个具体的例子：</p>
<p><img src="/images/14573058863617.jpg" alt="execve 例子"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Exceptions<ul>
<li>Events that require nonstandard control flow</li>
<li>Generated externally (interrupts) or internally (traps and faults)</li>
</ul>
</li>
<li>Processes<ul>
<li>At any given time, system has multiple active processes</li>
<li>Only one can execute at a time on a single core, though</li>
<li>Each process appears to have total control of processor + private memory space</li>
</ul>
</li>
<li>Spawning processes<ul>
<li>Call <code>fork</code></li>
<li>One call, two returns</li>
</ul>
</li>
<li>Process completion<ul>
<li>Call <code>exit</code></li>
<li>One call </li>
</ul>
</li>
<li>Reaping and waiting for processes<ul>
<li>Call <code>wait</code> or <code>waitpid</code></li>
</ul>
</li>
<li>Loading and running programs<ul>
<li>Call <code>execve</code></li>
<li>One call, (normally) no return</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解完了链接，我们来看看在程序出错的时候会发生什么事情，这一课我们主要来了解异常与进程。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="异常" scheme="http://wdxtub.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 12 课 Linking]]></title>
    <link href="http://wdxtub.com/2016/03/06/csapp-12/"/>
    <id>http://wdxtub.com/2016/03/06/csapp-12/</id>
    <published>2016-03-06T12:47:27.000Z</published>
    <updated>2016-03-06T18:48:49.000Z</updated>
    <content type="html"><![CDATA[<p>这一课我们要接触一个新概念：Linking，简单来说就是计算机如何让不同的代码协同工作的方式。</p>
<a id="more"></a>
<hr>
<p>我们先来看一个例子，假设有这么两个代码文件</p>
<p><img src="/images/14572758203003.jpg" alt=""></p>
<p>我们用下面的命令来编译执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; gcc -Og -o prog main.c sum.c</span><br><span class="line">linux&gt; ./prog</span><br></pre></td></tr></table></figure>
<p>编译器实际上会分别编译不同的源代码，生成 <code>.o</code> 文件，具体把这些文件链接在一起的是 Linker 链接器，整个过程如下图所示：</p>
<p><img src="/images/14572760766987.jpg" alt=""></p>
<blockquote>
<p>为什么要使用链接器？</p>
</blockquote>
<p>有如下两个原因。</p>
<ul>
<li>模块化角度考虑。我们可以把程序分散到不同的小的源代码中，而不是一个巨大的类中。这样带来的好处是可以复用常见的功能/库，比方说 Math library, standard C library.</li>
<li>效率角度考虑。改动代码时只需要重新编译改动的文件，其他不受影响。而常用的函数和功能可以封装成库，提供给程序进行调用（节省空间）</li>
</ul>
<blockquote>
<p>链接器做了什么？</p>
</blockquote>
<p>主要负责做两件事情</p>
<p><strong>第一步：Symbol resolution</strong></p>
<p>我们在代码中会声明变量及函数，之后会调用变量及函数，所有的符号声明都会被保存在符号表(symbol table)中，而符号表会保存在由汇编器生成的 object 文件中（也就是 <code>.o</code> 文件）。符号表实际上是一个结构体数组，每一个元素包含名称、大小和符号的位置。</p>
<p>在 symbol resolution 阶段，链接器会给每个符号应用一个唯一的符号定义，用作寻找对应符号的标志。</p>
<p><strong>第二步：Relocation</strong></p>
<p>这一步所做的工作是把原先分开的代码和数据片段汇总成一个文件，会把原先在 <code>.o</code> 文件中的相对位置转换成在可执行程序的绝对位置，并且据此更新对应的引用符号（才能找到新的位置）</p>
<p>在具体来看这两步做了啥之前，先要理解下面几个概念。</p>
<h2 id="u4E09_u79CD_Object_Files"><a href="#u4E09_u79CD_Object_Files" class="headerlink" title="三种 Object Files"></a>三种 Object Files</h2><p>所谓的 Object File 实际上是一个统称，具体来说有以下三种形式：</p>
<ul>
<li>Relocatable object file (<code>.o</code> file)<ul>
<li>每个 <code>.o</code> 文件都是由对应的 <code>.c</code> 文件生成，包含代码和数据，可以用来组合成 executable object file</li>
</ul>
</li>
<li>Executable object file (<code>a.out</code> file)<ul>
<li>包含代码和数据，可以直接被复制到内存中执行</li>
</ul>
</li>
<li>Shared object file (<code>.so</code> file)<ul>
<li>在 windows 中被称为 Dynamic Link Libraries(DLLs)，是一类特别的 relocatable object file，能够被载入内存并动态链接（载入时或运行时）</li>
</ul>
</li>
</ul>
<h2 id="Executable_and_Linkable_Format_28ELF_29"><a href="#Executable_and_Linkable_Format_28ELF_29" class="headerlink" title="Executable and Linkable Format(ELF)"></a>Executable and Linkable Format(ELF)</h2><p>上面提到的三种 obejct file 有统一的格式，即 Executable and Linkable Format(ELF)，因为，我们把它们统称为 ELF binaries，具体的文件格式如下</p>
<p><img src="/images/14572780724226.jpg" alt="ELF 文件格式"></p>
<p>下面分别介绍一下各个部分：</p>
<ul>
<li>ELF header<ul>
<li>包含 word size, byte ordering, file type (.o, exec, .so), machine type, etc</li>
</ul>
</li>
<li>Segment header table<ul>
<li>包含 page size, virtual addresses memory segments(sections), segment sizes</li>
</ul>
</li>
<li>.text section<ul>
<li>代码部分</li>
</ul>
</li>
<li>.rodata section<ul>
<li>只读数据部分，例如 jump tables</li>
</ul>
</li>
<li>.data section<ul>
<li>初始化的全局变量</li>
</ul>
</li>
<li>.bss section<ul>
<li>未初始化的全局变量</li>
<li>“Block Started by Symbol”</li>
<li>“Better Save Space”</li>
<li>有 section header 但实际上不占空间</li>
</ul>
</li>
<li>.symtab section<ul>
<li>包含 symbol table, procudure 和 static variable names 以及 section names 和 location</li>
</ul>
</li>
<li>.rel.txt section<ul>
<li>Relocation info for .text section</li>
<li>Addresses of instructions that will need to be modified in the executable</li>
<li>Instructions for modifying</li>
</ul>
</li>
<li>.rel.data section<ul>
<li>Relocation info for .data section</li>
<li>Addresses of pointer data that will need to be modified in the merged executable </li>
</ul>
</li>
<li>.debug section<ul>
<li>包含 symbolic debugging (<code>gcc -g</code>) 的信息 </li>
</ul>
</li>
<li>Section header table<ul>
<li>Offsets and sizes of each section</li>
</ul>
</li>
</ul>
<h2 id="Linker_Symbols"><a href="#Linker_Symbols" class="headerlink" title="Linker Symbols"></a>Linker Symbols</h2><p>而链接器实际上会处理三种不同的符号，对应于代码中不同写法的部分：</p>
<ul>
<li>Global symbols<ul>
<li>在当前模块中定义，且可以被其他代码引用的符号，例如非静态 C 函数和非静态全局变量</li>
</ul>
</li>
<li>External symbols<ul>
<li>同样是全局符号，但是是在其他模块（也就是其他的源代码）中定义的，但是可以在当前模块中引用</li>
</ul>
</li>
<li>Local symbols<ul>
<li>在当前模块中定义，只能被当前模块引用的符号，例如静态函数和静态全局变量</li>
<li>注意，Local linker symbol 并不是 local program variables</li>
</ul>
</li>
</ul>
<p>现在我们可以回过头来看看链接器具体做的工作了：</p>
<h2 id="u7B2C_u4E00_u6B65_uFF1ASymbol_resolution"><a href="#u7B2C_u4E00_u6B65_uFF1ASymbol_resolution" class="headerlink" title="第一步：Symbol resolution"></a>第一步：Symbol resolution</h2><p><img src="/images/14572791281425.jpg" alt="Symbol resolution"></p>
<p>我们可以看到，链接器只知道非静态的全局变量/函数，而对于局部变量一无所知。</p>
<p>然后我们来看看局部非静态变量和局部静态变量的区别</p>
<ul>
<li>局部非静态变量会保存在栈中</li>
<li>局部静态变量会保存在 <code>.bss</code> 或 <code>.data</code> 中</li>
</ul>
<p>例如：</p>
<p><img src="/images/14572793537491.jpg" alt=""></p>
<p>如果两个不同的源代码中使用了相同的全局变量名称，链接器会如何处理呢？</p>
<p>首先我们需要知道的是，不同的符号是有强弱之分的：</p>
<ul>
<li>Strong: procedures and initialized globals</li>
<li>Weak: uninitialized globals</li>
</ul>
<p>比如：</p>
<p><img src="/images/14572854731828.jpg" alt=""></p>
<p>在这个基础上，有如下规则：</p>
<p><img src="/images/14572855304555.jpg" alt=""></p>
<p>因为这个特性，可能会因为变量重名导致非常奇怪的现象，比如下面的情况：</p>
<p><img src="/images/14572855800167.jpg" alt=""></p>
<p>因此我们可以得到一条很重要的编程建议：</p>
<blockquote>
<p>如果可能，尽量避免使用全局变量</p>
</blockquote>
<p>如果一定要用的话，注意下面几点：</p>
<ul>
<li>使用静态变量</li>
<li>定义全局变量的时候初始化</li>
<li>注意使用 <code>extern</code> 关键字</li>
</ul>
<h2 id="u7B2C_u4E8C_u6B65_uFF1ARelocation"><a href="#u7B2C_u4E8C_u6B65_uFF1ARelocation" class="headerlink" title="第二步：Relocation"></a>第二步：Relocation</h2><p>大概的过程，通过下图就可以看得比较清楚，就是把不同的 relocatable object files 拼成 executable object file 的过程</p>
<p><img src="/images/14572863145911.jpg" alt=""></p>
<p>但具体是怎么做到的呢，还是刚才那个例子：</p>
<p><img src="/images/14572863618645.jpg" alt=""></p>
<p>对应的 relocatable object file 反编译出来 <code>objdump -r -d main.o</code> 可以看到汇编代码为：</p>
<p><img src="/images/14572864112503.jpg" alt=""></p>
<p>这里我们可以看到，编译器用 relocation entry 来标记不同的调用（注意看对应的代码后面四组数字都是零，就是留出位置让链接器在链接的时候填上对应的实际内存地址）</p>
<p>在完成链接之后我们得到 <code>prog</code> 这个程序，同样反编译 <code>objdump -dx prog</code> 可以看到：</p>
<p><img src="/images/14572865303343.jpg" alt=""></p>
<p>对应的地址已经被填上去了，这里注意用的是相对的位置，比方说 0x4004de 中的 05 00 00 00 的意思实际上是说要在下一句的基础上加上 0x5，也就是 0x4004e8，即 sum 函数的开始位置。</p>
<p>具体载入内存的时候，大概是这样的：</p>
<p><img src="/images/14572866787544.jpg" alt=""></p>
<p>这里需要注意左边的部分地址从上往下，右边则是从下往上，这里所有的程序都会从 0x400000 开始。</p>
<h2 id="u6253_u5305_u5E38_u7528_u7A0B_u5E8F"><a href="#u6253_u5305_u5E38_u7528_u7A0B_u5E8F" class="headerlink" title="打包常用程序"></a>打包常用程序</h2><p>基本上每个程序都会用到某些特定的函数，比如：Math, IO, memory management, string manipulation 等等，我们能用什么方法把它们结合到程序中呢，有以下两个思路：</p>
<ul>
<li>思路 1：把所有的函数放到一个源文件中，程序员每次把这一整个大块头链接到自己的程序中，这种做法从时间和空间上来说都比较低效</li>
<li>思路 2：不同的函数放到不同的源文件中，由程序员显式链接所需要的函数，这种做法效率更高，但是相当于是给程序员增加负担了</li>
</ul>
<h3 id="Static_Libraries"><a href="#Static_Libraries" class="headerlink" title="Static Libraries"></a>Static Libraries</h3><p>比较老式的做法就是所谓的静态库(Static Libraries, <code>.a</code> archive files)</p>
<ul>
<li>Concatenate related relocatable object files into a single file with an index (called an archive)</li>
<li>Enhance linker so that it tries to resolve unresolved external references by looking for the symbols in one or more archives</li>
<li>If an archive member file resolves reference, link it into the executable</li>
</ul>
<p>具体的过程如下：</p>
<p><img src="/images/14572879938673.jpg" alt=""></p>
<p>这里注意，Archiver 支持增量更新，如果有函数变动，只需要重新编译改动的部分。</p>
<p>下面是两个常用的库：C standard library 与 C math library</p>
<p><img src="/images/14572880658935.jpg" alt=""></p>
<p>接下来我们看一个具体的例子，通过静态库来连接：</p>
<p><img src="/images/14572880967573.jpg" alt=""></p>
<p>具体过程如下：</p>
<p><img src="/images/14572881242795.jpg" alt=""></p>
<p>具体的链接方式是：</p>
<p><img src="/images/14572882030642.jpg" alt=""></p>
<p>但是这样会带来一个问题：写编译命令的时候，顺序是很重要的！我们看下面这个例子</p>
<p><img src="/images/14572882337934.jpg" alt=""></p>
<p>第一条命令中，在编译链接的时候，如果在 libtest.o 中发现了外部引用，就会在 -lmine 中查找，但是如果反过来，在第二条语句中 libtest.o 后面没有东西，就会出现找不到引用的错误。所以建议就是要把静态库都放到后面去。</p>
<h3 id="Shared_Libraries"><a href="#Shared_Libraries" class="headerlink" title="Shared Libraries"></a>Shared Libraries</h3><p>现代的方法则是使用共享库，避免了在文件中静态库的大量重复。</p>
<p>动态链接可以在首次载入的时候执行(load-time linking)，这是 Linux 的标准做法，会由动态链接器 <code>ld-linux.so</code> 完成，Standard C library(libc.so) 通常是动态链接的。</p>
<p><img src="/images/14572885863404.jpg" alt="Dynamic Linking at Load-time"></p>
<p>动态链接也可以在程序开始执行的时候完成(run-time linking)，在 Linux 中使用 <code>dlopen()</code> 接口来完成（会使用函数指针，如下面的例子所示），通常用于分布式软件，高性能服务器上。而且共享库也可以在多个进程间共享，这在后面学习到虚拟内存的时候会介绍。</p>
<p><img src="/images/14572886125265.jpg" alt=""></p>
<p><img src="/images/14572886257737.jpg" alt="Dynamic Linking at Run-time"></p>
<p>总结一下：</p>
<ul>
<li>链接使得我们可以用多个 object files 构造我们的程序</li>
<li>链接可以发生在程序的不同阶段<ul>
<li>编译期间(when a program is compiled)</li>
<li>载入期间(when a program is loaded into memory)</li>
<li>运行期间(while program is executing)</li>
</ul>
</li>
<li>理解链接可以帮助我们避免遇到奇怪的错误</li>
</ul>
<h2 id="Case_Study_3A_Library_Interpositioning"><a href="#Case_Study_3A_Library_Interpositioning" class="headerlink" title="Case Study: Library Interpositioning"></a>Case Study: Library Interpositioning</h2><p>这是一个非常有意思的技术，我们可以通过这个技术让程序运行任意我们想要的代码，比方说我们的程序中使用了 <code>malloc</code>，我们可以通过 library interpositioning 让程序执行我们自定义的 <code>malloc</code> 而不是标准库中的 <code>malloc</code>。</p>
<p>因为这相当于是某种链接技术，所以同样可以在不同的时候发生，如：</p>
<ul>
<li>编译时：When the source code is compiled</li>
<li>链接时：When the relocatable object files are statically linked to form an executable object file</li>
<li>载入/运行时：When an executable object file is loaded into memory, dynamically linked, and then executed.</li>
</ul>
<p>这个技术可以应用在</p>
<ul>
<li>安全方面<ul>
<li>Confinement (sandboxing)</li>
<li>Behind the scenes encryption</li>
</ul>
</li>
<li>调试方面<ul>
<li>可以找到隐藏比较深的 bug</li>
</ul>
</li>
<li>监控和查看性能<ul>
<li>统计函数调用的次数</li>
<li>检测内存泄露</li>
<li>生成地址记录</li>
</ul>
</li>
</ul>
<p>我们用一个具体的例子来说明，先来看看程序，非常简单，只有几行：</p>
<p><img src="/images/14572895007610.jpg" alt=""></p>
<p>我们要做的事情也很简单，先申请一片内存空间，然后再释放掉。但是我们的目标是在不修改源代码的前提下，追踪分配地址的位置，要怎么办呢？</p>
<p>有三种方式，分别在编译、链接和运行时对 <code>malloc</code> 和 <code>free</code> 函数进行 interpositioning。</p>
<h3 id="Compile-time_Interpositioning"><a href="#Compile-time_Interpositioning" class="headerlink" title="Compile-time Interpositioning"></a>Compile-time Interpositioning</h3><p>我们写出另外两个函数，它们唯一做的事情就是输出地址，相当于把原来的函数做了个『包装』：</p>
<p><img src="/images/14572896784067.jpg" alt=""></p>
<p>然后在 <code>malloc.h</code> 利用宏进行改变：</p>
<p><img src="/images/14572897247442.jpg" alt=""></p>
<p>最后我们可以通过 <code>-I.</code> 这个选项来使得程序会调用我们自己写的函数，可以看到执行的时候会打印出地址</p>
<p><img src="/images/14572897797778.jpg" alt=""></p>
<h3 id="Link-time_Interpositioning"><a href="#Link-time_Interpositioning" class="headerlink" title="Link-time Interpositioning"></a>Link-time Interpositioning</h3><p>我们同样需要把两个函数包装一下：</p>
<p><img src="/images/14572898402918.jpg" alt=""></p>
<p>然后注意所用的命令：</p>
<p><img src="/images/14572898614846.jpg" alt=""></p>
<p>这里 <code>-Wl</code> 会告诉链接器，把每个逗号替换成空格。</p>
<p><code>--wrap,malloc</code> 这个参数会进行特殊方式的引用</p>
<ul>
<li>对 <code>malloc</code> 的引用会被解析为 <code>__wrap_malloc</code></li>
<li>对 <code>__real_malloc</code> 的引用会被解析为 <code>malloc</code></li>
</ul>
<h3 id="Load/Run-time_Interpositioning"><a href="#Load/Run-time_Interpositioning" class="headerlink" title="Load/Run-time Interpositioning"></a>Load/Run-time Interpositioning</h3><p>我们同样是对两个函数进行包装：</p>
<p><img src="/images/14572900345456.jpg" alt=""></p>
<p><img src="/images/14572900442044.jpg" alt=""></p>
<p>然后使用以下命令：</p>
<p><img src="/images/14572900675087.jpg" alt=""></p>
<p>这里的 <code>LD_PRELOAD</code> 环境变量会告诉动态链接器先在 <code>mymalloc.so</code> 中寻找所需的引用，就完成了 interpositioning 的效果。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一课我们要接触一个新概念：Linking，简单来说就是计算机如何让不同的代码协同工作的方式。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="链接" scheme="http://wdxtub.com/tags/%E9%93%BE%E6%8E%A5/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Programming iOS9 学习笔记 12 - Controls and Other Views]]></title>
    <link href="http://wdxtub.com/2016/03/06/programming-ios9-translation-12/"/>
    <id>http://wdxtub.com/2016/03/06/programming-ios9-translation-12/</id>
    <published>2016-03-06T12:39:13.000Z</published>
    <updated>2016-03-06T12:46:33.000Z</updated>
    <content type="html"><![CDATA[<p>这一章主要包含前面没有提到过的 <code>UIView</code> 的子类（由 UIKit 提供）</p>
<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<p>这一章主要包含前面没有提到过的 <code>UIView</code> 的子类（由 UIKit 提供）</p>]]>
    
    </summary>
    
      <category term="Control" scheme="http://wdxtub.com/tags/Control/"/>
    
      <category term="iOS9" scheme="http://wdxtub.com/tags/iOS9/"/>
    
      <category term="学习" scheme="http://wdxtub.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://wdxtub.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Programming iOS9 学习笔记 11 - Web Views]]></title>
    <link href="http://wdxtub.com/2016/03/06/programming-ios9-translation-11/"/>
    <id>http://wdxtub.com/2016/03/06/programming-ios9-translation-11/</id>
    <published>2016-03-06T11:12:42.000Z</published>
    <updated>2016-03-06T12:38:58.000Z</updated>
    <content type="html"><![CDATA[<p>Web view 实际是一个浏览器，知道如何从网络上获取资源，比如说渲染 HTML/CSS/JavaScript。不仅可以用于展示网络内容，而且还有一个强大的，可以用来布局、显示动画和多媒体的引擎。</p>
<a id="more"></a>
<hr>
<p>Web view 甚至还知道如何去显示 PDF/RTF/DOC/Pages 文件。</p>
<p><img src="/images/14572631505893.jpg" alt=""></p>
<p>Web view 中的资源加载是异步的，有一个另外的线程来完成这个工作，也就是说加载的时候用户仍然可以进行各种操作和访问。</p>
<p><img src="/images/14572632324008.jpg" alt=""></p>
<p>在 iOS 9 中，实际上有三类 web view 对象：</p>
<p><img src="/images/14572632568030.jpg" alt=""></p>
<p>这里主要讨论 <code>WKWebView</code> 和 <code>SFSafariViewController</code>。</p>
<p><img src="/images/14572633254117.jpg" alt=""></p>
<h2 id="WKWebView"><a href="#WKWebView" class="headerlink" title="WKWebView"></a>WKWebView</h2><p><code>WKWebView</code> 是 WebKit 框架的一部分，使用之前需要 <code>import WebKit</code> 并且在代码中创建 web view，比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> config = <span class="type">WKWebViewConfiguration</span>()</span><br><span class="line"><span class="comment">// .... 各种配置</span></span><br><span class="line"><span class="keyword">let</span> wv = <span class="type">WKWebView</span>(frame: <span class="type">CGRectZero</span>, configuration:config)</span><br></pre></td></tr></table></figure>
<p>当然也可以直接使用默认配置初始化，之后再进行修改，如</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wv = <span class="type">WKWebView</span>(frame: <span class="type">CGRectZero</span>)</span><br><span class="line"><span class="comment">// ... 各种配置</span></span><br></pre></td></tr></table></figure>
<p>无论用哪种方法，最好在开始载入之前就完成配置，因为不同的配置可能会导致渲染得到的页面不一样，比较常见的配置有：</p>
<p><img src="/images/14572640710901.jpg" alt=""></p>
<p><img src="/images/14572640995408.jpg" alt=""></p>
<p>也可以创建自定义的内容放到界面上，如：</p>
<p><img src="/images/14572641374200.jpg" alt=""></p>
<p><code>WKWebView</code> 并不是一个 scroll view，但是拥有一个 scroll view。</p>
<p>有下面四种方式可以让 <code>WKWebView</code> 显示内容：</p>
<p><img src="/images/14572642956567.jpg" alt=""></p>
<p><img src="/images/14572643064428.jpg" alt=""></p>
<p>以上四个方法都会返回 <code>WKNavigation</code> 对象</p>
<p>我们可以通过 <code>WKWebView</code> 的属性来跟踪其状态，比如：</p>
<ul>
<li><code>loading</code></li>
<li><code>estimatedProgress</code></li>
<li><code>URL</code></li>
<li><code>title</code></li>
</ul>
<p>我们可以通过这些属性来做一些操作，比如说在载入的时候在页面中间放一个进度指示器，并且在载入完成之后隐藏。具体代码如下</p>
<p><img src="/images/14572644352049.jpg" alt=""></p>
<p>我们可以通过 <code>backForwardList</code> 来进行前进和后退的操作，这是一个 <code>WKBackForwardList</code> 并且有以下属性</p>
<ul>
<li><code>currentItem</code></li>
<li><code>backItem</code></li>
<li><code>forwardItem</code></li>
<li><code>itemAtIndex</code></li>
</ul>
<p>列表中的每个项目都是 <code>WKBackForwardItem</code>，包含 <code>URL</code> 和 <code>title</code>。然后就可以调用 <code>goBack</code>, <code>goForward</code> 和 <code>goToBackForwardListItem:</code> 方法来进行导航。当然，也可以通过设定 <code>canGoBack</code> 和 <code>canGoForward</code> 来控制是否能够后退前进。</p>
<p>还有一个可以设置的属性 <code>allowsBackForwardNavigationGestures</code>，用来控制是否能够以手势返回，默认是 false，如果设置为 true，则在滑动边缘的时候能够返回。</p>
<p>通过设置 <code>WKWebView</code> 的 <code>navigationDelegate</code> 可以控制具体的导航行为，例如：</p>
<p><img src="/images/14572672880968.jpg" alt=""></p>
<p><img src="/images/14572672999616.jpg" alt=""></p>
<p>然后还有一些代理方法会通知目前的状态：</p>
<p><img src="/images/14572673546176.jpg" alt=""></p>
<p>如果想要给 <code>WKWebView</code> 中的网页发消息，可以调用 <code>evaluateJavaScript:completionHandler:</code> 方法，例子如下；</p>
<p><img src="/images/14572674300371.jpg" alt=""></p>
<p><img src="/images/14572674428385.jpg" alt=""></p>
<p>当然也可以反向来进行操作，比方说把页面的某些元素与按钮绑定，这里不深入。</p>
<p>最后需要注意的是，<code>WKWebView</code> 是不能在 nib 中初始化的（控件里的是 <code>UIWebView</code>）。并且在 iOS8 中，指向本地文件的链接无法在 <code>WKWebView</code> 中使用（iOS9 中已修复，但是考虑兼容性，只能使用 UIWebView）</p>
<p>另外一个问题是 <code>WKWebView</code> 不会自动参与到任何视图控制器的状态中（也就是无法保存和恢复），如果是显示本地内容的话可以人为进行保存恢复，这里不赘述</p>
<h2 id="Safari_View_Controller"><a href="#Safari_View_Controller" class="headerlink" title="Safari View Controller"></a>Safari View Controller</h2><p>简单来说，就是在你的应用中开一个单独的 safari 线程（提供比较完整的功能）。根据苹果的建议，如果是要显示内部的 HTML 内容，用 <code>WKWebView</code>，如果是访问网络，用 Safari view controller，这样可以省去很多麻烦。</p>
<p>使用需要 <code>import SafariServices</code>，如</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> svc = <span class="type">SFSafariViewController</span>(<span class="type">URL</span>: url)</span><br><span class="line"><span class="keyword">self</span>.presentViewController(svc, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/14572679027545.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Web view 实际是一个浏览器，知道如何从网络上获取资源，比如说渲染 HTML/CSS/JavaScript。不仅可以用于展示网络内容，而且还有一个强大的，可以用来布局、显示动画和多媒体的引擎。</p>]]>
    
    </summary>
    
      <category term="Webview" scheme="http://wdxtub.com/tags/Webview/"/>
    
      <category term="iOS9" scheme="http://wdxtub.com/tags/iOS9/"/>
    
      <category term="学习" scheme="http://wdxtub.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://wdxtub.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的软实力]]></title>
    <link href="http://wdxtub.com/2016/03/05/my-soft-skill/"/>
    <id>http://wdxtub.com/2016/03/05/my-soft-skill/</id>
    <published>2016-03-06T02:04:55.000Z</published>
    <updated>2016-03-06T11:15:44.000Z</updated>
    <content type="html"><![CDATA[<p>上一篇文章，<a href="http://wdxtub.com/2016/03/04/na-job-soft-skill/">北美找工作软实力指南</a>中提到了给自己定位的分析与思考方法，这里以自己为例子，来看看如何更好地找到自己并展示自己。</p>
<a id="more"></a>
<hr>
<p>自己比较适合游走在技术、管理与沟通之间的工作，所以就以这个为基准，作为这次思考的开始。</p>
<h2 id="u76EE_u6807"><a href="#u76EE_u6807" class="headerlink" title="目标"></a>目标</h2><p>我想找的工作职位是：项目经理（需要懂技术与管理，还需要与客户或者其他小组沟通协调，和微软的 Program Manager 的职责比较接近，而非传统那样只负责管理）。</p>
<p>选择这个职位作为走上社会的第一步，是经过深思熟虑的。我的性格、做事风格、技能、经历和喜好都非常适合这个职位，具体会在后面详细说明。</p>
<p><strong>短期职业目标</strong></p>
<p>我的短期职业目标是通过这份工作尽可能快得通过接触社会上各种类型的人来完成从学生到社会人这个身份的转换，并在具体实践中找到自己的方向。所以希望能不止局限于特定的工作，而是像『救火队员』一样，到最需要、最能学到东西、最能成长的地方，哪怕苦一点累一点，压力大一点也不怕。</p>
<p><strong>长期职业目标</strong></p>
<p>我的长期职业目标是通过接触不同领域，不同层次的项目和人群，建立其对技术、商业乃至于社会的整体框架，并利用自己的思考与行动力，带领志同道合的伙伴一起努力，为后辈创造一个更好的未来。我知道现在中国社会有太多太多的丑陋和需要改进的地方，我想通过自己的努力，从独当一面开始，真正能做一些影响到更多人的事情。简单来说就是想让世界 “Hear My Voice”</p>
<h2 id="u6280_u80FD"><a href="#u6280_u80FD" class="headerlink" title="技能"></a>技能</h2><p>对应于我的短期与长期的职业目标，我的以下技能是非常合适的：</p>
<h3 id="u6280_u80FD_u4E00_uFF1A_u9605_u8BFB"><a href="#u6280_u80FD_u4E00_uFF1A_u9605_u8BFB" class="headerlink" title="技能一：阅读"></a>技能一：阅读</h3><p>阅读能力的提升使得我能更快更好地把新知识融会贯通到已有的知识体系与认知架构中，我觉得这对于一个项目经理来说是很重要的。不谋万世者不足以谋一时，通过广泛涉猎建立起来的大局观与开放性思考问题的方式，相信对于完成这个职位所需要的工作有很大帮助。</p>
<p>从大四起，我有目的开始培养自己阅读的能力。书籍作为最重要且最有价值的信息来源，在这个碎片化的时代很容易被忽视。随着阅读量的增加，慢慢也有了一些影响力，成为了『多看特约书评人』，也积累了一些粉丝。</p>
<p><img src="/images/duokan-read.jpeg" alt="我在多看阅读中的一些数据"></p>
<p><a href="http://www.douban.com/people/wdx/" target="_blank" rel="external">这里</a>是我的豆瓣读书主页，也可以从中大概了解我的阅读兴趣。因为对这个世界好奇，所以基本上各个领域的书都有所涉猎，知识面比较广，每隔一段时间也会进行整理和反思。毫不夸张的说，阅读是我这几年快速成长的基础，具体可以参加下面几篇思考的日志：</p>
<ul>
<li><a href="http://wdxtub.com/2015/05/25/5000-hours/">写在五千小时</a></li>
<li><a href="http://wdxtub.com/2014/10/22/4000-hours/">写在四千小时</a></li>
<li><a href="http://wdxtub.com/2014/05/20/3000-hours/">写在三千小时</a></li>
<li><a href="http://wdxtub.com/2014/01/20/2000-hours/">写在两千小时</a></li>
<li><a href="http://wdxtub.com/2013/08/21/1000-hours/">写在一千小时</a></li>
</ul>
<h3 id="u6280_u80FD_u4E8C_uFF1A_u5199_u4F5C"><a href="#u6280_u80FD_u4E8C_uFF1A_u5199_u4F5C" class="headerlink" title="技能二：写作"></a>技能二：写作</h3><p>管理和沟通除了面对面交流之外，更重要的一部分是通过文字，因为文字可以跨域时空限制，清晰有逻辑的表述不但能够梳理思路，更能避免基本的思维误区。并且在不断的写作中，也通过和读者的沟通交流极大地提高自己跟不同行业的人介绍自己工作的能力，尤其是利用『比喻』的能力。我总是会利用比喻来尽可能让他人理解我要介绍的东西或者我的思维方式，这是我的最大收获。因为项目经理很多时候还需要进行协调沟通的工作，我的这个技能是很好的助力。</p>
<p>从高中开始就会在网上写写东西，起初都是没多少意义的流水账，开始有针对性阅读之后，就以书评的形式来组织自己的文章，从最简单的书摘，到慢慢有自己的见解，再到现在能够批判性去看待的观点，以及研究作者的思维方式，一步一步都让我得到了很多乐趣。</p>
<p>因为坚持时间比较长，<a href="http://wdxtub.lofter.com/" target="_blank" rel="external">我的博客</a>也慢慢积累了十万多粉丝，也认识了一批热爱文字，喜欢用笔尖思考的朋友，更重要的是使我能以他人的视角去看待问题。也曾受到 LOFTER 官方的推荐和转载，曾经（后来这个功能取消了）是『读书』分类下排在前十的『资深博客』。现在也会开始系列写作，把自己的想法组织成完整的观点，搭建一个整体框架来进行写作，比如下面的『人造系列』</p>
<ol>
<li><a href="http://wdxtub.com/2015/08/26/heroes-are-not-born/">人造英雄</a></li>
<li><a href="http://wdxtub.lofter.com/post/1a7a1d_5def559" target="_blank" rel="external">人造极简</a></li>
<li><a href="http://wdxtub.com/2015/02/06/manmade-peace/">人造定凝</a></li>
<li><a href="http://wdxtub.com/2015/01/31/manmade-speed/">人造速度</a></li>
<li><a href="http://wdxtub.com/2015/01/13/manmade-loss/">人造缺憾</a></li>
<li><a href="http://wdxtub.com/2015/01/05/manmade-startup/">人造创业</a></li>
<li><a href="http://wdxtub.com/2015/01/01/manmade-confidence/">人造自信</a></li>
<li><a href="http://wdxtub.com/2014/09/15/manmade-regret/">人造后悔</a></li>
</ol>
<h3 id="u6280_u80FD_u4E09_uFF1A_u601D_u8003"><a href="#u6280_u80FD_u4E09_uFF1A_u601D_u8003" class="headerlink" title="技能三：思考"></a>技能三：思考</h3><p>在前两个技能的基础上，以及非常幸运能获得高人点拨，慢慢也建立起自己的思考能力，从发现问题、观察问题、解决问题最后到寻找问题背后的核心，虽然现在还在努力练习，但是能感觉到自己走在正确的道路上。我觉得对于项目经理来说，思考是最重要的能力，因为很多时候需要从具体的细节中抽离出来，去寻找能把事情做得更好的方法，而思考就是找到这个宝藏的钥匙。希望能够在具体的工作中，不断应用和磨练自己的思考能力，站得更高，看得更远。</p>
<p>比方说最近看的《YC 创业课》与《穷查理宝典》，虽然仍旧未能完全领悟，但是也尽力从中汲取营养，<a href="http://wdxtub.com/2016/01/12/startup-and-investment/">《创业与投资》</a>这篇日志便是我的思考。</p>
<p>再比如我会以生活中的小事为引子深入思考，得到不一样的收获，把看似风马牛不相及的两个事情连接起来，<a href="http://wdxtub.com/2015/12/13/language-and-buybuybuy/">《学语言与买东西》</a>就是我从朋友的小举动中得到『无论是学语言还是买东西，如果从更高更长远的角度来看，都会得出和想当然完全不同的结论，年轻人应该努力去更高的地方看得更远，以发展的眼光看待问题。不管是什么事情，如果能从粒度和深度上细细考量，就会有不一样的答案』这样的结论。</p>
<h3 id="u6280_u80FD_u56DB_uFF1A_u6C9F_u901A"><a href="#u6280_u80FD_u56DB_uFF1A_u6C9F_u901A" class="headerlink" title="技能四：沟通"></a>技能四：沟通</h3><p>自己和其他同学相比最突出的可能就是沟通能力，我会尽力去争取机会做一些大家可能不会想到要去做的事来锻炼自己的沟通能力。我觉得这是作为项目经理非常重要的技能，双方互相理解的程度越高，事情就能办的越好。</p>
<p>我觉得自己给教授拜访朋友全程当口译的经历是一个非常好的锻炼，整个三天的双语互译给我带来了很大的震动，详情可以看<a href="http://wdxtub.com/2015/04/06/two-side/">《二向箔》</a>这篇日志，有几点结论我觉得还挺有意思的：</p>
<ol>
<li>从生活中学到的东西，才是最能运用到生活中去的。不要觉得说自己是学生，就下意识去逃避接触社会。如果担心自己表现得太糟糕，看书，能从别人的经验中学习。观察，总结，验证，慢慢去增长自己的阅历，渐渐开始有自己的理解和想法，这才是学习之道。</li>
<li>不同文化间的交流沟通，其实有点类似于自然界的生殖隔离，我给起了个名字叫文化隔离。具体指的是因为交流双方的文化不同，所处的位置，所站的立场不同，大部分沟通其实都停留在非常低层次的意义上(也就是事实类信息-吃了什么，最近怎么样)，而如果想要有更高层次的沟通，条件则严苛很多。一是对话双方至少要能达到较高的思想境界，二是作为中间人的口译着需要对于两种文化都有较深刻的认识。</li>
<li>比文化隔离低一些层次的隔离是教育隔离。不同于东西方差异，这种隔离更倾向于出现在同一个国家的人群中，因为受教育程度的不同，或者说受到的教育不同，使得不同人对身边世界的认知有着极大的差异，倘若对话双方都无法跳出原有思维进行更高层次的思考，恐怕盲人摸象，无言以对了。</li>
<li>文化隔离和教育隔离并不是不能解决的，至少只要双方达到标准，或者有一个合适的桥梁，就能够很大程度消除这种隔离。最为严重的一种隔离是心智隔离，一旦对话双方有心智隔离，这样的对话几乎很难有任何有意义的产出。心智隔离的产生是一个长期的过程，大量的阅读、思考和写作会有一定程度的帮助，但是从我的角度看来，一旦出现心智隔离，那么也许放弃治疗是最好的选择。</li>
</ol>
<h3 id="u6280_u80FD_u4E94_uFF1A_u7F16_u7A0B"><a href="#u6280_u80FD_u4E94_uFF1A_u7F16_u7A0B" class="headerlink" title="技能五：编程"></a>技能五：编程</h3><p>因为项目经理还需要参与技术，有扎实的技术背景，尤其是了解不同技术内在的本质及原理是非常重要的。在 CMU 学习的课程上至最火热的云计算与计算机视觉，下至汇编 C 语言与基本的硬件原理，再加上机器学习的相关知识以及软件架构的的具体应用，我对整个计算机学科有了更加深入和全面的的认识，我觉得这对于一个项目经理来说是非常重要的，尤其是在理解客户需求，转换成具体的功能上时，经过长期系统训练所得到的『直觉』会很有帮助。</p>
<p>最近我也在努力把正在学和已经学习的知识以课程笔记的形式分享出来，一是加深自己的理解，二是让更多的人能接触到高质量的中文资源。包括：</p>
<ul>
<li>云计算</li>
<li>深入理解计算系统(CSAPP)</li>
<li>软件架构与设计</li>
<li>并发编程</li>
<li>计算机学科基础知识</li>
<li>计算机相关工具指南</li>
<li>数据结构与算法</li>
<li>等等</li>
</ul>
<p>具体的列表可以参加<a href="http://wdxtub.com/about/">这里</a>，相信通过这种方式，不但自己的学习更扎实，也能把知识分享出去。我觉得这种开放和共赢的心态，对于一个项目经理也是非常重要的。</p>
<p>我也整理出了自己的历年来比较完整的项目作为<a href="http://wdxtub.com/portfolio/">作品集</a>，会比简历中说明得更加清晰。</p>
<h2 id="u7231_u597D"><a href="#u7231_u597D" class="headerlink" title="爱好"></a>爱好</h2><p>日常生活中我的兴趣爱好从某种程度来说也有助于我胜任项目经理这个职位。</p>
<ul>
<li>旅行<ul>
<li>去过除大西部外的大部分省份，在不同的环境中学习如何跟各行各业的人打交道</li>
<li>知道在什么情况下应该跟什么人怎么样说话</li>
</ul>
</li>
<li>运动<ul>
<li>日常长跑，在寻找与突破自己的生理极限中，更加深入理解自己</li>
<li>不断磨练自己的意志力，即使遇到困难也要尽力把事情坚持下去</li>
</ul>
</li>
</ul>
<h2 id="u957F_u5904"><a href="#u957F_u5904" class="headerlink" title="长处"></a>长处</h2><p>除了前面提到的技能，我还有下面一些特质让我能够胜任各项工作</p>
<ul>
<li>坚持<ul>
<li>遇到困难不会轻易放弃，而是从不同的失败中利用排除法摸索出正确的道路</li>
<li>即使犯了错误也能很快从打击中恢复，屡败屡战，朝抵抗力最大的路径走</li>
</ul>
</li>
<li>不好面子<ul>
<li>意识到自己弄错了会立刻承认，不会觉得丢面子，把事情做好才是最重要的</li>
<li>不会好大喜功，更愿意让真正做出贡献的人得到超出其预期的所得</li>
</ul>
</li>
<li>乐于分享<ul>
<li>希望能有更多高质量的中文资源被创造出来（也是为什么坚持写博客的原因）</li>
<li>共同进步，水涨船高，自己的水平是身边五个人的平均水平</li>
</ul>
</li>
</ul>
<h2 id="u77ED_u5904"><a href="#u77ED_u5904" class="headerlink" title="短处"></a>短处</h2><p>当然，也有一些日常工作学习逐渐累积下来的缺点</p>
<ul>
<li>有时过分相信自己的直觉<ul>
<li>应该从直觉开始，用数据和证据来验证自己的想法，而不是故意『凑』结论</li>
</ul>
</li>
<li>有时会比较固执<ul>
<li>应该更多接触不同的思维模型，尝试从不同角度去理解可能看起来『不太靠谱』的想法，并以此为基础共同讨论出最合理的方案</li>
</ul>
</li>
</ul>
<h2 id="u5199_u5728_u6700_u540E"><a href="#u5199_u5728_u6700_u540E" class="headerlink" title="写在最后"></a>写在最后</h2><p>以上就是我的职业规划和自己为什么想做，为什么能胜任项目经理这一职位的想法，可能有点啰嗦，但的确是希望能尽可能展示自己，希望能有机会进行进一步的沟通交流。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇文章，<a href="http://wdxtub.com/2016/03/04/na-job-soft-skill/">北美找工作软实力指南</a>中提到了给自己定位的分析与思考方法，这里以自己为例子，来看看如何更好地找到自己并展示自己。</p>]]>
    
    </summary>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="自我" scheme="http://wdxtub.com/tags/%E8%87%AA%E6%88%91/"/>
    
      <category term="软实力" scheme="http://wdxtub.com/tags/%E8%BD%AF%E5%AE%9E%E5%8A%9B/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo 主题 Maupassant 换图标教程]]></title>
    <link href="http://wdxtub.com/2016/03/05/maupassant-icon-config/"/>
    <id>http://wdxtub.com/2016/03/05/maupassant-icon-config/</id>
    <published>2016-03-05T17:08:20.000Z</published>
    <updated>2016-03-05T20:40:37.000Z</updated>
    <content type="html"><![CDATA[<p>折腾主题恐怕是搭建独立博客最痛并快乐的事情了。尤其是对我这种前端菜鸟来说，很多东西明明知道对应资源文件在哪里，却愣是不知道从何下手。今天我们说说，如何给 Hexo 主题 maupassant 换上自己喜欢的图标。</p>
<a id="more"></a>
<hr>
<p>使用 Hexo 以来，换过不少主题，不想用太『大众』的，『小众』的却往往文档不全想改也不知道从何下手。寻寻觅觅，总算找到了一个心仪的 —— <a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="external">Maupassant</a>（这里我用的是 tufu9441 个人定制的版本，也有两百多个 star 了，赞）。只因介绍中的一句话：</p>
<blockquote>
<p>大道至简</p>
</blockquote>
<p>整个博客非常简洁干净，虽然还有一些我觉得不是很满意的地方，不过暂时来说是小问题，我可以一边学一边改。目前来说，整体效果是这样的：</p>
<p><img src="/images/14572005603940.jpg" alt="整体效果"></p>
<p>接下来就是重点了，不同栏目的的图标（就是技术、生活、作品等）是我一直想定制的，其实文档里也给出了具体的方法和资源地址，可惜我不懂前端，看着也还是不会。隔一段时间总要试一试，屡败屡战，终于没有苦劳也有疲劳，算是弄清楚的怎么换图标。</p>
<p>其实思路也不难，就是先生成对应的图标，然后想办法在网页中显示出来，但是这着实让我摸索了一段时间。</p>
<p>第一步，到 <a href="https://icomoon.io/" target="_blank" rel="external">IcoMoon</a> 的网站中，点击右上角的 <a href="https://icomoon.io/app/#/select" target="_blank" rel="external">IcoMoon App</a>，然后就可以来到下面的图标选择页面：</p>
<p><img src="/images/14572008612929.jpg" alt="图标选择页面"></p>
<p>选择你喜欢的图标，然后点击右边的 Generate Font（我之前就一直以为是左边的 SVG 什么的，所以死活不成功），就会出现一个给你改名字的机会（这也就是对应生成的索引信息）</p>
<p><img src="/images/14572011524694.jpg" alt=""></p>
<p>然后再点击下载，正常情况下就可以了，下载之后就会得到这样一个文件夹：</p>
<p><img src="/images/14572009951366.jpg" alt=""></p>
<p>我们来比较一下 maupassant 主题的结构：</p>
<p><img src="/images/14572010529465.jpg" alt=""></p>
<p>发现了！都有 fonts 这个文件夹！里面的文件还一样，所以二话不说，赶紧复制粘贴过去，然后对应修改主题的配置文件（注意 icon 为前缀的图标名称）</p>
<p><img src="/images/14572012141830.jpg" alt=""></p>
<p>结果发现并没有用，甚至原来可以的都显示不出来了，但是发生了一个奇怪的现象，有一个图标能显示，但是错乱了位置，于是我猜想，肯定是哪里需要索引这些文件。再看看下载得到的 icomoon 文件夹中有一个 style.css，发现里面有这么一段：</p>
<p><img src="/images/14572013574673.jpg" alt="下载得到的 style.css"></p>
<p>于是一顿搜索，在 maupassant 主题的 style.scss 文件中也找到了类似的行，于是直接把整段复制过去。再部署，就可以看到效果啦！</p>
<p><img src="/images/14572015499052.jpg" alt=""></p>
<p>万万没想到原来这么简单，也要感谢这次尝试失败后的『灵机一动』，也因此找到了正确的用法。最后说一下选择这些图标的原因吧：</p>
<ul>
<li>首页：小房子的图标，基本是通用惯例了</li>
<li>技术：插电的图标，提醒自己要不断充电</li>
<li>生活：吃豆人的图标，提醒自己生活就是吃一个豆子再吃另一个，有些豆子会给自己不一样的力量</li>
<li>作品：无限的图标，激励自己要不停创造完整的作品</li>
<li>归档：软盘的图标，复古风，有保存的意思，也向上古和中古时代的程序员致敬</li>
<li>订阅：RSS 的图标，也算是惯例了</li>
</ul>
<p>希望以后能把自己的博客改得越来越好，虽然自己依然在纷繁的前端技术中找不到方向。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>折腾主题恐怕是搭建独立博客最痛并快乐的事情了。尤其是对我这种前端菜鸟来说，很多东西明明知道对应资源文件在哪里，却愣是不知道从何下手。今天我们说说，如何给 Hexo 主题 maupassant 换上自己喜欢的图标。</p>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://wdxtub.com/tags/Hexo/"/>
    
      <category term="icomoon" scheme="http://wdxtub.com/tags/icomoon/"/>
    
      <category term="主题" scheme="http://wdxtub.com/tags/%E4%B8%BB%E9%A2%98/"/>
    
      <category term="图标" scheme="http://wdxtub.com/tags/%E5%9B%BE%E6%A0%87/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Programming iOS9 学习笔记 10 - Text]]></title>
    <link href="http://wdxtub.com/2016/03/05/programming-ios9-translation-10/"/>
    <id>http://wdxtub.com/2016/03/05/programming-ios9-translation-10/</id>
    <published>2016-03-05T12:07:13.000Z</published>
    <updated>2016-03-05T14:34:48.000Z</updated>
    <content type="html"><![CDATA[<p>几乎所有的应用都需要显示文字，iOS 以简单的方式提供了强大且复杂的文字显示功能，很多时候我们只需要指定文字内容即可，这一章我们来看看 Text 的相关内容。</p>
<a id="more"></a>
<hr>
<p>Text 形式主要有两种：<code>NSString</code> 和 <code>NSAttributedString</code>，后者可以设定不同的风格，比如字符、段落、行距等等。具体显示只需要在 graphics context 上绘制，或者交给知道如何去绘制的对象：</p>
<p><img src="/images/14571810008511.jpg" alt=""></p>
<p>所有的文本绘制依赖于底层的 C API(<code>Core Text</code>)，不过现在 iOS 提供 <code>Text Kit</code> 使我们可以很方便的来进行操作。另一个绘制文字的方法是使用 web view，比方说 PDF, RTF, DOC 什么的。</p>
<h2 id="Fonts_and_Font_Descriptors"><a href="#Fonts_and_Font_Descriptors" class="headerlink" title="Fonts and Font Descriptors"></a>Fonts and Font Descriptors</h2><p>描述字体的方式有两种</p>
<ol>
<li><code>UIFont</code>：用于 <code>NSString</code> 或 UIKit 对象</li>
<li><code>CTFont</code>：用于 Core Text</li>
</ol>
<p>iOS 7 之前这俩居然协同起来不大方便，比方说要做一些变换，先要从 <code>UIFont</code> 换成 <code>CTFont</code>，然后在手动切换回来，不过现在已经没有这个问题了。另外一个比较重要的是 <code>CTFOntDescriptor</code>，在做 font transformation 的时候很有用。</p>
<p>字体是非常简单的对象，在初始化的时候可以指定名称和大小 <code>init(name:size:)</code>。下面的方法可以得到所有已安装字体的名字：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIFont</span>.familyNames().<span class="built_in">map</span> &#123;<span class="type">UIFont</span>.fontNamesForFamilyName($<span class="number">0</span>)&#125;</span><br><span class="line">    .forEach &#123;(n:[<span class="type">String</span>]) <span class="keyword">in</span> n.forEach &#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>系统字体可以通过 <code>systemFontOfSize:weight:</code> 来访问，weight 具体就是一个 <code>CGFloats</code>，如下：</p>
<p><img src="/images/14571820299805.jpg" alt=""></p>
<p><img src="/images/14571820506614.jpg" alt=""></p>
<h3 id="u52A8_u6001_u5B57_u4F53_u7C7B_u578B"><a href="#u52A8_u6001_u5B57_u4F53_u7C7B_u578B" class="headerlink" title="动态字体类型"></a>动态字体类型</h3><p>使用动态字体，用户可以在设置中更改字体的大小，对于不同的字体，我们不需要指定具体的大小，而是调用 <code>UIFont</code> 的 <code>preferredFontForTextStyle:</code>，可能的参数有：</p>
<p><img src="/images/14571823862991.jpg" alt=""></p>
<p><img src="/images/14571824014617.jpg" alt=""></p>
<p>为了能够根据用户的设置改变字体大小，需要注册 <code>UIContentSizeCategoryDidChangeNotification</code>，另外在字体大小变化的时候可能需要界面的改动，这时候 autolayout 就很有用了。下面是一个具体的例子，我们根据用户的设置来改变字体大小：</p>
<p><img src="/images/14571825459558.jpg" alt=""></p>
<p><img src="/images/14571825561811.jpg" alt=""></p>
<p>从 iOS 8 开始，<code>UITableView</code> 会依照设定自动更新而不用做这么多额外的工作</p>
<h3 id="u6DFB_u52A0_u5B57_u4F53"><a href="#u6DFB_u52A0_u5B57_u4F53" class="headerlink" title="添加字体"></a>添加字体</h3><p>有两种方法可以添加字体：</p>
<p><img src="/images/14571827009066.jpg" alt=""></p>
<p>如果要实时下载的话，需要 <code>import CoreText</code> 并且调用 <code>CTFontDescriptorMatchFontDescriptorsWithProgressHandler</code>（应该被放到后台线程），下面是一个具体的例子：</p>
<p><img src="/images/14571828209821.jpg" alt=""></p>
<p>这里注意，<code>print</code> 不是线程安全的，所以我们使用 <code>NSLog</code>。</p>
<p>Font Descriptors 部分内容比较基础，不懂时可以看看官方文档，这里略过</p>
<h2 id="Attributed_Strings"><a href="#Attributed_Strings" class="headerlink" title="Attributed Strings"></a>Attributed Strings</h2><p><img src="/images/14571829592932.jpg" alt=""></p>
<p>一个 <code>NSAttributedString</code> 包含 <code>NSString</code> 和对应的属性，比较重要的有：</p>
<p><img src="/images/14571830030382.jpg" alt=""></p>
<p><img src="/images/14571830182091.jpg" alt=""></p>
<p><img src="/images/14571830302896.jpg" alt=""></p>
<p><img src="/images/14571830444900.jpg" alt=""></p>
<p>构造 <code>NSAttributedString</code> 时，如果整个字符串的 attributes 相同的话可以使用 <code>init(string:attributes:)</code>，不然的话就使用 <code>NSMutableAttributedString</code>，这个类中我们可以具体设置不同 attributes 的范围。如果是段落属性的话则用 <code>NSParagraphStyle</code>。这俩都自带默认值，所以我们只需要设置关心的 attributes 就好。</p>
<p>我们来看一个具体的例子：</p>
<p><img src="/images/14571833506635.jpg" alt=""></p>
<p>如果我们想要让整一段居中的话，可以用如下的代码（注意 <code>firstLineHeadIndent</code> 需要单独设置）</p>
<p><img src="/images/14571834084982.jpg" alt=""></p>
<p><img src="/images/14571834298856.jpg" alt=""></p>
<p>再来一个例子，如果我们想让第一个字符变大的话，可以这么做：</p>
<p><img src="/images/14571834716206.jpg" alt=""></p>
<p>效果如下：</p>
<p><img src="/images/14571834811712.jpg" alt=""></p>
<p>但是可以看到第三行中缩进去了一块，我们可以用下面的代码来让它更好看一些：</p>
<p><img src="/images/14571835497442.jpg" alt=""></p>
<p>效果如下：</p>
<p><img src="/images/14571835610156.jpg" alt=""></p>
<p>最后是把两个效果合并起来的样子：</p>
<p><img src="/images/14571836150901.jpg" alt=""></p>
<p><strong>Tab stops</strong></p>
<p>有的时候我们还需要使用制表符，那么可以使用 <code>NSTextTab</code>，下面之际上例子（可以看到是按照小数点对齐的）：</p>
<p><img src="/images/14571839916429.jpg" alt=""></p>
<p><strong>Text attachments</strong></p>
<p>实际上就是内联的图像，使用图片数据来初始化 <code>NSTextAttachment</code> 即可，再来看一个例子：</p>
<p><img src="/images/14571840929748.jpg" alt=""></p>
<p>效果如下</p>
<p><img src="/images/14571841032318.jpg" alt=""></p>
<p><strong>从文件导入</strong></p>
<p>我们也可以直接从诸如 RTF 文件中直接导入格式，就不用在代码里设置这么麻烦了，比如：</p>
<p><img src="/images/14571844313983.jpg" alt=""></p>
<h3 id="Modifying_and_Querying_an_Attributed_String"><a href="#Modifying_and_Querying_an_Attributed_String" class="headerlink" title="Modifying and Querying an Attributed String"></a>Modifying and Querying an Attributed String</h3><p>基本的字符串操作也是支持的，也可以根据需要自定义每个字符的属性</p>
<p><img src="/images/14571845719969.jpg" alt=""></p>
<p>当然，我们也可以不用内置的控件，直接绘制文字，如：</p>
<p><img src="/images/14571846456322.jpg" alt=""></p>
<p>在这个例子中，直接把文字绘制到了图片的 context 中。同理，我们也可以直接在 UIView 的 <code>drawRect:</code> 方法中绘制，如：</p>
<p><img src="/images/14571847058762.jpg" alt=""></p>
<p>我们也可以用类似 <code>boundingRectWithSize:options:context:</code> 这样的方法来测量具体的大小，这里注意 <code>.UsesLineFragmentOrigin</code> 的设置，不然得到的值会非常小，获取到的高度可能带有小数部分，注意向上取整。</p>
<h2 id="Labels"><a href="#Labels" class="headerlink" title="Labels"></a>Labels</h2><p>对于 UILabel，<code>numberOfLines</code> 属性非常重要（配合上 line breaking 和 resizing），Line breaking 的一些规则如下：</p>
<p><img src="/images/14571849774329.jpg" alt=""></p>
<p><img src="/images/14571850016896.jpg" alt=""></p>
<p>要让 label 的文字自动适应长宽调整的大小的话，在代码中设置 <code>sizeToFit</code> 即可。</p>
<h2 id="Text_Fields"><a href="#Text_Fields" class="headerlink" title="Text Fields"></a>Text Fields</h2><p>这部分的内容比较基础，倒是跟文本框相关的另一个问题比较重要，就是怎么处理键盘。比方说可能遮挡内容，或者输入完成后如何让键盘消失。</p>
<p>但其实机制还是很简单的：</p>
<p><img src="/images/14571854772650.jpg" alt=""></p>
<p>所以实际上只要修改 first responder 的状况即可：</p>
<p><img src="/images/14571855137876.jpg" alt=""></p>
<p>奇怪的是，我们其实没办法很方便知道哪个 view 是 first responder。倒是有一个 <code>isFirstResponder</code> 方法来检测，不过这就意味着我们需要遍历所有 view 才能确定。一个方法是事先保存好谁是 first responder，一般在 text field 的 <code>textFieldDidBeginEditing:</code> 中设置。</p>
<p>如果想让用户在输入完成后按回车去掉键盘的话，可以重写 text field 的代理方法，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">textFieldShouldReturn</span><span class="params">(tf: UITextField)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    tf.resignFirstResponder()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Keyborad_Covers_Text_Field"><a href="#Keyborad_Covers_Text_Field" class="headerlink" title="Keyborad Covers Text Field"></a>Keyborad Covers Text Field</h3><p>处理键盘遮挡的时候，以下的通知会很有用：</p>
<p><img src="/images/14571860606126.jpg" alt=""></p>
<p>在 iPad 上因为键盘还可以分离，所以会有另外两个通知</p>
<p><img src="/images/14571861165823.jpg" alt=""></p>
<p>通知中的 <code>userInfo</code> 字典包含各类信息，如：</p>
<p><img src="/images/14571861447808.jpg" alt=""></p>
<p>具体来说，可以根据不同的界面风格，来选择如何处理遮挡问题，我们可以</p>
<ol>
<li>Sliding the interface，也就是整个界面往上飞</li>
<li>直接改变 frame 的大小</li>
</ol>
<p>具体的代码这里略过，注意保证应用中的处理方式比较一致即可</p>
<h3 id="Configuring_the_Keyborad"><a href="#Configuring_the_Keyborad" class="headerlink" title="Configuring the Keyborad"></a>Configuring the Keyborad</h3><p>可以定制键盘，加入一些额外的功能</p>
<p><img src="/images/14571864352162.jpg" alt=""></p>
<p>具体的做法是在键盘上添加一个 <code>inputAccessoryView</code>，然后就可以在之中做不同的操作了：</p>
<p><img src="/images/14571864705916.jpg" alt=""></p>
<p>比方说，有些键盘类型没有返回按键，这时候我们就需要自己来了。</p>
<p>iOS9 中，我们可以添加 bar button（<code>inputAssistantItem</code>，针对 iPad），比方说我们可以用如下代码添加一个照相机的按钮：</p>
<p><img src="/images/14571865845732.jpg" alt=""></p>
<h3 id="Text_Field_Delegate_and_Control_Event_Messages"><a href="#Text_Field_Delegate_and_Control_Event_Messages" class="headerlink" title="Text Field Delegate and Control Event Messages"></a>Text Field Delegate and Control Event Messages</h3><p>这里我们大概了解下相关的代理方法：</p>
<p><img src="/images/14571866342387.jpg" alt=""></p>
<p>比方说，我们可以只让用户输入小写字母，如下：</p>
<p><img src="/images/14571866536210.jpg" alt=""></p>
<p><img src="/images/14571866843681.jpg" alt=""></p>
<p>我们同样也可以在不同的时候给 text field 加上不同的 target-action 操作</p>
<p><img src="/images/14571867374814.jpg" alt=""></p>
<p>比方说，可以用下面的技巧，不写代码（或者很少代码）来让键盘自动消失：</p>
<p><img src="/images/14571868075239.jpg" alt=""></p>
<p>用户双击或者长按 text field 的时候，会出现菜单，比较常见的操作有：</p>
<p><img src="/images/14571869442936.jpg" alt=""></p>
<p>我们也可以自定义不同的菜单，加上对应的操作，具体这里不赘述</p>
<h2 id="Text_Views"><a href="#Text_Views" class="headerlink" title="Text Views"></a>Text Views</h2><p>Text View 和 text field 很类似，是一个 scroll view 的子类，但不是一个 control：</p>
<p><img src="/images/14571871067875.jpg" alt=""></p>
<p><img src="/images/14571871132224.jpg" alt=""></p>
<p>text view 的代理方法和通知同样和 text field 很类似：</p>
<p><img src="/images/14571871588928.jpg" alt=""></p>
<p>但是也有一些不同：</p>
<p><img src="/images/14571871701897.jpg" alt=""></p>
<p><img src="/images/14571871838313.jpg" alt=""></p>
<h2 id="Text_Kit"><a href="#Text_Kit" class="headerlink" title="Text Kit"></a>Text Kit</h2><p>在 <code>UITextView</code> 中可以直接访问 Text Kit 引擎，如：</p>
<p><img src="/images/14571879660310.jpg" alt=""></p>
<p>具体包括：</p>
<p><img src="/images/14571879856074.jpg" alt=""></p>
<p>具体有很多技巧，可以做出很浮夸的效果，以后专门写一篇，这里不深入了。</p>
<p>其实不需要 Text view 也可以使用 Text Kit，同样是直接绘制的方式。这部分内容还是需要更多的实践，后面会出实例教程的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>几乎所有的应用都需要显示文字，iOS 以简单的方式提供了强大且复杂的文字显示功能，很多时候我们只需要指定文字内容即可，这一章我们来看看 Text 的相关内容。</p>]]>
    
    </summary>
    
      <category term="Text" scheme="http://wdxtub.com/tags/Text/"/>
    
      <category term="iOS9" scheme="http://wdxtub.com/tags/iOS9/"/>
    
      <category term="学习" scheme="http://wdxtub.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://wdxtub.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[北美找工作软实力指南]]></title>
    <link href="http://wdxtub.com/2016/03/04/na-job-soft-skill/"/>
    <id>http://wdxtub.com/2016/03/04/na-job-soft-skill/</id>
    <published>2016-03-04T22:34:02.000Z</published>
    <updated>2016-03-05T02:22:39.000Z</updated>
    <content type="html"><![CDATA[<p>在北美找工作，除了基本的『硬实力』外，很多文化相关的『软实力』可能也起到了至关重要甚至是决定性的作用，这里总结了我在 CMU 研讨班学到的相关知识，希望能给还在努力『揾食』的同学们一些帮助。</p>
<a id="more"></a>
<hr>
<h2 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文的主要内容，来自于 ICC(Intercultural Communication Center) 关于找工作面试的讲义以及老师在研讨班上的讲解。上一次的学习记录在 <a href="http://wdxtub.com/2016/02/23/pronunciation-stress/">英语口语中的『噪声』</a> 一文中。</p>
<p>开始之前，一定要先摆正心态，之所以把这一点特别拿出来说明，因为我深知我们的文化中包含着的对『野路子草根逆袭』的『倾向』（比如说，对太平天国的『评价』）。但是至少在找工作这件事情上，有没有受过培训，有没有去刻意练习，身经百战的面试官肯定是能一眼看出来的。这里说的培训，主要指的是，在从学校过渡到社会的过程中，有没有针对性去进行职业态度的培训。从衣着仪态，到礼节谈吐，最后到对自己的认知，都是题中之义。当然，不可否认有些人天赋异禀，不需要太多训练就可以自然切换到『职业』模式，但是对于更多的人来说，参加不同的研讨班，有针对性地打磨自己的各项『软实力』，从依赖直觉（可能是天赋，也可能是幻想出来的）逐渐变成依赖技能，才是稳扎稳打的选择。</p>
<p>美国的学生从高中起就会开始做性格评估以寻找自己可能适合的工作，并且在找工作找实习的时候会花大量的时间上培训班，进行刻意练习。我们作为『外国人』，本身在语言和文化适应性上就差了一截，更应该花时间去认真打造自己的软实力，善于利用各种专业资源（研讨班，职业发展中心等等）来快速提高自己。闭门造车后『一鸣惊人』需要的天资和努力远超大部分人想象，还是不断在实践中提高自己比较靠谱（或者直接可以说，软实力闭门造车没用，因为最终还是需要根据实际来调整）。</p>
<p>另外，其实不存在某个『准备好了』的时间点，做任何事情（不只是找工作），我们都应该好好评估自己之前的经验，试着让下一次比上一次更好，用发展的眼光看问题，也许才是找到最终答案的『捷径』。</p>
<p>举个例子，CMU 定期有各种各样的培训班，细致到找工作的每一个环节，比如：</p>
<ul>
<li>推荐信是什么，应该怎么写</li>
<li>面试应该穿什么</li>
<li>面试过程中的仪态应该怎么样</li>
<li>作为打开话题的 Small Talk 应该怎么说</li>
<li>怎么样自我介绍</li>
<li>在边吃饭边面试的场景中，应该如何表现</li>
<li>如何利用所谓的『关系』</li>
<li>如何回答某些『常规』问题</li>
</ul>
<p>这些东西如果要自己模式，恐怕要花费大量的时间和精力，为什么不利用好学校的资源，去『武装』一下自己呢？（很多同学眼里只有刷题却不去准备自己的软实力，就属于看起来感动自己的勤奋却没多少功效的战术勤奋战略偷懒）</p>
<p>虽然很多东西无法『训练』出来，毕竟江山易改本性难移，但是我们至少可以变得更有『职业素养』一些。</p>
<h2 id="u95EE_u95EE_u81EA_u5DF1"><a href="#u95EE_u95EE_u81EA_u5DF1" class="headerlink" title="问问自己"></a>问问自己</h2><ul>
<li>What expectations/concerns do you have about job interviewing in the US?</li>
<li>Think about the kind of job you might look for. Be <strong>specific</strong>: job title, company, location, type, etc</li>
<li>Highlight your skills in relation to the job listed above</li>
<li>What are your strengths in relation to this job</li>
<li>What are your weaknesses</li>
<li>What are your <strong>short-term</strong> career goals</li>
<li>What are your <strong>long-term</strong> career goals</li>
</ul>
<p>这些问题其实一点都不好回答，无论是『找到自己』还是『认识自己』都是非常艰难的，但是不去找，就肯定找不到。</p>
<p>不过还是可以给出一点我自己的经验，多去试试，不知道自己想要什么，那么就不如排除法，看看自己不喜欢什么（这个一般比较容易感觉出来），慢慢就能找到方向了。</p>
<h2 id="u8F6F_u5B9E_u529B_u8981_u70B9"><a href="#u8F6F_u5B9E_u529B_u8981_u70B9" class="headerlink" title="软实力要点"></a>软实力要点</h2><ul>
<li>Highlight your skills and experience (not the time to be modest - you have to “sell yourself”)</li>
<li>Demonstrate cultrually appropriate trait, e.g. assertiveness, awareness of strengths and goals</li>
<li>Use “small talk” to show your social and cultural expertise</li>
<li>Communicate with non-verbal aspects of the interview: dress, handshakes, eye-contact, posture</li>
<li>Make use of the “networking” connections that are acceptable in the United States</li>
<li>Respond to the kinds of questions asked in US interviews</li>
</ul>
<p>下面是具体的要点叙述，篇幅所限不展开了（硬广：如果需要具体情况具体分析，欢迎来请我吃饭）</p>
<h3 id="Self_Promotion"><a href="#Self_Promotion" class="headerlink" title="Self Promotion"></a>Self Promotion</h3><ul>
<li>Assertiveness</li>
<li>Confidence in openly discussing goals and accomplishments</li>
<li>Follow-up(thank you notes, phone inquiries)</li>
<li>Appropriate dress</li>
</ul>
<p>不止要说自己的优点，还要用具体的事例证明，学会讲故事（不会讲故事的创业公司都死了）</p>
<p>如果可能，thank you note，一是表示态度，二是补充信息，充分展示自己</p>
<h3 id="Directness_in_Communication"><a href="#Directness_in_Communication" class="headerlink" title="Directness in Communication"></a>Directness in Communication</h3><ul>
<li>Open and direct responses to questions</li>
<li>Eye contact, relaxed posture and appropirate non-verbal behavior</li>
</ul>
<p>有啥说啥，明确说出来，比方说口音，或者语速，直接自己听不清楚，请求说清晰一点或慢一点</p>
<h3 id="Self-Disclosure"><a href="#Self-Disclosure" class="headerlink" title="Self-Disclosure"></a>Self-Disclosure</h3><ul>
<li>Personal descriptions of experiences, hobbies, strengths and weaknesses</li>
<li>Related answer to personality (e.g., leadership style, problem solving abilities)</li>
</ul>
<p>可以说兴趣爱好，但是要说明这些兴趣爱好给你带来了什么，对具体的工作有什么帮助。</p>
<p>想想产品发布会时候的用词和感觉。</p>
<p>是否了解自己，通过缺点和优点两个不同的视角来观察。</p>
<h3 id="Career_goals"><a href="#Career_goals" class="headerlink" title="Career goals"></a>Career goals</h3><ul>
<li>Demonstrating knowledge of self, career goals, and how they relate to this job</li>
<li>Discussion of long-range career plans</li>
</ul>
<p>什么都想做，就什么都做不好。</p>
<p>真的需要好好想这个问题</p>
<h3 id="Informality_of_Interview_Process"><a href="#Informality_of_Interview_Process" class="headerlink" title="Informality of Interview Process"></a>Informality of Interview Process</h3><ul>
<li>Congenial interviewing environment that encorages openness, some joking and exchange of information</li>
</ul>
<p>具体的语境切换，俗称『阅读空气』</p>
<h3 id="Individual_Equality"><a href="#Individual_Equality" class="headerlink" title="Individual Equality"></a>Individual Equality</h3><ul>
<li>Race, sex, age should not affect relationship</li>
</ul>
<p>我的建议是，最好彼此都抽离成一个无性别无年龄无人种的『综合个体』来进行交流</p>
<h3 id="Preparation_about_Organization"><a href="#Preparation_about_Organization" class="headerlink" title="Preparation about Organization"></a>Preparation about Organization</h3><ul>
<li>Obtain as much information as possible about job and organization</li>
<li>Demonstrate awareness in letters and in interview</li>
</ul>
<p>看起来要专业，形式影响心态，不要太随便，心态上认真。比如说即使是电话面试，事先准备好仪容仪表也是一个很好的热身。</p>
<h2 id="u5E38_u89C1_u95EE_u9898_u53CA_u89E3_u7B54"><a href="#u5E38_u89C1_u95EE_u9898_u53CA_u89E3_u7B54" class="headerlink" title="常见问题及解答"></a>常见问题及解答</h2><p>下面是面试中经常会出现的问题，准备好对应的故事来『证明』自己，尤其是后面几条 yes/no 的问题，千万不能说个答案（虽然通常肯定要答 yes）然后开始『谜之沉默』，要抓住机会展示自己。</p>
<p>留意下面问题中面试官可能想要听到的你的特质：</p>
<ul>
<li>Tell me about yourself</li>
<li>What are your major strengths</li>
<li>What are your major weakness</li>
<li>What are your short-range objectives</li>
<li>What are your career objectives</li>
<li>What was the last book you read?</li>
<li>If you could start again, what would you do differently? (Note: you cannot say “nothing”)</li>
<li>What interests you most about the position we have? What interests you least?</li>
<li>Why weren’t your grades better? or why haven’t you obtained a job so far? (Note: do not be defensive; this may be a test of your ability to handle pressure or to analyze your own situation)</li>
<li>What if you were in charge of this (company, research group, department)? Why should we hire you?</li>
</ul>
<p>注意拓展这些 yes/no 问题：</p>
<ul>
<li>Can you work under pressure</li>
<li>Are you a leader</li>
<li>Are you creative</li>
<li>Can you work as a member of a team</li>
</ul>
<p>所有的问题，可以记住关键词，但是整个叙述过程一定要自然，不要背课文。这里举一个例子，比如说面试官问 “Can you work under pressure?”，可以这么回答：</p>
<p>我可以承受压力，你知道在 CMU 期末考试压力非常大（可以具体渲染下如何压力大），但是我还是分配好了时间并得到高分，我觉得这是一个能抗压的表现。</p>
<p>其他的都可以按照这个思路回答。</p>
<h3 id="Small_Talk"><a href="#Small_Talk" class="headerlink" title="Small Talk"></a>Small Talk</h3><p>就是日常开启话题的闲聊，展示基本的社交能力，要注意像乒乓球，有来有回，不要出现『这话我没法接』的情况，具体怎么聊天，又是另一个话题，有空我再说。</p>
<ul>
<li>随口吹水的话题<ul>
<li>天气、居住城市、墙上的作品或者照片、共同兴趣、体育、旅行</li>
</ul>
</li>
<li>绝对不要提的话题<ul>
<li>年龄、宗教、政治、钱、婚姻状况</li>
</ul>
</li>
</ul>
<h2 id="u6700_u540E_u8BF4_u4E24_u53E5"><a href="#u6700_u540E_u8BF4_u4E24_u53E5" class="headerlink" title="最后说两句"></a>最后说两句</h2><p>其实上面任何一个小点都可以展开成一个很大的话题，这里简单举几个例子：</p>
<ul>
<li>仪容仪表<ul>
<li>男生，领带最好不要是红色(aggressive)，蓝色是比较安全的选择（体现团队合作）</li>
<li>女生，千万不要喷香水</li>
<li>穿正装不要穿白袜子</li>
<li>具体可以看看最近美国大选不同竞选人是怎么穿着，以及如何搭配他们对应的竞选风格的</li>
<li>一本书《Dress for Success》</li>
</ul>
</li>
<li>握手要坚定用点力，不过目的不是捏爆别人的手</li>
<li>上面提到的要求很多是有文化冲突的，也就是在美国大家习惯这样，可能在中国是另一套；我们需要意识到这种差别，但是千万不要矫枉过正，尽可能还是要按照自己舒服的方式来表现</li>
<li>守时！有些同学迟到半个小时，老师直接跟他们说 “too late to join”，我觉得这种惩罚方式很好，既然约定好了，就不要浪费大家的时间，或者把自己的话当放屁</li>
</ul>
<p>最后祝愿大家都能找到心仪的工作，贴一段我之前周记里写的话作为结束：</p>
<blockquote>
<p>找工作与其说是找一份工作，不如说是找到自己适合什么工作，化简一下就是找到自己。在不断的测试中了解自己擅长什么，喜欢什么，想要什么，这个很关键。具体到刷题之类的东西，其实是个人努力，有一个基准线在那里，过了就好。我想做什么工作，你能提供什么职位，这两个有多匹配，能不能接受，能接受咱们继续，不行就好聚好散。选择工作就是选择环境，不要被各种乱七八糟的光环亮瞎了双眼，还是那句话，要有自己的判断和选择，不能『随大流』。</p>
</blockquote>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.howtodothings.com/how-to-make-small-talk-during-a-job-interview" target="_blank" rel="external">How To Make Small Talk During a Job Interview</a></li>
<li><a href="https://www.youtube.com/watch?v=OTx_oXdHSis" target="_blank" rel="external">You Look Terrible: How NOT to Dress for a Job Interview</a></li>
<li><a href="https://www.cmu.edu/icc/index.shtml" target="_blank" rel="external">ICC 网站</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在北美找工作，除了基本的『硬实力』外，很多文化相关的『软实力』可能也起到了至关重要甚至是决定性的作用，这里总结了我在 CMU 研讨班学到的相关知识，希望能给还在努力『揾食』的同学们一些帮助。</p>]]>
    
    </summary>
    
      <category term="交际" scheme="http://wdxtub.com/tags/%E4%BA%A4%E9%99%85/"/>
    
      <category term="找工作" scheme="http://wdxtub.com/tags/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="文化" scheme="http://wdxtub.com/tags/%E6%96%87%E5%8C%96/"/>
    
      <category term="英语" scheme="http://wdxtub.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第八周 - 请走人行道]]></title>
    <link href="http://wdxtub.com/2016/03/04/walkway/"/>
    <id>http://wdxtub.com/2016/03/04/walkway/</id>
    <published>2016-03-04T13:13:24.000Z</published>
    <updated>2016-03-04T14:11:24.000Z</updated>
    <content type="html"><![CDATA[<p>不懂什么是骄傲，不懂什么是个性，不懂什么才算胡闹。</p>
<a id="more"></a>
<hr>
<p>腥风血雨的考试周总算是安然度过，虽然还有几百个坑要填，但是至少在接下来了两个月里有比较稳定的时间推进自己的计划了。少不了更高负荷的工作，不过做自己喜欢且想做的事情，本就没有苦与累。</p>
<p>最近的伙食标准比油价还低，基本都是做一顿吃两天，弄点肉加上豆子玉米胡萝卜，呼噜噜就是一大锅，有空的时候炒个青菜，这样每次煮个饭，往饭上一盖一浇，完事儿！时间久了，室友就吐槽『我都问吐了你还没吃吐嘛』。本来想回敬一波鸡汤，不过最后还是决定，只要她们不吐在我锅里，咱们就还是阳关道和独木桥。</p>
<p>不过这样吃有个好处，因为同样的肉往往要吃一个星期，现在对随着时间推移的肉质衰减以及不同部位的口感有了完全不同的认识。不过仔细想想这也有坏处，以后在学校吃快餐肯定得一边想着这是剩了几天的肉一边往肚子里塞了。另外一个收获是不同部位的差别真的跟价钱上反映出来的一致，一开始也许只能大概感觉出不同，但是一直吃吃吃，就真的能吃出个门道。</p>
<p>美国这边的肉（尤其是猪肉）大多带有奇怪的腥臭味（至少我家附近的超市里卖的是这样），区别就是贵的味道小一些，突出表现就是要么需要做之前焯一下，要么就煮的时候需要滤出血渣雪沫（不然味道不好）。抛开这个不说，切肉的时候，不同的纹理，不同的肥瘦，不同的切法都会影响最终的口感。总体来说，还是里脊部分（或者其他同等位置）的肉无论纹理还是口感最好（排骨不在比较之列，带骨头现在比较少吃了）。不过因为纹理结构比较深，最好提前腌制一下，这样更入味。</p>
<p>基础好的肉，口感衰减得比较慢，估计是因为内在结构更加紧密一些；基础差的肉，很快就散架了（可以想象肉松都是什么肉做的）。这个故事告诉我们，如果我们一定要做一块肉，那么要好好锻炼，成为有嚼劲紧实的肌肉，不要做松松垮垮的肥肉（但是五花肉也很好吃，纠结）。</p>
<p>最近身边的同学都进入了找工作找实习的白热化阶段，虽然我现在无论怎么样都有点『站着说话不腰疼』的感觉，不过还是觉得越是在意的事情，越应该淡定。在学校里要获得肯定，更多是一个单边操作，好好学习，好好考试，好好做研究，好好发论文，自然水涨船高。但是工作中不是养，变成了双边关系，很多老师未曾教过的东西，反而成为了关键。</p>
<p>找工作与其说是找一份工作，不如说是找到自己适合什么工作，化简一下就是找到自己。在不断的测试中了解自己擅长什么，喜欢什么，想要什么，这个很关键。具体到刷题之类的东西，其实是个人努力，有一个基准线在那里，过了就好。我想做什么工作，你能提供什么职位，这两个有多匹配，能不能接受，能接受咱们继续，不行就好聚好散。遇到的面试官很多，真正能让我看出有『智慧』的凤毛麟角（挑一道现成的面试题谁不会呢？），很多时候也影响了我对这家公司的看法。选择工作就是选择环境，不要被各种乱七八糟的光环亮瞎了双眼，还是那句话，要有自己的判断和选择，不能『随大流』。</p>
<p>前些天快到学校的时候，脑子里蹦出了『Form』 这个词，没想到特别合适的中文词汇（也许『形成』或者『塑造』合适？）。回忆过去，从小学到初中，从初中到高中，从高中到大学，从大学到研究生，虽然可能当时感觉不到太多的变化，但是按照历史课本的说法，总有那么一个标志性事件，把一条线段一分为二。在这个时间点之前，可以看做是发散的自我逐渐汇聚形成新自我的过程，而在这个时间点之后，是把自己重新散开等待下一个自我形成的过程。新的自我是怎么样的，就是『Form』的过程了。找到几个关键的核心，然后创造出新的『原子』和『分子』，最后形成全新的自己。不破不立，长肌肉是这样，成长同样也是这样。</p>
<p>既然如此，就不要害怕未知，不要害怕迷茫，每次都选择正确的事做很难，不如直接做自己喜欢做的事情（压根不需要选择了），坚持，直到它成为正确的事情。</p>
<p>世界很大无数奥妙，我要寻找我要奔跑，冲进那自由天地，什么事我都要做到。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>不懂什么是骄傲，不懂什么是个性，不懂什么才算胡闹。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="春假" scheme="http://wdxtub.com/tags/%E6%98%A5%E5%81%87/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 反思课 2 并发编程的策略与思考]]></title>
    <link href="http://wdxtub.com/2016/03/03/cc-rethink-2/"/>
    <id>http://wdxtub.com/2016/03/03/cc-rethink-2/</id>
    <published>2016-03-03T12:28:38.000Z</published>
    <updated>2016-03-03T15:03:41.000Z</updated>
    <content type="html"><![CDATA[<p>学习是一个不断改进方法论的过程，<a href="http://wdxtub.com/2016/02/29/cc-15/">第 15 课</a>中，因为自己缺乏对并发编程的基本认识，走了很多弯路。吃一堑长一智，本文着重讲三点：一是为什么我会犯错，二是对并发编程的一些思考，三是结合 Java 语言来探索相关细节。（感谢节瓜 @jiexing 的耐心指导）</p>
<a id="more"></a>
<hr>
<h2 id="u5E94_u7528_u573A_u666F"><a href="#u5E94_u7528_u573A_u666F" class="headerlink" title="应用场景"></a>应用场景</h2><p>因为涉及到具体的问题，所以先大概说明一下应用场景，方便之后的叙述。事情大概是这样的：</p>
<ul>
<li>后端有三台数据库服务器</li>
<li>需要支持两种不同的存储策略（复制机制与分区机制，详情参考<a href="http://wdxtub.com/2016/02/29/cc-15/">这里</a>）</li>
<li>由前端来接收和处理请求（不使用任何缓存）</li>
<li>请求有两种：GET（从数据库读取数据）与 PUT（向数据库写入数据）</li>
<li>数据的格式是键值对</li>
<li>保证数据的强一致性</li>
<li>按照请求的顺序返回响应（按照时间戳来排序）</li>
</ul>
<p>难点在于，每来一个请求，服务器都会新开一个线程来进行处理，多个线程的访问需要保证数据一致性及顺序，如果没有真正理解场景本身，很容易陷入无谓的复杂度，写出冗长却不完备的代码。</p>
<h2 id="u6211_u9519_u4E86"><a href="#u6211_u9519_u4E86" class="headerlink" title="我错了"></a>我错了</h2><p>写代码之前，我花了很多时间，试图找到一个合理的满足一致性和顺序的机制。根据文档的提示，用锁来保证一致性，用优先队列来保证顺序，万万没想到这就是一切复杂度的开端，最后我折腾出来的机制大概是这样的：</p>
<ul>
<li>每个 key 有自己的锁和优先队列</li>
<li>每来一个请求，把它加入到对应 key 的优先队列中</li>
<li>然后开一个线程，取出优先队列的队头进行处理</li>
<li>具体线程之间的同步由锁完成（在停止尝试之前已经变得很复杂，这里不详细展开，总的来说我试图利用三个状态手动控制线程的执行）</li>
<li>因为不同的线程可能需要访问同一个数据结构（这里我用 HashMap 来存储），也要考虑线程同步的问题，于是我决定依赖于『线程安全』的数据结构自动处理好访问冲突</li>
</ul>
<p>看起来还行，但是实际测试的时候既不能保证强一致性也没办法按顺序，甚至还引入了新的问题，这是为什么呢？我总结的原因如下：</p>
<ul>
<li>每次接收请求，新开的线程不一定执行这个请求对应的内容，而是执行队列头，让新线程做太复杂的工作</li>
<li>为了保证逻辑一致性被迫设计状态判断的机制，但是没办法穷举出所有的可能</li>
<li>控制线程时利用自动数据结构+手动逻辑控制，并没有得到半自动冲锋枪突突突的效果，而是乱成了一锅粥</li>
</ul>
<p>后来在瓜瓜的指引下找到了简单且有效的方法，关键点在于：</p>
<ul>
<li>要自动就全自动，要手动就全手动，不要依赖于自己并不完全理解的容器或者数据结构，因为很可能会和自己预期的表现不一样</li>
<li>每个线程应该就处理好传入的请求，而不是可能执行另外的请求（我之前的机制这种情况是可能出现的）</li>
<li>不要想当然去『控制』线程以达到最优性能，很多串行编程的思维在这里并不适用。</li>
</ul>
<p>从这样的思路拓展开去，就可以意识到自己之前的思路有多么『想当然』了。</p>
<h2 id="u4E00_u4E9B_u601D_u8003"><a href="#u4E00_u4E9B_u601D_u8003" class="headerlink" title="一些思考"></a>一些思考</h2><blockquote>
<p>Intuition is frequently wrong - be data intensive. [《Real-World Concurrency》 from ACM-Queue]</p>
</blockquote>
<p>如果要给云计算这门课一个关键词，当属 tradeoff。所谓权衡的艺术，从不同的角度来看，有不同的表现：</p>
<ul>
<li>从实现的角度，尽量以最小的代码换取最大的性能</li>
<li>从架构的角度，尽量以简洁的架构满足需求，减少复杂性</li>
<li>从经济的角度，尽力以最小的花费提供最好的服务质量</li>
</ul>
<p>同样的，对于并发编程，也是如此。</p>
<blockquote>
<p>Multi-threading is easy. Correct synchronization is hard</p>
</blockquote>
<p>最难的当属思维的转换，很多比较复杂的算法（或者说依赖比较多的算法），在并行环境中往往表现不好，比如说动态规划问题，原本是重复利用子问题的解，但是在多线程的条件下，子问题都不知道飞哪里去了；反而是分治算法，因为子问题独立，反而更适合并行。</p>
<p>而提到并发编程，就不得不提 OpenMP 了，这个学期当助教，我主要负责这一部分的内容，所以也算是有一些理解。OpenMP 的思路是利用尽可能少的代价，把串行代码弄成并行的，核心的机制是共享内存，然后利用线程执行不同的子问题，可能只需要几条 OpenMP 预编译指令，就可以带来明显的性能提升效果。</p>
<p>但是仔细想想，这种改进真的很大吗？在串行代码开发中，程序控制有一个清晰的流程。我们知道数据被访问和更改的方式，并了解其中的依赖关系。究其根本，OpenMP 依赖数据资源的锁定，和串行编程的思路是一样的，只是利用多核进行了简单的并行处理（相当于多叫几个人完成同一个工作，而不是大家做不同的工作）。如果使用不慎，除了带来性能问题之外，还可能造成数据不一致的问题。</p>
<p>而真正的并行程序中，有多个状态会同时发生和改变，依赖关系也会发生变化。必须思考如何同时执行多个指令，以及这些指令会对你的数据结构、变量、算法及其它一切产生什么影响。</p>
<p>总结一下：</p>
<ul>
<li>单线程逻辑设计的思路<ul>
<li>所有数据结构的生存期，以及对这些数据结构的访问都在同一个线程，不存在竞争条件，耗时的操作都给其他线程（IO线程、定时器线程，数据库线程等）做，做完之后向事件队列（多线程安全的队列，其他线程是生产者，逻辑线程是消费者）发送事件</li>
</ul>
</li>
<li>多线程逻辑设计的思路<ul>
<li>所有数据结构的生存期，以及对这些数据结构的访问不一定在同一个线程。需要考虑数据结构的竞争条件。网络事件、定时器事件唤醒工作线程（比方说 <code>notifyAll</code>）执行所有工作，一般不需要交换到其他线程</li>
</ul>
</li>
</ul>
<p>我们可以看出，最关键的就是如何访问数据的问题！线程执行和访问数据的时间没有确定的顺序。操作系统负责对线程进行调度，而它对于数据访问模式一无所知。并行程序中唯一的顺序是我们利用同步方法明确创建的（前面我把这部分工作交给自己并不熟悉的并行库来做，导致出问题）。最重要的是要牢牢记住所有并发线程，这样才能够创建更简单更有约束性的结构来限制并发情况。还有一个需要记得的点是，可能最优化的串行算法并不是好的并行算法。</p>
<p>最后的最后，并发编程真的是一门『纸上得来终觉浅』的艺术，最佳途径就是实践，实践，再实践。</p>
<h2 id="u4E00_u4E9B_u5BF9_u7B56"><a href="#u4E00_u4E9B_u5BF9_u7B56" class="headerlink" title="一些对策"></a>一些对策</h2><p>这里结合了 CMU 18645 How to Write Fast Code 课程上的一些思路，虽然对于具体场景不算特别适用，不过总体原则放到哪里都能用。</p>
<p>先说说优化并行部分的三个层面：</p>
<ul>
<li>逻辑层面：减少数据共享<ul>
<li>这一部分需要注意 false sharing 的问题，不然反而会造成大量的缓存浪费</li>
<li>解决方法也不算太难：线程本地存储 + 内存对齐，不过需要根据不同的机器不同处理</li>
</ul>
</li>
<li>编码层面：减少锁粒度<ul>
<li>同一个模块中，对不总是同时访问的数据，使用不同的锁（固定加锁顺序，防止死锁）</li>
<li>使用锁（临界区）来保护数据，而不是操作</li>
<li>将可能耗时的操作移到临界区外面（特别是 IO）</li>
<li>避免在临界区中调用未知代码 </li>
<li>谨慎使用读写锁，实现复杂，效率低下</li>
</ul>
</li>
<li>工具层面：使用轻量同步机制<ul>
<li>有些需要深入到内核态进行同步，对于基本的操作来说其实没必要这么兴师动众</li>
</ul>
</li>
</ul>
<p>换一个视角，可以总结出如下四条原则：</p>
<ol>
<li>单一职责：分离并发相关代码和其他代码（并发相关代码有自己的开发、修改和调优生命周期）</li>
<li>限制数据作用域：两个线程修改共享对象的同一字段时可能会相互干扰，导致不可预期的行为，解决方案之一是构造临界区，但是必须限制临界区的数量</li>
<li>使用数据副本：数据副本是避免共享数据的好方法，复制出来的对象只是以只读的方式对待</li>
<li>线程应尽可能独立：让线程存在于自己的世界中，不与其他线程共享数据。Servlet 就是以单实例多线程的方式工作，和每个请求相关的数据都是通过 Servlet 子类的 service 方法（或者是 doGet 或 doPost 方法）的参数传入的。只要 Servlet 中的代码只使用局部变量，Servlet 就不会导致同步问题</li>
</ol>
<p>在搜索资料的时候发现一个不错的提纲，不过因为刚接触，很多概念理解得不算特别清楚这里列出来，作为一个索引，感兴趣的同学可以按图索骥去深入了解下（参考资料中第二项）：</p>
<ul>
<li>资源并发访问的策略<ul>
<li>悲观策略<ul>
<li>lock based concurrency(theory)</li>
<li>java.util.concurrent (framework)</li>
<li>锁还是不锁，这是个问题， 锁多还是锁少，也是个问题(practice)</li>
</ul>
</li>
<li>乐观策略<ul>
<li>lock free concurrency(theory) : CAS</li>
<li>disruptor (framework)</li>
<li>并发度高，还是并发度低的时候使用，这是个问题(practice)</li>
</ul>
</li>
</ul>
</li>
<li>我拆我拆我拆拆拆（逻辑上拆分任务）<ul>
<li>task-based concurrency (theory)<ul>
<li>Runnable | Callable(model)</li>
<li>Executor | ExecutorService(framework)</li>
</ul>
</li>
<li>data-based concurrency(theory)<ul>
<li>Actor (model)</li>
<li>Akka(framework)</li>
</ul>
</li>
</ul>
</li>
<li>从单机到分布式<ul>
<li>divide and conquer<ul>
<li>map reduce pattern</li>
<li>master-worker pattern</li>
</ul>
</li>
<li>swarm framework(move computation instead of data)</li>
</ul>
</li>
<li>从软件到硬件<ul>
<li>GPU<ul>
<li>CUDA, jcuda, scuda</li>
<li>floating point computation, e.g. image reader and processing</li>
</ul>
</li>
<li>PPU<ul>
<li>物理计算</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>看了这么多，唯一的感受就是</p>
<blockquote>
<p>路漫漫其修远兮，吾将上下而求索。</p>
</blockquote>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.jianshu.com/p/053943a425c3" target="_blank" rel="external">Java并发编程的总结与思考</a></li>
<li><a href="http://afoo.me/posts/2013-03-12-concurrency_theory_frameworks_and_practices.html" target="_blank" rel="external">并发编程： 理论，框架与实践</a></li>
<li><a href="http://blog.csdn.net/lantian0802/article/details/19285937" target="_blank" rel="external">java并发编程学习总结（基础篇）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>学习是一个不断改进方法论的过程，<a href="http://wdxtub.com/2016/02/29/cc-15/">第 15 课</a>中，因为自己缺乏对并发编程的基本认识，走了很多弯路。吃一堑长一智，本文着重讲三点：一是为什么我会犯错，二是对并发编程的一些思考，三是结合 Java 语言来探索相关细节。（感谢节瓜 @jiexing 的耐心指导）</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="多线程" scheme="http://wdxtub.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 Twitter 语料分析 3 Vert.x 配置部署]]></title>
    <link href="http://wdxtub.com/2016/03/01/cc-p3/"/>
    <id>http://wdxtub.com/2016/03/01/cc-p3/</id>
    <published>2016-03-01T20:42:05.000Z</published>
    <updated>2016-03-02T00:19:44.000Z</updated>
    <content type="html"><![CDATA[<p>我们需要比较两个不同的 web 框架的性能，于是也选择了当下比较热门的 Vert.x 框架来做比较，网上的中文资源还是比较少的，这里同样记录一下如何在 EC2 上搭建和部署 Vert.x。</p>
<a id="more"></a>
<hr>
<h2 id="u73AF_u5883_u914D_u7F6E"><a href="#u73AF_u5883_u914D_u7F6E" class="headerlink" title="环境配置"></a>环境配置</h2><p>先启动一个标准的 Ubuntu 镜像（因为有 apt-get 安装软件比较方便）</p>
<p>我们需要安装 java 和 maven，并配置好对应的路径，具体参考下面的命令，这里和之前不同的是需要安装 Java 8，以及 maven 3：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 java,maven</span></span><br><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java8-installer</span><br><span class="line">sudo add-apt-repository <span class="string">"deb http://ppa.launchpad.net/natecarlson/maven3/ubuntu precise main"</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install maven3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认 jdk</span></span><br><span class="line">sudo update-alternatives --config java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 Java Home 编辑 ~/.bashrc</span></span><br><span class="line">JAVA_HOME=/usr/</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span></span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>同样用 maven 来创建项目，这次我们直接手动现在本地建立如下所示的文件层级：</p>
<p><img src="/images/14568662369892.jpg" alt="项目目录"></p>
<p>然后我们修改 <code>pom.xml</code> 文件，具体如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">project</span> <span class="attribute">xmlns</span>=<span class="value">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://maven.apache.org/POM/4.0.0</span><br><span class="line">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="title">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>housailei.vertx<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>vertx-server<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="title">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>io.vertx<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>vertx-core<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="title">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="title">source</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="title">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">execution</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="title">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="title">phase</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="title">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="title">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">transformers</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="title">transformer</span></span><br><span class="line">                    <span class="attribute">implementation</span>=<span class="value">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">manifestEntries</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="title">Main-Class</span>&gt;</span>io.vertx.core.Starter<span class="tag">&lt;/<span class="title">Main-Class</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="title">Main-Verticle</span>&gt;</span>housailei.vertx.App<span class="tag">&lt;/<span class="title">Main-Verticle</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="title">manifestEntries</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="title">transformer</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">transformers</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">artifactSet</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">outputFile</span>&gt;</span>$&#123;project.build.directory&#125;/$&#123;project.artifactId&#125;-$&#123;project.version&#125;-fat.jar<span class="tag">&lt;/<span class="title">outputFile</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们在 <code>src/main/java/housailei/vertx/</code> 下创建一个 <code>App.java</code> 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> housailei.vertx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.core.AbstractVerticle;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; fut)</span> </span>&#123;</span><br><span class="line">    vertx</span><br><span class="line">        .createHttpServer()</span><br><span class="line">        .requestHandler(r -&gt; &#123;</span><br><span class="line">          r.response().end(<span class="string">"&lt;h1&gt;Hello from my first "</span> +</span><br><span class="line">              <span class="string">"Vert.x 3 application! config by dawang&lt;/h1&gt;"</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .listen(<span class="number">8080</span>, result -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">            fut.complete();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fut.fail(result.cause());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们把代码上传回服务器上：<code>scp -i ../group.pem -r ./* ubuntu@dns.amazonaws.com:~/vertx-server/</code></p>
<p>执行的话稍微麻烦一点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn3 clean package</span><br><span class="line">java -jar target/vertx-server-<span class="number">1.0</span>-SNAPSHOT-fat.jar</span><br></pre></td></tr></table></figure>
<p>正常运行如下图所示：</p>
<p><img src="/images/14568725986794.jpg" alt="正常运行截图"></p>
<h2 id="u5B9E_u73B0_REST"><a href="#u5B9E_u73B0_REST" class="headerlink" title="实现 REST"></a>实现 REST</h2><p>前面的代码虽然可以工作，我们没办法设定不同的 api，也没办法做更进一步的处理，所以我们现在来更进一步，实现一个 RESTful 的简易 API。</p>
<p>我们先要在 <code>pom.xml</code> 文件中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>io.vertx<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>vertx-web<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后对应修改 <code>start</code> 方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; fut)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create a router object.</span></span><br><span class="line">   Router router = Router.router(vertx);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bind "/" to our hello message - so we are still compatible.</span></span><br><span class="line">   router.route(<span class="string">"/"</span>).handler(routingContext -&gt; &#123;</span><br><span class="line">   HttpServerResponse response = routingContext.response();</span><br><span class="line">   response</span><br><span class="line">      .putHeader(<span class="string">"content-type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">      .end(<span class="string">"&lt;h1&gt;Hello from my first "</span> +</span><br><span class="line">         <span class="string">"Vert.x 3 application! config by dawang&lt;/h1&gt;"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create the HTTP server and pass the "accept" method to the request handler.</span></span><br><span class="line">   vertx.createHttpServer().requestHandler(router::accept)</span><br><span class="line">       .listen(</span><br><span class="line">       <span class="comment">// Retrieve the port from the configuration,</span></span><br><span class="line">       <span class="comment">// default to 8080.</span></span><br><span class="line">       config().getInteger(<span class="string">"http.port"</span>, <span class="number">8080</span>), result -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">               fut.complete();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               fut.fail(result.cause());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在开始start方法里创建了一个 <code>Router</code> 对象。router 是 Vert.x Web 的基础，负责分发 HTTP 请求到 handler（处理器），在Vert.x Web中还有两个很重要的概念。</p>
<ul>
<li>Route - 定义请求的分发</li>
<li>Handler - 这是实际处理请求并且返回结果的地方。Handlers可以被链接起来使用。</li>
</ul>
<p>如果明白了这3个概念（Router、Routes、Handlers），就能明白 Vert.x Web 了。</p>
<p>重新运行一次，可以看到结果如下：</p>
<p><img src="/images/14568771965878.jpg" alt="再次配置成功"></p>
<p>然后我们多定义几个接口，并对应不同的方法来实现，同样是在 <code>start</code> 方法中，添加两条 router 规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">"/api/hou"</span>).handler(<span class="keyword">this</span>::HouHandler);</span><br><span class="line">router.get(<span class="string">"/api/sai"</span>).handler(<span class="keyword">this</span>::SaiHandler);</span><br></pre></td></tr></table></figure>
<p>然后创建对应的方法（就不用都写在一个函数里了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HouHandler</span><span class="params">(RoutingContext routingContext)</span></span>&#123;</span><br><span class="line">   routingContext.response()</span><br><span class="line">       .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json; charset=utf-8"</span>)</span><br><span class="line">       .end(<span class="string">"This is Hou HOu HOU!!! API!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SaiHandler</span><span class="params">(RoutingContext routingContext)</span></span>&#123;</span><br><span class="line">   routingContext.response()</span><br><span class="line">       .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json; charset=utf-8"</span>)</span><br><span class="line">       .end(<span class="string">"This is Sai SAi SAI!!! API!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再测试一下，可以看到 api 已经启用了：</p>
<p><img src="/images/14568776771132.jpg" alt="Hou Content"></p>
<p><img src="/images/14568776972444.jpg" alt="Sai Content"></p>
<p>有了这些，我们就可以自己来进行操作了，虽然可能代码丑一些，不过易上手，容易改。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://vertx.io/docs/" target="_blank" rel="external">官方文档</a></li>
<li><a href="http://vertx.io/docs/vertx-core/java/" target="_blank" rel="external">Vertx Core 手册</a></li>
<li><a href="http://vertx.io/docs/apidocs/" target="_blank" rel="external">Vertx Core API 文档</a></li>
<li><a href="http://vertx.io/docs/vertx-web/java/" target="_blank" rel="external">Vertx Web 手册</a></li>
<li><a href="http://vertx.io/docs/apidocs/" target="_blank" rel="external">Vertx Web API 文档</a></li>
</ul>
<p>非常有用的新手入门教程</p>
<ul>
<li><a href="http://vertx.io/blog/my-first-vert-x-3-application/index.html" target="_blank" rel="external">My first Vert.x 3 Application</a></li>
<li><a href="http://vertx.io/blog/vert-x-application-configuration/" target="_blank" rel="external">Vert.x Application Configuration</a></li>
<li><a href="http://vertx.io/blog/some-rest-with-vert-x/" target="_blank" rel="external">Some Rest with Vert.x</a></li>
<li><a href="http://vertx.io/blog/unit-and-integration-tests/" target="_blank" rel="external">Unit and Integration Tests</a></li>
<li><a href="https://github.com/quanke/vertx3_study_demo" target="_blank" rel="external">中文机器翻译版本</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们需要比较两个不同的 web 框架的性能，于是也选择了当下比较热门的 Vert.x 框架来做比较，网上的中文资源还是比较少的，这里同样记录一下如何在 EC2 上搭建和部署 Vert.x。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Vertx" scheme="http://wdxtub.com/tags/Vertx/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="服务" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 Twitter 语料分析 2 Undertow 配置部署]]></title>
    <link href="http://wdxtub.com/2016/03/01/cc-p2/"/>
    <id>http://wdxtub.com/2016/03/01/cc-p2/</id>
    <published>2016-03-01T14:41:11.000Z</published>
    <updated>2016-03-01T21:04:27.000Z</updated>
    <content type="html"><![CDATA[<p>因为项目有一定的性能要求，所以我们选择 Undertow 这个微框架来降低框架本身带来的性能影响，但是因为比较小众，所以网上很多资料都不全，这里记录下具体在 EC2 上如何配置和部署 Undertow。</p>
<a id="more"></a>
<hr>
<h2 id="u73AF_u5883_u914D_u7F6E"><a href="#u73AF_u5883_u914D_u7F6E" class="headerlink" title="环境配置"></a>环境配置</h2><p>先启动一个标准的 Ubuntu 镜像（因为有 apt-get 安装软件比较方便）</p>
<p>我们需要安装 java 和 maven，并配置好对应的路径，具体参考下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 java,maven</span></span><br><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java7-installer</span><br><span class="line">sudo apt-get install maven2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认 jdk</span></span><br><span class="line">sudo update-alternatives --config java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 Java Home 编辑 ~/.bashrc</span></span><br><span class="line">JAVA_HOME=/usr/</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span></span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure>
<p>如果一切正常的话，使用 <code>java -version</code> 可以看到：</p>
<p><img src="/images/14568475090854.jpg" alt="java -version"></p>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>我们创建一个项目来搭建服务器，因为 undertow 是使用 maven 来管理包和依赖的，所以我们也直接用 maven 来创建项目</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建项目，注意设置包名和项目名称</span></span><br><span class="line">mvn archetype:generate -DgroupId=housailei.undertow -DartifactId=p1_front -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=<span class="literal">false</span> -DartifactId=undertow-server</span><br></pre></td></tr></table></figure>
<p>为了编辑方便，我们把项目复制到本地</p>
<p><code>scp -i group.pem -r ubuntu@dns.amazonaws.com:~/undertow-server/* ./</code></p>
<p> 编辑完成可以用下面的命令上传回去（注意所在文件夹，我这里新建了一个文件夹用来存放源代码，密钥放在上一层）</p>
<p><code>scp -i ../group.pem -r ./* ubuntu@dns.compute-1.amazonaws.com:~/undertow-server/</code></p>
<p><img src="/images/14568478192103.jpg" alt="目录层级"></p>
<p>我们需要对 <code>App.java</code> 和 <code>pom.xml</code> 做一些修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> housailei.undertow;</span><br><span class="line"><span class="keyword">import</span> io.undertow.Undertow;</span><br><span class="line"><span class="keyword">import</span> io.undertow.server.*;</span><br><span class="line"><span class="keyword">import</span> io.undertow.util.Headers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// 设置成 0.0.0.0 开放访问以便测试</span></span><br><span class="line">        Undertow server = Undertow.builder().addHttpListener(<span class="number">8080</span>, <span class="string">"0.0.0.0"</span>)</span><br><span class="line">            .setHandler(<span class="keyword">new</span> HttpHandler() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> HttpServerExchange exchange)</span></span><br><span class="line">                       <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,</span><br><span class="line">                           <span class="string">"text/plain"</span>);</span><br><span class="line">               exchange.getResponseSender().send(<span class="string">"Hello World! This is wdxtub."</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;).build();</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 pom 文件的修改主要就是加上各类依赖，已经添加构建插件，我们这里选用了最新的 undertow，具体需要添加以下两个部分：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>io.undertow<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>undertow-core<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.3.18.Final<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>io.undertow<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>undertow-servlet<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.3.18.Final<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>和 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">build</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>exec-maven-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">execution</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="title">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">goal</span>&gt;</span>java<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="title">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">mainClass</span>&gt;</span>housailei.undertow.App<span class="tag">&lt;/<span class="title">mainClass</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后上传回 EC2 实例，就可以用以下代码执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile &amp;&amp; mvn <span class="built_in">exec</span>:java</span><br></pre></td></tr></table></figure>
<p>服务器正常开启之后，我们就可以在浏览器中访问了：</p>
<p><img src="/images/14568488280327.jpg" alt="访问网站"></p>
<h2 id="u6DFB_u52A0_Servlet"><a href="#u6DFB_u52A0_Servlet" class="headerlink" title="添加 Servlet"></a>添加 Servlet</h2><p>现在我们的服务器基本除了展示个页面没办法做任何事情，我们需要能让服务器运行 servlet 才行（最新版本的 undertow 会有一些小问题，会具体标记出来）</p>
<p>我们先写两个简单的 servlet，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个 servlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span>&#123;</span><br><span class="line">        message = <span class="string">"Hou HOu HOU!!!! Servlet!!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(<span class="string">"&lt;h1&gt;"</span> + message + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个 servlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaiServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span>&#123;</span><br><span class="line">        message = <span class="string">"Sai SAi SAI!!!! Servlet!!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(<span class="string">"&lt;h1&gt;"</span> + message + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改 <code>App.java</code> 把这两个 servlet 载入进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYAPP = <span class="string">"/hsl"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 官方例子中使用的 addServlets 方法不可用</span></span><br><span class="line">            <span class="comment">// 这里我用了 addServlet 方法</span></span><br><span class="line">            DeploymentInfo servletBuilder = Servlets.deployment()</span><br><span class="line">                .setClassLoader(App.class.getClassLoader())</span><br><span class="line">                .setContextPath(MYAPP)</span><br><span class="line">                .setDeploymentName(<span class="string">"test.war"</span>)</span><br><span class="line">                .addServlet(</span><br><span class="line">                        Servlets.servlet(<span class="string">"HouServlet"</span>, HouServlet.class)</span><br><span class="line">                                .addMapping(<span class="string">"/hou"</span>))</span><br><span class="line">                .addServlet(</span><br><span class="line">                        Servlets.servlet(<span class="string">"SaiServlet"</span>, SaiServlet.class)</span><br><span class="line">                                .addMapping(<span class="string">"/sai"</span>));</span><br><span class="line"></span><br><span class="line">            DeploymentManager manager = Servlets.defaultContainer().addDeployment(servletBuilder);</span><br><span class="line">            manager.deploy();</span><br><span class="line"></span><br><span class="line">            HttpHandler servletHandler = manager.start();</span><br><span class="line">            PathHandler path = Handlers</span><br><span class="line">                .path(Handlers.redirect(MYAPP))</span><br><span class="line">                .addPrefixPath(MYAPP, servletHandler);</span><br><span class="line"></span><br><span class="line">            Undertow server = Undertow.builder()</span><br><span class="line">                .addHttpListener(<span class="number">8080</span>, <span class="string">"0.0.0.0"</span>)</span><br><span class="line">                .setHandler(path)</span><br><span class="line">                .build();</span><br><span class="line">            server.start();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着还是传到服务器上并 <code>mvn compile &amp;&amp; mvn exec:java</code>，就可以看到结果</p>
<p><img src="/images/14568573432825.jpg" alt="SaiServlet 结果"></p>
<p><img src="/images/14568573815710.jpg" alt="HouServlet 结果"></p>
<p>之后的任务就可以在 Servlet 的 <code>doGet</code> 方法中对应写代码完成了。</p>
<p>后面应该会写一些脚本把配置的工作自动化，因为每次新建 EC2 都得重新配置还是挺麻烦的。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://undertow.io/undertow-docs/undertow-docs-1.3.0/index.html#introduction" target="_blank" rel="external">官方文档</a></li>
<li><a href="http://undertow.io/javadoc/1.3.x/index.html" target="_blank" rel="external">官方 JavaDoc</a></li>
<li><a href="https://github.com/undertow-io/undertow/tree/master/examples/src/main/java/io/undertow/examples" target="_blank" rel="external">官方样例代码</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为项目有一定的性能要求，所以我们选择 Undertow 这个微框架来降低框架本身带来的性能影响，但是因为比较小众，所以网上很多资料都不全，这里记录下具体在 EC2 上如何配置和部署 Undertow。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Undertow" scheme="http://wdxtub.com/tags/Undertow/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="服务" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 第 15 课 分区和复制]]></title>
    <link href="http://wdxtub.com/2016/02/29/cc-15/"/>
    <id>http://wdxtub.com/2016/02/29/cc-15/</id>
    <published>2016-02-29T12:01:54.000Z</published>
    <updated>2016-03-03T04:45:39.000Z</updated>
    <content type="html"><![CDATA[<p>之前我们做的是计算能力的伸缩拓展，这次我们也要对数据库做类似的事情，并且通过具体的场景，来了解键值对存储的应用特点。特别鸣谢瓜瓜 @jiexing 的点拨，不然我就卡在自己脑洞里出不来了。</p>
<a id="more"></a>
<hr>
<h2 id="u5B66_u4E60_u76EE_u6807"><a href="#u5B66_u4E60_u76EE_u6807" class="headerlink" title="学习目标"></a>学习目标</h2><ol>
<li>了解分布式键值对存储的设计空间和动机</li>
<li>比较在键值对存储中使用复制和分区的异同及优劣</li>
<li>利用复制或分区机制来拓展分布式键值对存储</li>
<li>了解并实现一致性哈希算法，并借此说明其在分布式键值对存储中的分区起到的作用</li>
<li>把复制和分区技术应用到现实场景中</li>
</ol>
<p>一致性哈希算法的要求很简单：</p>
<blockquote>
<p>在任何时候，对于同一个 key，要返回同一个 value</p>
</blockquote>
<p>理论上的要求很简洁，但具体实现的时候就会有需要细节了，比方说如何平均分配不同的 key，如果处理错误的状况等等。</p>
<h2 id="u80CC_u666F_u77E5_u8BC6"><a href="#u80CC_u666F_u77E5_u8BC6" class="headerlink" title="背景知识"></a>背景知识</h2><p>随着互联网、电子商务和社交媒体的快速发展，很多公司都不得不面对日益增长的数据量。如何存储、处理和分析这些数据越来越成为巨大的挑战。因为数据量已经远超一台机器可以承载的范围，我们需要分布式可拓展的存储系统。这里我们会专注于分布式键值对存储系统（也是 NoSQL 存储系统）。键值对存储系统支持两个基本操作：</p>
<ol>
<li><code>PUT</code> 请求，把一条记录放到数据库中</li>
<li><code>GET</code> 请求，从数据库中获取指定数据</li>
</ol>
<p>分布式键值对存储包含多个节点（可能不在一个地方），一个比较常见的做法是利用最近的服务器来处理对应请求以减少延迟。</p>
<p>说到数据库的扩展性，我们可以通过下面的视频来进行基本的了解</p>
<p><a href="https://www.youtube.com/watch?v=opYWHWG-vVg" target="_blank" rel="external">Video 1: Database Scaling</a></p>
<p>下面是视频中的要点：</p>
<ul>
<li>Vertical Scaling：提高硬件和软件配置（CPU, Memory, Disk, Network）<ul>
<li>优势：迁移简单，使用已有的软件</li>
<li>限制：硬件成本快速增长，可能最强大的硬件也不够用</li>
</ul>
</li>
<li>Horizontal Scaling：从一台数据库服务器扩展为数据库服务器集群，有下面两种机制来进行<ul>
<li>Replication 复制：每台数据库服务器都有同样的数据，读数据的时候没有问题，写数据的时候需要考虑数据同步的问题。对读数据性能要求较高的应用可以采用这种机制。</li>
<li>Sharding 分区：每台数据库服务器保存部分的数据库文件，需要决定什么时候访问哪台服务器，需要一个分区表。具体的分隔可以以行来分(Horizontal Partitioning)或者以列来分(Vertical Partitioning)。对写数据性能要求较高的应用可以采用这种机制。</li>
</ul>
</li>
</ul>
<p>这两个机制各有侧重点，这里简要介绍一下。</p>
<h3 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h3><p>对于复制机制来说，每次更新数据，都需要把改动『广播』到所有的节点上以保证数据一致性，如果系统的容错性要求很高，那么复制机制可能是比较好的选择，下图是一个例子：</p>
<p><img src="/images/14567497209474.jpg" alt="有 3 个复制节点的数据库"></p>
<p>在复制的情况下，主要的优化机制是提供不同级别的一致性保证。在一个数据库节点的某条记录被修改时，其他数据库中对应的记录是不可访问的，直到三个数据库的数据完全同步之后才可以，如下：</p>
<p><img src="/images/14567498771413.jpg" alt="强一致性保证"></p>
<p>并且，操作的不同顺序也会以时间戳的方式进行记录和排序，为了保证强一致性，需要保证任何时候从任何复制节点读取的数据都是一样的，具体的规则如下表所示</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">强一致性</td>
<td style="text-align:center">任何时候从任何复制节点中相同的 key 对应相同的 value</td>
</tr>
<tr>
<td style="text-align:center">严格排序</td>
<td style="text-align:center">按时间顺序处理请求</td>
</tr>
<tr>
<td style="text-align:center">原子操作</td>
<td style="text-align:center">所有的操作都应该是原子的，不能同时更新</td>
</tr>
<tr>
<td style="text-align:center">访问控制</td>
<td style="text-align:center">一个 key 在被更新时其他节点中的对应 key 不能访问</td>
</tr>
</tbody>
</table>
<h3 id="Sharding"><a href="#Sharding" class="headerlink" title="Sharding"></a>Sharding</h3><p>对于分区机制来说，可以直接用下图来描述与复制机制的区别（比较简单这里不详细介绍）</p>
<p><img src="/images/14567501863377.jpg" alt="三种方式的对比"></p>
<h2 id="u80CC_u666F_u8BBE_u5B9A"><a href="#u80CC_u666F_u8BBE_u5B9A" class="headerlink" title="背景设定"></a>背景设定</h2><p>简单来说就是要做一个支持 <code>PUT</code> 和 <code>GET</code> 的分布式键值对存储系统，保存以下两种数据：</p>
<ol>
<li>销售记录：保存支付密码等关键交易信息，一定要非常安全，不能轻易丢失。用户也会频繁访问购买历史，所以会有很多 <code>GET</code> 的操作，于是会采用复制机制</li>
<li>匿名日志：包含页面访问及歌曲收听记录等匿名日志，只会在用户行为分析的时候使用，并且对于安全性的要求没那么高，反而是会有很多 <code>PUT</code> 的操作，所以会利用分区机制。</li>
</ol>
<p>整个系统的设计如下：</p>
<p><img src="/images/14567578576946.jpg" alt=""></p>
<p>每个 datastore 已经帮我们配置好了，所以不必修改，我们需要做的就是折腾好 <code>Coordinator</code> 部分，也就是接收请求并转发给合适的 datastore</p>
<h2 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h2><p>具体的实现包含两个部分，分别对应前面提到的两种不同的需求。具体的需求如下</p>
<ul>
<li>并发执行<ul>
<li>利用多线程来并行处理不同的请求，已经提供了框架代码</li>
</ul>
</li>
<li>确定的行为<ul>
<li>不会出现竞争条件，利用各种保证并行安全的技术来实现</li>
</ul>
</li>
<li>非阻塞 <code>PUT</code> 操作<ul>
<li>具体参考下面的图示</li>
</ul>
</li>
<li>严格排序<ul>
<li>根据请求到来的顺序处理请求，已有的代码是包含时间戳的</li>
</ul>
</li>
<li>无缓存 Coordinator<ul>
<li>在处理请求的过程中临时保存请求是可以的，但是不能有持久的缓存</li>
</ul>
</li>
<li>动态策略<ul>
<li>Coordinator 应该支持后端的变动</li>
</ul>
</li>
</ul>
<p><img src="/images/14567593452426.jpg" alt="错误！阻塞了请求"></p>
<p><img src="/images/14567593813304.jpg" alt="正确！非阻塞机制"></p>
<h2 id="u4EFB_u52A1_u7B80_u4ECB"><a href="#u4EFB_u52A1_u7B80_u4ECB" class="headerlink" title="任务简介"></a>任务简介</h2><ul>
<li>打上标签：<code>Project: 3.2</code></li>
<li>Datastore: <code>ami-83ba8ae9</code>, <code>t1.micro</code></li>
<li>Coordinator:  <code>ami-17a4947d</code>, <code>t1.micro</code></li>
<li>Client:  <code>ami-a05d60ca</code>, <code>m1.small</code></li>
</ul>
<p>具体步骤</p>
<ol>
<li>开启 3 个 datastore 实例，注意允许 8080 端口的访问</li>
<li>在浏览器中访问 <code>http://[DATASTORE-DNS]:8080/test</code> 来测试 datastore 是否正常运行</li>
<li>开启 1 个 coordinator 实例，在 <code>/home/ubuntu/Project3_2/vertx/bin/</code> 可以看到一个 <code>Coordinator.java</code> 文件，我们主要会在这里完成代码 </li>
<li>使用命令 <code>./vertx run Coordinator.java</code> 来启动 coordinator</li>
<li>第一部分工作我们需要拓展 <code>Coordinator.java</code> 来完成复制机制</li>
<li>第二部分工作我们需要完成分区机制</li>
</ol>
<p>访问接口</p>
<ul>
<li><code>http://[Coordinator-DNS]:8080/storage?storage=TYPE_OF_STORAGE</code><ul>
<li>指定需要支持的存储类型（复制与分区），用来设置具体不同的模式</li>
</ul>
</li>
<li><code>http://[Coordinator-DNS]:8080/put?key=KEY&amp;value=VALUE</code><ul>
<li>接收键值对并保存在 datastore 实例中</li>
</ul>
</li>
<li><code>http://[Coordinator-DNS]:8080/get?key=KEY&amp;loc=LOCATION</code><ul>
<li>接收需要查询的 key，并包含指定的获取位置（1/2/3 为对应的序号），在分区机制中，如果指定的实例没有对应的 value，那么返回 0，如果没有指定获取位置，那么就根据哈希的结果从对应的实例中获取</li>
</ul>
</li>
<li>不同线程可以同时访问这些 API</li>
</ul>
<p>我们还提供了一个辅助类 <code>KeyValueLib</code>，可以在 <code>Coordinator.java</code> 中访问：</p>
<ul>
<li><code>KeyValueLib.PUT(String datastoreDNS, String key, String value)</code><ul>
<li>把键值对保存到对应的实例中</li>
</ul>
</li>
<li><code>KeyValueLib.GET(String datastoreDNS, String key)</code><ul>
<li>从指定的实例中得到对应 key 的 value</li>
</ul>
</li>
</ul>
<p>在设计 Coordinator 时，可以认为：</p>
<ul>
<li>GET 操作的延时是可以忽略的</li>
<li>可以认为 datastore 实例不会出现崩溃的状况，一旦 <code>KeyValueLib.PUT</code> 方法执行完成，那么对应的实例上的操作也完成，所以需要的同步机制不会太复杂。提示：不需要实现 <a href="http://en.wikipedia.org/wiki/Two-phase_commit_protocol" target="_blank" rel="external">Two-Phase Commit (2PC)</a> 机制</li>
</ul>
<h2 id="u7EBF_u7A0B_u540C_u6B65_u7B56_u7565"><a href="#u7EBF_u7A0B_u540C_u6B65_u7B56_u7565" class="headerlink" title="线程同步策略"></a>线程同步策略</h2><p>整个项目中最重要的是两个事情：数据一致性与严格顺序。严格顺序比较好完成，利用时间戳做评测标准使用优先队列来处理即可，因为需要保证非阻塞，所以针对复制机制，大概的流程如下（这个思路是不对的，或者说增加了无谓的复杂度，具体会另开一个反思课说明）：</p>
<ol>
<li>每个 key 都应该有自己的优先队列，来缓存可能需要等待的请求，并借此保证顺序（队列的操作应该是线程安全的，需要上锁）</li>
<li>每来一个请求，就会根据请求类型的不同在不同的 <code>handle</code> 方法中处理</li>
<li>每个 key 都应该有自己的锁，这样不会影响到其他 key 的访问，这里使用 <code>HashMap</code> 来存储</li>
<li>每次来一个请求，都需要先加入对应 key 的队列</li>
<li>在新开的线程，如果写操作正在进行，从队列中取出第一个请求进行操作，读取的话就上读锁，写入的话就上写锁</li>
<li>如果是写入的话，需要同步到其他两台机器</li>
<li>如果是读取的话，因为读锁是允许并发的，所以不需要为三个不同的数据库设计保存不同的锁，没有指定那个数据库的话，就随便访问一个即可</li>
<li>如果获取的时候没有对应的 key，返回 0</li>
</ol>
<p>针对分区机制，大概的流程如下（这个思路是不对的，或者说增加了无谓的复杂度，具体会另开一个反思课说明）：</p>
<ol>
<li>每个请求需要根据 key 来进行哈希，确定所在的数据库编号</li>
<li>每来一个请求，就会根据请求类型的不同在不同的 <code>handle</code> 方法中处理</li>
<li>每次来一个请求，都需要先加入对应 key 的队列</li>
<li>每个 key 都应该有自己的锁，这样不会影响到其他 key 的访问，这里使用 <code>HashMap</code> 来存储</li>
<li>在新开的线程，如果写操作正在进行，从队列中取出第一个请求进行操作，读取的话就上读锁，写入的话就上写锁</li>
<li>每个 key 都应该有自己的优先队列，来缓存可能需要等待的请求，并借此保证顺序（队列的操作应该是线程安全的，需要上锁）</li>
<li>获取的时候，如果指定的实例没有对应的 value（也就是和哈希出来的数据库编号不一致），那么返回 0</li>
<li>如果获取的时候没有对应的 key，返回 0</li>
</ol>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue里面存储的对象必须是实现Comparable接口。队列通过这个接口的compare方法确定对象的priority。</p>
<p>规则是：当前和其他对象比较，如果compare方法返回负数，那么在队列里面的优先级就比较高。</p>
<p>PriorityBlockingQueue队列添加新元素时候不是将全部元素进行顺序排列，而是从某个指定位置开始将新元素与之比较，一直比到队列头，这样既能保证队列头一定是优先级最高的元素，又能减少排序带来的性能消耗。每取一个头元素时候，都会对剩余的元素做一次调整，这样就能保证每次队列头的元素都是优先级最高的元素。</p>
<p>下面是 Thinking in Java 中的一个例子 - 使用PriorityBlockingQueue进行任务按优先级同步执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;   </span><br><span class="line"><span class="keyword">import</span> java.util.List;   </span><br><span class="line"><span class="keyword">import</span> java.util.Queue;   </span><br><span class="line"><span class="keyword">import</span> java.util.Random;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.PriorityBlockingQueue;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrioritizedTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Comparable</span>&lt;<span class="title">PrioritizedTask</span>&gt;   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = counter++;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> priority;   </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> List&lt;PrioritizedTask&gt; sequence = <span class="keyword">new</span> ArrayList&lt;PrioritizedTask&gt;();   </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrioritizedTask</span><span class="params">(<span class="keyword">int</span> priority)</span>    </span><br><span class="line">    </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.priority = priority;   </span><br><span class="line">        sequence.add(<span class="keyword">this</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">       </span><br><span class="line">    <span class="annotation">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PrioritizedTask o)</span> </span>&#123;   </span><br><span class="line">        <span class="comment">//复写此方法进行任务执行优先级排序   </span></span><br><span class="line"><span class="comment">//      return priority &lt; o.priority ? 1 :   </span></span><br><span class="line"><span class="comment">//          (priority &gt; o.priority ? -1 : 0);   </span></span><br><span class="line">        <span class="keyword">if</span>(priority &lt; o.priority)   </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;   </span><br><span class="line">        &#125;<span class="keyword">else</span>   </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span>(priority &gt; o.priority)   </span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;   </span><br><span class="line">            &#125;<span class="keyword">else</span>   </span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">   </span><br><span class="line">    <span class="annotation">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="comment">//执行任务代码..   </span></span><br><span class="line">        <span class="keyword">try</span> &#123;   </span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">250</span>));   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;   </span><br><span class="line">               </span><br><span class="line">        &#125;   </span><br><span class="line">        System.out.println(<span class="keyword">this</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">       </span><br><span class="line">    <span class="annotation">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%1$-3d]"</span>, priority) + <span class="string">" Task id : "</span> + id;   </span><br><span class="line">    &#125;   </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">summary</span><span class="params">()</span>   </span><br><span class="line">    </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"( Task id : "</span> + id + <span class="string">" _priority : "</span> + priority + <span class="string">")"</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">       </span><br><span class="line">    <span class="comment">/**  </span><br><span class="line">     * 结束所有任务  </span><br><span class="line">     */</span>   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EndSentinel</span> <span class="keyword">extends</span> <span class="title">PrioritizedTask</span>   </span><br><span class="line">    </span>&#123;   </span><br><span class="line">        <span class="keyword">private</span> ExecutorService exec;   </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EndSentinel</span><span class="params">(ExecutorService e)</span> </span>&#123;   </span><br><span class="line">            <span class="keyword">super</span>(Integer.MAX_VALUE);   </span><br><span class="line">            exec = e;   </span><br><span class="line">        &#125;   </span><br><span class="line">           </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>   </span><br><span class="line">        </span>&#123;   </span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;   </span><br><span class="line">            <span class="keyword">for</span>(PrioritizedTask pt : sequence)   </span><br><span class="line">            &#123;   </span><br><span class="line">                System.out.print(pt.summary());   </span><br><span class="line">                <span class="keyword">if</span>(++count % <span class="number">5</span> == <span class="number">0</span>)   </span><br><span class="line">                &#123;   </span><br><span class="line">                    System.out.println();   </span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">            System.out.println();   </span><br><span class="line">            System.out.println(<span class="keyword">this</span> + <span class="string">"Calling shutdownNow()"</span>);   </span><br><span class="line">            exec.shutdownNow();   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line">   </span><br><span class="line"><span class="comment">/**  </span><br><span class="line"> * 制造一系列任务,分配任务优先级  </span><br><span class="line"> */</span>   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrioritizedTaskProducer</span> <span class="keyword">implements</span> <span class="title">Runnable</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);   </span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Runnable&gt; queue;   </span><br><span class="line">    <span class="keyword">private</span> ExecutorService exec;   </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrioritizedTaskProducer</span><span class="params">(Queue&lt;Runnable&gt; q, ExecutorService e)</span>    </span><br><span class="line">    </span>&#123;   </span><br><span class="line">        queue = q;   </span><br><span class="line">        exec = e;   </span><br><span class="line">    &#125;   </span><br><span class="line">       </span><br><span class="line">    <span class="annotation">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">           </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)   </span><br><span class="line">        &#123;   </span><br><span class="line">            queue.add(<span class="keyword">new</span> PrioritizedTask(rand.nextInt(<span class="number">10</span>)));   </span><br><span class="line">            Thread.yield();   </span><br><span class="line">        &#125;   </span><br><span class="line">           </span><br><span class="line">        <span class="keyword">try</span> &#123;   </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;   </span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">250</span>);   </span><br><span class="line">                queue.add(<span class="keyword">new</span> PrioritizedTask(<span class="number">10</span>));   </span><br><span class="line">            &#125;   </span><br><span class="line">               </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)   </span><br><span class="line">            &#123;   </span><br><span class="line">                queue.add(<span class="keyword">new</span> PrioritizedTask(i));   </span><br><span class="line">            &#125;   </span><br><span class="line">               </span><br><span class="line">            queue.add(<span class="keyword">new</span> PrioritizedTask.EndSentinel(exec));   </span><br><span class="line">               </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;   </span><br><span class="line">               </span><br><span class="line">        &#125;   </span><br><span class="line">           </span><br><span class="line">        System.out.println(<span class="string">"Finished PrioritizedTaskProducer"</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="comment">/**  </span><br><span class="line"> * 使用PriorityBlockingQueue进行任务按优先级同步执行  </span><br><span class="line"> */</span>   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrioritizedTaskConsumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> PriorityBlockingQueue&lt;Runnable&gt; q;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrioritizedTaskConsumer</span><span class="params">(PriorityBlockingQueue&lt;Runnable&gt; q)</span>   </span><br><span class="line">    </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.q = q;   </span><br><span class="line">    &#125;   </span><br><span class="line">   </span><br><span class="line">    <span class="annotation">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">try</span>    </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted())    </span><br><span class="line">            &#123;   </span><br><span class="line">                q.take().run();   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)    </span><br><span class="line">        &#123;   </span><br><span class="line">        &#125;   </span><br><span class="line">        System.out.println(<span class="string">"Finished PrioritizedTaskConsumer"</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">       </span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueueDemo</span> </span>&#123;   </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span>   </span><br><span class="line">    </span>&#123;   </span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();   </span><br><span class="line">        PriorityBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> PriorityBlockingQueue&lt;Runnable&gt;();   </span><br><span class="line">           </span><br><span class="line">        exec.execute(<span class="keyword">new</span> PrioritizedTaskProducer(queue, exec));   </span><br><span class="line">        <span class="keyword">try</span> &#123;   </span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">250</span>);   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;   </span><br><span class="line">        &#125;   </span><br><span class="line">        exec.execute(<span class="keyword">new</span> PrioritizedTaskConsumer(queue));   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u8BFB_u5199_u9501_ReadWriteLock"><a href="#u8BFB_u5199_u9501_ReadWriteLock" class="headerlink" title="读写锁 ReadWriteLock"></a>读写锁 ReadWriteLock</h3><p>读写锁分为读锁和写锁，多个读锁之间是不需要互斥的(读操作不会改变数据，如果上了锁，反而会影响效率)，写锁和写锁之间需要互斥，也就是说，如果只是读数据，就可以多个线程同时读，但是如果你要写数据，就必须互斥，使得同一时刻只有一个线程在操作。在同一线程中，持有读锁后，不能直接调用写锁的lock方法 ，否则会造成死锁。</p>
<p>一个简单的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadWrite</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 共享数据，只能一个线程写数据，可以多个线程读数据 */</span></span><br><span class="line">	<span class="keyword">private</span> Object data = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">/* 创建一个读写锁 */</span></span><br><span class="line">	ReadWriteLock rwlock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 读数据，可以多个线程同时读， 所以上读锁即可</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">/* 上读锁 */</span></span><br><span class="line">		rwlock.readLock().lock();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" 准备读数据!"</span>);</span><br><span class="line">			<span class="comment">/* 休眠 */</span></span><br><span class="line">			Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"读出的数据为 :"</span> + data);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			rwlock.readLock().unlock();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 写数据，多个线程不能同时写 所以必须上写锁</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 上写锁 */</span></span><br><span class="line">		rwlock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" 准备写数据!"</span>);</span><br><span class="line">			<span class="comment">/* 休眠 */</span></span><br><span class="line">			Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" 写入的数据: "</span> + data);</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			rwlock.writeLock().unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/* 创建ReadWrite对象 */</span></span><br><span class="line">		<span class="keyword">final</span> ReadWrite readWrite = <span class="keyword">new</span> ReadWrite();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 创建并启动3个读线程 */</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="annotation">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					readWrite.get();</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">/*创建3个写线程*/</span></span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;	</span><br><span class="line">				<span class="annotation">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="comment">/*随机写入一个数*/</span></span><br><span class="line">					readWrite.put(<span class="keyword">new</span> Random().nextInt(<span class="number">8</span>));				</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5F3A_u4E00_u81F4_u590D_u5236_u673A_u5236"><a href="#u5F3A_u4E00_u81F4_u590D_u5236_u673A_u5236" class="headerlink" title="强一致复制机制"></a>强一致复制机制</h2><p>在分布式应用中，一致性是非常重要的，这里我们简要介绍一下</p>
<p><img src="/images/14567642451622.jpg" alt="一个银行系统的数据存储"></p>
<p>如果没有保证强一致性，那么上图中所示的场景可能就会出问题，如果同时取出 <code>$50</code>，那么可能最后的结果是两边都变成 <code>$950</code>，而不是正确的 <code>$900</code>，所以正确的做法是只能让一边完成操作，然后当数据库同步完成后，另一个操作才可以执行。</p>
<p>根据这个要求，我们的 Coordinator 还需要满足如下的强一致性需求：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">强一致性</td>
<td style="text-align:center">任何时候从任何复制节点中相同的 key 对应相同的 value</td>
</tr>
<tr>
<td style="text-align:center">严格排序</td>
<td style="text-align:center">对应 key 相同的操作，按时间顺序处理请求</td>
</tr>
<tr>
<td style="text-align:center">原子操作</td>
<td style="text-align:center">所有的操作都应该是原子的，不能同时更新</td>
</tr>
<tr>
<td style="text-align:center">访问控制</td>
<td style="text-align:center">一个 key 在被更新时其他节点中的对应 key 不能访问</td>
</tr>
</tbody>
</table>
<blockquote>
<p>提示</p>
</blockquote>
<ol>
<li>如果对并行编程不熟悉，需要复习多线程，线程安全和保证执行顺序的策略等相关内容</li>
<li>需要在给 PUT 排序的时候执行显式同步。注意可能引起的<a href="http://stackoverflow.com/questions/34510/what-is-a-race-condition" target="_blank" rel="external">竞争条件</a></li>
<li>有若干种方法来处理锁与竞争条件，可以参考<a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html" target="_blank" rel="external">这里</a>以及<a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html" target="_blank" rel="external">同步</a>的详细信息</li>
<li>使用时间戳来进行排序，<a href="https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html" target="_blank" rel="external">优先队列</a>会很有用</li>
<li>需要重设 datastore 时，可以访问 <code>http://[Datastore-DNS]:8080/flush</code></li>
<li>刚连上远程实例的时候会有比较大的延迟，请耐心等待，不要 <code>ctrl+c</code>，不然会出问题</li>
<li>早点开始，并行编程可能会比想象中要麻烦得多</li>
</ol>
<blockquote>
<p>提交方式</p>
</blockquote>
<ol>
<li>启动一个 <code>m1.small</code>(<code>ami-a05d60ca</code>) 客户端实例</li>
<li>进入 <code>/home/ubuntu/Project3_2/</code>，包含 <code>storage_checker</code>, <code>config.prop</code>, <code>submitter</code> 和 <code>references</code></li>
<li>可以用 <code>storage_checker</code> 来检测正确性，但是使用之前需要先填写 <code>config.prop</code>（注意里面 datastore 的顺序要和 <code>Coordinator.java</code> 中的保持一致）</li>
<li>填写完成后可以使用 <code>./storage_checker.sh replication</code> 来进行测试。</li>
</ol>
<h2 id="u5E73_u5747_u5206_u914D_u5206_u533A_u673A_u5236"><a href="#u5E73_u5747_u5206_u914D_u5206_u533A_u673A_u5236" class="headerlink" title="平均分配分区机制"></a>平均分配分区机制</h2><p>在分区机制中最重要的就是哈希函数，使用哈希的话，不可避免会出现<a href="https://en.wikipedia.org/wiki/Collision_(computer_science" target="_blank" rel="external">冲突</a> )的情况，所以评价一个哈希函数好不好，主要看能否使用这个哈希函数把输入尽可能平均分摊到不同的 key 中。</p>
<p>举个例子，假设我们的输入是 1-6 六个数字，有如下两个哈希函数</p>
<ul>
<li>函数 A<ul>
<li>1,2,3: -&gt; 0</li>
<li>4,5,6: -&gt; 1</li>
</ul>
</li>
<li>函数 B<ul>
<li>1,2,3,4,5: -&gt; 0</li>
<li>6        : -&gt; 1</li>
</ul>
</li>
</ul>
<p>因为函数 A 使得分布更平均，于是在这个场景中，函数 A 更好。在这个项目中，哈希函数用来决定数据应该存放在哪个数据库实例中，所以我们的目标是设计一个尽可能平均分配请求的哈希函数</p>
<p>具体的需求如下：</p>
<ul>
<li>一致性分区<ul>
<li>对于给定的 key，只会被分配到同一个实例上，同一个 key 只能存在与一个实例中</li>
</ul>
</li>
<li>一致性哈希<ul>
<li>对于给定的输入，每次哈希得到的值是一致的</li>
</ul>
</li>
<li>独立数据中心锁<ul>
<li>对于一个实例的请求不会令其他实例上锁</li>
</ul>
</li>
<li>非阻塞 PUT 操作<ul>
<li>对于一个实例的请求阻塞其他请求</li>
</ul>
</li>
<li>严格顺序<ul>
<li>要保持请求的顺序</li>
</ul>
</li>
</ul>
<p>其他需要注意的地方</p>
<ul>
<li>key “a” 必须放在 datastore 1 中</li>
<li>key “b” 必须放在 datastore 2 中</li>
<li>key “c” 必须放在 datastore 3 中</li>
<li>其他的 key 应该尽可能平均分配</li>
<li>不允许使用 <code>.hashCode()</code> 方法</li>
</ul>
<blockquote>
<p>提示</p>
</blockquote>
<ol>
<li>上一节的提示也适用于这一节</li>
<li>可以通过数学方法来得到哈希函数，也可以记录下 key 的分布对应来设计</li>
<li>当一致性模式改变的时候，注意清空你使用的数据结构</li>
<li>早点开始</li>
</ol>
<blockquote>
<p>提交方式</p>
</blockquote>
<ol>
<li>可以用 <code>storage_checker</code> 来检测正确性，使用之前需要先填写 <code>config.prop</code>（注意里面 datastore 的顺序要和 <code>Coordinator.java</code> 中的保持一致），然后使用 <code>./storage_checker.sh sharding</code> 来测试</li>
<li>测试完成之后，需要把 <code>Coordinator.java</code> 移动到客户端实例的 <code>/home/ubuntu/</code> 文件夹中，对应填写 <code>references</code></li>
<li>用 <code>./submitter.sh</code> 进行提交</li>
<li>TA 会人工给代码打分，尤其是可能的竞争条件，还要注意代码风格</li>
</ol>
<h2 id="u64CD_u4F5C_u65E5_u5FD7"><a href="#u64CD_u4F5C_u65E5_u5FD7" class="headerlink" title="操作日志"></a>操作日志</h2><ul>
<li>申请 EC2 实例：<code>ami-17a4947d</code>(<code>t1.micro</code>)，注意打开所有端口。</li>
<li>把要修改的文件复制到本地 <code>scp -i demo.pem ubuntu@dns.compute-1.amazonaws.com:~/Project3_2/vertx/bin/Coordinator.java ./</code></li>
<li>修改完成后传回服务器 <code>scp -i demo.pem ./Coordinator.java ubuntu@dns.compute-1.amazonaws.com:~/Project3_2/vertx/bin/</code></li>
<li>使用命令 <code>./vertx run Coordinator.java</code> 来启动 coordinator（也可以用来检查语法错误）</li>
<li>启动三个 datastore： <code>ami-83ba8ae9</code>(<code>t1.micro</code>)，注意打开所有端口</li>
<li>启动一个 <code>m1.small</code>(<code>ami-a05d60ca</code>) 客户端实例</li>
<li>分别把地址写到 <code>Coordinator.java</code> 和 <code>config.prop</code> 中</li>
<li>把 <code>config.prop</code> 复制到本地 <code>scp -i demo.pem ubuntu@dns.compute-1.amazonaws.com:~/config.prop ./</code></li>
<li>添加完之后复制回去 <code>scp -i demo.pem ./config.prop ubuntu@dns.compute-1.amazonaws.com:~/</code></li>
<li>使用 <code>./storage_checker.sh replication</code> 来进行测试</li>
<li>完成第一部分后，使用 <code>./storage_checker.sh sharding</code> 来测试第二部分</li>
<li>填写 <code>references</code> 以及把 <code>Coordinator.java</code> 上传到客户端实例 <code>scp -i demo.pem ./Coordinator.java ubuntu@dns.compute-1.amazonaws.com:~/</code></li>
<li>然后就提交 <code>./submitter.sh</code></li>
</ul>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://blog.csdn.net/lzm1340458776/article/details/27964243" target="_blank" rel="external">Java多线程中读写锁ReadWriteLock的使用</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html" target="_blank" rel="external">Class PriorityBlockingQueue<e></e></a></li>
<li><a href="http://www.cnblogs.com/techyc/p/3272321.html" target="_blank" rel="external">Java的wait(), notify()和notifyAll()使用小结</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前我们做的是计算能力的伸缩拓展，这次我们也要对数据库做类似的事情，并且通过具体的场景，来了解键值对存储的应用特点。特别鸣谢瓜瓜 @jiexing 的点拨，不然我就卡在自己脑洞里出不来了。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="数据库" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 期中考试复习]]></title>
    <link href="http://wdxtub.com/2016/02/28/csapp-midterm-review/"/>
    <id>http://wdxtub.com/2016/02/28/csapp-midterm-review/</id>
    <published>2016-02-28T13:08:37.000Z</published>
    <updated>2016-03-01T14:10:17.000Z</updated>
    <content type="html"><![CDATA[<p>这一次我们主要来回顾一下重要的知识点，以及讲解一些往年试题中容易混淆的概念。</p>
<a id="more"></a>
<hr>
<h2 id="u77E5_u8BC6_u70B9_u68B3_u7406"><a href="#u77E5_u8BC6_u70B9_u68B3_u7406" class="headerlink" title="知识点梳理"></a>知识点梳理</h2><p>范围是第 1-3 章和第 6 章，下面是部分知识点（每个其实都包含不少内容，建议再看一次我前面写过的系列，这里还是会挑一些重点来写以下）</p>
<ul>
<li>十六进制表示</li>
<li>数据类型的字节表示</li>
<li>C 语言中的位操作、逻辑操作、左移右移操作</li>
<li>整型的表示方法及运算方式</li>
<li>浮点数的表示方法及运算方式</li>
<li>理解汇编：访问数据，算术和逻辑运算，控制，过程调用，数组的内存空间分配和访问，结构体/联合体的表示，数据对齐</li>
<li>理解指针，栈帧以及常见的攻击方式</li>
<li>内存相关话题：Locality, Memory Hierarchy, Cache Memories</li>
</ul>
<h3 id="u5E03_u5C14_u8FD0_u7B97"><a href="#u5E03_u5C14_u8FD0_u7B97" class="headerlink" title="布尔运算"></a>布尔运算</h3><p>集合 A</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01101001</span> &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="number">76543210</span></span><br></pre></td></tr></table></figure>
<p>集合 B</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01010101</span> &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="number">76543210</span></span><br></pre></td></tr></table></figure>
<p>那么不同的布尔运算就代表：</p>
<ul>
<li><code>&amp;</code> 交集 Intersection <code>01000001</code> {0, 6}</li>
<li><code>|</code> 并集 Union <code>01111101</code> {0, 2, 3, 4, 5, 6}</li>
<li><code>^</code> 差集 Symmetric difference <code>00111100</code> {2, 3, 4, 5}</li>
<li><code>~</code> 补集 Complement <code>10101010</code> {1, 3, 5, 7}</li>
</ul>
<p>以上这四种运算 C 语言都支持，只要是『数值型』即可：<code>long</code>, <code>int</code>, <code>short</code>, <code>char</code>, <code>unsigned</code>。每个参数都会被看做是位向量。</p>
<h3 id="u6574_u578B_u7684_u8868_u793A"><a href="#u6574_u578B_u7684_u8868_u793A" class="headerlink" title="整型的表示"></a>整型的表示</h3><p>针对有符号数和无符号数，有两种不同的形式，这里的 w 表示 word size：</p>
<ul>
<li>无符号数：$B2U(X)=\sum_{i=0}^{w-1}x_i·2^i$</li>
<li>有符号数： $B2T(X)=-x_{w-1}·2^{w-1}+\sum_{i=0}^{w-2}x_i·2^i$ </li>
</ul>
<p>为了方便讲解，下面定义几个常量，这里 w 是 word size：</p>
<ul>
<li>UMin = 0 即 000…0</li>
<li>UMax = $2^w-1$ 即 111…1</li>
</ul>
<p>Two’s Complement 值</p>
<ul>
<li>TMin = $-2^{w-1}$ 即 100…0</li>
<li>TMax = $2^{w-1}-1$ 即 011…1</li>
</ul>
<p>其他值</p>
<ul>
<li>Minus 1 即 111…1</li>
</ul>
<p>观察可以得知两个很重要的特性</p>
<ul>
<li>|TMin| = TMax + 1 (范围并不是对称的)</li>
<li>UMax = 2*TMax + 1</li>
</ul>
<p>有符号数和无符号数在非负数的编码是一样的，每一个数字的编码是唯一的，这两者可以互换：</p>
<ul>
<li>$U2B(x)=B2U^{-1}(x)$</li>
<li>$T2B(x)=B2T^{-1}(x)$</li>
</ul>
<p><img src="/images/csapp2.jpg" alt="2&#39;s Complement vs Unsigned"></p>
<h3 id="u62D3_u5C55_u548C_u88C1_u526A"><a href="#u62D3_u5C55_u548C_u88C1_u526A" class="headerlink" title="拓展和裁剪"></a>拓展和裁剪</h3><p>有的时候我们需要扩展一个变量的位数，比如说从 32 位扩展到 64 位。更通用一点的话，给定一个 w 位的有符号整数 x，要把它转换成 w+k 位的整数（保持值不变），只需要在左边添加 k 个与符号位相同的数值即可，如下图：</p>
<p><img src="/images/csapp3.jpg" alt="从 32 位拓展到 64 位"></p>
<ul>
<li>扩展（例如从 <code>short int</code> 到 <code>int</code>）<ul>
<li>无符号数：加 0</li>
<li>有符号数：加符号位</li>
<li>都可以得到预期的结果</li>
</ul>
</li>
<li>缩短（例如 <code>unsigned</code> 到 <code>unsigned short</code>）<ul>
<li>均会截取</li>
<li>无符号数：mod 操作</li>
<li>有符号数：近似 mod 操作</li>
<li>对于小的数字可以得到预期的结果</li>
</ul>
</li>
</ul>
<h3 id="u6EA2_u51FA_u95EE_u9898"><a href="#u6EA2_u51FA_u95EE_u9898" class="headerlink" title="溢出问题"></a>溢出问题</h3><p>无符号加法和有符号加法有不同的溢出方式：</p>
<p><img src="/images/csapp5.jpg" alt="无符号加法的溢出"></p>
<p><img src="/images/csapp7.jpg" alt="有符号加法的两种溢出"></p>
<h3 id="u6D6E_u70B9_u6570"><a href="#u6D6E_u70B9_u6570" class="headerlink" title="浮点数"></a>浮点数</h3><p>二进制浮点数的表示，其实和我们日常生活中常见的十进制的方式是一致的，都是相当于每一位的系数，乘以每一位的数值，然后把结果加起来，如下图所示：</p>
<p><img src="/images/csapp13.jpg" alt="浮点数表示"></p>
<p>所以我们其实可以用一个统一的公式来表达：</p>
<p>$$ \sum_{k=-j}^ib_k\times 2^k $$</p>
<p>例如</p>
<p>$$ 5\frac{3}{4}=101.11_2 \;,\; 2\frac{7}{8}=10.111_2 \;,\; 1\frac{7}{16}=1.0111_2 $$</p>
<p>细心的同学就会发现，这种表达方式其实是比较明显的限制的，比如说，只有形为 $\frac{x}{2^k}$ 的小数部分可以被精确表示，其他的数字会变成循环的小数，例如：$\frac{1}{3}=0.0101010101[01]…_2$。</p>
<p>除此之外，另一个问题在于，如果给定了 w 个比特，能够表达的数字其实是有限的。</p>
<h3 id="IEEE__u6D6E_u70B9_u6570"><a href="#IEEE__u6D6E_u70B9_u6570" class="headerlink" title="IEEE 浮点数"></a>IEEE 浮点数</h3><p>我们用下面的公式来表达浮点数：</p>
<p>$$(-1)^s \; M \; 2^E$$</p>
<p>其中 s 是符号位，决定正负；M 通常是一个值在 [1.0, 2.0) 的小数；E 是次方数。具体编码的时候是这样的：</p>
<p><img src="/images/csapp14.jpg" alt="浮点数的格式"></p>
<p>其中 s 对应着符号位，exp 对应着 E（注意，不一定等于 E，因为位数限制表达能力有限），frac 对应着 M（注意，不一定等于 M，因为位数限制表达能力有限）。</p>
<p>不同的位数就代表了不同的表示能力，也就是单精度，双精度，扩展精度的来源，具体的位数表示如下：</p>
<p><img src="/images/csapp15.jpg" alt="单精度、双精度、拓展精度"></p>
<p>注意区别 normalized 和 denormalized 的区别</p>
<p>舍入到最近的偶数比较特别，中心思想是：舍入之后最右边的值要是偶数，从下面一个例子就可以明白：</p>
<p><img src="/images/csapp24.jpg" alt="舍入到最近的偶数"></p>
<p>对于二进制数也是类似的</p>
<p><img src="/images/csapp25.jpg" alt="二进制数舍入到最近的偶数"></p>
<h3 id="u6D6E_u70B9_u6570_u4E58_u6CD5"><a href="#u6D6E_u70B9_u6570_u4E58_u6CD5" class="headerlink" title="浮点数乘法"></a>浮点数乘法</h3><p>$$(-1)^{s1}\; M1 \; 2^{E1} \times (-1)^{s2}\; M2 \; 2^{E2}$$</p>
<p>结果是 $(-1)^{s}\; M \; 2^{E}$，其中 s= s1 ^ s2, M = M1 * M2, E = E1 + E2</p>
<ul>
<li>如果 M 大于等于 2，那么把 M 右移，并增加 E 的值。</li>
<li>如果 E 超出了可以表示的范围，溢出</li>
<li>把 M 舍入到 frac 的精度</li>
</ul>
<p>基本性质</p>
<ul>
<li>相乘可能产生 infinity 或者 NaN</li>
<li>满足交换率</li>
<li>不满足结合律（因为舍入会造成精度损失）</li>
<li>乘以 1 等于原来的数</li>
<li>不满足分配率 <code>1e20*(1e20-1e20)=0.0</code> 但 <code>1e20*1e20-1e20*1e20=NaN</code></li>
<li>除了 infinity 和 NaN，满足单调性，即 $a\ge b \to a\times c \ge a\times b$</li>
</ul>
<h3 id="u6D6E_u70B9_u6570_u52A0_u6CD5"><a href="#u6D6E_u70B9_u6570_u52A0_u6CD5" class="headerlink" title="浮点数加法"></a>浮点数加法</h3><p>$$(-1)^{s1}\; M1 \; 2^{E1} + (-1)^{s2}\; M2 \; 2^{E2}$$，这里假设 E1 &gt; E2</p>
<p><img src="/images/csapp26.jpg" alt="浮点数加法"></p>
<p>结果是 $(-1)^{s}\; M \; 2^{E}$，其中 s= s1 ^ s2, M = M1 + M2, E = E1</p>
<ul>
<li>如果 M 大于等于 2，那么把 M 右移，并增加 E 的值</li>
<li>如果 M 小于 1，把 M 左移 k 位，E 减少 k</li>
<li>如果 E 超出了可以表示的范围，溢出</li>
<li>把 M 舍入到 frac 的精度</li>
</ul>
<p>基本性质</p>
<ul>
<li>相加可能产生 infinity 或者 NaN</li>
<li>满足交换率</li>
<li>不满足结合律（因为舍入会造成精度损失，如 <code>3.14+1e10)-1e10=0</code>，但 <code>3.14+(1e10-1e10)=3.14</code>）</li>
<li>加上 0 等于原来的数</li>
<li>除了 infinity 和 NaN，每个元素都有对应的倒数</li>
<li>除了 infinity 和 NaN，满足单调性，即 $a\ge b \to a+c \ge a+b$</li>
</ul>
<h3 id="u79FB_u52A8_u6570_u636E_u4E0E_u5BFB_u5740"><a href="#u79FB_u52A8_u6570_u636E_u4E0E_u5BFB_u5740" class="headerlink" title="移动数据与寻址"></a>移动数据与寻址</h3><p>操作数主要有三种类型，一种是立即数，也就是直接给的一个数字，第二种是寄存器，第三种是内存</p>
<p><img src="/images/14531723678160.jpg" alt=""></p>
<p>普通模式，(R)，相当于 <code>Mem[Reg[R]]</code>，也就是说寄存器 R 指定内存地址，类似于 C 语言中的指针，语法为：<code>movq (%rcx), %rax</code> 也就是说以 %rcx 寄存器中存储的地址去内存里找对应的数据，存到寄存器 %rax 中</p>
<p>移位模式，D(R)，相当于 <code>Mem[Reg[R]+D]</code>，寄存器 R 给出起始的内存地址，然后 D 是偏移量，语法为：<code>movq 8(%rbp),%rdx</code> 也就是说以 %rbp 寄存器中存储的地址再加上 8 个偏移量去内存里找对应的数据，存到寄存器 %rdx 中</p>
<p><img src="/images/14531733075157.jpg" alt=""></p>
<p>举个例子：%rdx 的存着的地址是 0xf000；%rcx 的存着的地址是 0x0100，那么有：</p>
<p><img src="/images/14531733728296.jpg" alt=""></p>
<h3 id="u6761_u4EF6_u7801_u4E0E_u4EE3_u7801_u63A7_u5236"><a href="#u6761_u4EF6_u7801_u4E0E_u4EE3_u7801_u63A7_u5236" class="headerlink" title="条件码与代码控制"></a>条件码与代码控制</h3><p>最后的四个寄存器（CF, ZF, SF, OF）就是用来辅助程序的流程控制的，意思是：</p>
<ul>
<li>CF: Carry Flag (for unsigned)</li>
<li>ZF: Zero Flag</li>
<li>SF: Sign Flag (for signed)</li>
<li>OF: Overflow Flag (for signed)</li>
</ul>
<p>可以看到以上这四个寄存器，表示四种不同的状态，举个例子，假如我们有一条诸如 <code>t = a + b</code> 的语句，汇编之后假设用的是 <code>addq Src, Dest</code>，那么根据这个操作结果的不同，会相应设置上面提到的四个寄存器，而因为这个是执行类似操作时顺带尽心设置的，称为隐式设置，例如：</p>
<ul>
<li>如果两个数相加，在最高位还需要进位（也就是溢出了），那么 CF 寄存器就会被设置</li>
<li>如果 t 等于 0，那么 ZF 寄存器会被设置</li>
<li>如果 t 小于 0，那么 SF 寄存器会被设置</li>
<li>如果 2’s complement 溢出，那么 OF 寄存器会被设置为 1（溢出的情况是 <code>(a&gt;0 &amp;&amp; b &gt; 0 &amp;&amp; t &lt;0) || (a&lt;0 &amp;&amp; b&lt;0 &amp;&amp; t&gt;=0)</code>）</li>
</ul>
<p>这就发现了，其实这四个条件代码，是用来标记上一条命令的结果的各种可能的，是自动会进行设置的。注意，使用 <code>leaq</code> 指令的话不会进行设置。</p>
<h3 id="u6808_u5E27"><a href="#u6808_u5E27" class="headerlink" title="栈帧"></a>栈帧</h3><p>在 x86-64/Linux 中，栈帧的结构是固定的，当前的要执行的栈中包括：</p>
<ul>
<li>Argument Build: 需要使用的参数</li>
<li>如果不能保存在寄存器中，会把一些本地变量放在这里</li>
<li>已保存的寄存器上下文</li>
<li>老的栈帧的指针（可选）</li>
</ul>
<p>而调用者的栈帧则包括：</p>
<ul>
<li>返回地址（因为 <code>call</code> 指令被压入栈的）</li>
<li>调用所需的参数</li>
</ul>
<p>具体如下图所示：</p>
<p><img src="/images/14533846615880.jpg" alt="栈帧的例子"></p>
<h3 id="u5B58_u50A8_u76F8_u5173"><a href="#u5B58_u50A8_u76F8_u5173" class="headerlink" title="存储相关"></a>存储相关</h3><p>总的访问时间  Taccess =  寻址时间 Tavg seek + 旋转时间 Tavg rotation + 传输时间 Tavg transfer</p>
<ul>
<li>寻址时间 Tavg seek 因为物理规律的限制，一般是 3-9 ms</li>
<li>旋转延迟 Tavg rotation 取决于硬盘具体的转速，一般来说是 7200 RPM</li>
<li>传输时间 Tavg tranfer 就是需要读取的 sector 数目</li>
</ul>
<p>举个例子，假设转速是 7200 RPM，平均寻址时间 9ms，平均每个 track 的 sector 数目是 400，那么我们有：</p>
<ul>
<li>Tavg rotation = 1/2 x (60 secs / 7200 RPM) x 1000 ms/sec = 4 ms</li>
<li>Tavg transfer = 60 / 7200 RPM x 1/400 secs/track x 1000 ms/sec = 0.02 ms</li>
<li>Taccess = 9 ms + 4 ms + 0.02 ms</li>
</ul>
<p>从这里可以看出，主要决定访问时间的是寻址时间和旋转延迟；读取一个 sector 的第一个 bit 是非常耗时的，之后的都几乎可以忽略不计；硬盘比 SRAM 慢 40,000 倍，比 DRAM 慢 2500 倍。</p>
<h3 id="Locality__u4E0E_Memory_Heirarchy"><a href="#Locality__u4E0E_Memory_Heirarchy" class="headerlink" title="Locality 与 Memory Heirarchy"></a>Locality 与 Memory Heirarchy</h3><p>Locality 的思路很简单，就是如果一个数据最近被访问过，很可能还会被再次访问：</p>
<ul>
<li>Temporal locality: Recently referenced items are likely to be referenced again in the near future</li>
<li>Spatial locality: Items with nearby addresses tend to be referenced close together in time</li>
</ul>
<p>一种介质的速度越快，就会越贵，同时也消耗更多的电量，所以一般容量比较小。而 CPU 和内存之间的速度差距越来越大，所以好的程序都会尽可能利用 locality。根据这些特性，也就引申出了一个安排存储的方式，称为 memory hierarchy。</p>
<p><img src="/images/14555647586566.jpg" alt="Memory Heirarchy"></p>
<p>这里就涉及到一个技术：缓存。缓存可以看作是把大且缓慢的设备中的数据的一部分拿出来存储到其中的更快的存储设备。在 memory hierarchy 金字塔中，每一层都可以看作是下一层的缓存。利用 locality，程序会更倾向于访问第 k 层的数据，而非第 k+1 层，这样就减少了访问时间。</p>
<p><img src="/images/14555654345569.jpg" alt="访问时间比较"></p>
<h3 id="Cache_Miss"><a href="#Cache_Miss" class="headerlink" title="Cache Miss"></a>Cache Miss</h3><p>Cache miss 有三种：</p>
<ul>
<li>Cold(compulsory) Miss: CPU 第一次访问相应 cache 块，cache 中肯定没有该 cache 块，这是不可避免的</li>
<li>Confilict Miss: 在直接相联或组相联的 cache 中，不同的 cache 块由于 index 相同相互替换，引起的失效叫做冲突失效<ul>
<li>假设这里有 32KB 直接相联的 cache</li>
<li>如果有两个 8KB 的数据需要来回访问，但是这两个数组都映射到相同的地址，cache 大小足够存储全部的数据，但是因为相同地址发生了冲突需要来回替换，发生的失效则全都是冲突失效（第一次访问失效依旧是强制性失效），这时 cache 并没有存满</li>
</ul>
</li>
<li>Capacity Miss: 有限的 cache 容量导致 cache 放不下而被替换出 cache 块，被替换出去的 cache 块再被访问，引起的失效叫做容量失效<ul>
<li>假设这里有 32KB 直接相联的 cache</li>
<li>如果有一个 64KB 的数组需要重复访问，数组的大小远远大于 cache 大小，没办法全部放入 cache。第一次访问数组发生的失效全都是强制性失效。之后再访问数组，再发生的失效则全都是容量失效，这时 cache 已经存满，容量不足以存储全部数据</li>
</ul>
</li>
</ul>
<h3 id="Cache_Memories"><a href="#Cache_Memories" class="headerlink" title="Cache Memories"></a>Cache Memories</h3><p>通常来说，是按照如下图所示的方式来组织的，一定要注意 S/E/B 具体在说什么：</p>
<p><img src="/images/14555690389309.jpg" alt=""></p>
<p>实际上可以理解为三种层级关系，对应不同的索引，这样分层的好处在于，通过层级关系简化搜索需要的时间，并且和字节的排布也是一一对应的（之后介绍缓存的时候就体现得更加明显）。</p>
<p>具体的例子请参考<a href="http://wdxtub.com/2016/02/15/csapp-12/">深入理解计算机系统 第 12 课 Cache Memories</a></p>
<h3 id="Memory_Mountain"><a href="#Memory_Mountain" class="headerlink" title="Memory Mountain"></a>Memory Mountain</h3><p><img src="/images/14556314890158.jpg" alt=""></p>
<p>注意，这是根据 Core i7 得出来的图，不同的处理器可能因为不同的设计和架构而有所区别，但是可以通过不同的颜色和层次，看出不同 size 和 stride 对性能的影响。山脚是我们应该尽量避免的，山顶是我们力求达到的，也就是说，尽量一次访问一个 stride，一次读入的数据大小也不宜太大，最好和 L1 缓存数值上吻合。</p>
<h2 id="u5F80_u5E74_u8BD5_u9898_u8BB2_u89E3"><a href="#u5F80_u5E74_u8BD5_u9898_u8BB2_u89E3" class="headerlink" title="往年试题讲解"></a>往年试题讲解</h2><h3 id="u9009_u62E9_u9898_u77E5_u8BC6_u70B9"><a href="#u9009_u62E9_u9898_u77E5_u8BC6_u70B9" class="headerlink" title="选择题知识点"></a>选择题知识点</h3><ul>
<li><code>test</code> 指令和 <code>and</code> 指令一样，只设置 flag 不改变结果</li>
<li>在一个 32 位的 Linux 系统中，<code>long</code> 的大小为 <code>4 bytes</code></li>
<li>在一个 64 位的 Linux 系统中，并不是所有的参数都在栈上传递</li>
<li><code>mov</code> 和 <code>lea</code> 指令的不同在于 <code>mov</code> 会 dereferences an address，也就是说 <code>mov</code> 是取值，<code>lea</code> 是地址</li>
<li>先调用函数，然后压入 <code>%ebp</code></li>
<li>一个 8 位浮点数（1 sign, 3 exp, 4 frac），则 0 111 1111 表示 NaN</li>
<li>每次执行完一条语句，<code>%rsp</code> 的值减 8 </li>
<li>二维数组在内存中以 row-major 方式存储</li>
<li><code>%rdi</code> 保存着函数调用的第一个参数</li>
</ul>
<h3 id="u6D6E_u70B9_u6570_u7F16_u7801"><a href="#u6D6E_u70B9_u6570_u7F16_u7801" class="headerlink" title="浮点数编码"></a>浮点数编码</h3><p>这里我们考虑两种 6 位数的 IEEE 浮点数格式</p>
<ul>
<li>格式 A<ul>
<li>1 个符号位 s</li>
<li>k = 3 个 exponent bits，bias 为 $2^{k-1} - 1 = 3$</li>
<li>n = 2 个 fraction bits</li>
</ul>
</li>
<li>格式 B<ul>
<li>1 个符号位 s</li>
<li>k = 2 个 exponent bits，bias 为 $2^{k-1} - 1 = 1$</li>
<li>n = 3 个 fraction bits</li>
</ul>
</li>
</ul>
<p>注意</p>
<ul>
<li>对应于 denormalized 的情况，E = 1 - bias</li>
<li>对应于 normalized 的情况，E = exp - bias</li>
</ul>
<p>需要填写下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">Value</th>
<th style="text-align:center">Format A Bits</th>
<th style="text-align:center">Format B Bits</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Zero</td>
<td style="text-align:center">0 000 00</td>
<td style="text-align:center">0 00 000</td>
</tr>
<tr>
<td style="text-align:center">One</td>
<td style="text-align:center">0 011 00</td>
<td style="text-align:center">0 01 000</td>
</tr>
<tr>
<td style="text-align:center">$\frac{1}{2}$</td>
<td style="text-align:center">0 010 00</td>
<td style="text-align:center">0 00 100</td>
</tr>
<tr>
<td style="text-align:center">$\frac{11}{8}$</td>
<td style="text-align:center">0 011 10</td>
<td style="text-align:center">0 01 011</td>
</tr>
</tbody>
</table>
<p>我们来对应看一下具体要怎么填。</p>
<p>首先需要知道的是 IEEE 浮点数的具体格式，是 s | exp | frac。接下来要知道什么时候是 denormalized，什么时候是 normalized，简单来说就是如果 exp 全为 0 或全为 1 时，属于 denormalized，其他时候属于 normalized。</p>
<p>对应浮点数的公式</p>
<p>$$(-1)^s \; M \; 2^E$$</p>
<p>我们知道如果要表示 1，那么 E 应该等于 0，M 部分应该为 1（M 的形式应该是是 1.xxxxx，其中 xxx 是 frac 的部分，于是 frac 应该为 0）。这里 E 因为属于 normalized 的情况，所以 E = exp - bias，而 E 需要等于 0，所以 exp = bias，针对不同的格式，就可以找到对应的答案（格式 A 中 bias = 3，所以 exp 部分是 011；格式 B 中 bias = 1，所以 exp 部分是 01；frac 部分均为 0）</p>
<p>然后我们来看看如何表示 0.5，根据公式，E 应该等于 -1，那么对于格式 A，E = exp - bias，所以 exp = -1 + 3 = 2，exp 部分就是 010。但是对于格式 B 就有点不同，因为这时候是属于 denormalized 的，这时 E = 1 - bias = 0，我们需要对 frac 部分做出处理，在这种情况下(M 的形式是 0.xxx)，frac 的第一位就表示 0.5，所以最终的结果如上表所示。</p>
<p>最后我们来看看 $\frac{11}{8}$ 要如何表示，实际上就是 1 加上 $\frac{3}{8}$，因为前面已经表示过 1，所以只要在 frac 部分做做文章即可，这次我们先来看格式 B，根据浮点数的定义，我们很快就可以知道 frac 应该为 011，完成！对于格式 A，因为 frac 只有 2 位，那么就需要进行舍入（到最近的偶数），也就是 <code>011 -&gt; 01 + 01 -&gt; 10</code>，所以最终的结果如上表所示。</p>
<h3 id="u6C47_u7F16_u7A0B_u5E8F_u9605_u8BFB"><a href="#u6C47_u7F16_u7A0B_u5E8F_u9605_u8BFB" class="headerlink" title="汇编程序阅读"></a>汇编程序阅读</h3><p>假设有这么一段汇编程序</p>
<p><img src="/images/14566917311963.jpg" alt=""></p>
<p>根据上面的信息，补充完整下面对应的程序代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">transform</span><span class="params">(<span class="keyword">unsigned</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b, m;</span><br><span class="line">    <span class="keyword">for</span> (m = __; _____; _____)&#123;</span><br><span class="line">        b = ____;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            ______;</span><br><span class="line">        &#125;</span><br><span class="line">        ______;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们应该熟悉，这里 <code>%eax</code> 中存放的变量是 <code>m</code>，<code>%edx</code> 中存放的变量是 <code>n</code>。在 &lt;+6&gt; 这一行把 <code>0x0</code> 放到了 <code>%eax</code> 中，所以循环的初始条件是 <code>m=0</code>，然后 &lt;+11&gt; 这一句实际是判断 <code>%edx</code> 是否为 0，如果为 0，则跳转到 &lt;+28&gt;，所以终止条件是 <code>n != 0</code>。接着就是循环体里的内容，&lt;+15&gt; 用 <code>%dl</code> 和 <code>0x1</code> 做 <code>&amp;</code> 操作，在汇编中结果会保存到对应的 flag 中，在代码中我们就保存到了 <code>b</code> 中，如果 <code>b == 0</code>，那么就跳转到 &lt;+24&gt;，进行移位操作，也就是循环操作为 <code>n &gt;&gt;= 1</code>，否则先要执行 &lt;+20&gt;，这一句实际上就是 <code>m = m + m + 1</code>，综上所述，就可以得到最终答案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">transform</span><span class="params">(<span class="keyword">unsigned</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b, m;</span><br><span class="line">    <span class="keyword">for</span> (m = <span class="number">0</span>; n != <span class="number">0</span>; m &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        b = n &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = m + m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u7ED3_u6784_u4F53_u7684_u5185_u5B58_u6392_u5217"><a href="#u7ED3_u6784_u4F53_u7684_u5185_u5B58_u6392_u5217" class="headerlink" title="结构体的内存排列"></a>结构体的内存排列</h3><p>假设我们有下面这个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">long</span> b;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">    <span class="keyword">char</span> d[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> *e;</span><br><span class="line">    <span class="keyword">short</span> *f;</span><br><span class="line">&#125; foo;</span><br></pre></td></tr></table></figure>
<p>请给出具体的内存排列顺序。</p>
<p>首先我们需要知道每个数据类型所占据的字节数目，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 2 字节：short</span></span><br><span class="line">    <span class="comment">// 16 字节：long double</span></span><br><span class="line">    <span class="keyword">char</span> a;    <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="keyword">long</span> b;    <span class="comment">// 8 字节（其他 8 字节的有 double, 指针）</span></span><br><span class="line">    <span class="keyword">float</span> c;   <span class="comment">// 4 字节（其他 4 字节的有 int）</span></span><br><span class="line">    <span class="keyword">char</span> d[<span class="number">3</span>]; <span class="comment">// 1 x 3 字节</span></span><br><span class="line">    <span class="keyword">int</span> *e;    <span class="comment">// 8 字节</span></span><br><span class="line">    <span class="keyword">short</span> *f;  <span class="comment">// 8 字节</span></span><br><span class="line">&#125; foo;</span><br></pre></td></tr></table></figure>
<p>所以具体的排列为（用 x 表示 padding 的字节）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span> x x x x x x x <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span></span><br><span class="line">c c c c d d d x e e e e e e e e</span><br><span class="line">f f f f f f f f</span><br></pre></td></tr></table></figure>
<p> 如果想要紧凑一点，其实可以进行对其，把 a, c, d 组合一下，如</p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span> d d d c c c c <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span></span><br><span class="line">e e e e e e e e f f f f f f f f</span><br></pre></td></tr></table></figure>
<p>这样就省了 8 个字节出来</p>
<h3 id="u7ED3_u6784_u4F53_u7684_u8BBF_u95EE"><a href="#u7ED3_u6784_u4F53_u7684_u8BBF_u95EE" class="headerlink" title="结构体的访问"></a>结构体的访问</h3><p>给出下面的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> confuse &#123;</span><br><span class="line">    <span class="keyword">char</span> systems;</span><br><span class="line">    <span class="keyword">long</span> theory;</span><br><span class="line">    <span class="keyword">struct</span> applications &#123;</span><br><span class="line">        <span class="keyword">char</span> web[<span class="number">3</span>];</span><br><span class="line">    &#125; database;</span><br><span class="line">    <span class="keyword">int</span> *languages;</span><br><span class="line">    <span class="keyword">struct</span> confuse *math;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题是，右边的汇编程序分别对应哪个函数：</p>
<p><img src="/images/14566942080505.jpg" alt=""></p>
<p>根据上一题，我们可以先画出具体的内存排列，用变量的首字母作为缩写，用 x 表示 padding：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s x x x x x x x t t t t t t t t</span><br><span class="line">w w w x x x x x <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span></span><br><span class="line"><span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="literal">m</span></span><br></pre></td></tr></table></figure>
<p>然后根据偏移量来数对应的变量即可，其中要注意的是十六进制转十进制的运算。比较简单，最后的对应为：</p>
<ul>
<li>A - phd</li>
<li>B - bachelors</li>
<li>C = masters</li>
</ul>
<h3 id="Switch__u8BED_u53E5"><a href="#Switch__u8BED_u53E5" class="headerlink" title="Switch 语句"></a>Switch 语句</h3><p>我们先来看跳转表：</p>
<p><img src="/images/14566960252571.jpg" alt="跳转表"></p>
<p>接着是汇编程序</p>
<p><img src="/images/14566960458022.jpg" alt=""></p>
<p>我们要做的是补充完整下面的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">4</span>;   </span><br><span class="line">    <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            _____;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            _____;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            result = ____;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            _____;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            _____;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            _____;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编程序中负责跳转的是 <code>0x40047b    jmpq  *0x400598(, %rdi, 8)</code>，其中 <code>%rdi</code> 就是变量 <code>a</code> 的值，仔细观察跳转表和程序，可以发现一些规律：</p>
<ul>
<li>a 等于 0 或 1 的时候，做的事情是一样的，并且直到执行完 a 等于 2 的语句才会返回</li>
<li>a 等于 5 时是一套独立的指令</li>
<li>a 等于 3 和 7 时，做的事情类似，并且最后都会执行默认的命令</li>
<li>switch 语句中有些有 break，有些没有</li>
</ul>
<p>有了这些线索，就可以『翻译』对应的汇编代码了，答案如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">4</span>;   </span><br><span class="line">    <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            result = c - <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            result = c * <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            result = <span class="number">0x15213</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            c = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            b = b &amp; c;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = b + <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u6808_u7684_u5E94_u7528"><a href="#u6808_u7684_u5E94_u7528" class="headerlink" title="栈的应用"></a>栈的应用</h3><p>这一题主要考察函数调用时候压栈出栈以及栈指针和返回地址的理解，C 代码和对应的汇编代码为：</p>
<p><img src="/images/14567011035267.jpg" alt=""></p>
<p>我们需要画出栈中的数据存放表示，具体的函数是 <code>foo(3, 4, 5)</code>，注意要标志出 <code>%ebp</code> 的值</p>
<p>在调用 <code>foo</code> 函数时 <code>%ebp</code> 的值为 <code>0xffffd858</code>，调用 <code>foo</code> 的函数的返回地址是 <code>0x080483c9</code></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stack      The diagram starts with theaddresss   arguments for foo()</span><br><span class="line">           +-----------------------------------+0xffffd850 |<span class="string">                5                  </span>|           +-----------------------------------+0xffffd84c |<span class="string">                4                  </span>|           +-----------------------------------+0xffffd848 |<span class="string">                3                  </span>|           +-----------------------------------+0xffffd844 |<span class="string">      return addr 0x080483c9       </span>|           +-----------------------------------+0xffffd840 |<span class="string">        old ebp 0xffffd858         </span>|           +-----------------------------------+0xffffd83c |<span class="string">                3                  </span>|           +-----------------------------------+0xffffd838 |<span class="string">                4                  </span>|           +-----------------------------------+0xffffd834 |<span class="string">      return addr 0x08048397       </span>|           +-----------------------------------+0xffffd830 |<span class="string">        old ebp 0xffffd858         </span>|           +-----------------------------------+</span><br></pre></td></tr></table></figure>
<p>我们来看看这题要怎么做。首先，老师还是很贴心的给出了第一个参数在栈中的位置，不过开始之前还是先要弄明白我们到底需要在栈中放什么东西。首先是函数的参数（倒着放，这样第一个参数才能先弹出来），然后是返回值地址和旧的 <code>%ebp</code> 指针，这俩是为了告诉指令该去哪，以及栈要去哪的。</p>
<p>所以答案就呼之欲出了，前三个简单，543 一路下来即可；接下来是返回地址，也就是题目给出的初始条件；再下来是题目给出的初始 ebp；接着是调用 <code>bar</code> 函数的栈排列，也还是参数，但是这里题目是换了顺序的，所以先 3 后 4；然后是返回值地址，找到汇编代码中 call 的下一句，就是它了；最后一句可有可无，不过为了清晰 ebp 的做用，还是写上，应该指向旧的 ebp 地址，也就是 <code>0xffffd840</code>，至此，题目完成。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一次我们主要来回顾一下重要的知识点，以及讲解一些往年试题中容易混淆的概念。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="复习" scheme="http://wdxtub.com/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 期中考试复习]]></title>
    <link href="http://wdxtub.com/2016/02/27/sad-midterm-review/"/>
    <id>http://wdxtub.com/2016/02/27/sad-midterm-review/</id>
    <published>2016-02-28T03:10:51.000Z</published>
    <updated>2016-03-03T17:26:41.000Z</updated>
    <content type="html"><![CDATA[<p>这一部分是根据老师给出的复习提纲总结的部分相关内容，但是由于架构这个东西太抽象，所以只能尽力去理解一下了。</p>
<a id="more"></a>
<hr>
<p>一想到要背这么多东西我就头疼，尽量利用已有知识理解之后串起来。</p>
<blockquote>
<p>Why software architecture is important?</p>
</blockquote>
<p>自己的一些思考，之所以重要是因为：</p>
<ul>
<li>软件架构影响到传统软件开发的每一个环节</li>
<li>清晰的软件架构是项目正常推进的指引</li>
<li>方便重用与修改</li>
<li>易于分析和测试</li>
</ul>
<blockquote>
<p>Various view points</p>
</blockquote>
<p>这里应该就是<a href="http://wdxtub.com/2016/01/31/sad-r3/">习题课 3 从不同视角描述系统</a>的内容，几个视角是：</p>
<ul>
<li>Function View: 各个模块图，包括接口和依赖</li>
<li>Information View: 展示 schema，数据模型和数据流，用状态机图来描述系统的信息模型</li>
<li>Concurrency View: 软件的组件需要在哪里部署和运行</li>
<li>Deployment View: 主要的软件包是什么</li>
<li>Development View: 在不同地方运行时，系统是如何运行的。你会如何保证数据一致性？</li>
</ul>
<blockquote>
<p>What does it mean by architecture through software lifecycle?</p>
</blockquote>
<p>这个题目在问什么我都有点迷糊，是不是说软件架构在软件的生命周期中的作用？还是其他什么的，大概分下面几个阶段：</p>
<ul>
<li>Requirements</li>
<li>Design </li>
<li>Coding</li>
<li>Testing</li>
</ul>
<p>不同的过程都会由架构来指引并且对架构的设计和演化有影响</p>
<blockquote>
<p>Will architecture design allow creativity</p>
</blockquote>
<p>这个是开放性问题，我觉得需要回答的要点是：</p>
<ul>
<li>允许创新</li>
<li>但是更要尊重前人的经验</li>
<li>大部分情况下不需要全新的架构，需要在已有的基础上提高改进</li>
</ul>
<blockquote>
<p>Canonical elements of software architecture</p>
</blockquote>
<p>这题就是概念题了，不过之前接触了这么多次，应该有一些印象，主要最后的 configuration 可能比较容易忘</p>
<ul>
<li>Component: computation</li>
<li>Connector: communication / coordination</li>
<li>Configuration: topology and constraints</li>
</ul>
<blockquote>
<p>Architectural styles vs Architectural patterns</p>
</blockquote>
<p>这是我一直比较迷糊的概念，会着重解释一下。</p>
<ul>
<li>Architectural styles<ul>
<li>Codify key constraints and architectural elements (components, connectors, configurations) found effective used in a family of software systems over a given time period</li>
<li>Client/Server, P2P, Object Oriented, Layered, Data-Flow, Pipe and Filter, Blackboard, Rule Based</li>
</ul>
</li>
<li>Architectural patterns<ul>
<li>A set of architectural design decisions that are applicable to a recurring design problem, and parameterized to account for different software development contexts in which that problem appears.</li>
<li>3-tier (Stage-Logic-Display), MVC, Sense Compute Control</li>
</ul>
</li>
</ul>
<p>Compared to styles, architectural patterns are at a coarser level of granularity (design decisions versus actual architectural elements) and are inherently more domain specific</p>
<p>简单来说就是 style 会有更多的细节，涉及到具体的数据、对象、管道、客户端、服务器端什么的。pattern 的话就比较虚一点，具体的界限感觉也没有多么清晰，自圆其说即可</p>
<blockquote>
<p>Methods of evaluating design methods like styles and patterns</p>
</blockquote>
<ul>
<li>Vocabulary,</li>
<li>structural patterns</li>
<li>computational model</li>
<li>invariants</li>
<li>common examples</li>
<li>disadvantages</li>
<li>specializations</li>
</ul>
<p>我估计记不住，总体来说就是从概念，定义，模型，优势，劣势等说明，注意逻辑。</p>
<blockquote>
<p>Methods of design</p>
</blockquote>
<p>Greenfield design (entirely fresh start, no baggage)</p>
<ul>
<li>Analogy searching</li>
<li>Brainstorming</li>
<li>Literature searching</li>
<li>Morphological Charts</li>
<li>Removing Mental Blocks</li>
<li>Insight from requirements/implementation</li>
</ul>
<p>按照自己写作业的思路来回答即可</p>
<blockquote>
<p>Software Connectors</p>
</blockquote>
<p>4 main roles: Communication, Conversion, Facilitation, Coordination</p>
<p>8 main types: Event, Stream, Procedure Call, Arbitrator, Data Access, Distributor, Linkage, Adaptor</p>
<p>这个我真心背不下来，随缘</p>
<blockquote>
<p>Benefits of first-class connectors</p>
</blockquote>
<ul>
<li>Software evolution</li>
<li>separation of concerns</li>
<li>modularity</li>
<li>pluggability</li>
</ul>
<p>显式连接器其实是解耦的好方法，带来的好处自然就是更灵活，但是可能会有性能影响</p>
<blockquote>
<p>Architectural Modeling</p>
</blockquote>
<p>An architectural model is an artifact that captures some or all of the design decisions that comprise a system’s architecture</p>
<p>Architectural modeling is the reification and documentation of those design decisions</p>
<p>Important things to “get right”: Consistency, Accuracy/Precision, Ambiguity</p>
<p>How to choose what to model? Cost/Benefit Decision</p>
<p>What do we model? Structure (Architectural element), static/dynamic behaviors, functional/non-functional aspects, Views/Viewpoints</p>
<p>How do we evaluate modeling techniques? Scope/Purpose, Basic Elements, Style, Static/Dynamic Aspects, Dynamic Modeling, Non-functional aspects, ambiguity, accuracy/precision, viewpoints, view consistency</p>
<p>Modeling approaches: Generic, early ADLs, style-specific and domain-specific languages, extensible ADLs</p>
<blockquote>
<p>Service Oriented Architecture</p>
</blockquote>
<ul>
<li>Triangular Operational Model</li>
<li>SOA Standard Stack</li>
<li>SOA on Bilateral View</li>
<li>SOA Solution Lifecycle</li>
<li>Enterprise Service Bus</li>
<li>SOA Reference Architecture –  Software as a Service</li>
</ul>
<blockquote>
<p>ATAM</p>
</blockquote>
<ul>
<li>Nine steps</li>
<li>Review what you do in the group homework</li>
<li>Link architectural styles with utility tree, and analyze risks and provide justifications</li>
</ul>
<blockquote>
<p>People, Roles and Teams</p>
</blockquote>
<p>Desired skills</p>
<ul>
<li>Software development expertise</li>
<li>Domain expertise</li>
<li>Communicator</li>
<li>Strategist</li>
<li>Consultant</li>
<li>Leader</li>
<li>Technologist</li>
<li>Cost estimator</li>
<li>Cheerleader</li>
<li>Politician</li>
<li>Salesperson</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一部分是根据老师给出的复习提纲总结的部分相关内容，但是由于架构这个东西太抽象，所以只能尽力去理解一下了。</p>]]>
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第七周 - 假行僧]]></title>
    <link href="http://wdxtub.com/2016/02/27/fake-sadhu/"/>
    <id>http://wdxtub.com/2016/02/27/fake-sadhu/</id>
    <published>2016-02-28T01:41:16.000Z</published>
    <updated>2016-02-28T02:50:32.000Z</updated>
    <content type="html"><![CDATA[<p>我要从南走到北，我还要从白走到黑，我要人们都看到我，却不知道我是谁。</p>
<a id="more"></a>
<hr>
<blockquote>
<p>深秋，夕阳，酒馆。偌大的厅堂，除了三三两两坐在角落窃窃私语的人，有这么一个人，坐在酒馆正中。衣衫褴褛，大义凛然，手里拿着一壶酒，一饮而尽。</p>
<p>起身，回头，默念。去吧，朋友，你的灵魂与我同在。</p>
</blockquote>
<p>不知道为什么，无论是暗黑破坏神中的武僧，还是英雄联盟中的盲僧，又或是金庸笔下的虚竹，古龙笔下的无花，都着实出彩，也倍受大家喜爱。</p>
<p>对我来说，僧人的形象是两面的，既有悲天悯人苦海慈航，也有明心见性不二法门，一为外，一为内。再加一点，恐怕要数『酒肉穿肠过』这般洒脱。僧人讲究修行讲究开悟，这两个事情都需要漫长的积累和隐忍，还得心无杂念，想法太多，往往也就看不清自己。一个人心里光是太急切想去做一件事，就难免会做错了。</p>
<p>武功本就是入世的，只要你肯用心，无论做什么事的时候，都一样可以锻炼你的武功。武学的精义只有四个字——专心、苦练。其实这四个字也同样适于世上的每一件事。无论你做什么，若要想出人头地，就只有专心、苦练。</p>
<p>前些天和爸爸妈妈打电话，一直被教导『去做自己喜欢的事情』。首先得要知道自己喜欢什么，然后再努力去做，这恐怕就是所谓『成功』的秘笈了。这些天有师弟师妹来咨询相关经验，其实我倒是觉得，很多事情不必弄得一清二楚才敢去做，要相信自己能兵来将挡水来土掩。如果硬要给些什么经验，一句话也能说清楚：</p>
<blockquote>
<p>不要感动自己，要成为自己</p>
</blockquote>
<p>还有就是作业重要，考试重要，但是朋友和伙伴比这些都重要。所谓友情不是嘴上说说而已，更是应该在朋友需要的时候，出现在你最该出现的地方——朋友身边。这些才是最值得去做的事情。</p>
<p>往西岸跑了这么多趟，虽然没有实际去工作体验过，但是也借着面试的机会，近距离观察了小公司大公司。最终得到的结论就是：不合适，不喜欢。拿到 offer 当然开心，毕竟也是一种肯定，不过还是得像之前拒绝其他 offer 一样，甩下一句『大丈夫居于天地间，岂能久居人下』了。</p>
<p>假设我有十成功力，那么写代码可能只是其中的两成，虽然说这两成对于程序员日常工作已经绰绰有余了，可是我更想在一个我能恣意发挥的地方，向所有人展示我能做的，而不只是在屏幕前完成一个又一个需求，改好一个又一个 bug。</p>
<p>当然，人各有志，无论什么选择，只要是自己喜欢的，作为朋友，我定当全力支持。</p>
<p>你把我当朋友，我不能让你丢人。我有这双脚，我有这双腿，我有这千山和万水。我要这所有的所有，但不要恨和悔。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我要从南走到北，我还要从白走到黑，我要人们都看到我，却不知道我是谁。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="独立" scheme="http://wdxtub.com/tags/%E7%8B%AC%E7%AB%8B/"/>
    
      <category term="自我" scheme="http://wdxtub.com/tags/%E8%87%AA%E6%88%91/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
</feed>
