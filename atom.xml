<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-02-24T15:23:24.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 1 课 总览]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-1/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-1/</id>
    <published>2016-02-24T14:59:07.000Z</published>
    <updated>2016-02-24T15:23:24.000Z</updated>
    <content type="html"><![CDATA[<p>数据结构与算法是编程中基础中的基础，重要的不是具体某个结构或者算法本身，而是通过理解数据结构和算法在解决问题中发挥的作用，掌握如何用计算机解决问题的方法，进而练就一套自己观察问题，思考问题，解决问题的招式。</p>
<a id="more"></a>
<hr>
<p>网上相关的资料其实蛮多的，之所以打算『重复造轮子』，一是之前的<a href="http://wdxtub.com/2016/01/22/programmer-startline-1/">编程起跑线系列</a>有很多具体的算法思想没有详细说明，二是借着课程的体系重新梳理一下自己的思路。所以整个系列可能会给出大量的参考链接，用于说明基本的概念，而对于数据结构和算法背后的思想，则是我想要着重讨论的。</p>
<p>这门课的编程语言是 Java（CMU 感觉啥课都是 Java），学习目标是：</p>
<ol>
<li>根据特定问题设计或选择合适的算法</li>
<li>根据特定问题设计或选择合适的数据结构</li>
<li>在程序中使用：stacks, queues, linked lists, trees, graphs, 以及 hash tables. </li>
<li>能够用 Big O, Big Omega, 和 Big Theta 分析程序的性能</li>
<li>理解 worse case, best case, average case</li>
<li>理解程序正确性和性能的差异</li>
<li>理解 NP-completeness 理论</li>
<li>能够区分出哪里问题是可以通过计算解决的，哪些不是</li>
</ol>
<p>参考书目：</p>
<ul>
<li>《Data Structures &amp; Other Objects Using Java》 Michael Main, Fourth Edition (Addison-Wesley Longman, ISBN-13 978-0132576246)</li>
<li>《Introduction to Algorithms》Corman, et al., 1990, MIT Press, ISBN 0262031418</li>
</ul>
<p>总体来看是比较中规中矩的一门课，老师给出的课件也是比较凌乱，我会按照自己的理解重新进行组织。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>数据结构与算法是编程中基础中的基础，重要的不是具体某个结构或者算法本身，而是通过理解数据结构和算法在解决问题中发挥的作用，掌握如何用计算机解决问题的方法，进而练就一套自己观察问题，思考问题，解决问题的招式。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="信息处理" scheme="http://wdxtub.com/tags/%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[英语口语中的『噪声』]]></title>
    <link href="http://wdxtub.com/2016/02/23/pronunciation-stress/"/>
    <id>http://wdxtub.com/2016/02/23/pronunciation-stress/</id>
    <published>2016-02-24T02:33:28.000Z</published>
    <updated>2016-02-24T04:05:39.000Z</updated>
    <content type="html"><![CDATA[<p>一个人觉得自己不再需要改变的时候，最大的改变就已经发生了——他变成了没有未来的人。</p>
<a id="more"></a>
<hr>
<p>这个学期给一门研究生课程当助教，宾夕法尼亚州有这么一条法律，英语不是母语的同学当助教的话，必须要达到一定的沟通交流水平，否则学校要被罚款。具体到 CMU，就意味着我需要通过一门叫 ITA 的测试（之前的<a href="http://wdxtub.com/2016/02/19/ita-test/">日志</a>也有提及）。因为是专门负责英语教学的部门，我的英语虽然能应付日常交际，但是细化到讲课上，就有些捉襟见肘了，所以必须进行一些课程培训。</p>
<p>昨天完成了个人作业，已经感觉有了很大收获（见<a href="http://wdxtub.com/2016/02/22/how-to-speak/">这里</a>），今天去上了关于发音的培训课（主要是重音），更是感觉醍醐灌顶，小班教学，寓教于乐，原本担心两个小时太长的我，到最后还觉得时间过得太快，想让老师多讲一会儿。</p>
<p>所以在这篇日志中，讲讲如何快速掌握英语口语中的『重音』。掌握了重音，就可以最大程度减少表达中的『噪声』，让自己的表达更容易被听懂。</p>
<h2 id="u91CD_u97F3_u4E0E_u8BED_u8C03_28stress_and_intonation_29"><a href="#u91CD_u97F3_u4E0E_u8BED_u8C03_28stress_and_intonation_29" class="headerlink" title="重音与语调(stress and intonation)"></a>重音与语调(stress and intonation)</h2><p>以汉语为母语的我们，长期浸淫在汉语环境中（汉语属于 monotone），无论从生理还是心理上都难以完全转换到英语模式。但是我们真的需要说得跟以英语为母语的人一样吗？并不需要！我们需要的是让的表达更加清晰，更容易理解，至于带一点点口音其实无伤大雅，甚至有时候还能成为个人特色（生活大爆炸中的 Raj）。</p>
<p>如果说完整的表达是 100 分的话，那么口音其实只占 25 分，剩下的 75 分是重音与语调。但是奇怪的是，大多数英语学习者都忽略了这 75 分，有种舍本逐末的感觉。</p>
<p>举个例子，15(fifteen) 和 50(fifty) 是我们很容易说不清的，问题不在于我们发音不够准，而是我们重音不对。正确的读法应该是：</p>
<p>15 - fifTEEN, 50 - FIFty（大写的部分表示重音），通过重音的变换，别人可以轻松地明白我们在说 15 还是 50。</p>
<p>有重音，相对来说，肯定也有轻读的，甚至我们可以吞掉某些音节，看下面两个例子：</p>
<blockquote>
<p>Give a man a horse he can ride</p>
</blockquote>
<p>这里的 can，实际的发音类似 kon，尾音甚至可以省略</p>
<blockquote>
<p>His rank and wealth, his strenth and health</p>
</blockquote>
<p>这里的 and，实际的发音就剩下 n，大家可以自己读一下试一试。</p>
<p>再举一个对比：</p>
<blockquote>
<p>I can || go. 与 I || can’t || go. (这里 || 表示停顿)</p>
</blockquote>
<p>第一个句子，go 需要重音，第二个句子，can’t 需要重音。说了这么多，到底要怎么重音呢？有下面三个基本原则：</p>
<ol>
<li><strong>Louder</strong> (more air = more volume)</li>
<li><strong>Longer</strong> (s-t-r-e-t-c-h out the word, especially the vowel)</li>
<li><strong>Pause</strong> (before or after the stress to make it stand out)</li>
</ol>
<h2 id="u54EA_u4E9B_u8BCD_u9700_u8981_u91CD_u97F3"><a href="#u54EA_u4E9B_u8BCD_u9700_u8981_u91CD_u97F3" class="headerlink" title="哪些词需要重音"></a>哪些词需要重音</h2><p>重音本身是和说话的意思紧密相关的，所以大原则就是，要利用重音突出表达某个意思，也就是说，哪个词的信息量大，哪个词就需要重音。</p>
<p>总体来看可以这样划分：</p>
<ul>
<li>Content words are stressed: Nouns, verbs, adjectives and adverbs, question words, demonstratives(these, those, etc), negatives</li>
<li>Function words are not stressed: Prepositions, pronouns, articles, verb “to be”, conjunctions(and, but), auxiliaries(do, should, can)</li>
</ul>
<p>对于每个单词，其实也有重音，规则还是一样：louder, longer, pause。对于类似 AI, DNA 这种缩写，每个单词都需要重音。</p>
<p>对于复合名词，每个单词都需要重音，但是前面的可以再重一点，比如 “quantum || mechanics”</p>
<h2 id="u5229_u7528_u91CD_u97F3_u6765_u5F3A_u8C03_u4FE1_u606F"><a href="#u5229_u7528_u91CD_u97F3_u6765_u5F3A_u8C03_u4FE1_u606F" class="headerlink" title="利用重音来强调信息"></a>利用重音来强调信息</h2><p>对一个句子不同单词重音，可以有不同的强调效果，比如</p>
<ul>
<li>Did John study Chemical Engineering last semester? (normal yes/no question stress)</li>
<li>Did John study Chemical Engineering || <strong>last</strong> || semester? (no, three semesters ago)</li>
<li>Did John study || <strong>Chemical</strong> || Engineering last semester? (no, electrical)</li>
<li>Did John || <strong>study</strong> || Chemical Engineering last semester? (no, he taught)</li>
<li>Did || <strong>John</strong> || study Chemical Engineering last semester? (no, Bob did)</li>
</ul>
<p>另一种情形，是利用重音来区别比较近似的两个词，如：</p>
<ul>
<li>Did you study MICRO or MACROeconomics?</li>
<li>Did you say INput or OUTput?</li>
<li>Did you say SUPER or SEMIconductor?</li>
<li>Are we talking about FISion or FUSion?</li>
<li>Are you working with HARDware or SOFTware?</li>
<li>Was the result a POSITIVE or a NEGATIVE integer?</li>
<li>Is the curve conVEX or conCAVE?</li>
<li>Is that elastic or INelastic?</li>
<li>Did you say reFLECtion or reFRACtion</li>
</ul>
<p>这里大写表示要重音的部分，仔细感受一下。</p>
<p>最后一个情况是需要纠正别人的话，那么对于纠正的地方就需要重音，比方说：</p>
<ul>
<li>Boston is a state -&gt; No, it’s a || <strong>city</strong>.</li>
<li>Tokyo is in Korea -&gt; No, it’s in || <strong>Japan</strong>.</li>
</ul>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>给我震动最大的，不是精心准备的上课材料，不是精细到位的指导，而是去思考如何做好一件事情，并用最好的方式传达出去感染更多的人。这种教育模式是我在国内很少见到的（也就我爸妈教我的时候是这样），有这样的老师，学生又如何能不『尊师重道』呢？</p>
<p>信噪比是一个很重要的思路，生活中的方方面面都可以从这个角度来切入，思考并改进已有的方法。</p>
<p>最后说一个很有意思的看问题的角度，在强调语调和重音的作用时，老师让我们试着去模仿英语为母语的人如何说中文，通过仔细揣摩个中不同，就会发现他们即使说中文也带着说英文时的重音和语调，我们听起来就觉得有点怪（虽然意思可以明白），反之亦然。</p>
<p>这种通过反向模仿来进行思考和比较的思路，其实还可以应用在很多方面，这堂课哪怕我只听了这么一句话，这两个小时也值了，更何况整堂课干货满满毫无尿点呢！</p>
<p>还有很长的路要走，我要加油。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个人觉得自己不再需要改变的时候，最大的改变就已经发生了——他变成了没有未来的人。</p>]]>
    
    </summary>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 第 14 课 文件 vs 数据库]]></title>
    <link href="http://wdxtub.com/2016/02/22/cc-14/"/>
    <id>http://wdxtub.com/2016/02/22/cc-14/</id>
    <published>2016-02-22T14:46:58.000Z</published>
    <updated>2016-02-24T02:35:04.000Z</updated>
    <content type="html"><![CDATA[<p>从这一课起，我们要开始使用数据库了。通过数据库和文件的性能对比以及 SQL 与 NoSQL 的对比，学会选择最合适的技术。</p>
<a id="more"></a>
<hr>
<h2 id="u5B66_u4E60_u76EE_u6807"><a href="#u5B66_u4E60_u76EE_u6807" class="headerlink" title="学习目标"></a>学习目标</h2><ol>
<li>了解使用文件来存储信息的优势和劣势</li>
<li>增加使用 <code>awk</code>, <code>grep</code> 等命令修改文件的经验</li>
<li>了解使用数据库来存储信息的优势和劣势</li>
<li>了解 MySQL (SQL) 和 HBase (NoSQL) 的不同</li>
<li>学会如何把数据载入到数据库中(MySQL, HBase)</li>
<li>学会使用 JDBC 连接 MySQL</li>
<li>学会使用 Java API 来操作 HBase</li>
<li>了解 vertical scaling 的在持久云存储（磁盘, 固态硬盘）的性能</li>
</ol>
<p>这次的作业主要用 Bash 和 Java(MySQL &amp; HBase) 在 AWS 平台上完成。</p>
<h2 id="u80CC_u666F_u77E5_u8BC6"><a href="#u80CC_u666F_u77E5_u8BC6" class="headerlink" title="背景知识"></a>背景知识</h2><p>近年来『数据』越来越被重视，这之中很重要的一环就是——如何存储这些数据。这一课中我们会接触常见的存储数据的方式，并学会在实际场景中根据需要选择合适的技术。</p>
<p>我们先会介绍<a href="https://en.wikipedia.org/wiki/Flat_file_database" target="_blank" rel="external">『文件』</a>以及『关系型数据库』</p>
<p>通常来说，我们用文件来保存非结构化的数据，用数据库来保存结构化的数据，我们来看看下面这个例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件中的一行</span></span><br><span class="line">Name: Carnegie, Course: Cloud Computing, Section: A, Year: <span class="number">2015</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库中的一行（有四列）</span></span><br><span class="line">Name           Course         Section     Year</span><br><span class="line">Carnegie    Cloud Computing      A        <span class="number">2015</span></span><br></pre></td></tr></table></figure>
<p>在数据库中，数据以表的形式存储，访问不同的元素比较简单，但是在文件中，就需要做一定的解析工作。文件和数据库各有所长，重要的还是具体问题具体分析，不能一概而论。</p>
<p>除了文件和传统的关系型数据库，NoSQL 数据库现在也越来越流行了。因为大数据面临的挑战，NoSQL 数据库在扩展性上比传统方法更好，但是却不得牺牲一些一致性和结构性来换取性能和可拓展性。</p>
<p>这节课我们同样会尝试在 HBase 上做一些操作。完成之后，应该能够对这三种方式有更加清晰的理解，以及能够根据实际使用场景来选择对应的方法。</p>
<h2 id="u80CC_u666F_u8BBE_u5B9A"><a href="#u80CC_u666F_u8BBE_u5B9A" class="headerlink" title="背景设定"></a>背景设定</h2><p>我们的目标是打造一个关于音乐和电影的社交网络，作为一个菜鸟，我拿到的第一个任务是分析音乐数据。在把服务部署到云上之前，公司希望我能评估一下用文件和用关系型数据库的性能比较。提供的数据文件如下：</p>
<p><img src="/images/14561603284363.jpg" alt=""></p>
<p>其中 <code>million_songs_metadata.csv</code> 包含所有歌曲的信息，<code>million_songs_sales_data.csv</code> 包含一段时间内每首歌的每日销量。具体的格式如下：</p>
<p><img src="/images/14561643038821.jpg" alt="Schema for file `million_songs_metadata.csv`"></p>
<p><img src="/images/14561643402177.jpg" alt="Schema for file `million_songs_sales_data.csv`"></p>
<p>最后注意要给所有用到的资源打上 <code>Project: 3.1</code> 的标签</p>
<h2 id="u6587_u4EF6_u64CD_u4F5C"><a href="#u6587_u4EF6_u64CD_u4F5C" class="headerlink" title="文件操作"></a>文件操作</h2><p>这一部分主要是使用 <code>grep</code> 和 <code>awk</code> 来进行一些简单的数据处理工作，关于这两个命令的使用，本来是打算专门写日志来说明的（然而一直没抽出时间），所以就尽量在这里介绍得清晰一点。</p>
<p>Grep 命令可以用来查找文件中出现的关键词或者某种固定的模式，如果我们要找到一个文件中包含 “The Beatles” 的记录，那么可以用以下命令：</p>
<p><code>grep -P &#39;The Beatles&#39; million_songs_metadata.csv</code></p>
<p>具体的查找过程可以有不同的参数进行设置，比方说下面的语句就会忽略大小写进行匹配：</p>
<p><code>grep -i -P &#39;The Beatles&#39; million_songs_metadata.csv</code></p>
<p>关于不同参数的意义，可以直接在命令行中输入 <code>man grep</code> 进行查看。</p>
<p>利用管道，我们可以统计具体的行数，比如：</p>
<p><code>grep -P &#39;The Beatles&#39; million_songs_metadata.csv | wc -l</code></p>
<p>用 grep 得到的结果，只要某一行出现了要找的内容，就算找到，但是如果我们想在指定的列中寻找特定的字符，就可以使用 awk 命令了。比方说，我们只想找出 <code>artist_name</code> 那一列中出现 “The Beatles” 的记录，就可以用下面的命令：</p>
<p><code>awk &#39; BEGIN {FS = &quot;,&quot;} ; {if ($7 ~ /The Beatles/) { print; }}&#39; million_songs_metadata.csv</code></p>
<p>这里 <code>$7</code> 表示是第 7 列，而 <code>FS = &quot;,&quot;</code> 表示分隔符是 <code>,</code></p>
<p>如果我们想要更复杂一点的逻辑，比如要找到 Michael Jacksn 80 年代的歌曲，就可以用这个命令：</p>
<p><code>awk &#39; BEGIN {FS = &quot;,&quot;} ; {if (tolower($7) ~ /michael jackson/ &amp;&amp; $11 &gt;= 1980 &amp;&amp; $11 &lt; 1990) { print; }}&#39; million_songs_metadata.csv</code></p>
<p>随着问题越来越复杂，可能很多时候都没有办法在一行内解决问题，不过在这一部分，我们还是尽量试试看用 grep 和 awk 解决问题。</p>
<p>做好准备之后可以开启一个 <code>ami-ca685ba0</code> 的 <code>t1.micro</code> 实例来完成下面的任务。</p>
<p>基本我们要做的就是把 <code>runner.sh</code> 补充完整，仔细读题，仔细读题，仔细读题（比如是否区别大小写）。</p>
<p>第五题可以写一个程序或者若干命令，以 <code>million_songs_metadata.csv</code> 和 <code>million_songs_sales_data.csv</code> 中相同 <code>track_id</code> 为标准，合并两个文件。生成一个 <code>million_songs_metadata_and_sales.csv</code> 数据集，其中第 1 列是 <code>track_id</code>，第 2 列是 <code>sales_date</code>，第 3 列是 <code>sales_count</code>，第 4 - 13 列是 <code>million_songs_metadata.csv</code> 的其他列。</p>
<p>完成问题之后，可以使用 <code>./runner.sh files</code> 来检查输出结果</p>
<p><strong>提示</strong></p>
<ol>
<li>搜索找到一个能够完成合并文件的 unix 命令</li>
<li>只能用命令行脚本完成</li>
<li>不要使用 Java 和 Python</li>
<li>没有特别声明，所有的匹配都是大小写敏感的</li>
<li>第六题中，一个歌手可能有多个 <code>artist_names</code>，但是只会有一个唯一的 <code>artist_id</code>，应该根据 <code>artist_id</code> 来找到最大的销量，并返回所有 <code>artist_name</code></li>
<li>注意保存好 <code>runner.sh</code></li>
</ol>
<h3 id="u89E3_u9898_u653B_u7565"><a href="#u89E3_u9898_u653B_u7565" class="headerlink" title="解题攻略"></a>解题攻略</h3><p>首先先创建一个 <code>ami-ca685ba0</code> 的 <code>t1.micro</code> 实例。就绪之后 ssh 过去：<code>ssh -i demo.pem ubuntu@ec2-54-175-177-74.compute-1.amazonaws.com</code>，即可见到这次作业的相关文件：</p>
<p><img src="/images/14561733687303.jpg" alt=""></p>
<p>这部分我们只需要用 <code>runner.sh</code>，所以把它搞到本地 <code>scp -i demo.pem ubuntu@dns.compute-1.amazonaws.com:~/Project3_1/runner.sh ./</code></p>
<p>打开 <code>runner.sh</code> 文件，可以看到需要回答的问题是：</p>
<ol>
<li>在文件 <code>million_songs_metadata.csv</code> 中，有多少行包含 <code>Aerosmith</code>，大小写敏感</li>
<li>在文件 <code>million_songs_metadata.csv</code> 中，<code>artist_name</code> 包含 <code>Bob Marley</code> 的 <code>track_id</code> 有多少个，大小写敏感</li>
<li>在文件 <code>million_songs_metadata.csv</code> 中，第 7 列中包含 <code>The Beatles</code> 的有多少行，大小写敏感</li>
<li>写出与 SQL 命令 <code>SELECT AVG(duration) FROM songs</code> 等价的命令行命令</li>
<li>把两个 csv 文件合并为 <code>million_songs_metadata_and_sales.csv</code>，以相同 <code>track_id</code> 为标准</li>
<li>在文件 <code>million_songs_metadata_and_sales.csv</code> 中，找到销量最高的 artist，一个歌手可能有多个 <code>artist_names</code>，但是只会有一个唯一的 <code>artist_id</code>，应该根据 <code>artist_id</code> 来找到最大的销量，并返回所有 <code>artist_name</code></li>
</ol>
<p>写好之后传到服务器上：<code>scp -i demo.pem ./runner.sh ubuntu@dns.compute-1.amazonaws.com:~/Project3_1/</code></p>
<p>测试的话用 <code>./runner.sh files</code>，确定无误后使用 <code>./submitter -a dawang</code> 来进行提交，代码运行完成后输入提交密码即可。</p>
<h2 id="MySQL__u64CD_u4F5C"><a href="#MySQL__u64CD_u4F5C" class="headerlink" title="MySQL 操作"></a>MySQL 操作</h2><p>同样是使用 <code>ami-ca685ba0</code> 的 <code>t1.micro</code> 实例来完成这部分的内容</p>
<p>先通过<a href="https://youtu.be/x73HknyUGIM" target="_blank" rel="external">视频</a>来了解 MySQL 的基础知识</p>
<p>远程机器中已经安装配置好了 MySQL，使用下面的命令可以开启 MySQL 命令行客户端并且连接到数据库：</p>
<p><code>mysql -u root -pdb15319root song_db</code></p>
<p>上面的命令中，用户名是 <code>root</code> 密码是 <code>db15319root</code>，使用是数据名称是 <code>song_db</code></p>
<p>数据库的相关知识可以参考<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="external">这里</a>，就不在日志中赘述。</p>
<p>我们需要根据前面给出 schemas 来创建对应的表，作业文件中提供了 <code>~/Project3_1/create_tables.sql</code> 文件，可以从这里开始</p>
<blockquote>
<p>远程主机中的 MySQL 版本是 5.5，注意查看对应的文档</p>
</blockquote>
<p>创建好之后，可以使用下面的命令来查看表的 schema</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">DESCRIBE</span> songs;</span></span><br><span class="line"><span class="operator"><span class="keyword">DESCRIBE</span> sales;</span></span><br></pre></td></tr></table></figure>
<p>然后和前面给出的表格进行比较，看看是否一致。</p>
<p>所以我要做的是找到合适的命令，把 <code>million_songs_metadata.csv</code> 和 <code>million_songs_sales.csv</code> 导入到 MySQL 中。可以在 MySQL 命令行工具中使用 SQL 命令导入，也可以用 mysqlimport 工具来导入，记下所使用的命令即可。</p>
<p>想要验证是否导入成功的话，可以列出前十条记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> songs </span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure>
<p>SQL 的语法可以参考<a href="http://www.w3school.com.cn/sql/sql_syntax.asp" target="_blank" rel="external">这里</a>，下面选出一些简单的例子进行介绍。</p>
<p>比如说下面的命令就会从表中选出 <code>artist_name</code> 一列中包含 <code>The Beatles</code> 的表项：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> songs </span><br><span class="line"><span class="keyword">WHERE</span> artist_name </span><br><span class="line"></span><br><span class="line"><span class="keyword">LIKE</span> <span class="string">'%The Beatles%'</span>;</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>%</code> 表示任何字符出现任意次数，前面提到的寻找 <code>Michael Jackson</code> 的例子可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> songs </span><br><span class="line"><span class="keyword">WHERE</span> artist_name </span><br><span class="line"><span class="keyword">LIKE</span> <span class="string">'%michael jackson%'</span><span class="keyword">AND</span> <span class="keyword">year</span> &gt;= <span class="number">1980</span> <span class="keyword">AND</span> <span class="keyword">year</span> &lt; <span class="number">1990</span>;</span></span><br></pre></td></tr></table></figure>
<p>如果需要计算平均时间，就不需要使用 <code>awk</code> 命令那么复杂，可以直接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">duration</span>) <span class="keyword">FROM</span> songs;</span></span><br></pre></td></tr></table></figure>
<p>带索引的数据库可以极大提高查询的性能，在 MySQL 中，所有的主键都会自动成为索引。</p>
<p>Aggregate Functions 允许你在多个记录中执行运算并返回一个单一值，比较常用的有 <code>SUM</code>, <code>AVG</code>, <code>MAX</code>, <code>MIN</code> 和 <code>COUNT</code>. Aggregate functions 通常和 MySQL 的 GROUP BY 关键字一起使用来为不同的 subgroup 执行运算并返回对应结果。GROUP BY 非常有用，下面是一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> c1, c2, ... cn, aggregate_function(expression)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">WHERE</span> where_conditions</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2, ... cn;</span></span><br></pre></td></tr></table></figure>
<p>例如，要统计最近十天总销量排名，可以用下面的 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> sales_date, <span class="keyword">SUM</span>(sales_count) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sales_date</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sales_date <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure>
<p>MySQL 的 JOIN 关键字可以用来在两个或两个以上相关的表中进行查询。在 MySQL 中 <code>JOIN</code>, <code>CROSS JOIN</code> 和 <code>INNER JOIN</code> 是等价的，下面是一个例子：syntax:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#<span class="operator"><span class="keyword">select</span> <span class="keyword">statement</span></span><br><span class="line">    <span class="keyword">SELECT</span> c1,c2,....cn</span><br><span class="line">    <span class="keyword">FROM</span> join_table;</span></span><br><span class="line">#join_table</span><br><span class="line">    table1 [INNER|CROSS] JOIN table2 [join_condition]</span><br><span class="line">#join_condition:</span><br><span class="line">    ON conditional_expr</span><br><span class="line">  | USING (column_list)</span><br></pre></td></tr></table></figure>
<p><code>INNER JOIN</code> 会构造指定的表的笛卡尔乘积，也就是第一个表中的每一行通过 join condition 和第二个表中的每一行组合。因为我们的 songs 表中的所有 <code>track_ids</code> 在 sales 表中都有对应的记录，所以这里只用 <code>INNER JOIN</code> 即可。</p>
<p>例如，下面的 SQL 语句会返回销量最高的 10 首歌的名字：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> songs.title, <span class="keyword">SUM</span>(sales_count) <span class="keyword">AS</span> total_sale</span><br><span class="line"><span class="keyword">FROM</span> songs</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> sales <span class="keyword">ON</span> songs.track_id = sales.track_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sales.track_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> total_sale</span><br><span class="line"><span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于 OUTER JOIN</p>
</blockquote>
<p>和 INNER JOIN 不同的是可能会出现列的值为空的情况，根据提供不匹配的数据的表所在的位置，分为 LEFT 和 RIGHT JOINS。在 LEFT JOIN 中，会返回左边表中不匹配的记录，反之亦然。没有匹配的话，会把对应的列设为 NULL。如果想要保留不匹配的数据，这种方法就很有用了。</p>
<h3 id="JDBC__u548C_MySQL"><a href="#JDBC__u548C_MySQL" class="headerlink" title="JDBC 和 MySQL"></a>JDBC 和 MySQL</h3><p>Java Database Connectivity (JDBC) API 可以用来访问数据库，并且由于是一个跨平台的标准，在不同的平台上可以使用相同的代码。这一部分我们会使用 MySQL Connector/J。</p>
<p>第一步就是与数据建立连接，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">Connection conn = DriverManager.getConnection(URL, DB_USER, DB_PWD);</span><br></pre></td></tr></table></figure>
<p>第一行载入并初始化 MySQL 的 JDBC 驱动，然后我们就可以建立与数据库的连接（参数比较简单这里略过）</p>
<p>为了执行 SQL 操作以及获取执行完毕的结果，我们需要创建 Statement(用来执行 SQL 命令的对象)，并且在执行完成后得到一个 ResultSet 对象，下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line">ResultSet rs = stmt.executeQuery(<span class="string">"select count(*) as cnt from songs;"</span>);</span><br></pre></td></tr></table></figure>
<p>可以通过调用 <code>rs.next()</code> 来遍历结果：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (rs.<span class="keyword">next</span>()) &#123;</span><br><span class="line">    <span class="keyword">int</span> rowCount = rs.getInt(<span class="string">"cnt"</span>);</span><br><span class="line">    System.out.<span class="keyword">println</span>(<span class="string">"Total number of lines in songs is "</span> + rowCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完对应操作后，还需要关闭我们用到的 Statement 和 Connection，注意关闭 Statement 之后对应的 ResultSet 也会被关闭。</p>
<h3 id="u89E3_u9898_u653B_u7565-1"><a href="#u89E3_u9898_u653B_u7565-1" class="headerlink" title="解题攻略"></a>解题攻略</h3><p>和之前一样，我们要做的就是完成 7-11 题，需要修改 <code>MySQLTasks.java</code> 文件。仔细读题，仔细读题，仔细读题。</p>
<p>第 7-9 题我们需要为 songs 表创建索引。那么应该选择哪一列作为索引呢？</p>
<p>记录下使用的命令已经对应更新 <code>INDEX_NAME</code> 变量，建立索引需要花一点时间，不过可以换取比较大的性能提升，建立完索引后，使用下面的命令重启 mysql：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure>
<p>在第 9 题中，我们会使用和第 7 题一样的指令，就可以看到建立索引之后的性能提升。</p>
<p>开始写代码之前，可以先运行一下样例，了解 java 如何和 MySQL 交互。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac MySQLTasks<span class="class">.java</span></span><br><span class="line">java MySQLTasks demo</span><br></pre></td></tr></table></figure>
<p>会输出 songs 表中的行数（如果存在的话），做完之后可以用 <code>./runner.sh mysql</code> 来检查。</p>
<p><strong>Bonus</strong></p>
<p>如果完成 <code>MySQLTasks.java</code> 中的 <code>loadData</code> 函数，有 5 分的加分，可以通过下面代码进行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac MySQLTasks.java</span><br><span class="line">java MySQLTasks load_data</span><br></pre></td></tr></table></figure>
<p><strong>一些提示</strong></p>
<ul>
<li>SQL 的 LIKE 操作符默认是大小写不敏感的</li>
<li>记得把所有的答案输出到同一行</li>
<li>下一部分也可以用同一个远程机器，终止之前保存好所有的代码</li>
</ul>
<p>文件更灵活，可以存放结构或非结构数据，并且容易实现和修改；数据库则稍微笨重一些。对于文件来说，安全只能通过文件权限来控制，但是数据库有更加完善的权限管理。对文件的访问没有办法并行，但是数据库访问则可以。其他的不同基本上可以认为数据库有一套完整的管理接口和语法，而文件的话都需要自己实现，下表是一个总结：</p>
<p><img src="/images/14561824166535.jpg" alt="文件 vs 数据库"></p>
<p>首先我们把对应的文件复制到本地：<code>scp -i demo.pem ubuntu@dns.compute-1.amazonaws.com:~/Project3_1/MySQLTasks.java ./</code></p>
<p>然后我们可以用给出的 <code>create_tables.sql</code> 来新建数据表，先进入 MySQL 的命令行：<code>mysql -u root -pdb15319root song_db</code></p>
<p>然后输入 <code>source ./create_tables.sql</code> 来执行新建表格的命令。接着可以用 <code>DESCRIBE songs;</code> 和 <code>DESCRIBE sales;</code> 来查看是否成功创建（注意一定要最后的分号），如图</p>
<p><img src="/images/14561876662637.jpg" alt="songs 表"><br><img src="/images/14561876858760.jpg" alt="sales 表"></p>
<p>然后需要找到合适的命令，把 <code>million_songs_metadata.csv</code> 和 <code>million_songs_sales.csv</code> 导入到 MySQL 中（这里推荐用 <code>mysqlimport</code> 来导入，另一个有点问题）。命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要先更改两个 scv 文件的名字，这样才能载入到对应的表中</span></span><br><span class="line">cp million_songs_metadata.csv songs.csv</span><br><span class="line">cp million_songs_sales_data.csv sales.csv</span><br><span class="line"><span class="comment"># 然后进行载入</span></span><br><span class="line">mysqlimport -u root -pdb15319root --local --fields-terminated-by=<span class="string">","</span> --lines-terminated-by=<span class="string">"\n"</span> song_db songs.csv</span><br><span class="line">mysqlimport -u root -pdb15319root --local --fields-terminated-by=<span class="string">","</span> --lines-terminated-by=<span class="string">"\n"</span> song_db sales.csv</span><br></pre></td></tr></table></figure>
<p>然后我们用下面的命令来看看是否成功（如果不成功，就重新用前面的脚本生成一次对应的表）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> songs <span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sales <span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure>
<p>大概应该看到</p>
<p><img src="/images/14561903279207.jpg" alt=""></p>
<p>然后就可以进入写 java 代码的阶段了，先大概看一下已有的代码，发现已经帮我们初始化过了，实际上只要在代码中填写对应的 SQL 语句即可。问题为（第 7-11 题）：</p>
<ol>
<li>(7)返回 duration 最长的歌的 trackid</li>
<li>(8)选择一列作为索引，并建立索引</li>
<li>(9)返回 duration 最长的歌的 trackid（和第 1 个题目相同，用来比较性能）</li>
<li>(10)写一条与 <code>grep -P &#39;The Beatles&#39; million_songs_metadata.csv | wc -l</code> 等价的 sql 语句，这里注意大小写的问题，提示：<code>BINARY</code>（感谢 @jiexing）</li>
<li>(11)哪个 artist 的歌曲数目是第三多的，返回其名字，如果有多个，任意一个都可以</li>
</ol>
<p>其实主要就是写出对应的 SQL 语句，执行起来都是一样的，前面也有给出例子。然后就可以上传回服务器：<code>scp -i demo.pem ./MySQLTasks.java ubuntu@dns.compute-1.amazonaws.com:~/Project3_1/</code></p>
<p>测试的话用 <code>./runner.sh mysql</code>，确定无误后使用 <code>./submitter -a dawang</code> 来进行提交，代码运行完成后输入提交密码即可。</p>
<h2 id="Vertical_Scaling__u5B58_u50A8"><a href="#Vertical_Scaling__u5B58_u50A8" class="headerlink" title="Vertical Scaling 存储"></a>Vertical Scaling 存储</h2><p>那么问题来了，我们的数据到底保存在哪里呢？当然是物理世界的硬盘上，但是我们之前好像都没有考虑到这个事情，事实上，不同的硬盘对性能也有极大的影响。</p>
<p>接下来的部分我们会了解一些 Linux 下的磁盘操作命令并且利用 AWS 提供的存储设备来进行 vertical scaling。并且用常见的 benchmarking 工具来进行测试，通过整个过程，应该就能了解为什么实际存储数据的设备也对性能有极大的影响。</p>
<p>因为大多数命令都需要 root 权限，所以开始之前 <code>sudo su</code> 一下是比较方便的选择。</p>
<p>这个<a href="https://youtu.be/8Bwg_wUVhkE" target="_blank" rel="external">视频</a>介绍如何在 EC2 实例中使用 EBS</p>
<ul>
<li>一般来说在创建 EC2 实例的时候会自动创建一个 EBS 并挂载到 EC2 实例上</li>
<li>先进入 EBS Volume 页面，Create Volume -&gt; 选择不同的大小 -&gt; 选择 Availablility Zone(要和 EC2 在同一个区域) -&gt; Create</li>
<li>点击 Action -&gt; Attach Volumn -&gt; 选择已有的实例 -&gt; 填写挂载点 <code>/dev/sdf</code></li>
<li>ssh 到机器上，输入命令 <code>sudo parted -l</code> 可以发现并没有成功挂载</li>
<li>我们在磁盘上新建一个文件系统：<code>sudo mkfs.ext4 /dev/xvdf</code></li>
<li>再次运行 <code>sudo parted -l</code>，发现一切正常</li>
<li>然后创建文件夹用来挂载 <code>sudo mkdir /mnt/ebs1</code></li>
<li>接着进行挂载 <code>sudo mount /dev/xvdf /mnt/ebs1</code></li>
<li>就可以访问对应文件夹了 <code>cd /mnt/ebs1/</code></li>
<li>最后可以用 <code>df -h</code> 来进行查看</li>
</ul>
<p>GNU <code>parted</code> 是用来创建、销毁、改变大小、检查状态、复制分区的命令，可以操作分区表（取代原来的 <code>fdisk</code>），并支持如 GUID Partition Table(GPT) 等的新特性。想要了解更多可以参考<a href="https://www.gnu.org/software/parted/manual/html_chapter/parted_1.html" target="_blank" rel="external">这里</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parted <span class="operator">-l</span></span><br><span class="line">/dev/xvda1 – this is the OS partition</span><br><span class="line">/dev/xvdb – this is the first Ephemeral (instance store) drive</span><br><span class="line">/dev/xvdc – this is the second Ephemeral (instance store) drive</span><br></pre></td></tr></table></figure>
<p>创建并格式化一个分区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">umount /dev/xvdX <span class="comment">#where “X” - is a,b,c..etc (You should use your device’s name)</span></span><br><span class="line">parted /dev/xvdX mklabel gpt</span><br><span class="line">parted /dev/xvdX mkpart db ext4 <span class="number">0</span>% <span class="number">10</span>G</span><br><span class="line">mkfs.ext4 /dev/xvdX1</span><br></pre></td></tr></table></figure>
<p>对于比较小的 volume，可以直接整个格式化，不用分区</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs<span class="class">.ext4</span> /dev/xvdX</span><br></pre></td></tr></table></figure>
<p>创建挂载点并挂载</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="regexp">/storage/m</span>ountpoint</span><br><span class="line">mount <span class="regexp">/dev/y</span>ourdevice <span class="regexp">/storage/m</span>ountpoint</span><br></pre></td></tr></table></figure>
<p>到底用不用挂载点可以自己决定，不过一般来说 Linux 会挂载到 <code>/mnt</code>（EC2 也是这么做的）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount</span><br></pre></td></tr></table></figure>
<p>不带任何参数的话会显示所有的挂载点，可以用来判断是否挂载成功。</p>
<h3 id="u89E3_u9898_u653B_u7565-2"><a href="#u89E3_u9898_u653B_u7565-2" class="headerlink" title="解题攻略"></a>解题攻略</h3><p>简单来说就是比较传统硬盘和固态硬盘的性能差别，测试的场景如下：</p>
<p><img src="/images/14561980518607.jpg" alt=""></p>
<p>Sysbench 是一个包含多个测试的评测。这里我们使用的评测程序和 sysbench 唯一不同的是可以选择 [SSD|Magnetic]。</p>
<p>根据下面的指示完成不同配置的测试，记录下不同的 RPS，把数字填写到对应的位置即可。</p>
<blockquote>
<p>提示：使用比较慢的硬件时，准备 10GB 的数据可能要花费很长时间，用最好的的机器（比如 large）来准备数据</p>
</blockquote>
<p><strong>准备测试数据</strong></p>
<p>步骤如下</p>
<ol>
<li>用 <code>ami-ca685ba0</code> 启动一个 <code>t1.micro</code> 或 <code>m3.large</code> 的实例</li>
<li>创建一个 20GB 的 EBS volume (磁盘或固态硬盘) 。确保和 EC2 实例在同一个区域</li>
<li>把 EBS volume 挂载到 EC2 实例上</li>
<li>SSH 到 EC2 实例，格式化并挂载 EBS volume</li>
<li>进入挂载文件夹</li>
<li>用下面的命令生成测试数据 <code>sudo /home/ubuntu/Project3_1/sysbench --test=fileio --file-total-size=10G prepare</code></li>
</ol>
<p>上面的命令会在 EBS volume 上生成 10GB 的测试数据，在接下来的步骤中都可以重复使用</p>
<p><strong>试验 1 (上表中 Scenarios 1 &amp; 2 )</strong></p>
<p>执行以下步骤：</p>
<ol>
<li>启动一个 <code>ami-ca685ba0</code> 的 <code>t1.micro</code> 实例</li>
<li>挂载上 EBS volume </li>
<li>确保挂载成功</li>
<li>执行下面的代码 3 次（中间不要间隔太长时间）<code>sudo /home/ubuntu/Project3_1/sysbench --test=fileio --file-total-size=10G --file-test-mode=rndrw --max-time=300 --max-requests=0 run</code></li>
<li>把结果写到 <code>runner.sh</code> 中</li>
<li>使用另外的磁盘类型进行测试</li>
</ol>
<blockquote>
<p>暂时不要删除 EBS volume，之后还有用</p>
</blockquote>
<p><strong>试验 2 (上表中 Scenarios 3 &amp; 4 )</strong></p>
<ol>
<li>启动一个 <code>ami-ca685ba0</code> 的 <code>m3.large</code> 实例</li>
<li>挂载上 EBS volume </li>
<li>确保挂载成功</li>
<li>执行下面的代码 3 次（中间不要间隔太长时间）<code>sudo /home/ubuntu/Project3_1/sysbench --test=fileio --file-total-size=10G --file-test-mode=rndrw --max-time=300 --max-requests=0 run</code></li>
<li>把结果写到 <code>runner.sh</code> 中</li>
<li>使用另外的磁盘类型进行测试</li>
</ol>
<p>测试的话用 <code>./runner.sh scaling</code>，确定无误后使用 <code>./submitter -a dawang</code> 来进行提交，代码运行完成后输入提交密码即可。</p>
<h2 id="HBase__u64CD_u4F5C"><a href="#HBase__u64CD_u4F5C" class="headerlink" title="HBase 操作"></a>HBase 操作</h2><p>Apache HBase 是一个开源版本的 Google BigTable 分布式存储系统，其特点是分布式，可拓展，高性能，为大数据而生，在 Hadoop Distributed File System (HDFS) 上工作。HBase 在不同的服务器上把文件保存为重复的块，HDFS 保证其扩展性和可靠性。</p>
<p>在 HBase 中，输入按照行列排列，如下图所示：</p>
<p><img src="/images/14562066176431.jpg" alt="HBase table 的典型架构"></p>
<p>HBase 中的每一行都有对应的 row key，类似于主键，必须是唯一的。HBase 会自动根据 row key 来排列数据，默认按照字节顺序排序。</p>
<p>如上图所示，每一行包括：<code>rowkey</code>, <code>column_family</code>, <code>column</code> 和 <code>timestamp</code>，所以整个的映射变成 <code>(rowkey, column family, column, timestamp) -&gt; value</code>。Rowkey 和 value 都是简单的字节，所以只要能序列化成字节的都可以保存在 cell 中。这些 cell 会按照字典序排列，这是一个非常重要的特性，使得 HBase 支持快速搜索。</p>
<p>HBase 中的每一列都有列名，还可以进一步组织成 column family。所有的 column family 成员拥有共同的前缀，如上图所示，列 Metadata:Type 和列 Metadata:Language 都是 Metadata column family 的成员，而列 Content:Data 则属于 Content family。默认来说用冒号来分隔 column family 的前缀，这个前缀必须由能够打印的字符组成，后面的部分可以是任何字节。</p>
<p><strong>HBase 操作</strong></p>
<p>HBase 有四个主要的操作：Get, Put, Scan, 和 Delete.</p>
<ul>
<li>Get 操作会返回指定行的所有 cell</li>
<li>Put 操作可以添加新的记录或者更新已有记录</li>
<li>Scan 操作会根据条件遍历多行记录</li>
<li>Delete 操作会移除一条记录</li>
</ul>
<p>Get 和 Scan 操作的返回都是排好序的，依据为 rowkey, column family, family 成员，和时间戳（也就是最新的值会在最前面）。默认来说，Get, Scan 和  Delete 操作都是在数据最新的版本上的（也可以指定其他版本的数据）。Delete 操作一般来说会删除整行，但是也可以删除指定的 cell。</p>
<p><strong>HBase 架构</strong></p>
<p>HBase 是以 HBase 节点集群来进行组织的，节点有两种类型：master 和 slave（也叫 RegionServers）</p>
<p><img src="/images/14562066977793.jpg" alt="HBase 集群架构"></p>
<p>HBase 会动态分配数据表，这样支持大量的并行访问。一个 HBase 表在太大时会被分成多个 Region，一个 HBase Region 是一个 HBase 表的子集，但是 rowkey 的范围是连续的。每个  RegionServer 可以保存多个 Regions，但是一个 Region 只会在一个 RegionServer 上。</p>
<p>虽然一个 Region 只会在一个 RegionServer 上，但是这不意味着该 Region 部分的数据只能存在于一个 RegionServer 上。事实上，因为 HDFS 的复制机制，每个 Region 都会在其他 RegionServer 上有几份一模一样的拷贝。想要了解更多？查看 <a href="http://hbase.apache.org/book.html" target="_blank" rel="external">HBase Reference Guide</a> 以及 <a href="https://blogs.apache.org/hbase/" target="_blank" rel="external">HBase 博客</a>.</p>
<p>HBase 使用 Apache ZooKeeper 来协调控制整个 HBase 集群。Apache ZooKeeper 需要做的事情有：选择 master 节点，寻找 -ROOT- catalog table 以及节点注册（当新的 RegionServer 加入的时候）。由 ZooKeeper 选择出来的 master 节点会处理诸如 region 分配，失败处理，负载均衡等任务。</p>
<p>HBase 使用 HDFS 作为存储，但是同样支持其他文件系统（本地文件系统，甚至 Amazon S3）。</p>
<p>这个 <a href="https://youtu.be/lUOFLa0DKdc" target="_blank" rel="external">HBase Demo</a> 视频会介绍 HBase 的基本使用，虽然视频中的 EMR 版本较旧，但是对我们这次的任务没有什么影响。</p>
<ul>
<li>Costs = Instance + EMR costs</li>
<li>进入 EMR 页面 -&gt; 创建集群 -&gt; 输入名字 -&gt; 开启关闭保护 </li>
<li>选择 S3 的 log bucket -&gt; 打上标签 -&gt; 去掉 pig 和 hive，改为 HBase </li>
<li>选择 spot -&gt; 指定 keypair -&gt; 需要等待一段时间开启</li>
<li>ssh 到 master public dns，注意这里用户名是 hadoop 而不是 ubuntu</li>
<li><code>hbase shell</code> -&gt; <code>&gt; help</code> 查看帮助 -&gt; <code>&gt; status</code> 查看状态</li>
<li><code>create &#39;users&#39;, &#39;info&#39;</code> 创建表格</li>
<li><code>describe &#39;users&#39;</code> 可以查看表格内容</li>
<li><code>put &#39;user&#39;, &#39;johndeo&#39;, &#39;info&#39;, &#39;regularUser&#39;</code> 插入一条记录</li>
<li><code>get &#39;users&#39;, &#39;johndoe&#39;</code> 获取一条记录</li>
<li><code>scan &#39;users&#39;</code> 遍历某个表并输出</li>
<li><code>count &#39;users&#39;</code> 统计表的行数</li>
</ul>
<blockquote>
<p>注意：EMR 很贵，最好使用 spot instance</p>
</blockquote>
<h3 id="u4F7F_u7528_EMR__u521B_u5EFA_HBase__u96C6_u7FA4"><a href="#u4F7F_u7528_EMR__u521B_u5EFA_HBase__u96C6_u7FA4" class="headerlink" title="使用 EMR 创建 HBase 集群"></a>使用 EMR 创建 HBase 集群</h3><p>我们将使用 EMR 创建 HBase 集群。HBase 使用 Hadoop Distributed File System (HDFS) 来存储数据。默认来说 AWS 会直接用 EC2 内置的存储给 HDFS 使用，下面是具体的使用步骤：</p>
<ol>
<li>启动 EMR 集群：1 master &amp; 1 core <ul>
<li>在创建页面中选择 “Go to advanced options”</li>
<li>确保所有的实例都是 m1.large</li>
<li>确保 EMR 集群和存放 <code>runner.sh</code> 的实例在同一个区域</li>
<li>选择 AMI version 3.11.0 (hadoop version 2).</li>
<li>移除所有的已有服务(Pig &amp; Hive)并选择安装 HBase version 0.94.</li>
<li>指定 key-pair 以便 SSH 到 master 实例，ssh 的时候注意用户名是 hadoop</li>
<li>不要忘记设置标签</li>
<li>开启 “termination protection” 和 “keep-alive”</li>
</ul>
</li>
<li>master 和 core 节点的安全组都允许所有流量，使用 Master public DNS 来进行连接</li>
<li>ssh 到 master 节点之后，运行 <code>hadoop dfsadmin -report</code> 检查 HDFS 的状态</li>
</ol>
<h3 id="u8F7D_u5165_u6570_u636E_u5230_HBase"><a href="#u8F7D_u5165_u6570_u636E_u5230_HBase" class="headerlink" title="载入数据到 HBase"></a>载入数据到 HBase</h3><p>HBase 支持多种数据导入方法，这里我们介绍 Bulk Load 方法。</p>
<p>最直接的载入办法可以是在 MapReduce job 中使用 <code>TableOutputFormat</code> 类，也可以使用client APIs，但是这可能不是最有效率，因为 API 不支持 bulk loading.</p>
<p>Bulk Importing 会越过 HBase API 直接写入到数据文件中(HFiles)。使用 bulk load 可以减少 CPU 和网络带宽的占用。<code>ImportTsv</code> 就可以完成这个任务，虽然原本是为 TSV (Tab Separated Value) 格式设计的，但是通过设置参数，同样支持 CSV 文件，步骤如下：</p>
<ol>
<li>把 TSV/CSV 格式的数据集上传到 HDFS (Hadoop Distributed File System)<ul>
<li>File System (FS) shell 支持基本的文件操作比如 <code>Local FS</code>, <code>HFTP FS</code>, <code>S3 FS</code> 等等，可以通过 <code>hadoop fs &lt;args&gt;</code> 来调用</li>
<li>从 S3 bucket 获取 <code>million_songs_metadata.csv</code> 文件<ul>
<li><code>mkdir P3_1</code></li>
<li><code>cd P3_1</code></li>
<li><code>wget https://s3.amazonaws.com/15319-p31/million_songs_metadata.csv</code></li>
</ul>
</li>
<li>把下载下来的文件保存到 HDFS 中以便导入，具体命令需要自己寻找</li>
<li>可以用 <code>hadoop fs -ls /path/containing/your/uploaded/file</code> 来检测是否上传成功</li>
</ul>
</li>
<li>打开 HBase shell (<code>HBase shell</code>)并新建一个名为 songdata 的表(使用 <code>create</code> 命令，后面跟 column family name 的名字)。建立成功之后使用 <code>exit</code> 命令退出</li>
<li>为 HBase 表准备好 HFiles。使用 <code>ImportTsv</code> 命令把文件 <code>million_songs_metadata.csv</code> 中的数据传到 HDFS 中，名为 <code>importtsv.bulk.outputHbase</code>。这些 StoreFiles 之后会被载入到 HBase 中。注意这里我们使用 <code>track_id</code> 作为 row key，其他的列会成为 column family name (这里使用 ‘data’)。要了解 <code>ImportTsv</code> 的更多信息，请参考 <a href="http://hbase.apache.org/0.94/book/ops_mgt.html#importtsv" target="_blank" rel="external">official reference</a>.</li>
<li>正常启动的话，我们可以看到 MapReduce 工作的进程</li>
<li>检查 Map 步骤的输出来验证结果。通常来说应该会与数据集中的数据数量相等。注意，对应的输出文件应该是不存在的（不然会导致任务失败）</li>
<li>前面所做的所有工作都只是为了把数据保存到 HBase 中，但是此时 HBase 的表仍旧是空的（还没有添加对应的记录）</li>
<li>需要使用 CompleteBulkLoad 工具来完成数据上传，参考官方文档来使用</li>
<li>现在可以验证数据是否成功上传，打开 HBase shell 然后用以下命令来查看 <code>scan &#39;songdata&#39;</code></li>
<li>用 Ctrl-C 结束输出</li>
</ol>
<p>当然，除了这个方法，也可以在 MapReduce job 中使用 <code>TableOutputFormat</code> 或者其他 HBase client API。</p>
<h3 id="HBase__u67E5_u8BE2"><a href="#HBase__u67E5_u8BE2" class="headerlink" title="HBase 查询"></a>HBase 查询</h3><p>与 MySQL 类似，HBase 提供了查询的工具。在 HBase 中，数据存在 column 中，多个 column 组成 column family。我们可以用下面的指令来进行查询：</p>
<p><code>scan ‘table_name’, {COLUMNS =&gt; [‘column1’, ‘column2’, …], FILTER =&gt; “(FILTER1) … (FILTER2)”}</code></p>
<p>我们来做一个和之前类似的查询，找到所有 <code>artist_name</code> 以 “The Beatles” 开头的记录（是一个前缀匹配，不是子串匹配），查询如下：</p>
<p><code>scan &#39;songdata&#39;, {COLUMNS =&gt; &#39;data:artist_name&#39;, FILTER =&gt; &quot;SingleColumnValueFilter(&#39;data&#39;, &#39;artist_name&#39;, = , &#39;regexstring:^The Beatles.*&#39;)&quot;}</code></p>
<p>这里的列名的格式是 <code>(column family name):(column qualifier name)</code>。并且返回的数据中只包含了 <code>artist_name</code> 的数据，如果我们想多看一些数据，在 COLUMNS 部分多加一些内容，如：</p>
<p><code>scan &#39;songdata&#39;, {COLUMNS =&gt; [&#39;data:artist_name&#39;, &#39;data:title&#39;], FILTER =&gt; &quot;SingleColumnValueFilter(&#39;data&#39;, &#39;artist_name&#39;, = , &#39;regexstring:^The Beatles.*&#39;)&quot;}</code></p>
<p>同样，我们也可以添加更多的 FILTER，用逻辑运算符 AND, OR, WHILE 等来进行组合。比如说，如果我们想在原来条件的基础上增加另一个条件：其 title 以 W 或者以 W 之后的字母开头，那么命令就可以这么写：</p>
<p><code>scan &#39;songdata&#39;, {COLUMNS =&gt; [&#39;data:artist_name&#39;, &#39;data:title&#39;], FILTER =&gt; &quot;SingleColumnValueFilter(&#39;data&#39;, &#39;artist_name&#39;, = , &#39;regexstring:^The Beatles.*&#39;) AND SingleColumnValueFilter(&#39;data&#39;, &#39;title&#39;, &gt;= , &#39;binaryprefix:W&#39;)&quot;}</code></p>
<p>另外提一点，在 FILTER 中使用了某一列，就需要在 COLUMNS 列表中也加入对应的列名，不然就会被忽略的，更多信息可以参阅<a href="http://www.cloudera.com/content/cloudera/en/documentation/core/latest/topics/admin_hbase_filtering.html" target="_blank" rel="external">这篇日志</a>.</p>
<h3 id="HBase_Java_API"><a href="#HBase_Java_API" class="headerlink" title="HBase Java API"></a>HBase Java API</h3><p>HBase 也有其 Java API，可以用来创建、查看、修改和删除表，同样也可以插入和查询。</p>
<p><strong>建立连接</strong></p>
<p>首先我们需要建立连接，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Configuration conf = HBaseConfiguration.create();</span><br><span class="line">conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, zookeeperAddress);</span><br><span class="line">conf.set(<span class="string">"hbase.zookeeper.property.clientport"</span>, <span class="string">"2181"</span>);</span><br><span class="line">HConnection conn = HConnectionManager.createConnection(conf);</span><br><span class="line">HTableInterface table = conn.getTable(tableName);</span><br></pre></td></tr></table></figure>
<p>前三行配置地址和端口，这里需要填写 master node 的 IP 地址。然后就可以创建 <code>HConnection</code> 并得到一个 <code>HTableInterface</code> 对象（用来处理特定 HBase 表）。</p>
<p>另一个创建 HBase table handler 的方法是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTable table = <span class="keyword">new</span> HTable(conf, tableName);</span><br></pre></td></tr></table></figure>
<p>不过在新版本中已经被弃用了（所以直接不写出来不就好了嘛）</p>
<p>最常见的操作是 Get 和 Scan，get 用来获取某一行，scan 用来对多行操作，一般来说 scan 比 get 慢。不过我们这里会使用 scan。</p>
<p>下面是一个简单的例子，我们打印出所有 <code>artist_name</code> 以 “The Beatles” 开头的记录。更多详细的使用方法请参考 <a href="https://hbase.apache.org/0.94/apidocs/" target="_blank" rel="external">HBase Java API 文档</a>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new Scan object. By calling the default constructor, the entire table will be scanned.</span></span><br><span class="line">Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Binary representation of the column family name</span></span><br><span class="line"><span class="keyword">byte</span>[] bColFamily = Bytes.toBytes(<span class="string">"data"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Binary representation of the column name.</span></span><br><span class="line"><span class="keyword">byte</span>[] bCol = Bytes.toBytes(<span class="string">"artist_name"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is used for regular expression matching. You should use different comparators based on specific requirements.</span></span><br><span class="line">RegexStringComparator comp = <span class="keyword">new</span> RegexStringComparator(<span class="string">"^The Beatles.*"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This defines the filtering rules of our Scan object.</span></span><br><span class="line">Filter filter = <span class="keyword">new</span> SingleColumnValueFilter(bColFamily, bCol, CompareFilter.CompareOp.EQUAL, comp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Associate the filtering rules to our Scan object.</span></span><br><span class="line">scan.setFilter(filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use this if your query will return multiple rows.</span></span><br><span class="line">scan.setBatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the scan result.</span></span><br><span class="line">ResultScanner rs = songsTable.getScanner(scan);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Each call of rs.next() will return one row.</span></span><br><span class="line"><span class="keyword">for</span> (Result r = rs.next(); r != <span class="keyword">null</span>; r = rs.next()) &#123;</span><br><span class="line">    <span class="comment">// r represents one row in the table. r.getValue returns the specific cell (determined by column family</span></span><br><span class="line">    <span class="comment">// and column name.</span></span><br><span class="line">    System.out.println(Bytes.toString(r.getValue(bColFamily, bCol)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cleanup</span></span><br><span class="line">rs.close();</span><br></pre></td></tr></table></figure>
<p>看看 <a href="http://hbase.apache.org/0.94/book/client.filter.html" target="_blank" rel="external">HBase tutorial on Client Request Filters</a> 对完成这部分的任务也很有帮助。</p>
<h3 id="u89E3_u9898_u653B_u7565-3"><a href="#u89E3_u9898_u653B_u7565-3" class="headerlink" title="解题攻略"></a>解题攻略</h3><p>这部分的任务就是完成 <code>runner.sh</code> 中的 17-21 题，需要改动的文件是 <code>HBaseTasks.java</code>。可以用下面的代码来运行 demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac HBaseTasks.java</span><br><span class="line">java HBaseTasks demo</span><br></pre></td></tr></table></figure>
<p>会打印出所有 <code>artist_name</code> 以 “The Beatles” 开头的记录（大小写敏感）</p>
<p>先把需要的文件 scp 到本地 <code>scp -i demo.pem ubuntu@ec2-54-209-165-121.compute-1.amazonaws.com:~/Project3_1/HBaseTasks.java ./</code></p>
<p>问题列表(17 题开始)：</p>
<ol>
<li>(17)找到以 “Total” 开头 “Water 结尾的歌名</li>
<li>(18)找到 “Kanye West” 的歌曲的歌名，名称以 “Apologies” 或 “Confessions” 开头，大小写敏感</li>
<li>(19)找到歌手名以 “Bob Marley” 为前缀的一首歌的歌名，长度大于 400，年份是 2000 年之后（包括 2000 年）</li>
<li>(20)找到歌手名包含 “Consequence” 的一首歌的歌名，歌名包含 “Family” 并且 <code>artist_hotttnesss</code> 要大于 1</li>
<li>(21)找到歌手名以 “Gwen Guthrie” 为前缀的一首歌的歌名，歌名包含 “Love” 但不包含 “Bitter” 或者 “Never”，年份为 1990</li>
</ol>
<p>然后按照前面的指引开一个 EMR，注意一定要开启 SSH，不然开了等于白开，开启之后连接上去 <code>ssh -i demo.pem hadoop@ec2-52-90-21-43.compute-1.amazonaws.com</code></p>
<p>然后用 <code>hadoop dfsadmin -report</code> 检查状态，不过说已经弃用这种命令写法了，如下：</p>
<p><img src="/images/14562658234752.jpg" alt=""></p>
<p>然后我们创建一个文件夹并下载对应的 csv 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir P3_1</span><br><span class="line"><span class="built_in">cd</span> P3_1</span><br><span class="line">wget https://s3.amazonaws.com/<span class="number">15319</span>-p31/million_songs_metadata.csv</span><br></pre></td></tr></table></figure>
<p>然后创建对应的 HDFS 目录，再把 csv 文件移过去：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir /dawang</span><br><span class="line">hadoop fs -mkdir /dawang/csv</span><br><span class="line">hadoop fs -put ./million_songs_metadata.csv /dawang/csv/</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">hadoop fs -ls /dawang/csv/</span><br></pre></td></tr></table></figure>
<p><img src="/images/14562663033381.jpg" alt="hadoop fs -ls 结果"></p>
<p>然后进入 HBase Shell 操作 <code>hbase shell</code></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">001</span>:<span class="number">0</span>&gt; create <span class="string">'songdata'</span>,<span class="string">'data'</span></span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">002</span>:<span class="number">0</span>&gt; list</span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">003</span>:<span class="number">0</span>&gt; describe <span class="string">'songdata'</span></span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">004</span>:<span class="number">0</span>&gt; exit</span><br></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<p><img src="/images/14562664950809.jpg" alt=""></p>
<p>然后就需要具体的导入了，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hbase org.apache.hadoop.hbase.mapreduce.ImportTsv -Dimporttsv.separator=<span class="string">","</span> -Dimporttsv.bulk.output=/hfile_p31 -Dimporttsv.columns=HBASE_ROW_KEY,data:title,data:song_id,data:release,data:artist_id,data:artist_mbid,data:artist_name,data:duration,data:artist_familiarity,data:artist_hotttnesss,data:year songdata /dawang/csv/million_songs_metadata.csv</span><br><span class="line"></span><br><span class="line">hbase org.apache.hadoop.hbase.mapreduce.LoadIncrementalHFiles /hfile_p31 songdata</span><br></pre></td></tr></table></figure>
<p>完成之后测试一下 <code>hbase shell</code>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">001</span>:<span class="number">0</span>&gt; scan <span class="string">'songdata'</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/14562672790636.jpg" alt="结果输出"></p>
<p>有很多需要注意的地方，尤其是比较字符串的时候，有些坑是一定要踩的（爆炸感谢 @jiexing）。</p>
<p>测试的话用 <code>./runner.sh hbase</code>，确定无误后使用 <code>./submitter -a dawang</code> 来进行提交，代码运行完成后输入提交密码即可。</p>
<p>一些需要注意的地方：</p>
<ol>
<li>Java 代码中需要填写 HBase 的 master node 的 dns</li>
<li>每题的答案在一行里输出</li>
<li>设置正确的日志级别来防止不必要的输出</li>
</ol>
<blockquote>
<p>SCAN 操作是 O(N) 的，GET 操作是 O(logN)，比较好的方式是，通过精心设计的数据库，用两次 GET 操作拿到起始和结束的 rowkey，这样就有极大的效率提高，详情参考<a href="https://blog.cloudera.com/blog/2013/04/how-scaling-really-works-in-apache-hbase/" target="_blank" rel="external">这里</a></p>
</blockquote>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.runoob.com/linux/linux-comm-join.html" target="_blank" rel="external">Linux join命令</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>从这一课起，我们要开始使用数据库了。通过数据库和文件的性能对比以及 SQL 与 NoSQL 的对比，学会选择最合适的技术。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="数据库" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="文件" scheme="http://wdxtub.com/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[How to Speak]]></title>
    <link href="http://wdxtub.com/2016/02/22/how-to-speak/"/>
    <id>http://wdxtub.com/2016/02/22/how-to-speak/</id>
    <published>2016-02-22T14:14:09.000Z</published>
    <updated>2016-02-22T14:27:35.000Z</updated>
    <content type="html"><![CDATA[<p>因为要当助教的缘故，需要进行语言培训，其中一部分就是如何做展示，这篇日志主要介绍相关的技巧，主要来源自 MIT 的 Patrick Winston 的『How to Speak』小课程。</p>
<a id="more"></a>
<hr>
<h2 id="u5982_u4F55_u5F00_u59CB"><a href="#u5982_u4F55_u5F00_u59CB" class="headerlink" title="如何开始"></a>如何开始</h2><ul>
<li>了解知识本身加上练习，可以弥补大部分天赋上的差距</li>
<li>不要用讲笑话来开头，因为听众其实还没有准备好 </li>
<li>可以用一个承诺来开头，比方说告诉听众，听完我的演讲你们会得到很多有用的东西，这能让听众意识到你要说的内容的价值，并更加认真去听</li>
<li>列出大纲，第一告诉大家演讲要开始了，第二用清晰的结构让听众意识到现在所处的位置</li>
</ul>
<h2 id="u56DB_u5927_u65B9_u6CD5"><a href="#u56DB_u5927_u65B9_u6CD5" class="headerlink" title="四大方法"></a>四大方法</h2><ul>
<li>Cycling：重复去说一个事情，一次一次又一次<ul>
<li>从心理学角度来看，重复有助于形成长期记忆</li>
<li>从概率角度来看，重复可以让之前走神没听到的听众听到</li>
</ul>
</li>
<li>Verbal punctuation：用明确的分隔词来界定架构（首先，其次，等等）<ul>
<li>能够让因为走神不知道听到哪里的人重新跟上节奏</li>
</ul>
</li>
<li>Near-Miss：在解释复杂概念的时候，用具体的类似的例子，来清晰界定概念的范围<ul>
<li>比如说要介绍正方形的话，可以顺带介绍长方形，并指出为什么长方形不是正方形，这样就有了明确的区分条件</li>
</ul>
</li>
<li>Ask Quesitions：用常见且易于回答的问题来引导听众<ul>
<li>一般来说等待 5 秒钟，虽然对于演讲者来说感觉很长，但其实对于回答问题的来说很短    </li>
<li>注意，目的不是刁难人，而是让大家跟上演讲的节奏</li>
</ul>
</li>
</ul>
<h2 id="u65F6_u95F4_u548C_u5730_u70B9"><a href="#u65F6_u95F4_u548C_u5730_u70B9" class="headerlink" title="时间和地点"></a>时间和地点</h2><ul>
<li>最佳时间是早上十点半，如果要在下午三点之后进行演讲，最好准备些吃的，帮助听众补充能量，集中精神</li>
<li>要足够明亮，如果灯光太暗的话，听众容易睡着</li>
<li>尽量要选择人能坐满的地方，空着的位置很影响效果</li>
</ul>
<h2 id="u4F7F_u7528_u9ED1_u677F"><a href="#u4F7F_u7528_u9ED1_u677F" class="headerlink" title="使用黑板"></a>使用黑板</h2><ul>
<li>除了语言系统，视觉系统也是我们学习理解新知识非常重要的输入，利用黑板可以增加视觉上的冲击，帮助听众更好地理解内容</li>
<li>可以在黑板上写写画画，可以列表用作大纲，更重要的是，不用担心手放在哪里了，可以指着黑板上具体的内容进行讲述，就很自然</li>
</ul>
<h2 id="u4F7F_u7528_u6295_u5F71_u4EEA"><a href="#u4F7F_u7528_u6295_u5F71_u4EEA" class="headerlink" title="使用投影仪"></a>使用投影仪</h2><ul>
<li>应该…<ul>
<li>具体列出每一部分的标题</li>
<li>使用不同的颜色</li>
</ul>
</li>
<li>不应该…<ul>
<li>纯粹读 PPT（听众认字儿）</li>
<li>站到一边（你才是演讲的中心，而不是 PPT，要让观众把注意力集中在你身上）</li>
<li>把指点棒甩来甩去，分散注意力，所以干脆直接用手就好</li>
<li>遮住部分内容然后再掀开，这会让部分观众不爽</li>
</ul>
</li>
</ul>
<h2 id="u9053_u5177"><a href="#u9053_u5177" class="headerlink" title="道具"></a>道具</h2><ul>
<li>使用道具来增加演示效果，但是注意不要喧宾夺主</li>
</ul>
<h2 id="u98CE_u683C"><a href="#u98CE_u683C" class="headerlink" title="风格"></a>风格</h2><ul>
<li>从成功的演讲者身上学到适合自己的方法，而不是照搬</li>
<li>可以考虑的：用自己的特质（个性化装束）以及讲故事来吸引听众</li>
</ul>
<h2 id="u5982_u4F55_u7ED3_u5C3E"><a href="#u5982_u4F55_u7ED3_u5C3E" class="headerlink" title="如何结尾"></a>如何结尾</h2><ul>
<li>不要长篇大论说谢谢</li>
<li>可以用玩笑来结尾</li>
<li>提醒听众开头所提到的承诺，点题</li>
<li>Salute the audience</li>
</ul>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://vimeo.com/101543862" target="_blank" rel="external">How to Speak: Lecture Tips from Patrick Winston</a></li>
<li><a href="http://sixminutes.dlugan.com/speaking-tips-patrick-henry-winston-speak/" target="_blank" rel="external">How to Speak: 7 Speaking Tips from Patrick Henry Winston</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为要当助教的缘故，需要进行语言培训，其中一部分就是如何做展示，这篇日志主要介绍相关的技巧，主要来源自 MIT 的 Patrick Winston 的『How to Speak』小课程。</p>]]>
    
    </summary>
    
      <category term="技巧" scheme="http://wdxtub.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="演讲" scheme="http://wdxtub.com/tags/%E6%BC%94%E8%AE%B2/"/>
    
      <category term="英语" scheme="http://wdxtub.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C 格致余论 2 - Category]]></title>
    <link href="http://wdxtub.com/2016/02/21/dive-in-objc-2/"/>
    <id>http://wdxtub.com/2016/02/21/dive-in-objc-2/</id>
    <published>2016-02-22T01:07:23.000Z</published>
    <updated>2016-02-22T03:02:14.000Z</updated>
    <content type="html"><![CDATA[<p>Objective-C 中的 Category 和 Swift 中的 Extension 还是挺类似的，但是仍有一些区别，所以具体了解一下，也是有必要的。</p>
<a id="more"></a>
<hr>
<p>一般来说，在 C++ 或者 Java 中，如果我们想改变一个已有类型的行为，可以继承之后重写或者添加对应的方法。不过在 Objective-C 中，可以不用继承，就直接添加新的方法或替换已有的方法。</p>
<p>当然，前一篇文章中提到过 <code>class_addMethod</code> 方法，不过还是用 category 更加规范和方便。这里需要注意，正常情况下，我们只能添加新的方法，却不能增加新的变量。</p>
<h2 id="u4EC0_u4E48_u65F6_u5019_u7528"><a href="#u4EC0_u4E48_u65F6_u5019_u7528" class="headerlink" title="什么时候用"></a>什么时候用</h2><p>一般来说，继承是最正规的做法，可以很方便地重用。但是也有一些情况，继承不大容易，这时候用 category 就比较合适了，比如：</p>
<ol>
<li>Foundation 对象</li>
<li>用工厂模式创造的对象</li>
<li>单例对象</li>
<li>在 app 中已经使用很多次的自定对象（继承的话很容易因为漏改而出错）</li>
</ol>
<p>下面我们分别介绍这几种情况</p>
<h3 id="Foundation__u5BF9_u8C61"><a href="#Foundation__u5BF9_u8C61" class="headerlink" title="Foundation 对象"></a>Foundation 对象</h3><p>Foundation 中的类，比如 <code>NSString</code>, <code>NSArray</code>, <code>NSDictionary</code> 除了可以通过 Objective-C 的接口调用外，其实也可以用另一个 C 的接口调用。例如 <code>NSString</code> 会对应到 Core Foundation 中的 <code>CFStringRef</code>。</p>
<p>所以在实际生成的时候，其实具体的类别是难以确定的，也就是说，我们继承了一个 <code>NSString</code> 类创建了一个 <code>MyString</code>， 新建实例的时候，其实并不能保证新建的就是一个 <code>MyString</code>，所以这种情况下，不是很适合用继承，而是 category 直接进行拓展比较合适。</p>
<h3 id="u5DE5_u5382_u6A21_u5F0F_u5BF9_u8C61"><a href="#u5DE5_u5382_u6A21_u5F0F_u5BF9_u8C61" class="headerlink" title="工厂模式对象"></a>工厂模式对象</h3><p>工厂模式本身的机制就是，不用关心具体的子类，只要传入所需要的类型，会自动生成我们需要的类。</p>
<p>就拿 <code>UIButton</code> 来说，即使我们继承了，在具体生成的时候，也不能保证得到我们继承后的子类，从这个角度来看，和上一个情境是类似的。</p>
<p>或者说，我们想要改变一个父类的行为，让所有的子类都增加新的方法，当时实际上我们没办法改动这个父类的时候，就应该采用 category。</p>
<p>这种因为具体生成什么类不确定的情况，会导致很多奇奇怪怪的问题，一定要小心使用，或者直接用 Swift，真心的。</p>
<h3 id="u5355_u4F8B_u5BF9_u8C61"><a href="#u5355_u4F8B_u5BF9_u8C61" class="headerlink" title="单例对象"></a>单例对象</h3><p>这也是非常出名的设计模式了，比如 <code>UIApplication</code>, <code>NSUserDefault</code>, <code>NSNotificationCenter</code> 等都是这种设计。因为单例实现机制的问题，使其本身很难被继承，我们先来看看如何声明一个单例。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (MyClass *)sharedInstance;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现部分</span></span><br><span class="line"><span class="keyword">static</span> MyClass *sharedInstance = <span class="literal">nil</span>;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">+ (MyClass *)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> sharedInstance ? sharedInstance : (sharedInstance = [[MyClass alloc] init]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>(注意，其实一般 Singleton 会使用 GCD 的 <code>dispatch_once</code> 实现，不过暂时为了理解简单，先用上面的写法)</p>
<p>假如我们继承 MyClass 之后却没有重写覆盖 sharedInstance 方法，首先可能还是会返回原来的对象，另外如果我们覆盖的话，那么可能就会漏过放在原来的实现中的一些操作（因为我们可能看不到源代码），产生与预期不符的结果。</p>
<h2 id="Category__u7684_u5199_u6CD5"><a href="#Category__u7684_u5199_u6CD5" class="headerlink" title="Category 的写法"></a>Category 的写法</h2><p>语法还是很简单的，只要记住括号里是 category 的名称即可，我们用给 NSString 添加一个 <code>strokeCompare:</code> 为例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> (<span class="title">CustomCompare</span>)</span></span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>)strokeCompare:(<span class="built_in">NSString</span> *)anotherString;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSString</span> (<span class="title">CustomCompare</span>)</span></span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>)strokeCompare:(<span class="built_in">NSString</span> *)anotherString </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLocale</span> *strokeSortingLocale = [[[<span class="built_in">NSLocale</span> alloc]</span><br><span class="line">                    initWithLocaleIdentifier:<span class="string">@"zh@collation=stroke"</span>]</span><br><span class="line">                    autorelease];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> compare:anotherString</span><br><span class="line">                 options:<span class="number">0</span></span><br><span class="line">                   range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, [<span class="keyword">self</span> length])</span><br><span class="line">                  locale:strokeSortingLocale];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>惯例的命名方式是 <code>NSString+CustomCompare.h</code> 和 <code>NSString+CustomCompare.m</code></p>
<p>除了添加新方法，以下情况也很适合用 category</p>
<ul>
<li>将一个很大的类切分成几个部分，代码组织更清晰，也更易于跨平台</li>
<li>替换原来的实现，实现方法的重写，但是这种方式比较危险，推荐不要使用</li>
</ul>
<h2 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h2><p>另一个类似的设计是 extensions，可以认为 extensions 是一个没有名字的 category，在 extensions 中定义的方法，需要放在原本的类的实现中，是类名后面跟一对空括号，下面是一个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span>()</span></span><br><span class="line">- (<span class="keyword">void</span>)doSomething;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">- (<span class="keyword">void</span>)doSomething</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p> 具体有什么用呢，比方说可以：</p>
<ul>
<li>拆分 header</li>
<li>管理私有方法</li>
</ul>
<p>Swift 中的做法就更加简单粗暴，直接用类名，加上不同的关键字即可，如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，extension 也可以用来扩展 protocol 和 struct，不过这里暂时先不展开。</p>
<h2 id="u589E_u52A0_u53D8_u91CF_u4E0E_u5C5E_u6027"><a href="#u589E_u52A0_u53D8_u91CF_u4E0E_u5C5E_u6027" class="headerlink" title="增加变量与属性"></a>增加变量与属性</h2><p>虽然前面提到不能增加变量或者属性，但是其实还是有办法的，既然我们是用 virtual table 来记录相关的方法，同样可以用另一个表格来记录相关的变量和方法嘛，这就是 Associated Objects。具体的使用方式如下：</p>
<p><img src="/images/14561097124357.jpg" alt=""></p>
<p>另外，虽然 category 不能增加成员变量，但是 extension 可以，甚至也可以直接在 <code>@implementation</code> 中加入。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.gitbook.com/book/zonble/kkbox-ios-dev/details" target="_blank" rel="external">KKBOX iOS/Mac OS X 基本开发教材</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html" target="_blank" rel="external">Customizing Existing Classes</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html" target="_blank" rel="external">Category</a></li>
<li><a href="http://nshipster.com/associated-objects/" target="_blank" rel="external">Associated Objects</a></li>
<li><a href="http://kingscocoa.com/tutorials/associated-objects/" target="_blank" rel="external">Objective-C Associated Objects</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/" target="_blank" rel="external">Objective-C Runtime Reference</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Objective-C 中的 Category 和 Swift 中的 Extension 还是挺类似的，但是仍有一些区别，所以具体了解一下，也是有必要的。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://wdxtub.com/tags/Mac/"/>
    
      <category term="Objective-C" scheme="http://wdxtub.com/tags/Objective-C/"/>
    
      <category term="category" scheme="http://wdxtub.com/tags/category/"/>
    
      <category term="iOS" scheme="http://wdxtub.com/tags/iOS/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iTerm2 Version3 动手玩]]></title>
    <link href="http://wdxtub.com/2016/02/21/iterm-v3-preview/"/>
    <id>http://wdxtub.com/2016/02/21/iterm-v3-preview/</id>
    <published>2016-02-21T13:53:13.000Z</published>
    <updated>2016-02-21T16:20:32.000Z</updated>
    <content type="html"><![CDATA[<p>经过 18 个月的等待，iTerm2 终于迎来了第三个主要版本！虽然现在还在最后的 Beta 测试，不过很多超强功能已经可以体验了。这篇文章就带大家大致浏览下新功能，以及非常强大的 Shell integration。</p>
<a id="more"></a>
<hr>
<h2 id="u4E3B_u8981_u65B0_u7279_u6027"><a href="#u4E3B_u8981_u65B0_u7279_u6027" class="headerlink" title="主要新特性"></a>主要新特性</h2><p>这一部分先概要介绍一下 3.0 中的主要改进（相当令人惊喜）</p>
<ul>
<li>全新的界面设计<ul>
<li>配合最新 OSX 的扁平设计风格，和系统的整体基调更搭，更好看</li>
</ul>
</li>
<li>Shell Integration<ul>
<li>基本上可以认为是 login script 的超级强化版本，可以做很多超有意思的事情：命令提示符、命令执行完成的通知、拖拽上传和下载文件等等，这一部分会在后面详细介绍</li>
</ul>
</li>
<li>自动切换 profile<ul>
<li>比方说在 ssh 到远程机器上，或者进入 root 权限，或者进入某些特定的文件夹都可以自动切换 profile（至少可以变个配色）</li>
</ul>
</li>
<li>Session 恢复<ul>
<li>简单来说就是不用 tmux 的 tmux</li>
</ul>
</li>
<li>内部显示图片<ul>
<li>可以使用 <code>imgcat</code> 脚本来在 iTerm2 中显示图片（甚至 GIF 都可以），这一部分会在后面详细介绍</li>
</ul>
</li>
<li>Badges<ul>
<li>这是一个全新的功能！可以在当前的命令行的右上角显示一些相关信息（比如当前的主机名称或者 git 分支名称），这一部分后面会详细介绍</li>
</ul>
</li>
<li>密码管理器<ul>
<li>内置的密码管理器可以保存密码到 Mac OS 的 keychain 中，甚至可以在需要输入密码的时候自动打开密码管理器</li>
</ul>
</li>
<li>撤销关闭（回到过去）<ul>
<li>假如不小心关闭了一个窗口，command + z 就可以重新打开它（记得要在 5 秒之内按）</li>
</ul>
</li>
<li>标签栏现在可以放在左边，即使有很多 tab 也不怕了</li>
<li>动态 Profiles，可以把 profiles 保存在 JSON 文件中</li>
<li>不会再找不到光标了，可以高亮当前行或者让其他颜色变暗，总而言之就是显眼</li>
<li>时间戳功能能够让我看到不同命令的执行时间以及错误在何时发生</li>
<li>捕获输出，基本上来说，可以用这个功能实现部分 IDE 的便捷操作了</li>
</ul>
<p>注：虽然我不用 Alfred，但是新版的 iTerm2 也提供了对应支持，具体请查看官网文档。</p>
<h2 id="u67E5_u770B_u56FE_u7247"><a href="#u67E5_u770B_u56FE_u7247" class="headerlink" title="查看图片"></a>查看图片</h2><p>非常简单，只要使用 <code>imgcat imagename</code> 就可以显示图片，例如：</p>
<p><img src="/images/14560666426444.jpg" alt=""></p>
<p>不过使用之前还是需要配置一下：</p>
<ol>
<li>下载两个对应插件 <a href="https://raw.github.com/gnachman/iTerm2/master/tests/imgls" target="_blank" rel="external">imgls</a> <a href="https://raw.github.com/gnachman/iTerm2/master/tests/imgcat" target="_blank" rel="external">imgcat</a></li>
<li>去掉后缀名，把文件拷贝到 <code>/usr/local/bin</code> 中，并修改权限 <code>chmod 755 /usr/local/bin/imgls /usr/local/bin/imgcat</code></li>
</ol>
<p>然后就可以使用啦，如上图所示。另外一种用法是 <code>cat avatar.jpg | imgcat</code>，也是同样的效果：</p>
<h2 id="Badges"><a href="#Badges" class="headerlink" title="Badges"></a>Badges</h2><p>简单来说就是显示当前终端的信息，如下所示</p>
<p><img src="/images/14560679607791.jpg" alt=""></p>
<p>具体的设置也很简单，如果要像我这样显示的话，在 <code>Preferences&gt;Profiles&gt;General&gt;Badge</code> 输入 <code>\(session.username)@\(session.hostname)</code> 即可（这个依赖于 Shell Integration 功能）</p>
<p>更详细的文档可以查阅<a href="https://iterm2.com/badges.html" target="_blank" rel="external">这里</a></p>
<h2 id="Shell_Integration"><a href="#Shell_Integration" class="headerlink" title="Shell Integration"></a>Shell Integration</h2><p>这个算是重头戏了，不过需要先安装一下（支持 tcsh, zsh, bash 和 fish）。我是直接在菜单栏里选择 <code>iTerm2 &gt; Install Shell Integration</code> 进行安装的，实际上就是执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://iterm2.com/misc/install_shell_integration.sh | bash</span><br></pre></td></tr></table></figure>
<p>具体详细的文档在<a href="https://iterm2.com/shell_integration.html" target="_blank" rel="external">这里</a>，本文只挑选一些当下对我很有用的功能</p>
<h3 id="u5386_u53F2_u547D_u4EE4"><a href="#u5386_u53F2_u547D_u4EE4" class="headerlink" title="历史命令"></a>历史命令</h3><p>有四种方式可以查看：</p>
<ol>
<li><code>Edit&gt;Open Command History</code> (快捷键 Shift-Cmd-;)</li>
<li>自动完成功能（快捷键 Cmd-;）</li>
<li>Toolbet 中可以显示（这个后面介绍）</li>
<li>代码提示功能（View&gt;开启 Command Completion）</li>
</ol>
<p><img src="/images/14560694592327.jpg" alt="历史命令查看"></p>
<h3 id="Toolbelt"><a href="#Toolbelt" class="headerlink" title="Toolbelt"></a>Toolbelt</h3><p>在菜单栏中可以进行选择，然后就会出现在侧边栏，功能很多，很好用：</p>
<p><img src="/images/14560695283473.jpg" alt=""></p>
<p>选择之后的效果大概是：</p>
<p><img src="/images/14560695539493.jpg" alt=""></p>
<h3 id="u5BC6_u7801_u7BA1_u7406_u5668"><a href="#u5BC6_u7801_u7BA1_u7406_u5668" class="headerlink" title="密码管理器"></a>密码管理器</h3><p>我们先设置一个 trigger，如下图所示：</p>
<p><img src="/images/14560715131681.jpg" alt=""></p>
<p>然后在需要输入密码的时候，密码管理器会自动弹出：</p>
<p><img src="/images/14560715581287.jpg" alt=""></p>
<p>选择对应的帐号密码然后点击 Enter Password，就可以免去输入密码的烦恼了。</p>
<hr>
<p>还有很多功能没有摸索出来，网上的资料也比较少，以后有机会再慢慢补充吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>经过 18 个月的等待，iTerm2 终于迎来了第三个主要版本！虽然现在还在最后的 Beta 测试，不过很多超强功能已经可以体验了。这篇文章就带大家大致浏览下新功能，以及非常强大的 Shell integration。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://wdxtub.com/tags/Mac/"/>
    
      <category term="iTerm2" scheme="http://wdxtub.com/tags/iTerm2/"/>
    
      <category term="终端" scheme="http://wdxtub.com/tags/%E7%BB%88%E7%AB%AF/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C 格致余论 1 - Selector]]></title>
    <link href="http://wdxtub.com/2016/02/20/dive-in-objc-1/"/>
    <id>http://wdxtub.com/2016/02/20/dive-in-objc-1/</id>
    <published>2016-02-21T03:50:09.000Z</published>
    <updated>2016-02-22T00:56:48.000Z</updated>
    <content type="html"><![CDATA[<p>Selector 作为 Objective-C 中一个非常重要的概念，虽然在 Swift 中几乎已经不见踪影，但是在某些混编的项目中仍旧起到举足轻重的作用，所以仍然有必要深入理解一下。</p>
<a id="more"></a>
<hr>
<h2 id="Selector__u662F_u4EC0_u4E48"><a href="#Selector__u662F_u4EC0_u4E48" class="headerlink" title="Selector 是什么"></a>Selector 是什么</h2><p>所谓对概念的掌握，一定是能够用简短的语言描述出核心含义。并且还要理解这个概念的应用场景和常见上下文，这才算是『掌握』。</p>
<p>在我的理解来看，所谓 selector，实际上是函数指针的一种实现形式，我们用一个 C string 来表示对象中的某个函数，所以就可以把这个函数作为参数，传到其他的方法中去进行调用。</p>
<p>为了理解 selector，就先要搞明白，Objective-C 中的 Object，或者说 Class，到底是什么。我们知道 C 语言中是没有『类』这个概念的，只有 struct，所以 Objective-C 的 Class 在编译时会变成 C struct，Class 中包含的方法也会转换成 C function。之后在运行的时候，runtime 会建立起从 Objective-C Method 到 C function 的映射（可以认为是一个 virtual table）。</p>
<p>举个例子，我们写了一个简单的类</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Wdx</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>编译之后会变成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> mode;</span><br><span class="line">&#125; Wdx;</span><br></pre></td></tr></table></figure>
<p>所以你会发现，其实用无论用 Objective-C 还是 C 的方式进行调用，都没有问题：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wdx *wdx = [[Wdx alloc] init];</span><br><span class="line">wdx-&gt;mode = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>具体发生了什么？其实也很简单。Runtime 会为每个类准备一个 virtual table，里面是一个个键值对，key 称为 selector，类型是 <code>SEL</code>，value 实际上是 C function 的函数指针，类型是 <code>IMP</code>。而这里的 <code>SEL</code> 类型实际上就是 C string，可以用下面语句来进行输出：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, (<span class="keyword">char</span> *)(<span class="keyword">@selector</span>(doSomething)));</span><br></pre></td></tr></table></figure>
<p>了解了这个之后，我们就会发现，实际上调用某个方法，至少有以下三种方式：</p>
<ol>
<li>直接通过对象进行调用：<code>[myObject doSomething];</code></li>
<li>通过 <code>performSelector:</code> 调用：<code>[myObject performSelector:@selector(doSomething)];</code><ul>
<li>这里 <code>performSelector</code> 是基类 <code>NSObject</code> 的方法</li>
</ul>
</li>
<li>使用 <code>objc_msgSend</code> 调用：<code>objc_msgSend(myObject, @selector(doSomething), NULL);</code></li>
</ol>
<p>这里一定要清楚的意识到，其实一个类中有什么方法，是在 runtime 里决定的，既然如此，肯定有某种方法动态添加方法（比如说 category 和 swift 中的 extension，不过这里不展开）</p>
<p>也是因为这个机制，所以编译的时候，即使编译器没有发现类中对应的方法，也只是会发出警告而已；甚至如果使用 <code>performSelector:</code> 的话，连警告的不会有，只有在运行的时候才会发生 unrecognized selector sent to instance 错误导致程序崩溃。</p>
<p>比方说，我们可以通过 <code>class_addMethod</code> 方法来动态给一个类添加方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> myMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个文件</span></span><br><span class="line"><span class="preprocessor"># import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">class_addMethod([MyClass class], <span class="keyword">@selector</span>(myMethod), (IMP)myMethodIMP, <span class="string">"v@:"</span>);</span><br></pre></td></tr></table></figure>
<p>接下来就可以这么用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass *myObejct = [[MyClass alloc] init];</span><br><span class="line">[myObject myMethod];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然，直接这么做 Xcode 会给出警告的，这里只是用来介绍基本原理，实际开发中除非确实需要，否则不要这么做</p>
</blockquote>
<h2 id="Selector__u7528_u5728_u54EA"><a href="#Selector__u7528_u5728_u54EA" class="headerlink" title="Selector 用在哪"></a>Selector 用在哪</h2><p>因为 selector 可以看做是函数的另一个名字，所以很多需要调用函数或者建立连接的地方，都可以用到，以下是一些具体的使用场景</p>
<h3 id="Target/Action__u6A21_u5F0F"><a href="#Target/Action__u6A21_u5F0F" class="headerlink" title="Target/Action 模式"></a>Target/Action 模式</h3><p>这个模式非常常用，比方说我们新建的一个按钮，通过把 controller 中对应的 IBAction 方法和它连接，整个过程就是一个 Target/Action 模式，这个 controller 是 Button 的 target，而对应执行的方法，就是 action。</p>
<p>所以现在我们知道，其实在 storyboard 中做得代码和界面元素的连接，实际上就是建立一个 Target/Action 模式。不过 UIKit，也就是 iOS 上的 Target/Action 会稍微复杂一些（因为可以一次建立多个），这里用 AppKit 做例子（一次建立一个），比方说我们想要让一个按钮有自定义的行为，可以这么做：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyButton</span> : <span class="title">NSView</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> target;</span><br><span class="line">    SEL action;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">IBOutlet</span> <span class="keyword">id</span> target;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) SEL action;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyButton</span></span></span><br><span class="line">- (<span class="keyword">void</span>)mouseDown:(<span class="built_in">NSEvent</span> *)e</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> mouseDown:e];</span><br><span class="line">    [target performSelector:action withObject:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@synthesize</span> target, action;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面代码的意思是，在鼠标按下的时候，执行之前指定的 action，所以整个绑定的过程用下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[(MyButton *)button setTarget:<span class="keyword">self</span>];</span><br><span class="line">[(MyButton *)button setAction:<span class="keyword">@selector</span>(clickAction:)];</span><br></pre></td></tr></table></figure>
<p>我们可以看到在 Objective-C 中是用字符串来作为不同方法的标识符，在 C 语言会直接传递指针，其他抽象层级更高的语言有不同的处理方式，比如说把一段代码当做字符串传递，然后使用的时候去 evaluate，也可以把函数本身看做对象，直接像传递对象一样使用（也就是匿名函数），Objective-C 中的匿名函数实际上就是 block，不过这里不展开。</p>
<h3 id="u68C0_u67E5_method__u662F_u5426_u5B58_u5728"><a href="#u68C0_u67E5_method__u662F_u5426_u5B58_u5728" class="headerlink" title="检查 method 是否存在"></a>检查 method 是否存在</h3><p>这里一般用来配合向下兼容，比方说我们的代码需要调用一个新版本 iOS 才有的 API，那么最好先检查下对应方法是否存在，如果不存在，则做一些额外的处理，不然程序在较低版本的 iOS 就会崩溃，具体的检测方法也很简单，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> scale = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">if</span> ([[<span class="built_in">UIScreen</span> mainScreen] respondsToSelector:<span class="keyword">@selector</span>(scale)])&#123;</span><br><span class="line">    scale = [<span class="built_in">UIScreen</span>]<span class="variable">.scale</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过一般来说，在其他语言里，try catch 的方法是最常用的处理 method 是否存在的方式，不过因为 Objective-C 不算原生支持垃圾回收，try catch 可能会导致比较严重的内存泄露。好在 iOS 通过 runtime 提供了 ARC(Automatic Reference Conter) 来管理内存。</p>
<p>传统 Objective-C 使用 auto-release 的机制来释放内存（然而并不算太『自动』），会把要释放的内存放到下一轮 runloop 进行释放，这也是为什么不建议使用 try catch，因为实际上 try catch 是程序流中的非可控跳转，跳出了原来的 runloop，就会导致原来应该释放的内存没有释放。</p>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>另一个常见的用法是延迟调用某个方法，我们可以使用 <code>NSObject</code> 中的 <code>performSelector:withObject:afterDelay:</code> 在一定的延迟后调用某个方法，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(doSomething) withObject:<span class="literal">nil</span> afterDelay:<span class="number">1.0</span>];</span><br></pre></td></tr></table></figure>
<p>甚至还可以在方法执行之前取消方法的执行，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:<span class="keyword">self</span>];</span><br></pre></td></tr></table></figure>
<p>具体的实现方法可以是通过 <code>NSTimer</code>，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># timer 要做的事情</span></span><br><span class="line">- (<span class="keyword">void</span>)doSomething:(<span class="built_in">NSTimer</span> *)timer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Do Something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过 <code>doSomething:</code> 的 selector 来建立 timer：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span></span><br><span class="line">                          target:someObject</span><br><span class="line">                          selector:<span class="keyword">@selector</span>(doSomething:)</span><br><span class="line">                          userInfo:<span class="literal">nil</span></span><br><span class="line">                          repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<p>也可以通过 <code>NSInvocation</code> 来进行调用，实际上是把 target, action 和参数这三个东西包装成一个对象，然后进行调用，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMethodSignature</span> *sig = [MyClass instanceMethodSignatureForSelector: </span><br><span class="line">                           <span class="keyword">@selector</span>(doSomething:)];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:sig];</span><br><span class="line">[invocation setTarget:someObject];</span><br><span class="line">[invocation setSelector:<span class="keyword">@selector</span>(doSomething:)];</span><br><span class="line">[invocation setArgument:&amp;anArgument atIndex:<span class="number">2</span>];</span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span></span><br><span class="line">                          invocation:invocation</span><br><span class="line">                          repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<p>注意设置参数位置的时候要从 2 开始，参数 0 是 self, 参数 1 是 selector。</p>
<h3 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h3><p>通知的机制其实也依赖于 selector，相当于指定一个回调函数在接收到通知的时候执行对应的操作，这部分后面会专门介绍，这里就不过分展开了。</p>
<h3 id="u5728_u7EBF_u7A0B_u4E2D_u6267_u884C_u65B9_u6CD5"><a href="#u5728_u7EBF_u7A0B_u4E2D_u6267_u884C_u65B9_u6CD5" class="headerlink" title="在线程中执行方法"></a>在线程中执行方法</h3><p><code>NSObject</code> 实际上还有很多多线程执行的方法，如：</p>
<p><img src="/images/14560963965355.jpg" alt=""></p>
<p>一般来说，如果一个操作需要的时间比较多，应该放到不同线程去执行</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(doSomething) withObject:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>注意在线程中需要建立 auto-release pool，执行完毕之后通过 <code>performSelectorOnMainThread:withObjectwaitUntilDone:</code> 通知主线程，如</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSomething</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">        <span class="comment">// 在这里执行需要时间比较久的工作</span></span><br><span class="line">        [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(doAnotherThing)</span><br><span class="line">                                          withObject:<span class="literal">nil</span></span><br><span class="line">                                          waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u6570_u7EC4_u6392_u5E8F"><a href="#u6570_u7EC4_u6392_u5E8F" class="headerlink" title="数组排序"></a>数组排序</h3><p>我们实际上也可以把一个 comparator 传给排序函数，<code>NSString</code>, <code>NSDate</code>, <code>NSNumber</code>, <code>NSIndexPath</code> 都有 <code>compare:</code> 方法，可以用来进行排序，比较有用的方法是 <code>localizedCompare:</code>，会自动根据当前语言来排序。</p>
<p>这里简单列出两个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *sortedArray = [anArray sortedArrayUsingSelector:<span class="keyword">@selector</span>(localizedCompare:)];</span><br></pre></td></tr></table></figure>
<p>也可以利用 selector 让数组中的每个元素都做一次指定的操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[anArray makeObjectsPerformSelector:<span class="keyword">@selector</span>(doSomething)];</span><br></pre></td></tr></table></figure>
<h3 id="u4EE3_u66FF_if_else_/_switch"><a href="#u4EE3_u66FF_if_else_/_switch" class="headerlink" title="代替 if else / switch"></a>代替 if else / switch</h3><p>因为 selector 其实就是 C string，所以可以放在数组或者字典中备用，因为如此可以用来做条件选择来代替 if else 或者 switch，比如下面这个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(condition) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        [object doSomething];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        [object doAnotherThing];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以改写为</span></span><br><span class="line">[object performSelector:<span class="built_in">NSSelectorFromString</span>(@[<span class="string">@"doSomething"</span>, <span class="string">@"doAnotherThing"</span>][condition])];</span><br></pre></td></tr></table></figure>
<h3 id="u8C03_u7528_u79C1_u6709_API_08"><a href="#u8C03_u7528_u79C1_u6709_API_08" class="headerlink" title="调用私有 API"></a>调用私有 API</h3><p>这里的私有 API，值得就是官方文档里没有说明，但是实际上可以通过 <code>performSelector:</code> 来调用的内部方法，不过如果打算上架的话，是不能使用的，可以平时用来测试或了解系统本身的运作机制。</p>
<h2 id="u6CE8_u610F_u4E8B_u9879"><a href="#u6CE8_u610F_u4E8B_u9879" class="headerlink" title="注意事项"></a>注意事项</h2><p>使用 selector 时也有一些需要注意的地方，比方说我们使用 <code>super</code> 来调用父类的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">super</span> doSomething];</span><br></pre></td></tr></table></figure>
<p>会执行父类的 doSomething 方法，而如果是用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">super</span> performSelector:<span class="keyword">@selector</span>(doSomething)];</span><br></pre></td></tr></table></figure>
<p>实际的效果等同于 <code>[self doSomething]</code></p>
<h2 id="u4F18_u52BF_u4E0E_u9650_u5236"><a href="#u4F18_u52BF_u4E0E_u9650_u5236" class="headerlink" title="优势与限制"></a>优势与限制</h2><p>Selector 的机制本身有其便捷性，但是反过来，也造成了一定的限制。</p>
<p>在 Objective-C 中，一个对象的方法都会保存在 virtual table 中，而因为这个表是在 runtime 决定的，所以其实是非常动态的，比如说不用继承就可以增加方法，或者是直接交换不同的 selector 的指向（也就是 method swizzling）。</p>
<p>但是因为一个 selector 能且仅能对应一个方法，所以不会有 C++, Java, C# 中的重载功能，这也是为什么 Objective-C 的函数名称普遍比较长，毕竟不能根据参数列表来具体判断要执行的函数，只能在起名字上下功夫了。如果有同一个名称的方法，那么新的会覆盖旧的。</p>
<p>在 Objective-C 中，我们调用某个方法，实际上是在 virtual table 中找寻对应这个 selector 的方法，而 C++ 或 Java 则是直接指定执行 vitual table 中的某个方法。问题就来了，每次函数调用都要查表，那效率肯定不会很高，这也是为什么之前 Objective-C 一直不流行的原因。</p>
<p>不过这样做也有好处，实际上 Objective-C 没有所谓固定版本的 runtime，只要 selector 不变，通过查表一样可以找到，新系统不用保留旧系统的库，避免了 C++ 等语言中 <a href="https://zh.wikipedia.org/zh/DLL地獄" target="_blank" rel="external">dll 地狱</a>的问题</p>
<p>而最新的 Swift 中，实际上苹果放弃了这个做法，选择了和 C++, Java 类似的设计，这也是为什么 Swift 的性能反而会更好一些的原因，不过这样一样，就需要包含对应版本的 swift runtime 了，这也是为什么 swift 会出现更多因为版本不一致而导致的兼容问题的原因。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.gitbook.com/book/zonble/kkbox-ios-dev/details" target="_blank" rel="external">KKBOX iOS/Mac OS X 基本开发教材</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html" target="_blank" rel="external">Programming with Objective-C</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">Objective-C Runtime Programming Guide</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/DevPedia-CocoaCore/Selector.html" target="_blank" rel="external">Cocoa Core Competencies - Selector</a></li>
<li><a href="http://cocoasamurai.blogspot.tw/2010/01/understanding-objective-c-runtime.html" target="_blank" rel="external">Understanding the Objective-C Runtime</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Selector 作为 Objective-C 中一个非常重要的概念，虽然在 Swift 中几乎已经不见踪影，但是在某些混编的项目中仍旧起到举足轻重的作用，所以仍然有必要深入理解一下。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://wdxtub.com/tags/Mac/"/>
    
      <category term="Objective-C" scheme="http://wdxtub.com/tags/Objective-C/"/>
    
      <category term="iOS" scheme="http://wdxtub.com/tags/iOS/"/>
    
      <category term="selector" scheme="http://wdxtub.com/tags/selector/"/>
    
      <category term="理解" scheme="http://wdxtub.com/tags/%E7%90%86%E8%A7%A3/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PS4 游戏简评]]></title>
    <link href="http://wdxtub.com/2016/02/20/ps4-game-short-review/"/>
    <id>http://wdxtub.com/2016/02/20/ps4-game-short-review/</id>
    <published>2016-02-20T21:23:49.000Z</published>
    <updated>2016-02-20T23:37:29.000Z</updated>
    <content type="html"><![CDATA[<p>这个系列主要是记录一下自己玩过的众多 PS4 游戏，因为时间和篇幅所限，每个游戏可能只会用几句话简单评测，当然，某些我觉得值得单独拉出来评测的，还是会专门进行介绍的。</p>
<a id="more"></a>
<hr>
<h2 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h2><ul>
<li>入选标准纯主观</li>
<li>按自然顺序排列（就是瞎排，没有类别和时间顺序）</li>
<li>评测标准纯主观，具体评测角度看心情</li>
<li>一分钱广告费没有拿，没有利益相关</li>
<li>部分内容可能因为记忆偏差或者游戏更新而不一致，不要在意这些细节</li>
<li>先写列表，然后慢慢补充</li>
<li>想到了再多加几条显得既随性又专业</li>
</ul>
<h2 id="Amplitude"><a href="#Amplitude" class="headerlink" title="Amplitude"></a>Amplitude</h2><p>音乐游戏，除了按键之外，还需要利用方向键切换不同的音轨，总体来说非常不错。</p>
<ul>
<li>大小：2.5 GB</li>
<li>开发商：Harmonix Music Systems, Inc</li>
<li>价格：$19.99</li>
<li>发售日：2016.1.5</li>
</ul>
<p><img src="/images/14560053059106.jpg" alt=""></p>
<p>不过键位设计很奇怪，一共三个按键，分别是 L1, R1, R2，因为 R1 和 R2 的键程不一样，所以按起来怪怪的，还是有点不习惯。切换音轨需要大量的提前量预判，而且很容易在最后一个 miss，一 miss 整个 section 的分数都没有，无他，唯手熟耳。</p>
<p>画面比较科幻，看久了眼睛疼，而且音乐偏电子音乐，我不算特别喜欢。不过作为难得的音乐节拍游戏，还是值得一玩的，多人合作的话应该挺刺激。</p>
<h2 id="ARSLAN_3A_The_WARRIORS_OF_LEGEND"><a href="#ARSLAN_3A_The_WARRIORS_OF_LEGEND" class="headerlink" title="ARSLAN: The WARRIORS OF LEGEND"></a>ARSLAN: The WARRIORS OF LEGEND</h2><p>光荣开始换着花样出割草游戏了，不过这次的动画画风还是不错的。</p>
<ul>
<li>大小：15.5 GB</li>
<li>开发商：Tecmo KOEI America</li>
<li>价格：$59.99</li>
<li>发售日：2016.2.9</li>
</ul>
<p><img src="/images/14560059636741.jpg" alt=""></p>
<p>整体玩起来也没啥特别大的区别，连招还有效果都比较趋同。换句话说，我还不如玩真三呢，至少还有点代入感。这么换个模型就出来骗 60 刀，光荣也是很黑啊。不是很推荐购入，当然铁粉另说。</p>
<h2 id="Blacklight_3A_Retribution"><a href="#Blacklight_3A_Retribution" class="headerlink" title="Blacklight: Retribution"></a>Blacklight: Retribution</h2><p>标准的美式在线多人射击对战游戏，重点在于免费，不过也使得玩家的技术差距比较大，新手很容易直接被打哭（教程也不是特别友好）</p>
<ul>
<li>大小：4.6 GB</li>
<li>开发商：Hardsuit Labs</li>
<li>价格：FREE</li>
<li>发售日：2013.11.15</li>
</ul>
<p><img src="/images/14560071072422.jpg" alt=""></p>
<p>13 年的老游戏了，比较简单粗暴的对战射击，估计是预计玩家都有基本的经验了，所以学习曲线非常陡峭，而且因为是免费游戏，没啥门槛，所以很容易出现挂机的，非常影响体验。不过我一直对射击对战类游戏非常苦手，还是比较喜欢合作或者剧情向的。</p>
<h2 id="RAINBOW_MOON"><a href="#RAINBOW_MOON" class="headerlink" title="RAINBOW MOON"></a>RAINBOW MOON</h2><p>丑到哭的回合制 RPG，我玩了五分钟就表示阵亡坚持不下去，真的是太复古了。</p>
<ul>
<li>大小：1.6 GB</li>
<li>开发商：EastAsiaSoft</li>
<li>价格：$14.99</li>
<li>发售日：2016.2.16</li>
</ul>
<p><img src="/images/14560076052824.jpg" alt=""></p>
<p>战棋走格子 + 回合制 RPG，人设丑出新高度，字体和界面的整体感觉也很奇怪，让人不大舒服。总而言之，不推荐。</p>
<h2 id="Gems_of_War"><a href="#Gems_of_War" class="headerlink" title="Gems of War"></a>Gems of War</h2><p>三消 + 卡牌 + 回合 = Gems of War，个人感觉有点不伦不类。</p>
<ul>
<li>大小：1.6 GB</li>
<li>开发商：505 Games</li>
<li>价格：FREE</li>
<li>发售日：2015.11.13</li>
</ul>
<p><img src="/images/14560078541208.jpg" alt=""></p>
<p>不同颜色代表不同的能力，然后通过消除三个或以上对应元素来进行攻击或者属性增强。就我的感觉来说，要么直接神魔之塔不要太多策略，要么直接炉石传说好好收集卡牌，结合起来不是不可以，但是回合制就有点怪怪了。一次消除四个元素有额外的一轮操作并且还有附加效果，不过因为是回合制，基本上如果对手会玩，是很难有机会四个的。</p>
<p>另外，手柄玩这类点击类游戏，其实不是特别顺手。不过总体来说算是不错的休闲游戏</p>
<h2 id="GUNS_UP_21"><a href="#GUNS_UP_21" class="headerlink" title="GUNS UP!"></a>GUNS UP!</h2><p>索尼自己出的休闲即使策略小游戏，画风可爱，操作也很简单明了，不算给第一方丢脸。</p>
<ul>
<li>大小：867 MB</li>
<li>开发商：Sony Computer Entertainment America</li>
<li>价格：FREE</li>
<li>发售日：2015.12.5</li>
</ul>
<p><img src="/images/14560083740117.jpg" alt=""></p>
<p>简单来说就是控制进攻方或者防守方，用简单的操作完成指定任务，游戏模式还是很丰富的，整体的艺术风格也很和谐，虽然是战场，但是更多的是欢乐。基本上玩家要做的就是选择生产什么兵种，以及确定轰炸地点之类的技能，算是塔防类型的变体。</p>
<p>反正免费，干嘛不玩一玩呢？另外难得容量没超过 1G 但是画面也不错，我就好奇其他的『小游戏』到底放了啥在游戏里面。</p>
<h2 id="Tearaway_Unfolded"><a href="#Tearaway_Unfolded" class="headerlink" title="Tearaway Unfolded"></a>Tearaway Unfolded</h2><p>索尼大法继小小大星球用布娃娃之后，这次直接用纸片弄出了一个新世界，而且还是全 3D 的！百分百值得入手！</p>
<ul>
<li>大小：6.8 MB</li>
<li>开发商：Sony Computer Entertainment America</li>
<li>价格：$19.99</li>
<li>发售日：2015.9.8</li>
</ul>
<p><img src="/images/14560111893739.jpg" alt=""></p>
<p>无论是对手柄各种功能的应用（触摸板，声音，动作），还是整个游戏自由开放且独树一帜的艺术风格，都远远甩开 XBOX ONE 第一方游戏几条街，更可怕的是，这还只是一个不到 20 刀的『小品』游戏。</p>
<p>从小小大星球开始索尼就有点接过任天堂衣钵的感觉，本作一出，任你马里奥再强，耐不住索尼大法一波又一波艺术+创意的攻势。</p>
<p>会专门为本作写一篇测评，不然没办法表达『索尼大法好』这一题中之义。</p>
<h2 id="Bloodborne"><a href="#Bloodborne" class="headerlink" title="Bloodborne"></a>Bloodborne</h2><h2 id="DEAD_OR_ALIVE_5_Last_Round"><a href="#DEAD_OR_ALIVE_5_Last_Round" class="headerlink" title="DEAD OR ALIVE 5 Last Round"></a>DEAD OR ALIVE 5 Last Round</h2><h2 id="Destiny"><a href="#Destiny" class="headerlink" title="Destiny"></a>Destiny</h2><h2 id="Dying_Light"><a href="#Dying_Light" class="headerlink" title="Dying Light"></a>Dying Light</h2><h2 id="Fallout_4"><a href="#Fallout_4" class="headerlink" title="Fallout 4"></a>Fallout 4</h2><h2 id="FIFA_16"><a href="#FIFA_16" class="headerlink" title="FIFA 16"></a>FIFA 16</h2><h2 id="Flower"><a href="#Flower" class="headerlink" title="Flower"></a>Flower</h2><h2 id="Indivisible_Prototype"><a href="#Indivisible_Prototype" class="headerlink" title="Indivisible Prototype"></a>Indivisible Prototype</h2><h2 id="Journey"><a href="#Journey" class="headerlink" title="Journey"></a>Journey</h2><h2 id="LEGO_MARVEL_u2019s_Avengers"><a href="#LEGO_MARVEL_u2019s_Avengers" class="headerlink" title="LEGO MARVEL’s Avengers"></a>LEGO MARVEL’s Avengers</h2><h2 id="Life_Is_Strange"><a href="#Life_Is_Strange" class="headerlink" title="Life Is Strange"></a>Life Is Strange</h2><h2 id="Little_Big_Planet_3"><a href="#Little_Big_Planet_3" class="headerlink" title="Little Big Planet 3"></a>Little Big Planet 3</h2><h2 id="Loadout"><a href="#Loadout" class="headerlink" title="Loadout"></a>Loadout</h2><h2 id="METAL_GEAR_SOLID_V_3A_THE_PHANTOM_PAIN"><a href="#METAL_GEAR_SOLID_V_3A_THE_PHANTOM_PAIN" class="headerlink" title="METAL GEAR SOLID V: THE PHANTOM PAIN"></a>METAL GEAR SOLID V: THE PHANTOM PAIN</h2><h2 id="NARUTO_SHIPPUDEN_3A_Ultimate_Ninja_STORM_4"><a href="#NARUTO_SHIPPUDEN_3A_Ultimate_Ninja_STORM_4" class="headerlink" title="NARUTO SHIPPUDEN: Ultimate Ninja STORM 4"></a>NARUTO SHIPPUDEN: Ultimate Ninja STORM 4</h2><h2 id="NBA_LIVE_16"><a href="#NBA_LIVE_16" class="headerlink" title="NBA LIVE 16"></a>NBA LIVE 16</h2><h2 id="RESIDENT_EVIL_REVELATIONS_2"><a href="#RESIDENT_EVIL_REVELATIONS_2" class="headerlink" title="RESIDENT EVIL REVELATIONS 2"></a>RESIDENT EVIL REVELATIONS 2</h2><h2 id="The_Crew"><a href="#The_Crew" class="headerlink" title="The Crew"></a>The Crew</h2><h2 id="Toukiden_3A_Kiwami"><a href="#Toukiden_3A_Kiwami" class="headerlink" title="Toukiden: Kiwami"></a>Toukiden: Kiwami</h2><h2 id="Uncharted_3A_The_Nathan_Drake_Collection"><a href="#Uncharted_3A_The_Nathan_Drake_Collection" class="headerlink" title="Uncharted: The Nathan Drake Collection"></a>Uncharted: The Nathan Drake Collection</h2><h2 id="Warframe"><a href="#Warframe" class="headerlink" title="Warframe"></a>Warframe</h2><h2 id="Farcry_4"><a href="#Farcry_4" class="headerlink" title="Farcry 4"></a>Farcry 4</h2><h2 id="The_Last_of_US"><a href="#The_Last_of_US" class="headerlink" title="The Last of US"></a>The Last of US</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>这个系列主要是记录一下自己玩过的众多 PS4 游戏，因为时间和篇幅所限，每个游戏可能只会用几句话简单评测，当然，某些我觉得值得单独拉出来评测的，还是会专门进行介绍的。</p>]]>
    
    </summary>
    
      <category term="PS4" scheme="http://wdxtub.com/tags/PS4/"/>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="评测" scheme="http://wdxtub.com/tags/%E8%AF%84%E6%B5%8B/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第六周 - 曾经的你]]></title>
    <link href="http://wdxtub.com/2016/02/19/used-to-be/"/>
    <id>http://wdxtub.com/2016/02/19/used-to-be/</id>
    <published>2016-02-20T03:13:43.000Z</published>
    <updated>2016-02-20T04:08:29.000Z</updated>
    <content type="html"><![CDATA[<p>曾梦想仗剑走天涯，看一看世界的繁华。走在勇往直前的路上，有难过也有精彩。</p>
<a id="more"></a>
<hr>
<p>阿来写过一本书，叫《尘埃落定》，说的是一个傻子少爷，用其特有的观察世界的角度，穿透愚蠢与欲望，一针见血刺出事物的本质，也见证了土司制度的衰亡。这一周，我也算是『随性』而『傻』地做出了『尘埃落定』的决定：买好回国机票，切断所有后路，大踏步继续往前。</p>
<p>一直觉得，年轻人不要用所谓『大家觉得好』的路，去麻痹和替代自己对未来的思考。喜欢什么，讨厌什么，擅长什么，拙于什么，都应该在不同的体验中增进对自己的了解。对我来说，没有家庭的负担，甚至也没有太多儿女情长的羁绊，所以更希望去做自己真正想要去做的事情。</p>
<p>回顾自己一路走来的旅程，更多的决定是随性的，或者说是冥冥之中已经决定的，从论文的题目，到学业的选择，从租房的变动，到工作的确定，都是和自己的兴趣爱好有关。一直以来都是那种一旦有个念头就打不起精神做其他事情的人，恐怕全情投入背水一战才是最好的选择。</p>
<p>前段时间有些迷茫，毕竟身处大环境中，很容易被身边人的焦虑所『感染』，开始去追逐『大家觉得好』的事情，用『大家觉得对』的评判标准来衡量自己。后来想清楚了才意识到，既然一直以来我选择的就是不同的路，不同的标准，那么唯一的标尺，就是这件事情我喜不喜欢，我愿不愿意去做，而不是那些『别人觉得好大家都应该去做』的事情。</p>
<p>即使有这么一条路，宽敞平坦，直达所谓『终点』，我也并不愿意走。目的地不明确，又可能是坎坷的路，我反而愿意去试试，毕竟，每一步都是经过自己的判断迈出的，走出去才无怨无悔。而且话说回来，到底那条路更艰难，不去试试怎么知道呢？同样是做火影忍者游戏，玩家很短时间就能意识到谁是用心开发谁是为了赚钱，生活学习工作也是这个道理：不要隐藏自己，努力去做自己真正想做的事情。</p>
<p>随着对课程的适应，基本上进入了比较轻松的阶段，开学前计划的各类事项也在逐步启动。重启翻译计划后，因为对计算机体系的深入理解，很多概念的理解也更加深入了。另外一个好消息是，随着时间的推移，自己的技术博客也逐渐有了一些有价值的互动了，这是我一直想要看到的。既然知道了很多东西中文世界里没人写过，那么我愿意吃点苦流点汗，去做这第一个人（这周的几篇日志应该都是其他地方没有的）。</p>
<p>身处变革的时代，在中国这样一个『启蒙时代』一切未定型的国家，经济政治社会环境道德文化都有太多太多需要改进的地方，有太多太多让年轻人大展宏图的机会，为什么不趁着年轻去闯一闯呢？假如生活终将归于平静，为什么不在万籁俱寂前发出自己的声音呢？</p>
<blockquote>
<p>正义之子面对有悖于常理的世界，会使其天翻地覆</p>
</blockquote>
<p>让我们干了这杯酒，好男儿胸怀像大海。总想起身边走在路上的朋友，有多少正在醒来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>曾梦想仗剑走天涯，看一看世界的繁华。走在勇往直前的路上，有难过也有精彩。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="坚持" scheme="http://wdxtub.com/tags/%E5%9D%9A%E6%8C%81/"/>
    
      <category term="转弯" scheme="http://wdxtub.com/tags/%E8%BD%AC%E5%BC%AF/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ITA Testing 相关资料]]></title>
    <link href="http://wdxtub.com/2016/02/19/ita-test/"/>
    <id>http://wdxtub.com/2016/02/19/ita-test/</id>
    <published>2016-02-19T15:06:41.000Z</published>
    <updated>2016-02-19T15:58:35.000Z</updated>
    <content type="html"><![CDATA[<p>这门语言考试是在 CMU 做助教必须要通过的，虽然『据说』比较轻松，但是还是认真准备一下，算是通过研究考试的方式加深对于语言本身的认识。</p>
<a id="more"></a>
<hr>
<p>简单来说，就是所有母语不是英语的助教，都需要通过这么一个测试。主要考察口语交流能力，整个过程有 4 到 5 个评审，测试包含两部分：</p>
<ol>
<li>交流部分，需要讨论自己的学术背景和兴趣</li>
<li>具体选择一个话题来进行正式的解释（大约五分钟），评审会根据内容来问一些问题。</li>
</ol>
<p>主要考察发音、语法、流畅度以及如何去定义一个学术概念，并且解释清楚术语和定义，以及举出相关例子来进行阐述和说明。注意这里的要求不会特别高，所以不用担心，也不会评价专业领域的知识和教学技巧。</p>
<p>会有四个评价等级：</p>
<p>Pass, Restricted I, Restricted II, Not Qualified</p>
<p>这里只贴出前两个等级（毕竟后面两个比较惨）</p>
<p><img src="/images/14558964554346.jpg" alt=""></p>
<p>还有一些具体的技巧，我觉得不仅可以用在 ITA 测试上，对于日常的交流也很有帮助。列举如下：</p>
<ul>
<li>了解你的听众，他们对各个领域有基本的相关知识，但是可能对特定领域没有很深的认识，所以一定要考虑到听众的接收程度</li>
<li>解释清楚那些可能对于普通人来说难以理解的技术名词，不要依赖公式和『科学黑话』</li>
<li>做助教很多时候需要面对没有准备的问题，就是需要测试在这种情况下我们的表现</li>
<li>如果评审给出的主题不合适，需要说清楚为什么不合适，并且找到一个合适的话题，总体来说就是一个交流的过程</li>
<li>因为只有五分钟的时间，所以可能评审会打断你的解释，所以把每一句话当做最后一句话，尽力解释清楚</li>
<li>语速不要太快，注意说话的节奏</li>
<li>和听众多多交流，确保他们听懂</li>
<li>可能的话使用黑板，视觉也是学习很重要的输入</li>
<li>注意使用过渡语言来让听众明白整个介绍的逻辑组织形式</li>
<li>不要紧张，不要紧张，不要紧张</li>
</ul>
<p>基本上是一个考察『硬实力』的测试，正常发挥应该就没有多少问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这门语言考试是在 CMU 做助教必须要通过的，虽然『据说』比较轻松，但是还是认真准备一下，算是通过研究考试的方式加深对于语言本身的认识。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="助教" scheme="http://wdxtub.com/tags/%E5%8A%A9%E6%95%99/"/>
    
      <category term="测试" scheme="http://wdxtub.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac 技巧指南]]></title>
    <link href="http://wdxtub.com/2016/02/18/mac-tips/"/>
    <id>http://wdxtub.com/2016/02/18/mac-tips/</id>
    <published>2016-02-19T03:05:09.000Z</published>
    <updated>2016-02-19T03:33:37.000Z</updated>
    <content type="html"><![CDATA[<p>这里主要整理一些一直以来使用 Mac 的技巧以及构建高效开发学习环境的指南。主要是按照个人的使用习惯，所以所用的工具和软件都比较偏写代码一些。</p>
<a id="more"></a>
<hr>
<h2 id="u6280_u5DE7_u7BC7"><a href="#u6280_u5DE7_u7BC7" class="headerlink" title="技巧篇"></a>技巧篇</h2><p>遇到一些疑难杂症，可以试试看。</p>
<h3 id="u5207_u6362_shell"><a href="#u5207_u6362_shell" class="headerlink" title="切换 shell"></a>切换 shell</h3><p>nano 编辑器中</p>
<ul>
<li>ctrl 表示 ^</li>
<li>F3保存，F2退出</li>
</ul>
<p>具体步骤</p>
<ol>
<li><code>sudo nano /etc/shells</code></li>
<li>把 <code>/usr/local/bin/fish</code> 添加进去（这里以添加 fish shell 为例子）</li>
<li><code>chsh -s /usr/local/bin/fish</code> （平时切换只需要用这句即可）</li>
</ol>
<h3 id="u6279_u91CF_u5220_u9664_u6307_u5B9A_u7C7B_u578B_u7684_u6587_u4EF6"><a href="#u6279_u91CF_u5220_u9664_u6307_u5B9A_u7C7B_u578B_u7684_u6587_u4EF6" class="headerlink" title="批量删除指定类型的文件"></a>批量删除指定类型的文件</h3><p>可以使用这条命令</p>
<p><code>find . -name &quot;.Ulysses-Group.plist&quot; -exec rm -Rf {} \;</code></p>
<h3 id="u6E05_u9664_u4E0D_u5FC5_u8981_u7684_u670D_u52A1"><a href="#u6E05_u9664_u4E0D_u5FC5_u8981_u7684_u670D_u52A1" class="headerlink" title="清除不必要的服务"></a>清除不必要的服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">launchctl list 查看服务列表</span><br><span class="line">launchctl remove xxxx 删除xxxxx服务的自启动</span><br></pre></td></tr></table></figure>
<h3 id="u5173_u95ED_Rootless"><a href="#u5173_u95ED_Rootless" class="headerlink" title="关闭 Rootless"></a>关闭 Rootless</h3><p>Rootless 是 OSX 10.11 中为了增强安全性而增加的特性，不过对于开发者来说，不能访问根目录下的某些文件夹实在是很恼人的事情。下面是关闭的方法：</p>
<ul>
<li>开机按住 Command＋R，进入恢复模式，打开 terminal，键入：</li>
<li><code>csrutil disable</code></li>
<li>回车，重新启动即可。</li>
<li>要恢复 rootless ，只需将 disable 改为 enable</li>
</ul>
<h3 id="u91CD_u5EFA_Mail__u7D22_u5F15"><a href="#u91CD_u5EFA_Mail__u7D22_u5F15" class="headerlink" title="重建 Mail 索引"></a>重建 Mail 索引</h3><p>当邮箱出现问题时，您可能会看到提醒信息说“邮件”需要通过重新索引邮件来修复邮箱。在其他时候，您可能想要自己重新索引邮件，例如，使用“主题”、“收件人”或“发件人”搜索邮箱时未返回正确结果时。</p>
<ul>
<li>如果“邮件”已打开，请退出它。</li>
<li>在“User/资源库/Mail/V3/MailData”中，删除任何以“Envelope Index”开头的文件，如 Envelope Index 或 Envelope Index-shm。</li>
<li>默认情况下，您的“资源库”个人文件夹处于隐藏状态。若要显示它，请选取 Finder &gt;“前往文件夹”，然后输入“~/资源库”。</li>
<li>打开“邮件”。</li>
<li>“邮件”将创建新 Envelope Index 文件。此过程可能需要几分钟，取决于“邮件”要重新索引的邮件数量。</li>
</ul>
<h3 id="u6E05_u9664_PRAM"><a href="#u6E05_u9664_PRAM" class="headerlink" title="清除 PRAM"></a>清除 PRAM</h3><p>(只适用于英特尔的苹果电脑)</p>
<p>这个方法不是根本的解决方法，但是可以除去一些不必要的开机设置。因而也节省了时间。方法是：重启你的电脑，同时按下 command + option + p + r 直到听到 3 到 4 声启动铃响之后松手。</p>
<h3 id="u6E05_u9664PMU"><a href="#u6E05_u9664PMU" class="headerlink" title="清除PMU"></a>清除PMU</h3><p>(iMac不适用)</p>
<p>对于Macbook, Macbook Pro用户，方法是：</p>
<ol>
<li>确保Macbook关闭.</li>
<li>去掉电源适配器和电池.</li>
<li>按下电源开关并保持5 秒钟，放开.</li>
<li>接上电源适配器和电池.</li>
<li>打开电源开关.</li>
</ol>
<h3 id="u663E_u793A/_u9690_u85CF__u9690_u85CF_u6587_u4EF6"><a href="#u663E_u793A/_u9690_u85CF__u9690_u85CF_u6587_u4EF6" class="headerlink" title="显示/隐藏 隐藏文件"></a>显示/隐藏 隐藏文件</h3><p>使用下面的命令即可分别测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool <span class="literal">true</span></span><br><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="u8FD8_u539F_F1-F12"><a href="#u8FD8_u539F_F1-F12" class="headerlink" title="还原 F1-F12"></a>还原 F1-F12</h3><p>默认情况下，F1-F12 都是特殊功能，比如调节屏幕亮度。而当你需要键入 F1-F12 时（比如在使用 IntelliJ IDEA 的快捷键时），需要同时按住 Fn。这对于开发人员来说是非常不方便的。</p>
<p>把 F1-F12 改成标准功能键：选择 <code>System Preferences</code> &gt; <code>Keyboard</code>，在<code>Keyboard</code>标签页中选中<code>Use all F1, F2, etc. keys as standard function keys</code>。</p>
<h3 id="u5229_u7528_u8BED_u97F3_u529F_u80FD"><a href="#u5229_u7528_u8BED_u97F3_u529F_u80FD" class="headerlink" title="利用语音功能"></a>利用语音功能</h3><p>OS X 自带了语音功能，可以用<code>say</code>命令让 Mac 开口说话：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">say hello</span><br></pre></td></tr></table></figure>
<p>可以和<code>&amp;&amp;</code>或者<code>;</code>配合使用来提示你某任务已经完成：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew update &amp;&amp; brew upgrade &amp;&amp; brew cleanup ; say mission complete</span><br></pre></td></tr></table></figure>
<p>通过命令行来听取发音还是有点麻烦。其实我们几乎可以在任何地方选中单词，然后使用快捷键 <code>⌥+ESC</code> 发音。仅仅需要这样设置一下：选择 <code>System Preferences</code> &gt; <code>Dictation &amp; Speech</code>，在<code>Text to Speech</code>标签页中选中<code>Speak selected text when the key is pressed</code>。</p>
<h3 id="u5728_Finder__u7A97_u53E3_u663E_u793A_u66F4_u591A_u4FE1_u606F"><a href="#u5728_Finder__u7A97_u53E3_u663E_u793A_u66F4_u591A_u4FE1_u606F" class="headerlink" title="在 Finder 窗口显示更多信息"></a>在 Finder 窗口显示更多信息</h3><p>打开任意 Finder 窗口。前往并打开「显示」－「显示路径栏」、「显示」－「显示状态栏」和「显示」－「显示预览」三项。</p>
<p>路径栏通常是从磁盘分区开始的，没改过名字的就叫做「Macintosh HD」，接下来是「用户」，可是路径信息的这两个项目几乎没什么作用，我们需要看的一般都是从个人账户开始后面的路径。下面我们就来尝试删除这两个路径选项：</p>
<p>打开终端，输入以下命令：</p>
<pre><code>defaults write com.apple.finder PathBarRootAtHome -bool TRUE;killall Finder
</code></pre><p>回车后 Finder 会重启一下，改变即可见。</p>
<p>恢复默认：打开终端，输入如下代码并回车就可以恢复原样：</p>
<pre><code>defaults delete com.apple.finder PathBarRootAtHome;killall Finder
</code></pre><h3 id="u8BA9_u6587_u4EF6_u6269_u5C55_u540D_u59CB_u7EC8_u663E_u793A"><a href="#u8BA9_u6587_u4EF6_u6269_u5C55_u540D_u59CB_u7EC8_u663E_u793A" class="headerlink" title="让文件扩展名始终显示"></a>让文件扩展名始终显示</h3><p>当你看到一个文件但是不知道它的格式的时候，会不会困惑？每次都要去简介页面查看文件是 .jpg 还是 .png 是不是很繁琐？哦，还有 CMD－i 快捷键？但是这些都比默认就显示来得慢。</p>
<p>打开 Finder 偏好设置，选中「高级」标签，然后在「始终显示文件扩展名」前面打勾即可。</p>
<h3 id="u4F7F_Finder__u9ED8_u8BA4_u663E_u793A_u81EA_u5B9A_u4E49_u76EE_u5F55"><a href="#u4F7F_Finder__u9ED8_u8BA4_u663E_u793A_u81EA_u5B9A_u4E49_u76EE_u5F55" class="headerlink" title="使 Finder 默认显示自定义目录"></a>使 Finder 默认显示自定义目录</h3><p>「我的所有文件」是一个非常实用的功能。但是这对于那些需要按照目录来显示文件的用户来说，每次都需要进行一次额外的操作才能打开用户目录或者其他文件夹。让我们取消默认显示「我的所有文件」功能：</p>
<p>打开 Finder 偏好设置，选中「通用」标签，然后在「开启新 Finder 窗口时打开」项下选择你喜欢的目录即可。</p>
<h3 id="u5728_u4FA7_u8FB9_u680F_u663E_u793A_u7528_u6237_u76EE_u5F55"><a href="#u5728_u4FA7_u8FB9_u680F_u663E_u793A_u7528_u6237_u76EE_u5F55" class="headerlink" title="在侧边栏显示用户目录"></a>在侧边栏显示用户目录</h3><p>在 Mac 系统中，绝大多数用户文件，例如音乐、照片等都存储在用户目录下，所以在 Finder 侧边栏一直显示用户目录的内容是一个好主意。设置起来同样很简单：</p>
<p>打开 Finder 偏好设置，选中「边栏」标签，然后记得勾选你的用户名。</p>
<h3 id="u5728_Finder__u6807_u9898_u680F_u663E_u793A_u5B8C_u6574_u8DEF_u5F84"><a href="#u5728_Finder__u6807_u9898_u680F_u663E_u793A_u5B8C_u6574_u8DEF_u5F84" class="headerlink" title="在 Finder 标题栏显示完整路径"></a>在 Finder 标题栏显示完整路径</h3><p>众所周知 Finder 是不显示路径的，你进入某个文件夹只会显示当前文件夹的名字而已。虽然你可以通过上文中的方法将路径栏调出来，但是这样也增加了 Finder 窗口的高度，对小屏幕机器尤为不利。那么，让我们更进一步，将 Finder 的完整路径显示在标题栏如何？</p>
<p>打开终端，输入以下命令并回车：</p>
<pre><code>defaults write com.apple.finder _FXShowPosixPathInTitle -bool YES
</code></pre><p>然后把 Finder 窗口关了再打开，你会发现路径栏变样子了：</p>
<p>其实呢，对着路径最左边的小图标点右键，就能快速访问路径中的任意一层：</p>
<p>恢复</p>
<pre><code>defaults write com.apple.finder _FXShowPosixPathInTitle -bool NO
</code></pre><h3 id="u59CB_u7EC8_u663E_u793A_u7528_u6237_u300C_u8D44_u6599_u5E93_u300D"><a href="#u59CB_u7EC8_u663E_u793A_u7528_u6237_u300C_u8D44_u6599_u5E93_u300D" class="headerlink" title="始终显示用户「资料库」"></a>始终显示用户「资料库」</h3><p>用户资料库是用来储存配置文件、缓存和用户数据的目录（路径：~/Library/），由于 OS X 设置了系统文件保护，资料库在 Finder 中被设置为默认不显示。然而，通过终端执行一个简单的命令，就可以让它始终显示了。</p>
<p>打开终端，运行以下命令：</p>
<pre><code>chflags nohidden ~/Library/
</code></pre><p>回车即可。</p>
<h3 id="u663E_u793A_u6587_u4EF6_uFF08_u5939_uFF09_u7684_u4FE1_u606F"><a href="#u663E_u793A_u6587_u4EF6_uFF08_u5939_uFF09_u7684_u4FE1_u606F" class="headerlink" title="显示文件（夹）的信息"></a>显示文件（夹）的信息</h3><p>Finder 可以告诉你一些关于文件和文件夹的非常实用的信息，比如选中的文件夹内有多少个文件、照片的分辨率（这个笔者最喜欢）等等。对于笔者这种重度截图党来说，这几乎是一个「必选」的设置。</p>
<p>在桌面点击鼠标右键，选择「查看显示选项」，选中「显示项目简介」项，现在看看，你的文件、文件夹有什么变化？</p>
<h2 id="u5E94_u7528_u8F6F_u4EF6"><a href="#u5E94_u7528_u8F6F_u4EF6" class="headerlink" title="应用软件"></a>应用软件</h2><p>付费软件：</p>
<ul>
<li>1Password：密码管理；</li>
<li>BetterZip2：解压缩；</li>
<li>Parallels Desktop：虚拟机</li>
<li>CleanMyMac 3：垃圾清理</li>
</ul>
<p>免费软件：</p>
<ul>
<li>Alferd：提高效率的神器</li>
<li>MPlayerX：视频播放器，播放各种格式视频</li>
<li>iTerm2：命令行终端</li>
<li>SiteSucker：网站备份工具</li>
<li>LICEcap：截取GIF动态图</li>
<li>ImageAlpha(Pngyu)：png图片压缩</li>
</ul>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>现在 OS X 都不会自带 JDK 了，所以进行 Java 开发的话，需要下载 JDK。在 brew-cask 之前，我们需要从 <a href="https://developer.apple.com/downloads/" target="_blank" rel="external">https://developer.apple.com/downloads/</a> 或者 Oracle 网站上下载。还有更麻烦的－－卸载 JDK 和升级 JDK。</p>
<p>JDK 安装文件是 pkg 格式，卸载和<code>.app</code>不一样，且没有自动卸载方式。</p>
<p>而 brew-cask 提供了自动安装和卸载功能，能够自动从官网上下载并安装 JDK 8。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install java</span><br></pre></td></tr></table></figure>
<p>如果你需要安装 JDK 7 或者 JDK 6，可以使用<code>homebrew-cask-versions</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap caskroom/versions</span><br><span class="line">brew cask install java6</span><br></pre></td></tr></table></figure>
<p>在 OS X 上，你可以同时安装多个版本的 JDK。你可以通过命令<code>/usr/libexec/java_home -V</code>来查看安装了哪几个 JDK。</p>
<p>那问题来了，当你运行<code>java</code>或者 Java 程序时使用的是哪个 JDK 呢？在 OS X 下，<code>java</code>也就是<code>/usr/bin/java</code>在默认情况下指向的是已经安装的最新版本。但是你可以设置环境变量<code>JAVA_HOME</code>来更改其指向：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version <span class="string">"1.8.0_60"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build <span class="number">1.8</span>.<span class="number">0</span>_60-b27)</span><br><span class="line">Java HotSpot(TM) <span class="number">64</span>-Bit Server VM (build <span class="number">25.60</span>-b23, mixed mode)</span><br><span class="line">$ JAVA_HOME=/Library/Java/JavaVirtualMachines/<span class="number">1.6</span>.<span class="number">0</span>.jdk/Contents/Home java -version</span><br><span class="line">java version <span class="string">"1.6.0_65"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build <span class="number">1.6</span>.<span class="number">0</span>_65-b14-<span class="number">466.1</span>-<span class="number">11</span>M4716)</span><br><span class="line">Java HotSpot(TM) <span class="number">64</span>-Bit Server VM (build <span class="number">20.65</span>-b04-<span class="number">466.1</span>, mixed mode)</span><br></pre></td></tr></table></figure>
<p>其中<code>JAVA_HOME=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home</code>可以用<code>JAVA_HOME=`/usr/libexec/java_home -v 1.6` </code>这种更加通用的方式代替。</p>
<h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h3><p>Mac OS X是基于Unix的操作系统，可以安装大部分为Unix/Linux开发的软件。然而，如果只是以使用为目的，对每个软件都进行手工编译不是很方便，也不利于管理已安装的软件，于是出现了类似于Linux中APT、Yum等类似的软件包管理系统，其中最著名的有MacPorts、Fink、Homebrew等。</p>
<p>Homebrew 尽可能地利用系统自带的各种库，使得软件包的编译时间大为缩短；同时由于几乎不会造成冗余，软件包的管理也清晰、灵活了许多。Homebrew的另一个特点是使用Ruby定义软件包安装配置（叫做formula），定制非常简单。</p>
<p>Homebrew的安装非常简单，在终端程序中输入以下命令即可。</p>
<pre><code>ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&quot;
</code></pre><p>由于Homebrew的安装地址可能变化，请到官方网站查看最新的安装方法。</p>
<p>Homebrew的可执行命令是brew，其基本使用方法如下（以wget为例）。</p>
<ul>
<li>查找软件包 <code>brew search wget</code></li>
<li>安装软件包 <code>brew install wget</code></li>
<li>列出已安装的软件包 <code>brew list</code></li>
<li>删除软件包 <code>brew remove wget</code></li>
<li>查看软件包信息 <code>brew info wget</code></li>
<li>列出软件包的依赖关系 <code>brew deps wget</code></li>
<li>更新 <code>brew update</code></li>
<li>列出过时的软件包（已安装但不是最新版本）<code>brew outdated</code></li>
<li>更新过时的软件包（全部或指定）<code>brew upgrade</code> 或 <code>brew upgrade wget</code></li>
</ul>
<h3 id="Homebrew_Cask"><a href="#Homebrew_Cask" class="headerlink" title="Homebrew Cask"></a><a href="http://caskroom.io" target="_blank" rel="external">Homebrew Cask</a></h3><p>brew-cask 允许你使用命令行安装 OS X 应用。比如你可以这样安装 Chrome：<code>brew cask install google-chrome</code>。还有 Evernote、Skype、Sublime Text、VirtualBox 等都可以用 brew-cask 安装。</p>
<p>brew-cask 是社区驱动的，如果你发现 brew-cask 上的应用不是最新版本，或者缺少你某个应用，你可以自己提交 pull request。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install caskroom/cask/brew-cask</span><br></pre></td></tr></table></figure>
<p>应用也可以通过 App Store 安装，而且有些应用只能通过 App Store 安装，比如 Xcode 等一些 Apple 的应用。App Store 没有对应的命令行工具，还需要 Apple ID。倒是更新起来很方便。</p>
<p>几乎所有常用的应用都可以通过 brew-cask 安装，所以你要安装新的应用时，建议用 brew-cask 安装。如果你不知道应用在 brew-cask 中的 ID，可以先用<code>brew cask search</code>命令搜索。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/macdao/ocds-guide-to-setting-up-mac" target="_blank" rel="external">如何配置一个高效的 Mac 工作环境</a></li>
<li><a href="http://lapwinglabs.com/blog/hacker-guide-to-setting-up-your-mac" target="_blank" rel="external">Hacker’s Guide to Setting up Your Mac</a></li>
<li><a href="https://mattstauffer.co/blog/setting-up-a-new-os-x-development-machine-part-1-core-files-and-custom-shell" target="_blank" rel="external">Setting up a new (OS X) development machine</a></li>
<li><a href="http://www.xialeizhou.com/?p=71" target="_blank" rel="external">高效 MacBook 工作环境配置</a></li>
<li><a href="http://www.zhihu.com/question/20873070" target="_blank" rel="external">程序员如何优雅地使用 Mac？</a></li>
<li><a href="http://sspai.com/27403" target="_blank" rel="external">少数派1</a></li>
<li><a href="http://sspai.com/28385" target="_blank" rel="external">少数派2</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里主要整理一些一直以来使用 Mac 的技巧以及构建高效开发学习环境的指南。主要是按照个人的使用习惯，所以所用的工具和软件都比较偏写代码一些。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://wdxtub.com/tags/Mac/"/>
    
      <category term="技巧" scheme="http://wdxtub.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="疑难杂症" scheme="http://wdxtub.com/tags/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
      <category term="高效" scheme="http://wdxtub.com/tags/%E9%AB%98%E6%95%88/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[zsh 全程指南]]></title>
    <link href="http://wdxtub.com/2016/02/18/oh-my-zsh/"/>
    <id>http://wdxtub.com/2016/02/18/oh-my-zsh/</id>
    <published>2016-02-18T22:09:15.000Z</published>
    <updated>2016-02-19T13:43:58.000Z</updated>
    <content type="html"><![CDATA[<p>新年新气象，打算从 bash 迁移到 zsh 上来。网上教程很多，但是大多比较零散也不够让人知其所以然，而且很多配置也不符合我个人的习惯，于是打算『贪天之功』，写这么一个『全程指南』，希望能给大家带来些帮助。</p>
<a id="more"></a>
<hr>
<p>工欲善其事，必先利其器。工欲利其器，必先思其行。凡事谋定而后动，得有个基本的目标，才好一步一步细化并实施。实话说，zsh 真的比 bash 好很多吗？从小处着眼，是的，无论是历史记录还是搜索还是自定义插件，zsh 都比 bash 强，但是看看隔壁的 powershell(windows)，才算得上真正现代化面向对象的命令行工具。而且很多时候我们都是连接到远程的机器上进行编程和配置，在那里 bash 可是一统天下的（当然每次都愿意配置折腾一次，zsh 也不是不行）。那么问题就来了，为什么还要折腾呢？</p>
<p>答案很简单，充分利用高级功能，来提高自己的效率。当然，如果顺带能让界面更漂亮一点的话，何乐不为呢？不过有一点需要注意，如果要用 shell 脚本进行编程的话，最好还是按照 bash 的语法来做，不然把自己绑定到『非标准』的语法上，换个环境就可能导致巨大的问题。</p>
<p>如果只是想要换个主题弄得花里胡哨的话，那么还不如节省点时间去做有意义的事情，虽然网上都说 zsh 是『终结 shell』，但是其实哪有所谓的『终极』？只有自己成为了大师，才能『飞花落叶皆可伤人』。</p>
<p>不过既然说是『全程指南』，还是会尽量事无巨细介绍清楚，总体来说选择标准取决于我个人的审美和习惯，这点需要注意。</p>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>安装 <a href="http://www.iterm2.com/" target="_blank" rel="external">iTerm2</a>（最近要出新版了，很多新特性还是值得期待的）</li>
<li>安装完成后可以在 iTerm2 中输入命令安装 <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">oh-my-zsh</a><ul>
<li><code>curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh</code> </li>
<li>因为 zsh 配置比较繁琐，所以这里可以直接用配置好的配置文件的基础上进行使用</li>
</ul>
</li>
<li>安装 <a href="http://powerline.readthedocs.org/en/latest/installation.html" target="_blank" rel="external">Powerline</a> （一个 vim 的插件，随后有用）<ul>
<li><code>pip install powerline-status</code></li>
<li>如果没有 <code>pip</code> 命令的话，先把 <code>pip</code> 装上：<code>sudo easy_install pip</code></li>
</ul>
</li>
<li>有些 zsh 中的主题需要使用额外的字体，我们也一并装好，<a href="https://github.com/powerline/fonts" target="_blank" rel="external">下载地址</a>。把所有东西下载下来，然后用命令行进入到 <code>install.sh</code> 所在文件夹，执行 <code>./install.sh</code> 进行安装</li>
</ol>
<h2 id="u73AF_u5883_u914D_u7F6E"><a href="#u73AF_u5883_u914D_u7F6E" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="u5B57_u4F53"><a href="#u5B57_u4F53" class="headerlink" title="字体"></a>字体</h3><p>前面我们安装了额外的字体，但是还是需要在 iTerm2 中配置一下，具体的字体选择有很多，只要是后面带有 Powerline 字样的就可以，注意 Regular Font 和 Non-ASCII Font 都需要进行修改</p>
<p><img src="/images/14558361988595.jpg" alt="Preference -&gt; Profiles -&gt; Text"></p>
<p>我觉得比较不错的字体有：</p>
<ul>
<li>Incosolata-dz for Powerline</li>
<li>Roboto Mono Light for Powerline</li>
<li>Ubuntu Mono derivative Powerline</li>
</ul>
<p>我自己在用的是</p>
<ul>
<li>Regular Font: 18pt Ubuntu Mono derivative Powerline</li>
<li>Non-ASCII Font: 14pt Roboto Mono for Powerline</li>
</ul>
<p><img src="/images/14558366464605.jpg" alt="效果图"></p>
<h3 id="u914D_u8272"><a href="#u914D_u8272" class="headerlink" title="配色"></a>配色</h3><p>这里就不推荐烂大街的 Solarized 配色了，而是直接给成吨选择，在<a href="http://iterm2colorschemes.com" target="_blank" rel="external">配色页面</a>中下载，然后根据截图自己选择，选择好之后在 Preference -&gt; Profiles -&gt; Colors 里面的 Load Presets 进行导入即可。我比较喜欢的是 Tomorrow Night 这个主题，并且稍微把颜色调亮了一点，显得比较活泼。像下面这样：</p>
<p><img src="/images/14558402138712.jpg" alt="Tomorrow Night"></p>
<p>其他我觉得比较不错的还有：</p>
<ul>
<li>Argonaut</li>
<li>Cobalt2</li>
<li>Molokai</li>
<li>Monokai Soda</li>
<li>PaulMillr</li>
<li>Solarized Dark Higher Contrast</li>
<li>SpaceGray Eighties</li>
<li>Thayer Bright</li>
<li>Tomorrow Night 全系列</li>
<li>Wez</li>
</ul>
<h3 id="u914D_u7F6E_u6587_u4EF6"><a href="#u914D_u7F6E_u6587_u4EF6" class="headerlink" title="配置文件"></a>配置文件</h3><p>大部分配置都可以在配置文件中进行设置，这里我大概翻译一下，以及给出自己的一些使用偏好。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ZSH的环境变量</span></span><br><span class="line"><span class="built_in">export</span> ZSH=/Users/dawang/.oh-my-zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主题设置</span></span><br><span class="line"><span class="comment"># 主题列表在 ~/.oh-my-zsh/themes/</span></span><br><span class="line"><span class="comment"># 如果设置为 "random", 每次开启都会是不同的主题</span></span><br><span class="line">ZSH_THEME=<span class="string">"agnoster"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想要大小写敏感，可以取消注释下面的一行</span></span><br><span class="line"><span class="comment"># CASE_SENSITIVE="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想要连接符不敏感，可以取消注释下面的一行。_ 和 - 将可以互换</span></span><br><span class="line"><span class="comment"># HYPHEN_INSENSITIVE="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不想要自动更新，可以取消注释下面的一行</span></span><br><span class="line"><span class="comment"># DISABLE_AUTO_UPDATE="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动更新的时间间隔，单位是天，这里设置 30 天更新一次</span></span><br><span class="line"><span class="built_in">export</span> UPDATE_ZSH_DAYS=<span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不想要 ls 命令输出带颜色，可以取消注释下面的一行</span></span><br><span class="line"><span class="comment"># DISABLE_LS_COLORS="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否禁止更改终端标题,不要禁止,不然所有终端tab只显示zsh了,而不随着目录的改变而改变显示</span></span><br><span class="line"><span class="comment"># DISABLE_AUTO_TITLE="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动纠正命令,不启用,不怎么好用</span></span><br><span class="line"><span class="comment"># ENABLE_CORRECTION="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按tab键补全命令的时候,如果没什么可补全的就会出现三个红点,更人性化显示，这里我们启用</span></span><br><span class="line">COMPLETION_WAITING_DOTS=<span class="string">"true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line if you want to disable marking untracked files</span></span><br><span class="line"><span class="comment"># under VCS as dirty. This makes repository status check for large repositories</span></span><br><span class="line"><span class="comment"># much, much faster.</span></span><br><span class="line"><span class="comment"># 不要在意这些细节，不需要改动</span></span><br><span class="line"><span class="comment"># DISABLE_UNTRACKED_FILES_DIRTY="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 历史命令日期显示格式</span></span><br><span class="line"><span class="comment"># 有三种方式: "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"，我比较习惯最后那种</span></span><br><span class="line">HIST_STAMPS=<span class="string">"yyyy-mm-dd"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Would you like to use another custom folder than $ZSH/custom?</span></span><br><span class="line"><span class="comment"># ZSH_CUSTOM=/path/to/new-custom-folder</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)</span></span><br><span class="line"><span class="comment"># Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/</span></span><br><span class="line"><span class="comment"># Example format: plugins=(rails git textmate ruby lighthouse)</span></span><br><span class="line"><span class="comment"># 插件设置，如果添加太多启动速度会比较慢</span></span><br><span class="line">plugins=(git autojump)</span><br><span class="line"></span><br><span class="line">[[ <span class="operator">-s</span> ~/.autojump/etc/profile.d/autojump.zsh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 剩下部分比较不常改动 </span></span><br><span class="line"><span class="comment"># User configuration</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/Library/TeX/texbin"</span></span><br><span class="line"><span class="comment"># export MANPATH="/usr/local/man:$MANPATH"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># You may need to manually set your language environment</span></span><br><span class="line"><span class="comment"># export LANG=en_US.UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Preferred editor for local and remote sessions</span></span><br><span class="line"><span class="comment"># if [[ -n $SSH_CONNECTION ]]; then</span></span><br><span class="line"><span class="comment">#   export EDITOR='vim'</span></span><br><span class="line"><span class="comment"># else</span></span><br><span class="line"><span class="comment">#   export EDITOR='mvim'</span></span><br><span class="line"><span class="comment"># fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compilation flags</span></span><br><span class="line"><span class="comment"># export ARCHFLAGS="-arch x86_64"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ssh</span></span><br><span class="line"><span class="comment"># export SSH_KEY_PATH="~/.ssh/dsa_id"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set personal aliases, overriding those provided by oh-my-zsh libs,</span></span><br><span class="line"><span class="comment"># plugins, and themes. Aliases can be placed here, though oh-my-zsh</span></span><br><span class="line"><span class="comment"># users are encouraged to define aliases within the ZSH_CUSTOM folder.</span></span><br><span class="line"><span class="comment"># For a full list of active aliases, run `alias`.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example aliases</span></span><br><span class="line"><span class="comment"># alias zshconfig="mate ~/.zshrc"</span></span><br><span class="line"><span class="comment"># alias ohmyzsh="mate ~/.oh-my-zsh"</span></span><br></pre></td></tr></table></figure>
<h2 id="u9AD8_u7EA7_u529F_u80FD"><a href="#u9AD8_u7EA7_u529F_u80FD" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="u5E38_u7528_u5FEB_u6377_u952E"><a href="#u5E38_u7528_u5FEB_u6377_u952E" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><ul>
<li>命令历史记录<ul>
<li>一旦在 shell 敲入正确命令并能执行后，shell 就会存储你所敲入命令的历史记录（存放在<code>~/.zsh_history</code> 文件中），方便再次运行之前的命令。可以按方向键↑和↓来查看之前执行过的命令</li>
<li>可以用 <code>!!</code>来执行上一条命令</li>
<li>使用 <code>ctrl-r</code> 来搜索命令历史记录</li>
</ul>
</li>
<li>命令和文件补全(按tab键)</li>
<li>命令别名<ul>
<li>可以简化命令输入，在 <code>.zshrc</code> 中添加 <code>alias shortcut=&#39;this is the origin command&#39;</code> 一行就相当于添加了别名</li>
<li>在命令行中输入 <code>alias</code> 可以查看所有的命令别名</li>
</ul>
</li>
</ul>
<p>一些比较好用的设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> cls=<span class="string">'clear'</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">'ls -l'</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">'ls -a'</span></span><br><span class="line"><span class="built_in">alias</span> grep=<span class="string">"grep --color=auto"</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> html=<span class="string">'vim'</span>   <span class="comment"># 在命令行直接输入后缀为 html 的文件名，会在 Vim 中打开</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> rb=<span class="string">'vim'</span>     <span class="comment"># 在命令行直接输入 ruby 文件，会在 Vim 中打开</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> py=<span class="string">'vim'</span>      <span class="comment"># 在命令行直接输入 python 文件，会用 vim 中打开，以下类似</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> js=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> c=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> java=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> txt=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> gz=<span class="string">'tar -xzvf'</span> <span class="comment"># 在命令行直接输入后缀为 gz 的文件名，会自动解压打开</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> tgz=<span class="string">'tar -xzvf'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> zip=<span class="string">'unzip'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> bz2=<span class="string">'tar -xjvf'</span></span><br></pre></td></tr></table></figure>
<h3 id="u63D2_u4EF6"><a href="#u63D2_u4EF6" class="headerlink" title="插件"></a>插件</h3><p><strong>git</strong></p>
<p>在进入一个 git 文件夹后会切换显示的模式：</p>
<p><img src="/images/14558436247342.jpg" alt=""></p>
<p>自带大部分 git 命令的缩写，命令内容可以参考 <code>~/.oh-my-zsh/plugins/git/git.plugin.zsh</code></p>
<p>Oh My Zsh 提供了一套系统别名（alias），来达到相同的功能。比如<code>gst</code>作为<code>git status</code>的别名。而且 Git 插件是 Oh My Zsh 默认启用的，相当于你使用了 Oh My Zsh，你就拥有了一套高效率的别名，而且还是全球通用的。是不是棒棒哒？下面是一些我常用的别名：</p>
<table>
<thead>
<tr>
<th>Alias</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>gapa</td>
<td><code>git add --patch</code></td>
</tr>
<tr>
<td>gc!</td>
<td><code>git commit -v --amend</code></td>
</tr>
<tr>
<td>gcl</td>
<td><code>git clone --recursive</code></td>
</tr>
<tr>
<td>gclean</td>
<td><code>git reset --hard &amp;&amp; git clean -dfx</code></td>
</tr>
<tr>
<td>gcm</td>
<td><code>git checkout master</code></td>
</tr>
<tr>
<td>gcmsg</td>
<td><code>git commit -m</code></td>
</tr>
<tr>
<td>gco</td>
<td><code>git checkout</code></td>
</tr>
<tr>
<td>gd</td>
<td><code>git diff</code></td>
</tr>
<tr>
<td>gdca</td>
<td><code>git diff --cached</code></td>
</tr>
<tr>
<td>gp</td>
<td><code>git push</code></td>
</tr>
<tr>
<td>grbc</td>
<td><code>git rebase --continue</code></td>
</tr>
<tr>
<td>gst</td>
<td><code>git status</code></td>
</tr>
<tr>
<td>gup</td>
<td><code>git pull --rebase</code></td>
</tr>
</tbody>
</table>
<p>完整列表请参考：<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git" target="_blank" rel="external">https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git</a></p>
<p><strong>osx</strong></p>
<ul>
<li>tab - 在一个新标签打开当前目录</li>
<li>cdf - cd到当前Finder目录</li>
<li>quick-look - 快速浏览特殊的文件</li>
<li>man-preview - 在Preview应用打开特定的man page</li>
<li>trash - 将特定的文件移到垃圾桶</li>
</ul>
<p><strong>autojump</strong></p>
<p>这个插件会记录进入过的文件夹，下次再进入只要输入很少的内容即可，如下图所示：</p>
<p><img src="/images/14558437933171.jpg" alt=""></p>
<p><strong>zsh-syntax-highlighting</strong></p>
<p>这是一个类似 fish 的命令高亮插件，安装也很简单 <code>brew install zsh-syntax-highlighting</code>，需要把 <code>source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</code> 添加到 <code>.zshrc</code> 的最后面。</p>
<p>其他的<a href="https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md" target="_blank" rel="external">安装方法</a></p>
<h3 id="u4F7F_u7528_u6280_u5DE7"><a href="#u4F7F_u7528_u6280_u5DE7" class="headerlink" title="使用技巧"></a>使用技巧</h3><ol>
<li>连按两次Tab会列出所有的补全列表并直接开始选择，补全项可以使用 ctrl+n/p/f/b上下左右切换</li>
<li>命令选项补全。在zsh中只需要键入 <code>tar -&lt;tab&gt;</code> 就会列出所有的选项和帮助说明</li>
<li>命令参数补全。键入 <code>kill &lt;tab&gt;</code> 就会列出所有的进程名和对应的进程号</li>
<li>更智能的历史命令。在用<ctrl-p>或者方向上键查找历史命令时，zsh支持限制查找。比如，输入<code>ls</code>,然后再按方向上键，则只会查找用过的ls命令。而此时使用<ctrl-p>则会仍然按之前的方式查找，忽略 <code>ls</code></ctrl-p></ctrl-p></li>
<li>多个终端会话共享历史记录</li>
<li>智能跳转，安装了 autojump 之后，zsh 会自动记录你访问过的目录，通过 <code>j 目录名</code> 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过 hadoop-1.0.0 目录，输入<code>j hado</code> 即可正确跳转。<code>j --stat</code> 可以看你的历史路径库。</li>
<li>目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。</li>
<li>在当前目录下输入 <code>..</code> 或 <code>...</code> ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。在你知道路径的情况下，比如 <code>/usr/local/bin</code> 你可以输入 <code>cd /u/l/b</code> 然后按<tab>进行补全快速输入</tab></li>
<li>通配符搜索：<code>ls -l **/*.sh</code>，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find。使用 <code>**/</code> 来递归搜索</li>
<li>扩展环境变量，输入环境变量然后按 <tab> 就可以转换成表达的值</tab></li>
<li>在 <code>.zshrc</code> 中添加 <code>setopt HIST_IGNORE_DUPS</code> 可以消除重复记录，也可以利用 <code>sort -t &quot;;&quot; -k 2 -u ~/.zsh_history | sort -o ~/.zsh_history</code> 手动清除</li>
</ol>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://macshuo.com/?p=676" target="_blank" rel="external">终极 Shell</a></li>
<li><a href="http://hackerxu.com/2014/11/19/ZSH.html" target="_blank" rel="external">Zsh使用指南(译)</a></li>
<li><a href="http://www.jianshu.com/p/dc4ee939a08d" target="_blank" rel="external">zsh调研(2)配置和使用</a></li>
<li><a href="http://blog.csdn.net/yangcs2009/article/details/45720193" target="_blank" rel="external">Shell（一）：功能、配置和插件（附iTerm 2(for mac) &amp;&amp; Oh My Zsh教程）</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Zsh_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">Zsh (简体中文)</a>)</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>新年新气象，打算从 bash 迁移到 zsh 上来。网上教程很多，但是大多比较零散也不够让人知其所以然，而且很多配置也不符合我个人的习惯，于是打算『贪天之功』，写这么一个『全程指南』，希望能给大家带来些帮助。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://wdxtub.com/tags/Mac/"/>
    
      <category term="bash" scheme="http://wdxtub.com/tags/bash/"/>
    
      <category term="zsh" scheme="http://wdxtub.com/tags/zsh/"/>
    
      <category term="命令行" scheme="http://wdxtub.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 14 课 Architecture Tradeoff Analysis Method]]></title>
    <link href="http://wdxtub.com/2016/02/18/sad-14/"/>
    <id>http://wdxtub.com/2016/02/18/sad-14/</id>
    <published>2016-02-18T16:03:29.000Z</published>
    <updated>2016-02-18T20:52:54.000Z</updated>
    <content type="html"><![CDATA[<p>这节课具体会介绍进行架构分析时候的一些权衡考量的方法，还是非常有用的（至少比前面两课那么『虚』的要好很多）。这里也会综合老师给出的阅读材料，争取给大家一个完整的概念。</p>
<a id="more"></a>
<hr>
<h2 id="u9636_u6BB5_u4E00_Evaluator__26amp_3B_Decision_Maker"><a href="#u9636_u6BB5_u4E00_Evaluator__26amp_3B_Decision_Maker" class="headerlink" title="阶段一 Evaluator &amp; Decision Maker"></a>阶段一 Evaluator &amp; Decision Maker</h2><h3 id="u7B2C_u4E00_u6B65_Present_ATAM"><a href="#u7B2C_u4E00_u6B65_Present_ATAM" class="headerlink" title="第一步 Present ATAM"></a>第一步 Present ATAM</h3><p>使用的技术有：</p>
<ul>
<li>Utility tree genration</li>
<li>Architecture elicitation and analysis</li>
<li>Scenario brainstorming / mapping</li>
</ul>
<p>这个阶段的产出有</p>
<ul>
<li>Architectural approaches</li>
<li>Utility tree</li>
<li>Scenarios</li>
<li>Risks and “non-risks”</li>
<li>sensitivity points and tradeoffs</li>
</ul>
<p><img src="/images/14558185071430.jpg" alt="ATAM 过程"></p>
<h3 id="u7B2C_u4E8C_u6B65_Present_Business_Drivers"><a href="#u7B2C_u4E8C_u6B65_Present_Business_Drivers" class="headerlink" title="第二步 Present Business Drivers"></a>第二步 Present Business Drivers</h3><p>顾客代表会描述：</p>
<ul>
<li>系统的商业 context</li>
<li>高层级的功能需求</li>
<li>高层级的质量需求</li>
</ul>
<blockquote>
<p>Architectural drivers: quality attributes that “shape” the architecture</p>
<p>Critical reirements: quality attributes most central to the system’s success</p>
</blockquote>
<p>具体来说包括：</p>
<ul>
<li>系统的关键功能</li>
<li>任何技术、管理、经济或政策的限制</li>
<li>商业目标和背景</li>
<li>主要的权益关系着</li>
<li>主要的质量目标(principla quality attribute, NFP)</li>
</ul>
<h3 id="u7B2C_u4E09_u6B65_Present_the_Architecture"><a href="#u7B2C_u4E09_u6B65_Present_the_Architecture" class="headerlink" title="第三步 Present the Architecture"></a>第三步 Present the Architecture</h3><p>展示系统的整体架构，可能包括：</p>
<ul>
<li>技术限制：操作系统、硬件、中间件</li>
<li>其他需要与之交互的系统</li>
<li>如何选择架构风格来达到质量要求</li>
</ul>
<p>这个阶段评估小组开始寻找可能的风险</p>
<h3 id="u7B2C_u56DB_u6B65_Identify_Architectural_Approaches"><a href="#u7B2C_u56DB_u6B65_Identify_Architectural_Approaches" class="headerlink" title="第四步 Identify Architectural Approaches"></a>第四步 Identify Architectural Approaches</h3><p>开始寻找那些在架构中堆达到质量目标举足轻重的关键点，了解比较常用的架构模型：</p>
<ul>
<li>Client-Server</li>
<li>3-tier</li>
<li>Proxy</li>
<li>Publish-Subscribe</li>
<li>Redundant hardware</li>
</ul>
<h3 id="u7B2C_u4E94_u6B65_Generate_Utility_Tree"><a href="#u7B2C_u4E94_u6B65_Generate_Utility_Tree" class="headerlink" title="第五步 Generate Utility Tree"></a>第五步 Generate Utility Tree</h3><p>通过构造 utility tree 来进一步优化改进重要的质量目标</p>
<ul>
<li>Utility tree 是一个自顶向下的方法，来驱动属性相关的需求</li>
<li>高层级节点应当是最重要的质量目标（如 performance, modifiability, security 和 availability）</li>
<li>场景是 utility tree 的叶子</li>
</ul>
<p><img src="/images/14558198859387.jpg" alt="一个 utility tree 的例子"></p>
<p><strong>Scenarios</strong></p>
<p>用来展示利益相关者的兴趣所在，便于理解质量需求，应当包括</p>
<ul>
<li>Anticipated uses of (use case scenarios)</li>
<li>Anticipated changes to (growth scenarios)</li>
<li>Unanticipated stresses (exploratory scenarios)</li>
</ul>
<p><img src="/images/14558199929846.jpg" alt="ATAM Scenarios"></p>
<p><img src="/images/14558200171596.jpg" alt="Scenario 的例子"></p>
<h3 id="u7B2C_u516D_u6B65_Analyze_Architectural_Approaches"><a href="#u7B2C_u516D_u6B65_Analyze_Architectural_Approaches" class="headerlink" title="第六步 Analyze Architectural Approaches"></a>第六步 Analyze Architectural Approaches</h3><p>评估小组从特定的质量目标的角度入手，了解架构及识别可能的风险：</p>
<ul>
<li>找到那些保证质量需求的方法</li>
<li>提出相关问题</li>
<li>识别出 risks, non-risks, sensitivity points 和 tradeoffs</li>
</ul>
<p>下面是一些例子：</p>
<p><img src="/images/14558202021169.jpg" alt="可能的问题"></p>
<p><img src="/images/14558202227194.jpg" alt="Sensitivity &amp; Tradeoffs"></p>
<p><img src="/images/14558202695271.jpg" alt="Risk &amp; Non-Risks"></p>
<h3 id="u6700_u540E_u51E0_u6B65"><a href="#u6700_u540E_u51E0_u6B65" class="headerlink" title="最后几步"></a>最后几步</h3><ul>
<li>第七步 Brainstom &amp; Prioritize Scenarios<ul>
<li>利益相关者头脑风暴，相关过程</li>
</ul>
</li>
<li>第八步 Analyze Architectural Approaches<ul>
<li>重复第六步中的工作</li>
</ul>
</li>
<li>第九步 Present ATAM results<ul>
<li>完整的产出</li>
<li>Architectural appoaches</li>
<li>Utility tree</li>
<li>Scenarios</li>
<li>Risks and Non-risks</li>
<li>Sensitivity points and tradeoffs</li>
</ul>
</li>
</ul>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>架构分析既不简单也不便宜</li>
<li>从长远来看，利大于弊</li>
<li>关于系统核心特性的早期信息非常重要</li>
<li>应当使用多种分析技术</li>
<li>到底需要分析到什么程度？<ul>
<li>这是架构师最需要琢磨的地方</li>
<li>分析过多，则会无谓消耗有限的资源</li>
<li>分析过少，则会面临系统失败的风险</li>
<li>错误的分析既浪费资源，又可能导致系统失败</li>
</ul>
</li>
</ul>
<h2 id="u9605_u8BFB_u6750_u6599_u7B14_u8BB0"><a href="#u9605_u8BFB_u6750_u6599_u7B14_u8BB0" class="headerlink" title="阅读材料笔记"></a>阅读材料笔记</h2><ul>
<li>云计算部分非常简略，建议参考我的云计算课程笔记</li>
<li>使用 ATAM 来评估一个架构时，目标是理解不同的架构决定对系统质量可能带来的影响，所以可以看作是一个风险识别的方法</li>
<li>实际上是根据不同的属性和资源提出对应的问题，并找出相互的影响</li>
<li>三个场景：use case scenarios, growth scenarios, exploratory scenarios</li>
<li>不同的场景有不同的侧重点和要求，具体可以结合下图的实例来理解体会</li>
</ul>
<p><img src="/images/14558122473154.jpg" alt="Use Case Scenarios"></p>
<p><img src="/images/14558122635076.jpg" alt="Growth Scenarios"></p>
<p><img src="/images/14558122890374.jpg" alt="Exploratory Scenarios"></p>
<ul>
<li>Utility tree 和 Facilitated brainstorm 是两种常见的方式，各有不同的侧重</li>
</ul>
<p><img src="/images/14558123943034.jpg" alt="Utility Trees vs. Scenario Brainstorming"></p>
<p><img src="/images/14558124405619.jpg" alt="一个 Utility Tree 的例子"></p>
<ul>
<li>ATAM 过程结束后的产出有<ul>
<li>Risk and Non-Risks 文档，用来分析各个架构决定的风险性</li>
<li>Sensitivity and Tradeoff Points 文档，用来具体说明不同权衡的利弊（最重要的部分）</li>
<li>A Structure for Reasoning 文档，用来说明具体的架构选择及其原因</li>
</ul>
</li>
</ul>
<p><img src="/images/14558126249185.jpg" alt="Concept Interactions"></p>
<ul>
<li>评测中的重要属性<ul>
<li>Availability, Modifiability, Performance, Security, Usability</li>
<li>Deployment, Locating, Errors, Cost/Effort Estimation, Personalization, Safety</li>
</ul>
</li>
<li>可能的风险来源<ul>
<li>Risks Due to Unknowns</li>
<li>Risks Due to Side Effects of Architectural Decisions</li>
<li>Risks Due to Ignoring Architectural Solutions to Attribute Requirements</li>
<li>Risks Due to Interaaction with Other Organizations</li>
</ul>
</li>
<li>具体步骤<ul>
<li>Background</li>
<li>Business and Mission Drivers</li>
<li>Architectural Approaches</li>
<li>Utility Tree</li>
<li>Scenario Generation and Prioritization</li>
<li>Analysis Process</li>
<li>Post-ATAM Activities </li>
</ul>
</li>
</ul>
<p>感觉还是有点虚，估计作业就是模仿阅读材料完成一次具体的 ATAM 分析，但是老师给出的参考作业的内容又是关于 SOA 的，真的很令人费解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课具体会介绍进行架构分析时候的一些权衡考量的方法，还是非常有用的（至少比前面两课那么『虚』的要好很多）。这里也会综合老师给出的阅读材料，争取给大家一个完整的概念。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 习题课 4 Cachelab]]></title>
    <link href="http://wdxtub.com/2016/02/17/csapp-lab4/"/>
    <id>http://wdxtub.com/2016/02/17/csapp-lab4/</id>
    <published>2016-02-17T17:33:35.000Z</published>
    <updated>2016-02-18T04:27:28.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们来讲讲第四次作业，主要会尽可能利用缓存来加速计算，不过在开始作业之前会先复习一下 C 语言。</p>
<a id="more"></a>
<hr>
<h2 id="C__u8BED_u8A00_u590D_u4E60"><a href="#C__u8BED_u8A00_u590D_u4E60" class="headerlink" title="C 语言复习"></a>C 语言复习</h2><ul>
<li>注意代码风格，不要写糟糕的代码</li>
<li>小心隐式类型转换</li>
<li>小心未定义的行为</li>
<li>小心内存泄露</li>
<li>宏和指针计算很容易出错</li>
</ul>
<p><strong>例 1</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (u &gt; -<span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>u</code> 是无符号整型，所以在比较的时候 -1 也会按照无符号整型来处理，于是实际的比较相当于 <code>u &gt; int_max</code>，使得这个函数总是会返回 0。</p>
<p><strong>例 2</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* a = <span class="built_in">malloc</span>(<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        a[i] = i / a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>a</code> 中的值都没有进行初始化，所以 main 函数的行为是未定义的。</p>
<p><strong>例 3</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> w[strln(<span class="string">"C programming"</span>)];</span><br><span class="line">    <span class="built_in">strcpy</span>(w, <span class="string">"C programming"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, w);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>strlen</code> 返回的长度是不包括最后的 <code>\0</code> 的，写入的时候会越界。</p>
<p><strong>例 4</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ht_node &#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ht_node* node;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">makeNnode</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    node curr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">    curr-&gt;key = k;</span><br><span class="line">    curr-&gt;data = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里把 <code>node</code> 定义为一个指针，并不是指向一个结构体。</p>
<p><strong>例 5</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcdup</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> dup[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dup[i] = c;</span><br><span class="line">    dup[i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">char</span> *A = dup;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>strcdup</code> 函数返回了一个分配在栈中的指针，函数返回之后地址 <code>A</code> 可能会被抹掉。</p>
<p><strong>例 6</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_GREATER(a, b) a &gt; b</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">isGreater</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m1 = IS_GREATER(<span class="number">1</span>, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> m2 = isGreater(<span class="number">1</span>, <span class="number">0</span>) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><code>IS_GREATER</code> 是一个没有带括号的宏，所以 <code>m1</code> 的值相当于 <code>1 &gt; 0+1 = 0</code></p>
<p><strong>例 7</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NEXT_BYTE(a) ((char *)(a + <span class="number">1</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">54</span>; <span class="comment">// &amp;a1 = 0x100</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a2 = <span class="number">42</span>; <span class="comment">// &amp;a2 = 0x200</span></span><br><span class="line"><span class="keyword">void</span>* b1 = NEXT_BYTE(&amp;a1);</span><br><span class="line"><span class="keyword">void</span>* b2 = NEXT_BYTE(&amp;a2);</span><br></pre></td></tr></table></figure>
<ul>
<li>这里 <code>b1</code> 指向 <code>0x104</code></li>
<li>这里 <code>b2</code> 指向 <code>0x208</code></li>
</ul>
<p>会根据类型的不同，决定下一个 byte 的起始位置。</p>
<p>注意提交的代码列数不要超过 80，会人工检查的。</p>
<p><strong>GDB 命令</strong></p>
<ul>
<li><code>gdbtui &lt;binary&gt;</code></li>
<li><code>layout split</code></li>
</ul>
<p><img src="/images/14557338869148.jpg" alt=""></p>
<p><strong>valgrind</strong></p>
<p>可以用来查找</p>
<ul>
<li>内存泄露</li>
<li>其他内存错误</li>
<li>内存损害</li>
</ul>
<p>使用 <code>gcc -g</code> 可以列出内存泄露的具体行数</p>
<p>使用 <code>valgrind --leak-check=full</code> 可以查看全部详细信息</p>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>先下载好试验的压缩包，然后上传到学校的主机上：<code>scp cachelab-handout.tar dawang@shark.ics.cs.cmu.edu:~/513</code></li>
<li>接着 ssh 过去：<code>ssh -X dawang@shark.ics.cs.cmu.edu</code></li>
<li>解压：<code>tar -xvf cachelab-handout.tar</code></li>
</ul>
<p>然后就可以看到这次作业的内容了：</p>
<p><img src="/images/14557441434948.jpg" alt=""></p>
<p>我们需要修改的是 <code>csim.c</code>（需要自己创建） 和 <code>trans.c</code>。这里我会把这两个文件传回本地进行修改，完成后再传到服务器上进行测试：</p>
<ul>
<li>服务器至本地<ul>
<li><code>scp dawang@shark.ics.cs.cmu.edu:~/513/cachelab-handout/csim.c ./</code></li>
<li><code>scp dawang@shark.ics.cs.cmu.edu:~/513/cachelab-handout/trans.c ./</code></li>
</ul>
</li>
<li>本地至服务器<ul>
<li><code>scp csim.c dawang@shark.ics.cs.cmu.edu:~/513/cachelab-handout/</code></li>
<li><code>scp trans.c dawang@shark.ics.cs.cmu.edu:~/513/cachelab-handout/</code></li>
</ul>
</li>
</ul>
<p>编译的时候只需要简单 <code>make clean</code> 和 <code>make</code>，然后就可以进行测试了。</p>
<h2 id="u7B2C_u4E00_u90E8_u5206__u7F13_u5B58_u6A21_u62DF_u5668"><a href="#u7B2C_u4E00_u90E8_u5206__u7F13_u5B58_u6A21_u62DF_u5668" class="headerlink" title="第一部分 缓存模拟器"></a>第一部分 缓存模拟器</h2><p>这里需要注意的是，缓存模拟器并不是缓存！我们不需要存储具体的内存内容，也就是说，块偏移量不重要（也就是最后的 b bits 我们不需要在意），只需要计算 hit, miss 和 eviction 的次数即可。</p>
<p>这一部分内容具体理解请参阅 <a href="http://wdxtub.com/2016/02/15/csapp-12/">第 12 课 Cache Memories</a>，这里不再赘述，如果弄懂了这篇日志里的内容，应该就没有问题。</p>
<p>我们的缓存模拟器需要在不同的 s, b, E 设定下正常工作，使用的替换策略是 LRU(Least Recently Used)，这里可以考虑用队列或者时间戳的方式来记录。</p>
<h3 id="u4EFB_u52A1_u76EE_u6807"><a href="#u4EFB_u52A1_u76EE_u6807" class="headerlink" title="任务目标"></a>任务目标</h3><p>因为这次作业可能重复性比较高，所以这里就不贴代码了。主要讲一下每个步骤以及遇到问题时的解决思路。</p>
<p>先来了解一下这次用作输入数据的 trace 文件，可以使用 <code>valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l</code> 来体验一下，具体做的事情，就是把执行 <code>ls -l</code> 这个命令时访问内存的日志输出到终端中，大概是这样的：</p>
<p><img src="/images/14557449805626.jpg" alt=""></p>
<p>每一条对内存访问的记录格式是 <code>[空格]操作符 地址,大小</code>，以 <code>I</code> 开头的是载入指令的记录，不算在内存访问中。</p>
<ul>
<li>M 表示数据修改，需要一次载入 + 一次存储，也就是相当于两次访问</li>
<li>S 表示数据存储</li>
<li>L 表示数据载入</li>
<li>地址指的是一个 64 位的 16 进制内存地址</li>
<li>大小表示该操作内存访问的字节数</li>
</ul>
<p>我们要做的实际是读入 <code>valgrind</code> 生成的 trace 日志，并统计出 hit, miss 和 eviction 的次数。同时已经给出了一个参考程序 <code>csim-ref</code>，于是任务就变成山寨一个这样的程序，比如：</p>
<p><img src="/images/14557460323055.jpg" alt="注意两种不同的模式"></p>
<p>具体用法如下：</p>
<p><img src="/images/14557462175638.jpg" alt="注意各个参数的含义"></p>
<p>其他的就是概念的理解和实现了，这里给出几个关键问题，大家可以从这里找到思路：</p>
<ol>
<li>如何从命令中拿到所需的参数</li>
<li>如何从文件中读入内容</li>
<li>如何进行 cache 的存储</li>
<li>如何进行错误处理</li>
<li>如何保证两种模式输出</li>
</ol>
<p>因为已经给出了参考输出，所以对着一点一点做，应该没有太多问题。</p>
<h3 id="u4E00_u4E9B_u63D0_u793A"><a href="#u4E00_u4E9B_u63D0_u793A" class="headerlink" title="一些提示"></a>一些提示</h3><p>我们可以用一个 <code>cache_line</code> 的结构体来保存每个 cache line 的信息，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> valid;</span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    <span class="keyword">int</span> time_stamp;</span><br><span class="line">&#125; cache_line;</span><br></pre></td></tr></table></figure>
<p>而对应到我们的缓存模拟器，可以用一个二维数组来存储并模拟，如：<code>cache[S][E]</code>。这里 $S=2^s$，也就是 set 的个数，E 是一个 set 里有多少个 cache line。</p>
<p>因为这次测试的输入是如下所示的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./csim [-hv] <span class="operator">-s</span> &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;</span><br></pre></td></tr></table></figure>
<p>也就是说我们的程序需要能够读取命令行参数。这时候可以使用 <code>getopt()</code> 来完成，使用前注意包括 <code>#include &lt;unistd.h&gt;</code>，如果不在 CMU 的机器上运行，还需要加上 <code>#include &lt;getopt.h&gt;</code>。</p>
<p>具体的使用方法参见 <code>man 3 getopt</code> 或 <a href="http://www.gnu.org/software/libc/manual/html_node/Getopt.html" target="_blank" rel="external">这里</a>。当然，还需要考虑如何处理非法输入。一个简单的例子，对于命令 <code>./foo -x 1 -y 3</code>，可以这样解析：</p>
<p><img src="/images/14557375929445.jpg" alt=""></p>
<p>有了命令行参数，我们还需要对应读入 trace 文件的内容，可以使用 <code>fscanf</code> 来完成这个任务，具体的使用可以参考 <code>man fscanf</code> 或 <a href="http://crasseux.com/books/ctutorial/fscanf.html" target="_blank" rel="external">这里</a>，一个例子：</p>
<p><img src="/images/14557377045267.jpg" alt=""></p>
<p>因为我们需要根据传入的参数来创建 cache，所以需要动态分配空间，可以使用 <code>malloc</code> 在堆上完成这个任务。但是需要注意 <code>malloc</code> 的内容一定要 <code>free</code> 掉，不然就会造成内存泄露。另外，不是自己 <code>malloc</code> 的内存，也不要去 <code>free</code> 掉。一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some_pointer_you_malloced = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">Free(some_pointer_you_malloced);</span><br></pre></td></tr></table></figure>
<h2 id="u7B2C_u4E8C_u90E8_u5206__u4F18_u5316_u77E9_u9635_u8F6C_u5236"><a href="#u7B2C_u4E8C_u90E8_u5206__u4F18_u5316_u77E9_u9635_u8F6C_u5236" class="headerlink" title="第二部分 优化矩阵转制"></a>第二部分 优化矩阵转制</h2><h3 id="u4EFB_u52A1_u76EE_u6807-1"><a href="#u4EFB_u52A1_u76EE_u6807-1" class="headerlink" title="任务目标"></a>任务目标</h3><p>测试的矩阵尺寸为：</p>
<ul>
<li>32 x 32</li>
<li>64 x 64</li>
<li>61 x 67</li>
</ul>
<p>缓存的指标：</p>
<ul>
<li>有 1KB 大小的缓存</li>
<li>是 directly mapped，也就是 E=1</li>
<li>Block size 为 32 字节，也就是 b=5</li>
<li>一共有 32 个 set，也就是 s=5</li>
</ul>
<p>可能出乎大家意料，最困难的其实是 64 x 64，因为对于 miss 数量的要求非常严苛！</p>
<h3 id="u7F13_u5B58_u5206_u6790"><a href="#u7F13_u5B58_u5206_u6790" class="headerlink" title="缓存分析"></a>缓存分析</h3><p>为了加深印象，还是具体分析一下使用的策略。61 x 67 因为不规则，所以基本的策略就是用不同的分块大小去试验，我一路从 8 测试到 24，最后选了个看起来最顺眼的。这里主要还是分析 32 x 32 和 64 x 64 的。</p>
<p>根据给出的缓存大小，可以知道，一个 block 可以放 8 个 int 值，那么对于 32 x 32 矩阵，有下面的图：</p>
<p><img src="/images/14557681819928.jpg" alt="32 x 32"></p>
<p>这里的数字表示对应的值会存在缓存的哪个 set 中，我们可以看到第九行和第一行会冲突，但是如果我们分成 8 x 8 的小块，就可以保证尽可能利用到缓存的特性（读取第 1 个的时候后面 7 个也已经载入缓存中），于是简单分块就可以解决 32 x 32 的矩阵（要求是 miss 数量不超过 300）</p>
<p>但是对于 64 x 64，情况就不一样了，首先是 miss 的数量限制得比较严格，不超过 1300，然后是缓存中的排列也有一些变化，如图：</p>
<p><img src="/images/14557683448384.jpg" alt="64 x 64"></p>
<p>因为宽度的变化，现在第 5 行就会和第 1 行冲突，所以如果我们还用原来的 8 x 8，肯定是不行的。那么如果用 4 x 4 呢？经过尝试之后，发现超过要求的 1300 还是比较多的。问题在哪里？一是因为每次读取 4 个数字，我们实际只用了 4 个，二是宽度改变带来的 conflict miss 仍旧没有很好解决。</p>
<p>题目中说不能使用超过 12 个变量，有 4 个需要作为遍历矩阵的索引值，另外八个是不是可以做一点文章呢？答案是肯定的。</p>
<p>我们依然可以按照原来的 8 x 8 来进行处理，只是在每个 8 x 8 中，还需要进行分块。首先是左上角的 4 x 4，这里没有冲突，都会在缓存中，所以按照正常的分块算法处理。比较有技巧的是右上角和左下角，这里我们会发现重复访问会造成很多的 conflict miss，这个时候就可以利用 4 个本地变量作为 buffer，先存起来，以后再用。这样就利用了每次读入 8 个的优势，并且避开了因为地址冲突而导致的 conflict miss 的问题。</p>
<h3 id="u4E00_u4E9B_u63D0_u793A-1"><a href="#u4E00_u4E9B_u63D0_u793A-1" class="headerlink" title="一些提示"></a>一些提示</h3><p>矩阵转制并不是特别复杂的操作，但是如何利用缓存来尽可能提高速度，就有很多的优化空间了。和矩阵相乘中使用的 cache blocking 方法一样，在这里我们同样可以利用 blocking 的方法来提高效率，可能需要尝试不同的大小，以找到最合适的尺寸。</p>
<p>最好在编译的时候加上 <code>-Werror</code>，这样就不会放过任何一个 warning。如果使用的函数缺少头文件，可以通过 <code>man &lt;function-name&gt;</code> 找到相关头文件</p>
<p>因为只会跑 32x32, 64x64, 61x67 这三个测试，所以可以硬编码来进行检测，针对不同的矩阵大小进行优化。</p>
<p>都写完之后可以利用 <code>./driver.py</code> 进行完整的测试，最后提交自动打包好的 tar 压缩包到 autolab 即可。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>被汇编语言虐了两周之后，回过头来写 C 语言，真的感觉从地狱到了天堂。虽然降低了语言的复杂度，但是对于概念的理解有了更高的要求。回过头来想想，正因为隐藏了足够多的细节，更高层级的抽象才得以方便实现。</p>
<p>缓存的整个设计非常精妙，仅仅利用 locality 一个特性，几乎是用最小的成本达到了最好的性能。</p>
<blockquote>
<p>The memory hierarcy creates a large pool of storage that costs as much as the cheap storage near the bottom, but that serves data to programs at the rate of the fast storage near the top.</p>
</blockquote>
<p>带着镣铐跳舞，精髓。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们来讲讲第四次作业，主要会尽可能利用缓存来加速计算，不过在开始作业之前会先复习一下 C 语言。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Cachelab" scheme="http://wdxtub.com/tags/Cachelab/"/>
    
      <category term="习题课" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98%E8%AF%BE/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Programming iOS9 翻译 9 - iPad Interface]]></title>
    <link href="http://wdxtub.com/2016/02/17/programming-ios9-translation-9/"/>
    <id>http://wdxtub.com/2016/02/17/programming-ios9-translation-9/</id>
    <published>2016-02-17T11:59:39.000Z</published>
    <updated>2016-02-17T15:47:16.000Z</updated>
    <content type="html"><![CDATA[<p>这一章主要讨论 iPad 和 iPhone 在界面特性上的一些不同。Popover 和 split view 是原生为 iPad 设计的界面，在 iOS8 之前都只能在 iPad 上使用，但是现在也可以在 iPhone 上应用。另一个值得注意的是 iPad 多任务功能。</p>
<a id="more"></a>
<hr>
<h2 id="Popovers"><a href="#Popovers" class="headerlink" title="Popovers"></a>Popovers</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>这一章主要讨论 iPad 和 iPhone 在界面特性上的一些不同。Popover 和 split view 是原生为 iPad 设计的界面，在 iOS8 之前都只能在 iPad 上使用，但是现在也可以在 iPhone 上应用。另一个值得注意的是 iPad 多任务功能。</p>]]>
    
    </summary>
    
      <category term="iOS9" scheme="http://wdxtub.com/tags/iOS9/"/>
    
      <category term="iPad" scheme="http://wdxtub.com/tags/iPad/"/>
    
      <category term="学习" scheme="http://wdxtub.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://wdxtub.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Programming iOS9 翻译 8 - TableViews and Collection Views]]></title>
    <link href="http://wdxtub.com/2016/02/17/programming-ios9-translation-8/"/>
    <id>http://wdxtub.com/2016/02/17/programming-ios9-translation-8/</id>
    <published>2016-02-17T11:59:34.000Z</published>
    <updated>2016-02-21T12:24:37.000Z</updated>
    <content type="html"><![CDATA[<p>一个 table view(<code>UITableView</code>) 是一个竖直方向的 <code>UIScrollView</code>，其中包含单列的矩形 cell(<code>UITableViewCell</code>)。Table view 是非常重要的，可以用来展示信息、进行选择和导航。</p>
<a id="more"></a>
<hr>
<p>除了 cell 本身，table view 还有一些其他特性让其更灵活更有用：</p>
<ul>
<li>可以在顶上展示 header，在底部显示 footer</li>
<li>cell 可以聚合成不同的 section，每个 section 可以有其 header 和 footer，并且没有离开当前 section 的话 header 会保持在屏幕上，也可以自定义列表边缘的索引，方便用户快速跳转</li>
<li>可以对表格进行操作：添加，删除或者排序</li>
<li>可以给不同的 cell 分组</li>
</ul>
<p>Table view cell 也非常灵活，除了内置的几种类型，可以轻松进行自定义。</p>
<p>有一个 <code>UIViewController</code> 的子类是 <code>UITableViewController</code>，很方便，但是其实它做得所有事情我们都可以自己做，以下是 <code>UITableViewController</code> 做的事情：</p>
<ul>
<li><code>UITableViewController</code> 的 <code>init(style:)</code> 会根据参数创建一个 table view</li>
<li>视图控制器会自动指定 table view 的 delegate 和 data source</li>
<li>table view 会被设为视图控制器的 <code>tableView</code> 属性，方便使用</li>
</ul>
<h2 id="Table_View_Cells"><a href="#Table_View_Cells" class="headerlink" title="Table View Cells"></a>Table View Cells</h2><p>利用 reuse identifier 来实现重用，只是更换显示的内容，而不重复创建和销毁 cell。因为这个机制，我们需要在使用之前指定好需要展示的数据，也就是哪个位置显示什么，具体位置由 <code>NSIndexPath</code> 确定。</p>
<p>最简单的创建一个 table view cell 的方式是使用内置的四种 style。使用 <code>init(style:reuseIdentifier:)</code>，可选的 style 有：</p>
<p><img src="/images/14557985360452.jpg" alt=""></p>
<p><img src="/images/14557985469035.jpg" alt=""></p>
<p>使用的时候，有几个函数是很重要的</p>
<ul>
<li><code>numberOfSectionsInTableView</code> 返回 section 的个数</li>
<li><code>numberOfRowsInSection</code> 返回列表的行数</li>
<li><code>cellForRowAtIndexPath</code> 返回当前位置现在应该显示的 cell</li>
<li><code>tableview.dequeueReusableCellWithIdentifier</code>  利用这个函数得到一个已经存在 cell（如果返回空则需要我们自己创建），用以重用</li>
</ul>
<p>其他一些可以设置的属性：</p>
<p><img src="/images/14557989567864.jpg" alt=""></p>
<p>也可以给 <code>cell.imageView</code> 设置 image，比如：</p>
<p><img src="/images/14557990302124.jpg" alt="事先缩放成所需大小，而不是依赖系统"></p>
<p>每个 cell 本身也有很多属性，可以进行设置：</p>
<p><img src="/images/14557990872623.jpg" alt=""></p>
<p><img src="/images/14557991035763.jpg" alt=""></p>
<p>最后是 table view 本身的一些属性</p>
<p><img src="/images/14557991407378.jpg" alt=""></p>
<h3 id="Registering_a_Cell_Class"><a href="#Registering_a_Cell_Class" class="headerlink" title="Registering a Cell Class"></a>Registering a Cell Class</h3><p>我们可以使用下面两种方式来得到一个重用的 cell:</p>
<ul>
<li><code>dequeueReusableCellWithIdentifier:</code></li>
<li><code>dequeueReusableCellWithIdentifier:forIndexPath</code></li>
</ul>
<p>第一种我们之前见过，第二种中的第二个参数应当永远和 <code>tableview:cellForRowAtIndexPath:</code> 的第二个参数保持一致。这两个方法看起来差不多，但其实有很大的不同，第二种有以下三个优点：</p>
<ol>
<li>返回值永远不是 <code>nil</code>，如果有可重用的 cell，那么会返回，如果没有，会创建一个并返回</li>
<li>cell 的大小此时已经确定，因为我们指定了 <code>IndexPath</code>，所以系统可以事先确定好尺寸</li>
<li>在第一个方法中，可能会因为传错 identifier 导致重用失效，但是在第二个方法中，不会发生这种事情</li>
</ol>
<p>使用 <code>dequeueRedusableCellWithIndentifier:forIndexPath:</code> 之前，需要向 table 本身注册一下（除非是从 storyboard 创建的），调用 <code>registerClass:forCellReuseIdentifier:</code> 来完成这个工作。这个方法会把一个 <code>UITableViewCell</code> 和一个字符串 identifier 关联起来。而后 <code>dequeueRedusableCellWithIndentifier:forIndexPath:</code> 会利用这个信息返回对应类型的 cell。</p>
<ul>
<li>应该尽早注册，比方说 <code>viewDidLoad</code> 就是不错的地方</li>
<li>如果想要使用其他的 style，可以使用 <code>UITableViewCell</code> 的子类并重写 <code>init(style:reuseIdentifier)</code> 方法来使用指定的 style</li>
<li>如何判断返回的是重用的还是新创建的 cell 呢？可以在函数返回 cell 之后对 cell 本身进行一些检查，如果我们已经配置过，那么就是一个重用的，反之则是新创建的</li>
</ul>
<h3 id="Custom_Cells"><a href="#Custom_Cells" class="headerlink" title="Custom Cells"></a>Custom Cells</h3><p>很快我们就会发现内置的 style 没办法满足我们的需要，所以就需要进行定制了。至少有四种方式可以完成这个工作：</p>
<ol>
<li>用内置的 cell style，但是使用 <code>UITableViewCell</code> 的子类并且重写 <code>layoutSubviews</code> 来改变内置 subview 的 frame</li>
<li>在 <code>tableView:cellForRowAtIndexPath:</code> 中，在每个 cell 被创建的时候在其 <code>contentView</code> 添加 subview，这个可以和第一个方法结合来用</li>
<li>在 nib 中设计 cell，并且在 <code>tableView:cellForRowAtIndexPath:</code> 需要创建 cell 的时候从 nib 中载入</li>
<li>在 storyboard 中设计 cell</li>
</ol>
<p><img src="/images/14558093926092.jpg" alt=""></p>
<p><strong>重写 cell 的 subview layout</strong></p>
<p>不能直接在 <code>tableView:cellForRowAtIndexPath:</code> 中修改，因为之后 cell 自己的 <code>layoutSubviews</code> 会覆盖我们所做的修改，于是解决方法也很简单，直接重写 <code>layoutSubviews</code>。我们创建一个 <code>UITableViewCell</code> 的子类，注意需要在 <code>dequeueReusableCellWithIdentifier:forIndexPath:</code> 中生成我们这个子类的实例，然后重写下面的方法：</p>
<p><img src="/images/14558847687832.jpg" alt=""></p>
<p>这样就把 cell 中的图片移到了右边，如下图：</p>
<p><img src="/images/14558847989080.jpg" alt=""></p>
<p><strong>在代码中添加 subviews</strong></p>
<p>除了修改已有的默认 subview，我们还可以给每个 <code>UITableView</code> 添加全新的 view，可以在 <code>tableView:cellForRowAtIndexPath:</code> 完成这个工作，但是有几点需要注意：</p>
<ul>
<li>需要增加的 view 必须在创建 cell 的时候就添加进去</li>
<li>不要给 cell 本身发送 <code>addSubview:</code> 消息，而只应该操作其 <code>contentView</code></li>
<li>应该给新的 view 合适的 <code>autoresizingMask</code> 或者 constraints，因为可能在屏幕旋转的时候大小会变化</li>
<li>每个新的 view 都应该有一个 tag，这样可以被识别和重用。</li>
</ul>
<p>我们用这个方法来实现上图的效果：</p>
<p><img src="/images/14558852905252.jpg" alt=""></p>
<p><img src="/images/14558852992928.jpg" alt=""></p>
<p><strong>在 nib 中设计 cell</strong></p>
<p>上面的方法要写一堆代码，所以不如直接用图形界面进行设计。我们先创建一个 <code>.xib</code> 文件，删掉原来的 view 并且添加一个 Table View Cell，然后就可以进行设计了。设计好之后记得给每个部件一个 tag，这样莫问在代码中可以引用它们：</p>
<p><img src="/images/14558856434855.jpg" alt=""></p>
<p>那么怎么从 xib 文件读取我们的表格呢，用如下方法即可：</p>
<p><img src="/images/14558856940231.jpg" alt=""></p>
<p>是不是超级方便？</p>
<p><img src="/images/14558857502413.jpg" alt=""></p>
<p>如果不想一直用 tag 来找部件的话，可以创建一个 <code>UITableViewCell</code> 的子类，连接好对应的 outlet，然后注册对应的子类：</p>
<p><img src="/images/14558859180063.jpg" alt=""></p>
<p>这样做完之后就可以直接用名字来调用了：</p>
<p><img src="/images/14558859429911.jpg" alt=""></p>
<p><strong>在 Storyboard 中设计 cell</strong></p>
<p>需要注意的是一定要填写在 cell prototype 中填写好 identifier，然后系统就会自动关联上</p>
<p><img src="/images/14558862782575.jpg" alt=""></p>
<h2 id="Table_View_Data"><a href="#Table_View_Data" class="headerlink" title="Table View Data"></a>Table View Data</h2><p>表格中的数据由 <code>dataSource</code> 属性以及配套的 <code>UITableViewDataSource</code> 协议提供。data source 本身会在需要数据的时候调用若干方法来获取所需数据，总结起来是下面三条原则：</p>
<p><img src="/images/14558865052646.jpg" alt=""></p>
<p>在 mvc 模型中，data source 可以认为是 controller。作为 data source，需要回答下面这三个问题：</p>
<p><img src="/images/14558884427561.jpg" alt=""></p>
<p>对应到具体的代码设计，可能是这样的：</p>
<p><img src="/images/14558885316385.jpg" alt=""></p>
<h3 id="Reusing_Cells"><a href="#Reusing_Cells" class="headerlink" title="Reusing Cells"></a>Reusing Cells</h3><p>重用其实很简单，系统已经帮我们实现了，只需要调用 <code>dequeueReusableCellWithIdentifier:forIndexPath:</code></p>
<p>我们可以用以下代码做个测试</p>
<p><img src="/images/14558892105796.jpg" alt=""></p>
<p>通过命令行的输出可以知道，实际上并没有创建 1000 个 cell</p>
<p><img src="/images/14558892426258.jpg" alt=""></p>
<p>因为你得到的 cell 可能是新创建的也可能是重用的，所以最好每次都做完整的配置，而不是依赖于具体某种类型。</p>
<h3 id="Table_View_Sections"><a href="#Table_View_Sections" class="headerlink" title="Table View Sections"></a>Table View Sections</h3><p>header 和 footer 可以包含自定义的 view，所以可以搞出很多花样。</p>
<p><img src="/images/14558895820319.jpg" alt=""></p>
<p>具体 section 的个数在 <code>numberOfSectionsInTableView:</code> 中决定，<code>UITableViewHeaderFooterView</code> 是 <code>UIView</code> 的子类，可以重用，有以下属性：</p>
<p><img src="/images/14558897816852.jpg" alt=""></p>
<p><img src="/images/14558897960076.jpg" alt=""></p>
<p>有两种方法来提供 header 或者 footer 的内容，可以都用，但是最好从中选择一种：</p>
<p><img src="/images/14558898458407.jpg" alt=""></p>
<p>还有一些更加具体的设置：</p>
<p><img src="/images/14558898851365.jpg" alt=""></p>
<p>提供数据的时候，注意好所用的数据结构和索引即可。</p>
<p>也可以通过如下方法提供快速索引：</p>
<p><img src="/images/14558900378289.jpg" alt=""></p>
<p>如果要修改外观，可以用以下方法；</p>
<p><img src="/images/14558901131758.jpg" alt=""></p>
<h3 id="Refreshing_Table_View_Data"><a href="#Refreshing_Table_View_Data" class="headerlink" title="Refreshing Table View Data"></a>Refreshing Table View Data</h3><p>因为 table view 并不知道它所显示的数据，所以如果数据有改变，可以通过如下方法进行更新：</p>
<p><img src="/images/14558909959784.jpg" alt=""></p>
<p>后面两个方法可以加动画方法，具体的参数是：</p>
<p><img src="/images/14558912456356.jpg" alt=""></p>
<p>如果我们只是需要更新 index，可以调用 <code>reloadSectionIndexTitles:</code>，它会调用 data source 的 <code>sectionIndexTitlesForTableView:</code>。</p>
<p>也可以具体操作某个 cell：</p>
<p><img src="/images/14558919604494.jpg" alt=""></p>
<p><img src="/images/14558920720526.jpg" alt=""></p>
<h3 id="Variable_Row_Heights"><a href="#Variable_Row_Heights" class="headerlink" title="Variable Row Heights"></a>Variable Row Heights</h3><p>大多数表格每一行的高度都是一样的，在 table view 的 <code>rowHeight</code> 属性中设置，但是通过 <code>tableView:HeightForRowAtIndexPath:</code> 代理，可以为不同的行指定不同的高度。而后书中介绍了 4 种改变行高的方法，但是现在随着系统的更新，很多方法已经没有太多必要使用了。这里只介绍 iOS 8 中引入的 Automatic row height。</p>
<p>使用这个机制很简单，使用 autolayout 来确定 <code>contentView</code> 的尺寸，然后设置一下 table view 的 <code>estimatedRowHeight</code> 即可，连 <code>tableView:HeightForRowAtIndexPath:</code> 都不用实现！不过这种方法虽然简单，性能却是最差的，所以如果 table view 遇到了什么性能问题，可能还是要回归到最传统的做法——自己进行计算高度，而不是依赖系统。</p>
<h2 id="Table_View_Cell_Selection"><a href="#Table_View_Cell_Selection" class="headerlink" title="Table View Cell Selection"></a>Table View Cell Selection</h2><p>每个 table view cell 都有一个正常状态和一个高亮状态（<code>highlighted</code> 属性），以及被选中状态（<code>selected</code> 属性）。可以通过代码直接改变这些状态，也可以带上动画，比如调用 cell 的<code>setHighlighted:animated:</code> 和 <code>setSelected:animated:</code>。但是通常我们是通过操作 table view 来完成状态的改变，而不是直接操作 cell 本身。</p>
<p>当一个 cell 被选中时，会把高亮状态传递给其子视图的 <code>highlighted</code> 属性（如果有的话）。比方说被选中时，<code>UILabel</code> 的 <code>highlightedTextColor</code> 就会被显示；同样的，<code>UIImageView</code> 的 <code>highlightedImage</code> 也是如此。</p>
<p>table view 支持单选和多选，被选中时 cell 的背景颜色会改变，可以通过设置 <code>selectedBackgroudView</code> 或者 <code>multipleSelectionBackgroundView</code> 或者 <code>selectionStyle</code> 来进行自定义。</p>
<p>我们可以通过下面的方法来管理被选中的 cell：</p>
<p><img src="/images/14559731699807.jpg" alt=""></p>
<p><img src="/images/14559731806172.jpg" alt=""></p>
<p>想要取消选择所有已经被选择的 cell，可以给 <code>selectRowAtIndexPath:animated:scrollPosition:</code> 传入一个 <code>nil</code> 作为 index path。重新载入 cell 的数据也可以清除选择，调用 <code>reloadData</code> 会取消选择所有已被选择的行。</p>
<p>通过下列 table view 的代理方法来实现对用户选择的响应：</p>
<p><img src="/images/14559737261676.jpg" alt=""></p>
<p>这里的 <code>will</code> 实际上是 <code>should</code> 的意思，需要返回一个值的：</p>
<ul>
<li>如果返回值是 <code>nil</code> 则选择或者取消选择都不会发生</li>
<li>返回对应的 index path 使选择或者取消选择得以进行，如果返回另外的 index，则另一个 cell 的状态会被改变</li>
</ul>
<p>简单总结一下整个的调用流程：</p>
<p><img src="/images/14559738761048.jpg" alt=""></p>
<p>下面就是一个例子，我们可以通过重写对应方法，实现用户第一次点击的时候选择，第二次点击的时候取消选择：</p>
<p><img src="/images/14559739412275.jpg" alt=""></p>
<p>除了列表选择，table view 另一个很重要的功能就是导航，master-detail 的结构就是一个很有代表性的例子，比如说下面的代码就可以完成从专辑列表到专辑详情的跳转：</p>
<p><img src="/images/14559743251362.jpg" alt=""></p>
<p>在 storyboard 中，当我们从 <code>UITableViewCell</code> 连接一个 segue 时，有两种不同的选择：Selection Segue 和 Accessory Action。如果创建了一个 Selection Segue，segue 会在用户选择一个 cell 的时候被触发，可以对应 push 或者 present 另一个视图。</p>
<p>如果使用的是 <code>UITableViewController</code>，那么默认情况下所有的选择会在 <code>viewWillAppear:</code> 中被清除，，如果不想要这一个效果，可以设置 <code>clearsSelectionOnViewWillAppear</code> 为 <code>false</code>，有些时候会禁用这个特性，因为希望在用户返回列表时还保持之前的选择。</p>
<p>通常来说，如果对 table view cell 的选择会导致界面切换，cell 应该被给定一个 <code>.DisclosureIndicator</code> 的 <code>accessoryType</code>(UITableViewCellAccessory)。另外两个可能的选择是：</p>
<p><img src="/images/14559751352611.jpg" alt=""></p>
<p>对应需要实现 <code>tableView:accessoryButtonTappedForRowWithIndexPaht:</code> 的代理方法，或者在 storyboard 中选择 Accessory Action segue。</p>
<p>另外一个应用就是类似与 radio button 的效果，使用 group 结构，有一个 <code>.Checkmark</code> 的 <code>accessoryType</code>。通常会与 static table 来进行展示，如下图：</p>
<p><img src="/images/14559758236052.jpg" alt=""></p>
<p>对应的代码为：</p>
<p><img src="/images/14559758750555.jpg" alt=""></p>
<p><img src="/images/14559758822874.jpg" alt=""></p>
<p>具体在用户选择之后，可以利用下面代码完成单选的功能：</p>
<p><img src="/images/14559759470380.jpg" alt=""></p>
<h2 id="Table_View_Scrolling_and_Layout"><a href="#Table_View_Scrolling_and_Layout" class="headerlink" title="Table View Scrolling and Layout"></a>Table View Scrolling and Layout</h2><p>UITableView 也是一个 UIScrollView，所以对应的操作都可以继续用，而且还提供了两个方便的方法：</p>
<p><img src="/images/14559763307905.jpg" alt=""></p>
<p>下面的一些方法可以用来在 table view 中不同的位置定位</p>
<p><img src="/images/14559763765446.jpg" alt=""></p>
<h2 id="Table_View_State_Restoration"><a href="#Table_View_State_Restoration" class="headerlink" title="Table View State Restoration"></a>Table View State Restoration</h2><p>如果 UITableView 使用了 saving 和 restoration 功能，那么可以保存所有的选择和滚动的位置，这个过程基本是自动的。</p>
<p>不过有的时候可能数据在后台改变了，所以可能需要使用下面两个方法来进行调整：</p>
<p><img src="/images/14559765954511.jpg" alt=""></p>
<h2 id="Table_View_Searching"><a href="#Table_View_Searching" class="headerlink" title="Table View Searching"></a>Table View Searching</h2><p>通常来说如果我们想让列表可以搜索（通过 UISearchBar），可以利用 UISearchController(UIViewController subclass)。实际上 UISearchController 不仅仅可以用在列表中，返回的格式也不一定要是列表，但是这里利用 table view 来进行讲解。</p>
<p>配置 UISearchController 有三个方法：</p>
<p><img src="/images/14559769500936.jpg" alt=""></p>
<p>我们可以发现 UISearchController 并不会返回搜索结果，也不会管理搜索结果，甚至不会做任何搜索，它拥有一个搜索栏，然后在用户交互的时候会更新 <code>updateSearchResultsForSearchController:</code></p>
<p>下面是属性是可能会用到的：</p>
<p><img src="/images/14559778309298.jpg" alt=""></p>
<p>效果图及代码如下：</p>
<p><img src="/images/14559784183758.jpg" alt=""></p>
<p>返回结果的部分也可以自己定义：</p>
<p><img src="/images/14559786392368.jpg" alt=""></p>
<h2 id="Table_View_Editing"><a href="#Table_View_Editing" class="headerlink" title="Table View Editing"></a>Table View Editing</h2><p>一个 table view cell 有正常状态和编辑状态，通过 <code>editing</code> 属性控制，通常来说，编辑状态有以下表现形式：</p>
<p><img src="/images/14560548311069.jpg" alt=""></p>
<p>注意，在编辑模式同样是可以选中的（<code>allowSelectionDuringEditing</code> 或者 <code>allowMultipleSelectionDuringEditing</code> 设置为 <code>true</code>），但是不算很常见。</p>
<p>通常来说我们会放一个按钮，让用户点击，之后进入 table view 的编辑模式：</p>
<p><img src="/images/14560549661669.jpg" alt=""></p>
<p>然后在进入编辑模式的时候用一个完成的按钮来退出编辑模式，代码如上所示。</p>
<p>然而！其实这些系统都已经帮我们实现了，使用 <code>editButtonItem</code> 方法即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.navigationItem.rightBarButtonItem = <span class="keyword">self</span>.editButtonItem()</span><br></pre></td></tr></table></figure>
<p>进入编辑模式之后，table view 会通过代理的方式来获知 cell 的信息，如下：</p>
<p><img src="/images/14560551203316.jpg" alt=""></p>
<p>当用户完成操作的时候，会发送 <code>tableView:commitEditingStyle:forRowAtIndexPath:</code> 给 data source，然后我们可能会需要堆 table view 进行一定的修改，有如下方法：</p>
<p><img src="/images/14560552110623.jpg" alt=""></p>
<p>如果你还想在这个过程中做更多的事情，可以在 <code>beginUpdates</code> 和 <code>endUpdates</code> 间弄一个 update block</p>
<p>删除的过程我们举一个例子来说明，假设我们有一个名称数组(<code>self.sectionNames</code>) 和数据数组（<code>self.sectionData</code>），则可以这样删除：</p>
<p><img src="/images/14560554888868.jpg" alt=""></p>
<p>默认来说，在 cell 上左滑可以快速删除一个 cell，甚至都不用进入编辑模式，如果我们不想要这样怎么办呢？如果只想在编辑模式才能左滑删除呢？也很简单，如下：</p>
<p><img src="/images/14560555881617.jpg" alt=""></p>
<p>每个 cell 本身实际上是一个水平的 scroll view，我们左滑实际上就是让放在后面的删除按钮显示出来，这部分其实也是可以自定义的，只要实现 <code>tableView:editActionsForRowAtIndexPath:</code> 这个代理方法即可，返回一组 UITableViewRowAction 对象（从右到左），可以通过 <code>init(style:title:handler:)</code> 来进行创建，参数如下：</p>
<p><img src="/images/14560557947681.jpg" alt=""></p>
<p>注意，如果想支持滑动出 action button，一定要实现 <code>tableView:commitEditingStyle:forRowAtIndexPath:</code>，即使里面是空的也可以，下面是一个具体的例子，除了默认的删除按钮，又多加了一个名为 <code>Mark</code> 的按钮</p>
<p><img src="/images/14560559293242.jpg" alt=""></p>
<p>下面是一些具体操作的样例代码，比较简单，就不赘述了：</p>
<p><img src="/images/14560560907294.jpg" alt="插入 cell"></p>
<p><img src="/images/14560561097153.jpg" alt="重新排列 cell"></p>
<p>书中最后还给出了一个很有趣的例子，利用代理方法在不同情况下返回不同的 cell 数量来做出 section 收缩和展开的效果，注意用一个集合来保存相关信息即可。</p>
<h2 id="Table_View_Menus"><a href="#Table_View_Menus" class="headerlink" title="Table View Menus"></a>Table View Menus</h2><p>我们也可以给 table view cell 加上 menu，比如说复制粘贴什么的功能，那么就需要实现下面的方法：</p>
<p><img src="/images/14560564648447.jpg" alt=""></p>
<p>下面是一个例子及其对应的展示：</p>
<p><img src="/images/14560564910694.jpg" alt=""></p>
<p>如果想要添加自定义操作，可以使用下面的代码：</p>
<p><img src="/images/14560565155740.jpg" alt=""></p>
<h2 id="Collection_Views"><a href="#Collection_Views" class="headerlink" title="Collection Views"></a>Collection Views</h2><p>UICollectionView 是 UIScrollView 的子类，把 UITableView 的各种操作都通用化了，也就是说，它们俩其实很像，例如：</p>
<p><img src="/images/14560569513318.jpg" alt=""></p>
<p>collection view 的 section 同样可以有 header 和 footer，但是不是 view 本身去调用，而是根据 cell 的类型来自行决定，称为 supplementary views（实际上就是一个 <code>UICollectionReusableView</code>，一个 <code>UICollectionViewCell</code> 的子类）：</p>
<p><img src="/images/14560571077602.jpg" alt=""></p>
<p>collection view 和 table view 的一个重大区别就是它们如何排布所拥有的元素，table view 只会是竖直排列（宽度定死），但是 collection view 就自由很多：</p>
<p><img src="/images/14560571917709.jpg" alt=""></p>
<p>比方说可以实现如下图所示的效果：</p>
<p><img src="/images/14560572097314.jpg" alt=""></p>
<p>又或者是像系统的照片 app 一样：</p>
<p><img src="/images/14560572352360.jpg" alt=""></p>
<h3 id="Collection_View_Classes"><a href="#Collection_View_Classes" class="headerlink" title="Collection View Classes"></a>Collection View Classes</h3><p>这一部分是相关类的介绍，就直接上图了：</p>
<p><img src="/images/14560572768133.jpg" alt=""></p>
<p>对应的方法与 UITableView 中的异同有：</p>
<p><img src="/images/14560573082144.jpg" alt=""></p>
<p>其他的类型还有：</p>
<p><img src="/images/14560573210309.jpg" alt=""></p>
<p><img src="/images/14560573334969.jpg" alt=""></p>
<p><img src="/images/14560573442411.jpg" alt=""></p>
<p><img src="/images/14560573583842.jpg" alt=""></p>
<p>具体的使用这里不再赘述，因为随着 swift 的大幅进化可能会有一定改动，但是我们需要知道不同 layout 可以动态切换，还可以自定义动画效果。</p>
<p>这一章的内容就告一段落。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个 table view(<code>UITableView</code>) 是一个竖直方向的 <code>UIScrollView</code>，其中包含单列的矩形 cell(<code>UITableViewCell</code>)。Table view 是非常重要的，可以用来展示信息、进行选择和导航。</p>]]>
    
    </summary>
    
      <category term="iOS9" scheme="http://wdxtub.com/tags/iOS9/"/>
    
      <category term="学习" scheme="http://wdxtub.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://wdxtub.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="表格" scheme="http://wdxtub.com/tags/%E8%A1%A8%E6%A0%BC/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【火影忍者究级风暴4】伊邪那美]]></title>
    <link href="http://wdxtub.com/2016/02/16/yi-xie-na-mei/"/>
    <id>http://wdxtub.com/2016/02/16/yi-xie-na-mei/</id>
    <published>2016-02-17T01:32:38.000Z</published>
    <updated>2016-02-17T03:46:36.000Z</updated>
    <content type="html"><![CDATA[<p>过去的我们是独孤又渴望爱情，让憎恨逐渐变强的小鬼。各自走上不同的道路，并且彼此对抗。渺小的我们总是互相争执，但是现在已经可以互相理解对方内心的痛楚。 —— 宇智波佐助</p>
<a id="more"></a>
<hr>
<p>当一切的一切最终落幕，所有的波澜壮阔都化为生活中的琐碎时，那一场场殊死战斗才真正有了意义。同样是游戏，同样是火影忍者，每一分每一秒都越发清晰地认识到，这是一群真正爱游戏，真正爱火影，真正爱这个世界并愿意为之付出努力的人倾尽全力想要给这个系列划上圆满的句号。比腾讯的坑钱手游不知道高到哪里去了。</p>
<p><img src="/images/naruto.jpg" alt="有些东西，是心里只有赚钱的人，永远做不出来的"></p>
<h2 id="u6E38_u620F_u90E8_u5206"><a href="#u6E38_u620F_u90E8_u5206" class="headerlink" title="游戏部分"></a>游戏部分</h2><p>游戏的战斗系统和前几作相比没有太大的区别，但是在忍术的释放和小队成员即时协作的操作上，利用 QTE 系统迸发出了极强的张力，加上场景和音乐的烘托，整个游戏过程酣畅淋漓，不会有可以为难玩家的数值与关卡设计，反而处处为玩家着想。就拿战斗失败的处理方式来对比，究极风暴4中会给出『坚强』与『不屈』两种选择，分别对应于防御和攻击的提高，表现形式是忍者始祖的『仙人指路』；但是到了腾讯这里，就是明明白白的『一元复活』，说真的，庸俗恶心。</p>
<p>可使用的角色林林总总有六十多个，从召唤兽到尾兽，从单挑到混战，还结合了射击与跑酷，视觉效果之华丽，气氛营造之到位，让人不禁感叹『游戏才是本体』，动画和漫画都成了配菜。</p>
<p>美中不足的是，可能因为容量与预算的限制，剧情部分大多是以静态图片加配音的方式展现的。虽然配音演员非常卖力，但是人物不动（或者只有微小的表情变化）总是让人觉得不够过瘾。但是毕竟不是每个游戏都能像《合金装备》那样大段大段塞入过场动画，这种表现形式也算是对于原著漫画与动画的致敬。</p>
<p>更难能可贵的是，根据关卡设计（主线分支而后汇合，某些章节分为鸣人线和佐助线，在决战时候两条剧情线汇合）和角色性格丰满的需要，游戏改动了部分剧情，使得整个剧情-战斗-剧情的循环非常合理，一气呵成，根本停不下来。</p>
<p>总而言之，即使是很久没有看火影的老粉丝（比如我），也能一口气把所有的剧情以互动的形式补完，还是最初的少年热血，还是最初的少年情怀，那份为了朋友为了羁绊而不断努力的心情，我相信每一个玩家都能真真切切地感受到。</p>
<p>没什么好说的，虽然有这样那样的不足，对我来说，这就是满分神作。</p>
<h2 id="u5267_u60C5_u90E8_u5206"><a href="#u5267_u60C5_u90E8_u5206" class="headerlink" title="剧情部分"></a>剧情部分</h2><p>那些陪伴我们成长的东西，往往因为太过『习以为常』而被忽略，却又在不经意间出现，让人充满力量。那些一直以来的牵绊，那些一代代的传承，总是会在最危急的时刻，成为最可靠的依赖。</p>
<p>神明为了安定，将世界分为阴阳两极，相反的两种元素互相做用，产生出森罗万象；相反的两种力量互相合作，就能得到真正的幸福。很多东西看似矛盾，其实反而是相互依存的（不由得想起『战争即和平，自由即奴役，无知即力量』）。</p>
<p>随着剧情的发展，很多从前以为是『坏人』的角色，都忽然洗白了，尤以大蛇丸和兜为代表，一个最叛逆在邪路上走的最远，在看见太多事情之后反而有了更加深刻的理解，坏就坏个彻底，好就好个通透；一个在『伊邪那美』的幻术中一次次重复终于超越了自我的局限，找回了自己。</p>
<p>剧情深入之后带来的另一个问题就是关于通往幸福的哲学讨论。一种说法认为『目的地既然不明确，又知道是条坎坷的路，就不用特地去走，走了也是增加同伴的牺牲；但是如果有明确目的地，又有捷径的话，任谁都会选择那条路』；另一种说法认为『重要的不是走捷径，而是走过坎坷道路的方法，到底哪条路是捷径，自己走过才知道。所谓火影，就是忍受痛楚，然后走在众人前方的领导者，成为火影没有捷径，想当上火影的人也绝不会逃避』。所谓正确的道路，所谓光明与黑暗，很多时候真的就只是一念之间。不同哲学路线带来了不同的世界观与方法论，也就是一切争斗的根源。</p>
<p>当然，我还学到了很多其他东西：</p>
<ul>
<li>关于伙伴的事，再痛苦我都能忍耐；可是心中没有伙伴，对我来说才是最痛苦的事情</li>
<li>人会因为思考、烦恼与挫折而成长，所谓幸福，应该是在那前方的东西</li>
<li>死亡并不是结束</li>
<li>不要用面具来掩盖自己</li>
<li>言语掩饰不了真心</li>
<li>回归到生活本身</li>
<li>别拘泥于无聊的自尊心</li>
<li>只要愿意，就看得见</li>
<li>朋友，就是看你迷茫受苦胡闹，心疼，没有办法丢下不管</li>
<li>爱不仅是努力帮 ta 遮风挡雨，更是相信 ta 自己的判断</li>
<li>人们像念珠一样串在一起的信念，会化成强大的力量</li>
<li>与信念相同的东西铭记在心，使彼此的生命联系在一起；放弃了信念，才是真正杀害了同伴</li>
</ul>
<p>不要再隐藏自己了！最后一个问题是：</p>
<blockquote>
<p>愿不愿意以一只眼睛的代价，让另一个人得到救赎？</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>过去的我们是独孤又渴望爱情，让憎恨逐渐变强的小鬼。各自走上不同的道路，并且彼此对抗。渺小的我们总是互相争执，但是现在已经可以互相理解对方内心的痛楚。 —— 宇智波佐助</p>]]>
    
    </summary>
    
      <category term="兄弟" scheme="http://wdxtub.com/tags/%E5%85%84%E5%BC%9F/"/>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="火影忍者" scheme="http://wdxtub.com/tags/%E7%81%AB%E5%BD%B1%E5%BF%8D%E8%80%85/"/>
    
      <category term="结局" scheme="http://wdxtub.com/tags/%E7%BB%93%E5%B1%80/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 应用简评]]></title>
    <link href="http://wdxtub.com/2016/02/16/ios-app-short-review/"/>
    <id>http://wdxtub.com/2016/02/16/ios-app-short-review/</id>
    <published>2016-02-16T15:45:49.000Z</published>
    <updated>2016-02-20T18:08:21.000Z</updated>
    <content type="html"><![CDATA[<p>这个系列主要是记录一下自己玩过的众多 iOS 应用，因为时间和篇幅所限，每个游戏可能只会用几句话简单评测，当然，某些我觉得值得单独拉出来评测的，还是会专门进行介绍的。</p>
<a id="more"></a>
<hr>
<h2 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h2><ul>
<li>入选标准纯主观</li>
<li>按自然顺序排列（就是瞎排，没有类别和时间顺序）</li>
<li>不会有截图，只有图标</li>
<li>评测标准纯主观，具体评测角度看心情</li>
<li>一分钱广告费没有拿，没有利益相关</li>
<li>部分内容可能因为记忆偏差或者应用更新而不一致，不要在意这些细节</li>
<li>基本都是中国区的应用，例外会特别标出</li>
<li>想到了再多加几条显得既随性又专业</li>
</ul>
<h2 id="16__u5E74_2__u6708_20__u65E5"><a href="#16__u5E74_2__u6708_20__u65E5" class="headerlink" title="16 年 2 月 20 日"></a>16 年 2 月 20 日</h2><p><img src="/images/14559836686902.jpg" alt=""></p>
<p>Full - Track and measure your time</p>
<p>统计时间的应用最大的意义就是让我意识到花在统计时间上的时间也不少，平日里闲下来多思考即可</p>
<hr>
<p><img src="/images/14559837573330.jpg" alt=""></p>
<p>Jane</p>
<p>中文名是『简拼』，不过到最后我发现我连拼都懒得拼，唉</p>
<hr>
<p><img src="/images/14559838013423.jpg" alt=""></p>
<p>Grid Diary</p>
<p>脱胎于之前风靡一时的九宫格日志，不过现在再看的话，还是有些死板，有思维的人，应该让思维更加自由流动才是</p>
<hr>
<p><img src="/images/14559838164869.jpg" alt=""></p>
<p>最美应用</p>
<p>我觉得这类应用推荐都免不了『利益相关』，不过应用本身还是很不错的</p>
<hr>
<p><img src="/images/14559838343514.jpg" alt=""></p>
<p>Medium</p>
<p>分到 News 这一栏也勉强说得过去，不过我觉得更像是一个文字社区，不过中文的社区无一不沦为段子手小清新的根据地，真正的思想讨论在哪里</p>
<hr>
<p><img src="/images/14559838483105.jpg" alt=""></p>
<p>Swifty</p>
<p>蛮不错的互动语言教学，不过按照 Swift 这个进化速度，这个应用任重道远</p>
<hr>
<p><img src="/images/14559838587038.jpg" alt=""></p>
<p>读读日报</p>
<p>粉丝向的知乎日报，我个人非常不喜欢这种乱七八糟的信息。</p>
<hr>
<p><img src="/images/14559839373786.jpg" alt=""></p>
<p>TimeShutter</p>
<p>每天拍一张自己的照片，然后生成一个动画，看看自己的变化，还是挺好玩的</p>
<hr>
<p><img src="/images/14559839956993.jpg" alt=""></p>
<p>Transit App</p>
<p>半小时一班的公交车，没有这个 APP，就只能走路回家，虽然我总是走路回家</p>
<hr>
<p><img src="/images/14559840244294.jpg" alt=""></p>
<p>字节社</p>
<p>之所以专门提一下，是因为字节社的字体确实不错，不过创始人总感觉有点不接地气，式微也正常</p>
<hr>
<p><img src="/images/14559840570217.jpg" alt=""></p>
<p>Worktile</p>
<p>团队协作工具，不过目前学生阶段还是单打独斗多，没有特别的切身体会</p>
<hr>
<p><img src="/images/14559840633879.jpg" alt=""></p>
<p>微信读书</p>
<p>不大明白是要怎样，不出墨水屏阅读器就搞数字阅读，都是耍流氓</p>
<hr>
<p><img src="/images/14559841005840.jpg" alt=""></p>
<p>GoodReader</p>
<p>超神阅读器，all-in-one 的最佳选择，本来还有些竞争者，无奈它最持久</p>
<hr>
<p><img src="/images/14559841408489.jpg" alt=""></p>
<p>Union</p>
<p>意思就是用两个图融成一幅更美的图，不过我至今没学会怎么用</p>
<hr>
<p><img src="/images/14559841734501.jpg" alt=""></p>
<p>Wunderlist</p>
<p>中文名叫奇妙清单，大版本都更新好多次了，还是一直在进步的，之前好像被微软收了？不是特别有印象了</p>
<hr>
<p><img src="/images/14559842045457.jpg" alt=""></p>
<p>5 coins</p>
<p>国人出品的记账软件，不过一个单机的记账软件其实效率很低。</p>
<hr>
<p><img src="/images/14559842104566.jpg" alt=""></p>
<p>Musyc</p>
<p>很有创意的物理 + 音乐创作应用，不过好多都要花钱买，这年头玩音乐，都玩不起了</p>
<hr>
<p><img src="/images/14559842665716.jpg" alt=""></p>
<p>AirPano Travel Book</p>
<p>超赞超赞超赞的旅行书!!!动画效果一流超一流!!!服！</p>
<hr>
<p><img src="/images/14559843462955.jpg" alt=""></p>
<p>iStudiez Pro</p>
<p>远古时期用来记课程表的，不过后来我学会了翘课</p>
<hr>
<p><img src="/images/14559843568156.jpg" alt=""></p>
<p>知趣天气</p>
<p>印象中是第一个把经营养成带入天气应用的应用，虽然我不明白为什么，但是有段时间我还是孜孜不倦在养应用里的花</p>
<hr>
<p><img src="/images/14559843756157.jpg" alt=""></p>
<p>PhotoViva</p>
<p>作为一个收费应用，三天两头限免，这个 app 说自己是老二，就没有老大。据我观察，妹子们一般用这个来打码。</p>
<hr>
<p><img src="/images/14559843990625.jpg" alt=""></p>
<p>一柱香</p>
<p>简单来说，就是一个强制自己不玩手机的应用，不过这个计时的方式很中国很传统我很喜欢</p>
<hr>
<p><img src="/images/14559844176390.jpg" alt=""></p>
<p>Expenses OK</p>
<p>记账软件图标真的都太像了，不信等下又有一个</p>
<hr>
<p><img src="/images/14559844283046.jpg" alt=""></p>
<p>Paint FX</p>
<p>修图软件，不过感觉对功底有一定要求，所以我就算了</p>
<hr>
<p><img src="/images/14559844397929.jpg" alt=""></p>
<p>Spendee</p>
<p>看，又一个记账软件，不过这个我还确实是用了一段时间的，发现，我就这么点钱，不用记账软件也知道钱花到哪里去了，唉</p>
<h2 id="16__u5E74_2__u6708_16__u65E5"><a href="#16__u5E74_2__u6708_16__u65E5" class="headerlink" title="16 年 2 月 16 日"></a>16 年 2 月 16 日</h2><p><img src="/images/14556379936188.jpg" alt=""></p>
<p>iDaily·每日环球视野</p>
<p>我基本就看看图，存存壁纸，但是现在我都用默认的壁纸了，也就不用了</p>
<hr>
<p><img src="/images/14556380070431.jpg" alt=""></p>
<p>SuperMemo</p>
<p>说白了就是记忆卡片，不过我始终静不下心背单词（或者其他），只是稍微尝试了一下，据说背后的算法很牛，不过没怎么体会到就是了。</p>
<hr>
<p><img src="/images/14556380356757.jpg" alt=""></p>
<p>Discovr</p>
<p>发现音乐的，找到不同歌手的联系，不过感觉对华语乐坛支持比较差，希望外国歌曲的盆友可以搞起</p>
<hr>
<p><img src="/images/14556380923184.jpg" alt=""></p>
<p>myUnit·Global Unit Converter</p>
<p>单位转换，这类应用基本就是拼界面了，这个因为是四叶草出品的，还是比较有保证的。</p>
<hr>
<p><img src="/images/14556381114390.jpg" alt=""></p>
<p>Forest: Stay focused</p>
<p>简单来说就是『封印』手机，我的感觉是不必有强迫症，感觉控制不住自己的时候用用就好。</p>
<hr>
<p><img src="/images/14556381202296.jpg" alt=""></p>
<p>Keep - 移动健身教练</p>
<p>美女帅哥很多，各个身材都比我好，但是人懒起来，就是不运动，你说怎么办！</p>
<hr>
<p><img src="/images/14556381707433.jpg" alt=""></p>
<p>53 Paper - Notes</p>
<p>非常文艺的画画记笔记软件，看这个介绍就知道跟我没啥关系了，因为我并不会画画。不过动画效果一流，看看还是不错的。</p>
<hr>
<p><img src="/images/14556381804646.jpg" alt=""></p>
<p>CalCube</p>
<p>立方体计算器，本质还是计算器呗，动画效果特别一些</p>
<hr>
<p><img src="/images/14556381980813.jpg" alt=""></p>
<p>NextDay</p>
<p>每天一张图一段话，文艺小清新，就是这个意思。</p>
<hr>
<p><img src="/images/14556382182817.jpg" alt=""></p>
<p>食色</p>
<p>一开始用得比较多，但是后来基本沦为修图软件，再后来图都懒得修了，晒吃总不能天天晒，那么不晒的时候我干嘛要看别人晒折磨自己。</p>
<hr>
<p><img src="/images/14556382269782.jpg" alt=""></p>
<p>The Great Photo App</p>
<p>手把手教你拍照，互动很不错，专业性也没有什么问题，就是更新太慢</p>
<hr>
<p><img src="/images/14556382681077.jpg" alt=""></p>
<p>图解电影</p>
<p>标题非常简明扼要，对我来说的好处就是，有些不敢看的恐怖片，可以看静态图过过瘾，毕竟没有那么可怕了</p>
<hr>
<p><img src="/images/14556383281179.jpg" alt=""></p>
<p>Polarr Photo Editor</p>
<p>总体感觉是功能很强大，但是上手难度太大，我一直就没怎么学会。</p>
<hr>
<p><img src="/images/14556383627121.jpg" alt=""></p>
<p>Light</p>
<p>网易出品的精选新闻，可以评论某一个段落或者图片什么的，打发时间。</p>
<hr>
<p><img src="/images/14556383931838.jpg" alt=""></p>
<p>DailyCost</p>
<p>之前自己在用的记账软件，界面比较清晰也挺好用，不过现在感觉还是刷卡的时候让信用卡账单自动记账比较省事儿。</p>
<hr>
<p><img src="/images/14556384034802.jpg" alt=""></p>
<p>Calculator ‘3’</p>
<p>这年头计算器花样太多，不过我最常用的还是原生自带的，这个功能挺强大的，感兴趣可以试一试。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这个系列主要是记录一下自己玩过的众多 iOS 应用，因为时间和篇幅所限，每个游戏可能只会用几句话简单评测，当然，某些我觉得值得单独拉出来评测的，还是会专门进行介绍的。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://wdxtub.com/tags/iOS/"/>
    
      <category term="应用" scheme="http://wdxtub.com/tags/%E5%BA%94%E7%94%A8/"/>
    
      <category term="评测" scheme="http://wdxtub.com/tags/%E8%AF%84%E6%B5%8B/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 游戏简评]]></title>
    <link href="http://wdxtub.com/2016/02/16/ios-game-short-review/"/>
    <id>http://wdxtub.com/2016/02/16/ios-game-short-review/</id>
    <published>2016-02-16T15:34:25.000Z</published>
    <updated>2016-02-20T18:09:14.000Z</updated>
    <content type="html"><![CDATA[<p>这个系列主要是记录一下自己玩过的众多 iOS 游戏，因为时间和篇幅所限，每个游戏可能只会用几句话简单评测，当然，某些我觉得值得单独拉出来评测的，还是会专门进行介绍的。</p>
<a id="more"></a>
<hr>
<h2 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h2><ul>
<li>入选标准纯主观</li>
<li>按自然顺序排列（就是瞎排，没有类别和时间顺序）</li>
<li>不会有截图，只有图标</li>
<li>评测标准纯主观，具体评测角度看心情</li>
<li>一分钱广告费没有拿，没有利益相关</li>
<li>部分内容可能因为记忆偏差或者游戏更新而不一致，不要在意这些细节</li>
<li>基本都是中国区的游戏，例外会特别标出</li>
<li>想到了再多加几条显得既随性又专业</li>
</ul>
<h2 id="16__u5E74_2__u6708_20__u65E5"><a href="#16__u5E74_2__u6708_20__u65E5" class="headerlink" title="16 年 2 月 20 日"></a>16 年 2 月 20 日</h2><p><img src="/images/14559836509210.jpg" alt=""></p>
<p>AERENA - Clash of Champions</p>
<p>画面超级赞的走格子对战游戏，人物动作场景什么都很精美，上乘</p>
<hr>
<p><img src="/images/14559836595602.jpg" alt=""></p>
<p>愤怒的小鸟思黛拉</p>
<p>出来骗钱的一作，换个颜色难道我就不认识了嘛？</p>
<hr>
<p><img src="/images/14559836772410.jpg" alt=""></p>
<p>Zombie Highway</p>
<p>路怒症丧尸爱好者福音！根本停不下来，这个题材基本上只有他们一家在做，不过玩久了还是有点无聊——丧尸到后面实在是太强了</p>
<hr>
<p><img src="/images/14559837761722.jpg" alt=""></p>
<p>Bug Princess</p>
<p>叫『虫姬』就懂了，弹幕游戏扛鼎之作，不黑不吹</p>
<hr>
<p><img src="/images/14559837882605.jpg" alt=""></p>
<p>Wind-up Knight 2</p>
<p>小小骑士 2，操作简单，玩法也还算多样，不错的休闲游戏</p>
<hr>
<p><img src="/images/14559837951722.jpg" alt=""></p>
<p>jukebeat</p>
<p>音乐节拍游戏新形态，不得不说，除了心疼屏幕，还真的是好玩，虽然我依然最爱 psp 上的 djmax portable 2</p>
<hr>
<p><img src="/images/14559838101240.jpg" alt=""></p>
<p>Overkill 2</p>
<p>狙击游戏之一，玩多了同质化明显，ready - steady - shoot!</p>
<hr>
<p><img src="/images/14559838244581.jpg" alt=""></p>
<p>Rayman Jungle Run</p>
<p>雷曼家族一年一作系列，质量有保证，但是，看多了还是腻歪</p>
<hr>
<p><img src="/images/14559838419675.jpg" alt=""></p>
<p>Sky Gambler Air Supremacy</p>
<p>苹果推荐的空战游戏，不过实话说，离皇牌空战还是差距比较大，我表示玩不下去</p>
<hr>
<p><img src="/images/14559838707926.jpg" alt=""></p>
<p>LONEWOLF</p>
<p>又是一个狙击游戏，换换模型换换枪，其他一样</p>
<hr>
<p><img src="/images/14559839437614.jpg" alt=""></p>
<p>Agent Dash</p>
<p>我觉得画风什么的比 Temple Run 都好，但是毕竟是跟风之作没办法这么火，解锁的妹子角色那叫一个火辣，我喜欢</p>
<hr>
<p><img src="/images/14559839515923.jpg" alt=""></p>
<p>FRAMED</p>
<p>创意爆炸的游戏，不是年度最佳不科学，真的很想自己也做一个这么独特的游戏</p>
<hr>
<p><img src="/images/14559839605619.jpg" alt=""></p>
<p>Madcoaster</p>
<p>还是当年的过山车！还是当年的味道！</p>
<hr>
<p><img src="/images/14559839698033.jpg" alt=""></p>
<p>Flight Control Rocket</p>
<p>把飞机换成了火箭，但是游戏模式还是一个样，所以，还是很容易腻</p>
<hr>
<p><img src="/images/14559839792834.jpg" alt=""></p>
<p>Nuts!: Infinite Forest Run</p>
<p>一只松鼠一直往上爬，还是基本的跑酷游戏，不知道为啥我玩久了会晕，怪</p>
<hr>
<p><img src="/images/14559840043887.jpg" alt=""></p>
<p>Grimm</p>
<p>画风诡异的横版过关游戏，推个婴儿车还甩来甩去真的有点难以接受</p>
<hr>
<p><img src="/images/14559840156367.jpg" alt=""></p>
<p>Warhammer Quest</p>
<p>战锤系列质量一如既往的高，喜欢这个系列</p>
<hr>
<p><img src="/images/14559840305175.jpg" alt=""></p>
<p>Blek</p>
<p>超级烧脑的益智游戏！人工配音有点恶趣味也有点搞笑！至今未能通关</p>
<hr>
<p><img src="/images/14559840404204.jpg" alt=""></p>
<p>Warhammer 40000</p>
<p>印象中是第一个用上 3D touch 的游戏，靠谱，引领风潮，而且非常自然不是强行加特性的那种</p>
<hr>
<p><img src="/images/14559840709495.jpg" alt=""></p>
<p>GRAVITY: DON’T LET GO</p>
<p>很难操作，感觉完美还原了太空中移动的无力感</p>
<hr>
<p><img src="/images/14559840836616.jpg" alt=""></p>
<p>MUJO</p>
<p>这个游戏看图标保准大部分人猜不出来是干嘛的，结果就是三消</p>
<hr>
<p><img src="/images/14559840931099.jpg" alt=""></p>
<p>Block Fortress</p>
<p>Minecraft 类似游戏，不过新手指引做得不知所云，没搞懂在玩啥</p>
<hr>
<p><img src="/images/14559841080068.jpg" alt=""></p>
<p>BIT.TRIP RUN!</p>
<p>画风非常花哨的游戏，亮瞎眼，但是人物设计和动作都很搞笑，赞</p>
<hr>
<p><img src="/images/14559841493700.jpg" alt=""></p>
<p>Rolling Kongs</p>
<p>蛮有创意的转转消游戏，不过图标太丑</p>
<hr>
<p><img src="/images/14559841805459.jpg" alt=""></p>
<p>Dungeon Hunter 4</p>
<p>地牢系列第四作，消磨时间杠杠的，基本上中规中矩</p>
<hr>
<p><img src="/images/14559841894346.jpg" alt=""></p>
<p>Temple Run</p>
<p>洗脑游戏，不过后期有些创新，但是似乎无法复制当时的奇迹，招聘会的时候还见到他们来着，不过只招美国人</p>
<hr>
<p><img src="/images/14559841971361.jpg" alt=""></p>
<p>DEAD TARGET: Zombie</p>
<p>为什么要拿出来了，真的是图标太丑….</p>
<hr>
<p><img src="/images/14559842226821.jpg" alt=""></p>
<p>Tower Madness 2</p>
<p>比较好的 3D 塔防，值得玩一玩</p>
<hr>
<p><img src="/images/14559842379720.jpg" alt=""></p>
<p>MAYDAY!</p>
<p>紧急迫降的游戏，实话说真的不好操控，非常需要熟能生巧</p>
<hr>
<p><img src="/images/14559842477229.jpg" alt=""></p>
<p>Blood Roofs</p>
<p>这是第一次在手机上见到这么『油腻』的画风，抱着妹子还能在屋顶上跳来跳去，总体来说很重口</p>
<hr>
<p><img src="/images/14559842548228.jpg" alt=""></p>
<p>Save a Rhino</p>
<p>环保游戏，跑酷中感受犀牛</p>
<hr>
<p><img src="/images/14559842737882.jpg" alt=""></p>
<p>Superbrothers</p>
<p>非常经典的 RPG，画风独特，剧情一流，虽然我现在还没通关</p>
<hr>
<p><img src="/images/14559843263974.jpg" alt=""></p>
<p>Infinity Blade III</p>
<p>炫技游戏，主要是展示下引擎，玩法基本来说比较无趣，第三代也是那么无趣</p>
<hr>
<p><img src="/images/14559843338055.jpg" alt=""></p>
<p>Snapimals</p>
<p>画风有趣，动物很萌，可是收集起来很花时间，给动物拍照还是挺不错的创意</p>
<hr>
<p><img src="/images/14559843629122.jpg" alt=""></p>
<p>EPOCH 2</p>
<p>类似以前的街机游戏，打打打突突突，还是不错的</p>
<hr>
<p><img src="/images/14559843699736.jpg" alt=""></p>
<p>Twin Shooter - Invaders</p>
<p>这个游戏告诉我们不坑钱同样能做出好游戏，好的打飞机游戏</p>
<hr>
<p><img src="/images/14559844110880.jpg" alt=""></p>
<p>Jetpack Joyride</p>
<p>这个超级好玩，half brick 是个靠谱的公司，不过最近更新之后也变得坑钱向了，不能愉快玩耍了。</p>
<h2 id="16__u5E74_2__u6708_16__u65E5"><a href="#16__u5E74_2__u6708_16__u65E5" class="headerlink" title="16 年 2 月 16 日"></a>16 年 2 月 16 日</h2><p><img src="/images/14556380188112.jpg" alt=""></p>
<p>3D Badminton</p>
<p>整体来说手感不错，手指当球拍，划不同区域不同力度就相当于跑位和击球方式了，不过因为我对羽毛球真的是略懂，所以觉得其实和其他球类游戏差别不大，估计改改参数就可以做成乒乓球排球网球，反正只要是有网的竞技体育就行。</p>
<hr>
<p><img src="/images/14556380616375.jpg" alt=""></p>
<p>Flight Control</p>
<p>经典的上古级游戏，记得当时我还玩得很上瘾，根本停不下来，不过后面因为玩法变化太小玩多了难免有那么一个瞬间觉得『啊这有什么好玩啊』，然后就不继续玩了</p>
<hr>
<p><img src="/images/14556380714213.jpg" alt=""></p>
<p>A Dark Room</p>
<p>恐怖游戏一直不是我的菜，实在是联想能力太强，晚上果断睡不着觉，不过整体氛围还是不错的。</p>
<hr>
<p><img src="/images/14556380782615.jpg" alt=""></p>
<p>Broken Sword 2</p>
<p>也是比较早的游戏了，动画片画风略微有点违和，不过习惯了之后感觉还是挺不错的，标准的剧情解密，谜题设计得还算不错，值得玩一玩。</p>
<hr>
<p><img src="/images/14556380855019.jpg" alt=""></p>
<p>Flappy Bird</p>
<p>洗脑游戏，一句话就可以说清楚玩的感受『看起来这么蠢的游戏我竟然只能得个位数分数，这不科学我不服』</p>
<hr>
<p><img src="/images/14556381036144.jpg" alt=""></p>
<p>OPUS: The Day We Found Earth</p>
<p>非常文艺的游戏，就是孤独的小机器人在茫茫宇宙中找寻适合人类居住的星球，需要一定情怀和耐心。</p>
<hr>
<p><img src="/images/14556381272633.jpg" alt=""></p>
<p>Burn it Down</p>
<p>一开始玩感觉还不错，后面进入恐怖模式了，我就又不敢玩了，横版过关。</p>
<hr>
<p><img src="/images/14556381549828.jpg" alt=""></p>
<p>ZENFORMS: Protectors</p>
<p>既然任天堂不在手机上出宠物小精灵，那么肯定就会有后来者满足大家愿望，这个就是了。</p>
<hr>
<p><img src="/images/14556381633213.jpg" alt=""></p>
<p>Skyward</p>
<p>看图标就知道，纪念碑谷之后这类画风的游戏就流行起来了，但是玩法和纪念碑谷是万万不同的。</p>
<hr>
<p><img src="/images/14556381906331.jpg" alt=""></p>
<p>Turbo Dismount</p>
<p>物理学自虐游戏，这个是第二作，花样在马路上作死，发泄起来还是很爽的。</p>
<hr>
<p><img src="/images/14556382087935.jpg" alt=""></p>
<p>Tap ‘n Slash</p>
<p>非常简单粗暴的小游戏，沿着对角线走走砍砍，熟能生巧，不过像素风格还是比较有趣的</p>
<hr>
<p><img src="/images/14556382361373.jpg" alt=""></p>
<p>Towers Infinite</p>
<p>从前还是在索爱上玩过的盖楼，现在出了高清无尽版，不过还是怀旧成分比较多。</p>
<hr>
<p><img src="/images/14556382432271.jpg" alt=""></p>
<p>Rayman Fiesta Run</p>
<p>雷曼系列跑酷，质量一流，收集癖慎玩，很容易发生因为没有收集完在一关死循环的情况。</p>
<hr>
<p><img src="/images/14556382529865.jpg" alt=""></p>
<p>The Sandbo - Build&amp; Create</p>
<p>沙盒造物主系列，像素风，我个人对这个类型游戏比较一般。</p>
<hr>
<p><img src="/images/14556382612517.jpg" alt=""></p>
<p>rop</p>
<p>切完糖果可以切绳子！基本来说就是基于物理规则的益智游戏</p>
<hr>
<p><img src="/images/14556382759883.jpg" alt=""></p>
<p>Super Hexagon</p>
<p>非常考验反应力，而且多边形大色块很容易让人意乱神迷，洗脑游戏 </p>
<hr>
<p><img src="/images/14556382823039.jpg" alt=""></p>
<p>FOTONICA</p>
<p>第一人称线条型跑酷，超级狂拽酷炫，音乐也是亮点</p>
<p><img src="/images/14556382896123.jpg" alt=""></p>
<p>Call of Mini: Dino Hunter</p>
<p>打完僵尸打恐龙，其实差不多是一个意思，喜欢左右摇杆射击可以试试看。</p>
<hr>
<p><img src="/images/14556382987408.jpg" alt=""></p>
<p>Angry Birds Star Wars II</p>
<p>愤怒小鸟主题游戏第 N 波，我向来不是特别感冒</p>
<hr>
<p><img src="/images/14556383193105.jpg" alt=""></p>
<p>Assassin’s Creed Pirates</p>
<p>刺客信条海战系列，总体来说还原得不错，不过从大航海时代我就是海战苦手，过过过。</p>
<hr>
<p><img src="/images/14556383343499.jpg" alt=""></p>
<p>OLO game</p>
<p>画面清新玩法简单非常适合情侣虐狗的游戏，就是这样。</p>
<hr>
<p><img src="/images/14556383492141.jpg" alt=""></p>
<p>Doodle Jump</p>
<p>也是上古游戏列表中的知名一员，重力感应跳跳跳，玩久了很容易无聊。</p>
<hr>
<p><img src="/images/14556383552948.jpg" alt=""></p>
<p>Eternity Warriors 3</p>
<p>可能是 glu 最后一款这样的大作了？只能说在手机上我玩不来这个类型游戏，太累。</p>
<hr>
<p><img src="/images/14556383711674.jpg" alt=""></p>
<p>Assassin’s Creed Recollection</p>
<p>非常有创意的卡牌对战游戏，我觉得和炉石传说相比一点都不逊色，而且刺客明显更酷嘛。</p>
<hr>
<p><img src="/images/14556383809420.jpg" alt=""></p>
<p>Edge</p>
<p>又是一个画面洗脑的游戏，看久了不知道为啥就会感觉不大舒服，多边形益智类，你懂的。</p>
<hr>
<p><img src="/images/14556383870555.jpg" alt=""></p>
<p>Skiing Yeti Mountain</p>
<p>虽然不知道是什么山，但是这个山上出了很多人命是一定的，手感真的非常不错，滑雪控不要错过</p>
<hr>
<p><img src="/images/14556384107682.jpg" alt=""></p>
<p>Radiation Island</p>
<p>辐射岛，可能是最近玩过的手机平台上最 hard core 的游戏了，不过需要很多心思，没啥时间深入感受</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这个系列主要是记录一下自己玩过的众多 iOS 游戏，因为时间和篇幅所限，每个游戏可能只会用几句话简单评测，当然，某些我觉得值得单独拉出来评测的，还是会专门进行介绍的。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://wdxtub.com/tags/iOS/"/>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="评测" scheme="http://wdxtub.com/tags/%E8%AF%84%E6%B5%8B/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 12 课 Cache Memories]]></title>
    <link href="http://wdxtub.com/2016/02/15/csapp-12/"/>
    <id>http://wdxtub.com/2016/02/15/csapp-12/</id>
    <published>2016-02-15T15:15:18.000Z</published>
    <updated>2016-02-16T15:11:46.000Z</updated>
    <content type="html"><![CDATA[<p>上一讲我们了解了存储的相关知识，这节课我们来更加深入研究一下 cache memory 的知识。</p>
<a id="more"></a>
<hr>
<p>Cache memory 是由硬件自动管理的 SRAM 内存，CPU 会首先从这里找数据，其所处的位置如下：</p>
<p><img src="/images/14555689621035.jpg" alt=""></p>
<p><strong>General Cache Organization(S, E, B)</strong></p>
<p>通常来说，是按照如下图所示的方式来组织的，一定要注意 S/E/B 具体在说什么：</p>
<p><img src="/images/14555690389309.jpg" alt=""></p>
<p>实际上可以理解为三种层级关系，对应不同的索引，这样分层的好处在于，通过层级关系简化搜索需要的时间，并且和字节的排布也是一一对应的（之后介绍缓存的时候就体现得更加明显）。</p>
<h2 id="u8BFB_u5165"><a href="#u8BFB_u5165" class="headerlink" title="读入"></a>读入</h2><p><img src="/images/14556253748808.jpg" alt=""></p>
<p>具体在从缓存中读取一个地址时，首先我们通过 set index 确定要在哪个 set 中寻找，确定后利用 tag 和同一个 set 中的每个 line 进行比对，找到 tag 相同的那个 line，最后再根据 block offset 确定要从 line 的哪个位置读起（这里的而 line 和 block 是一个意思）。</p>
<p>当 E=1 时，也就是每个 set 只有 1 个 line 的时候，称之为直接映射缓存(Direct Mapped Cache)。</p>
<p><img src="/images/14556267189507.jpg" alt=""></p>
<p>这种情况下，因为每个 set 对应 1 个 line，反过来看，1 个 line 就需要一个 set，所以 set index 的位数就会较多（和之后的多路映射对比）。具体的检索过程就是先通过 set index 确定哪个 set，然后看是否 valid，然后比较那个 set 里唯一 line 的 tag 和地址的 t bits 是否一致，就可以确定是否缓存命中。</p>
<p><img src="/images/14556274155804.jpg" alt=""></p>
<p>命中之后根据 block offset 确定偏移量，因为需要读入一个 int，所以会读入 4 5 6 7 这四个字节（假设缓存是 8 个字节）。如果 tag 不匹配的话，这行会被扔掉并放新的数据进来。</p>
<p>这里举一个具体的例子</p>
<p><img src="/images/14556275938967.jpg" alt=""></p>
<p>缓存的大小如图所示，对应就是有 4 个 set，所以需要 2 位的 set index，所以进行读入的时候，会根据中间两位来确定在哪个 set 中查找，其中 8 和 0，因为中间两位相同，会产生冲突，导致连续 miss，这个问题可以用多路映射来解决。</p>
<p>当 E 大于 1 时，也就是每个 set 有 E 个 line 的时候，称之为 E-way Set Associative Cache。这里用 E = 2 来做例子：</p>
<p><img src="/images/14556282750323.jpg" alt=""></p>
<p>跟前面所说的一致，这里每个 set 有两个 line，所以就没有那么多 set，也就是说说 set index 可以少一位（之后的例子可以看到）</p>
<p><img src="/images/14556285710342.jpg" alt=""></p>
<p>再简述一下整个过程，先从 set index 确定那个 set，然后看 valid 位，接着利用 t bits 分别和每个 line 的 tag 进行比较，如果匹配则命中，那么返回 4 5 位置的数据，如果不匹配，就需要替换，可以随机替换，也可以用 least recently used(LRU) 来进行替换。下面是一个具体的例子：</p>
<p><img src="/images/14556295742803.jpg" alt=""></p>
<p>可以看到因为每个 set 有 2 个 line，所以只有 2 个 set，set index 也只需要 1 位了，这个情况下即使 8 和 0 的 set index 一致，因为一个 set 可以容纳两个数据，所以最后一次访问 0，就不会 miss 了。</p>
<h2 id="u5199_u5165"><a href="#u5199_u5165" class="headerlink" title="写入"></a>写入</h2><p>在整个 memory hierarchy 中，不同的层级可能会存放同一个数据的不同拷贝（如 L1, L2, L3, 主内存, 硬盘）。如果发生写入命中的时候（也就是要写入的地址在缓存中有），有两种策略：</p>
<ul>
<li>Write-through: 命中后更新缓存，同时写入到内存中</li>
<li>Write-back: 直到这个缓存需要被指环出去，才写入到内存中（需要额外的 dirty bit 来表示缓存中的数据是否和内存中相同，因为可能在其他的时候内存中对应地址的数据已经更新，那么重复写入就会导致原有数据丢失）</li>
</ul>
<p>在写入 miss 的时候，同样有两种方式：</p>
<ul>
<li>Write-allocate: 载入到缓存中，并更新缓存（如果之后还需要对其操作，这个方式就比较好）</li>
<li>No-write-allocate: 直接写入到内存中，不载入到缓存 </li>
</ul>
<p>这四种策略通常的搭配是：</p>
<ul>
<li>Write-through + No-wirte-allocate</li>
<li>Write-back + Write-allocate</li>
</ul>
<p>其中第一种可以保证绝对的数据一致性，第二种效率会比较高（通常情况下）。</p>
<h2 id="u5B9E_u4F8B_u5B66_u4E60_uFF1AIntel_Core_i7"><a href="#u5B9E_u4F8B_u5B66_u4E60_uFF1AIntel_Core_i7" class="headerlink" title="实例学习：Intel Core i7"></a>实例学习：Intel Core i7</h2><p>Intel Core i7 的 cache hierarchy 如下图所示：</p>
<p><img src="/images/14556301866362.jpg" alt=""></p>
<p>我们通常用如下的指标来评价缓存的性能：</p>
<ul>
<li>Miss Rate<ul>
<li>1 - hit rate</li>
<li>对于 L1 来说一般 3-10%</li>
<li>对于 L2 来说很小 &lt; 1%</li>
<li>也就是说大部分时间堆数据的访问都是极快的</li>
</ul>
</li>
<li>Hit Time<ul>
<li>把 1 个 line 的缓存传输给处理器所用的时间，包括判断其是否在缓存中这个过程</li>
<li>对于 L1 来说一般 4 个时钟周期</li>
<li>对于 L2 来说一般 10 个时钟周期</li>
</ul>
</li>
<li>Miss Penalty<ul>
<li>因为 miss 所需要花费的额外时间</li>
<li>一般来说需要 50-200 个时钟周期（因为要读内存，而且由于处理器速度越来越快，这个时间还在增长）</li>
</ul>
</li>
</ul>
<p>从前面的数据中，我们可以看出，hit 和 miss 所需要的时间是天壤之别（只看 L1 和主存的话，可能差 100 倍）。</p>
<p>还有一个比较有意思的现象是，99% 的命中率，是 97% 的命中率的性能的两倍。举个例子，假设缓存命中时需要 1 个周期，而 miss penalty 是 100 个周期，那么</p>
<ul>
<li>97% hits: 1 cycle + 0.03 x 100 cycles = 4 cycles</li>
<li>99% hits: 1 cycle + 0.01 x 100 cycles = 2 cycles</li>
</ul>
<p>这也是为什么我们用 miss rate 而不是 hit rate，因为更能体现出倍数的关系。</p>
<h2 id="Memory_mountain"><a href="#Memory_mountain" class="headerlink" title="Memory mountain"></a>Memory mountain</h2><p>我们用每秒从内存中读入的字节数目来衡量内存的性能（单位 MB/s），根据 spatial 和 temporal locality 的特性，我们可以画出一幅立体的表现性能走向的图，具体用的测试代码为：</p>
<p><img src="/images/14556314610621.jpg" alt=""></p>
<p>可以得到这么一幅图</p>
<p><img src="/images/14556314890158.jpg" alt=""></p>
<p>注意，这是根据 Core i7 得出来的图，不同的处理器可能因为不同的设计和架构而有所区别，但是可以通过不同的颜色和层次，看出不同 size 和 stride 对性能的影响。山脚是我们应该尽量避免的，山顶是我们力求达到的，也就是说，尽量一次访问一个 stride，一次读入的数据大小也不宜太大，最好和 L1 缓存数值上吻合。</p>
<h2 id="u77E9_u9635_u76F8_u4E58"><a href="#u77E9_u9635_u76F8_u4E58" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h2><p>矩阵相乘是学习缓存非常好的例子，这里给出一些条件：</p>
<ul>
<li>两个 N x N 的矩阵相乘，N 非常大，所以可以认为 1/N 等于 0</li>
<li>矩阵的每个元素是 double，也就是 8 个字节</li>
<li>一共需要 $O(n^3)$ 次操作</li>
<li>源矩阵的每个元素需要被读入 N 次</li>
<li>目标矩阵的每个元素要被写入 N 次（相加），但是可以在寄存器中完成</li>
<li>缓存中每 1 个 line 的大小是 32 个字节（足够放下 4 个 double）</li>
<li>缓存可能至多能容纳矩阵的一行（甚至只能是一行的一部分）</li>
</ul>
<h3 id="u66F4_u6539_u5FAA_u73AF_u987A_u5E8F_u63D0_u9AD8_spatial_locality"><a href="#u66F4_u6539_u5FAA_u73AF_u987A_u5E8F_u63D0_u9AD8_spatial_locality" class="headerlink" title="更改循环顺序提高 spatial locality"></a>更改循环顺序提高 spatial locality</h3><p>一种算法是这样的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ijk */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            sum += a[i][k] * b[k][j];</span><br><span class="line">        c[i][j] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察里面的循环，大概的访问模式是这样的：</p>
<p><img src="/images/14556324266700.jpg" alt=""></p>
<p>因为 C 语言是根据行来分配数组内存的，所以按照列的顺序来访问，可以得到最好的 spatial locality。假设我们需要读入 N 个连续的字节，如果缓存的 block 大小为 B 个字节，那么实际上真正需要去内存中访问是 N/B 次（这种时候会 miss）。但是如果按照行来访问，每次都是跳着来，miss rate 就是百分之百。</p>
<p><img src="/images/14556327200253.jpg" alt=""></p>
<p>而 <code>ijk</code> 的访问模式，处理矩阵 A 的时候是按列访问的，因为这里设定一个 block 可以存放 4 个 double，读入每四个元素的情况下，我们只会在读入第一个 double 的时候 miss，所以对于矩阵 A 来说，内部的循环（就是 k 的那个循环）每次迭代平均会 miss 0.25 次（就是 1/4 次）。而访问矩阵 B 的时候，因为是按照行访问的，缓存实际上没有任何用，同样的条件下，每次迭代都会 miss。（我们还可以发现 <code>jik</code> 的访问模式和 <code>ijk</code> 很类似，这里略过）</p>
<p>但是如果换一下顺序，变成 <code>kij</code> 的访问模式，就会有不一样的变化，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kij */</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        r = a[i][k];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            c[i][j] += r * b[k][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的访问模式：</p>
<p><img src="/images/14556331411420.jpg" alt=""></p>
<p>可以看到对于矩阵 B 和 C 来说都是按照列访问的（就是横着），所以内循环中每次迭代只会 miss 0.25 次（<code>ikj</code> 的访问模式也是如此）</p>
<p>当然还可以使用 <code>jki</code> 或 <code>kji</code> 的访问模式，这种模式下对于矩阵 A 和 C 的访问都是按行访问的（就是竖着），内循环中每次迭代都会 miss 1 次，是很糟糕的</p>
<p>比较一下：</p>
<p><img src="/images/14556333212757.jpg" alt=""></p>
<p>就可以发现不同的访问模式会产生巨大的影响，下面的表格更加能说明问题：</p>
<p><img src="/images/14556334394809.jpg" alt=""></p>
<h3 id="u5229_u7528_blocking__u63D0_u9AD8_temporal_locality"><a href="#u5229_u7528_blocking__u63D0_u9AD8_temporal_locality" class="headerlink" title="利用 blocking 提高 temporal locality"></a>利用 blocking 提高 temporal locality</h3><p>还是矩阵相乘的例子，先看代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="keyword">double</span> *) <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>), n*n);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiply n x n matrices a and b */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmm</span><span class="params">(<span class="keyword">double</span> *a, <span class="keyword">double</span> *b, <span class="keyword">double</span> *c, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                c[i*n + j] += a[i*n + k] * b[k*n + j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们假设矩阵的元素是 double，缓存的每个 line 可以容纳 8 个 double，整个缓存的大小 C 远小于 n。</p>
<p>对应的访问模式为：</p>
<p><img src="/images/14556337275150.jpg" alt=""></p>
<p>进行计算的时候，对于矩阵 a，因为是一行一行读取的，在读取第一个 double 的时候，后面 7 个也会被载入缓存（miss 数目为 n/8），但是对于矩阵 b，因为是一列一列读取的，所以每次都需要更新缓存（miss 数目为 n）</p>
<p><img src="/images/14556342437811.jpg" alt=""></p>
<p>所以总的 miss 数目为：$\frac{9n}{8}\times n^2=\frac{9}{8}n^3$</p>
<p>但是如果我们把矩阵分成一块一块来计算，就会有不一样的效果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="keyword">double</span> *) <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>), n*n);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiply n x n matrices a and b */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmm</span><span class="params">(<span class="keyword">double</span> *a, <span class="keyword">double</span> *b, <span class="keyword">double</span> *c, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> i1, j1, k1;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i+=B)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j+=B)</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k+=B)</span><br><span class="line">            <span class="comment">/* B x B mini matrix multiplications */</span></span><br><span class="line">                <span class="keyword">for</span> (i1 = i; i1 &lt; i+B; i1++)</span><br><span class="line">                    <span class="keyword">for</span> (j1 = j; j1 &lt; j+B; j1++)</span><br><span class="line">                        <span class="keyword">for</span> (k1 = k; k1 &lt; k+B; k1++)</span><br><span class="line">                            c[i1*n+j1] += a[i1*n+k1] * b[k1*n + j1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是如下图所示：</p>
<p><img src="/images/14556343880865.jpg" alt=""></p>
<p>这里我们加一个条件，假设缓存中可以放下 3 个 Block，即 $3B^2 &lt; C$。</p>
<p><img src="/images/14556347788350.jpg" alt=""></p>
<p>那么在计算的时候，这三个 Block 其实都可以放到缓存中。对于每个 Block 来说，一共有 $B^2$ 个元素，8 个元素会 miss 一次，所以一共会 miss $\frac{B^2}{8}$ 次。而一次完整的计算（指算完整行乘以整列），矩阵 a 和 b 都需要读入 $\frac{n}{B}$ 个 block，所以总的 miss 数目是 $\frac{2n}{B}\times \frac{B^2}{8} = \frac{nB}{4}$（这里的 2n 是因为矩阵 a 和 b 各有 n/B 个 Block）。</p>
<p>而对于整个矩阵 c 来说，一共有 $(\frac{n}{B})^2$ 个 block，所以整个计算过程的 miss 数目为：</p>
<p>$$\frac{nB}{4}\times (\frac{n}{B})^2 = \frac{n^3}{4B}$$</p>
<p>比较一下，一个是 $\frac{9}{8} n^3$，另一个是 $\frac{1}{4B} n^3$，有巨大的差异！，但是需要保证的就是 $3B^2 &lt; C$（所以需要针对机器进行调整）</p>
<p>总结下</p>
<ul>
<li>Cache memories 对性能会有极大的影响</li>
<li>写代码的时候可以考虑<ul>
<li>关注内循环，尤其是访问元素的顺序和方向</li>
<li>以 stride 1 的顺序来访问可以最大化 spatial locality</li>
<li>尽可能多利用读入的数据（重复使用）来最大化 temporal locality</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一讲我们了解了存储的相关知识，这节课我们来更加深入研究一下 cache memory 的知识。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="缓存" scheme="http://wdxtub.com/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
