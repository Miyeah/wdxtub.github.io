<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-03-20T03:32:44.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 19 课 Dynamic Memory Allocation - Advanced Concept]]></title>
    <link href="http://wdxtub.com/2016/03/19/csapp-19/"/>
    <id>http://wdxtub.com/2016/03/19/csapp-19/</id>
    <published>2016-03-19T21:32:34.000Z</published>
    <updated>2016-03-20T03:32:44.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们来看看关于内存分配的延伸话题，包括更加复杂的选择机制以及垃圾回收等相关内容。</p>
<a id="more"></a>
<hr>
<p>这节课主要介绍后面三种方法，都是用来记录未分配空间的，具体如下：</p>
<p><img src="/images/14584386982186.jpg" alt="Keeping Track of Free Blocks"></p>
<h2 id="u663E_u5F0F_free__u5217_u8868"><a href="#u663E_u5F0F_free__u5217_u8868" class="headerlink" title="显式 free 列表"></a>显式 free 列表</h2><p>主要的改动在于，只记录 free block，而不是所有的 block。因为是指针，所以不仅需要记录后一个也需要记录前一个；与此同时，仍然需要 boundary tag 来作为合并的辅助信息。具体的结构如下：</p>
<p><img src="/images/14584389197608.jpg" alt="Explicit Free Lists"></p>
<p>因为是指针，逻辑上是连续的，但实际上可以是无序的，如下图：</p>
<p><img src="/images/14584389533544.jpg" alt="Logically vs Physically"></p>
<p>分配空间的过程就是指针重新指向的过程：</p>
<p><img src="/images/14584389995555.jpg" alt="Allocating From Explicit Free Lists"></p>
<p>然后我们来看看，当释放空间的时候，具体要把刚释放的 block，放在列表中的哪个位置呢？有两种策略：后入先出或按照地址排序。</p>
<p><img src="/images/14584390706378.jpg" alt="Freeing With Explicit Free Lists"></p>
<p>接下来是 LIFO 策略的几个不同的情况，灰色表示已经分配的空间：</p>
<p>Case 1</p>
<p><img src="/images/14584391317448.jpg" alt="Case 1"></p>
<p>Case 2</p>
<p><img src="/images/14584391482644.jpg" alt="Case 2"></p>
<p>Case 3</p>
<p><img src="/images/14584391607445.jpg" alt="Case 3"></p>
<p>Case 4</p>
<p><img src="/images/14584391818093.jpg" alt="Case 4"></p>
<p>总结一下，与隐式列表相比</p>
<ul>
<li>因为只记录 free block，在内存几乎满的时候效率很高</li>
<li>因为需要切分 block 以及维护列表，所以稍微复杂一点</li>
<li>对于每个链接来说需要 2 个额外的 word 来记录前面一个 free block 和后面一个 free block</li>
</ul>
<h2 id="Segregated_free__u5217_u8868"><a href="#Segregated_free__u5217_u8868" class="headerlink" title="Segregated free 列表"></a>Segregated free 列表</h2><blockquote>
<p>Most common use of linked lists is in conjunction with segregated free lists. Keep multiple linked lists of different size classes, or possibly for different types of objects.</p>
</blockquote>
<p>也就是说，每个不同大小 block 会在不同的列表里，对于较小的 size，一般会有单独的列表，对于稍大的 size，列表的范围也会更大，如下图所示：</p>
<p><img src="/images/14584404151349.jpg" alt="Each size class of blocks has its own free list"></p>
<p>要分配一个大小为 n 的 block：</p>
<ul>
<li>搜索比 n 大的 free list 列表</li>
<li>如果找到了合适的，切分 block 并且把剩余的放到对应的列表中（可选）</li>
<li>如果没有合适的 block，找更大的 size</li>
<li>重复上述过程，直到找到为止</li>
</ul>
<p>如果确实找不到：</p>
<ul>
<li>向系统请求额外的堆内存（使用 <code>sbrk()</code>）</li>
<li>在新的内存中分配对应的空间</li>
<li>把剩余的空间放到最大 size 的列表中</li>
</ul>
<p>释放空间时：</p>
<ul>
<li>合并 block 并放到对应的列表中</li>
</ul>
<p>Seglist allocator 的优势：</p>
<ul>
<li>更高的吞吐量(log time for power-of-two size classes)</li>
<li>更好的内存利用率<ul>
<li>First-fit search of segregated free list approximates a best-fit search of entire heap</li>
<li>Extreme case: Giving each block its own size class is equivalent to best-fit</li>
</ul>
</li>
</ul>
<h2 id="u5783_u573E_u56DE_u6536"><a href="#u5783_u573E_u56DE_u6536" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>所谓垃圾回收，就是我们不再需要显式释放所申请内存空间了，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* p block is now garbage*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种机制在许多动态语言中都有实现：Python, Ruby, Java, Perl, ML, Lisp, Mathematica。C 和 C++ 中也有类似的变种，但是需要注意的是，是不可能回收所有的垃圾的。</p>
<p>我们如何知道什么东西才是『垃圾』呢？简单！只要没有任何指针指向的地方，不管有没有用，因为都不可能被使用，当然可以直接清理掉啦。不过这其实是需要一些前提条件的：</p>
<ul>
<li>我们可以知道哪里是指针，哪里不是指针</li>
<li>每个指针都指向 block 的开头</li>
<li>指针不能被隐藏(by coercing them to an <code>int</code>, and then back again)</li>
</ul>
<p>相关的算法如下：</p>
<p><img src="/images/14584417083434.jpg" alt="Classical GC Algorithms"></p>
<p>这里我们主要讨论第一种 Mark-and-sweep collection 算法（居然已经有五十多年的历史了）</p>
<p>内存具体的分布，可以看做是一个有向图，每个 block 相当于一个节点，每个指针相当于一条边。那些不在堆中的且指向堆的指针称为根节点（如寄存器，栈，全局变量等），如下图所示：</p>
<p><img src="/images/14584420668262.jpg" alt="Memory as a Graph"></p>
<h3 id="Mark_and_Sweep_Collecting"><a href="#Mark_and_Sweep_Collecting" class="headerlink" title="Mark and Sweep Collecting"></a>Mark and Sweep Collecting</h3><p>这个机制可以在 malloc/free 的基础上实现。当空间不够的时候， 在每个 block 的头部增加一个额外的 mark bit。</p>
<ul>
<li>Mark: Start at roots and set mark bit on each reachable block</li>
<li>Sweep: Scan all blocks and free blocks that are not marked</li>
</ul>
<p>整个过程如下：</p>
<p><img src="/images/14584422740964.jpg" alt="Mark and Sweep Collecting"></p>
<p>一个简易实现的思路：</p>
<p><img src="/images/14584424812466.jpg" alt="Assumptions For a Simple Iimplementation"></p>
<p>代码如下：</p>
<p><img src="/images/14584426898133.jpg" alt=""></p>
<p>在 C 语言中，我们可以使用 <code>is_ptr()</code> 来判断是否为指针，但我们也知道，C 指针可能指向 block 的中间，这个时候我们要如何找到 block 的开头呢？</p>
<p><img src="/images/14584429046281.jpg" alt="指向中间"></p>
<p> 可以这么做</p>
<ul>
<li>Can use a balanced binary tree to keep track of all allocated blocks (key is start-of-block)</li>
<li>Balanced-tree pointers can be stored in header (use two additional words)</li>
</ul>
<p><img src="/images/14584429821424.jpg" alt="存储结构"></p>
<h2 id="u5185_u5B58_u76F8_u5173_u9677_u9631"><a href="#u5185_u5B58_u76F8_u5173_u9677_u9631" class="headerlink" title="内存相关陷阱"></a>内存相关陷阱</h2><p>关于内存的使用需要注意避免以下问题：</p>
<ul>
<li>Dereferencing bad pointers</li>
<li>Reading uninitialized memory</li>
<li>Overwriting memory</li>
<li>Referencing nonexistent variables</li>
<li>Freeing blocks multiple times</li>
<li>Referencing freed blocks</li>
<li>Failing to free blocks</li>
</ul>
<p>具体看上述问题前，我们先来了解 C 语言中操作符的顺序以及优先级：</p>
<p><img src="/images/14584431989892.jpg" alt="C operators"></p>
<p>下面是一些例子，一定要好好理解（指针什么的真的头疼）</p>
<p><img src="/images/14584433625063.jpg" alt="C Pointer Declarations"></p>
<h3 id="Dereferencing_Bad_Pointers"><a href="#Dereferencing_Bad_Pointers" class="headerlink" title="Dereferencing Bad Pointers"></a>Dereferencing Bad Pointers</h3><p>这是非常常见的例子，没有引用对应的地址，少了 <code>&amp;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, val);</span><br></pre></td></tr></table></figure>
<h3 id="Reading_Uninitialized_Memory"><a href="#Reading_Uninitialized_Memory" class="headerlink" title="Reading Uninitialized Memory"></a>Reading Uninitialized Memory</h3><p>不能假设堆中的数据会自动初始化为 0，下面的代码就会出现奇怪的问题</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* return y = Ax */</span><br><span class="line">int *matvec(int **A, int *x) &#123;</span><br><span class="line">    int *y = malloc(N * sizeof(int));</span><br><span class="line">    int i, j;</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; N; i++)</span><br><span class="line">        for (j = 0; j &lt; N; j++)</span><br><span class="line">            y[i] += A[i][j] * x[j];</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Overwriting_Memory"><a href="#Overwriting_Memory" class="headerlink" title="Overwriting Memory"></a>Overwriting Memory</h3><p>这里有挺多问题，第一种是分配了错误的大小，下面的例子中，一开始不能用 <code>sizeof(int)</code>，因为指针的长度不一定和 int 一样。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int **p;</span><br><span class="line">p = malloc(N * sizeof(int));</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; N; i++) </span><br><span class="line">    p[i] = malloc(M * sizeof(int));</span><br></pre></td></tr></table></figure>
<p>第二个问题是超出了分配的空间，下面代码的 for 循环中，因为使用了 <code>&lt;=</code>，会写入到其他位置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int **p;</span><br><span class="line"></span><br><span class="line">p = malloc(N * sizeof (int *));</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt;= N; i++)</span><br><span class="line">    p[i] = malloc(M * sizeof(int));</span><br></pre></td></tr></table></figure>
<p>第三种是因为没有检查字符串的长度，超出部分就写到其他地方去了（经典的缓冲区溢出攻击也是利用相同的机制）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">gets(s); <span class="comment">/* reads "123456789" from stdin */</span></span><br></pre></td></tr></table></figure>
<p>第四种是没有正确理解指针的大小以及对应的操作，应该使用 <code>sizeof(int *)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">search</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*p &amp;&amp; *p != null)</span><br><span class="line">        p += <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第五种是引用了指针，而不是其指向的对象，下面的例子中，<code>*size--</code> 一句因为 <code>--</code> 的优先级比较高，所以实际上是对指针进行了操作，正确的应该是 <code>(*size)--</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">BinheapDelete</span><span class="params">(<span class="keyword">int</span> **binheap, <span class="keyword">int</span> *size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *packet;</span><br><span class="line">    packet = binheap[<span class="number">0</span>];</span><br><span class="line">    binheap[<span class="number">0</span>] = binheap[*size - <span class="number">1</span>];</span><br><span class="line">    *size--;</span><br><span class="line">    Heapify(binheap, *size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Referencing_Nonexistent_Variables"><a href="#Referencing_Nonexistent_Variables" class="headerlink" title="Referencing Nonexistent Variables"></a>Referencing Nonexistent Variables</h3><p>下面的情况中，没有注意到局部变量会在函数返回的时候失效（所以对应的指针也会无效），这是传引用和返回引用需要注意的，传值的话则不用担心</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Freeing_Blocks_Multiple_Times"><a href="#Freeing_Blocks_Multiple_Times" class="headerlink" title="Freeing Blocks Multiple Times"></a>Freeing Blocks Multiple Times</h3><p>这个不用多说，不能重复搞两次</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = malloc(N * sizeof(int));</span><br><span class="line">//  &lt;manipulate x&gt;</span><br><span class="line">free(x);</span><br><span class="line"></span><br><span class="line">y = malloc(M * sizeof(int));</span><br><span class="line">//  &lt;manipulate y&gt;</span><br><span class="line">free(x);</span><br></pre></td></tr></table></figure>
<h3 id="Referencing_Freed_Blocks"><a href="#Referencing_Freed_Blocks" class="headerlink" title="Referencing Freed Blocks"></a>Referencing Freed Blocks</h3><p>同样是很明显的错误，不要犯</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = malloc(N * sizeof(int));</span><br><span class="line">//  &lt;manipulate x&gt;</span><br><span class="line">free(x);</span><br><span class="line">//  ....</span><br><span class="line"></span><br><span class="line">y = malloc(M * sizeof(int));</span><br><span class="line">for (i = 0; i &lt; M; i++)</span><br><span class="line">    y[i] = x[i]++;</span><br></pre></td></tr></table></figure>
<h3 id="Memory_Leaks"><a href="#Memory_Leaks" class="headerlink" title="Memory Leaks"></a>Memory Leaks</h3><p>用完没有释放，就是内存泄露啦</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo() &#123;</span><br><span class="line">    int *x = malloc(N * sizeof(int));</span><br><span class="line">    // ...</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者只释放了数据结构的一部分：</p>
<p><img src="/images/14584447178117.jpg" alt="Freeing only part of a data structure"></p>
<h3 id="u5BF9_u7B56"><a href="#u5BF9_u7B56" class="headerlink" title="对策"></a>对策</h3><p>我们可以使用下面的工具和方法来处理内存的 bug</p>
<p><img src="/images/14584447590453.jpg" alt="Dealing With Memory Bugs"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们来看看关于内存分配的延伸话题，包括更加复杂的选择机制以及垃圾回收等相关内容。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="内存分配" scheme="http://wdxtub.com/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 18 课 Dynamic Memory Allocation - Basic Concept]]></title>
    <link href="http://wdxtub.com/2016/03/19/csapp-18/"/>
    <id>http://wdxtub.com/2016/03/19/csapp-18/</id>
    <published>2016-03-19T21:32:26.000Z</published>
    <updated>2016-03-20T00:16:19.000Z</updated>
    <content type="html"><![CDATA[<p>前面了解了虚拟内存的相关知识，这节课我们来看看动态内存分配的基本概念，相信这之后就知道诸如 <code>malloc</code> 和 <code>new</code> 这类方法是怎么做的了。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u7840_u6982_u5FF5"><a href="#u57FA_u7840_u6982_u5FF5" class="headerlink" title="基础概念"></a>基础概念</h2><p>程序员通过动态内存分配（例如 <code>malloc</code>）来让程序在运行时得到虚拟内存。动态内存分配器会管理一个虚拟内存区域，称为堆(heap)，如下图所示：</p>
<p><img src="/images/14584238419962.jpg" alt="Dynamic Memory Allocation"></p>
<p>分配器以 block 为单位来维护 heap，可以进行 allocate 或 free。有两种类型的分配器：</p>
<ul>
<li>显式分配器：应用分配并且回收空间（C 语言中的 <code>malloc</code> 和 <code>free</code>）</li>
<li>隐式分配器：应用只负责分配，但是不负责回收（Java 中的垃圾收集）</li>
</ul>
<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>我们来看看 <code>malloc</code> 函数：</p>
<p><img src="/images/14584242618725.jpg" alt="The malloc Package"></p>
<p>一个简单的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void foo(int n) &#123;</span><br><span class="line">    int i, *p;</span><br><span class="line">    </span><br><span class="line">    /* Allocate a block of n ints */</span><br><span class="line">    p = (int *) malloc(n * sizeof(int));</span><br><span class="line">    if (p == NULL) &#123;</span><br><span class="line">        perror("malloc");</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* Initialize allocated block */</span><br><span class="line">    for (i=0; i&lt;n; i++)</span><br><span class="line">        p[i] = i;</span><br><span class="line"></span><br><span class="line">    /* Return allocated block to the heap */</span><br><span class="line">    free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这节课中，为了讲述方便，我们做如下假设：</p>
<ul>
<li>Memory is word addressed</li>
<li>Words are int-sized</li>
</ul>
<p><img src="/images/14584252386542.jpg" alt="Assumptions Made in This Lecture"></p>
<p>具体的例子：</p>
<p><img src="/images/14584253826838.jpg" alt="Allocation Example"></p>
<p>程序可以用任意的顺序发送 <code>malloc</code> 和 <code>free</code> 请求，<code>free</code> 请求必须作用与已被分配的 block。</p>
<p>分配器有如下的限制：</p>
<ul>
<li>不能控制已分配 block 的数量和大小</li>
<li>必须立即响应 <code>malloc</code> 请求（不能缓存或者给请求重新排序）</li>
<li>必须在未分配的内存中分配</li>
<li>不同的 block 需要对齐（32 位中 8 byte，64 位中 16 byte）</li>
<li>只能操作和修改未分配的内存</li>
<li>不能移动已分配的 block</li>
</ul>
<h2 id="u6027_u80FD_u6307_u6807"><a href="#u6027_u80FD_u6307_u6807" class="headerlink" title="性能指标"></a>性能指标</h2><p>现在我们可以来看看如何去评测具体的分配算法了。假设给定一个 <code>malloc</code> 和 <code>free</code> 的请求的序列：</p>
 $$R_0, R_1, ..., R_k, ..., R_{n-1}$$ 
<p>目标是尽可能提高吞吐量以及内存利用率（注意，这两个目标常常是冲突的）</p>
<p>吞吐量是在单位时间内完成的请求数量。假设在 10 秒中之内进行了 5000 次 <code>malloc</code> 和 5000 次 <code>free</code> 调用，那么吞吐量是 1000 operations/second</p>
<p>另外一个目标是 Peak Memory Utilization，就是最大的内存利用率，具体如下：</p>
<p><img src="/images/14584265326302.jpg" alt="Peak Memory Utilization"></p>
<p>影响内存利用率的主要因素就是『内存碎片』，有两种类型：</p>
<ul>
<li>internal fragmentation</li>
<li>external fragmentation0</li>
</ul>
<h3 id="u5185_u90E8_u788E_u7247"><a href="#u5185_u90E8_u788E_u7247" class="headerlink" title="内部碎片"></a>内部碎片</h3><p>对于给定的 block，internal fragmentation 主要是因为 payload 小于 block size 造成的，如下图所示：</p>
<p><img src="/images/14584268109274.jpg" alt="internal fragmentation"></p>
<p>主要是由以下原因导致；</p>
<ul>
<li>Overhead of maintaining heap data structures</li>
<li>Padding for alignment purposes</li>
<li>Explicit policy decisions</li>
</ul>
<p>只依赖于上一个请求的具体模式，所以比较容易测量。</p>
<h3 id="u5916_u90E8_u788E_u7247"><a href="#u5916_u90E8_u788E_u7247" class="headerlink" title="外部碎片"></a>外部碎片</h3><p>指的是内存中没有足够的连续空间，如下图所示：</p>
<p><img src="/images/14584269418830.jpg" alt="External Fragmentation"></p>
<p>依赖于未来的请求模式，所以比较难测量。</p>
<h3 id="u5B9E_u73B0_u7EC6_u8282"><a href="#u5B9E_u73B0_u7EC6_u8282" class="headerlink" title="实现细节"></a>实现细节</h3><p>在具体实现之前，需要考虑以下问题：</p>
<ul>
<li>给定一个指针，我们如何知道需要释放多少内存？</li>
<li>如何记录未分配的 block ？</li>
<li>实际需要的空间比未分配的空间要小的时候，剩下的空间怎么办？</li>
<li>如果有多个区域满足条件，如何选择？</li>
<li>释放空间之后如何进行记录？</li>
</ul>
<p>一个标准的方式是在指针的前一个  word 中保存 block 的大小，通常称之为 header field 或 header，这种方式需要额外的一个 word，具体如下：</p>
<p><img src="/images/14584273450722.jpg" alt="Standard method"></p>
<p>这里我们先给出常用的四种方式，这节课主要介绍第一种，下节课会介绍后面的方法：</p>
<p><img src="/images/14584273923045.jpg" alt="Keeping Track of Free Blocks"></p>
<h2 id="u9690_u5F0F_free__u5217_u8868"><a href="#u9690_u5F0F_free__u5217_u8868" class="headerlink" title="隐式 free 列表"></a>隐式 free 列表</h2><p>对于每个 block 来说，我们需要知道大小和具体的状态（已分配/未分配），可以用两个 word 来存储，但是这样太浪费了。</p>
<p>如果一个 block 已经对其，低位地址一定是 0，所以我们可以用来当做 allocated/free 标志，当读入 word 大小的时候，需要标记出这个值。</p>
<p><img src="/images/14584304354717.jpg" alt="Implicit List"></p>
<p><img src="/images/14584304662424.jpg" alt="Detailed Implicit Free List Example"></p>
<p>寻找未分配的空间的方式如下，主要有三种：</p>
<p><img src="/images/14584305912848.jpg" alt="Finding a Free Block"></p>
<p>确定空间之后，具体进行分配如下：</p>
<p><img src="/images/14584306987840.jpg" alt="Allocating in Free Block"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addblock</span><span class="params">(ptr p, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newsize = ((len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;  <span class="comment">// round up to even</span></span><br><span class="line">    <span class="keyword">int</span> oldsize = *p &amp; -<span class="number">2</span>;                <span class="comment">// mask out low bit</span></span><br><span class="line">    *p = newsize | <span class="number">1</span>;                     <span class="comment">// set new length</span></span><br><span class="line">    <span class="keyword">if</span> (newsize &lt; oldsize)</span><br><span class="line">        *(p+newsize) = oldsize - newsize; <span class="comment">// set length in remaining</span></span><br><span class="line">                                          <span class="comment">// part of block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在释放空间的时候如果 block 后面也是未分配的空间，只做基本的处理的话，会出现有足够的位置，但是因为多余的分隔而找不到对应的位置，如下所示：</p>
<p><img src="/images/14584314075261.jpg" alt="Freeing a Block"></p>
<p>解决的办法是 Coalescing：</p>
<p><img src="/images/14584314805605.jpg" alt="coalesce"></p>
<p>另一种方法是双向 coalescing：</p>
<p><img src="/images/14584318651163.jpg" alt="Bidirectional Coalescing"></p>
<p>具体 coalescing 的时候有四种情况：</p>
<p><img src="/images/14584319803616.jpg" alt="Constant Time Coalescing"></p>
<p>下面是四种情况的：</p>
<p>Case 1：</p>
<p><img src="/images/14584322811295.jpg" alt="Case 1"></p>
<p>Case 2：</p>
<p><img src="/images/14584322969946.jpg" alt="Case 2"></p>
<p>Case 3：</p>
<p><img src="/images/14584323407555.jpg" alt="Case 3"></p>
<p>Case 4：</p>
<p><img src="/images/14584323554767.jpg" alt="Case 4"></p>
<p>Boundary Tags 的坏处就是会导致 internal fragmentation。</p>
<p>总结一下：</p>
<p><img src="/images/14584328927396.jpg" alt="Summary of Key Allocator Policies"></p>
<p>最后是 implicit list 的总结：</p>
<p><img src="/images/14584329366933.jpg" alt="Implicit Lists: Summary"></p>
<p>总体来说这一部分还是比较简单的，虽然简单，但是一定要理解清楚，因为下节课会介绍更加复杂的机制。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面了解了虚拟内存的相关知识，这节课我们来看看动态内存分配的基本概念，相信这之后就知道诸如 <code>malloc</code> 和 <code>new</code> 这类方法是怎么做的了。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="内存分配" scheme="http://wdxtub.com/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第十周 - Deacon Blue]]></title>
    <link href="http://wdxtub.com/2016/03/18/deacon-blue/"/>
    <id>http://wdxtub.com/2016/03/18/deacon-blue/</id>
    <published>2016-03-19T02:37:13.000Z</published>
    <updated>2016-03-19T11:55:43.000Z</updated>
    <content type="html"><![CDATA[<p>You can’t control what life presents. Keep it moving man, one day you’ll make it through.</p>
<a id="more"></a>
<hr>
<p>不知不觉就来到了第十周，回顾上个学期的周记，清楚地意识到，恐怕再写六周，就真的要告别『校园生活』了。没有太多不舍，因为已经尽力去体验了校园中的各种角色；没有太多遗憾，因为很多事情已经做到了足够好；甚至没有太多期待，人来人往，熙熙攘攘，桃源室外，锦城何在？</p>
<p>万万没想到，记录一下对于课程的理解，翻译一下逻辑混乱语句不同的课程资料，竟收到了老师的『警告』：因为涉及题目的思路以及相关课程内容，必须把相关日志都删掉，否则老师很生气，后果很严重。我其实没有任何选择，人在屋檐下，不得不低头，二十多篇很用心写的日志不得不『消失』，虽有些气不过，但是更多的是失望。既然都写到这儿了，一不做二不休，来说说所谓的『老师』，和所谓的『课程』：</p>
<ol>
<li>我不知道老师到底干了啥，如果他真的有看课程资料的话，是如何容忍毫无逻辑且经常前后矛盾的作业说明的？</li>
<li>我不知道助教到底是为啥一肚子坏水，说明写得不清不楚就算了，样例代码写得像下水道大学出来的一样就算了，但是拿着鸡毛当令箭真的好吗？</li>
<li>我不知道作业中为啥老师和助教工作的不严谨，要让全体同学的时间来买单，很多明显是故意设置出来『浪费』大家时间的设定，我真心觉得这已经背离了『传道授业解惑』的范畴？</li>
</ol>
<p>日志就是我的武器，用重新组织的逻辑清晰的描述完备的文字，让大家尽可能明白每次的作业到底是要做什么，把时间节约起来，去做自己真正想做的事情。然而这个不知道在哪『梦游』的老师直接用行政压力让我缴械。势单力薄，除了投降我还能做什么？</p>
<p>缺乏基本的语文能力是理工科学生的通病，又或者因为平时的生活学习节奏压根没有太多的表达训练，我真的真的遇到了太多哭笑不得的沟通障碍。举个例子，一旦走到专业之外，文化的范畴中，很多人就成了盲人。他们感受不到不同词汇不同句法背后蕴藏的深意，他们不去思考专业外的东西，眼中只有短期目标，一旦视线离开这个点，就成了无头苍蝇。</p>
<p>跟六七十岁的教授讨论起文化、哲学、历史相关的话题，才真正有『沟通』的体验：一点即通，不会在细枝末节上浪费太多精力；一针见血，直接把最核心的问题拿出来打磨讨论，用思考来切磋。</p>
<p>最近一直在玩《合金装备 5：幻痛》，整个剧情及世界观的设定和《白鲸记》《一九八四》以及《蝇王》有非常深的联系，跟同学聊起，没有人读过这些书，根本没办法进入游戏理念已经具体通过游戏来表达想法的技术讨论。</p>
<p>这真的是很痛苦的事情。聊得来是非常高的标准，至少需要双方有同等水平的思维能力。</p>
<p>最近也慢慢进入了找到工作互相请客的状态，看着大家一路坚持过来到最终实现自己的目标，我还是很开心的。借由自己的疏离感带来的观察，更加深刻理解了『性格即命运』。</p>
<p>各种各样的性格，面对问题的时候也有各种各样的解法。从我的角度来说，除了一种人需要远离之外，其他怎么折腾都行。</p>
<blockquote>
<p>远离那些野心很大，自己却配不上这份野心的人。</p>
</blockquote>
<p>他们是最可能放弃一切尊严和道德，用力把你拉下水或者会为了一丁点微不足道的东西铤而走险的人。</p>
<p>估计是因为没睡够的缘故，整篇周记的风格竟然成了这样，最后当然还是要 look on the bright side。</p>
<p>很久没有聊过这么久的电话，即使特别困也想要多说两句，高质量的沟通真的是非常愉快的事情，找到加速度差不多的人真的不容易。</p>
<p>最后说一句，AI 能取代的终究是那些思维强度太低的人，最好的做法就是多读多写多思考，人类在推动技术发展的同时，技术也在引导着人类进步的方向，跟不上时代的注定要淘汰，物竞天择，优胜劣汰。</p>
<p>Set your goal high. Be sure to stay true.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>You can’t control what life presents. Keep it moving man, one day you’ll make it through.</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="变化" scheme="http://wdxtub.com/tags/%E5%8F%98%E5%8C%96/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="春天" scheme="http://wdxtub.com/tags/%E6%98%A5%E5%A4%A9/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 17 课 Virtual Memory - System]]></title>
    <link href="http://wdxtub.com/2016/03/18/csapp-17/"/>
    <id>http://wdxtub.com/2016/03/18/csapp-17/</id>
    <published>2016-03-18T13:48:57.000Z</published>
    <updated>2016-03-19T02:21:36.000Z</updated>
    <content type="html"><![CDATA[<p>了解了基本的虚拟内存概念，这节课我们来具体看看 Core i7 和 Linux 的内存系统，相信会对虚拟内存这一套机制有更深刻的认识。</p>
<a id="more"></a>
<hr>
<p>开始之前我们还是先复习一下基本的概念：</p>
<p><img src="/images/14583183552533.jpg" alt="Review of Symbols"></p>
<h2 id="u5730_u5740_u7FFB_u8BD1_u5B9E_u4F8B"><a href="#u5730_u5740_u7FFB_u8BD1_u5B9E_u4F8B" class="headerlink" title="地址翻译实例"></a>地址翻译实例</h2><p>然后来看一个简单的例子：</p>
<ul>
<li>14 位的虚拟地址</li>
<li>12 位的物理地址</li>
<li>page size 为 64 字节</li>
</ul>
<p>如下图所示</p>
<p><img src="/images/14583359973808.jpg" alt="Addressing"></p>
<p>TLB 的配置为：</p>
<ul>
<li>16 entries</li>
<li>4-way associative</li>
</ul>
<p>如下图所示</p>
<p><img src="/images/14583376303817.jpg" alt="TLB"></p>
<p>然后来看看 page table，一共有 256 个 entry，这里列出前 16 个：</p>
<p><img src="/images/14583376858566.jpg" alt="Page Table"></p>
<p>最后来看看系统本身缓存：</p>
<ul>
<li>16 lines, 4-byte block size</li>
<li>Physically addressed</li>
<li>Direct mapped</li>
</ul>
<p><img src="/images/14583377349696.jpg" alt="Cache"></p>
<p>一定要注意好不同部分的所代表的位置，这里我也会尽量写得清楚一些，来看第一个例子：</p>
<blockquote>
<p>虚拟地址为 <code>0x03D4</code></p>
</blockquote>
<p>具体的转换过程如下图所示：</p>
<p><img src="/images/14583479163395.jpg" alt="第一个例子"></p>
<p>具体来梳理一次：</p>
<p>先看 TLB 中有没有对应的条目，所以先看虚拟地址的第 6-13 位，在前面的 TLB 表中，根据 TLBI 为 3 这个信息，去看这个 set 中有没有 tag 为 3 的项目，发现有，并且对应的 PPN 是 0x0D，所以对应到物理地址，就是 PPN 加上虚拟地址的 0-5 位，而具体的物理地址又可以在缓存中找到（利用 cache memory 的机制），就可以获取到对应的数据了。</p>
<p>下面的例子同样可以按照这个方法来进行分析</p>
<p><img src="/images/14583493888490.jpg" alt="第二个例子"></p>
<h2 id="u6848_u4F8B_u5B66_u4E60_uFF1ACore_i7"><a href="#u6848_u4F8B_u5B66_u4E60_uFF1ACore_i7" class="headerlink" title="案例学习：Core i7"></a>案例学习：Core i7</h2><p>我们先来看看整体的架构</p>
<p><img src="/images/14583495456299.jpg" alt="Intel Core i7 Memory System"></p>
<p>这里先留意一点，为什么 L1 d-cache 比上 L2 unified cache，和 L1 d-TLB 比上 L2 unified TLB 的比例一样呢？</p>
<p><img src="/images/14583500587332.jpg" alt="End-to-end Core i7 Address Translation"></p>
<p>可以清楚地看到，从 TLB 到 Page table 以及对应 cache 的转换，结合上面的说明仔细体会下。接下来的内容比较偏理论，大家有一个基本的认识即可（因为平时编程理论上也不会涉及到这些）</p>
<p>Core i7 有 4 层的 page table，前 3 层的结构一样，如下图所示</p>
<p><img src="/images/14583503794880.jpg" alt="Core i7 Level 1-3 Page Table Entries"></p>
<p>第四层有少许不同，具体看下面的说明：</p>
<p><img src="/images/14583505732854.jpg" alt="Core i7 Level 4 Page Table Entries"></p>
<p>具体的翻译过程为：</p>
<p><img src="/images/14583506241439.jpg" alt="Core i7 Page Table Translation"></p>
<p>接下来就可以回答前面的问题了，为啥是成比例的呢？原因很简单！用来加速 L1 的访问！</p>
<blockquote>
<p>Virtually indexed, physically tagged</p>
</blockquote>
<p><img src="/images/14583509113693.jpg" alt="Cute Trick for Speeding Up L1 Access"></p>
<h2 id="u6848_u4F8B_u5B66_u4E60_uFF1ALinux_Process"><a href="#u6848_u4F8B_u5B66_u4E60_uFF1ALinux_Process" class="headerlink" title="案例学习：Linux Process"></a>案例学习：Linux Process</h2><p>这一部分也是了解一下即可（具体可以不用太深究）</p>
<p><img src="/images/14583511838723.jpg" alt="Virtual Address Space of a Linux Process"></p>
<p>Linux 以不同的『区域』来组织虚拟内存</p>
<p><img src="/images/14583514430157.jpg" alt="Linux Organizes VM as Collection of &quot;Areas&quot;"></p>
<p>下面是处理 page fault 的机制：</p>
<p><img src="/images/14583519002966.jpg" alt="Linux Page Fault Handling"></p>
<h2 id="u5185_u5B58_u6620_u5C04"><a href="#u5185_u5B58_u6620_u5C04" class="headerlink" title="内存映射"></a>内存映射</h2><p>初始化虚拟内存的过程，实际上就是把对应的虚拟内存和磁盘上的对象关联起来的过程，称之为内存映射(memory mapping)</p>
<p><img src="/images/14583529040142.jpg" alt=""></p>
<p>Linux 中所谓的『交换分区』就是这么来的（我估计）</p>
<p><img src="/images/14583530219645.jpg" alt="Shared Objects"></p>
<ul>
<li>Process 1 maps the shared object</li>
<li>Process 2 maps the shared object</li>
<li>Two processes mapping a <strong>private copy-on-write(COW)</strong> object</li>
<li>Area flagged as private copy-on-write</li>
<li>PTEs in private areas are flagged as read-only</li>
</ul>
<p><img src="/images/14583530323902.jpg" alt="Private Copy-on-write(COW) Objects"></p>
<ul>
<li>Instruction writing to private page triggers protection fault</li>
<li>Handler creates new R/W page</li>
<li>Instruction restarts upon handler return</li>
<li>Copying deferred as long as possible!</li>
</ul>
<p>Fork 函数就是这种机制的一个很好的例子：</p>
<p><img src="/images/14583534506790.jpg" alt="The `fork` Function"></p>
<p>接着来看看 <code>execve</code> 函数</p>
<p><img src="/images/14583535882515.jpg" alt="The `execve` Function"></p>
<p>最后介绍了 <code>mmap</code> 函数，这里不赘述了。</p>
<p>这一部分比较偏向实际，主要还是要理解虚拟内存的机制（具体现代的处理器和操纵系统已经『太』复杂了）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解了基本的虚拟内存概念，这节课我们来具体看看 Core i7 和 Linux 的内存系统，相信会对虚拟内存这一套机制有更深刻的认识。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="虚拟内存" scheme="http://wdxtub.com/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 16 课 Virtual Memory - Concepts]]></title>
    <link href="http://wdxtub.com/2016/03/18/csapp-16/"/>
    <id>http://wdxtub.com/2016/03/18/csapp-16/</id>
    <published>2016-03-18T13:48:52.000Z</published>
    <updated>2016-03-18T16:11:31.000Z</updated>
    <content type="html"><![CDATA[<p>这节课开始，我们会接触到计算机系统中另外一个非常重要的概念：虚拟内存。这个机制提供给了上层应用一个统一的地址空间，而无须操心物理内存的位置。</p>
<a id="more"></a>
<hr>
<p>在具体讲述之前，我们先来看看什么是物理地址，什么是虚拟地址。</p>
<p><img src="/images/14583091815694.jpg" alt="物理地址"></p>
<p>物理地址一般应用在简单的嵌入式微控制器中（汽车、电梯、电子相框等），因为应用的范围有严格的限制，不需要在内存管理中引入过多的复杂度。</p>
<p>但是对于计算机（以及其他智能设备）来说，虚拟地址则是必不可少的，通过 MMU(Memory management unit)把虚拟地址(Virtual Address, VA)转换为物理地址(Physical Address, PA)，再由此进行实际的数据传输。大致的过程如下图所示</p>
<p><img src="/images/14583093850630.jpg" alt="虚拟地址"></p>
<p>使用虚拟内存主要是基于下面三个考虑：</p>
<ol>
<li>可以更有效率的使用内存：使用 DRAM 当做部分的虚拟地址空间的缓存</li>
<li>简化内存管理：每个进程都有统一的线性地址空间</li>
<li>隔离地址控件：进程之间不会相互影响；用户程序不能访问内核信息和代码</li>
</ol>
<h2 id="u4F5C_u4E3A_u7F13_u5B58_u5DE5_u5177"><a href="#u4F5C_u4E3A_u7F13_u5B58_u5DE5_u5177" class="headerlink" title="作为缓存工具"></a>作为缓存工具</h2><p>概念上来说，虚拟内存就是存储在磁盘上的 N 个连续字节的数组。这个数组的部分内容，会缓存在 DRAM 中，在 DRAM 中的每个 cache block 就称为 page（页），具体的大小为 $P=2^p$（这里 p 表示具体的位数），如下图所示：</p>
<p><img src="/images/14583098368523.jpg" alt=""></p>
<p>大致的思路和之前的 cache memory 是类似的，就是利用 DRAM 比较快的特性，把最常用的数据换缓存起来。如果要访问磁盘的话，大约会比访问 DRAM 慢一万倍，所以我们的目标就是尽可能从 DRAM 中拿数据。为此，我们需要：</p>
<ul>
<li>更大的 page size：通常是 4KB，有的时候可以达到 4MB</li>
<li>全相联 Fully associative：每一个 virual page 可以放在任意的 physical page 中，没有限制。</li>
<li>映射函数非常复杂，所以没有办法用硬件实现</li>
<li>通常使用 Write-back 而非 Write-through 机制<ul>
<li>Write-through: 命中后更新缓存，同时写入到内存中</li>
<li>Write-back: 直到这个缓存需要被置换出去，才写入到内存中（需要额外的 dirty bit 来表示缓存中的数据是否和内存中相同，因为可能在其他的时候内存中对应地址的数据已经更新，那么重复写入就会导致原有数据丢失）</li>
</ul>
</li>
</ul>
<p>具体怎么做呢？通过 page table。每个 page table 实际上是一个数组，数组中的每个元素称为 page table entry(PTE)，每个 PTE 负责把 virtual page 映射到 physical page 上。在 DRAM 中，每个进程都有自己的 page table，具体如下</p>
<p><img src="/images/14583104118576.jpg" alt="Page Table"></p>
<p>因为有一个表可以查询，就会遇到两种情况，一种是 Page Hit，另一种则是 Page Fault。</p>
<blockquote>
<p>Page hit: reference to VM word that is in physical memory (DRAM cache hit)</p>
</blockquote>
<p>访问到 page table 中蓝色条目的地址时，因为在 DRAM 中有对应的数据，可以直接访问。</p>
<blockquote>
<p>Page fault: reference to VM word that is not in physical memory (DRAM cache miss)</p>
</blockquote>
<p>访问到 page table 中灰色条目的时候，因为在 DRAM 中并没有对应的数据，所以需要执行一系列操作（从磁盘复制到 DRAM 中），具体为：</p>
<ul>
<li>触发 Page fault，也就是一个异常</li>
<li>Page fault handler 会选择 DRAM 中需要被置换的 page，并把数据从磁盘复制到 DRAM 中</li>
<li>重新执行访问指令，这时候就会是 page hit</li>
</ul>
<p>复制过程中的等待时间称为 demand paging。</p>
<p>仔细留意上面的 page table，会发现有一个条目是 null，也就是没有分配。具体的分配过程（比方说声明了一个大数组），就是让该条目指向虚拟内存（在磁盘上）的某个 page（但并不复制到 DRAM，只有当出现 page fault 的时候才需要赋值）</p>
<p>看起来『多此一举』，但是由于局部性原理，虚拟内存其实是非常高效的机制，这一部分最后提到了 working set 的概念，比较简单，这里不再赘述：</p>
<p><img src="/images/14583113431902.jpg" alt="working set"></p>
<h2 id="u4F5C_u4E3A_u5185_u5B58_u7BA1_u7406_u5DE5_u5177"><a href="#u4F5C_u4E3A_u5185_u5B58_u7BA1_u7406_u5DE5_u5177" class="headerlink" title="作为内存管理工具"></a>作为内存管理工具</h2><p>前面提到，每个进程都有自己的虚拟地址空间，这样一来，对于进程来说，它们看到的就是简单的线性空间（但实际上在物理内存中可能是间隔、支离破碎的），具体的映射过程可以用下图表示：</p>
<p><img src="/images/14583114512897.jpg" alt="maping"></p>
<p>在内存分配中没有太多限制，每个 virtual page 都可以被映射到任何的 physical page 上。这样也带来一个好处，如果两个进程间有共享的数据，那么直接指向同一个 physical page 即可（也就是上图 PP 6 的状况，只读数据）</p>
<p>虚拟内存带来的另一个好处就是可以简化链接和载入的结构（因为有了统一的抽象，不需要纠结细节），如下图所示：</p>
<p><img src="/images/14583116383432.jpg" alt="Simplifying Linking and Loading"></p>
<h2 id="u4F5C_u4E3A_u5185_u5B58_u4FDD_u62A4_u5DE5_u5177"><a href="#u4F5C_u4E3A_u5185_u5B58_u4FDD_u62A4_u5DE5_u5177" class="headerlink" title="作为内存保护工具"></a>作为内存保护工具</h2><p>Page table 中的每个条目的高位部分是表示权限的位，MMU 可以通过检查这些位来进行权限控制（读、写、执行）</p>
<p><img src="/images/14583120873244.jpg" alt="Permission bits"></p>
<h2 id="u5730_u5740_u7FFB_u8BD1"><a href="#u5730_u5740_u7FFB_u8BD1" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>开始之前先来了解以下概念：</p>
<p><img src="/images/14583133332593.jpg" alt="Summary of Address Translation Symbols"></p>
<p>然后我们通过一个具体的例子来说明如何进行地址翻译</p>
<p><img src="/images/14583134329438.jpg" alt="Address Translation With a Page Table"></p>
<p>具体的访问过程为：</p>
<ul>
<li>通过虚拟地址找到 page table 中对应的条目</li>
<li>检查 valid bit，是否需要触发 page fault</li>
<li>然后根据 page table 中的 physical page number 找到内存中的对应地址</li>
<li>最后把 virtual page offset 和前面的实际地址拼起来，就是最终的物理地址了</li>
</ul>
<p>这里又分两种情况：Page Hit 和 Page Fault，具体过程如下：</p>
<p><img src="/images/14583139236125.jpg" alt="Page Hit"></p>
<ol>
<li>Processor sends virtual address to MMU</li>
<li>MMU fetches PTE from page table in memory</li>
<li>MMU fetches PTE from page table in memory</li>
<li>MMU sends physical address to cache/memory</li>
<li>Cache/memory sends data word to processor</li>
</ol>
<p><img src="/images/14583140218329.jpg" alt="Page Fault"></p>
<ol>
<li>Processor sends virtual address to MMU</li>
<li>MMU fetches PTE from page table in memory</li>
<li>MMU fetches PTE from page table in memory</li>
<li>Valid bit is zero, so MMU triggers page fault exception</li>
<li>Handler identifies victim (and, if dirty, pages it out to disk)</li>
<li>Handler pages in new page and updates PTE in memory</li>
<li>Handler returns to original process, restarting faulting instruction</li>
</ol>
<p>把这个和我们前面提到的 cache memory 结合起来就是：</p>
<p><img src="/images/14583153762095.jpg" alt="Integrating VM and Cache"></p>
<ul>
<li>VA: virtual address, PA: physical address</li>
<li>PTE: page table entry, PTEA = PTE address</li>
</ul>
<p>但是我们会发现，这样其实还不够快，L1 cache 虽然快，为什么不能直接在 MMU 进行一部分的工作呢？于是就有了另外一个设计：Translation Lookaside Buffer(TLB)</p>
<ul>
<li>Small set-associative hardware cache in MMU</li>
<li>Maps virtual page numbers to physical page numbers</li>
<li>Contains complete page table entries for small number of pages</li>
</ul>
<p>我们使用 Virtual Page Number 部分当做访问 TLB 的索引，具体如下（和 cache memory 非常相似）：</p>
<p><img src="/images/14583156462414.jpg" alt="Accessing the TLB"></p>
<p>同样分两个情况：TLB Hit 和 TLB Miss</p>
<blockquote>
<p>A TLB hit eliminates a memory access</p>
</blockquote>
<p><img src="/images/14583156886189.jpg" alt="TLB Hit"></p>
<blockquote>
<p>A TLB miss incurs an additional memory access(the PTE)</p>
</blockquote>
<p><img src="/images/14583157195012.jpg" alt="TLB Miss"></p>
<h3 id="Multi-Level_Page_Tables"><a href="#Multi-Level_Page_Tables" class="headerlink" title="Multi-Level Page Tables"></a>Multi-Level Page Tables</h3><p>Page table 的另一个问题就是，因为往往虚拟地址的位数比物理内存的位数要大得多，所以保存 page table entry(PTE) 也是一个问题。举个例子：</p>
<p>假设一个 page 的大小是 4KB($2^12$)，每个地址有 48 位，一条 PTE 记录有 8 个字节，那么要全部保存下来，需要的大小是：</p>
<p>$$2^{48} \times 2^{-12} \times 2^3 = 2^{39} bytes$$</p>
<p>整整 512 GB!</p>
<p>所以解决办法就是，多层的 page table，第一层的 page table 中的条目指向其他的 page table，然后再去寻找具体的地址：</p>
<p><img src="/images/14583164443493.jpg" alt="A Two-Level Page Table Hierarchy"></p>
<p>具体的翻译过程如下：</p>
<p><img src="/images/14583165384715.jpg" alt="Translating with a k-level Page Table"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Programmer’s view of virtual memory<ul>
<li>Each process has its own private linear address space</li>
<li>Cannot be corrupted by other processes</li>
</ul>
</li>
<li>System view of virtual memory<ul>
<li>Use memory efficiently by caching virtual memory pages<ul>
<li>Efficient only because of locality </li>
</ul>
</li>
<li>Simplifies memory management and programming</li>
<li>Simplifies protection by providing a convenient interpositioning point to check permissions</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课开始，我们会接触到计算机系统中另外一个非常重要的概念：虚拟内存。这个机制提供给了上层应用一个统一的地址空间，而无须操心物理内存的位置。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="虚拟内存" scheme="http://wdxtub.com/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 20 课 设计模式]]></title>
    <link href="http://wdxtub.com/2016/03/17/sad-20/"/>
    <id>http://wdxtub.com/2016/03/17/sad-20/</id>
    <published>2016-03-17T17:33:55.000Z</published>
    <updated>2016-03-18T01:30:19.000Z</updated>
    <content type="html"><![CDATA[<p>前面讲了这么多『玄学』概念，这一次终于回到软件开发的主战场——设计模式！</p>
<a id="more"></a>
<hr>
<p>设计模式可以算得上是软件架构中最有门道的一部分，也是大家最熟悉却又最陌生的一部分。熟悉是因为任何软件工程的课一定会提到，陌生则是因为『纸上得来终觉浅』，往往在实际应用中，会出现很多问题。总体来说，设计模式可以看作是解决某种特定问题的成功经验的提炼，学习设计模式，等于是站在巨人的肩膀上，能看得更远。</p>
<p>因为自己对这个话题也很有兴趣，所以就不按照老师课堂的讲述来编排了（实话说我觉得她讲的非常一般），课堂上主要介绍了工厂模式、单例模式、建造者模式和原型模式（本文都会涉及）。</p>
<p>本文主要写自己对不同模式，以及模式之间的一些思考。</p>
<h2 id="u5148_u5520_u53E8_u4E24_u53E5"><a href="#u5148_u5520_u53E8_u4E24_u53E5" class="headerlink" title="先唠叨两句"></a>先唠叨两句</h2><p>从前提到『设计模式』，总觉得是特别高大上的东西。随着代码越写越多，接触的事物越来越广泛，慢慢开始意识到这些所谓的『规则』，是保护，也是束缚。也开始怀疑过去不知道为什么就会去『相信』的东西，比如说本文的『设计模式』，以及与之密切相关的『面向对象』。</p>
<p>学术界的一大问题在于，有的时候为了凸现自己的不同，会强行『发明』一些东西。层出不穷的理论与技术，结合不同时代的主题，颇有种『一代补丁一代神』的循环感。最近特别火的 AlphaGO，最终不可避免会遇到 PS4 的尴尬——是在模拟地球，还是在模拟地球仪？</p>
<p>最近几年听到看到的各路流派给自己贴光环的故事已经太多，从 OO 到 SOA，从 Vim 到 Emac，从 Windows 到 Linux/Unix，例子不胜枚举。问题在于，它们都想用一个东西解决所有问题，但是真有这么个东西，早就解决了你想要解决这个解决问题的问题了（是不是被绕了？）。不能只有一种声音，不能只有一种思路，甚至可以从《一九八四》中『偷』来这么个概念——双重思想。</p>
<p>C++ STL 库的作者关于面向对象说过这么一段话（虽有断章取义之嫌，但应该还是能表达出他的理念）：</p>
<blockquote>
<p>I find OOP technically unsound. It attempts to decompose the world in terms of interfaces that vary on a single type. To deal with the real problems you need multisorted algebras – families of interfaces that span multiple types. I find OOP philosophically unsound. It claims that everything is an object. Even if it is true it is not very interesting – saying that everything is an object is saying nothing at all. I find OOP methodologically wrong. It starts with classes. It is as if mathematicians would start with axioms. You do not start with axioms – you start with proofs. Only when you have found a bunch of related proofs, can you come up with axioms. You end with axioms. The same thing is true in programming: you have to start with interesting algorithms. Only when you understand them well, can you come up with an interface that will let them work.</p>
</blockquote>
<p>就拿 Java 来说，所有东西都是对象，这跟所有东西都不是对象又有什么区别呢？纵观《设计模式》一书所说的 23 种设计模式，说白了就是：</p>
<ul>
<li>多组合少继承</li>
<li>面向接口而非实现</li>
<li>高内聚低耦合</li>
</ul>
<p>其实都是平时听得太多以至于不太在意的概念。或者很多时候我们被『想当然』封印住了思考，本能就往 OO 或者 SOA 的方向跳了。</p>
<p>然后说说 SOA，从大三刚开始接触的时候，我就感觉非常不科学。SOA 的想法很好，方向也很好，但是遇到的一个悖论就是，在业务复杂到足以体现 SOA 的优势的时候，往往 SOA 本身已经复杂得没人弄得懂了。因为大家都是提供一个服务给别人调用，那么调用背后发生的事情就是一团乱麻了，基本上一个功能完成后就只有两个命运：用一段时间，需要更新的时候直接重写。</p>
<p>这种时候不妨回过头来看看『传统』的数据驱动编程，就会发现只有一直抓住问题的本质，才不至于人为增加太多复杂度（所以这个学期的云计算课程人为浪费大家时间我真心感受到了助教的恶意）。</p>
<blockquote>
<p>Keep It Simple, Stupid!</p>
</blockquote>
<h2 id="u5E38_u89C1_u6A21_u5F0F"><a href="#u5E38_u89C1_u6A21_u5F0F" class="headerlink" title="常见模式"></a>常见模式</h2><ul>
<li>工厂模式的本质，实际上是以一个统一的角度去理解所有的资源，具体根据特定的标志符来进行对应处理</li>
<li>抽象工厂的本质，其实就是一组配置文件，搞得那么玄乎，真心还就是几个文本文件可以解决的问题</li>
<li>原型模式的本质，Unix 中的 <code>fork</code> 可以说是完美体现，反正我先原样搞出来一个，剩下的自己继续处理</li>
<li>单例模式的本质，更像是中央集权，可以通过穿透层级进行信息的快速传递，减少消耗</li>
<li>适配器模式的本质，就是带面具，和病毒欺骗细胞完成匹配一个意思</li>
</ul>
<p>这样列下去还有很多，术语之所以存在，是为大家提供一个概念上的平台，在平台之上，就可以放开手脚自由发挥，而不是被平台所限制。</p>
<blockquote>
<p>人法地、地法天、天法道、道法自然</p>
</blockquote>
<p>多去观察，多去思考，而不是借由所谓的『权威』代替自己的劳动，才是不断进步的动力。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>那些我们习以为常觉得『自然』的东西，其实才是最重要的『模式』。</p>
<p>（这真是一篇头重脚轻的日志，实在没意思赘述概念了，具体在后面的参考链接都有）</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://design-patterns.readthedocs.org/zh_CN/latest/" target="_blank" rel="external">图说设计模式</a></li>
<li><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="external">Java之美从菜鸟到高手演变之设计模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="external">设计模式</a></li>
<li><a href="http://coolshell.cn/articles/8961.html" target="_blank" rel="external">从面向对象的设计模式看软件设计</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面讲了这么多『玄学』概念，这一次终于回到软件开发的主战场——设计模式！</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高级语法教程 2 The nature of grammar and grammar errors]]></title>
    <link href="http://wdxtub.com/2016/03/17/advanced-grammar-monitoring-2/"/>
    <id>http://wdxtub.com/2016/03/17/advanced-grammar-monitoring-2/</id>
    <published>2016-03-17T16:02:24.000Z</published>
    <updated>2016-03-17T22:06:06.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们通过一些具体的例子，来复习基本的语法概念，以及寻找为什么我们会出现语法错误的原因。</p>
<a id="more"></a>
<hr>
<p>课前回顾了之前的作业，就是一定要意识到自己到底是在哪里不熟悉，然后有针对性的用对自己有意义的事情来练习。并且尽可能多读英文书，找寻多样的表达方式</p>
<h2 id="u540D_u8BCD"><a href="#u540D_u8BCD" class="headerlink" title="名词"></a>名词</h2><blockquote>
<p>Divide this list of nouns into three categoreis, giving a heading to each.</p>
</blockquote>
<p>Word List: elephant, hope, September, delay, Diana, humor, car, marmalade, radio, Poland, truth, telephone, pole, mirror, oak, excitement</p>
<p>仔细查看各个选项之后，直觉的分类就是：抽象名词、具体名词和其他专有名词（月份/名字/国家）</p>
<p>不过除了专有名词之外，还有另一种思路，就是按照『可以当动词』的名词，和『不可以当动词』的名词，具体大家可以查查看</p>
<h2 id="u52A8_u8BCD"><a href="#u52A8_u8BCD" class="headerlink" title="动词"></a>动词</h2><blockquote>
<p>Divide the verbs in these utterances into two categories, stating a reason for your allocation</p>
</blockquote>
<p>这里主要是帮助大家区分及物动词(transitive)和不及物动词(intransitive)</p>
<ol>
<li>You’ve finished your tea.</li>
<li>They are eating cake.</li>
<li>They are eating at home.</li>
<li>She wants to watch TV.</li>
<li>I’m going to bed.</li>
<li>I’m reparing the car.</li>
<li>Cortez conquered Mexico.</li>
<li>Many leading politicians have died violently.</li>
<li>I can’t think clearly!</li>
<li>I hate this exersise!</li>
</ol>
<p>这里还出现了完成时，具体之后会详细说。</p>
<h2 id="u53E5_u5B50_u7ED3_u6784"><a href="#u53E5_u5B50_u7ED3_u6784" class="headerlink" title="句子结构"></a>句子结构</h2><blockquote>
<p>Why do these nonsense sentences sound acceptable</p>
</blockquote>
<p>这里需要注意英语的结构：SVO(Subject + Verb + Object)，想想为什么下面这一堆乱七八糟的也能构成『像样』的句子</p>
<ol>
<li>He crattled his splot and scrot out a neelying groal.</li>
<li>They strentered folicly until a magan veened to famble them.</li>
</ol>
<p>有主语，有类似过去式的动词，有借此，有形容词，有类似的短语结构。</p>
<h2 id="u5F85_u7EED"><a href="#u5F85_u7EED" class="headerlink" title="待续"></a>待续</h2><p>还有下半部分，不过由于今天老师迟到，暂时等下次上课后再补。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们通过一些具体的例子，来复习基本的语法概念，以及寻找为什么我们会出现语法错误的原因。</p>]]>
    
    </summary>
    
      <category term="结构" scheme="http://wdxtub.com/tags/%E7%BB%93%E6%9E%84/"/>
    
      <category term="英语" scheme="http://wdxtub.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="语法" scheme="http://wdxtub.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="错误" scheme="http://wdxtub.com/tags/%E9%94%99%E8%AF%AF/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Presentation Basics 2 展示问题及解决方案]]></title>
    <link href="http://wdxtub.com/2016/03/16/presentation-basics-2/"/>
    <id>http://wdxtub.com/2016/03/16/presentation-basics-2/</id>
    <published>2016-03-17T00:25:23.000Z</published>
    <updated>2016-03-17T01:00:52.000Z</updated>
    <content type="html"><![CDATA[<p>第二课主要是具体实践的过程，我们被要求选取一个自己领域的问题，按照给定的逻辑结构，来完成『背景，问题，解决方案，评估』这样一个完整体系的展示。</p>
<a id="more"></a>
<hr>
<p>因为主要是通过具体的小组练习来进行概念的掌握，所以这里列出相关的概念，感兴趣的同学可以自己找时间练习。老师推荐了一个方法：用手机把自己说话的内容录制下来，再回头看就会发现很多问题（因为我们说的时候是不可能一边说一边听，发现自己的问题的）</p>
<blockquote>
<p>Problem-solution presentations are often organized into the following parts:</p>
</blockquote>
<ul>
<li>Description of the situation or context that the problem exists in<ul>
<li>Give the background and the consequences of the problem, so that the audience will appreciate why the solution is important</li>
</ul>
</li>
<li>Description of the problem<ul>
<li>talk about all relevant parts of the problem so that in the next section the audience will see how your solution solves the problem</li>
</ul>
</li>
<li>Discussion of the solution(s)<ul>
<li>make sure to refer back to the description of the context and the problem in order to link the solution effectively to the previous parts of the presentation</li>
</ul>
</li>
<li>Evaluation of the solution(s)<ul>
<li>you may want to discuss both the positives and the negatives of the solution you are discussing. However, in a persuasive speech, presenters tend to downplay the negatives so that their audience does not focus on the negatives</li>
</ul>
</li>
</ul>
<p>总结起来其实就是下面四个要点：</p>
<ul>
<li>Context：用平易近人的口气和例子来让大家进入节奏</li>
<li>Problem：说明问题的严重性，借此引出解决方案的重要性</li>
<li>Solution：多个角度来说明解决方案如何对应问题的各个方面</li>
<li>Evaluation：正反两面说明，更加可信</li>
</ul>
<p>注意不同要点之间的过渡要自然，并且用明显的转折词和关键字来让受众跟上节奏。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第二课主要是具体实践的过程，我们被要求选取一个自己领域的问题，按照给定的逻辑结构，来完成『背景，问题，解决方案，评估』这样一个完整体系的展示。</p>]]>
    
    </summary>
    
      <category term="展示" scheme="http://wdxtub.com/tags/%E5%B1%95%E7%A4%BA/"/>
    
      <category term="英语" scheme="http://wdxtub.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高级语法教程 1 Challenging your grammar assumptions]]></title>
    <link href="http://wdxtub.com/2016/03/15/advanced-grammar-monitoring-1/"/>
    <id>http://wdxtub.com/2016/03/15/advanced-grammar-monitoring-1/</id>
    <published>2016-03-15T17:09:17.000Z</published>
    <updated>2016-03-15T20:06:32.000Z</updated>
    <content type="html"><![CDATA[<p>最近在上的另一门课程叫做 Advanced Grammar Monitoring。主要是针对英语不是母语的人群，帮助我们了解为什么会出现各类语法错误，以及如何改正它们。</p>
<a id="more"></a>
<hr>
<h2 id="u8BFE_u7A0B_u603B_u89C8"><a href="#u8BFE_u7A0B_u603B_u89C8" class="headerlink" title="课程总览"></a>课程总览</h2><p>这门课主要专注于我们在口语中出现的各类语法错误，帮助我们建立起语法的感觉，以及识别出对应的语法错误。语法在语言中的作用，类似于某种范式，是 guideline（我觉得 trend 也合适）而非 rule。</p>
<p>课程目标是让我们建立起：</p>
<ul>
<li>the way grammar is used in communicative settings</li>
<li>the kins of errors that are commonly made in academic language, and why those errors are made</li>
<li>useful monitoring strategies that allow you to address your own errors</li>
</ul>
<p>具体的上课方式是：</p>
<ul>
<li>learning about the role that grammar plays in language use</li>
<li>identifying, interpreting and correcting grammar errors in written material and from video tapes</li>
<li>monitoring peers and ourselves for grammar errors in discussion</li>
<li>developing strategies to control grammar errors while speaking</li>
</ul>
<p>这个系列课程一共有六次，主题分别是：</p>
<ol>
<li>Challenging your grammar assumptions</li>
<li>The nature of grammar and grammar errors</li>
<li>Patterns of language and the importance of context</li>
<li>Building a greater understanding of grammar usage</li>
<li>What are your own grammar needs</li>
<li>Integration of theory and practice</li>
</ol>
<h2 id="u8BFE_u7A0B_u5185_u5BB9"><a href="#u8BFE_u7A0B_u5185_u5BB9" class="headerlink" title="课程内容"></a>课程内容</h2><p>八十分钟的课上除了小组讨论之外，还是有很多有意思的内容的，这里挑选三个核心问题来进行说明</p>
<h3 id="u8BED_u6CD5_u9519_u8BEF_u662F_u600E_u4E48_u6765_u7684"><a href="#u8BED_u6CD5_u9519_u8BEF_u662F_u600E_u4E48_u6765_u7684" class="headerlink" title="语法错误是怎么来的"></a>语法错误是怎么来的</h3><p>对于母语不是英语的人来说，表达自己的时候通常需要『并行思考』，一面要组织表达的逻辑与句子结构，一面需要选择正确的词语以及合适的语法，正是『鱼与熊掌不可得兼』。用老师的话来说，这属于 “too much cognitive load”，我们没办法在短时间内完美处理好 vocabulary, pronounciation, grammar, intent 这四个项目。</p>
<p>另外一个导致语法错误的原因，是母语本身和英语的差异，比方在中文里时态很多时候是隐含的（或者我们本能理解的），但是对应到英文中，各种不同类型的时态，就很容易选择错误（跟我们一开始学习英语时的习惯有关）。而且在日常的交流中，毕竟主要目的是互相弄懂意思，别人也不会特地去纠正我们的语法错误，也就意味着我们即使很多时候不知道自己说错了。</p>
<p>按照老师的说法，我们在描述复杂概念和想法的时候，说的其实是介于母语与第二语言的 interlanguage，想要跨越这个鸿沟并不简单，需要抛弃从前的习惯，转为养成新的习惯（当然这也不是上几次课就可以解决的，需要『刻意练习』）。不过也有好消息，至少我们可以通过训练，在跨域鸿沟之前也能把话说清楚。</p>
<h3 id="u8BED_u6CD5_u5230_u5E95_u662F_u4EC0_u4E48"><a href="#u8BED_u6CD5_u5230_u5E95_u662F_u4EC0_u4E48" class="headerlink" title="语法到底是什么"></a>语法到底是什么</h3><p>这部分就以判断对错的形式来进行说明（虽然想都不用想肯定都是错的叙述）</p>
<blockquote>
<p>True or false? Grammar is a set of rules, which are defined by experts in grammar books.</p>
</blockquote>
<p>当然是不对的，首先语法不是 rule，而是 guideline(agreement)，并且也不可能有所谓的一群『专家』来决定大家要怎么说话。从概念上来说，作为一种约定俗成的方式，其实不能被定义，只能被描述</p>
<blockquote>
<p>True or false? Most errors in grammar are caused by interference from the first language, so the best way to prevent these errors is for the teacher to contrast the two languages.</p>
</blockquote>
<p>前半句是对的，但是后半句就不对了。首先语言之间的对比是很难的，即使花了大力气对比成功了，似乎也没什么用。作为男生，我了解男生和女生的不同，但这并不意味着我就了解女生。</p>
<blockquote>
<p>True or false? Grammar is a problem for non-native speakers of a language because they are lazy and they didn’t study the rules hard enough.</p>
</blockquote>
<p>也是错的。我觉得问题有二：一是思维过载（前面提过），二是很多时候我们都不知道自己在犯错（所以需要帮助我们建立起意识到自己犯错的能力）</p>
<blockquote>
<p>True or false? Grammar errors always interfere with meaning.</p>
</blockquote>
<p>以偏概全。对于比较简单的描述，哪怕只是蹦几个词出来，对方应该都能够明白意思。但是对于更加细腻的感情和复杂的思维来说，语法错误可能就会导致大问题。</p>
<blockquote>
<p>True or false? In grammar, it is the rules that are most important for correct usage; context and the intent of the speaker are not important.</p>
</blockquote>
<p>这个问题引出了这门课最重要的一个观念：</p>
<p>Context + Intent = Grammar</p>
<p>语法应当是为我们服务的，而不是反过来，重要的是上下文和我们要表达的意思</p>
<blockquote>
<p>True or false? A grammar error occurs when a speaker breaks a rule.</p>
</blockquote>
<p>这里需要注意一个概念到底是 Grammar as Fact 还是 Grammar as Choice 呢？</p>
<p>目前我也没有特别好的答案（或者说知道是 Grammar as Choice 但是没有办法把背后的问题搞清楚）</p>
<p>所谓语法的规则，在初学者阶段需要强制培养出某种刻板的语感，但是到后来就不能拘泥于此了。</p>
<h3 id="u8868_u8FBE_u80FD_u529B_u516C_u5F0F"><a href="#u8868_u8FBE_u80FD_u529B_u516C_u5F0F" class="headerlink" title="表达能力公式"></a>表达能力公式</h3><p>这个其实是我自己想出来的一个公式：</p>
<p>表达能力 = 结构 + 词汇 + 语法 + 思维</p>
<p>暂时先卖个关子，不详细解释，来看下面的例子</p>
<blockquote>
<p>Discuss an interesting event that happened this semester</p>
</blockquote>
<p>需要注意以下三点：</p>
<ol>
<li>Tense: past tense</li>
<li>Finish the sentence</li>
<li>Awkward phrases</li>
</ol>
<p>老师随后举了一个例子，她是这么描述『昨天』的一件事的：</p>
<blockquote>
<p>Yesterday afteroon, I was on a bus. I was reading a book. Then a man punches me in the head!</p>
</blockquote>
<p>这里为什么最后用了现在时而不是继续过去时呢？老师的解释是这样的：动词的时态，其实不单单只是用来表达时间，更可以表示距离。如果我这里的 punch 也用过去时，给人的感觉就是现在已经没什么事儿了，但是如果我要表达即使到现在也非常不爽的感情，就要用动词来明确表示出这种感觉，也就是用现在时。</p>
<hr>
<p>总体来说这个系列课程参与的人数更多，同学也更踊跃，整体氛围更好，希望能多学到一点东西。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在上的另一门课程叫做 Advanced Grammar Monitoring。主要是针对英语不是母语的人群，帮助我们了解为什么会出现各类语法错误，以及如何改正它们。</p>]]>
    
    </summary>
    
      <category term="口语" scheme="http://wdxtub.com/tags/%E5%8F%A3%E8%AF%AD/"/>
    
      <category term="英语" scheme="http://wdxtub.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="语法" scheme="http://wdxtub.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 反思课 3 提高 Web 服务性能的策略与思考]]></title>
    <link href="http://wdxtub.com/2016/03/15/cc-rethink-3/"/>
    <id>http://wdxtub.com/2016/03/15/cc-rethink-3/</id>
    <published>2016-03-15T12:17:53.000Z</published>
    <updated>2016-03-15T13:37:57.000Z</updated>
    <content type="html"><![CDATA[<p>学习是一个不断改进方法论的过程，<a href="http://wdxtub.com/2016/03/11/cc-p6/">课程项目 6 MySQL 和 HBase 配置及测试</a>，因为自己对于搭建基于 NoSQL 数据库的 Web 服务缺乏足够的经验，在具体对前后端进行优化的时候走了很多弯路，也意识到了没有目的的优化很可能是劣化，这里主要整理一下自己对于优化问题的思考。</p>
<a id="more"></a>
<hr>
<h2 id="u5E94_u7528_u573A_u666F"><a href="#u5E94_u7528_u573A_u666F" class="headerlink" title="应用场景"></a>应用场景</h2><p>因为涉及到具体的问题，所以先大概说明一下应用场景，方便之后的叙述。事情大概是这样的：</p>
<ul>
<li>数据是 5100W 条左右带 tag 的 tweet</li>
<li>这些 tweet 有各种语言</li>
<li>只有读请求，每次需要返回指定用户用指定 tag 发送的 tweet</li>
<li>前端使用 Undertow，后端是部署在 Amazon EMR 的 HBase</li>
<li>有一定的预算限制（不能开多台机器来凑）</li>
</ul>
<p>难点在于，优化问题其实是一个涉及多层级多组件的『复杂』问题，需要考虑的东西很多，更纠结的是，整个系统是符合『木桶理论』的，也就是最短板决定了系统的整体性能。那么就牵扯出两个关键问题：短板在哪里？短板怎么解决。</p>
<h2 id="u4E00_u4E9B_u601D_u8003"><a href="#u4E00_u4E9B_u601D_u8003" class="headerlink" title="一些思考"></a>一些思考</h2><p>对于 Web 服务来说，所谓优化，可以简单粗暴分为两个子类，一是增加吞吐量，二是增加并发数。优化的整体思路，按照实施的顺序来看，大概是这样的：</p>
<ol>
<li>充分理解应用场景<ul>
<li>服务具体接收的请求的格式和具体需要返回的内容是什么</li>
<li>是偏向于读，还是偏向于写，亦或者是读写比较均衡</li>
<li>数据量大概是多少，分布式集群（如果要用）的基本配置是什么</li>
</ul>
</li>
<li>数据格式设计<ul>
<li>根据具体的场景，需要思考具体数据库的设计</li>
<li>如果是读比较多，可以考虑对数据进行预处理，用空间换时间</li>
<li>如果是写比较多，则需要尽可能减少冗余，减少改动时需要同步更新的记录</li>
</ul>
</li>
<li>分析服务瓶颈（慢在哪里）<ul>
<li>使用什么工具，监控什么指标来寻找瓶颈</li>
<li>根据输出的日志（这里需要自己决定输出什么）来找寻请求的规律</li>
<li>根据日志的数据统计，找到短板所在</li>
<li>这一步其实并不简单，更可怕的是，如果在这里分析错误，就会把整个优化带入死胡同（去优化并不需要优化的问题）</li>
</ul>
</li>
<li>充分利用硬件资源<ul>
<li>在预算限制下有没有开够机器</li>
<li>对于每台机器，其 CPU，内存，带宽等资源有没有尽可能使用</li>
<li>如果没有尽量利用，就说明钱没有花在刀刃上，可以考虑更换不同类型的机器，Amazon 提供了『通用』，『内存优化』和『计算优化』这几种不同的机器，可以根据监控的数据，根据前后端不同的任务来决定具体使用什么类型的机器</li>
</ul>
</li>
<li>解决木桶效应，不同层优化<ul>
<li>算法 + 数据结构优化</li>
<li>事务处理逻辑优化，尽可能减少单次请求需要的资源（包括计算、内存和带宽资源）</li>
<li>硬件优化，vertical scaling 或者 horizontal scaling</li>
<li>分布式结构优化，采用 ELB 或 Hadoop</li>
</ul>
</li>
</ol>
<h2 id="u4E00_u4E9B_u7B56_u7565"><a href="#u4E00_u4E9B_u7B56_u7565" class="headerlink" title="一些策略"></a>一些策略</h2><p>前面从总体的思路切入，这里因为涉及到具体的指标要求，所以会从细节方面切入。</p>
<p>首先要意识到从我们在浏览器中输入网址，到最后看到显示的内容之间发生了什么。因为这里不是网络分析课（Amazon 的网络我们能调优的范围也有限），所以 DNS 路由之类的内容这里不提，具体可以参考<a href="http://wdxtub.com/2016/02/10/internet-protocol/">计算机网络</a>一文。</p>
<p>那么到底中间的过程是什么呢？其实就 3 步：</p>
<ol>
<li>页面模板根据实际内容渲染成网页。这部分我们不需要考虑，并没有用任何渲染引擎，就是单纯返回一段数据而已</li>
<li>业务逻辑部分。显示内容之前做的预处理，对应配套的缓存，连接池等等内容。这部分理论上是需要考虑的，但是在具体的测试中，影响不算特别大（和后面相比）</li>
<li>数据库与网络传输部分。这部分是主要的瓶颈所在，接下来会细说。</li>
</ol>
<p>网络部分优化，其实是比较简单粗暴的，因为是只读操作，所以不需要考虑一致性问题，努力增加并发数即可，另一个角度则是减少每次传输所需要的带宽，综合来看，有下面的策略：</p>
<ul>
<li>使用 ELB 增加多台前端，多台机器并发请求</li>
<li>每台机器增加线程数（当然要在内存的允许范围内），但是加到一定程度也就足够了（毕竟带宽是有限的）</li>
<li>在后端对数据进行压缩，在前端进行解压缩，这样就减少了需要网络传输的数据</li>
</ul>
<p>（这部分策略我还没有具体尝试，因为用下面的方法已经满足要求了）</p>
<p>后台数据库和前台缓存实际上类似于 Memory Hierarchy，需要利用看似不大存在的 Locality 来获得最快的访问速度（经过测试如果缓存命中基本上可以认为是无延迟）。这里的 Locality，可以认为是具体流量模式的 Locality，而并非是在数据库中顺序访问。</p>
<p>有缓存，那么肯定就有预热，预热的重要性在于，把常用的记录缓存下来，具体缓存要多大呢？我也不知道，反正可能情况下，越大是越好的（这就是为啥最好开一个内存优化的机器，比其他系列多一倍内存）</p>
<p>最后说一下数据库的参数优化，不知道是不是 Amazon EMR 本身根据不同的配置会进行一定的优化，我并没有改动 HBase 的任何设置。这里的问题在于，因为刚接触 HBase，很多内容不熟悉，所以看着网上的教程瞎折腾很容易弄巧成拙，在优化的时候，一定要确定每一步都清楚自己在干嘛，不然就会出现自己以为正确的错误，而这种错误往往是最难解决的（因为自己压根不知道错了）</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>总体来说，这次的任务还是很有趣的，我也已经意识到了优化真心是一个牵一发动全身的问题，还是要有更加清晰的大局观和思路，才不至于迷失方向。不过话说回来，遇到不懂的问题，最好的方法是停下来，把相关的概念都捋一遍（比方说官方文档就不错），思考具体的问题所在，大胆假设小心验证，才更能找到令自己满意的答案。</p>
<p>另外，对于分析 web 服务的各类工具一头雾水（甚至都不知道有啥），还是得抽空研究一下，不然依靠手动输出计算时间效率太低，得到的数据可能也不准确。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>学习是一个不断改进方法论的过程，<a href="http://wdxtub.com/2016/03/11/cc-p6/">课程项目 6 MySQL 和 HBase 配置及测试</a>，因为自己对于搭建基于 NoSQL 数据库的 Web 服务缺乏足够的经验，在具体对前后端进行优化的时候走了很多弯路，也意识到了没有目的的优化很可能是劣化，这里主要整理一下自己对于优化问题的思考。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="优化" scheme="http://wdxtub.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Presentation Basics 1 理解美国式演讲风格]]></title>
    <link href="http://wdxtub.com/2016/03/14/presentation-basics-1/"/>
    <id>http://wdxtub.com/2016/03/14/presentation-basics-1/</id>
    <published>2016-03-14T23:15:12.000Z</published>
    <updated>2016-03-15T01:13:46.000Z</updated>
    <content type="html"><![CDATA[<p>最近开始上一门名为 Presentation Basics 课程，其目标是: Helping nonnative English speakers build the fluency to give successful presentations。虽然风格是比较美式的，但是对于我们平日里沟通和写作都有一定的指导意义。</p>
<a id="more"></a>
<hr>
<h2 id="u8BFE_u7A0B_u603B_u89C8"><a href="#u8BFE_u7A0B_u603B_u89C8" class="headerlink" title="课程总览"></a>课程总览</h2><p>这门课主要是为我们这种外国留学生（英语不是母语）而准备的，会教给我们基本的做展示的技术已经帮助我们在展示中更流畅地表达自己。因为是小班教学（九个人），所以会有充足的展示和反馈的机会。在整个课程中，每个人都需要做 4 次 mini-talk 和 1 次 presentation。课程结束后，我们应该能做到：</p>
<ul>
<li>Becoming more aware of your own speaking strengths and weaknesses and developing a plan for improving your speaking skills</li>
<li>Recognizing the importance of understanding an audience and how to engage that audience</li>
<li>Using organizational language to help guide your audience and emphasize key information</li>
<li>Using non-verbal cues to help convey information successfully</li>
<li>Becoming more comfortable in the role of presenter</li>
</ul>
<p>当站在台前，被大家注视的时候，感觉害羞尴尬不自在都是非常正常的表现，我们需要做的是慢慢去习惯适应，即所谓 comfortable with uncomfortable。</p>
<p>简单来说，一周两节课，第一节课会学习相关技巧，第二节课用来练习和展示，具体的上课方法是：</p>
<ul>
<li>Watching videotaped presentations that can serve as models of strong presenting in the US academic style</li>
<li>Identifying the way key content information is conveyed in presentations</li>
<li>Focusing on the way information is organized so that it is clear for listeners</li>
<li>Practicing presentation techniques through in-class activities and in a prepared presentation</li>
<li>Meeting individually with the instructor for detailed feedback on your videotaped presentation</li>
</ul>
<p>其实从中我们可以总结出交流沟通的几个重要技巧：首先是确定重要信息是什么，然后思考如何去组织这些信息，让受众更容易理解，之后就是通过不断练习来磨练自己的技艺。</p>
<h2 id="u8BFE_u7A0B_u5B89_u6392_u4E0E_u53C2_u8003_u8D44_u6599"><a href="#u8BFE_u7A0B_u5B89_u6392_u4E0E_u53C2_u8003_u8D44_u6599" class="headerlink" title="课程安排与参考资料"></a>课程安排与参考资料</h2><p>下面是具体八次课的安排以及每节课的目标</p>
<ol>
<li>Understanding the US discourse style<ul>
<li>To recognize your audience’s expectations and how to communicate effectively with your audience</li>
</ul>
</li>
<li>First mini-talk: Define a problem and its solution<ul>
<li>To identify the parts of a problem-solution presentation and to practice this organization in a mini-talk</li>
</ul>
</li>
<li>Linking &amp; organizing language<ul>
<li>To practice using linking and organizing language to help structure your presentations</li>
</ul>
</li>
<li>Second mini-talk: Describing a process<ul>
<li>To apply what you know about organization strategies and linking language to clearly explain a process </li>
</ul>
</li>
<li>Attention-getting openers<ul>
<li>To identify qualities of successful introductions and to practice using them</li>
</ul>
</li>
<li>Third mini-talk: Defining a concept<ul>
<li>To identify qualities of clear definitions and to practice defining a term from your field</li>
</ul>
</li>
<li>Pronunciation and presenting<ul>
<li>To understand the importance of stress and intonation to give clarity to your presentations</li>
</ul>
</li>
<li>Videotaped presentations<ul>
<li>To synthesize skills learned in this class to present a concept from your field</li>
</ul>
</li>
</ol>
<p>参考资料</p>
<ul>
<li>Alley, <the craft="" of="" scientific="" presentations=""></the></li>
<li>Reinhart, <giving academic="" presentations=""></giving></li>
<li>Smith, <communicate: strategies="" fro="" international="" teaching="" assistants=""></communicate:></li>
<li>Sterns, Breaking the Accent Barrier(Video)</li>
<li>Winston, How to Speak(<a href="https://vimeo.com/101543862" target="_blank" rel="external">Video</a>)</li>
</ul>
<h2 id="u4E0A_u8BFE_u5185_u5BB9_u53CA_u611F_u60F3"><a href="#u4E0A_u8BFE_u5185_u5BB9_u53CA_u611F_u60F3" class="headerlink" title="上课内容及感想"></a>上课内容及感想</h2><p>具体的上课内容是大家一起看 <a href="https://vimeo.com/101543862" target="_blank" rel="external">How to Speak</a> 这个视频，然后讨论其使用的各种技巧，具体的内容我在 <a href="http://wdxtub.com/2016/02/22/how-to-speak/">How to Speak 日志</a> 中已经有总结，这里不再赘述，主要记录一下我上课时的感想。</p>
<ul>
<li>展示开头直接开门见山，告诉听众可以期待什么，并且列举出接下来要说的要点，有清晰的组织结构</li>
<li>为了解释复杂的问题和概念，尽量使用比喻，来帮助人们建立起基本的认知</li>
<li>如果想要听众印象深刻，可以考虑使用排比句，精炼展示的内容</li>
<li>很多时候我们不欠缺日常生活共同以及专业学术讨论的能力，但是给非本领域的人介绍相关内容时，往往容易出问题，这是我们需要着重去准备的</li>
<li>从纯技术领域开始，进行简化，最后应用 KISS(Keep It Simple &amp; Stupid) 原则</li>
<li>这里的 Stupid 很有意思，不是蠢，而是指 hard to break，例如没有任何机械部分的东西就比有机械部分的东西 stupid，从这个角度来说，静态网站比动态网站 stupid，所以我用静态网站生成器做博客，也算是 stay stupid</li>
<li>除了总体的结构，还需要注意每个段落之间每句话的结构和联系，总而言之，就是通通都是逻辑，不要拐弯抹角，不要随意用『显然』跳过推理过程</li>
</ul>
<p>第一节课的内容就这么多，我们下次再见。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近开始上一门名为 Presentation Basics 课程，其目标是: Helping nonnative English speakers build the fluency to give successful presentations。虽然风格是比较美式的，但是对于我们平日里沟通和写作都有一定的指导意义。</p>]]>
    
    </summary>
    
      <category term="展示" scheme="http://wdxtub.com/tags/%E5%B1%95%E7%A4%BA/"/>
    
      <category term="英语" scheme="http://wdxtub.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第九周 - 怕黑]]></title>
    <link href="http://wdxtub.com/2016/03/11/dark-fear/"/>
    <id>http://wdxtub.com/2016/03/11/dark-fear/</id>
    <published>2016-03-12T01:36:00.000Z</published>
    <updated>2016-03-12T03:18:57.000Z</updated>
    <content type="html"><![CDATA[<p>如果我说我忍住眼泪，如果我说我不会后悔，如果我说我忍住伤悲。因为我会怕黑，因为我厌倦雨打风吹，因为我隐藏我的眼泪。</p>
<a id="more"></a>
<hr>
<p>不知道什么时候开始怕黑，也不知道自己为什么怕黑。但是有句话这么说：Know God, No Fear; No God, Know Fear，想来我就是 No God 的那类人。看不一样的书，想不一样的理，做不一样的事，走不一样的路，自然就少了很多『牵绊』。</p>
<blockquote>
<p>It is no nation that we inhabit, but a language. by Emil Cioran</p>
</blockquote>
<p>倒是可以用这个句式来表达自己的心意：It is no goal that I pursue, but an experiment.</p>
<p>解释一下，对于目标来说，去追逐，意味着很多事情是冲着成功去做；而对于试验来说，更多是期待失败而去做。以目标的心态去做事情，成功开心，失败不开心；以试验的心态去做事情，无论成功还是失败，都算是验证了想法，都是下一次做得更好的基石。</p>
<p>这样去想，往往能放下很多没太多必要的『包袱』，轻装上阵反而更容易超水平发挥。很多人在真正达成目标的时候并没有想象中快乐，因为所谓的『快乐』本身就是虚幻的，即所谓 Phantom Happiness，不到最后，都没办法戳破自己吹的泡泡。不过话说回来，至少也达成了目标，也不是一件坏事儿。</p>
<p>Phantom Happiness 对应的恐怕就是 Phantom Pain 了，也就是 Metal Gear SOLID V 的标题。这要写起来就刹不住车了，还是留到专门的游戏评测里慢慢写个痛快，不过这里提三本相关的，严肃且黑暗的小说，看完这三本应该就对 Phantom Pain 有更深的了解，它们是《白鲸记》《一九八四》和《蝇王》。从无意义复仇，讲到极权统治双重思想，最后到个人意志与集体意志的冲突与湮灭，都是 MGS 这整个系列贯穿讨论的深刻哲学社会学问题。</p>
<p>前两天换了个莫(sha)西(ma)干(te)发型，开始了系统的运动健身计划，希望能以最好的精神面貌回国，现在真是数着日子过日子了。</p>
<blockquote>
<p>Two roads diverged in a wood, and I took the one less traveled by, And that has made all the difference.</p>
</blockquote>
<p>不要把心围上层层堡垒，不要让疲倦的心再枯萎，请不要让这一切变成不对。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果我说我忍住眼泪，如果我说我不会后悔，如果我说我忍住伤悲。因为我会怕黑，因为我厌倦雨打风吹，因为我隐藏我的眼泪。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="静静" scheme="http://wdxtub.com/tags/%E9%9D%99%E9%9D%99/"/>
    
      <category term="黑暗" scheme="http://wdxtub.com/tags/%E9%BB%91%E6%9A%97/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【潜龙谍影系列】故事、剧情与历史]]></title>
    <link href="http://wdxtub.com/2016/03/10/mgs/"/>
    <id>http://wdxtub.com/2016/03/10/mgs/</id>
    <published>2016-03-10T14:07:09.000Z</published>
    <updated>2016-03-10T19:49:33.000Z</updated>
    <content type="html"><![CDATA[<p>如果说这个世界上有第二个系列像 EVA 一样让我如痴如醉的话，那么肯定是 MGS 系列。在玩『潜龙谍影5：幻痛』的时候，每一段磁带（包含大量重要剧情信息）都认真听过之后，对于整个系列的剧情有了大概的认知。这篇文章会比较长，综合了网上的各种资料和我自己的理解，希望能给大家带来一个比较完整的阅读体验。</p>
<a id="more"></a>
<hr>
<p>Here’s to you Nicolas and Bart 尼古拉和巴特，这是献给你们的赞歌</p>
<p>Rest forever here in our hearts 你们将永远被铭记在心</p>
<p>The last and final moment is yours 最终的胜利属于你们</p>
<p>That agony is your triumph 那份痛苦和折磨就是你们的见证</p>
<p>Petals of white 片片白花</p>
<p>Cover fields flowing in grieving tears 漫散在这个被泪水淹没的地方</p>
<p>And all the hearts once new, old and shattered now 一颗颗曾年轻的心，如今也都已苍老破碎</p>
<p>Love can kill,love will die 爱能伤人，爱也会死</p>
<p>Give me wings to fly 给我翅膀去飞吧</p>
<p>Fleeing this world so cold 飞离这个冰冷的世界</p>
<p>I just wonder why 我只是不能理解这一切</p>
<p>Cold as the dark 寒冷如夜</p>
<p>Now my words, are frosted with every breath 话语已随气息而凝结</p>
<p>Still the hate burns wild, growing inside this heart 但那仇恨却越燃越盛，深深扎根于这颗心</p>
<p>When the wind changes course when the star align 若一切物是人非，沧海桑田</p>
<p>I will reach out to you and leave this all behind 我就会破除万难并回到你的身边</p>
<p>When heavens divide 当天堂破碎的时候……</p>
<p>I will see the choices within my hands 我才明了我选择的路</p>
<p>How can we ever protect and fight with our tiny souls 我们渺小的灵魂要怎样去抗争，去奋斗？</p>
<p>Let me shine like the sun through the doubts of fear 让我闪耀，像太阳一样，穿透那些恐惧的阴云</p>
<p>Do you feel the storm approach as the end draws near 而你又是否会感受到这场终结的风暴即将来临</p>
<p>When heavens divide当天堂破碎的时候</p>
<p>Time will come to softly lay me down 时间将会悄悄为我送葬</p>
<p>Then I can see a face that I long to see 这样我才能看到那个，我期盼已久的脸庞</p>
<p>And for you, only you I would give anything 为了你，只为了你，我愿意付出一切</p>
<p>Leaving a trace for love to find a way 筑出一条血路，去追寻你的足迹</p>
<p>When heavens divide当天堂破碎的时候</p>
<p>I will dive into the fire 我会为你赴汤蹈火</p>
<p>Spilling the blood of my desire 撒尽我的每一滴热血</p>
<p>The very last time 在最后的最后</p>
<p>My name scorched into the sky 我的名字将会刻入天际</p>
<h2 id="u5386_u53F2_u80CC_u666F"><a href="#u5386_u53F2_u80CC_u666F" class="headerlink" title="历史背景"></a>历史背景</h2><h3 id="1960__u5E74_u4E4B_u524D"><a href="#1960__u5E74_u4E4B_u524D" class="headerlink" title="1960 年之前"></a>1960 年之前</h3><p>1918 年同盟国（德国、奥匈、土耳其、保加利亚）和协约国（英国、法国、俄国、意大利）进行的世界大战，简称一战，约有6500万人参战，1000万人丧生，2000万人受伤。1918年，这场战争以协约国的胜利告终。</p>
<p>同年，弗拉基米尔·列宁在俄国建立了秘密情报机构格勒乌（GRU）。</p>
<p><img src="/images/14576194971120.jpg" alt=""></p>
<p>一战之后，美国、苏联、中国三大国最富有、最有权力的人——他们被称为智者议会（ Wisemen’s Committee），建立了秘密组织：哲学家（ThePhilosophers）。这些人拥有广泛的社会触角和近乎无限的资源，哲学家组织希望借助他们庞大的资源影响世界局势，让类似一战的大规模全球冲突不再重演。在成立后，哲学家的势力迅速增长，很快成为他们各自的国家政府背后的绝对权力。</p>
<p><strong>引领者出生 1922 年</strong></p>
<p><img src="/images/14576196418920.jpg" alt="引领者，又称 The Boss"></p>
<p>哲学家组织高级成员，智者议会成员的女儿引领者（TheBoss）出生。这个女子会成为美国乃至世界历史中的一位幕后的关键人物。</p>
<p><strong>第二次世界大战开始 1939 年</strong></p>
<p>1939年9月1日，德国集中强大兵力，对波兰发动“闪电战”，第二次世界大战全面爆发。</p>
<p>在二战期间，哲学家的成员收集了大量资源、金钱，总金额超过1000亿美元（大概相当于今天的1万6000亿美元左右）,意在发展新型战争手段：如核武器、眼镜蛇部队等，以终结战争。这笔巨额资产被称为“哲学家的遗产”（the Philosophers’ Legacy），而各国的哲学家组织则达成协议，在击败轴心国后，把这笔巨款返还各国。唯一取得这笔巨款的方式是一套微型胶片——胶片里储存着这些资金在各个银行的交易记录。然而，二战结束后，哲学家的遗产——即微型胶卷却被负责为哲学家洗钱的苏联军官鲍里斯·沃尔金（Boris Volgin）窃取。</p>
<p><img src="/images/14576198651470.jpg" alt="第二次世界大战"></p>
<p><strong>卡廷惨案</strong></p>
<p>第二次世界大战期间苏联秘密警察机关在苏共中央的批准下，于1940年4月至5月间对被俘的波兰战俘、知识分子、警察及其他公务员进行的大屠杀,共杀死2.2万人。因为4421人在卡廷森林被处决，故名卡廷事件。</p>
<p>窃取哲学家遗产的鲍里斯·沃尔金的儿子，时任苏联内务部内卫部队军官的叶夫根尼·鲍里索维奇·沃尔金（Yevgeny Borisovitch Volgin）上校参与了这场惨案。他的惯用手法是，将囚徒的眼罩掀开，再殴打致死。沃尔金还参与过1953年的东德反乱镇压和1956年的匈牙利动乱镇压，其本人曾不无得意地表示，他“处理”过超过10万人。</p>
<p>鲍里斯·沃尔金去世后，哲学家的遗产被其子叶夫根尼·鲍里索维奇·沃尔金继承。</p>
<p><img src="/images/14576200196071.jpg" alt="卡廷惨案"></p>
<p><strong>曼哈顿计划启动·眼镜蛇部队成军 1942 年</strong></p>
<p>二战期间，引领者创建了秘密特殊部队眼镜蛇部队。这支部队集合了联合国军最优秀的士兵，并由引领者亲自编成和训练。眼镜蛇部队所负责的任务一般绝对保密，在死前，该部队成员会用身上装备的小型炸弹进行自爆，以避免泄露秘密。在部队中，代号为苦痛者（The Pain）、恐惧者（The Fear）、末日者（The End）、狂怒者（The Fury）、悲哀者（The Sorrow）几位成员对引领者怀有特殊的情感，后来再次集结到她的身边。引领者本人则代号“欢乐”（The Joy），意为在战场上寻找到无上的欢乐。</p>
<p>同年，开发原子弹的工程曼哈顿计划在美国启动。</p>
<p><img src="/images/14576201575441.jpg" alt="曼哈顿计划"></p>
<p><strong>盟军进行诺曼底登陆行动 1944 年</strong></p>
<p>20世纪最大的登陆战役，盟军调集288万部队，横渡英吉利海峡，让英美军队重返欧洲战场。</p>
<p>由于眼镜蛇部队破坏了德军的V2导弹，在诺曼底登陆中发生了重要作用。引领者和悲哀者者的孩子山猫（Ocelot）在也在这场登陆战役中诞生，并在引领者的腹部留下一道蛇形的疤痕。</p>
<p><img src="/images/14576202257805.jpg" alt="诺曼底登陆"></p>
<p><strong>三一弹试爆，日本遭受原子弹轰炸&amp;修依·艾默里出生 1945 年</strong></p>
<p>第一颗原子弹——三一弹在美国试爆成功。同年，美国在日本投下两颗原子弹——小男孩、胖子。</p>
<p>同年，修依·艾默里克出生。他的父亲参与过曼哈顿计划，他则出生就双腿残疾。后来，他成为一名双足步行兵器的开发者。</p>
<p><strong>CIA成立·眼镜蛇部队解散 1947 年</strong></p>
<p>美国中央情报局（CIA）成立。同年，在二战中功勋卓著的部队“眼镜蛇”，在哲学家组织因为争夺哲学家遗产导致的紧张分裂态势下解散。</p>
<p><strong>朝鲜战争爆发·引领者与大首领相遇 1950 年</strong></p>
<p>1950年6月25日，朝鲜进攻韩国，朝鲜战争爆发。以美国为首的联合国军在当年9月15日从仁川登陆，帮助韩国进行反攻。10月25日，中国人民志愿军赴朝，与朝鲜并肩作战。</p>
<p>一个15岁的少年约翰（John）参与了朝鲜战争，而他将成为美国历史上最优秀的战士：大首领（Big Boss）。同样在这一年，约翰结识了传奇英雄引领者，并向引领者学习战斗、谍报、生存等多种技能超过10年以上，二人的关系和羁绊已经超越简单的师徒。二人一起创立了CQC近身格斗术。</p>
<p><strong>美国进行内华达州核爆实验·引领者暴露于大量核辐射 1951 年</strong></p>
<p>1950年，美国总统杜鲁门签署命令，宣布在内华达州的内利斯空军靶场建立内华达国家安全区。</p>
<p>1951年1月27日，内华达国家安全区在弗伦奇曼平底进行了第一次核试验，爆炸当量相当于1000吨TNT。</p>
<p>1951年11月1日，引领者参与内华达州核爆实验，暴露在大量核辐射下，失去了生育的能力。</p>
<p><img src="/images/14576205637151.jpg" alt="内华达州核爆实验"></p>
<p><strong>美国试爆第一枚氢弹·大首领暴露于大量辐射 1954 年</strong></p>
<p>美国在比基尼环礁上试爆了第一枚氢弹。约翰，即后来的大首领也被牵扯其中。他当时的朋友都因核辐射染上白血病、甲状腺癌等致命疾病，或直接死于辐射，但大首领并没有染上这类病症。尽管如此，大首领还是和他的导师引领者一样，在核辐射下失去了自然生殖的能力。</p>
<p><img src="/images/14576205854028.jpg" alt="试爆第一枚氢弹"></p>
<h3 id="1961__u5E74_-_1970__u5E74"><a href="#1961__u5E74_-_1970__u5E74" class="headerlink" title="1961 年 - 1970 年"></a>1961 年 - 1970 年</h3><p><strong>美政府实行“水星计划”·奇爱博士结识引领者 1961 年</strong></p>
<p>美国在1959年开始载人航天计划“水星计划”。尽管官方历史记载美国航天第一任是1961年5月5日进入太空的艾伦·B·谢泼德，但事实上，第一位进入太空的美国人是引领者，她在“水星计划”中扮演了重要角色，并在1961年4月进入太空，1961年4月12日返回地球。再入大气层时，引领者被宇宙辐射和再入大气层产生的热量严重灼伤，进入了长达6个月的严重昏迷。在太空俯瞰地球的震撼景象，让引领者深信世界应该团结一心，而非分阵营对立。</p>
<p>在水星计划中，引领者结识了水星计划科研人员奇爱博士，奇爱博士对引领者产生了深深的感情。</p>
<p><strong>古巴导弹危机 1962 年</strong></p>
<p>1962年，苏联在古巴秘密部署导弹，并被美国发现。肯尼迪总统大为震怒，宣布封锁古巴，要求苏联撤回已经部署的导弹设施。1962年，10月24日，美国出动90艘军舰，封锁了古巴海峡，所有导弹部队均处于高度戒备状态，全球性的核战争一触即发。最终，赫鲁晓夫同意撤回部署在古巴的导弹设施。</p>
<p>而事实上，赫鲁晓夫同意妥协的不为人知的重要原因，在于肯尼迪同意将逃往至美国的武器开发专家斯特潘诺维奇·索科洛夫遣返至苏联。被遣返回苏联后，这位武器专家被直接送到秘密设计局OKB-754。</p>
<p><img src="/images/14576208423544.jpg" alt="古巴导弹危机"></p>
<p><strong>肯尼迪遇刺身亡·小岛秀夫出生1963</strong></p>
<p>美国总统肯尼迪遇刺，其原因在于哲学家组织不满肯尼迪在猪湾事件中的表现，将其刺杀。</p>
<p>同年，日本人小岛秀夫出生。有传言他与哲学家、引领者、大首领均有神秘的关系，有人甚至认为这个出生晚于哲学家建立的日本人其实是一切的幕后黑手。实际联系至今亦不明朗，尚需进一步调查确认。（这个中二程度不轻啊）</p>
<p><img src="/images/14576209221127.jpg" alt="肯尼迪遇刺身亡"></p>
<p><strong>贞洁行动失败 1964 年 8 月 24 日</strong></p>
<p>美国政府则派出FOX部队——零少校（Major Zero）和引领者建立的CIA秘密行动小组，希望将遣返回美国的武器专家斯特潘诺维奇·索科洛夫再次营救回美国，这次任务的代号即为“贞洁行动”（Virtuous Mission）。约翰（John）,任务代号裸蛇（Naked Snake），FOX部队的第一个探员，被派往苏联丛林带回索科洛夫。</p>
<p>任务进行到一半，原本应是任务支援的引领者却向苏联变节，阻止了整个行动。引领者集结了眼镜蛇部队的一帮原成员，伙同苏联军官，哲学家遗产的拥有者沃尔金，将裸蛇打下吊桥，带走了索科洛夫。引领者将一枚微型核弹头作为见面礼送给了沃尔金，沃尔金则在苏联领土用这枚核弹打击了秘密设计局OKB-754。这枚美国核弹在苏联的引爆，导致美国的非法入侵被苏联指责，核大战危机再次一触即发。当然，贞洁行动也以失败告终。</p>
<p>在贞洁行动中，裸蛇完成了历史首次HALO降落——从高空跳下，并在低空打开降落伞。</p>
<p><img src="/images/14576210570962.jpg" alt="Metal Gear Solid 3 Snake Eater"></p>
<p>这段故事就是『潜龙谍影3：食蛇者』的剧情，于 2004年11月(PS2)/2011年11月(PS3，360版HD)/2012年6月(PSV版HD) 发售。可以看做是游戏系列里最先的一作。</p>
<p><strong>代号食蛇者行动·苏联军官沃尔金意外遭受雷击 1964 年 8 月 30 日</strong></p>
<p>为了抹杀变节者引领者,食蛇者行动展开。裸蛇乘坐单人驾驶式飞机，再次侵入苏联境内。在任务中，他得到了伊娃（Eva）的帮助，她表面上是一个前美国国安局间谍，其实是哲学家和某大国的双重间谍，裸蛇也遭遇了年轻的俄国格勒乌军官左轮山猫，与他数次交手，并在他的枪下失去了右眼，戴上眼罩。在重重的困难之中，裸蛇一一击败了前眼镜蛇部队的成员，并击毁了核搭载战车峡谷虎（Shagohod）。在追逐裸蛇的过程中，沃尔金遭雷劈，疑似死亡。</p>
<p><img src="/images/14576212112140.jpg" alt="代号食蛇者行动"></p>
<p><strong>代号食蛇者行动·引领者在苏联境内逝世</strong></p>
<p>在食蛇者行动的最后，引领者和大首领在一片花海之中展开命定的师徒之战。引领者吐露了自己的梦想，希望世界不要在冷战的阴云下割裂，而应该再次团结一心。大首领只有10分钟击败自己的导师，在时间结束之时，他们的所在地会遭到轰炸。大首领最终打败了自己的导师，在生命的最后时刻，引领者把记载着爱国者遗产交易记录的微缩胶片交给了大首领，并要求大首领杀死自己。枪响，白色的花海一片血红。</p>
<p><img src="/images/14576212725582.jpg" alt="Boss VS Big Boss"></p>
<p><strong>美国总统授予战斗英雄约翰大首领称号 1969 年</strong></p>
<p>由于成功击杀了引领者，裸蛇约翰被美国总统授予大首领的荣誉称号。但随后，他也了解到关于食蛇者行动的真相。引领者其实秘密为美国政府工作。沃尔金从他父亲手中继承了哲学家的遗产，而引领者变节的目的是接近沃尔金，拿回哲学家的遗产，但因为沃尔金意料之外地发射核弹，她的任务变了:她需要死在裸蛇手里，永远作为一个叛徒为世人所知，从而给愤怒的苏联一个交代，引领者也接受了这一任务的变化，最终死在自己门徒手中，并把哲学家遗产交给了美国。裸蛇对美国政府幻想破灭，他拒绝承认大首领的称号，并退出了FOX部队。引领者交给大首领的哲学家遗产只有一半，这一半遗产落入CIA之手，然而CIA的中央情报总监并未上报，只是留在自己的手中。</p>
<p><strong>阿帕网诞生 1969 年</strong></p>
<p>美国高级研究计划署组建了计算机网络：高级研究计划代理网络（Advanced Research Projects Agency Network），简称阿帕网。在阿帕网基础上，现代的互联网逐渐发展而来。信息串流和分享方式的革命给“爱国者”AI后来利用信息统治世界提供了技术基础。</p>
<p>事实上，后来的“爱国者”组织的创始人之一希金特也参与了阿帕网的开发，并在此后不久升任美国国防部高级研究计划局（DARPA）的局长。</p>
<p><img src="/images/14576214023876.jpg" alt="阿帕网"></p>
<p><strong>“爱国者”诞生 1970 年</strong></p>
<p>山猫刺杀了CIA的中央情报总监，取得了哲学家遗产。在哲学家遗产的基础上，大首领、零上校、左轮山猫，和两位参加了食蛇者行动的FOX前成员：空降护理和希金特建立了“爱国者”（The Patriots）组织。爱国者组织实际上是哲学家美国分布的重组。其建立目的是为了实现引领者关于世界大同的梦想。零把这个梦想解读为“没有边界的世界（World Without Borders）”，在一个规则下团结起整个世界。所以零大肆宣扬大首领的传奇，作为一种宣传控制的手段。斯内克相信零是为了自己的利益歪曲了引领者的心愿。</p>
<p><img src="/images/14576214873702.jpg" alt="The Patriots"></p>
<p><strong>黑历史之中的猎狐犬小队成立 1969~1970 年</strong></p>
<p>有着Big Boss称号的Snake早已从FOX小队中退役，开始过着训练新兵的生活。可是突然一天Snake等全部和FOX小队有关系的人员都被逮捕。原来FOX小队的指挥官Gene叛变了，Gene意图建立Army’s Heaven——这个只属于军人的国家，以打破世界的军事平衡。Big Boss在追击Gene的途中将很多人纳为了自己的同伴，比如NULL，Elisa和Johnthan等，同时这些人成立了猎狐犬小队，开始对FOX部队进行反击。最终BB干掉了MetalGear之后打倒了Gene。Gene在死前将手头上的所有资金设备全部交给了BB，并且声称BB以后一定会用到这笔资源。</p>
<p><img src="/images/14576215645424.jpg" alt="Metal Gear Solid : Portable Ops Plus"></p>
<p>这段故事就是 Metal Gear Solid : Portable Ops Plus 中的剧情，于 2006年12月/2007年9月(加强版) 在 PSP 平台发售。</p>
<h3 id="1971__u5E74_-_1980__u5E74"><a href="#1971__u5E74_-_1980__u5E74" class="headerlink" title="1971 年 - 1980 年"></a>1971 年 - 1980 年</h3><p><strong>美政府启动“魔童计划” 1971 年</strong></p>
<p>美国政府开始进行魔童计划（Les Enfants Terribles，法语，糟糕的，可怕的孩子，来自50年代同名电影）。该计划意图制造出传奇战士大首领的克隆体。该计划的幕后资助人是零，克拉克博士带头进行。零的意图不仅是要造出最强的战士，更是要保证如果和大首领分道扬镳，可以制造出另一个可以加以利用的偶像。克拉克博士参与过贞洁行动和食蛇者行动，当时代号空降护理（Para-Medic）。</p>
<p><img src="/images/14576216937761.jpg" alt="魔童计划"></p>
<p><strong>双蛇诞生 1972 年</strong></p>
<p>伊娃作为代孕母亲，魔童计划的成果——双蛇诞生。继承较优秀显性基因的孩子，就来被叫做利奎德·斯内克（Liquid Snake，液体蛇），而继承较劣质隐性基因的孩子，就是后来的索立德·斯内克（Solid Snake，固体蛇）。后来，继承了完美而平衡的基因的第三个克隆体，索利达斯·斯内克（Solidus Snake）诞生，即日后的美国总统乔治·希尔斯（George Sears）。</p>
<p>魔童计划并没有事先知会大首领，大首领为零私下进行这一计划感到愤怒。由于和零不可弥合的理念分歧，同年，大首领离开爱国者，与零分道扬镳。</p>
<p><img src="/images/14576217571827.jpg" alt="双蛇诞生"></p>
<p><strong>和平行者事件·AI核武器“和平行者”被毁 1974 年</strong></p>
<p>某一天，自称是和平大学教授的盖尔维兹与他的学生帕兹（Paz）来到无界之师的驻地，请求大首领前往哥斯达黎加调查一支神秘的武装部队，并许以一个人造浮岛基地，但是遭到了拒绝。最终由于一卷录有引领者声音的录音带，大首领答应了真实身份是为克格勃工作的盖尔维兹。</p>
<p>大首领之后在哥斯达黎加当地游击队桑地诺民族解放阵线（FSLN）的帮助下，发现神秘部队受美国中情局（CIA）指挥，将由AI控制的核武器运入哥斯达黎加。其中有一台搭载了引领者的AI——和平行者，也正是录音带中声音的来源。而这一切都是CIA中美洲站长冦尔德曼（Coldman）为了夺回自己在CIA中的地位，而计划另美苏再次陷入核危机之中。在冦尔德曼死在盖尔维兹（真名扎德尔诺夫）枪下之前，启动了和平行者的核弹发射指令。大首领在与和平行者一番激战之后，引领者的AI控制和平行者自己沉入湖中，再次给了世界一个和平的机会。</p>
<p><img src="/images/14576218515576.jpg" alt="Metal Gear Solid: Peace Walker"></p>
<p>这段故事就是 Metal Gear Solid: Peace Walker 的剧情，于 2010年4月(PSP)/2011年11月(PS3,360版HD) 发售。</p>
<p><strong>和平行者事件·三重间谍帕兹坠海失踪</strong></p>
<p>帕兹的真实身份是一名Cipher（零）的间谍。在“和平行者事件”后，回到无界之师的她开始了真正的任务。在试图破坏Metal Gear ZEKE的动力部时被奇科目击，不得已提前行动。帕兹表明Cipher希望大首领重新回到“爱国者”组织并以向美国东部发射核弹相威胁，但遭到拒绝，只能驾驶Metal Gear ZEKE与大首领开战，后被大首领击败，坠入太平洋中。</p>
<p><img src="/images/14576219542113.jpg" alt="帕兹 Paz"></p>
<p><strong>和平行者事件·雇佣兵团无界之师崛起</strong></p>
<p>通过“和平行者事件”，无界之师获得了“母基地”（Mother Base）作为基地，又说得了不少CIA与苏联的佣兵与人才，无论是兵力还是装备，都已经匹敌一个小国的军事实力，并且开始对外派遣佣兵，已可以称为民间军事企业。从和平行者上回收核弹头并自行开发了Metal Gear ZEKE后，无界之师已经成为“世界第七个核武器保有国”。</p>
<p>在击败帕兹，并再次粉碎Cipher的企图后，大首领发布了无界之师崛起宣言：“我们没有国家，没有信仰，没有意识形态。哪里需要我们我们就去哪里，不为国家，不为政府，我们为自己而战。我们战斗不需要理由，仅仅因为有人需要我们。我们会是那些无助者们的威慑力！我们是没有国界的士兵，我们的目标由我们所处的时代所决定！”</p>
<p><img src="/images/14576220334771.jpg" alt="无界之师"></p>
<p><strong>《自私的基因》发表·海上雇佣兵基地“母基地”被毁 1975 年</strong></p>
<p>修依坚持无界之师（MSF）应该向全世界证明自己的干净清白，于是MSF决定接受相关检查。在检查之夜，米勒和斯内克得到消息，帕兹活下来了，被关在欧米茄（OMEGA）营地——一个美国设在古巴的秘密据点。同时，小男孩奇科也被关在那里。帕兹和奇科都知道合金装备ZEKE，大首领必须在他们泄露信息前救回他们。</p>
<p>大首领侵入基地成功解救二人，返回时却发现母基地被攻击了，攻击者是谜之组织XOF，被神秘的疤面男子Skull Face(骷髅脸)领导。在一片混乱中大首领找到米勒，二人乘直升机逃走，母基地则毁于一片火海。但同时乘机的帕兹体内还有一枚炸弹。在帕兹跳下飞机的一刻，炸弹爆炸，大首领陷入长达9年的昏迷。（这也是 Ground Zero 原爆点的剧情，引发后面的毒蛇，山猫另其以为自己就是 Big Boss）</p>
<p>同年，美国科学作家理查德·道金斯发表著名文章《自私的基因》，首次使用模因（meme）一词，指“在诸如语言、观念、信仰、行为方式等的传递过程中与基因（gene）在生物进化过程中所起的作用相类似的那个东西。”后爱国者的“民智选择计划”和该理念有莫大关系。</p>
<p><img src="/images/14576222758289.jpg" alt="Metal Gear SOLID V: GROUNDZEROES"></p>
<p>去救出 Paz 和 Chico 的故事就是 Metal Gear SOLID V: GROUNDZEROES 的剧情，于 2014年3月20日(PS3,PS4,XBOX360,XBOXONE)，2014年12月18日(PC) 发售。</p>
<p><strong>两伊战争爆发&amp;哈尔·艾默里克出生 1980 年</strong></p>
<p>两伊战争，又称第一次波斯湾战争爆发。同年，苏联入侵阿富汗，新冷战爆发。</p>
<p>弗兰克·耶格在罗得西亚内战中，收养了成为孤儿的内奥米（Naomi）。</p>
<p><img src="/images/14576224704845.jpg" alt="两伊战争爆发"></p>
<h3 id="1981__u5E74_-_1990__u5E74"><a href="#1981__u5E74_-_1990__u5E74" class="headerlink" title="1981 年 - 1990 年"></a>1981 年 - 1990 年</h3><p><strong>1984~198X 年《潜龙谍影V：幻痛》绝密档案</strong></p>
<p>零少校为了保护大首领的安全，把大首领转移到塞浦路斯的一家医院治疗，并把大首领身边的医疗兵整形为大首领的模样，作为大首领的替身以保护大首领，代号毒蛇（Venom Snake），最后还委托山猫秘密保护大首领。大首领先于他的替身苏醒，并保护他的替身在骷髅脸的追杀下逃离医院。表达大首领苏醒的暗号即为“V has come to”。之后，大首领去建设他的军事国家，真正的“世外天堂”。毒蛇则在米勒和山猫的支持下经营壮大名为“钻石狗”的雇佣兵军队。</p>
<p>大首领的替身完成了对骷髅脸的复仇。骷髅脸研发了能携带核武器的新型合金装备：类人猿（Sahelanthropus），意图借此进入危险的核平衡。同时他强令密语者研制了一种声带寄生虫，它们寄生入人体后，如果暴露在一种特定的声音下，就会大量繁殖，杀死宿主的肺部。这种特定声音，就是某种特定的语言，即这种寄生虫能杀死说特定语言的宿主，以达到清除这种语言的目的。骷髅脸阴谋计划利用这种寄生虫杀死所有英语使用者，消灭世界通用语，让世界归于混乱和“自由”。大首领的幻影击败了骷髅脸，粉碎了他的阴谋。在过程中，大首领的幻影也遭遇了童年的魔童计划产物：利奎德·斯内克（就是白曼巴，Eli）和原本奉命杀死“大首领”，最后为了却救了他的命的狙击手“安静”（静静，Quiet）。</p>
<p>静静是Cipher安插到毒蛇身边的卧底，在医院的刺杀行动中她全身烧伤，在寄生虫疗法的帮助下幸存。她身上携带着英语种类的寄生虫，作为后备方案，把寄生虫传播到钻石狗部队和全世界。但静静怀抱着对毒蛇的特殊感情，一直闭口不言。直到静静被苏联军队抓取，毒蛇为了救她而陷入生命危险后，静静才迫不得已开口，指引直升机方向营救毒蛇。这导致了寄生虫在静静体内的爆发繁殖，静静也在开口后选择了离开。</p>
<p>而利奎德·斯内克（就是白曼巴，Eli）也在少年心理螳螂的帮助下，带着类人猿和少年士兵最终离开了钻石狗，并继续秉持着向“父亲”：大首领复仇的欲念。</p>
<p>这部分的故事就是 Metal Gear Solid V: Phantom Pain 的剧情，于 2015 年 9 月 2 日发售（PS4, XBOX ONE, PC）</p>
<p><img src="/images/14576228532142.jpg" alt="Metal Gear Solid V: Phantom Pain"></p>
<p><strong>佣兵国家“世外天堂”建立 198X 年</strong></p>
<p>80年代后期，具体年份未明，大首领利用雇佣兵时代积攒的财富扩张他的武装力量，并在南美建立了一个独立的国家：“世外天堂（Outer Heaven）”。在这个国家内，大首领建立了一个巨大的堡垒，作为他的雇佣兵公司的基地。世外天堂是大首领个人信念的产物，它一度成为了幻想破灭的士兵们的避难所，他们在世外天堂不必被当做政府的爪牙利用，也不会被社会抛弃。为了增强世外天堂的军事力量，大首领准备了TX-55型合金装备（TX-55 Metal Gear），一台两足战车，能在世界上任何一个地方直接发射核弹。</p>
<p><img src="/images/14576229516518.jpg" alt="世外天堂"></p>
<p><strong>利比里亚内战爆发·雷电参加利比里亚内战 1989 年</strong></p>
<p>1989年，利比里亚全国爱国阵线打回国内，利比里亚战争由此爆发。</p>
<p>杰克，代号雷电（Raiden）作为少年士兵参与了这场战争。索利达斯·斯内克杀死雷电的双亲后，作为教父收养了雷电，而雷电则一直被他当做战士训练培养，在战争中杀人无数，被称为“白恶魔”和“开膛手杰克”。</p>
<h3 id="1991__u5E74_-_2000__u5E74"><a href="#1991__u5E74_-_2000__u5E74" class="headerlink" title="1991 年 - 2000 年"></a>1991 年 - 2000 年</h3><p><strong>海湾战争爆发，苏联解体·索立德·斯内克加入猎狐犬部队 1991 年</strong></p>
<p>美国为首的多国部队于1991年1月17日对伊拉克开展的战争，目的是恢复科威特的领土。索立德·斯内克和利奎德·斯内克作为特种部队的成员都参加了这场战争。</p>
<p>在这场战争中，美军向士兵注射研究大首领时得到的“战斗基因”，引发了群体性的副作用。士兵们感觉肌肉疼痛、长期疲乏、失眠、丧失记忆、头晕、情绪低落、身体消瘦以及性功能减退，这些症状被统称为“海湾战争综合症”，被媒体广泛报道，但公众并不知道真正的原因。</p>
<p>同年，索立德·斯内克加入了猎狐犬部队。戈尔巴乔夫卸任苏共中央总书记一职，苏联正式宣告解体，冷战结束。</p>
<p><img src="/images/14576232053406.jpg" alt="海湾战争"></p>
<p><strong>索立德·斯内克突袭世外天堂 1995 年</strong></p>
<p>美国得知了世外天堂的存在，也得知了军事基地里有秘密大规模杀伤性武器TX-55型合金装备。此时大首领还是猎狐犬部队的指挥官，他和世外天堂的关系还不为人知。美政府决定让大首领和他的猎狐犬部队去解决危机。大首领派出了自己的儿子，索立德·斯内克(Solid 斯内克,固体蛇，那时还不知道自己是大首领的克隆儿子)去完成这个任务，但给了他一系列错误线索，让他进入一系列陷阱，不过SS都一一克服。斯内克救出了之前执行任务失败被困的灰狐，并最终打败了大首领。之后，北约对世外天堂进行了地毯式轰炸。大首领在爆炸中幸存，召集了麾下部队的幸存者，准备卷土重来。</p>
<p><img src="/images/14576232862358.jpg" alt="Metal Gear"></p>
<p>这部分的故事就是初代作品 Metal Gear 的剧情，于 1987年(MSX2/FC) 发售。</p>
<p><strong>克隆羊多利诞生·能源科学家马弗博士被绑架杀害 1999 年</strong></p>
<p>面对燃油极速消耗的世界性难题，基奥·马弗（Kio Marv)博士提出了一个解决方案：OILIX，一种综合燃料资源，可以解决潜在的全球危机。也因为此，他被一支叫桑给巴尔岛(Zanzibar Land)的武装力量绑架。罗伊·坎贝尔, 猎狐犬部队的现任头领，再次把已经退休的索立德·斯内克送上战场,营救博士。</p>
<p>在任务过程中，斯内克发现了很多冲击性的事实:灰狐已经成为了他的敌人，大首领还活着，此外——还有另外一台合金装备。马弗博士已经被折磨致死，OILIX的方程式落入灰狐之手。索立德·斯内克打败了灰狐和大首领。离开后，索立德·斯内克隐居在阿拉斯加。爱国者收回了大首领的遗体，利用纳米机器让大首领进入昏迷，其遗体一直被零上校保存。</p>
<p>同年，公众所知的第一个生物克隆体——克隆羊多利诞生</p>
<p><img src="/images/14576233891657.jpg" alt="Metal Gear：SOLID SNAKE"></p>
<p>这部分故事就是 Metal Gear：SOLID SNAKE 的剧情，于 1990年(MSX2平台) 发售。可以看做是 Solid Snake 与 Big Boss 的决战</p>
<h3 id="2001__u5E74_-_2010__u5E74"><a href="#2001__u5E74_-_2010__u5E74" class="headerlink" title="2001 年 - 2010 年"></a>2001 年 - 2010 年</h3><p><strong>911事件爆发 2001 年</strong></p>
<p>2001年9月11日上午，两架被恐怖分子劫持的民航客机分别撞向美国纽约世界贸易中心一号楼和世界贸易中心二号楼，两座建筑在遭到攻击后相继倒塌，世界贸易中心其余5座建筑物也受震而坍塌损毁；9时许，另一架被劫持的客机撞向位于美国华盛顿的美国国防部五角大楼，五角大楼局部结构损坏并坍塌。</p>
<p><img src="/images/14576235050107.jpg" alt="911事件"></p>
<p><strong>影子摩西岛事件·猎狐犬发动叛乱 2005 年</strong></p>
<p>时间已经到了20世纪，SS已在阿拉斯加隐居很久。</p>
<p>猎狐犬部队在影子摩西岛发动了叛乱，其时猎狐犬的指挥官是大首领的另一个克隆体——利奎德·斯内克。影子摩西岛存放着核武器和合金装备霸王（METAL GEAR REX）。利奎德·斯内克，左轮山猫，和其他猎狐犬部队的队友要求政府交出大首领的遗体和10亿美金，不然就要发射核弹。利奎德·斯内克的目的在于，通过大首领的遗体治疗手下基因士兵的怪病，并在影子摩西岛重现大首领的“世外天堂”。</p>
<p><img src="/images/14576235752201.jpg" alt="Metal Gear SOLID"></p>
<p>这一部分故事就是 Metal Gear SOLID 的剧情，是 Solid Snake 身世的首次揭开，也是 Metal Gear SOLID 系列的第一部作品，于 1998年(PS)/1999年(PS平台加强版)/2000(PC平台) 发售。</p>
<p><strong>影子摩西岛事件·索立德·斯内克孤身潜入影子摩西岛</strong></p>
<p>罗伊·坎贝尔再次把再次退休的索立德·斯内克拽上战场，去解救影子摩西岛的一些重要人物，然而，任务过程中，这些人全都死于死狐（FOXDIE）病毒引发的心脏病突发，而病毒是内奥米（Naomi）博士在任务前秘密注射进斯内克体内的。斯内克得知灰狐不仅没死，还被改造成了机械忍者。灰狐斩掉了左轮山猫的一只手。斯内克也在任务中遇到了坎贝尔上校的女儿梅丽尔（Meryl），和霸王的设计者哈尔·艾默里奇（修依博士的儿子），他们帮助了斯内克完成任务。</p>
<p><strong>影子摩西岛事件·利奎德·斯内克死于死狐病毒</strong></p>
<p>击败猎狐犬部队的几位成员后，索立德·斯内克得以面对他的兄弟利奎德·斯内克和合金装备“霸王”（Metal Gear Rex）。灰狐牺牲自己，给索立德·斯内克足够的时间摧毁了霸王。最终，索立德·斯内克和利奎德·斯内克近身决战，击败利奎德后，索立德·斯内克和梅丽尔一起逃出生天。利奎德不依不挠继续追逐，但最终还是死于死狐病毒。</p>
<p>而这一切的幕后黑手是时任的美国总统，这一切都是美国政府的阴谋，让斯内克带着死狐病毒进入基地，以杀死利奎德·斯内克等人。</p>
<p>当时的美国总统就是索利达斯·斯内克，总统时用名乔治·希尔斯。同年，他卸任美国总统一职。</p>
<p><strong>“慈善组织”建立 2006 年</strong></p>
<p>影子摩西岛事件之后，索立德·斯内克和奥塔肯建立了名为“慈善组织”的反合金装备非政府组织。这一组织尝试揭露关于影子摩西岛和“霸王”的真相，并呼吁世界停止建造合金装备。</p>
<p><img src="/images/14576238123776.jpg" alt="“慈善组织”建立 "></p>
<p><strong>曼哈顿油轮沉没事件 2007 年</strong></p>
<p>曼哈顿油轮事件，简称油轮事件。美国海军开发了两栖反合金装备武器“海魔鬼”（Metal Gear Ray），用一艘伪装的油轮途径纽约港运送。索立德·斯内克潜入了这艘游轮，试图拍照向世人揭露“海魔鬼”的存在和真相，呼吁停止建造合金装备。在他潜入的同时，格鲁科维奇上校也带领一队俄国士兵，准备夺去海魔鬼。正当斯内克拍摄过照片准备离开时，左轮山猫现身，杀死了格鲁科维奇上校，奉爱国者之命开走了海魔鬼，油轮被海魔鬼撕裂沉没。爱国者将这一切罪责均栽赃在索立德·斯内克身上。</p>
<p><img src="/images/14576239967912.jpg" alt="Metal Gear SOLID 2: SONS OF LIBERTY"></p>
<p>这部分故事就是 Metal Gear SOLID 2: SONS OF LIBERTY 的剧情，也是雷电首次登场，于 2001年11月(PS2)/2011年11月(PS3，360版HD)/2012年6月(PSV版HD) 发售。</p>
<p><strong>巨壳占据事件·“自由之子”劫持美国总统 2009 年</strong></p>
<p>油轮在纽约港沉没后引发了大量环境污染，美国海军趁此机会，在这里建立了建造了建造“玄武”（Arsenal Gear）的设施——巨壳（Big Shell）。玄武是一艘可潜水的巨大堡垒，为了爱国者的信息控制目的而建。一伙自称“自由之子”的恐怖分子劫持了巨壳，并控制了正在检查巨壳的美国总统詹姆斯·约翰逊。“自由之子”由美国前总统乔治·希尔斯，即索利达斯·斯内克带领，目的是获取“玄武”，并由此获取“爱国者”成员的名单。雷电（Raiden）作为一位没有任何经验的新兵，潜入巨壳营救美国总统。</p>
<p><img src="/images/14576241344850.jpg" alt="这部分同样是 Metal Gear SOLID 2: SONS OF LIBERTY 的剧情"></p>
<p><strong>巨壳占据事件&amp;美国前总统乔治·希尔斯去世</strong></p>
<p>雷电出色地一路战胜了“自由之子”的各个成员，并发现了关于巨壳建造“玄武”的真相。“玄武”守护着爱国者精心建造的大型AI：GW。事实上，在大首领离开后，零对一切失去信任，相信下一代不会明白他的意志，便建造了AI来继续爱国者的统治。爱国者的AI共分为5大部分，中枢JD，和4个分管AI：GW、AL、TR和TJ，它们统治着世界一切经济、信息、军事的运行。左轮山猫伪装成被利奎德·斯内克的右手操纵的样子，将玄武导引向曼哈顿，引发了一场大碰撞。在那里，雷电和索利达斯·斯内克决斗，并取得了胜利。</p>
<p><strong>巨壳占据事件·民智选择计划宣告成功</strong></p>
<p>雷电潜入巨壳的一切，其实都在爱国者的控制之下。爱国者试图用GW建立一个通过情报信息控制来控制人类意志的系统，目标是实现“民智选择”（称为3S计划），为达成社会思想上的健全化而进行选择。雷电潜入巨壳其实是对“影子摩西岛事件”的重演，为了测试GW能否在极限状态下发挥作用，控制雷电的行为。而随着雷电杀死索利达斯·斯内克，民智选择计划也宣告成功。在巨壳事件之后，GW这一AI就被爱国者废弃，并在后来被左轮山猫（液体山猫）重组利用。</p>
<p><strong>美国开始积极使用PMC 2010 年</strong></p>
<p>PMC是民间军事雇用企业的简称，指经营军事业务的法人企业。以玄武撞击曼哈顿事件为契机，美国开始积极使用PMC。由此，PMC在战争中的作用逐渐重要，并引发了一种新的经济模式：战争经济。到2014年，世界已形成5大PMC公司，美国2家，英国1家，法国1家，俄罗斯1家。而这些公司，都属于山猫控制的“世外天堂”。</p>
<h3 id="2011__u5E74_u81F3_u4ECA"><a href="#2011__u5E74_u81F3_u4ECA" class="headerlink" title="2011 年至今"></a>2011 年至今</h3><p><strong>“爱国者之枪”事件&amp;索立德·斯内克刺杀左轮失败2014</strong></p>
<p>为了阻止世界在战争经济中越陷越深，罗伊·坎贝尔再次请斯内克出山，刺杀领导PMC的，貌似已经被利奎德·斯内克彻底侵占意识的左轮山猫（现在被称为利奎德·山猫）。而诞生于魔童计划的斯内克，寿命被设定的极其短暂，此时已经急速衰老，呈现老人的模样，被称为老蛇（Old Snake)。在中东，斯内克和梅丽尔的小队一起行动，找到了山猫，但山猫启动了某种设备，所有体内有纳米机器士兵都陷入癫狂，斯内克本人也无奈倒地，并没有成功地刺杀他。</p>
<p><img src="/images/14576244368025.jpg" alt="Metal Gear Solid 4: Guns of the Patriots"></p>
<p>这部分故事就是 Metal Gear Solid 4: Guns of the Patriots 的剧情，也是 Solid Snake 的最后一个任务，于 2008年6月(PS3) 发售</p>
<p><strong>“爱国者之枪”事件·爱国者AI系统覆灭</strong></p>
<p>之后斯内克来到欧洲，找到了引他来此的伊娃，以及大首领的遗体。然而左轮的军队也追上了伊娃和斯内克，在和左轮部队的追逐战斗中伊娃死去，斯内克重伤，大首领的遗体则焚毁。左轮利用大首领的基因骗过了爱国者的AI网络，夺去了控制全世界武器枪械的“爱国者之子”系统。逃往影子摩西岛偷取了合金装备霸王的核弹头，去毁灭爱国者的中枢AI：JD。在最后的努力中，斯内克和他的战友们进入了左轮的海上基地：“玄武”级战舰，那里承载着被左轮重新利用的GW系统，左轮的阴谋是毁灭JD后，用GW取代JD，从而控制全世界。斯内克破坏了左轮的行动，向GW上传了活狐病毒。“活狐”以GW为跳板，摧毁了所有爱国者AI，世界被从爱国者的统治下解放出来。</p>
<p><strong>大首领死于死狐病毒</strong></p>
<p>SS在任务中遇到了很多熟人，包括给自己植入病毒的Namoi，Roy的女儿Meryl，爱国者的真相，还有在危机时刻舍生救自己的雷电(已被改造为半机械忍者形态)。</p>
<p>在这里简单说一下雷电吧，雷电在结束2代的剧情之后选择和女友Rose一起生活，但是由于雷电作为一个士兵，他无法适应这样和平又幸福的生活，而且他又害怕伤害到Rose，郁闷的雷电只好每日酗酒，再加上Rose说我们的儿子流产了，Rose改嫁Roy离开了雷电，雷电承受不了打击于是重返战场。实际上他们的儿并没有流产，因为雷电引起了爱国者的注意，在他身边不会安全。果然之后爱国者将回到战场的雷电抓了起来同时将它改造成了机械忍者。不甘被爱国者控制的雷电找到机会逃离了爱国者的控制，在路上遇到了Big mama(其实就是MGS3的Eva)，加入了他们的反爱国者组织。</p>
<p>一切结束后，斯内克去拜访引领者的坟墓。当爱国者AI离线后，大首领就从长年的昏迷中醒来。事实上，在欧洲被焚毁的尸体属于索利达斯·斯内克，而左轮被山猫的手侵占意志只是一出戏，目的是不让爱国者发现他真正的目的：唤醒大首领，找出零的位置。在引领者的墓前，大首领切断了垂垂老矣失去意识的零的生命维持设备，一场百年战争就此终结。随后，他和他的儿子——索立德·斯内克度过了一段难得的平静时光。因为和斯内克的接触，大首领感染了死狐病毒，并最终因此结束了生命。</p>
<p><strong>近未来·《合金装备崛起：复仇》时代</strong></p>
<p>其实《崛起》的时间轴是算在正专里面的，但是这是一部彻彻底底的以雷电为主角的动作游戏，所以还是单独挑出来说一下比较好。本作由小岛工作室和合金工作室合作开发，实际上一开始只有小岛工作室在开发，打算这次做一个还是以潜行为核心，但是会更注重战斗场面的游戏;但是之后白金工作室加入把本作核心放在了动作上，虽然变成一个彻头彻尾的动作游戏，但是游戏没有给MGS系列丢人。</p>
<p>主角雷电依然保持着MGS4中的机械忍者形象，而且这一次，玩家要操控他拿起手上的刀，将世界从战争危急中解救出来。游戏中会出现Sunny等一些老人物，同时也会对雷电这个人物做更多的。喜欢帅哥雷电同时又热爱高速爽快战斗的话，本作一定不能错过。
　　</p>
<h2 id="u4F5C_u54C1_u5217_u8868"><a href="#u4F5C_u54C1_u5217_u8868" class="headerlink" title="作品列表"></a>作品列表</h2><p>这里按照剧情时间顺序来介绍，而非作品的序号</p>
<p>《合金装备索利德3：食蛇者》→《合金装备索利德：掌上行动》→《合金装备索利德：和平行者》→《合金装备索利德5：原爆点》→《合金装备索利德5：幻痛》→《合金装备》→《合金装备2 ：索利德斯内克》→《合金装备索利德》→《合金装备索利德2：自由之子》→《合金装备索利德4：爱国者之枪》→《合金装备崛起：复仇》</p>
<ul>
<li>SS: Solid Snake</li>
<li>BB: Big Boss</li>
<li>MG: Metal Gear</li>
<li>MGS: Metal Gear Solid</li>
</ul>
<p><img src="/images/14576193203131.jpg" alt="系列作品年表"></p>
<p><img src="/images/14576193670265.jpg" alt="作品中的 Snake"></p>
<h3 id="MGS_3_3A_Snake_Eater"><a href="#MGS_3_3A_Snake_Eater" class="headerlink" title="MGS 3: Snake Eater"></a>MGS 3: Snake Eater</h3><p>发售日：2004年11月(PS2)/2011年11月(PS3，360版HD)/2012年6月(PSV版HD)</p>
<p>《合金装备》系列剧情的原点——故事的时间在1964年，主人公是一名美国特殊部队Fox Unit的成员，行动代号Naked Snake(裸蛇)。游戏的开场，Snake接到了一个任务——去营救被困在苏联的科学家，这名科学家的发明有着可以引发第三次世界大战的力量。在任务途中，Snake突然被自己的恩师The Boss背叛，Snake被打下山崖，任务自然以失败告终。九死一生的Snake在不久之后接到了新的任务，目的是再次拯救那位科学家，同时干掉背叛国家的The Boss。</p>
<p>最终，Snake与自己的恩师The Boss展开了决战并亲手杀掉了她。在最后我们才知道，The Boss是美国派去苏联的卧底，她的目的是拿到苏联的那份“哲学家的遗产”，但是当时的苏联将军 Volgin(沃尔金)将The Boss带来的核弹头直接在苏联境内发射了(核弹头是美方为了表示诚意以便The Boss成功潜入内部而准备的礼物。)，苏联上层不知情认为是美方所做，美国没有办法只好把锅都甩给TheBoss，决定要将她当作叛徒处理。所以就让Snake去解决掉她。所以The Boss至死都没有背叛过自己的祖国。The Boss在弥留之际说自己希望世界是一个整体而不是东方和西方。之后Snake因为干掉了TheBoss，为国家做出了贡献，被授予Big Boss的称号。</p>
<p>游戏的最后一幕就是成为了Big Boss的Snake在The Boss的无名之墓上敬礼并且留下了眼泪。这一幕在MGS系列乃至整个游戏界中都相当著名。</p>
<p>本作有令人耳目一新的“生存系统”，同时也是游戏的核心系统。玩家可以看到角色的身体状况，吃刚捕获的动物作为充饥的粮食(食物会随着PS2的系统时间的推移而腐化)，玩家需要凭借着自己的实力在森林之中找到食物，而且在中弹之后还需要手动进行包扎止血。游戏还真实的表现出CQC(近身搏斗)技巧，就像是真的潜入作战一样。</p>
<p>而且游戏不仅将“野外生存”这一主题有力地体现出来，游戏中的各种设定也十分有趣。直到现在，可以调整时间来让The End老死的设定依然让玩家津津乐道。</p>
<h3 id="MGS_3A_Portable_Ops_Plus"><a href="#MGS_3A_Portable_Ops_Plus" class="headerlink" title="MGS: Portable Ops Plus"></a>MGS: Portable Ops Plus</h3><p>发售时间：2006年12月(PSP)/2007年9月(加强版)</p>
<p>距离3代的故事已经过去了6年。有着Big Boss称号的Snake早已从FOX小队中退役，开始过着训练新兵的生活。可是突然一天Snake等全部和FOX小队有关系的人员都被逮捕。原来FOX小队的指挥官Gene叛变了，Gene意图建立Army’s Heaven——这个只属于军人的国家，以打破世界的军事平衡。Big Boss在追击Gene的途中将很多人纳为了自己的同伴，比如NULL，Elisa和Johnthan等，同时这些人成立了猎狐犬小队，开始对FOX部队进行反击。最终BB干掉了Metal Gear之后打倒了Gene。Gene在死前将手头上的所有资金设备全部交给了BB，并且声称BB以后一定会用到这笔资源。</p>
<p>作为PSP上第一款MGS作品，掌上行动已经很努力的将《合金装备》的精髓玩法带给了大家，而且大胆尝试了很多新的要素比如联机模式，招募伙伴。但是由于是第一次登陆掌机，各方面还不成熟，所以本作的实际游玩体验会打一些折扣，但是并不怎么影响掌上行动的素质，Fami也给出了39分的高分。虽然小岛没有把本作放在正传列表中，但是BB在故事中遇到的人和事其实都对之后的事件埋下了一些伏笔，所以说这款黑历史之中的《掌上行动》还是值得一玩的。</p>
<h3 id="MGS_3A_Peace_Walker"><a href="#MGS_3A_Peace_Walker" class="headerlink" title="MGS: Peace Walker"></a>MGS: Peace Walker</h3><p>发售时间：2010年4月(PSP)/2011年11月(PS3,360版HD)</p>
<p>不逊色于主机作品的掌机续作——这次故事发生在1974年，这时冷战时期也进入到了末期，形势看似和平，但是在哥斯达黎加，却遭受到了不明军队的袭击，可这里有着和平宪法的保护无法出动任何部队反击。这时在哥斯达黎加和平大学的女学生Paz和她的教授Galevz选择了请求“无国界军队”帮助，而这个部队正是由Big Boss所指挥。而且教授还给Big Boss了一份酷似The Boss声音的录音带，这让Big Boss没有理由拒绝这份委托。然而随着故事的进行，阴谋逐渐浮出水面，代号为Peace Walker的二足步行兵器(MG)已经开发完成并且加上了The Boss的AI，而Paz竟然是“CIPHER”的间谍，而且要毁灭BB全部的军队，最后经过一番苦战终于打败了Paz，Paz也坠入了大海。</p>
<p>FAMI通的满分作品，也是PSP平台非常少见的满分。在吸取了前作《掌上行动》的缺点之后，这次《和平行者》在画面，剧情和游戏性上堪称集大成之作。游戏保留了之前的漫画过场，联机与招募同伴的要素，而且在剧情上为了承上启下大下功夫，可以算是MGS的转折点。同时场景也丰富了很多，再加上成熟的动作与有趣的联动要素（比如和猎人的联动会让蛇叔和轰龙对决）使得本作算是PSP 平台不可多得的佳作。</p>
<h3 id="MGS_5_3A_Ground_Zeros"><a href="#MGS_5_3A_Ground_Zeros" class="headerlink" title="MGS 5: Ground Zeros"></a>MGS 5: Ground Zeros</h3><p>发售日：2014年3月20日(PS3,PS4,XBOX360,XBOXONE)，2014年12月18日(PC)</p>
<p>次世代的第一款MGS——故事发生在上一作《和平行者》事件结束的一段时间之后，依旧在无国界军队执行任务的Big Boss突然收到了消息称Paz没有死，而且偷偷去营救她的Chico也被一个组织抓住了，于是BB必须前去营救他们。但是同时，Huey单方面的同意了一个世界核组织对基地的检查，这就直接引出了开篇的一幕，一个称作Skull Face(骷髅脸)的角色率领了一个叫做XOF(FOX小队的对立面)小队，抓走Paz和Chico，随后他们撕下自己的XOF徽章伪装成世界核组织前去“检查”BB的基地。之后虽然BB成功的解救出了Paz和Chico但是却发现自己的基地已经被毁灭了，Paz也称自己体内还有炸弹于是自己跳下飞机爆炸，BB受重伤昏迷，无国界军队被XOF小队几乎全灭。等到BB苏醒之后，他要去复仇，找到毁灭自己基地的人究竟是谁，Huey等人为什么要背叛自己，只有接下来的《幻痛》能告诉我们真相了。</p>
<p>作为次世代的第一款MGS，《原爆点》只能算是一个《合金装备索利德5》的序章，但是本作的画面等细节方面非常出众，而且也包含了很多额外任务与彩蛋，为了迎接之后的《幻痛》，《原爆点》没有理由不去将它通关一次。</p>
<h3 id="MGS_5_3A_Phantom_Pain"><a href="#MGS_5_3A_Phantom_Pain" class="headerlink" title="MGS 5: Phantom Pain"></a>MGS 5: Phantom Pain</h3><p>故事发生在1984年，此时的游戏中和现实一样也在进行着阿富汗战争。尽管游戏大体和现实相同，但是玩家可以发现游戏内的武器和科技要远远比现实中的冷战时期先进。不光是“合金装备”本身，其他军事技术诸如外骨骼、双足机甲、光学隐形、全息影像都被各国谍报机关所使用着。其他科学技术诸如纳米技术、克隆、人工智能也进入了实用化的阶段。玩家还可以在游戏中发现一些陌生却又熟悉的枪械，例如类似AK74突击步枪的SVG-76突击步枪。而性能相对于现实有些夸张、但却让老玩家怀念的“富尔顿地对空回收系统”也重回作品并在游戏内扮演着举足轻重的角色。</p>
<p>同时，游戏还包含制作人小岛秀夫惯有的幽默气息。比如主角Big Boss可以使用的装备中有被称为“终极隐蔽科技”的道具纸箱子。玩家可以藏在纸箱子里进行移动，并突然钻出纸箱子用消音麻醉手枪击倒敌人。</p>
<p>在一手建立的佣兵组织“无界之师”（Militaires Sans Frontières）于《原爆点》结尾被摧毁后，主角大首领（Big Boss）也陷入了长达九年的昏迷。醒来后，世界发生了翻天覆地的变化，而他重新建立了佣兵组织“钻石狗”（Diamond Dogs）。在名为“毒蛇”（Venom Snake）的代号下，他重新卷入了位于阿富汗的苏联入侵行动中，目的是寻找要为袭击“无界之师”事件而负责的罪人。为了达成复仇，他重新召集了他的劲敌“山猫”（Ocelot）并与一批忠诚的战士们相遇，谱写新的历程。他与米勒（Kazuhira Miller）在复仇的过程中发现了名为“密码”（Cipher）的组织正在开发一款甚至可以超越合金装备的武器，而Big Boss的任务也迅速转变为消灭新的威胁。</p>
<p>毒蛇是本作的主角，玩家主要扮演他来进行任务。通常被称为“大首领”（Big Boss），而“毒蛇”（Venom Snake）是他行动的代号，被视为传奇。他本是“无国界之军”的一名医疗兵，在母基地遭受袭击，PAZ体内的第二颗炸弹爆炸（详情请看后面的PAZ介绍），他挡在了Big Boss前面（这就是为什么Venom Snake身体内有那么多人体碎片而BIGBOSS没有），之后陷入了长达九年的昏迷。苏醒后代替下落不明的大首领（naked snake）组建“钻石狗”，并成为领袖。率部深入阿富汗和非洲，在阿富汗战争中寻找摧毁了“无界之师”要塞的罪人并予以复仇。</p>
<h3 id="Metal_Gear"><a href="#Metal_Gear" class="headerlink" title="Metal Gear"></a>Metal Gear</h3><p>发售日：1987年(MSX2/FC)</p>
<p>包受争议的初代作品——剧情是在1995年左右，Big Boss已经建立了猎狐犬组织，这时突然得知在南非，出现了一个叫做“Outer Heaven”(世外天堂)的要塞国家，并且有消息传出这个国家在生产大杀器——Metal Gear 。于是Big Boss派出手下的一名新兵前去侦查这个国家并且营救之前去侦查结果失去联系的Grey Fox，这个人就是我们之后系列的主角Solid Snake。但是当SS不断深入之后发现Big Boss给自己的通信越来越奇怪，时常将自己引到陷阱之中。原来这个世外天堂的建立者就是自己的上司Big Boss。最终SS摧毁了整个基地，粉碎了Big Boss的野心。</p>
<p><img src="/images/14576254881646.jpg" alt="Metal Gear"></p>
<p>作为全系列的第一部作品，游戏本身的素质堪称上乘，潜入式的玩法在当时给人耳目一新的感觉，但由于MSX2平台只在日本地区发售的原因，本作并未在全球范围内引起热潮放在那个时代本身素质还算过得去，丰富的道具和有趣的游戏模式也算能让人玩的下去，但是这作而由于当时KONAMI错误的市场估计，所以之后在美国并未发行MSX2的初代合金装备(很大一部分原因是因为MSX2主机根本没有在日本以外的地区发售。)，更加糟糕的是，KONAMI在没有令小岛秀夫参与制作的情况下，单方面让美国分部在NES上发行所谓的FC版，而美国的小组则自作主张将游戏内容进行改编，反而使得游戏丧失了原版的精髓，最终BOSS也由Metal Gear变为了庸俗的所谓“控制MG的电脑”。小岛秀夫已经认定FC版的合金装备并非正统，甚至认为就是一款彻头彻尾的垃圾作品。所以本作的争议很大，这也直接导致小岛要出一个为自己正名的续作。</p>
<h3 id="Metal_Gear_2_3A_Solid_Snake"><a href="#Metal_Gear_2_3A_Solid_Snake" class="headerlink" title="Metal Gear 2: Solid Snake"></a>Metal Gear 2: Solid Snake</h3><p>发售日：1990年(MSX2平台)</p>
<p>Solid Snake与Big Boss的决战——故事发生在上作的4年后，Zanzibarland(桑给巴尔岛)上的一个军事政府突然突击了各国的核武器安放库，由于核平等条约的束缚，这个国家反倒成为了唯一可以使用核武器的国家，对世界造成了巨大威胁。这时解决了Outer Heaven危机的SS临危受命，前往这个小岛解救被绑架的Marv博士，这位博士发现了一个可以精炼石油的微生物，所以他对这个小岛统治全球的计划是关键性的人物，SS需要把世界从危急之中解救出来。</p>
<p><img src="/images/14576255533327.jpg" alt="Metal Gear 2：SOLID SNAKE"></p>
<p>在任务的最后，我们会遇到我们的熟人Big Boss，最终决战自然是以Big Boss战败收尾，而Big Boss也结束了他传奇的一生。SS也到阿拉斯加隐居起来，不再参与战事。值得一提的本作实际是只有日版，美版自己做了一款叫做《斯内克的复仇》的游戏，模式是类似于魂斗罗的横版射击，小岛自然无法认同这部被“糟蹋”的作品，再加上本作由于MSX2只有日版，所以《斯内克的复仇》压根没有在日本发售。</p>
<p><img src="/images/14576256407693.jpg" alt="Metal Gear 2：SOLID SNAKE"></p>
<h3 id="MGS"><a href="#MGS" class="headerlink" title="MGS"></a>MGS</h3><p>发售日：1998年(PS)/1999年(PS平台加强版)/2000(PC平台)</p>
<p>Solid Snake身世的首次揭开——时间已经到了20世纪，SS已在阿拉斯加隐居很久，但是突然有个部队占领了一个阿拉斯加的军事基地，并且抢到了正在做演习的Metal Gear Rex，而这个部队正是SS之前所在的猎狐犬小队，这次叛变也就被成为“影子摩西岛事件”。猎狐犬小队仗着自己拥有可以发射核武器的Metal Gear，向美国索要大量金钱，更重要的是他们还要Big Boss的遗体。当时在掌上行动中出现的ROY上校亲自请求SS出马，拯救被猎狐犬绑架的人质，解决这次危机。但是在SS在执行任务的途中，他发现自己要拯救的人质在看到他之后都会莫名其妙的突发心脏病死亡，而且还遇到了不少关系到SS命运的家伙，比如Ocelot(山猫，在与SS决斗的时候被NULL砍掉了一个手臂)，Meryl(ROY上校的侄女，不过实际上是女儿)，NULL(掌上行动时的忍者，也就是灰狐gray fox)，Otacon(MG Rex的设计师)。</p>
<p>最终我们遇到了实施整个事件的头目，他就是Liquid Snake。这个和SS拥有一样长相的人告诉了SS他们的身世：其实他们都是一个叫做魔童计划(Les Enfants Terribles/恐るべき子供达计划) 的产物，这个计划就是利用Big Boss的基因，制造出很多像BB一样伟大的战士，两个人都是克隆体，其实是兄弟。</p>
<p>但是Liquid说自己是继承了的是劣质基因，SS继承了优质基因，由于痛恨自己的基因不足必须干掉SS，而且还要超过Big Boss——重建世外天堂。不过最终Liquid还是败在了SS的手下，但是在最后时刻SS在一场汽车追逐战中翻了车，动弹不得，Liquid拿着枪走了过来却在准备开枪之时突然心脏病突发死亡。SS总归还是完美完成了任务。</p>
<p>实际上，Liquid率领的猎狐犬小队叛乱并不是他一个人的计划，而是在山猫和美国总统Solidus Snake的怂恿下进行的。而Solidus Snake则是BB的完美克隆体。而任务中的那些突发心脏病死亡的人其实是受到SS身上一种叫做死狐病毒(fox die)的影响，这种病毒可以直接引起一些特定基因的人死亡。这个病毒是一个叫Naomi的医学家在SS不知情的情况下为它注射的，Naomi是Gray Fox的妹妹，他知道以为自己的哥哥是被SS所杀所以想利用这个病毒杀掉SS复仇，但是由于期间和SS接触久了之后发现其实自己的哥哥并不恨SS，自己也知道SS当时也不迫不得已，但是由于已经注射了病毒，只好将死狐病毒的发作时间改成了随机发作(实际上一直到4代中才有些发作的体现。)</p>
<p>最后讽刺的是Liquid Snake实际上是优质基因的继承者，他的实力完全是在SS之上，但是最后的失败也正式MGS1想告诉玩家的主题——永远不要被命运或者基因所束缚。</p>
<p>《MGS1》开创3D潜入的先河，同时也率先引领了电影化叙事的潮流，而且剧情全部都是即时演算，这在当时大量依靠文字或者图片叙事的游戏之中，MGS这种表现手法实在让人眼前一亮。而且距离上一作距离8年之久，这样一个回归是非常令人震撼的，成功的为MGS在这个时代的平台树立起自己的招牌。</p>
<h3 id="MGS_2_3A_Sons_Of_Liberty"><a href="#MGS_2_3A_Sons_Of_Liberty" class="headerlink" title="MGS 2: Sons Of Liberty"></a>MGS 2: Sons Of Liberty</h3><p>发售日：2001年11月(PS2)/2011年11月(PS3，360版HD)/2012年6月(PSV版HD)</p>
<p>新主角雷电的初次登场——MGS2的故事大致可以分成前轮篇和Big Shell篇。</p>
<p><strong>油轮篇</strong></p>
<p>发生在MGS1结束后的2年，山猫夺取了MG的数据并且在黑市上兜售，这导致很多国家都可以制造出MG这种危险兵器。SS便和Otacon一起成立了一个反MG的组织——Philanthropy(慈善事业)，两人开始四处摧毁被制造出来的MG。突然他们得到消息，称纽约附近的油轮上有新型的两栖用MG，于是SS立即前去准备破坏它。但是在到达油轮底层之后发现了其实这一切都是山猫在捣鬼，他假装和其他国家的军官合作但最终的目的是为了夺取新型MG。当SS和山猫对峙的时候山猫右臂抽搐然后仿佛换了个人似的说：“好久不见了，兄弟。”原来当初山猫被砍掉右臂之后又移植了Liquid Snake的胳膊，所以Liquid Snake有时就会控制山猫的心智。之后山猫恢复了意识，驾驶MG破坏了游轮后逃走，并且在网上大肆散布SS在游轮上的照片，让大众将SS视作了恐怖分子，同时油轮篇的故事到这里为止了。<br>　　<br><strong>Big Shell篇</strong></p>
<p>雷电在执行这次任务之前也仅仅是一个新兵菜鸟。而这一次他的任务就是去海洋设施拯救人质(《MGS》非常喜欢用解救人质开头)。还记得之前油轮篇的油轮吗?山猫在将它破坏之后石油散落在大海之中，于是建立了一个海洋净化设施Big Shell，而这里明显不单单是一个环保设施。果然，雷电在执行任务的途中遇到了SS和Otacon等人，同时也知道了这个设施其实下面隐藏着一台由爱国者控制的超级数字战舰，而这一切都是由前任美国总统Solidus Snake，现在的恐怖组织头目所策划的，他自称Sons of Liberty(自由之子)，还绑架了即将当选的下任总统，而且Solidus Snake也是雷电的养父，是他将小时候的雷电从战场中捡了回来。<br>　　<br>当剧情进行到全部人员都汇集到超级战舰之上的时候，山猫终于说出了自己的目的：原来这一切都是爱国者计划好的，故事中的一切的事件都与影子摩西事件一模一样，都是为了重现当年的事件（详细可以查看S3计划）。随后山猫进入了Metal Gear Ray的驾驶舱，跳进了大海，SS也随即跳入海中，战舰上只留雷电和Solidus Snake两人。最终战舰撞向了美国纽约，最后在国家纪念堂前才停了下来。</p>
<p>这时Solidus Snake 也说明了自己做这一切的目的：他做的这一切都是为了摆脱爱国者的控制，现在爱国者过于强大了，我们全部的行为都会受到爱国者的保护，但是这样一来我们自己能为后代留下什么遗产?!一般人类还可以通过基因流传，而他和SS等克隆人没有生育的能力，他们最终只会被历史遗忘，他要做的就是永远的被历史所铭记，要战胜爱国者，解放人类，成为“自由之子”。之后雷电接到通信，通信中说明了爱国者现在的状态：爱国者现在其实是一个为了生命数字化而制造的超级电脑，如今人类身上都植入了纳米机器人用来治病或者强化身体，而爱国者正是通过这个机器人收集人类的信息，于是为了人类的未来，他会主动过滤掉一些无用的信息，从而慢慢控制人类的思想，感情。而这整个的事件，不过就是爱国者的试验罢了。<br>　　<br>最终，雷电和Solidus Snake的决战在所难免，雷电靠自己高超的剑术击败了Solidus Snake，Solidus Snake掉下房顶死亡。最终雷电打算加入SS寻找爱国者的所在，但是SS却说还有更重要的事在等着你，原来自己的女友Rose早已在后面等他。</p>
<p>跨入PS2时代的《MGS2》带不仅仅在画面上有了突破，更是正式加入了第一人称的射击视角(其实在MGS1代完全版中，只要你通关一遍即可开启第一人称视角。)，而且本作还有很多有趣的故事，比如用雷电裸奔的剧情，现在也时常会被玩家拿出来开玩笑。<br>　　<br>值得一提的是小岛在游戏发售之前没有任何一次提到过会换主角，宣传视频也一直就是蛇叔，但是当玩家拿到手上玩到雷电的时候，小岛承认是自己骗了大家，希望大家能自己感受到换主角那种惊喜。这款游戏还有一个小插曲，2001年在游戏宣传的时候提到过最后战舰冲向纽约破坏了一群建筑的剧情，其中就是纽约世贸大楼，但是就在之后9.11发生了，为了避免这一个敏感问题小岛只好直接剪掉了那一段动画，剧情也就变成了战舰冲向纽约之后直接切入最终战的样子。</p>
<h3 id="MGS_4_3A_Guns_of_the_Patriots"><a href="#MGS_4_3A_Guns_of_the_Patriots" class="headerlink" title="MGS 4: Guns of the Patriots"></a>MGS 4: Guns of the Patriots</h3><p>发售日：2008年6月(PS3)</p>
<p>老蛇的最后一个任务——故事发生在2014年，在这期间，上次驾驶MG逃走的山猫成立了全球级别的专业的佣兵部队PMC，同时将称为“SOP”(爱国者之子)系统的纳米机器人全部植入PMC之中，包括人和武器，而这个系统目的就是控制士兵情绪，达成降低战争成本的目的。而且山猫这时已经被称为Liquid Ocelot，拥有大量MG，这一切都需要让这位已经略显老态的传奇战士再次出马了。</p>
<p><img src="/images/14576260972014.jpg" alt="Metal Gear Solid 4: Guns of the Patriots"></p>
<p>SS在任务中遇到了很多熟人，包括给自己植入病毒的Namoi，Roy的女儿Meryl，爱国者的真相，还有在危机时刻舍生救自己的雷电。当然，最后我们面对的还是我们的老朋友——山猫。从山猫口中，我们得知其实Liquid并没有控制自己，或者说之前的双重人格都是山猫为了破坏爱国者而演出来的。因为爱国者早已控制了几乎整个世界，所以想骗过爱国者给它植入病毒那就必须先骗过自己，于是通过药物和心理暗示让自己成为Liquid。最终目的达到了，他成功的给爱国者的AI植入了FOXLIVE病毒使爱国者全部崩溃，解放了整个世界。但是最终，我们和山猫那持续了几十年的恩怨，也要在今天划上一个句号。</p>
<p>打败了山猫之后，SS来到了The Boss的墓地，拿出手枪准备了结自己，但在这个时候，我们看到了通过手术复活的Big Boss和已经成为植物人的Zero(爱国者的建立者，BB之前的同伴)，BB对SS说：“我们之前为了The Boss的理想做了那么多事，如今我们时代已经过去了，你一定要活下去。我从来没有把你当作儿子来看待，我一直看作你是一个伟大的战士，我认为即使当时是你面对着The Boss ，你也能扣下扳机。”，之后他拔掉了Zero的氧气管，走进SS自己主动感染他的死狐病毒。SS在帮BB点完一根雪茄之后，选择了坚强活下去，最终和Otacon一起出门旅游，蛇叔的传奇一生也到此为止了。</p>
<p>本作在科学的支持下蛇叔可以使用光学迷彩从而做到像变色龙一样的隐藏在周围的环境之中，带给玩家全新的体验。不过这次最强大的地方就是小岛把这部老蛇的最终作狠狠的玩了一把情怀，特别是当剧情进行到重回影子摩西岛，看到MGS1的故事地点在PS3上再现的时候，系类玩家都会为之感动。而且在最终和山猫决战时，好几个阶段的UI也是从1到4逐渐的变化，不得不说小岛这次真的是把情怀牌打到了极致。</p>
<h2 id="u4EBA_u7269_u4ECB_u7ECD"><a href="#u4EBA_u7269_u4ECB_u7ECD" class="headerlink" title="人物介绍"></a>人物介绍</h2><h3 id="u5F15_u9886_u8005_The_Boss"><a href="#u5F15_u9886_u8005_The_Boss" class="headerlink" title="引领者 The Boss"></a>引领者 The Boss</h3><p>事迹：二战时率领眼镜蛇部队加速结束战争/贞洁行动中做卧底假装背叛/食蛇者行动中死于BB手下</p>
<p>The Boss的一生是一段传奇，她最早是作为二战的眼镜蛇特种部队的队长为美国执行任务，但是在二战结束之后，她发现了这个世界的变化并不是她想象中的那样。虽然表面上战争结束了，但是 “哲学家”却开始了更加残酷的战斗，不仅仅世界四分五裂，连自己之前的部下也都各奔东西，甚至成为了敌人。而为国家一直战斗的The Boss最终被美国所抛弃，原本的间谍被当作叛徒，而亲手杀掉这个“叛徒”的人就是Snake，也就是之后的Big Boss。但是实际上，The Boss至死至终即使牺牲了自己的丈夫，离开了自己的儿子，都不曾背叛自己的国家，是一名伟大的爱国者。</p>
<p>但是在Snake看来，The Boss是自己的老师，她养育了Snake，教给了他知识与战斗的方式，但是他对The Boss更多的是爱，甚至超越了老师或者母亲。(EVA在MGS3领走的时候也说过：自己无法取代The Boss在Snake心中的地位。)所以在Snake击败The Boss之后，他获得了Big Boss的称号，同时也为了实现The Boss的理想走上了另一条道路。</p>
<blockquote>
<p>One must die and one must live. No victory, no defeat. The survivor will carry on the fight. It is our destiny… The one who survives will inherit the title of Boss. And the one who inherits the title of Boss will face an existence of endless battle.” ―The Boss to Naked Snake</p>
</blockquote>
<p>这是The Boss在最终决战的时候对Snake说的：“我们之间必须要死一个，不是为了胜利，也不会有失败，只是单纯的宿命罢了。胜者将会继承boss的名号而且之后也会带着它去面对无尽的战斗。”不得不说The Boss虽然本人只出现在了MGS3代，但是她给BB带来的影响才导致BB之后做的一连串事件，所以The Boss其实从开始一直贯穿到了全部故事的最后。</p>
<p>顺便一提在《和平行者》中，Peace Walker采用的AI就是The Boss，可以说是The Boss在一定意义上的复活，同时Peace Walker最后的自杀也表明着The Boss即使只留下一个思想，也不会背叛自己的祖国。</p>
<h3 id="Big_Boss"><a href="#Big_Boss" class="headerlink" title="Big Boss"></a>Big Boss</h3><p>事迹：食蛇者行动杀掉The Boss，成为Big Boss/成立爱国者组织/创立猎狐犬小队/创立无国界军队/创立世外天国</p>
<p>Big Boss的故事在之前的作品介绍中我们应该都能了解很多了。他是一个连国家都会害怕其力量的战士，Big Boss的一生到底去过哪些地方参加过多少战争已经很难统计了，但是可以确定的是，对于Big Boss，几乎没有不可能完成的任务。BB在3代食蛇者任务完成之后加入了爱国者组织。但是BB的思想其实一直离不开战斗，或者说BB就是一个天生的战士，最终他还是离开了组织，选择自己作为一个战士打开新的道路。</p>
<blockquote>
<p>We have no nation, no philosophy, no ideology. We go where we’re needed, fighting not for country, not for government, but for ourselves. We need no reason to fight. We fight because we are needed. We will be the deterrent for those with no other recourse. We are soldiers without borders, our purpose defined by the era we live in.</p>
</blockquote>
<p>BB的这句话诠释了自己——</p>
<p>“我们不属于任何国家，我们也不会为了任何国家或者政府而战斗。战斗的理由只因为我们自己需要而已。我们是不受国界约束的战士，我们生存的地方要由自己决定。”</p>
<p>当然这种思想也直接导致他后来建立世外天国打算用武力来实现The Boss世界统一的理想。而Big Boss也败在了自己的“儿子”——SS手上。在4代的结尾，年近80的BB已经彻底看开了这一切选择了离开这个世界。</p>
<blockquote>
<p>This is good… Isn’t it?</p>
</blockquote>
<p>这是他的最后一句台词。战斗了一生的Big Boss，这样安静的离开才是最好的结局吧。</p>
<h3 id="Solid_Snake"><a href="#Solid_Snake" class="headerlink" title="Solid Snake"></a>Solid Snake</h3><p>事迹：打败Big Boss，成功化解世外天国危机与桑给巴尔岛危机/化解影子摩西岛事件，打败Liquid/成立反MG组织/协助了MGS2中雷电的行动/打败山猫，破坏爱国者电脑</p>
<p>SS的故事同样是一段传奇，他曾数次将世界从危机之中拯救出来。他打败了自己的“好朋友”，“兄弟”甚至是“父亲”。和Big Boss不一样，SS并不喜欢战斗，相反，他在完成任务之后会选择隐居。但是作为一个战士，他也是无可挑剔的;不过作为一个人，他有一些可悲，SS本身就是为了当作一个战士而克隆出来的，而且当初克隆时为了防止BIG BOSS的基因外流(比如Solid Snake被敌人捕获，克隆出新的BIG BOSS样的战士)而特意设计出会让SS快速老化，所以在经历一定年限之后就会开始迅速老化，是不可遏制的，这些应该已经写进Snake的DNA，无法改变。</p>
<p>而且SS的体内还被注射了死狐病毒这一颗炸弹，他快速老化的身体环境还改变了旧的FOXDIE病毒，有可能传染给非特定基因人群，将成为生物武器。所以他身边人其实是被自己的病毒感染致死。不过在MGS4的最后，SS在和BB对话完了之后放弃了自杀选择在剩下的时间之内周游世界。这样的故事对于SS的一生，也算了令人满意的结局了。</p>
<h3 id="Liquid_Snake"><a href="#Liquid_Snake" class="headerlink" title="Liquid Snake"></a>Liquid Snake</h3><p>事迹：BB的克隆体，SS的兄弟，优质基因继承者/率领猎狐犬小队叛变，实施影子摩西岛事件/借山猫“复活”</p>
<p>Liquid是一个天才，因为他继承了BB的优质基因，所以无论是战斗力还是策略能力都在他的“孪蛇”兄弟SS之上。同时，他实施的影子摩西岛事件也成为了MGS走向的一个巨大转折点。但是这样一个天才，却因为对自己能力的不自信而认为SS才是优质基因继承者，于是他开始嫉妒又憎恨自己的兄弟。在MGS1故事的最后几场战斗，Liquid意外的都输给了SS，虽然在最后关头SS翻车被Liquid找到机会，但是他自己却被死狐病毒感染致死，也就是最终他也不知道其实自己并不是天生比SS弱，自己会输真的是因为基因无法决定命运。Liquid虽然就这么退场了，但是他告诉了SS的身世，幕后的几个黑手也都浮出水面。在《合金装备索利德5：幻痛》的预告片中，我们能看到一个叫做Eli的小男孩，从各方面看来他和Liquid真的是非常相似。同时还有一对双胞胎似的少年，下面写了魔童计划，相信《幻痛》会对这对孪蛇的这段时期有一个交代吧。</p>
<h3 id="Ocelot"><a href="#Ocelot" class="headerlink" title="Ocelot"></a>Ocelot</h3><p>事迹：创建爱国者组织/怂恿Liquid策划影子摩西岛事件/夺取REX设计图并买到黑市/怂恿Solidus Snake开始行动/用Liquid的人格骗过爱国者同时摧毁了爱国者电脑</p>
<p><img src="/images/14576382123468.jpg" alt="Ocelot"></p>
<p>山猫的父亲是The Sorrow(MGS3中出现过他的亡灵)，母亲就是The Boss。如果说BB或者SS是天生的超级战士的话，那么山猫就是天生的完美间谍，简单梳理一下山猫的一生：最早出生的时候就被 “哲学家”组织带走用来当作人质控制The Boss(实际上山猫不知道自己的父母是谁)，之后山猫就由“哲学家”培养成一名间谍安插在当时的CIA身边，而CIA又把他派去苏联在Volgin将军手下当间谍。所以单单在MGS3中，山猫就是一名双面间谍。</p>
<p>随后山猫在MGS3的最后拿到了那笔“哲学家的遗产”，创建了“爱国者”。故事就进行到了MGS1，山猫有作为间谍安插在当时的美国总统Solidus Snake身边，而Solidus Snake却不知道山猫其实就是一直控制自己的爱国者，Solidus Snake又将山猫派去Liquid身边当间谍，主要目的就是怂恿Liquid叛变，试验一下人类能否反抗爱国者。所以说Liquid自己也不过就是一个被利用的棋子罢了。在 MGS1的最后，山猫拿走了REX的设计图，同时之后移植的Liquid的右手之后形成的Liquid人格也成为了他反抗爱国者计划的重要的一环。</p>
<p>在MGS2中，山猫一开始夺取了RAY的原型机(油轮篇的剧情)，假装在Solidus手下帮他做事，实际上他是爱国者安排在Solidus身边收集集S3计划数据的人选。当收集数据的目标完成后，他主动坦白自己其实是爱国者的间谍，如今目的已经达成了。随后他变成Liquid的人格驾驶着原型机RAY逃离了战舰。</p>
<p>山猫组建PMC，同时开始了他最后一段间谍生涯——成为自己的间谍，破坏爱国者。山猫知道爱国者知道自己的想法，想要骗过它就必须骗过自己，于是Liquid，这个通过心理暗示出现的人格成功的骗了自己，也骗了爱国者。等于说是山猫实现了当时The Boss的理想，而最终败在自己一直追赶的偶像——Big Boss的克隆体手上，最后那一句：“You’re pretty good。”也代表着山猫和Snake家族这50多年的恩怨终于了结。</p>
<h3 id="Zero"><a href="#Zero" class="headerlink" title="Zero"></a>Zero</h3><p><img src="/images/14576381904423.jpg" alt="Zero"></p>
<p>事迹：建立“爱国者”组织</p>
<p>Zero其实没有在任何一代游戏之中作为主要人物出场，他一直处在一个幕后的位置，但是他所做的一切，在MGS系列中都有举足轻重的地位。首次登场就是在MGS3，他当时只是一个负责传达命令的配角，和其他人一样，Zero也不过是一个行动代号罢了，而且他还有一个很重要的外号，叫做Cipher(也有零的含义)。</p>
<p>在MGS3的最后，山猫拿到“哲学家遗产”之后就和Zero一起创建了爱国者组织，是爱国者的创始人之一。起初他们的目的就是利用手上的这笔财产实现The Boss当时世界统一的理想，但是之后他和Big Boss之间的理念产生了重大分歧(具体内容可以查看爱国者和魔童计划)，在Big Boss走后Zero变得非常恐惧，他非常害怕这样强大的Big Boss会与自己做对，于是魔童计划的产物孪蛇和solidus出现了。Zero也在bb的身边安插了间谍Paz(《和平行者》中的故事)，在Paz失败之后Zero开始专心着手爱国者AI的研究(期间的空白期5代可能会补充。)，在自己老了之后依靠着生命维持装置苟延残喘，最终被Big Boss拔掉了氧气管死亡。</p>
<h3 id="Paz"><a href="#Paz" class="headerlink" title="Paz"></a>Paz</h3><p>事迹：《和平行者》中BB身边的间谍，《原爆点》中BB需要解救的人质，疑似在《幻痛》之中的死而复生的神秘人物</p>
<p><img src="/images/14576382767731.jpg" alt="Paz"></p>
<p>Paz是Cipher安排在bb身边的间谍，她一开始说自己只有16岁，是一名大学生，当然这些都是伪造的，目的就是夺取MG，杀掉bb。但是这样一个看起来狡猾狠毒的间谍，随着故事的进行却渐渐的被BB一行人所改变。特别是在《和平行者》的后面，部队要举行聚会活动，士兵们都要求Paz上去唱歌，作为一个间谍大可不去理会，但是Paz心理却想先放下任务，去和大家一起庆祝。</p>
<blockquote>
<p>Paz：“士兵们也都很期待.事到如今也无法拒绝了。”<br>Paz：“虽然我没有在人前唱过歌.但是像这样被期待著感觉也不坏。”<br>Paz：“只少我敢保证唱的一定比米穆好。”<br>Paz：“可是ZEKE的改造已经完成了.我必须要达成我的使命不可了。”<br>Paz：“要是背叛了CIPHER.一定会让我尝到比死还恐怖的绝望吧。”<br>Paz：“可是。”<br>Paz：“应该也不是马上就得实施计画不可吧。”<br>Paz：“稍微晚一点实行应该也不是问题吧。”<br>Paz：“难得的和平日…只少等到那天应该没关系吧。”<br>Paz：“说不定.是我自己把问题给快转了也说不定。”<br>Paz：“到了那一天.不管怎麼样我跟Snake一定有一方会死。”<br>Paz：“就算这样…”<br>Paz：“只少在和平之日来临之前.先想办法瞒住CIPHER。”<br>Paz：“不知为何我开始想著这样的事….”</p>
</blockquote>
<p>这是在《和平行者》中Paz的录音记录，可以看出她并不是一个单纯甘心被利用的“机器”。之后，Paz掉入海中，被渔民救起却被XOF部队抓走进行虐待(《原爆点》剧情)。</p>
<h3 id="Chico"><a href="#Chico" class="headerlink" title="Chico"></a>Chico</h3><p><img src="/images/14576384343657.jpg" alt="Chico"></p>
<p>Chico是哥斯达黎加民间反抗组织——Sandinista National Liberation Front的一个少年兵，他有一个父亲，一个姐姐，他的父亲就是这个组织的首领，Chico算是这个组织里面的小少爷。可是之后他的父亲战死，组织的领导就落到了他的姐姐头上。而Chico一直想成为一名独当一面的战士，就像bb那样，于是乎他和姐姐率领这组织一同加入了bb的无国界军队。在军队之中，Chico看到了Paz并且对她一见钟情，当Paz坠海之后，大家都以为她死了。但是随后有人给军队放出消息称Paz没死，在我们手上做人质。Chico听到决定就独自一人触发营救Paz，结果就是《原爆点》的剧情，自己被俘虏还被虐待，最终还当了叛徒告诉了BB基地的所在位置，导致XOF部队能如此快速的对BB进行打击。故事的最后并没有给Chico一个具体的交代，看来只有在《幻痛》中才能知道这个少年的结局了。</p>
<h3 id="Kazuhira_Miller"><a href="#Kazuhira_Miller" class="headerlink" title="Kazuhira Miller"></a>Kazuhira Miller</h3><p>事迹：和BB一同管理无国界军队，一起战斗</p>
<p><img src="/images/14576384591948.jpg" alt="Kazuhira Miller"></p>
<p>Miller其实是在二战期间一位美国将军与一位日本女人生的孩子，在Miller长大之后他的母亲就去世了，他选择了加入日本自卫队保护国家，维护和平，他的名字中的Kazuhira其实就是和平的意思。但是Miller在做了一段之后发现日本自卫队并不能有他心理那种维护和平的感觉，于是他选择离开日本加入佣兵部队。在一次行动中他遇上了BB的小队，结果自己部队被全灭，他想使用手雷和BB同归于尽，但是却被BB救了。从此之后他就死心塌地一直跟随BB成立无国界军队，而自己在军队中处于一个管家的地位，负责后方为bb提供支援。</p>
<p>值得一提的是Miller非常喜欢美女，因为他总是和部队里面的女性扯出一些关系，BB还揍过他。但是在原爆点的最后，基地被炸毁无国界军队随之消失，他和BB之后的故事就只能期待《幻痛》了。</p>
<p>对于他的死其实并没有交代的特别清楚，在MGS2中，会有一名自称Miller的教官一直为你提供情报，关于这个教官官方的设定是：曾在日本陆上自卫队、SAS、陆军特殊部队军団、美国海军陆战队服役，还和Big Boss两度合作成立和经营佣兵组织，最后成为了Foxhound的教官。当时被称为“鬼教官”，队员们对他极为尊敬故称他为“Master Miller”。现在已辞退了教官之职，在阿拉斯加与大自然一起生活。</p>
<p>但是在最后Liquid告诉你那个Miller其实被自己干掉了，也就是说当年那个Miller其实死在了Liquid手下。</p>
<h3 id="Huey"><a href="#Huey" class="headerlink" title="Huey"></a>Huey</h3><p>事迹：开发Peace Walker/协助bb和无国界军队/“背叛”BB导致基地毁灭</p>
<p><img src="/images/14576385384049.jpg" alt="Huey"></p>
<p>Huey有2个很有名的孩子——其中一个就是Otacon，两者长的真的是一模一样，性格也是;还有一个就是Emma，也就是MGS2中制作病毒摧毁爱国者GW的那个妹子。Huey是一名MG的开发人员，Peace Walker就是他和奇爱博士一同开发完成的(他负责机械，奇爱负责AI。)，但是做出Peace Walker并不是他的本愿，他被寇曼所欺骗，认为制作这台机器的原因是为了保护和平。这一点和他儿子Otacon非常相似——都是天真的科学宅。Huey在知道和平行者要发射核弹之后毅然决然的离开了寇曼投奔BB，开始为BB做技术支援，之后也就有了《原爆点》的剧情。但是Huey不知为何私自答应一个所谓的“世界核武器检查”的组织的要求，同意他们来到基地。在这之后基地就被敌人袭击导致毁灭，Huey也被当作叛徒。从《幻痛》的预告来看，其中会有审讯Huey的情节，看来Huey叛变的原因也只能在幻痛中揭晓了。</p>
<h3 id="Punished__u201CVenom_u201D_Snake"><a href="#Punished__u201CVenom_u201D_Snake" class="headerlink" title="Punished “Venom” Snake"></a>Punished “Venom” Snake</h3><p>Venom是以Big Boss之名而存在，却实则并非Big Boss。真实且原先的身份是The Medic，即《潜龙谍影5：原爆点》负责在直升机紧急治疗Paz的医疗兵。根据判断，The Medic很可能是由Kiefer Sutherland配音，而真正的Big Boss仍由David Hayter负责。</p>
<p>The Medic最初是以普通士兵加入Big Boss创建的Militaires Sans Frontières军事无国界组织，并随后成为了Big Boss最为信任的人之一。由于声音的相似，因而成为Big Boss替身的最好选择，并最终在医院完成整容手术。</p>
<p>通过观察The Medic在《潜龙谍影5：原爆点》的直升机爆炸瞬间，可以发现其为保护Big Boss而所处的身位，导致其头部留有金属残片。通过完成任务46，可以发现真正的Big Boss的面部并无金属残片或明显伤痕。</p>
<p>The Medic接受过Eli的DNA测试，却发现与Big Boss的不符。且在随后Huey，Quiet，Liquid Snake都有质疑表现。</p>
<h3 id="Skull_face"><a href="#Skull_face" class="headerlink" title="Skull face"></a>Skull face</h3><p>Skullface是《潜龙谍影5》事件的元凶。其生于匈牙利，父母工作于秘密兵工厂，却皆遭炸弹袭击而受伤。</p>
<p>由于伤情严重且治疗有限，在基本遭到放弃的情况下，终因最新的寄生疗法而存货。然而，这种疗法的副作用影响了他的身理系统，使其不再能感到疼痛。</p>
<p>Skullface随后得到Zero的招募并成立XOF来监控Big Boss来预防其重要任务成功，注入《潜龙谍影3》的噬蛇者行动。多年为Zero工作并监视Big Boss，使其对两人感到愤怒，尤其是Zero。于是，他在1975年通过袭击Big Boss基地并在Paz体内安装炸弹谋求杀死Big Boss。</p>
<p>在其发现Zero与Dr. Strangelove正在研发爱国者AI智能，他便只做了一种寄生感染，能使人类喉咙病变而失声。这种寄生虫由Code Talker研发，也有解药却不愿公开。《潜龙谍影3》的眼镜蛇小队也是寄生感染技术的试验品。</p>
<p>根据《潜龙谍影5：原爆点》最后，Skullface根据Paz所透露的情报，使Zero感染该病毒病逐渐成为植物人状态。而Skullface更想通过ST-84 Metal Gear来传播。</p>
<p>在最后所有计划即将完成之际，The Third Child在Mantis发现Liquid Snake出现在XOF直升机之后，而发怒与Skullface决裂。Skullface因ST-84 Metal Gear受困，而Big Boss和Miller决定弃他而去使其受苦而死，但Hery无视他们的想法而最终杀死了Skullface。</p>
<h3 id="Quiet__u9759_u9759"><a href="#Quiet__u9759_u9759" class="headerlink" title="Quiet 静静"></a>Quiet 静静</h3><p>Quiet便是在医院袭击Big Boss和Venom的女性。因Big Boss的反击而受到重伤，但其特殊能力因寄生治疗而增强。</p>
<p>她的听力是普通士兵的10倍，且视力不受日夜交替影响，但却携带着导致失声的病变寄生源。其肌肤可以通过洗澡或雨水吸收水分，也是其体内寄生虫的影响。然而，水会对Quiet的特殊能力有所削弱。</p>
<p>在通过招募之后，其将会在任务43之后离队。在主要任务全部完成之后，Venom会在一个次要任务寻找其踪迹。在逃脱时，Venom被毒蛇所咬伤。Quiet必须不再沉默并说出实情，来解救Venom。但在最后，她仍然会独自消失于沙漠之中……</p>
<h3 id="Man_on_Fire"><a href="#Man_on_Fire" class="headerlink" title="Man on Fire"></a>Man on Fire</h3><p>The Man on Fire火男，即是《潜龙谍影3》的Volgin，现为The Third Child进行着精神控制。在与Big Boss对决后，Volgin仍然存活却呈脑死状态，其想要向Big Boss复仇的执念使其成为一个恶魔而存在，并被俄罗斯医生作为科学研究而供养。</p>
<p><img src="/images/14576392498262.jpg" alt="Man on Fire"></p>
<p>Venom在随后回收其身体并保存在基地，但因ST-84 Metal Gear袭击而损毁。  </p>
<h2 id="u540D_u8BCD_u89E3_u91CA"><a href="#u540D_u8BCD_u89E3_u91CA" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="u9B54_u7AE5_u8BA1_u5212"><a href="#u9B54_u7AE5_u8BA1_u5212" class="headerlink" title="魔童计划"></a>魔童计划</h3><p>魔童计划【Les Enfants Terribles(法文)/恐るべき子供たち】是由美国政府在20世纪70年代早期着手进行的一项试验，目的是通过基因克隆等手段，制造出更多像Big Boss这样的超级战士。值得一提的是这项计划的赞助者就是爱国者组织的领导——Zero，提供医学技术支持的是Dr. Clark，也是爱国者组织中的一员。在1972年，Zero等人通过提取了Big Boss的基因，再将Eva当作母体的方式成功制作出了2个克隆人。不过其实当时有8个成功的受精卵，但是为了做出最强的而消灭掉了6个来全力强化剩下的那2个。</p>
<p>但是Big Boss在知道这件事后，他愤怒的离开了爱国者组织。最终9个月后，Eva成功产出了2个婴儿，由于他们2个都是用Snake的基因制作出的，所以被称为“Twin Snakes(孪蛇)”。这2个也就是日后我们熟知的Liquid Snake和Solid Snake。而且因为Big Boss的离开，Zero也开始变得不再信任其他人，于是他将孪蛇当作爱国者组织的保险，以防Big Boss将来会与他为敌。随后不久，魔童计划又制作出了一名新蛇，不同于之前的SS和LS，他的名字既不是固体也不是液态，而是Solidus Snake。Solidus Snake是一个完美的克隆体，他不像之前的孪蛇一样分别继承了隐性和显性，而是完美的继承优良基因，所以他也会被爱国者选中成为美国总统。不过魔童计划也在Solidus Snake制作出之后就彻底终结了。所以Solidus可以说是魔童计划的最后一个也是最完美的产物。</p>
<h3 id="u7231_u56FD_u8005"><a href="#u7231_u56FD_u8005" class="headerlink" title="爱国者"></a>爱国者</h3><p>爱国者(The Patriots)最早是由一个当时在MGS3食蛇者行动之中存活下来的人们建立的一个可以控制世界军事，政治和经济形式的一个强大组织，成员有：Zero、Big Boss、Eva、Ocelot、 Sigint(技师，日后的机械忍者骨骼就是他所开发的)、Para-Medic(医生，研究死狐病毒，实行魔童计划的人物)。而让组织运作的资金就是3代最终山猫拿到的那份哲学家的遗产(Philosophers’ Legacy) 。哲学家(或称作“贤人”)是在二战结束之后世界各地的强大领导者聚集在一起形成的一个组织，但是随着世界格局的变化这个组织最终瓦解，但是却留下了一笔非常惊人的财富，也就是这份遗产。在3 代后，山猫拿着这份钱找到了Zero想要建立起一个组织来实现The Boss的理想，同时也极力推荐Big Boss等人的加入，最终这6人也就形成了最早的爱国者组织。</p>
<p>但是这样一个组织没有团结太久，Big Boss和Zero对The Boss的理念有着不同的看法，BB认为应当放任自由，但是不会放弃武力约束;Zero认为应当集权统治，独裁才能统一。最终再加上BB发现了Zero暗地里对自己做的魔童计划，终于分道扬镳。而BB在之后建立了世外天国的武装国家，Zero过于害怕BB的力量于是策划了桑吉巴尔岛事件，利用自己制作的Solid Snake干掉了BB。但是随着Zero的日益老去，再加上爱国者组织的成员不断减少而且Zero也没有增添新的成员，于是他决定利用人工智能电脑来辅佐爱国者的运作。不过随着时间的推移，Zero对AI的约束管理越来越少，再加上拥有高智能和全球人类数据的爱国者电脑不断的进化，结果就是AI自己制作出了一套引领人类进步的系统，也就是MGS4中提到的爱国者之子系统，通过纳米机器人控制人类的情绪，打算自己统领人类。而他对计划的测试就是整个2代的故事，最终在4代里，利用FOX ALIVE病毒才彻底消灭了爱国者。</p>
<p>顺带一提Patriots为了封闭信息，人体内的NANOMACHINE(纳米机器)在本体要说出爱国者这个词的时候会将其转变为LA LI LU LE LO……这也就是为什么在2代的时候，总会听到LA LI LU LE LO的原因。</p>
<h3 id="u6B7B_u72D0_u75C5_u6BD2"><a href="#u6B7B_u72D0_u75C5_u6BD2" class="headerlink" title="死狐病毒"></a>死狐病毒</h3><p>FOXDIE病毒能致死特定基因的人，影子摩西岛事件时被NAOMI注射入Snake身体的FOXDIE对应Liquid Snake\Kenneth Baker以及叛变的FOXHOUND成员，当年实际被FOXDIE致死的人只有Liquid Snake 、Kenneth Baker和Decoy Octopus。这一点，我们在MGS1的故事中都已经说了一些，但是死狐病毒不单单只会对特定人造成致命威胁，还有新的死狐病毒。</p>
<p>新的FOXDIE和FOXALIVE不同，后者是对爱国者的AI系统的，前者是爱国者研制出来由DREBIN893注射到Snake体内，他将FOXDIE的指向人群转为ZERO、BIG BOSS、LIQUID Ocelot、BIG MAMA以及当初发明死狐病毒的Namoi。新的FOXDIE病毒和旧的FOXDIE混合发生变异，DREBIN注射之后其实Snake不会成为生物武器了，所以他无需自杀，BIG BOSS出面告诉他，他才得知。但是他的身体也仍然在急速老化，剩下的时间不多了，因为不能繁衍后代，他将和Otacon、Sunny一起见证自己的存在。</p>
<p>DREBIN是很多人的总称，是战场上的洗枪者。DREBIN893是游戏中的人物，是孤儿，先被爱国者收养，后被反抗组织俘虏并为组织训练为洗枪者，893是一个代号而已。实际上他一直是接受爱国者的命令的。是爱国者特意安排他接近Snake，帮助Snake洗枪，并将新的死狐病毒混合在最新的纳米机器中注射入Snake体内。</p>
<h3 id="S3_u8BA1_u5212"><a href="#S3_u8BA1_u5212" class="headerlink" title="S3计划"></a>S3计划</h3><p>S3计划是由爱国者在MGS2中实施的一个计划，S3有2层含义：</p>
<p>表：“Solid Snake Simulation(模拟Solid Snake)”，即重现MGS1中影子摩西岛的事件，从而找到能再现像当年像SS一样的超级战士。所以之前也说MGS2中整个事件为什么和影子摩西岛那么相似，比如：</p>
<ul>
<li>Raiden ⇔ Snake (主角)</li>
<li>AI上校 ⇔ Roy Campbell上校 (任务指挥官)</li>
<li>伪装成石油分解平台的Big Shell ⇔ 伪装为核废弃储存设施的影子摩西 (背景舞台)</li>
<li>特工Richard Ames ⇔ DARPA局长Donald Anderson (第一个死于“心脏病”的人质)</li>
<li>总统James Johnson ⇔ Arms军工总裁Kenneth Baker (第二个死亡的人质)</li>
<li>Olga Gurlukovich/Mr X ⇔ Gray Fox/Deepthroat (机械忍者)</li>
<li>Emma Emmerich = Sniper Wolf (与Otacon相关且死去的女人)</li>
<li>目击Emma被Vamp刺中 ⇔ 目击Meryl被Wolf击中 (看见女孩受伤却爱莫能助的情况)</li>
<li>Solidus Snake ⇔ Liquid Snake (最终Boss与主角都有亲人般的联系)</li>
<li>电脑病毒 ⇔ 死狐病毒</li>
</ul>
<p>而S3的深层含义则是：“Selection for Societal Sanity(社会健全选择)/社会の思想的健全化のための淘汰”，说白了就是爱国者想要测试在MGS2那种高强度危机事件下，能否靠自己控制住人类的情绪，如果可以，那么之后就不会再担心会再有人反抗自己了。MGS2的那么多牺牲其实就是爱国者的一个实验罢了。S3的过程除了ss和Otacon真的出现之外堪称完美，而且就结果而言，爱国者成功的得到了它想要的结果，这也为MGS4中的事件打下了基础。</p>
<h3 id="Metal_Gear-1"><a href="#Metal_Gear-1" class="headerlink" title="Metal Gear"></a>Metal Gear</h3><p>游戏中的MG其实一种超级武器。其实最早的设计理念仅仅是开发“可移动型核战车”，随之就出现了2条分支，一种以履带驱动，一种是双足站立。其实最初和MG相关的故事就是在MGS3中，一开始的贞洁行动要去拯救的那位科学家索科洛夫(Sokolov)就是在研究可移动型核战车，也就是3代中的BOSS——峡谷虎(Shagohod)，Shagohod采用的是履带行动而非双足，所以在Shagohod战败之后也就舍弃了履带驱动这个分支，之后选择的都是双足站立的MG。</p>
<p>这里额外需要注明一下的就是Shagohod其实并不是MG，Shagohod和MG其实是以“可移动型核战车”为开发理念制作的不同分支，当然也不存在什么原型机一说。</p>
<p>在《合金装备》中有大大小小各种各样的Metal Gear，大到MGS2中的巨型战舰，小到量产型的月光(Gecko)。但是有3种Metal Gear是非常具有代表性的，分别是ZEKE，REX，RAY。</p>
<p>Metal Gear ZEKE，首次出场：《合金装备索利德：和平行者》</p>
<p><img src="/images/14576377622940.jpg" alt="Metal Gear ZEKE"></p>
<p>ZEKE最早是由BB下达指示，让huey着手开发的一台Metal Gear，其最开始的目的只是单纯的作业用辅助机器，但是在经理了和平行者中的事件之后，获得了Peace Walker(和平行者中出现的一台MG)的部分零件，再加上考虑到自己的部队可能也会需要这样的战斗力，于是将其改造成了一台战斗用MG，但是依旧是由AI控制。但是Paz在之后偷走了ZEKE并且将它改造成了人工驾驶，在游戏的最后和BB展开了对决。不过最终即使拥有众多强大武器的ZEKE也没有战胜BB，Paz也随着爆炸掉入海中结果被人俘虏，之后就是《合金装备索利德5：原爆点》的剧情了。</p>
<p>Metal Gear REX，首次出场：《合金装备索利德》</p>
<p><img src="/images/14576377952638.jpg" alt="Metal Gear REX"></p>
<p>REX虽然不是最早的，但是可能是最有名的一台MG。REX是由DARPA(美国国防部先进研究项目局)进行开发，之后在影子摩西岛进行轨道炮演习的时候被叛变的猎狐犬小队夺取，也就是MGS1代中的影子摩西岛事件。值得一提的是REX的主要开发人员就是Otacon，但是他是在不知情的情况下开发的，因为当时上面告诉他这个兵器的目的是为了反导弹，保证核安全，结果最后才知道自己被忽悠了，不过这也让Otacon决定之后走上的反MG道路。</p>
<p>REX的造型非常霸气，而是是第一个以3D形式呈现的MG，当然不仅仅是外表，REX的实力也不容小觑。它厚实的装甲可以抵御反坦克导弹的攻击，同时强大的机动性可以在打击之后快速撤离。最重要的是REX搭载的电磁轨道炮，如果利用其发射核弹的话完全不会被提前侦测到。最终在MGS1结束之时，山猫将REX的设计图偷走并在黑市上售卖，这直接引起了MG的量产，同时也为新一代MG做了准备。</p>
<p>Metal Gear RAY，首次出场：《合金装备索利德2：自由之子》</p>
<p><img src="/images/14576378455276.jpg" alt="Metal Gear RAY"></p>
<p>RAY可以当作是REX的一种进化，甚至可以说RAY的制作目的就是为了破坏REX。RAY在造型上仅仅继承了双足站立这一特点，其余都有非常大的进步。最明显的就是它那1对翅膀，这对翅膀可以帮助 RAY在水下推进，所以RAY是一种水路两栖用MG。RAY的武装也更加强大，它配置了水刀(高压水流切割装置)，威力几乎和激光剑等同，同时它还有标准的机枪和火箭发射器。而且RAY的机械部分采用了生物组织，不仅可以在受伤时分泌出粘性物质自我修复，机动力更是大幅度提高。所以RAY在2,4,乃至最后的《合金装备崛起：复仇》中都充当了相当重要的地位。</p>
<p>在MGS2中，RAY有一台原型机和数台量产机，但是量产机的实力很差，都被雷电全部摆平，最终山猫驾驶着原型机脱离了战场，同时在4代中，有着SS驾驶REX和山猫驾驶的RAY对战的场面，虽然就两者的性能而言剧情设定有些勉强但是还是REX获得了胜利。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.gamersky.com/handbook/201511/680245.shtml" target="_blank" rel="external">《合金装备》系列历史剧情 合金装备全系列历史剧情揭秘</a></li>
<li><a href="http://www.gamersky.com/handbook/201508/657226.shtml" target="_blank" rel="external">《合金装备》全系列回顾 合金装备全系列剧情回顾及人物介绍</a></li>
<li><a href="/"></a></li>
<li></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果说这个世界上有第二个系列像 EVA 一样让我如痴如醉的话，那么肯定是 MGS 系列。在玩『潜龙谍影5：幻痛』的时候，每一段磁带（包含大量重要剧情信息）都认真听过之后，对于整个系列的剧情有了大概的认知。这篇文章会比较长，综合了网上的各种资料和我自己的理解，希望能给大家带来一个比较完整的阅读体验。</p>]]>
    
    </summary>
    
      <category term="BigBOSS" scheme="http://wdxtub.com/tags/BigBOSS/"/>
    
      <category term="Quiet" scheme="http://wdxtub.com/tags/Quiet/"/>
    
      <category term="Snake" scheme="http://wdxtub.com/tags/Snake/"/>
    
      <category term="合金装备" scheme="http://wdxtub.com/tags/%E5%90%88%E9%87%91%E8%A3%85%E5%A4%87/"/>
    
      <category term="幻痛" scheme="http://wdxtub.com/tags/%E5%B9%BB%E7%97%9B/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 习题课 5 Shelllab]]></title>
    <link href="http://wdxtub.com/2016/03/08/csapp-lab5/"/>
    <id>http://wdxtub.com/2016/03/08/csapp-lab5/</id>
    <published>2016-03-08T18:47:44.000Z</published>
    <updated>2016-03-10T00:41:08.000Z</updated>
    <content type="html"><![CDATA[<p>这次的作业，我们需要自己完成一个简单的 shell 程序，通过具体的实现，我们可以更加深入地计算机运行的机制（尤其是 Exceptional Control Flow 和进程）。</p>
<a id="more"></a>
<hr>
<p>在具体开始这次的试验之前，最好先复习一下基本概念（具体的细节可以参考前面的几课），这里放在文末的附录中。</p>
<p>这次的任务不简单！但是老师提供了很多辅助函数，确定先读懂已有代码再开始（注意代码风格），需要仔细查看的 man pages：</p>
<ul>
<li><code>sigemptyset()</code></li>
<li><code>sigaddset()</code></li>
<li><code>sigprocmask()</code></li>
<li><code>sigsuspend()</code></li>
<li><code>waitpid()</code></li>
<li><code>open()</code></li>
<li><code>dup2()</code></li>
<li><code>setpgid()</code></li>
<li><code>kill()</code></li>
</ul>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>先把文件上传到学校的机器中 <code>scp tshlab-handout.tar dawang@shark.ics.cs.cmu.edu:~/513</code>，然后登录上去 <code>ssh -X dawang@shark.ics.cs.cmu.edu</code>，登录成功后解压 <code>tar xvf tshlab-handout.tar</code></p>
<p>因为我比较习惯在本地写代码，所以把文件复制回来：</p>
<ul>
<li>服务器至本地<ul>
<li><code>scp -r dawang@shark.ics.cs.cmu.edu:~/513/tshlab-handout/* ./</code></li>
</ul>
</li>
<li>本地至服务器<ul>
<li><code>scp ./tsh.c dawang@shark.ics.cs.cmu.edu:~/513/tshlab-handout/</code></li>
</ul>
</li>
</ul>
<p>然后需要在 <code>tsh.c</code> 中填写 Andrew ID，这个文件中已经包含了一个基本的 shell 程序，但是还有很多东西没有完成，我们的任务是补全下列空函数：</p>
<ul>
<li><code>void eval(char *cmdline)</code>：解析命令与执行，约 300 行</li>
<li><code>void sigchld_handler(int sig)</code>：捕获 SIGCHLD 信号</li>
<li><code>void sigtstp_handler(int sig)</code>：捕获 SIGTSTP(ctrl-z) 信号</li>
<li><code>void sigint_handler(int sig)</code>：捕获 SIGINT(ctrl-c) 信号</li>
</ul>
<p>测试的时候先 <code>make</code> 然后 <code>./tsh</code> 即可，不过一开始好像没办法退出</p>
<h2 id="Shell__u7B80_u4ECB"><a href="#Shell__u7B80_u4ECB" class="headerlink" title="Shell 简介"></a>Shell 简介</h2><p>简单来说，shell 有两种执行模式：</p>
<ol>
<li>如果用户输入的命令是内置命令，那么 shell 会直接在当前进程执行（例如 <code>jobs</code>）</li>
<li>如果用户输入的是一个可执行程序的路径，那么 shell 会 fork 出一个新进程，并且在这个子进程中执行该程序（例如 <code>/bin/ls -l -d</code>）</li>
</ol>
<p>第二种情况中，每个子进程称为一个 job（当然也可以不止一个，通过管道机制，不过我们这里的实现不需要考虑管道）</p>
<p>如果命令以 <code>&amp;</code> 结束，那么这个 job 会在后台执行（比如 <code>/bin/ls -l -d &amp;</code>），也就是说 shell 本身不会等待 job 执行完成，直接可以继续输入其他命令；而在其他情况下，则是在前台运行，shell 会等待 job 完成，用户才可以继续输入命令。也就是说同一个时间只可能有一个前台任务，但是后台任务可以有任意多个。</p>
<p>程序的入口是 <code>int main(int argc, char *argv[])</code>，对于 <code>/bin/ls -l -d</code> 来说，我们有：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">argc</span> == <span class="number">3</span></span><br><span class="line"><span class="built_in">argv</span>[<span class="number">0</span>] == <span class="string">''</span>/bin/<span class="keyword">ls</span><span class="string">''</span></span><br><span class="line"><span class="built_in">argv</span>[<span class="number">1</span>] == <span class="string">''</span>-<span class="keyword">l</span><span class="string">''</span></span><br><span class="line"><span class="built_in">argv</span>[<span class="number">2</span>] == <span class="string">''</span>-<span class="keyword">d</span><span class="string">''</span></span><br></pre></td></tr></table></figure>
<p>另外两个需要支持功能是：</p>
<ul>
<li>job control：允许用户更改进程的前台/后台状态以及京城的状态(running, stopped, or terminated)<ul>
<li>ctrl-c 会触发 SIGINT 信号并发送给每个前台进程，默认的动作是终止该进程</li>
<li>ctrl-z 会触发 SIGTSTP 信号并发送给每个前台进程，默认的动作是挂起该进程，直到再收到 SIGCONT 信号才继续</li>
<li><code>jobs</code> 命令会列出正在执行和被挂起的后台任务</li>
<li><code>bg job</code> 命令可以让一个被挂起的后台任务继续执行</li>
<li><code>fg job</code> 命令可以让一个被挂起的前台任务继续执行</li>
</ul>
</li>
<li>I/O redirection：重定向输入输出<ul>
<li><code>tsh&gt; /bin/ls &gt; foo</code></li>
<li><code>tsh&gt; /bin/cat &lt; foo</code></li>
</ul>
</li>
</ul>
<h2 id="u4EFB_u52A1_u76EE_u6807"><a href="#u4EFB_u52A1_u76EE_u6807" class="headerlink" title="任务目标"></a>任务目标</h2><p>我们正在使用的 shell 其实包含很多复杂的功能，不过我们自己写的 shell 就简单很多，这里总结一下具体的实现规格：</p>
<ul>
<li>每一行会输出一个 <code>tsh&gt;</code>，然后等待用户输入</li>
<li>用户的输入包括 <code>name</code> 加上零个或多个参数，这些参数之间用一个或多个空格分隔。如果 <code>name</code> 是内置命令，那么直接执行，否则需要新建一个子进程，并在子进程中完成具体的工作</li>
<li>不需要支持管道，但是需要支持输入输出重定向，如 <code>tsh&gt; /bin/cat &lt; foo &gt; bar</code>（必须支持在同一行重定向输入以及输出）<ul>
<li>也需要支持内置命令的重定向，如 <code>tsh&gt; jobs &gt; foo</code> </li>
</ul>
</li>
<li>输入 <code>ctrl-c</code> 或 <code>ctrl-z</code> 会给当前的前台进程（包括其子进程）发送 SIGINT(SIGTSTP) 信号，如果没有前台任务，那么这俩信号没有任何效果</li>
<li>如果输入的命令以 <code>&amp;</code> 结尾，那么就要以后台任务的方式执行，否则按照前台执行</li>
<li>每个 job 都有其进程 ID(PID) 和 job ID(JID)，都是由 tsh 指定的正整数，JID 以 <code>%</code> 开头（如 <code>%5</code> 表示 JID 为 5，而 <code>5</code> 则表示 PID 为 5），这部分已提供了辅助函数</li>
<li>支持的内置命令有<ul>
<li><code>quit</code> 退出 shell</li>
<li><code>jobs</code> 列出所有的后台任务</li>
<li><code>bg job</code> 给后台 <code>job</code> 发送 SIGCONT 信号来继续执行该任务，具体的 <code>job</code> 数值可以是 PID 或 JID</li>
<li><code>fg job</code> 给前台 <code>job</code> 发送 SIGCONT 信号来继续执行该任务，具体的 <code>job</code> 数值可以是 PID 或 JID</li>
</ul>
</li>
<li>tsh 应该回收所有的僵尸进程，如果任何 job 因为接收了没有 catch 的信号而终止，tsh 应该识别出这个时间并且打印出 JID 和相关信号的信息</li>
</ul>
<h2 id="u6D4B_u8BD5_u65B9_u6CD5"><a href="#u6D4B_u8BD5_u65B9_u6CD5" class="headerlink" title="测试方法"></a>测试方法</h2><p>最简单（也是首先应该做的）是直接运行 tsh，然后输入命令试试看。如果需要参考，可以试试 <code>tshref</code> 这个程序。确定无误之后可以进行完整测试。</p>
<p>这里我们用 trace 文件来测试，具体使用命令 <code>./runtrace</code> 来测试，具体用法如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">./runtrace -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试某个特性</span></span><br><span class="line">./runtrace <span class="operator">-f</span> trace05.txt <span class="operator">-s</span> ./tsh</span><br></pre></td></tr></table></figure>
<p>如果想要进行完整的测试，可以使用 <code>./sdriver</code>，具体用法如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">./sdriver -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般来说可以直接使用默认设置测试</span></span><br><span class="line">./sdriver</span><br></pre></td></tr></table></figure>
<p>只需要提交 <code>tsh.c</code> 即可，系统会自动评分，具体每个文件在测试的内容是：</p>
<p><img src="/images/14575490108688.jpg" alt="trace 文件内容"></p>
<h2 id="u63D0_u793A"><a href="#u63D0_u793A" class="headerlink" title="提示"></a>提示</h2><ul>
<li>不要使用 <code>sleep()</code> 来同步</li>
<li>不要使用忙等待 <code>while(1);</code></li>
<li>使用 <code>sigsuspend</code> 来同步</li>
<li>竞争条件</li>
<li>僵尸进程回收（注意竞争条件以及正确处理信号）</li>
<li>等待前台任务（仔细思考怎么样才是好的方式）</li>
<li>不要假定进程的执行顺序</li>
<li>子进程挂掉的时候应该在一个限定时间内被回收</li>
<li>不要在多个地方调用 <code>waitpid</code>，很容易造成竞争条件，也会造成程序过分复杂</li>
<li>不要使用任何系统调用来管理 terminal group</li>
<li><code>waitpid</code>, <code>kill</code>, <code>fork</code>, <code>execve</code>, <code>setpgid</code>, <code>sigprocmask</code> 和 <code>sigsuspend</code> 都非常有用，<code>waitpid</code> 中的 WUNTRACED 和 WNOHANG 选项也是如此。</li>
<li>遇到不清晰的用 <code>man</code> 来查看细节</li>
<li>实现 signal handler 的时候注意给全部的前台进程组发送 SIGINT 和 SIGTSTP 信号</li>
<li>在 <code>kill</code> 函数中使用 <code>-pid</code> 的格式作为参数</li>
<li>在 shell 等待前台工作完成时，需要决定在 <code>eval</code> 及 <code>sigchold handler</code> 具体的分配，这里有一定技巧</li>
<li>在函数 <code>eval</code> 中，在 fork 出子进程之前，必须使用 <code>sigprocmask</code> 来阻塞 SIGCHLD, SIGINT 和 SIGTSTP 信号，完成之后再取消阻塞。调用 <code>addjob</code> 的时候也需要如此。注意，因为子进程也继承了之前的各种状态，所以在子进程中调用 <code>exec</code> 执行新程序的时候注意需要取消阻塞，同样也需要恢复默认的 handler（shell 本身已经忽略了这些信号），具体可以看书本的 8.5.6 节</li>
<li>不要使用 <code>top</code>, <code>less</code>, <code>vi</code>, <code>emacs</code> 之类的复杂程序，使用简单的文本程序如：<code>/bin/cat</code>, <code>/bin/ls</code>, <code>/bin/ps</code>, <code>/bin/echo</code></li>
<li>因为毕竟不是真正的 shell，所以在 fork 之后，execve 之前，子进程需要调用 <code>setpgid(0, 0)</code>，这样就把子进程放到一个新的进程组里。这样就保证我们的 shell 前台进程组中唯一的进程，当按下 ctrl-c 时，应该捕获 SIGINT 信号并发送给对应的前台进程组中。</li>
</ul>
<p>同样提供一个 <code>tshref</code> 参考程序来作为比对输出（除了进程 id 之外其他需要一模一样），具体是通过 <code>runtrace</code> 文件来测试，每个 trace 文件会测试一个特性</p>
<h2 id="u89E3_u9898_u653B_u7565"><a href="#u89E3_u9898_u653B_u7565" class="headerlink" title="解题攻略"></a>解题攻略</h2><p>最开始当时是要先读懂代码，尤其是整个程序到底在干什么，如果有仔细看我前面的介绍和课本的话，应该比较轻松能找到对应（毕竟这是一个简化的版本），所以这里废话不多说，直接开始完成基础工作。我们先来看看如何改动 <code>eval</code> 这个函数。</p>
<p>在这个函数中，我们会先解析命令（具体的解析已经有工具函数），然后得到一系列 token，结构如下</p>
<p><img src="/images/14575497659305.jpg" alt="token 的结构"></p>
<p>目前来说，对我们最有用的是这里面的枚举类型，我们可以先用这个来判断是否是内置函数，据此来决定走哪条分支。我们先把最基本的退出功能做了，这样就不会出现一旦开始就没办法结束的情况，具体方法也很简单，直接 <code>exit(0);</code> 即可，我们测试一下，发现已经可以正确退出了：</p>
<p><img src="/images/14575502436640.jpg" alt="退出程序"></p>
<p>接着我们来实现 <code>jobs</code> 这个命令，因为已经提供了 <code>listjobs</code> 这个函数，所以我们直接围绕着这个函数来做文章即可。留意到 token 结构体中有 <code>infile</code> 和 <code>outfile</code> 两项，这个就是用来重定向的判断（我们不需要担心解析的问题，可以直接用）。同样，我们来判断一下有没有 <code>outfile</code>，对应进行处理即可。注意输出的时候如果不需要重定向，那么就输出到 stdout，如果需要重定向，就输出到对应的 file descriptor 中（打开文件的时候需要设定 flag，具体可以 <code>man open</code> 进行查看）。</p>
<p>接着我们来实现 FG 和 BG 这两个命令，我们需要注意的地方有两个，一个是先根据判断传入的是 JID 还是 PID，然后发送信号之后需要等待进程完成（这里注意使用 <code>sigsuspend</code>）。</p>
<p>这里需要注意 <code>.</code> 和 <code>-&gt;</code> 这两个操作符的不同，简单来说，就是如果左边是一个指向结构体的指针，那么就要用 <code>-&gt;</code>；如果是一个结构体，那么就要用 <code>.</code>。</p>
<p>这些做完之后我们可以先来简单测试一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./runtrace <span class="operator">-f</span> trace00.txt <span class="operator">-s</span> ./tsh</span><br><span class="line">./runtrace <span class="operator">-f</span> trace00.txt <span class="operator">-s</span> ./tshref</span><br><span class="line">./runtrace <span class="operator">-f</span> trace01.txt <span class="operator">-s</span> ./tsh</span><br><span class="line">./runtrace <span class="operator">-f</span> trace01.txt <span class="operator">-s</span> ./tshref</span><br></pre></td></tr></table></figure>
<p><img src="/images/14575550290784.jpg" alt="测试结果"></p>
<p>看到和参考程序输出至少是一致的，我们就可以继续了。</p>
<p>接着我们需要来处理非内置命令的情况，参考课件中的代码，先把需要用到的 mask 之类的弄好，并且我们暂时不考虑重定向的问题。然后需要把对应的 signal handler 补充完整。</p>
<p>这之后我们可以来跑一次测试 <code>./sdriver</code>，最后的得分是 60/100，第一个错误出现在 trace08.txt 这个文件中，查表得知是发送 fatal SIGINT 给前台进程。我自己用 <code>./runtrace -f trace08.txt -s ./tsh</code> 测试了几次，发现有时候可以正确输出，有时候则会超时，说明是处理进程同步的时候出了问题。经过检查发现，阻塞信号的时候需要阻塞全部信号（之前我只阻塞了 SIGCHLD 会出问题），再测试的话，发现已经有了 80/100 分。</p>
<p>继续看看哪里出了问题，在输出的日志中寻找最先出错的地方，发现是 trace22.txt，功能是 I/O redirection(input)，这就对了，毕竟我们还没写这个功能。</p>
<p>我们现在就来写一下。不过在此之前，回答一下前面的问题，前面提到过：</p>
<blockquote>
<p>在 shell 等待前台工作完成时，需要决定在 <code>eval</code> 及 <code>sigchold handler</code> 具体的分配，这里有一定技巧</p>
</blockquote>
<p>那么技巧是什么呢？其实很简单，就是都在 eval 里做，handler 尽量短小精悍。</p>
<p>好，我们继续来做输入输出重定向，同样分为内置函数与其他两个类型，内置函数唯一需要输出的是 <code>jobs</code> 这个函数，不过我们之前已经处理过，这里暂且不管（出问题再说）。所以把主要精力集中在非内置的函数上。具体应该在 <code>setpgid(0,0)</code> 这句之后，且应该在 <code>execve</code> 之前。具体的操作也比较简单，就是打开文件（只读），然后利用 <code>dups</code> 重定向到 STDIN 中即可。对于输出的情况也是类似的，这里不赘述。唯一需要注意的一点是打开文件时候的 flag，设置错误会导致没办法正确重定向。</p>
<p>改完错误之后发现 trace15.txt 又出错了，而且经过测试发现死锁的问题还在，而且是内置函数的问题（果然一开始有小问题），后来发现是搞错了一个变量（但是仍旧有小概率会出现死锁，不过提交的时候似乎一切正常）</p>
<p>最后需要注意的是有些测试会直接修改源代码，所以每次都需要重新解压（还是蛮讨厌的）。总体来说只要理解了整个过程就不算太难，使用 <code>csapp.h</code> 的时候可能需要把代码复制到 <code>tsh.c</code> 中。</p>
<h2 id="u9644_u5F551_3A__u4E2D_u6587_man__u6587_u6863"><a href="#u9644_u5F551_3A__u4E2D_u6587_man__u6587_u6863" class="headerlink" title="附录1: 中文 man 文档"></a>附录1: 中文 man 文档</h2><p>如果觉得看英文太累（虽然建议看英文），可以使用中文的 man 文档，具体的使用步骤如下：</p>
<p>在<a href="http://manpages-zh.googlecode.com/files/manpages-zh-1.5.1.tar.gz" target="_blank" rel="external">这里</a>下载安装包，然后通过如下命令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf manpages-zh-<span class="number">1.5</span>.<span class="number">1</span>.tar.gz</span><br><span class="line"><span class="built_in">cd</span> manpages-zh-<span class="number">1.5</span>.<span class="number">1</span></span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/zhman --disable-zhtw</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>在 Mac 上会乱码，所以需要安装 groff，具体命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install homebrew/dupes/groff</span><br></pre></td></tr></table></figure>
<p>然后打开 <code>/etc/man.conf</code>，把 <code>NROFF</code> 的那一行改为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NROFF preconv <span class="operator">-e</span> UTF8 | /usr/<span class="built_in">local</span>/bin/nroff -Tutf8 -mandoc -c</span><br></pre></td></tr></table></figure>
<p>最后我么加一个别名，方便使用（根据自己使用的 shell 来针对改，bash 的话是 ~/.bashrc，zsh 的话是 ~/.zshrc），在文件中加入这么一句：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias cman='<span class="keyword">man</span> -<span class="keyword">M</span> /usr/<span class="keyword">local</span>/zhman/share/<span class="keyword">man</span>/zh_CN'</span><br></pre></td></tr></table></figure>
<p>然后 <code>source .zshrc</code> 启用，我们就可以通过 <code>cman</code> 命令来查看了，比如说输入 <code>cman kill</code>，就可以看到</p>
<p><img src="/images/14575529137049.jpg" alt="效果"></p>
<p>大功告成。</p>
<h2 id="u9644_u5F552_3A__u57FA_u7840_u77E5_u8BC6"><a href="#u9644_u5F552_3A__u57FA_u7840_u77E5_u8BC6" class="headerlink" title="附录2: 基础知识"></a>附录2: 基础知识</h2><p>开始之前需要理解的内容</p>
<h3 id="u5F02_u6B65_u5F02_u5E38_28_u4E2D_u65AD_29"><a href="#u5F02_u6B65_u5F02_u5E38_28_u4E2D_u65AD_29" class="headerlink" title="异步异常(中断)"></a>异步异常(中断)</h3><p><img src="/images/14574791971112.jpg" alt="Asynchronous Exceptions(Interrupts)"></p>
<h3 id="u540C_u6B65_u5F02_u5E38"><a href="#u540C_u6B65_u5F02_u5E38" class="headerlink" title="同步异常"></a>同步异常</h3><p><img src="/images/14574792452633.jpg" alt="Synchronous Exceptions"></p>
<h3 id="u8FDB_u7A0B"><a href="#u8FDB_u7A0B" class="headerlink" title="进程"></a>进程</h3><p><img src="/images/14574793369863.jpg" alt="Definition"></p>
<p><img src="/images/14574793444040.jpg" alt="Four basic States"></p>
<p><img src="/images/14574793738605.jpg" alt="Control States"></p>
<p>fork 函数详细介绍：</p>
<p><img src="/images/14574794567977.jpg" alt="fork"></p>
<p><img src="/images/14574794700303.jpg" alt="fork"></p>
<p>exec 函数详细介绍</p>
<p><img src="/images/14574794860146.jpg" alt="exec"></p>
<p>exit 函数详细介绍</p>
<p><img src="/images/14574795006407.jpg" alt=""></p>
<p>wait 函数详细介绍</p>
<p><img src="/images/14574795185122.jpg" alt=""></p>
<h3 id="u7B80_u5355_u7684_u8FDB_u7A0B_u4F8B_u5B50"><a href="#u7B80_u5355_u7684_u8FDB_u7A0B_u4F8B_u5B50" class="headerlink" title="简单的进程例子"></a>简单的进程例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (child_pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 这部分只有子进程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Child!\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 父进程通过下面这句等待子进程完成，才继续执行</span></span><br><span class="line">    waitpid(child_pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Parent!\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个使用 execvc 的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"><span class="keyword">char</span>* argv[] = &#123;<span class="string">"/bin/ls"</span>, <span class="string">"-l"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="keyword">char</span>* env[] = &#123;..., <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (child_pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 这部分只有子进程执行</span></span><br><span class="line">    execve(<span class="string">"/bin/ls"</span>, argv, env);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为已经被取代，所以 execve 之后的语句将不会被执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 父进程通过下面这句等待子进程完成，才继续执行</span></span><br><span class="line">    waitpid(child_pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 等待子进程结束之后继续执行父线程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Parent!\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u4FE1_u53F7"><a href="#u4FE1_u53F7" class="headerlink" title="信号"></a>信号</h3><p><img src="/images/14574798651564.jpg" alt="Three possible ways to react"></p>
<p><img src="/images/14574798879407.jpg" alt="Ohter Reaction Options"></p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.yurendu.com/read/install-man-command-chinese-help-documentation-on-mac-and-linux.html" target="_blank" rel="external">Mac/Linux 安装man命令的中文帮助文档</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这次的作业，我们需要自己完成一个简单的 shell 程序，通过具体的实现，我们可以更加深入地计算机运行的机制（尤其是 Exceptional Control Flow 和进程）。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Shelllab" scheme="http://wdxtub.com/tags/Shelllab/"/>
    
      <category term="习题课" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98%E8%AF%BE/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 15 课 System Level I/O]]></title>
    <link href="http://wdxtub.com/2016/03/06/csapp-15/"/>
    <id>http://wdxtub.com/2016/03/06/csapp-15/</id>
    <published>2016-03-06T12:47:39.000Z</published>
    <updated>2016-03-08T18:45:12.000Z</updated>
    <content type="html"><![CDATA[<p>了解完了 Exceptional Control Flow，我们再来看看系统级 IO 的相关内容，完成这一课之后，就可以开始写我们自己的 shell 程序了。</p>
<a id="more"></a>
<hr>
<h2 id="Unix_I/O"><a href="#Unix_I/O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p>在 Linux 中，文件实际上可以看做是字节的序列。更有意思的是，所有的 I/O 设备也是用文件来表示的，比如：</p>
<ul>
<li><code>./dev/sda2</code> (<code>/usr</code> disk partition)</li>
<li><code>/dev/tty2</code> (terminal)</li>
</ul>
<p>甚至连内核也是用文件来表示的：</p>
<ul>
<li><code>/boot/vmlinuz-3.13.0-55-generic</code> (kernel image)</li>
<li><code>/proc</code> (kernel data structures)</li>
</ul>
<p>因为 I/O 设备也是文件，所以内核可以利用称为 Unix I/O 的简单接口来处理输入输出，比如：</p>
<p><img src="/images/14574522789531.jpg" alt="Unix I/O Overview"></p>
<p>为了区别不同文件的类型，会有一个 <code>type</code> 来进行区别：</p>
<ul>
<li>普通文件：包含任意数据</li>
<li>目录：相关一组文件的索引</li>
<li>Socket：和另一台机器上的进程通信的类型</li>
</ul>
<p>其实还有一些比较特别的类型，但是这里提一下，不深入了解：</p>
<ul>
<li>Named pipes(FIFOs)</li>
<li>Symbolic links</li>
<li>Character and block devices</li>
</ul>
<h3 id="Regular_File"><a href="#Regular_File" class="headerlink" title="Regular File"></a>Regular File</h3><p>普通的文件包含任意数据，应用一般来说需要区分出 text files 和 binary files。文本文件只包含 ASCII 或 Unicode 字符。除此之外的都是 binary files(object files, JPEG images, etc)。对于内核来说其实并不能区分出个中的区别。</p>
<p>文本文件就是一系列的文本行，每行以 <code>\n</code> 结尾，新的一行是 <code>0xa</code>，和 ASCII 码中的 line feed 字符(LF) 一样。不同系统用用判断一行结束的符号不同(End of line, EOL)，如：</p>
<ul>
<li>Linux &amp; Mac OS: <code>\n</code>(0xa)<ul>
<li>line feed(LF) </li>
</ul>
</li>
<li>Windows &amp; Internet protocols: <code>\r\n</code> (0xd 0xa)<ul>
<li>Carriage return(CR) followed by line feed(LF)</li>
</ul>
</li>
</ul>
<h3 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a>目录</h3><p>目录包含一个 link 数组，并且每个目录至少包含两条记录：</p>
<ul>
<li><code>.</code>(dot) 当前目录</li>
<li><code>..</code>(dot dot) 上一层目录</li>
</ul>
<p>用来操作目录的命令主要有 <code>mkdir</code>, <code>ls</code>, <code>rmdir</code></p>
<p>目录是以树装结构组织的，跟目录是 <code>/</code>(slash)</p>
<p><img src="/images/14574529458797.jpg" alt="Directory Hierarchy"></p>
<p>内核会为每个进程保存 current working directory (cwd)，可以用 <code>cd</code> 命令来进行更改。</p>
<p>我们通过路径名来确定文件的位置，一般分为绝对路径和相对路径。</p>
<h3 id="u64CD_u4F5C_u6587_u4EF6"><a href="#u64CD_u4F5C_u6587_u4EF6" class="headerlink" title="操作文件"></a>操作文件</h3><p>接下来我们了解一下基本的文件操作。</p>
<p>在使用文件之前需要通知内核打开该文件：</p>
<p><img src="/images/14574530910656.jpg" alt="Opening Files"></p>
<p>返回值是一个小的整型称为 file descriptor（如果这个值等于 -1 则说明发生了错误）。每个由 Linux sheel 创建的进程都会默认打开三个文件：</p>
<ul>
<li>0: standard input(stdin)</li>
<li>1: standard output(stdout)</li>
<li>2: standar error(stderr)</li>
</ul>
<p>使用完毕之后同样需要通知内核关闭文件：</p>
<p><img src="/images/14574532174613.jpg" alt="Closing Files"></p>
<p>如果在此关闭已经关闭了的文件，会出大问题。所以一定要检查返回值，哪怕是 <code>close()</code> 函数（如上面的例子所示）</p>
<p>在打开和关闭之间就是读取文件，实际上就是把文件中对应的字节复制到内存中，并更新文件指针：</p>
<p><img src="/images/14574533193683.jpg" alt="Reading Files"></p>
<p>返回值是读取的字节数量，是一个 <code>ssize_t</code> 类型（其实就是一个 signed integer），如果 <code>nbytes &lt; 0</code> 那么表示出错。<code>nbytes &lt; sizeof(buf)</code> 这种情况(short counts) 是可能发生的，而且并不是错误。</p>
<p>写入文件是把内存中的数据复制到文件中，并更新文件指针：</p>
<p><img src="/images/14574534505640.jpg" alt="Wrting Files"></p>
<p>返回值是写入的字节数量，如果 <code>nbytes &lt; 0</code> 那么表示出错。<code>nbytes &lt; sizeof(buf)</code> 这种情况(short counts) 是可能发生的，而且并不是错误。</p>
<p>综合上面的操作，我们可以来看看 Unix I/O 的例子：</p>
<p><img src="/images/14574535145592.jpg" alt="Copying stdin to stdout, one byte at a time"></p>
<p>前面提到的 short count 会在下面的情形下发生：</p>
<ul>
<li>在读取的时候遇到 EOF(end-of-file)</li>
<li>从终端中读取文本行</li>
<li>读取和写入网络 sockets</li>
</ul>
<p>但是在下面的情况下不会发生</p>
<ul>
<li>从磁盘文件中读取（除 EOF 外）</li>
<li>写入到磁盘文件中</li>
</ul>
<p>最好总是允许 short count，这样就可以避免处理这么多不同的情况。</p>
<h2 id="Robust_I/O"><a href="#Robust_I/O" class="headerlink" title="Robust I/O"></a>Robust I/O</h2><p>RIO 实际上就是一个包装，用来在不同的应用中提供强壮的 IO 接口，主要有一下两类：</p>
<p><img src="/images/14574544870012.jpg" alt="The RIO Package"></p>
<p>可以从<a href="http://csapp.cs.cmu.edu/3e/code.html" target="_blank" rel="external">这里</a> 中下载（<code>src/csapp.c</code> 和  <code>include/csapp.h</code>）</p>
<p>无缓存的输入输出和 Unix 的 <code>read</code> 和 <code>write</code> 接口一致，如果要通过 network sockets 来传输数据，就非常拥有了：</p>
<p><img src="/images/14574546347971.jpg" alt="Unbuffered ROI Input and Output"></p>
<p>具体的实现是：</p>
<p><img src="/images/14574547191767.jpg" alt="Implementation of `rio_readn`"></p>
<p>有缓存的输入在从文件中读取数据的时候通过内置的内存缓冲区提高效率：</p>
<p><img src="/images/14574547952581.jpg" alt="Buffered RIO Input Functions"></p>
<p><img src="/images/14574548277481.jpg" alt=""></p>
<p>具体的实现如下：</p>
<p><img src="/images/14574548545398.jpg" alt="Buffered I/O: Implementation"></p>
<p>对应的结构体是：</p>
<p><img src="/images/14574549507104.jpg" alt=""></p>
<p>这是一个对应的例子：</p>
<p><img src="/images/14574549871674.jpg" alt="Copying the lines of a text file from standar input to standard output"></p>
<h2 id="Metadata_2C_Sharing__26amp_3B_Redirection"><a href="#Metadata_2C_Sharing__26amp_3B_Redirection" class="headerlink" title="Metadata, Sharing &amp; Redirection"></a>Metadata, Sharing &amp; Redirection</h2><p>元数据是用来描述数据的数据，由内核维护，可以通过 <code>stat</code> 和 <code>fstat</code> 函数来访问，其结构是：</p>
<p><img src="/images/14574550707059.jpg" alt="File Metadata"></p>
<p>对应的访问例子：</p>
<p><img src="/images/14574551947810.jpg" alt="Example of Accessing File Metadata"></p>
<p>了解了具体的结构之后，我们来看看内核是如何表示打开的文件的。其实过程很简单，每个进程都有自己的 Descriptor table，然后 Descriptor 1 指向终端，Descriptor 4 指向磁盘文件，如下图所示：</p>
<p><img src="/images/14574553689850.jpg" alt="How the Unix Kernel Represents Open Files"></p>
<p>两个不同的 descriptors 通过两个不同的 open file 记录来共享同一个磁盘文件（对应指向同一个 v-noe table）。</p>
<p>这里有一个需要说明的情况，就是使用 <code>fork</code>。子进程实际上是会继承父进程打开的文件，在调用 <code>fork</code> 之前，我们假设情况是这样的：</p>
<p><img src="/images/14574555865284.jpg" alt="Before fork call"></p>
<p>在 fork 之后，子进程实际上和父进程的指向是一样的，这里需要注意的是会把 <code>refcnt</code> 加上 1（也就是引用计数加 1）</p>
<p><img src="/images/14574556597788.jpg" alt="After fork"></p>
<p>了解了这个，我们我们就可以知道所谓的重定向是怎么实现的了。其实很简单，只要调用 <code>dup2(oldfd, newfd)</code> 函数即可。具体如下：</p>
<p><img src="/images/14574609050965.jpg" alt="I/O Redirection"></p>
<p>Step #1: open file to which stdout should be redirected(happends in child executing shell code, before <code>exec</code>)</p>
<p><img src="/images/14574609981392.jpg" alt="Step #1: open file to which stdout should be redirected"></p>
<p>Step #2: call <code>dup2(4,1)</code> -&gt; cause fd=1(stdout) to refer to disk file pointed at fd=4</p>
<p><img src="/images/14574613741105.jpg" alt="Step #2: call `dup2(4,1)`"></p>
<h2 id="Standar_I/O"><a href="#Standar_I/O" class="headerlink" title="Standar I/O"></a>Standar I/O</h2><p>C 标准库中包含一系列高层的标准 IO 函数，一些具体的函数：</p>
<p><img src="/images/14574614463046.jpg" alt="Examples of standard I/O functions"></p>
<p>标准 IO 会用流的形式打开文件，所谓流(stream)实际上是 file descriptor 和 buffer 在内存中的抽象。C 程序一般以三个流开始，如下所示：</p>
<p><img src="/images/14574615606437.jpg" alt="Standard I/O Streams"></p>
<p>接下来我们详细了解一下为什么需要使用缓冲区，程序经常会一次读入或者写入一个字符，比如 <code>getc</code>, <code>putc</code>, <code>ungetc</code>，同时也会一次读入或者写入一行，比如 <code>gets</code>, <code>fgets</code>。如果用 Unix I/O 的方式来进行调用，是非常昂贵的，比如说 <code>read</code> 和 <code>write</code> 因为需要内核调用，需要大于 10000 个时钟周期。</p>
<p>解决的办法就是利用 <code>read</code> 函数一次读取一块数据，然后再由高层的接口，一次从缓冲区读取一个字符（当缓冲区用完的时候需要重新填充），例如：</p>
<p><img src="/images/14574622326310.jpg" alt="Buffering in Standard I/O"></p>
<p>具体来看看这个例子：</p>
<p><img src="/images/14574622882078.jpg" alt="Standard I/O Buffering in Action"></p>
<p>注意右边的输出，实际上只写入了一次，一次六个字符，而不是程序中写的六次（这里好好感受下）</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>前面介绍了几种不同的 IO，它们的层级如下所示：</p>
<p><img src="/images/14574624849987.jpg" alt="Unix I/O vs. Standard I/O vs. RIO"></p>
<p>Unix I/O 的优劣：</p>
<p><img src="/images/14574625259926.jpg" alt="Pros and Cons of Unix I/O"></p>
<p>Standard I/O 的优劣：</p>
<p><img src="/images/14574625620916.jpg" alt="Pros and Cons of Standard I/O"></p>
<p>具体的选择建议为：</p>
<p><img src="/images/14574626154586.jpg" alt="Choosing I/O Functions"></p>
<p>最后是处理 binary files 的守则：</p>
<p><img src="/images/14574626867246.jpg" alt="Working with Binary Files"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解完了 Exceptional Control Flow，我们再来看看系统级 IO 的相关内容，完成这一课之后，就可以开始写我们自己的 shell 程序了。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="IO" scheme="http://wdxtub.com/tags/IO/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 14 课 Signals and Nonlocal Jumps]]></title>
    <link href="http://wdxtub.com/2016/03/06/csapp-14/"/>
    <id>http://wdxtub.com/2016/03/06/csapp-14/</id>
    <published>2016-03-06T12:47:36.000Z</published>
    <updated>2016-03-07T21:53:55.000Z</updated>
    <content type="html"><![CDATA[<p>了解完了异常与进程，异常处理中另外两个很重要的部分是信号和非局部跳转，也就是我们这节课要介绍的内容。</p>
<a id="more"></a>
<hr>
<p>Linux 的进程树，可以通过 <code>pstree</code> 命令查看，如下：</p>
<p><img src="/images/14573806185809.jpg" alt="Linux Process Hierarchy"></p>
<p>我们以 shell 为例子，来看看整个过程是如何实现的：</p>
<p><img src="/images/14573806718703.jpg" alt="Shell: Execution is a sequence of read/evaluate steps"></p>
<p><img src="/images/14573807472000.jpg" alt="Simple Shell eval Function"></p>
<p>如果只有前台进程的话，我们的 shell 可以在前台工作完成之后进行回收。但是后台进程则会在终止之后成为僵尸进程，不会被回收并且造成内存泄露。</p>
<p>这怎么办呢？同样可以利用 Exceptional control flow，当后台进程完成时，内核会中断常规执行并通知我们，具体的通知机制就是『信号』(signal)。</p>
<h2 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h2><blockquote>
<p>A signal is a small message that notifies a process that an event of some type has occurred in the system</p>
</blockquote>
<p>这样看来，其实是类似于 exception 和 interrupt 的，是由内核（在其他进程的请求下）向当前进程发出的。信号的类型由 1-30 的整数定义，信号所能携带的信息极少，一是对应的编号，二就是信号到达这个事实。下面是几个比较常用的信号的编号及简介：</p>
<p><img src="/images/14573811635888.jpg" alt=""></p>
<blockquote>
<p>Kernel sends a signal to a destination process by updating some state in the context of the destination process</p>
</blockquote>
<p>在下面两个场景中，内核会发送信号：</p>
<ul>
<li>内核检测到了如除以零(SIGFPE)或子进程终止(SIGCHLD)的系统事件</li>
<li>另一个进程调用了 <code>kill</code> 指令来请求内核发送信号给指定的进程</li>
</ul>
<blockquote>
<p>A destination process receives a signal when it is forced by the kernel to react in some way to the delivery of the signal</p>
</blockquote>
<p>一个进程在接收到了信号之后，可以有几种不同的操作：</p>
<ul>
<li><strong>忽略</strong>这个型号</li>
<li><strong>终止</strong>进程</li>
<li><strong>捕获</strong>信号，通过执行 signal handler 完成（类似于异步中断中的 exception handler）</li>
</ul>
<p>具体的过程如下：</p>
<p><img src="/images/14573814877982.jpg" alt=""></p>
<blockquote>
<p>A signal is pending if sent but not yet received</p>
</blockquote>
<p>同类型的信号至多只会有一个 pending signal，一定要注意这个特性，因为内部实现机制不可能提供较复杂的数据结构，所以信号的接收并不是一个队列。(If a process has a pending signal of type k, then subsequent signals of type k that are sent to that process are discarded)</p>
<p>一个 pending signal 至多只能被收到一次。</p>
<blockquote>
<p>A process can block the receipt of certain signals</p>
</blockquote>
<p>被阻塞的信号仍然可以发送，但是知道不阻塞之后才能被接收</p>
<p>内核用 pending 位向量 和 blocked 位向量来维护每个进程的信号相关状态</p>
<ul>
<li>pending: represents the set of pending signals<ul>
<li>Kernel sets bit k in <strong>pending</strong> when a signal of type k is delivered</li>
<li>Kernel clears bit k in <strong>pending</strong> when a signal of type k is received </li>
</ul>
</li>
<li>blocked: represent the set of blocked signals<ul>
<li>Can be set and cleared by using <code>sigprocmask</code> 函数</li>
<li>Also referred to as the <strong>signal mask</strong></li>
</ul>
</li>
</ul>
<p><strong>进程组</strong></p>
<p>每个进程都只属于一个进程组，如下图所示：</p>
<p><img src="/images/14573820359900.jpg" alt=""></p>
<p>我们可以据此指定一个进程组或者一个单独的进程，如：</p>
<p><img src="/images/14573821103841.jpg" alt="Sending Signals with `/bin/kill` Program"></p>
<p>这里可以看到，第一个命令只会杀掉编号为 24818 的进程，但是第二个命令，因为有两个进程都属于进程组 24817，所以会杀掉进程组中的每个进程。</p>
<p>键盘同样可以让内核向每个前台进程发送 SIGINT(SIGTSTP) 信号</p>
<ul>
<li>SIGINT - default action is to terminate each process</li>
<li>SIGTSTP - default action is to stop(suspend) each process</li>
</ul>
<p><img src="/images/14573823408948.jpg" alt="Example of ctrl-c and ctrl-z"></p>
<p>我们可以可以通过 <code>kill</code> 函数来发送信号：</p>
<p><img src="/images/14573824038965.jpg" alt="Sending Signals with kill Function"></p>
<h2 id="u63A5_u6536_u4FE1_u53F7"><a href="#u63A5_u6536_u4FE1_u53F7" class="headerlink" title="接收信号"></a>接收信号</h2><p>所有的上下文切换都是通过调用某个 exception handler 完成的，内核会计算对易于某个进程 p 的 pnb 值：<code>pnb = pending &amp; ~blocked</code></p>
<ul>
<li>如果 <code>pnb == 0</code><ul>
<li>那么就把控制交给进程 p 的逻辑流中的下一条指令</li>
</ul>
</li>
<li>否则<ul>
<li>选择 <code>pnb</code> 中最小的非零位 k，并强制进程 p 接收信号 k</li>
<li>接收到信号之后，进程 p 会执行对应的动作</li>
<li>对 <code>pnb</code> 中所有的非零位进行这个操作</li>
<li>最后把控制交给进程 p 的逻辑流中的下一条指令</li>
</ul>
</li>
</ul>
<p><strong>默认动作</strong></p>
<p>每个信号类型都有一个预定义的『默认动作』，可能是以下的情况：</p>
<ul>
<li>终止进程</li>
<li>终止进程并 dump core</li>
<li>停止进程，收到 <code>SIGCONT</code> 信号之后重启</li>
<li>忽略信号</li>
</ul>
<p><code>signal</code> 函数可以修改默认的动作：<code>handler_t *signal(int signum, handler_t *handler)</code>，具体来说：</p>
<p><img src="/images/14573845678378.jpg" alt="Different values for handler"></p>
<p>我们再通过具体的代码来感受下：</p>
<p><img src="/images/14573846209836.jpg" alt="Signal Handling Example"></p>
<p>可以这么理解 signal handler：</p>
<blockquote>
<p>A signal handler is a separate logical flow(not process) that runs concurrently with the main program</p>
</blockquote>
<p>如下图所示：</p>
<p><img src="/images/14573846875850.jpg" alt="Signals Handlers as Concurrent Flows"></p>
<p><img src="/images/14573847143072.jpg" alt="Another View of Signal Handlers as Concurrent Flows"></p>
<p>还是有一个需要注意的是，handler 也可以被其他的 handler 中断，控制流如下图所示：</p>
<p><img src="/images/14573848399013.jpg" alt="Nested Signal Handlers"></p>
<h2 id="u963B_u585E/_u4E0D_u963B_u585E_u4FE1_u53F7"><a href="#u963B_u585E/_u4E0D_u963B_u585E_u4FE1_u53F7" class="headerlink" title="阻塞/不阻塞信号"></a>阻塞/不阻塞信号</h2><p>隐式的机制是，内核会阻塞与当前在处理的信号同类型的其他 pending signal，也就是说，一个 SIGINT handler 是不能被另一个 SIGINT 信号中断的。</p>
<p>如果想要显式阻塞，就需要使用 <code>sigprocmask</code> 函数了，以及其他一些辅助函数：</p>
<ul>
<li><code>sigemptyset</code> - Create empty set</li>
<li><code>sigfillset</code> - Add every signal number to set</li>
<li><code>sigaddset</code> - Add signal number to set</li>
<li><code>sigdelset</code> - Delete signal number from set</li>
</ul>
<p>我们可以用下面折断代码来临时阻塞特定的信号：</p>
<p><img src="/images/14573850645959.jpg" alt="Temporarily Blocking Signals"></p>
<h2 id="u5B89_u5168_u5730_u5904_u7406_u4FE1_u53F7"><a href="#u5B89_u5168_u5730_u5904_u7406_u4FE1_u53F7" class="headerlink" title="安全地处理信号"></a>安全地处理信号</h2><blockquote>
<p>Handlers are tricky because they are concurrent with main program and share the same global data structures</p>
</blockquote>
<p>尤其要注意因为并行访问可能导致的数据损坏的问题，这里提供一些基本的指南（后面的课程会详细介绍）</p>
<p><img src="/images/14573852332585.jpg" alt="Guidelines for Writing Safe Handlers"></p>
<p>另外一个需要注意的问题是 Async-Signal-Safety。</p>
<blockquote>
<p>Function is async-signal-safe if either reentrant(all variables sotred on stack frame) or non-interruptible by signals</p>
</blockquote>
<p>Posix 标准指定了 117 个 async-signal-safe 的函数（可以通过 <code>man 7 signal</code> 查看）</p>
<p><img src="/images/14573853746526.jpg" alt="许多常用的函数都不是 async-signal-safe 的"></p>
<p>因为输出函数不是 async-signal-safe 的，所以最好使用课本中提供的 <code>csapp.c</code> 中的相关 handler</p>
<ul>
<li><code>ssize_t sio_puts(char s[])</code> - Put string</li>
<li><code>ssize_t sio_putl(long v)</code> - Put long</li>
<li><code>void sio_error(char s[])</code> - Put msg &amp; exit</li>
</ul>
<p><img src="/images/14573854667518.jpg" alt=""></p>
<p>正确的信号处理方法：</p>
<ul>
<li>You can’t use signals to count events, such as children terminating</li>
<li>Must wait for all terminated child processes.</li>
</ul>
<p><img src="/images/14573856728934.jpg" alt="Put `wait` in a loop to reap all terminated children"></p>
<p>还有一个问题，不同 Unix 版本有不同的 signal handling semantics，我们给出的解决方案是使用 <code>sigaction</code>，如下：</p>
<p><img src="/images/14573860066787.jpg" alt="Portable Signal Handling"></p>
<h2 id="u907F_u514D_u8FDB_u7A0B_u7ADE_u4E89"><a href="#u907F_u514D_u8FDB_u7A0B_u7ADE_u4E89" class="headerlink" title="避免进程竞争"></a>避免进程竞争</h2><p>我们之前的 shell 代码会出现微妙的同步错误，因为我们假设父进程会在子进程之前执行，代码如下：</p>
<p><img src="/images/14573866195444.jpg" alt=""></p>
<p><img src="/images/14573866343912.jpg" alt=""></p>
<p>我们需要在循环中添加同步条件，确保父进程和子进程的顺序（注意比较）</p>
<p><img src="/images/14573867961969.jpg" alt="Corrected Shell Program without Race"></p>
<h2 id="u663E_u5F0F_u7B49_u5F85_u4FE1_u53F7"><a href="#u663E_u5F0F_u7B49_u5F85_u4FE1_u53F7" class="headerlink" title="显式等待信号"></a>显式等待信号</h2><p>我们也可以用类似与等待前台任务执行的方式来等待子进程，方法如下：</p>
<p><img src="/images/14573869619954.jpg" alt="Handlers for program explicitly waiting for SIGCHLD to arrive"></p>
<p><img src="/images/14573869910604.jpg" alt="Handlers for program explicitly waiting for SIGCHLD to arrive"></p>
<p>这里的代码是正确的，但是我们注意 <code>while(!pid)</code> 这一句，通过忙等待的方式实现同步，非常浪费资源，而其他方式看起来也不行：</p>
<p><img src="/images/14573870533166.jpg" alt="Other options"></p>
<p>怎么办呢？我们的解决办法是 <code>sigsuspend</code>，函数为：</p>
<p><code>int sigsuspend(const sigset_t *mask)</code></p>
<p>等同于 atomic 版本的：</p>
<p><img src="/images/14573871178306.jpg" alt=""></p>
<p>所以代码如下：</p>
<p><img src="/images/14573871346551.jpg" alt="Wating for Signals with sigsuspend"></p>
<h2 id="Nonlocal_Jump"><a href="#Nonlocal_Jump" class="headerlink" title="Nonlocal Jump"></a>Nonlocal Jump</h2><p>这一部分比较简单，主要是使用 <code>setjmp</code> 与 <code>longjmp</code></p>
<p><img src="/images/14573872756594.jpg" alt="NoNonlocal Jumps: setjmp/longjmp"></p>
<p><img src="/images/14573873026532.jpg" alt="NoNonlocal Jumps: setjmp/longjmp"></p>
<p>我们可以利用这种方式，来跳转到其他的栈帧中，比方说在嵌套函数中，我们可以利用这个快速返回栈底的函数：</p>
<p><img src="/images/14573874602644.jpg" alt=""></p>
<p>但是也有限制，必须在栈中（也就是还没完成）才可以进行跳转，下面的例子中，因为 P2 已经返回，所以不能跳转了：</p>
<p><img src="/images/14573875130970.jpg" alt=""></p>
<p>最后是一个非常清晰的例子：</p>
<p><img src="/images/14573875598038.jpg" alt="A Program that restarts itself when ctrl-c"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这两个基本说完了 exceptional control flow 的全部内容，可能会稍微有点难以理解，我会在后面的习题课中尽可能详细说明。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解完了异常与进程，异常处理中另外两个很重要的部分是信号和非局部跳转，也就是我们这节课要介绍的内容。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="异常" scheme="http://wdxtub.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 13 课 Exceptions and Processes]]></title>
    <link href="http://wdxtub.com/2016/03/06/csapp-13/"/>
    <id>http://wdxtub.com/2016/03/06/csapp-13/</id>
    <published>2016-03-06T12:47:32.000Z</published>
    <updated>2016-03-06T23:16:54.000Z</updated>
    <content type="html"><![CDATA[<p>了解完了链接，我们来看看在程序出错的时候会发生什么事情，这一课我们主要来了解异常与进程。</p>
<a id="more"></a>
<hr>
<p>从开机到关机，CPU 做的工作其实很简单，就是不断读取并执行指令，每次执行一条，整个指令执行的序列，称为 CPU 的控制流。到目前为止，我们已经学过了两种改变控制流的方式：</p>
<ul>
<li>跳转和分支</li>
<li>调用和返回</li>
</ul>
<p>这对应于 program state 的改变。但是这实际上仅仅局限于程序的控制，没有办法去应对更加复杂的情况，比方说 system state 变化的时候：</p>
<ul>
<li>数据从磁盘或者网络适配器到达</li>
<li>指令除以了零</li>
<li>用户按下 ctrl+c</li>
<li>系统的计时器到时间</li>
</ul>
<p>所以我们这里会介绍另一种机制，称为 exceptional control flow。</p>
<h2 id="Exceptional_Control_Flow"><a href="#Exceptional_Control_Flow" class="headerlink" title="Exceptional Control Flow"></a>Exceptional Control Flow</h2><p>Exceptional Control Flow 存在于系统的每个层级：</p>
<p><img src="/images/14572937620861.jpg" alt=""></p>
<p>本节课我们先介绍前两种，下节课介绍后面两种。</p>
<h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><p>An <strong>exception</strong> is a transfer of control to the OS kernel in response to some event (i.e., change in processor state)</p>
<ul>
<li>Kernel 是操作系统常驻内存的一部分</li>
<li>Event: Divide by 0, arithmetic overflow, page fault, I/O request completes, typing ctrl-c</li>
</ul>
<p>具体的过程可以用下图表示：</p>
<p><img src="/images/14572946534326.jpg" alt="Exception 流程"></p>
<p>系统会通过 Exception Table 来确定跳转的位置，每种事件都有对应的唯一的异常编号，发生对应异常时就会调用对应的异常处理代码：</p>
<p><img src="/images/14572947301161.jpg" alt="Exception Table"></p>
<h3 id="Asynchronous_Exceptions__28Interrupts_29"><a href="#Asynchronous_Exceptions__28Interrupts_29" class="headerlink" title="Asynchronous Exceptions (Interrupts)"></a>Asynchronous Exceptions (Interrupts)</h3><p>异步异常称之为中断，是有处理器外面发生的事情引起的，这种情况下：</p>
<ul>
<li>需要设置处理器的 interrupt pin</li>
<li>处理完成后会返回之前控制流中的『下一条』指令</li>
</ul>
<p><img src="/images/14572948483518.jpg" alt="中断的两个例子"></p>
<h3 id="Synchronous_Exceptions"><a href="#Synchronous_Exceptions" class="headerlink" title="Synchronous Exceptions"></a>Synchronous Exceptions</h3><p>同步异常是因为执行某条指令所导致的事件，分为 Traps, Faults 和 Aborts 三种情况：</p>
<p><img src="/images/14572949405706.jpg" alt="同步异常的三种类型"></p>
<p>这里需要注意三种不同类型的处理方式，比方说 Traps 和终端一样，会返回执行『下一条』指令；而 Faults 会重新执行之前触发事件的指令；Aborts 则是直接退出当前的程序。</p>
<p><strong>System Call Example</strong></p>
<p>这里我们来了解一下系统调用 System Calls，系统调用看起来像是函数调用，但其实是走异常控制流的，在 x86-64 系统中，每个系统调用都有一个唯一的 ID，如：</p>
<p><img src="/images/14572951617051.jpg" alt=""></p>
<p>而具体的的调用过程如下所示：</p>
<p><img src="/images/14572951831475.jpg" alt=""></p>
<p><strong>Fault Example</strong></p>
<p>这里卫门以 Page Fault 为例，来说明 Fault 的机制。Page Fault 发生的条件是：</p>
<ul>
<li>用户写入内存位置</li>
<li>但该位置目前还不在内存中</li>
</ul>
<p>比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    a[<span class="number">500</span>] = <span class="number">13</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么系统会通过 Page Fault 把对应的部分载入到内存中，然后重新执行赋值语句：</p>
<p><img src="/images/14572953320001.jpg" alt=""></p>
<p>但是如果代码改为这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    a[<span class="number">5000</span>] = <span class="number">13</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是引用非法地址的时候，整个流程就会变成：</p>
<p><img src="/images/14572953822399.jpg" alt=""></p>
<p>具体来说会像用户进程发送 <code>SIGSEGV</code> 信号，用户进程会以 segmentation fault 的标记退出。</p>
<p>从上面我们就可以看到异常是非常底层的机制。</p>
<h2 id="Process__u8FDB_u7A0B"><a href="#Process__u8FDB_u7A0B" class="headerlink" title="Process 进程"></a>Process 进程</h2><blockquote>
<p>A process is an instance of a running program</p>
</blockquote>
<p>进程是计算机可续中最为重要的思想之一，注意，和 “program” 或 “processor” 都不一样。</p>
<p><img src="/images/14572960158600.jpg" alt="进程示意图"></p>
<p>进程给每个应用提供了两个非常关键的抽象：</p>
<p><img src="/images/14572959919795.jpg" alt="两个关键抽象"></p>
<p>计算机会同时运行多个进程，比如说不同的前台应用，或者后台任务，比方说在 Mac 下输入 <code>top</code>，可以看到如下的进程信息：</p>
<p><img src="/images/14572961362662.jpg" alt="我的电脑当前的状态"></p>
<p>具体的多线程模型如下所示：</p>
<p><img src="/images/14572962685162.jpg" alt="多线程模型（单核）"></p>
<ul>
<li>CPU 交替执行不同的进程</li>
<li>虚拟内存系统会负责管理地址空间</li>
<li>没有执行的进程的寄存器值会被保存在内存中</li>
</ul>
<p><img src="/images/14572963666951.jpg" alt="切换到另一个进程执行，会载入原先的寄存器值(context switch)"></p>
<p>而现代处理器一般有多个核心，所以可以真正同时执行多个进程：</p>
<p><img src="/images/14572964493864.jpg" alt="现代处理器执行模型"></p>
<p>进程之间，也分并行与串行的关系：</p>
<ul>
<li>Two processes run <strong>concurrently</strong> if their flows overlap in time</li>
<li>Otherwise, they are <strong>sequential</strong></li>
</ul>
<p>比方说下图中：</p>
<p><img src="/images/14572965827499.jpg" alt=""></p>
<ul>
<li>Concurrent: A&amp;B, A&amp;C</li>
<li>Sequential: B&amp;C</li>
</ul>
<p>不过在用户看来，执行的感觉是这样的：</p>
<p><img src="/images/14572966466237.jpg" alt=""></p>
<h3 id="Context_Switching"><a href="#Context_Switching" class="headerlink" title="Context Switching"></a>Context Switching</h3><p>具体切换进程时，kernel 会负责具体的调度。</p>
<blockquote>
<p>The kernel is not a separate process, but rather runs as part of some existing process</p>
</blockquote>
<p>控制流通过上下文切换的方式从一个进程到另一个进程，如下图所示：</p>
<p><img src="/images/14572967455790.jpg" alt="上下文切换 Context Switching"></p>
<h2 id="Process_Control__u8FDB_u7A0B_u63A7_u5236"><a href="#Process_Control__u8FDB_u7A0B_u63A7_u5236" class="headerlink" title="Process Control 进程控制"></a>Process Control 进程控制</h2><h3 id="System_Call_Error_Handling"><a href="#System_Call_Error_Handling" class="headerlink" title="System Call Error Handling"></a>System Call Error Handling</h3><p>在遇到错误的时候，Linux 系统级函数通常会返回 -1 并且设置 <code>errno</code> 这个全局变量来表示错误的原因。使用的时候记住两个规则：</p>
<ol>
<li>You must check the return status of every system-level function</li>
<li>Only exception is the handful of functions that return void</li>
</ol>
<p>例如，对于 <code>fork()</code> 函数，我们应该这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"fork error: %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果觉得这样写太麻烦，可以利用一个辅助函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unix_error</span><span class="params">(<span class="keyword">char</span> *msg)</span> <span class="comment">/* Unix-style error */</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: %s\n"</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的片段可以写为</span></span><br><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">"fork error"</span>);</span><br></pre></td></tr></table></figure>
<p>我们甚至可以更进一步，把整个 <code>fork()</code> 包装起来，就可以自带错误处理，比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> Fork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">"Fork error"</span>);</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的时候直接使用 <code>pid = Fork();</code> 即可（注意这里是大写的 F）</p>
<h3 id="u83B7_u53D6_u8FDB_u7A0B_u4FE1_u606F"><a href="#u83B7_u53D6_u8FDB_u7A0B_u4FE1_u606F" class="headerlink" title="获取进程信息"></a>获取进程信息</h3><ul>
<li><code>pid_t getpid(void)</code> - 返回当前进程的 PID</li>
<li><code>pid_t getppid(void)</code> - 返回当前进程的父进程的 PID</li>
</ul>
<p>我们可以认为，进程有三个状态：</p>
<ul>
<li>Running<ul>
<li>正在被执行、正在等待执行或者最终将会被执行</li>
</ul>
</li>
<li>Stopped<ul>
<li>执行被挂起，在进一步通知前不会计划执行</li>
</ul>
</li>
<li>Terminated<ul>
<li>进程被永久停止</li>
</ul>
</li>
</ul>
<p><strong>终止进程</strong></p>
<p>在下面三种情况时，进程会被终止：</p>
<ol>
<li>接收到一个终止信号</li>
<li>返回到 <code>main</code> </li>
<li>调用了 <code>exit</code> 函数</li>
</ol>
<p><img src="/images/14573038632263.jpg" alt="exit is called once but never returns"></p>
<p><strong>创建进程</strong></p>
<p>调用 <code>fork</code> 来创造新进程</p>
<p><img src="/images/14573039229956.jpg" alt="fork is interesting becasue it is called once but returns twice"></p>
<p>下面我们来看一个简单的例子：</p>
<p><img src="/images/14573039725814.jpg" alt=""></p>
<p>有以下几点需要注意：</p>
<ul>
<li>调用一次，但是会有两个返回值</li>
<li>并行执行，不能预计父进程和子进程的执行顺序</li>
<li>拥有自己独立的地址空间（也就是变量都是独立的），除此之外其他都相同</li>
<li>在父进程和子进程中 <code>stdout</code> 是一样的</li>
</ul>
<h3 id="u8FDB_u7A0B_u56FE"><a href="#u8FDB_u7A0B_u56FE" class="headerlink" title="进程图"></a>进程图</h3><p>进程图是一个很好的帮助我们理解进程执行的工具：</p>
<ul>
<li>每个节点代表一条执行的语句</li>
<li>a -&gt; b 表示 a 在 b 前面执行</li>
<li>边可以用当前变量的值来标记</li>
<li><code>printf</code> 节点可以用输出来进行标记</li>
<li>每个图由一个入度为 0 的节点作为起始</li>
</ul>
<p>对于进程图来说，只要满足拓扑排序，就是可能的输出。我们还是用刚才的例子：</p>
<p><img src="/images/14573044246995.jpg" alt=""></p>
<p>我们再来看三个稍微复制一点的例子：</p>
<p><img src="/images/14573045555520.jpg" alt="Two consecutive forks"></p>
<p><img src="/images/14573045862749.jpg" alt="Nested forks in parent"></p>
<p><img src="/images/14573046274270.jpg" alt="Nested forks in children"></p>
<h3 id="Reaping_Child_Processes"><a href="#Reaping_Child_Processes" class="headerlink" title="Reaping Child Processes"></a>Reaping Child Processes</h3><p>即使进程已经终止，也还在消耗系统资源，我们称之为『僵尸』。为了『打僵尸』，就可以采用『收割』(Reaping) 的方法。父进程利用 <code>wait</code> 或 <code>waitpid</code> 回收已终止的子进程，然后给系统提供相关信息，kernel 就会把 zombie child process 给删除。</p>
<p>如果父进程不『收割』的话，通常来说会被 <code>init</code> 进程(pid == 1)回收，所以一般不必显式回收。但是在长期运行的进程中，就需要显式回收（例如 shell 和 server）。下面是几个僵尸进程的例子：</p>
<p><img src="/images/14573049855888.jpg" alt="这里，子进程可以成功被回收"></p>
<p><img src="/images/14573050208627.jpg" alt="这里，因为子进程没有调用 `exit`，所以需要显式回收"></p>
<p><strong>wait: Synchronizing with Children</strong></p>
<p>父进程通过调用 <code>wait</code> 函数来『收割』子进程</p>
<p><img src="/images/14573055666401.jpg" alt=""></p>
<p>下面是一个具体的例子，同样用进程图来描述：</p>
<p><img src="/images/14573056037360.jpg" alt="wait: Synchronizing with Children"></p>
<p><img src="/images/14573056447947.jpg" alt="If multiple children completed, will take in arbitrary order. Can use macros WIFEXITED and WEXITSTATUS to get information about exit status"></p>
<p><strong>waitpid: Waiting for a Specific Process</strong></p>
<p>直接看例子：</p>
<p><img src="/images/14573057138513.jpg" alt=""></p>
<p><strong>execve: Loading and Running Programs</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span></span><br></pre></td></tr></table></figure>
<p>具体的行为是：</p>
<p><img src="/images/14573057856048.jpg" alt=""></p>
<p>为了理解 <code>execve</code> 的行为，我们要先理解程序在栈中的布局：</p>
<p><img src="/images/14573058581756.jpg" alt="栈的结构"></p>
<p>一个具体的例子：</p>
<p><img src="/images/14573058863617.jpg" alt="execve 例子"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Exceptions<ul>
<li>Events that require nonstandard control flow</li>
<li>Generated externally (interrupts) or internally (traps and faults)</li>
</ul>
</li>
<li>Processes<ul>
<li>At any given time, system has multiple active processes</li>
<li>Only one can execute at a time on a single core, though</li>
<li>Each process appears to have total control of processor + private memory space</li>
</ul>
</li>
<li>Spawning processes<ul>
<li>Call <code>fork</code></li>
<li>One call, two returns</li>
</ul>
</li>
<li>Process completion<ul>
<li>Call <code>exit</code></li>
<li>One call </li>
</ul>
</li>
<li>Reaping and waiting for processes<ul>
<li>Call <code>wait</code> or <code>waitpid</code></li>
</ul>
</li>
<li>Loading and running programs<ul>
<li>Call <code>execve</code></li>
<li>One call, (normally) no return</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解完了链接，我们来看看在程序出错的时候会发生什么事情，这一课我们主要来了解异常与进程。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="异常" scheme="http://wdxtub.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 12 课 Linking]]></title>
    <link href="http://wdxtub.com/2016/03/06/csapp-12/"/>
    <id>http://wdxtub.com/2016/03/06/csapp-12/</id>
    <published>2016-03-06T12:47:27.000Z</published>
    <updated>2016-03-06T18:48:49.000Z</updated>
    <content type="html"><![CDATA[<p>这一课我们要接触一个新概念：Linking，简单来说就是计算机如何让不同的代码协同工作的方式。</p>
<a id="more"></a>
<hr>
<p>我们先来看一个例子，假设有这么两个代码文件</p>
<p><img src="/images/14572758203003.jpg" alt=""></p>
<p>我们用下面的命令来编译执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; gcc -Og -o prog main.c sum.c</span><br><span class="line">linux&gt; ./prog</span><br></pre></td></tr></table></figure>
<p>编译器实际上会分别编译不同的源代码，生成 <code>.o</code> 文件，具体把这些文件链接在一起的是 Linker 链接器，整个过程如下图所示：</p>
<p><img src="/images/14572760766987.jpg" alt=""></p>
<blockquote>
<p>为什么要使用链接器？</p>
</blockquote>
<p>有如下两个原因。</p>
<ul>
<li>模块化角度考虑。我们可以把程序分散到不同的小的源代码中，而不是一个巨大的类中。这样带来的好处是可以复用常见的功能/库，比方说 Math library, standard C library.</li>
<li>效率角度考虑。改动代码时只需要重新编译改动的文件，其他不受影响。而常用的函数和功能可以封装成库，提供给程序进行调用（节省空间）</li>
</ul>
<blockquote>
<p>链接器做了什么？</p>
</blockquote>
<p>主要负责做两件事情</p>
<p><strong>第一步：Symbol resolution</strong></p>
<p>我们在代码中会声明变量及函数，之后会调用变量及函数，所有的符号声明都会被保存在符号表(symbol table)中，而符号表会保存在由汇编器生成的 object 文件中（也就是 <code>.o</code> 文件）。符号表实际上是一个结构体数组，每一个元素包含名称、大小和符号的位置。</p>
<p>在 symbol resolution 阶段，链接器会给每个符号应用一个唯一的符号定义，用作寻找对应符号的标志。</p>
<p><strong>第二步：Relocation</strong></p>
<p>这一步所做的工作是把原先分开的代码和数据片段汇总成一个文件，会把原先在 <code>.o</code> 文件中的相对位置转换成在可执行程序的绝对位置，并且据此更新对应的引用符号（才能找到新的位置）</p>
<p>在具体来看这两步做了啥之前，先要理解下面几个概念。</p>
<h2 id="u4E09_u79CD_Object_Files"><a href="#u4E09_u79CD_Object_Files" class="headerlink" title="三种 Object Files"></a>三种 Object Files</h2><p>所谓的 Object File 实际上是一个统称，具体来说有以下三种形式：</p>
<ul>
<li>Relocatable object file (<code>.o</code> file)<ul>
<li>每个 <code>.o</code> 文件都是由对应的 <code>.c</code> 文件生成，包含代码和数据，可以用来组合成 executable object file</li>
</ul>
</li>
<li>Executable object file (<code>a.out</code> file)<ul>
<li>包含代码和数据，可以直接被复制到内存中执行</li>
</ul>
</li>
<li>Shared object file (<code>.so</code> file)<ul>
<li>在 windows 中被称为 Dynamic Link Libraries(DLLs)，是一类特别的 relocatable object file，能够被载入内存并动态链接（载入时或运行时）</li>
</ul>
</li>
</ul>
<h2 id="Executable_and_Linkable_Format_28ELF_29"><a href="#Executable_and_Linkable_Format_28ELF_29" class="headerlink" title="Executable and Linkable Format(ELF)"></a>Executable and Linkable Format(ELF)</h2><p>上面提到的三种 obejct file 有统一的格式，即 Executable and Linkable Format(ELF)，因为，我们把它们统称为 ELF binaries，具体的文件格式如下</p>
<p><img src="/images/14572780724226.jpg" alt="ELF 文件格式"></p>
<p>下面分别介绍一下各个部分：</p>
<ul>
<li>ELF header<ul>
<li>包含 word size, byte ordering, file type (.o, exec, .so), machine type, etc</li>
</ul>
</li>
<li>Segment header table<ul>
<li>包含 page size, virtual addresses memory segments(sections), segment sizes</li>
</ul>
</li>
<li>.text section<ul>
<li>代码部分</li>
</ul>
</li>
<li>.rodata section<ul>
<li>只读数据部分，例如 jump tables</li>
</ul>
</li>
<li>.data section<ul>
<li>初始化的全局变量</li>
</ul>
</li>
<li>.bss section<ul>
<li>未初始化的全局变量</li>
<li>“Block Started by Symbol”</li>
<li>“Better Save Space”</li>
<li>有 section header 但实际上不占空间</li>
</ul>
</li>
<li>.symtab section<ul>
<li>包含 symbol table, procudure 和 static variable names 以及 section names 和 location</li>
</ul>
</li>
<li>.rel.txt section<ul>
<li>Relocation info for .text section</li>
<li>Addresses of instructions that will need to be modified in the executable</li>
<li>Instructions for modifying</li>
</ul>
</li>
<li>.rel.data section<ul>
<li>Relocation info for .data section</li>
<li>Addresses of pointer data that will need to be modified in the merged executable </li>
</ul>
</li>
<li>.debug section<ul>
<li>包含 symbolic debugging (<code>gcc -g</code>) 的信息 </li>
</ul>
</li>
<li>Section header table<ul>
<li>Offsets and sizes of each section</li>
</ul>
</li>
</ul>
<h2 id="Linker_Symbols"><a href="#Linker_Symbols" class="headerlink" title="Linker Symbols"></a>Linker Symbols</h2><p>而链接器实际上会处理三种不同的符号，对应于代码中不同写法的部分：</p>
<ul>
<li>Global symbols<ul>
<li>在当前模块中定义，且可以被其他代码引用的符号，例如非静态 C 函数和非静态全局变量</li>
</ul>
</li>
<li>External symbols<ul>
<li>同样是全局符号，但是是在其他模块（也就是其他的源代码）中定义的，但是可以在当前模块中引用</li>
</ul>
</li>
<li>Local symbols<ul>
<li>在当前模块中定义，只能被当前模块引用的符号，例如静态函数和静态全局变量</li>
<li>注意，Local linker symbol 并不是 local program variables</li>
</ul>
</li>
</ul>
<p>现在我们可以回过头来看看链接器具体做的工作了：</p>
<h2 id="u7B2C_u4E00_u6B65_uFF1ASymbol_resolution"><a href="#u7B2C_u4E00_u6B65_uFF1ASymbol_resolution" class="headerlink" title="第一步：Symbol resolution"></a>第一步：Symbol resolution</h2><p><img src="/images/14572791281425.jpg" alt="Symbol resolution"></p>
<p>我们可以看到，链接器只知道非静态的全局变量/函数，而对于局部变量一无所知。</p>
<p>然后我们来看看局部非静态变量和局部静态变量的区别</p>
<ul>
<li>局部非静态变量会保存在栈中</li>
<li>局部静态变量会保存在 <code>.bss</code> 或 <code>.data</code> 中</li>
</ul>
<p>例如：</p>
<p><img src="/images/14572793537491.jpg" alt=""></p>
<p>如果两个不同的源代码中使用了相同的全局变量名称，链接器会如何处理呢？</p>
<p>首先我们需要知道的是，不同的符号是有强弱之分的：</p>
<ul>
<li>Strong: procedures and initialized globals</li>
<li>Weak: uninitialized globals</li>
</ul>
<p>比如：</p>
<p><img src="/images/14572854731828.jpg" alt=""></p>
<p>在这个基础上，有如下规则：</p>
<p><img src="/images/14572855304555.jpg" alt=""></p>
<p>因为这个特性，可能会因为变量重名导致非常奇怪的现象，比如下面的情况：</p>
<p><img src="/images/14572855800167.jpg" alt=""></p>
<p>因此我们可以得到一条很重要的编程建议：</p>
<blockquote>
<p>如果可能，尽量避免使用全局变量</p>
</blockquote>
<p>如果一定要用的话，注意下面几点：</p>
<ul>
<li>使用静态变量</li>
<li>定义全局变量的时候初始化</li>
<li>注意使用 <code>extern</code> 关键字</li>
</ul>
<h2 id="u7B2C_u4E8C_u6B65_uFF1ARelocation"><a href="#u7B2C_u4E8C_u6B65_uFF1ARelocation" class="headerlink" title="第二步：Relocation"></a>第二步：Relocation</h2><p>大概的过程，通过下图就可以看得比较清楚，就是把不同的 relocatable object files 拼成 executable object file 的过程</p>
<p><img src="/images/14572863145911.jpg" alt=""></p>
<p>但具体是怎么做到的呢，还是刚才那个例子：</p>
<p><img src="/images/14572863618645.jpg" alt=""></p>
<p>对应的 relocatable object file 反编译出来 <code>objdump -r -d main.o</code> 可以看到汇编代码为：</p>
<p><img src="/images/14572864112503.jpg" alt=""></p>
<p>这里我们可以看到，编译器用 relocation entry 来标记不同的调用（注意看对应的代码后面四组数字都是零，就是留出位置让链接器在链接的时候填上对应的实际内存地址）</p>
<p>在完成链接之后我们得到 <code>prog</code> 这个程序，同样反编译 <code>objdump -dx prog</code> 可以看到：</p>
<p><img src="/images/14572865303343.jpg" alt=""></p>
<p>对应的地址已经被填上去了，这里注意用的是相对的位置，比方说 0x4004de 中的 05 00 00 00 的意思实际上是说要在下一句的基础上加上 0x5，也就是 0x4004e8，即 sum 函数的开始位置。</p>
<p>具体载入内存的时候，大概是这样的：</p>
<p><img src="/images/14572866787544.jpg" alt=""></p>
<p>这里需要注意左边的部分地址从上往下，右边则是从下往上，这里所有的程序都会从 0x400000 开始。</p>
<h2 id="u6253_u5305_u5E38_u7528_u7A0B_u5E8F"><a href="#u6253_u5305_u5E38_u7528_u7A0B_u5E8F" class="headerlink" title="打包常用程序"></a>打包常用程序</h2><p>基本上每个程序都会用到某些特定的函数，比如：Math, IO, memory management, string manipulation 等等，我们能用什么方法把它们结合到程序中呢，有以下两个思路：</p>
<ul>
<li>思路 1：把所有的函数放到一个源文件中，程序员每次把这一整个大块头链接到自己的程序中，这种做法从时间和空间上来说都比较低效</li>
<li>思路 2：不同的函数放到不同的源文件中，由程序员显式链接所需要的函数，这种做法效率更高，但是相当于是给程序员增加负担了</li>
</ul>
<h3 id="Static_Libraries"><a href="#Static_Libraries" class="headerlink" title="Static Libraries"></a>Static Libraries</h3><p>比较老式的做法就是所谓的静态库(Static Libraries, <code>.a</code> archive files)</p>
<ul>
<li>Concatenate related relocatable object files into a single file with an index (called an archive)</li>
<li>Enhance linker so that it tries to resolve unresolved external references by looking for the symbols in one or more archives</li>
<li>If an archive member file resolves reference, link it into the executable</li>
</ul>
<p>具体的过程如下：</p>
<p><img src="/images/14572879938673.jpg" alt=""></p>
<p>这里注意，Archiver 支持增量更新，如果有函数变动，只需要重新编译改动的部分。</p>
<p>下面是两个常用的库：C standard library 与 C math library</p>
<p><img src="/images/14572880658935.jpg" alt=""></p>
<p>接下来我们看一个具体的例子，通过静态库来连接：</p>
<p><img src="/images/14572880967573.jpg" alt=""></p>
<p>具体过程如下：</p>
<p><img src="/images/14572881242795.jpg" alt=""></p>
<p>具体的链接方式是：</p>
<p><img src="/images/14572882030642.jpg" alt=""></p>
<p>但是这样会带来一个问题：写编译命令的时候，顺序是很重要的！我们看下面这个例子</p>
<p><img src="/images/14572882337934.jpg" alt=""></p>
<p>第一条命令中，在编译链接的时候，如果在 libtest.o 中发现了外部引用，就会在 -lmine 中查找，但是如果反过来，在第二条语句中 libtest.o 后面没有东西，就会出现找不到引用的错误。所以建议就是要把静态库都放到后面去。</p>
<h3 id="Shared_Libraries"><a href="#Shared_Libraries" class="headerlink" title="Shared Libraries"></a>Shared Libraries</h3><p>现代的方法则是使用共享库，避免了在文件中静态库的大量重复。</p>
<p>动态链接可以在首次载入的时候执行(load-time linking)，这是 Linux 的标准做法，会由动态链接器 <code>ld-linux.so</code> 完成，Standard C library(libc.so) 通常是动态链接的。</p>
<p><img src="/images/14572885863404.jpg" alt="Dynamic Linking at Load-time"></p>
<p>动态链接也可以在程序开始执行的时候完成(run-time linking)，在 Linux 中使用 <code>dlopen()</code> 接口来完成（会使用函数指针，如下面的例子所示），通常用于分布式软件，高性能服务器上。而且共享库也可以在多个进程间共享，这在后面学习到虚拟内存的时候会介绍。</p>
<p><img src="/images/14572886125265.jpg" alt=""></p>
<p><img src="/images/14572886257737.jpg" alt="Dynamic Linking at Run-time"></p>
<p>总结一下：</p>
<ul>
<li>链接使得我们可以用多个 object files 构造我们的程序</li>
<li>链接可以发生在程序的不同阶段<ul>
<li>编译期间(when a program is compiled)</li>
<li>载入期间(when a program is loaded into memory)</li>
<li>运行期间(while program is executing)</li>
</ul>
</li>
<li>理解链接可以帮助我们避免遇到奇怪的错误</li>
</ul>
<h2 id="Case_Study_3A_Library_Interpositioning"><a href="#Case_Study_3A_Library_Interpositioning" class="headerlink" title="Case Study: Library Interpositioning"></a>Case Study: Library Interpositioning</h2><p>这是一个非常有意思的技术，我们可以通过这个技术让程序运行任意我们想要的代码，比方说我们的程序中使用了 <code>malloc</code>，我们可以通过 library interpositioning 让程序执行我们自定义的 <code>malloc</code> 而不是标准库中的 <code>malloc</code>。</p>
<p>因为这相当于是某种链接技术，所以同样可以在不同的时候发生，如：</p>
<ul>
<li>编译时：When the source code is compiled</li>
<li>链接时：When the relocatable object files are statically linked to form an executable object file</li>
<li>载入/运行时：When an executable object file is loaded into memory, dynamically linked, and then executed.</li>
</ul>
<p>这个技术可以应用在</p>
<ul>
<li>安全方面<ul>
<li>Confinement (sandboxing)</li>
<li>Behind the scenes encryption</li>
</ul>
</li>
<li>调试方面<ul>
<li>可以找到隐藏比较深的 bug</li>
</ul>
</li>
<li>监控和查看性能<ul>
<li>统计函数调用的次数</li>
<li>检测内存泄露</li>
<li>生成地址记录</li>
</ul>
</li>
</ul>
<p>我们用一个具体的例子来说明，先来看看程序，非常简单，只有几行：</p>
<p><img src="/images/14572895007610.jpg" alt=""></p>
<p>我们要做的事情也很简单，先申请一片内存空间，然后再释放掉。但是我们的目标是在不修改源代码的前提下，追踪分配地址的位置，要怎么办呢？</p>
<p>有三种方式，分别在编译、链接和运行时对 <code>malloc</code> 和 <code>free</code> 函数进行 interpositioning。</p>
<h3 id="Compile-time_Interpositioning"><a href="#Compile-time_Interpositioning" class="headerlink" title="Compile-time Interpositioning"></a>Compile-time Interpositioning</h3><p>我们写出另外两个函数，它们唯一做的事情就是输出地址，相当于把原来的函数做了个『包装』：</p>
<p><img src="/images/14572896784067.jpg" alt=""></p>
<p>然后在 <code>malloc.h</code> 利用宏进行改变：</p>
<p><img src="/images/14572897247442.jpg" alt=""></p>
<p>最后我们可以通过 <code>-I.</code> 这个选项来使得程序会调用我们自己写的函数，可以看到执行的时候会打印出地址</p>
<p><img src="/images/14572897797778.jpg" alt=""></p>
<h3 id="Link-time_Interpositioning"><a href="#Link-time_Interpositioning" class="headerlink" title="Link-time Interpositioning"></a>Link-time Interpositioning</h3><p>我们同样需要把两个函数包装一下：</p>
<p><img src="/images/14572898402918.jpg" alt=""></p>
<p>然后注意所用的命令：</p>
<p><img src="/images/14572898614846.jpg" alt=""></p>
<p>这里 <code>-Wl</code> 会告诉链接器，把每个逗号替换成空格。</p>
<p><code>--wrap,malloc</code> 这个参数会进行特殊方式的引用</p>
<ul>
<li>对 <code>malloc</code> 的引用会被解析为 <code>__wrap_malloc</code></li>
<li>对 <code>__real_malloc</code> 的引用会被解析为 <code>malloc</code></li>
</ul>
<h3 id="Load/Run-time_Interpositioning"><a href="#Load/Run-time_Interpositioning" class="headerlink" title="Load/Run-time Interpositioning"></a>Load/Run-time Interpositioning</h3><p>我们同样是对两个函数进行包装：</p>
<p><img src="/images/14572900345456.jpg" alt=""></p>
<p><img src="/images/14572900442044.jpg" alt=""></p>
<p>然后使用以下命令：</p>
<p><img src="/images/14572900675087.jpg" alt=""></p>
<p>这里的 <code>LD_PRELOAD</code> 环境变量会告诉动态链接器先在 <code>mymalloc.so</code> 中寻找所需的引用，就完成了 interpositioning 的效果。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一课我们要接触一个新概念：Linking，简单来说就是计算机如何让不同的代码协同工作的方式。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="链接" scheme="http://wdxtub.com/tags/%E9%93%BE%E6%8E%A5/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Programming iOS9 学习笔记 12 - Controls and Other Views]]></title>
    <link href="http://wdxtub.com/2016/03/06/programming-ios9-translation-12/"/>
    <id>http://wdxtub.com/2016/03/06/programming-ios9-translation-12/</id>
    <published>2016-03-06T12:39:13.000Z</published>
    <updated>2016-03-06T12:46:33.000Z</updated>
    <content type="html"><![CDATA[<p>这一章主要包含前面没有提到过的 <code>UIView</code> 的子类（由 UIKit 提供）</p>
<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<p>这一章主要包含前面没有提到过的 <code>UIView</code> 的子类（由 UIKit 提供）</p>]]>
    
    </summary>
    
      <category term="Control" scheme="http://wdxtub.com/tags/Control/"/>
    
      <category term="iOS9" scheme="http://wdxtub.com/tags/iOS9/"/>
    
      <category term="学习" scheme="http://wdxtub.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://wdxtub.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Programming iOS9 学习笔记 11 - Web Views]]></title>
    <link href="http://wdxtub.com/2016/03/06/programming-ios9-translation-11/"/>
    <id>http://wdxtub.com/2016/03/06/programming-ios9-translation-11/</id>
    <published>2016-03-06T11:12:42.000Z</published>
    <updated>2016-03-06T12:38:58.000Z</updated>
    <content type="html"><![CDATA[<p>Web view 实际是一个浏览器，知道如何从网络上获取资源，比如说渲染 HTML/CSS/JavaScript。不仅可以用于展示网络内容，而且还有一个强大的，可以用来布局、显示动画和多媒体的引擎。</p>
<a id="more"></a>
<hr>
<p>Web view 甚至还知道如何去显示 PDF/RTF/DOC/Pages 文件。</p>
<p><img src="/images/14572631505893.jpg" alt=""></p>
<p>Web view 中的资源加载是异步的，有一个另外的线程来完成这个工作，也就是说加载的时候用户仍然可以进行各种操作和访问。</p>
<p><img src="/images/14572632324008.jpg" alt=""></p>
<p>在 iOS 9 中，实际上有三类 web view 对象：</p>
<p><img src="/images/14572632568030.jpg" alt=""></p>
<p>这里主要讨论 <code>WKWebView</code> 和 <code>SFSafariViewController</code>。</p>
<p><img src="/images/14572633254117.jpg" alt=""></p>
<h2 id="WKWebView"><a href="#WKWebView" class="headerlink" title="WKWebView"></a>WKWebView</h2><p><code>WKWebView</code> 是 WebKit 框架的一部分，使用之前需要 <code>import WebKit</code> 并且在代码中创建 web view，比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> config = <span class="type">WKWebViewConfiguration</span>()</span><br><span class="line"><span class="comment">// .... 各种配置</span></span><br><span class="line"><span class="keyword">let</span> wv = <span class="type">WKWebView</span>(frame: <span class="type">CGRectZero</span>, configuration:config)</span><br></pre></td></tr></table></figure>
<p>当然也可以直接使用默认配置初始化，之后再进行修改，如</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wv = <span class="type">WKWebView</span>(frame: <span class="type">CGRectZero</span>)</span><br><span class="line"><span class="comment">// ... 各种配置</span></span><br></pre></td></tr></table></figure>
<p>无论用哪种方法，最好在开始载入之前就完成配置，因为不同的配置可能会导致渲染得到的页面不一样，比较常见的配置有：</p>
<p><img src="/images/14572640710901.jpg" alt=""></p>
<p><img src="/images/14572640995408.jpg" alt=""></p>
<p>也可以创建自定义的内容放到界面上，如：</p>
<p><img src="/images/14572641374200.jpg" alt=""></p>
<p><code>WKWebView</code> 并不是一个 scroll view，但是拥有一个 scroll view。</p>
<p>有下面四种方式可以让 <code>WKWebView</code> 显示内容：</p>
<p><img src="/images/14572642956567.jpg" alt=""></p>
<p><img src="/images/14572643064428.jpg" alt=""></p>
<p>以上四个方法都会返回 <code>WKNavigation</code> 对象</p>
<p>我们可以通过 <code>WKWebView</code> 的属性来跟踪其状态，比如：</p>
<ul>
<li><code>loading</code></li>
<li><code>estimatedProgress</code></li>
<li><code>URL</code></li>
<li><code>title</code></li>
</ul>
<p>我们可以通过这些属性来做一些操作，比如说在载入的时候在页面中间放一个进度指示器，并且在载入完成之后隐藏。具体代码如下</p>
<p><img src="/images/14572644352049.jpg" alt=""></p>
<p>我们可以通过 <code>backForwardList</code> 来进行前进和后退的操作，这是一个 <code>WKBackForwardList</code> 并且有以下属性</p>
<ul>
<li><code>currentItem</code></li>
<li><code>backItem</code></li>
<li><code>forwardItem</code></li>
<li><code>itemAtIndex</code></li>
</ul>
<p>列表中的每个项目都是 <code>WKBackForwardItem</code>，包含 <code>URL</code> 和 <code>title</code>。然后就可以调用 <code>goBack</code>, <code>goForward</code> 和 <code>goToBackForwardListItem:</code> 方法来进行导航。当然，也可以通过设定 <code>canGoBack</code> 和 <code>canGoForward</code> 来控制是否能够后退前进。</p>
<p>还有一个可以设置的属性 <code>allowsBackForwardNavigationGestures</code>，用来控制是否能够以手势返回，默认是 false，如果设置为 true，则在滑动边缘的时候能够返回。</p>
<p>通过设置 <code>WKWebView</code> 的 <code>navigationDelegate</code> 可以控制具体的导航行为，例如：</p>
<p><img src="/images/14572672880968.jpg" alt=""></p>
<p><img src="/images/14572672999616.jpg" alt=""></p>
<p>然后还有一些代理方法会通知目前的状态：</p>
<p><img src="/images/14572673546176.jpg" alt=""></p>
<p>如果想要给 <code>WKWebView</code> 中的网页发消息，可以调用 <code>evaluateJavaScript:completionHandler:</code> 方法，例子如下；</p>
<p><img src="/images/14572674300371.jpg" alt=""></p>
<p><img src="/images/14572674428385.jpg" alt=""></p>
<p>当然也可以反向来进行操作，比方说把页面的某些元素与按钮绑定，这里不深入。</p>
<p>最后需要注意的是，<code>WKWebView</code> 是不能在 nib 中初始化的（控件里的是 <code>UIWebView</code>）。并且在 iOS8 中，指向本地文件的链接无法在 <code>WKWebView</code> 中使用（iOS9 中已修复，但是考虑兼容性，只能使用 UIWebView）</p>
<p>另外一个问题是 <code>WKWebView</code> 不会自动参与到任何视图控制器的状态中（也就是无法保存和恢复），如果是显示本地内容的话可以人为进行保存恢复，这里不赘述</p>
<h2 id="Safari_View_Controller"><a href="#Safari_View_Controller" class="headerlink" title="Safari View Controller"></a>Safari View Controller</h2><p>简单来说，就是在你的应用中开一个单独的 safari 线程（提供比较完整的功能）。根据苹果的建议，如果是要显示内部的 HTML 内容，用 <code>WKWebView</code>，如果是访问网络，用 Safari view controller，这样可以省去很多麻烦。</p>
<p>使用需要 <code>import SafariServices</code>，如</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> svc = <span class="type">SFSafariViewController</span>(<span class="type">URL</span>: url)</span><br><span class="line"><span class="keyword">self</span>.presentViewController(svc, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/14572679027545.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Web view 实际是一个浏览器，知道如何从网络上获取资源，比如说渲染 HTML/CSS/JavaScript。不仅可以用于展示网络内容，而且还有一个强大的，可以用来布局、显示动画和多媒体的引擎。</p>]]>
    
    </summary>
    
      <category term="Webview" scheme="http://wdxtub.com/tags/Webview/"/>
    
      <category term="iOS9" scheme="http://wdxtub.com/tags/iOS9/"/>
    
      <category term="学习" scheme="http://wdxtub.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://wdxtub.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
