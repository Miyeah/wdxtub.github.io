<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-04-07T20:24:36.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 24 课 Synchronization - Advanced]]></title>
    <link href="http://wdxtub.com/2016/04/07/csapp-24/"/>
    <id>http://wdxtub.com/2016/04/07/csapp-24/</id>
    <published>2016-04-07T15:30:39.000Z</published>
    <updated>2016-04-07T20:24:36.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们通过『生产者-消费者问题』以及『读者-写者问题』来更深入理解同步机制。</p>
<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们通过『生产者-消费者问题』以及『读者-写者问题』来更深入理解同步机制。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="同步" scheme="http://wdxtub.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 23 课 Synchronization - Basics]]></title>
    <link href="http://wdxtub.com/2016/04/07/csapp-23/"/>
    <id>http://wdxtub.com/2016/04/07/csapp-23/</id>
    <published>2016-04-07T15:30:32.000Z</published>
    <updated>2016-04-07T20:19:11.000Z</updated>
    <content type="html"><![CDATA[<p>并行编程中最重要的问题就是同步，这节课我们来了解同步相关的基础知识</p>
<a id="more"></a>
<hr>
<h2 id="u5171_u4EAB_u53D8_u91CF"><a href="#u5171_u4EAB_u53D8_u91CF" class="headerlink" title="共享变量"></a>共享变量</h2><p>在介绍同步之前，我们需要弄清楚一个定义，什么是 Shared variable（共享变量）？</p>
<blockquote>
<p>A variable <code>x</code> is <em>shared</em> if and only if multiple threads reference some instance of <code>x</code></p>
</blockquote>
<p>另外一个需要注意的是线程的内存模型，因为概念上的模型和实际的模型有一些差异，非常容易导致错误。</p>
<p>在概念上的模型中：</p>
<ul>
<li>多个线程在一个单独进程的上下文中运行</li>
<li>每个线程有单独的线程上下文（线程 ID，栈，栈指针，PC，条件码，GP 寄存器）</li>
<li>所有的线程共享剩下的进程上下文<ul>
<li>Code, data, heap, and shared library segments of the process virtual address space</li>
<li>Open files and installed handlers</li>
</ul>
</li>
</ul>
<p>在实际的模型中，寄存器的值虽然是隔离且被保护的，但是在栈中的值并不是这样的（其他线程也可以访问）。</p>
<p>我们来看一个简单的例子：</p>
<p><img src="/images/14600480676890.jpg" alt="Example Program to Illustrate Sharing"></p>
<p>这里有几个不同类型的变量，我们一一来看一下：</p>
<ul>
<li>全局变量：在函数外声明的变量<ul>
<li>虚拟内存中有全局唯一的一份实例</li>
</ul>
</li>
<li>局部变量：在函数内声明，且没有用 static 关键字<ul>
<li>每个线程的栈中都保存着对应线程的局部变量</li>
</ul>
</li>
<li>局部静态变量：在函数内用 static 关键字声明的变量<ul>
<li>虚拟内存中有全局唯一的一份实例</li>
</ul>
</li>
</ul>
<p>具体分析下上面例子中的变量，有：</p>
<p><img src="/images/14600483444019.jpg" alt="Mapping Variable Instances to Memory"></p>
<p>具体来分析下，一个变量只有在被多个线程引用的时候才算是共享，在这个例子中，共享变量有 <code>ptr</code>, <code>cnt</code> 和 <code>msgs</code>；非共享变量有 <code>i</code> 和 <code>myid</code>。</p>
<p><img src="/images/14600486014966.jpg" alt="Shared Vairable Analysis"></p>
<p>共享变量看起来不难，但是会导致一个并行编程中最重要的问题——同步问题。</p>
<h2 id="Critical_Section"><a href="#Critical_Section" class="headerlink" title="Critical Section"></a>Critical Section</h2><p>我们直接来看例子</p>
<p><img src="/images/14600488439280.jpg" alt="Improper Synchronization"></p>
<p>为什么运行的时候，会出现不一样的结果呢？我们把操作 <code>cnt</code> 的部分抽出来单独看一看：</p>
<p><img src="/images/14600574108297.jpg" alt="Assembly Code for Counter Loop"></p>
<p>这里有一点需要注意，<code>cnt</code> 使用了 <code>volatile</code> 关键字声明，意思是不要在寄存器中保存值，无论是读取还是写入，都要对内存操作（还记得 write-through 吗？）。这里把具体的步骤分成 5 步：HLUST，尤其要注意的 LUS 这三个操作，后面会继续说。</p>
<p>我们先来看看没有问题的情况：</p>
<p><img src="/images/14600579848706.jpg" alt=""></p>
<p>这里我们可以看到，有颜色的指令连在一起，所以没有问题。但是一旦交叉，就有问题了，如：</p>
<p><img src="/images/14600580383523.jpg" alt=""></p>
<h2 id="Progress_Graph__26amp_3B_Trajectory"><a href="#Progress_Graph__26amp_3B_Trajectory" class="headerlink" title="Progress Graph &amp; Trajectory"></a>Progress Graph &amp; Trajectory</h2><p>为了描述上面这种情况，我们可以用 Progress Graph 来辅助，比如：</p>
<p><img src="/images/14600581230106.jpg" alt="Progress Graph"></p>
<p>不同的轴代表在某线程中的指令执行顺序，每个点对应一个可能的执行状态，比如说图中的红点，表示线程 1 执行完了 L1，而线程 2 执行完了 S2。</p>
<p>Trajectory 的概念也很好理解，即可行的执行顺序，如下图：</p>
<p><img src="/images/14600582550787.jpg" alt="Trajectory"></p>
<p>我们把 critical section 的边界画出来，就可以判断不同的 trajectory 是否是安全的了：</p>
<p><img src="/images/14600583380649.jpg" alt=""></p>
<p>怎么样保证我们的执行不会走到不安全的区域里呢？有几种方法，这里我们只介绍 Semaphores。下面是比较常用的：</p>
<ul>
<li>Semaphores - Edsger Dijkstra</li>
<li>Mutex &amp; condition variables - Pthreads</li>
<li>Monitors - Java</li>
</ul>
<h2 id="Semaphores"><a href="#Semaphores" class="headerlink" title="Semaphores"></a>Semaphores</h2><p>先看定义</p>
<blockquote>
<p>Semaphore: non-negative global integer synchronization vairable. Manipulated by P and V operations.</p>
</blockquote>
<p>具体的操作为：</p>
<p><img src="/images/14600591923220.jpg" alt=""></p>
<p>根据这样的设计，我们可以知道作为 Semaphore 变量其值一定是非负的。另外样例代码中已经封装了 Pthreads 的函数，如下：</p>
<p><img src="/images/14600599945369.jpg" alt="C Semaphore Operations"></p>
<p>用法也很简单，在进入 critical section 之前，用 P 操作锁住，操作完成之后，用 V 才做释放。一些术语为：</p>
<p><img src="/images/14600600984591.jpg" alt="Terminology"></p>
<p>就可以用 Semaphore 来保证前面的程序不会算错数了，但是因为要同步的缘故，速度会慢</p>
<p><img src="/images/14600602184868.jpg" alt="Proper Synchronization"></p>
<p>具体的机制就是给不安全的区域上了个『锁』：</p>
<p><img src="/images/14600602784245.jpg" alt="Why Mutexes Work"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>总结一下，在使用线程时，程序员脑中需要又一个清晰的分享变量的概念，共享变量需要互斥访问，而 Semaphores 是一个基础的机制。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>并行编程中最重要的问题就是同步，这节课我们来了解同步相关的基础知识</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="同步" scheme="http://wdxtub.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 22 课 Concurrent Programming]]></title>
    <link href="http://wdxtub.com/2016/04/06/csapp-22/"/>
    <id>http://wdxtub.com/2016/04/06/csapp-22/</id>
    <published>2016-04-07T02:16:36.000Z</published>
    <updated>2016-04-07T13:12:00.000Z</updated>
    <content type="html"><![CDATA[<p>如果想要充分利用硬件资源，就要尽可能让计算机同时处理多项事务，具体是怎么实现的？又哪些基本的策略？这节课会一一解答。</p>
<a id="more"></a>
<hr>
<p>首先一定要清楚地意识到：『并行编程不简单』！最主要的原因恐怕就是我们自己的大脑，人脑实际上是一个非常精妙的系统，所采取的并行策略是一明一暗两条线，但是对于明线来说，是线性的，于是就和计算机中并行的概念冲突了。另外时间这个概念也是线性的，这就导致了想要处理好并行程序可能出现的各种问题几乎是不可能的（或者常常要出错）。</p>
<p>常见的错误有仨：竞争条件、死锁和活锁，具体如下：</p>
<p><img src="/images/14599962597558.jpg" alt="Classical problem classes"></p>
<h2 id="u670D_u52A1_u5668_u7684_u4F8B_u5B50"><a href="#u670D_u52A1_u5668_u7684_u4F8B_u5B50" class="headerlink" title="服务器的例子"></a>服务器的例子</h2><p>我们前面实现的服务器，一次只能处理一个请求，只有当前的请求处理完了，才能继续处理下一个。</p>
<p><img src="/images/14599976220466.jpg" alt=""></p>
<p>这里具体讲解一下：Client 1 向 Server 发送连接请求(connect)，Server 接受(accept)之后开始等待 Client 1 发送请求（也就是开始 read），这之后 Client 1 发送具体的内容(write)后转为等待响应(call read)，Server 的 read 接收到了内容之后，发送响应(write) 后仅需进入等待(read)，而 Client 1 接收到了响应(ret read)，最后根据用户指令退出(close)。</p>
<p>而只有当 Client 1 断开之后，Server 才会处理 Client 2 的请求，从图中也可以看到这一点。具体是在哪里等待呢？因为 TCP 会缓存，所以实际上 Client 2 在 <code>ret read</code> 之前进行等待，如：</p>
<p><img src="/images/14599992829071.jpg" alt="Where Does Second Client Block"></p>
<p>为了解决这个问题，我们可以使用并行的策略，同时处理不同客户端发来的请求。</p>
<h2 id="u5E76_u884C_u65B9_u6CD5"><a href="#u5E76_u884C_u65B9_u6CD5" class="headerlink" title="并行方法"></a>并行方法</h2><p>总体来说，根据系统机制的层级和实现方式，有下面三大类方法：</p>
<ol>
<li>基于进程<ul>
<li>内核自动管理多个逻辑流</li>
<li>每个进程有其私有的地址空间（也就是说进程切换的时候需要保存和载入数据）</li>
</ul>
</li>
<li>基于事件<ul>
<li>由程序员手动控制多个逻辑流</li>
<li>所有的逻辑流共享同一个地址空间</li>
<li>这个技术称为 I/O multiplexing</li>
</ul>
</li>
<li>基于线程<ul>
<li>内核自动管理多个逻辑流</li>
<li>每个线程共享地址空间</li>
<li>属于基于进程和基于事件的混合体</li>
</ul>
</li>
</ol>
<h3 id="u57FA_u4E8E_u8FDB_u7A0B"><a href="#u57FA_u4E8E_u8FDB_u7A0B" class="headerlink" title="基于进程"></a>基于进程</h3><p>为每个客户端分离出一个单独的进程，是建立了连接之后才开始并行，连接的建立还是串行的。</p>
<p><img src="/images/14600273587521.jpg" alt="Spawn separate process for each client"></p>
<p>具体的代码为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(-<span class="number">1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// Reap all zombie children</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_storage clientaddr;</span><br><span class="line">    </span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            Close(listenfd); <span class="comment">// Child closes its listening socket</span></span><br><span class="line">            echo(connfd); <span class="comment">// Child services client</span></span><br><span class="line">            Close(connfd); <span class="comment">// Child closes connection with client</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// Child exits</span></span><br><span class="line">        &#125;</span><br><span class="line">        Close(connfd); <span class="comment">// Parent closes connected socket (important!)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键步骤(accept)的描述为</p>
<p><img src="/images/14600278440053.jpg" alt="Concurrent Server: `accept` Illustrated"></p>
<p>执行模型为</p>
<p><img src="/images/14600278862489.jpg" alt="Process-based Server Execution Model"></p>
<ul>
<li>每个客户端由独立子进程处理<ul>
<li>必须回收僵尸进程，来避免严重的内存泄露</li>
</ul>
</li>
<li>不同进程之间不共享数据</li>
<li>父进程和子进程都有 <code>listenfd</code> 和 <code>connfd</code>，所以在父进程中需要关闭 <code>connfd</code>，在子进程中需要关闭 <code>listenfd</code><ul>
<li>内核会保存每个 socket 的引用计数，在 fork 之后 <code>refcnt(connfd) = 2</code>，所以在父进程需要关闭 connfd，这样在子进程结束后引用计数才会为零</li>
</ul>
</li>
</ul>
<blockquote>
<p>优劣</p>
</blockquote>
<p><img src="/images/14600282200028.jpg" alt="Pros and Cons of Process-based Servers"></p>
<h3 id="u57FA_u4E8E_u4E8B_u4EF6"><a href="#u57FA_u4E8E_u4E8B_u4EF6" class="headerlink" title="基于事件"></a>基于事件</h3><p>服务器会维护一个 connection 数组，包含若干 <code>connfd</code>，具体的过程为：</p>
<p><img src="/images/14600283355967.jpg" alt=""></p>
<p>这里一个很重要的技术是 I/O Multiplexing，感兴趣的同学可以查阅书中对应章节（具体内容会在习题课中介绍）。</p>
<blockquote>
<p>优劣</p>
</blockquote>
<p><img src="/images/14600283984253.jpg" alt="Pros and Cons of Event-based Servers"></p>
<h3 id="u57FA_u4E8E_u7EBF_u7A0B"><a href="#u57FA_u4E8E_u7EBF_u7A0B" class="headerlink" title="基于线程"></a>基于线程</h3><p>和基于进程的方法非常相似，唯一的区别是这里用线程。进程其实是比较『重』的，一个进程包括：</p>
<p><img src="/images/14600286544772.jpg" alt="Traditional View of a Process"></p>
<p>当然，我们也可以从线程的角度来描述进程：</p>
<p><img src="/images/14600286291425.jpg" alt="Alternate View of a Process"></p>
<p>这两个角度的区别在于，通过线程视角观察，把单独的可执行部分抽离出来了，于是当一个进程有多个线程的时候，看起来像这样：</p>
<p><img src="/images/14600287485774.jpg" alt="A Process With Multiple Threads"></p>
<p>每个线程有自己的线程 id，有自己的逻辑控制流，也有自己的用来保存局部变量的栈（其他线程可以修改）但是会共享所有的代码、数据以及内核上下文。</p>
<p>和进程不同的是，线程没有一个明确的树状结构（使用 <code>fork</code> 是有明确父进程子进程区分的），看起来就像下面这样：</p>
<p><img src="/images/14600293169627.jpg" alt="Logical View of Threads"></p>
<p>和进程中『并行』的概念一样，如果两个线程的控制流在时间上有『重叠』（或者说有交叉），那么就是并行的，例如：</p>
<p><img src="/images/14600295257230.jpg" alt="Concurrent Threads"></p>
<p>单核与多核处理器也有一点点不同：</p>
<p><img src="/images/14600297006546.jpg" alt="Concurrent Thread Execution"></p>
<p>进程和线程的差别已经被说了太多次，这里简单提一下。相同点在于，它们都有自己的逻辑控制流，可以并行，都需要进行上下文切换。不同点在于，线程共享代码和数据（进程通常不会），线程开销比较小（创建和回收）</p>
<h2 id="Posix_Threads__28Pthreads_29_Interface"><a href="#Posix_Threads__28Pthreads_29_Interface" class="headerlink" title="Posix Threads (Pthreads) Interface"></a>Posix Threads (Pthreads) Interface</h2><p>Pthreads 是一个线程库，基本上只要是 C 程序能跑的平台，都会支持这个标准，具体如下；</p>
<p><img src="/images/14600332547386.jpg" alt=""></p>
<p>一个例子</p>
<p><img src="/images/14600332776267.jpg" alt="The Pthreads &quot;hello, world&quot; Program"></p>
<p>这个程序的流程描述为</p>
<p><img src="/images/14600338560676.jpg" alt="Execution of Thread &quot;hello, world&quot;"></p>
<p>我们用线程的方式重写一次之前的 Echo Server</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread routine</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connf = *((<span class="keyword">int</span> *)vargp);</span><br><span class="line">    <span class="comment">// detach 之后不用显式 join，会在执行完毕后自动回收</span></span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    Free(vargp);</span><br><span class="line">    echo(connfd);</span><br><span class="line">    <span class="comment">// 一定要记得关闭！</span></span><br><span class="line">    Close(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, *connfdp;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_storage clientaddr;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    </span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        <span class="comment">// 这里使用新分配的 connected descriptor 来避免竞争条件</span></span><br><span class="line">        connfdp = Malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        *connfdp = Accept(listenfd, (SA *) &amp; clientaddr, &amp;clientlen);</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, connfdp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的执行模型为：</p>
<p><img src="/images/14600343334886.jpg" alt="Thread-based Server Execution Model"></p>
<p>在这个模型中，每个客户端由单独的线程进行处理，这些线程除了线程 id 之外，共享所有的进程状态（但是每个线程有自己的局部变量栈）。需要注意的有：</p>
<p><img src="/images/14600346185454.jpg" alt="Issues With Thread-Based Servers"></p>
<p>说了这么多，其实就是同步问题（后面两节课会专门介绍）</p>
<blockquote>
<p>优劣</p>
</blockquote>
<p><img src="/images/14600346688214.jpg" alt=""></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这里我们了解了三大类方法的特点，具体的会在习题课结合例子说明，这里是一个简单的总结</p>
<p><img src="/images/14600347193577.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果想要充分利用硬件资源，就要尽可能让计算机同时处理多项事务，具体是怎么实现的？又哪些基本的策略？这节课会一一解答。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="并行" scheme="http://wdxtub.com/tags/%E5%B9%B6%E8%A1%8C/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 21 课 Network Programming II]]></title>
    <link href="http://wdxtub.com/2016/04/06/csapp-21/"/>
    <id>http://wdxtub.com/2016/04/06/csapp-21/</id>
    <published>2016-04-06T11:34:02.000Z</published>
    <updated>2016-04-07T00:44:41.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们来学习如何编写 web 服务器！</p>
<a id="more"></a>
<hr>
<h2 id="u67B6_u6784_u603B_u89C8"><a href="#u67B6_u6784_u603B_u89C8" class="headerlink" title="架构总览"></a>架构总览</h2><p>写服务器，最重要的就是理清思路，上节课我们介绍了诸多概念，尤其是最后提到的 <code>getaddrinfo</code> 和 <code>getnameinfo</code>，都是我们在搭建过程中必不可少的工具。这里先借下图来介绍具体的实现思路：</p>
<p><img src="/images/14599728555354.jpg" alt=""></p>
<p>整个的工作流程有 5 步：</p>
<ol>
<li>开启服务器（<code>open_listenfd</code> 函数，做好接收请求的准备）<ul>
<li><code>getaddrinfo</code>: 设置服务器的相关信息，具体可以参见 图1&amp;2</li>
<li><code>socket</code>: 创建 socket descriptor，也就是之后用来读写的 file descriptor<ul>
<li><code>int socket(int domain, int type, int protocol)</code></li>
<li>例如 <code>int clientfd = socket(AF_INET, SOCK_STREAM, 0);</code></li>
<li><code>AF_INET</code> 表示在使用 32 位 IPv4 地址</li>
<li><code>SOCK_STREAM</code> 表示这个 socket 将是 connection 的 endpoint</li>
<li>前面这种写法是协议相关的，建议使用 <code>getaddrinfo</code> 生成的参数来进行配置，这样就是协议无关的了</li>
</ul>
</li>
<li><code>bind</code>: 请求 kernel 把 socket address 和 socket descriptor 绑定<ul>
<li><code>int bind(int sockfd, SA *addr, socklen_t addrlen);</code></li>
<li>The process can read bytes that arrive on the connection whose endpoint is <code>addr</code> by reading from descriptor <code>sockfd</code></li>
<li>Similarly, writes to <code>sockfd</code> are transferred along connection whose endpoint is <code>addr</code></li>
<li>最好是用 <code>getaddrinfo</code> 生成的参数作为 <code>addr</code> 和 <code>addrlen</code> </li>
</ul>
</li>
<li><code>listen</code>: 默认来说，我们从 <code>socket</code> 函数中得到的 descriptor 默认是 active socket（也就是客户端的连接），调用 <code>listen</code> 函数告诉 kernel 这个 socket 是被服务器使用的<ul>
<li><code>int listen(int sockfd, int backlog);</code></li>
<li>把 <code>sockfd</code> 从 active socket 转换成 listening socket，用来接收客户端的请求</li>
<li><code>backlog</code> 的数值表示 kernel 在接收多少个请求之后（队列缓存起来）开始拒绝请求</li>
</ul>
</li>
<li>[*]<code>accept</code>: 调用 <code>accept</code> 函数，开始等待客户端请求<ul>
<li><code>int accept(int listenfd, SA *addr, int *addrlen);</code></li>
<li>等待绑定到 <code>listenfd</code> 的连接接收到请求，然后把客户端的 socket address 写入到 <code>addr</code>，大小写入到 <code>addrlen</code></li>
<li>返回一个 connected descriptor 用来进行信息传输（类似 Unix I/O）</li>
<li>具体的过程可以参考 图3</li>
</ul>
</li>
</ul>
</li>
<li>开启客户端（<code>open_clientfd</code> 函数，设定访问地址，尝试连接）<ul>
<li><code>getaddrinfo</code>: 设置客户端的相关信息，具体可以参见 图1&amp;2</li>
<li><code>socket</code>: 创建 socket descriptor，也就是之后用来读写的 file descriptor</li>
<li><code>connect</code>: 客户端调用 <code>connect</code> 来建立和服务器的连接<ul>
<li><code>int connect(int clientfd, SA *addr, socklen_t addrlen);</code></li>
<li>尝试与在 socker address <code>addr</code> 的服务器建立连接</li>
<li>如果成功 <code>clientfd</code> 可以进行读写</li>
<li>connection 由 socket 对描述 <code>(x:y, addr.sin_addr:addr.sin_port)</code></li>
<li><code>x</code> 是客户端地址，<code>y</code> 是客户端临时端口，后面的两个是服务器的地址和端口</li>
<li>最好是用 <code>getaddrinfo</code> 生成的参数作为 <code>addr</code> 和 <code>addrlen</code> </li>
</ul>
</li>
</ul>
</li>
<li>交换数据（主要是一个流程循环，客户端向服务器写入，就是发送请求；服务器向客户端写入，就是发送响应）<ul>
<li>[Client]<code>rio_writen</code>: </li>
<li>[Client]<code>rio_readlineb</code>: </li>
<li>[Server]<code>rio_readlineb</code>:</li>
<li>[Server]<code>rio_writen</code>: </li>
</ul>
</li>
<li>关闭客户端（主要是 <code>close</code>）<ul>
<li>[Client]<code>close</code>:</li>
</ul>
</li>
<li>断开客户端（服务接收到客户端发来的 EOF 消息之后，断开已有的和客户端的连接）<ul>
<li>[Server]<code>rio_readlineb</code>:</li>
<li>[Server]<code>close</code>: </li>
</ul>
</li>
</ol>
<p><img src="/images/14599747281009.jpg" alt="图 1 Generic socket address"></p>
<p><img src="/images/14599747501489.jpg" alt="图 2 Socket Address Structures"></p>
<p><img src="/images/14599774536738.jpg" alt="图3 `accept` Illustrated"></p>
<blockquote>
<p>[Client]Connected Descriptor vs. [Server]Listening Descriptors</p>
</blockquote>
<p> 这两个的差别还是需要注意一下：</p>
<p> <img src="/images/14599776259093.jpg" alt=""></p>
<p>之所以要有这样的差别，是因为这样服务器可以同时处理多个请求（只要 fork 即可）</p>
<h2 id="u4EE3_u7801_u8BB2_u89E3"><a href="#u4EE3_u7801_u8BB2_u89E3" class="headerlink" title="代码讲解"></a>代码讲解</h2><blockquote>
<p>[Client] <code>open_clientfd</code></p>
</blockquote>
<p>用来建立和服务器的连接，协议无关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_clientfd</span><span class="params">(<span class="keyword">char</span> *hostname, <span class="keyword">char</span> *port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clientfd;</span><br><span class="line">    <span class="keyword">struct</span> addrinfo hints, *listp, *p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Get a list of potential server address</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">// Open a connection</span></span><br><span class="line">    hints.ai_flags = AI_NUMERICSERV; <span class="comment">// using numeric port arguments</span></span><br><span class="line">    hints.ai_flags |= AI_ADDRCONFIG; <span class="comment">// Recommended for connections</span></span><br><span class="line">    getaddrinfo(hostname, port, &amp;hints, &amp;listp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Walk the list for one that we can successfully connect to</span></span><br><span class="line">    <span class="comment">// 如果全部都失败，才最终返回失败（可能有多个地址）</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">// Create a socket descriptor</span></span><br><span class="line">        <span class="comment">// 这里使用从 getaddrinfo 中得到的参数，实现协议无关</span></span><br><span class="line">        <span class="keyword">if</span> ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</span><br><span class="line">                               p-&gt;ai_protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// Socket failed, try the next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Connect to the server</span></span><br><span class="line">        <span class="comment">// 这里使用从 getaddrinfo 中得到的参数，实现协议无关</span></span><br><span class="line">        <span class="keyword">if</span> (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Success</span></span><br><span class="line">        </span><br><span class="line">        close(clientfd); <span class="comment">// Connect failed, try another</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">// All connections failed</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// The last connect succeeded</span></span><br><span class="line">        <span class="keyword">return</span> clientfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[Server] <code>open_listenfd</code></p>
</blockquote>
<p>创建 listening descriptor，用来接收来自客户端的请求，协议无关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_listenfd</span><span class="params">(<span class="keyword">char</span> *port)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> addrinfo hints, *listp, *p;</span><br><span class="line">    <span class="keyword">int</span> listenfd, optval=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Get a list of potential server addresses</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">// Accept connection</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; <span class="comment">// on any IP address</span></span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV; <span class="comment">// using port number</span></span><br><span class="line">    <span class="comment">// 因为服务器不需要连接，所以原来填写地址的地方直接是 NULL</span></span><br><span class="line">    getaddrinfo(<span class="literal">NULL</span>, port, &amp;hints, &amp;listp); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Walk the list for one that we can successfully connect to</span></span><br><span class="line">    <span class="comment">// 如果全部都失败，才最终返回失败（可能有多个地址）</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">// Create a socket descriptor</span></span><br><span class="line">        <span class="comment">// 这里使用从 getaddrinfo 中得到的参数，实现协议无关</span></span><br><span class="line">        <span class="keyword">if</span> ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</span><br><span class="line">                               p-&gt;ai_protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// Socket failed, try the next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Eliminates "Address already in use" error from bind</span></span><br><span class="line">        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR), </span><br><span class="line">                    (<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;optval, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Bind the descriptor to the address</span></span><br><span class="line">        <span class="keyword">if</span> (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Success</span></span><br><span class="line">        </span><br><span class="line">        close(listenfd); <span class="comment">// Bind failed, try another</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">// No address worked</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Make it a listening socket ready to accept connection requests</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, LISTENQ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(listenfd);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一个简单的 socket 服务器实例</p>
<blockquote>
<p>Echo Client: Main Routine</p>
</blockquote>
<p>这个客户端做得事情很简单，就是把一段用户输入的文字发送到服务器，然后再把从服务器接收到的内容显示到输出中，具体可以参见注释</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// echoclient.c</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clientfd;</span><br><span class="line">    <span class="keyword">char</span> *host, *port, buf[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line">    </span><br><span class="line">    host = argv[<span class="number">1</span>];</span><br><span class="line">    port = argv[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建立连接（前面已经详细介绍）</span></span><br><span class="line">    clientfd = Open_clientfd(host, port);</span><br><span class="line">    Rio_readinitb(&amp;rio, clientfd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (Fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 写入，也就是向服务器发送信息</span></span><br><span class="line">        Rio_writen(clientfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="comment">// 读取，也就是从服务器接收信息</span></span><br><span class="line">        Rio_readlineb(&amp;rio, buf, MAXLINE);</span><br><span class="line">        <span class="comment">// 把从服务器接收的信息显示在输出中</span></span><br><span class="line">        Fputs(buf, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(clientfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative Echo Server: Main Rountine</p>
</blockquote>
<p>服务器做得工作也很简单，接收到从客户端发送的信息，然后返回一个一模一样的。具体参加注释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// echoserveri.c</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_storage clientaddr; <span class="comment">// Enough room for any addr</span></span><br><span class="line">    <span class="keyword">char</span> client_hostname[MAXLINE], client_port[MAXLINE];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启监听端口，注意只开这么一次</span></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要具体的大小</span></span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage); <span class="comment">// Important!</span></span><br><span class="line">        <span class="comment">// 等待连接</span></span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="comment">// 获取客户端相关信息</span></span><br><span class="line">        Getnameinfo((SA *) &amp;clientaddr, clientlen, client_hostname,</span><br><span class="line">                     MAXLINE, client_port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Connected to (%s, %s)\n"</span>, client_hostname, client_port);</span><br><span class="line">        <span class="comment">// 服务器具体完成的工作</span></span><br><span class="line">        echo(coonfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取从客户端传输过来的数据</span></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span>((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server received %d bytes\n"</span>, (<span class="keyword">int</span>)n);</span><br><span class="line">        <span class="comment">// 把从 client 接收到的信息再写回去</span></span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6D4B_u8BD5_u5DE5_u5177"><a href="#u6D4B_u8BD5_u5DE5_u5177" class="headerlink" title="测试工具"></a>测试工具</h2><p>测试的时候，我们可以使用 <code>telnet</code> 应用来测试服务器（只传输 ASCII 字符串的话，命令行工具无法显示图片），例如：</p>
<p>使用方法 <code>$ telnet &lt;host&gt; &lt;portnumber&gt;</code>，例如</p>
<p><img src="/images/14599877200828.jpg" alt="Testing Echo Server with `telnet`"></p>
<h2 id="Web__u670D_u52A1_u5668"><a href="#Web__u670D_u52A1_u5668" class="headerlink" title="Web 服务器"></a>Web 服务器</h2><p>客户端和服务器通过 HyperText Transfer Protocol(HTTP) 协议进行传输，具体的步骤是</p>
<ul>
<li>客户端和服务器建立 TCP 连接</li>
<li>客户端请求内容</li>
<li>服务器响应所请求的内容<ul>
<li>content: a sequence of bytes with an associated MIME (Multipurporse Internet Mail Extensions) types</li>
</ul>
</li>
<li>（最终）客户端和服务器关闭连接</li>
</ul>
<p><img src="/images/14599884494825.jpg" alt="Web Server Basics"></p>
<p>目前的版本是 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html" target="_blank" rel="external">HTTP/1.1 RFC 2616, June, 1999</a></p>
<p>一些 MIME 类型，更详细可见<a href="http://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank" rel="external">这里</a></p>
<ul>
<li><code>text/html</code> HTML document</li>
<li><code>text/plain</code> Unformatted text</li>
<li><code>image/gif</code> Binary image encoded in GIF format</li>
<li><code>image/png</code> Binary image encoded in PNG format</li>
<li><code>imgae/jpeg</code> Binary image encoded in JPEG format</li>
</ul>
<blockquote>
<p>静态内容与动态内容</p>
</blockquote>
<p>这部分比较简单，直接上图</p>
<p><img src="/images/14599890887501.jpg" alt=""></p>
<blockquote>
<p>URL 相关</p>
</blockquote>
<p>这部分比较简单，直接上图</p>
<p><img src="/images/14599891181741.jpg" alt=""></p>
<blockquote>
<p>HTTP Request</p>
</blockquote>
<p>这部分比较简单，直接上图</p>
<p><img src="/images/14599892040565.jpg" alt=""></p>
<blockquote>
<p>HTTP Responses</p>
</blockquote>
<p>这部分比较简单，直接上图</p>
<p><img src="/images/14599892360582.jpg" alt=""></p>
<blockquote>
<p>Example HTTP Transaction</p>
</blockquote>
<p><img src="/images/14599895910357.jpg" alt=""></p>
<p>剩下的概念主要是 CGI 应用，地址中 GET 表达形式，具体会在之后的习题课结合例子进行讲解，这里就不赘述了。不过还是要提一个重要概念：代理</p>
<blockquote>
<p>Proxies</p>
</blockquote>
<p><img src="/images/14599898580384.jpg" alt=""></p>
<p><img src="/images/14599898773522.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们来学习如何编写 web 服务器！</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="网络" scheme="http://wdxtub.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 20 课 Network Programming I]]></title>
    <link href="http://wdxtub.com/2016/04/06/csapp-20/"/>
    <id>http://wdxtub.com/2016/04/06/csapp-20/</id>
    <published>2016-04-06T11:33:58.000Z</published>
    <updated>2016-04-06T15:53:03.000Z</updated>
    <content type="html"><![CDATA[<p>网络已经成为了我们『智能』生活中最重要的一部分，这两节课我们会通过 C API 来了解具体的网络相关编程（用更高层次的封装只会更轻松！）</p>
<a id="more"></a>
<hr>
<h2 id="u7F51_u7EDC_u67B6_u6784"><a href="#u7F51_u7EDC_u67B6_u6784" class="headerlink" title="网络架构"></a>网络架构</h2><p>计算机网络的知识可谓是非常『保值』的，因为这么多基础设备还在运行着，基本机制在短时间内很难改变，关于网络的另一个版本的讲解在<a href="/./2016/02/10/internet-protocol/">这里</a>，我觉得也非常不错，大家感兴趣可以看看。</p>
<p>客户端-服务器模型是网络应用最广泛使用的模型，作为耳熟能详的概念，这里不多提，相信通过下图就能大致明白：</p>
<p><img src="/images/14599482011858.jpg" alt=""></p>
<p>网络相关的处理，都是通过网络适配器来完成的，具体在硬件上为：</p>
<p><img src="/images/14599482515878.jpg" alt="Hardware Organization of a Network Host"></p>
<p>根据应用范围和架构层级，可以分成三个部分：</p>
<ul>
<li>SAN - System Area Network<ul>
<li>Switched Ethernet, Quadrics QSW, …</li>
</ul>
</li>
<li>LAN - Local Area Network<ul>
<li>Ethernet, ..</li>
</ul>
</li>
<li>WAN - Wide Area Network<ul>
<li>High speed point-to-point phone lines</li>
</ul>
</li>
</ul>
<blockquote>
<p>最底层 - Ethernet Segment</p>
</blockquote>
<p>Ethernet segment consists of a collection of <strong>hosts</strong> connected by wires (twisted pairs) to a <strong>hub</strong>.</p>
<p>通常范围是房间或一层楼</p>
<p><img src="/images/14599485111822.jpg" alt="Ethernet Segment"></p>
<ul>
<li>每个 Ethernet 适配器有一个唯一的 48 位的地址（也就是 MAC 地址），例如 <code>00:16:ea:e3:54:e6</code></li>
<li>不同主机间发送的数据称为帧(frame)</li>
<li>Hub 会把每个端口发来的所有数据复制到其他的端口<ul>
<li>所有的主机都可以看到所有的数据（注意安全问题）</li>
</ul>
</li>
</ul>
<blockquote>
<p>下一层 - Bridged Ethernet Segment</p>
</blockquote>
<p><img src="/images/14599487658645.jpg" alt="Bridged Ethernet Segment"></p>
<p>通常范围是一层楼，通过不同的 bridge 来连接不同的 ethernet segment。Bridge 知道从某端口出发可达的主机，并有选择的在端口间复制数据。</p>
<p>为了从概念上简化，我们可以认为，所有的 hub, bridge 可以抽象为一条线，如下图所示：</p>
<p><img src="/images/14599488669806.jpg" alt="Conceptual View of LANs"></p>
<blockquote>
<p>下一层 - internets</p>
</blockquote>
<p>不同的（也许不兼容）的 LAN 可以通过 router 来进行物理上的连接，这样连接起来的网络称为 internet（注意是小写，大写的 Internet 可以认为是最著名的 internet）</p>
<p><img src="/images/14599491906184.jpg" alt="internets"></p>
<blockquote>
<p>internet 的逻辑结构</p>
</blockquote>
<p><img src="/images/14599492763163.jpg" alt="Logical Structure of an internet"></p>
<ul>
<li>Ad hoc interconnection of networks<ul>
<li>没有特定的拓扑结构</li>
<li>不同的 router 和 link 差异可能很大</li>
</ul>
</li>
<li>通过在不同的网络间跳转来传递 packet<ul>
<li>Router 是不同网络间的连接</li>
<li>不同的 packet 可能会走不同的路线</li>
</ul>
</li>
</ul>
<h2 id="u7F51_u7EDC_u534F_u8BAE"><a href="#u7F51_u7EDC_u534F_u8BAE" class="headerlink" title="网络协议"></a>网络协议</h2><p>在不同的 LAN 和 WAN 中传输数据，就要守规矩，这个规矩就是协议。协议负责做的事情有：</p>
<ul>
<li>提供 naming scheme<ul>
<li>定义 host address 格式</li>
<li>每个主机和路由器都至少有一个独立的 internet 地址</li>
</ul>
</li>
<li>提供 delivery mechanism<ul>
<li>定义了标准的传输单元 - packet</li>
<li>Packet 包含 header 和 payload<ul>
<li>header 包括 packet size, source 和 destination address</li>
<li>payload 包括需要传输的数据  </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在这样的协议下，具体的数据传输是：</p>
<p><img src="/images/14599502534733.jpg" alt="Transferring internet Data Via Encapsulation"></p>
<p>PH = Internet packet header, FH = LAN frame header</p>
<blockquote>
<p>Globle IP Internet(upper case)</p>
</blockquote>
<p>Internet 是 internet 最为著名的例子。主要基于 TCP/IP 协议族：</p>
<ul>
<li>IP (Internet Protocal)<ul>
<li>Provides <strong>basic naming scheme</strong> and unreliable <strong>delivery capability</strong> of packets (datagrams) from <strong>host-to-host</strong></li>
</ul>
</li>
<li>UDP (Unreliable Datagram Protocol)<ul>
<li>Uses IP to provide <strong>unreliable</strong> datagram delivery from <strong>process-to-process</strong></li>
</ul>
</li>
<li>TCP (Transmission Control Protocol)<ul>
<li>Uses IP to provide <strong>reliable</strong> byte streams from <strong>process-to-process</strong> over <strong>connections</strong></li>
</ul>
</li>
</ul>
<p>Accessed via a mix of Unix file I/O and functions from <strong>sockets interface</strong>.（很多东西不是很好翻译，用原文比较准确）</p>
<p><img src="/images/14599506938536.jpg" alt="Hardware and Software Organization of an Internet Application"></p>
<h2 id="Internet__u7684_u7A0B_u5E8F_u5458_u89C6_u89D2"><a href="#Internet__u7684_u7A0B_u5E8F_u5458_u89C6_u89D2" class="headerlink" title="Internet 的程序员视角"></a>Internet 的程序员视角</h2><ul>
<li>主机有 32 位的 IP 地址 - 23.235.46.133<ul>
<li>IPv4 - 32 位地址，IPv6 - 128 位地址</li>
</ul>
</li>
<li>IP 地址被映射到域名 - 23.235.46.133 映射到 www.wdxtub.com</li>
<li>不同主机之间的进程，可以通过 connection 来交换数据</li>
</ul>
<blockquote>
<p>IP 地址</p>
</blockquote>
<p>我们会用一个叫做 IP address stuct 的东西来存储，并且 IP 地址是以 network byte order（也就是大端）来进行存储的</p>
<p><img src="/images/14599515895838.jpg" alt="IP Address"></p>
<p>为了方便读，一般用下图的形式来进行表示：</p>
<p><img src="/images/14599516332783.jpg" alt=""></p>
<p>具体的转换可以使用 <code>getaddrinfo</code> 和 <code>getnameinfo</code> 函数</p>
<blockquote>
<p>Internet 域名</p>
</blockquote>
<p><img src="/images/14599516793840.jpg" alt="Internet Domain Names"></p>
<p>这里主要需要了解的就是 Domain Naming System(DNS) 的概念，用来做 IP 地址到域名的映射。具体可以用 <code>nslookup</code> 命令来查看，下面是一些例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">wdxtub.local</span><br><span class="line"></span><br><span class="line">$ nslookup www.wdxtub.com</span><br><span class="line">Server:		<span class="number">8.8</span>.<span class="number">8.8</span></span><br><span class="line">Address:	<span class="number">8.8</span>.<span class="number">8.8</span><span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.wdxtub.com	canonical name = wdxtub.github.io.</span><br><span class="line">wdxtub.github.io	canonical name = github.map.fastly.net.</span><br><span class="line">Name:	github.map.fastly.net</span><br><span class="line">Address: <span class="number">23.235</span>.<span class="number">39.133</span></span><br><span class="line"></span><br><span class="line">$ nslookup www.twitter.com</span><br><span class="line">Server:		<span class="number">8.8</span>.<span class="number">8.8</span></span><br><span class="line">Address:	<span class="number">8.8</span>.<span class="number">8.8</span><span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.twitter.com	canonical name = twitter.com.</span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: <span class="number">199.16</span>.<span class="number">156.6</span></span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: <span class="number">199.16</span>.<span class="number">156.198</span></span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: <span class="number">199.16</span>.<span class="number">156.230</span></span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: <span class="number">199.16</span>.<span class="number">156.70</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Internet Connections</p>
</blockquote>
<p>客户端和服务器通过 connection 来发送字节流，特点是：</p>
<ul>
<li>Point-to-point: 连接一对进程</li>
<li>Full-duplex: 数据同时可以在两个方向流动</li>
<li>Reliable: 字节的发送的顺序和收到的一致</li>
</ul>
<p>Socket 则可以认为是 connection 的 endpoint，socket 地址是一个 <code>IPaddress:port</code> 对。</p>
<p>Port（端口）是一个 16 位的整数，用来标识不同的进程：</p>
<ul>
<li>Ephemeral port: Assigned automatically by client kernel when client makes a connection request</li>
<li>Well-known port: Associated with some <strong>service</strong> provided by a server（在 linux 系统上可以在 <code>/etc/services</code> 中查看具体的信息）<ul>
<li>echo server: 7/echo</li>
<li>ssh server: 22/ssh</li>
<li>email server: 25/smtp</li>
<li>web servers: 80/http</li>
</ul>
</li>
</ul>
<blockquote>
<p>Connection 详解</p>
</blockquote>
<p>A connection is uniquely identified by the socket addresses of its endpoints(socket pair - cliaddr:cliport, servaddr: servport)</p>
<p><img src="/images/14599531325600.jpg" alt="Anatomy of a Connection"></p>
<p>利用不同的端口来连接不同的服务：</p>
<p><img src="/images/14599534610996.jpg" alt="Using Ports to Identify Services"></p>
<blockquote>
<p>Socket Interface</p>
</blockquote>
<p>一系列系统级的函数，和 Unix I/O 配合构造网络应用（在所有的现代操作系统上都可用）。</p>
<p>对于 kernel 来说，socket 是 endpoint of communication；对于应用程序来说，socket 是 file descriptor，用来读写（回忆一下，STDIN 和 STDOUT 也是 file descriptor）。客户端和服务器通过读写对应的 socket descriptor 来进行。</p>
<p><img src="/images/14599559864957.jpg" alt=""></p>
<p>The main distinction between regular file I/O and socket I/O is how the application “opens” the socket descriptors.</p>
<blockquote>
<p>Generic socket address</p>
</blockquote>
<p><img src="/images/14599561357752.jpg" alt=""></p>
<blockquote>
<p>Internet-specific socket address</p>
</blockquote>
<p>实际上占用同样的空间，但是有更详细的信息</p>
<p><img src="/images/14599561803255.jpg" alt=""></p>
<p>总体的流程为：</p>
<p><img src="/images/14599565974716.jpg" alt=""></p>
<h2 id="u5E38_u7528_u51FD_u6570"><a href="#u5E38_u7528_u51FD_u6570" class="headerlink" title="常用函数"></a>常用函数</h2><p>接下来直接用 PPT 介绍两个重要函数 <code>getaddrinfo</code> 和 <code>getnameinfo</code></p>
<blockquote>
<p>getaddrinfo</p>
</blockquote>
<p>用来把 hostname, host address, port, service name 的字符串表示转换成 socket address 结构。</p>
<p><img src="/images/14599569037369.jpg" alt=""></p>
<p>函数原型为：</p>
<p><img src="/images/14599569254580.jpg" alt=""></p>
<p>这里具体说一下 <code>result</code> 这个链表：</p>
<p><img src="/images/14599569748746.jpg" alt="Linked List Returned by `getaddrinfo`"></p>
<p> 客户端需要遍历这个列表，按顺序访问每个 socket address，直到 <code>socket</code> 和 <code>connect</code> 函数调用成功。</p>
<p> 服务器需要遍历这个列表，直到 <code>socket</code> 和  <code>bind</code> 函数调用成功</p>
<p>每个 <code>addrinfo</code> 结构体为</p>
<p><img src="/images/14599573080061.jpg" alt="addrinfo Struct"></p>
<blockquote>
<p>getnameinfo</p>
</blockquote>
<p>刚好和 <code>getaddrinfo</code> 相反，把 socket address 转换成对应的字符串信息，函数原型为</p>
<p><img src="/images/14599575876044.jpg" alt=""></p>
<p>举个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hostinfo.c</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> addrinfo *p, *listp, hints;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> rc, flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Get a list of addrinfo records</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_family = AF_INET; <span class="comment">// IPv4 only</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">// Connections only</span></span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(argv[<span class="number">1</span>], <span class="literal">NULL</span>, &amp;hints, &amp;listp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"getaddrinfo error: %s\n"</span>, gai_strerror(rc));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Walk the list and display each IP address</span></span><br><span class="line">    flags = NI_NUMERICHOST; <span class="comment">// Display address instead of name</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        getnameinfo(p-&gt;ai_addr, p-&gt;ai_addrlen, buf, MAXLINE, <span class="literal">NULL</span>, <span class="number">0</span>, flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>网络已经成为了我们『智能』生活中最重要的一部分，这两节课我们会通过 C API 来了解具体的网络相关编程（用更高层次的封装只会更轻松！）</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="网络" scheme="http://wdxtub.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker 碎碎念]]></title>
    <link href="http://wdxtub.com/2016/04/03/docker-gossip/"/>
    <id>http://wdxtub.com/2016/04/03/docker-gossip/</id>
    <published>2016-04-03T19:14:10.000Z</published>
    <updated>2016-04-03T22:35:01.000Z</updated>
    <content type="html"><![CDATA[<p>这篇日志主要来自 Docker 的应用及部署实践，算是从感性的角度来了解 Docker。</p>
<a id="more"></a>
<hr>
<p>以 Docker 为代表的容器技术模糊了 IaaS 与 PaaS 之间的界限，为云计算的服务形式带来了一个开放的未来。</p>
<p>一些言论：</p>
<ul>
<li>对 Docker 大规模应用到生产环境需要谨慎，但是仅考虑测试和开发，是可以真正解决环境部署问题的好办法</li>
<li>将所有服务放在一个容器叫做 Fat Container</li>
<li>Docker 天然适合一个容器只运行一种服务（官方更推荐）<ul>
<li>为每个服务创建单独文件夹，并在每个文件夹下放一个 Dockerfile</li>
</ul>
</li>
<li>每个容器只运行单一服务，容器间的互相通信有两种办法：<ul>
<li>将容器端口绑定到一个本地端口，通过端口通讯</li>
<li>通过 Docker 提供的 Linking 功能，推荐使用 Docker-Compose</li>
</ul>
</li>
<li>当前容器技术面临的最大阻力是安全问题和管理工具</li>
<li>学习 Docker 的三个阶段<ul>
<li>Docker 本身功能的使用</li>
<li>驾驭 Docker 集群（使用 Kubernetes, Shipyard, Machine+Swarm+Compose）</li>
<li>为场景和业务深度定制</li>
</ul>
</li>
<li>Docker 面临的最大阻碍 <ul>
<li>Docker 所属公司本身的强势，想做一揽子事情的态度，这使得 Docker 现在非常臃肿</li>
<li>不要把眼光局限在 Docker 上面，让 Docker 只做容器的事情</li>
</ul>
</li>
</ul>
<blockquote>
<p>除非你不想做，不想做就算了，想做好的话就不可能不劳而获</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">差劲的叛逆者</th>
<th style="text-align:center">优秀的叛逆者</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">抱怨</td>
<td style="text-align:center">创造</td>
</tr>
<tr>
<td style="text-align:center">断言</td>
<td style="text-align:center">质疑</td>
</tr>
<tr>
<td style="text-align:center">关注个人</td>
<td style="text-align:center">关注任务</td>
</tr>
<tr>
<td style="text-align:center">悲观</td>
<td style="text-align:center">乐观</td>
</tr>
<tr>
<td style="text-align:center">愤怒</td>
<td style="text-align:center">热情</td>
</tr>
<tr>
<td style="text-align:center">耗费能量</td>
<td style="text-align:center">生成能量</td>
</tr>
<tr>
<td style="text-align:center">疏离</td>
<td style="text-align:center">吸引</td>
</tr>
<tr>
<td style="text-align:center">问题</td>
<td style="text-align:center">可能性</td>
</tr>
<tr>
<td style="text-align:center">抱怨问题</td>
<td style="text-align:center">寻找机会</td>
</tr>
<tr>
<td style="text-align:center">担心</td>
<td style="text-align:center">希冀</td>
</tr>
<tr>
<td style="text-align:center">指责他人</td>
<td style="text-align:center">指出原因</td>
</tr>
<tr>
<td style="text-align:center">困扰</td>
<td style="text-align:center">反抗</td>
</tr>
<tr>
<td style="text-align:center">说教</td>
<td style="text-align:center">倾听</td>
</tr>
</tbody>
</table>
<p>成功叛逆者的秘密</p>
<table>
<thead>
<tr>
<th style="text-align:left">策略：实现特定目标的行动</th>
<th style="text-align:left">行为：你的行为举止，特别是对他人时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">利用他人的才华，明白没人能独自完成意义重大的改变</td>
<td style="text-align:left">保持乐观，鼓舞他人加入解决问题的行列</td>
</tr>
<tr>
<td style="text-align:left">将自己的想法和组织的目标统一起来</td>
<td style="text-align:left">评论想法，不评论人；讨论想法和想法的价值</td>
</tr>
<tr>
<td style="text-align:left">展现改变带来的好处与代价相称</td>
<td style="text-align:left">从愤怒中学习：思考是什么引发了愤怒，避免陷入情绪闹剧</td>
</tr>
<tr>
<td style="text-align:left">有效利用冲突：探究分歧和冲突，学习如何完善和推进一个想法</td>
<td style="text-align:left">尊重他人并考虑不同的观点</td>
</tr>
<tr>
<td style="text-align:left">不操之过急：给他人实践来接受新想法并思考它的影响</td>
<td style="text-align:left">知道何时该放弃坚持，懂得权衡想法的重要性和固执的代价</td>
</tr>
</tbody>
</table>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.wolonge.com/zhuanlan/detail/117441" target="_blank" rel="external">Docker在PHP项目开发环境中的应用</a></li>
<li><a href="http://news.oneapm.com/mesos-docker-go/" target="_blank" rel="external">通过 Mesos、Docker 和 Go，使用 300 行代码创建一个分布式系统</a></li>
<li>《Docker 开发实践》</li>
<li>《Docker——容器与容器云》</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇日志主要来自 Docker 的应用及部署实践，算是从感性的角度来了解 Docker。</p>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://wdxtub.com/tags/Docker/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="平台" scheme="http://wdxtub.com/tags/%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker 基本概念]]></title>
    <link href="http://wdxtub.com/2016/04/03/docker-basic-concept/"/>
    <id>http://wdxtub.com/2016/04/03/docker-basic-concept/</id>
    <published>2016-04-03T10:03:09.000Z</published>
    <updated>2016-04-03T17:56:32.000Z</updated>
    <content type="html"><![CDATA[<p>在 <a href="/./2016/04/02/docker-first-step/">Docker 快速入门及试验环境配置</a>中我们通过一个例子简单了解了 docker 的使用。这篇文章会从基本概念出发，用实际操作去更加深入理解 docker。</p>
<a id="more"></a>
<hr>
<p>具体的安装部分这里不赘述，可以在 <a href="/./2016/04/02/docker-first-step/">Docker 快速入门及试验环境配置</a> 的『安装』部分找到。</p>
<p>先大概复习一下基本概念：</p>
<p>主要是三个：</p>
<ul>
<li>镜像(Image)<ul>
<li>一个只读的模板，镜像可以用来创建 Docker 容器</li>
<li>可以简单创建或更新现有镜像，或者直接下载使用其他人的</li>
</ul>
</li>
<li>容器(Container)<ul>
<li>容器是从镜像创建的运行实例，在启动的时候创建一层可写层作为最上层（因为镜像是只读的）</li>
<li>可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台</li>
<li>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序</li>
</ul>
</li>
<li>仓库(Repository)<ul>
<li>集中存放镜像文件的场所</li>
<li>最大的公开仓库是 <a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a></li>
<li>国内的公开仓库包括 <a href="http://www.dockerpool.com/" target="_blank" rel="external">Docker Pool</a> 等</li>
<li>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了</li>
<li>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务</li>
</ul>
</li>
</ul>
<h2 id="u955C_u50CF"><a href="#u955C_u50CF" class="headerlink" title="镜像"></a>镜像</h2><p>我们可以使用 <code>docker pull</code> 命令从仓库中获取所需要的镜像。比如说 <code>sudo docker pull ubuntu:12.04</code>，相当于 <code>sudo docker pull registry.hub.docker.com/ubuntu:12.04</code>，即从注册服务器 <code>registry.hub.docker.com</code> 中的 <code>ubuntu</code> 仓库来下载标记为<code>12.04</code> 的镜像。</p>
<p>如果想从其他仓库注册服务器下载，需要输入完成的地址，例如：<code>sudo docker pull dl.dockerpool.com:5000/ubuntu:12.04</code></p>
<p>下载完成之后就可以使用该镜像了，比如下面的语句就会创建容器，其中运行 <code>bash</code>：<code>sudo docker run -t -i ubuntu:12.04 /bin/bash</code></p>
<p>可以使用 <code>dokcer images</code> 来显示本地已有的镜像，如下</p>
<p><img src="/images/14596963929829.jpg" alt="docker images"></p>
<p>具体字段的意思一目了然，这里不再赘述。然后我们来运行官方例子 <code>whalesay</code> 镜像。</p>
<h3 id="u8FD0_u884C_u955C_u50CF"><a href="#u8FD0_u884C_u955C_u50CF" class="headerlink" title="运行镜像"></a>运行镜像</h3><p>打开浏览器，进入 <a href="https://hub.docker.com/?utm_source=getting_started_guide&amp;utm_medium=embedded_Linux&amp;utm_campaign=find_whalesay" target="_blank" rel="external">Docker Hub</a></p>
<p><img src="/images/14596967621449.jpg" alt="Docker Hub"></p>
<p>搜索 <code>whalesay</code> 这个镜像，就可以看到结果，点进去可以看到详细内容（基于 Ubuntu）</p>
<p><img src="/images/14596968187418.jpg" alt="whalesay image"></p>
<p>然后我们来运行一下，使用命令 <code>docker run docker/whalesay cowsay boo</code>，其中 <code>cowsay</code> 是要运行的命令，后面的 <code>boo</code> 是参数。</p>
<p>Docker 会先在本地查找有没有镜像，如果没有就从仓库中下载，具体的运行结果是：</p>
<p><img src="/images/14596971019958.jpg" alt="cowsay boo"></p>
<p>也可以让鲸鱼说不同的话，比如：</p>
<p><img src="/images/14596971443647.jpg" alt=""></p>
<h3 id="u5236_u4F5C_u955C_u50CF"><a href="#u5236_u4F5C_u955C_u50CF" class="headerlink" title="制作镜像"></a>制作镜像</h3><p>如果想要制作自己的镜像，需要自己写 Dockerfile。具体步骤如下</p>
<ol>
<li>创建一个文件夹 <code>mkdir wdxtub; cd wdxtub</code>，构造镜像所需的所有东西都会放在这个文件夹中</li>
<li>创建一个名为 <code>Dockerfile</code> 的文件 <code>gedit Dockerfile</code></li>
<li>添加第一句话 <code>FROM docker/whalesay:latest</code>，表示我们的镜像以 <code>whalesay</code> 为基础</li>
<li>添加需要运行的命令，如 <code>RUN apt-get -y update &amp;&amp; apt-get install -y fortunes</code>（<code>fortunes</code> 这个程序会输出名言警句）</li>
<li>通过 <code>CMD</code> 指定镜像载入之后需要执行的命令，如 <code>CMD /usr/games/fortune -a | cowsay</code></li>
<li>保存并关闭 Dockerfile</li>
<li>使用 <code>sudo docker build -t wdx-whale .</code> 来构造镜像，简单来说就是用 Dockerfile 中的内容按步骤构造</li>
<li>使用 <code>docker images</code> 应该就可以看到我们新创建的镜像</li>
</ol>
<p><img src="/images/14596980285832.jpg" alt="wdx-whale image"></p>
<p>然后我们就可以运行一下看看 <code>docker run wdx-whale</code></p>
<p><img src="/images/14596980932968.jpg" alt="搞笑句"></p>
<p>还有更贱的（感觉可以玩一天）</p>
<p><img src="/images/14596987783177.jpg" alt=""></p>
<p>如果想要把自己的镜像上传到网上，就需要注册一个 Docker Hub 帐号，然后点击 Create Repository，这里我创建了一个名为 <code>wdxtub/demo</code> 的公用仓库。</p>
<p>接下来我们需要打上 tag，目前 <code>docker images</code> 的情况是：</p>
<p><img src="/images/14596980285832.jpg" alt="wdx-whale image"></p>
<p>记住我们的 IMAGE ID 26ac9649d7da。用以下命令打 tag <code>docker tag 26ac9649d7da wdxtub/wdx-whale:latest</code>，然后再 <code>docker images</code> 一次：</p>
<p><img src="/images/14596998719751.jpg" alt=""></p>
<p>然后用这个命令登录 <code>docker login --username=yourhubusername --email=youremail@company.com</code>，对于我来说就是 <code>docker login --username=wdxtub --email=dacrocodilee@gmail.com</code></p>
<p>成功之后大概是这样：</p>
<p><img src="/images/14596999803535.jpg" alt="登录成功"></p>
<p>然后就可以 push 上去了 <code>docker push wdxtub/wdx-whale</code>，像下面这样</p>
<p><img src="/images/14597002872580.jpg" alt="push"></p>
<p>为了测试 pull 自己的镜像，我们先把本地上的 whale 镜像删掉：<code>docker rmi -f wdxtub/wdx-whale; docker rmi -f wdx-whale</code>（如果有其他的用不着的也都删掉），最后剩下（上课要用的镜像）：</p>
<p><img src="/images/14597004851281.jpg" alt=""></p>
<p>接着来运行一下 <code>docker run wdxtub/wdx-whale</code></p>
<h3 id="u7BA1_u7406_u955C_u50CF"><a href="#u7BA1_u7406_u955C_u50CF" class="headerlink" title="管理镜像"></a>管理镜像</h3><p>我们可以把镜像导出到本地文件，使用 <code>docker save</code> 命令即可，比如针对我现在有的镜像 <code>wdxtub/wdx-whale(id:26ac9649d7da)</code>，可以这样：<code>docker save -o wdx-local-whale.tar wdxtub/wdx-whale</code>。如果要载入的话，使用下面的命令即可（会载入相关的元数据信息）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker load --input wdx-local-whale.tar</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker load &lt; wdx-local-whale.tar</span><br></pre></td></tr></table></figure>
<p>在删除镜像之前要先用 <code>docker rm</code> 删掉依赖于这个镜像的所有容器.</p>
<p><code>sudo docker rmi $(docker images -q -f &quot;dangling=true&quot;)</code></p>
<blockquote>
<p>镜像的实现原理</p>
</blockquote>
<p>Docker 镜像是怎么实现增量的修改和维护的？ 每个镜像都由很多层次构成，Docker 使用 <a href="http://en.wikipedia.org/wiki/UnionFS" target="_blank" rel="external">Union FS</a> 将这些不同的层结合到一个镜像中去。</p>
<p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。 Docker 在 AUFS 上构建的容器也是利用了类似的原理。</p>
<h2 id="u5BB9_u5668"><a href="#u5BB9_u5668" class="headerlink" title="容器"></a>容器</h2><p>容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>
<p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器（对于初级应用来说后者更方便）。</p>
<p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<p>可以利用 <code>docker start</code> 命令，直接将一个已经终止的容器启动运行。<br>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p>
<h3 id="u542F_u52A8"><a href="#u542F_u52A8" class="headerlink" title="启动"></a>启动</h3><p>举个例子，我们来创建一个 ubuntu:14.04 的容器 <code>docker run ubuntu:14.04 /bin/echo &#39;Hello wdx!&#39;</code></p>
<p><img src="/images/14597044909422.jpg" alt=""></p>
<p>用 <code>docker run -t -i ubuntu:14.04 /bin/bash</code> 可以启动一个 bash 终端用来交互。其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。我们可以输入一些命令来测试</p>
<p><img src="/images/14597046071804.jpg" alt=""></p>
<p>我们用 <code>ps</code> 或 <code>top</code> 在伪终端中查看进程信息，可以看到：</p>
<p><img src="/images/14597046832387.jpg" alt=""></p>
<p>输入 <code>exit</code> 可以退出 docker</p>
<p>容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p>
<h3 id="u540E_u53F0_u8FD0_u884C"><a href="#u540E_u53F0_u8FD0_u884C" class="headerlink" title="后台运行"></a>后台运行</h3><p>更多的时候，需要让 Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。</p>
<p>下面举两个例子来说明一下。</p>
<p>如果不使用 -d 参数运行容器 <code>docker run ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code> 容器会把输出的结果(STDOUT)打印到宿主机上面</p>
<p><img src="/images/14597048507796.jpg" alt=""></p>
<p>如果使用了 -d 参数运行容器 <code>docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code>，则显示是这样：</p>
<p><img src="/images/14597049156842.jpg" alt=""></p>
<p>使用 <code>docker logs containerid</code> 可以查看输出，如：</p>
<p><img src="/images/14597049744299.jpg" alt=""></p>
<p>使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker ps 命令来查看容器信息。容器是否会长久运行，是和docker run指定的命令有关，和 -d 参数无关</p>
<p>在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作，有很多种方法，包括使用 docker attach 命令或 nsenter 工具等。具体参考<a href="https://yeasy.gitbooks.io/docker_practice/content/container/enter.html" target="_blank" rel="external">这里</a></p>
<h3 id="u7EC8_u6B62_u4E0E_u91CD_u65B0_u542F_u52A8"><a href="#u7EC8_u6B62_u4E0E_u91CD_u65B0_u542F_u52A8" class="headerlink" title="终止与重新启动"></a>终止与重新启动</h3><p>使用 <code>docker stop containerid</code> 来终止容器。终止状态的容器可以用 <code>docker ps -a</code> 命令看到。</p>
<p>另外，<code>docker restart containerid</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h3 id="u5BFC_u5165_u5BFC_u51FA_u4E0E_u5220_u9664"><a href="#u5BFC_u5165_u5BFC_u51FA_u4E0E_u5220_u9664" class="headerlink" title="导入导出与删除"></a>导入导出与删除</h3><p>如果要导出本地某个容器，可以使用 <code>docker export containerid</code> 命令。</p>
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat ubuntu.tar | sudo docker import - <span class="built_in">test</span>/ubuntu:v1.<span class="number">0</span></span><br><span class="line"><span class="comment"># 也可以通过指定 URL 或者某个目录来导入，例如</span></span><br><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>
<p>用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<p>可以使用 <code>docker rm</code> 来删除一个处于终止状态的容器。如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</p>
<p>用 <code>docker ps -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用 <code>docker rm $(docker ps -a -q)</code> 可以全部清理掉。</p>
<p>注意：这个命令其实会试图删除所有的包括还在运行中的容器，不过就像上面提过的<code>docker rm</code> 默认并不会删除运行中的容器。</p>
<h2 id="u4ED3_u5E93"><a href="#u4ED3_u5E93" class="headerlink" title="仓库"></a>仓库</h2><p>仓库（Repository）是集中存放镜像的地方。</p>
<p>一个容易混淆的概念是注册服务器（Registry）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址dl.dockerpool.com/ubuntu 来说，dl.dockerpool.com 是注册服务器地址，ubuntu是仓库名。</p>
<p>大部分时候，并不需要严格区分这两者的概念。相信信息可以直接看教程，这里不赘述了。</p>
<ul>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/dockerhub.html" target="_blank" rel="external">Docker Hub 指南</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/local_repo.html" target="_blank" rel="external">私有仓库指南</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/config.html" target="_blank" rel="external">配置文件指南</a></li>
</ul>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="/Find and run the whalesay image">Find and run the whalesay image</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/image/create.html" target="_blank" rel="external">创建镜像</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/container/enter.html" target="_blank" rel="external">进入容器</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 <a href="/./2016/04/02/docker-first-step/">Docker 快速入门及试验环境配置</a>中我们通过一个例子简单了解了 docker 的使用。这篇文章会从基本概念出发，用实际操作去更加深入理解 docker。</p>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://wdxtub.com/tags/Docker/"/>
    
      <category term="概念" scheme="http://wdxtub.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker 快速入门及试验环境配置]]></title>
    <link href="http://wdxtub.com/2016/04/02/docker-first-step/"/>
    <id>http://wdxtub.com/2016/04/02/docker-first-step/</id>
    <published>2016-04-03T00:11:29.000Z</published>
    <updated>2016-04-04T00:48:18.000Z</updated>
    <content type="html"><![CDATA[<p>借着课程的机会来了解一下 Docker，大部分内容来自官方文档以及课程指引。</p>
<a id="more"></a>
<hr>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Docker 最初 dotCloud 公司内部的一个业余项目</li>
<li>Docker 基于 Go 语言</li>
<li>Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案</li>
<li>Docker 的基础是 Linux 容器（LXC）等技术</li>
<li>Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多</li>
<li>Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器</li>
</ul>
<p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</p>
<p><img src="/images/14596424862659.png" alt=""></p>
<p><img src="/images/14596424920098.png" alt=""></p>
<p>容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。</p>
<p>主要优势为：</p>
<ul>
<li>更快速的交付和部署 - 容器成为了最小单位</li>
<li>更高效的虚拟化 - 内核级虚拟化</li>
<li>更轻松的迁移和拓展</li>
<li>更简单的管理</li>
</ul>
<h2 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h2><p>主要是三个：</p>
<ul>
<li>镜像(Image)<ul>
<li>一个只读的模板，镜像可以用来创建 Docker 容器</li>
<li>可以简单创建或更新现有镜像，或者直接下载使用其他人的</li>
</ul>
</li>
<li>容器(Container)<ul>
<li>容器是从镜像创建的运行实例，在启动的时候创建一层可写层作为最上层（因为镜像是只读的）</li>
<li>可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台</li>
<li>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序</li>
</ul>
</li>
<li>仓库(Repository)<ul>
<li>集中存放镜像文件的场所</li>
<li>最大的公开仓库是 <a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a></li>
<li>国内的公开仓库包括 <a href="http://www.dockerpool.com/" target="_blank" rel="external">Docker Pool</a> 等</li>
<li>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了</li>
<li>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务</li>
</ul>
</li>
</ul>
<h2 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h2><p>官方网站提供了 <a href="https://docs.docker.com/mac/" target="_blank" rel="external">Mac</a>, <a href="https://docs.docker.com/linux/" target="_blank" rel="external">Linux</a> 和 <a href="https://docs.docker.com/windows/" target="_blank" rel="external">Windows</a> 版本的安装教程。因为我打算使用虚拟机进行安装测试，所以这里主要走 Linux 的安装教程，不过其他的应该大同小异。我的 ubuntu 版本是 14.04 LTS, trusty</p>
<p>Docker 目前只能安装在 64 位平台上，并且要求内核版本不低于 3.10，实际上内核越新越好，过低的内核版本容易造成功能的不稳定。可以通过下面的命令来检查内核版本（两个方式，都可以）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parallels@ubuntu:~$ uname <span class="operator">-a</span>Linux ubuntu <span class="number">3.13</span>.<span class="number">0</span>-<span class="number">83</span>-generic <span class="comment">#127-Ubuntu SMP Fri Mar 11 00:25:37 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line">parallels@ubuntu:~$ cat /proc/versionLinux version <span class="number">3.13</span>.<span class="number">0</span>-<span class="number">83</span>-generic (buildd@lgw01-<span class="number">55</span>) (gcc version <span class="number">4.8</span>.<span class="number">2</span> (Ubuntu <span class="number">4.8</span>.<span class="number">2</span>-<span class="number">19</span>ubuntu1) ) <span class="comment">#127-Ubuntu SMP Fri Mar 11 00:25:37 UTC 2016</span></span><br></pre></td></tr></table></figure>
<p>这里我们按照官网的教程，不使用 <code>apt-get</code> 而是使用 <code>curl</code> 来进行安装。</p>
<ol>
<li>如果没有安装 <code>curl</code>，使用 <code>sudo apt-get update; sudo apt-get install curl</code> 来进行安装</li>
<li>下载最新的 Docker 包 <code>curl -fsSL https://get.docker.com/ | sh</code><ul>
<li>如果想要以 non-root 用户的角色来使用，请使用 <code>sudo usermod -aG docker parallels</code>（这里 <code>parallels</code> 是用户名），注意需要注销并重新登录以应用改动</li>
</ul>
</li>
<li>验证安装<ul>
<li>需要先启用 docker <code>sudo service docker start</code></li>
<li>然后可以用 <code>docker version</code> 来查看版本</li>
<li>最后使用 <code>docker run hello-world</code> 来测试</li>
</ul>
</li>
</ol>
<p>版本信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parallels@ubuntu:~$ docker versionClient: Version:      <span class="number">1.10</span><span class="number">.3</span> API version:  <span class="number">1.22</span> Go version:   go1<span class="number">.5</span><span class="number">.3</span> Git commit:   <span class="number">20f</span>81dd Built:        Thu Mar <span class="number">10</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">52</span> <span class="number">2016</span> OS/Arch:      linux/amd64Server: Version:      <span class="number">1.10</span><span class="number">.3</span> API version:  <span class="number">1.22</span> Go version:   go1<span class="number">.5</span><span class="number">.3</span> Git commit:   <span class="number">20f</span>81dd Built:        Thu Mar <span class="number">10</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">52</span> <span class="number">2016</span> OS/Arch:      linux/amd64</span><br></pre></td></tr></table></figure>
<p>成功运行 hello world 的结果</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parallels@ubuntu:~$ docker run hello-worldHello <span class="built_in">from</span> Docker.This message shows that your installation appears <span class="built_in">to</span> be working correctly.To generate this message, Docker took <span class="operator">the</span> following steps: <span class="number">1.</span> The Docker client contacted <span class="operator">the</span> Docker daemon. <span class="number">2.</span> The Docker daemon pulled <span class="operator">the</span> <span class="string">"hello-world"</span> image <span class="built_in">from</span> <span class="operator">the</span> Docker Hub. <span class="number">3.</span> The Docker daemon created <span class="operator">a</span> <span class="built_in">new</span> container <span class="built_in">from</span> that image which runs <span class="operator">the</span>    executable that produces <span class="operator">the</span> output you are currently reading. <span class="number">4.</span> The Docker daemon streamed that output <span class="built_in">to</span> <span class="operator">the</span> Docker client, which sent <span class="keyword">it</span>    <span class="built_in">to</span> your terminal.To <span class="keyword">try</span> something more ambitious, you can run <span class="operator">an</span> Ubuntu container <span class="operator">with</span>: $ docker run -<span class="keyword">it</span> ubuntu bashShare images, automate workflows, <span class="operator">and</span> more <span class="operator">with</span> <span class="operator">a</span> free Docker Hub account: <span class="keyword">https</span>://hub.docker.comFor more examples <span class="operator">and</span> ideas, visit: <span class="keyword">https</span>://docs.docker.com/userguide/</span><br></pre></td></tr></table></figure>
<p>这之后的部分是课程需求。</p>
<p>我们需要安装 docker machine 和 virtual box，具体步骤为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取权限</span></span><br><span class="line">$ sudo su</span><br><span class="line"><span class="comment"># 下载 Docker Machine 的二进制文件 </span></span><br><span class="line">$ curl -L https://github.com/docker/machine/releases/download/v0.<span class="number">6.0</span>/docker-machine-`uname <span class="operator">-s</span>`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-machine &amp;&amp; chmod +x /usr/<span class="built_in">local</span>/bin/docker-machine</span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">$ docker-machine version</span><br><span class="line">docker-machine version <span class="number">0.6</span>.<span class="number">0</span>, build e27fb87</span><br></pre></td></tr></table></figure>
<ul>
<li>添加源<ul>
<li>把这行添加到 <code>/etc/apt/sources.list</code> 文件中 <code>deb http://download.virtualbox.org/virtualbox/debian trusty contrib</code> </li>
<li><code>wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add -</code></li>
</ul>
</li>
<li>更新并安装 <code>sudo apt-get update; sudo apt-get install virtualbox-5.0</code></li>
</ul>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2><p>然后是一些配置，先重设默认的虚拟机 </p>
<ul>
<li>删除原来的默认（如果有的话）<code>docker-machine rm default</code></li>
<li>创建新的默认虚拟机 <code>docker-machine create --driver virtualbox default</code>（这一步可能需要等一下，我用的是 Parallel Desktop 11，还需要在虚拟机设置中开启 CPU 虚拟化，主要是支持 vt-x）</li>
</ul>
<p>然后如果直接在菜单中选择 Virtual Box 的话，就会发现什么都没有，技巧是要在刚才的命令行中输入 <code>virtualbox</code>，然后就可以看到下面的界面：</p>
<p><img src="/images/14596481872848.jpg" alt="default 就是我们刚才创建的虚拟机"></p>
<p>在 Settings - Network 中选择 Port Forwarding，然后按照如图所示添加记录</p>
<p><img src="/images/14596485001418.jpg" alt=""></p>
<p>这里的 Host Port: 9234 记为 A，Guest Port: 9001 记为 B。然后就可以启动 docker 中老师提供的镜像了：</p>
<p>命令为 <code>docker run -it -p 9001:9000 cmusvsc/apachecmda:1.1</code>（需要下载一段时间，然后再解压一段时间），这里 9001 记为 C，9000 记为 D。</p>
<p>接着就会直接连接到 docker 中的虚拟机，从之后的图中可以看到命令行前面的内容也变化了。然后我们输入命令开启前端 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/Spring2016/ApacheCMDA-Frontend</span><br><span class="line">./activator run <span class="comment"># 相当于在 9000 端口开启</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/14596510005751.jpg" alt="开启前端"></p>
<p>不要关现在的终端，开启一个新的终端。仍然 <code>docker run -it -p 9001:9000 cmusvsc/apachecmda:1.1</code></p>
<p>等待一段时间后，继续走以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/Spring2016/ApacheCMDA-Backend</span><br><span class="line">./activator <span class="string">"run 9034"</span></span><br></pre></td></tr></table></figure>
<p>然后可以见到 </p>
<p><img src="/images/14596503095705.jpg" alt="开启后端"></p>
<p>然后等待一段时间（第一运行需要编译），就可以见到主页面了：</p>
<p><img src="/images/14596510450895.jpg" alt="主界面"></p>
<p>还记得前面的端口转发吗？这里解释一下：</p>
<ul>
<li>A，也就是 9234，是用户访问的端口号</li>
<li>B，也就是 9001，我们通过虚拟机的端口转发从 9234 转到了 9001</li>
<li>C，也就是 9001（这个命令中的 <code>docker run -it -p 9001:9000 cmusvsc/apachecmda:1.1</code>），是虚拟机继续转发的端口</li>
<li>D，也就是 9000（这个命令中的 <code>docker run -it -p 9001:9000 cmusvsc/apachecmda:1.1</code>），是 Docker 容器中接收请求的端口。</li>
</ul>
<p>也就是说，B 和 C 一定要一样，A 和 D 可以在命令中设置。至于为什么后端需要运行在 9034 端口，是因为前端和后端通过这个端口通讯（应该是写死在代码里的）</p>
<p>挂载主机数据卷到容器内，可以通过如下命令进行文件夹映射</p>
<p><code>docker run -it -p 9999:9999 -p 9001:9000 -v ~/localFolder:/sharedFolder cmusvsc/apachecmda:1.1</code></p>
<p>从容器内拷贝文件到主机上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出 container</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 复制 这个不知道为啥不行</span></span><br><span class="line">docker cp &lt;containerId&gt;:/file/path/within/container /host/path/target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载映射</span></span><br><span class="line">docker run -it -v /home/parallels/Documents/code:/home/code cmusvsc/apachecmda:<span class="number">1.1</span></span><br><span class="line"><span class="comment"># 复制</span></span><br><span class="line">cp -r Spring2016/* ./code/</span><br></pre></td></tr></table></figure>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/docker/docker" target="_blank" rel="external">开源代码</a></li>
<li><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a></li>
<li><a href="https://docs.docker.com/machine/install-machine/" target="_blank" rel="external">Install Docker Machine</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>借着课程的机会来了解一下 Docker，大部分内容来自官方文档以及课程指引。</p>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://wdxtub.com/tags/Docker/"/>
    
      <category term="容器" scheme="http://wdxtub.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第十二周 - 正趣果上果]]></title>
    <link href="http://wdxtub.com/2016/04/02/the-fun/"/>
    <id>http://wdxtub.com/2016/04/02/the-fun/</id>
    <published>2016-04-02T12:58:28.000Z</published>
    <updated>2016-04-02T14:44:39.000Z</updated>
    <content type="html"><![CDATA[<p>人生在世三万天，趣果有间孤独无解，苦练含笑半步颠。心怀啮雪大志愿，被人称作小可怜。本欲歃血定风月，乌飞兔走光阴只负尾生约。</p>
<a id="more"></a>
<hr>
<p>习惯了没有四季的广州，在四季分明的匹兹堡，真的能感受到生机勃勃的味道。不过这都是用六个月的寒冬换来的，如果可以选的话，我宁愿放弃四季。虽然温差依然可以二十多度，好歹下午是可以开开心心去跑跑步了。离开之前，多看几眼。</p>
<p>对一个地方的感情，其实和在这个地方交到的朋友和自己的改变程度有关。在执信我既经历了自我的重大转变，也交到了许多挚友，理所当然是我感情密度最高的地方。</p>
<p>相对来说，在匹兹堡的这段时间，以另外的方式认识了很多朋友，也真正完成了一直以来想要完成的转身。华丽不华丽不知道，虽然还有这样那样的小问题，总体来说我是满意的。</p>
<p>陆陆续续在收拾行李，发现其实也没有多少要带回去的东西，因为一直都是以『游子』的心态在过日子，大件的东西不买，可能用到=不用，带不走的直接送人，轻轻来轻轻走。年年毕业季，年年卖闲置，我觉得为了几块钱几十块钱劳神费力真不值得，还不如以交朋友的心态直接送给有缘人。</p>
<p>慢慢熟悉了英文歌的套路之后，现在又开始听中文歌了，但是口味变了不少。从陈粒 Jam 程璧常石磊到屠洪刚韩磊刘欢，除了旋律之外，越来越在意歌词讲不讲究。除了标题是陈粒的『正趣果上果』外，我还想安利几首：</p>
<blockquote>
<p>给少年的歌 程璧</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">月亮悄悄蒙上一层纱 夜云悄悄隆起崖</span><br><span class="line">曾经年少的我啊 曾经痴心这么想</span><br><span class="line">如果有一天 如果有一个人</span><br><span class="line">陪我一起看花开 陪我一起看流霞</span><br><span class="line">我就想为谁 为谁唱起这首歌</span><br><span class="line">一首少年的歌 一首为你写的歌</span><br></pre></td></tr></table></figure>
<blockquote>
<p>晴日共剪窗 程璧</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">庭前花木满 院外小径芳</span><br><span class="line">四时常相往 晴日共剪窗</span><br></pre></td></tr></table></figure>
<blockquote>
<p>七月上 Jam</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我想你就站在，站在大漠边疆</span><br><span class="line">我想你就站在，站在七月上</span><br><span class="line">我化尘埃飞扬，追寻赤裸逆翔</span><br><span class="line">奔去七月刑场，时间烧灼滚烫</span><br><span class="line">回忆撕毁臆想，路上行走匆忙</span><br><span class="line">难能可贵世上，散播留香磁场</span><br></pre></td></tr></table></figure>
<blockquote>
<p>老爸 常石磊</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我在牵挂 你也在牵挂 是你引我走天涯</span><br><span class="line">你慢慢老 我渐渐长大 是你让我别想家</span><br><span class="line">你在牵挂 我也在牵挂 是你教我志在四方 什么都别怕 </span><br><span class="line">我不在家 你好好保重吧</span><br></pre></td></tr></table></figure>
<p>未来的选择，和选择的未来，更多是计划之后的顺其自然。</p>
<p>正趣果上果，归依天中天，一道长死生，有无离二边。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>人生在世三万天，趣果有间孤独无解，苦练含笑半步颠。心怀啮雪大志愿，被人称作小可怜。本欲歃血定风月，乌飞兔走光阴只负尾生约。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="反思" scheme="http://wdxtub.com/tags/%E5%8F%8D%E6%80%9D/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="选择" scheme="http://wdxtub.com/tags/%E9%80%89%E6%8B%A9/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Prolog 快速入门]]></title>
    <link href="http://wdxtub.com/2016/04/01/prolog-first-step/"/>
    <id>http://wdxtub.com/2016/04/01/prolog-first-step/</id>
    <published>2016-04-02T01:02:45.000Z</published>
    <updated>2016-04-02T15:45:43.000Z</updated>
    <content type="html"><![CDATA[<p>Prolog 是一门声明式编程语言，也是最早成功的逻辑编程语言之一。只需提供 fact 和 inference，程序会替我们进行推断。甚至不需要知道怎么做，只要告诉计算机要做什么即可。比方说，用不到 20 行代码解决数独问题。</p>
<a id="more"></a>
<hr>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><ul>
<li>1972 年由 Alain Colmerauer 和 Phillipe Roussel 开发完成</li>
<li>基于数据库，数据由逻辑规则和关系组成</li>
<li>包含两个部分：一部分用于描述数据，另一部分用于查询数据</li>
</ul>
<p>在 Prolog 中，数据以逻辑规则的形式存在，下面是基本构建单元：</p>
<ul>
<li>事实：关于真实世界的基本断言（Babe 是一头猪，猪喜欢泥巴）</li>
<li>规则：关于真实世界中的一些事实的推论（如果一个动物是猪，那么它喜欢泥巴）</li>
<li>查询：关于真实世界的一个问题（Babe 喜欢泥巴吗）</li>
</ul>
<p>事实和规则被放入一个知识库(knowledge base)。Prolog 编译器将这个知识库编译成一种适于高效查询的形式。</p>
<p>这里我们在 ubuntu 下做实验，直接 <code>sudo apt-get install gprolog</code> 即可</p>
<h2 id="u7F16_u7A0B_u6A21_u578B"><a href="#u7F16_u7A0B_u6A21_u578B" class="headerlink" title="编程模型"></a>编程模型</h2><p>Prolog 中，一个词以小写字母开头，就是一个原子(atom)——类似于 Ruby 中的符号(symbol)的固定值，如果一个词以大写字母或下划线开头，那么它就是一个变量。变量的值可以改变，原则则不能。</p>
<p>下面是一个简单的例子，先创建一个文件（比如 <code>friends.pl</code>），输入以下内容</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">likes</span>(<span class="atom">wallace</span>, <span class="atom">cheese</span>).</span><br><span class="line"><span class="atom">likes</span>(<span class="atom">grommit</span>, <span class="atom">cheese</span>).</span><br><span class="line"><span class="atom">likes</span>(<span class="atom">wendolene</span>, <span class="atom">sheep</span>).</span><br><span class="line"></span><br><span class="line"><span class="atom">friend</span>(<span class="name">X</span>, <span class="name">Y</span>) :- \+(<span class="name">X</span> = <span class="name">Y</span>), <span class="atom">likes</span>(<span class="name">X</span>, <span class="name">Z</span>), <span class="atom">likes</span>(<span class="name">Y</span>, <span class="name">Z</span>).</span><br></pre></td></tr></table></figure>
<p>上面这个文件就是由事实和规则组成的知识库。前三条语句是事实，最后一条语句是一个规则。<code>wallace</code>, <code>grommit</code> 和 <code>wendolene</code> 都是原子，翻译过来就是</p>
<ul>
<li><code>wallace</code> 喜欢 <code>cheese</code></li>
<li><code>grommit</code> 喜欢 <code>cheese</code></li>
<li><code>wendolene</code> 喜欢 <code>sheep</code></li>
</ul>
<p>具体执行时，先输入 <code>gprolog</code>，然后输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- [<span class="string">'friends.pl'</span>].compiling /home/parallels/Documents/friends.pl <span class="keyword">for</span> byte code.../home/parallels/Documents/friends.pl compiled, <span class="number">5</span> lines <span class="built_in">read</span> - <span class="number">976</span> bytes written, <span class="number">6</span> ms(<span class="number">1</span> ms) yes</span><br></pre></td></tr></table></figure>
<p>除非 Prolog 在等待一个中间结果，否则都会用 <code>yes</code> 或者 <code>no</code> 来回应，这一句里文件加载成功，所以返回 <code>yes</code>。而 <code>| ?-</code> 是命令前面的提示符，类似于命令行前的 <code>$</code>，不过这么有个性的，我还是第一次见</p>
<p>然后我们就可以让计算机自己进行逻辑推断了，比如：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- <span class="atom">likes</span>(<span class="atom">wallace</span>, <span class="atom">sheep</span>).<span class="atom">no</span></span><br></pre></td></tr></table></figure>
<p>通过前面的条件我们知道，并不能推断出 wallace 喜欢 sheep，所以返回 no。</p>
<blockquote>
<p>基本推论和变量</p>
</blockquote>
<p>来测试以下前面的 <code>friend</code> 规则：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| ?- <span class="atom">friend</span>(<span class="atom">wallace</span>, <span class="atom">wallace</span>).<span class="atom">no</span></span><br><span class="line">| ?- <span class="atom">friend</span>(<span class="atom">grommit</span>, <span class="atom">wallace</span>).<span class="atom">yes</span>| ?- <span class="atom">friend</span>(<span class="atom">wallace</span>, <span class="atom">grommit</span>).<span class="atom">yes</span></span><br></pre></td></tr></table></figure>
<p>我们来用自然语言翻译一下 <code>friend</code> 规则</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">friend</span>(<span class="name">X</span>, <span class="name">Y</span>) :- \+(<span class="name">X</span> = <span class="name">Y</span>), <span class="atom">likes</span>(<span class="name">X</span>, <span class="name">Z</span>), <span class="atom">likes</span>(<span class="name">Y</span>, <span class="name">Z</span>).</span><br></pre></td></tr></table></figure>
<p>如果 <code>X</code> 和 <code>Y</code> 是朋友，那么 X 就不能与 Y 相同。<code>:-</code> 右边的称为子目标(subgoal)。<code>\+</code> 是逻辑取反操作，所以第一个子目标 <code>\+(X=Y)</code> 的意思是 <code>X</code> 不等于 <code>Y</code>。后面的 <code>likes</code> 语句表示如果 <code>X</code> 喜欢 <code>Z</code>，并且 <code>Y</code> 也喜欢 <code>Z</code>，所以后面的子目标就是在 <code>X</code> 不等于 <code>Y</code> 的情况下，他们还喜欢同一个 <code>Z</code>。我们可以试验以下其他的组合，来看看 prolog 的工作机制。</p>
<p>上面的代码是一个具有三个变量 <code>X</code>, <code>Y</code> 和 <code>Z</code> 的 Prolog 规则，称为 <code>friend/2</code> 表示参数有 2 个，这个规则有三个子目标（条件）。只有都满足的时候，规则才为真。</p>
<blockquote>
<p>填空</p>
</blockquote>
<p>我们还可以利用 prolog 查询出所有可能的匹配，这时候我们就需要一个变量，打开一个新的文件 <code>food.pl</code>，并填入下面的代码：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">food_type</span>(<span class="atom">velveeta</span>, <span class="atom">cheese</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">ritz</span>, <span class="atom">cracker</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">spam</span>, <span class="atom">meat</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">sausage</span>, <span class="atom">meat</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">jolt</span>, <span class="atom">soda</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">twinkie</span>, <span class="atom">dessert</span>).</span><br><span class="line"></span><br><span class="line"><span class="atom">flavor</span>(<span class="atom">sweet</span>, <span class="atom">dessert</span>).</span><br><span class="line"><span class="atom">flavor</span>(<span class="atom">savory</span>, <span class="atom">meat</span>).</span><br><span class="line"><span class="atom">flavor</span>(<span class="atom">savory</span>, <span class="atom">cheese</span>).</span><br><span class="line"><span class="atom">flavor</span>(<span class="atom">sweet</span>, <span class="atom">soda</span>).</span><br><span class="line"></span><br><span class="line"><span class="atom">food_flavor</span>(<span class="name">X</span>, <span class="name">Y</span>) :- <span class="atom">food_type</span>(<span class="name">X</span>, <span class="name">Z</span>), <span class="atom">flavor</span>(<span class="name">Y</span>, <span class="name">Z</span>).</span><br></pre></td></tr></table></figure>
<p>其中 <code>food_type(velveeta, cheese)</code> 意思是 <code>velveeta</code> 属于 <code>cheese</code> 类食物；而 <code>flavor(sweet, dessert)</code> 则表示 <code>sweet</code> 是 <code>dessert</code> 的味道。最后的规则的意思是如果食物 <code>X</code> 属于类别 <code>Z</code> 并且 <code>Z</code> 的味道是 <code>Y</code>，那么食物 <code>X</code> 具有 <code>food_flavor</code> <code>Y</code>。编译一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- [<span class="string">'food.pl'</span>].compiling /home/parallels/Documents/food.pl <span class="keyword">for</span> byte code.../home/parallels/Documents/food.pl compiled, <span class="number">13</span> lines <span class="built_in">read</span> - <span class="number">1536</span> bytes written, <span class="number">5</span> msyes</span><br></pre></td></tr></table></figure>
<p>然后我们来问几个问题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- food_<span class="built_in">type</span>(What, meat).What = spam ? ;What = sausage ? ;no</span><br></pre></td></tr></table></figure>
<p>这里 prolog 会先找到 <code>spam</code>，然后输入 <code>;</code>，prolog 就会继续寻找下一个，也就是返回 <code>sausage</code>，继续输入 <code>;</code>，会发现返回了 <code>no</code>，这表示在未经更多计算的情况下不能判断是否还有更多选项。</p>
<p>另一个问题可以是 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- food_flavor(What, savory).What = velveeta ? ;What = spam ? ;What = sausage ? ;no</span><br></pre></td></tr></table></figure>
<p>这里要注意 <code>food_flavor(X,Y)</code> 是一个规则，而不是事实，逻辑引擎会遍历所有使目标为真的可能组合。</p>
<h2 id="u4E60_u9898"><a href="#u4E60_u9898" class="headerlink" title="习题"></a>习题</h2><h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://fengdidi.github.io/blog/2011/11/15/di-1zhang-pei-zhi-kai-fa-huan-jing/" target="_blank" rel="external">笨办法学Prolog</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Prolog 是一门声明式编程语言，也是最早成功的逻辑编程语言之一。只需提供 fact 和 inference，程序会替我们进行推断。甚至不需要知道怎么做，只要告诉计算机要做什么即可。比方说，用不到 20 行代码解决数独问题。</p>]]>
    
    </summary>
    
      <category term="Prolog" scheme="http://wdxtub.com/tags/Prolog/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="语言" scheme="http://wdxtub.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Io 快速入门]]></title>
    <link href="http://wdxtub.com/2016/04/01/io-first-step/"/>
    <id>http://wdxtub.com/2016/04/01/io-first-step/</id>
    <published>2016-04-01T15:33:13.000Z</published>
    <updated>2016-04-02T01:02:26.000Z</updated>
    <content type="html"><![CDATA[<p>原型语言我接触得其实非常少，Io 和 JavaScript/Lua 一样，每个对象都是另一个对象的复制品。这部分暂时我的兴趣不是特别大，所以简要记录一下，以后有兴趣再学。</p>
<a id="more"></a>
<hr>
<ul>
<li>Io 语言于 2002 年由 Steve Dekorte 发明</li>
<li>基于原型的语言，每个对象都不是类的复制品</li>
<li>带有微型虚拟机和丰富并发特性的可嵌入语言来推广</li>
<li>拥有大量可定制语法和函数，以及强有力的并发模型</li>
<li>万事万物皆为消息，且每条消息都会返回另一接收消息的对象</li>
<li>没有关键字，只有少量在行为上接近于关键字的字符</li>
</ul>
<h2 id="u7F16_u7A0B_u6A21_u578B"><a href="#u7F16_u7A0B_u6A21_u578B" class="headerlink" title="编程模型"></a>编程模型</h2><blockquote>
<p>优势</p>
</blockquote>
<ul>
<li>灵活，可以快速创建出想要的语法</li>
<li>强大的、现代的并发库</li>
<li>占用空间小，但功能强大且灵活，应用在嵌入式领域</li>
<li>语法简洁，灵活</li>
</ul>
<blockquote>
<p>劣势</p>
</blockquote>
<ul>
<li>社区规模小</li>
<li>单线程性能较差</li>
</ul>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://iolanguage.org/" target="_blank" rel="external">官方网站</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>原型语言我接触得其实非常少，Io 和 JavaScript/Lua 一样，每个对象都是另一个对象的复制品。这部分暂时我的兴趣不是特别大，所以简要记录一下，以后有兴趣再学。</p>]]>
    
    </summary>
    
      <category term="Io" scheme="http://wdxtub.com/tags/Io/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="语言" scheme="http://wdxtub.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聪明人的枷锁]]></title>
    <link href="http://wdxtub.com/2016/03/31/smart-lock/"/>
    <id>http://wdxtub.com/2016/03/31/smart-lock/</id>
    <published>2016-03-31T18:31:02.000Z</published>
    <updated>2016-04-01T04:23:31.000Z</updated>
    <content type="html"><![CDATA[<p>小聪明到大智慧之间，有一条看不见的横沟，只能用天赋、坚持和勤奋来填。如果硬要说有技巧，恐怕就是『元学习』、『元思考』、『元实践』和『元创造』。</p>
<a id="more"></a>
<hr>
<h2 id="u806A_u660E_u4E86_u5417_uFF1F"><a href="#u806A_u660E_u4E86_u5417_uFF1F" class="headerlink" title="聪明了吗？"></a>聪明了吗？</h2><p>聪明固然是一件好事，但是一旦被别人被自己贴上了『聪明人』的标签，也就戴上了枷锁。外在的枷锁随着时间的推移逐渐会被移去，但是内在的枷锁，想要解开，就没那么容易了。</p>
<p>内在的枷锁主要体现在以下两个方面：</p>
<ol>
<li>做事情凭借直觉，大多数情况下都能完成得不错。可是直觉也有范围，一旦超出，因为平时没有培养正确做事的能力，往往不尽如人意。</li>
<li>做事情依赖个人，在学生时代作业考试甚至是小组项目都可以自己扛，可是个人能力再大也有范围，一旦超出，因为平时没有培养合作的能力，常常功亏一篑。</li>
</ol>
<p>直觉是可以培养的，合作是可以学习的。小聪明若是想要转变为大智慧，得利用自己的聪明，用不依赖聪明的方法，在正确做事的前提下，扩大自己的直觉范围，优化自己的合作机制。</p>
<p>遗憾的是，市面上大部分的书，到这里就结束了，剩下的不是猛灌鸡汤，就是列举一堆『看起来有用但是实际没用』的技巧，基本属于作者自己都没想明白就出来忽悠。</p>
<p>这篇文章想说的就是各类畅销书没说清楚的东西：</p>
<ol>
<li>正确学习的方法</li>
<li>正确思考的方法</li>
<li>正确实践的方法</li>
<li>正确创造的方法</li>
</ol>
<p>就像大贤得出世再入世一样，想要成为『大智慧』，首先得有点『小聪明』。注意，这里的『小聪明』和大家通常理解的不一样，指的是相对于『大』智慧的『小』聪明，而不是原来略带贬义的意思。成为『小聪明』的第一步，就是认清自己的思维模式，要想以聪明的方式思考问题，就得善用自己的长处，认识并完善自己的弱点。</p>
<p>另外正如《穷查理宝典》中所说的那样：『我们必须掌握许多知识，让它们在头脑中形成一个思维框架，在随后的日子里能自动地运用它们。与之相反，如果不努力去实践这种跨科学的方法，许多最聪明的人只会取得中等成就，甚至生活在阴影中』。</p>
<h2 id="u6B63_u786E_u5B66_u4E60"><a href="#u6B63_u786E_u5B66_u4E60" class="headerlink" title="正确学习"></a>正确学习</h2><blockquote>
<p>Data is not information. Information is not knowledge. Knowledge is not expertise. Expertise is not execution.</p>
</blockquote>
<p>广义来说，所有的学习都是自学，毕竟没有任何一种科技可以直接把知识『灌输』到我们脑中，即使有老师，我们仍然需要自己去学习。当我仔细审视『自学能力』的时候，发现有以下几个重要的组成部分：</p>
<ul>
<li>阅读能力 - 基础技能 <ul>
<li>广泛阅读，略读结合精读</li>
</ul>
</li>
<li>理解能力 - 在阅读能力基础上的初级技能<ul>
<li>提取核心思想，按照章节逻辑堆阅读进行总结</li>
</ul>
</li>
<li>检索能力 - 在理解能力基础上的中级技能<ul>
<li>围绕核心思想，寻找相关材料，从多方面看问题</li>
</ul>
</li>
<li>写作能力 - 由输入到输出的重要技能<ul>
<li>写作实际上是一个思考的过程。把思维中的想法用文字写下来，本身就是一个整理、分类的过程</li>
</ul>
</li>
<li>思考能力 - 在写作能力基础上的高级技能<ul>
<li>勤于琢磨思考该事情的目标、实质、意义，而后再据此去思考做好这件事情的方法，并挖掘出更深层次的意义</li>
</ul>
</li>
<li>实践能力 - 把学习转化为价值的核心技能<ul>
<li>能够举一反三，能把所学应用于实践，并根据实际情况调整前进的方向</li>
</ul>
</li>
</ul>
<p>一定要脱离『学霸/学渣』的思维定式。学校的教育体系本来就是有缺陷的，我们需要做的就是通过自学能力，去弥补那些自己感兴趣但学校从未教授的东西。这样看来，我们应该成为『沙盒游戏』中的『自由探索者』，不要限定自己的角色，也不要被学校、专业所限制。多学科视角的思考方法能产生某种「共奏效应」，发现原本无法发现的深度见解。</p>
<p>学习关于学习本身的知识，就是元学习。</p>
<h2 id="u6B63_u786E_u601D_u8003"><a href="#u6B63_u786E_u601D_u8003" class="headerlink" title="正确思考"></a>正确思考</h2><blockquote>
<p>So avoid the temptation to master all the skills you need before taking on a challenge. </p>
</blockquote>
<p>应试教育，或者说以考试制度为核心的教育体系中，学生会自然而然被灌输『标准答案』的概念，写对有分写错没分，每个问题对应一个标准答案就被植入到我们的脑中。小聪明可能可以每次都填上标准答案，但大智慧会以标准答案为起点，开始探索的旅程。</p>
<p>差异在哪里？在于『思考无固定答案』的习惯。把纸上的问题映射到现实问题中，培养独立思考的能力，得到自己的答案。这里有一点需要强调，就是『独立』。思考时不要依靠网络，毕竟思考是思考，搜索是搜索。如果总是依赖网络，一旦遇到搜不出来的情况，就很难找到解决办法了。</p>
<p>当然，在有了自己的思考之后，还是需要借助搜索的力量，更加全面地看待问题。这个过程中千万不能『囫囵吞枣』，信息需要经过考虑、推敲后才能转化为想法。不同人看待同样的信息角度不同，得出的结论也不同，相信自己的判断，确认信息，独立思考，不能偷懒。我们还需要时刻拥抱不确定性，越是不习惯，越是要让自己站在正反两面去思考分析问题。</p>
<p>思考的时候一定要有的放矢，意识流看起来很美，但是不利于交流，思考的输出应当是他人容易重视、记住和接受的，也就是要有：</p>
<ul>
<li>逻辑推理能力 - 论点分解或总结</li>
<li>时间管理能力 - 区分优先性</li>
<li>交流能力 - 加强说服力</li>
</ul>
<p>至于思考的结果是对是错，反而不是重要的。一旦出现错误时，要学会追踪当初的思维轨迹，找到哪里出了差错，经验——错误的归纳模式是人类最根本也最可靠的学习方法。</p>
<p>思考关于思考本身的东西，就是元思考。</p>
<h2 id="u6B63_u786E_u5B9E_u8DF5"><a href="#u6B63_u786E_u5B9E_u8DF5" class="headerlink" title="正确实践"></a>正确实践</h2><blockquote>
<p>Whenever you can, as long as the water’s not too far over your head, just jump in, and figure it out as you go.</p>
</blockquote>
<p>知行合一，可能是正确实践的终极奥义。在实践的过程中，一定要时不时问自己下面几个问题：</p>
<ul>
<li>正在解决的问题是我需要解决的问题吗？<ul>
<li>沿着正确的方向前行通常并不会花很多时间，方向不清的情况下走冤枉路却是白费工夫</li>
</ul>
</li>
<li>为什么要这样做，这是最好的方式吗？<ul>
<li>实践过程中会出各种小差错，要从这些差错中学习并提高实践能力</li>
</ul>
</li>
<li>能不能利用前辈的经验减少重复劳动？<ul>
<li>太阳底下没有新鲜事，很多经验是共同的</li>
</ul>
</li>
<li>可能会遇到什么困难，对应的尝试思路是什么？<ul>
<li>遇到困难的时候已经有了准备，就不会慌乱</li>
</ul>
</li>
<li>信息流动顺畅吗？是不是团队的每个成员都真正参与了进来？<ul>
<li>让每个人都清楚明白，就是流程的『可视化』，能让工作更简洁、更有效率</li>
</ul>
</li>
</ul>
<p>实践是学习和思考的演戏场，前面提到的各种能力和技巧，都可以运用到实践中来。当我们遇到问题时，最高效的做法是：</p>
<ol>
<li>认识问题。思考问题背后的东西，背景、事物、条件、关系。通过重新定义问题本身来探索问题的本质。</li>
<li>独立思考。先不借助书本和网络，大胆假设，小心求证。试错的目的就是从中得到意外的收获。现实不比理论，遇到的问题往往具体而特殊，几乎没有什么现成的经验，还是那句话：主动思考大胆假设小心求证。书本和网络的资料可能会给人启发，但是也是枷锁，框住想象力。</li>
<li>全面观测。这个时候可以在书本或网络中找寻相关内容，可能的话尽量与他人交换想法。认知本身就是主观的，横看成岭侧成峰，要全面观测，才能得到更接近『真实』的认知。也就是主观的客观化。</li>
<li>形成框架。简单来说，就是要有自己的『套路』，不同类型的问题有不同的解法，通过具体的实践不断迭代优化自己的理论与套路。</li>
<li>魔鬼细节。仰望星空同时也要脚踏实地，实践难免把手弄脏，但也只有把手弄脏才能得到完备的解决方案，继而解决复杂的现实问题。</li>
<li>每次处理问题请重复上述步骤</li>
</ol>
<p>实践是问题导向的，不能为了做而做，面对动态世界的复杂系统，只有以未知作为起点进行思考，才可能拨开迷雾找到答案。</p>
<p>实践关于实践本身的东西，就是元实践。</p>
<h2 id="u6B63_u786E_u521B_u9020"><a href="#u6B63_u786E_u521B_u9020" class="headerlink" title="正确创造"></a>正确创造</h2><blockquote>
<p>The purpose of education is to provide you the toolsets that enable you take the data around you, make sense out of it and find out a way to create something productive out of that. As the amount of data around us explode, the necessity for education grows.</p>
</blockquote>
<p>创造性这个东西，说流淌在血液中一点也不为过。我们骨子里传下来的智慧、毅力、勤勉、奋发当然不能丢，但是更应该再来点浪漫主义，从超越功利的角度找回精神自主性，每个人都要是特立独行的个体，而不是流水线生产出来的千人一面脸谱化。</p>
<p>多元化的生活态度与人生哲学，对生活本身的富于诗情的理解，才能真正让自己『立体』，有广度也有深度，才能创造出更多新东西，而不是循规蹈矩墨守成规。</p>
<p>『当幸福来敲门』这个翻译我觉得特别好，很多东西不是去找就能找得到的，而是把该做好的都做好，然后静静等待那个时刻的到来。创造就是如此，尤其是下面提到的『酝酿』阶段，就是『当创意来敲门』。但是需要注意的是，不同阶段有不同的侧重点：</p>
<ul>
<li>准备阶段。搜集相关信息，缩小问题范围，直到看到障碍</li>
<li>酝酿阶段。将自己完全浸在问题里，运用潜意识思考，不要有寻找解决方案的压力</li>
<li>启发阶段。用直觉或有意识的思考处理问题，用直觉或洞察力来形成可能的解决方案</li>
<li>验证阶段。对可能的解决方案进行合理性检验，验证方案的正确性，并最终打磨完整</li>
</ul>
<p>创造关于创造本身的东西，就是元创造。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>Heroes inspire us for many reasons: they make tough decisions, they keep going and they get done what matters. But there’s another reason we love our heroes. Inside us all, we know we have the power to become one ourselves.</p>
</blockquote>
<p>英雄人物之所以能激励我们，是因为他们能够作出艰难的抉择，他们永不言弃，他们总能做出惊天动地的事情。但我们之所以崇拜英雄还有另一个原因。在内心深处，我们都相信自己有能力成为他们。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>小聪明到大智慧之间，有一条看不见的横沟，只能用天赋、坚持和勤奋来填。如果硬要说有技巧，恐怕就是『元学习』、『元思考』、『元实践』和『元创造』。</p>]]>
    
    </summary>
    
      <category term="创造" scheme="http://wdxtub.com/tags/%E5%88%9B%E9%80%A0/"/>
    
      <category term="感觉" scheme="http://wdxtub.com/tags/%E6%84%9F%E8%A7%89/"/>
    
      <category term="方法" scheme="http://wdxtub.com/tags/%E6%96%B9%E6%B3%95/"/>
    
      <category term="聪明" scheme="http://wdxtub.com/tags/%E8%81%AA%E6%98%8E/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 反思课 5 实时服务测试的策略与思考]]></title>
    <link href="http://wdxtub.com/2016/03/31/cc-rethink-5/"/>
    <id>http://wdxtub.com/2016/03/31/cc-rethink-5/</id>
    <published>2016-03-31T10:02:04.000Z</published>
    <updated>2016-03-31T11:19:15.000Z</updated>
    <content type="html"><![CDATA[<p>昨天我们的 Twitter Analysis Service 采用了新的测试方式，在大约两个半小时的时间内进行各类请求的压力测试，以确保系统能够应对复杂请求。虽然我做的部分表现非常糟糕，但是从中学到了很多东西，知耻而后勇。</p>
<a id="more"></a>
<hr>
<p>总得来说，因为有靠谱的队友（手动重启服务器几十次），整个测试不至于滑铁卢，但是这也暴露了我们在前后端设计处理的各种问题，接下来逐条分析。</p>
<blockquote>
<p>架构设计</p>
</blockquote>
<p>因为整套系统目前有 6 台机器，之前测试的时候使用 1 台前端 + 4 台后端是行得通的。但是因为之前并没有过多留意前后端机器的硬件利用情况（基本凭感觉），所以想当然得觉得后端是瓶颈（对 HBase 的特性不大了解，估计错误）。事实狠狠打了我的脸，前端的 CPU 利用率居高不下（接近满负荷运载）而后端的利用率分布不均（有的节点 60% 的 CPU 使用率，有的节点甚至只有 20%）。</p>
<p>当我意识到这个问题的时候，只能眼睁睁看着唯一的一台前端苦苦支撑，爆内存，和 HBase 的连接断开，每次都只能手动重启服务器（但是因为 CPU 占用满了，重启也需要几分钟）。这极大影响了正确率和吞吐量，最终得到的分数自然少得可怜。</p>
<p>参考其他组的先进经验，前端使用 ELB(负载均衡) + 2 台机器，后端使用 1(master) + 3(slave) 的模式可能是最科学的，这样可以尽可能得减轻前端单机压力。</p>
<blockquote>
<p>硬件监控</p>
</blockquote>
<p>好消息是，在同学的帮助之下，终于意识到了『监控』的重要性。虽然不难（每台机器开着 <code>top</code> 查看使用率即可），但是有没有这个意识就有天壤之别。简单粗暴来说，哪怕只通过 CPU 利用率一个指标，就能大概估计目前的硬件使用情况，可是我之前竟然拍脑袋想当然总觉得硬件不是问题。</p>
<p>这是很好的教训，我要吸取经验。</p>
<p>痛定思痛，至少可以从其他多个角度来利用监控数据：</p>
<ul>
<li>了解不同的监控命令，深入理解不同监控参数的意义，编写脚本抓取重点关注的数据</li>
<li>结合 CPU 利用率 + 内存利用率来优化代码，力求达到充分利用 CPU 以及内存</li>
<li>观察 CPU / 内存 / 网络的相关数据，来确定具体的瓶颈所在，然后对症下药，寻找可能的解决方案</li>
<li>在监控脚本的基础上，可以设定一些阈值，自动化提醒和记录日志（不用自己时刻盯着屏幕了）</li>
<li>提醒内容：CPU / 内存 / 网络满载警报，或者不均衡使用警报等</li>
<li>日志内容：在出现警报的时候，需要记录相关请求，查看日志的时候能够快速掌握上下文</li>
</ul>
<blockquote>
<p>数据统计</p>
</blockquote>
<p>一般来说，不同的 web 服务，用户的请求模式总体来说是有一定规律的。对于 Twitter 数据的分析，就有热门/冷门的用户/hashtag/单词/时间段（比方说有重大事件发生的日子，tweet 的数量可能会更多）</p>
<p>我们应该根据具体的需求，通过统计大致了解数据分布。比方说其中一个请求是返回某用户包含某 hashtag 的 tweet，那么我们最好需要了解哪些用户热门，哪些 hashtag 热门，然后根据这些特点来进行数据库 schema 的设计（就是 rowkey 和 value）以及数据库中不同 region 在不同 regionserver 的平衡。之前的设计方式会导致有些 region 访问次数非常多，有些却非常少，这样就没有充分利用 HBase 的能力。</p>
<p>这部分具体怎么实现还需要通过不断实践来摸索，但是想要获得更好的性能，总是逃不开这步的。</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>这一部分就是压力测试下暴露的代码问题了，主要是以下几点：</p>
<ul>
<li>请求的参数要进行检查，很可能为空。但是写起来的语法很麻烦，这个时候就开始怀念 Swift 中的语法糖了</li>
<li>对于 HBase 1.0 来说，连接池几乎没用，因为共用 HConnection 的 HTableInterface 并不会并行</li>
<li>线程池也不大需要，undertow 框架基本能够处理好，就不要画蛇添足（容易爆内存）</li>
</ul>
<p>最后写三句，从错误中学习比实现 web 服务本身更有意义，这是第二句，第三句也写完了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天我们的 Twitter Analysis Service 采用了新的测试方式，在大约两个半小时的时间内进行各类请求的压力测试，以确保系统能够应对复杂请求。虽然我做的部分表现非常糟糕，但是从中学到了很多东西，知耻而后勇。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="优化" scheme="http://wdxtub.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[tmux 指南]]></title>
    <link href="http://wdxtub.com/2016/03/30/tmux-guide/"/>
    <id>http://wdxtub.com/2016/03/30/tmux-guide/</id>
    <published>2016-03-30T22:55:27.000Z</published>
    <updated>2016-03-31T04:01:21.000Z</updated>
    <content type="html"><![CDATA[<p>今天试用了一下 tmux，发现简直是神器！以前还傻傻不停开窗口，现在一个窗口就可以都搞定啦！</p>
<a id="more"></a>
<hr>
<p>Tmux 简单来说就是终端里的『窗口管理器』，如果我使用终端登录到远程主机并运行前台程序，那么这个窗口等于就被占用了，想要看一下 CPU 的使用率，就得再连接一次。但是如果在远程主机上运行 tmux，那么就可以开启多个控制台（类似于窗口），相当高效，比方说可以像下面这样：</p>
<p><img src="/images/14593788571503.jpg" alt="一个面板监视服务器，一个面板查看硬件状况"></p>
<p>需要注意的是，这里是在我本地使用 tmux，最好在远程主机也安装 tmux，这样就只需要连接一次。</p>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>前面提到的窗口管理只是 tmux 功能的一小部分，另一个很有用的功能就是，连接到远程主机之后，一旦断开，那么当前账户登录的任务就被取消了，但是使用 tmux 可以在断开之后继续工作，下次登录可以查看。其他的功能还有：</p>
<ol>
<li>窗口切换，每个窗口里还可以分割面板</li>
<li>配置方便，可以使用脚本</li>
<li>类似 vim 的双层操作逻辑</li>
<li>复制粘贴缓冲区</li>
</ol>
<p>安装的话也很简单，在 mac 下直接 <code>brew install tmux</code>（前提需要安装 homebrew），ubuntu 下则直接 <code>sudo apt-get install tmux</code></p>
<p>在终端中输入 <code>tmux</code> 就可以打开一个新的 tmux session，tmux 的所有操作必须先使用一个前缀键（默认是 <code>ctrl + b</code>）进入命令模式，或者说进入控制台，就像 vim 中的 esc。</p>
<h2 id="u57FA_u672C_u64CD_u4F5C"><a href="#u57FA_u672C_u64CD_u4F5C" class="headerlink" title="基本操作"></a>基本操作</h2><blockquote>
<p>信息查询</p>
</blockquote>
<ul>
<li><code>tmux list-keys</code> 列出所有可以的快捷键和其运行的 tmux 命令</li>
<li><code>tmux list-commands</code> 列出所有的 tmux 命令及其参数</li>
<li><code>tmux info</code> 流出所有的 session, window, pane, 运行的进程号，等。</li>
</ul>
<blockquote>
<p>窗口控制</p>
</blockquote>
<p>先来看看在 tmux 之外如何进行控制</p>
<ul>
<li>session 会话：session是一个特定的终端组合。输入tmux就可以打开一个新的session<ul>
<li><code>tmux new -s session_name</code> 创建一个叫做 <code>session_name</code> 的 tmux session</li>
<li><code>tmux attach -t session_name</code> 重新开启叫做 <code>session_name</code> 的 tmux session</li>
<li><code>tmux switch -t session_name</code> 转换到叫做 <code>session_name</code> 的 tmux session</li>
<li><code>tmux list-sessions</code> / <code>tmux ls</code> 列出现有的所有 session</li>
<li><code>tmux detach</code> 离开当前开启的 session</li>
</ul>
</li>
<li>window 窗口：session 中可以有不同的 window（但是同时只能看到一个 window）<ul>
<li><code>tmux new-window</code> 创建一个新的 window</li>
<li><code>tmux list-windows</code> </li>
<li><code>tmux select-window -t :0-9</code> 根据索引转到该 window</li>
<li><code>tmux rename-window</code> 重命名当前 window</li>
</ul>
</li>
<li>pane 面板：window 中可以有不同的 pane（可以把 window 分成不同的部分）<ul>
<li><code>tmux split-window</code> 将 window 垂直划分为两个 pane</li>
<li><code>tmux split-window -h</code> 将 window 水平划分为两个 pane</li>
<li><code>tmux swap-pane -[UDLR]</code> 在指定的方向交换 pane</li>
<li><code>tmux select-pane -[UDLR]</code> 在指定的方向选择下一个 pane</li>
</ul>
</li>
</ul>
<p>更常用的是在 tmux 中直接通过默认前缀 <code>ctrl + b</code> 之后输入对应命令来操作，具体如下（这里只列出输入默认前缀之后需要输入的操作）：</p>
<blockquote>
<p>基本操作</p>
</blockquote>
<ul>
<li><code>?</code> 列出所有快捷键；按q返回</li>
<li><code>d</code> 脱离当前会话,可暂时返回Shell界面</li>
<li><code>s</code> 选择并切换会话；在同时开启了多个会话时使用</li>
<li><code>D</code> 选择要脱离的会话；在同时开启了多个会话时使用</li>
<li><code>:</code> 进入命令行模式；此时可输入支持的命令，例如 <code>kill-server</code> 关闭所有tmux会话</li>
<li><code>[</code> 复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q/Esc退出</li>
<li><code>]</code> 进入粘贴模式，粘贴之前复制的内容，按q/Esc退出</li>
<li><code>~</code> 列出提示信息缓存；其中包含了之前tmux返回的各种提示信息</li>
<li><code>t</code> 显示当前的时间</li>
<li><code>ctrl + z</code> 挂起当前会话</li>
</ul>
<blockquote>
<p>窗口操作</p>
</blockquote>
<ul>
<li><code>c</code> 创建新窗口</li>
<li><code>&amp;</code> 关闭当前窗口</li>
<li><code>[0-9]</code> 数字键切换到指定窗口</li>
<li><code>p</code> 切换至上一窗口</li>
<li><code>n</code> 切换至下一窗口</li>
<li><code>l</code> 前后窗口间互相切换</li>
<li><code>w</code> 通过窗口列表切换窗口</li>
<li><code>,</code> 重命名当前窗口，便于识别</li>
<li><code>.</code> 修改当前窗口编号，相当于重新排序</li>
<li><code>f</code> 在所有窗口中查找关键词，便于窗口多了切换</li>
</ul>
<blockquote>
<p>面板操作</p>
</blockquote>
<ul>
<li><code>&quot;</code> 将当前面板上下分屏（我自己改成了 <code>|</code>）</li>
<li><code>%</code> 将当前面板左右分屏（我自己改成了 <code>-</code>）</li>
<li><code>x</code> 关闭当前分屏</li>
<li><code>!</code> 将当前面板置于新窗口,即新建一个窗口,其中仅包含当前面板</li>
<li><code>ctrl+方向键</code> 以1个单元格为单位移动边缘以调整当前面板大小</li>
<li><code>alt+方向键</code> 以5个单元格为单位移动边缘以调整当前面板大小</li>
<li><code>q</code> 显示面板编号</li>
<li><code>o</code> 选择当前窗口中下一个面板</li>
<li><code>方向键</code> 移动光标选择对应面板</li>
<li><code>{</code> 向前置换当前面板</li>
<li><code>}</code> 向后置换当前面板</li>
<li><code>alt+o</code> 逆时针旋转当前窗口的面板</li>
<li><code>ctrl+o</code> 顺时针旋转当前窗口的面板</li>
<li><code>z</code> 最大化当前所在面板</li>
<li><code>page up</code> 向上滚动屏幕，q 退出</li>
<li><code>page down</code> 向下滚动屏幕，q 退出</li>
</ul>
<p>因为 iTerm2 的支持，很多切换的操作可以直接用鼠标进行，非常方便。具体大家可以自己尝试一下。</p>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2><p>我们可以先进行一些简单的配置，修改 <code>~/.tmux.conf</code> 即可，让整个使用更方便。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#<span class="comment">-- base --#</span></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">default</span>-terminal <span class="string">"screen-256color"</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> display-<span class="keyword">time</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> history-<span class="keyword">limit</span> <span class="number">10000</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> base-<span class="keyword">index</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> pane-base-<span class="keyword">index</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> -s escape-<span class="keyword">time</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> mouse <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line">#<span class="comment">-- bindkeys --#</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">split</span> windows <span class="keyword">like</span> vim.  - Note: vim<span class="string">'s definition of a horizontal/vertical split is reversed from tmux'</span>s</span><br><span class="line"></span><br><span class="line">unbind s</span><br><span class="line">bind s <span class="keyword">split</span>-window -v</span><br><span class="line">bind S <span class="keyword">split</span>-window -v -<span class="keyword">l</span> <span class="number">40</span></span><br><span class="line">bind v <span class="keyword">split</span>-window -h</span><br><span class="line">bind V <span class="keyword">split</span>-window -h -<span class="keyword">l</span> <span class="number">120</span></span><br><span class="line"></span><br><span class="line"># navigate panes <span class="keyword">with</span> hjkl</span><br><span class="line">bind h <span class="keyword">select</span>-pane -<span class="keyword">L</span></span><br><span class="line">bind j <span class="keyword">select</span>-pane -<span class="keyword">D</span></span><br><span class="line">bind <span class="keyword">k</span> <span class="keyword">select</span>-pane -U</span><br><span class="line">bind <span class="keyword">l</span> <span class="keyword">select</span>-pane -R</span><br><span class="line"></span><br><span class="line"># <span class="keyword">key</span> bindings <span class="keyword">for</span> horizontal <span class="keyword">and</span> vertical panes</span><br><span class="line">unbind %</span><br><span class="line">bind | <span class="keyword">split</span>-window -h      # 使用|竖屏，方便分屏</span><br><span class="line">unbind <span class="string">'"'</span></span><br><span class="line">bind - <span class="keyword">split</span>-window -v      # 使用-横屏，方便分屏</span><br><span class="line"></span><br><span class="line"># swap panes</span><br><span class="line">bind ^u swapp -U</span><br><span class="line">bind ^<span class="keyword">d</span> swapp -<span class="keyword">D</span></span><br><span class="line"></span><br><span class="line">bind q killp</span><br><span class="line">bind ^<span class="keyword">e</span> <span class="keyword">last</span></span><br><span class="line"></span><br><span class="line">unbind r</span><br><span class="line">bind r <span class="keyword">source</span>-<span class="keyword">file</span> ~/.tmux.conf \;</span> display "Configuration Reloaded!"</span><br><span class="line"></span><br><span class="line">#<span class="comment">-- statusbar --#</span></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-justify centre</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">left</span> <span class="string">"#[fg=red]s#S:w#I.p#P#[default]"</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">right</span> <span class="string">'[#(whoami)#(date +" %m-%d %H:%M ")]'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">left</span>-<span class="keyword">attr</span> bright</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">left</span>-<span class="keyword">length</span> <span class="number">120</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">right</span>-<span class="keyword">length</span> <span class="number">120</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-utf8 <span class="keyword">on</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="built_in">interval</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> visual-activity <span class="keyword">on</span></span><br><span class="line">setw -<span class="keyword">g</span> monitor-activity <span class="keyword">on</span></span><br><span class="line">setw -<span class="keyword">g</span> <span class="keyword">automatic</span>-<span class="keyword">rename</span> <span class="keyword">off</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">default</span> statusbar colors</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-bg colour235 #base02</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-fg colour136 #yellow</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">attr</span> <span class="keyword">default</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">default</span> window title colors</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-fg colour244</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-bg <span class="keyword">default</span></span><br><span class="line">#setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">attr</span> dim</span><br><span class="line"></span><br><span class="line"># active window title colors</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-fg colour166 #orange</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-bg <span class="keyword">default</span></span><br><span class="line">#setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-<span class="keyword">attr</span> bright</span><br><span class="line"></span><br><span class="line"># window title <span class="keyword">string</span> (uses statusbar <span class="keyword">variables</span>)</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">set</span>-titles-<span class="keyword">string</span> <span class="string">'#T'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-justify <span class="string">"centre"</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">format</span> <span class="string">'#I #W'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-<span class="keyword">format</span> <span class="string">' #I #W '</span></span><br><span class="line"></span><br><span class="line"># pane border</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> pane-active-border-fg <span class="string">'#55ff55'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> pane-border-fg <span class="string">'#555555'</span></span><br><span class="line"></span><br><span class="line"># message <span class="built_in">text</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> message-bg colour235 #base02</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> message-fg colour166 #orange</span><br><span class="line"></span><br><span class="line"># pane <span class="built_in">number</span> display</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> display-panes-active-colour colour33 #blue</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> display-panes-colour colour166 #orange</span><br><span class="line"></span><br><span class="line"># clock</span><br><span class="line">setw -<span class="keyword">g</span> clock-<span class="keyword">mode</span>-colour colour64 #green</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 修改进入命令模式按键</span><br><span class="line"># remap prefix <span class="keyword">to</span> Control + a</span><br><span class="line"># <span class="keyword">set</span> -<span class="keyword">g</span> prefix <span class="keyword">C</span>-a</span><br><span class="line"># unbind <span class="keyword">C</span>-b</span><br><span class="line"># bind <span class="keyword">C</span>-a send-prefix</span></span><br></pre></td></tr></table></figure>
<p>最终的效果是</p>
<p><img src="/images/14593965566247.jpg" alt=""></p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://foocoder.com/blog/zhong-duan-huan-jing-zhi-tmux.html/" target="_blank" rel="external">终端环境之tmux</a></li>
<li><a href="http://blog.jeswang.org/blog/2013/06/24/tmux-kuai-su-jiao-cheng/" target="_blank" rel="external">Tmux 快速教程</a></li>
<li><a href="http://kumu-linux.github.io/blog/2013/08/06/tmux/" target="_blank" rel="external">Linux下终端利器tmux</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天试用了一下 tmux，发现简直是神器！以前还傻傻不停开窗口，现在一个窗口就可以都搞定啦！</p>]]>
    
    </summary>
    
      <category term="命令行" scheme="http://wdxtub.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="效率" scheme="http://wdxtub.com/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="窗口" scheme="http://wdxtub.com/tags/%E7%AA%97%E5%8F%A3/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ruby 快速入门]]></title>
    <link href="http://wdxtub.com/2016/03/30/ruby-first-step/"/>
    <id>http://wdxtub.com/2016/03/30/ruby-first-step/</id>
    <published>2016-03-30T13:14:28.000Z</published>
    <updated>2016-04-01T15:07:09.000Z</updated>
    <content type="html"><![CDATA[<p>学编程就好比学有用，再好的理论也不如一头扎下水，扑腾着呼吸新鲜空气管用。这个系列的目的，就是帮助自己跳入水中，这一次我们来学 Ruby。</p>
<a id="more"></a>
<hr>
<p>获得任何新技能的第一步，是先别想着独立解决什么，而是重复一边前人已竟之事，这是最快的方法。每门语言都有自己的一套惯用方法，各有所长，各有所短。通过学习不同的编程语言，你会明白，哪门语言最适宜解决自己当下关注的问题。</p>
<p>精于禅宗的大师会告诉你，拉丁语学得越好，数学也就越好。编程也同样如此。通过研究逻辑式编程或函数式编程，你能领悟到面向对象编程的精华；通过学习汇编语言，你能更透彻地理解函数式编程。</p>
<p>学习新语言的时候，一定要弄清楚以下几个问题：</p>
<ul>
<li>语言的类型模型是什么？<ul>
<li>强类型/弱类型，静态类型/动态类型</li>
<li>类型模型会改变问题的处理方式，控制语言的运行方式</li>
</ul>
</li>
<li>语言的编程范型是什么？<ul>
<li>面向对象、函数式、过程式等等</li>
</ul>
</li>
<li>怎样和语言交互？<ul>
<li>编译、解释</li>
</ul>
</li>
<li>语言的判断结构(decision construct)和核心数据结构是什么？</li>
<li>哪些核心特性让这门语言与众不同？</li>
</ul>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><ul>
<li>由松本行弘(Yukihiro Matsumoto)大约在 1993 年发明</li>
<li>脚本语言、解释型、面向对象、动态类型</li>
</ul>
<p>现在我的机器上安装的 ruby 版本是 2.1，可以使用下面的命令来查询：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -v</span><br><span class="line">ruby <span class="number">2.1</span>.<span class="number">4</span>p265 (<span class="number">2014</span>-<span class="number">10</span>-<span class="number">27</span> revision <span class="number">48166</span>) [x86_64-darwin14.<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>具体的安装不做太多介绍，在<a href="https://www.ruby-lang.org/zh_cn/" target="_blank" rel="external">官方网站</a>查阅不同平台的相关资料即可，下面是一个简单的例子</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> properties = [<span class="string">'good'</span>, <span class="string">'bad'</span>, <span class="string">'clever'</span>, <span class="string">'stupid'</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"good"</span>, <span class="string">"bad"</span>, <span class="string">"clever"</span>, <span class="string">"stupid"</span>]</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> properties.each &#123;|property| puts <span class="string">"I am <span class="subst">#&#123;property&#125;</span>."</span>&#125;</span><br><span class="line"><span class="constant">I</span> am good.</span><br><span class="line"><span class="constant">I</span> am bad.</span><br><span class="line"><span class="constant">I</span> am clever.</span><br><span class="line"><span class="constant">I</span> am stupid.</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"good"</span>, <span class="string">"bad"</span>, <span class="string">"clever"</span>, <span class="string">"stupid"</span>]</span><br></pre></td></tr></table></figure>
<p>留意一下 ruby 是如何进行遍历及值替换的，之后我们也会深入了解。需要注意的是，这种写起来方便的语言，一般来说效率都不会太高。但是开发效率与执行效率常常是鱼与熊掌，很多时候不得不进行选择。</p>
<p>我们再来看一个长一点的例子：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> puts <span class="string">'hello, wdx'</span></span><br><span class="line">hello, wdx</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> friend = <span class="string">'Snake'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Snake"</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> puts <span class="string">"hello, <span class="subst">#&#123;friend&#125;</span>"</span></span><br><span class="line">hello, <span class="constant">Snake</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> friend = <span class="string">'Queit'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Queit"</span></span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> puts <span class="string">"hello, <span class="subst">#&#123;friend&#125;</span>"</span></span><br><span class="line">hello, <span class="constant">Queit</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到以下几点：</p>
<ul>
<li>不用声明变量</li>
<li>每条 ruby 代码都会返回某个值</li>
<li>单引号表示直接解释</li>
<li>双引号包含的字符串会进行字符串替换</li>
</ul>
<h2 id="u7F16_u7A0B_u6A21_u578B"><a href="#u7F16_u7A0B_u6A21_u578B" class="headerlink" title="编程模型"></a>编程模型</h2><p>Ruby 是一门纯面向对象语言。从下面的例子就可以看出来：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="number">233</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">233</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> <span class="number">233</span>.class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">Fixnum</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> <span class="number">233</span> + <span class="number">233</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">466</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> <span class="number">233</span>.methods</span><br><span class="line"><span class="status">=&gt;</span> [<span class="symbol">:to_s</span>, <span class="symbol">:inspect</span>, <span class="symbol">:-@</span>, <span class="symbol">:+</span>, <span class="symbol">:-</span>, <span class="symbol">:*</span>, <span class="symbol">:/</span>, <span class="symbol">:div</span>, <span class="symbol">:%</span>, <span class="symbol">:modulo</span>, <span class="symbol">:divmod</span>, <span class="symbol">:fdiv</span>, <span class="symbol">:**</span>, <span class="symbol">:abs</span>, <span class="symbol">:magnitude</span>, <span class="symbol">:==</span>, <span class="symbol">:===</span>, <span class="symbol">:&lt;=&gt;</span>, <span class="symbol">:&gt;</span>, <span class="symbol">:&gt;=</span>, <span class="symbol">:&lt;</span>, <span class="symbol">:&lt;=</span>, <span class="symbol">:~</span>, <span class="symbol">:&amp;</span>, <span class="symbol">:|</span>, <span class="symbol">:^</span>, <span class="symbol">:[]</span>, <span class="symbol">:&lt;&lt;</span>, <span class="symbol">:&gt;&gt;</span>, <span class="symbol">:to_f</span>, <span class="symbol">:size</span>, <span class="symbol">:bit_length</span>, <span class="symbol">:zero?</span>, <span class="symbol">:odd?</span>, <span class="symbol">:even?</span>, <span class="symbol">:succ</span>, <span class="symbol">:integer?</span>, <span class="symbol">:upto</span>, <span class="symbol">:downto</span>, <span class="symbol">:times</span>, <span class="symbol">:next</span>, <span class="symbol">:pred</span>, <span class="symbol">:chr</span>, <span class="symbol">:ord</span>, <span class="symbol">:to_i</span>, <span class="symbol">:to_int</span>, <span class="symbol">:floor</span>, <span class="symbol">:ceil</span>, <span class="symbol">:truncate</span>, <span class="symbol">:round</span>, <span class="symbol">:gcd</span>, <span class="symbol">:lcm</span>, <span class="symbol">:gcdlcm</span>, <span class="symbol">:numerator</span>, <span class="symbol">:denominator</span>, <span class="symbol">:to_r</span>, <span class="symbol">:rationalize</span>, <span class="symbol">:singleton_method_added</span>, <span class="symbol">:coerce</span>, <span class="symbol">:i</span>, <span class="symbol">:+@</span>, <span class="symbol">:eql?</span>, <span class="symbol">:remainder</span>, <span class="symbol">:real?</span>, <span class="symbol">:nonzero?</span>, <span class="symbol">:step</span>, <span class="symbol">:quo</span>, <span class="symbol">:to_c</span>, <span class="symbol">:real</span>, <span class="symbol">:imaginary</span>, <span class="symbol">:imag</span>, <span class="symbol">:abs2</span>, <span class="symbol">:arg</span>, <span class="symbol">:angle</span>, <span class="symbol">:phase</span>, <span class="symbol">:rectangular</span>, <span class="symbol">:rect</span>, <span class="symbol">:polar</span>, <span class="symbol">:conjugate</span>, <span class="symbol">:conj</span>, <span class="symbol">:between?</span>, <span class="symbol">:nil?</span>, <span class="symbol">:=~</span>, <span class="symbol">:</span>!~, <span class="symbol">:hash</span>, <span class="symbol">:class</span>, <span class="symbol">:singleton_class</span>, <span class="symbol">:clone</span>, <span class="symbol">:dup</span>, <span class="symbol">:taint</span>, <span class="symbol">:tainted?</span>, <span class="symbol">:untaint</span>, <span class="symbol">:untrust</span>, <span class="symbol">:untrusted?</span>, <span class="symbol">:trust</span>, <span class="symbol">:freeze</span>, <span class="symbol">:frozen?</span>, <span class="symbol">:methods</span>, <span class="symbol">:singleton_methods</span>, <span class="symbol">:protected_methods</span>, <span class="symbol">:private_methods</span>, <span class="symbol">:public_methods</span>, <span class="symbol">:instance_variables</span>, <span class="symbol">:instance_variable_get</span>, <span class="symbol">:instance_variable_set</span>, <span class="symbol">:instance_variable_defined?</span>, <span class="symbol">:remove_instance_variable</span>, <span class="symbol">:instance_of?</span>, <span class="symbol">:kind_of?</span>, <span class="symbol">:is_a?</span>, <span class="symbol">:tap</span>, <span class="symbol">:send</span>, <span class="symbol">:public_send</span>, <span class="symbol">:respond_to?</span>, <span class="symbol">:extend</span>, <span class="symbol">:display</span>, <span class="symbol">:method</span>, <span class="symbol">:public_method</span>, <span class="symbol">:singleton_method</span>, <span class="symbol">:define_singleton_method</span>, <span class="symbol">:object_id</span>, <span class="symbol">:to_enum</span>, <span class="symbol">:enum_for</span>, <span class="symbol">:equal?</span>, <span class="symbol">:</span>!, <span class="symbol">:</span>!=, <span class="symbol">:instance_eval</span>, <span class="symbol">:instance_exec</span>, <span class="symbol">:__send__</span>, <span class="symbol">:__id__</span>]</span><br></pre></td></tr></table></figure>
<p>看出来了吗，ruby 中一切皆为对象，比方说数字就是 <code>Fixnum</code> 类型的对象，我们也可以用 <code>.</code> 来调用对象的各种方法。</p>
<blockquote>
<p>判断</p>
</blockquote>
<p>我们同样可以通过例子来研究研究。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> x = <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">4</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> x &lt; <span class="number">5</span></span><br><span class="line"><span class="status">=&gt;</span> true</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> x &lt;= <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> true</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> x &gt; <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> false</span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> false.class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">FalseClass</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> true.class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">TrueClass</span></span><br><span class="line"><span class="prompt">irb(main):007:0&gt;</span> puts <span class="string">'This is false'</span> unless x == <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):008:0&gt;</span> puts <span class="string">'This is true'</span> if x == <span class="number">4</span></span><br><span class="line"><span class="constant">This</span> is <span class="keyword">true</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):009:0&gt;</span> if x == <span class="number">4</span></span><br><span class="line"><span class="prompt">irb(main):010:1&gt;</span>     puts <span class="string">'This is true'</span></span><br><span class="line"><span class="prompt">irb(main):011:1&gt;</span> end</span><br><span class="line"><span class="constant">This</span> is <span class="keyword">true</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):012:0&gt;</span> unless x == <span class="number">4</span></span><br><span class="line"><span class="prompt">irb(main):013:1&gt;</span>    puts <span class="string">'This is false'</span></span><br><span class="line"><span class="prompt">irb(main):014:1&gt;</span> else</span><br><span class="line">irb(main)<span class="symbol">:</span><span class="number">015</span><span class="symbol">:</span><span class="number">1</span>*    puts <span class="string">'This is true'</span></span><br><span class="line"><span class="prompt">irb(main):016:1&gt;</span> end</span><br><span class="line"><span class="constant">This</span> is <span class="keyword">true</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):017:0&gt;</span> puts <span class="string">'This is true'</span> if not true</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):018:0&gt;</span> puts <span class="string">'This is ture'</span> if !true</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>比较什么的和其他语言大同小异，条件判断的话，主要是 <code>if</code> 和 <code>unless</code>（当然 <code>!</code> 和 <code>not</code> 都可以用，但是建议用 <code>unless</code> 比较清晰），在 Ruby 的语法中可以直接一行搞定判断一句，这样至少写起来很清晰。</p>
<p>除了 <code>nil</code> 和 <code>false</code> 之外，其他值都代表 <code>true</code>，注意！0 也是 <code>true</code>！</p>
<p>循环语句可以使用 <code>while</code> 和 <code>until</code>，比较简单，这里直接看例子，需要注意的是，Ruby 中没种对戏那个都有自己的相等的概念，对于数字来说，值相等就是相等。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> x = <span class="number">2</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> x = x + <span class="number">1</span> while x &lt; <span class="number">10</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> x</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">10</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> x = x - <span class="number">1</span> until x == <span class="number">1</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> x</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> while x &lt; <span class="number">10</span></span><br><span class="line"><span class="prompt">irb(main):007:1&gt;</span>   x = x + <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):008:1&gt;</span>   puts x</span><br><span class="line"><span class="prompt">irb(main):009:1&gt;</span> end</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>逻辑运算符和 C++/Java 有少许不同，<code>and</code>(<code>&amp;&amp;</code>) 是逻辑与，<code>or</code>(<code>||</code>) 是逻辑或，都是短路求值的，如果想要整个表达式都执行的话，使用 <code>&amp;</code> 和 <code>|</code> 来比较，具体为</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> true and false</span><br><span class="line"><span class="status">=&gt;</span> false</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> true or false</span><br><span class="line"><span class="status">=&gt;</span> true</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> false &amp;&amp; false</span><br><span class="line"><span class="status">=&gt;</span> false</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> true &amp;&amp; this_will_cause_an_error</span><br><span class="line"><span class="constant">NameError</span><span class="symbol">:</span> undefined local variable <span class="keyword">or</span> method <span class="string">`this_will_cause_an_error' for main:Object</span><br><span class="line">	from (irb):4</span><br><span class="line">	from /usr/local/bin/irb:11:in `</span>&lt;main&gt;<span class="string">'</span><br><span class="line">irb(main):005:0&gt; false &amp;&amp; this_will_not_cause_an_error</span><br><span class="line">=&gt; false</span><br><span class="line">irb(main):006:0&gt; true or this_will_not_cause_an_error</span><br><span class="line">=&gt; true</span><br><span class="line">irb(main):007:0&gt; true || this_will_not_cause_an_error</span><br><span class="line">=&gt; true</span><br><span class="line">irb(main):008:0&gt; true | this_will_cause_an_error</span><br><span class="line">NameError: undefined local variable or method `this_will_cause_an_error'</span> <span class="keyword">for</span> <span class="symbol">main:</span><span class="constant">Object</span></span><br><span class="line">	from (irb)<span class="symbol">:</span><span class="number">8</span></span><br><span class="line">	from /usr/local/bin/<span class="symbol">irb:</span><span class="number">11</span><span class="symbol">:in</span> <span class="string">`&lt;main&gt;'</span><br><span class="line">irb(main):009:0&gt; true | false</span><br><span class="line">=&gt; true</span></span><br></pre></td></tr></table></figure>
<p>基本来说还是一目了然的，这里不再赘述</p>
<blockquote>
<p>鸭子类型</p>
</blockquote>
<p>Ruby 是强类型语言，直到真正执行代码时，才进行类型检查，称为『动态类型』，但是这也带来了一些好处：多个类不必继承自相同父类，就能以相同方式使用，如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> i = <span class="number">0</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> a = [<span class="string">'100'</span>, <span class="number">100.0</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"100"</span>, <span class="number">100.0</span>]</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> while i &lt; <span class="number">2</span></span><br><span class="line"><span class="prompt">irb(main):004:1&gt;</span>   puts a[i].to_i</span><br><span class="line"><span class="prompt">irb(main):005:1&gt;</span>   i = i + <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:1&gt;</span> end</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>这其实就是面向对象设计思想中的重要原则：对接口编码。举个例子，对象若有 <code>push</code> 和 <code>pop</code>，那么就可以当做栈来使用。</p>
<blockquote>
<p>函数</p>
</blockquote>
<p>函数的定义也和简单，并且，函数也是一个对象</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tell_the_truth</span></span></span><br><span class="line">    <span class="keyword">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组</p>
</blockquote>
<p>同样先来看实例</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> animals = [<span class="string">'lions'</span>, <span class="string">'tigers'</span>, <span class="string">'bears'</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>]</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> puts animals</span><br><span class="line">lions</span><br><span class="line">tigers</span><br><span class="line">bears</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> animals[<span class="number">2</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"bears"</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> animals[<span class="number">3</span>]</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> animals[-<span class="number">1</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"bears"</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> animals[<span class="number">0</span>..<span class="number">2</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>]</span><br><span class="line"><span class="prompt">irb(main):007:0&gt;</span> (<span class="number">0</span>..<span class="number">1</span>).class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">Range</span></span><br></pre></td></tr></table></figure>
<p>具体部分比较好明白，唯一需要注意的是 <code>0..1</code> 其实是个对象。另外 <code>[]</code> 是 <code>Array</code> 类的方法，所以 <code>[]</code> 和 <code>[]=</code> 其实是语法糖。想要用的话，必须先在变量里放一个空数组。数组元素不必具有相同类型。</p>
<blockquote>
<p>散列表</p>
</blockquote>
<p>其实就是键值对存储，来看例子</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> numbers = &#123;<span class="number">1</span> =&gt; <span class="string">'one'</span>, <span class="number">2</span> =&gt; <span class="string">'two'</span>&#125;</span><br><span class="line"><span class="status">=&gt;</span> &#123;<span class="number">1</span>=&gt;<span class="string">"one"</span>, <span class="number">2</span>=&gt;<span class="string">"two"</span>&#125;</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> numbers[<span class="number">1</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"one"</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> stuff = &#123;<span class="symbol">:array</span> =&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="symbol">:string</span> =&gt; <span class="string">'Hi, mom!'</span>&#125;</span><br><span class="line"><span class="status">=&gt;</span> &#123;<span class="symbol">:array=&gt;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="symbol">:string=&gt;<span class="string">"Hi, mom!"</span></span>&#125;</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> stuff[<span class="symbol">:string</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Hi, mom!"</span></span><br></pre></td></tr></table></figure>
<p>这里尤其需要注意 <code>stuff</code> 这个散列表，我们使用了 symbol 的概念，就是变量名称前面加个冒号。这样做的意义在于，相同的 symbol 会指向相同的物理对象，比如下面的例子，两次 <code>&#39;string&#39;</code> 的 id 值不一样，但是 <code>:string</code> 的值是一样的</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):005:0&gt;</span> <span class="string">'string'</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">70186296639880</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> <span class="string">'string'</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">70186296271240</span></span><br><span class="line"><span class="prompt">irb(main):007:0&gt;</span> <span class="symbol">:string</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">156648</span></span><br><span class="line"><span class="prompt">irb(main):008:0&gt;</span> <span class="symbol">:string</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">156648</span></span><br></pre></td></tr></table></figure>
<p>散列表的一个应用就是模拟命名参数（就是不同的参数有不同的名字，这样可以根据名字来引用，而不是根据预订好的位置类进行引用），例如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="function"><span class="keyword">def</span> <span class="title">tell_the_truth</span><span class="params">(options=&#123;&#125;)</span></span></span><br><span class="line"><span class="prompt">irb(main):002:1&gt;</span>   if options[<span class="symbol">:profession</span>] == <span class="symbol">:lawyer</span></span><br><span class="line"><span class="prompt">irb(main):003:2&gt;</span>     <span class="string">'oh you are a laywer'</span></span><br><span class="line"><span class="prompt">irb(main):004:2&gt;</span>   else</span><br><span class="line">irb(main)<span class="symbol">:</span><span class="number">005</span><span class="symbol">:</span><span class="number">2</span>*     <span class="string">'who you are'</span></span><br><span class="line"><span class="prompt">irb(main):006:2&gt;</span>   end</span><br><span class="line"><span class="prompt">irb(main):007:1&gt;</span> end</span><br><span class="line"><span class="status">=&gt;</span> <span class="symbol">:tell_the_truth</span></span><br><span class="line"><span class="prompt">irb(main):008:0&gt;</span> tell_the_truth</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"who you are"</span></span><br><span class="line"><span class="prompt">irb(main):009:0&gt;</span> tell_the_truth <span class="symbol">:profession</span> =&gt; <span class="symbol">:lawyer</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"oh you are a laywer"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>options</code> 表示可选参数，如果不传入，默认就是空散列表</li>
<li>散列表用作最后一个参数的时候可以省略大括号</li>
</ul>
<blockquote>
<p>代码块和 yield</p>
</blockquote>
<p>代码块就是匿名函数，可以作为参数传递，比如说</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="number">3</span>.times &#123;puts <span class="string">'great day!'</span>&#125;</span><br><span class="line">great day!</span><br><span class="line">great day!</span><br><span class="line">great day!</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">3</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> animals = [<span class="string">'lions'</span>, <span class="string">'tigers'</span>, <span class="string">'bears'</span>, <span class="string">'rabbits'</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>, <span class="string">"rabbits"</span>]</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> animals.each &#123;|a| puts a&#125;</span><br><span class="line">lions</span><br><span class="line">tigers</span><br><span class="line">bears</span><br><span class="line">rabbits</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>, <span class="string">"rabbits"</span>]</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> animals.each do |a| \</span><br><span class="line">irb(main)<span class="symbol">:</span><span class="number">005</span><span class="symbol">:</span><span class="number">1</span>*                 puts a <span class="keyword">end</span></span><br><span class="line">lions</span><br><span class="line">tigers</span><br><span class="line">bears</span><br><span class="line">rabbits</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>, <span class="string">"rabbits"</span>]</span><br></pre></td></tr></table></figure>
<p>代码块只占一行时用 <code>{ / }</code>，多行的话则使用 <code>do / end</code>。如果我们要实现自己的 <code>times</code> 函数要怎么做呢？其实也很简单，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Fixnum</span></span></span><br><span class="line"><span class="prompt">irb(main):002:1&gt;</span>   <span class="function"><span class="keyword">def</span> <span class="title">my_times</span></span></span><br><span class="line"><span class="prompt">irb(main):003:2&gt;</span>     i = self</span><br><span class="line"><span class="prompt">irb(main):004:2&gt;</span>     while i &gt; <span class="number">0</span></span><br><span class="line"><span class="prompt">irb(main):005:3&gt;</span>       i = i - <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:3&gt;</span>       yield</span><br><span class="line"><span class="prompt">irb(main):007:3&gt;</span>     end</span><br><span class="line"><span class="prompt">irb(main):008:2&gt;</span>   end</span><br><span class="line"><span class="prompt">irb(main):009:1&gt;</span> end</span><br><span class="line"><span class="status">=&gt;</span> <span class="symbol">:my_times</span></span><br><span class="line"><span class="prompt">irb(main):010:0&gt;</span> <span class="number">3</span>.my_times &#123;puts <span class="string">'my own times!'</span>&#125;</span><br><span class="line">my own times!</span><br><span class="line">my own times!</span><br><span class="line">my own times!</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>因为代码块可以作为参数，于是类似于函数指针，可以更加灵活进行调用。</p>
<blockquote>
<p>面向对象</p>
</blockquote>
<p>主要是类和模块，这里设计的知识点比较繁杂，可以自行阅读参考链接中的文档，这里不再赘述</p>
<blockquote>
<p>优劣</p>
</blockquote>
<p>使用 Ruby 可以用一致的方向处理对象，还有各种不同的语法糖，可以有效提高编程的效率，不过这也导致一定的性能损失。另外，ruby 在并发条件下会产生严重问题（资源竞争）</p>
<h2 id="u4E60_u9898"><a href="#u4E60_u9898" class="headerlink" title="习题"></a>习题</h2><blockquote>
<p>替换字符串某一部分</p>
</blockquote>
<p>字符串相关的操作可以在<a href="http://ruby-doc.org/core-2.3.0/String.html" target="_blank" rel="external">这里</a>查看（其他的类也可以通过这种方式来学习）</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> title = <span class="string">"This is DaWang."</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"This is DaWang."</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> title[<span class="number">0</span>,<span class="number">3</span>] = <span class="string">"That"</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"That"</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> title</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Thats is DaWang."</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> title[<span class="number">0</span>,<span class="number">5</span>] = <span class="string">"That"</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"That"</span></span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> title</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"That is DaWang."</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意字符串的位置索引，具体可以试验一下。</p>
<blockquote>
<p>在字符串 <code>Hello, dawang</code> 中，找到 <code>dawang</code> 所在下标 </p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> s = <span class="string">'Hello, dawang'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Hello, dawang"</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> i = s.index(<span class="string">'dawang'</span>)</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>打印名字十次，并输出序号</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> name = <span class="string">'dawang'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"dawang"</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> i = <span class="number">0</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> while i &lt; <span class="number">10</span></span><br><span class="line"><span class="prompt">irb(main):004:1&gt;</span>   puts <span class="string">"<span class="subst">#&#123;i+<span class="number">1</span>&#125;</span> <span class="subst">#&#123;name&#125;</span>"</span></span><br><span class="line"><span class="prompt">irb(main):005:1&gt;</span>   i = i + <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:1&gt;</span> end</span><br><span class="line"><span class="number">1</span> dawang</span><br><span class="line"><span class="number">2</span> dawang</span><br><span class="line"><span class="number">3</span> dawang</span><br><span class="line"><span class="number">4</span> dawang</span><br><span class="line"><span class="number">5</span> dawang</span><br><span class="line"><span class="number">6</span> dawang</span><br><span class="line"><span class="number">7</span> dawang</span><br><span class="line"><span class="number">8</span> dawang</span><br><span class="line"><span class="number">9</span> dawang</span><br><span class="line"><span class="number">10</span> dawang</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从文件运行 Ruby 程序</p>
</blockquote>
<p>类似 python，直接 <code>ruby filename</code> 即可，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [8:47:56]</span></span><br><span class="line">$ cat test.rb</span><br><span class="line">name = <span class="string">'dawang'</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span></span><br><span class="line">    puts <span class="string">"#&#123;i+1&#125; #&#123;name&#125;"</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [8:48:36]</span></span><br><span class="line">$ ruby test.rb</span><br><span class="line"><span class="number">1</span> dawang</span><br><span class="line"><span class="number">2</span> dawang</span><br><span class="line"><span class="number">3</span> dawang</span><br><span class="line"><span class="number">4</span> dawang</span><br><span class="line"><span class="number">5</span> dawang</span><br><span class="line"><span class="number">6</span> dawang</span><br><span class="line"><span class="number">7</span> dawang</span><br><span class="line"><span class="number">8</span> dawang</span><br><span class="line"><span class="number">9</span> dawang</span><br><span class="line"><span class="number">10</span> dawang</span><br></pre></td></tr></table></figure>
<blockquote>
<p>生成一个 0~9 的随机数，让用户猜，并告知结果</p>
</blockquote>
<p>具体可以直接看代码</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [9:07:47]</span></span><br><span class="line"><span class="variable">$ </span>cat test.rb</span><br><span class="line">puts <span class="string">'Please input a number between 0~9: '</span></span><br><span class="line">numstr = gets</span><br><span class="line">num = numstr.to_i(base=<span class="number">10</span>)</span><br><span class="line">puts <span class="string">'Generating random number..'</span></span><br><span class="line">target = rand(<span class="number">10</span>)</span><br><span class="line">puts <span class="string">"The target number is <span class="subst">#&#123;target&#125;</span>"</span></span><br><span class="line"><span class="keyword">if</span> num == target</span><br><span class="line">    puts <span class="string">'You made it!'</span></span><br><span class="line"><span class="keyword">elsif</span> num &lt; target</span><br><span class="line">    puts <span class="string">'Answer Too Small!'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    puts <span class="string">'Answer Too Large!'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [9:07:53]</span></span><br><span class="line"><span class="variable">$ </span>ruby test.rb</span><br><span class="line"><span class="constant">Please</span> input a number between <span class="number">0</span>~<span class="number">9</span><span class="symbol">:</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="constant">Generating</span> random number..</span><br><span class="line"><span class="constant">The</span> target number is <span class="number">6</span></span><br><span class="line"><span class="constant">Answer</span> <span class="constant">Too</span> <span class="constant">Small</span>!</span><br></pre></td></tr></table></figure>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://ruby-doc.org/core-2.3.0/" target="_blank" rel="external">Ruby APi</a></li>
<li><a href="http://ruby-doc.com/docs/ProgrammingRuby/" target="_blank" rel="external">Programming Ruby: The Pragmatic Programmer’s Guide</a></li>
<li><a href="http://www.runoob.com/ruby/ruby-regular-expressions.html" target="_blank" rel="external">Ruby 正则表达式</a></li>
<li><a href="http://www.runoob.com/ruby/ruby-range.html" target="_blank" rel="external">Ruby 区间(range)</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>学编程就好比学有用，再好的理论也不如一头扎下水，扑腾着呼吸新鲜空气管用。这个系列的目的，就是帮助自己跳入水中，这一次我们来学 Ruby。</p>]]>
    
    </summary>
    
      <category term="Ruby" scheme="http://wdxtub.com/tags/Ruby/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="语言" scheme="http://wdxtub.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 习题课 6 设计模式进阶练习]]></title>
    <link href="http://wdxtub.com/2016/03/30/sad-r6/"/>
    <id>http://wdxtub.com/2016/03/30/sad-r6/</id>
    <published>2016-03-30T11:11:03.000Z</published>
    <updated>2016-04-02T20:46:16.000Z</updated>
    <content type="html"><![CDATA[<p>接着上次的练习，这次给出具体场景，来进行设计模式的应用，咱们直接看习题。</p>
<a id="more"></a>
<hr>
<blockquote>
<p>简单来说就是不同等级的领导可以批不同价格的订单，超出了价格范围就需要提交给上一级审批，这个时候用什么设计模式呢？如果具体的限制因素不止价格一个呢？</p>
</blockquote>
<p>顾名思义，直接用『责任链模式』。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DecisionMaker.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DecisionMaker</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> director = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> vp = <span class="number">25000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> president = <span class="number">100000</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">protected</span> string title;</span><br><span class="line">    <span class="comment">// next element in the chain</span></span><br><span class="line">    <span class="keyword">protected</span> DecisionMaker nextDM;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextDM</span><span class="params">(DecisionMaker dm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextDM = dm;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeDecision</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.price &gt; <span class="number">0</span> &amp;&amp; price &lt;= <span class="keyword">this</span>.price)&#123;</span><br><span class="line">            System.out.println(title + <span class="string">"can make the decision for price "</span>  + price);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextDM != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Handle to higher level decision maker"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DirectorDM.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectorDM</span> <span class="keyword">extends</span> <span class="title">DecisionMaker</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectorDM</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VPDM.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VPDM</span> <span class="keyword">extends</span> <span class="title">DecisionMaker</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VPDM</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PresidentDM.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PresidentDM</span> <span class="keyword">extends</span> <span class="title">DecisionMaker</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PresidentDM</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExecutiveMeetingDM</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutiveMeetingDM</span> <span class="keyword">extends</span> <span class="title">DecisionMaker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutiveMeetingDM</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DMDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DMDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DecisionMaker <span class="title">getChainOfDMs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DecisionMaker director = <span class="keyword">new</span> DirectorDM(<span class="number">10000</span>);</span><br><span class="line">        DecisionMaker vp = <span class="keyword">new</span> VPDM(<span class="number">25000</span>);</span><br><span class="line">        DecisionMaker president = <span class="keyword">new</span> PresidentDM(<span class="number">100000</span>);</span><br><span class="line">        <span class="comment">// -1 means infinitive</span></span><br><span class="line">        DecisionMaker exemeet = <span class="keyword">new</span> ExecutiveMeetingDM(-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        director.setNextDM(vp);</span><br><span class="line">        vp.setNextDM(president);</span><br><span class="line">        prsident.setNextDM(exemeet);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> director;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DecisionMaker dmChain = getChainofDMs();</span><br><span class="line">        </span><br><span class="line">        dmChain.makeDecision(<span class="number">5000</span>);</span><br><span class="line">        dmChain.makeDecision(<span class="number">12000</span>);</span><br><span class="line">        dmChain.makeDecision(<span class="number">32000</span>);</span><br><span class="line">        dmChain.makeDecision(<span class="number">302000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>机场一般由塔台统一协调控制，各个飞机之间不会有练习沟通，这里更适合用什么设计模式？</p>
</blockquote>
<p>一般使用中介者模式，用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tower.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Plane plane)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"["</span> + plane.toString() + <span class="string">"] Requested."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Plane.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plane</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String company;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plane</span><span class="params">(String c, String co)</span></span>&#123;</span><br><span class="line">        company = c;</span><br><span class="line">        code = co;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">sendRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Tower.handleRequest(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toSring</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> company + <span class="string">"-"</span> + code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Airport.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Airport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Plane p1 = <span class="keyword">new</span> Plane(<span class="string">"AA"</span>, <span class="string">"1000"</span>);</span><br><span class="line">        Plane p2 = <span class="keyword">new</span> Plane(<span class="string">"Delta"</span>, <span class="string">"2000"</span>);</span><br><span class="line">        </span><br><span class="line">        p1.sendRequest();</span><br><span class="line">        p2.sendRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CPU 的调度算法一般是 Round Robin，什么设计模式比较合适呢？画出类图并写出伪代码。</p>
</blockquote>
<p>（注）这个模式我也不是很确定</p>
<p>前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。</p>
<p>图和伪代码略</p>
<blockquote>
<p>弄一个消息系统，可以广播给所有的订阅者，什么设计模式比较合适呢？画出类图并写出伪代码。</p>
</blockquote>
<p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。</p>
<p>图和伪代码略</p>
<blockquote>
<p>同一个社区的方法除了颜色基本一致，什么设计模式比较合适呢？画出类图并写出伪代码。</p>
</blockquote>
<p>（注）这个模式我也不是很确定</p>
<p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>
<p>图和伪代码略</p>
<blockquote>
<p>给出一个实际生活中使用状态模式的例子</p>
</blockquote>
<p>编译器的词法解析器</p>
<blockquote>
<p>给出一个实际生活中使用状态模式的例子</p>
</blockquote>
<p>JSON 解析器</p>
<blockquote>
<p>给出一个实际生活中使用命令模式的例子</p>
</blockquote>
<p>各种 shell</p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html" target="_blank" rel="external">责任链模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/mediator-pattern.html" target="_blank" rel="external">中介者模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/front-controller-pattern.html" target="_blank" rel="external">前端控制器模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/observer-pattern.html" target="_blank" rel="external">观察者模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/flyweight-pattern.html" target="_blank" rel="external">享元模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/state-pattern.html" target="_blank" rel="external">状态模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/visitor-pattern.html" target="_blank" rel="external">访问者模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/command-pattern.html" target="_blank" rel="external">命令模式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>接着上次的练习，这次给出具体场景，来进行设计模式的应用，咱们直接看习题。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="习题" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 反思课 4 HBase 优化的策略与思考]]></title>
    <link href="http://wdxtub.com/2016/03/29/cc-rethink-4/"/>
    <id>http://wdxtub.com/2016/03/29/cc-rethink-4/</id>
    <published>2016-03-30T00:18:51.000Z</published>
    <updated>2016-03-30T03:44:46.000Z</updated>
    <content type="html"><![CDATA[<p>优化的最大敌人，是反向优化。</p>
<a id="more"></a>
<hr>
<p>这次的小组作业还是挺费事费时的，虽然我也还没有做到满分，但是这两天的一些尝试还是值得记录一下的，也算是给大家提个醒。一个很深的感触：捷径就是把该走的该经历的都过完，想歪门邪道一步登天的，往往都是绕远路。</p>
<h2 id="u6570_u636E_u5904_u7406"><a href="#u6570_u636E_u5904_u7406" class="headerlink" title="数据处理"></a>数据处理</h2><p>这部分的任务可能是这次作业我做得最不好的地方，主要是因为没有在动手前设计好整个流程思路。因为时间紧，没有仔细分析问题和情境，但最终欲速则不达，像无头苍蝇一样试验各种方法出各种差错。盲目乐观和照搬 MySQL 部分的实现思路（我负责 HBase 部分），遇到问题之后依靠『侥幸』而不是『思考』来解决问题，实在是大失水准。</p>
<p>具体来看，主要有：</p>
<ol>
<li>合并数据时候实现算法不细致，用测试集测试的时候没有检查出错误，到最后导入完数据开始部署好了才发现错，每次导入+部署的半个多小时就因为这里的失误而浪费了</li>
<li>处理数据的流程没有事先规划好，遇到错误拆东墙补西墙，最后全部推倒重来才做好，以后不能再这样</li>
<li>没有设计好测试用例，导致每个步骤都不知道自己对不对，依靠『侥幸』写代码肯定要出大问题</li>
</ol>
<p>时间再紧也要谋定而后动，战略偷懒只会导致战术回旋空间变小，最终导致各种『无用功』。</p>
<h2 id="u5E73_u53F0_u9009_u62E9"><a href="#u5E73_u53F0_u9009_u62E9" class="headerlink" title="平台选择"></a>平台选择</h2><p>原先使用 Amazon EMR 来搭建 HBase，主要有几个问题：</p>
<ol>
<li>HBase 版本较低</li>
<li>没办法随时调整参数（虽然后来意识到参数是浮云）</li>
<li>性能糟糕（当然也可能是我不会用）</li>
<li>贵（除了机器本身的费用，EMR 也是要钱的）</li>
</ol>
<p>所以后来选择使用 Cloudera 来搭建自己的 Hadoop 框架平台。因为老师没有给出太多相关的资料，基本上就是一边看着文档，一个坑一个坑踩过来的。虽然没有 Amazon EMR 这么简单粗暴，但是后来看到性能明显提升，也就值得了。总的来说有以下的感觉：</p>
<ol>
<li>配置的过程其实已经尽可能简化了，基本需要手动操作的就是把交换空间设为 0，其他基本都可以在网络界面上完成（Cloudera 做得还是挺不错的，好顶赞）</li>
<li>根据自己的需要选择合适的服务，多的话用不上还占内存</li>
<li>多多利用 Cloudera 的监控表盘可以得到很多有用的信息，据此可以找到瓶颈所在</li>
<li>RegionServer 中 Region 的分布平衡很重要，Region 不能太少也不能太多，没有所谓定值，需要不断测试和优化（实在不行的话，多 split 几次也没啥问题）</li>
<li>很多参数其实不懂具体的含义，对于这种大的平台还是需要仔细研究才能真正把强大的工具用好</li>
<li>Cloudera 已经进行了一定的参数优化，基本上不用改动（尤其是在自己都不知道自己在干嘛的时候）</li>
</ol>
<p>最后就是想要强调监控数据的重要性，如何挑选需要的数据，如何去分析这些数据里面都有门道，要好好学习。</p>
<h2 id="u53C2_u6570_u8BBE_u7F6E"><a href="#u53C2_u6570_u8BBE_u7F6E" class="headerlink" title="参数设置"></a>参数设置</h2><p>忽然想到这么一句话</p>
<blockquote>
<p>按照大多数人数据库设计和代码实现的糟糕程度，根本轮不到拼参数</p>
</blockquote>
<p>像我这样的初学者，往往过分夸大了参数的重要性，只有当系统达到了瓶颈，然后对应去调整相关参数才是有意义的。按照我之前的做法，既不知道问题在哪，更谈不上硬件的充分利用，就盲目根据网上的教程来进行『优化』，所做的基本都是『反向优化』。</p>
<p>所以这个时候搜索相关网页以及请教同学都是非常有帮助的，有了大致的方向会好很多，不然在一无所知的情况下真的很容易病急乱投医。</p>
<p>不同参数的设置一定要弄清楚具体代表什么，什么时候需要改，改了会有什么影响这一系列问题之后，再进行修改测试。</p>
<p>总的来说还是学到不少东西的，以后早些开始，继续努力。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>优化的最大敌人，是反向优化。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="优化" scheme="http://wdxtub.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[范式转移]]></title>
    <link href="http://wdxtub.com/2016/03/27/paradigm-shift/"/>
    <id>http://wdxtub.com/2016/03/27/paradigm-shift/</id>
    <published>2016-03-28T00:18:45.000Z</published>
    <updated>2016-03-28T02:19:32.000Z</updated>
    <content type="html"><![CDATA[<p>所谓范式，是一套非常清晰的概念、思维模式、研究方法、假设和标准。从这些基准出发，我们可以推导演绎出『真理』。但假如有一天，基准改变了，是不是这些『真理』，也就不再『真』了？</p>
<a id="more"></a>
<hr>
<p>前段时间知道了『范式转移』这个概念，感觉很有意思，但是拖着拖着一直到今天才动笔。一是懒，二是最近生活中的一些变化也印证了『范式转移』本身，能够说道说道了。</p>
<p>简单来说，范式转移可以看做是一种根本假设的改变，继而带来翻天覆地的影响。对于我们来说，范式转移更应该接近于『范式升级』，我们要改变的不仅是思维，而是对事物对人情的更准确更基本的认识。</p>
<p>从去年九十月份开始一路面试了半年，了解了许多之前不熟悉的圈子，接触了不同的行业、公司、职位。虽然通过面试官来了解一个公司有些『管中窥豹』，但是至少要比从新闻中得来的要真实。毕竟新闻里说得都是最好的一面，刚入职的话，更可能接触的就是面试官一级的人。大公司选组更像是摇骰子，小公司更多时候是跟着创始人的想法走。我既不想把未来寄托于概率，也不想丢掉太多的自主性，那么正在发展转型期的已经证明自己的公司恐怕是最佳的选择，既可以通过自己的努力主导技术及业务方向，又可以不被各种制度流程所束缚。</p>
<p>从学生向社会人转变，其实就是一个『范式转移』的过程。校园是静态的，成绩、奖项以及几乎固定的同学；只要分数高，很多事儿都不是事儿；社会是动态的，环境、形势一直在变；前行路上难免磕磕碰碰，荣时知辱，逆时知顺。</p>
<p>在选择职业选择公司的时候，重要的是『三观一致』，知道自己的价值，去最能发光发热的地方去。</p>
<blockquote>
<p>一个人的命运，当然要靠自我奋斗，但是也要考虑到历史的行程。</p>
</blockquote>
<p>职业发展一定要从长远的角度思考，慢慢去摸索未来与趋势，顺势而为。俗一点说，在大家都能赚钱的时候才最好赚钱。与人相处，也更应该『职业』一些，以合作为主、待人接物自然（不要凡事都写在脸上），珍惜别人的时间，让身边的人变得更好，从更大的格局去看待问题。</p>
<p>另外，从课程考试向『做成事情』转变，也是重中之重。很多时候，我们是因为没有能力做好手头上的事情，所以才不喜欢。而越是工作做不好的无用之人，就越是会强调自己有多努力。</p>
<p>无论是在学校还是在公司，重要的不是分数的高低还是职位的级别，而是全身心投入，去验证自己的想法。不要专门去做那些证明自己的事情，事实会说明一切。</p>
<p>这也是为什么我决定从 iOS 开发转到后台系统的开发。iOS 实在太火了，各种培训班批量生产学员搞得乌烟瘴气（最近的前端热估计也是这个套路），开发一款基本的应用难度也越来越低。当然，高端人才总是稀缺的，但是有这样的大环境在，又岂能独善其身呢？</p>
<p>做成事情的重点是策略和坚持，而坚持就是最重要的策略。越来越觉得，无论是编程、雕刻还是建筑，都是技术加艺术的结晶，天赋固然重要，但刻苦练习也是不可或缺的。想要做成事情，不把手弄『脏』是不可能的。</p>
<p>于是主题就变成：范式转移了吗？手弄脏了吗？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>所谓范式，是一套非常清晰的概念、思维模式、研究方法、假设和标准。从这些基准出发，我们可以推导演绎出『真理』。但假如有一天，基准改变了，是不是这些『真理』，也就不再『真』了？</p>]]>
    
    </summary>
    
      <category term="改变" scheme="http://wdxtub.com/tags/%E6%94%B9%E5%8F%98/"/>
    
      <category term="范式" scheme="http://wdxtub.com/tags/%E8%8C%83%E5%BC%8F/"/>
    
      <category term="远见" scheme="http://wdxtub.com/tags/%E8%BF%9C%E8%A7%81/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【鸟哥的 Linux 私房菜 - 基础】学习笔记]]></title>
    <link href="http://wdxtub.com/2016/03/26/linux-basic-soup/"/>
    <id>http://wdxtub.com/2016/03/26/linux-basic-soup/</id>
    <published>2016-03-27T01:33:53.000Z</published>
    <updated>2016-03-27T17:20:41.000Z</updated>
    <content type="html"><![CDATA[<p>因为之后更多会涉及后台开发的部分，所以系统学习一下 Linux 还是很有必要的，这里就用《鸟哥的 Linux 私房菜》作为主要的学习材料。不过因为我本身已经有一定基础了，所以这里主要会记录个人觉得比较生疏和重要的地方。</p>
<a id="more"></a>
<hr>
<p>对于计算机的基本了解，可以参考我之前写的『深入理解计算机系统』系列日志。接下来主要是比较零散的知识点，具体可以参见目录。</p>
<h2 id="u5E38_u7528_u6280_u5DE7"><a href="#u5E38_u7528_u6280_u5DE7" class="headerlink" title="常用技巧"></a>常用技巧</h2><ul>
<li>遇到不懂的命令，一定先用 <code>man</code> 命令来了解一下，可以看到详细的介绍<ul>
<li><code>/string</code> 向下搜索 string 这个字符串</li>
<li><code>?string</code> 向上搜索这个字符串</li>
<li>搜索的时候输入 n, N 可以跳到下一个/上一个结果 ，q 可以退出</li>
</ul>
</li>
<li>遇到不懂的命令，可以使用 <code>info</code> 命令来查看<ul>
<li>n（下一个），p（前一个），u（上一层），h（帮助），q（退出）</li>
</ul>
</li>
<li>nano 是非常简单的编辑器，只需要 <code>nano filename</code> 即可，具体的操作会在终端中显示<ul>
<li><code>^</code> 表示 ctrl 按键</li>
</ul>
</li>
<li>改变文件属性与权限的命令<ul>
<li><code>chgrp</code>：改变文件所属群组</li>
<li><code>chown</code>：改变文件拥有者</li>
<li><code>chmod</code>：改变文件权限</li>
</ul>
</li>
<li>目录相关操作<ul>
<li><code>.</code>：代表此层目录</li>
<li><code>..</code>：代表上一层目录</li>
<li><code>-</code>：代表前一个工作目录</li>
<li><code>~</code>：代表“目前使用者身份”所在的主文件夹</li>
<li><code>~account</code>：代表 account 这个使用者的主文件夹（account是个帐号名称）</li>
<li>在所有目录下面都会存在的两个目录，分别是“.”与“..” 分别代表此层与上层目录的意思</li>
<li><code>cd</code>：变化目录</li>
<li><code>pwd</code>：显示目前目录</li>
<li><code>mkdir</code>：创建新目录</li>
<li><code>rmdir</code>：删除一个空的目录</li>
</ul>
</li>
<li>可执行文件路径变量 <code>$PATH</code><ul>
<li>当我们在执行一个指令的时候，举例来说“ls”好了，系统会依照PATH的设置去每个PATH定义的目录下搜寻文件名为ls的可执行文件， 如果在PATH定义的目录中含有多个文件名为ls的可可执行文件，那么先搜寻到的同名指令先被执行！</li>
<li><code>echo $PATH</code> 来查看当前的值</li>
</ul>
</li>
</ul>
<h2 id="u547D_u4EE4_3A_ls_2C_cp_2C_rm_2C_mv"><a href="#u547D_u4EE4_3A_ls_2C_cp_2C_rm_2C_mv" class="headerlink" title="命令: ls, cp, rm, mv"></a>命令: ls, cp, rm, mv</h2><blockquote>
<p>ls 用来查看文件与目录，选项与参数为：</p>
</blockquote>
<ul>
<li><code>-a</code>：全部的文件，连同隐藏文件（ 开头为 . 的文件） 一起列出来（常用）</li>
<li><code>-A</code>：全部的文件，连同隐藏文件，但不包括 . 与 .. 这两个目录</li>
<li><code>-d</code>：仅列出目录本身，而不是列出目录内的文件数据（常用）</li>
<li><code>-f</code>：直接列出结果，而不进行排序 （ls 默认会以文件名排序！）</li>
<li><code>-F</code>：根据文件、目录等信息，给予附加数据结构，例如：<code>*:</code> 代表可可执行文件； <code>/:</code> 代表目录； <code>=:</code> 代表 socket 文件； <code>|:</code> 代表 FIFO 文件；</li>
<li><code>-h</code>：将文件大小以人类较易读的方式（例如 GB, KB 等等）列出来；</li>
<li><code>-i</code>：列出 inode 号码，inode 的意义下一章将会介绍；</li>
<li><code>-l</code>：长数据串行出，包含文件的属性与权限等等数据；（常用）</li>
<li><code>-n</code>：列出 UID 与 GID 而非使用者与群组的名称 （UID与GID会在帐号管理提到！）</li>
<li><code>-r</code>：将排序结果反向输出，例如：原本文件名由小到大，反向则为由大到小；</li>
<li><code>-R</code>：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来；</li>
<li><code>-S</code>：以文件大小大小排序，而不是用文件名排序；</li>
<li><code>-t</code>：依时间排序，而不是用文件名。</li>
<li><code>--color=never</code>：不要依据文件特性给予颜色显示；</li>
<li><code>--color=always</code>：显示颜色</li>
<li><code>--color=auto</code>：让系统自行依据设置来判断是否给予颜色</li>
<li><code>--full-time</code>：以完整时间模式 （包含年、月、日、时、分） 输出</li>
<li><code>--time={atime,ctime}</code>：输出 access 时间或改变权限属性时间 （ctime） 而非内容变更时间 （modification time）</li>
</ul>
<blockquote>
<p>cp 用来复制文件或者创建链接，选项与参数为：</p>
</blockquote>
<ul>
<li><code>-a</code>：相当于 -dr –preserve=all 的意思，至于 dr 请参考下列说明；（常用）</li>
<li><code>-d</code>：若来源文件为链接文件的属性（link file），则复制链接文件属性而非文件本身；</li>
<li><code>-f</code>：为强制（force）的意思，若目标文件已经存在且无法打开，则移除后再尝试一次；</li>
<li><code>-i</code>：若目标文件（destination）已经存在时，在覆盖时会先询问动作的进行（常用）</li>
<li><code>-l</code>：进行硬式链接（hard link）的链接文件创建，而非复制文件本身；</li>
<li><code>-p</code>：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）；</li>
<li><code>-r</code>：递回持续复制，用于目录的复制行为；（常用）</li>
<li><code>-s</code>：复制成为符号链接文件 （symbolic link），亦即“捷径”文件；</li>
<li><code>-u</code>：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制。</li>
<li><code>--preserve=all</code>：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了。最后需要注意的，如果来源文件有两个以上，则最后一个目的文件一定要是“目录”才行！</li>
</ul>
<blockquote>
<p>mv 用来移动文件或者重命名，选项与参数为：</p>
</blockquote>
<ul>
<li><code>-f</code>：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li><code>-i</code>：若目标文件 （destination） 已经存在时，就会询问是否覆盖！</li>
<li><code>-u</code>：若目标文件已经存在，且 source 比较新，才会更新 （update）</li>
</ul>
<blockquote>
<p>rm 用来删除文件，选项与参数为：</p>
</blockquote>
<ul>
<li><code>-f</code>：就是 force 的意思，忽略不存在的文件，不会出现警告讯息；</li>
<li><code>-i</code>：互动模式，在删除前会询问使用者是否动作</li>
<li><code>-r</code>：递回删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
</ul>
<h2 id="u547D_u4EE4_3A_cat_2C_tac_2C_nl_2C_more_2C_less"><a href="#u547D_u4EE4_3A_cat_2C_tac_2C_nl_2C_more_2C_less" class="headerlink" title="命令: cat, tac, nl, more, less"></a>命令: cat, tac, nl, more, less</h2><blockquote>
<p>cat 由第一行开始显示文件内容</p>
</blockquote>
<ul>
<li><code>-A</code>：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li><code>-b</code>：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li><code>-E</code>：将结尾的断行字符 $ 显示出来；</li>
<li><code>-n</code>：打印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li><code>-T</code>：将 [tab] 按键以 ^I 显示出来；</li>
<li><code>-v</code>：列出一些看不出来的特殊字符</li>
</ul>
<blockquote>
<p>tac  从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</p>
</blockquote>
<p>具体的参数和 cat 是一致的，这里不赘述</p>
<blockquote>
<p>nl   显示的时候，顺道输出行号！</p>
</blockquote>
<ul>
<li><code>-b</code>：指定行号指定的方式，主要有两种：<ul>
<li><code>-b a</code>：表示不论是否为空行，也同样列出行号（类似 cat -n）；</li>
<li><code>-b t</code>：如果有空行，空的那一行不要列出行号（默认值）；</li>
</ul>
</li>
<li><code>-n</code>：列出行号表示的方法，主要有三种：<ul>
<li><code>-n ln</code>：行号在屏幕的最左方显示；</li>
<li><code>-n rn</code>：行号在自己字段的最右方显示，且不加 0 ；</li>
<li><code>-n rz</code>：行号在自己字段的最右方显示，且加 0 ；</li>
</ul>
</li>
<li><code>-w</code>：行号字段的占用的字符数。</li>
</ul>
<blockquote>
<p>more 一页一页的显示文件内容，支持的按键有</p>
</blockquote>
<ul>
<li><code>空格</code>：代表向下翻一页；</li>
<li><code>Enter</code>：代表向下翻“一行”；</li>
<li><code>/字串</code>：代表在这个显示的内容当中，向下搜寻“字串”这个关键字；</li>
<li><code>:f</code>：立刻显示出文件名以及目前显示的行数；</li>
<li><code>q</code>：代表立刻离开 more ，不再显示该文件内容。</li>
<li><code>b 或 [ctrl]-b</code>：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<blockquote>
<p>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！支持的按键有</p>
</blockquote>
<ul>
<li><code>空格</code>：向下翻动一页；</li>
<li><code>[pagedown]</code>：向下翻动一页；</li>
<li><code>[pageup]</code>：向上翻动一页；</li>
<li><code>/字串</code>：向下搜寻“字串”的功能；</li>
<li><code>?字串</code>：向上搜寻“字串”的功能；</li>
<li><code>n</code>：重复前一个搜寻 （与 / 或 ? 有关！）</li>
<li><code>N</code>：反向的重复前一个搜寻 （与 / 或 ? 有关！）</li>
<li><code>g</code>：前进到这个数据的第一行去；</li>
<li><code>G</code>：前进到这个数据的最后一行去 （注意大小写）；</li>
<li><code>q</code>：离开 less 这个程序；</li>
</ul>
<p>你是否会觉得 less 使用的画面与环境与 man page 非常的类似呢？没错啦！因为man这个指令就是调用 less 来显示说明文档的内容的！</p>
<h2 id="u547D_u4EE4_3A_head_2C_tail_2C_od_2C_touch"><a href="#u547D_u4EE4_3A_head_2C_tail_2C_od_2C_touch" class="headerlink" title="命令: head, tail, od, touch"></a>命令: head, tail, od, touch</h2><blockquote>
<p>head 只看头几行</p>
</blockquote>
<ul>
<li><code>-n</code>：后面接数字，代表显示几行的意思</li>
<li>另外那个 -n 选项后面的参数较有趣，如果接的是负数，例如上面范例的 -n -100时，代表列前的所有行数， 但不包括后面100行</li>
</ul>
<blockquote>
<p>tail 只看尾巴几行</p>
</blockquote>
<ul>
<li><code>-n</code>：后面接数字，代表显示几行的意思</li>
<li><code>-f</code>：表示持续侦测后面所接的文件名，要等到按下[ctrl]-c才会结束tail的侦测</li>
</ul>
<blockquote>
<p>od 以二进制的方式读取文件内容！</p>
</blockquote>
<ul>
<li><code>-t</code>：后面可以接各种“类型 （TYPE）”的输出，例如：<ul>
<li><code>a</code>：利用默认的字符来输出；</li>
<li><code>c</code>：使用 ASCII 字符来输出</li>
<li><code>d[size]</code>：利用十进制（decimal）来输出数据，每个整数占用 size Bytes ；</li>
<li><code>f[size]</code>：利用浮点数值（floating）来输出数据，每个数占用 size Bytes ；</li>
<li><code>o[size]</code>：利用八进位（octal）来输出数据，每个整数占用 size Bytes ；</li>
<li><code>x[size]</code>：利用十六进制（hexadecimal）来输出数据，每个整数占用 size Bytes ；</li>
</ul>
</li>
</ul>
<blockquote>
<p>touch 修改文件时间或创建新文件</p>
</blockquote>
<p>我们在 ls 这个指令的介绍时，有稍微提到每个文件在linux下面都会记录许多的时间参数， 其实是有三个主要的变动时间，那么三个时间的意义是什么呢？</p>
<ul>
<li>modification time （mtime）：<ul>
<li>当该文件的“内容数据”变更时，就会更新这个时间！内容数据指的是文件的内容，而不是文件的属性或权限喔！</li>
</ul>
</li>
<li>status time （ctime）：<ul>
<li>当该文件的“状态 （status）”改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间啊。</li>
</ul>
</li>
<li>access time （atime）：<ul>
<li>当“该文件的内容被取用”时，就会更新这个读取时间 （access）。举例来说，我们使用 cat 去读取 /etc/man_db.conf ， 就会更新该文件的 atime 了。</li>
</ul>
</li>
</ul>
<p>选项与参数</p>
<ul>
<li><code>-a</code>：仅修订 access time；</li>
<li><code>-c</code>：仅修改文件的时间，若该文件不存在则不创建新文件；</li>
<li><code>-d</code>：后面可以接欲修订的日期而不用目前的日期，也可以使用 –date=”日期或时间”</li>
<li><code>-m</code>：仅修改 mtime ；</li>
<li><code>-t</code>：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]</li>
</ul>
<h2 id="u547D_u4EE4_3A_file_2C_which_2C_whereis_2C_locate/updatedb_2C_find"><a href="#u547D_u4EE4_3A_file_2C_which_2C_whereis_2C_locate/updatedb_2C_find" class="headerlink" title="命令: file, which, whereis, locate/updatedb, find"></a>命令: file, which, whereis, locate/updatedb, find</h2><blockquote>
<p>file 观察文件类型</p>
</blockquote>
<p>如果你想要知道某个文件的基本数据，例如是属于 ASCII 或者是 data 文件，或者是 binary ， 且其中有没有使用到动态函数库 （share library） 等等的信息，就可以利用 file 这个指令来检阅喔！</p>
<blockquote>
<p>which 指令文件名的搜寻 </p>
</blockquote>
<p><code>which [-a] command</code> 选项或参数：</p>
<ul>
<li><code>-a</code>：将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称</li>
</ul>
<blockquote>
<p>whereis 由一些特定的目录中寻找文件文件名</p>
</blockquote>
<p><code>whereis [-bmsu] 文件或目录名</code>  选项或参数：</p>
<ul>
<li><code>-l</code>:可以列出 whereis 会去查询的几个主要目录而已</li>
<li><code>-b</code>:只找 binary 格式的文件</li>
<li><code>-m</code>:只找在说明文档 manual 路径下的文件</li>
<li><code>-s</code>:只找 source 来源文件</li>
<li><code>-u</code>:搜寻不在上述三个项目当中的其他特殊文件</li>
</ul>
<blockquote>
<p>locate 搜索包含指定词的文件</p>
</blockquote>
<p><code>locate [-ir] keyword</code> 选项与参数：</p>
<ul>
<li><code>-i</code>：忽略大小写的差异；</li>
<li><code>-c</code>：不输出文件名，仅计算找到的文件数量</li>
<li><code>-l</code>：仅输出几行的意思，例如输出五行则是 -l 5</li>
<li><code>-S</code>：输出 locate 所使用的数据库文件的相关信息，包括该数据库纪录的文件/目录数量等</li>
<li><code>-r</code>：后面可接正则表达式的显示方式</li>
</ul>
<p>locate 寻找的数据是由“已创建的数据库 /var/lib/mlocate/” 里面的数据所搜寻到的，所以不用直接在去硬盘当中存取数据。那么有什么限制呢？就是因为他是经由数据库来搜寻的，而数据库的创建默认是在每天执行一次 </p>
<p>那能否手动更新数据库哪？当然可以啊！更新 locate 数据库的方法非常简单，直接输入“ updatedb ”就可以了！ updatedb 指令会去读取 /etc/updatedb.conf 这个配置文件的设置，然后再去硬盘里面进行搜寻文件名的动作， 最后就更新整个数据库文件啰！因为 updatedb 会去搜寻硬盘，所以当你执行 updatedb 时，可能会等待数分钟的时间喔！</p>
<blockquote>
<p>find 查找具体文件</p>
</blockquote>
<p><code>find [PATH] [option] [action]</code> 选项与参数：</p>
<ul>
<li>与时间有关的选项：共有 -atime, -ctime 与 -mtime ，以 -mtime 说明<ul>
<li><code>-mtime  n</code>：n 为数字，意义为在 n 天之前的“一天之内”被更动过内容的文件；</li>
<li><code>-mtime +n</code>：列出在 n 天之前（不含 n 天本身）被更动过内容的文件文件名；</li>
<li><code>-mtime -n</code>：列出在 n 天之内（含 n 天本身）被更动过内容的文件文件名。</li>
<li><code>-newer file</code>：file 为一个存在的文件，列出比 file 还要新的文件文件名</li>
</ul>
</li>
<li>与使用者或群组名称有关的参数<ul>
<li><code>-uid n</code>：n 为数字，这个数字是使用者的帐号 ID，亦即 UID ，这个 UID 是记录在 /etc/passwd 里面与帐号名称对应的数字。</li>
<li><code>-gid n</code>：n 为数字，这个数字是群组名称的 ID，亦即 GID，这个 GID 记录在/etc/group</li>
<li><code>-user name</code>：name 为使用者帐号名称喔！例如 dmtsai </li>
<li><code>-group name</code>：name 为群组名称喔，例如 users ；</li>
<li><code>-nouser</code>：寻找文件的拥有者不存在 /etc/passwd 的人！</li>
<li><code>-nogroup</code>：寻找文件的拥有群组不存在于 /etc/group 的文件！</li>
<li>当你自行安装软件时，很可能该软件的属性当中并没有文件拥有者，这是可能的！在这个时候，就可以使用 -nouser 与 -nogroup 搜寻。</li>
</ul>
</li>
<li>与文件权限及名称有关的参数：<ul>
<li><code>-name filename</code>：搜寻文件名称为 filename 的文件；</li>
<li><code>-size [+-]SIZE</code>：搜寻比 SIZE 还要大（+）或小（-）的文件。这个 SIZE 的规格有：<ul>
<li><code>c</code>: 代表 Byte</li>
<li><code>k</code>: 代表 1024Bytes</li>
<li>所以，要找比 50KB 还要大的文件，就是 <code>-size +50k</code></li>
</ul>
</li>
<li><code>-type TYPE</code>：搜寻文件的类型为 TYPE 的，类型主要有：一般正规文件 （f）, 设备文件 （b, c）,目录 （d）, 链接文件 （l）, socket （s）, 及 FIFO （p） 等属性。</li>
<li><code>-perm mode</code>：搜寻文件权限“刚好等于” mode 的文件，这个 mode 为类似 chmod 的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！</li>
<li><code>-perm -mode</code>：搜寻文件权限“必须要全部囊括 mode 的权限”的文件，举例来说，我们要搜寻 <code>-rwxr--r--</code> ，亦即 0744 的文件，使用 <code>-perm -0744</code>，当一个文件的权限为 <code>-rwsr-xr-x</code> ，亦即 4755 时，也会被列出来，因为 <code>-rwsr-xr-x</code> 的属性已经囊括了 <code>-rwxr--r--</code> 的属性了。</li>
<li><code>-perm /mode</code>：搜寻文件权限“包含任一 mode 的权限”的文件，举例来说，我们搜寻 <code>-rwxr-xr-x</code> ，亦即 <code>-perm /755</code> 时，但一个文件属性为 <code>-rw-------</code> 也会被列出来，因为他有 <code>-rw....</code> 的属性存在！</li>
</ul>
</li>
</ul>
<h2 id="u547D_u4EE4_3A_gzip_2C_zcat/zmore/zless/zgrep"><a href="#u547D_u4EE4_3A_gzip_2C_zcat/zmore/zless/zgrep" class="headerlink" title="命令: gzip, zcat/zmore/zless/zgrep"></a>命令: gzip, zcat/zmore/zless/zgrep</h2><p>gzip 可以说是应用度最广的压缩指令了！目前 gzip 可以解开 compress, zip 与 gzip 等软件所压缩的文件。 至于 gzip 所创建的压缩文件为 *.gz 的文件名喔！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip [-cdtv<span class="comment">#] 文件名</span></span><br><span class="line">zcat 文件名.gz</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-c</code>：将压缩的数据输出到屏幕上，可通过数据流重导向来处理；</li>
<li><code>-d</code>：解压缩的参数；</li>
<li><code>-t</code>：可以用来检验一个压缩文件的一致性～看看文件有无错误；</li>
<li><code>-v</code>：可以显示出原文件/压缩文件的压缩比等信息；</li>
<li><code>-#</code>：# 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！默认是 -6</li>
</ul>
<p>当你使用 gzip 进行压缩时，在默认的状态下原本的文件会被压缩成为 .gz 的文件名，原始文件就不再存在了。 </p>
<p>cat/more/less 可以使用不同的方式来读取纯文本文件，那个 zcat/zmore/zless 则可以对应于 cat/more/less 的方式来读取纯文本文件被压缩后的压缩文件！ 由于 gzip 这个压缩指令主要想要用来取代 compress 的，所以不但 compress 的压缩文件可以使用 gzip 来解开，同时 zcat 这个指令可以同时读取 compress 与 gzip 的压缩文件呦！</p>
<h2 id="u547D_u4EE4_3A_bzip2_2C_bzcat/bzmore/bzless/bzgrep"><a href="#u547D_u4EE4_3A_bzip2_2C_bzcat/bzmore/bzless/bzgrep" class="headerlink" title="命令: bzip2, bzcat/bzmore/bzless/bzgrep"></a>命令: bzip2, bzcat/bzmore/bzless/bzgrep</h2><p>若说 gzip 是为了取代 compress 并提供更好的压缩比而成立的，那么 bzip2 则是为了取代 gzip 并提供更佳的压缩比而来的。 bzip2 真是很不错用的东西～这玩意的压缩比竟然比 gzip 还要好～至于 bzip2 的用法几乎与 gzip 相同！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bzip2 [-cdkzv<span class="comment">#] 文件名</span></span><br><span class="line">bzcat 文件名.bz2</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-c</code>：将压缩的过程产生的数据输出到屏幕上！</li>
<li><code>-d</code>：解压缩的参数</li>
<li><code>-k</code>：保留原始文件，而不会删除原始的文件喔！</li>
<li><code>-z</code>：压缩的参数 （默认值，可以不加）</li>
<li><code>-v</code>：可以显示出原文件/压缩文件的压缩比等信息；</li>
<li><code>-#</code>：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！</li>
</ul>
<h2 id="u547D_u4EE4_3A_tar"><a href="#u547D_u4EE4_3A_tar" class="headerlink" title="命令: tar"></a>命令: tar</h2><p>tar 可以将多个目录或文件打包成一个大文件，同时还可以通过 gzip/bzip2/xz 的支持，将该文件同时进行压缩！ 更有趣的是，由于 tar 的使用太广泛了，目前 Windows 的 WinRAR 也支持 .tar.gz 文件名的解压缩呢！</p>
<p>tar 的选项与参数非常的多！我们只讲几个常用的选项，更多选项您可以自行 man tar 查询啰！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar [-z|-j|-J] [cv] [<span class="operator">-f</span> 待创建的新文件名] filename... &lt;==打包与压缩</span><br><span class="line">tar [-z|-j|-J] [tv] [<span class="operator">-f</span> 既有的 tar文件名]             &lt;==察看文件名</span><br><span class="line">tar [-z|-j|-J] [xv] [<span class="operator">-f</span> 既有的 tar文件名] [-C 目录]   &lt;==解压缩</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-c</code>：创建打包文件，可搭配 -v 来察看过程中被打包的文件名（filename）</li>
<li><code>-t</code>：察看打包文件的内容含有哪些文件名，重点在察看“文件名”就是了；</li>
<li><code>-x</code>：解打包或解压缩的功能，可以搭配 -C （大写） 在特定目录解开特别留意的是， -c, -t, -x 不可同时出现在一串指令列中。</li>
<li><code>-z</code>：通过 gzip  的支持进行压缩/解压缩：此时文件名最好为 *.tar.gz</li>
<li><code>-j</code>：通过 bzip2 的支持进行压缩/解压缩：此时文件名最好为 *.tar.bz2</li>
<li><code>-J</code>：通过 xz    的支持进行压缩/解压缩：此时文件名最好为 *.tar.xz 特别留意， -z, -j, -J 不可以同时出现在一串指令列中</li>
<li><code>-v</code>：在压缩/解压缩的过程中，将正在处理的文件名显示出来！</li>
<li><code>-f filename</code>：-f 后面要立刻接要被处理的文件名！建议 -f 单独写一个选项啰！（比较不会忘记）</li>
<li><code>-C 目录</code>：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。</li>
<li><code>-p</code>：保留备份数据的原本权限与属性，常用于备份（-c）重要的配置文件</li>
<li><code>-P</code>：保留绝对路径，亦即允许备份数据中含有根目录存在之意；</li>
<li><code>--exclude=FILE</code>：在压缩的过程中，不要将 FILE 打包！ </li>
</ul>
<p>tar 并不会主动的产生创建的文件名喔！我们要自订啦！ 所以扩展名就显的很重要了！如果不加 <code>[-z|-j|-J]</code> 的话，文件名最好取为 <code>*.tar</code> 即可。如果是 <code>-j</code>选项，代表有 bzip2 的支持，因此文件名最好就取为 <code>*.tar.bz2</code> ，因为 bzip2 会产生 <code>.bz2</code> 的扩展名之故！ 至于如果是加上了 <code>-z</code> 的 gzip 的支持，那文件名最好取为 <code>*.tar.gz</code> 喔！</p>
<p>另外值得一提的是，tar 打包出来的文件有没有进行压缩所得到文件称呼不同喔！ 如果仅是打包而已，就是 <code>tar -cv -f file.tar</code>而已，这个文件我们称呼为 tarfile 。 如果还有进行压缩的支持，例如 <code>tar -jcv -f file.tar.bz2</code> 时，我们就称呼为 tarball （tar 球？）！这只是一个基本的称谓而已，不过很多书籍与网络都会使用到这个 tarball 的名称！所以得要跟您介绍介绍。</p>
<h2 id="u547D_u4EE4_3A_cut_2C_grep"><a href="#u547D_u4EE4_3A_cut_2C_grep" class="headerlink" title="命令: cut, grep"></a>命令: cut, grep</h2><blockquote>
<p>cut</p>
</blockquote>
<p>cut 不就是“切”吗？没错啦！这个指令可以将一段讯息的某一段给他“切”出来～ 处理的讯息是以“行”为单位喔！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cut <span class="operator">-d</span><span class="string">'分隔字符'</span> <span class="operator">-f</span> fields &lt;==用于有特定分隔字符</span><br><span class="line">cut -c 字符区间            &lt;==用于排列整齐的讯息</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-d</code>：后面接分隔字符。与 -f 一起使用；</li>
<li><code>-f</code>：依据 -d 的分隔字符将一段讯息分区成为数段，用 -f 取出第几段的意思；</li>
<li><code>-c</code>：以字符 （characters） 的单位取出固定字符区间；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 PATH 变量取出，我要找出第五个路径。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;PATH&#125;</span> | cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">5</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;PATH&#125;</span> | cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">3</span>,<span class="number">5</span> <span class="comment"># 找第 3 与第 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：将 export 输出的讯息，取得第 12 字符以后的所有字串</span></span><br><span class="line"><span class="built_in">export</span> | cut -c <span class="number">12</span>-</span><br><span class="line"><span class="comment"># 知道怎么回事了吧？用 -c 可以处理比较具有格式的输出数据！</span></span><br><span class="line"><span class="comment"># 我们还可以指定某个范围的值，例如第 12-20 的字符，就是 cut -c 12-20 等等！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：用 last 将显示的登陆者的信息中，仅留下使用者大名</span></span><br><span class="line">last | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 由输出的结果我们可以发现第一个空白分隔的字段代表帐号，所以使用如上指令：</span></span><br><span class="line"><span class="comment"># 但是因为 root   pts/1 之间空格有好几个，并非仅有一个，所以，如果要找出 </span></span><br><span class="line"><span class="comment"># pts/1 其实不能以 cut -d ' ' -f 1,2 喔！输出的结果会不是我们想要的。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>grep</p>
</blockquote>
<p>刚刚的 cut 是将一行讯息当中，取出某部分我们想要的，而 grep 则是分析一行讯息， 若当中有我们所需要的信息，就将该行拿出来～简单的语法是这样的：</p>
<p><code>grep [-acinv] [--color=auto] &#39;搜寻字串&#39; filename</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-a</code>：将 binary 文件以 text 文件的方式搜寻数据</li>
<li><code>-c</code>：计算找到 ‘搜寻字串’ 的次数</li>
<li><code>-i</code>：忽略大小写的不同，所以大小写视为相同</li>
<li><code>-n</code>：顺便输出行号</li>
<li><code>-v</code>：反向选择，亦即显示出没有 ‘搜寻字串’ 内容的那一行！</li>
<li><code>--color=auto</code>：可以将找到的关键字部分加上颜色的显示喔！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 last 当中，有出现 root 的那一行就取出来；</span></span><br><span class="line">last | grep <span class="string">'root'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：与范例一相反，只要没有 root 的就取出！</span></span><br><span class="line">last | grep -v <span class="string">'root'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：在 last 的输出讯息中，只要有 root 就取出，并且仅取第一栏</span></span><br><span class="line">last | grep <span class="string">'root'</span> | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span>1</span><br><span class="line"><span class="comment"># 在取出 root 之后，利用上个指令 cut 的处理，就能够仅取得第一栏啰！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例四：取出 /etc/man_db.conf 内含 MANPATH 的那几行</span></span><br><span class="line">grep --color=auto <span class="string">'MANPATH'</span> /etc/man_db.conf</span><br><span class="line">....（前面省略）....</span><br><span class="line">MANPATH_MAP     /usr/games              /usr/share/man</span><br><span class="line">MANPATH_MAP     /opt/bin                /opt/man</span><br><span class="line">MANPATH_MAP     /opt/sbin               /opt/man</span><br><span class="line"><span class="comment"># 神奇的是，如果加上 --color=auto 的选项，找到的关键字部分会用特殊颜色显示喔！</span></span><br></pre></td></tr></table></figure>
<h2 id="u547D_u4EE4_3A_sort_2C_wc_2C_uniq"><a href="#u547D_u4EE4_3A_sort_2C_wc_2C_uniq" class="headerlink" title="命令: sort, wc, uniq"></a>命令: sort, wc, uniq</h2><blockquote>
<p>sort</p>
</blockquote>
<p>sort 是很有趣的指令，他可以帮我们进行排序，而且可以依据不同的数据型态来排序喔！ 例如数字与文字的排序就不一样。此外，排序的字符与语系的编码有关，因此， 如果您需要排序时，建议使用 <code>LANG=C</code> 来让语系统一，数据排序比较好一些。</p>
<p><code>sort [-fbMnrtuk] [file or stdin]</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-f</code>：忽略大小写的差异，例如 A 与 a 视为编码相同；</li>
<li><code>-b</code>：忽略最前面的空白字符部分；</li>
<li><code>-M</code>：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；</li>
<li><code>-n</code>：使用“纯数字”进行排序（默认是以文字体态来排序的）；</li>
<li><code>-r</code>：反向排序；</li>
<li><code>-u</code>：就是 uniq ，相同的数据中，仅出现一行代表；</li>
<li><code>-t</code>：分隔符号，默认是用 [tab] 键来分隔；</li>
<li><code>-k</code>：以那个区间 （field） 来进行排序的意思</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：个人帐号都记录在 /etc/passwd 下，请将帐号进行排序。</span></span><br><span class="line">cat /etc/passwd | sort</span><br><span class="line"></span><br><span class="line">abrt:x:<span class="number">173</span>:<span class="number">173</span>::/etc/abrt:/sbin/nologin</span><br><span class="line">adm:x:<span class="number">3</span>:<span class="number">4</span>:adm:/var/adm:/sbin/nologin</span><br><span class="line">alex:x:<span class="number">1001</span>:<span class="number">1002</span>::/home/alex:/bin/bash</span><br><span class="line"><span class="comment"># 鸟哥省略很多的输出～由上面的数据看起来， sort 是默认“以第一个”数据来排序，</span></span><br><span class="line"><span class="comment"># 而且默认是以“文字”型态来排序的喔！所以由 a 开始排到最后啰！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：/etc/passwd 内容是以 : 来分隔的，我想以第三栏来排序，该如何？</span></span><br><span class="line">cat /etc/passwd | sort -t <span class="string">':'</span> -k <span class="number">3</span></span><br><span class="line"></span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">dmtsai:x:<span class="number">1000</span>:<span class="number">1000</span>:dmtsai:/home/dmtsai:/bin/bash</span><br><span class="line">alex:x:<span class="number">1001</span>:<span class="number">1002</span>::/home/alex:/bin/bash</span><br><span class="line">arod:x:<span class="number">1002</span>:<span class="number">1003</span>::/home/arod:/bin/bash</span><br><span class="line"><span class="comment"># 看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～</span></span><br><span class="line"><span class="comment"># 如果是以文字体态来排序的话，原本就会是这样，想要使用数字排序：</span></span><br><span class="line"><span class="comment"># cat /etc/passwd | sort -t ':' -k 3 -n</span></span><br><span class="line"><span class="comment"># 这样才行啊！用那个 -n 来告知 sort 以数字来排序啊！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：利用 last ，将输出的数据仅取帐号，并加以排序</span></span><br><span class="line">last | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span>1 | sort</span><br></pre></td></tr></table></figure>
<blockquote>
<p>wc</p>
</blockquote>
<p>如果我想要知道 /etc/man_db.conf 这个文件里面有多少字？多少行？多少字符的话， 可以怎么做呢？其实可以利用 wc 这个指令来达成喔！他可以帮我们计算输出的讯息的整体数据！</p>
<p><code>wc [-lwm]</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-l</code>：仅列出行；</li>
<li><code>-w</code>：仅列出多少字（英文单字）；</li>
<li><code>-m</code>  ：多少字符；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：那个 /etc/man_db.conf 里面到底有多少相关字、行、字符数？</span></span><br><span class="line">cat /etc/man_db.conf | wc </span><br><span class="line">    <span class="number">131</span>     <span class="number">723</span>    <span class="number">5171</span></span><br><span class="line"><span class="comment"># 输出的三个数字中，分别代表： “行、字数、字符数”</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：我知道使用 last 可以输出登陆者，但是 last 最后两行并非帐号内容，那么请问，我该如何以一行指令串取得登陆系统的总人次？</span></span><br><span class="line">last | grep [a-zA-Z] | grep -v <span class="string">'wtmp'</span> | grep -v <span class="string">'reboot'</span> | \</span><br><span class="line">&gt; grep -v <span class="string">'unknown'</span> |wc <span class="operator">-l</span> </span><br><span class="line"><span class="comment"># 由于 last 会输出空白行, wtmp, unknown, reboot 等无关帐号登陆的信息，因此，我利用</span></span><br><span class="line"><span class="comment"># grep 取出非空白行，以及去除上述关键字那几行，再计算行数，就能够了解啰</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>uniq</p>
</blockquote>
<p>如果我排序完成了，想要将重复的数据仅列出一个显示，可以怎么做呢？</p>
<p><code>uniq [-ic]</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-i</code>：忽略大小写字符的不同；</li>
<li><code>-c</code>：进行计数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：使用 last 将帐号列出，仅取出帐号栏，进行排序后仅取出一位；</span></span><br><span class="line">last | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span>1 | sort | uniq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：承上题，如果我还想要知道每个人的登陆总次数呢？</span></span><br><span class="line">last | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span>1 | sort | uniq -c</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">      <span class="number">6</span> （unknown</span><br><span class="line">     <span class="number">47</span> dmtsai</span><br><span class="line">      <span class="number">4</span> reboot</span><br><span class="line">      <span class="number">7</span> root</span><br><span class="line">      <span class="number">1</span> wtmp</span><br><span class="line"><span class="comment"># 从上面的结果可以发现 reboot 有 4 次， root 登陆则有 7 次！大部分是以 dmtsai 来操作！</span></span><br><span class="line"><span class="comment"># wtmp 与第一行的空白都是 last 的默认字符，那两个可以忽略的！</span></span><br></pre></td></tr></table></figure>
<h2 id="u547D_u4EE4_3A_tee_2C_split_2C_xargs"><a href="#u547D_u4EE4_3A_tee_2C_split_2C_xargs" class="headerlink" title="命令: tee, split, xargs"></a>命令: tee, split, xargs</h2><blockquote>
<p>tee</p>
</blockquote>
<p><img src="/images/14590942194893.jpg" alt="tee 的工作流程示意图"></p>
<p>tee 会同时将数据流分送到文件去与屏幕 （screen）；而输出到屏幕的，其实就是 stdout ，那就可以让下个指令继续处理喔！</p>
<p><code>tee [-a] file</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-a</code>：以累加 （append） 的方式，将数据加入 file 当中！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">last | tee last.list | cut <span class="operator">-d</span> <span class="string">" "</span> <span class="operator">-f</span>1</span><br><span class="line"><span class="comment"># 这个范例可以让我们将 last 的输出存一份到 last.list 文件中；</span></span><br><span class="line"></span><br><span class="line">ls <span class="operator">-l</span> /home | tee ~/homefile | more</span><br><span class="line"><span class="comment"># 这个范例则是将 ls 的数据存一份到 ~/homefile ，同时屏幕也有输出讯息！</span></span><br><span class="line"></span><br><span class="line">ls <span class="operator">-l</span> / | tee <span class="operator">-a</span> ~/homefile | more</span><br><span class="line"><span class="comment"># 要注意！ tee 后接的文件会被覆盖，若加上 -a 这个选项则能将讯息累加。</span></span><br></pre></td></tr></table></figure>
<p>tee 可以让 standard output 转存一份到文件内并将同样的数据继续送到屏幕去处理！ 这样除了可以让我们同时分析一份数据并记录下来之外，还可以作为处理一份数据的中间暂存盘记录之用！</p>
<blockquote>
<p>split 将一个大文件，依据文件大小或行数来分区</p>
</blockquote>
<p><code>split [-bl] file PREFIX</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-b</code>：后面可接欲分区成的文件大小，可加单位，例如 b, k, m 等；</li>
<li><code>-l</code>：以行数来进行分区。</li>
<li><code>PREFIX</code>：代表前置字符的意思，可作为分区文件的前导文字。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：我的 /etc/services 有六百多K，若想要分成 300K 一个文件时？</span></span><br><span class="line"><span class="built_in">cd</span> /tmp; split -b <span class="number">300</span>k /etc/services services</span><br><span class="line">ll -k services*</span><br><span class="line"></span><br><span class="line">-rw-rw-r--. <span class="number">1</span> dmtsai dmtsai <span class="number">307200</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">52</span> servicesaa</span><br><span class="line">-rw-rw-r--. <span class="number">1</span> dmtsai dmtsai <span class="number">307200</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">52</span> servicesab</span><br><span class="line">-rw-rw-r--. <span class="number">1</span> dmtsai dmtsai  <span class="number">55893</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">52</span> servicesac</span><br><span class="line"><span class="comment"># 那个文件名可以随意取的啦！我们只要写上前导文字，小文件就会以</span></span><br><span class="line"><span class="comment"># xxxaa, xxxab, xxxac 等方式来创建小文件的！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：如何将上面的三个小文件合成一个文件，文件名为 servicesback</span></span><br><span class="line">cat services* &gt;&gt; servicesback</span><br><span class="line"><span class="comment"># 很简单吧？就用数据流重导向就好啦！简单！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：使用 ls -al / 输出的信息中，每十行记录成一个文件</span></span><br><span class="line">ls -al / | split <span class="operator">-l</span> <span class="number">10</span> - lsroot</span><br><span class="line">wc <span class="operator">-l</span> lsroot*</span><br><span class="line"></span><br><span class="line">  <span class="number">10</span> lsrootaa</span><br><span class="line">  <span class="number">10</span> lsrootab</span><br><span class="line">   <span class="number">4</span> lsrootac</span><br><span class="line">  <span class="number">24</span> total</span><br><span class="line"><span class="comment"># 重点在那个 - 啦！一般来说，如果需要 stdout/stdin 时，但偏偏又没有文件，</span></span><br><span class="line"><span class="comment"># 有的只是 - 时，那么那个 - 就会被当成 stdin 或 stdout ～</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>xargs 参数代换</p>
</blockquote>
<p>xargs 是在做什么的呢？就以字面上的意义来看， x 是加减乘除的乘号，args 则是 arguments （参数） 的意思，所以说，这个玩意儿就是在产生某个指令的参数的意思！ xargs 可以读入 stdin 的数据，并且以空白字符或断行字符作为分辨，将 stdin 的数据分隔成为 arguments 。 因为是以空白字符作为分隔，所以，如果有一些文件名或者是其他意义的名词内含有空白字符的时候， xargs 可能就会误判了</p>
<p><code>xargs [-0epn] command</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-0</code>：如果输入的 stdin 含有特殊字符，例如 `, \, 空白键等等字符时，这个 -0 参数可以将他还原成一般字符。这个参数可以用于特殊状态喔！</li>
<li><code>-e</code>：这个是 EOF （end of file） 的意思。后面可以接一个字串，当 xargs 分析到这个字串时，就会停止继续工作！</li>
<li><code>-p</code>：在执行每个指令的 argument 时，都会询问使用者的意思；</li>
<li><code>-n</code>：后面接次数，每次 command 指令执行时，要使用几个参数的意思。</li>
<li>当 xargs 后面没有接任何的指令时，默认是以 echo 来进行输出喔！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 /etc/passwd 内的第一栏取出，仅取三行，使用 id 这个指令将每个帐号内容秀出来</span></span><br><span class="line">id root</span><br><span class="line"></span><br><span class="line">uid=<span class="number">0</span>（root） gid=<span class="number">0</span>（root） groups=<span class="number">0</span>（root）   <span class="comment"># 这个 id 指令可以查询使用者的 UID/GID 等信息</span></span><br><span class="line"></span><br><span class="line">id $（cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span>）</span><br><span class="line"><span class="comment"># 虽然使用 $（cmd） 可以预先取得参数，但可惜的是， id 这个指令“仅”能接受一个参数而已！</span></span><br><span class="line"><span class="comment"># 所以上述的这个指令执行会出现错误！根本不会显示用户的 ID 啊！</span></span><br><span class="line"></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | id</span><br><span class="line"></span><br><span class="line">uid=<span class="number">1000</span>（dmtsai） gid=<span class="number">1000</span>（dmtsai） groups=<span class="number">1000</span>（dmtsai）,<span class="number">10</span>（wheel）   <span class="comment"># 我不是要查自己啊！</span></span><br><span class="line"><span class="comment"># 因为 id 并不是管线命令，因此在上面这个指令执行后，前面的东西通通不见！只会执行 id！</span></span><br><span class="line"></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | xargs id</span><br><span class="line"><span class="comment"># 依旧会出现错误！这是因为 xargs 一口气将全部的数据通通丢给 id 处理～但 id 就接受 1 个啊最多！</span></span><br><span class="line"></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | xargs -n <span class="number">1</span> id</span><br><span class="line"></span><br><span class="line">uid=<span class="number">0</span>（root） gid=<span class="number">0</span>（root） groups=<span class="number">0</span>（root）</span><br><span class="line">uid=<span class="number">1</span>（bin） gid=<span class="number">1</span>（bin） groups=<span class="number">1</span>（bin）</span><br><span class="line">uid=<span class="number">2</span>（daemon） gid=<span class="number">2</span>（daemon） groups=<span class="number">2</span>（daemon）</span><br><span class="line"><span class="comment"># 通过 -n 来处理，一次给予一个参数，因此上述的结果就 OK 正常的显示啰！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：同上，但是每次执行 id 时，都要询问使用者是否动作？</span></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | xargs -p -n <span class="number">1</span> id</span><br><span class="line"></span><br><span class="line">id root ?...y</span><br><span class="line">uid=<span class="number">0</span>（root） gid=<span class="number">0</span>（root） groups=<span class="number">0</span>（root）</span><br><span class="line">id bin ?...y</span><br><span class="line">.....（下面省略）.....</span><br><span class="line"><span class="comment"># 呵呵！这个 -p 的选项可以让使用者的使用过程中，被询问到每个指令是否执行！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：将所有的 /etc/passwd 内的帐号都以 id 查阅，但查到 sync 就结束指令串</span></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | xargs <span class="operator">-e</span><span class="string">'sync'</span> -n <span class="number">1</span> id</span><br><span class="line"><span class="comment"># 仔细与上面的案例做比较。也同时注意，那个 -e'sync' 是连在一起的，中间没有空白键</span></span><br><span class="line"><span class="comment"># 上个例子当中，第六个参数是 sync 啊，那么我们下达 -e'sync' 后，则分析到 sync 这个字串时，</span></span><br><span class="line"><span class="comment"># 后面的其他 stdin 的内容就会被 xargs 舍弃掉了！</span></span><br></pre></td></tr></table></figure>
<p>其实，在 man xargs 里面就有三四个小范例，您可以自行参考一下内容。 此外， xargs 真的是很好用的一个玩意儿！您真的需要好好的参详参详！会使用 xargs 的原因是， 很多指令其实并不支持管线命令，因此我们可以通过 xargs 来提供该指令引用 standard input 之用！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例四：找出 /usr/sbin 下面具有特殊权限的文件名，并使用 ls -l 列出详细属性</span></span><br><span class="line">find /usr/sbin -perm /<span class="number">7000</span> | xargs ls <span class="operator">-l</span></span><br><span class="line"></span><br><span class="line">-rwx-<span class="operator">-s</span>--x. <span class="number">1</span> root lock      <span class="number">11208</span> Jun <span class="number">10</span>  <span class="number">2014</span> /usr/sbin/lockdev</span><br><span class="line">-rwsr-xr-x. <span class="number">1</span> root root     <span class="number">113400</span> Mar  <span class="number">6</span> <span class="number">12</span>:<span class="number">17</span> /usr/sbin/mount.nfs</span><br><span class="line">-rwxr-sr-x. <span class="number">1</span> root root      <span class="number">11208</span> Mar  <span class="number">6</span> <span class="number">11</span>:<span class="number">05</span> /usr/sbin/netreport</span><br><span class="line">.....（下面省略）.....</span><br><span class="line"><span class="comment"># 聪明的读者应该会想到使用“ ls -l $（find /usr/sbin -perm /7000） ”来处理这个范例！</span></span><br><span class="line"><span class="comment"># 都 OK！能解决问题的方法，就是好方法！</span></span><br></pre></td></tr></table></figure>
<h2 id="u547D_u4EE4_3A_tr_2C_col_2C_join_2C_paste_2C_expand"><a href="#u547D_u4EE4_3A_tr_2C_col_2C_join_2C_paste_2C_expand" class="headerlink" title="命令: tr, col, join, paste, expand"></a>命令: tr, col, join, paste, expand</h2><blockquote>
<p>tr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换！</p>
</blockquote>
<p><code>tr [-ds] SET1 ...</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-d</code>：删除讯息当中的 SET1 这个字串；</li>
<li><code>-s</code>：取代掉重复的字符！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 last 输出的讯息中，所有的小写变成大写字符：</span></span><br><span class="line">last | tr <span class="string">'[a-z]'</span> <span class="string">'[A-Z]'</span></span><br><span class="line"><span class="comment"># 事实上，没有加上单引号也是可以执行的，如：last | tr [a-z] [A-Z]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：将 /etc/passwd 输出的讯息中，将冒号 （:） 删除</span></span><br><span class="line">cat /etc/passwd | tr <span class="operator">-d</span> <span class="string">':'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：将 /etc/passwd 转存成 dos 断行到 /root/passwd 中，再将 ^M 符号删除</span></span><br><span class="line">cp /etc/passwd ~/passwd &amp;&amp; unix2dos ~/passwd</span><br><span class="line">file /etc/passwd ~/passwd</span><br><span class="line"></span><br><span class="line">/etc/passwd:         ASCII text</span><br><span class="line">/home/dmtsai/passwd: ASCII text, with CRLF line terminators  &lt;==就是 DOS 断行</span><br><span class="line"></span><br><span class="line">cat ~/passwd | tr <span class="operator">-d</span> <span class="string">'\r'</span> &gt; ~/passwd.linux</span><br><span class="line"><span class="comment"># 那个 \r 指的是 DOS 的断行字符，关于更多的字符，请参考 man tr</span></span><br><span class="line">ll /etc/passwd ~/passwd*</span><br><span class="line">-rw-r--r--. <span class="number">1</span> root   root   <span class="number">2092</span> Jun <span class="number">17</span> <span class="number">00</span>:<span class="number">20</span> /etc/passwd</span><br><span class="line">-rw-r--r--. <span class="number">1</span> dmtsai dmtsai <span class="number">2133</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">13</span> /home/dmtsai/passwd</span><br><span class="line">-rw-rw-r--. <span class="number">1</span> dmtsai dmtsai <span class="number">2092</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">13</span> /home/dmtsai/passwd.linux</span><br><span class="line"><span class="comment"># 处理过后，发现文件大小与原本的 /etc/passwd 就一致了！</span></span><br></pre></td></tr></table></figure>
<p>其实这个指令也可以写在“正则表达式”里头！因为他也是由正则表达式的方式来取代数据的！ 以上面的例子来说，使用 [] 可以设置一串字呢！也常常用来取代文件中的怪异符号！ 例如上面第三个例子当中，可以去除 DOS 文件留下来的 <code>^M</code> 这个断行的符号！这东西相当的有用！相信处理 Linux &amp; Windows 系统中的人们最麻烦的一件事就是这个事情啦！亦即是 DOS 下面会自动的在每行行尾加入 <code>^M</code> 这个断行符号！这个时候除了以前讲过的 dos2unix 之外，我们也可以使用这个 tr 来将 <code>^M</code> 去除！ <code>^M</code> 可以使用 <code>\r</code> 来代替之！</p>
<blockquote>
<p>col</p>
</blockquote>
<p><code>col [-xb]</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-x</code>：将 tab 键转换成对等的空白键</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">范例一：利用 cat -A 显示出所有特殊按键，最后以 col 将 [tab] 转成空白</span><br><span class="line"> cat -A /etc/man_db.conf  &lt;==此时会看到很多 ^I 的符号，那就是 tab</span><br><span class="line"> cat /etc/man_db.conf | col -x | cat -A | more</span><br><span class="line"><span class="comment"># 嘿嘿！如此一来， [tab] 按键会被取代成为空白键，输出就美观多了！</span></span><br></pre></td></tr></table></figure>
<p>虽然 col 有他特殊的用途，不过，很多时候，他可以用来简单的处理将 [tab] 按键取代成为空白键！ 例如上面的例子当中，如果使用 cat -A 则 [tab] 会以 <code>^I</code> 来表示。 但经过 col -x 的处理，则会将 [tab] 取代成为对等的空白键！</p>
<blockquote>
<p>join 处理两个文件之间的数据</p>
</blockquote>
<p><code>join [-ti12] file1 file2</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-t</code>：join 默认以空白字符分隔数据，并且比对“第一个字段”的数据，如果两个文件相同，则将两笔数据联成一行，且第一个字段放在第一个</li>
<li><code>-i</code>：忽略大小写的差异；</li>
<li><code>-1</code>：这个是数字的 1 ，代表“第一个文件要用那个字段来分析”的意思；</li>
<li><code>-2</code>：代表“第二个文件要用那个字段来分析”的意思。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：用 root 的身份，将 /etc/passwd 与 /etc/shadow 相关数据整合成一栏</span></span><br><span class="line">head -n <span class="number">3</span> /etc/passwd /etc/shadow</span><br><span class="line">==&gt; /etc/passwd &lt;==</span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin</span><br><span class="line"></span><br><span class="line">==&gt; /etc/shadow &lt;==</span><br><span class="line">root:<span class="variable">$6</span><span class="variable">$wtbCCce</span>/PxMeE5wm<span class="variable">$KE2IfSJr</span>...:<span class="number">16559</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">bin:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">daemon:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line"><span class="comment"># 由输出的数据可以发现这两个文件的最左边字段都是相同帐号！且以 : 分隔</span></span><br><span class="line"></span><br><span class="line">join -t <span class="string">':'</span> /etc/passwd /etc/shadow | head -n <span class="number">3</span></span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash:<span class="variable">$6</span><span class="variable">$wtbCCce</span>/PxMeE5wm<span class="variable">$KE2IfSJr</span>...:<span class="number">16559</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line"><span class="comment"># 通过上面这个动作，我们可以将两个文件第一字段相同者整合成一列！</span></span><br><span class="line"><span class="comment"># 第二个文件的相同字段并不会显示（因为已经在最左边的字段出现了啊！）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：我们知道 /etc/passwd 第四个字段是 GID ，那个 GID 记录在 /etc/group 当中的第三个字段，请问如何将两个文件整合？</span></span><br><span class="line">head -n <span class="number">3</span> /etc/passwd /etc/group</span><br><span class="line">==&gt; /etc/passwd &lt;==</span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin</span><br><span class="line"></span><br><span class="line">==&gt; /etc/group &lt;==</span><br><span class="line">root:x:<span class="number">0</span>:</span><br><span class="line">bin:x:<span class="number">1</span>:</span><br><span class="line">daemon:x:<span class="number">2</span>:</span><br><span class="line"><span class="comment"># 从上面可以看到，确实有相同的部分喔！赶紧来整合一下！</span></span><br><span class="line"></span><br><span class="line">join -t <span class="string">':'</span> -<span class="number">1</span> <span class="number">4</span> /etc/passwd -<span class="number">2</span> <span class="number">3</span> /etc/group | head -n <span class="number">3</span></span><br><span class="line"><span class="number">0</span>:root:x:<span class="number">0</span>:root:/root:/bin/bash:root:x:</span><br><span class="line"><span class="number">1</span>:bin:x:<span class="number">1</span>:bin:/bin:/sbin/nologin:bin:x:</span><br><span class="line"><span class="number">2</span>:daemon:x:<span class="number">2</span>:daemon:/sbin:/sbin/nologin:daemon:x:</span><br><span class="line"><span class="comment"># 同样的，相同的字段部分被移动到最前面了！所以第二个文件的内容就没再显示。</span></span><br><span class="line"><span class="comment"># 请读者们配合上述显示两个文件的实际内容来比对！</span></span><br></pre></td></tr></table></figure>
<p>这个 join 在处理两个相关的数据文件时，就真的是很有帮助的啦！ 例如上面的案例当中，我的 /etc/passwd, /etc/shadow, /etc/group 都是有相关性的， 其中 /etc/passwd, /etc/shadow 以帐号为相关性，至于 /etc/passwd, /etc/group 则以所谓的 GID （帐号的数字定义） 来作为他的相关性。根据这个相关性， 我们可以将有关系的数据放置在一起！这在处理数据可是相当有帮助的！ 但是上面的例子有点难，希望您可以静下心好好的看一看原因喔！</p>
<p>此外，需要特别注意的是，在使用 join 之前，你所需要处理的文件应该要事先经过排序 （sort） 处理！ 否则有些比对的项目会被略过呢！特别注意了！</p>
<blockquote>
<p>paste 直接将两行贴在一起，且中间以 [tab] 键隔开</p>
</blockquote>
<p><code>paste [-d] file1 file2</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-d</code>：后面可以接分隔字符。默认是以 [tab] 来分隔的！</li>
<li><code>-</code>：如果 file 部分写成 - ，表示来自 standard input 的数据的意思。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：用 root 身份，将 /etc/passwd 与 /etc/shadow 同一行贴在一起</span></span><br><span class="line">paste /etc/passwd /etc/shadow</span><br><span class="line"></span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash root:<span class="variable">$6</span><span class="variable">$wtbCCce</span>/PxMeE5wm<span class="variable">$KE2IfSJr</span>...:<span class="number">16559</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin        bin:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin daemon:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line"><span class="comment"># 注意喔！同一行中间是以 [tab] 按键隔开的！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：先将 /etc/group 读出（用 cat），然后与范例一贴上一起！且仅取出前三行</span></span><br><span class="line">cat /etc/group|paste /etc/passwd /etc/shadow - | head -n <span class="number">3</span></span><br><span class="line"><span class="comment"># 这个例子的重点在那个 - 的使用！那玩意儿常常代表 stdin 喔！</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>expand 将 [tab] 按键转成空白键</p>
</blockquote>
<p><code>expand [-t] file</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-t</code>：后面可以接数字。一般来说，一个 tab 按键可以用 8 个空白键取代。我们也可以自行定义一个 [tab] 按键代表多少个字符呢！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 /etc/man_db.conf 内行首为 MANPATH 的字样就取出；仅取前三行；</span></span><br><span class="line">grep <span class="string">'^MANPATH'</span> /etc/man_db.conf | head -n <span class="number">3</span></span><br><span class="line"></span><br><span class="line">MANPATH_MAP     /bin                    /usr/share/man</span><br><span class="line">MANPATH_MAP     /usr/bin                /usr/share/man</span><br><span class="line">MANPATH_MAP     /sbin                   /usr/share/man</span><br><span class="line"><span class="comment"># 行首的代表标志为 ^ ，这个我们留待下节介绍！先有概念即可！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：承上，如果我想要将所有的符号都列出来？（用 cat）</span></span><br><span class="line">grep <span class="string">'^MANPATH'</span> /etc/man_db.conf | head -n <span class="number">3</span> |cat -A</span><br><span class="line"></span><br><span class="line">MANPATH_MAP^I/bin^I^I^I/usr/share/man$</span><br><span class="line">MANPATH_MAP^I/usr/bin^I^I/usr/share/man$</span><br><span class="line">MANPATH_MAP^I/sbin^I^I^I/usr/share/man$</span><br><span class="line"><span class="comment"># 发现差别了吗？没错～ [tab] 按键可以被 cat -A 显示成为 ^I </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：承上，我将 [tab] 按键设置成 6 个字符的话？</span></span><br><span class="line">grep <span class="string">'^MANPATH'</span> /etc/man_db.conf | head -n <span class="number">3</span> | expand -t <span class="number">6</span> - | cat -A</span><br><span class="line"></span><br><span class="line">MANPATH_MAP /bin              /usr/share/man$</span><br><span class="line">MANPATH_MAP /usr/bin          /usr/share/man$</span><br><span class="line">MANPATH_MAP /sbin             /usr/share/man$</span><br><span class="line"><span class="number">123456123456123456123456123456123456123456123456</span>...</span><br><span class="line"><span class="comment"># 仔细看一下上面的数字说明，因为我是以 6 个字符来代表一个 [tab] 的长度，所以，</span></span><br><span class="line"><span class="comment"># MAN... 到 /usr 之间会隔 12 （两个 [tab]） 个字符喔！如果 tab 改成 9 的话，</span></span><br><span class="line"><span class="comment"># 情况就又不同了！这里也不好理解～您可以多设置几个数字来查阅就晓得！</span></span><br></pre></td></tr></table></figure>
<h2 id="vi__u4E0E_vim"><a href="#vi__u4E0E_vim" class="headerlink" title="vi 与 vim"></a>vi 与 vim</h2><p>基本上 vi 共分为三种模式，分别是“一般指令模式”、“编辑模式”与“指令列命令模式”。 这三种模式的作用分别是：</p>
<ul>
<li>一般指令模式 （command mode）<ul>
<li>以 vi 打开一个文件就直接进入一般指令模式了（这是默认的模式，也简称为一般模式）。在这个模式中， 你可以使用“上下左右”按键来移动光标，你可以使用“删除字符”或“删除整列”来处理文件内容， 也可以使用“复制、贴上”来处理你的文件数据。</li>
</ul>
</li>
<li>编辑模式 （insert mode）<ul>
<li>在一般指令模式中可以进行删除、复制、贴上等等的动作，但是却无法编辑文件内容的！ 要等到你按下 <code>i, I, o, O, a, A, r, R</code> 等任何一个字母之后才会进入编辑模式。注意了！通常在 Linux 中，按下这些按键时，在画面的左下方会出现“ INSERT 或 REPLACE ”的字样，此时才可以进行编辑。而如果要回到一般指令模式时， 则必须要按下“Esc”这个按键即可退出编辑模式。</li>
</ul>
</li>
<li>指令列命令模式 （command-line mode）<ul>
<li>在一般模式当中，输入 <code>: / ?</code> 三个中的任何一个按钮，就可以将光标移动到最下面那一列。在这个模式当中， 可以提供你“搜寻数据”的动作，而读取、存盘、大量取代字符、离开 vi 、显示行号等等的动作则是在此模式中达成的！</li>
</ul>
</li>
</ul>
<p><img src="/images/14590796988736.jpg" alt=""></p>
<blockquote>
<p>一般指令模式可用的按钮说明</p>
</blockquote>
<ul>
<li>光标移动<ul>
<li><code>h 或 向左方向键（←）</code>：光标向左移动一个字符</li>
<li><code>j 或 向下方向键（↓）</code>：光标向下移动一个字符</li>
<li><code>k 或 向上方向键（↑）</code>：光标向上移动一个字符</li>
<li><code>l 或 向右方向键（→）</code>：光标向右移动一个字符</li>
<li>如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 列，可以使用 <code>30j</code> 或 <code>30↓</code> 的组合按键， 亦即加上想要进行的次数（数字）后，按下动作即可！</li>
<li><code>[Ctrl] + [f]</code>：屏幕“向下”移动一页，相当于 [Page Down]按键 （常用）</li>
<li><code>[Ctrl] + [b]</code>：屏幕“向上”移动一页，相当于 [Page Up] 按键 （常用）</li>
<li><code>[Ctrl] + [d]</code>：屏幕“向下”移动半页</li>
<li><code>[Ctrl] + [u]</code>：屏幕“向上”移动半页</li>
<li><code>+</code>：光标移动到非空白字符的下一列</li>
<li><code>-</code>：光标移动到非空白字符的上一列</li>
<li><code>n&lt;space&gt;</code>：那个 n 表示“数字”，例如 20 。按下数字后再按空白键，光标会向右移动这一列的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</space></li>
<li><code>0 或功能键[Home]</code>：这是数字“ 0 ”：移动到这一列的最前面字符处 （常用）</li>
<li><code>$ 或功能键[End]</code>：移动到这一列的最后面字符处（常用）</li>
<li><code>H</code>：光标移动到这个屏幕的最上方那一列的第一个字符</li>
<li><code>M</code>：光标移动到这个屏幕的中央那一列的第一个字符</li>
<li><code>L</code>：光标移动到这个屏幕的最下方那一列的第一个字符</li>
<li><code>G</code>：移动到这个文件的最后一列（常用）</li>
<li><code>nG</code>：n 为数字。移动到这个文件的第 n 列。例如 20G 则会移动到这个文件的第 20 列（可配合 <code>:set nu</code>）</li>
<li><code>gg</code>：移动到这个文件的第一列，相当于 1G 啊！ （常用）</li>
<li><code>n&lt;Enter&gt;</code>：n 为数字。光标向下移动 n 列（常用）</li>
</ul>
</li>
<li>复制粘贴<ul>
<li><code>x, X</code>：在一列字当中，x 为向后删除一个字符 （相当于 [del] 按键）， X 为向前删除一个字符（相当于 [backspace] 亦即是倒退键） （常用）</li>
<li><code>nx</code>：n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， “10x”</li>
<li><code>dd</code>：删除光标所在的那一整列（常用）</li>
<li><code>ndd</code>：n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列 （常用）</li>
<li><code>d1G</code>：删除光标所在到第一列的所有数据</li>
<li><code>dG</code>：删除光标所在到最后一列的所有数据</li>
<li><code>d$</code>：删除光标所在处，到该列的最后一个字符</li>
<li><code>d0</code>：那个是数字的 0 ，删除光标所在处，到该列的最前面一个字符</li>
<li><code>yy</code>：复制光标所在的那一列（常用）</li>
<li><code>nyy</code>：n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20 列（常用）</li>
<li><code>y1G</code>：复制光标所在列到第一列的所有数据</li>
<li><code>yG</code>：复制光标所在列到最后一列的所有数据</li>
<li><code>y0</code>：复制光标所在的那个字符到该列行首的所有数据</li>
<li><code>y$</code>：复制光标所在的那个字符到该列行尾的所有数据</li>
<li><code>p, P</code>：p 为将已复制的数据在光标下一列贴上，P 则为贴在光标上一列！ 举例来说，我目前光标在第 20 列，且已经复制了 10 列数据。则按下 p 后， 那 10 列数据会贴在原本的 20 列之后，亦即由 21 列开始贴。但如果是按下 P 呢？ 那么原本的第 20 列会被推到变成 30 列。 （常用）</li>
<li><code>J</code>：将光标所在列与下一列的数据结合成同一列</li>
<li><code>c</code>：重复删除多个数据，例如向下删除 10 列，[ 10cj ]</li>
<li><code>u</code>：复原前一个动作。（常用）</li>
<li><code>[Ctrl]+r</code>：重做上一个动作。（常用）这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</li>
<li><code>.</code>：不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点“.”就好了！ （常用）</li>
</ul>
</li>
<li>搜寻取代<ul>
<li><code>/word</code>：向光标之下寻找一个名称为 word 的字串。例如要在文件内搜寻 vbird 这个字串，就输入 <code>/vbird</code> 即可！ （常用）</li>
<li><code>?word</code>：向光标之上寻找一个字串名称为 word 的字串。</li>
<li><code>n</code>：这个 n 是英文按键。代表“重复前一个搜寻的动作”。举例来说， 如果刚刚我们执行 <code>/vbird</code> 去向下搜寻 vbird 这个字串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字串。如果是执行 <code>?vbird</code> 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字串！</li>
<li><code>N</code>：这个 N 是英文按键。与 n 刚好相反，为“反向”进行前一个搜寻动作。 例如 <code>/vbird</code> 后，按下 N 则表示“向上”搜寻 vbird 。</li>
<li>使用 <code>/word</code> 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键字！</li>
<li><code>:n1,n2s/word1/word2/g</code>：n1 与 n2 为数字。在第 n1 与 n2 列之间寻找 word1 这个字串，并将该字串取代为 word2 ！举例来说，在 100 到 200 列之间搜寻 vbird 并取代为 VBIRD 则：<code>:100,200s/vbird/VBIRD/g</code>（常用）</li>
<li><code>:1,$s/word1/word2/g</code>：从第一列到最后一列寻找 word1 字串，并将该字串取代为 word2 ！（常用）</li>
<li><code>:1,$s/word1/word2/gc</code>：从第一列到最后一列寻找 word1 字串，并将该字串取代为 word2 ！且在取代前显示提示字符给使用者确认 （confirm） 是否需要取代！（常用）</li>
</ul>
</li>
</ul>
<blockquote>
<p>进入插入或取代的编辑模式</p>
</blockquote>
<ul>
<li><code>i, I</code>：进入插入模式（Insert mode）<ul>
<li>i 为“从目前光标所在处插入”， I 为“在目前所在列的第一个非空白字符处开始插入”。 （常用）</li>
</ul>
</li>
<li><code>a, A</code>：进入插入模式（Insert mode）<ul>
<li>a 为“从目前光标所在的下一个字符处开始插入”， A 为“从光标所在列的最后一个字符处开始插入”。（常用）</li>
</ul>
</li>
<li><code>o, O</code>：进入插入模式（Insert mode）<ul>
<li>这是英文字母 o 的大小写。o 为“在目前光标所在的下一列处插入新的一列”； O 为在目前光标所在处的上一列插入新的一列！（常用）</li>
</ul>
</li>
<li><code>r, R</code>：进入取代模式（Replace mode）<ul>
<li>r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；（常用）</li>
</ul>
</li>
<li>上面这些按键中，在 vi 画面的左下角处会出现“–INSERT–”或“–REPLACE–”的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在文件里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</li>
<li><code>[Esc]</code>：退出编辑模式，回到一般指令模式中（常用）</li>
</ul>
<blockquote>
<p>一般指令模式切换到指令列模式的可用按钮说明</p>
</blockquote>
<ul>
<li>指令列模式的储存、离开等指令<ul>
<li><code>:w</code>：将编辑的数据写入硬盘文件中（常用）</li>
<li><code>:w!</code>：若文件属性为“只读”时，强制写入该文件。不过，到底能不能写入， 还是跟你对该文件的文件权限有关啊！</li>
<li><code>:q</code>：离开 vi （常用）</li>
<li><code>:q!</code>：若曾修改过文件，又不想储存，使用 ! 为强制离开不储存盘案。</li>
<li><code>:wq</code>：储存后离开，若为 <code>:wq!</code> 则为强制储存后离开 （常用）</li>
<li><code>ZZ</code>：这是大写的 Z 喔！若文件没有更动，则不储存离开，若文件已经被更动过，则储存后离开！</li>
<li><code>:w [filename]</code>：将编辑的数据储存成另一个文件（类似另存新文件）</li>
<li><code>:r [filename]</code>：在编辑的数据中，读入另一个文件的数据。亦即将 “filename” 这个文件内容加到光标所在列后面</li>
<li><code>:n1,n2 w [filename]</code>：将 n1 到 n2 的内容储存成 filename 这个文件。</li>
<li><code>:! command</code>：暂时离开 vi 到指令列模式下执行 command 的显示结果！例如 <code>:! ls /home</code> 即可在 vi 当中察看 /home 下面以 ls 输出的文件信息！</li>
</ul>
</li>
<li>vim 环境的变更<ul>
<li><code>:set nu</code>：显示行号，设置之后，会在每一列的字首显示该列的行号</li>
<li><code>:set nonu</code>：与 set nu 相反，为取消行号！</li>
</ul>
</li>
</ul>
<blockquote>
<p>区块选择（Visual Block）</p>
</blockquote>
<ul>
<li><code>v</code>：字符选择，会将光标经过的地方反白选择！</li>
<li><code>V</code>：列选择，会将光标经过的列反白选择！</li>
<li><code>[Ctrl]+v</code>：区块选择，可以用长方形的方式选择数据</li>
<li><code>y</code>：将反白的地方复制起来</li>
<li><code>d</code>：将反白的地方删除掉</li>
<li><code>p</code>：将刚刚复制的区块，在光标所在处贴上！</li>
</ul>
<blockquote>
<p>多文件编辑</p>
</blockquote>
<p>通过 <code>vim file1 file2</code> 指令来使用一个 vim 打开两个文件</p>
<ul>
<li><code>:n</code>：编辑下一个文件</li>
<li><code>:N</code>：编辑上一个文件</li>
<li><code>:files</code>：列出目前这个 vim 的打开的所有文件</li>
</ul>
<blockquote>
<p>多窗口功能</p>
</blockquote>
<p>如何分区窗口并放入文件呢？ 很简单啊！在指令列模式输入“:sp {filename}”即可！那个 filename 可有可无， 如果想要在新窗口启动另一个文件，就加入文件名，否则仅输入 :sp 时， 出现的则是同一个文件在两个窗口间！</p>
<ul>
<li><code>:sp [filename]</code>：打开一个新窗口，如果有加 filename， 表示在新窗口打开一个新文件，否则表示两个窗口为同一个文件内容（同步显示）。</li>
<li><code>[ctrl]+w+j</code> / <code>[ctrl]+w+↓</code> ：按键的按法是：先按下 [ctrl] 不放， 再按下 w 后放开所有的按键，然后再按下 j （或向下方向键），则光标可移动到下方的窗口。</li>
<li><code>[ctrl]+w+k</code> / <code>[ctrl]+w+↑</code>：同上，不过光标移动到上面的窗口。</li>
<li><code>[ctrl]+w+q</code>：其实就是 :q 结束离开啦！ 举例来说，如果我想要结束下方的窗口，那么利用 <code>[ctrl]+w+↓</code> 移动到下方窗口后，按下 <code>:q</code> 即可离开， 也可以按下 <code>[ctrl]+w+q</code> 啊！</li>
</ul>
<blockquote>
<p>vim 环境设置与记录</p>
</blockquote>
<p>主要是修改 <code>~/.vimrc</code> 和 <code>~/.viminfo</code></p>
<ul>
<li><code>:set nu</code> / <code>:set nonu</code>：就是设置与取消行号啊！</li>
<li><code>:set hlsearch</code> / <code>:set nohlsearch</code>：hlsearch 就是 high light search（高亮度搜寻）。 这个就是设置是否将搜寻的字串反白的设置值。默认值是 hlsearch</li>
<li><code>:set autoindent</code> / <code>:set noautoindent</code>：是否自动缩排？autoindent 就是自动缩排。</li>
<li><code>:set backup</code>：是否自动储存备份文件？一般是 nobackup 的， 如果设置 backup 的话，那么当你更动任何一个文件时，则原始文件会被另存成一个文件名为 filename~ 的文件。 举例来说，我们编辑 hosts ，设置 <code>:set backup</code>，那么当更动 hosts 时，在同目录下，就会产生 hosts~ 文件名的文件，记录原始的 hosts 文件内容</li>
<li><code>:set ruler</code>：还记得我们提到的右下角的一些状态列说明吗？ 这个 ruler 就是在显示或不显示该设置值的啦！</li>
<li><code>:set showmode</code>：这个则是，是否要显示 <code>--INSERT--</code> 之类的字眼在左下角的状态列。</li>
<li><code>:set backspace=（012）</code>：一般来说， 如果我们按下 i 进入编辑模式后，可以利用倒退键 （backspace） 来删除任意字符的。 但是，某些 distribution 则不许如此。此时，我们就可以通过 backspace 来设置啰～ 当 backspace 为 2 时，就是可以删除任意值；0 或 1 时，仅可删除刚刚输入的字符， 而无法删除原本就已经存在的文字了！</li>
<li><code>:set all</code>：显示目前所有的环境参数设置值。</li>
<li><code>:set</code>：显示与系统默认值不同的设置参数， 一般来说就是你有自行变动过的设置参数啦！</li>
<li><code>:syntax on</code> / <code>:syntax off</code>：是否依据程序相关语法显示不同颜色？ 举例来说，在编辑一个纯文本文件时，如果开头是以 # 开始，那么该列就会变成蓝色。 如果你懂得写程序，那么这个 <code>:syntax on</code> 还会主动的帮你除错呢！但是， 如果你仅是编写纯文本，要避免颜色对你的屏幕产生的干扰，则可以取消这个设置 。</li>
<li><code>:set bg=dark</code> / <code>:set bg=light</code>：可用以显示不同的颜色色调，默认是 light 。如果你常常发现注解的字体深蓝色实在很不容易看， 那么这里可以设置为 dark 喔！试看看，会有不同的样式呢！</li>
</ul>
<p>总之，这些设置值很有用处的啦！但是…我是否每次使用 vim 都要重新设置一次各个参数值？ 这不太合理吧？没错啊！所以，我们可以通过配置文件来直接规定我们习惯的 vim 操作环境呢！ 整体 vim 的设置值一般是放置在 <code>/etc/vimrc</code> 这个文件，不过，不建议你修改他！ 你可以修改 <code>~/.vimrc</code> 这个文件 （默认不存在，请你自行手动创建！），将你所希望的设置值写入！ 举例来说，可以是这样的一个文件：</p>
<p><img src="/images/14590898239987.jpg" alt=""></p>
<p>很多朋友常常哀嚎，说他们的 vim 里面怎么无法显示正常的中文啊？其实这很有可能是因为编码的问题！ 因为中文编码有 big5 与 utf8 两种，如果你的文件是使用 big5 编码制作的，但在 vim 的终端接口中你使用的是万国码（utf8）， 由于编码的不同，你的中文文件内容当然就是一堆乱码了！怎么办？这时你得要考虑许多东西啦！有这些：</p>
<ol>
<li>你的 Linux 系统默认支持的语系数据：这与 <code>/etc/locale.conf</code> 有关；</li>
<li>你的终端接口 （bash） 的语系： 这与 <code>LANG</code>, <code>LC_ALL</code> 这几个变量有关；</li>
<li>你的文件原本的编码；</li>
<li>打开终端机的软件，例如在 GNOME 下面的窗口接口。</li>
</ol>
<p>事实上最重要的是上头的第三与第四点，只要这两点的编码一致，你就能够正确的看到与编辑你的中文文件。 否则就会看到一堆乱码啦！</p>
<h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2><p>默认的指令记忆功能可以到达 1000 个！也就是说，你曾经下达过的指令几乎都被记录下来了。<br>这么多的指令记录在哪里呢？在你的主文件夹内的 <code>.bash_history</code> 啦！ 不过，需要留意的是，<code>~/.bash_history</code> 记录的是前一次登陆以前所执行过的指令， 而至于这一次登陆所执行的指令都被暂存在内存中，当你成功的登出系统后，该指令记忆才会记录到 <code>.bash_history</code> 当中！</p>
<p>bash 的配置文件主要分为 login shell 与 non-login shell。login shell 主要读取 <code>/etc/profile</code> 与 <code>~/.bash_profile</code>， non-login shell 则仅读取 <code>~/.bashrc</code></p>
<blockquote>
<p>命令别名设置功能 alias</p>
</blockquote>
<p>假如我需要知道这个目录下面的所有文件 （包含隐藏文件） 及所有的文件属性，那么我就必须要下达 <code>ls -al</code> 这样的指令串，唉！真麻烦，有没有更快的取代方式？呵呵！就使用命令别名呀！例如鸟哥最喜欢直接以 lm 这个自订的命令来取代上面的命令，也就是说， lm 会等于 <code>ls -al</code> 这样的一个功能，嘿！那么要如何作呢？就使用 alias 即可！你可以在指令列输入 alias 就可以知道目前的命令别名有哪些了！也可以直接下达命令来设置别名呦：<code>alias lm=&#39;ls -al&#39;</code></p>
<blockquote>
<p>查询指令是否为 Bash shell 的内置命令 type</p>
</blockquote>
<p><code>type [-tpa] name</code> 选项与参数：</p>
<ul>
<li>不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内置指令</li>
<li><code>-t</code>：当加入 -t 参数时，type 会将 name 以下面这些字眼显示出他的意义：<ul>
<li><code>file</code>：表示为外部指令；</li>
<li><code>alias</code>：表示该指令为命令别名所设置的名称；</li>
<li><code>builtin</code>：表示该指令为 bash 内置的指令功能；</li>
</ul>
</li>
<li><code>-p</code>：如果后面接的 name 为外部指令时，才会显示完整文件名；</li>
<li><code>-a</code>：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 alias</li>
</ul>
<blockquote>
<p>指令的下达与快速编辑按钮</p>
</blockquote>
<p>上面这个指令用途是将三个文件复制到 <code>/root</code> 这个目录下而已。不过，因为指令太长， 于是鸟哥就利用 <code>\[Enter]</code> 来将 [Enter] 这个按键“跳脱！”开来，让 [Enter] 按键不再具有“开始执行”的功能！好让指令可以继续在下一行输入。 需要特别留意， [Enter] 按键是紧接着反斜线 <code>\</code> 的，两者中间没有其他字符。 因为 <code>\</code> 仅跳脱“紧接着的下一个字符”而已！</p>
<p>另外，当你所需要下达的指令特别长，或者是你输入了一串错误的指令时，你想要快速的将这串指令整个删除掉，一般来说，我们都是按下删除键的。 有没有其他的快速组合键可以协助呢？是有的！常见的有下面这些：</p>
<ul>
<li><code>[ctrl]+u</code> / <code>[ctrl]+k</code><ul>
<li>分别是从光标处向前删除指令串 （[ctrl]+u） 及向后删除指令串 （[ctrl]+k）。</li>
</ul>
</li>
<li><code>[ctrl]+a</code> / <code>[ctrl]+e</code><ul>
<li>分别是让光标移动到整个指令串的最前面 （[ctrl]+a） 或最后面 （[ctrl]+e）。</li>
</ul>
</li>
</ul>
<p>Shell 相关的部分会另外进行学习，这里暂时略过</p>
<blockquote>
<p>万用字符</p>
</blockquote>
<ul>
<li><code>*</code>：代表“ 0 个到无穷多个”任意字符</li>
<li><code>?</code>：代表“一定有一个”任意字符</li>
<li><code>[ ]</code>：同样代表“一定有一个在括号内”的字符（非任意字符）。例如 [abcd] 代表“一定有一个字符， 可能是 a, b, c, d 这四个任何一个”</li>
<li><code>[ - ]</code>：若有减号在中括号内时，代表“在编码顺序内的所有字符”。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！</li>
<li><code>[^ ]</code>：若中括号内的第一个字符为指数符号（<code>^</code>），那表示“反向选择”，例如 <code>[^abc]</code> 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。</li>
</ul>
<blockquote>
<p>特殊符号</p>
</blockquote>
<ul>
<li><code>#</code> 注解符号：这个最常被使用在 script 当中，视为说明！在后的数据均不执行</li>
<li><code>\</code> 跳脱符号：将“特殊字符或万用字符”还原成一般字符</li>
<li><code>|</code> 管线 （pipe）：分隔两个管线命令的界定（后两节介绍）；</li>
<li><code>;</code> 连续指令下达分隔符号：连续性命令的界定 （注意！与管线命令并不相同）</li>
<li><code>~</code> 使用者的主文件夹</li>
<li><code>$</code> 取用变量前置字符：亦即是变量之前需要加的变量取代值</li>
<li><code>&amp;</code> 工作控制 （job control）：将指令变成背景下工作</li>
<li><code>!</code> 逻辑运算意义上的“非” not 的意思！</li>
<li><code>/</code> 目录符号：路径分隔的符号</li>
<li><code>&gt;</code>, <code>&gt;&gt;</code> 数据流重导向：输出导向，分别是“取代”与“累加”</li>
<li><code>&lt;</code>, <code>&lt;&lt;</code> 数据流重导向：输入导向 （这两个留待下节介绍）</li>
<li><code>&#39; &#39;</code> 单引号，不具有变量置换的功能（<code>$</code> 变为纯文本）</li>
<li><code>&quot; &quot;</code> 具有变量置换的功能！（<code>$</code> 可保留相关功能）</li>
<li>` ` 两个 ` 中间为可以先执行的指令，亦可使用 $（ ）</li>
<li><code>（ ）</code> 在中间为子 shell 的起始与结束</li>
<li><code>{ }</code> 在中间为命令区块的组合！</li>
</ul>
<blockquote>
<p>重定向</p>
</blockquote>
<p>简单的说，标准输出指的是“指令执行所回传的正确的讯息”，而标准错误输出可理解为“ 指令执行失败后，所回传的错误讯息”。举个简单例子来说，我们的系统默认有 <code>/etc/crontab</code> 但却无 <code>/etc/vbirdsay</code>， 此时若下达 <code>cat /etc/crontab /etc/vbirdsay</code> 这个指令时，cat 会进行：</p>
<ul>
<li>标准输出：读取 <code>/etc/crontab</code> 后，将该文件内容显示到屏幕上；</li>
<li>标准错误输出：因为无法找到 <code>/etc/vbirdsay</code>，因此在屏幕上显示错误讯息</li>
</ul>
<p>不管正确或错误的数据都是默认输出到屏幕上，所以屏幕当然是乱乱的！那能不能通过某些机制将这两股数据分开呢？ 当然可以啊！那就是数据流重导向的功能啊！数据流重导向可以将 standard output （简称 stdout） 与 standard error output （简称 stderr） 分别传送到其他的文件或设备去，而分别传送所用的特殊字符则如下所示：</p>
<ol>
<li>标准输入　　（stdin） ：代码为 0 ，使用 <code>&lt;</code> 或 <code>&lt;&lt;</code> ；</li>
<li>标准输出　　（stdout）：代码为 1 ，使用 <code>&gt;</code>（覆盖） 或 <code>&gt;&gt;</code>（累加） ；</li>
<li>标准错误输出（stderr）：代码为 2 ，使用 <code>2&gt;</code>（覆盖） 或 <code>2&gt;&gt;</code>（累加） ；</li>
</ol>
<p>想像一下，如果我知道错误讯息会发生，所以要将错误讯息忽略掉而不显示或储存呢？ 这个时候黑洞设备 /dev/null 就很重要了！这个 /dev/null 可以吃掉任何导向这个设备的信息喔！</p>
<p>如：<code>find /home -name .bashrc 2&gt; /dev/null</code></p>
<blockquote>
<p>命令执行的判断依据： <code>;</code> , <code>&amp;&amp;</code>, <code>||</code></p>
</blockquote>
<ul>
<li><code>cmd ; cmd</code> 不考虑指令相关性的连续指令下达</li>
<li><code>$? （指令回传值） 与 &amp;&amp; 或 ||</code></li>
</ul>
<blockquote>
<p>管线命令 pipe</p>
</blockquote>
<p>在每个管线后面接的第一个数据必定是“指令”喔！而且这个指令必须要能够接受 standard input 的数据才行，这样的指令才可以是为“管线命令”，例如 less, more, head, tail 等都是可以接受 standard input 的管线命令啦。至于例如 ls, cp, mv 等就不是管线命令了！因为 ls, cp, mv 并不会接受来自 stdin 的数据。 也就是说，管线命令主要有两个比较需要注意的地方：</p>
<ul>
<li>管线命令仅会处理 standard output，对于 standard error output 会予以忽略</li>
<li>管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行。</li>
</ul>
<blockquote>
<p>关于减号 - 的用途</p>
</blockquote>
<p>管线命令在 bash 的连续的处理程序中是相当重要的！另外，在 log file 的分析当中也是相当重要的一环， 所以请特别留意！另外，在管线命令当中，常常会使用到前一个指令的 stdout 作为这次的 stdin ， 某些指令需要用到文件名称 （例如 tar） 来进行处理时，该 stdin 与 stdout 可以利用减号 “-“ 来替代， 举例来说：</p>
<p>``bash<br>mkdir /tmp/homeback<br>tar -cvf - /home | tar -xvf - -C /tmp/homeback<br>```</p>
<p>上面这个例子是说：“我将 /home 里面的文件给他打包，但打包的数据不是纪录到文件，而是传送到 stdout； 经过管线后，将 <code>tar -cvf - /home</code> 传送给后面的 <code>tar -xvf -</code> ”。后面的这个 <code>-</code> 则是取用前一个指令的 <code>stdout</code>，因此，我们就不需要使用 filename 了！这是很常见的例子喔！注意注意！</p>
<h2 id="Linux__u76EE_u5F55_u7684_u542B_u4E49"><a href="#Linux__u76EE_u5F55_u7684_u542B_u4E49" class="headerlink" title="Linux 目录的含义"></a>Linux 目录的含义</h2><ul>
<li><code>bin</code><ul>
<li>系统有很多放置可执行文件的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin下面的指令可以被root与一般帐号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。</li>
</ul>
</li>
<li><code>/boot</code><ul>
<li>这个目录主要在放置开机会使用到的文件，包括Linux核心文件以及开机菜单与开机所需配置文件等等。 Linux kernel常用的文件名为：vmlinuz，如果使用的是grub2这个开机管理程序， 则还会存在/boot/grub2/这个目录喔！</li>
</ul>
</li>
<li><code>/dev</code><ul>
<li>在Linux系统上，任何设备与周边设备都是以文件的型态存在于这个目录当中的。 你只要通过存取这个目录下面的某个文件，就等于存取某个设备啰～ 比要重要的文件有 <code>/dev/null</code>, <code>/dev/zero</code>, <code>/dev/tty</code>, <code>/dev/loop*</code>, <code>/dev/sd*</code> 等等 </li>
</ul>
</li>
<li><code>/etc</code><ul>
<li>系统主要的配置文件几乎都放置在这个目录内，例如人员的帐号密码档、 各种服务的启始档等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的， 但是只有root有权力修改。FHS建议不要放置可可执行文件（binary）在这个目录中喔。比较重要的文件有： /etc/modprobe.d/, /etc/passwd, /etc/fstab, /etc/issue 等等。另外 FHS 还规范几个重要的目录最好要存在 /etc/ 目录下喔：</li>
<li>/etc/opt（必要）：这个目录在放置第三方协力软件 /opt 的相关配置文件</li>
<li>/etc/X11/（建议）：与 X Window 有关的各种配置文件都在这里，尤其是 xorg.conf 这个 X Server 的配置文件。</li>
<li>/etc/sgml/（建议）：与 SGML 格式有关的各项配置文件</li>
<li>/etc/xml/（建议）：与 XML 格式有关的各项配置文件</li>
</ul>
</li>
<li><code>/lib</code><ul>
<li>系统的函数库非常的多，而/lib放置的则是在开机时会用到的函数库， 以及在/bin或/sbin下面的指令会调用的函数库而已。 什么是函数库呢？你可以将他想成是“外挂”，某些指令必须要有这些“外挂”才能够顺利完成程序的执行之意。 另外 FSH 还要求下面的目录必须要存在：</li>
<li>/lib/modules/：这个目录主要放置可抽换式的核心相关模块（驱动程序）喔！</li>
</ul>
</li>
<li><code>/media</code><ul>
<li>media是“媒体”的英文，顾名思义，这个/media下面放置的就是可移除的设备啦！ 包括软盘、光盘、DVD等等设备都暂时挂载于此。常见的文件名有：/media/floppy，/media/cdrom等等。</li>
</ul>
</li>
<li><code>/mnt</code><ul>
<li>如果你想要暂时挂载某些额外的设备，一般建议你可以放置到这个目录中。 在古早时候，这个目录的用途与/media相同啦！只是有了/media之后，这个目录就用来暂时挂载用了。</li>
</ul>
</li>
<li><code>/opt</code><ul>
<li>这个是给第三方协力软件放置的目录。什么是第三方协力软件啊？ 举例来说，KDE这个桌面管理系统是一个独立的计划，不过他可以安装到Linux系统中，因此KDE的软件就建议放置到此目录下了。 另外，如果你想要自行安装额外的软件（非原本的distribution提供的），那么也能够将你的软件安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！ </li>
</ul>
</li>
<li><code>/run</code><ul>
<li>早期的 FHS 规定系统开机后所产生的各项信息应该要放置到 /var/run 目录下，新版的 FHS 则规范到 /run 下面。 由于 /run 可以使用内存来仿真，因此性能上会好很多！</li>
</ul>
</li>
<li><code>/sbin</code><ul>
<li>Linux有非常多指令是用来设置系统环境的，这些指令只有root才能够利用来“设置”系统，其他使用者最多只能用来“查询”而已。 放在/sbin下面的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序，一般则放置到/usr/sbin/当中。至于本机自行安装的软件所产生的系统可执行文件（system binary）， 则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, mkfs等等。</li>
</ul>
</li>
<li><code>/srv</code><ul>
<li>srv可以视为“service”的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如WWW, FTP等等。举例来说，WWW服务器需要的网页数据就可以放置在/srv/www/里面。 不过，系统的服务数据如果尚未要提供给网际网络任何人浏览的话，默认还是建议放置到 /var/lib 下面即可。 </li>
</ul>
</li>
<li><code>/tmp</code><ul>
<li>这是让一般使用者或者是正在执行的程序暂时放置文件的地方。 这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！ 因为FHS甚至建议在开机时，应该要将/tmp下的数据都删除唷！</li>
</ul>
</li>
<li><code>/usr</code><ul>
<li>第二层 FHS 设置，后续介绍</li>
</ul>
</li>
<li><code>/var</code><ul>
<li>第二层 FHS 设置，主要为放置变动性的数据，后续介绍</li>
</ul>
</li>
</ul>
<p>FHS 建议可以存在的目录</p>
<ul>
<li><code>/home</code><ul>
<li>这是系统默认的使用者主文件夹（home directory）。在你新增一个一般使用者帐号时， 默认的使用者主文件夹都会规范到这里来。比较重要的是，主文件夹有两种代号喔：</li>
<li><code>~</code>：代表目前这个使用者的主文件夹</li>
<li><code>~dmtsai</code>：则代表 dmtsai 的主文件夹！</li>
</ul>
</li>
<li><code>/lib&lt;qual&gt;</code><ul>
<li>用来存放与 /lib 不同的格式的二进制函数库，例如支持 64 位的 /lib64 函数库等</li>
</ul>
</li>
<li><code>/root</code><ul>
<li>系统管理员（root）的主文件夹。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有root的主文件夹，所以我们会希望root的主文件夹与根目录放置在同一个分区中。</li>
</ul>
</li>
</ul>
<p>事实上FHS针对根目录所定义的标准就仅有上面的咚咚，不过我们的Linux下面还有许多目录你也需要了解一下的。 下面是几个在Linux当中也是非常重要的目录喔</p>
<ul>
<li><code>/lost+found</code><ul>
<li>这个目录是使用标准的ext2/ext3/ext4文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。不过如果使用的是 xfs 文件系统的话，就不会存在这个目录了！</li>
</ul>
</li>
<li><code>/proc</code><ul>
<li>这个目录本身是一个“虚拟文件系统（virtual filesystem）”喔！他放置的数据都是在内存当中， 例如系统核心、行程信息（process）、周边设备的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的文件例如：<code>/proc/cpuinfo</code>, <code>/proc/dma</code>, <code>/proc/interrupts</code>, <code>/proc/ioports</code>, <code>/proc/net/*</code> 等等。</li>
</ul>
</li>
<li><code>/sys</code><ul>
<li>这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录核心与系统硬件信息较相关的信息。 包括目前已载入的核心模块与核心侦测到的硬件设备信息等等。这个目录同样不占硬盘容量喔！</li>
</ul>
</li>
</ul>
<p>早期 Linux 在设计的时候，若发生问题时，救援模式通常仅挂载根目录而已，因此有五个重要的目录被要求一定要与根目录放置在一起， 那就是 /etc, /bin, /dev, /lib, /sbin 这五个重要目录。现在许多的 Linux distributions 由于已经将许多非必要的文件移出 /usr 之外了， 所以 /usr 也是越来越精简，同时因为 /usr 被建议为“即使挂载成为只读，系统还是可以正常运行”的模样，所以救援模式也能同时挂载 /usr 喔！ </p>
<h3 id="/usr__u4ECB_u7ECD"><a href="#/usr__u4ECB_u7ECD" class="headerlink" title="/usr 介绍"></a>/usr 介绍</h3><p>依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的（shareable, static）。usr是Unix Software Resource的缩写， 也就是“Unix操作系统软件资源”所放置的目录，而不是使用者的数据啦！这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行创建该软件自己独立的目录。</p>
<p>一般来说，/usr的次目录建议有下面这些：</p>
<ul>
<li><code>/usr/bin/</code><ul>
<li>所有一般用户能够使用的指令都放在这里！目前新的 CentOS 7 已经将全部的使用者指令放置于此，而使用链接文件的方式将 /bin 链接至此！ 也就是说， /usr/bin 与 /bin 是一模一样了！另外，FHS 要求在此目录下不应该有子目录！</li>
</ul>
</li>
<li><code>/usr/lib/</code><ul>
<li>基本上，与 /lib 功能相同，所以 /lib 就是链接到此目录中的！</li>
</ul>
</li>
<li><code>/usr/local/</code><ul>
<li>系统管理员在本机自行安装自己下载的软件（非distribution默认提供者），建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦！ 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录喔！</li>
</ul>
</li>
<li><code>/usr/sbin/</code><ul>
<li>非系统正常运行所需要的系统指令。最常见的就是某些网络服务器软件的服务指令（daemon）啰！不过基本功能与 /sbin 也差不多， 因此目前 /sbin 就是链接到此目录中的。</li>
</ul>
</li>
<li><code>/usr/share/</code><ul>
<li>主要放置只读架构的数据文件，当然也包括共享文件。在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文字文件嘛！在此目录下常见的还有这些次目录：</li>
<li>/usr/share/man：线上说明文档</li>
<li>/usr/share/doc：软件杂项的文件说明</li>
<li>/usr/share/zoneinfo：与时区有关的时区文件</li>
</ul>
</li>
</ul>
<p>FHS 建议可以存在的目录</p>
<ul>
<li><code>/usr/games/</code><ul>
<li>与游戏比较相关的数据放置处</li>
</ul>
</li>
<li><code>/usr/include/</code><ul>
<li>c/c++等程序语言的文件开始（header）与包含档（include）放置处，当我们以tarball方式 （<code>*.tar.gz</code> 的方式安装软件）安装某些数据时，会使用到里头的许多包含档喔！</li>
</ul>
</li>
<li><code>/usr/libexec/</code><ul>
<li>某些不被一般使用者惯用的可执行文件或脚本（script）等等，都会放置在此目录中。例如大部分的 X 窗口下面的操作指令， 很多都是放在此目录下的。</li>
</ul>
</li>
<li><code>/usr/lib&lt;qual&gt;/</code><ul>
<li>与 <code>/lib&lt;qual&gt;/</code> 功能相同，因此目前 <code>/lib&lt;qual&gt;</code> 就是链接到此目录中 </li>
</ul>
</li>
<li><code>/usr/src/</code><ul>
<li>一般源代码建议放置到这里，src有source的意思。至于核心源代码则建议放置到/usr/src/linux/目录下。</li>
</ul>
</li>
</ul>
<h3 id="/var__u4ECB_u7ECD"><a href="#/var__u4ECB_u7ECD" class="headerlink" title="/var 介绍"></a>/var 介绍</h3><p>如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运行后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括高速缓存（cache）、登录文件（log file）以及某些软件运行所产生的文件， 包括程序文件（lock file, run file），或者例如MySQL数据库的文件等等。常见的次目录有：</p>
<ul>
<li><code>/var/cache/</code><ul>
<li>应用程序本身运行过程中会产生的一些暂存盘；</li>
</ul>
</li>
<li><code>/var/lib/</code><ul>
<li>程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去！</li>
</ul>
</li>
<li><code>/var/lock/</code><ul>
<li>某些设备或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该设备时， 就可能产生一些错误的状况，因此就得要将该设备上锁（lock），以确保该设备只会给单一软件所使用。 举例来说，烧录机正在烧录一块光盘，你想一下，会不会有两个人同时在使用一个烧录机烧片？ 如果两个人同时烧录，那片子写入的是谁的数据？所以当第一个人在烧录时该烧录机就会被上锁， 第二个人就得要该设备被解除锁定（就是前一个人用完了）才能够继续使用啰。目前此目录也已经挪到 /run/lock 中！</li>
</ul>
</li>
<li><code>/var/log/</code><ul>
<li>重要到不行！这是登录文件放置的目录！里面比较重要的文件如/var/log/messages, /var/log/wtmp（记录登陆者的信息）等。</li>
</ul>
</li>
<li><code>/var/mail/</code><ul>
<li>放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中！ 通常这两个目录是互为链接文件啦！</li>
</ul>
</li>
<li><code>/var/run/</code><ul>
<li>某些程序或者是服务启动后，会将他们的PID放置在这个目录下喔！至于PID的意义我们会在后续章节提到的。 与 /run 相同，这个目录链接到 /run 去了！</li>
</ul>
</li>
<li><code>/var/spool/</code><ul>
<li>这个目录通常放置一些伫列数据，所谓的“伫列”就是排队等待其他程序使用的数据啦！ 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作调度数据（crontab），就会被放置到/var/spool/cron/目录中！</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为之后更多会涉及后台开发的部分，所以系统学习一下 Linux 还是很有必要的，这里就用《鸟哥的 Linux 私房菜》作为主要的学习材料。不过因为我本身已经有一定基础了，所以这里主要会记录个人觉得比较生疏和重要的地方。</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://wdxtub.com/tags/Linux/"/>
    
      <category term="基础" scheme="http://wdxtub.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="服务器" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【启示录：打造用户喜爱的产品】读书笔记]]></title>
    <link href="http://wdxtub.com/2016/03/26/inspired-create-product/"/>
    <id>http://wdxtub.com/2016/03/26/inspired-create-product/</id>
    <published>2016-03-26T20:53:01.000Z</published>
    <updated>2016-03-26T20:56:23.000Z</updated>
    <content type="html"><![CDATA[<p>这本书基本上说清楚了打造好产品的方方面面，很值得一看。</p>
<a id="more"></a>
<hr>
<p>我们汲取了深刻教训：如果开发的产品没有市场价值，那么无论开发团队多么优秀也无济于事。不仅如此，我们认识到仅仅做出产品并不够，还要确认产品是有价值的、可用的、可行的。</p>
<p>从担任网景高级产品经理开始，我的日常工作明确分为三块：人员、流程、产品。</p>
<ul>
<li>人员是指负责定义和开发产品的团队成员的角色和职责。</li>
<li>流程是指探索、开发富有创意的产品时，反复应用的步骤和成功的实践经验。</li>
<li>产品是指富有创意的产品具有的鲜明特性。</li>
</ul>
<p>这三个部分是探索和开发用户喜爱的产品必不可少的。项目都是由人完成的，流程则保证大家持续开发出用户喜爱的产品。</p>
<hr>
<p>我从不认为富有创意的产品来自偶然。成功的产品都遵循一定的规律。以下是我总结的十条规律。</p>
<ol>
<li>产品经理的任务是探索产品的价值、可用性、可行性。</li>
<li>探索（定义）产品需要产品经理、交互设计师、软件架构师通力合作。</li>
<li>开发人员不擅长用户体验设计，因为开发人员脑子里想的是实现模型，而用户看重的是产品的概念模型。</li>
<li>用户体验设计就是交互设计、视觉设计（对硬件设备来说，则是工业设计）。</li>
<li>功能（产品需求）和用户体验设计密不可分。</li>
<li>产品创意必须尽早地、反复地接受目标用户的试用，以便获取有效的用户体验。</li>
<li>为了验证产品的价值和可用性，必须尽早地、反复地请目标用户测试产品创意。</li>
<li>采用高保真的产品原型是全体团队成员了解用户需求和用户体验最有效的途径。</li>
<li>产品经理的目标是在最短的时间内把握复杂的市场/用户需求，确定产品的基本要求——价值、可用性、可行性。</li>
<li>一旦认定产品符合以上基本要求，它就是一个完整的概念，去掉任何因素，都不可能达到预期的结果。</li>
</ol>
<h2 id="u5173_u952E_u89D2_u8272_u53CA_u5176_u804C_u8D23"><a href="#u5173_u952E_u89D2_u8272_u53CA_u5176_u804C_u8D23" class="headerlink" title="关键角色及其职责"></a>关键角色及其职责</h2><p>产品经理的主要职责分为两项：评估产品机会（product opportunity）；定义要开发的产品。</p>
<p>产品创意的来源很多，比如，公司高管的意见、用户的反馈、可用性测试的结果、产品团队和营销团队的点子、业内人士的分析等。应该有人严格审核这些创意，判断是否值得采纳。产品经理就是负责这项评估的人。许多公司借助市场需求文档（market requirements document，MRD）来完成这项工作。我更愿意使用一种简化的方法，我称之为机会评估（opportunity assessment）。</p>
<p>确定有价值且符合公司发展要求的产品机会后，还需要探索产品的解决方案，包括基本的产品特征和功能、产品的用户体验、产品的发布标准。这些也属于产品经理的工作范畴，而且是产品经理的核心职责。有些公司借助产品需求文档（product requirements document，PRD）来完成这项工作，也有人称其为产品说明文档或功能说明文档。同样，我主张采用简化的文档，围绕产品原型来展开这项工作。注意，文档应该清晰地描述产品的功能和属性，避免讨论产品的实现方法。</p>
<p>用户体验设计团队由多种角色组成，稍后我会详细说明。这里只谈谈最关键的角色——交互设计师（也称为信息架构师、用户界面设计师、用户体验架构师）。交互设计师负责深入理解目标用户，设计有价值的、可用的功能，以及用户导航和产品使用流程。交互设计师与产品经理密切合作，将功能与设计相结合，满足用户需求。目标是确保产品同时具有可用性和价值（可用性指的是用户明白如何使用产品，价值指的是用户对产品的渴求程度）。</p>
<p>产品经理完成产品定义后，开发团队承接项目，开始开发产品。项目管理的核心任务是制订计划和跟踪进度。项目管理工作常常由不同的角色承担，可能由专职的项目经理操刀，也可能由开发经理兼任（因为开发团队占有大部分项目资源），还可能由产品经理披挂上阵。这通常取决于公司文化和项目规模。规模较大的项目最好安排经验丰富的专职项目经理管理。</p>
<p>软件工程师也称为产品开发人员或软件开发人员，负责开发产品。开发团队在有些公司被称为IT（信息技术）团队。注意不要混淆这两个概念，区分的关键是看他们是为顾客开发软件，还是为公司内部（如人力资源部门）开发软件。IT团队通常指的是为内部员工提供技术支持的团队，而开发团队指的是为外部客户开发和维护产品的团队。</p>
<p>互联网服务产品通常运行在服务器上，用户通过web访问服务。运维团队负责保证服务正常运行。虽然有些公司将这项任务交给开发团队负责，但是运维工作需要一系列专业技能，很难由开发团队单独承担。</p>
<p>产品营销团队负责对外发布信息、宣传产品，为拓展市场销售渠道、组织重点营销活动（如在线营销）、促进产品销售提供支持。有些公司让一个人同时负责产品管理（产品定义）和产品营销。这两项工作内容相差很大，这样做实在不明智。</p>
<p>顺便提一下，微软把负责制定产品说明文档和管理项目进度的人称为项目经理（program manager）。由于这些“可怜”的人要同时应付多个项目，因此业界现在已经习惯用这个头衔称呼同时管理多个项目的管理人员。在微软，产品经理指的是那些负责产品营销的人。虽然我不喜欢微软对这两个头衔的用法，但我认为他们定义产品的工作做得非常棒。</p>
<h2 id="u4EA7_u54C1_u7BA1_u7406_u4E0E_u4EA7_u54C1_u8425_u9500"><a href="#u4EA7_u54C1_u7BA1_u7406_u4E0E_u4EA7_u54C1_u8425_u9500" class="headerlink" title="产品管理与产品营销"></a>产品管理与产品营销</h2><p>产品经理负责详细定义待开发的产品，让真实的用户测试产品。产品营销人员负责向外界宣传和推广产品，负责产品发布，为拓展市场销售渠道、组织重点营销活动（如在线营销）、促进产品销售提供支持。</p>
<h2 id="u4EA7_u54C1_u7BA1_u7406_u4E0E_u9879_u76EE_u7BA1_u7406"><a href="#u4EA7_u54C1_u7BA1_u7406_u4E0E_u9879_u76EE_u7BA1_u7406" class="headerlink" title="产品管理与项目管理"></a>产品管理与项目管理</h2><p>有些项目经理以为管理能力等同于使用微软Project软件的能力，他们没有领悟项目管理的真谛。以下是我从琳·丽迪这样优秀的项目经理身上总结出的七个特点。</p>
<p><strong>工作紧迫感</strong></p>
<p>只要琳走进房间，立刻就能传达给大家一种紧迫感。每次会议大约60秒闲话开场白后，马上转入正题。这种效果表面看来是因为她独特的身体语言和气质，但事实上，紧迫感和高效率是eBay企业文化的核心，而且已经升华为琳人格的一部分。</p>
<p><strong>善于捕捉问题</strong></p>
<p>有无数原因导致会议效率低下、毫无建设性，其中最主要的原因是会议目的不明确，不清楚要解决什么问题，也不知道难点在哪。优秀的项目经理能够迅速地、准确地指出问题及其要害，改善会议效果。</p>
<p><strong>思路清晰</strong></p>
<p>引发典型业务问题的原因多种多样，比如政治因素、日程安排有冲突、同事个性不合等，如果置之不理，稍作拖延就会导致整个项目一团糟。项目经理需要排除感情因素，放下思想包袱，拨云见日，把待解决的问题逐一独立分离出来，分配给每位同事，专注解决。</p>
<p><strong>用数据说话</strong></p>
<p>优秀的项目经理明白数据的重要性，懂得利用数据识别项目方向，确认项目进度。他们知道改善产品和开发流程必须从测量、收集数据开始。在时间紧迫的情况下，最容易仅凭直觉草率行事。为避免出现这种情况，项目经理务必坚持根据数据和事实制定决策。</p>
<p><strong>果断</strong></p>
<p>在多数公司里，产品团队成员不必向项目经理汇报工作，但项目经理必须驱动同事作出决策。项目经理必须向大家传达一种紧迫感，及时向团队收集数据和建议，适时向上级部门汇报情况，把问题理顺，用理性的思路和清晰的理由帮助大家，利用数据作出决策。</p>
<p><strong>判断力</strong></p>
<p>以上这些特点都基于良好的判断力。项目经理必须清楚何时催促进度，何时向上级汇报，何时需要收集更多信息，何时找个别成员私下交流。判断力很难言传身教，只能靠自己积累经验获得。</p>
<p><strong>态度</strong></p>
<p>如果产品不能按时交付，我们总能听到各种理由：可行性太差、资源不足、时间不够、资金匮乏等等。项目经理绝不能为自己找借口，必须克服所有障碍，解决所有问题，一往无前、愈挫愈勇，直到梦想成真。</p>
<h2 id="u4EA7_u54C1_u7BA1_u7406_u4E0E_u4EA7_u54C1_u8BBE_u8BA1"><a href="#u4EA7_u54C1_u7BA1_u7406_u4E0E_u4EA7_u54C1_u8BBE_u8BA1" class="headerlink" title="产品管理与产品设计"></a>产品管理与产品设计</h2><p>好产品必须提供舒适的用户体验。舒适的用户体验是产品管理和用户体验设计共同作用的结果。这是个很大的话题，我们先从了解设计包括哪些角色、分工开始。这里我给出与用户体验设计密切相关的分工。注意我描述的是工作角色而不是个人，因为有的人可能承担多项工作。</p>
<p><strong>用户研究</strong></p>
<p>专门研究、分析用户，评估产品或产品原型是否符合特定用户的使用习惯。其具体工作包括拟订恰当的测试项目，监督测试，评估测试结果，提出改进方案。</p>
<p><strong>交互设计</strong></p>
<p>在理解目标用户的基础上设计有价值的、可用的目标功能、用户导航和产品使用流程。交互设计师通常用线框绘制产品需求，然后交给视觉设计师。</p>
<p><strong>视觉设计</strong></p>
<p>根据线框设计可见的用户界面（页面），包括严格的布局、颜色和字体设置等。视觉设计能够传达并唤起产品蕴含的情感（其重要性常常被低估）。</p>
<p><strong>原型制作</strong></p>
<p>迅速制作融合了产品经理和设计师创意的产品原型，让用户试用，并根据反馈意见反复修正原型。</p>
<p>对大型产品（尤其是大众互联网服务）来说，这四种角色缺一不可。开发企业级应用软件的公司如果想从众多竞争对手中脱颖而出，最简单的办法是提供优秀的用户体验。用户体验是大部分企业级产品的弱项。对小型产品来说，可以让一位设计师身兼多职。例如，我最近与一家创业型公司合作，开发针对大众的Web 2.0服务。对方只有三个人：一位产品经理、一位交互设计师（同时负责用户研究）、一位视觉设计师（同时负责开发原型）。他们的工作非常出色，很快就拿出了可供目标用户测试的产品原型。</p>
<p>很多公司希望改善产品的用户体验，把用户体验设计外包给设计公司。这在一定程度上是可行的，但是有些工作不适合外包。例如，我认为交互设计不能外包，原因如下。</p>
<ol>
<li>深入理解用户需求非常费时间，需要多个项目的经验积累。设计公司没时间深入了解客户需求，就算他们做到了，这些经验也很难保存下来，用到下一个版本里。</li>
<li>交互设计师必须现场深度参与项目开发，从立项直到产品发布。开发和测试过程中会出现各种细节问题，必须有一名交互设计师迅速作出决定。</li>
<li>产品的用户体验是公司的核心竞争力，必须在内部完成。如果让我选择，质量检验更适合外包。 只要团队中有一位称职的交互设计师，视觉设计也可以外包，毕竟视觉设计公司很多，完全可以满足需求。此外，用户研究和可用性测试也可以外包，只是成本较高，对我这种重视测试反馈（参考第22章）的人来说更是如此，所以我建议让产品经理和交互设计师分担这项工作。</li>
</ol>
<h2 id="u4EA7_u54C1_u7BA1_u7406_u4E0E_u8F6F_u4EF6_u5F00_u53D1"><a href="#u4EA7_u54C1_u7BA1_u7406_u4E0E_u8F6F_u4EF6_u5F00_u53D1" class="headerlink" title="产品管理与软件开发"></a>产品管理与软件开发</h2><p>产品经理负责定义产品方案；开发团队最了解哪些产品构思是可行的，他们负责产品的开发与实现。作为产品经理，你很快能体会到，只有与开发团队融洽合作，才有可能开发出合格的产品；否则等待你的将是一段漫长、难挨的日子。形成合作关系的关键是双方承认彼此平等——任何一方不从属于另一方。产品经理负责定义正确的产品，开发团队负责正确地开发产品，双方相互依赖。你要求开发团队完成任务，必须先取得他们的认可，确信为了达到产品质量标准必须这么做；开发团队也要留给你足够的空间，设计有价值、可用的产品。</p>
<p>开发人员帮助产品经理完善产品定义的方式有如下三种。</p>
<ol>
<li>让开发人员直接面对用户或顾客，体会用户的困惑和疑虑，了解问题的严重性，这样好点子常常会随之而来，譬如，可以邀请一名开发人员参加产品原型测试。</li>
<li>向开发人员了解最新的技术发展动向，讨论哪些新技术可以用到产品里。开展头脑风暴，看看目前已实现的技术或即将实现的技术能不能解决手头的问题。</li>
<li>让开发人员在探索（定义）产品的初期阶段参与评估产品设计，协助策划方案。产品经理常犯一类错误，即完成产品定义后，便扔给开发团队，置之不理。这样做只会贻误协调需求与可行性的最佳时机，等到发现问题时，为时已晚。</li>
</ol>
<p>同样，产品经理也应该配合开发人员的工作，方式如下。</p>
<ol>
<li>产品经理只定义满足基本要求的产品。产品经理应该意识到，自己要定义的不是最终产品，而是满足基本要求的产品。只有这样，产品管理与软件开发之间才能形成良好的互动。</li>
<li>一旦产品进入开发阶段，要尽可能避免修改产品的需求和设计。虽然有些事情超出你的控制范围，导致项目波动是不可避免的（开发人员也能理解），但是千万不要在此时尝试突发奇想的点子。</li>
<li>产品开发阶段难免会产生诸多问题，比如，用例丢失，用例设计考虑不周全等，这很正常，最优秀的团队也避免不了。产品经理应该迅速采取行动，在维持产品基本功能、尽量避免修改的原则上，拿出解决方案。</li>
</ol>
<p>与开发团队合作应该遵循以下原则：在产品管理上为开发团队预留20%的自主时间，让他们自由支配。开发团队可以利用这些时间重写代码、完善架构、重构代码库中有缺陷的部分，或者更换数据库管理系统，提高系统性能，避免“需要停下来重写代码”的情形发生。</p>
<p>如果你的糟糕处境已经初现端倪，就应该拿出至少20%的资源进行调整。我担心有些团队连20%都不愿意拿出来。如果你已经身陷重写代码的困境，说明公司危在旦夕，这里给出一点建议供你参考。</p>
<p>第一，针对开发团队确定的产品修改目标制订切实可行的计划和时间表。通常，有经验的开发团队估计的开发时间八九不离十，但是重写代码是例外，因为多数团队没有重写代码的实际经验，估计往往过于乐观。你必须审时度势，仔细检查每处细节，确保计划切实可行。</p>
<p>第二，只要有可能，最好把重写目标分成几大块，实现递增修改，让用户感受到产品的改进，哪怕会因此把九个月的工作时间延长至两年，也一定要采用这种方式。重写代码时，保证让用户看到功能的改进——即使会占用少则25%，多则50%的开发资源——对保持产品（尤其是互联网产品）的市场占有率至关重要。</p>
<p>第三，由于开发用户可见功能的资源有限，必须谨慎选择正确的产品特性，确保产品定义的正确性。</p>
<h2 id="u62DB_u8058_u4EA7_u54C1_u7ECF_u7406"><a href="#u62DB_u8058_u4EA7_u54C1_u7ECF_u7406" class="headerlink" title="招聘产品经理"></a>招聘产品经理</h2><p><strong>个人素质和态度</strong></p>
<p>技术可以学习，素质却难以培养，有些素质是成功的产品经理必不可少的。</p>
<p><strong>对产品的热情</strong></p>
<p>有这样一群人，他们对产品有一种本能的热爱，把自己生活中的一切事物都看成产品，怀揣对优秀的产品的热爱和尊重。这份热情是产品经理必备的素质，是他们夜以继日克服困难、完善产品的动力。这份热情能感染团队成员，激励所有人。</p>
<p><strong>用户立场</strong></p>
<p>理想的产品经理不一定来自产品的目标市场（这种情况有利也有弊），但是他必须融入目标市场。这一特质对制造大众产品的高科技企业尤为难得。我们倾向于从自己的角度去理解用户和市场。事实上，目标用户的经验、喜好、价值观、知觉能力、忍受程度、技术理解很可能与我们的大相径庭。</p>
<p><strong>智力</strong></p>
<p>人的智力水平是无法替换的。产品管理需要洞察力和判断力，因此必须具备敏锐的头脑。勤奋当然是必需的，但从事这项工作光有勤奋还远远不够。</p>
<p><strong>职业操守</strong></p>
<p>每种团队角色承担的义务和付出的努力都不相同。产品经理肩负着产品的前途和命运，绝不适合贪图安逸的人担任。即便掌握了时间管理和产品管理的技巧，产品经理依然要为产品投入大量精力。成功的产品经理能拥有时间享受清闲的家庭生活吗？只要具备足够的经验，我相信可以做到。但是，如果你期望的是一周只工作四十个小时，下班后把工作抛诸脑后，那是不现实的。</p>
<p><strong>正直</strong></p>
<p>在所有产品团队成员里，产品经理最能体现公司和产品的价值观。通常产品经理不直接管理团队成员，不能要求别人执行命令，所以他必须通过行动影响、说服身边的同事。这种影响基于相互的信任和尊重，要求产品经理必须是个正直的人。</p>
<p><strong>信心</strong></p>
<p>很多人相信经验可以让人产生自信。如果仅凭经验可以建立信心，为什么许多工作多年的产品经理却毫无自信？相反，刚刚步入社会的大学毕业生却往往充满自信（虽然这种自信通常源自对自身状况的无知）。 自信是很重要的素质。公司高管、产品团队、销售团队都需要看到产品经理的信心，确信他们投入的时间、金钱、努力不会付之东流。自信的人更有说服力，更容易成为人们愿意追随的领导者。</p>
<p><strong>态度</strong></p>
<p>称职的产品经理把自己当成产品的CEO，愿意为产品的最终成败承担全部责任，绝不找借口。虽然他清楚产品按时成功上市要克服许多困难——开发难度大、开发时间长、成本过高、产品复杂等，但他明白预见和解决这些问题是他的责任。</p>
<p><strong>技能</strong></p>
<p>掌握一些重要的技能是打造成功产品的关键。我相信，只要具备优秀的个人素质，所有技能都可以习得。</p>
<p><strong>运用技术的能力</strong></p>
<p>很多成功的产品经理是工程师出身，因为策划产品在很大程度上取决于对新技术的理解，以及如何应用技术解决相关的问题。出色的产品经理并不需要自己发明或实现新技术，但必须有能力理解技术，发掘技术的应用潜力。</p>
<p><strong>注意力</strong></p>
<p>产品经理要优先解决重要问题。研发产品的过程中有很多干扰。能否集中注意力解决关键问题、克制不断增加功能的冲动、不受关键人物或重要客户的影响，取决于产品经理是否有足够强的自律性——不但要遵守公司制度，还要严格要求自己。</p>
<p><strong>时间管理</strong></p>
<p>电子邮件、即时消息和手机构成的世界充满了干扰。你可能一大早就来上班，拼命工作一整天，连吃饭喝水都顾不上，深夜回到家却发现到头来没完成一件重要工作。时间都用来“救火”和处理“紧急”事件了。熟练、迅速地区分重要任务和紧急任务，合理地规划和安排时间是产品经理必备的技能。如果产品经理无法集中精力完成真正重要的任务，那产品就难免命运多舛了。</p>
<p><strong>沟通技能</strong></p>
<p>虽然沟通技巧可以学习，但要做到出类拔萃需要经年累月的练习。沟通（包括口头表达和书面表达）能力是产品经理必备的技能，如前所述，产品经理只能以理服人，绝不能靠职位压制他人。口头表达能力可以在面试中测试，测试书面表达能力则需另寻他法。我常建议应聘者随身携带文字材料证明其书面表达能力，比如，不涉及专利的产品策划文档。</p>
<p><strong>商业技能</strong></p>
<p>作为产品团队的发言人，产品经理要协调团队与财务部门、营销部门、销售团队、公司高管之间的工作——必须使用这些人听得懂的概念和术语。 我认为产品经理应该具备双语技能。这并非指中文和英文，而是指产品经理既能与程序员讨论技术，又能与管理层和营销人员讨论成本结构、边际效应、市场份额、产品定位和品牌。</p>
<p>技术发展很快，所以产品经理必须善于快速学习新技术，解决新问题。我面试应聘者时，不关心他们已掌握的知识，只看重他们的学习思路。比如，让他们回忆研发产品之前，他们需要学习哪些知识，需要多长时间学习，如何利用这些知识。</p>
<h2 id="u5DF4_u987F_u5C06_u519B_u7684_u5FE0_u544A"><a href="#u5DF4_u987F_u5C06_u519B_u7684_u5FE0_u544A" class="headerlink" title="巴顿将军的忠告"></a>巴顿将军的忠告</h2><p>永远不要告诉别人怎么做。告诉他们做什么，他们自然会发挥天赋，给你惊喜。 ——乔治·史密斯·巴顿</p>
<p>优秀的用户体验设计师，特别是交互设计师可谓凤毛麟角。如果你发现了这样的人选，就一定要给予足够的创作空间，充分发挥其才能，使设计师成为产品团队的重要组成部分，让他们探索各种设计方案，倾听他们分析用户的行为和喜好。</p>
<p>总之，你留给用户体验设计师和开发人员的空间越大，他们就越有可能打造出用户喜爱的产品。</p>
<h2 id="u4EA7_u54C1_u526F_u7ECF_u7406"><a href="#u4EA7_u54C1_u526F_u7ECF_u7406" class="headerlink" title="产品副经理"></a>产品副经理</h2><p>我有一点工作体会，做产品要找公司最聪明的人合作。我发现每个公司都有几个聪明绝顶的人，这些人是公司的潜在资源，关键看你能不能发现他们。如果有幸能找到他们，就应该不拘一格地任用。我把这些人看做产品副经理，甚至公开授予他们头衔，把他们招进产品团队。</p>
<p>产品经理还可以向自己的领导借力，听取他们对产品的建议，虽然他们不太可能参与具体工作，但并不表示他们会袖手旁观。你需要的帮手可能隐身于公司各处——开发部门、销售部门、客户服务部门，甚至董事会。如何发现他们呢？</p>
<ol>
<li>打听！多问问同事，肯定会有收获。</li>
<li>采用走动式管理模式。这源于惠普的做法。管理者要走出自己的办公室和圈子，花时间与员工相处。</li>
<li>认真倾听与会者的对话与发言。</li>
<li>敞开办公室的门，让大家知道你随时欢迎他们向你提出产品建议。</li>
<li>坦率地把你的烦恼告诉同事，大家会热情地帮助你。</li>
<li>一起泡吧。工作之余，产品经理总是与产品经理一起消遣，高管总是与高管为伍，这是司空见惯的事。如果你能抽出时间与普通员工一起休息、娱乐，一定能发现“埋在沙里的金子”。</li>
</ol>
<h2 id="u7BA1_u7406_u4E0A_u53F8"><a href="#u7BA1_u7406_u4E0A_u53F8" class="headerlink" title="管理上司"></a>管理上司</h2><p>下面我介绍管理上司的十条经验。</p>
<ol>
<li>为项目波动做好准备 我用项目波动代指让你心烦意乱的各种返工、计划变更。不要企图消灭项目波动，但是可以尽量降低其负面影响。方法是提高警惕，记录工作进度，比如，记录每周、每月、每季度有多少时间项目在往前推进，掌握项目波动的规律，寻找对策。制订项目计划时，预留出时间应对变化和调整，做好“做无用功”的心理准备。这个方法不仅能缓解压力，提高计划的准确度，还有助于挖掘有待改善的细节。</li>
<li>注意沟通的方式与频率 千人千面，管理者也不例外的。有些管理者喜欢事无巨细亲力亲为；有些则希望尽量不被打扰。有些喜欢你用邮件介绍工作进展；有些则喜欢简短的口头汇报。弄清上司的喜好，对症下药。</li>
<li>会前沟通很多公司频繁开会。公司的高管、股东越多，汇报进度和评估工作的会议就越多。为了让大家了解进展，必须确保人人到场。组织好会议的诀窍是在正式会议召开前充分沟通，即在会前逐一会见与会的高管和股东，提出你的观点，征询他们的意见，确保会议召开前你们已经达成一致意见。如果会前沟通顺利，可以大大缩短正式会议的时间，结果也将毫无悬念。正式会议的作用只是让与会人员认识到大家取得了一致意见。</li>
<li>多提建议，少谈问题 管理者希望听到解决问题的方法，而不是听你报怨。最好根据问题的重要性列举出多种解决方案，并附上你的依据和建议。</li>
<li>向上司借力 许多员工不懂得向上司借力。假如你通过分析得出了解决方案，公司高管没有时间与你进行会前沟通，但你的上司能找到机会与他们交流，你可以把想法告诉上司，请他帮你转达建议。上司也想尽早结束会议，因而会乐于帮你。</li>
<li>充分准备 管理者通常聪明过人，能够立马发现你思路和计划上的漏洞。你最好准备充分，弄清问题所在，做到有备无患。</li>
<li>缩短邮件篇幅 产品经理喜欢写长篇的邮件向上司汇报工作，这是大忌。上司每天可能会收到上百封邮件，他更希望用简明扼要的方式进行交流。收件人的级别越高，邮件的篇幅就该越短。你可以添加附件，但不要让正文篇幅过长。</li>
<li>多用数据和事实说话 与上司（尤其是高管）打交道时，务必要提供数据和事实。网景公司前CEO吉姆·巴克斯德尔（Jim Barksdale）说过一句名言：如果我们依照个人看法来做决定，那就是臆断。多做准备工作，收集事实和数据，你的建议才有说服力。</li>
<li>内部宣传 向公司同事宣传产品，让大家认可你的工作，乐于帮助你。充分、有效的宣传，可以大大降低与其他部门合作的成本。</li>
<li>做让领导省心的员工 管理者的工作是保证团队高效运作，他们时间有限。不要劳烦你的上司做你的导师，但可以在你的直接管理层外另寻导师。思考如何节省上司的时间，你会获益匪浅。</li>
</ol>
<h2 id="u8BC4_u4F30_u4EA7_u54C1_u673A_u4F1A"><a href="#u8BC4_u4F30_u4EA7_u54C1_u673A_u4F1A" class="headerlink" title="评估产品机会"></a>评估产品机会</h2><p>市场给予新产品诸多机会，即使成熟的市场也不例外。因为市场环境充满变数：竞争对手不断被淘汰，新技术、新创意不断涌现……产品经理必须用他灵敏的“嗅觉”，从纷至沓来的机遇中迅速评估、挑选出有市场潜力、可行的创意，过滤那些没有价值或时机尚不成熟的点子。</p>
<p>为了评估产品机会，我要求产品经理回答如下十个问题。</p>
<ol>
<li>产品要解决什么问题？（产品价值）</li>
<li>为谁解决这个问题？（目标市场）</li>
<li>成功的机会有多大？（市场规模）</li>
<li>怎样判断产品成功与否？（度量指标或收益指标）</li>
<li>有哪些同类产品？（竞争格局）</li>
<li>为什么我们最适合做这个产品？（竞争优势）</li>
<li>时机合适吗？（市场时机）</li>
<li>如何把产品推向市场？（营销组合策略）</li>
<li>成功的必要条件是什么？（解决方案要满足的条件）</li>
<li>根据以上问题，给出评估结论。（继续或放弃）</li>
</ol>
<p>开发新产品能为老用户提供更多选择，还能吸纳新用户；改善原有产品能提高老用户的满意度，也能吸纳新用户。两者各有千秋。</p>
<h2 id="u4EA7_u54C1_u63A2_u7D22"><a href="#u4EA7_u54C1_u63A2_u7D22" class="headerlink" title="产品探索"></a>产品探索</h2><p>管理层坚持给产品探索设定期限，主要有如下原因。</p>
<ol>
<li>探索产品的过程不可预测。管理层担心花几个月研究解决方案，最后却做不出产品，而如果按计划进入开发阶段，至少有事可做。</li>
<li>开发人员是紧缺资源，开发团队无事可做会让管理层抓狂。问题是，这反而导致开发资源被浪费。 不管大家意识到没有，所有的公司都会执行探索产品的流程，只不过有些公司不是利用产品原型完成这项工作，而是孤注一掷，用实际产品搭上全部开发时间进行产品探索。他们开发的是一款非常昂贵的原型，让不知情的用户掏钱参与原型测试。这些公司需要一两年时间（发布几个版本）才能赢利。</li>
</ol>
<h2 id="u4EA7_u54C1_u539F_u5219"><a href="#u4EA7_u54C1_u539F_u5219" class="headerlink" title="产品原则"></a>产品原则</h2><p>产品原则是对团队信仰和价值观的总结，用来指导产品团队作出正确的决策和取舍。它体现了产品团队的目标和愿景，是产品战略的重要组成部分。从形式上看，它是一系列明确的、体现团队特色的产品价值准则。</p>
<p>每次加入新团队，我要做的第一件事就是制定产品原则。制定产品原则意味着决定什么重要、什么不重要，哪些原则是根本的、战略性的，哪些是临时的、战术性的。产品原则不是产品功能的清单，不依赖于任何单独的产品，它是整个产品线的战略指南，是公司的价值宣言。好的产品原则甚至可以激发设计产品的灵感。制定产品原则的过程也是学习的过程，我可以从中了解新公司的企业文化，以及公司创始人设立的企业目标。产品原则是一套价值判断的框架，帮助公司作出正确的决策。</p>
<p>制定产品原则时容易出现两类错误。第一类是原则过于空泛，失去了指导作用。第二类是把设计原则误当成产品原则，比如，为用户提供清晰的导航路径（方便用户完成下一步操作）属于常见的设计原则，不是产品原则。</p>
<p>不少产品经理向我抱怨说，他们受够了没完没了的会议（既无议程也无结果），以及会议中的那些争论、冲突。公司高管还时不时打断会议进程，扔下没头没脑的意见，然后拂袖而去，留下他们丈二和尚摸不着头脑。 这种情况在产品决策过程中经常发生，原因主要有以下几点：第一，每位同事对公司的产品都有自己的看法；第二，大家都非常在乎产品，明白公司营利得靠用户，只有产品才能吸引用户；第三，许多人以为自己比其他人了解目标用户，事实上并非如此。</p>
<p>务必认真分析产品目标的优先级（从最重要到最不重要逐项排序），让团队达成共识。切不可囫囵吞枣地把所有目标都贴上“关键”和“重要”的标签。一定要区分什么最重要，什么第二重要…… 我常被请去解决产品决策中出现的争议，我发现，多数团队跳过了这关键的一步。由于缺少基本评估标准，每个人对目标和优先级的理解都不同，大家往往情绪激动，在细枝末节上争执不下。</p>
<p>即使大家已经达成共识，也应该在讨论开始前再次予以强调，最好把目标按优先级顺序写在白板上，这样每位同事都可以看到评估方案和制定决策的确切依据。制定决策的过程和依据必须完全透明，不要让人觉得你只凭直觉判断。务必告诉大家决策的依据和理由，清楚地展示每一个决策环节。激烈的会议争论会影响大伙的斗志和工作效率。如果再出现这种情况，请先回顾产品目标和目标优先级，确保大家达成共识。</p>
<h2 id="u4EA7_u54C1_u8BC4_u5BA1_u56E2"><a href="#u4EA7_u54C1_u8BC4_u5BA1_u56E2" class="headerlink" title="产品评审团"></a>产品评审团</h2><p>产品评审团并不是设计和开发产品的团队，它的职责是监督产品研发流程，制定关键决策。 它根据研发产品的四个里程碑来评审产品，制定决策。</p>
<ol>
<li>评审产品战略和产品路线图，启动评估产品机会的工作，即选择值得投入精力的产品，请产品经理开始评估产品机会。</li>
<li>根据评估产品机会的结果，决定是否开始定义产品的解决方案。</li>
<li>评审产品原型、用户测试结果、成本估算明细，决定是否开始开发产品。</li>
<li>评审最终产品、产品品质、发布计划、社会效应，决定是否发布产品。</li>
</ol>
<h2 id="u7279_u7EA6_u7528_u6237"><a href="#u7279_u7EA6_u7528_u6237" class="headerlink" title="特约用户"></a>特约用户</h2><p>组织特约用户的注意事项</p>
<ol>
<li>不要向特约用户收取参与费用，否则合作关系将会变味。产品经理需要的是开发产品的伙伴，不要变成为特约用户开发产品。如果特约用户愿意，你尽可以等正式产品发布后再向他们收取费用。</li>
<li>由于可以免费试用产品，通常会有大量的申请者申请成为特约用户。公司的销售部门为了提高业绩，可能会要求产品经理招募更多的用户。这会消耗产品经理大量的精力，而且这些用户不一定符合要求。为了满足大批心急的用户，公司可以发布预览版产品。特约用户的人数绝不能超过十个，否则产品经理不可能有时间和精力与每位用户深入沟通。</li>
<li>如果在寻找特约用户时遇到困难，很可能是因为产品要解决的问题不像产品经理想象的那么重要，将来也很难销售出去。这可以初步验证产品创意是否有价值。出现这种情况，产品经理应该重新考虑产品计划。</li>
<li>产品经理需要确保特约用户是产品的潜在目标用户。我们很容易把产品尝鲜者（early adopter）误当成特约用户。产品尝鲜者常常能容忍产品的不足和缺陷，根据他们的建议研发的产品，很可能只适合他们自己，无法满足大众的需求（参见第35章）。</li>
<li>产品经理务必向特约用户说明，我们要开发的是面向大众的通用产品，不是为某家公司开发的定制产品。特约用户也不希望出现这种情况，因为小众产品的生命周期比较短，一旦产品被淘汰，售后服务也将被取消。产品经理应该向特约用户承诺产品不会昙花一现。</li>
<li>产品经理应该把特约用户当成开发伙伴对待，视他们为同事，互相帮助。许多特约用户和我结下了深厚持久的友谊。</li>
<li>产品经理与特约用户的合作贯穿产品研发的每个环节：向他们展示产品原型，请他们参加测试，向他们请教产品的细节问题，让他们帮你部署、测试待发布产品的备选版本。</li>
<li>正式产品发布之前，一定要先请特约用户试用，确保每个人都满意，一旦发布，他们会坚定不移地向大众推荐产品。</li>
<li>产品经理还要和产品营销团队紧密合作。一方面，营销团队可以帮助你物色特约用户；另一方面，他们可以协助你提高特约用户受关注的程度。</li>
<li>如果是平台产品，特约用户的作用就更突出了，只不过六个特约用户要换成六个应用。产品经理要与特约应用的开发者紧密合作，确保在平台上构建的应用让用户感到满意，最好鼓励应用开发者发展自<br>己的特约用户。</li>
</ol>
<h2 id="u5E02_u573A_u8C03_u7814"><a href="#u5E02_u573A_u8C03_u7814" class="headerlink" title="市场调研"></a>市场调研</h2><p><strong>用户调查</strong></p>
<p>网络降低了用户调查的难度，提高了调查的效率，以至于现在几乎所有产品都要求做用户调查。做用户调查要注意两点。第一，设计调查问卷需要技巧和经验，不是一件容易的事。要结合具体情景，仔细设置问题，如果调查问卷措辞不清、先入为主，其他部门的同事就会质疑调查结果。第二，调查结果为获得解决方案提供了一条途径，但不是解决方案本身。哪怕所有用户都回答喜欢X特性，我们还是可以通过提供Y特性更实际地解决他们的需求。</p>
<p><strong>产品使用分析</strong></p>
<p>如果你的产品是网站，有很多实用的工具可以分析用户访问网站的行为。这些工具正确安装和配置后即可使用，非常划算。越早使用分析工具越好，不断地观察学习，然后调整产品。如果你的产品不是网站，可以在产品中添加分析工具，记录用户使用产品的行为。应该明确告知用户分析工具的用途，声明只收集统计数据，不涉及用户隐私。这样做虽然麻烦，但很值得。</p>
<p><strong>数据挖掘</strong></p>
<p>收集数据的渠道很多，除了上面提到的产品使用分析，还有用户的账单和账户信息、产品数据等。新的数据分析工具的功能越来越强。想知道同时使用几项服务的用户性别比例？想知道特定人物角色的活跃程度和分布情况？新的数据分析工具可以轻松回答这类问题。</p>
<p><strong>拜访用户</strong></p>
<p>没有一种方法可以替代前往用户使用产品的场所（家、办公室）实地考察的作用。虽然拜访用户成本高、耗时长，但我每次都能收集到从其他途径无法了解的信息。拜访用户很有效，但出于对资金和时间成本的考虑，建议谨慎使用。</p>
<p><strong>人物角色</strong></p>
<p>我喜欢在定义和设计产品的过程中使用人物角色。市场调研也可以借助人物角色展开。请记住，你要面对的绝不是单一类型的用户，务必找出若干主要用户类型，深入了解他们，弄清哪些是当前的用户，哪些是潜在的用户。具体内容请参考第17章。</p>
<p><strong>可用性测试</strong></p>
<p>我主张尽早、反复地进行可用性测试（请参考第22章）。观察用户使用现有产品的反应，收集反馈意见，了解他们的真实想法。从用户的视角重新审视产品，不光阅读反馈信息，更要观察、记录用户的行为和反应（比如兴奋、沮丧）。现在还有工具带有远程功能，可以在异地进行可用性测试，记录、分析用户行为。</p>
<p><strong>同类产品分析</strong></p>
<p>产品团队常常低估了竞争对手。就我的经验而言，每款产品都有做得好的地方。有必要找出竞争对手的优势，学习对手的成功经验。</p>
<p>合理地利用市场调研工具和方法可以回答以下几个关键问题。</p>
<ol>
<li>谁是目标用户？</li>
<li>用户会怎样使用产品？</li>
<li>用户能想明白怎样使用产品吗？障碍在哪里？</li>
<li>用户为什么选用你的产品？</li>
<li>用户喜欢产品的哪些特点？</li>
<li>用户希望如何改进产品，增加哪些功能</li>
</ol>
<p>探索（定义）产品的过程则要回答如下问题。</p>
<ol>
<li>采用什么技术来更好地解决产品要解决的问题？</li>
<li>设计什么样的用户体验？</li>
</ol>
<h2 id="u4EA7_u54C1_u4EBA_u7269_u89D2_u8272"><a href="#u4EA7_u54C1_u4EBA_u7269_u89D2_u8272" class="headerlink" title="产品人物角色"></a>产品人物角色</h2><p>作为产品管理的工具，人物角色的主要用途如下。</p>
<ol>
<li>人物角色可以用来筛选重要的产品功能。假设目标用户是“玛丽”，就该添加对“玛丽”重要的功能；如果某项功能只是针对“山姆”的，就该被淘汰。人物角色既有助于决定谁是目标用户，也有助于决定谁不是目标用户，两者同样重要。面面倶到的产品往往一无是处，使用人物角色可以避免犯这种错误。</li>
<li>产品团队常常把自己的需求当成用户需求，我在别处讨论过这个问题，使用人物角色可以避免犯这类的错误。</li>
<li>许多产品的用户类型不止一种。如果只是简单地针对每种用户添加功能，结果会是一团乱麻。这主要是设计上的问题，使用人物角色有助于对用户类型的优先级进行排序，识别需要重点考虑用户体验的地方。</li>
<li>有了人物角色，可以方便地向团队描述产品的目标用户是谁，他们怎样使用产品，他们关心产品的哪些方面。</li>
<li>和产品原则一样，人物角色可以帮助团队成员达成共识。产品发布之前有数以千计的细节问题要解决，产品经理和设计师不可能事必躬亲。如果产品经理、设计师、文案创作人员、开发人员、测试人员在产品原则和人物角色上达成共识，解决问题的效率会更高。</li>
</ol>
<h2 id="u91CD_u65B0_u5B9A_u4E49_u4EA7_u54C1_u8BF4_u660E_u6587_u6863"><a href="#u91CD_u65B0_u5B9A_u4E49_u4EA7_u54C1_u8BF4_u660E_u6587_u6863" class="headerlink" title="重新定义产品说明文档"></a>重新定义产品说明文档</h2><p>我认为理想的产品说明文档应该满足以下要求。</p>
<ol>
<li>产品说明文档应该完整地描述用户体验——不只是用户需求，还包括交互设计和视觉设计。希望大家已经明白用户需求和用户体验是密不可分的。</li>
<li>产品说明文档必须准确地描述软件的行为。文字和图片的表达能力实在有限，不足以完成这项任务。</li>
<li>产品说明文档的受众较广——开发人员、测试人员、客服人员、市场营销人员、运维人员、销售人员、管理层等等。因此，产品说明文档必须以某种直观的方式把产品信息和产品行为告诉所有人。</li>
<li>产品说明文档应该可以修改。虽然进入开发阶段后，应该尽量避免修改产品说明文档，但总有意想不到的问题出现，需要修改产品说明文档以适应新情况。</li>
<li>撰写产品说明文档的过程中会出现许多衍生物，比如，按优先级排列的需求列表、线框图、实体模型，但应该有一个主体来代表产品，避免混淆不清，版本错乱。在我看来，只有一种形式的产品说明文档可以满足以上所有要求，那就是高保真产品原型。</li>
</ol>
<h2 id="u7528_u6237_u4F53_u9A8C_u8BBE_u8BA1_u4E0E_u5B9E_u73B0"><a href="#u7528_u6237_u4F53_u9A8C_u8BBE_u8BA1_u4E0E_u5B9E_u73B0" class="headerlink" title="用户体验设计与实现"></a>用户体验设计与实现</h2><p>许多团队把用户体验设计和软件开发放在一起进行，这是行不通的。原因如下。</p>
<ol>
<li>与软件开发团队合作的人要记住一点：一旦产品进入开发阶段，再修改设计思路是非常困难的，而且越往后修改的成本越高。因为开发团队必须根据确定的用户需求和产品定义设计软件架构，然后进行开发。前期架构决策极大地制约着后期的开发工作，事后修改软件架构，无异于推翻重来。另外，从心理上说，事后修改设计会打击开发人员的斗志，引发消极的心态。随着时间一分一秒过去，返工和波动会增加团队的压力。尽管敏捷方法提倡不断修改和完善，但并非所有的修改都受欢迎。</li>
<li>用户体验设计要保证产品同时具备可用性和价值，任务很重。为了拿出既可用又具有价值的设计，必须尽早、反复地验证设计思路。有些人觉得可以等到每个迭代周期结束再观察设计思路是否合适，甚至等到产品公开测试时再收集用户反馈，这样低效的验证方法肯定是行不通的。优秀的用户体验设<br>计师一两天内要尝试几十个点子，哪怕只是2～4周的迭代周期都会慢得让人无法忍受。</li>
<li>我认为验证设计思路必须使用高保真原型。有人说，迭代结果和公开测试的产品可以当做原型。抛开要等很长时间不谈，这些开发中的产品与产品原型有很大的区别，不能混用。为了验证各种设计思路，产品原型应该可以随意修改，完成其任务后应该被丢弃。而开发中的产品应该以固定的原型为基础。</li>
<li>尽管产品开发可以分成多次迭代（这样做可以降低风险，提高质量，便于产品集成），用户体验设计却不能拆分。设计师必须全面地、连贯地看待用户体验，考虑以往用户的使用习惯。让用户放弃不可用的软件很容易，要他们放弃使用习惯却很难。</li>
<li>用户体验设计不一定是最费时间的工作（像软件开发一样，所需时间取决于具体的方法、特定的产品需求，以及从业者的技能和经验），但至少需要一两周时间。</li>
</ol>
<p>只有在开发人员要开发大量后台基础软件的情况下，用户体验设计和软件开发才能并行展开。在这种情况下，开发团队可以利用设计师设计产品的时间完成这部分工作。虽然双方的工作会有一些依赖关系，但可以解决。多给设计师一些时间定义详细的待开发任务。</p>
<h2 id="u57FA_u672C_u4EA7_u54C1"><a href="#u57FA_u672C_u4EA7_u54C1" class="headerlink" title="基本产品"></a>基本产品</h2><p>我号召产品团队放弃老式的产品设计方式。比如，不再试图定义最终产品，转而定义只满足基本要求（价值、可用性、可行性）的产品，简称基本产品。一旦基本产品定义完成，通过了用户测试，它就是一个不可分割的整体，去掉任何元素，都不可能获得预期的效果。</p>
<h2 id="u4EA7_u54C1_u9A8C_u8BC1"><a href="#u4EA7_u54C1_u9A8C_u8BC1" class="headerlink" title="产品验证"></a>产品验证</h2><p><strong>可行性测试</strong></p>
<p>首先要明确在现有的技术条件下，能否成功开发出产品。邀请架构师和开发人员深度参与技术调研，寻找可行的方案。有些方案通向死胡同，但总有些是可行的。重点是让开发人员寻找产品设计里那些难以克服的障碍，现在发现远比损失了时间和资金后发现来得好。有些产品的技术风险较大，如果你的产品存在可行性风险，一定要提前解决这些问题。</p>
<p><strong>可用性测试</strong></p>
<p>交互设计师应该与产品经理密切合作，想方设法突出产品的功能特性，让不同类型的用户都能明白如何使用。可用性测试往往能发现没能成功实现的产品需求，如果测试得当的话，甚至能发现原本被忽略的产品需求。最好规划多次迭代测试，确保实现最佳的用户体验效果。一定要请真实的用户来试用可用性原型，从目标用户那里可以得到宝贵的反馈信息。虽然产品经理和设计师也能从设计和使用原型的过程中掌握大量信息，但这些都不能代替让真实用户体验原型的作用。</p>
<p>请注意，为了测试可用性，即使要模拟复杂的后台处理过程也是值得的，关键是要评估用户体验的实际效果。</p>
<p><strong>价值测试</strong></p>
<p>最后，仅仅知道产品能够开发出来、方便使用，这还不够。同样要紧的是知道用户是否觉得你的产品有用，是否愿意购买，有多喜欢产品的设计。价值测试可以和可用性测试同时进行，使用的原型也是一样的。只不过可用性测试重在观察用户如何设法完成必要的操作，而价值测试重在观察用户是否喜欢这些功能，是否满意功能的具体实现方式。</p>
<p>简单的产品也许在纸上画画原型就够了，但对于大多数采用复杂用户界面、运用新技术的产品来说，必须借助产品原型评估设计是否符合要求。不同的产品有不同的原型，比如，常见的原型是可点击的页面，当然，原型也可能是物理设备，或是软件与硬件的结合。无论哪种形式的原型都必须足够真实（高保真），可以提供给目标用户测试，并获取有效的用户反馈信息。</p>
<p>使用原型并非验证产品（尤其是互联网服务）的唯一方式，还有其他简单有效的方法，但它们都强调在正式开发软件前验证产品设计，因为设计总有考虑不周、出人意料的情况。越早发现问题越好，不要等到产品公开测试，甚至正式发布才醒悟。一旦进入开发阶段，修改产品设计的难度和成本会越来越高。</p>
<h2 id="u6539_u8FDB_u73B0_u6709_u4EA7_u54C1"><a href="#u6539_u8FDB_u73B0_u6709_u4EA7_u54C1" class="headerlink" title="改进现有产品"></a>改进现有产品</h2><p>产品经理应该时刻关注这些指标，与交互设计师、用户研究人员、主程序员密切合作，分析改善产品的可能性。想要进一步了解产品情况，还可以进行网站分析，请用户测试产品，向客服人员、销售人员了解情况，做盈亏分析，估算净推荐值。在互联网服务领域，可以获得几乎实时的数据反馈。通过分析这些数据改进产品，往往能收到事半功倍的效果。</p>
<p>记住，改进产品不是简单地满足个别用户的要求，也不能对用户调查的结果照单全收。能提高指标的功能才是你关注的重点。你应该找准方向，分析关键指标，有针对性地改进产品。</p>
<h2 id="u5E73_u6ED1_u90E8_u7F72"><a href="#u5E73_u6ED1_u90E8_u7F72" class="headerlink" title="平滑部署"></a>平滑部署</h2><p>毫无征兆地更新不必要的版本会令用户产生反感。有件事你可能觉得难以置信，但的确是事实：不是所有用户都喜欢新版本的产品。用户产生反感主要有以下几个原因。</p>
<ol>
<li>事前没有收到更新通知，用户觉得措手不及。</li>
<li>用户没时间学习、适应新版本，产品公司也没有提供旧版本方便用户在过渡阶段使用。</li>
<li>新版本无法正常运行。</li>
<li>新旧版本不兼容（比如新版本无法访问旧版本的数据）。</li>
<li>虽然新版本可以正常运行，但用户认为添加的功能和特性毫无必要。</li>
<li>应付接二连三的版本更新，用户感到疲惫不堪。</li>
<li>新版本修改了用户已经习惯的使用方式和操作流程，用户不得不重新调整适应。通常情况下，用户不喜欢变化。虽然他们也希望产品更完善，功能更丰富，但前提是不改变已有的使用习惯，大多数人不愿意花时间学习、适应新的使用方式。</li>
</ol>
<p>为了将版本更新带来的负面影响降到最低，可以采取以下几种措施。</p>
<ol>
<li>通过公告、群发邮件、在线教程等方式提前通知用户，但是很多人既没时间也没兴趣阅读这些内容，所以这个方法效果有限。</li>
<li>加倍做好测试工作，避免新版本存在影响正常使用的隐患，比如可靠性问题、扩展性问题、性能问题。确保将来不会陷入被迫返回旧版本的窘境，为用户增加不必要的麻烦。</li>
<li>如果更新版本会影响大规模的用户，应该采取并行部署或者增量部署的方式来降低风险。平滑部署的方式很多，比如发布两个并行的版本，邀请有兴趣、有时间的用户试用新版本。如果新版本运行正常，大部分用户习惯新版本后，再将新版本设为默认版本。同时将旧版本保留一段时间，公示为旧版本提供支持的最后期限，以便没来得及习惯新版本的用户在这段时间内能照常使用产品。</li>
</ol>
<p>对于用户数量庞大的服务和产品，这个过渡可能需要几个月的时间。产品经理还要准备好承担来自开发团队和运维团队的压力，毕竟支持并行版本不是件容易的事。另一种平滑部署的方式是区域性逐步部署，首先在某个区域内部署新版本，然后逐步扩大范围。还有一种方式是增量部署，将更新项分割成几个较小的部分逐步发布。无论采用哪种处理方式，关键要全面考虑更新可能带来的“副作用”，为用户提供便利，方便他们在空闲时适应变化，同时尽可能降低新版本带来的负面影响。</p>
<h2 id="u5FEB_u901F_u54CD_u5E94_u9636_u6BB5"><a href="#u5FEB_u901F_u54CD_u5E94_u9636_u6BB5" class="headerlink" title="快速响应阶段"></a>快速响应阶段</h2><p>我反复强调发布产品不等于大获全胜，交付产品后依然需要保持高度警惕。本章详细介绍产品交付后的收尾工作。产品发布后，多数公司会迅速撤走为研发产品和发布产品整合的资源，急于投入下一个项目，殊不知此时正是收集反馈信息、改进产品的最佳时机。急于“撤军”是项目管理和产品开发流程中的大忌，只要稍微延长项目周期，观察用户对产品的反应，效果就会有天壤之别。这样做投资之小、回报之高会令你瞠目结舌，绝非其他项目阶段可比。</p>
<p>我向来坚持产品发布后的几天至一周内，所有项目成员应该留出时间作为快速响应阶段。这个阶段的主要工作是快速响应、处理产品发布后的用户反馈意见。快速响应阶段最早是针对大众网络服务的，因为大众网络服务特别重视用户的反馈意见。我相信它同样适用于平台产品、基础设施类产品、企业级产品。</p>
<h2 id="u5408_u7406_u8FD0_u7528_u654F_u6377_u65B9_u6CD5"><a href="#u5408_u7406_u8FD0_u7528_u654F_u6377_u65B9_u6CD5" class="headerlink" title="合理运用敏捷方法"></a>合理运用敏捷方法</h2><p>注意这些诀窍只适用于产品软件团队，不适用于定制软件团队。</p>
<ol>
<li>产品经理即是产品负责人（product owner），他代表了客户的需求，因而需要与产品开发团队保持密切的联系，协助督促开发进程，及时解决出现的问题。有些产品经理以为敏捷方法可以让工作变得轻松，这是大错特错的。如果产品经理和产品负责人不是由一个人担任，通常会埋下隐患（参见第2章）。</li>
<li>使用敏捷方法绝不等于省略产品规划。产品经理仍然要明白产品的方向和目标，设定衡量产品成功与否的标准。只不过在敏捷环境里，规划周期应该适度缩短，反复迭代，采用轻量级的机会评估方法替代冗长的市场需求文档（参见第11章）。</li>
<li>产品经理和设计师的工作进度应该比开发团队领先一两个迭代周期，确保你们有足够的时间攻克难题。让交互设计师和视觉设计师提前设计产品，充分发挥他们主导设计的作用，不能一边设计一边开发（参见第19章）。另外，始终让开发人员参与评估产品设计和产品原型，及时反馈关于可行性、成本、解决方案的建议。</li>
<li>尽量把产品设计工作拆分成独立的部分，分而治之，但也不能拆得太细——好比设计建筑不能一次只设计一个房间。目标是设计出符合基本要求的产品（参见第20章）。值得注意的是，在敏捷环境里，设计师必须加快工作速度，采用迅速制作原型的方法更能适应敏捷环境。</li>
<li>产品经理的主要任务是定义有价值、可用的产品原型和用户故事（user story），作为开发的基础。用产品原型和用户故事替代厚厚的产品需求文档和功能说明文档有三个优势：①可以请用户测试；②强迫产品经理全面认真地思考问题；③向开发团队明确地描述每次迭代周期需要完成的任务。请用户测试原型，根据反馈意见反复迭代修改原型设计，确保交给开发团队的是有价值的结果，避免任何浪费，哪怕只是一个迭代周期。</li>
<li>让开发人员自主划分迭代周期。有的产品功能可以在一个迭代周期完成，有的却需要好几次迭代才能完成。好的原型可以提高估算工作量和开发时间的精度。别忘了，开发团队必须考虑产品的质量、性能、扩展性，应该让他们自行决定如何划分迭代周期。</li>
<li>产品经理和交互设计师必须出席每天的晨会。晨会是一天沟通过程的开始，而不是结束，关于产品的讨论会持续一整天。设计师向开发人员和测试人员展示产品功能；开发人员互相展示完成的代码，让测试人员测试，请设计师和产品经理过目；测试人员和开发人员在制作原型的阶段识别潜在的问题，协助产品经理制定更合理的决策，解决产品设计、开发的问题。</li>
<li>除非达到了产品经理的要求，否则不要轻易发布新版本。产品经理必须确保交给用户的产品能正常运行。过度频繁更新版本会让用户感到不安（参见第24章）。</li>
<li>在每次迭代完成后，产品经理应该向团队展示产品现状，以及下次迭代的产品原型，让大家看到工作成果，同时加深大家对产品的理解，增强团队对这种开发方式的信心。</li>
<li>在团队内展开敏捷培训。聘请敏捷顾问协助你们完成向敏捷团队转型的目标，但是要确保敏捷顾问有过类似的工作经验，理解产品软件与定制软件的差别。只有每位团队成员都真正理解敏捷方法，你才能把工作重心放在执行上，否则敏捷方法就只能停留在教条式的理论层面。</li>
</ol>
<h2 id="u5408_u7406_u8FD0_u7528_u7011_u5E03_u5F0F_u5F00_u53D1_u65B9_u6CD5"><a href="#u5408_u7406_u8FD0_u7528_u7011_u5E03_u5F0F_u5F00_u53D1_u65B9_u6CD5" class="headerlink" title="合理运用瀑布式开发方法"></a>合理运用瀑布式开发方法</h2><p>瀑布式开发方法的基本原则</p>
<p>传统瀑布式开发方法的理念很简单，主要有两点。</p>
<ol>
<li>采用阶段式开发 软件开发过程被事先分成固定的几个阶段：撰写书面的需求说明文档、设计高层软件架构、设计低层细节、编写代码、测试、部署。</li>
<li>采用阶段式评审 每个阶段结束后，对该阶段提交的成果进行评审，评审通过后才能进入下一阶段。</li>
</ol>
<h2 id="u5927_u516C_u53F8_u5982_u4F55_u521B_u65B0"><a href="#u5927_u516C_u53F8_u5982_u4F55_u521B_u65B0" class="headerlink" title="大公司如何创新"></a>大公司如何创新</h2><p>臭鼬工程是工程界的行话，原指秘密军事行动，现指在受限制的条件下，利用自己的时间，低调地进行创新研究。臭鼬工程拯救了很多大公司。在大公司里，普通员工很难凭空获得允许从事创新研究。如果你能拿出阶段性的成果来，获得许可会容易得多。在这种情况下，只要不耽误本职工作，管理层通常会支持你的做法。</p>
<p>有一点要提醒大家，有些公司规定员工在职期间研究出来的成果都归公司所有，所以不要随意拿研究成果自行创业。如果公司因为某些原因不愿意帮助你，你才能尝试谋求其他途径来实现自己的创意。了解硅谷历史的人知道，当年斯蒂夫·沃兹尼亚克（Steve Wozniak）因为惠普公司不愿意进入个人电脑市场，所以离职创业，才有了后来的苹果公司。</p>
<h2 id="u5728_u5927_u516C_u53F8_u65BD_u5C55_u62F3_u811A"><a href="#u5728_u5927_u516C_u53F8_u65BD_u5C55_u62F3_u811A" class="headerlink" title="在大公司施展拳脚"></a>在大公司施展拳脚</h2><p>理解这两点后，我再介绍在大公司施展拳脚的方法。</p>
<ol>
<li>了解公司制定决策的方式 每家公司的企业文化都不相同，制定决策的方式也千差万别。如果公司制定决策的方式不符合你的习惯，不要老想着改变大家来适应自己，要学着融入其中。有些公司虽然有明确的民主决策制度，但最终决策还是要请某位大人物拍板。你千万不要纠缠大家有没有没按照制度办事，与其抱怨，不如主动利用这一点。知道决策权在谁手里，你的工作目标就更明确了。了解他制定决策的方式，他是更看重原型演示、市场数据，还是客户的承诺和评价。如果你需要公司的支持，只需要说服他就行了。</li>
<li>建立人脉网络 在大公司工作必须与人合作，如果你喜欢单枪匹马工作，创业型公司更适合你。你需要同事的协助才能完成设计、开发、发布工作。主动与各个部门的同事结交朋友，聊聊工作的事，向大家介绍你手头的项目，不要等到有事才去找人家。主动帮助他人，积累人脉关系。</li>
<li>臭鼬工程 在大公司里，凭空申请创新资源很困难（参见第29章）。想靠几张画着产品构想的幻灯片说服老板是不切实际的。更可行的方法是找三五个志趣相投的同事在工作之余做出产品原型来。产品原型具有超出想象的说服效果。比起枯燥的陈述，生动形象的演示更有吸引力。数不清的优秀产品是这样诞生的。</li>
<li>自己顶上 说出来你也许不信，大公司里虽然员工众多，但真正需要帮手的时候，却总找不到人。即使是公司高管重视的项目，也难免资源不齐。遇到这种情况，你就得自己想办法了，比如，打电话找人帮忙，甚至自己顶上。在凡事都需要提交材料，有严格流程要求的大公司，与其对抗流程，不如自己主动填写、提交需要的材料。很多时候产品经理还要协助编写技术文档，组织销售培训，提供客户服务。一切为了推出产品，不要计较个人得失。</li>
<li>有选择地据理力争 在大公司工作，多一个敌人不如多一个朋友。如果你不满意同事的工作，或者与他人意见不同，不要随便发脾气，除非这件事对你确实重要，值得你据理力争，撕破脸也在所不惜。与人辩论，要小心措辞，做到对事不对人，不要把对方逼到死角。你的目标是完成产品，别为了一场战役输掉整场战争。</li>
<li>会前沟通，形成默契 在重要的决策会议上，如果有人公开反对你的提议，你会变得非常被动。在这种公开场合下发表的意见，反对者很难改口，你想再挽回就很难了。与其临渴掘井，不如未雨绸缪，设法在会前达成一致意见。会议的主要作用是让与会者认识到大家取得了一致意见。所以会前应该逐一找与会者聊聊，了解每个人的立场，如果有不同的意见，对症下药及时化解，确保他们会投赞成票。</li>
<li>合理分配时间 大公司频繁开会，有些人每天忙于参加大大小小的会议，深夜回家还要回复邮件，忙得不可开交，产品却毫无起色。产品经理应该重新检查会议日程，划掉无关紧要的会议；学会充分信任同事，让他们自己拿主意。产品经理应该留下时间完成自己的本职工作：制定产品战略，构思产品路线图，研究产品原型，分析竞争对手。</li>
<li>分享信息 不管在哪种组织里，沟通都是难题，大公司尤其如此——信息俨然变成了某种货币，大家只想获取，不愿支出。许多人把它看成私有财产，藏起来不愿与人分享。其实有舍才有得，分享信息会让你获得更多的朋友和资源，作为交换，别人也会毫无保留地分享信息给你。充分共享信息对你自己和公司都有好处，这叫共赢。</li>
<li>向上司借力 学会利用上司的关系，可以更好地开展工作。如果你的上司在公司里威望很高，你应该学会向他借力，利用他的人脉关系，传播你的理念，多向他请教，了解公司文化和组织结构。如果需要上司出面说服公司高管，你一定要事前做好充分的准备，为他提供翔实可靠的资料和信息，用实力取得他的信任，让他放心地当你的说客。</li>
<li>传播你的产品理念 多向同事传播你的产品理念，向大家描绘产品愿景，介绍产品策略，演示产品原型，分享用户反馈信息。不要低估了内部宣传潜移黙化的作用。让大家（包括没有直接业务联系的部门同事）不遗余力地支持你。</li>
</ol>
<h2 id="u82F9_u679C_u516C_u53F8_u7ED9_u6211_u7684_u542F_u793A"><a href="#u82F9_u679C_u516C_u53F8_u7ED9_u6211_u7684_u542F_u793A" class="headerlink" title="苹果公司给我的启示"></a>苹果公司给我的启示</h2><ol>
<li>硬件为软件服务 与其他硬件公司不同，苹果公司明白硬件必须为软件服务，这种关系不能颠倒。软件直接服务用户，满足用户需求。采用多点触控显示屏、重力加速器、距离传感器这些硬件技术是为了配合软件满足用户需求，而不是花哨的噱头。苹果公司明白，仅凭华丽的硬件技术和软件效果无法真正吸引用户，一旦消费者过了尝鲜的阶段，就会对产品失去兴趣。要抓住消费者的心，需要更深层的东西。</li>
<li>软件为用户体验服务 所有公司都把用户体验挂在嘴边，只有苹果公司把它放在心里。苹果公司的所有工作都围绕着产品的可用性、交互设计、视觉设计、工业设计展开。研发一款iPhone手机要两年半时间，设计用户体验几乎占了大部分时间。设计团队明白用户体验的重要性，即使阻力重重，也不轻言放弃。公司各个部门不遗余力地支持用户体验设计。相比之下，微软就差得远了，改善Vista用户体验的工作不但效果差，而且进展缓慢。苹果公司明白用户体验是产品立足之本。</li>
<li>用户体验为情感服务 如果非要举出苹果公司成功的秘诀，我相信是这一点：他们比谁都清楚是什么让消费者为产品疯狂，他们知道怎样抓住用户的情感需求。人人都想拥有一台iPhone手机，哪怕是四百美元的天价也心甘情愿！没人把iPhone和RAZR、Treo做比较，它们完全不是一个“重量级”的。我在机场候机时，常常暗中比较人们对待苹果电脑和其他品牌电脑的态度——前者像是宝马，后者像是租来的二手车。如果你胆敢从街头少年手里抢他的iPod，那一定是吃了熊心豹子胆。</li>
<li>产品为真正的需求服务 手机并非苹果公司首创，但他们挖掘出尚未被满足的用户需求。市面上的手机品种成百上千，却没几款让人爱不释手。十几年不变的语音邮件系统、不兼容的地址簿、蹩脚的网页浏览器和电子邮箱，只会让用户抓狂。苹果公司逐一完善这些功能，成功的产品应运而生。在数码音乐播放器领域，他们做得一样出色。很少公司像苹果公司那样理解和运用以上四点。竞相模仿其产品的大有人在，这些公司不过是在照猫画虎，形似神非。</li>
</ol>
<h2 id="u65B0_u74F6_u88C5_u8001_u9152"><a href="#u65B0_u74F6_u88C5_u8001_u9152" class="headerlink" title="新瓶装老酒"></a>新瓶装老酒</h2><p>成功的产品往往不是什么新鲜事物，只是新瓶装老酒，之所以成功，是因为这个“新瓶”做得更好、更方便、更便宜，改变了消费者对“老酒”的印象。</p>
<p>想在成熟的市场抢占一席之地，精明的公司至少要手握两件“法宝”。</p>
<p>第一，对目标市场了如指掌，对现有产品的缺陷洞若观火。我喜欢通过产品可用性测试掌握产品情况（包括自己的产品和竞争对手的产品）。</p>
<p>第二，跟踪最新的技术趋势。新技术层出不穷，让之前无法实现的方案变得可能。虽然谁都没有把握永远走在技术的前列，把最新的技术融入产品设计中，但是只要做到一次，你的产品将所向披靡。</p>
<h2 id="u6050_u60E7_u3001_u8D2A_u5A6A_u3001_u6B32_u671B"><a href="#u6050_u60E7_u3001_u8D2A_u5A6A_u3001_u6B32_u671B" class="headerlink" title="恐惧、贪婪、欲望"></a>恐惧、贪婪、欲望</h2><p>多数软件产品行业的从业者都是理工科或经济学背景，我们每天的工作却和研究人类情感的心理学有关。虽然很少有人意识到这一点，但事实如此。消费者购买产品大多源于情感需求。优秀的产品经理和销售人员明白其中的道理，懂得产品应该满足用户的情感需求。</p>
<p>企业级消费者出于恐惧和贪婪购买产品：如果不买这款产品，竞争对手会超过我，黑客会攻破我的防火墙、客户将弃我而去；如果买了，我会赚得更多、省得更多</p>
<h2 id="u60C5_u611F_u63A5_u7EB3_u66F2_u7EBF"><a href="#u60C5_u611F_u63A5_u7EB3_u66F2_u7EBF" class="headerlink" title="情感接纳曲线"></a>情感接纳曲线</h2><p>杰弗里·摩尔（Geoffrey Moore）在他的作品《跨越鸿沟》中提出了一个颇具影响力的概念——技术接纳曲线，这条曲线涉及了技术创新者、尝鲜者、早期消费大众、后期消费大众和跟随者。这本书尝试解释为什么很少有产品能越过鸿沟——获得尝鲜者以外消费者的青睐。</p>
<p>不要一味从技术角度看待产品，多从用户的角度考虑问题。是什么问题让他们头痛？是什么让他们垂头丧气、愁眉苦脸？比如，如今大家都讨厌旅行——旅行的过程变得毫无乐趣可言；又比如，人人都讨厌电话公司——复杂的话费清单几乎没人能看懂。电话公司仿佛存心为难消费者，每个月月底大家都得提高警惕，免得被忽悠。</p>
<h2 id="u5927_u4F17_u7F51_u7EDC_u670D_u52A1_u4EA7_u54C1"><a href="#u5927_u4F17_u7F51_u7EDC_u670D_u52A1_u4EA7_u54C1" class="headerlink" title="大众网络服务产品"></a>大众网络服务产品</h2><ol>
<li>可用性 在我看来，多数公司不够重视产品的可用性，尤其是开发企业级软件的公司。大众网络服务产品必须具备良好的用户体验。如果用户不清楚怎样使用产品，也不知道产品的优势何在，你就等着关门歇业吧。另外，别忘了产品性能是最重要的一条可用性指标，页面加载缓慢让用户无法忍受，也是糟糕的用户体验。</li>
<li>人物角色 网站用户数量过百万后，产品经理不可能再逐个研究每位用户，只能按典型特征将用户分类，抽象出有代表性的用户类型（人物角色），加以分析。产品每增加一项新功能，都要请典型用户参与测试，根据反馈信息加以完善（参见第17章）。</li>
<li>扩展性 激增的用户数量会带来莫明其妙的问题：数据库崩溃、系统出现性能瓶颈、用户界面罢工。网站上线前进行压力测试虽然可以发现部分问题，但正式使用时总有意想不到的情况出现。实现扩展性需要产品经理、设计人员、开发人员、运维人员的通力协作，最好利用部分开发资源和运维资源（我建议分配20%的资源）专门为系统扩展做好准备。不要到系统承受不了压力，即将崩溃才追悔莫及。从设计系统的第一天开始，就应该不间断地考虑扩展性问题，永远留有余地，不到万不得已不要满负载运行（参见第5章）。</li>
<li>持续可用性 大众网络服务要求一刻也不能停歇，但迄今为止我还没见过哪家网站能做到24×7小时无故障运行。系统中止服务是件痛苦的事，对那些负责解决系统故障的人来说更是如此，不是所有人都适合干这一行。系统出故障的时间没个准，工作日、节假日、周末、深夜，随时可能发生，从业者的压力相当大。在系统设计上保证持续可用性与规划扩展性一样重要。</li>
<li>客户服务 另一件让大众网络服务公司头痛的事是客户服务。传统的客户服务完全无法应付数量庞大的网络用户，收费的网络服务情况更严重。要想降低客服压力，除了尽量减少系统故障和缺陷外别无他法。在这个问题上，节省开支只是一方面，更重要的是维持良好的用户体验。</li>
<li>保护用户隐私 大众网络服务公司容易因侵犯或泄露用户隐私被迫停业。虽然你收集用户资料的初衷可能是好的，比如提供个性化用户体验，但如今电子邮件信息、信用卡卡号等用户数据都是敏感资料，一旦不小心泄露出去，后果不堪设想——接踵而来的负面报道、法律制裁，还有用户的满腔怒火。应尽早树立保护用户隐私的意识，设置用户资料保护机制，千万不能辜负用户对你的信任。最近美国在线的案件给我们敲响了警钟，我们需要警惕，提防自己的员工泄露用户资料。</li>
<li>口碑营销 用户如果喜欢产品，就会主动向家人、朋友、同事推荐。这是宣传产品的最佳方式。令我费解的是，很少有公司充分利用这种营销手段。我建议为用户提供便利，方便他们（通过邮件、短信、社交网络等）向熟人推荐产品。许多公司愿意为吸引新用户支付报酬，不妨向踊跃推荐产品的用户发放奖金。当然奖金激励还是次要的，最重要的是让用户易于向家人、朋友、同事、网友推荐产品。</li>
<li>全球化 优秀的互联网产品很快会被其他国家、地区的用户接受，迅速在互联网覆盖的范围内传播开。易于本地化的产品设计可以大大节省开发成本和开发时间，避免为了语言、货币、文化差异大量改写程序。这样随着产品业务的拓展，你可以迅速适应当地用户的需求。</li>
<li>平滑部署 网站用户数量过百万后，任何小小的变化都会影响大面积的用户，要三思而行。我详细讲述过平滑部署的要点（参见第24章），请大家务必谨慎小心。部署前要仔细测试，逐步过渡，步幅不可过大，为用户留出足够的时间来适应变化。有些公司让新老版本同时运行一段时间，让用户适应过渡，这是个好办法。最后，尽量减少不必要的更新，用户消化、吸收新事物不是件容易的事。</li>
<li>用户社区管理 所有的商业公司都依靠用户生存，这一点对大众网络服务公司来说显得尤为突出，水能载舟亦能覆舟。如果用户认可你的产品，他们会很乐意成为用户社区的一员，同时希望得到重视和认可。与用户交流的方法有很多，多和他们接触，了解他们希望如何改进产品。多用类似于“回馈用户”的活动表达对他们的重视。让公司上下认识到用户的重要性，真正从行动上把用户当做“上帝”。</li>
</ol>
<h2 id="u6253_u9020_u5E73_u53F0_u4EA7_u54C1_u7684_u7ECF_u9A8C"><a href="#u6253_u9020_u5E73_u53F0_u4EA7_u54C1_u7684_u7ECF_u9A8C" class="headerlink" title="打造平台产品的经验"></a>打造平台产品的经验</h2><p>产品管理中难度最大，也最能体现产品经理实力的是定义成功的平台产品。所谓平台产品，是指一类基础软件，应用开发者能在其基础上开发应用程序。平台有很多种，例如，操作系统（如Window操作系统、Mac操作系统、Palm智能手机操作系统）、运行环境（如Java、Flash）、web服务（如亚马逊和eBay的集成应用程序接口）、游戏开发平台（如XNA），以及应用平台（如Facebook和Salesforce.com）。</p>
<h2 id="u6700_u4F73_u5B9E_u8DF5_u7ECF_u9A8C"><a href="#u6700_u4F73_u5B9E_u8DF5_u7ECF_u9A8C" class="headerlink" title="最佳实践经验"></a>最佳实践经验</h2><p>从业二十多年来，我一直在总结打造富有创意产品的方法。这里分享我认为最重要的十个要点。每个要点在书中都有详细描述，希望这里的汇总能加深读者的印象，建议大家结合实际工作来体会。</p>
<ol>
<li>产品管理的职责 许多产品经理将大把的时间浪费在与产品管理无关的工作上，比如，营销管理和项目管理，这些都不是产品经理应该干的活。</li>
<li>用户体验 对于大多数软件产品来说，用户体验就是产品的生命。产品经理应该与交互设计师、开发人员密切合作，设计良好的用户体验，打造有实用价值的产品。</li>
<li>机会评估 用方便快捷的机会评估方法取代过时的市场需求文档。动手设计产品前，先明确产品要解决什么问题，为谁解决问题，以及评估产品的标准。</li>
<li>特约用户 有些产品团队企图绕过用户，直接设计、开发产品，这种想法可笑至极。打造优秀的产品没有任何捷径，只能请用户反复试用产品，不断改进。</li>
<li>产品原则 产品管理工作的主要内容是制定决策。明确的产品原则可以帮助产品经理和产品团队树立清晰的价值标准，作出果断的决策。</li>
<li>人物角色 人物角色是协助产品经理制定决策的另一项工具。把目标用户按特征分类，逐一分析、理解其情感和行为，以此作为决策的依据。</li>
<li>探索（定义）产品 产品经理的主要职责是探索（定义）有价值的、可用的、可行的产品。除非产品经理确定这三点，否则同事的努力都将付之东流。</li>
<li>使用原型 使用高保真原型是探索（定义）产品的关键步骤。原因如下：第一，迫使产品经理深入定义解决方案；第二，可以让真实的用户参与测试、验证产品创意；第三，可以直观地向团队展示产品的设计思路。</li>
<li>用户参与原型测试 有了产品原型，产品经理可以方便地请用户验证产品创意。原型测试是所有产品经理和产品设计师都必须掌握的工作技能。获取有效的用户反馈是产品经理最重要的工作。</li>
<li>根据数据改进产品 成功的产品经理懂得利用数据来改进现有产品。改进产品不是根据客户要求一味增加新功能，而是根据产品的实际应用情况，不断地提升产品的各项指标，逐步完善产品。</li>
</ol>
<h2 id="u4EA7_u54C1_u7ECF_u7406_u7684_u53CD_u7701_u6E05_u5355"><a href="#u4EA7_u54C1_u7ECF_u7406_u7684_u53CD_u7701_u6E05_u5355" class="headerlink" title="产品经理的反省清单"></a>产品经理的反省清单</h2><p>出色的产品经理会时刻关注产品的现状与未来。以下是产品经理无时无刻不在思考的问题。</p>
<ol>
<li>产品能吸引目标消费者的关注吗？</li>
<li>产品的设计是否人性化，是否易于操作？</li>
<li>产品能在竞争中取胜吗？即使是面对未来风云变化的市场，依旧有取胜的把握吗？</li>
<li>我了解目标用户吗？产品（不是理想的产品，而是实际开发出来的产品）是否能得到他们的认可？</li>
<li>产品是否有别于市面上的其他产品？我能在两分钟内向公司高管清楚地阐明这些差别吗？能在一分钟内向客户解释清楚吗？能在半分钟内向经验丰富的行业分析师解释清楚吗？</li>
<li>产品能正常运行吗？</li>
<li>产品是否完整？用户对产品的印象如何？销售业绩如何？销售任务能否顺利完成？</li>
<li>产品的特色是否与目标用户的需求一致？产品特色是否鲜明？</li>
<li>产品值钱吗？值多少钱？为什么值这么多钱？用户会选择更便宜的产品吗？</li>
<li>我了解其他团队成员对产品的看法吗？他们觉得产品好在哪里？他们的看法是否与我的观点一致？为什么每天的思考时间如此重要，为什么产品经理的工作如此费时？原因就在于这十个问题等着他不断地去琢磨。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>这本书基本上说清楚了打造好产品的方方面面，很值得一看。</p>]]>
    
    </summary>
    
      <category term="产品" scheme="http://wdxtub.com/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="方法" scheme="http://wdxtub.com/tags/%E6%96%B9%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
