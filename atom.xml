<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-03-26T16:44:18.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Latex 常用符号表]]></title>
    <link href="http://wdxtub.com/2016/03/26/latex-notation-table/"/>
    <id>http://wdxtub.com/2016/03/26/latex-notation-table/</id>
    <published>2016-03-26T16:37:43.000Z</published>
    <updated>2016-03-26T16:44:18.000Z</updated>
    <content type="html"><![CDATA[<p>这里记录了常用的 Latex 符号及用法</p>
<a id="more"></a>
<hr>
<h2 id="u5B57_u4F53"><a href="#u5B57_u4F53" class="headerlink" title="字体"></a>字体</h2><ul>
<li><code>\mathrm{}</code>，正常字体</li>
<li><code>\mathit{}</code>，斜体</li>
<li><code>\mathbf{}</code>，粗体符号boldfont</li>
<li><code>\mathbb{}</code>，空心粗体blackboard</li>
<li><code>\mathnormal{}</code>，正常字体</li>
</ul>
<h2 id="u6570_u5B66_u516C_u5F0F"><a href="#u6570_u5B66_u516C_u5F0F" class="headerlink" title="数学公式"></a>数学公式</h2><p><img src="/images/14590103911299.jpg" alt=""></p>
<h2 id="u6392_u7248"><a href="#u6392_u7248" class="headerlink" title="排版"></a>排版</h2><ul>
<li><code>\quad</code> 生成一个空格（相当于大写’M’的宽度）</li>
<li><code>\qquad</code> 生成一个大空格</li>
<li><code>\,</code> 相当于3/18个\quad</li>
<li><code>:</code> 相当于4/18个\quad</li>
<li><code>\;</code> 相当于5/18个\quad</li>
<li><code>!</code> 生成一个负空格-3/18个\quad</li>
<li>将 <code>\left</code> 放在分隔符前，tex会自动调整分隔符的大小</li>
<li>但是每个 <code>\left</code> 必须要用一个<code>\right</code>关闭</li>
<li>如果分隔符仅有左括号则用<code>\right.</code>关闭</li>
</ul>
<p>$$\left{ x^2 \right}$$</p>
<h2 id="u7B26_u53F7_u8868"><a href="#u7B26_u53F7_u8868" class="headerlink" title="符号表"></a>符号表</h2><p><img src="/images/14590105384037.jpg" alt=""></p>
<p><img src="/images/14590105424692.jpg" alt=""></p>
<p><img src="/images/14590105464309.jpg" alt=""></p>
<p><img src="/images/14590105502032.jpg" alt=""></p>
<p><img src="/images/14590105541907.jpg" alt=""></p>
<p><img src="/images/14590105592350.jpg" alt=""></p>
<p><img src="/images/14590105659095.jpg" alt=""></p>
<p><img src="/images/14590105709311.jpg" alt=""></p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://hustlei.tk/2014/08/latex-math-equation.html" target="_blank" rel="external">latex数学公式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里记录了常用的 Latex 符号及用法</p>]]>
    
    </summary>
    
      <category term="Latex" scheme="http://wdxtub.com/tags/Latex/"/>
    
      <category term="符号" scheme="http://wdxtub.com/tags/%E7%AC%A6%E5%8F%B7/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google 搜索技巧]]></title>
    <link href="http://wdxtub.com/2016/03/26/google-tip/"/>
    <id>http://wdxtub.com/2016/03/26/google-tip/</id>
    <published>2016-03-26T16:15:16.000Z</published>
    <updated>2016-03-26T16:16:19.000Z</updated>
    <content type="html"><![CDATA[<p>这里记录一些非常有用的搜索技巧，熟练运用后可以有效提升自己的效率。</p>
<a id="more"></a>
<hr>
<h2 id="u64CD_u4F5C_u7B26"><a href="#u64CD_u4F5C_u7B26" class="headerlink" title="操作符"></a>操作符</h2><p><code>+</code> 强制搜索</p>
<p>由于Google会忽略和过滤一些常用词（称为stop words / common words），如and、how等。使用+可以让搜索引擎强制包括这些词。使用+还可以强制过滤关键词变体形式（不让搜索结果出现关键词的其它形式），如单复数、动词时态、ing形式等等。</p>
<p><code>-</code>  逻辑非</p>
<p>用于过滤-号后面的关键词。如：MP3 -MP4，表示只搜索MP3而不要MP4的搜索结果。 -号后面没有空格。</p>
<p><code>~</code> 同义词</p>
<p>关键词前加波浪线。如：~table 。</p>
<p><code>*</code> 通配符</p>
<p>如：Google was founded in * 。</p>
<p><code>**</code> 指数</p>
<p>作用同  ^ ，如：2**10 。</p>
<p><code>&quot; &quot;</code> 引号</p>
<p>用引号精确搜索，有时可只用左侧引号。如：”Google hacking” = “Google hacking 。</p>
<p><code>|</code> 逻辑或</p>
<p>作用同 OR ，如：Google hacking | hacks 。</p>
<p><code>..</code> 数字范围</p>
<p>用于限定数值范围，如：spring festival logo 2002..2009 。</p>
<p><code>^</code> 指数</p>
<p>作用同  ** ，如：2^10 。</p>
<h2 id="u64CD_u4F5C_u547D_u4EE4"><a href="#u64CD_u4F5C_u547D_u4EE4" class="headerlink" title="操作命令"></a>操作命令</h2><p><code>OR</code>  逻辑或</p>
<p>作用同 | ，如：Google hacking OR hacks 。</p>
<p><code>define:</code>  关键词定义</p>
<p>查询关键词的网络释义。如： define:google 。</p>
<p><code>ext:</code>  限定搜索指定文件类型</p>
<p>作用同 filetype:</p>
<p><code>filetype:</code>  限定搜索指定文件类型<br>    作用同 ext: 如：filetype:pdf = ext:pdf 。目前文件类型支持如下格式：<br>    Adobe Acrobat PDF (.pdf)<br>    Adobe Postscript (.ps)<br>    Autodesk DWF (.dwf)<br>    Google地球 KML (.kml)<br>    Google地球 KMZ (.kmz)<br>    Lotus 1-2-3（wk1、wk2、wk3、wk4、wk5、wki、wks、wku）<br>    Lotus WordPro (.lwp)<br>    MacWrite (.mw)<br>    Microsoft Excel (.xls)<br>    Microsoft Powerpoint (.ppt)<br>    Microsoft Word (.doc)<br>    Microsoft Works（wks、wps、wdb）<br>    Microsoft Write (.wri)<br>    Rich Text Format富文本格式 (.rtf)<br>    Shockwave Flash (.swf)<br>    纯文本（ans、txt）</p>
<p><code>intitle:</code>  限定搜索标题中含指定关键词的网页</p>
<p>如： intitle:google search guide 。限定多个关键词用 allintitle:</p>
<p><code>inurl:</code>  限定搜索url中含指定关键词的网页</p>
<p>如： inurl:google search guide 。通过inurl:view.shtml 你可以找到在线的网络摄像头。 限定多个关键词用 allinurl:</p>
<p><code>inanchor:</code>  限定搜索页面链接锚文本中含指定关键词的网页</p>
<p>如： inanchor:google search guide 。限定多个关键词用 allinanchor:</p>
<p><code>intext:</code>  限定搜索正文文本（不含标题和链接）中含指定关键词的网页</p>
<p>如： intext:google vs mircosoft。</p>
<h2 id="u7F51_u7AD9_u7F51_u9875_u547D_u4EE4"><a href="#u7F51_u7AD9_u7F51_u9875_u547D_u4EE4" class="headerlink" title="网站网页命令"></a>网站网页命令</h2><p><code>site:</code>  限定搜索某网站的网页</p>
<p>如： site:www.google.com 。</p>
<p><code>link:</code>  搜索链向某网站/网址的网页</p>
<p>如： link:www.google.com 。</p>
<p><code>related:</code>  搜索与某网页相似或相关的页面</p>
<p>如： related:www.google.com 。</p>
<p><code>cache:</code>  搜索某网页在Google缓存（网页快照）中的旧版本</p>
<p>如： cache:www.google.com 。</p>
<p><code>info:</code>  综合查询某网页的信息，即列出上述四个命令</p>
<p>如： info:www.google.com 。作用同 id:</p>
<h2 id="u56FE_u7247_u641C_u7D22_u4E0E_u5F71_u89C6_u641C_u7D22"><a href="#u56FE_u7247_u641C_u7D22_u4E0E_u5F71_u89C6_u641C_u7D22" class="headerlink" title="图片搜索与影视搜索"></a>图片搜索与影视搜索</h2><p>filetype: 限定搜索指定文件类型的图片，支持如下格式：</p>
<ul>
<li>filetype:jpg</li>
<li>filetype:gif</li>
<li>filetype:png</li>
<li>filetype:bmp</li>
</ul>
<p>imagesize: 限定搜索指定尺寸的图片，如: imagesize:800x600</p>
<p>URL 参数：加在图片搜索网页的 URL 后面，可以实现更精细的搜索</p>
<ul>
<li>&amp;imgtype=news 资讯</li>
<li>&amp;imgtype=face 脸部特写</li>
<li>&amp;imgtype=clipart 剪贴画</li>
<li>&amp;imgtype=lineart 素描</li>
<li>&amp;imgtype=photo 照片</li>
<li>&amp;imgc=gray 黑白图片</li>
<li>&amp;imgc=mono 灰阶图片</li>
<li>&amp;imgc=color 全彩图片</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里记录一些非常有用的搜索技巧，熟练运用后可以有效提升自己的效率。</p>]]>
    
    </summary>
    
      <category term="Google" scheme="http://wdxtub.com/tags/Google/"/>
    
      <category term="搜索" scheme="http://wdxtub.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux 的概念与体系]]></title>
    <link href="http://wdxtub.com/2016/03/26/linux-basic/"/>
    <id>http://wdxtub.com/2016/03/26/linux-basic/</id>
    <published>2016-03-26T15:17:06.000Z</published>
    <updated>2016-03-26T15:38:33.000Z</updated>
    <content type="html"><![CDATA[<p>这篇日志来自 <a href="http://www.cnblogs.com/vamei" target="_blank" rel="external">Vamei 博客</a> 中的系列文章，把一些基本的内容做了整合，方便查阅。</p>
<a id="more"></a>
<hr>
<h2 id="Linux_u7B80_u4ECB_u4E0E_u5382_u5546_u7248_u672C"><a href="#Linux_u7B80_u4ECB_u4E0E_u5382_u5546_u7248_u672C" class="headerlink" title="Linux简介与厂商版本"></a>Linux简介与厂商版本</h2><p><strong>Linux简介</strong></p>
<p>Linux可以有狭义和广义两种定义。狭义来说，Linux实际上指Linux kernel (内核)。内核负责管理硬件，并为上层应用提供接口。而广义来说，是指以Linux kernel为基础的，包括OS和各种应用在内的各个Linux版本(distribution)。尽管看起来版本眼花缭乱，但实际上，各个版本之间也只是大同小异，其差别往往体现在客户群、升级维护和界面等方面。</p>
<p>Linus Torvalds是Linux之父。他根据Minix系统的代码，参照UNIX系统的设计，写出了第一给Linux内核。Linus的创举在于将Linux内核的代码开源。后来，Linux内核和一套开源的应用软件GNU结合，共同采取开源协议，并迅速发展成熟。我们可以随意地使用和修改开源代码，但以此为基础开发的程序也要根据开源协议公开。Linux和GNU的开源性吸引了大批优秀的程序员参与到Linux相关的开发中。</p>
<p>从哲学和设计理念上，Linux与其他的UNIX版本相类似，并使用类似的接口。我们可以通过学习Linux的基本概念和机制来了解其它UNIX系统，比如Solaris, FreeBSD，还有基于FreeBSD的苹果公司的Mac OS。曾经Windows的兴起曾经让许多人认为UNIX将最终被Windows取代，但如今看到Linux和苹果产品的兴盛，我很感慨于UNIX体系的力量。</p>
<p>Linux的有如下比较重要的机制: 用于储存数据以及管理权限的文件系统，用于IO的文本操作API，用于管理操作的进程，用于实现多任务运行的多线程，以及进程间通信(我将信号和网络也都归入这一类中)。</p>
<p>特别推荐下面的一些文章，以便你对Linux有一个概观：</p>
<p><a href="http://www.catb.org/~esr/writings/cathedral-bazaar/introduction/" target="_blank" rel="external">大教堂和市集（The Cathedral and the Bazaar）</a>，作者Eric Raymond</p>
<p>可以说是为Linux正名的一篇文章，深入分析Linux成功的原因。你也可以通过名字来搜索中文翻译版本。</p>
<p>该作者的<a href="http://www.catb.org/~esr/writings/" target="_blank" rel="external">其他文章</a>也非常值得一读。</p>
<p>UNIX传奇，来自酷壳，作者陈皓</p>
<ul>
<li>上篇：<a href="http://coolshell.cn/articles/2322.html" target="_blank" rel="external">http://coolshell.cn/articles/2322.html</a></li>
<li>下篇：<a href="http://coolshell.cn/articles/2324.html" target="_blank" rel="external">http://coolshell.cn/articles/2324.html</a></li>
</ul>
<p>(作者博客内容丰富，又容易读，非常值得订阅。)</p>
<p><strong>Linux的厂商版本</strong></p>
<p>在Linux内核基础上，我们还有许多厂商版本。即使有了内核和GNU软件，Linux的安装和编译并不是简单的工作，Linux厂商就是瞄准了这个市场。这些厂商会在Linux内核的基础上，结合自己开发的软件，帮助用户安装和使用Linux，并提供技术支持。由于在服务器领域，Linux操作系统远远领先于Windows系统，而这些被政府部门、银行或者大学拥有的服务器往往承担很重要的信息处理和IO (input/outpt) 工作，所以尽管Linux开源，厂商还是可以根据其提供的商用软件和技术支持获得丰厚的利润。</p>
<p>(IBM是Linux设备最大的供应商，同时它的咨询业务很大一部份也来源于提供Linux相关的支持。我们所熟知的Android操作系统，也算是Google提供的一个厂商版本。)</p>
<p>我们这里主要介绍在PC上比较流行的Linux厂商版本:</p>
<p><strong>红帽系列</strong></p>
<ul>
<li>Red Hat linux: 大名鼎鼎的红帽，现在已经完结。以此为基础有以下分支:</li>
<li>Red Hat Enterprise: (www.redhat.com) 这个是企业级的linux，主要面向服务器。作为商业版，有比较好的配套软件和技术支持。RH的教材也堪称经典。</li>
<li>Fedora: (<a href="http://fedoraproject.org" target="_blank" rel="external">http://fedoraproject.org</a>) 由社区维护，去除了一些商业软件。红帽实际上赞助了这个项目，以便以此作为技术测试平台。</li>
<li>CentOS: (www.centos.org) 这个版本不来自红帽的公司，是收集红帽公开的源码组成的免费版本，由社区维护，和红帽完全兼容。版本号升级较慢，但有持续的技术支持，所以适合于不愿意频繁升级的情形，鸟哥中就推荐以CentOS来建站。</li>
</ul>
<p><strong>SUSE系列</strong></p>
<ul>
<li>SUSE Linux Enterprise: (www.suse.com) 和红帽商业版类似，是德国公司制作的，据说在欧洲比较流行，但我欧洲的朋友表示没怎么听说过。SUSE系列比较有特色的是YAST2，就是用来设置Linux的界面，对初级管理员比较方便。</li>
<li>openSUSE: (www.opensuse.org) SUSE的免费版本。以前SUSE不是很推这个免费版本，支持不好。现在似乎态度大大转变。就我个人的使用体验来说，还是觉得社区支持不足。</li>
</ul>
<p><strong>Debian系列</strong></p>
<ul>
<li>Debian: (www.debian.org) 完全免费，社区维护的Linux版本，有很大的用户群，所以遇到问题，基本都可以找到社区用户的支持。</li>
<li>Ubuntu: (www.ubuntu.com) 由一个基金提供支持的免费Linux版本。 继承自Debian。界面很友好。发邮件过去，还会送你免费安装CD (不知道现在还有没有)。现在的版本加载的东西有些多，速度有些慢。写《大教堂和市集》的Eric Raymond说它是最好的Linux。</li>
<li>Mint (<a href="http://www.linuxmint.com" target="_blank" rel="external">http://www.linuxmint.com</a>), 基于ubuntu。它提供了更加丰富的预装应用，以减少用户搜索并安装应用的麻烦。其使用的应用版本比较新，可能不是很稳定。</li>
</ul>
<p>此外，还有如下一些版本：</p>
<ul>
<li>Gentoo (www.gentoo.org) 基于源码的版本，提供给用户很大的自由度。为用户提供大量应用程序的源码，可以在用户的系统上重新编译建造。需要一定的系统配置的知识。</li>
<li>ArchLinux (www.archlinux.org)，推崇简洁，避免不必要和复杂的修改，是一个轻便灵活的版本。其配置文件有良好注释。</li>
<li>Mandriva (www.mandriva.com) 一个很方便用户使用的版本，其目标是使得新用户更容易使用linux。</li>
<li>Slackware (www.slackware.com) 稳定，基本。它的只包含稳定版本的应用程序。对于初级用户不是很友好。</li>
<li>TurboLinux (www.turbolinux.com) 在亚洲比较流行。商业版本，提供技术支持和咨询服务。</li>
</ul>
<h2 id="Linux_u5F00_u673A_u542F_u52A8"><a href="#Linux_u5F00_u673A_u542F_u52A8" class="headerlink" title="Linux开机启动"></a>Linux开机启动</h2><p>计算机开机是一个神秘的过程。我们只是按了开机键，就看到屏幕上的进度条或者一行行的输出，直到我们到达登录界面。然而，计算机开机又是个异常脆弱的过程，我们满心期望的登录界面可能并不会出现，而是一个命令行或者错误信息。了解计算机开机过程有助于我们修复开机可能出现的问题。</p>
<p><strong>最初始阶段</strong></p>
<p>当我们打开计算机电源，计算机会自动从主板的BIOS(Basic Input/Output System)读取其中所存储的程序。这一程序通常知道一些直接连接在主板上的硬件(硬盘，网络接口，键盘，串口，并口)。现在大部分的BIOS允许你从软盘、光盘或者硬盘中选择一个来启动计算机。</p>
<p>下一步，计算机将从你所选择的存储设备中读取起始的512 bytes(比如光盘一开是的512 bytes，如果我们从光盘启动的话)。这512 bytes叫做主引导记录MBR (master boot record)。MBR会告诉电脑从该设备的某一个分区(partition)来装载引导加载程序(boot loader)。Boot loader储存有操作系统(OS)的相关信息，比如操作系统名称，操作系统内核 (kernel)所在位置等。常用的boot loader有GRUB和LILO。</p>
<p>随后，boot loader会帮助我们加载kernel。kernel实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过kernel传达给硬件。Windows和Linux各自有自己kernel。狭义的操作系统就是指kernel，广义的操作系统包括kernel以及kernel之上的各种应用。</p>
<p>（Linus Torvalds与其说是Linux之父，不如说是Linux kernel之父。他依然负责Linux kernel的开发和维护。至于Ubuntu, Red Hat, 它们都是基于相同的kernel之上，囊括了不同的应用和界面构成的一个更加完整的操作系统版本。)</p>
<p>实际上，我们可以在多个分区安装boot loader，每个boot loader对应不同的操作系统，在读取MBR的时候选择我们想要启动的boot loader。这就是多操作系统的原理。</p>
<p>小结：BIOS -&gt; MBR -&gt; boot loader -&gt; kernel</p>
<p><strong>kernel</strong></p>
<p>如果我们加载的是Linux kernel，Linux kernel开始工作。kernel会首先预留自己运行所需的内存空间，然后通过驱动程序(driver)检测计算机硬件。这样，操作系统就可以知道自己有哪些硬件可用。随后，kernel会启动一个init进程。它是Linux系统中的1号进程(Linux系统没有0号进程)。到此，kernel就完成了在计算机启动阶段的工作，交接给init来管理。</p>
<p>小结: kernel -&gt; init process</p>
<p><strong>init process</strong></p>
<p>(根据boot loader的选项，Linux此时可以进入单用户模式(single user mode)。在此模式下，初始脚本还没有开始执行，我们可以检测并修复计算机可能存在的错误)</p>
<p>随后，init会运行一系列的初始脚本(startup scripts)，这些脚本是Linux中常见的shell scripts。这些脚本执行如下功能：</p>
<p>设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络……</p>
<p>当这些初始脚本，操作系统已经完全准备好了，只是，还没有人可以登录！！！init会给出登录(login)对话框，或者是图形化的登录界面。</p>
<p>输入用户名(比如说vamei)和密码，DONE！</p>
<p>在此后的过程中，你将以用户(user)vamei的身份操作电脑。此外，根据你创建用户时的设定，Linux还会将你归到某个组(group)中，比如可以是stupid组，或者是vamei组。</p>
<p>所以你将是用户vamei， 同时是vamei组的组员。(注意，组vamei和用户vamei只是重名而已，就好想你可以叫Dell, 同时还是Dell公司的老板一样。你完全也可以是用户vamei，同时为stupid组的组员)</p>
<p><strong>总结</strong></p>
<p>BIOS -&gt; MBR -&gt; boot loader -&gt; kernel -&gt; init process -&gt; login</p>
<p>用户，组。</p>
<h2 id="Linux_u6587_u4EF6_u7BA1_u7406"><a href="#Linux_u6587_u4EF6_u7BA1_u7406" class="headerlink" title="Linux文件管理"></a>Linux文件管理</h2><p>对于计算机来说，所谓的数据就是0和1的序列。这样的一个序列可以存储在内存中，但内存中的数据会随着关机而消失。为了将数据长久保存，我们把数据存储在光盘或者硬盘中。根据我们的需要，我们通常会将数据分开保存到文件这样一个个的小单位中(所谓的小，是相对于所有的数据而言)。但如果数据只能组织为文件的话，而不能分类的话，文件还是会杂乱无章。每次我们搜索某一个文件，就要一个文件又一个文件地检查，太过麻烦。文件系统(file system)是就是文件在逻辑上组织形式，它以一种更加清晰的方式来存放各个文件。</p>
<p><strong>路径与文件简介</strong></p>
<p>文件被组织到文件系统(file system)中，通常会成为一个树状(tree)结构。Linux有一个根目录/, 也就是树状结构的最顶端。这个树的分叉的最末端都代表一个文件，而这个树的分叉处则是一个目录(directory, 相当于我们在windows界面中看到的文件夹)。在图1中看到的是整个的一个文件树。如果我们从该树中截取一部分，比如说从目录vamei开始往下，实际上也构成一个文件系统。</p>
<p>要找到一个文件，除了要知道该文件的文件名，还需要知道从树根到该文件的所有目录名。从根目录开始的所有途径的目录名和文件名构成一个路径(path)。比如说，我们在Linux中寻找一个文件file.txt，不仅要知道文件名(file.txt)，还要知道完整路径，也就是绝对路径(/home/vamei/doc/file.txt)。从根目录录/, 也就是树状结构的最顶端出发，经过目录home, vamei, doc，最终才看到文件file.txt。整个文件系统层层分级(hierarchy)，vamei是home的子目录，而home是vamei的父目录。</p>
<p>在Linux中，我们用ls命令来显示目录下的所有文件，比如 $ls /home/vamei/doc</p>
<p><strong>目录</strong></p>
<p>在Linux系统中，目录也是一种文件。所以/home/vamei是指向目录文件vamei的绝对路径。</p>
<p>这个文件中至少包含有以下条目:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">.       </span>指向当前目录</span><br><span class="line"><span class="bullet">..      </span>指向父目录</span><br></pre></td></tr></table></figure>
<p>除此之外，目录文件中还包含有属于该目录的文件的文件名，比如vamei中就还要有如下条目，指向属于该目录的文件:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">doc</span></span><br><span class="line"><span class="keyword">movie</span><br><span class="line"></span><span class="label">photo</span></span><br></pre></td></tr></table></figure>
<p>Linux解释一个绝对路径的方式如下：先找到根目录文件，从该目录文件中读取home目录文件的位置，然后从home文件中读取vamei的位置……直到找到目录doc中的file.txt的位置。</p>
<p>由于目录文件中都有.和..的条目，我们可以在路径中加入.或者..来表示当前目录或者父目录，比如/home/vamei/doc/..与/home/vamei等同。</p>
<p>此外，Linux会在进程中，维护一个工作目录(present working directory)的变量。在shell中，你可以随时查询到到工作目录(在命令行输入<code>$pwd</code>)。这是为了省去每次都输入很长的绝对路径的麻烦。比如说我们将工作目录更改为/home/vamei (<code>$cd /home/vamei</code>)，那么此时我们再去找file.txt就可以省去/home/vamei/ (<code>$ls doc/file.txt</code>)，这样得到的路径叫相对路径(relative path)，上面的doc/file.txt就是这样一个相对路径。</p>
<p>当文件出现在一个目录文件中时，我们就把文件接入到文件系统中，我们称建立一个到文件的硬链接(hard link)。一个文件允许出现在多个目录中，这样，它就有多个硬链接。当硬链接的数目(link count)降为0时，文件会被Linux删除。所以很多时候，unlink与remove在Linux操作系统中是一个意思。由于软链接(soft link)的广泛使用(soft link不会影响link count，而且可以跨越文件系统)，现在较少手动建立硬连接。</p>
<p><strong>文件操作</strong></p>
<p>对于文件，我们可以读取(read)，写入(write)和运行(execute)。读取是从已经存在的文件中获得数据。写入是向新的文件或者旧的文件写入数据。如果文件储存的是可执行的二进制码，那么它可以被载入内存，作为一个程序运行。在Linux的文件系统中，如果某个用户想对某个文件执行某一种操作，那么该用户必须拥有对该文件进行这一操作的权限。文件权限的信息保存在文件信息(metadata)中, 见下一节。</p>
<p><strong>文件附加信息 (metadata)</strong></p>
<p>文件自身包含的只有数据。文件名实际上储存在目录文件。除了这些之外，还有操作系统维护的文件附加信息，比如文件类型，文件尺寸，文件权限，文件修改时间，文件读取时间等。可以用ls命令查询文件信息($ls -l file.txt)，得到如下结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- <span class="number">1</span> vamei vamei <span class="number">8445</span> Sep  <span class="number">8</span> <span class="number">07</span>:<span class="number">33</span> file1.txt</span><br></pre></td></tr></table></figure>
<p>各个部分的含义如下：</p>
<ul>
<li>我们先介绍最开始的-，它表示文件类型，说明file1.txt是常规文件(如果是目录文件，则应显示d)。</li>
<li>随后有九个字符，为rw-r–r–，它们用于表示文件权限。这九个字符分为三组，rw-, r–, r–，分别对应拥有者(owner)，拥有组(owner group)和所有其他人(other)。回顾Linux开机启动，登录后，我会有一个用户身份和一个组身份, 相当于我的名片。第一组表示，如果我的名片上的用户身份证明我是该文件的拥有者，那么我就可以对该文件有读取(r)，写入(w)该文件的权限，但不拥有执行(-，如果拥有执行权限，则为x)该文件的权限。第二组表示，如果我的名片上的组身份证明我所在的组是该文件的拥有组的一员，那么我有从该文件读入的权限。第三组表示，如果我的名片显示我既不是拥有者，也不是拥有组的一员，那么我只有读入的权限。当我想要进行一个读取操作时，Linux会先看我是否是拥有者下文会进一步解释拥有者和拥有组。</li>
<li>后面的1是硬连接(hard link)数目(link count)。</li>
<li>之后的vamei表示用户vamei是文件的拥有者(owner)，文件的拥有者有权更改文件权限(比如改为rwxrwxrwx)。而后面的vamei文件的拥有组是组vamei。文件的拥有者和拥有组在文件创建时就附加在文件上(相当于给文件上锁，只有有合适名片的用户才能打开操作)。要注意，Linux有一个超级用户root (也叫做根用户)，该用户拥有所有的文件。</li>
<li>随后的8445表示文件大小，单位为字节(byte)。</li>
<li>Sep 8 07:33表示文件的上一次写入的时间(modification time)。实际上在文件附加信息中还包含有文件的上一次读取时间(access time)，没有显示出来。</li>
</ul>
<p><strong>软链接 (soft link, or symbolic link)</strong></p>
<p>如上讨论硬链接时说到的，软链接不会影响文件的link count。如果还记得windows系统的快捷方式的话，Linux的软链接(soft link，也叫做symbolic link)就是linux的快捷方式。软链接本质上是一个文件，它的文件类型是symbolic link。在这个文件中，包含有链接指向的文件的绝对路径。当你从这个文件读取数据时，linux会把你导向所指向的文件，然后从那个文件中读取（就好像你双击快捷方式的效果一样）。软链接可以方便的在任何地方建立，并指向任何一个绝对路径。</p>
<p>软链接本身也是一个文件，也可以执行文件所可以进行的操作。当我们对软链接操作时，要注意我们是对软链接本身操作，还是对软链接指向的目标操作。如果是后者，我们就说该操作跟随链接指引(follow the link)。</p>
<p>umask</p>
<p>当我们创建文件的时候，比如使用touch，它会尝试将新建文件创建为权限666，也就是rw-rw-rw-。但操作系统要参照权限mask来看是否真正将文件创建为666。权限mask表示操作系统不允许设置的权限位，比如说037(—-wxrwx)的权限mask意味着不允许设置设置group的wx位和other的rwx位。如果是这个权限mask的话，最终的文件权限是rw-r—– (group的w位和other的rw位被mask)。</p>
<p>我们可以通过</p>
<pre><code>$umask 022
</code></pre><p>的方式改变权限mask。</p>
<p><strong>总结</strong></p>
<p>计算机本质上是对数据进行处理的工具，而文件是数据储存的逻辑载体，所以了解Linux文件系统很重要。对于文件系统的了解要结合Linux的其他方面(比如用户管理)进行有机的学习。</p>
<p>文件权限，拥有者，拥有组，超级用户root</p>
<p>硬链接，软链接，follow the link</p>
<h2 id="Linux_u7684_u67B6_u6784"><a href="#Linux_u7684_u67B6_u6784" class="headerlink" title="Linux的架构"></a>Linux的架构</h2><p>我以下图为基础，说明Linux的架构(architecture)。(该图参考《Advanced Programming in Unix Environment》)</p>
<p><img src="/images/14590055441877.jpg" alt=""></p>
<p>最内层是硬件，最外层是用户常用的应用，比如说firefox浏览器，evolution查看邮件，一个计算流体模型等等。硬件是物质基础，而应用提供服务。但在两者之间，还要经过一番周折。</p>
<p>还记得Linux启动。Linux首先启动内核 (kernel)，内核是一段计算机程序，这个程序直接管理管理硬件，包括CPU、内存空间、硬盘接口、网络接口等等。所有的计算机操作都要通过内核传递给硬件。</p>
<p>为了方便调用内核，Linux将内核的功能接口制作成系统调用(system call)。系统调用看起来就像C语言的函数。你可以在程序中直接调用。Linux系统有两百多个这样的系统调用。用户不需要了解内核的复杂结构，就可以使用内核。系统调用是操作系统的最小功能单位。一个操作系统，以及基于操作系统的应用，都不可能实现超越系统调用的功能。一个系统调用函数就像是汉字的一个笔画。任何一个汉字都要由基本的笔画（点、横、撇等等）构成。我不能臆造笔画。</p>
<p>在命令行中输入<code>$man 2 syscalls</code>可以查看所有的系统调用。你也可以通过<code>$man 2 read</code>来查看系统调用read()的说明。在这两个命令中的2都表示我们要在2类(系统调用类)中查询 (具体各个类是什么可以通过<code>$man man</code>看到)。</p>
<p>系统调用提供的功能非常基础，所以使用起来很麻烦。一个简单的给变量分配内存空间的操作，就需要动用多个系统调用。Linux定义一些库函数(library routine)来将系统调用组合成某些常用的功能。上面的分配内存的操作，可以定义成一个库函数(像malloc()这样的函数)。再比如说，在读取文件的时候，系统调用要求我们设置好所需要的缓冲。我可以使用Standard IO库中的读取函数。这个读取函数既负责设置缓冲，又负责使用读取的系统调用函数。使用库函数对于机器来说并没有效率上的优势，但可以把程序员从细节中解救出来。库函数就像是汉字的偏旁部首，它由笔画组成，但使用偏旁部首更容易组成字，比如”铁”。当然，你也完全可以不使用库函数，而直接调用系统函数，就像“人”字一样，不用偏旁部首。</p>
<p>(实际上，一个操作系统要称得上是UNIX系统，必须要拥有一些库函数，比如ISO C标准库，POSIX标准等。)</p>
<p>shell是一个特殊的应用。很多用户将它称为命令行。shell是一个命令解释器(interpreter)，当我们输入“ls -l”的时候，它将此字符串解释为</p>
<ol>
<li>在默认路径找到该文件(/bin/ls)，</li>
<li>执行该文件，并附带参数”-l”。</li>
</ol>
<p>我之前用&gt;表示重新定向，用|表示管道，也是通过shell解释&amp;或者|的含义。Shell接着通过系统调，用指挥内核，实现具体的重定向或者管道。在没有图形界面之前，shell充当了用户的界面，当用户要运行某些应用时，通过shell输入命令，来运行程序。shell是可编程的，它可以执行符合shell语法的文本。这样的文本叫做shell脚本(script)。可以在架构图中看到，shell下通系统调用，上通各种应用，同时还有许多自身的小工具可以使用。Shell脚本可以在寥寥数行中，实现复杂的功能。</p>
<p>UNIX的一条哲学是让每个程序尽量独立的做好一个小的功能。而shell充当了这些小功能之间的”胶水”，让不同程序能够以一个清晰的接口(文本流)协同工作，从而增强各个程序的功能。这也是Linux老鸟鼓励新手多用shell，少用图形化界面的原因之一。</p>
<p>(shell也有很多种，最常见的是bash, 另外还有sh, csh, tcsh, ksh。它们出现的年代不同，所支持的功能也有差异。)</p>
<p>一个shell对应一个终端 (terminal)。曾经来说，终端是一个硬件设备，用来输入并显示输出。如今，由于图形化界面的普及，终端往往就像上图一样，是一个图形化的窗口。你可以通过这个窗口输入或者输出文本。这个文本直接传递给shell进行分析解释，然后执行。</p>
<p>最后，我们进入一般的应用。应用是一个程序，它可以</p>
<ol>
<li>直接调用系统函数</li>
<li>调用库函数</li>
<li>运行shell脚本</li>
</ol>
<p>这些应用可以由多种语言开发。最常见的是C语言。</p>
<p><strong>总结</strong></p>
<p>Linux利用内核实现软硬件的对话。</p>
<p>通过系统调用的这个接口，Linux将上层的应用与下层的内核分离，隐藏了底层的复杂性，也提高了上层应用的可移植性。</p>
<p>库函数利用系统调用创造出模块化的功能，</p>
<p>Shell则提供了一个用户界面，并让我们可以利用shell的语法编写脚本，以整合程序。</p>
<h2 id="Linux_u547D_u4EE4_u884C_u4E0E_u547D_u4EE4"><a href="#Linux_u547D_u4EE4_u884C_u4E0E_u547D_u4EE4" class="headerlink" title="Linux命令行与命令"></a>Linux命令行与命令</h2><p>Linux的命令是很重要的工具，也往往是初学者最大的瓶颈。有朋友用了很长时间的Linux图形界面，基本不使用命令行输入命令执行，所以装的Linux最终成了摆设。这里总结一些命令行下常使用的命令，希望能有用。</p>
<p><strong>什么是命令</strong></p>
<p>我们通常所说的Linux命令行是运行在终端(terminal)的shell (阅读Linux架构以了解什么是shell以及它在Linux系统中的位置)</p>
<p>所谓的命令，是我们在命令行输入的一串字符。shell负责理解并执行这些字符串。shell命令可以分为如下几类 1）可执行文件(executable file) 2）shell内建函数(built-in function) 3) 别名(alias)。可执行文件为经过编译的程序文件，我们输入这些文件的路径来让shell运行，比如<code>$/bin/ls</code>。有些可执行文件被放在特殊的目录(默认路径)下面，从而使得操作系统可以通过文件名找到，而不用总是输入该文件的绝对路径(absolute path)。比如说<code>$ls</code>(实际上，shell自动帮我们补齐ls的路径)。随后，这些可执行文件中包含的程序运行，并成为进程。shell的内建函数与上面类似，只是其对应的程序被保存在shell的内部。别名是指我们给以上两种命令起一个简称，以便减少输入的工作量。</p>
<p>我们可以通过type命令来了解命令的类型：</p>
<ul>
<li><code>$type ls</code></li>
<li><code>$type cd</code></li>
</ul>
<p>命令的构成</p>
<p>当我们在命令行输入命令的时候，往往由以下方式构成:</p>
<pre><code>$ls -l /home
</code></pre><p>整个一行命令由空格分为三个部分（注意, $是自动出现的提示符，有时还会在此之前出现计算机名）。第一个为命令的名字ls，这个命令ls的功能是列出目录中所有文件，第二个-l是关键字，它告诉ls要列出每个文件的详细信息，第三个/home为参数，表示我所要列出的目录是/home。实际上关键字是一种特殊的参数，大部分情况下用来开关程序的某些特殊功能 （用来选择做出的是拿铁咖啡还是黑咖啡）。而参数是用来传递给程序的一般的变量。ls经过处理之后，将在终端输出/home下面包含的各个文件名 (该文件系统见:<a href="http://www.cnblogs.com/vamei/archive/2012/09/09/2676792.html)：" target="_blank" rel="external">http://www.cnblogs.com/vamei/archive/2012/09/09/2676792.html)：</a></p>
<pre><code>vamei another
</code></pre><p>关键字和参数可以不止有一个，比如:</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ls</span> -l -a /home /bin</span><br><span class="line"><span class="variable">$ls</span> -la /home /bin</span><br><span class="line">(上面两个命令等价)</span><br></pre></td></tr></table></figure>
<p>列出/home和/bin目录下的文件，-a表示列出全部文件(即使是隐藏文件也要列出)， -l表示列出每个文件的详细信息。</p>
<p>(如果命令没有被放在默认路径中，你也可以输入绝对路径来执行)</p>
<p>回忆Linux文件管理背景知识，我们知道，每个文件能否被执行要根据用户所拥有的权限。命令实际上是可执行文件，也是如此。系统相关的命令，或者某个命令中的定义的操作，往往会要求超级用户root的身份才能使用。如果你是用户vamei，那么你就无法使用这些命令。但以root的身份登录是个糟糕的想法。为了解决这一矛盾，你可以以vamei的身份登录，但在执行命令之前加上sudo， 以便临时以root的身份执行某条命令。比如<code>$sudo ls .</code></p>
<p>对于大多数的shell来说，都有命令补齐的功能。当你在<code>$</code>的后面输入命令的一部分时，比如rmdir的rmd的时候，按Tab键，Linux会帮你打剩下的字符，补充成为rmdir。不止是命令，如果你输入的是文件名，Linux也可以帮你补齐。比如说, <code>$ls a.txt</code>。当你输入到<code>$ls a.t</code>的时候，按Tab键，Linux会帮你补齐该文件名，成为<code>$ls a.txt</code>。当然，这样做的前提是你输入到rmd的时候，默认路径下能和它相符的命令只有一个rmdir了。如果有多个相符的命令，连按两下Tab，Linux会显示所有的相符的命令。</p>
<p><strong>多使用命令的好处</strong></p>
<p>实际上，许多命令的功能都可以通过图形化界面来实现，学习这些命令的意义在哪里呢？</p>
<p>在UNIX发育的大部分历史上，用户都是通过shell来工作的。大部分命令都已经经过了几十年的发展和改良，功能强大，性能稳定。Linux继承自UNIX，自然也是如此。此外Linux的图形化界面并不好，并不是所有的命令都有对应的图形按钮。更别说在图形化界面崩溃的情况下，你就要靠shell输入命令来恢复计算机了。</p>
<p>命令本身是一个函数 (function)，是一个小的功能模块。当我们想要让计算机做很复杂的事情 (比如说: 在晚上12:00下载某个页面的所有链接，然后复制到移动硬盘)的时候，不断地去按各个图形化按钮并不是个很聪明的事情 (1. 要点很多下，2. 必须等到12:00)。我们通常是通过shell编程来实现这样一些复杂任务，这时，就可以把命令作为函数，嵌入到我们的shell程序中, 从而让不同命令协同工作 (比如使用date来查询时间，再根据时间来使用wget下载等等)。</p>
<p><strong>如何了解一个陌生的命令</strong>？</p>
<p>有一些命令可以用来了解某个命令本身的情况，比如这个命令的绝对路径。</p>
<pre><code>$which ls
</code></pre><p>which 在默认路径中搜索命令，返回该命令的绝对路径。</p>
<pre><code>$whereis ls
</code></pre><p>whereis 在相对比较大的范围搜索命令，返回该命令的绝对路径。</p>
<pre><code>$whatis ls
</code></pre><p>whatis 用很简短的一句话来介绍命令。</p>
<pre><code>$man ls
</code></pre><p>man 查询简明的帮助手册。对于大部分的Linux自带的命令来说，当作者编写它的时候，都会带有一个帮助文档，告诉用户怎么使用这个命令。</p>
<p>(man可以说是我们了解Linux最好的百科全书，它不但可以告诉你Linux自带的命令的功能，还可以查询Linux的系统文件和系统调用。如果想要深入学习Linux，就必须要懂得如何用man来查询相关文档。)</p>
<pre><code>$info ls
</code></pre><p>info 查询更详细的帮助信息</p>
<p>此外，在shell中，你还可以用向上箭头来查看之前输入运行的命令。</p>
<p>你也可以用</p>
<pre><code>$history
</code></pre><p>来查询之前在命令行的操作。</p>
<p>当一个命令运行时，你中途想要停止它时，可以用Ctrl + c。如果你只是想暂时停止，使用Ctrl + z。具体机制与信号(signal)有关，我们将在以后介绍</p>
<p><strong>总结</strong></p>
<p>命令行: 使用shell解释输入的字符串，以运行程序</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span></span><br><span class="line">sudo</span><br><span class="line"><span class="keyword">which</span>, whereis, whatis, <span class="keyword">man</span>, info</span><br></pre></td></tr></table></figure>
<p>使用Tab自动补齐，向上箭头查询历史，history</p>
<pre><code>Ctrl + c, Ctrl + z
</code></pre><h2 id="Linux_u6587_u4EF6_u7BA1_u7406_u76F8_u5173_u547D_u4EE4"><a href="#Linux_u6587_u4EF6_u7BA1_u7406_u76F8_u5173_u547D_u4EE4" class="headerlink" title="Linux文件管理相关命令"></a>Linux文件管理相关命令</h2><p>在了解了Linux文件管理背景知识之后， 我们可以学习一些命令来管理我们的文件。</p>
<p><strong>文件操作相关</strong></p>
<p>有一些命令可以帮助我们”修剪”之前看到的文件树。</p>
<pre><code>$touch a.txt
</code></pre><p>如果a.txt不存在，生成一个新的空文档a.txt。如果a.txt存在，那么只更改该文档的时间信息。(这个命令实际上用得并不广泛，但可以帮我们创建一个空文件来实验下面操作)</p>
<pre><code>$ls .
</code></pre><p>是list的简写，列出当前目录下的所有文件名</p>
<pre><code>$ls -l a.txt
</code></pre><p>列出文件的详细信息</p>
<pre><code>$cp a.txt b.txt 
</code></pre><p>cp是copy的简写，用来复制文件。在工作目录下，将a.txt复制到文件b.txt</p>
<pre><code>$cp a.txt ..
</code></pre><p>将a.txt复制到父目录的a.txt</p>
<pre><code>$mv a.txt c.txt
</code></pre><p>mv是move的简写，用来移动文件。将a.txt移动成为c.txt (相当于重命名rename)</p>
<pre><code>$mv c.txt /home/vamei
</code></pre><p>将c.txt移动到/home/vamei目录</p>
<pre><code>$rm a.txt
</code></pre><p>rm是remove的缩写，用于删除文件。删除a.txt</p>
<pre><code>$rm -r /home/vamei 
</code></pre><p>删除从/home/vamei向下的整个子文件系统。-r表示recursive， 是指重复删除的操作，/home/vamei文件夹为空，然后删除/home/vamei文件夹本身。</p>
<p>(程序员总是对这个命令很感兴趣,   <code>$rm -rf /</code>   它会删除整个文件树。f的目的是告诉rm放心干，不用再确认了…… 一般情况下，应该没有人会用这个命令。)</p>
<pre><code>$mkdir /home/vamei/good
</code></pre><p>创建一个新的目录</p>
<pre><code>$rmdir /home/vamei/good
</code></pre><p>删除一个空的目录</p>
<p><strong>文件权限相关</strong></p>
<pre><code>$chmod 755 a.txt
</code></pre><p>(你必须是文件a.txt的拥有者才能运行此命令。或者以$sudo chmod 755 a.txt的方式，以超级用户的身份运行该命令。)</p>
<p>change mode 改变a.txt的读、写以及执行权限。还记得每个文件都有九位的读写执行权限(参看 Linux文件管理背景知识)，分为三组，分别对应拥有者(owner)，拥有组(owner group)中的用户和所有其他用户(other)。在这里，我们也有三个数字，755，对应三个组。7被分配给拥有者，5被分配给拥有组，最后一个5分配给其它用户。Linux规定: 4为有读取的权利，2为有写入的权利，1为有执行的权利。我们看到的7实际上是4 + 2 + 1，表示拥有者有读、写、执行三项权利。(想想5 意味着什么)</p>
<p>这时，运行<code>$ls -l a.txt</code>, 你应该看到九位的权限变成了rwxr-xr-x。根据自己的需要，你可以用比如444, 744代替755，来让文件有不同的权限。</p>
<pre><code>$sudo chown root a.txt
</code></pre><p>change owner 改变文件的拥有者为root用户。这个命令需要有超级用户权限才能执行，所以我们在命令之前加上sudo。</p>
<pre><code>$sudo chgrp root a.txt
</code></pre><p>change group 改变文件的拥有组为root组</p>
<p><strong>Linux文件名通配表达式</strong></p>
<p>(wild card, 也叫filename pattern matching)</p>
<p>之前所讲的命令，比如ls, mv, cp都可以接收多个参数，比如:</p>
<pre><code>$ls -l a.txt b.txt c.txt
</code></pre><p>就可以列出这三个文件的所有信息。</p>
<p>有时候，我们想列出工作目录下所有的以.txt结尾的文件的信息，可以用下面的方式:</p>
<pre><code>$ls -l *.txt
</code></pre><p><code>*.txt</code>的写法就运用了Linux通配表达式。它与正则表达式相类似，但语法有所不同。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Filename Pattern Matching</th>
<th style="text-align:center">对应含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">任意多个任意字符</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">任意一个字符</td>
</tr>
<tr>
<td style="text-align:center">[kl]</td>
<td style="text-align:center">字符k或者字符l</td>
</tr>
<tr>
<td style="text-align:center">[0-4]</td>
<td style="text-align:center">数字0到4字符中的一个</td>
</tr>
<tr>
<td style="text-align:center">[b-e]</td>
<td style="text-align:center">b到e字符中的一个</td>
</tr>
<tr>
<td style="text-align:center">[^mnp]</td>
<td style="text-align:center">一个字符，这个字符不是m,n,p</td>
</tr>
</tbody>
</table>
<p>Linux会找到符合表达式的文件名，然后用这些文件名作为参数传递给命令。注意，当使用rm的时候，要格外小心。下面两个命令，只相差一个空格，但效果大为不同:</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$rm</span> * .txt</span><br><span class="line"><span class="variable">$rm</span> *.txt</span><br></pre></td></tr></table></figure>
<p>第一个命令会删除当前目录下所有文件！</p>
<p><strong>总结</strong></p>
<p>touch, ls, mv, cp, rm, mkdir, rmdir</p>
<p>chmod, chown, chgrp</p>
<p>wild card</p>
<h2 id="Linux_u6587_u672C_u6D41"><a href="#Linux_u6587_u672C_u6D41" class="headerlink" title="Linux文本流"></a>Linux文本流</h2><p><strong>文本流</strong></p>
<p>文件用于数据的存储，相当于一个个存储数据的房子。我们之前说，所谓的数据是0或者1的序列，但严格来说，Linux以字节(byte)来作为数据的单位，也就是说这个序列每八位(bit)为一个单位(八位二进制对应的十进制范围为0到255)。使用ASCII编码，可以将这样一个字节转换成为字符。所以，在Linux中，我们所说的数据，完全可以用字符表达出来，也就是说文本(text)的形式。</p>
<p>实际上，如果以bit为单位处理字符的话，机器会更容易读懂和传输，效率会更高。但为什么Linux依然以字节为单位进行处理呢？原因在于，相对于以bit为单位处理数据，以byte为单位可以更容易将数据转化为字符。相对于枯燥的0和1，字符更容易被人读懂 (human readable)。然而，并不是所有的数据都是设计来让人读懂的，比如可执行文件包含的各种字符对于人来说并没有什么意义 (因为可执行文件是为了让机器读懂的)。但Linux依然以字节为单位处理所有文件，这是为了让所有文件能够共用一套接口 (virtual file system)，从而减少Linux设计的复杂度。</p>
<p>(“everything is a file”是通常所流传的UNIX设计的哲学之一，但Linus对此作出纠正，改为”everything is a stream of bytes”。)</p>
<p>然而，数据不是在找到了自己的房子(file)之后就永远的定居下来。它往往要被读入到内存 (就像是到办公室上班)，或者被传送到外部设备(好像去酒店休假)，或者搬到别的房子中。在这样的搬迁过程中，数据像是一个个排着队走路的人流，我们叫它文本流(text stream，或者byte stream)。然而，计算机不同设备之间的连接方法差异很大，从内存到文件的连接像是爬山，从内存到外设像是游过一条河。为此，Linux还定义了流 (stream)，以此作为修建连接各处的公路的标准。Stream的好处在于，无论你是从内存到外设，还是从内存到文件，所有的公路都是相同的 (至于公路下面是石头还是土地，都可以不用操心)。</p>
<p>我们再回味一下“everything is a stream of bytes”这句话。信息包含在文本流中，不断在计算机的各个组件之间流动，不断地接受计算机的加工，最终成为用户所需要的某种服务。</p>
<p>标准输入，标准输出，标准错误与重新定向</p>
<p>当Linux执行一个程序的时候，会自动打开三个流，标准输入(standard input)，标准输出(standard output)，标准错误(standard error)。比如说你打开命令行的时候，默认情况下，命令行的标准输入连接到键盘，标准输出和标准错误都连接到屏幕。对于一个程序来说，尽管它总会打开这三个流，但它会根据需要使用，并不是一定要使用。</p>
<p>想象一下敲击一个</p>
<pre><code>$ls
</code></pre><p>键盘敲击的文本流(“ls\n”，\n是回车时输入的字符，表示换行)命令行 (命令行实际上也是一个程序)。命令行随后调用/bin/ls得到结果(“a.txt”)，最后这个输出的文本流(“a.txt”)流到屏幕，显示出来，比如说：</p>
<pre><code>a.txt
</code></pre><p>假设说我们不想让文本流流到屏幕，而是流到另一个文件，我们可以采用重新定向(redirect)的机制。</p>
<pre><code>$ls &gt; a.txt
</code></pre><p>重新定向标准输出。这里的&gt;就是提醒命令行，让它知道我现在想变换文本流的方向了，我们不让标准输出输出到屏幕，而是要到a.txt这个文件 (好像火车轨道换轨)。此时，计算机会新建一个a.txt的文件，并将命令行的标准输出指向这个文件。</p>
<p>有另一个符号:</p>
<pre><code>$ls &gt;&gt; a.txt
</code></pre><p>这里&gt;&gt;的作用也是重新定向标准输出。如果a.txt已经存在的话，ls产生的文本流会附加在a.txt的结尾，而不会像&gt;那样每次都新建a.txt。</p>
<p>我们下面介绍命令echo：</p>
<pre><code>$echo IamVamei
</code></pre><p>echo的作用是将文本流导向标准输出。在这里，echo的作用就是将IamVamei输出到屏幕上。如果是</p>
<pre><code>$echo IamVamei &gt; a.txt
</code></pre><p>a.txt中就会有IamVamei这个文本。</p>
<p>我们也可以用&lt;符号来改变标准输入。比如cat命令，它可以从标准输入读入文本流，并输出到标准输出:</p>
<pre><code>$cat &lt; a.txt
</code></pre><p>我们将cat标准输入指向a.txt，文本会从文件流到cat，然后再输出到屏幕上。当然，我们还可以同时重新定向标准输出:</p>
<pre><code>$cat &lt; a.txt &gt; b.txt
</code></pre><p>这样，a.txt的内容就复制到了b.txt中。</p>
<p>我们还可以使用&gt;&amp;来同时重新定向标准输出和标准错误。假设我们并没有一个目录void。那么</p>
<pre><code>$cd void &gt; a.txt
</code></pre><p>会在屏幕上返回错误信息。因为此时标准错误依然指向屏幕。当我们使用:</p>
<pre><code>$cd void &gt;&amp; a.txt
</code></pre><p>错误信息被导向a.txt。</p>
<p>如果只想重新定向标准错误，可以使用2&gt;:</p>
<pre><code>$cd void 2&gt; a.txt &gt; b.txt
</code></pre><p>标准错误对应的总是2号，所以有以上写法。标准错误输出到a.txt，标准输出输出到b.txt。</p>
<p><strong>管道 (pipe)</strong></p>
<p>理解了以上的内容之后，管道的概念就易如反掌。管道可以将一个命令的输出导向另一个命令的输入，从而让两个(或者更多命令)像流水线一样连续工作，不断地处理文本流。在命令行中，我们用|表示管道：</p>
<pre><code>$cat &lt; a.txt | wc 
</code></pre><p>wc命令代表word count，用于统计文本中的行、词以及字符的总数。a.txt中的文本先流到cat，然后从cat的标准输出流到wc的标准输入，从而让wc知道自己要处理的是a.txt这个字符串。</p>
<p>Linux的各个命令实际上高度专业化，并尽量相互独立。每一个都只专注于一个小的功能。但通过pipe，我们可以将这些功能合在一起，实现一些复杂的目的。</p>
<p><strong>总结</strong></p>
<p>文本流，标准输入，标准输出，标准错误</p>
<p>cat, echo, wc</p>
<p><code>&gt;, &gt;&gt;, &lt;, |</code></p>
<h2 id="Linux_u8FDB_u7A0B_u57FA_u7840"><a href="#Linux_u8FDB_u7A0B_u57FA_u7840" class="headerlink" title="Linux进程基础"></a>Linux进程基础</h2><p>计算机实际上可以做的事情实质上非常简单，比如计算两个数的和，再比如在内存中寻找到某个地址等等。这些最基础的计算机动作被称为指令 (instruction)。所谓的程序(program)，就是这样一系列指令的所构成的集合。通过程序，我们可以让计算机完成复杂的操作。程序大多数时候被存储为可执行的文件。这样一个可执行文件就像是一个菜谱，计算机可以按照菜谱作出可口的饭菜。</p>
<p>那么，程序和进程(process)的区别又是什么呢?</p>
<p>进程是程序的一个具体实现。只有食谱没什么用，我们总要按照食谱的指点真正一步步实行，才能做出菜肴。进程是执行程序的过程，类似于按照食谱，真正去做菜的过程。同一个程序可以执行多次，每次都可以在内存中开辟独立的空间来装载，从而产生多个进程。不同的进程还可以拥有各自独立的IO接口。</p>
<p>操作系统的一个重要功能就是为进程提供方便，比如说为进程分配内存空间，管理进程的相关信息等等，就好像是为我们准备好了一个精美的厨房。</p>
<p><strong>看一眼进程</strong></p>
<p>首先，我们可以使用<code>$ps</code>命令来查询正在运行的进程，比如<code>$ps -eo pid,comm,cmd</code>，下图为执行结果:</p>
<p>(-e表示列出全部进程，-o pid,comm,cmd表示我们需要PID，COMMAND，CMD信息)</p>
<p><img src="/images/14590055629919.jpg" alt=""></p>
<p>每一行代表了一个进程。每一行又分为三列。第一列PID(process IDentity)是一个整数，每一个进程都有一个唯一的PID来代表自己的身份，进程也可以根据PID来识别其他的进程。第二列COMMAND是这个进程的简称。第三列CMD是进程所对应的程序以及运行时所带的参数。</p>
<p>(第三列有一些由中括号[]括起来的。它们是kernel的一部分功能，被打扮成进程的样子以方便操作系统管理。我们不必考虑它们。)</p>
<p>我们看第一行，PID为1，名字为init。这个进程是执行/bin/init这一文件(程序)生成的。当Linux启动的时候，init是系统创建的第一个进程，这一进程会一直存在，直到我们关闭计算机。这一进程有特殊的重要性，我们会不断提到它。</p>
<p><strong>如何创建一个进程</strong></p>
<p>实际上，当计算机开机的时候，内核(kernel)只建立了一个init进程。Linux kernel并不提供直接建立新进程的系统调用。剩下的所有进程都是init进程通过fork机制建立的。新的进程要通过老的进程复制自身得到，这就是fork。fork是一个系统调用。进程存活于内存中。每个进程都在内存中分配有属于自己的一片空间 (address space)。当进程fork的时候，Linux在内存中开辟出一片新的内存空间给新的进程，并将老的进程空间中的内容复制到新的空间中，此后两个进程同时运行。</p>
<p>老进程成为新进程的父进程(parent process)，而相应的，新进程就是老的进程的子进程(child process)。一个进程除了有一个PID之外，还会有一个PPID(parent PID)来存储的父进程PID。如果我们循着PPID不断向上追溯的话，总会发现其源头是init进程。所以说，所有的进程也构成一个以init为根的树状结构。</p>
<p>如下，我们查询当前shell下的进程：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@vamei:~# ps -o pid,ppid,cmd&#10;  PID  PPID CMD&#10;16935  3101 sudo -i&#10;16939 16935 -bash&#10;23774 16939 ps -o pid,ppid,cmd</span><br></pre></td></tr></table></figure>
<p>我们可以看到，第二个进程bash是第一个进程sudo的子进程，而第三个进程ps是第二个进程的子进程。</p>
<p>还可以用$pstree命令来显示整个进程树：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init&#9472;&#9516;&#9472;NetworkManager&#9472;&#9516;&#9472;dhclient&#10;     &#9474;                &#9492;&#9472;2*[&#123;NetworkManager&#125;]&#10;     &#9500;&#9472;accounts-daemon&#9472;&#9472;&#9472;&#123;accounts-daemon&#125;&#10;     &#9500;&#9472;acpid&#10;     &#9500;&#9472;apache2&#9472;&#9516;&#9472;apache2&#10;     &#9474;         &#9492;&#9472;2*[apache2&#9472;&#9472;&#9472;26*[&#123;apache2&#125;]]&#10;     &#9500;&#9472;at-spi-bus-laun&#9472;&#9472;&#9472;2*[&#123;at-spi-bus-laun&#125;]&#10;     &#9500;&#9472;atd&#10;     &#9500;&#9472;avahi-daemon&#9472;&#9472;&#9472;avahi-daemon&#10;     &#9500;&#9472;bluetoothd&#10;     &#9500;&#9472;colord&#9472;&#9472;&#9472;2*[&#123;colord&#125;]&#10;     &#9500;&#9472;console-kit-dae&#9472;&#9472;&#9472;64*[&#123;console-kit-dae&#125;]&#10;     &#9500;&#9472;cron&#10;     &#9500;&#9472;cupsd&#9472;&#9472;&#9472;2*[dbus]&#10;     &#9500;&#9472;2*[dbus-daemon]&#10;     &#9500;&#9472;dbus-launch&#10;     &#9500;&#9472;dconf-service&#9472;&#9472;&#9472;2*[&#123;dconf-service&#125;]&#10;     &#9500;&#9472;dropbox&#9472;&#9472;&#9472;15*[&#123;dropbox&#125;]&#10;     &#9500;&#9472;firefox&#9472;&#9472;&#9472;27*[&#123;firefox&#125;]&#10;     &#9500;&#9472;gconfd-2&#10;     &#9500;&#9472;geoclue-master&#10;     &#9500;&#9472;6*[getty]&#10;     &#9500;&#9472;gnome-keyring-d&#9472;&#9472;&#9472;7*[&#123;gnome-keyring-d&#125;]&#10;     &#9500;&#9472;gnome-terminal&#9472;&#9516;&#9472;bash&#10;     &#9474;                &#9500;&#9472;bash&#9472;&#9472;&#9472;pstree&#10;     &#9474;                &#9500;&#9472;gnome-pty-helpe&#10;     &#9474;                &#9500;&#9472;sh&#9472;&#9472;&#9472;R&#9472;&#9472;&#9472;&#123;R&#125;&#10;     &#9474;                &#9492;&#9472;3*[&#123;gnome-terminal&#125;]</span><br></pre></td></tr></table></figure>
<p>fork通常作为一个函数被调用。这个函数会有两次返回，将子进程的PID返回给父进程，0返回给子进程。实际上，子进程总可以查询自己的PPID来知道自己的父进程是谁，这样，一对父进程和子进程就可以随时查询对方。</p>
<p>通常在调用fork函数之后，程序会设计一个if选择结构。当PID等于0时，说明该进程为子进程，那么让它执行某些指令,比如说使用exec库函数(library function)读取另一个程序文件，并在当前的进程空间执行 (这实际上是我们使用fork的一大目的: 为某一程序创建进程)；而当PID为一个正整数时，说明为父进程，则执行另外一些指令。由此，就可以在子进程建立之后，让它执行与父进程不同的功能。</p>
<p><strong>子进程的终结(termination)</strong></p>
<p>当子进程终结时，它会通知父进程，并清空自己所占据的内存，并在kernel里留下自己的退出信息(exit code，如果顺利运行，为0；如果有错误或异常状况，为&gt;0的整数)。在这个信息里，会解释该进程为什么退出。父进程在得知子进程终结时，有责任对该子进程使用wait系统调用。这个wait函数能从kernel中取出子进程的退出信息，并清空该信息在kernel中所占据的空间。但是，如果父进程早于子进程终结，子进程就会成为一个孤儿(orphand)进程。孤儿进程会被过继给init进程，init进程也就成了该进程的父进程。init进程负责该子进程终结时调用wait函数。</p>
<p>当然，一个糟糕的程序也完全可能造成子进程的退出信息滞留在kernel中的状况（父进程不对子进程调用wait函数），这样的情况下，子进程成为僵尸（zombie）进程。当大量僵尸进程积累时，内存空间会被挤占。</p>
<p><strong>进程与线程(thread)</strong></p>
<p>尽管在UNIX中，进程与线程是有联系但不同的两个东西，但在Linux中，线程只是一种特殊的进程。多个线程之间可以共享内存空间和IO接口。所以，进程是Linux程序的唯一的实现方式。</p>
<p><strong>总结</strong></p>
<p>程序，进程，PID，内存空间</p>
<p>子进程，父进程，PPID，fork， wait</p>
<h2 id="Linux_u4FE1_u53F7_u57FA_u7840"><a href="#Linux_u4FE1_u53F7_u57FA_u7840" class="headerlink" title="Linux信号基础"></a>Linux信号基础</h2><p>Linux进程基础一文中已经提到，Linux以进程为单位来执行程序。我们可以将计算机看作一个大楼，内核(kernel)是大楼的管理员，进程是大楼的房客。每个进程拥有一个独立的房间(属于进程的内存空间)，而每个房间都是不允许该进程之外的人进入。这样，每个进程都只专注于自己干的事情，而不考虑其他进程，同时也不让别的进程看到自己的房间内部。这对于每个进程来说是一种保护机制。(想像一下几百个进程总是要干涉对方，那会有多么混乱，或者几百个进程相互偷窥……)</p>
<p>然而，在一些情况，我们需要打破封闭的房间，以便和进程交流信息。比如说，内核发现有一个进程在砸墙(硬件错误)，需要让进程意识到这样继续下去会毁了整个大楼。再比如说，我们想让多个进程之间合作。这样，我们就需要一定的通信方式。信号(signal)就是一种向进程传递信息的方式。我们可以将信号想象成大楼的管理员往房间的信箱里塞小纸条。随后进程取出小纸条，会根据纸条上的内容来采取一定的行动，比如灯坏了，提醒进程使用手电。(当然，也可以完全无视这张纸条，然而在失火这样紧急的状况下，无视信号不是个好的选择)。相对于其他的进程间通信方式(interprocess communication， 比如说pipe, shared memory)来说，信号所能传递的信息比较粗糙，只是一个整数。但正是由于传递的信息量少，信号也便于管理和使用。信号因此被经常地用于系统管理相关的任务，比如通知进程终结、中止或者恢复等等。</p>
<p>信号是由内核(kernel)管理的。信号的产生方式多种多样，它可以是内核自身产生的，比如出现硬件错误(比如出现分母为0的除法运算，或者出现segmentation fault)，内核需要通知某一进程；也可以是其它进程产生的，发送给内核，再由内核传递给目标进程。内核中针对每一个进程都有一个表存储相关信息(房间的信箱)。当内核需要将信号传递给某个进程时，就在该进程相对应的表中的适当位置写入信号(塞入纸条)，这样，就生成(generate)了信号。当该进程执行系统调用时，在系统调用完成后退出内核时，都会顺便查看信箱里的信息。如果有信号，进程会执行对应该信号的操作(signal action, 也叫做信号处理signal disposition)，此时叫做执行(deliver)信号。从信号的生成到信号的传递的时间，信号处于等待(pending)状态(纸条还没有被查看)。我们同样可以设计程序，让其生成的进程阻塞(block)某些信号，也就是让这些信号始终处于等待的状态，直到进程取消阻塞(unblock)或者无视信号。</p>
<p><strong>常见信号</strong></p>
<p>信号所传递的每一个整数都被赋予了特殊的意义，并有一个信号名对应该整数。常见的信号有SIGINT, SIGQUIT, SIGCONT, SIGTSTP, SIGALRM等。这些都是信号的名字。你可以通过</p>
<pre><code>$man 7 signal
</code></pre><p>来查阅更多的信号。</p>
<p>上面几个信号中，</p>
<ul>
<li><code>SIGINT</code>   当键盘按下CTRL+C从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是中断 (INTERRUPT) 该进程。</li>
<li><code>SIGQUIT</code>  当键盘按下CTRL+\从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是退出 (QUIT) 该进程。</li>
<li><code>SIGTSTP</code>  当键盘按下CTRL+Z从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是暂停 (STOP) 该进程。</li>
<li><code>SIGCONT</code>  用于通知暂停的进程继续。</li>
<li><code>SIGALRM</code>  起到定时器的作用，通常是程序在一定的时间之后才生成该信号。</li>
</ul>
<p><strong>在shell中使用信号</strong></p>
<p>下面我们实际应用一下信号。我们在shell中运行ping：</p>
<pre><code>$ping localhost
</code></pre><p>此时我们可以通过CTRL+Z来将SIGTSTP传递给该进程。shell中显示：</p>
<pre><code>[1]+  Stopped                 ping localhost
</code></pre><p>我们使用<code>$ps</code>来查询ping进程的PID (PID是ping进程的房间号), 在我的机器中为27397</p>
<p>我们可以在shell中通过$kill命令来向某个进程发出信号:</p>
<pre><code>$kill -SIGCONT  27397
</code></pre><p>来传递SIGCONT信号给ping进程。</p>
<p><strong>信号处理 (signal disposition)</strong></p>
<p>在上面的例子中，所有的信号都采取了对应信号的默认操作。但这并不绝对。当进程决定执行信号的时候，有下面几种可能：</p>
<ol>
<li>无视(ignore)信号，信号被清除，进程本身不采取任何特殊的操作</li>
<li>默认(default)操作。每个信号对应有一定的默认操作。比如上面SIGCONT用于继续进程。</li>
<li>自定义操作。也叫做获取 (catch) 信号。执行进程中预设的对应于该信号的操作。</li>
</ol>
<p>进程会采取哪种操作，要根据该进程的程序设计。特别是获取信号的情况，程序往往会设置一些比较长而复杂的操作(通常将这些操作放到一个函数中)。</p>
<p>信号常常被用于系统管理，所以它的内容相当庞杂。深入了解信号，需要一定的Linux环境编程知识。</p>
<p><strong>总结</strong></p>
<p>信号机制; generate, deliver, pending, blocking</p>
<p>signal action/dispositon; ignore, default action, catch signal</p>
<p><code>$kill</code></p>
<h2 id="Linux_u8FDB_u7A0B_u5173_u7CFB"><a href="#Linux_u8FDB_u7A0B_u5173_u7CFB" class="headerlink" title="Linux进程关系"></a>Linux进程关系</h2><p>Linux的进程相互之间有一定的关系。比如说，在Linux进程基础中，我们看到，每个进程都有父进程，而所有的进程以init进程为根，形成一个树状结构。我们在这里讲解进程组和会话，以便以更加丰富的方式了管理进程。</p>
<p><strong>进程组 (process group)</strong></p>
<p>每个进程都会属于一个进程组(process group)，每个进程组中可以包含多个进程。进程组会有一个进程组领导进程 (process group leader)，领导进程的PID (PID见Linux进程基础)成为进程组的ID (process group ID, PGID)，以识别进程组。</p>
<pre><code>$ps -o pid,pgid,ppid,comm | cat
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  PID  PGID  PPID COMMAND</span><br><span class="line"><span class="number">17763</span> <span class="number">17763</span> <span class="number">17751</span> bash</span><br><span class="line"><span class="number">18534</span> <span class="number">18534</span> <span class="number">17763</span> ps</span><br><span class="line"><span class="number">18535</span> <span class="number">18534</span> <span class="number">17763</span> cat</span><br></pre></td></tr></table></figure>
<p>PID为进程自身的ID，PGID为进程所在的进程组的ID， PPID为进程的父进程ID。从上面的结果，我们可以推测出如下关系：</p>
<p><img src="/images/14590055773563.jpg" alt=""></p>
<p>图中箭头表示父进程通过fork和exec机制产生子进程。ps和cat都是bash的子进程。进程组的领导进程的PID成为进程组ID。领导进程可以先终结。此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。</p>
<p>我们将一些进程归为进程组的一个重要原因是我们可以将信号发送给一个进程组。进程组中的所有进程都会收到该信号。我们会在下一部分深入讨论这一点。</p>
<p><strong>会话 (session)</strong></p>
<p>更进一步，在shell支持工作控制(job control)的前提下，多个进程组还可以构成一个会话 (session)。bash(Bourne-Again shell)支持工作控制，而sh(Bourne shell)并不支持。</p>
<p>会话是由其中的进程建立的，该进程叫做会话的领导进程(session leader)。会话领导进程的PID成为识别会话的SID(session ID)。会话中的每个进程组称为一个工作(job)。会话可以有一个进程组成为会话的前台工作(foreground)，而其他的进程组是后台工作(background)。每个会话可以连接一个控制终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。由终端产生的信号，比如CTRL+Z， CTRL+\，会传递到前台进程组。</p>
<p>会话的意义在于将多个工作囊括在一个终端，并取其中的一个工作作为前台，来直接接收该终端的输入输出以及终端信号。 其他工作在后台运行。</p>
<p>一个命令可以通过在末尾加上&amp;方式让它在后台运行:</p>
<pre><code>$ping localhost &gt; log &amp;
</code></pre><p>此时终端显示:</p>
<pre><code>[1] 10141
</code></pre><p>括号中的1表示工作号，而10141为PGID</p>
<p>我们通过如下方式查询更加详细的信息:</p>
<pre><code>$ps -o pid,pgid,ppid,sid,tty,comm
(tty表示控制终端）
</code></pre><p>信号可以通过kill</p>
<pre><code>$kill -SIGTERM -10141
</code></pre><p>或者</p>
<pre><code>$kill -SIGTERM %1
</code></pre><p>的方式来发送给工作组。上面的两个命令，一个是发送给PGID(通过在PGID前面加-来表示是一个PGID而不是PID)，一个是发送给工作1(%1)，两者等价。</p>
<p>一个工作可以通过$fg从后台工作变为前台工作:</p>
<pre><code>$cat &gt; log &amp;
$fg %1
</code></pre><p>当我们运行第一个命令后，由于工作在后台，我们无法对命令进行输入，直到我们将工作带入前台，才能向cat命令输入。在输入完成后，按下CTRL+D来通知shell输入结束。</p>
<p>进程组(工作)的概念较为简单易懂。而会话主要是针对一个终端建立的。当我们打开多个终端窗口时，实际上就创建了多个终端会话。每个会话都会有自己的前台工作和后台工作。这样，我们就为进程增加了管理和运行的层次。在没有图形化界面的时代，会话允许用户通过shell进行多层次的进程发起和管理。比如说，我可以通过shell发起多个后台工作，而此时标准输入输出并不被占据，我依然可以继续其它的工作。如今，图形化界面可以帮助我们解决这一需求，但工作组和会话机制依然在Linux的许多地方应用。</p>
<p><strong>总结</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process group, pgid</span><br><span class="line">session, sid, job, forground, background</span><br><span class="line"><span class="built_in">fg</span>, <span class="built_in">kill</span> -pid, &amp;, %</span><br></pre></td></tr></table></figure>
<h2 id="Linux_u7528_u6237"><a href="#Linux_u7528_u6237" class="headerlink" title="Linux用户"></a>Linux用户</h2><p>Linux的用户在登录(login)之后，就带有一个用户身份(user ID, UID)和一个组身份(group ID, GID)。在Linux文件管理背景知识中，我们又看到，每个文件又有九位的权限说明，用来指明该文件允许哪些用户执行哪些操作(读、写或者执行)。</p>
<p><strong>进程权限</strong></p>
<p>但是，在Linux中，用户的指令是在进程的范围内进行的。当我们向对某个文件进行操作的时候，我们需要在进程中运行一个程序，在进程中对文件打开，并进行读、写或者执行的操作。因此，我们需要将用户的权限传递给进程，以便进程真正去执行操作。例如我们有一个文件a.txt, 文件中为一个字符串:</p>
<pre><code>Hello world!
</code></pre><p>我以用户Vamei的身份登录，并在shell中运行如下命令：</p>
<pre><code>$cat a.txt
</code></pre><p>整个运行过程以及文件读取如下:</p>
<p><img src="/images/14590055890788.jpg" alt=""></p>
<p>我们可以看到，整个过程中我们会有两个进程，一个是shell本身(2256)，一个是shell复制自身，再运行/bin/cat (9913)。图中的fork, exec, PID可参看Linux进程基础。第二个进程总共对文件系统进行了两次操作，一次是执行(x)文件/bin/cat，另外一次是读取(r)文件a.txt。使用<code>$ls -l</code> 查看这两个文件的权限:</p>
<pre><code>$ls -l /bin/cat
-rwxr-xr-x 1 root root 46764 Apr  1  2012 /bin/cat

$ls -l a.txt
-rw-rw-r-- 1 Vamei Vamei 14 Oct  7 09:14 a.txt
</code></pre><p>从上面可以看到(参考Linux文件管理背景知识)，/bin/cat让所有用户都享有执行的权利，而Vamei作为a.txt的拥有者，对a.txt享有读取的权利。</p>
<p>让我们进入更多的细节 (The devil is in the details)。在进行这两次操作的时候，尽管用户Vamei拥有相应的权限，但我们发现，真正做工作的是进程9913。我们要让这个进程得到相应的权限。实际上，每个进程会维护有如下6个ID：</p>
<p>真实身份: real UID,       real GID</p>
<p>有效身份: effective UID,  effective GID</p>
<p>存储身份: saved UID,      saved GID</p>
<p>其中，真实身份是我们登录使用的身份，有效身份是当该进程真正去操作文件时所检查的身份，存储身份较为特殊，我们等一下再深入。当进程fork的时候，真实身份和有效身份都会复制给子进程。大部分情况下，真实身份和有效身份都相同。当Linux完成开机启动之后，init进程会执行一个login的子进程。我们将用户名和密码传递给login子进程。login在查询了/etc/passwd和/etc/shadow，并确定了其合法性之后，运行(利用exec)一个shell进程，shell进程真实身份被设置成为该用户的身份。由于此后fork此shell进程的子进程都会继承真实身份，所以该真实身份会持续下去，直到我们登出并以其他身份再次登录(当我们使用su成为root的时候，实际上就是以root身份再次登录，此后真实身份成为root)。</p>
<p><strong>最小权限原则</strong></p>
<p>每个进程为什么不简单地只维护真实身份，却选择费尽麻烦地去维护有效身份和存储身份呢？这牵涉到Linux的“最小特权”(least priviledge)的原则。Linux通常希望进程只拥有足够完成其工作的特权，而不希望赋予更多的特权给它。从设计上来说，最简单的是赋予每个进程以super user的特权，这样进程就可以想做什么做什么。然而，这对于系统来说是一个巨大的安全漏洞，特别是在多用户环境下，如果每个用户都享有无限制的特权，就很容易破坏其他用户的文件或者系统本身。“最小特权”就是收缩进程所享有的特权，以防进程滥用特权。</p>
<p>然而，进程的不同阶段可能需要不同的特权。比如一个进程最开始的有效身份是真实身份，但运行到中间的时候，需要以其他的用户身份读入某些配置文件，然后再进行其他的操作。为了防止其他的用户身份被滥用，我们需要在操作之前，让进程的有效身份变更回来成为真实身份。这样，进程需要在两个身份之间变化。</p>
<p>存储身份就是真实身份之外的另一个身份。当我们将一个程序文件执行成为进程的时候，该程序文件的拥有者(owner)和拥有组(owner group)可以被，存储成为进程的存储身份。在随后进程的运行过程中，进程就将可以选择将真实身份或者存储身份复制到有效身份，以拥有真实身份或者存储身份的权限。并不是所有的程序文件在执行的过程都设置存储身份的。需要这么做的程序文件会在其九位(bit)权限的执行位的x改为s。这时，这一位(bit)叫做set UID bit或者set GID bit。</p>
<pre><code>$ls -l /usr/bin/uuidd
-rwsr-sr-x 1 libuuid libuuid 17976 Mar 30  2012 /usr/sbin/uuidd
</code></pre><p>当我以root(UID), root(GID)的真实身份运行这个程序的时候，由于拥有者(owner)有s位的设定，所以saved UID被设置成为libuuid，saved GID被设置成为libuuid。这样，uuidd的进程就可以在两个身份之间切换。</p>
<p>我们通常使用chmod来修改set-UID bit和set-GID bit:</p>
<pre><code>$chmod 4700 file
</code></pre><p>我们看到，这里的chmod后面不再只是三位的数字。最前面一位用于处理set-UID bit/set-GID bit，它可以被设置成为4/2/1以及或者上面数字的和。4表示为set UID bit, 2表示为set GID bit，1表示为sticky bit (暂时不介绍)。必须要先有x位的基础上，才能设置s位。</p>
<p>作为一个Linux用户来说，我们并不需要特别关心上面的机制。但是，当我们去编写一个Linux应用程序的时候，就要注意在程序中实现以上切换(有必要的前提下)，以便让我们的程序符合”最小权限”的原则，不给系统留下可能的安全隐患</p>
<h2 id="Linux_u4ECE_u7A0B_u5E8F_u5230_u8FDB_u7A0B"><a href="#Linux_u4ECE_u7A0B_u5E8F_u5230_u8FDB_u7A0B" class="headerlink" title="Linux从程序到进程"></a>Linux从程序到进程</h2><p>计算机如何执行进程呢？这是计算机运行的核心问题。即使已经编写好程序，但程序是死的。只有活的进程才能产出。我们已经从Linux进程基础中了解了进程。现在我们看一下从程序到进程的漫漫征程。</p>
<p><strong>一段程序</strong></p>
<p>下面是一个简单的C程序，假设该程序已经编译好</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> glob=<span class="number">0</span>;                                             <span class="comment">/*global variable*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> main1=<span class="number">5</span>;                                          <span class="comment">/*local variable of main()*/</span></span><br><span class="line">  <span class="keyword">int</span> main2;                                            <span class="comment">/*local variable of main()*/</span></span><br><span class="line">  main2 = inner(main1);                                 <span class="comment">/* call inner() function */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"From Main: glob: %d \n"</span>, glob);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"From Main: main2: %d \n"</span>, main2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inner</span><span class="params">(<span class="keyword">int</span> inner1)</span> </span>&#123;                                 <span class="comment">/*inner1 is an argument, also local to inner()*/</span></span><br><span class="line">  <span class="keyword">int</span> inner2=<span class="number">10</span>;                                        <span class="comment">/*local variable of inner()*/</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"From inner: glob: %d \n"</span>, glob);</span><br><span class="line">  <span class="keyword">return</span>(inner1+inner2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(选取哪一个语言或者具体的语法并不是关键，大部分语言都可以写出类似上面的程序。在看Python教程的读者也可以利用Python的函数结构和print写一个类似的python程序。当然，还可以是C++，Java，Objective-C等等。选用C语言的原因是：它是为UNIX而生的语言。)</p>
<p>main()函数中调用了inner()函数。inner()中调用一次printf()以输出。最后，在main()中进行了两次printf()。</p>
<p>注意变量的作用范围。简单地说，变量可以分为全局变量和局部变量。在所有函数之外声明的变量为全局变量，比如glob，在任何时候都可以使用。在函数内定义的变量为局部变量，只能在该函数的作用域(range)内使用，比如说我们在inner()工作的时候不能使用main()函数中声明的main1变量，而在main()中我们无法使用inner()函数中声明的inner2变量。</p>
<p>不用太过在意这个程序的具体功能。要点是这个程序的运行过程。下图为该程序的运行过程，以及各个变量的作用范围：</p>
<p><img src="/images/14590056061703.jpg" alt=""></p>
<p><strong>进程空间</strong></p>
<p>为了进一步了解上面程序的运行，我们还需要知道，进程如何使用内存。当程序文件运行为进程时，进程在内存中获得空间。这个空间是进程自己的小屋子。</p>
<p>每个进程空间按照如下方式分为不同区域:</p>
<p><img src="/images/14590056162054.jpg" alt=""></p>
<p>Text区域用来储存指令(instruction)，说明每一步的操作。Global Data用于存放全局变量，栈(Stack)用于存放局部变量，堆(heap)用于存放动态变量 (dynamic variable. 程序利用malloc系统调用，直接从内存中为dynamic variable开辟空间)。Text和Global data在进程一开始的时候就确定了，并在整个进程中保持固定大小。</p>
<p>栈(Stack)以帧(stack frame)为单位。当程序调用函数的时候，比如main()函数中调用inner()函数，stack会向下增长一帧。帧中存储该函数的参数和局部变量，以及该函数的返回地址(return address)。此时，计算机将控制权从main()转移到inner()，inner()函数处于激活(active)状态。位于栈最下方的帧，和全局变量一起，构成了当前的环境(context)。激活函数可以从环境中调用需要的变量。典型的编程语言都只允许你使用位于stack最下方的帧 ，而不允许你调用其它的帧 (这也符合stack结构“先进后出”的特征。但也有一些语言允许你调用栈的其它部分，相当于允许你在运行inner()函数的时候调用main()中声明的局部变量，比如Pascal)。当函数又进一步调用另一个函数的时候，一个新的帧会继续增加到栈的下方，控制权转移到新的函数中。当激活函数返回的时候，会从栈中弹出(pop，读取并从栈中删除)该帧，并根据帧中记录的返回地址，将控制权交给返回地址所指向的指令(比如从inner()函数中返回，继续执行main()中赋值给main2的操作)。</p>
<p>下图是栈在运行过程中的变化。箭头表示栈的增长方向。每个方块代表一帧。开始的时候我们有一个为main()服务的帧，随着调用inner()，我们为inner()增加一个帧。在inner()返回时，我们再次只有main()的帧，直到最后main()返回，其返回地址为空，所以进程结束。</p>
<p><img src="/images/14590056276526.jpg" alt=""></p>
<p>在进程运行的过程中，通过调用和返回函数，控制权不断在函数间转移。进程可以在调用函数的时候，原函数的帧中保存有在我们离开时的状态，并为新的函数开辟所需的帧空间。在调用函数返回时，该函数的帧所占据的空间随着帧的弹出而清空。进程再次回到原函数的帧中保存的状态，并根据返回地址所指向的指令继续执行。上面过程不断继续，栈不断增长或减小，直到main()返回的时候，栈完全清空，进程结束。</p>
<p>当程序中使用malloc的时候，堆(heap)会向上增长，其增长的部分就成为malloc从内存中分配的空间。malloc开辟的空间会一直存在，直到我们用free系统调用来释放，或者进程结束。一个经典的错误是内存泄漏(memory leakage), 就是指我们没有释放不再使用的堆空间，导致堆不断增长，而内存可用空间不断减少。</p>
<p>栈和堆的大小则会随着进程的运行增大或者变小。当栈和堆增长到两者相遇时候，也就是内存空间图中的蓝色区域(unused area)完全消失的时候，再无可用内存。进程会出现栈溢出(stack overflow)的错误，导致进程终止。在现代计算机中，内核一般会为进程分配足够多的蓝色区域，如果清理及时，栈溢出很容易避免。即便如此，内存负荷过大，依然可能出现栈溢出的情况。我们就需要增加物理内存了。</p>
<p>Stack overflow可以说是最出名的计算机错误了，所以才有IT网站(stackoverflow.com)以此为名。</p>
<p><strong>进程附加信息</strong></p>
<p>除了上面的信息之外，每个进程还要包括一些进程附加信息，包括PID，PPID，PGID(参考Linux进程基础以及Linux进程关系)等，用来说明进程的身份、进程关系以及其它统计信息。这些信息并不保存在进程的内存空间中。内核会为每个进程在内核自己的空间中分配一个变量(task_struct结构体)以保存上述信息。内核可以通过查看自己空间中的各个进程的附加信息就能知道进程的概况，而不用进入到进程自身的空间 (就好像我们可以通过门牌就可以知道房间的主人是谁一样，而不用打开房门)。每个进程的附加信息中有位置专门用于保存接收到的信号(正如我们在Linux信号基础中所说的“信箱”)。</p>
<p><strong>fork &amp; exec</strong></p>
<p>现在，我们可以更加深入地了解fork和exec(参考Linux进程基础)的机制了。当一个程序调用fork的时候，实际上就是将上面的内存空间，包括text, global data, heap和stack，又复制出来一个，构成一个新的进程，并在内核中为改进程创建新的附加信息 (比如新的PID，而PPID为原进程的PID)。此后，两个进程分别地继续运行下去。新的进程和原有进程有相同的运行状态(相同的变量值，相同的instructions…)。我们只能通过进程的附加信息来区分两者。</p>
<p>程序调用exec的时候，进程清空自身内存空间的text, global data, heap和stack，并根据新的程序文件重建text, global data, heap和stack (此时heap和stack大小都为0)，并开始运行。</p>
<p>(现代操作系统为了更有效率，改进了管理fork和exec的具体机制，但从逻辑上来说并没有差别。具体机制请参看Linux内核相关书籍)</p>
<p>这一篇写了整合了许多东西，所以有些长。这篇文章主要是概念性的，许多细节会根据语言和平台乃至于编译器的不同而有所变化，但大体上，以上的概念适用于所有的计算机进程(无论是Windows还是UNIX)。更加深入的内容，包括线程(thread)、进程间通信(IPC)等，都依赖于这里介绍的内容。</p>
<p><strong>总结</strong></p>
<p>函数，变量的作用范围，global/local/dynamic variables</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">global data, text,</span><br><span class="line"><span class="built_in">stack</span>, <span class="built_in">stack</span> frame, <span class="keyword">return</span> address, <span class="built_in">stack</span> overflow</span><br><span class="line">heap, <span class="built_in">malloc</span>, <span class="built_in">free</span>, memory leakage</span><br><span class="line">进程附加信息, task_struct</span><br><span class="line">fork &amp; exec</span><br></pre></td></tr></table></figure>
<h2 id="Linux_u591A_u7EBF_u7A0B_u4E0E_u540C_u6B65"><a href="#Linux_u591A_u7EBF_u7A0B_u4E0E_u540C_u6B65" class="headerlink" title="Linux多线程与同步"></a>Linux多线程与同步</h2><p>典型的UNIX系统都支持一个进程创建多个线程(thread)。在Linux进程基础中提到，Linux以进程为单位组织操作，Linux中的线程也都基于进程。尽管实现方式有异于其它的UNIX系统，但Linux的多线程在逻辑和使用上与真正的多线程并没有差别。</p>
<p><strong>多线程</strong></p>
<p>我们先来看一下什么是多线程。在Linux从程序到进程中，我们看到了一个程序在内存中的表示。这个程序的整个运行过程中，只有一个控制权的存在。当函数被调用的时候，该函数获得控制权，成为激活(active)函数，然后运行该函数中的指令。与此同时，其它的函数处于离场状态，并不运行。如下图所示:</p>
<p><img src="/images/14590056454901.jpg" alt=""></p>
<p>我们看到，各个方块之间由箭头连接。各个函数就像是连在一根线上一样，计算机像一条流水线一样执行各个函数中定义的操作。这样的一个程序叫做单线程程序。</p>
<p>多线程就是允许一个进程内存在多个控制权，以便让多个函数同时处于激活状态，从而让多个函数的操作同时运行。即使是单CPU的计算机，也可以通过不停地在不同线程的指令间切换，从而造成多线程同时运行的效果。如下图所示，就是一个多线程的流程:</p>
<p><img src="/images/14590056551293.jpg" alt=""></p>
<p>main()到func3()再到main()构成一个线程，此外func1()和func2()构成另外两个线程。操作系统一般都有一些系统调用来让你将一个函数运行成为一个新的线程。</p>
<p>回忆我们在Linux从程序到进程中提到的栈的功能和用途。一个栈，只有最下方的帧可被读写。相应的，也只有该帧对应的那个函数被激活，处于工作状态。为了实现多线程，我们必须绕开栈的限制。为此，创建一个新的线程时，我们为这个线程建一个新的栈。每个栈对应一个线程。当某个栈执行到全部弹出时，对应线程完成任务，并收工。所以，多线程的进程在内存中有多个栈。多个栈之间以一定的空白区域隔开，以备栈的增长。每个线程可调用自己栈最下方的帧中的参数和变量，并与其它线程共享内存中的Text，heap和global data区域。对应上面的例子，我们的进程空间中需要有3个栈。</p>
<p>(要注意的是，对于多线程来说，由于同一个进程空间中存在多个栈，任何一个空白区域被填满都会导致stack overflow的问题。)</p>
<p><strong>并发</strong></p>
<p>多线程相当于一个并发(concunrrency)系统。并发系统一般同时执行多个任务。如果多个任务可以共享资源，特别是同时写入某个变量的时候，就需要解决同步的问题。比如说，我们有一个多线程火车售票系统，用全局变量i存储剩余的票数。多个线程不断地卖票(i = i - 1)，直到剩余票数为0。所以每个都需要执行如下操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*mu is a global mutex*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;                        <span class="comment">/*infinite loop*/</span></span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) i = i -<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"no more tickets"</span>);</span><br><span class="line">      <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只有一个线程执行上面的程序的时候(相当于一个窗口售票)，则没有问题。但如果多个线程都执行上面的程序(相当于多个窗口售票), 我们就会出现问题。我们会看到，其根本原因在于同时发生的各个线程都可以对i读取和写入。</p>
<p>我们这里的if结构会给CPU两个指令, 一个是判断是否有剩余的票(i != 0), 一个是卖票 (i = i -1)。某个线程会先判断是否有票(比如说此时i为1)，但两个指令之间存在一个时间窗口，其它线程可能在此时间窗口内执行卖票操作(i = i -1)，导致该线程卖票的条件不再成立。但该线程由于已经执行过了判断指令，所以无从知道i发生了变化，所以继续执行卖票指令，以至于卖出不存在的票 (i成为负数)。对于一个真实的售票系统来说，这将成为一个严重的错误 (售出了过多的票，火车爆满)。</p>
<p>在并发情况下，指令执行的先后顺序由内核决定。同一个线程内部，指令按照先后顺序执行，但不同线程之间的指令很难说清除哪一个会先执行。如果运行的结果依赖于不同线程执行的先后的话，那么就会造成竞争条件(race condition)，在这样的状况下，计算机的结果很难预知。我们应该尽量避免竞争条件的形成。最常见的解决竞争条件的方法是将原先分离的两个指令构成不可分隔的一个原子操作(atomic operation)，而其它任务不能插入到原子操作中。</p>
<p><strong>多线程同步</strong></p>
<p>对于多线程程序来说，同步(synchronization)是指在一定的时间内只允许某一个线程访问某个资源 。而在此时间内，不允许其它的线程访问该资源。我们可以通过互斥锁(mutex)，条件变量(condition variable)和读写锁(reader-writer lock)来同步资源。</p>
<p><strong>1) 互斥锁</strong></p>
<p>互斥锁是一个特殊的变量，它有锁上(lock)和打开(unlock)两个状态。互斥锁一般被设置成全局变量。打开的互斥锁可以由某个线程获得。一旦获得，这个互斥锁会锁上，此后只有该线程有权打开。其它想要获得互斥锁的线程，会等待直到互斥锁再次打开的时候。我们可以将互斥锁想像成为一个只能容纳一个人的洗手间，当某个人进入洗手间的时候，可以从里面将洗手间锁上。其它人只能在互斥锁外面等待那个人出来，才能进去。在外面等候的人并没有排队，谁先看到洗手间空了，就可以首先冲进去。</p>
<p>上面的问题很容易使用互斥锁的问题解决，每个线程的程序可以改为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*mu is a global mutex*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;                <span class="comment">/*infinite loop*/</span></span><br><span class="line">  mutex_lock(mu);           <span class="comment">/*aquire mutex and lock it, if cannot, wait until mutex is unblocked*/</span></span><br><span class="line">  <span class="keyword">if</span> (i != <span class="number">0</span>) i = i - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"no more tickets"</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_unlock(mu);         <span class="comment">/*release mutex, make it unblocked*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个执行mutex_lock()的线程会先获得mu。其它想要获得mu的线程必须等待，直到第一个线程执行到mutex_unlock()释放mu，才可以获得mu，并继续执行线程。所以线程在mutex_lock()和mutex_unlock()之间的操作时，不会被其它线程影响，就构成了一个原子操作。</p>
<p>需要注意的时候，如果存在某个线程依然使用原先的程序 (即不尝试获得mu，而直接修改i)，互斥锁不能阻止该程序修改i，互斥锁就失去了保护资源的意义。所以，互斥锁机制需要程序员自己来写出完善的程序来实现互斥锁的功能。我们下面讲的其它机制也是如此。</p>
<p><strong>2) 条件变量</strong></p>
<p>条件变量是另一种常用的变量。它也常常被保存为全局变量，并和互斥锁合作。</p>
<p>假设这样一个状况: 有100个工人，每人负责装修一个房间。当有10个房间装修完成的时候，老板就通知相应的十个工人一起去喝啤酒。</p>
<p>我们如何实现呢？老板让工人在装修好房间之后，去检查已经装修好的房间数。但多线程条件下，会有竞争条件的危险。也就是说，其他工人有可能会在该工人装修好房子和检查之间完成工作。采用下面方式解决：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*mu: global mutex, cond: global codition variable, num: global int*/</span></span><br><span class="line">mutex_lock(mu)</span><br><span class="line"></span><br><span class="line">num = num + <span class="number">1</span>;                      <span class="comment">/*worker build the room*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num &lt;= <span class="number">10</span>) &#123;                     <span class="comment">/*worker is within the first 10 to finish*/</span></span><br><span class="line">    cond_wait(mu, cond);            <span class="comment">/*wait*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"drink beer"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num = <span class="number">11</span>) &#123;                <span class="comment">/*workder is the 11th to finish*/</span></span><br><span class="line">  cond_broadcast(mu, cond);         <span class="comment">/*inform the other 9 to wake up*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutex_unlock(mu);</span><br></pre></td></tr></table></figure>
<p>上面使用了条件变量。条件变量除了要和互斥锁配合之外，还需要和另一个全局变量配合(这里的num, 也就是装修好的房间数)。这个全局变量用来构成各个条件。</p>
<p>具体思路如下。我们让工人在装修好房间(num = num + 1)之后，去检查已经装修好的房间数( num &lt; 10 )。由于mu被锁上，所以不会有其他工人在此期间装修房间(改变num的值)。如果该工人是前十个完成的人，那么我们就调用cond_wait()函数。<br>cond_wait()做两件事情，一个是释放mu，从而让别的工人可以建房。另一个是等待，直到cond的通知。这样的话，符合条件的线程就开始等待。</p>
<p>当有通知(第十个房间已经修建好)到达的时候，condwait()会再次锁上mu。线程的恢复运行，执行下一句prinft(“drink beer”) (喝啤酒！)。从这里开始，直到mutex_unlock()，就构成了另一个互斥锁结构。</p>
<p>那么，前面十个调用cond_wait()的线程如何得到的通知呢？我们注意到elif if，即修建好第11个房间的人，负责调用cond_broadcast()。这个函数会给所有调用cond_wait()的线程放送通知，以便让那些线程恢复运行。</p>
<p>条件变量特别适用于多个线程等待某个条件的发生。如果不使用条件变量，那么每个线程就需要不断尝试获得互斥锁并检查条件是否发生，这样大大浪费了系统的资源。</p>
<p><strong>3) 读写锁</strong></p>
<p>读写锁与互斥锁非常相似。r、RW lock有三种状态: 共享读取锁(shared-read), 互斥写入锁(exclusive-write lock), 打开(unlock)。后两种状态与之前的互斥锁两种状态完全相同。</p>
<p>一个unlock的RW lock可以被某个线程获取R锁或者W锁。</p>
<p>如果被一个线程获得R锁，RW lock可以被其它线程继续获得R锁，而不必等待该线程释放R锁。但是，如果此时有其它线程想要获得W锁，它必须等到所有持有共享读取锁的线程释放掉各自的R锁。</p>
<p>如果一个锁被一个线程获得W锁，那么其它线程，无论是想要获取R锁还是W锁，都必须等待该线程释放W锁。</p>
<p>这样，多个线程就可以同时读取共享资源。而具有危险性的写入操作则得到了互斥锁的保护。</p>
<p>我们需要同步并发系统，这为程序员编程带来了难度。但是多线程系统可以很好的解决许多IO瓶颈的问题。比如我们监听网络端口。如果我们只有一个线程，那么我们必须监听，接收请求，处理，回复，再监听。如果我们使用多线程系统，则可以让多个线程监听。当我们的某个线程进行处理的时候，我们还可以有其他的线程继续监听，这样，就大大提高了系统的利用率。在数据越来越大，服务器读写操作越来越多的今天，这具有相当的意义。多线程还可以更有效地利用多CPU的环境。</p>
<p>(就像做饭一样，不断切换去处理不同的菜。)</p>
<p>本文中的程序采用伪C的写法。不同的语言有不同的函数名(比如mutex_lock)。这里关注的是逻辑上的概念，而不是具体的实现和语言规范。</p>
<p><strong>总结</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">multiple </span>threads, <span class="keyword">multiple </span>stacks</span><br><span class="line"><span class="label">race</span> condition</span><br><span class="line"><span class="label">mutex</span>, condition variable, RW lock</span><br></pre></td></tr></table></figure>
<h2 id="Linux_u8FDB_u7A0B_u95F4_u901A_u4FE1"><a href="#Linux_u8FDB_u7A0B_u95F4_u901A_u4FE1" class="headerlink" title="Linux进程间通信"></a>Linux进程间通信</h2><p>我们在Linux信号基础中已经说明，信号可以看作一种粗糙的进程间通信(IPC, interprocess communication)的方式，用以向进程封闭的内存空间传递信息。为了让进程间传递更多的信息量，我们需要其他的进程间通信方式。这些进程间通信方式可以分为两种:</p>
<ul>
<li>管道(PIPE)机制。在Linux文本流中，我们提到可以使用管道将一个进程的输出和另一个进程的输入连接起来，从而利用文件操作API来管理进程间通信。在shell中，我们经常利用管道将多个进程连接在一起，从而让各个进程协作，实现复杂的功能。</li>
<li>传统IPC (interprocess communication)。我们主要是指消息队列(message queue)，信号量(semaphore)，共享内存(shared memory)。这些IPC的特点是允许多进程之间共享资源，这与多线程共享heap和global data相类似。由于多进程任务具有并发性 (每个进程包含一个进程，多个进程的话就有多个线程)，所以在共享资源的时候也必须解决同步的问题 (参考Linux多线程与同步)。</li>
</ul>
<p><strong>管道与FIFO文件</strong></p>
<p>一个原始的IPC方式是所有的进程通过一个文件交流。比如我在纸(文件)上写下我的名字和年纪。另一个人读这张纸，会知道我的名字和年纪。他也可以在同一张纸上写下他的信息，而当我读这张纸的话，同样也可以知道别人的信息。但是，由于硬盘读写比较慢，所以这个方式效率很低。那么，我们是否可以将这张纸放入内存中以提高读写速度呢？</p>
<p>在Linux文本流中，我们已经讲解了如何在shell中使用管道连接多个进程。同样，许多编程语言中，也有一些命令用以实现类似的机制，比如在Python子进程中使用Popen和PIPE，在C语言中也有popen库函数来实现管道 (shell中的管道就是根据此编写的)。管道是由内核管理的一个缓冲区(buffer)，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。</p>
<p><img src="/images/14590056730715.jpg" alt=""></p>
<p>从原理上，管道利用fork机制建立(参考Linux进程基础和Linux从程序到进程），从而让两个进程可以连接到同一个PIPE上。最开始的时候，上面的两个箭头都连接在同一个进程Process 1上(连接在Process 1上的两个箭头)。当fork复制进程的时候，会将这两个连接也复制到新的进程(Process 2)。随后，每个进程关闭自己不需要的一个连接 (两个黑色的箭头被关闭; Process 1关闭从PIPE来的输入连接，Process 2关闭输出到PIPE的连接)，这样，剩下的红色连接就构成了如上图的PIPE。</p>
<p><img src="/images/14590056811596.jpg" alt=""></p>
<p><strong>传统IPC</strong></p>
<p>这几种传统IPC实际上有很悠久的历史，所以其实现方式也并不完善 (比如说我们需要某个进程负责删除建立的IPC)。一个共同的特征是它们并不使用文件操作的API。对于任何一种IPC来说，你都可以建立多个连接，并使用键值(key)作为识别的方式。我们可以在一个进程中中通过键值来使用的想要那一个连接 (比如多个消息队列，而我们选择使用其中的一个)。键值可以通过某种IPC方式在进程间传递(比如说我们上面说的PIPE，FIFO或者写入文件)，也可以在编程的时候内置于程序中。</p>
<p>在几个进程共享键值的情况下，这些传统IPC非常类似于多线程共享资源的方式(参看Linux多线程与同步):</p>
<ul>
<li>semaphore与mutex类似，用于处理同步问题。我们说mutex像是一个只能容纳一个人的洗手间，那么semaphore就像是一个能容纳N个人的洗手间。其实从意义上来说，semaphore就是一个计数锁(我觉得将semaphore翻译成为信号量非常容易让人混淆semaphore与signal)，它允许被N个进程获得。当有更多的进程尝试获得semaphore的时候，就必须等待有前面的进程释放锁。当N等于1的时候，semaphore与mutex实现的功能就完全相同。许多编程语言也使用semaphore处理多线程同步的问题。一个semaphore会一直存在在内核中，直到某个进程删除它。</li>
<li>共享内存与多线程共享global data和heap类似。一个进程可以将自己内存空间中的一部分拿出来，允许其它进程读写。当使用共享内存的时候，我们要注意同步的问题。我们可以使用semaphore同步，也可以在共享内存中建立mutex或其它的线程同步变量来同步。由于共享内存允许多个进程直接对同一个内存区域直接操作，所以它是效率最高的IPC方式。</li>
</ul>
<p>消息队列(message queue)与PIPE相类似。它也是建立一个队列，先放入队列的消息被最先取出。不同的是，消息队列允许多个进程放入消息，也允许多个进程取出消息。每个消息可以带有一个整数识别符(message_type)。你可以通过识别符对消息分类 (极端的情况是将每个消息设置一个不同的识别符)。某个进程从队列中取出消息的时候，可以按照先进先出的顺序取出，也可以只取出符合某个识别符的消息(有多个这样的消息时，同样按照先进先出的顺序取出)。消息队列与PIPE的另一个不同在于它并不使用文件API。最后，一个队列不会自动消失，它会一直存在于内核中，直到某个进程删除该队列。</p>
<p>多进程协作可以帮助我们充分利用多核和网络时代带来的优势。多进程可以有效解决计算瓶颈的问题。互联网通信实际上也是一个进程间通信的问题，只不过这多个进程分布于不同的电脑上。网络连接是通过socket实现的。由于socket内容庞大，所以我们不在这里深入。一个小小的注解是，socket也可以用于计算机内部进程间的通信。</p>
<p><strong>总结</strong></p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PIPE, FIFO</span><br><span class="line">semaphore, message queue, <span class="keyword">shared</span> memory; <span class="keyword">key</span></span><br></pre></td></tr></table></figure>
<h2 id="Linux_u6587_u4EF6_u7CFB_u7EDF_u7684_u5B9E_u73B0"><a href="#Linux_u6587_u4EF6_u7CFB_u7EDF_u7684_u5B9E_u73B0" class="headerlink" title="Linux文件系统的实现"></a>Linux文件系统的实现</h2><p>Linux文件管理从用户的层面介绍了Linux管理文件的方式。Linux有一个树状结构来组织文件。树的顶端为根目录(/)，节点为目录，而末端的叶子为包含数据的文件。当我们给出一个文件的完整路径时，我们从根目录出发，经过沿途各个目录，最终到达文件。</p>
<p>我们可以对文件进行许多操作，比如打开和读写。在Linux文件管理相关命令中，我们看到许多对文件进行操作的命令。它们大都基于对文件的打开和读写操作。比如cat可以打开文件，读取数据，最后在终端显示：</p>
<pre><code>$cat test.txt
</code></pre><p>对于Linux下的程序员来说，了解文件系统的底层组织方式，是深入进行系统编程所必备的。即使是普通的Linux用户，也可以根据相关的内容，设计出更好的系统维护方案。</p>
<p><strong>存储设备分区</strong></p>
<p>文件系统的最终目的是把大量数据有组织的放入持久性(persistant)的存储设备中，比如硬盘和磁盘。这些存储设备与内存不同。它们的存储能力具有持久性，不会因为断电而消失；存储量大，但读取速度慢。</p>
<p>观察常见存储设备。最开始的区域是MBR，用于Linux开机启动(参考Linux开机启动)。剩余的空间可能分成数个分区(partition)。每个分区有一个相关的分区表(Partition table)，记录分区的相关信息。这个分区表是储存在分区之外的。分区表说明了对应分区的起始位置和分区的大小。</p>
<p><img src="/images/14590056923433.jpg" alt=""></p>
<p>我们在Windows系统常常看到C分区、D分区等。Linux系统下也可以有多个分区，但都被挂载在同一个文件系统树上。</p>
<p>数据被存入到某个分区中。一个典型的Linux分区(partition)包含有下面各个部分:</p>
<p><img src="/images/14590056997684.jpg" alt=""></p>
<p>分区的第一个部分是启动区(Boot block)，它主要是为计算机开机服务的。Linux开机启动后，会首先载入MBR，随后MBR从某个硬盘的启动区加载程序。该程序负责进一步的操作系统的加载和启动。为了方便管理，即使某个分区中没有安装操作系统，Linux也会在该分区预留启动区。</p>
<p>启动区之后的是超级区(Super block)。它存储有文件系统的相关信息，包括文件系统的类型，inode的数目，数据块的数目。</p>
<p>随后是多个inodes，它们是实现文件存储的关键。在Linux系统中，一个文件可以分成几个数据块存储，就好像是分散在各地的龙珠一样。为了顺利的收集齐龙珠，我们需要一个“雷达”的指引：该文件对应的inode。每个文件对应一个inode。这个inode中包含多个指针，指向属于该文件各个数据块。当操作系统需要读取文件时，只需要对应inode的”地图”，收集起分散的数据块，就可以收获我们的文件了。</p>
<p>最后一部分，就是真正储存数据的数据块们(data blocks)了。</p>
<p><strong>inode简介</strong></p>
<p>上面我们看到了存储设备的宏观结构。我们要深入到分区的结构，特别是文件在分区中的存储方式。</p>
<p>文件是文件系统对数据的分割单元。文件系统用目录来组织文件，赋予文件以上下分级的结构。在硬盘上实现这一分级结构的关键，是使用inode来虚拟普通文件和目录文件对象。</p>
<p>在Linux文件管理中，我们知道，一个文件除了自身的数据之外，还有一个附属信息，即文件的元数据(metadata)。这个元数据用于记录文件的许多信息，比如文件大小，拥有人，所属的组，修改日期等等。元数据并不包含在文件的数据中，而是由操作系统维护的。事实上，这个所谓的元数据就包含在inode中。我们可以用$ls -l filename来查看这些元数据。正如我们上面看到的，inode所占据的区域与数据块的区域不同。每个inode有一个唯一的整数编号(inode number)表示。</p>
<p>在保存元数据，inode是“文件”从抽象到具体的关键。正如上一节中提到的，inode储存由一些指针，这些指针指向存储设备中的一些数据块，文件的内容就储存在这些数据块中。当Linux想要打开一个文件时，只需要找到文件对应的inode，然后沿着指针，将所有的数据块收集起来，就可以在内存中组成一个文件的数据了。</p>
<p><img src="/images/14590057101211.jpg" alt=""></p>
<p>inode并不是组织文件的唯一方式。最简单的组织文件的方法，是把文件依次顺序的放入存储设备，DVD就采取了类似的方式。但如果有删除操作，删除造成的空余空间夹杂在正常文件之间，很难利用和管理。</p>
<p>复杂的方式可以使用链表，每个数据块都有一个指针，指向属于同一文件的下一个数据块。这样的好处是可以利用零散的空余空间，坏处是对文件的操作必须按照线性方式进行。如果想随机存取，那么必须遍历链表，直到目标位置。由于这一遍历不是在内存进行，所以速度很慢。</p>
<p>FAT系统是将上面链表的指针取出，放入到内存的一个数组中。这样，FAT可以根据内存的索引，迅速的找到一个文件。这样做的主要问题是，索引数组的大小与数据块的总数相同。因此，存储设备很大的话，这个索引数组会比较大。</p>
<p>inode既可以充分利用空间，在内存占据空间不与存储设备相关，解决了上面的问题。但inode也有自己的问题。每个inode能够存储的数据块指针总数是固定的。如果一个文件需要的数据块超过这一总数，inode需要额外的空间来存储多出来的指针。</p>
<p><strong>inode示例</strong></p>
<p>在Linux中，我们通过解析路径，根据沿途的目录文件来找到某个文件。目录中的条目除了所包含的文件名，还有对应的inode编号。当我们输入$cat /var/test.txt时，Linux将在根目录文件中找到var这个目录文件的inode编号，然后根据inode合成var的数据。随后，根据var中的记录，找到text.txt的inode编号，沿着inode中的指针，收集数据块，合成text.txt的数据。整个过程中，我们参考了三个inode：根目录文件，var目录文件，text.txt文件的inodes。</p>
<p>在Linux下，可以使用$stat filename，来查询某个文件对应的inode编号。</p>
<p><img src="/images/14590057224870.jpg" alt=""></p>
<p>在存储设备中实际上存储为：</p>
<p><img src="/images/14590057295211.jpg" alt=""></p>
<p>当我们读取一个文件时，实际上是在目录中找到了这个文件的inode编号，然后根据inode的指针，把数据块组合起来，放入内存供进一步的处理。当我们写入一个文件时，是分配一个空白inode给该文件，将其inode编号记入该文件所属的目录，然后选取空白的数据块，让inode的指针指像这些数据块，并放入内存中的数据。</p>
<p><strong>文件共享</strong></p>
<p>在Linux的进程中，当我们打开一个文件时，返回的是一个文件描述符。这个文件描述符是一个数组的下标，对应数组元素为一个指针。有趣的是，这个指针并没有直接指向文件的inode，而是指向了一个文件表格，再通过该表格，指向加载到内存中的目标文件的inode。如下图，一个进程打开了两个文件。</p>
<p><img src="/images/14590057435416.jpg" alt=""></p>
<p>可以看到，每个文件表格中记录了文件打开的状态(status flags)，比如只读，写入等，还记录了每个文件的当前读写位置(offset)。当有两个进程打开同一个文件时，可以有两个文件表格，每个文件表格对应的打开状态和当前位置不同，从而支持一些文件共享的操作，比如同时读取。</p>
<p>要注意的是进程fork之后的情况，子进程将只复制文件描述符的数组，而和父进程共享内核维护的文件表格和inode。此时要特别小心程序的编写。</p>
<p><strong>总结</strong></p>
<p>这里概括性的总结了Linux的文件系统。Linux以inode的方式，让数据形成文件。</p>
<p>了解Linux的文件系统，是深入了解操作系Linux原理的重要一步。</p>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/03/03/2871198.html" target="_blank" rel="external">Linux 常用命令</a></li>
<li><a href="http://www.cnblogs.com/peida/archive/2012/12/05/2803591.html" target="_blank" rel="external">每天一个linux命令目录</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇日志来自 <a href="http://www.cnblogs.com/vamei">Vamei 博客</a> 中的系列文章，把一些基本的内容做了整合，方便查阅。</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://wdxtub.com/tags/Linux/"/>
    
      <category term="Vamei" scheme="http://wdxtub.com/tags/Vamei/"/>
    
      <category term="概念" scheme="http://wdxtub.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第十一周 - 声律启蒙]]></title>
    <link href="http://wdxtub.com/2016/03/25/rhythm-inspiration/"/>
    <id>http://wdxtub.com/2016/03/25/rhythm-inspiration/</id>
    <published>2016-03-25T10:04:09.000Z</published>
    <updated>2016-03-25T10:59:31.000Z</updated>
    <content type="html"><![CDATA[<p>云对雨，雪对风，晚照对晴空。天浩浩，日融融，弯月对长虹。</p>
<a id="more"></a>
<hr>
<p>这周的状态不是特别好，睡了八个月的帐篷终于开始有些不习惯了，再加上早早做完了作业，反而是有了更多『想干嘛就干嘛』的时间。周二买了无论是质量还是设计都不走洗的毕业礼服，周三和同学边吃饭边聊天，其他时间不是在睡觉，就是在准备睡觉的路上。</p>
<p>当然也有好消息，总算是确定了自己毕业后要落脚的地方。经过这么长时间的逡巡，应该说找到的双方都比较满意的工作，既不用一轮轮刷题（总有种摇尾乞怜的感觉），也没有太多的不信任感（不需要花时间自证）。工作嘛，双向选择，适合自己的，有广阔发展前景的，可能才是最好的选择。</p>
<p>于我，机会在哪里，我就愿意在哪里，而不是为了所谓『光环』，去当一颗螺丝钉。不想当将军的厨子不是好士兵，不过话说回来，人各有志，喜欢就好。</p>
<p>我不知道用战术勤奋掩盖战略懒惰是不是身边同学的『习惯』，经常在群里能看到三四点还在问作业相关问题，又或者告诉大家自己三四十个小时没有合眼。</p>
<p>我不大理解，也并不觉得真的需要这么『拼』，或者都不能说是『拼』，只能说是用低效率乘以长时间最后感动了自己。一天能做完的事情做一周，这根本不是什么值得骄傲或者感动的地方吧。说什么『现在的泪是选课时脑子进的水』，估计不是选课时进的，是本来就是水，不多去想想怎么提高效率，遇到简单问题就到处问，怎么进步呢？</p>
<p>我个人是很讨厌大半夜二话不说就甩作业问题来的人的，即使很多时候就是一句话的事儿，但是我也不想看这个头，不然以后就没完没了了。既然只是一句话的事儿，为什么不自己看看文档资料研究一下呢？</p>
<p>反而是有一些工作经验的同学，无论是相处还是聊天，都自在得多，至少不会出现『沟通障碍』。学校的学习是很重要，但是更重要的可能是培养自己去观察去思考的能力，作业是一种方式，但绝不是最好的方式。</p>
<p>我有我的冷漠无情，我有我的满腔热血。只索取不给予的人，离我远点，谢谢。</p>
<p>两鬓霜，一客行，新绿衬酒红。七颗星，一袍风，佛陀对苍生。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>云对雨，雪对风，晚照对晴空。天浩浩，日融融，弯月对长虹。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="平淡" scheme="http://wdxtub.com/tags/%E5%B9%B3%E6%B7%A1/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写文章]]></title>
    <link href="http://wdxtub.com/2016/03/24/write-an-article/"/>
    <id>http://wdxtub.com/2016/03/24/write-an-article/</id>
    <published>2016-03-25T00:47:12.000Z</published>
    <updated>2016-03-25T01:50:11.000Z</updated>
    <content type="html"><![CDATA[<p>在这个风云千樯的夜晚，我们来聊聊写文章。</p>
<a id="more"></a>
<hr>
<p>从高中开始写博客，转眼也快写了十年了。当然前七年都是瞎折腾，最近几年，随着阅读量的增加，写作慢慢才有了点起色。不由得想起这么一句话『Garbage in, Garbage out』，有高质量的『输入』，高质量的『输出』才成为可能。</p>
<p>这篇日志是我对于写文章这个事儿的一点感悟，比较零碎。</p>
<p>动笔之前，腹稿是很重要的，中心思想是什么，怎么组织文章来表达自己的想法，可能由于天资的问题我没办法一边写一边完成，所以我通常都会在纸上写关键字列提纲，这样不至于写着写着都不知道自己在写什么。浪费读者时间就是砸自己招牌，这种事情，给钱也不应该做。</p>
<p>写故事是另一种风格，真的是需要一些灵感，强求不来，对于故事本身来说，也许一开始不设定套路，反而是最好的套路，不然很容易落入俗套。另外一定要控制好『描述』、『说理』和『传情』的比例。描述太多累赘，说理太多教条，传情太多矫情。</p>
<p>那些让自己不开心不爽的事情，其实最有写下来的价值，这种内心的冲突，最难写，但是也最能出彩，试着去观察自己，并描述出来，既是很好的发泄，也是绝佳的训练。</p>
<p>另外值得写的就是各种光怪陆离的梦境，对于有些违背常理的东西，想要说清楚是很难的，但是这种训练的目的，只是去练习表达而已，多写就有不一样的收获。</p>
<p>从某种角度来说，写作是一种肌肉记忆，比方说写周记，我通常就会在周四或周五的晚上写作，慢慢形成习惯之后，到时间自然而然就会进入状态，几乎不会出现不知道写啥的情况，几乎都是自然而然流淌出来的文字。</p>
<p>时不时需要看自己以前的文字，用现在的标准去审视，有没有个人的风格，有没有词汇的不恰当，慢慢去培养自己的感觉。很多时候进入写作状态之后，出来的文字是比较『原生态』的，如果想要更进一步，就需要仔细打磨。观察自己的写作特点，并据此决定之后的方向。</p>
<blockquote>
<p>生气、嫉妒和沮丧是你灵感之源的毒药，你把这些处于萌芽状态的迹象消灭得越早，你的写作就会越好。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这个风云千樯的夜晚，我们来聊聊写文章。</p>]]>
    
    </summary>
    
      <category term="写作" scheme="http://wdxtub.com/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="阅读" scheme="http://wdxtub.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[看电影]]></title>
    <link href="http://wdxtub.com/2016/03/24/see-a-movie/"/>
    <id>http://wdxtub.com/2016/03/24/see-a-movie/</id>
    <published>2016-03-25T00:46:45.000Z</published>
    <updated>2016-03-25T01:15:13.000Z</updated>
    <content type="html"><![CDATA[<p>在这个风云千樯的夜晚，我们来聊聊看电影。</p>
<a id="more"></a>
<hr>
<p>我不算一个电影爱好者，看得不多，写得不多，想得也不多。但作为一种艺术表达形式，其实很多东西都是相通的。总体来说，依然可以按照《人间词话》中的三层来划分。</p>
<blockquote>
<p>昨夜西风凋碧树，独上高楼，望尽天涯路</p>
</blockquote>
<p>第一层很简单，就是两个字——『代入』。喜剧片大笑，言情片大哭，动作片大叫。不同的电影像是不同的楼，走到楼顶，去看这栋楼给你的风景。</p>
<blockquote>
<p>衣带渐宽终不悔，为伊消得人憔悴</p>
</blockquote>
<p>第二层需要加入一些『思考』，主题、道理、文化、知识，虽然有一定的局限性，但是至少自己觉得这些『思考』是有价值的（实际不一定，因为电影毕竟是艺术表现，可能得到的所谓『经验』并没有什么用）。</p>
<p>之所以比第一层要高，是因为已经开始『加工』电影本身，夹带『私货』，从『体验』变成了『参与』。</p>
<blockquote>
<p>众里寻他千百度，回首蓦见，那人正在灯火阑珊处</p>
</blockquote>
<p>第三层的关键词，恐怕是『抽离』，以一个局外人的角度，去观察电影的表达形式，去挖掘镜头的细节和深度。也就是说，要以电影为起点，去追根溯源，找到作者当初灵感迸发的瞬间，并研究为什么要用这样那样的形式去表现。</p>
<p>也许得到的答案，也就是平时自己忽略的细小瞬间罢了。</p>
<p>或者可以这么说，电影是起点，终点则是生活本身。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这个风云千樯的夜晚，我们来聊聊看电影。</p>]]>
    
    </summary>
    
      <category term="欣赏" scheme="http://wdxtub.com/tags/%E6%AC%A3%E8%B5%8F/"/>
    
      <category term="电影" scheme="http://wdxtub.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[广州美食地图]]></title>
    <link href="http://wdxtub.com/2016/03/24/guangzhou-food-map/"/>
    <id>http://wdxtub.com/2016/03/24/guangzhou-food-map/</id>
    <published>2016-03-25T00:13:02.000Z</published>
    <updated>2016-03-25T00:25:38.000Z</updated>
    <content type="html"><![CDATA[<p>这里记录一下网上比较出名的广州美食，非常适合『按图索骥』，口味比较个人化。</p>
<a id="more"></a>
<hr>
<h2 id="u5C0F_u5403"><a href="#u5C0F_u5403" class="headerlink" title="小吃"></a>小吃</h2><h3 id="u4E1C_u5DDD_u8DEF_u7A57_u94F6_u80A0_u7C89_u5E97"><a href="#u4E1C_u5DDD_u8DEF_u7A57_u94F6_u80A0_u7C89_u5E97" class="headerlink" title="东川路穗银肠粉店"></a>东川路穗银肠粉店</h3><p>猪腰肠或者牛肉肠。只要过去那边一定吃一次。反正是我个人认为的最好吃的肠粉</p>
<h3 id="u9648_u6DFB_u8BB0"><a href="#u9648_u6DFB_u8BB0" class="headerlink" title="陈添记"></a>陈添记</h3><p>过了宝华面店斜对面有条小巷叫十五甫三巷，拐进去就能看到“陈添记”的招牌，  此店绝对是广州的老字号，陈添记有三宝：爽滑鱼皮、艇仔粥、猪肠粉，招牌鱼皮：里面有花生粒、葱、姜、辣椒丝、香菜、芹菜，用特制酱油来调配，味道够足且各种滋味分明~</p>
<h3 id="u65B0_u8054_u7C89_u80A0_u5E97"><a href="#u65B0_u8054_u7C89_u80A0_u5E97" class="headerlink" title="新联粉肠店"></a>新联粉肠店</h3><p>地址：荔湾区多宝路88号  营业时间:7:00–14:30 二十多年的老店，门面超小，人气却火爆。拉肠3块一碟，粥4块一碗，十分大众化兼符合西关人省钱观念。拉肠口感香滑，配上自制酱油，非常美味。要注意的是，店铺之营业到下午两点半，要吃就要趁早了！</p>
<h3 id="u963F_u5A46_u725B_u6742"><a href="#u963F_u5A46_u725B_u6742" class="headerlink" title="阿婆牛杂"></a>阿婆牛杂</h3><p>地址：陆居路陆居肉菜市场牌坊内  开档时间：下午4时  价格：1元/串</p>
<p>网传是人气最强牛杂  仅仅在牛杂汤里滚两下已经可以吃得人满口香。觉得最能尝出阿婆牛杂真味的是豆卜串，饱吸酱汁浓味香口。而且阿婆这里也是全市少见的卖牛杂兼卖鱼蛋和牛丸的。不过略嫌汤底味道重，容易口渴。</p>
<h3 id="u897F_u5173_u5C0F_u98DF_u5E97_u2014_u2014_u798F_u6765_u9601"><a href="#u897F_u5173_u5C0F_u98DF_u5E97_u2014_u2014_u798F_u6765_u9601" class="headerlink" title="西关小食店——福来阁"></a>西关小食店——福来阁</h3><p>荔湾区泮塘路(仁威庙对面)  招牌就是传统瀬粉——粘米粉+人工压制.还有就是用料十足的萝卜糕，还有好多好味的小吃.</p>
<h3 id="u6F6E_u5B9D"><a href="#u6F6E_u5B9D" class="headerlink" title="潮宝"></a>潮宝</h3><p>多宝路221号，地铁长寿路站E出口的恒宝华庭出来以后，从中国银行方向往上下九方向走，就会看到一间不显眼的小店。小吃店真的很不起眼，还是很陋室那种。但是毕竟姜是老的辣——买午餐的人排了一条长队。</p>
<h3 id="u5E99_u524D_u76F4_u8857_u4E91_u541E_u9762_u4E16_u5BB6"><a href="#u5E99_u524D_u76F4_u8857_u4E91_u541E_u9762_u4E16_u5BB6" class="headerlink" title="庙前直街云吞面世家"></a>庙前直街云吞面世家</h3><p>越秀区庙前直街10号(近7中)</p>
<p>推荐美食：蟹子云吞面（汤底很好，不放味精，云吞也好味，面是竹升面）</p>
<h3 id="u5468_u751F_u8BB0_u592A_u7237_u9E21"><a href="#u5468_u751F_u8BB0_u592A_u7237_u9E21" class="headerlink" title="周生记太爷鸡"></a>周生记太爷鸡</h3><p>龟岗大马路江岭东路4号龟岗市场第二档</p>
<p>推荐美食：太爷鸡、猪手</p>
<p>注：是一间烧腊店，在文明路和寺右新马路都有分店，是烟熏味的食品。这是间起码开了二十年的老字号，在北京吃过烤鸭的同学们请注意了，周生记太爷熏鸡在家禽烹饪界绝对不落烤鸭下风。今天你吃了几斤？</p>
<h3 id="u8FBE_u6768_u7096_u54C1"><a href="#u8FBE_u6768_u7096_u54C1" class="headerlink" title="达杨炖品"></a>达杨炖品</h3><p>广州越秀区文明路160号-1(近北京路)</p>
<p>推荐美食：炖鹌鹑、椰子炖乌鸡。不用说，绝对值得一赞</p>
<h3 id="u4E5D_u7237_u9E21"><a href="#u4E5D_u7237_u9E21" class="headerlink" title="九爷鸡"></a>九爷鸡</h3><p>广州越秀区文明路103号(近106车站)</p>
<p>推荐美食：油鸡、叉烧、烧鸭、白切鸡</p>
<h3 id="u8001_u897F_u5173_u6FD1_u7C89"><a href="#u8001_u897F_u5173_u6FD1_u7C89" class="headerlink" title="老西关濑粉"></a>老西关濑粉</h3><p>广州越秀区文明路216号(近中山图书馆)</p>
<p>推荐美食：濑粉、斋烧鹅、水菱角</p>
<h3 id="u534E_u5174_u80A0_u7C89_u5E97"><a href="#u534E_u5174_u80A0_u7C89_u5E97" class="headerlink" title="华兴肠粉店"></a>华兴肠粉店</h3><p>越秀区文明路(中山图书馆对面)</p>
<p>每次路过总看到无数当地人在津津有味的吃着，怎么能够错过。。</p>
<p>推荐美食：煲仔猪肠粉</p>
<h3 id="u80A5_u5988_u725B_u9AA8_u6C64"><a href="#u80A5_u5988_u725B_u9AA8_u6C64" class="headerlink" title="肥妈牛骨汤"></a>肥妈牛骨汤</h3><p>广州市惠福东路中街2号(大佛寺旁)</p>
<p>推荐美食：牛骨汤、大碗粉</p>
<h3 id="u5DE7_u7F8E_u4E91_u541E_u9762"><a href="#u5DE7_u7F8E_u4E91_u541E_u9762" class="headerlink" title="巧美云吞面"></a>巧美云吞面</h3><p>广州越秀区惠福东路401-403号(近起义路)</p>
<p>推荐美食：五宝云吞、五宝云吞面</p>
<p>这家面店据说是老字号！而且是因为蔡澜一直捧场过来吃！所以变得很有名气！</p>
<p>点了最有名的五宝云吞面！里面有五种不同的云吞 ！包括蟹子 鲜虾 鲜虾蟹子 鲍鱼仔 元贝五种！</p>
<p>扎实的馅料再加上打得又细又韧的竹升面！加上熬制很长时间的鲜美汤头！</p>
<h3 id="u98CE_u5473_u9986"><a href="#u98CE_u5473_u9986" class="headerlink" title="风味馆"></a>风味馆</h3><p>广州越秀区越秀南路161号</p>
<p>推荐美食：牛三星汤</p>
<p>门口的小妹妹，多少年如一日。现在终于有空调了。但是，无论它的环境如何，它的出品总是一如既往的有保证。如果没有去过的食客，请记住暗语“大汤”=大碗牛三星汤，“细汤”=小碗牛三星汤，粉只需要点大小就行，因为要去里面拿的，那个时候再选牛腩、牛杂也行。汤点完之后，拿着牌子在座位上面乖乖坐好即可。</p>
<h3 id="u8354_u6E7E_u540D_u98DF_u5BB6"><a href="#u8354_u6E7E_u540D_u98DF_u5BB6" class="headerlink" title="荔湾名食家"></a>荔湾名食家</h3><p>荔湾区第十甫路99号1楼</p>
<p>推荐美食：德昌咸煎饼</p>
<p>这里的拉肠都是传统的布拉肠啊，特别的薄。酱汁做得味道很好，有点甜甜的，让人很有食欲。</p>
<p>为了搭配拉肠，我都会要个艇仔粥或者及第粥。很喜欢把油炸鬼和粥一起吃得感觉，又脆又滑</p>
<h3 id="u5B9D_u534E_u9762_u5E97"><a href="#u5B9D_u534E_u9762_u5E97" class="headerlink" title="宝华面店"></a>宝华面店</h3><p>荔湾区宝华路117号</p>
<p>推荐美食：鲜虾云吞面、金牌猪手面</p>
<p>刚从广州回来的时候，每每到了晚上想吃东西的时候，都有想买张机票飞广州吃宝华面店的冲动，朋友回来嘴上也是常常念叨着要去吃宝华面店，从小到大从来不吃云吞，结果这一习惯被终结了。。。</p>
<h3 id="u897F_u5173_u4EBA_u5BB6"><a href="#u897F_u5173_u4EBA_u5BB6" class="headerlink" title="西关人家"></a>西关人家</h3><p>荔湾区德星路9号荔湾广场南塔4楼(近下九路)</p>
<p>很喜欢这里的老广州味道……好吃,环境是那种不讨厌的热闹.</p>
<h3 id="u4F0D_u6E5B_u8BB0"><a href="#u4F0D_u6E5B_u8BB0" class="headerlink" title="伍湛记"></a>伍湛记</h3><p>荔湾区第十甫路99号1楼荔湾名食家内</p>
<p>推荐美食：及第粥、艇仔粥</p>
<h3 id="u6797_u6797_u725B_u6742"><a href="#u6797_u6797_u725B_u6742" class="headerlink" title="林林牛杂"></a>林林牛杂</h3><p>荔湾区第十甫路188号十甫假日酒店1楼</p>
<p>推荐美食：萝卜牛杂</p>
<h3 id="u559C_u54E5_u751F_u869D"><a href="#u559C_u54E5_u751F_u869D" class="headerlink" title="喜哥生蚝"></a>喜哥生蚝</h3><p>地址:越秀区沿江路江湾酒店对面</p>
<p>湛江海鲜日日到，烧烤，砂锅粥令人食指大动，再也不用去天河立交底下吃没品位的大排档了，沙虫刺身好味道。</p>
<h2 id="u98CE_u5473"><a href="#u98CE_u5473" class="headerlink" title="风味"></a>风味</h2><h3 id="u5927_u54E5_u9910_u5385"><a href="#u5927_u54E5_u9910_u5385" class="headerlink" title="大哥餐厅"></a>大哥餐厅</h3><p>地址: 番禺市桥西丽南路</p>
<p>大哥餐厅的出品没人说过有差池，黑色的牛河，公主城堡，相信爱情，每一样东西都值得每日大量开二三十公里车来到番禺市桥就为了吃个茶餐厅的逼格食货们。老板是香港虔诚基督徒，用心做好每个细节，细节做到洗手间都充满港式文化。</p>
<h3 id="u591A_u5229_u6765_u9910_u5385"><a href="#u591A_u5229_u6765_u9910_u5385" class="headerlink" title="多利来餐厅"></a>多利来餐厅</h3><p>地址:越秀区八旗二马路</p>
<p>一间有着几十年历史的餐厅，功夫鲈鱼拿过不少大奖，老板亲自喂养回春鸽，谁吃谁知道，老餐厅自有老味道，来过说的出来的食客已经可以令专业吃货报以赏识表情！</p>
<h3 id="u82AD_u91CC_u9910_u5385"><a href="#u82AD_u91CC_u9910_u5385" class="headerlink" title="芭里餐厅"></a>芭里餐厅</h3><p>地址:番禺沙湾大桥底草河村</p>
<p>在沙湾大桥底下，稍微有点远，但是风情很好，不是农庄又生存在农村中，回头客很多，螃蟹焖飞鸭，榴莲炒饭，出品很具创意。来了不会有人说介绍错。</p>
<h3 id="MIX_u89C5_u98DF_u9910_u5385"><a href="#MIX_u89C5_u98DF_u9910_u5385" class="headerlink" title="MIX觅食餐厅"></a>MIX觅食餐厅</h3><p>地址:白云区万达广场金街出口背后母米粥旁</p>
<p>影视大红人，绝世好老公榜样文章是合伙人之一，MIX混搭风格装修，餐具都有爱情的味道，装修精致有情调，价格公道好味道，松茸鸡煲是口感有追求的食客最爱，香辣虾，香辣鲍鱼更是令好辣一族疯狂，冬天来了，去吃个娘惹羊排煲，最重要现在去不用等位，还门口还有免费停车场，有情人去到绝对有惊艳感觉。一间去签到过，会令资深食家们刮目相看的餐厅。</p>
<h3 id="u9EC4_u6C99_u6C34_u4EA7_u5E02_u573A_u697C_u4E0A_u6D77_u73CD_u822B_u5927_u9152_u697C_u3002"><a href="#u9EC4_u6C99_u6C34_u4EA7_u5E02_u573A_u697C_u4E0A_u6D77_u73CD_u822B_u5927_u9152_u697C_u3002" class="headerlink" title="黄沙水产市场楼上海珍舫大酒楼。"></a>黄沙水产市场楼上海珍舫大酒楼。</h3><p>去过七八次，虽然远了一些，但有空还是专程去吃吃吃。【海珍舫出品三个词可概括：「新鲜，大件，美味」。最最推荐超级无敌虾饺皇，每只有数整粒虾仁，不点多两笼都可惜。招牌珍味冻猪手皮脆肉爽，调出的酱油味道极美，淘饭亦佳。至尊烧麦皇、鲜竹牛肉球肉厚味香，一口咬下去幸福感爆棚。免费停车两小时，还够去黄沙市场逛一圈，拎几斤冰鲜三文鱼返屋企</p>
<h3 id="u4E1C_u5703_u4E2D_u5C71_u5927_u9E3D_u996D"><a href="#u4E1C_u5703_u4E2D_u5C71_u5927_u9E3D_u996D" class="headerlink" title="东圃中山大鸽饭"></a>东圃中山大鸽饭</h3><p>平均一周至少一次。从最早的特价6.8元/只到现在的19.8元/只，我不知为这家老板贡献了多少银纸。盐焗乳鸽优于红烧乳鸽，另外好吃的还包括油渣鸽杂炒菜心，酸辣藕尖，椰子煲鸽，拆骨猪手，以及萝卜条。</p>
<h3 id="u5927_u5934_u867E"><a href="#u5927_u5934_u867E" class="headerlink" title="大头虾"></a>大头虾</h3><p>广州越秀区西湖路63号光明广场8楼801铺(近北京路)</p>
<p>咖喱虾正宗，香茅豆腐口味独树一帜（豆腐还很嫩很滑喔！），麻油鸡和猪颈肉让口味挑剔的人都脱口称赞~</p>
<h3 id="u5929_u6CB3_u6C47_u6E58_u4E4B_u56ED"><a href="#u5929_u6CB3_u6C47_u6E58_u4E4B_u56ED" class="headerlink" title="天河汇湘之园"></a>天河汇湘之园</h3><p>剁椒鱼头。新鲜热辣，细嫩入味。去了大概十次以上吧。我一个常年呆在长沙的，推荐广州的剁椒鱼头，你知道有多美味了。</p>
<h3 id="u963F_u5F3A_u9178_u83DC_u9C7C"><a href="#u963F_u5F3A_u9178_u83DC_u9C7C" class="headerlink" title="阿强酸菜鱼"></a>阿强酸菜鱼</h3><p>广州天河北，阿强酸菜鱼。不夸张地说，88元/条（开发票加10元）的酸菜鱼，两个人可以干完。鱼肉十分之软嫩，酸麻鲜辣拿捏得很有水平，浇饭都算一绝。有预感以后要经常在这儿刷了。</p>
<h3 id="u7EA2_u57CE_u98CE_u5473"><a href="#u7EA2_u57CE_u98CE_u5473" class="headerlink" title="红城风味"></a>红城风味</h3><p>地址：西华路475号（南海中学对面）爱吃辣的童鞋一定会大爱的川菜馆，推荐：酸菜鱼、水煮牛肉、毛血旺、凉面，菜式好吃又正宗，价格都不贵，环境就一般，不适合约会，但适合同学聚会或同事聚餐；人均30元左右</p>
<h3 id="u7C73_u5E02_u8DEF_u6CD7_u5DF7_u7684_u6912_u76D0_u6FD1_u5C3F_u867E"><a href="#u7C73_u5E02_u8DEF_u6CD7_u5DF7_u7684_u6912_u76D0_u6FD1_u5C3F_u867E" class="headerlink" title="米市路泗巷的椒盐濑尿虾"></a>米市路泗巷的椒盐濑尿虾</h3><p>一间好小的大拍档，每款菜式都不会超过20元，除了必点的椒盐濑尿虾外，咸蛋黄炒云南小瓜，豆豉陈皮蒸鉗鱼，炒滑蛋等等都好吃到爆！五点半左右开档，超过六点就会有超多人排队，不会天天开档，所以去之前最好打个电话问下~电话：83372343</p>
<h3 id="u9648_u5BB6_u7960_u7684_u80A5_u4F6C_u7F8E_u98DF"><a href="#u9648_u5BB6_u7960_u7684_u80A5_u4F6C_u7F8E_u98DF" class="headerlink" title="陈家祠的肥佬美食"></a>陈家祠的肥佬美食</h3><p>陈家祠隔离的一条叫龙塘西尾的巷，康王北路公交车站就系巷口，行入巷到尾转右，过两三间屋就到，门牌号系6号，88259926  ，这个比米市路贵，但虾全都大只的，而且新鲜，至于味道就各有千秋，有盐水同椒盐两种味，无膏35元一例一斤左右，有膏就45元。其他菜色20左右，椒盐多春鱼，白灼墨鱼仔青口等都份大味道好。环境一般，折叠木台+矮凳，不过这样又有另一番风味~</p>
<h3 id="u548C_u98CE_u4E2D_u534E_u5C45_u9152_u5C4B"><a href="#u548C_u98CE_u4E2D_u534E_u5C45_u9152_u5C4B" class="headerlink" title="和风中华居酒屋"></a>和风中华居酒屋</h3><p>盘福路转入解放北右手边  这里的牛肉火锅很好味，豆腐很滑很香，入口即溶，牛肉煮得不老，刚刚好，分量足卖相好，价钱又不贵（25元）。另一推荐海鲜饼（25元）份量大，虽然没有海鲜在里面，但是铺了很多木鱼，很香口很满足。中午有特价便当送汤，15元左右，份量很足，味道不过不失</p>
<h3 id="u73AF_u7403_u6E14_u592B"><a href="#u73AF_u7403_u6E14_u592B" class="headerlink" title="环球渔夫"></a>环球渔夫</h3><p>地址:番禺美丽华酒店一楼展云轩</p>
<p>要吃到最新鲜的世界海产，这里有齐，刺身一绝，不是日本餐厅更多单纯海鲜的品味，还有两斤重的南非鲍鱼，绝对是土豪的隐蔽好去处，并且不失一个嘴刁食客的身份！</p>
<h3 id="u4E03_u7EAC_u7F18_u519C_u5E84"><a href="#u4E03_u7EAC_u7F18_u519C_u5E84" class="headerlink" title="七纬缘农庄"></a>七纬缘农庄</h3><p>地址：番禺金山大道</p>
<p>一大片的火龙果庄园，红肉的火龙果还可以做出各种菜式，农庄里有吃火龙果大的猪，鸡，鱼，周末一家大小可以耗一天的好去处，钓鱼，采摘，赶猪，吃全生态农庄菜，吃得放心，玩得开心！</p>
<h2 id="u7CA4_u83DC"><a href="#u7CA4_u83DC" class="headerlink" title="粤菜"></a>粤菜</h2><h3 id="u4EBA_u6C11_u4E2D_u8DEF_u51E4_u53A8_u987A_u5FB7_u79C1_u623F_u83DC"><a href="#u4EBA_u6C11_u4E2D_u8DEF_u51E4_u53A8_u987A_u5FB7_u79C1_u623F_u83DC" class="headerlink" title="人民中路凤厨顺德私房菜"></a>人民中路凤厨顺德私房菜</h3><p>这家的大师傅水准还是不错的。招牌凤厨鸡，鱼腐竹笙鱼肚浸时蔬，豉汁蒸大鱼头，煎焗骨腩，（以我偏淡的口味来说）除了稍咸半分外，基本无可挑剔。饭后来份双皮奶，边饮茶边吃南乳花生， 甚是惬意。说到美食，在广州的满意度确是要超过绝大多数城市。</p>
<h3 id="u4E91_u9999_u9152_u697C"><a href="#u4E91_u9999_u9152_u697C" class="headerlink" title="云香酒楼"></a>云香酒楼</h3><p>推荐理由：百年老字号，食客里好多都是公公婆婆，颇有几分怀旧的调调。点心款式不太多，但胜在分量超足，味道也可以;粤菜都是家常口味，价格几实惠，有几个特价菜好好味。环境就不咋样了，挺邋遢挺破旧的。</p>
<p>推荐菜式：冰花鸡蛋散，蛋挞，烧鹅，萝卜包，葱头鸡</p>
<p>人均消费：￥30</p>
<p>联系电话：020-37638057 020-83818661</p>
<p>详细地址：越秀区东华东路342号(近东川路)</p>
<h3 id="u798F_u65B0_u660C_u83DC_u9986"><a href="#u798F_u65B0_u660C_u83DC_u9986" class="headerlink" title="福新昌菜馆"></a>福新昌菜馆</h3><p>推荐理由：好火爆的一家粤菜馆，从没见过那么多桌子排得那么密集，还有好多人在等位。菜肴大众化，味道几靓，陈皮骨、牛肉丸尤其值得推荐，埋单更是便到出乎意料。环境就认真麻麻，岂是吵字可以形容。</p>
<p>推荐菜式：黄鳝煲，凉伴鱼皮，冰镇鳝片，陈皮骨，隔水蒸鸡，金牌甜薄撑，沙地金针浸牛滑，牛肉丸，煎面，乳鸽，烧鹅，香煎咸鲈鱼</p>
<p>人均消费：￥30-50</p>
<p>联系电话：020-84476298</p>
<p>详细地址：海珠区基立北街2号</p>
<h3 id="u5BCC_u4E34_u98DF_u5E9C"><a href="#u5BCC_u4E34_u98DF_u5E9C" class="headerlink" title="富临食府"></a>富临食府</h3><p>推荐理由：惠福东路上的一家“超正又实惠”的酒楼，是老饕街坊的聚脚点，位置很隐蔽，店面浅窄，位于一排灯饰店的中间。虽然环境一般，店面的装修和气氛，却有着毫不造作的朴实。而且出品好抵，碟头大，味道也好，招牌菜是脆皮猪手，简直是人间美味;饭后送的红豆沙也绝对比得起糖水铺的出品，服务态度又好，一家人吃饭就最 适合了。</p>
<p>推荐菜式：脆皮猪手，白灼牛肉，沙拉猪扒，德国咸猪手，葱油鸡，上汤苋菜，新味骨，姜酒鸡什煮鸡蛋，白切鸡，冰镇鳝片，丹青黄金条，叉烧，红烧乳鸽，水晶牛尾，煎面，红豆沙</p>
<p>人均消费：￥30-50</p>
<p>联系电话：020-83302789</p>
<p>详细地址：越秀区惠福东路417号(近教育路)</p>
<h3 id="u5411_u7FA4_u996D_u5E97_28_u9F99_u6D25_u8DEF_u603B_u5E97_29"><a href="#u5411_u7FA4_u996D_u5E97_28_u9F99_u6D25_u8DEF_u603B_u5E97_29" class="headerlink" title="向群饭店(龙津路总店)"></a>向群饭店(龙津路总店)</h3><p>推荐理由：向群的总店，出品很家常的住家菜式，而且价格普遍都非常实惠，位少人多，必需预先订位。推荐招牌豉油王葱油淋鸡，用料是“走地鸡”，皮爽脆，肉质嫩滑，味道很有家的感觉;其实要品尝有广州特色的粤菜，要在这些老字号的餐厅才算是正宗的。</p>
<p>推荐菜式：葱油淋鸡，酿炸面，捞肚尖，豉油皇鹅肠，肥叉鸡杂炒菜心，葱头鸡，煎鹅，果汁猪扒，酿油炸鬼，鲈鱼丁，让炸面，干炒牛河</p>
<p>人均消费：￥30-50</p>
<p>联系电话：020-81885146</p>
<p>详细地址：越秀区龙津东路853-857号</p>
<h3 id="u5229_u534E_u996D_u5E97"><a href="#u5229_u534E_u996D_u5E97" class="headerlink" title="利华饭店"></a>利华饭店</h3><p>推荐理由：老字号粤菜馆，出品地道的粤式风味，招牌陈皮骨、七彩捞蟮片、红葱头淋鸡、豉油鹅肠等，味道的确正宗，分量够大，价格又实惠，一家大小聚餐就最适合，老字号的环境与服务，自然就一般了，人多拥挤且嘈杂，但架不住出品的味道好，每天饭点都很多人排队等号;想一饱口福，又不太计较环境的，可以来试试。</p>
<p>推荐菜式：陈皮骨，红葱头鸡，鹅肠，七彩捞蟮片，冰浸鳝片，豉油皇鹅肠，茶叶虾，冰浸芥兰，羊肉煲，铁板烧汁鲈鱼，牛肉丸，捞起蟮片，咸蛋黄炒蟹，冬瓜盅。</p>
<p>人均消费：￥30-50</p>
<p>联系电话：020-83308399</p>
<p>详细地址：越秀区德政中路329号</p>
<h3 id="u5357_u56ED_u9152_u5BB6"><a href="#u5357_u56ED_u9152_u5BB6" class="headerlink" title="南园酒家"></a>南园酒家</h3><p>推荐理由：远近闻名的老字号餐厅，是广州四大园林酒家之一，环境气派，有种古色古香的岭南园林风格，以潮菜粤点而闻名;点心即点即蒸，味道正宗，尤其推荐虾饺;粤菜也做得精致，味道一流，价格合理，适合百姓人家常去，人非常多，去之前一定要先订位;也很适合宴请、婚宴等讲求排场的喜庆日子。</p>
<p>推荐菜式：佛跳墙，潮州烧雁鹅，潮州豆酱鸡，潮州扒大翅，护国菜，海南椰子盅，琼山豆腐，竹园椰奶鸡，三色马蹄糕，椰酱蛋角，生炸象生虾，虾饺，蛋挞，XO酱萝卜糕，顺德猪杂粥，奶皇包，流沙包，叉烧酥，拉肠，春卷，烧鹅</p>
<p>人均消费：￥50-100</p>
<p>联系电话：020-84448380</p>
<p>详细地址：海珠区前进路142号</p>
<h3 id="u9676_u9676_u5C45_u9152_u5BB6"><a href="#u9676_u9676_u5C45_u9152_u5BB6" class="headerlink" title="陶陶居酒家"></a>陶陶居酒家</h3><p>推荐理由：广州剩余为数不多的百年老字号，是广州市最著名最古老的大型酒家，创建于清光绪六年(1880年)，装修具广州风情，充满西关特色，是体验老广州生活的首选之地，也是外地人品尝地道广州美食的绝佳选择;出品的点心，可谓便宜实在，口味地道，还有各式粤式名菜，服务到位，人就非常多，所以经常看到有人等位。</p>
<p>推荐菜式：猪脑鱼羹、五彩鲜虾仁、姜葱炒肉蟹、西湖菊花鱼、手撕盐焗鸡、片皮挂炉鸭、云腿爽肚、雪里藏珍</p>
<p>人均消费：￥30-50</p>
<p>联系电话：020-81389632 020-81396111</p>
<p>详细地址：荔湾区第十甫路20号</p>
<h3 id="u53CB_u8054_u83DC_u9986"><a href="#u53CB_u8054_u83DC_u9986" class="headerlink" title="友联菜馆"></a>友联菜馆</h3><p>推荐理由：以吃清平鸡为特色的老字号粤菜。大排挡式，环境可以说非常的一般。鸡很不错， 也不贵，20多就半只，还是正宗的清平鸡，其他菜比如蒸肉丸都非常好吃，各类粤菜都很好，性价比超高!喜欢吃鸡的朋友不能错过，但喜欢环境舒服的，就不太合适了。原清平饭店以“友联菜馆”的名字从现江湖!饭店继续由原清平饭店“清平鸡”唯一传人及原清平饭店的大厨主理。经实践证明，主打的清平鸡果真是皮爽肉滑。</p>
<p>推荐菜式：清平鸡，猪手，鸡杂炒菜心，生炒骨，生炒菜心，葱茜捞肚尖，鱼肠煎蛋，桂花扎，道窖肉丸，钵仔鸡红。</p>
<p>人均消费：￥30-50</p>
<p>联系电话：020-81876751</p>
<p>详细地址：荔湾区杉木栏路163号</p>
<h2 id="u751C_u54C1"><a href="#u751C_u54C1" class="headerlink" title="甜品"></a>甜品</h2><h3 id="u73AB_u7470_u751C_u54C1_u5E97"><a href="#u73AB_u7470_u751C_u54C1_u5E97" class="headerlink" title="玫瑰甜品店"></a>玫瑰甜品店</h3><p>越秀区文明路218号(中山图书馆斜对面)  招牌芒果西米露，粒粒西米晶莹通透，好浓的芒果味；杏仁豆腐香甜爽滑，一个实在是爽啊</p>
<h3 id="GANSO"><a href="#GANSO" class="headerlink" title="GANSO"></a>GANSO</h3><p>彩虹桥店  电话：020-81369696  地址：荔湾区荔湾路100号新大新百货一楼</p>
<p>江燕店  电话：020-34368119  地址：海珠区江燕路245号</p>
<p>说实话我不喜欢吃太甜的东西，不过这个好可爱，38元6个，冰淇淋口味一个10元，店里还有其他日本点心，感觉嘛，有点小贵，喜欢倒是可以试一下</p>
<h3 id="u7F8E_u5229_u6743_u51B0_u5BA4"><a href="#u7F8E_u5229_u6743_u51B0_u5BA4" class="headerlink" title="美利权冰室"></a>美利权冰室</h3><p>越秀区北京路344号太平馆1楼  83197141  广州老字号的传统冰室，装修有点西餐厅的风格，出品的雪糕还保持着传统的手工做法，便宜又好吃;而特色的硬雪糕，在广州更几乎是独此一家！心水推荐：棉花雪糕，炸雪糕，椰子雪糕，焗雪山！</p>
<h3 id="u767E_u82B1_u751C_u54C1"><a href="#u767E_u82B1_u751C_u54C1" class="headerlink" title="百花甜品"></a>百花甜品</h3><p>广州越秀区文明路210号(近中山图书馆)</p>
<p>推荐美食：红豆沙、芝麻糊、凤凰奶糊等</p>
<h3 id="u5357_u4FE1"><a href="#u5357_u4FE1" class="headerlink" title="南信"></a>南信</h3><p>推荐美食：双皮奶、牛三星汤</p>
<h3 id="u987A_u8BB0_u51B0_u5BA4"><a href="#u987A_u8BB0_u51B0_u5BA4" class="headerlink" title="顺记冰室"></a>顺记冰室</h3><p>荔湾区宝华路85号</p>
<p>推荐美食：香芒雪糕</p>
<p>这是一个可以找到小时候感觉的冰室。浓浓的椰子雪糕，传统的配方，带着略粗野的口感，一样撩拨人的味蕾。芒果雪糕也不错，芒果肉很多，很香！</p>
<h3 id="u5F00_u8BB0_u7CD6_u6C34"><a href="#u5F00_u8BB0_u7CD6_u6C34" class="headerlink" title="开记糖水"></a>开记糖水</h3><p>荔湾区多宝路219号</p>
<p>推荐美食：绿豆沙、芝麻糊</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里记录一下网上比较出名的广州美食，非常适合『按图索骥』，口味比较个人化。</p>]]>
    
    </summary>
    
      <category term="广州" scheme="http://wdxtub.com/tags/%E5%B9%BF%E5%B7%9E/"/>
    
      <category term="美食" scheme="http://wdxtub.com/tags/%E7%BE%8E%E9%A3%9F/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简易 Shell 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/shell-guide/"/>
    <id>http://wdxtub.com/2016/03/24/shell-guide/</id>
    <published>2016-03-25T00:06:21.000Z</published>
    <updated>2016-03-25T00:07:50.000Z</updated>
    <content type="html"><![CDATA[<p>Shell 可以说是程序员最好的帮手了，这里简单记录一些常用的技巧，包括 shell 脚本与常用的命令。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u672C_u64CD_u4F5C"><a href="#u57FA_u672C_u64CD_u4F5C" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>脚本的第一行叫 shebang，用来告知系统如何执行该脚本 <code>#!/bin/bash</code></li>
<li>输出内容 <code>echo &quot;Hello world!&quot;</code></li>
<li>每一句指令用换行或分号隔开</li>
<li>声明一个变量(不能有空格) <code>VARIABLE=&quot;Some string&quot;</code></li>
<li>使用变量 <code>echo $VARIABLE</code>, <code>echo &quot;$VARIABLE&quot;</code>, <code>echo &#39;$VARIABLE&#39;</code></li>
<li>当赋值和 export 时，或者以其他方式使用变量时，变量名前不加 $</li>
<li>如果要使用变量的值，则要加 $</li>
<li>带你引号不会展开变量</li>
<li>在变量内部进行字符串替换 <code>echo ${VARIABLE/Some/A}</code> 会把 VARIABLE 中首次出现的 Some 替换成 A</li>
<li>内置变量 <code>$?</code>, <code>$$</code>, <code>$#</code>, <code>$@</code></li>
</ul>
<p>例子</p>
<pre><code>echo &quot;Last program return value: $?&quot;
echo &quot;Script&apos;s PID: $$&quot;
echo &quot;Number of arguments: $#&quot;
echo &quot;Scripts arguments: $@&quot;
echo &quot;Scripts arguments separated in different variables: $1 $2&quot;
</code></pre><ul>
<li>读取输入 <code>read NAME</code> 不需要声明新变量</li>
</ul>
<h2 id="u6761_u4EF6_u6D41_u7A0B"><a href="#u6761_u4EF6_u6D41_u7A0B" class="headerlink" title="条件流程"></a>条件流程</h2><p>通常的 IF</p>
<pre><code>if [ $NAME -ne $USER ]
then
    echo &quot;Your name is your username&quot;
else
    echo &quot;Your name isn&apos;t your username&quot;
fi
</code></pre><p>Bash 的 case 语句与 Java 和 C++ 中的 switch 语句类似:</p>
<pre><code>case &quot;$VARIABLE&quot; in
    # 列出需要匹配的字符串
    0) echo &quot;There is a zero.&quot;;;
    1) echo &quot;There is a one.&quot;;;
    *) echo &quot;It is not null.&quot;;;
esac
</code></pre><h2 id="u8868_u8FBE_u5F0F"><a href="#u8868_u8FBE_u5F0F" class="headerlink" title="表达式"></a>表达式</h2><ul>
<li>格式 <code>echo $(( 10 + 5 ))</code></li>
</ul>
<h2 id="u4E0A_u4E0B_u6587_u4F9D_u8D56"><a href="#u4E0A_u4E0B_u6587_u4F9D_u8D56" class="headerlink" title="上下文依赖"></a>上下文依赖</h2><ul>
<li>bash 运行时依赖上下文</li>
<li><code>ls</code> 列出当前目录</li>
<li><code>ls -l</code> 列出文件和目录的详细信息，指令可以带有选项</li>
<li>前一个指令的输出可以当做后一个指令的输入。<code>grep</code> 用来匹配字符串</li>
<li>用下面的指令列出当前目录下所有的 txt 文件 <code>ls -l | grep &quot;\.txt&quot;</code></li>
<li>重定向可以到输出，输入和错误输出。 &gt; 会覆盖已存在的文件，&gt;&gt; 会以累加的方式输出文件中</li>
</ul>
<p>例如</p>
<pre><code>python hello.py &lt; &quot;input.in&quot;
python hello.py &gt; &quot;output.out&quot;
python hellp.py &gt;&gt; &quot;error.err&quot;
</code></pre><ul>
<li>一个指令可用 <code>$()</code> 嵌套在另一个指令内部，如 <code>echo &quot;There are $(ls | wc -l) items here.&quot;</code></li>
</ul>
<h2 id="u5176_u4ED6"><a href="#u5176_u4ED6" class="headerlink" title="其他"></a>其他</h2><p>循环遍历给定的参数序列:变量$VARIABLE 的值会被打印 3 次。注意 ` ` 和 $( ) 等价。seq 返回长度为 3 的数组。</p>
<pre><code>for VARIABLE in `seq 3`
do
    echo &quot;$VARIABLE&quot;
done
</code></pre><p>你也可以使用函数，定义函数：</p>
<pre><code>function foo ()
{
    echo &quot;Arguments work just like script arguments: $@&quot;
    echo &quot;And: $1 $2...&quot;
    echo &quot;This is a function&quot;
    return 0
}
</code></pre><p>更简单的方法</p>
<pre><code>bar ()
{
    echo &quot;Another way to declare functions!&quot;
    return 0
}
</code></pre><p>调用函数</p>
<pre><code>foo &quot;My name is&quot; $NAME
</code></pre><p>有很多有用的指令需要学习:</p>
<pre><code>tail -n 10 file.txt
</code></pre><p>打印 file.txt 的最后 10 行</p>
<pre><code>head -n 10 file.txt
</code></pre><p>打印 file.txt 的前 10 行</p>
<pre><code>sort file.txt
</code></pre><p>将 file.txt 按行排序</p>
<pre><code>uniq -d file.txt
</code></pre><p>报告或忽略重复的行，用选项 -d 打印重复的行</p>
<pre><code>cut -d &apos;,&apos; -f 1 file.txt
</code></pre><p>打印每行中 ‘,’ 之前内容</p>
<h2 id="u57FA_u7840"><a href="#u57FA_u7840" class="headerlink" title="基础"></a>基础</h2><ul>
<li>学习 Bash 的基础知识。具体来说，输入 <code>man bash</code> 并至少全文浏览一遍; 它很简单并且不长。其他的 shell 可能很好用，但 Bash 功能强大且几乎所有情况下都是可用的 （ <em>只</em>学习 zsh，fish 或其他的 shell 的话，在你自己的电脑上会显得很方便，但在很多情况下会限制你，比如当你需要在服务器上工作时）。</li>
<li>学习并掌握至少一个基于文本的编辑器。通常 Vim （<code>vi</code>） 会是你最好的选择，因为在终端里进行随机编辑 Vim 真的毫无敌手，哪怕是 Emacs、某大型 IDE 甚至时下非常流行的编辑器。</li>
<li>学会如何使用 <code>man</code> 命令去阅读文档。学会使用 <code>apropos</code> 去查找文档。了解有些命令并不对应可执行文件，而是Bash内置的，可以使用 <code>help</code> 和 <code>help -d</code> 命令获取帮助信息。</li>
<li>学会使用 <code>&gt;</code> 和 <code>&lt;</code> 来重定向输出和输入，学会使用 <code>|</code> 来重定向管道。明白 <code>&gt;</code> 会覆盖了输出文件而 <code>&gt;&gt;</code> 是在文件未添加。了解标准输出 stdout 和标准错误 stderr。</li>
<li>学会使用通配符 <code>*</code> （或许再算上 <code>?</code> 和 <code>[</code>…<code>]</code>） 和引用以及引用中 <code>&#39;</code> 和 <code>&quot;</code> 的区别。</li>
<li>熟悉 Bash 任务管理工具：<code>&amp;</code>，<strong>ctrl-z</strong>，<strong>ctrl-c</strong>，<code>jobs</code>，<code>fg</code>，<code>bg</code>，<code>kill</code> 等。</li>
<li>了解 <code>ssh</code>，以及学会通过使用 <code>ssh-agent</code>，<code>ssh-add</code> 等命令来实现基本的无密码认证。</li>
<li>学会基本的文件管理：<code>ls</code> 和 <code>ls -l</code> （了解 <code>ls -l</code> 中每一列代表的意义），<code>less</code>，<code>head</code>，<code>tail</code> 和 <code>tail -f</code> （甚至 <code>less +F</code>），<code>ln</code> 和 <code>ln -s</code> （了解硬链接与软链接的区别），<code>chown</code>，<code>chmod</code>，<code>du</code> （硬盘使用情况概述：<code>du -hs *</code>）。 关于文件系统的管理，学习 <code>df</code>，<code>mount</code>，<code>fdisk</code>，<code>mkfs</code>，<code>lsblk</code>。知道 inode 是什么（与 <code>ls -i</code> 和 <code>df -i</code> 等命令相关）。</li>
<li>学习基本的网络管理：<code>ip</code> 或 <code>ifconfig</code>，<code>dig</code>。</li>
<li>熟悉正则表达式，以及 <code>grep</code>／<code>egrep</code> 里不同参数的作用，例如 <code>-i</code>，<code>-o</code>，<code>-v</code>，<code>-A</code>，<code>-B</code> 和 <code>-C</code>，这些参数是值得学习并掌握的。</li>
<li>学会使用 <code>apt-get</code>，<code>yum</code>，<code>dnf</code> 或 <code>pacman</code> （取决于你使用的 Linux 发行版）来查找或安装软件包。并确保你的环境中有 <code>pip</code> 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 <code>pip</code> 来安装会很方便）。</li>
</ul>
<h2 id="u65E5_u5E38_u4F7F_u7528"><a href="#u65E5_u5E38_u4F7F_u7528" class="headerlink" title="日常使用"></a>日常使用</h2><ul>
<li>在 Bash 中，可以使用 <strong>Tab</strong> 自动补全参数，使用 <strong>ctrl-r</strong> 搜索命令行历史（在按下之后，键入便可以搜索，重复按下 <strong>ctrl-r</strong> 会在更多匹配中循环，按下 <strong>Enter</strong> 会执行找到的命令，按下右方向键会将结果放入当前行中，使你可以进行编辑）。</li>
<li>在 Bash 中，可以使用 <strong>ctrl-w</strong> 删除你键入的最后一个单词，使用 <strong>ctrl-u</strong> 删除整行，使用 <strong>alt-b</strong> 和 <strong>alt-f</strong> 以单词为单位移动光标，使用 <strong>ctrl-a</strong> 将光标移至行首，使用 <strong>ctrl-e</strong> 将光标移至行尾，使用 <strong>ctrl-k</strong> 删除光标至行尾的所有内容，使用 <strong>ctrl-l</strong> 清屏。键入 <code>man readline</code> 查看 Bash 中的默认快捷键，内容很多。例如 <strong>alt-.</strong> 循环地移向前一个参数，以及 <strong>alt-*</strong> 展开通配符。</li>
<li>你喜欢的话，可以键入 <code>set -o vi</code> 来使用 vi 风格的快捷键，而 <code>set -o emacs</code> 可以把它改回来。</li>
<li>为了方便地键入长命令，在设置你的编辑器后（例如 <code>export EDITOR=vim</code>），键入 <strong>ctrl-x</strong> <strong>ctrl-e</strong> 会打开一个编辑器来编辑当前命令。在 vi 模式下则键入 <strong>escape-v</strong> 实现相同的功能。</li>
<li>键入 <code>history</code> 查看命令行历史记录。其中有许多缩写，例如 <code>!$</code>（最后键入的参数）和 <code>!!</code>（最后键入的命令），尽管通常被 <strong>ctrl-r</strong> 和 <strong>alt-.</strong> 取代。</li>
<li>回到上一个工作路径：<code>cd -</code></li>
<li>如果你输入命令的时候改变了主意，按下 <strong>alt-#</strong> 来在行首添加 <code>#</code>，或者依次按下 <strong>ctrl-a</strong>， <strong>#</strong>， <strong>enter</strong>。这样做的话，之后你可以很方便的利用命令行历史回到你刚才输入到一半的命令。</li>
<li><p>使用 <code>xargs</code> （ 或 <code>parallel</code>）。他们非常给力。注意到你可以控制每行参数个数（<code>-L</code>）和最大并行数（<code>-P</code>）。如果你不确定它们是否会按你想的那样工作，先使用 <code>xargs echo</code> 查看一下。此外，使用 <code>-I{}</code> 会很方便。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">'*.py'</span> | xargs grep some_<span class="keyword">function</span></span><br><span class="line">cat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>pstree -p</code> 有助于展示进程树。</p>
</li>
<li>使用 <code>pgrep</code> 和 <code>pkill</code> 根据名字查找进程或发送信号（<code>-f</code> 参数通常有用）。</li>
<li>了解你可以发往进程的信号的种类。比如，使用 <code>kill -STOP [pid]</code> 停止一个进程。使用 <code>man 7 signal</code> 查看详细列表。</li>
<li>使用 <code>nohup</code> 或 <code>disown</code> 使一个后台进程持续运行。</li>
<li>使用 <code>netstat -lntp</code> 或 <code>ss -plat</code> 检查哪些进程在监听端口（默认是检查 TCP 端口; 使用参数 <code>-u</code> 检查 UDP 端口）。</li>
<li>有关打开套接字和文件，请参阅 <code>lsof</code>。</li>
<li>使用 <code>uptime</code> 或 <code>w</code> 来查看系统已经运行多长时间。</li>
<li>使用 <code>alias</code> 来创建常用命令的快捷形式。例如：<code>alias ll=&#39;ls -latr&#39;</code> 使你可以方便地执行<code>ls -latr</code>命令。</li>
<li><p>在 Bash 脚本中，使用 <code>set -x</code> 去调试输出，尽可能的使用严格模式，使用 <code>set -e</code> 令脚本在发生错误时退出而不是继续运行，使用 <code>set -u</code> 来检查是否使用了未赋值的变量，使用 <code>set -o pipefail</code> 严谨地对待错误（尽管问题可能很微妙）。当牵扯到很多脚本时，使用 <code>trap</code>。一个好的习惯是在脚本文件开头这样写，这会使它检测一些错误，并在错误发生时中断程序并输出信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -euo pipefail</span><br><span class="line"><span class="built_in">trap</span> <span class="string">"echo 'error: Script failed: see failed command above'"</span> ERR</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Bash 脚本中，子 shell（使用括号 <code>(...)</code>）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># do something in current dir</span></span><br><span class="line">(<span class="built_in">cd</span> /some/other/dir &amp;&amp; other-command)</span><br><span class="line"><span class="comment"># continue in original dir</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Bash 中，要注意其中有许多形式的扩展。检查变量是否存在：<code>${name:?error message}</code>。例如，当 Bash 脚本需要一个参数时，可以使用这样的代码 <code>input_file=${1:?usage: $0 input_file}</code>。数学表达式：<code>i=$(( (i + 1) % 5 ))</code>。序列：<code>{1..10}</code>。截断字符串：<code>${var%suffix}</code> 和 <code>${var#prefix}</code>。例如，假设 <code>var=foo.pdf</code>，那么 <code>echo ${var%.pdf}.txt</code> 将输出 <code>foo.txt</code>。</p>
</li>
<li><p>使用括号扩展（<code>{</code>…<code>}</code>）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 <code>mv foo.{txt,pdf} some-dir</code>（同时移动两个文件），<code>cp somefile{,.bak}</code>（会被扩展成 <code>cp somefile somefile.bak</code>）或者 <code>mkdir -p test-{a,b,c}/subtest-{1,2,3}</code>（会被扩展成所有可能的组合，并创建一个目录树）。</p>
</li>
<li><p>通过使用 <code>&lt;(some command)</code> 可以将输出视为文件。例如，对比本地文件 <code>/etc/hosts</code> 和一个远程文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)</span><br></pre></td></tr></table></figure>
</li>
<li><p>了解 Bash 中的“here documents”，例如 <code>cat &lt;&lt;EOF ...</code>。</p>
</li>
<li><p>在 Bash 中，同时重定向标准输出和标准错误，<code>some-command &gt;logfile 2&gt;&amp;1</code>。通常，为了保证命令不会在标准输入里残留一个打开了的文件句柄导致你当前所在的终端无法操作，添加 <code>&lt;/dev/null</code> 是一个好习惯。</p>
</li>
<li><p>使用 <code>man ascii</code> 查看具有十六进制和十进制值的ASCII表。<code>man unicode</code>，<code>man utf-8</code>，以及 <code>man latin1</code> 有助于你去了解通用的编码信息。</p>
</li>
<li><p>使用 <code>screen</code> 或 <a href="https://tmux.github.io/" target="_blank" rel="external"><code>tmux</code></a> 来使用多个屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。另一个轻量级的解决方案是 <code>dtach</code>。</p>
</li>
<li><p>ssh 中，了解如何使用 <code>-L</code> 或 <code>-D</code>（偶尔需要用 <code>-R</code>）去开启隧道是非常有用的，例如当你需要从一台远程服务器上访问 web。</p>
</li>
<li><p>对 ssh 设置做一些小优化可能是很有用的，例如这个 <code>~/.ssh/config</code> 文件包含了防止特定环境下断开连接、压缩数据、多通道等选项：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TCPKeepAlive=<span class="literal">yes</span></span><br><span class="line">ServerAliveInterval=<span class="number">15</span></span><br><span class="line">ServerAliveCountMax=<span class="number">6</span></span><br><span class="line">Compression=<span class="literal">yes</span></span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath <span class="regexp">/tmp/</span>%r@%<span class="attribute">h</span>:%p</span><br><span class="line">ControlPersist <span class="literal">yes</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>部分其他的关于 ssh 的选项是安全敏感且应当小心启用的。例如在可信任的网络中：<code>StrictHostKeyChecking=no</code>，<code>ForwardAgent=yes</code></p>
</li>
<li><p>考虑使用 <a href="https://mosh.mit.edu/" target="_blank" rel="external"><code>mosh</code></a> 作为 ssh 的替代品，它使用 UDP 协议。</p>
</li>
<li><p>获取文件的八进制格式权限，使用类似如下的代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> -c <span class="string">'%A %a %n'</span> /etc/timezone</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <a href="https://github.com/mooz/percol" target="_blank" rel="external"><code>percol</code></a> 或者 <a href="https://github.com/junegunn/fzf" target="_blank" rel="external"><code>fzf</code></a> 可以交互式地从另一个命令输出中选取值。</p>
</li>
<li><p>使用 <code>fpp</code>（<a href="https://github.com/facebook/PathPicker" target="_blank" rel="external">PathPicker</a>）可以与基于另一个命令(例如 <code>git</code>）输出的文件交互。</p>
</li>
<li><p>将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：<br><code>python -m SimpleHTTPServer 7777</code> （使用端口 7777 和 Python 2）或<code>python -m http.server 7777</code> （使用端口 7777 和 Python 3）。</p>
</li>
<li><p>以某种权限执行命令，使用<code>sudo</code>（root 权限）或<code>sudo -u</code>（其他用户）。使用<code>su</code>或者<code>sudo bash</code>来启动一个以对应用户权限运行的 shell。使用<code>su -</code>模拟其他用户的登录。</p>
</li>
</ul>
<h2 id="u6587_u4EF6_u53CA_u6570_u636E_u5904_u7406"><a href="#u6587_u4EF6_u53CA_u6570_u636E_u5904_u7406" class="headerlink" title="文件及数据处理"></a>文件及数据处理</h2><ul>
<li><p>在当前路径下通过文件名定位一个文件，<code>find . -iname &#39;*something*&#39;</code>（或类似的）。在所有路径下通过文件名查找文件，使用 <code>locate something</code> （但请记住 <code>updatedb</code> 可能没有对最近新建的文件建立索引）。</p>
</li>
<li><p>使用 <a href="https://github.com/ggreer/the_silver_searcher" target="_blank" rel="external"><code>ag</code></a> 在源代码或数据文件里检索（比 <code>grep -r</code> 更好）。</p>
</li>
<li><p>将 HTML 转为文本：<code>lynx -dump -stdin</code></p>
</li>
<li><p>Markdown，HTML，以及所有文档格式之间的转换，试试 <a href="http://pandoc.org/" target="_blank" rel="external"><code>pandoc</code></a>。</p>
</li>
<li><p>如果你不得不处理 XML，<code>xmlstarlet</code> 宝刀未老。</p>
</li>
<li><p>使用 <a href="http://stedolan.github.io/jq/" target="_blank" rel="external"><code>jq</code></a> 处理 JSON。</p>
</li>
<li><p>使用 <a href="https://github.com/0k/shyaml" target="_blank" rel="external"><code>shyaml</code></a> 处理 YAML。</p>
</li>
<li><p>Excel 或 CSV 文件的处理，<a href="https://github.com/onyxfish/csvkit" target="_blank" rel="external">csvkit</a> 提供了 <code>in2csv</code>，<code>csvcut</code>，<code>csvjoin</code>，<code>csvgrep</code> 等工具。</p>
</li>
<li><p>关于 Amazon S3，<a href="https://github.com/s3tools/s3cmd" target="_blank" rel="external"><code>s3cmd</code></a> 很方便而 <a href="https://github.com/bloomreach/s4cmd" target="_blank" rel="external"><code>s4cmd</code></a> 更快。Amazon 官方的 <a href="https://github.com/aws/aws-cli" target="_blank" rel="external"><code>aws</code></a> 以及  <a href="https://github.com/donnemartin/saws" target="_blank" rel="external"><code>saws</code></a> 是其他 AWS 相关工作的基础。</p>
</li>
<li><p>了解如何使用 <code>sort</code> 和 <code>uniq</code>，包括 uniq 的 <code>-u</code> 参数和 <code>-d</code> 参数，详见后文单行脚本节。另外可以了解一下 <code>comm</code>。</p>
</li>
<li><p>了解如何使用 <code>cut</code>，<code>paste</code> 和 <code>join</code> 来更改文件。很多人都会使用 <code>cut</code>，但几乎都不会使用 <code>join</code>。</p>
</li>
<li><p>了解如何运用 <code>wc</code> 去计算新行数（<code>-l</code>），字符数（<code>-m</code>），单词数（<code>-w</code>）以及字节数（<code>-c</code>）。</p>
</li>
<li><p>了解如何使用 <code>tee</code> 将标准输入复制到文件甚至标准输出，例如 <code>ls -al | tee file.txt</code>。</p>
</li>
<li><p>了解语言环境对许多命令行工具的微妙影响，包括排序的顺序和性能。大多数 Linux 的安装过程会将 <code>LANG</code> 或其他有关的变量设置为符合本地的设置。意识到当你改变语言环境时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降<em>许多倍</em>。某些情况下（例如集合运算）你可以放心的使用 <code>export LC_ALL=C</code> 来忽略掉国际化并使用基于字节的顺序。</p>
</li>
<li><p>了解 <code>awk</code> 和 <code>sed</code> 关于数据的简单处理的用法。例如，将文本文件中第三列的所有数字求和：<code>awk &#39;{ x += $3 } END { print x }&#39;</code>. 这可能比同等作用的 Python 代码快三倍且代码量少三倍。</p>
</li>
<li><p>替换一个或多个文件中出现的字符串：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pi.bak <span class="operator">-e</span> <span class="string">'s/old-string/new-string/g'</span> my-files-*.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <a href="https://github.com/jlevy/repren" target="_blank" rel="external"><code>repren</code></a> 来批量重命名，或是在多个文件中搜索替换。（有些时候 <code>rename</code> 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Full rename of filenames, directories, and contents foo -&gt; bar:</span></span><br><span class="line">repren --full --preserve-case --from foo --to bar .</span><br><span class="line"><span class="comment"># Recover backup files whatever.bak -&gt; whatever:</span></span><br><span class="line">repren --renames --from <span class="string">'(.*)\.bak'</span> --to <span class="string">'\1'</span> *.bak</span><br><span class="line"><span class="comment"># Same as above, using rename, if available:</span></span><br><span class="line">rename <span class="string">'s/\.bak$//'</span> *.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据 man 页面的描述，<code>rsync</code> 真的是一个快速且非常灵活的文件复制工具。它通常被用于机器间的同步，但在本地也同样有用。它同时也是删除大量文件的<a href="https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html" target="_blank" rel="external">最快方法</a>之一：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>shuf</code> 从一个文件中随机选取多行。</p>
</li>
<li><p>了解 <code>sort</code> 的参数。处理数字方面，使用 <code>-n</code> 或者 <code>-h</code> 来处理可读性数字（例如 <code>du -h</code> 的输出）。明白键的工作原理（<code>-t</code> 和 <code>-k</code>）。例如，注意到你需要 <code>-k1，1</code> 来仅按第一个域来排序，而 <code>-k1</code> 意味着按整行排序。稳定排序（<code>sort -s</code>）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 <code>sort -k1，1 | sort -s -k2，2</code>。</p>
</li>
<li><p>如果你想在 Bash 命令行中写 tab 制表符，按下 <strong>ctrl-v</strong> <strong>[Tab]</strong> 或键入 <code>$&#39;\t&#39;</code> （后者可能更好，因为你可以复制粘贴它）。</p>
</li>
<li><p>标准的源代码对比及合并工具是 <code>diff</code> 和 <code>patch</code>。使用 <code>diffstat</code> 查看变更总览数据。注意到 <code>diff -r</code> 对整个文件夹有效。使用 <code>diff -r tree1 tree2 | diffstat</code> 查看变更总览数据。</p>
</li>
<li><p>对于二进制文件，使用 <code>hd</code> 使其以十六进制显示以及使用 <code>bvi</code> 来编辑二进制。</p>
</li>
<li><p>同样对于二进制文件，<code>strings</code>（包括 <code>grep</code> 等等）允许你查找一些文本。</p>
</li>
<li><p>二进制文件对比（Delta 压缩），使用 <code>xdelta3</code>。</p>
</li>
<li><p>使用 <code>iconv</code> 更改文本编码。而更高级的用法，可以使用 <code>uconv</code>，它支持一些高级的 Unicode 功能。例如，这条命令将所有元音字母转为小写并移除了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uconv <span class="operator">-f</span> utf-<span class="number">8</span> -t utf-<span class="number">8</span> -x <span class="string">'::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; '</span> &lt; input.txt &gt; output.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>拆分文件，查看 <code>split</code>（按大小拆分）和 <code>csplit</code>（按模式拆分）。</p>
</li>
<li><p>用 <a href="http://www.fresse.org/dateutils/" target="_blank" rel="external"><code>dateutils</code></a> 中的 <code>dateadd</code>, <code>datediff</code>, <code>strptime</code> 等工具操作日期和时间表达式。</p>
</li>
<li><p>使用 <code>zless</code>，<code>zmore</code>，<code>zcat</code> 和 <code>zgrep</code> 对压缩过的文件进行操作。</p>
</li>
</ul>
<h2 id="u7CFB_u7EDF_u8C03_u8BD5"><a href="#u7CFB_u7EDF_u8C03_u8BD5" class="headerlink" title="系统调试"></a>系统调试</h2><ul>
<li><p><code>curl</code> 和 <code>curl -I</code> 可以便捷地被应用于 web 调试中，它们的好兄弟 <code>wget</code> 也可以，或者是更潮的 <a href="https://github.com/jakubroztocil/httpie" target="_blank" rel="external"><code>httpie</code></a>。</p>
</li>
<li><p>使用 <code>iostat</code>、<code>netstat</code>、<code>top</code> （<code>htop</code> 更佳）和 <code>dstat</code> 去获取硬盘、cpu 和网络的状态。熟练掌握这些工具可以使你快速的对系统的当前状态有一个大概的认识。</p>
</li>
<li><p>使用 <code>netstat</code> 和 <code>ss</code> 查看网络连接的细节。</p>
</li>
<li><p>若要对系统有一个深度的总体认识，使用 <a href="https://github.com/nicolargo/glances" target="_blank" rel="external"><code>glances</code></a>。它在一个终端窗口中向你提供一些系统级的数据。这对于快速的检查各个子系统非常有帮助。</p>
</li>
<li><p>若要了解内存状态，运行并理解 <code>free</code> 和 <code>vmstat</code> 的输出。尤其注意“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，因此它与空闲内存无关。</p>
</li>
<li><p>Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 <code>kill -3 &lt;pid&gt;</code> 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准输出/日志文件。JDK 中的 <code>jps</code>，<code>jstat</code>，<code>jstack</code>，<code>jmap</code> 很有用。<a href="https://github.com/aragozin/jvm-tools" target="_blank" rel="external">SJK tools</a> 更高级.</p>
</li>
<li><p>使用 <code>mtr</code> 去跟踪路由，用于确定网络问题。</p>
</li>
<li><p>用 <code>ncdu</code> 来查看磁盘使用情况，它比常用的命令，如 <code>du -sh *</code>，更节省时间。</p>
</li>
<li><p>查找正在使用带宽的套接字连接或进程，使用 <code>iftop</code> 或 <code>nethogs</code>。</p>
</li>
<li><p><code>ab</code> 工具（捆绑于 Apache）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 <code>siege</code>。</p>
</li>
<li><p><code>wireshark</code>，<code>tshark</code> 和 <code>ngrep</code> 可用于复杂的网络调试。</p>
</li>
<li><p>了解 <code>strace</code> 和 <code>ltrace</code>。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（<code>-c</code>）和附加到一个运行的进程参数 （<code>-p</code>）。</p>
</li>
<li><p>了解使用 <code>ldd</code> 来检查共享库。</p>
</li>
<li><p>了解如何运用 <code>gdb</code> 连接到一个运行着的进程并获取它的堆栈轨迹。</p>
</li>
<li><p>学会使用 <code>/proc</code>。它在调试正在出现的问题的时候有时会效果惊人。比如：<code>/proc/cpuinfo</code>，<code>/proc/meminfo</code>，<code>/proc/cmdline</code>，<code>/proc/xxx/cwd</code>，<code>/proc/xxx/exe</code>，<code>/proc/xxx/fd/</code>，<code>/proc/xxx/smaps</code>（这里的 <code>xxx</code> 表示进程的 id 或 pid）。</p>
</li>
<li><p>当调试一些之前出现的问题的时候，<code>sar</code> 非常有用。它展示了 cpu、内存以及网络等的历史数据。</p>
</li>
<li><p>关于更深层次的系统分析以及性能分析，看看 <code>stap</code>（<a href="https://sourceware.org/systemtap/wiki" target="_blank" rel="external">SystemTap</a>），<a href="http://en.wikipedia.org/wiki/Perf_(Linux" target="_blank" rel="external"><code>perf</code></a>)，以及<a href="https://github.com/draios/sysdig" target="_blank" rel="external"><code>sysdig</code></a>。</p>
</li>
<li><p>查看你当前使用的系统，使用 <code>uname</code> ， <code>uname -a</code> （Unix／kernel 信息） 或者 <code>lsb_release -a</code> （Linux 发行版信息）。</p>
</li>
<li><p>无论什么东西工作得很欢乐时试试 <code>dmesg</code>（可能是硬件或驱动问题）。</p>
</li>
</ul>
<h2 id="u5355_u884C_u811A_u672C"><a href="#u5355_u884C_u811A_u672C" class="headerlink" title="单行脚本"></a>单行脚本</h2><p>一些命令组合的例子：</p>
<ul>
<li><p>当你需要对文本文件做集合交、并、差运算时，结合使用 <code>sort</code>/<code>uniq</code> 很有帮助。假设 <code>a</code> 与 <code>b</code> 是两内容不同的文件。这种方式效率很高，并且在小文件和上G的文件上都能运用 （<code>sort</code> 不被内存大小约束，尽管在 <code>/tmp</code> 在一个小的根分区上时你可能需要 <code>-T</code> 参数），参阅前文中关于 <code>LC_ALL</code> 和 <code>sort</code> 的 <code>-u</code> 参数的部分。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat a b | sort | uniq &gt; c   <span class="comment"># c is a union b</span></span><br><span class="line">cat a b | sort | uniq <span class="operator">-d</span> &gt; c   <span class="comment"># c is a intersect b</span></span><br><span class="line">cat a b b | sort | uniq -u &gt; c   <span class="comment"># c is set difference a - b</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>grep . *</code>（每行都会附上文件名）或者 <code>head -100 *</code>（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 <code>/sys</code>、<code>/proc</code>、<code>/etc</code>）时特别好用。</p>
</li>
<li><p>计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123; x += $3 &#125; END &#123; print x &#125;'</span> myfile</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你想在文件树上查看大小/日期，这可能看起来像递归版的 <code>ls -l</code> 但比 <code>ls -lR</code> 更易于理解：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -ls</span><br></pre></td></tr></table></figure>
</li>
<li><p>假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 <code>acct_id</code> 参数在URI中。如果你想计算出每个 <code>acct_id</code> 值有多少次请求，使用如下代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | egrep -o <span class="string">'acct_id=[0-9]+'</span> | cut <span class="operator">-d</span>= <span class="operator">-f</span>2 | sort | uniq -c | sort -rn</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">taocl</span></span>() &#123;</span><br><span class="line">  curl <span class="operator">-s</span> https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |</span><br><span class="line">    pandoc <span class="operator">-f</span> markdown -t html |</span><br><span class="line">    xmlstarlet fo --html --dropdtd |</span><br><span class="line">    xmlstarlet sel -t -v <span class="string">"(html/body/ul/li[count(p)&gt;0])[<span class="variable">$RANDOM</span> mod last()+1]"</span> |</span><br><span class="line">    xmlstarlet unesc | fmt -<span class="number">80</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="u51B7_u95E8_u4F46_u6709_u7528"><a href="#u51B7_u95E8_u4F46_u6709_u7528" class="headerlink" title="冷门但有用"></a>冷门但有用</h2><ul>
<li><p><code>expr</code>：计算表达式或正则匹配</p>
</li>
<li><p><code>m4</code>：简单地宏处理器</p>
</li>
<li><p><code>yes</code>：多次打印字符串</p>
</li>
<li><p><code>cal</code>：漂亮的日历</p>
</li>
<li><p><code>env</code>：执行一个命令（脚本文件中很有用）</p>
</li>
<li><p><code>printenv</code>：打印环境变量（调试时或在使用脚本文件时很有用）</p>
</li>
<li><p><code>look</code>：查找以特定字符串开头的单词</p>
</li>
<li><p><code>cut</code>、<code>paste</code> 和 <code>join</code>：数据修改</p>
</li>
<li><p><code>fmt</code>：格式化文本段落</p>
</li>
<li><p><code>pr</code>：将文本格式化成页/列形式</p>
</li>
<li><p><code>fold</code>：包裹文本中的几行</p>
</li>
<li><p><code>column</code>：将文本格式化成多列或表格</p>
</li>
<li><p><code>expand</code> 和 <code>unexpand</code>：制表符与空格之间转换</p>
</li>
<li><p><code>nl</code>：添加行号</p>
</li>
<li><p><code>seq</code>：打印数字</p>
</li>
<li><p><code>bc</code>：计算器</p>
</li>
<li><p><code>factor</code>：分解因数</p>
</li>
<li><p><a href="https://gnupg.org/" target="_blank" rel="external"><code>gpg</code></a>：加密并签名文件</p>
</li>
<li><p><code>toe</code>：terminfo entries 列表</p>
</li>
<li><p><code>nc</code>：网络调试及数据传输</p>
</li>
<li><p><code>socat</code>：套接字代理，与 <code>netcat</code> 类似</p>
</li>
<li><p><a href="https://github.com/mattthias/slurm" target="_blank" rel="external"><code>slurm</code></a>：网络可视化</p>
</li>
<li><p><code>dd</code>：文件或设备间传输数据</p>
</li>
<li><p><code>file</code>：确定文件类型</p>
</li>
<li><p><code>tree</code>：以树的形式显示路径和文件，类似于递归的 <code>ls</code></p>
</li>
<li><p><code>stat</code>：文件信息</p>
</li>
<li><p><code>time</code>：执行命令，并计算执行时间</p>
</li>
<li><p><code>lockfile</code>：使文件只能通过 <code>rm -f</code> 移除</p>
</li>
<li><p><code>logrotate</code>: 切换、压缩以及发送日志文件</p>
</li>
<li><p><code>watch</code>：重复运行同一个命令，展示结果并高亮有更改的部分</p>
</li>
<li><p><code>tac</code>：反向输出文件</p>
</li>
<li><p><code>shuf</code>：文件中随机选取几行</p>
</li>
<li><p><code>comm</code>：一行一行的比较排序过的文件</p>
</li>
<li><p><code>pv</code>：监视通过管道的数据</p>
</li>
<li><p><code>hd</code>，<code>hexdump</code>，<code>xxd</code>，<code>biew</code> 和 <code>bvi</code>：保存或编辑二进制文件</p>
</li>
<li><p><code>strings</code>：从二进制文件中抽取文本</p>
</li>
<li><p><code>tr</code>：转换字母</p>
</li>
<li><p><code>iconv</code> 或 <code>uconv</code>：简易的文件编码</p>
</li>
<li><p><code>split</code> 和 <code>csplit</code>：分割文件</p>
</li>
<li><p><code>sponge</code>：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 <code>grep -v something some-file | sponge some-file</code></p>
</li>
<li><p><code>units</code>：将一种计量单位转换为另一种等效的计量单位（参阅 <code>/usr/share/units/definitions.units</code>）</p>
</li>
<li><p><code>apg</code>：随机生成密码</p>
</li>
<li><p><code>7z</code>：高比例的文件压缩</p>
</li>
<li><p><code>ldd</code>：动态库信息</p>
</li>
<li><p><code>nm</code>：提取 obj 文件中的符号</p>
</li>
<li><p><code>ab</code>：性能分析 web 服务器</p>
</li>
<li><p><code>strace</code>：系统调用调试</p>
</li>
<li><p><code>mtr</code>：更好的网络调试跟踪工具</p>
</li>
<li><p><code>cssh</code>：可视化的并发 shell</p>
</li>
<li><p><code>rsync</code>：通过 ssh 或本地文件系统同步文件和文件夹</p>
</li>
<li><p><code>wireshark</code> 和 <code>tshark</code>：抓包和网络调试工具</p>
</li>
<li><p><code>ngrep</code>：网络层的 grep</p>
</li>
<li><p><code>host</code> 和 <code>dig</code>：DNS 查找</p>
</li>
<li><p><code>lsof</code>：列出当前系统打开文件的工具以及查看端口信息</p>
</li>
<li><p><code>dstat</code>：系统状态查看</p>
</li>
<li><p><a href="https://github.com/nicolargo/glances" target="_blank" rel="external"><code>glances</code></a>：高层次的多子系统总览</p>
</li>
<li><p><code>iostat</code>：硬盘使用状态</p>
</li>
<li><p><code>mpstat</code>: CPU 使用状态</p>
</li>
<li><p><code>vmstat</code>: 内存使用状态</p>
</li>
<li><p><code>htop</code>：top 的加强版</p>
</li>
<li><p><code>last</code>：登入记录</p>
</li>
<li><p><code>w</code>：查看处于登录状态的用户</p>
</li>
<li><p><code>id</code>：用户/组 ID 信息</p>
</li>
<li><p><code>sar</code>：系统历史数据</p>
</li>
<li><p><code>iftop</code> 或 <code>nethogs</code>：套接字及进程的网络利用</p>
</li>
<li><p><code>ss</code>：套接字数据</p>
</li>
<li><p><code>dmesg</code>：引导及系统错误信息</p>
</li>
<li><p><code>sysctl</code>: 在内核运行时动态地查看和修改内核的运行参数</p>
</li>
<li><p><code>hdparm</code>：SATA/ATA 磁盘更改及性能分析</p>
</li>
<li><p><code>lsb_release</code>：Linux 发行版信息</p>
</li>
<li><p><code>lsblk</code>：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息</p>
</li>
<li><p><code>lshw</code>，<code>lscpu</code>，<code>lspci</code>，<code>lsusb</code> 和 <code>dmidecode</code>：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等</p>
</li>
<li><p><code>lsmod</code> 和 <code>modinfo</code>：列出内核模块，并显示其细节</p>
</li>
<li><p><code>fortune</code>，<code>ddate</code> 和 <code>sl</code>：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用”</p>
</li>
</ul>
<h2 id="u4EC5_u9650_MacOS_X__u7CFB_u7EDF"><a href="#u4EC5_u9650_MacOS_X__u7CFB_u7EDF" class="headerlink" title="仅限 MacOS X 系统"></a>仅限 MacOS X 系统</h2><p>以下是<em>仅限于</em> MacOS 系统的技巧</p>
<ul>
<li><p>用 <code>brew</code> （Homebrew）或者 <code>port</code> （MacPorts）进行包管理。这些可以用来在 Mac 系统上安装以上的大多数命令。</p>
</li>
<li><p>用 <code>pbcopy</code> 复制任何命令的输出到桌面应用，用 <code>pbpaste</code> 粘贴输入。</p>
</li>
<li><p>若要在 Mac OS 终端中将 Option 键视为 alt 键（例如在上面介绍的 <strong>alt-b</strong>, <strong>alt-f</strong> 等命令中用到），打开 偏好设置 -&gt; 描述文件 -&gt; 键盘 并勾选“使用 Option 键作为 Meta 键”。</p>
</li>
<li><p>用 <code>open</code> 或者 <code>open -a /Applications/Whatever.app</code> 使用桌面应用打开文件。</p>
</li>
<li><p>Spotlight： 用 <code>mdfind</code> 搜索文件，用 <code>mdls</code> 列出元数据（例如照片的 EXIF 信息）。</p>
</li>
<li><p>注意 MacOS 系统是基于 BSD UNIX 的，许多命令（例如 <code>ps</code>，<code>ls</code>，<code>tail</code>，<code>awk</code>，<code>sed</code>）都和 Linux 中有些微的不同，这些极大的被 System V-style Unix 和 GNU 工具影响。你可以通过标题为 “BSD General Commands Manual” 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 <code>gawk</code> 和 <code>gsed</code> 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 <code>perl</code> ）或者经过仔细的测试。</p>
</li>
<li><p>用 <code>sw_vers</code> 获取 MacOS 的版本信息。</p>
</li>
</ul>
<h2 id="u66F4_u591A_u8D44_u6E90"><a href="#u66F4_u591A_u8D44_u6E90" class="headerlink" title="更多资源"></a>更多资源</h2><ul>
<li><a href="https://github.com/alebcay/awesome-shell" target="_blank" rel="external">awesome-shell</a>：一份精心组织的命令行工具及资源的列表。</li>
<li><a href="https://github.com/herrbischoff/awesome-osx-command-line" target="_blank" rel="external">awesome-osx-command-line</a>：一份针对 Mac OS 命令行的更深入的指南。</li>
<li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/" target="_blank" rel="external">Strict mode</a>：为了编写更好的脚本文件。</li>
<li><a href="https://github.com/koalaman/shellcheck" target="_blank" rel="external">shellcheck</a>：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。</li>
<li><a href="http://www.dwheeler.com/essays/filenames-in-shell.html" target="_blank" rel="external">Filenames and Pathnames in Shell</a>：有关如何在 shell 脚本里正确处理文件名的细枝末节。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Shell 可以说是程序员最好的帮手了，这里简单记录一些常用的技巧，包括 shell 脚本与常用的命令。</p>]]>
    
    </summary>
    
      <category term="命令行" scheme="http://wdxtub.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="技巧" scheme="http://wdxtub.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SVN 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/svn-guide/"/>
    <id>http://wdxtub.com/2016/03/24/svn-guide/</id>
    <published>2016-03-24T20:34:47.000Z</published>
    <updated>2016-03-24T20:35:18.000Z</updated>
    <content type="html"><![CDATA[<p>国内不少云平台都只支持 SVN，所以还是需要了解基本的操作的。和 Git 的思路不大一样，SVN 等于是总-分结构，虽然可能不如 git 灵活，但是还是比较方便的。</p>
<a id="more"></a>
<hr>
<h2 id="u64CD_u4F5C_u6D41_u7A0B"><a href="#u64CD_u4F5C_u6D41_u7A0B" class="headerlink" title="操作流程"></a>操作流程</h2><p>常见的操作如下：</p>
<ul>
<li>checkout（检出）项目</li>
<li>增加文件或目录 — add(增加)，commit(提交)</li>
<li>修改文件或目录 — commit(提交)</li>
<li>删除文件或目录 — commit(提交)</li>
<li>更新文件或目录 — update(更新)</li>
</ul>
<p>其中，checkout只进行一次，以后使用update更新即可。update、commit、add操作根据需要会经常使用。</p>
<p>简单来说可以这样理解：</p>
<ul>
<li>项目中增加了文件或目录，需要先通知服务器要增加，所以首先要 add</li>
<li>然后如果要让服务器知道这些变动，就 commit，具体参加下面的命令</li>
<li>如果要从服务器获取最新的代码，就 update</li>
</ul>
<p>首先checkout出$appname的svn仓库。</p>
<pre><code>$ svn checkout https://svn.sinacloud.com/$appname
</code></pre><p>进入代码目录，创建一个新的子目录 <code>1</code> 作为版本1的代码目录。</p>
<pre><code>$ mkdir 1
</code></pre><p>进入版本1的代码目录，编辑代码并版本1的代码部署到线上。</p>
<pre><code>$ svn add .
$ svn commit -m &quot;make it better&quot;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>国内不少云平台都只支持 SVN，所以还是需要了解基本的操作的。和 Git 的思路不大一样，SVN 等于是总-分结构，虽然可能不如 git 灵活，但是还是比较方便的。</p>]]>
    
    </summary>
    
      <category term="版本控制" scheme="http://wdxtub.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim 基本操作]]></title>
    <link href="http://wdxtub.com/2016/03/24/vim-basic-op/"/>
    <id>http://wdxtub.com/2016/03/24/vim-basic-op/</id>
    <published>2016-03-24T20:23:06.000Z</published>
    <updated>2016-03-24T20:31:14.000Z</updated>
    <content type="html"><![CDATA[<p>虽然我还是喜欢图形化界面编辑器，但是有的时候登录到远程机器，不得不使用 vim 来编辑文件，这里记录下基本的操作。</p>
<a id="more"></a>
<hr>
<ul>
<li><code>i</code> 进入 Insert 模式</li>
<li><code>x</code> 删除当前光标所在的字符</li>
<li><code>:w</code> 存盘(后面可以跟文件名) </li>
<li><code>:q</code> 退出</li>
<li><code>:wq</code> 存盘并退出</li>
<li><code>dd</code> 删除当前行，并存到剪贴板里</li>
<li><code>p</code> 粘贴剪贴板</li>
<li><code>:help &lt;command&gt;</code> 要 :q 退出帮助</li>
</ul>
<p>如何浏览帮助呢？请牢记如下秘籍：</p>
<ul>
<li>移动: 使用光标键，或者用 h 向左，j 向下，k 向上，l 向右。</li>
<li>退出: 使用 :q<enter>。</enter></li>
<li>跳转到一个主题: 将光标置于标签 (例如 usr_01.txt) 上然后输入 CTRL-]。</li>
<li>跳回: 键入 CTRL-T。</li>
<li>翻页：键入 CTRL-F/B</li>
</ul>
<h2 id="u63D2_u5165_u6A21_u5F0F"><a href="#u63D2_u5165_u6A21_u5F0F" class="headerlink" title="插入模式"></a>插入模式</h2><ul>
<li><code>a</code> 在光标后插入</li>
<li><code>o</code> 在当前行后插入一个新行</li>
<li><code>O</code> 在当前行前插入一个新行</li>
<li><code>cw</code> 替换从光标所在位置后到一个单词结尾的字符</li>
</ul>
<h2 id="u79FB_u52A8_u5149_u6807"><a href="#u79FB_u52A8_u5149_u6807" class="headerlink" title="移动光标"></a>移动光标</h2><ul>
<li><code>0</code> 数字零，到行头</li>
<li><code>^</code> 到本行第一个不是blank字符的位置</li>
<li><code>$</code> 到本行行尾</li>
<li><code>g_</code> 到本行最后一个不是blank字符的位置。</li>
<li><code>/pattern</code> 搜索 pattern 的字符串(按n到下一个)</li>
<li><code>w b</code> 词移动</li>
</ul>
<h2 id="u62F7_u8D1D/_u7C98_u8D34"><a href="#u62F7_u8D1D/_u7C98_u8D34" class="headerlink" title="拷贝/粘贴"></a>拷贝/粘贴</h2><ul>
<li><code>p</code> 在当前位置之后粘贴</li>
<li><code>P</code> 在当前位置之前粘贴</li>
<li><code>yy</code> 拷贝当前行，相当于 ddP</li>
</ul>
<h2 id="u64A4_u9500/_u91CD_u505A"><a href="#u64A4_u9500/_u91CD_u505A" class="headerlink" title="撤销/重做"></a>撤销/重做</h2><ul>
<li><code>u</code> undo</li>
<li><code>&lt;C-r&gt;</code> redo</li>
</ul>
<h2 id="u6253_u5F00/_u4FDD_u5B58/_u9000_u51FA/_u6539_u53D8_u6587_u4EF6_28Buffer_29"><a href="#u6253_u5F00/_u4FDD_u5B58/_u9000_u51FA/_u6539_u53D8_u6587_u4EF6_28Buffer_29" class="headerlink" title="打开/保存/退出/改变文件(Buffer)"></a>打开/保存/退出/改变文件(Buffer)</h2><ul>
<li><code>:e &lt;path/to/file&gt;</code> 打开一个文件</li>
<li><code>:w</code> 存盘</li>
<li><code>:saveas &lt;path/to/file&gt;</code> 另存为 <code>&lt;path/to/file&gt;</code></li>
<li><code>:x</code>, <code>ZZ</code> 或 <code>:wq</code> 保存并退出</li>
<li><code>:q!</code> 退出不保存 </li>
<li><code>:qa!</code> 强行退出所有文件。</li>
<li><code>:bn</code> 和 <code>:bp</code> 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。</li>
</ul>
<h2 id="u6280_u5DE7"><a href="#u6280_u5DE7" class="headerlink" title="技巧"></a>技巧</h2><ol>
<li>打开 Vim之后，可以用 <code>:split filename</code>或 <code>:vsplit filename</code> 或 <code>new filename</code> 横向或纵向切割窗口，使用 <code>ctrl + w</code> 可以在个窗口之间跳转，使用 <code>ctrl + 方向键</code> 可以按照方向切换窗口。</li>
<li>用 Vim 打开一个文件，如果我们想实现所有文本行翻转，那么可以执行如下命令：<code>:g/^/m 0</code></li>
<li>在 Vim 中统计文本行数和当前光标的位置，可以使用 <code>ctrl + g</code>，统计字节数，可以使用 <code>g + ctrl + g</code></li>
<li>对文本进行简单排序：用 <code>shift v</code> 选中多行文本，输入 <code>:!sort</code>，看看效果如何</li>
<li>如果你想把当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么依次执行如下命令： 在当前目录下执行：</li>
</ol>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim</span><br><span class="line">:n <span class="keyword">*</span><span class="keyword">*</span>/<span class="keyword">*</span>.java</span><br><span class="line">:argdo %s/apache/eclipse/ge |<span class="string"> update</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然我还是喜欢图形化界面编辑器，但是有的时候登录到远程机器，不得不使用 vim 来编辑文件，这里记录下基本的操作。</p>]]>
    
    </summary>
    
      <category term="编辑器" scheme="http://wdxtub.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gradle 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/gradle-guide/"/>
    <id>http://wdxtub.com/2016/03/24/gradle-guide/</id>
    <published>2016-03-24T20:14:58.000Z</published>
    <updated>2016-03-24T20:18:40.000Z</updated>
    <content type="html"><![CDATA[<p>Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。它提供灵活的通用构建工具，就像ant。同时完美兼容Maven或Ivy仓库</p>
<a id="more"></a>
<hr>
<p>Gradle的特点：</p>
<ul>
<li>一个像Ant一样非常灵活的通用构建工具</li>
<li>一种可切换的，像Maven一样基于约定的构建框架，约定优于配置</li>
<li>强大的对于多工程构建的支持</li>
<li>完全支持现有的Maven和lvy仓库</li>
<li>支持传递性依赖管理，而不需要远程仓库或者是pom.xml和ivy.xml文件</li>
<li>非常适合构建Ant tasks和build</li>
<li>支持Groovy构建脚本</li>
<li>非常丰富的域模型来描述你的构建</li>
</ul>
<p>2009年7月20日发行第一个版本0.7，到现在已经发行了20个大版本，目前最新版本是2.3。从2.0版本开始，Gradle提供了C和C++的支持，使得Gradle的构建、测试和提交工作不仅限于基于JVM的系统。</p>
<p>从2012年6月发布1.0以来，Gradle一直以八周一个新版本的速率稳步升级，从1.0到2.0，Gradle也逐渐成熟。现在越来越多的Java开发者开始使用Gradle进行项目的自动化构建 </p>
<h2 id="u5B89_u88C5Gradle"><a href="#u5B89_u88C5Gradle" class="headerlink" title="安装Gradle"></a>安装Gradle</h2><p>安装一个 Java JDK 或者 JRE. 而且 Java 版本必须至少是 6 以上<br>从 Gradle网站<a href="http://www.gradle.org/downloads下载任意一个已经发布的版本，并解压到任意目录" target="_blank" rel="external">http://www.gradle.org/downloads下载任意一个已经发布的版本，并解压到任意目录</a></p>
<p>添加一个 GRADLE_HOME 环境变量来指明 Gradle 的安装路径<br>添加 GRADLE_HOME/bin 到您的 PATH 环境变量中</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux:</span><br><span class="line">export GRADLE_HOME=&#123;your gradle path&#125;</span><br><span class="line">export PATH=<span class="variable">$PATH</span>:GRADLE_HOME/bin</span><br></pre></td></tr></table></figure>
<h2 id="Gradle_u7684_u57FA_u672C_u7EC4_u6210"><a href="#Gradle_u7684_u57FA_u672C_u7EC4_u6210" class="headerlink" title="Gradle的基本组成"></a>Gradle的基本组成</h2><p>项目(Project) 和 任务(tasks)，Gradle 里的任何东西都是基于这两个基础概念。</p>
<ul>
<li>项目是指我们的构建产物（比如Jar包）或实施产物（将应用程序部署到生产环境）。</li>
<li>任务是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）。</li>
<li>每一个构建都是由一个或多个 projects 构成的，每一个 project 是由一个或多个 tasks 构成的，一个 task是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）</li>
</ul>
<p><img src="/images/14588506801339.jpg" alt=""></p>
<p>一个工程的Build，是由多个Project组成，而一个Project又是由task组成的</p>
<h2 id="Gradle_u6784_u5EFA_u7CFB_u7EDF_u7684_u7EC4_u6210"><a href="#Gradle_u6784_u5EFA_u7CFB_u7EDF_u7684_u7EC4_u6210" class="headerlink" title="Gradle构建系统的组成"></a>Gradle构建系统的组成</h2><p>任何一个构建系统都是由多个构建文件组成，如Ant是由build.xml组成，Maven是由pom.xml组成，Make是由makefile组成。这些构建脚本定义了一系列的规则来指定项目编译流程。</p>
<p>Gradle的构建系统是由以下几个文件组成</p>
<ul>
<li>build.gradle 我们称这个文件为一个构建脚本，这个脚本定义了一个模块和编译用的tasks，它一般是放在项目的模块中，也可以放在项目的根目录用来作为编译结构全局设置，它是必须的</li>
<li>settings.gradle 它描述了哪一个模块需要参与构建。每一个多模块的构建都必须在项目结构的根目录中加入这个设置文件，它也是必须的</li>
<li>gradle.properties 用来配置构建属性，这个不是必须的</li>
</ul>
<p>settings.gradle和gradle.properties的用法都十分简单，这里就不再多加说明，后面会给出示例，看示例就能明白其用法，现在主要对build.gradle的进行说明。</p>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>Gradle是基于Groovy语言的构建系统（这里并不会详细解释Groovy语法的使用，有需要请参考Groovy的官方文档 — <a href="http://groovy-lang.org/single-page-documentation.html" target="_blank" rel="external">Groovy语法</a>），所以在构建脚本中可以使用Groovy语言来执行一些任务。</p>
<p>下面编写一个简单的build.gradle文件，定义一个task来打印hello world，如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> hello &#123; <span class="comment">//先定义一个hello的task</span></span><br><span class="line">    <span class="keyword">doLast</span> &#123; <span class="comment">//实现doLast方法</span></span><br><span class="line">        <span class="keyword">println</span> <span class="string">'Hello world!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在终端中运行gradle hello命令来执行这个task,就会看到以下输入内容：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">gradle</span> <span class="tag">hello</span></span><br><span class="line"><span class="pseudo">:hello</span></span><br><span class="line"><span class="tag">Hello</span> <span class="tag">world</span>!</span><br></pre></td></tr></table></figure>
<p>对于hello这个task，还可以使用更简单的定义方式，如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> hello &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello world!'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;&lt;</code> 就等价于 doLast，doLast 是gradle提供访问task任务的一个API，类似的还有 doFirst，当一个task被执行的时候，可以通过 doFirst 和 doLast 向task中动态添加操作。doFirst 和 doLast 会在task本身被执行之后才会被执行。例如：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> hello &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Earth'</span></span><br><span class="line">&#125;</span><br><span class="line">hello.<span class="keyword">doFirst</span> &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Venus'</span></span><br><span class="line">&#125;</span><br><span class="line">hello.<span class="keyword">doFirst</span> &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Mercury'</span></span><br><span class="line">&#125;</span><br><span class="line">hello.<span class="keyword">doLast</span> &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Mars'</span></span><br><span class="line">&#125;</span><br><span class="line">hello &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Jupiter'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入如下所示：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">Hello</span> Earth</span><br><span class="line">:hello</span><br><span class="line"><span class="label">Hello</span> Mercury</span><br><span class="line"><span class="label">Hello</span> Venus</span><br><span class="line"><span class="label">Hello</span> <span class="keyword">Mars</span><br><span class="line"></span><span class="label">Hello</span> Jupiter</span><br></pre></td></tr></table></figure>
<h2 id="Task_u4F9D_u8D56"><a href="#Task_u4F9D_u8D56" class="headerlink" title="Task依赖"></a>Task依赖</h2><p>上面示例展示了如何编写一个hello world的task，在Gradle中各个task并不是孤立的，它们可以是相互依赖的。要让一个task依赖另外一个task，只需要在task定义时加入 dependsOn: 说明即可，被依赖的task会优先依赖者被执行，例如：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> hello &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello world!'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">task</span> intro(dependsOn: hello) &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">"I'm Gradle"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行gradle intro命令后可以看到以下输出：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="blockquote">&gt; gradle intro</span></span><br><span class="line">Hello world!</span><br><span class="line">I'm Gradle</span><br></pre></td></tr></table></figure>
<h2 id="Gradle_u63D2_u4EF6"><a href="#Gradle_u63D2_u4EF6" class="headerlink" title="Gradle插件"></a>Gradle插件</h2><p>Gradle的设计理念是，所有有用的特性都由Gradle插件提供，例如编写一个Java项目时，需要使用到 Java 插件， 它会将许多任务自动的加入到你项目里。Gradle本身提供了一系列的标准插件，无需多余配置只需要在你的build.gradle文件中加入 <code>apply plugin: &#39;java&#39;</code></p>
<p>这样就可以引入许多task，只需要使用相应的task命令就可以进行项目构建。例如下列一些task:</p>
<ul>
<li>gradle build：编译整个项目，它会执行代码编译、代码检测和单元测试等</li>
<li>gradle assemble：编译并打包你的代码, 但是并不运行代码检测和单元测试</li>
<li>gradle clean：删除 build 生成的目录和所有生成的文件</li>
<li>gradle check：编译并测试你的代码。其它的插件会加入更多的检查步骤，如使用 checkstyle、pmd、findbugs</li>
</ul>
<p>Gradle各个task的关系图：</p>
<p><img src="/images/14588507104558.jpg" alt=""></p>
<p>从上图可以看出，我们通常在执行一个build命令时其实是将一些零散的命令批量执行了，我们也可以根据自己的需求执行其中某一个命令。</p>
<h2 id="u5916_u90E8_u4F9D_u8D56"><a href="#u5916_u90E8_u4F9D_u8D56" class="headerlink" title="外部依赖"></a>外部依赖</h2><p>通常, 一个 Java 项目将有许多外部的依赖, 既指向外部的 JAR 文件. 为了在项目里引用这些 JAR 文件, 你需要告诉 Gradle 去哪里找它们. 在 Gradle 中, JAR 文件位于一个仓库中，这里的仓库类似于 maven 的仓库。</p>
<p>首先，指定maven的仓库地址：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mavenCentral() 是Gradle内置的一个maven仓库地址，加入maven仓库后，就可以直接加入maven仓库中的外部依赖，如果这个外部依赖不存在，gradle会联网去maven仓库中自动下载它，并将它缓存到本地，下次再使用时会优先从本地缓存中查找该依赖。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">group</span>: <span class="string">'commons-collections'</span>, name: <span class="string">'commons-collections'</span>, version: <span class="string">'3.2'</span></span><br><span class="line">    <span class="comment">// 简化写法</span></span><br><span class="line">    <span class="comment">// compile 'commons-collections:commons-collections:3.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用一个外部依赖需要指定使用的group, name 和 version 属性，三者缺一不可。那从哪里得知JAR包的这三个属性呢？我们可以从mvnrepository中搜索到。</p>
<h2 id="u672C_u5730_u4F9D_u8D56"><a href="#u672C_u5730_u4F9D_u8D56" class="headerlink" title="本地依赖"></a>本地依赖</h2><p>Gradle也可以从本地目录中引入JAR包依赖，可以单一引入指定的某一JAR包，也可以引入某目录下所有的JAR包</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> files(<span class="string">'dir/file.jar'</span>)</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: <span class="string">'*.jar'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u9879_u76EE_u4F9D_u8D56"><a href="#u9879_u76EE_u4F9D_u8D56" class="headerlink" title="项目依赖"></a>项目依赖</h2><p>往往一个完整的项目由多个子项目构成。在Gradle中，使用文件settings.gradle定义当前项目的子项目。默认情况下，每个子项目的名称对应着当前操作系统目录下的一个子目录。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="symbol">'sub</span>-project1', <span class="symbol">'sub</span>-project2', <span class="symbol">'sub</span>-project3'</span><br></pre></td></tr></table></figure>
<p>如sub-project1依赖sub-project2，则在sub-project1的build.gradle中加入以下配置即可：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':sub-project2'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u4F9D_u8D56_u5173_u7CFB_u7BA1_u7406"><a href="#u4F9D_u8D56_u5173_u7CFB_u7BA1_u7406" class="headerlink" title="依赖关系管理"></a>依赖关系管理</h2><p>从宏观上说，依赖关系管理分为两个方面。首先，gradle需要知道你要构建或者运行的项目，以便找到它们。我们将这些导入的文件视为项目的依赖。第二，gradle需要构建或者打包你的项目产品。我们将这些导出的文件视为项目的发布。</p>
<p>例如在编译源码时项目需要Hibernate的某些jar包被加入到工程中，而在进行单元测试时还另需要Junit的某些jar被加入。这些被引入的jar包就是项目的依赖。Gradle允许对依赖进行相应的配置，通过不同的配置可以形成不同的依赖效果。例如：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'org.hibernate'</span>, <span class="string">name:</span> <span class="string">'hibernate-core'</span>, <span class="string">version:</span> <span class="string">'3.6.7.Final'</span></span><br><span class="line">    testCompile <span class="string">group:</span> <span class="string">'junit'</span>, <span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目编译时期，junit的jar包不会被引入，只有在单元测试时才会被引入。这样，就可以在不同的场景下加入相应的依赖关系，非常的灵活</p>
<p>Java 插件中定义了许多标准的配置，例如如下：</p>
<ul>
<li>compile: 用来编译项目源代码的依赖</li>
<li>runtime: 在运行时被生成的类使用的依赖。 默认的, 也包含了compile时的依赖。</li>
<li>testCompile: 编译测试代码的依赖。 默认的, 包含runtime时的依赖和compile时的依赖。</li>
<li>testRuntime: 运行测试所需要的依赖。 默认的, 包含上面三个依赖。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。它提供灵活的通用构建工具，就像ant。同时完美兼容Maven或Ivy仓库</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://wdxtub.com/tags/Android/"/>
    
      <category term="包管理" scheme="http://wdxtub.com/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sublime 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/sublime-guide/"/>
    <id>http://wdxtub.com/2016/03/24/sublime-guide/</id>
    <published>2016-03-24T20:08:06.000Z</published>
    <updated>2016-03-24T20:10:02.000Z</updated>
    <content type="html"><![CDATA[<p>Sublime 基本算是我的主力代码编辑器，这里简要介绍一些插件和技巧。</p>
<a id="more"></a>
<hr>
<h2 id="u63D2_u4EF6"><a href="#u63D2_u4EF6" class="headerlink" title="插件"></a>插件</h2><ol>
<li><a href="https://github.com/emmetio/emmet" target="_blank" rel="external">Emmet Git</a>，<a href="http://docs.emmet.io/" target="_blank" rel="external">Document</a>原名为：<code>Zencoding, 快速生成html,css</code>，默认扩展快捷为<code>tab</code>，如果<code>tab</code>按钮损坏，<code>ctrl+e</code>替换。 生成规则在：<code>Preferences -&gt; Browser packages -&gt; Emment -&gt; emment -&gt; snippets.json</code>中修改。<a href="http://www.iteye.com/news/27580" target="_blank" rel="external">@ Emmet 中文版文档</a></li>
<li><a href="https://github.com/titoBouzout/SideBarEnhancements" target="_blank" rel="external">Side Bar</a><code>增强的侧边栏</code></li>
<li><a href="https://github.com/spadgos/sublime-jsdocs" target="_blank" rel="external">Docblockr</a><code>增强js注释</code></li>
<li><a href="https://github.com/wbond/sublime_alignment" target="_blank" rel="external">Alignment</a><code>等号对齐</code>。在<code>Preferences -&gt; package settings -&gt; Alignment -&gt; Settings User</code>添加冒号对齐。<code>{ &quot;align_indent&quot;: false, &quot;alignment_chars&quot;: [&quot;=&quot;, &quot;:&quot;], &quot;alignment_space_chars&quot;: [&quot;=&quot;, &quot;:&quot;] }</code></li>
<li><a href="https://github.com/BoundInCode/AutoFileName" target="_blank" rel="external">AutoFileName</a>: <code>文件路径自动提示</code></li>
<li><a href="https://github.com/akira-cn/sublime-gbk" target="_blank" rel="external">gbk支持 GBK Encoding Support</a></li>
<li><a href="http://www.welefen.com/keymapmanager-add-check-plugins-keymap-conflict-feature.html" target="_blank" rel="external">检测快捷键冲突</a></li>
<li><a href="https://github.com/revolunet/sublimetext-markdown-preview" target="_blank" rel="external">markdown</a> <a href="http://www.tcreator.info/social/experience/markdown-to-pdf.html" target="_blank" rel="external">markdown 转为 pdf</a></li>
<li><a href="https://github.com/SublimeText/LineEndings" target="_blank" rel="external">LineEndings 设置换行符</a></li>
<li><a href="https://sublime.wbond.net/" target="_blank" rel="external">SublimeText插件列表</a></li>
<li><a href="https://github.com/rehorn/sublime-htmlbeautify" target="_blank" rel="external">html美化插件</a></li>
<li><a href="http://www.fantxi.com/blog/archives/sublime-template-engine-sublimetmpl/" target="_blank" rel="external">Sublime Text 新建文件的模版插件: SublimeTmpl</a></li>
<li><a href="http://www.cnblogs.com/liu-l/p/3902100.html" target="_blank" rel="external">前端自动化神器LiveReload配合浏览器和less/sass使用方法</a></li>
<li><a href="http://www.cnblogs.com/yili16438/p/3721896.html" target="_blank" rel="external">使用 Sublime Text 2 开发 Unity3D 项目</a></li>
<li><a href="http://www.cnblogs.com/lhb25/p/10-essential-sublime-text-plugins.html" target="_blank" rel="external">全栈开发必备的10款 Sublime Text 插件</a></li>
</ol>
<h2 id="u8BBE_u7F6E"><a href="#u8BBE_u7F6E" class="headerlink" title="设置"></a>设置</h2><ol>
<li>Font 推荐使用 <a href="http://code.google.com/p/uigroupcode/downloads/detail?name=YaHei.Consolas.1.12.zip&amp;can=2&amp;q=#makechanges" target="_blank" rel="external">YaHei.Consolas.1.12.ttf</a>，即为上图中所示字体。</li>
<li>Theme<ul>
<li>code style: 推荐使用这款<a href="http://code.google.com/p/uigroupcode/downloads/detail?name=Monokai.rar&amp;can=2&amp;q=#makechanges" target="_blank" rel="external">marktheme</a></li>
<li><a href="https://gist.github.com/1854721" target="_blank" rel="external">更换sidebar皮肤</a></li>
<li><a href="http://jamiewilson.io/predawn/" target="_blank" rel="external">分享一个sublime 主题 </a></li>
<li><a href="http://colorsublime.com/" target="_blank" rel="external">颜色配色</a></li>
</ul>
</li>
<li>Preferences -&gt; Settings - User</li>
<li><a href="http://baelabs.duapp.com/Sublime/indentation.html" target="_blank" rel="external">定制缩进</a></li>
<li><a href="http://baelabs.duapp.com/Sublime/spell_checking.html" target="_blank" rel="external">拼写检查</a></li>
<li><a href="http://baelabs.duapp.com/Sublime/distraction_free.html" target="_blank" rel="external">全屏模式，自由模式的定制</a></li>
<li><a href="http://www.cnblogs.com/jikey/archive/2013/03/12/2955230.html" target="_blank" rel="external">浏览器中预览</a></li>
<li><a href="http://baelabs.duapp.com/Sublime/settings.html" target="_blank" rel="external">其它配置</a></li>
</ol>
<h2 id="u7279_u6B8A_u64CD_u4F5C"><a href="#u7279_u6B8A_u64CD_u4F5C" class="headerlink" title="特殊操作"></a>特殊操作</h2><ol>
<li>按住 <code>ctrl</code> 键，鼠标单击就是多重选择。</li>
<li><a href="http://baelabs.duapp.com/Sublime/multiple_selection_with_the_keyboard.html" target="_blank" rel="external">键盘多重选择</a></li>
<li>根据选择文本自动添加 ‘, “”,(),[] 匹配。</li>
<li>搜索按钮的功能说明 (<a href="http://hi.baidu.com/chaoxinggsc/item/904a471aa937bc35f6625c42" target="_blank" rel="external">冷风贡献</a>)</li>
</ol>
<h2 id="u5FEB_u6377_u952E"><a href="#u5FEB_u6377_u952E" class="headerlink" title="快捷键"></a>快捷键</h2><ol>
<li>Ctrl+L             选择整行（按住-继续选择下行）</li>
<li>Ctrl+Shift+K(shhift+del)     删除整行，  ctrl + KK 从光标处删之行尾，Ctrl+K Backspace 从光标处删除至行首</li>
<li>Ctrl+Shift+D       复制光标所在整行，插入在该行之前</li>
<li>Ctrl+D             选词 （按住-继续选择下个相同的字符串，再按，可跳到相应的方法定义处</li>
<li>Ctrl+Shift+M       选择括号内的内容（按住-继续选择父括号）</li>
<li>Ctrl+/             注释整行（如已选择内容，同“Ctrl+Shift+/”效果）</li>
<li>Ctrl + alt + /     取消注释</li>
<li>Ctrl+Shift+UP      与上行互换  ctrl + shift + up: 列模式编辑</li>
<li>Ctrl + R           跳转当前页的目标方法</li>
<li>Ctrl+K + U        大写</li>
<li>Ctrl+K + L        小写</li>
<li>鼠标中间           列模式编辑</li>
<li>Ctrl+Shift+[]     代码折叠</li>
<li>ctrl+k ctrl+1:    折叠所有代码</li>
<li>Ctrl + K,B        打开侧边栏</li>
<li>ctrl + 回车：　　   光标后插入行，　Ctrl+Shift+Enter 光标前插入行</li>
<li>ctrl + m:         匹配括号</li>
<li>vim mode下        查找上一个下一个的快捷键是 是* #</li>
<li>ctrl +z, y:       撤销，恢复撤销</li>
<li>alt + .:          闭合当前标签</li>
<li>Ctrl+F2:          设置书签</li>
<li>F2:               下一个书签</li>
<li>Shift+F2:         上一个书签</li>
<li>ctrl + p:         即时的文件切换</li>
<li>ctrl + shift + a: 选择标签内的内容</li>
<li>ctrl + 单击：      多行随意位置添加光标</li>
<li>alt + F3( mac: ctrl + command + g): 选择页面中所有相同的词</li>
<li>ctrl + F3:        跳转到下一个选中的词</li>
<li>Ctrl+Shift+P Set Syntax:html : 设置文件类型</li>
<li>Shift + 右键:     连续多行光标选中 (by Gary Gauh)</li>
</ol>
<ul>
<li>非官方文档：<a href="https://sublime-text-unofficial-documentation.readthedocs.org/en/latest/" target="_blank" rel="external">Unofficial Document英文版</a></li>
<li><a href="http://baelabs.duapp.com/Sublime_unofficial/" target="_blank" rel="external">Unofficial Document中文版</a></li>
<li>sublime <a href="http://www.feelcss.com/sublime-text-2-settings.html" target="_blank" rel="external">配置详解</a></li>
<li>sublime <a href="http://baelabs.duapp.com/Sublime/" target="_blank" rel="external">其它文档</a></li>
</ul>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>如何删除安装的插件？</p>
<ol>
<li>ctr+shift+P,输入package</li>
<li>查找remove package</li>
<li>输入你要删除的package</li>
<li>回车，OK</li>
</ol>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/martomo/SublimeTextXdebug" target="_blank" rel="external">xdebug调试</a></li>
<li><a href="http://baelabs.duapp.com/Sublime%20text3" target="_blank" rel="external">sublimetext 3.0文档</a></li>
<li><a href="http://www.cnblogs.com/bananaplan/p/Sublime-Text-3-Powerful.html" target="_blank" rel="external">Sublime Text 3 绝对神器</a></li>
<li><a href="http://docs.sublimetext.tw/" target="_blank" rel="external">SublimeText手册-tw</a></li>
<li><a href="http://code-tech.diandian.com/post/2012-11-10/40041273125" target="_blank" rel="external">怎样从直接Github的repository安装Sublime Text插件</a></li>
<li><a href="http://code-tech.diandian.com/post/2012-11-14/40041132753" target="_blank" rel="external">Sublime text2的ThinkPHP插件</a></li>
<li><a href="http://code-tech.diandian.com/post/2012-11-21/40042403501" target="_blank" rel="external">sublime text 左侧菜单美化1</a></li>
<li><a href="http://zh.lucida.me/blog/sublime-text-complete-guide/" target="_blank" rel="external">Sublime Text 全程指南</a></li>
<li><a href="http://www.zhihu.com/question/24896283" target="_blank" rel="external">sublime 有哪些使用技巧</a></li>
<li><a href="http://www.html-js.com/article/The-frontend-tool-Megamix" target="_blank" rel="external">前端工程师手中的Sublime Text</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Sublime 基本算是我的主力代码编辑器，这里简要介绍一些插件和技巧。</p>]]>
    
    </summary>
    
      <category term="编辑器" scheme="http://wdxtub.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[VS Code 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/visual-code-guide/"/>
    <id>http://wdxtub.com/2016/03/24/visual-code-guide/</id>
    <published>2016-03-24T20:03:14.000Z</published>
    <updated>2016-03-24T20:08:33.000Z</updated>
    <content type="html"><![CDATA[<p>Visual Studio 终于把触角伸到了全平台，在加入了插件功能之后，VSC 事实上已经对各种老牌新生编辑器造成了强大的压力，为了紧跟时代脚步，还是要熟悉和了解一下 VSC 的。</p>
<p>这里基本上是官方教程的总结和翻译。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u7840_u77E5_u8BC6"><a href="#u57FA_u7840_u77E5_u8BC6" class="headerlink" title="基础知识"></a>基础知识</h2><p>归根到底 VSC 是一个代码编辑器，所以和其他的代码编辑器一样，基本的该有的甚至不该有的功能，都有。下面会简要介绍一下</p>
<h3 id="u6587_u4EF6_u3001_u6587_u4EF6_u5939_u548C_u9879_u76EE"><a href="#u6587_u4EF6_u3001_u6587_u4EF6_u5939_u548C_u9879_u76EE" class="headerlink" title="文件、文件夹和项目"></a>文件、文件夹和项目</h3><p>随意打开一个文件或者文件夹，就可以进行编辑，如果文件夹里包含 <code>package.json</code>, <code>project.json</code>, <code>tsconfig.json</code> 或者其他 ASP.NET 5 的 sln 文件，VSC 可以自动读取项目结构并且高亮显示出来</p>
<h3 id="u57FA_u7840_u89C6_u56FE"><a href="#u57FA_u7840_u89C6_u56FE" class="headerlink" title="基础视图"></a>基础视图</h3><p>Editor, Side Bar, Status Bar 和 View Bar 这里基本的标配都有</p>
<blockquote>
<p>Tip: 可以用 command+B 来切换显示侧边栏</p>
</blockquote>
<h3 id="u591A_u680F_u7F16_u8F91"><a href="#u591A_u680F_u7F16_u8F91" class="headerlink" title="多栏编辑"></a>多栏编辑</h3><p>只需要记住一些快捷键即可</p>
<ul>
<li>command+\ 分成多栏</li>
<li>command+1/2/3 通过数字键选择当前激活的文件</li>
<li>可以自由调整和重新排序</li>
</ul>
<h3 id="u6587_u4EF6_u6D4F_u89C8_u5668"><a href="#u6587_u4EF6_u6D4F_u89C8_u5668" class="headerlink" title="文件浏览器"></a>文件浏览器</h3><p>文件浏览器中可以进行基本的文件操作，对着文件点击右键即可，甚至还可以直接在 terminal 中打开！</p>
<blockquote>
<p>Tip: command+p 可以通过文件名快速查找并打开文件</p>
</blockquote>
<p>默认来说，VSC 会排除显示一些文件夹(例如 <code>.git</code>)，当然也可以在 user setting 中配置 <code>files.exclude</code> 来自定义排除规则（是支持通配符的如<code>\*.meta</code>）</p>
<h3 id="u5DF2_u6253_u5F00_u6587_u4EF6"><a href="#u5DF2_u6253_u5F00_u6587_u4EF6" class="headerlink" title="已打开文件"></a>已打开文件</h3><p>已打开文件会在边栏的上方显示，如果需要自定义，可以设置下面一些属性：</p>
<ul>
<li><code>explorer.workingFiles.maxVisible</code></li>
<li><code>explorer.workingFiles.dynamicHeight</code></li>
</ul>
<h3 id="u8DE8_u6587_u4EF6_u641C_u7D22"><a href="#u8DE8_u6587_u4EF6_u641C_u7D22" class="headerlink" title="跨文件搜索"></a>跨文件搜索</h3><p>快捷键 shift+command+f，支持全文搜索，中文英文都可以！简直爆炸！而且还支持正则表达式！</p>
<p>如果需要更高级的搜索，可以使用 shift+command+j</p>
<p>下面列出基本的正则表示：</p>
<ul>
<li><code>*</code> to match one or more characters in a path segment</li>
<li><code>?</code> to match on one character in a path segment</li>
<li><code>**</code> to match any number of path segments ,including none</li>
<li><code>{}</code> to group conditions (e.g. <code>{**/*.html,**/*.txt}</code> matches all html and txt files)</li>
<li><code>[]</code> to declare a range of characters to match (e.g., example.[0-9] to match on example.0, example.1, …</li>
</ul>
<p>注意可以自定义搜索范围，在设置中设定</p>
<ul>
<li><code>files.exclude</code></li>
<li><code>search.exclude</code></li>
</ul>
<h3 id="u547D_u4EE4_u677F"><a href="#u547D_u4EE4_u677F" class="headerlink" title="命令板"></a>命令板</h3><p>按 F1 就可以调出 Command Palette，这里可以快速输入各种命令，一些基本技巧</p>
<ul>
<li>command+p: 通过文件名找文件</li>
<li>control+tab: 可以循环切换之前打开的文件</li>
<li>shift+command+o: 可以导航到文件中的指定符号</li>
<li>control+g: 导航到指定行</li>
</ul>
<p>在 Command Palette 中输入 <code>?</code> 可以显示当前可用的操作</p>
<h3 id="u6587_u4EF6_u7F16_u7801_u652F_u6301"><a href="#u6587_u4EF6_u7F16_u7801_u652F_u6301" class="headerlink" title="文件编码支持"></a>文件编码支持</h3><p>在 <code>files.encoding</code> 设置中设置具体的编码，可以在 右下角的状态栏中看到。点击状态栏中的编码可以用指定编码打开或者保存文件(还需要选择具体的编码格式)</p>
<h2 id="u7F16_u8F91_u529F_u80FD"><a href="#u7F16_u8F91_u529F_u80FD" class="headerlink" title="编辑功能"></a>编辑功能</h2><p>理论上来说，基本上该有的功能都有，这里只列出一些超赞的功能</p>
<h3 id="u62EC_u53F7_u5339_u914D"><a href="#u62EC_u53F7_u5339_u914D" class="headerlink" title="括号匹配"></a>括号匹配</h3><p>括号会自动高亮匹配，可以用 <code>shift+command+]</code> 来跳到匹配的括号位置</p>
<h3 id="u591A_u884C_u9009_u62E9"><a href="#u591A_u884C_u9009_u62E9" class="headerlink" title="多行选择"></a>多行选择</h3><p>利用 <code>alt+click</code> 来激活多行选择，每个光标都是独立的，另一个比较方便添加光标的方式是 <code>option+command+↓</code> 和 <code>option+command+↑</code>，这会在正下方或上方添加光标</p>
<p><code>command+D</code> 选择当前单词，或者是当前单词下一次出现的位置，<code>command+K command+D</code> 会选择单词最后一次出现的位置</p>
<p>其他一些添加光标的方式是</p>
<ul>
<li><code>shift+command+l</code>: 在单词下一次出现处添加光标</li>
<li><code>command+f2</code>: 在下一个单词前添加光标</li>
</ul>
<h3 id="u7F29_u8FDB/_u6269_u5C55_u9009_u62E9"><a href="#u7F29_u8FDB/_u6269_u5C55_u9009_u62E9" class="headerlink" title="缩进/扩展选择"></a>缩进/扩展选择</h3><p>选择缩进/扩展，快捷键 <code>control+shift+command+←</code> / <code>control+shift+command+→</code></p>
<p><img src="/images/14588498234616.jpg" alt=""></p>
<h3 id="u667A_u80FD_u63D0_u793A"><a href="#u667A_u80FD_u63D0_u793A" class="headerlink" title="智能提示"></a>智能提示</h3><p>对于 JavaScript, JSON, HTML, CSS, Less, Sass, C#, TypeScript 都有智能提示，也可以用 <code>control+space</code> 手动激活，用 <code>.</code>, <code>tab</code>, <code>Enter</code> 来选择</p>
<p>默认会在输入的时候进行智能提示，即所谓 24x7 IntelliSense，可以在 <code>editor.quickSuggestions</code> 和 <code>editor.suggestOnTriggerCharacters</code> 中进行设置</p>
<h3 id="u53C2_u6570_u63D0_u793A"><a href="#u53C2_u6570_u63D0_u793A" class="headerlink" title="参数提示"></a>参数提示</h3><p>在 JavaScript, TypeScript 和 C# 中，会自动提示函数的参数，可以用方向键进行导航</p>
<h3 id="u4EE3_u7801_u7247_u6BB5"><a href="#u4EE3_u7801_u7247_u6BB5" class="headerlink" title="代码片段"></a>代码片段</h3><p>可以在 <code>User Snippets</code> (<code>File | Preferences</code>) 中设定自己的 snippet</p>
<h3 id="u8DF3_u8F6C_u5230_u5B9A_u4E49"><a href="#u8DF3_u8F6C_u5230_u5B9A_u4E49" class="headerlink" title="跳转到定义"></a>跳转到定义</h3><p>如果语言支持的话，可以用 <code>F12</code> 来跳转到定义。如果按着 <code>ctrl</code> 并把指针放到一个符号上，会有一个简单的预览框。如果需要跳转到定义处可以使用 <code>ctrl+click</code>。如果需要在另外一侧的窗口打开定义，使用 <code>ctrol+alt+click</code></p>
<h2 id="u6269_u5C55"><a href="#u6269_u5C55" class="headerlink" title="扩展"></a>扩展</h2><p>支持扩展是使编辑器更加强大的方法，这里简要介绍一些目前我觉得比较有用的扩展</p>
<h3 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h3><p>安装方法非常简单，用 <code>F1</code> 打开 命令行，然后输入 <code>ext inst</code> 来进行操作</p>
<p><a href="https://marketplace.visualstudio.com/#VSCode" target="_blank" rel="external">MarketPlace</a></p>
<ul>
<li>Markdown Theme Kit</li>
<li>Markdown 预览 <code>command+k v</code></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Visual Studio 终于把触角伸到了全平台，在加入了插件功能之后，VSC 事实上已经对各种老牌新生编辑器造成了强大的压力，为了紧跟时代脚步，还是要熟悉和了解一下 VSC 的。</p>
<p>这里基本上是官方教程的总结和翻译。</p>]]>
    
    </summary>
    
      <category term="编辑器" scheme="http://wdxtub.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python 编程思想]]></title>
    <link href="http://wdxtub.com/2016/03/24/thinking-in-python/"/>
    <id>http://wdxtub.com/2016/03/24/thinking-in-python/</id>
    <published>2016-03-24T19:36:15.000Z</published>
    <updated>2016-03-24T19:52:07.000Z</updated>
    <content type="html"><![CDATA[<p>这里收集了一些深入 python 机制的内容。</p>
<a id="more"></a>
<hr>
<h2 id="u6D45_u8C08_Python__u7684_with__u8BED_u53E5"><a href="#u6D45_u8C08_Python__u7684_with__u8BED_u53E5" class="headerlink" title="浅谈 Python 的 with 语句"></a>浅谈 Python 的 with 语句</h2><p>with 语句是从 Python 2.5 开始引入的一种与异常处理相关的功能（2.5 版本中要通过 <code>from __future__ import with_statement</code> 导入后才可以使用），从 2.6 版本开始缺省可用（参考 What’s new in Python 2.6? 中 with 语句相关部分介绍）。with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。</p>
<h3 id="u672F_u8BED"><a href="#u672F_u8BED" class="headerlink" title="术语"></a>术语</h3><p>要使用 with 语句，首先要明白上下文管理器这一概念。有了上下文管理器，with 语句才能工作。</p>
<p>下面是一组与上下文管理器和with 语句有关的概念。</p>
<p>上下文管理协议（Context Management Protocol）：包含方法 <code>__enter__()</code> 和 <code>__exit__()</code>，支持该协议的对象要实现这两个方法。</p>
<p>上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了<br><code>__enter__()</code> 和 <code>__exit__()</code> 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。</p>
<p>运行时上下文（runtime context）：由上下文管理器创建，通过上下文管理器的 <code>__enter__()</code> 和 <code>__exit__()</code> 方法实现，<code>__enter__()</code> 方法在语句体执行之前进入运行时上下文，<code>__exit__()</code> 在语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。</p>
<p>上下文表达式（Context Expression）：with 语句中跟在关键字 with 之后的表达式，该表达式要返回一个上下文管理器对象。</p>
<p>语句体（with-body）：with 语句包裹起来的代码块，在执行语句体之前会调用上下文管<br>理器的 <code>__enter__()</code> 方法，执行完语句体之后会执行 <code>__exit__()</code> 方法。</p>
<h3 id="u57FA_u672C_u8BED_u6CD5_u548C_u5DE5_u4F5C_u539F_u7406"><a href="#u57FA_u672C_u8BED_u6CD5_u548C_u5DE5_u4F5C_u539F_u7406" class="headerlink" title="基本语法和工作原理"></a>基本语法和工作原理</h3><p>with 语句的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> context_expression [<span class="keyword">as</span> target(s)]:</span><br><span class="line">    <span class="keyword">with</span>-body</span><br></pre></td></tr></table></figure>
<p>这里 context_expression 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 target(s) ，如果指定了 as 子句的话，会将上下文管理器的 <code>__enter__()</code> 方法的返回值赋值给 target(s)。target(s) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）。</p>
<p>Python 对一些内建对象进行改进，加入了对上下文管理器的支持，可以用于 with 语句中，比如可以自动关闭文件、线程锁的自动获取和释放等。假设要对一个文件进行操作，使用 with 语句可以有如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">r'somefileName'</span>) <span class="keyword">as</span> somefile:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> somefile:</span><br><span class="line">        <span class="keyword">print</span> line</span><br><span class="line">        <span class="comment"># ...more code</span></span><br></pre></td></tr></table></figure>
<p>这里使用了 with 语句，不管在处理文件过程中是否发生异常，都能保证 with 语句执行完毕后已经关闭了打开的文件句柄。如果使用传统的 try/finally 范式，则要使用类似如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">somefile = open(<span class="string">r'somefileName'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> somefile:</span><br><span class="line">        <span class="keyword">print</span> line</span><br><span class="line">        <span class="comment"># ...more code</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    somefile.close()</span><br></pre></td></tr></table></figure>
<p>比较起来，使用 with 语句可以减少编码量。已经加入对上下文管理协议支持的还有模块 threading、decimal 等。</p>
<p>PEP 0343 对 with 语句的实现进行了描述。with 语句的执行过程类似如下代码块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">context_manager = context_expression</span><br><span class="line">exit = type(context_manager).__exit__  </span><br><span class="line">value = type(context_manager).__enter__(context_manager)</span><br><span class="line">exc = <span class="keyword">True</span>   <span class="comment"># True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        target = value  <span class="comment"># 如果使用了 as 子句</span></span><br><span class="line">        <span class="keyword">with</span>-body     <span class="comment"># 执行 with-body</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># 执行过程中有异常发生</span></span><br><span class="line">        exc = <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常</span></span><br><span class="line">        <span class="comment"># 由外层代码对异常进行处理</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exit(context_manager, *sys.exc_info()):</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出</span></span><br><span class="line">    <span class="comment"># 或者忽略异常退出</span></span><br><span class="line">    <span class="keyword">if</span> exc:</span><br><span class="line">        exit(context_manager, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line">    <span class="comment"># 缺省返回 None，None 在布尔上下文中看做是 False</span></span><br></pre></td></tr></table></figure>
<ol>
<li>执行 context_expression，生成上下文管理器 context_manager</li>
<li>调用上下文管理器的 <code>__enter__()</code> 方法；如果使用了 as 子句，则将 <code>__enter__()</code> 方法的返回值赋值给 as 子句中的 target(s)</li>
<li>执行语句体 with-body</li>
<li>不管是否执行过程中是否发生了异常，执行上下文管理器的 <code>__exit__()</code> 方法，<code>__exit__()</code> 方法负责执行“清理”工作，如释放资源等。如果执行过程中没有出现异常，或者语句体中执行了语句 break/continue/return，则以 None 作为参数调用 <code>__exit__(None, None, None)</code> ；如果执行过程中出现异常，则使用 sys.exc_info 得到的异常信息为参数调用 <code>__exit__(exc_type, exc_value, exc_traceback)</code></li>
<li>出现异常时，如果 <code>__exit__(type, value, traceback)</code> 返回 False，则会重新抛出异常，让with 之外的语句逻辑来处理异常，这也是通用做法；如果返回 True，则忽略异常，不再对异常进行处理</li>
</ol>
<h2 id="Python_u7A0B_u5E8F_u7684_u6267_u884C_u539F_u7406"><a href="#Python_u7A0B_u5E8F_u7684_u6267_u884C_u539F_u7406" class="headerlink" title="Python程序的执行原理"></a>Python程序的执行原理</h2><p>Python先把代码(.py文件)编译成字节码，交给字节码虚拟机，然后虚拟机一条一条执行字节码指令，从而完成程序的执行。</p>
<p>字节码在Python虚拟机程序里对应的是PyCodeObject对象。</p>
<p>.pyc文件是字节码在磁盘上的表现形式。</p>
<p>PyCodeObject对象的创建时机是模块加载的时候，即import。</p>
<p>Python test.py会对test.py进行编译成字节码并解释执行，但是不会生成test.pyc。</p>
<p>如果test.py加载了其他模块，如import util，Python会对util.py进行编译成字节码，生成util.pyc，然后对字节码解释执行。</p>
<p>如果想生成test.pyc，我们可以使用Python内置模块py_compile来编译。</p>
<p>加载模块时，如果同时存在.py和.pyc，Python会尝试使用.pyc，如果.pyc的编译时间早于.py的修改时间，则重新编译.py并更新.pyc。</p>
<p>Python代码的编译结果就是PyCodeObject对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    int co_argcount;        /* 位置参数个数 */</span><br><span class="line">    int co_nlocals;         /* 局部变量个数 */</span><br><span class="line">    int co_stacksize;       /* 栈大小 */</span><br><span class="line">    int co_flags;   </span><br><span class="line">    PyObject *co_code;      /* 字节码指令序列 */</span><br><span class="line">    PyObject *co_consts;    /* 所有常量集合 */</span><br><span class="line">    PyObject *co_names;     /* 所有符号名称集合 */</span><br><span class="line">    PyObject *co_varnames;  /* 局部变量名称集合 */</span><br><span class="line">    PyObject *co_freevars;  /* 闭包用的的变量名集合 */</span><br><span class="line">    PyObject *co_cellvars;  /* 内部嵌套函数引用的变量名集合 */</span><br><span class="line">    /* The rest doesn’t count <span class="keyword">for</span> hash/cmp */</span><br><span class="line">    PyObject *co_filename;  /* 代码所在文件名 */</span><br><span class="line">    PyObject *co_name;      /* 模块名|函数名|类名 */</span><br><span class="line">    int co_firstlineno;     /* 代码块在文件中的起始行号 */</span><br><span class="line">    PyObject *co_lnotab;    /* 字节码指令和行号的对应关系 */</span><br><span class="line">    void *co_zombieframe;   /* <span class="keyword">for</span> optimization only (see frameobject.c) */</span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>
<p>加载模块时，模块对应的PyCodeObject对象被写入.pyc文件，格式如下：</p>
<p><img src="/images/14588486364401.jpg" alt=""></p>
<h3 id="u5206_u6790_u5B57_u8282_u7801"><a href="#u5206_u6790_u5B57_u8282_u7801" class="headerlink" title="分析字节码"></a>分析字节码</h3><p>Python提供了内置函数compile可以编译Python代码和查看PyCodeObject对象，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = ”hello”</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> s</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure>
<p>在Python交互式shell里编译代码得到PyCodeObject对象:</p>
<p><img src="/images/14588486530973.jpg" alt=""></p>
<p>dir(co)已经列出co的各个域，想查看某个域直接在终端输出即可：</p>
<p><img src="/images/14588486595605.jpg" alt=""></p>
<p>test.py的PyCodeObject</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">co.co_argcount    0</span><br><span class="line">co.co_nlocals     0</span><br><span class="line">co.co_names       (‘s’, ’func’)</span><br><span class="line">co.co_varnames    (‘s’, ’func’)</span><br><span class="line">co.co_consts      (‘hello’, &lt;code object func at 0x2aaeeec57110, file ”test.py”, line 3&gt;, None)</span><br><span class="line">co.co_code        ’d<span class="command">\x</span>00<span class="command">\x</span>00Z<span class="command">\x</span>00<span class="command">\x</span>00d<span class="command">\x</span>01<span class="command">\x</span>00<span class="command">\x</span>84<span class="command">\x</span>00<span class="command">\x</span>00Z<span class="command">\x</span>01<span class="command">\x</span>00e<span class="command">\x</span>01<span class="command">\x</span>00<span class="command">\x</span>83<span class="command">\x</span>00<span class="command">\x</span>00<span class="command">\x</span>01d<span class="command">\x</span>02<span class="command">\x</span>00S’</span><br></pre></td></tr></table></figure>
<p>Python解释器会为函数也生成的字节码PyCodeObject对象，见上面的co_consts[1]</p>
<p>func的PyCodeObject</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_argcount</span>   0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_nlocals</span>    0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_names</span>      <span class="params">(‘s’,)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_varnames</span>   <span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_consts</span>     <span class="params">(None,)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_code</span>       ‘<span class="title">t</span>\<span class="title">x00</span>\<span class="title">x00GHd</span>\<span class="title">x00</span>\<span class="title">x00S</span>’</span></span><br></pre></td></tr></table></figure>
<h3 id="u6267_u884C_u5B57_u8282_u7801"><a href="#u6267_u884C_u5B57_u8282_u7801" class="headerlink" title="执行字节码"></a>执行字节码</h3><p>Python虚拟机的原理就是模拟可执行程序再X86机器上的运行，X86的运行时栈帧如下图：</p>
<p><img src="/images/14588486859304.jpg" alt=""></p>
<p>假如test.py用C语言来实现，会是下面这个样子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s = “hello”;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(“%s\n”, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python虚拟机的原理就是模拟上述行为。当发生函数调用时，创建新的栈帧，对应Python的实现就是PyFrameObject对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _frame &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    struct _frame *f_back;    /* 调用者的帧 */</span><br><span class="line">    PyCodeObject *f_code;     /* 帧对应的字节码对象 */</span><br><span class="line">    PyObject *f_builtins;     /* 内置名字空间 */</span><br><span class="line">    PyObject *f_globals;      /* 全局名字空间 */</span><br><span class="line">    PyObject *f_locals;       /* 本地名字空间 */</span><br><span class="line">    PyObject **f_valuestack;  /* 运行时栈底 */</span><br><span class="line">    PyObject **f_stacktop;    /* 运行时栈顶 */</span><br><span class="line">    …….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么对应Python的运行时栈就是这样子：</p>
<p><img src="/images/14588486997857.jpg" alt=""></p>
<p>执行test.py的字节码时，会先创建一个栈帧，以下用f表示当前栈帧，执行过程注释如下：</p>
<p>test.py的符号名集合和常量集合</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">co<span class="class">.co_names</span>   (‘s’, ’func’)</span><br><span class="line">co<span class="class">.co_consts</span>  (‘hello’, &lt;<span class="tag">code</span> <span class="tag">object</span> func at <span class="number">0</span>x2aaeeec57110, file ”test.py”, line <span class="number">3</span>&gt;, None)</span><br></pre></td></tr></table></figure>
<p>如果你想查看当前栈帧，Python提供了<code>sys._getframe()</code>方法可以获取当前栈帧，你只需要在代码里加入代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    frame = sys._getframe()</span><br><span class="line">    <span class="keyword">print</span> frame.f_locals</span><br><span class="line">    <span class="keyword">print</span> frame.f_globals</span><br><span class="line">    <span class="keyword">print</span> frame.f_back.f_locals</span><br><span class="line">    <span class="comment">#你可以打印frame的各个域</span></span><br><span class="line">    <span class="keyword">print</span> s</span><br></pre></td></tr></table></figure>
<h2 id="Python__u9ED1_u9B54_u6CD5"><a href="#Python__u9ED1_u9B54_u6CD5" class="headerlink" title="Python 黑魔法"></a>Python 黑魔法</h2><h3 id="Python__u591A_u7EE7_u627F"><a href="#Python__u591A_u7EE7_u627F" class="headerlink" title="Python 多继承"></a>Python 多继承</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class A(object):</span><br><span class="line">   ...:         def foo(self):</span><br><span class="line">   ...:                 print("class A")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [2]: class B(object):</span><br><span class="line">   ...:         def foo(self):</span><br><span class="line">   ...:                 print("class B")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [3]: class C(A, B):</span><br><span class="line">   ...:         pass</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [4]: C().foo()</span><br><span class="line">class A # 例子很好懂, C继承了A和B，从左到右,发现A有foo方法,返回了</span><br></pre></td></tr></table></figure>
<p>看起来都是很简单, 有次序的从底向上,从前向后找,找到就返回. 再看例子:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [5]: class A(object):</span><br><span class="line">   ...:        def foo(self):</span><br><span class="line">   ...:               print("class A")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [6]: class B(A):</span><br><span class="line">   ...:        pass</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [7]: class C(A):</span><br><span class="line">   ...:        def foo(self):</span><br><span class="line">   ...:               print("class C")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [8]: class D(B,C):</span><br><span class="line">   ...:        pass</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [9]: D().foo()</span><br><span class="line">class C # ? 按道理, 顺序是 D-&gt;B-&gt;A,为什么找到了C哪去了</span><br></pre></td></tr></table></figure>
<p>这也就涉及了MRO(Method Resolution Order):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: D.__mro__</span><br><span class="line">Out[<span class="number">10</span>]: (__main__.D, __main__.B, __main__.C, __main__.A, object)</span><br></pre></td></tr></table></figure>
<p>简单的理解其实就是新式类是广度优先了， D-&gt;B, 但是发现C也是继承A，就先找C，最后再去找A</p>
<h3 id="u5217_u8868_u7684+_u548C+_3D_2C_append_u548Cextend"><a href="#u5217_u8868_u7684+_u548C+_3D_2C_append_u548Cextend" class="headerlink" title="列表的+和+=, append和extend"></a>列表的+和+=, append和extend</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: print(<span class="string">'ID:'</span>, id(a_list))</span><br><span class="line">(<span class="string">'ID:'</span>, <span class="number">4481323592</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: a_list += [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: print(<span class="string">'ID (+=):'</span>, id(a_list))</span><br><span class="line">(<span class="string">'ID (+=):'</span>, <span class="number">4481323592</span>) <span class="comment"># 使用+= 还是在原来的列表上操作</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: a_list = a_list + [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: print(<span class="string">'ID (list = list + ...):'</span>, id(a_list))</span><br><span class="line">(<span class="string">'ID (list = list + ...):'</span>, <span class="number">4481293056</span>) <span class="comment"># 简单的+其实已经改变了原有列表</span></span><br><span class="line">In [<span class="number">28</span>]: a_list = []</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: id(a_list)</span><br><span class="line">Out[<span class="number">29</span>]: <span class="number">4481326976</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: a_list.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: id(a_list)</span><br><span class="line">Out[<span class="number">31</span>]: <span class="number">4481326976</span> <span class="comment"># append 是在原有列表添加</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: a_list.extend([<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: id(a_list)</span><br><span class="line">Out[<span class="number">33</span>]: <span class="number">4481326976</span> <span class="comment"># extend 也是在原有列表上添加</span></span><br></pre></td></tr></table></figure>
<h3 id="datetime_u4E5F_u6709_u5E03_u5C14_u503C"><a href="#datetime_u4E5F_u6709_u5E03_u5C14_u503C" class="headerlink" title="datetime也有布尔值"></a>datetime也有布尔值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">34</span>]: <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: print(<span class="string">'"datetime.time(0,0,0)" (Midnight) -&gt;'</span>, bool(datetime.time(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)))</span><br><span class="line">(<span class="string">'"datetime.time(0,0,0)" (Midnight) -&gt;'</span>, <span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: print(<span class="string">'"datetime.time(1,0,0)" (1 am) -&gt;'</span>, bool(datetime.time(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)))</span><br><span class="line">(<span class="string">'"datetime.time(1,0,0)" (1 am) -&gt;'</span>, <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="u2019_3D_3D_u2019__u548C_is__u7684_u533A_u522B"><a href="#u2019_3D_3D_u2019__u548C_is__u7684_u533A_u522B" class="headerlink" title="’==’ 和 is 的区别"></a>’==’ 和 is 的区别</h3><p>我的理解是”is”是判断2个对象的身份, ==是判断2个对象的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">37</span>]: a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: print(<span class="string">'a is b'</span>, bool(a <span class="keyword">is</span> b))</span><br><span class="line">(<span class="string">'a is b'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: c = <span class="number">999</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: d = <span class="number">999</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: print(<span class="string">'c is d'</span>, bool(c <span class="keyword">is</span> d))</span><br><span class="line">(<span class="string">'c is d'</span>, <span class="keyword">False</span>) <span class="comment"># 原因是python的内存管理,缓存了-5 - 256的对象</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: print(<span class="string">'256 is 257-1'</span>, <span class="number">256</span> <span class="keyword">is</span> <span class="number">257</span>-<span class="number">1</span>)</span><br><span class="line">(<span class="string">'256 is 257-1'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: print(<span class="string">'257 is 258-1'</span>, <span class="number">257</span> <span class="keyword">is</span> <span class="number">258</span> - <span class="number">1</span>)</span><br><span class="line">(<span class="string">'257 is 258-1'</span>, <span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: print(<span class="string">'-5 is -6+1'</span>, -<span class="number">5</span> <span class="keyword">is</span> -<span class="number">6</span>+<span class="number">1</span>)</span><br><span class="line">(<span class="string">'-5 is -6+1'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: print(<span class="string">'-7 is -6-1'</span>, -<span class="number">7</span> <span class="keyword">is</span> -<span class="number">6</span>-<span class="number">1</span>)</span><br><span class="line">(<span class="string">'-7 is -6-1'</span>, <span class="keyword">False</span>)</span><br><span class="line">In [<span class="number">47</span>]: a = <span class="string">'hello world!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: b = <span class="string">'hello world!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: print(<span class="string">'a is b,'</span>, a <span class="keyword">is</span> b)</span><br><span class="line">(<span class="string">'a is b,'</span>, <span class="keyword">False</span>) <span class="comment"># 很明显 他们没有被缓存,这是2个字段串的对象</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: print(<span class="string">'a == b,'</span>, a == b)</span><br><span class="line">(<span class="string">'a == b,'</span>, <span class="keyword">True</span>) <span class="comment"># 但他们的值相同</span></span><br><span class="line"><span class="comment"># But, 有个特例</span></span><br><span class="line">In [<span class="number">51</span>]: a = float(<span class="string">'nan'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: print(<span class="string">'a is a,'</span>, a <span class="keyword">is</span> a)</span><br><span class="line">(<span class="string">'a is a,'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: print(<span class="string">'a == a,'</span>, a == a)</span><br><span class="line">(<span class="string">'a == a,'</span>, <span class="keyword">False</span>) <span class="comment"># 亮瞎我眼睛了~</span></span><br></pre></td></tr></table></figure>
<h3 id="bool_u5176_u5B9E_u662Fint_u7684_u5B50_u7C7B"><a href="#bool_u5176_u5B9E_u662Fint_u7684_u5B50_u7C7B" class="headerlink" title="bool其实是int的子类"></a>bool其实是int的子类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">97</span>]: isinstance(<span class="keyword">True</span>, int)</span><br><span class="line">Out[<span class="number">97</span>]: <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: <span class="keyword">True</span> + <span class="keyword">True</span></span><br><span class="line">Out[<span class="number">98</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: <span class="number">3</span> * <span class="keyword">True</span> + <span class="keyword">True</span></span><br><span class="line">Out[<span class="number">99</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: <span class="number">3</span> * <span class="keyword">True</span> - <span class="keyword">False</span></span><br><span class="line">Out[<span class="number">100</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: <span class="keyword">True</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">Out[<span class="number">104</span>]: <span class="number">1024</span></span><br></pre></td></tr></table></figure>
<h3 id="u5143_u7EC4_u662F_u4E0D_u662F_u771F_u7684_u4E0D_u53EF_u53D8_3F"><a href="#u5143_u7EC4_u662F_u4E0D_u662F_u771F_u7684_u4E0D_u53EF_u53D8_3F" class="headerlink" title="元组是不是真的不可变?"></a>元组是不是真的不可变?</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [111]: tup = ([],)</span><br><span class="line"></span><br><span class="line">In [112]: tup[0] += [1]</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-112-d4f292cf35de&gt; in &lt;module&gt;()</span><br><span class="line">----&gt; 1 tup[0] += [1]</span><br><span class="line"></span><br><span class="line">TypeError: 'tuple' object does not support item assignment</span><br><span class="line"></span><br><span class="line">In [113]: tup</span><br><span class="line">Out[113]: ([1],) # 我靠 又是亮瞎我眼睛,明明抛了异常 还能修改?</span><br><span class="line"></span><br><span class="line">In [114]: tup = ([],)</span><br><span class="line"></span><br><span class="line">In [115]: tup[0].extend([1])</span><br><span class="line"></span><br><span class="line">In [116]: tup[0]</span><br><span class="line">Out[116]: [1] # 好吧,我有点看明白了, 虽然我不能直接操作元组，但是不能阻止我操作元组中可变的子对象(list)</span><br></pre></td></tr></table></figure>
<p>+= 是一个特例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">117</span>]: my_tup = (<span class="number">1</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: my_tup += (<span class="number">4</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: my_tup = my_tup + (<span class="number">5</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: my_tup</span><br><span class="line">Out[<span class="number">120</span>]: (<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment"># ? 嗯 不是不能操作元组嘛?</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: my_tup = (<span class="number">1</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: print(id(my_tup))</span><br><span class="line"><span class="number">4481317904</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: my_tup += (<span class="number">4</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: print(id(my_tup))</span><br><span class="line"><span class="number">4480606864</span> <span class="comment"># 操作的不是原来的元组 所以可以</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: my_tup = my_tup + (<span class="number">5</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">126</span>]: print(id(my_tup))</span><br><span class="line"><span class="number">4474234912</span></span><br></pre></td></tr></table></figure>
<h3 id="u5F02_u5E38_u5904_u7406_u52A0_else"><a href="#u5F02_u5E38_u5904_u7406_u52A0_else" class="headerlink" title="异常处理加 else"></a>异常处理加 else</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">150</span>]: <span class="keyword">try</span>:</span><br><span class="line">   .....:     print(<span class="string">'third element:'</span>, a_list[<span class="number">2</span>])</span><br><span class="line">   .....: <span class="keyword">except</span> IndexError:</span><br><span class="line">   .....:     print(<span class="string">'raised IndexError'</span>)</span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:     print(<span class="string">'no error in try-block'</span>) <span class="comment"># 只有在try里面没有异常的时候才会执行else里面的表达式</span></span><br><span class="line">   .....:</span><br><span class="line">raised IndexError <span class="comment"># 抛异常了 没完全完成</span></span><br><span class="line">In [<span class="number">153</span>]: i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">154</span>]: <span class="keyword">while</span> i &lt; <span class="number">2</span>:</span><br><span class="line">   .....:     print(i)</span><br><span class="line">   .....:     i += <span class="number">1</span></span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:     print(<span class="string">'in else'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> <span class="keyword">else</span> <span class="comment"># while也支持哦~</span></span><br><span class="line">In [<span class="number">155</span>]: i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: <span class="keyword">while</span> i &lt; <span class="number">2</span>:</span><br><span class="line">   .....:         print(i)</span><br><span class="line">   .....:         i += <span class="number">1</span></span><br><span class="line">   .....:         <span class="keyword">break</span></span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:         print(<span class="string">'completed while-loop'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span> <span class="comment"># 被break了 没有完全执行完 就不执行else里面的了</span></span><br><span class="line">In [<span class="number">158</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">   .....:         print(i)</span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:         print(<span class="string">'completed for-loop'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">completed <span class="keyword">for</span>-loop</span><br><span class="line"></span><br><span class="line">In [<span class="number">159</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">   .....:         print(i)</span><br><span class="line">   .....:         <span class="keyword">break</span></span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:         print(<span class="string">'completed for-loop'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span> <span class="comment"># 也是因为break了</span></span><br></pre></td></tr></table></figure>
<h2 id="u6DF1_u62F7_u8D1D_u4E0E_u6D45_u62F7_u8D1D"><a href="#u6DF1_u62F7_u8D1D_u4E0E_u6D45_u62F7_u8D1D" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><h3 id="u5BF9_u8C61_u8D4B_u503C"><a href="#u5BF9_u8C61_u8D4B_u503C" class="headerlink" title="对象赋值"></a>对象赋值</h3><p>Python中，对象的赋值，拷贝（深/浅拷贝）之间是有差异的，如果使用的时候不注意，就可能产生意外的结果。</p>
<p>直接看一段代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">will = [<span class="string">"Will"</span>, <span class="number">28</span>, [<span class="string">"Python"</span>, <span class="string">"C#"</span>, <span class="string">"JavaScript"</span>]]</span><br><span class="line">wilber = will</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">"Wilber"</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">"CSS"</span>)</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br></pre></td></tr></table></figure>
<p><img src="/media/14521096832549/tip1.png" alt="tip1"></p>
<p>下面来分析一下这段代码：</p>
<ul>
<li>首先，创建了一个名为will的变量，这个变量指向一个list对象，从第一张图中可以看到所有对象的地址（每次运行，结果可能不同）</li>
<li>然后，通过will变量对wilber变量进行赋值，那么wilber变量将指向will变量对应的对象（内存地址），也就是说”wilber is will”，”wilber[i] is will[i]”</li>
<li>可以理解为，Python中，对象的赋值都是进行对象引用（内存地址）传递</li>
</ul>
<p>第三张图中，由于will和wilber指向同一个对象，所以对will的任何修改都会体现在wilber上<br>这里需要注意的一点是，str是不可变类型，所以当修改的时候会替换旧的对象，产生一个新的地址39758496</p>
<p><img src="/images/14588487955418.jpg" alt=""></p>
<h3 id="u6D45_u62F7_u8D1D"><a href="#u6D45_u62F7_u8D1D" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>下面就来看看浅拷贝的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">will = [<span class="string">"Will"</span>, <span class="number">28</span>, [<span class="string">"Python"</span>, <span class="string">"C#"</span>, <span class="string">"JavaScript"</span>]]</span><br><span class="line">wilber = copy.copy(will)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">"Wilber"</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">"CSS"</span>)</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br></pre></td></tr></table></figure>
<p>代码结果为：</p>
<p><img src="/images/14588488054814.jpg" alt=""></p>
<p>分析一下这段代码：</p>
<ul>
<li>首先，依然使用一个will变量，指向一个list类型的对象</li>
<li>然后，通过copy模块里面的浅拷贝函数copy()，对will指向的对象进行浅拷贝，然后浅拷贝生成的新对象赋值给wilber变量<ul>
<li>浅拷贝会创建一个新的对象，这个例子中”wilber is not will”</li>
<li>但是，对于对象中的元素，浅拷贝就只会使用原始元素的引用（内存地址），也就是说”wilber[i] is will[i]”</li>
</ul>
</li>
<li>当对will进行修改的时候<ul>
<li>由于list的第一个元素是不可变类型，所以will对应的list的第一个元素会使用一个新的对象39758496</li>
<li>但是list的第三个元素是一个可变类型，修改操作不会产生新的对象，所以will的修改结果会相应的反应到wilber上</li>
</ul>
</li>
</ul>
<p><img src="/images/14588488145630.jpg" alt=""></p>
<p>总结一下，当我们使用下面的操作的时候，会产生浅拷贝的效果：</p>
<ul>
<li>使用切片[:]操作</li>
<li>使用工厂函数（如list/dir/set）</li>
<li>使用copy模块中的copy()函数</li>
</ul>
<h3 id="u6DF1_u62F7_u8D1D"><a href="#u6DF1_u62F7_u8D1D" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>最后来看看深拷贝：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">will = [<span class="string">"Will"</span>, <span class="number">28</span>, [<span class="string">"Python"</span>, <span class="string">"C#"</span>, <span class="string">"JavaScript"</span>]]</span><br><span class="line">wilber = copy.deepcopy(will)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">"Wilber"</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">"CSS"</span>)</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br></pre></td></tr></table></figure>
<p>代码的结果为：</p>
<p><img src="/images/14588488380987.jpg" alt=""></p>
<p>分析一下这段代码：</p>
<ul>
<li>首先，同样使用一个will变量，指向一个list类型的对象</li>
<li>然后，通过copy模块里面的深拷贝函数deepcopy()，对will指向的对象进行深拷贝，然后深拷贝生成的新对象赋值给wilber变量<ul>
<li>跟浅拷贝类似，深拷贝也会创建一个新的对象，这个例子中”wilber is not will”</li>
<li>但是，对于对象中的元素，深拷贝都会重新生成一份（有特殊情况，下面会说明），而不是简单的使用原始元素的引用（内存地址）</li>
<li>例子中will的第三个元素指向39737304，而wilber的第三个元素是一个全新的对象39773088，也就是说，”wilber[2] is not will[2]”</li>
</ul>
</li>
<li>当对will进行修改的时候<ul>
<li>由于list的第一个元素是不可变类型，所以will对应的list的第一个元素会使用一个新的对象39758496</li>
<li>但是list的第三个元素是一个可变类型，修改操作不会产生新的对象，但是由于”wilber[2] is not will[2]”，所以will的修改不会影响wilber</li>
</ul>
</li>
</ul>
<p><img src="/images/14588488493152.jpg" alt=""></p>
<h3 id="u62F7_u8D1D_u7684_u7279_u6B8A_u60C5_u51B5"><a href="#u62F7_u8D1D_u7684_u7279_u6B8A_u60C5_u51B5" class="headerlink" title="拷贝的特殊情况"></a>拷贝的特殊情况</h3><p>其实，对于拷贝有一些特殊情况：</p>
<ul>
<li>对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有拷贝这一说<ul>
<li>也就是说，对于这些类型，”obj is copy.copy(obj)” 、”obj is copy.deepcopy(obj)”</li>
</ul>
</li>
<li>如果元组变量只包含原子类型对象，则不能深拷贝，看下面的例子</li>
</ul>
<p><img src="/images/14588488582446.jpg" alt=""></p>
<p>总结</p>
<p>本文介绍了对象的赋值和拷贝，以及它们之间的差异：</p>
<ul>
<li>Python中对象的赋值都是进行对象引用（内存地址）传递</li>
<li>使用copy.copy()，可以进行对象的浅拷贝，它复制了对象，但对于对象中的元素，依然使用原始的引用.</li>
<li>如果需要复制一个容器对象，以及它里面的所有元素（包含元素的子元素），可以使用copy.deepcopy()进行深拷贝</li>
<li>对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有被拷贝一说</li>
<li>如果元组变量只包含原子类型对象，则不能深拷贝，看下面的例子</li>
</ul>
<h2 id="Python__u4E2D_self__u7684_u542B_u4E49"><a href="#Python__u4E2D_self__u7684_u542B_u4E49" class="headerlink" title="Python 中 self 的含义"></a>Python 中 self 的含义</h2><p>刚开始学习Python的类写法的时候觉得很是麻烦，为什么定义时需要而调用时又不需要，为什么不能内部简化从而减少我们敲击键盘的次数？</p>
<h3 id="self_u4EE3_u8868_u7C7B_u7684_u5B9E_u4F8B_uFF0C_u800C_u975E_u7C7B_u3002"><a href="#self_u4EE3_u8868_u7C7B_u7684_u5B9E_u4F8B_uFF0C_u800C_u975E_u7C7B_u3002" class="headerlink" title="self代表类的实例，而非类。"></a>self代表类的实例，而非类。</h3><p>实例来说明</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line">        print(self.__class__)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Test object at <span class="number">0x000000000284E080</span>&gt;</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Test</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的例子中可以很明显的看出，self代表的是类的实例。而self.class则指向类。</p>
<h3 id="self_u4E0D_u5FC5_u975E_u5199_u6210self"><a href="#self_u4E0D_u5FC5_u975E_u5199_u6210self" class="headerlink" title="self不必非写成self"></a>self不必非写成self</h3><p>有很多童鞋是先学习别的语言然后学习Python的，所以总觉得self怪怪的，想写成this，可以吗？</p>
<p>当然可以，还是把上面的代码改写一下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(this)</span>:</span></span><br><span class="line">        print(this)</span><br><span class="line">        print(this.__class__)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure>
<p>改成this后，运行结果完全一样。</p>
<p>当然，最好还是尊重约定俗成的习惯，使用self。</p>
<h3 id="self_u53EF_u4EE5_u4E0D_u5199_u5417"><a href="#self_u53EF_u4EE5_u4E0D_u5199_u5417" class="headerlink" title="self可以不写吗"></a>self可以不写吗</h3><p>在Python的解释器内部，当我们调用t.prt()时，实际上Python解释成Test.prt(t)，也就是说把self替换成类的实例。</p>
<p>有兴趣的童鞋可以把上面的t.prt()一行改写一下，运行后的实际结果完全相同。</p>
<p>实际上已经部分说明了self在定义时不可以省略，如果非要试一下，那么请看下面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">()</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure>
<p>运行时提醒错误如下：prt在定义时没有参数，但是我们运行时强行传了一个参数。<br>由于上面解释过了t.prt()等同于Test.prt(t)，所以程序提醒我们多传了一个参数t。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"h.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    t.<span class="function"><span class="title">prt</span><span class="params">()</span></span></span><br><span class="line">TypeError: <span class="function"><span class="title">prt</span><span class="params">()</span></span> takes <span class="number">0</span> positional arguments but <span class="number">1</span> was given</span><br></pre></td></tr></table></figure>
<p>当然，如果我们的定义和调用时均不传类实例是可以的，这就是类方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">()</span>:</span></span><br><span class="line">        print(__class__)</span><br><span class="line">Test.prt()</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<pre><code>&lt;class &apos;__main__.Test&apos;&gt;
</code></pre><p>在继承时，传入的是哪个实例，就是那个传入的实例，而不是指定义了self的类的实例。<br>先看代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pprt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cprt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line">c = Child()</span><br><span class="line">c.cprt()</span><br><span class="line">c.pprt()</span><br><span class="line">p = Parent()</span><br><span class="line">p.pprt()</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__<span class="class">.Child</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A47080&gt;</span><br><span class="line">&lt;__main__<span class="class">.Child</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A47080&gt;</span><br><span class="line">&lt;__main__<span class="class">.Parent</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A47240&gt;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>运行c.cprt()时应该没有理解问题，指的是Child类的实例。</p>
<p>但是在运行c.pprt()时，等同于Child.pprt(c)，所以self指的依然是Child类的实例，由于self中没有定义pprt()方法，所以沿着继承树往上找，发现在父类Parent中定义了pprt()方法，所以就会成功调用。</p>
<p>在描述符类中，self指的是描述符类的实例</p>
<p>不太容易理解，先看实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desc</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, ins, cls)</span>:</span></span><br><span class="line">        print(<span class="string">'self in Desc: %s '</span> % self )</span><br><span class="line">        print(self, ins, cls)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    x = Desc()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'self in Test: %s'</span> % self)</span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br><span class="line">t.x</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self <span class="keyword">in</span> Test: &lt;__main__<span class="class">.Test</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A570B8&gt;</span><br><span class="line">self <span class="keyword">in</span> Desc: &lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000283E208&gt;</span><br><span class="line">&lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000283E208&gt; &lt;__main__<span class="class">.Test</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A570B8&gt; &lt;class <span class="string">'__main__.Test'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>大部分童鞋开始有疑问了，为什么在Desc类中定义的self不是应该是调用它的实例t吗？怎么变成了Desc类的实例了呢？</p>
<p>注意：此处需要睁大眼睛看清楚了，这里调用的是t.x，也就是说是Test类的实例t的属性x，由于实例t中并没有定义属性x，所以找到了类属性x，而该属性是描述符属性，为Desc类的实例而已，所以此处并没有顶用Test的任何方法。</p>
<p>那么我们如果直接通过类来调用属性x也可以得到相同的结果。</p>
<p>下面是把t.x改为Test.x运行的结果。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self <span class="keyword">in</span> Test: &lt;__main__<span class="class">.Test</span> <span class="tag">object</span> at <span class="number">0</span>x00000000022570B8&gt;</span><br><span class="line">self <span class="keyword">in</span> Desc: &lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000223E208&gt;</span><br><span class="line">&lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000223E208&gt; None &lt;class <span class="string">'__main__.Test'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>题外话：由于在很多时候描述符类中仍然需要知道调用该描述符的实例是谁，所以在描述符类中存在第二个参数ins，用来表示调用它的类实例，所以t.x时可以看到第三行中的运行结果中第二项为<main.test object="" at="" 0x0000000002a570b8="">。而采用Test.x进行调用时，由于没有实例，所以返回None。</main.test></p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>self在定义时需要定义，但是在调用时会自动传入。</li>
<li>self的名字并不是规定死的，但是最好还是按照约定是用self</li>
<li>self总是指调用时的类的实例。</li>
</ul>
<h2 id="Python_u7684_u5185_u5B58_u7BA1_u7406"><a href="#Python_u7684_u5185_u5B58_u7BA1_u7406" class="headerlink" title="Python的内存管理"></a>Python的内存管理</h2><p>以Python语言为例子，说明一门动态类型的、面向对象的语言的内存管理方式。</p>
<h3 id="u5BF9_u8C61_u7684_u5185_u5B58_u4F7F_u7528"><a href="#u5BF9_u8C61_u7684_u5185_u5B58_u4F7F_u7528" class="headerlink" title="对象的内存使用"></a>对象的内存使用</h3><p>赋值语句是语言最常见的功能了。但即使是最简单的赋值语句，也可以很有内涵。Python的赋值语句就很值得研究。</p>
<pre><code>a = 1
</code></pre><p>整数1为一个对象。而a是一个引用。利用赋值语句，引用a指向对象1。Python是动态类型的语言(参考动态类型)，对象与引用分离。Python像使用“筷子”那样，通过引用来接触和翻动真正的食物——对象。</p>
<p>为了探索对象在内存的存储，我们可以求助于Python的内置函数id()。它用于返回对象的身份(identity)。其实，这里所谓的身份，就是该对象的内存地址。</p>
<pre><code>a = 1
print(id(a))
print(hex(id(a)))
</code></pre><p>在我的计算机上，它们返回的是:</p>
<pre><code>11246696
’0xab9c68′
</code></pre><p>分别为内存地址的十进制和十六进制表示。</p>
<p>在Python中，整数和短小的字符，Python都会缓存这些对象，以便重复使用。当我们创建多个等于1的引用时，实际上是让所有这些引用指向同一个对象。</p>
<pre><code>a = 1
b = 1
print(id(a))
print(id(b))
</code></pre><p>上面程序返回</p>
<pre><code>11246696
11246696
</code></pre><p>可见a和b实际上是指向同一个对象的两个引用。</p>
<p>为了检验两个引用指向同一个对象，我们可以用is关键字。is用于判断两个引用所指的对象是否相同。</p>
<pre><code># True
a = 1
b = 1
print(a is b)

# True
a = &quot;good&quot;
b = &quot;good&quot;
print(a is b)

# False
a = &quot;very good morning&quot;
b = &quot;very good morning&quot;
print(a is b)

# False
a = []
b = []
print(a is b)
</code></pre><p>上面的注释为相应的运行结果。可以看到，由于Python缓存了整数和短字符串，因此每个对象只存有一份。比如，所有整数1的引用都指向同一对象。即使使用赋值语句，也只是创造了新的引用，而不是对象本身。长的字符串和其它对象可以有多个相同的对象，可以使用赋值语句创建出新的对象。</p>
<p>在Python中，每个对象都有存有指向该对象的引用总数，即引用计数(reference count)。</p>
<p>我们可以使用sys包中的getrefcount()，来查看某个对象的引用计数。需要注意的是，当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的多1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(getrefcount(a))</span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line">print(getrefcount(b))</span><br></pre></td></tr></table></figure>
<p>由于上述原因，两个getrefcount将返回2和3，而不是期望的1和2。</p>
<p>Python的一个容器对象(container)，比如表、词典等，可以包含多个对象。实际上，容器对象中包含的并不是元素对象本身，是指向各个元素对象的引用。</p>
<p>我们也可以自定义一个对象，并引用其它对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">from_obj</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, to_obj)</span>:</span></span><br><span class="line">        self.to_obj = to_obj</span><br><span class="line"></span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a = from_obj(b)</span><br><span class="line">print(id(a.to_obj))</span><br><span class="line">print(id(b))</span><br></pre></td></tr></table></figure>
<p>可以看到，a引用了对象b。</p>
<p>对象引用对象，是Python最基本的构成方式。即使是a = 1这一赋值方式，实际上是让词典的一个键值”a”的元素引用整数对象1。该词典对象用于记录所有的全局引用。该词典引用了整数对象1。我们可以通过内置函数globals()来查看该词典。</p>
<p>当一个对象A被另一个对象B引用时，A的引用计数将增加1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(getrefcount(a))</span><br><span class="line"></span><br><span class="line">b = [a, a]</span><br><span class="line">print(getrefcount(a))</span><br></pre></td></tr></table></figure>
<p>由于对象b引用了两次a，a的引用计数增加了2。</p>
<p>容器对象的引用可能构成很复杂的拓扑结构。我们可以用objgraph包来绘制其引用关系，比如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [x, dict(key1=x)]</span><br><span class="line">z = [y, (x, y)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> objgraph</span><br><span class="line">objgraph.show_refs([z], filename=<span class="string">'ref_topo.png'</span>)</span><br></pre></td></tr></table></figure>
<p>objgraph是Python的一个第三方包。安装之前需要安装xdot。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="keyword">install</span> xdot</span><br><span class="line">sudo pip <span class="keyword">install</span> objgraph</span><br></pre></td></tr></table></figure>
<p>两个对象可能相互引用，从而构成所谓的引用环(reference cycle)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">b = [a]</span><br><span class="line">a.append(b)</span><br></pre></td></tr></table></figure>
<p>即使是一个对象，只需要自己引用自己，也能构成引用环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">a.append(a)</span><br><span class="line">print(getrefcount(a))</span><br></pre></td></tr></table></figure>
<p>引用环会给垃圾回收机制带来很大的麻烦，我将在后面详细叙述这一点。</p>
<p>某个对象的引用计数可能减少。比如，可以使用del关键字删除某个引用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">print(getrefcount(b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line">print(getrefcount(b))</span><br></pre></td></tr></table></figure>
<p>del也可以用于删除容器元素中的元素，比如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> a[<span class="number">0</span>]</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>如果某个引用指向对象A，当这个引用被重新定向到某个其他对象B时，对象A的引用计数减少:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">print(getrefcount(b))</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">print(getrefcount(b))</span><br></pre></td></tr></table></figure>
<h3 id="u5783_u573E_u56DE_u6536"><a href="#u5783_u573E_u56DE_u6536" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>吃太多，总会变胖，Python也是这样。当Python中的对象越来越多，它们将占据越来越大的内存。不过你不用太担心Python的体形，它会乖巧的在适当的时候“减肥”，启动垃圾回收(garbage collection)，将没用的对象清除。在许多语言中都有垃圾回收机制，比如Java和Ruby。尽管最终目的都是塑造苗条的提醒，但不同语言的减肥方案有很大的差异。</p>
<p>从基本原理上，当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如某个新建对象，它被分配给某个引用，对象的引用计数变为1。如果引用被删除，对象的引用计数为0，那么该对象就可以被垃圾回收。比如下面的表:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> a</span><br></pre></td></tr></table></figure>
<p>del a后，已经没有任何引用指向之前建立的[1, 2, 3]这个表。用户不可能通过任何方式接触或者动用这个对象。这个对象如果继续待在内存里，就成了不健康的脂肪。当垃圾回收启动时，Python扫描到这个引用计数为0的对象，就将它所占据的内存清空。</p>
<p>然而，减肥是个昂贵而费力的事情。垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要总启动垃圾回收。所以，Python只会在特定条件下，自动启动垃圾回收。当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。</p>
<p>我们可以通过gc模块的get_threshold()方法，查看该阈值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">print(gc.get_threshold())</span><br></pre></td></tr></table></figure>
<p>返回(700, 10, 10)，后面的两个10是与分代回收相关的阈值，后面可以看到。700即是垃圾回收启动的阈值。可以通过gc中的set_threshold()方法重新设置。</p>
<p>我们也可以手动启动垃圾回收，即使用gc.collect()。</p>
<p>Python同时采用了分代(generation)回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。</p>
<p>小家伙要多检查</p>
<p>Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。</p>
<p>这两个次数即上面get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。</p>
<p>同样可以用set_threshold()来调整，比如对2代对象进行更频繁的扫描。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">gc.set_threshold(<span class="number">700</span>, <span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>引用环的存在会给上面的垃圾回收机制带来很大的困难。这些引用环可能构成无法使用，但引用计数不为0的一些对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">b = [a]</span><br><span class="line">a.append(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"><span class="keyword">del</span> b</span><br></pre></td></tr></table></figure>
<p>上面我们先创建了两个表对象，并引用对方，构成一个引用环。删除了a，b引用之后，这两个对象不可能再从程序中调用，就没有什么用处了。但是由于引用环的存在，这两个对象的引用计数都没有降到0，不会被垃圾回收。</p>
<p>为了回收这样的引用环，Python复制每个对象的引用计数，可以记为gc_ref。假设，每个对象i，该计数为gc_ref_i。Python会遍历所有的对象i。对于每个对象i引用的对象j，将相应的gc_ref_j减1。</p>
<p>在结束遍历后，gc_ref不为0的对象，和这些对象引用的对象，以及继续更下游引用的对象，需要被保留。而其它的对象则被垃圾回收。</p>
<h3 id="u603B_u7ED3-1"><a href="#u603B_u7ED3-1" class="headerlink" title="总结"></a>总结</h3><p>Python作为一种动态类型的语言，其对象和引用分离。这与曾经的面向过程语言有很大的区别。为了有效的释放内存，Python内置了垃圾回收的支持。Python采取了一种相对简单的垃圾回收机制，即引用计数，并因此需要解决孤立引用环的问题。Python与其它语言既有共通性，又有特别的地方。对该内存管理机制的理解，是提高Python性能的重要一步。</p>
<h2 id="u5B57_u5178_u63A8_u5BFC_28Dictionary_comprehensions_29_u548C_u96C6_u5408_u63A8_u5BFC_28Set_comprehensions_29"><a href="#u5B57_u5178_u63A8_u5BFC_28Dictionary_comprehensions_29_u548C_u96C6_u5408_u63A8_u5BFC_28Set_comprehensions_29" class="headerlink" title="字典推导(Dictionary comprehensions)和集合推导(Set comprehensions)"></a>字典推导(Dictionary comprehensions)和集合推导(Set comprehensions)</h2><p>大多数的Python程序员都知道且使用过列表推导(list comprehensions)。如果你对list comprehensions概念不是很熟悉——一个list comprehension就是一个更简短、简洁的创建一个list的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>some_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>another_list = [ x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> some_list ]</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>another_list</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>自从python 3.1 (甚至是Python 2.7)起，我们可以用同样的语法来创建集合和字典表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="comment"># Set Comprehensions</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>some_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>even_set = &#123; x <span class="keyword">for</span> x <span class="keyword">in</span> some_list <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>even_set</span><br><span class="line">set([<span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="comment"># Dict Comprehensions</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d = &#123; x: x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="number">1</span>: <span class="keyword">False</span>, <span class="number">2</span>: <span class="keyword">True</span>, <span class="number">3</span>: <span class="keyword">False</span>, <span class="number">4</span>: <span class="keyword">True</span>, <span class="number">5</span>: <span class="keyword">False</span>, <span class="number">6</span>: <span class="keyword">True</span>, <span class="number">7</span>: <span class="keyword">False</span>, <span class="number">8</span>: <span class="keyword">True</span>, <span class="number">9</span>: <span class="keyword">False</span>, <span class="number">10</span>: <span class="keyword">True</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个例子里，我们以some_list为基础，创建了一个具有不重复元素的集合，而且集合里只包含偶数。而在字典表的例子里，我们创建了一个key是不重复的1到10之间的整数，value是布尔型，用来指示key是否是偶数。</p>
<p>这里另外一个值得注意的事情是集合的字面量表示法。我们可以简单的用这种方法创建一个集合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>my_set</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>而不需要使用内置函数set()。</p>
<h2 id="Python_u8C03_u7528_u7CFB_u7EDF_u547D_u4EE4_u6216_u8005_u811A_u672C"><a href="#Python_u8C03_u7528_u7CFB_u7EDF_u547D_u4EE4_u6216_u8005_u811A_u672C" class="headerlink" title="Python调用系统命令或者脚本"></a>Python调用系统命令或者脚本</h2><p>使用 os.system() 调用系统命令 , 程序中无法获得到输出和返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>os.system(<span class="string">'ls -l /proc/cpuinfo'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>os.system(<span class="string">"ls -l /proc/cpuinfo"</span>)</span><br><span class="line">  -r--r--r-- <span class="number">1</span> root root <span class="number">0</span>  <span class="number">3</span>月 <span class="number">29</span> <span class="number">16</span>:<span class="number">53</span> /proc/cpuinfo</span><br><span class="line">  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>使用 os.popen() 调用系统命令, 程序中可以获得命令输出，但是不能得到执行的返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>out = os.popen(<span class="string">"ls -l /proc/cpuinfo"</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> out.read()</span><br><span class="line">  -r--r--r-- <span class="number">1</span> root root <span class="number">0</span>  <span class="number">3</span>月 <span class="number">29</span> <span class="number">16</span>:<span class="number">59</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure>
<p>使用 commands.getstatusoutput() 调用系统命令, 程序中可以获得命令输出和执行的返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> commands</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>commands.getstatusoutput(<span class="string">'ls /bin/ls'</span>)</span><br><span class="line">  (<span class="number">0</span>, <span class="string">'/bin/ls'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Python__u6355_u83B7_u7528_u6237_Ctrl+C__2CCtrl+D__u4E8B_u4EF6"><a href="#Python__u6355_u83B7_u7528_u6237_Ctrl+C__2CCtrl+D__u4E8B_u4EF6" class="headerlink" title="Python 捕获用户 Ctrl+C ,Ctrl+D 事件"></a>Python 捕获用户 Ctrl+C ,Ctrl+D 事件</h2><p>有些时候，需要在程序中捕获用户键盘事件，比如ctrl+c退出，这样可以更好的安全退出程序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    do_some_func()</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"User Press Ctrl+C,Exit"</span></span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"User Press Ctrl+D,Exit"</span></span><br></pre></td></tr></table></figure>
<h2 id="Python__u8BFB_u5199_u6587_u4EF6"><a href="#Python__u8BFB_u5199_u6587_u4EF6" class="headerlink" title="Python 读写文件"></a>Python 读写文件</h2><p>一次性读入文件到列表，速度较快，适用文件比较小的情况下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">track_file = <span class="string">"track_stock.conf"</span></span><br><span class="line">fd = open(track_file)</span><br><span class="line">content_list = fd.readlines()</span><br><span class="line">fd.close()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> content_list:</span><br><span class="line">    <span class="keyword">print</span> line</span><br></pre></td></tr></table></figure>
<p>逐行读入，速度较慢,适用没有足够内存读取整个文件(文件太大)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fd = open(file_path)</span><br><span class="line">fd.seek(<span class="number">0</span>)</span><br><span class="line">title = fd.readline()</span><br><span class="line">keyword = fd.readline()</span><br><span class="line">uuid = fd.readline()</span><br><span class="line">fd.close()</span><br></pre></td></tr></table></figure>
<p>写文件 write 与 writelines 的区别   </p>
<ul>
<li>Fd.write(str) : 把str写到文件中，write()并不会在str后加上一个换行符</li>
<li>Fd.writelines(content) : 把content的内容全部写到文件中,原样写入，不会在每行后面加上任何东西</li>
</ul>
<h2 id="u88C5_u9970_u5668"><a href="#u88C5_u9970_u5668" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器使一个函数或方法包装在另一个函数里头，可以在被包装的函数添加一些额外的功能，比如日志，还可以对参数、返回结果进行修改。装饰器有点类似Java中的AOP。下面这个例子是打印被装饰的函数里面的参数的装饰器，  </p>
<pre><code>&gt;&gt;&gt; def print_args(function):
&gt;&gt;&gt;     def wrapper(*args, **kwargs):
&gt;&gt;&gt;         print &apos;Arguments:&apos;, args, kwargs
&gt;&gt;&gt;         return function(*args, **kwargs)
&gt;&gt;&gt;     return wrapper

&gt;&gt;&gt; @print_args
&gt;&gt;&gt; def write(text):
&gt;&gt;&gt;     print text

&gt;&gt;&gt; write(&apos;foo&apos;)
Arguments: (&apos;foo&apos;,) {}
foo
</code></pre><p>@是语法糖，它等价于：  </p>
<pre><code>&gt;&gt;&gt; write = print_args(write)
&gt;&gt;&gt; write(&apos;foo&apos;)
arguments: (&apos;foo&apos;,) {}
foo
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这里收集了一些深入 python 机制的内容。</p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://wdxtub.com/tags/Python/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[个人知识管理指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/self-knowledge-management/"/>
    <id>http://wdxtub.com/2016/03/24/self-knowledge-management/</id>
    <published>2016-03-24T14:14:42.000Z</published>
    <updated>2016-03-24T15:06:19.000Z</updated>
    <content type="html"><![CDATA[<p>经过一年时间打磨，我的个人知识管理体系终于成型，在这里跟大家分享一下。</p>
<a id="more"></a>
<hr>
<p>在这个碎片化的时代，如何『聚合』是有门道的，甚至可以认为是『刚需』。各类门户各类新闻聚合各类资讯文章层出不穷，但是问题在于，作为个人，如何真正把看到的『信息』转化为『知识』呢？</p>
<p>在我之前的文章<a href="http://wdxtub.lofter.com/post/1a7a1d_5d46742" target="_blank" rel="external">《信息极简之道》</a>中，粗略介绍了基于七个不同组件的信息管理工作流，经过大半年的改进，最终形成了<a href="http://wdxtub.com/2016/01/02/cloud-workflow/">《极简解构工作流》</a>中介绍的方法。</p>
<blockquote>
<p>这套工作流的核心，在于『流』，也就是说，所有的一切，都是为了让信息在尽可能少的依赖和限制下自由流动。无论是不同的设备，不同的应用还是不同的形式，信息都应该能以最简单最自然的方式进行流动。并且，我也不希望整套工作流过分依赖某个步骤或者某个应用。</p>
</blockquote>
<p>前面的文章主要说的是思路，这篇文章中会结合实际应用详细介绍具体的工作流程（当然也有一些更新）。</p>
<h2 id="u8BBE_u8BA1_u54F2_u5B66"><a href="#u8BBE_u8BA1_u54F2_u5B66" class="headerlink" title="设计哲学"></a>设计哲学</h2><p>设计哲学主要有四点：极简、GTD、Unix 以及沉淀</p>
<ul>
<li>极简：所用工具简单，适应性稳定性强，对环境的依赖少，关注信息本身，自动完成琐碎繁杂工作，与此同时保持高可拓展性</li>
<li>GTD：规则化任务处理，尽量减少任务选择和切换时的消耗，断舍离，不陷入任务堆积的恶性循环中</li>
<li>Unix：所有信息通过文本文件的方式进行流动，减少了不同步骤和模块间的耦合，每一个步骤和模块都可以根据自己的喜好进行定制</li>
<li>沉淀：提取主题，写系列博客，把知识组织并分享出去</li>
</ul>
<p>根据这样的设计哲学，具体的设计和功能有：</p>
<ul>
<li>文件同步：Dropbox / Box / 百度云 / 金山云盘 / …<ul>
<li>不同文件夹表示不同笔记的类别，不同的笔记保存在不同的文本文件中</li>
<li>采用跨平台的文件同步服务，可以在不同电脑、手机上方便访问自己的笔记</li>
</ul>
</li>
<li>文本编辑：MWeb / Sublime / Atom / Visual Studio Code / Vim / Emacs / …<ul>
<li>基于 Markdown 语法的记录方式，利用文本文件实现不同的逻辑标记</li>
<li>任何文本编辑器都可以，只是显示效果可能有所差别</li>
</ul>
</li>
<li>信息导入：主要是 Kindle <ul>
<li>因为通常在使用 Kindle 进行阅读的时候会记录大量书摘，利用自己编写的信息导入插件，可以方便导出 kindle 书摘（成为文本文件），并无缝对接到知识管理系统中</li>
</ul>
</li>
<li>博客：Hexo / WordPress / …<ul>
<li>博客主要是用于记录和沉淀，并且能够把自己的思考分享出去</li>
</ul>
</li>
<li>随处访问：Github / Web / 手机 / 电脑<ul>
<li>因为基于简单的文件同步机制，所以在不同的平台上，都可以集成各种服务。比如说用 Github 进行版本控制，利用支持云盘同步的 APP 即可在手机上随时查看，博客内容也只需浏览器就可以方便浏览</li>
</ul>
</li>
</ul>
<h2 id="u5E94_u7528_u63A8_u8350"><a href="#u5E94_u7528_u63A8_u8350" class="headerlink" title="应用推荐"></a>应用推荐</h2><p>下面是我用着觉得比较顺手应用，推荐给大家（部分需要付费）</p>
<h3 id="MWeb"><a href="#MWeb" class="headerlink" title="MWeb"></a><a href="http://www.mweb.im/" target="_blank" rel="external">MWeb</a></h3><p><img src="/images/14588310376887.jpg" alt=""></p>
<ul>
<li>平台：Mac</li>
<li>功能：文件夹/文件管理，跨文件检索，即时预览，快捷插入图片，一键生成网站</li>
<li>简介：非常强大美观，可以说一次满足所有愿望，还是国人开发者的作品，良心</li>
</ul>
<h3 id="1Writer"><a href="#1Writer" class="headerlink" title="1Writer"></a><a href="http://1writerapp.com/" target="_blank" rel="external">1Writer</a></h3><p><img src="/images/14588312196908.jpg" alt=""></p>
<ul>
<li>平台：iPhone / iPad</li>
<li>功能：Markdown 支持，Dropbox 同步，文件夹/文件管理，导出 PDF，各种分享方式</li>
<li>简介：当之无愧的最佳，具体可以参考 <a href="http://wdxtub.com/2015/12/08/md-editor-ios/">iOS 上 Markdown 编辑器简评</a></li>
</ul>
<h2 id="Draft"><a href="#Draft" class="headerlink" title="Draft"></a><a href="https://play.google.com/store/apps/details?id=com.mvilla.draft" target="_blank" rel="external">Draft</a></h2><p><img src="/images/14588315888356.jpg" alt=""></p>
<ul>
<li>平台：Android</li>
<li>功能：Markdown 支持，Dropbox 同步，文件夹/文件管理，导出 PDF，各种分享方式</li>
<li>简介：因为小插件的缘故，甚至比 iOS 平台上的体验都好得多</li>
</ul>
<h3 id="Kindle_Voyage"><a href="#Kindle_Voyage" class="headerlink" title="Kindle Voyage"></a>Kindle Voyage</h3><p><img src="/images/14588317350582.jpg" alt=""></p>
<p>没啥好说的，还没买赶紧买买买啊！</p>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a><a href="https://hexo.io/" target="_blank" rel="external">Hexo</a></h3><p><img src="/images/14588317944639.jpg" alt=""></p>
<p>静态网站生成器，可以和 Github 完美对接（免费搭建自己的独立博客），相比其他的平台简单很多，我的博客就是由 hexo 搭建的</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这套工作流基本和工具解耦，能够很方便地根据自己的需要进行配置</p>
<ul>
<li>打通了各个设备的界限。微信订阅号的文章可以统一发送到 Kindle 上，在Kindle 上阅读批注后可以统一导入到电脑中</li>
<li>对操作系统和软件没有要求。整个工作流哪怕在一台全新的电脑上都可以快速展开，文件和文件夹是现代操作系统都有，系统也会自带编辑器和查找功能。唯一的区别就是，自己的电脑可以根据喜好进行配置，但是即使没有这些配置，整个工作流依然可以进行（比方说手头上没有自己电脑的时候）</li>
<li>所有的信息可以通过网络进行访问，无论是 Github 还是 Dropbox 或者是其他的云盘服务，都可以在线查看，只要有网，无论是手机还是电脑，都可以随时访问全部的信息</li>
<li>所有的内容保存在云端，可以方便进行场景的切换，比方说可以在手机上查看和编辑笔记，会自动同步到电脑上，随时可以切换到电脑继续刚才的工作</li>
<li>自动备份冗余：版本控制，更新时间等等都由云端处理，无须自己费心</li>
</ul>
<p>相信大家在具体的实践和摸索中，能找到最适合自己的方式。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>经过一年时间打磨，我的个人知识管理体系终于成型，在这里跟大家分享一下。</p>]]>
    
    </summary>
    
      <category term="信息" scheme="http://wdxtub.com/tags/%E4%BF%A1%E6%81%AF/"/>
    
      <category term="效率" scheme="http://wdxtub.com/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="自由" scheme="http://wdxtub.com/tags/%E8%87%AA%E7%94%B1/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[架与构 1 缘起]]></title>
    <link href="http://wdxtub.com/2016/03/22/arch-build-1/"/>
    <id>http://wdxtub.com/2016/03/22/arch-build-1/</id>
    <published>2016-03-22T19:09:02.000Z</published>
    <updated>2016-03-22T19:58:37.000Z</updated>
    <content type="html"><![CDATA[<p>做架构师是我从刚开始接触计算机科学时的梦想，现在，是时候为了这个梦想而做一些沉淀了。这个系列会写不同的架构概念，写不同的实际系统分析，写自己的想法和思考。</p>
<a id="more"></a>
<hr>
<p>大二的时候，我走到老师的办公室，问了这样一个问题：</p>
<blockquote>
<p>我要怎么样成为一个游戏制作人，或者是一个架构师呢？</p>
</blockquote>
<p>老师当时的反应我还记得，他说这俩职位的差别还是挺大的（中间省略一万字）但是有一点是相同的，就是都要 think different。</p>
<p>这年头，传统意义上的『好』，不如『特别』。所谓『特别』，意味着去想去做别人没想过或者不敢做的事儿，而不是在大家都知道要做的事情上做得最好。</p>
<p>比如说写博客，我不是懂最多的，也不是做得最快的，但是我却是最先开始写课程相关博客的。虽然主要目的其实是强迫自己认真思考所学知识，但是能够给大家提供一点方便，做一个交流和讨论的平台，甚至让有些同学也开始写博客。我觉得这是特别好的事情，可能我自己做不到一百分，但是能让大家都学到八九十分，也许比自己的一百分更重要。</p>
<p>回到正题，这个系列到底要写什么呢？主要分两大部分，一个是架构相关的基本概念介绍（<a href="http://parlab.eecs.berkeley.edu/wiki/patterns/patterns" target="_blank" rel="external">来源</a>），另一个就是结合各大公司公开出来的资料来分析不同业务背后对应的不同架构（主要来源于『聊聊架构』微信公众号）。</p>
<p>具体涉及的知识点主要有：</p>
<p><img src="/images/14586760521793.jpg" alt=""></p>
<p>具体涉及的业务分析有：</p>
<ul>
<li>58 同城架构优化</li>
<li>Etsy 研发体系构建</li>
<li>豆瓣研发管理</li>
<li>蘑菇街运维体系</li>
<li>Qzone 架构设计</li>
<li>当当网架构优化</li>
<li>携程异步消息系统架构设计</li>
<li>支付宝红包高并发</li>
<li>eBay 微服务生态系统</li>
<li>Twitter 高性能分布式日志</li>
<li>LinkedIn 架构演进</li>
<li>Uber 架构重构经验</li>
<li>京东商品搜索系统架构设计</li>
<li>IFTTT 的数据架构</li>
<li>美团架构</li>
<li>Spotify 运维监控体系</li>
<li>酷狗大数据平台重构</li>
<li>魅族云同步架构</li>
<li>微博推荐系统架构</li>
<li>1 号店分布式搜索引擎架构</li>
<li>Airbnb 架构</li>
</ul>
<p>我个人是很希望能写好这个系列的，因为在不断的学习和思考的过程中，能够慢慢培养自己的架构思考模式。另外之所以把这个系列取名为『架与构』，是为了提醒自己设计和实现是不可分割的部分，『架』得再好，『构』不出来也没用。所谓『脚踏实地，仰望星空』，大概就是这个道理。</p>
<p>与诸君共勉。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>做架构师是我从刚开始接触计算机科学时的梦想，现在，是时候为了这个梦想而做一些沉淀了。这个系列会写不同的架构概念，写不同的实际系统分析，写自己的想法和思考。</p>]]>
    
    </summary>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 习题课 5 设计模式练习]]></title>
    <link href="http://wdxtub.com/2016/03/20/sad-r5/"/>
    <id>http://wdxtub.com/2016/03/20/sad-r5/</id>
    <published>2016-03-21T00:43:05.000Z</published>
    <updated>2016-03-21T01:44:11.000Z</updated>
    <content type="html"><![CDATA[<p>这次的作业就是对设计模式的练习和熟悉，直接来看情境吧。</p>
<a id="more"></a>
<hr>
<blockquote>
<p>Does the following code fragment implement the Factory Method design pattern? Explain why.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLReaderFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This method returns an instance of a class</span></span><br><span class="line">    <span class="comment">// that implements the XMLReader interface.</span></span><br><span class="line">    <span class="comment">// The specific class it creates and returns is</span></span><br><span class="line">    <span class="comment">// based on a system property.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> XMLReader <span class="title">createXMLReader</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">XMLReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentHandler</span><span class="params">(ContentHandler handler)</span>:</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(InputStream is)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码片段实现了工厂模式，注释中说明是根据系统属性来进行创建，所以无须传入参数，需要被生成的对象都需要实现 XMLReader 接口。</p>
<blockquote>
<p>Typically, there is a significant performance penalty for declaring a method synchronized. In general adding the keyword synchronized to a method slows the invocation of the method by a factor of 6. A common programming idiom used to avoid synchronization in the common case is double check locking. Can the double-check locking idiom be used with the singleton pattern to avoid synchronizing every time the static instance method is called? For example, is the following valid? Explain why.</p>
</blockquote>
<p>```java<br>public class Singleton {<br>    private Singleton() { }<br>    static private Singleton instance = null;<br>    static public Singleton instance() {<br>        // Double check locking idiom<br>        // The synchronization is done internally<br>        // rather than on the method. This avoids<br>        // the expense of synchronizing for the<br>        // common case.<br>/<em>12</em>/  if( instance == null ) {<br>            synchronized( Singleton.class ) {<br>                // Second check<br>                if( instance == null ) {<br>/<em>16</em>/               instance = new Singleton( );<br>                 }<br>            }<br>        }<br>/<em>20</em>/  return instance;<br>    }<br>}</p>
<p>在大部分情况下代码没有问题，不过为了保险起见，还是要加上 <code>volatile</code> 关键字，不然在下面的情况中就会出问题：</p>
<ol>
<li>线程A发现变量没有被初始化, 然后它获取锁并开始变量的初始化。</li>
<li>由于某些编程语言的语义，编译器生成的代码允许在线程A执行完变量的初始化之前，更新变量并将其指向部分初始化的对象。</li>
<li>线程B发现共享变量已经被初始化，并返回变量。由于线程B确信变量已被初始化，它没有获取锁。如果在A完成初始化之前共享变量对B可见（这是由于A没有完成初始化或者因为一些初始化的值还没有穿过B使用的内存(缓存一致性)），程序很可能会崩溃。</li>
</ol>
<p><a href="https://zh.wikipedia.org/wiki/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">这里</a>有一个很好的参考资料</p>
<blockquote>
<p>Consider the following scenario, please suggest a design pattern and implement it. The outcome should like this:</p>
</blockquote>
<p><img src="/images/14585221758261.jpg" alt=""></p>
<p>In Elizabeth’s day care center, the teacher helps the kids to build all kinds of toys to develop their creative skills. One of Elizabeth’s favorite activities is to make animals with play-dough.</p>
<p>A set of molds is the tool that Elizabeth always uses to create her favorite cool animals.</p>
<p>One mold tool set includes five parts, including the head, body, arm, leg, and tail. Whenever Elizabeth wants to build an animal, she will use one set of each tools to make a head, body , leg, arm, and tail for that animal, and then assembles them with glue to build an animal. There are many types of animal mold tool sets that the kids can choose from.</p>
<p>For example: if Elizabeth wants to make a monkey, then she will pick the set of monkey molds to start.</p>
<ul>
<li>Step 1. Make monkey head.</li>
<li>Step 2. Make monkey body.</li>
<li>Step 3. Make monkey leg.</li>
<li>Step 4. Make monkey arm.</li>
<li>Step 5. Make monkey tail.</li>
</ul>
<p>Once all the five parts are finished, then Elizabeth will glue them all together and decorate it to have a monkey done as a finished product. Most likely, she will give it to her mom as a gift when she picks her (she will not give her the monkey if the monkey is not decorated, since it will not be looking good at all then). When she wants to make a kitten, she follows the same steps with the set of Kitten molds.</p>
<p>这道题目非常简单粗暴，看描述就知道直接使用建造者模式即可，具体的介绍看<a href="http://www.runoob.com/design-pattern/builder-pattern.html" target="_blank" rel="external">这里</a></p>
<p>实现的话这里就不贴代码了，反正是不难的。</p>
<blockquote>
<p>You are working on software that interacts with a new hardware device and are anxious to test against the actual hardware. The hardware manufacture has a beta version of the driver they plan to release but is warning the interface of the device driver could change between now and the release date. The device driver is used throughout your code and you are concerned about writing code to an interface that is subject to change. What design pattern can be used to mitigate the risks involved? Describe what the risks are and how the design pattern mitigates these risks.</p>
</blockquote>
<p>这个其实也比较简单，直觉反应就是适配器模式，用来做不同接口的转换。</p>
<blockquote>
<p>In keeping with the holiday theme, use the Decorator design pattern to model a Christmas tree as a base component (the tree) and optional decorations or adornments such as bulbs, candy and garland. Initially it’s enough for your solution to model just the printing or display of the tree along with its adornments. You can also assume that each type of decoration is added all at once.</p>
</blockquote>
<p><img src="/images/14585236303062.jpg" alt=""></p>
<p>Show the class diagram for your solution and the runtime organization of objects for different configurations of adornments.</p>
<p>这里题目已经指名说要用装饰器模式，就按照<a href="http://www.runoob.com/design-pattern/decorator-pattern.html" target="_blank" rel="external">这里</a>的方法设计一下即可，我就不啰嗦了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这次的作业就是对设计模式的练习和熟悉，直接来看情境吧。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="习题" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 习题课 6 Malloclab]]></title>
    <link href="http://wdxtub.com/2016/03/20/csapp-lab6/"/>
    <id>http://wdxtub.com/2016/03/20/csapp-lab6/</id>
    <published>2016-03-20T21:10:37.000Z</published>
    <updated>2016-03-24T12:58:59.000Z</updated>
    <content type="html"><![CDATA[<p>在这个实验中，我们会实现自己的 <code>malloc</code>, <code>free</code>, <code>realloc</code>, <code>calloc</code> 函数，并借此深入理解堆中的内存分配机制。</p>
<a id="more"></a>
<hr>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>老套路</p>
<ul>
<li>上传文件 <code>scp malloclab-handout.tar dawang@shark.ics.cs.cmu.edu:~/513</code></li>
<li>登录 <code>ssh -X dawang@shark.ics.cs.cmu.edu</code></li>
<li>解压 <code>tar xvf malloclab-handout.tar</code></li>
</ul>
<p>因为我比较习惯在本地写代码，所以把文件复制回来：</p>
<ul>
<li>服务器至本地<ul>
<li><code>scp -r dawang@shark.ics.cs.cmu.edu:~/513/malloclab-handout/mm* ./</code></li>
</ul>
</li>
<li>本地至服务器<ul>
<li><code>scp ./mm.c dawang@shark.ics.cs.cmu.edu:~/513/malloclab-handout/</code></li>
</ul>
</li>
</ul>
<p>我们需要做的是完成在 <code>mm.c</code> 中的以下几个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(size_t size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, size_t size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(size_t nmemb, size_t size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_checkheap</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>mm-naive.c</code> 中有一个简单的实现，另外 <code>mm-textbook.c</code> 中实现了课本中提到的 implicit list allocator。具体的函数介绍如下：</p>
<ul>
<li><code>mm-init</code>：在这里执行所有的初始化操作，包括分配初始的堆区域。注意，必须在这里重新初始化所有的全局变量，并且不要调用 <code>mem.init</code> 函数。成功的话返回 0 ，否则返回 -1</li>
<li><code>malloc</code>：至少需要分配 <code>size</code> 这么大的空间（可能因为对齐的原因会更大一点，8 byte 对齐），不能超出堆的范围，也不能覆盖其他已分配的区域</li>
<li><code>free</code>：释放 <code>ptr</code> 指针指向的区域（这个区域必须是已分配的），<code>free(NULL)</code> 什么都不做</li>
<li><code>realloc</code>：重新分配，根据传入指针的不同，有不同的表现<ul>
<li><code>ptr</code> 为 NULL 时，等同于 <code>malloc(size)</code></li>
<li><code>size</code> 为 0 时，等同于 <code>free(ptr)</code>，需要返回 NULL</li>
<li><code>ptr</code> 不为 NULL 时，一定是指向一个已分配的空间的，就根据新的 size 的大小进行调整，并让 <code>ptr</code> 指向新的地址（如果是新地址的话），并且旧的区域应该被释放。另外需要注意的是，需要把原来 block 的值复制过去  </li>
</ul>
</li>
<li><code>calloc</code>：分配一个有 <code>nmemb</code> 个大小为 <code>size</code> 的数组，这个函数不评分，只要简单实现即可</li>
<li><code>mm_checkheap</code>：扫描堆并检查其状态，注意，只有在检测到错误时才输出内容并调用 <code>exit</code> 退出。<code>mm_heapchecker(__Line__);</code> 传入的参数是当前行数，方便大家找到错误位置。</li>
</ul>
<p><code>memlib.c</code> 模拟了内存系统，可以调用下面的方法来得到响应的信息：</p>
<ul>
<li><code>void *mem_sbrk(int incr)</code>：让堆扩展 <code>incr</code> 个字节，并返回新分配的地址的头指针</li>
<li><code>void *mem_heap_lo(void)</code>：返回指向堆的第一个字节的指针</li>
<li><code>void *mem_heap_hi(void)</code>：返回指向堆的最后一个字节的指针</li>
<li><code>size_t mem_heapsize(void)</code>：返回当前的堆大小</li>
<li><code>size_t mem_pagesize(void)</code>：返回系统的 page size</li>
</ul>
<p>head checker 需要做的工作有：</p>
<ul>
<li>检查堆(implicit list, explicit list, segregated list)<ul>
<li>Check epilogue and prologue blocks</li>
<li>Check each block’s address alignment</li>
<li>Check heap boundaries</li>
<li>Check each block’s header and footer: size(minimum size, slignment), previous/net allocate/free bit consistency, header and footer matching each other</li>
<li>Check coalescing: no two consecutive free blocks in the heap</li>
</ul>
</li>
<li>检查 free list(explicit list, segregated list)<ul>
<li>All next/previous pointer are consistent (is A’s next pointer points ot B, B’s previous pointer should point to A)</li>
<li>All free list pointers points between <code>mem_heap_lo()</code> and <code>mem_heap_hi()</code></li>
<li>Count free blocks by iterating through every block and traversing free list by pointers and see if they match</li>
<li>All blocks in each list bucket fall within bucket size range(segregated list) </li>
</ul>
</li>
</ul>
<p>需要注意的地方：</p>
<ul>
<li>不能改动 <code>mm.h</code>，但是可以在 <code>mm.c</code> 中添加 <code>static</code> 方法使代码更好理解</li>
<li><code>mm.c</code> 中不能定义任何全局 array, tree 或 list，但是可以定义全局 struct 和诸如 integer, float 和 pointer 等变量</li>
<li>返回的指针必须是 8-byte 对齐的</li>
<li>编译代码不能有警告</li>
<li>建议先实现 explcit free list</li>
<li>代码开头写注释说明思路，也要写上 ID 和名字</li>
</ul>
<h2 id="u63D0_u793A_u4E0E_u6D4B_u8BD5"><a href="#u63D0_u793A_u4E0E_u6D4B_u8BD5" class="headerlink" title="提示与测试"></a>提示与测试</h2><ul>
<li>因为是 64 位机器，所以指针的大小是 8 字节</li>
<li><code>sizeof(size_t) == 8</code></li>
<li><code>gprof</code> 工具可能会很有用</li>
<li>三种组织 free block 的方法：implicit free list, explicit free list, segregated free list</li>
<li>三种扫描 free block 的方法：first fit/next fit, blocks sorted by address with first fit, best fit</li>
<li>可以随机用上面的方法排列组合</li>
<li>可以根据 implicit free list（在 <code>mm-textbook.c</code> 中）来实现 explicit free list，然后实现 segregated list</li>
</ul>
<p>可以通过 <code>mdriver.c</code> 来进行测试，每个测试会跑 12 次，一次检测正确性，一次检测空间使用，十次测试性能，下面是具体的参数：</p>
<ul>
<li><code>-p</code>：完整测试</li>
<li><code>-t &lt;tracedir&gt;</code>：在自定义的文件夹中搜索测试文件</li>
<li><code>-f &lt;tracefile&gt;</code>：进行一个特定的测试</li>
<li><code>-c &lt;tracefile&gt;</code>：执行特定的测试 1 次，用来检测正确性很方便</li>
<li><code>-h</code>：输出命令行参数</li>
<li><code>-l</code>：用真实的 <code>malloc</code> 函数来测试，可以比较自己写的代码和系统代码的差距</li>
<li><code>-V</code>：输出各种信息</li>
<li><code>-v &lt;verbose level&gt;</code>：设置需要输出的日志等级</li>
<li><code>-d &lt;i&gt;</code>： 有 0,1,2 三个层级，检查的标准越来越严格</li>
<li><code>-D</code>：等于 <code>-d2</code></li>
<li><code>-s &lt;s&gt;</code>：超过 s 秒则认为是超时，默认是永远不会超时的</li>
</ul>
<p>主要的考察目标是空间使用率以及吞吐量（每秒钟执行的操作数目）</p>
<h2 id="u89E3_u9898_u601D_u8DEF"><a href="#u89E3_u9898_u601D_u8DEF" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目中给出了一个提示，说堆的大小不会超过 $2^32$ 字节，这个是什么意思呢？其实很简单，我们知道 64 位机器中指针的长度是 8 个字节（八八六十四），但是因为堆的大小是有上限的，理论上来说，只要 4 个字节就可以完成整个空间的寻址（只需要记录偏移量即可），这样一来，用来保存结构信息的部分只需要原来的一半，内存的有效使用率自然就上去了。（不过具体作业的时候因为我主要参考 <code>mm-textbook.c</code> 中的代码，就没有另外做 4 字节寻址的版本了）</p>
<p>如果有仔细看习题课视频的话，其实助教已经讲得非常清楚了，我的建议如下：</p>
<ul>
<li><code>mm-naive.c</code> 很短，一下就可以看完，用来热身</li>
<li><code>mm-textbook.c</code> 基本上包括各种所需的宏以及存储结构，一定要好好理解清楚</li>
<li>确定了具体保存信息的数据结构之后，一定要先完成 heap checker</li>
<li>遇到段错误的时候就需要利用 heap checker 找到具体问题所在了</li>
<li>最好画简单的示意图，对照着来编码，不然很容易乱</li>
<li>很多时候需要用到位操作，确保每个基本操作都没有错（如果用 <code>mm-textbook.c</code> 中的就不用担心这个）</li>
<li>列表的粒度越细，利用率就越高，但是最好的优化还是从数据结构入手</li>
</ul>
<p>最后要说的是不用自定义的数据结构应该很难做到 100 分，但是 90 分是没有问题的。</p>
<h2 id="u57FA_u7840_u77E5_u8BC6_u590D_u4E60"><a href="#u57FA_u7840_u77E5_u8BC6_u590D_u4E60" class="headerlink" title="基础知识复习"></a>基础知识复习</h2><h3 id="u5B8F_u4E0E_u5185_u8054_u51FD_u6570"><a href="#u5B8F_u4E0E_u5185_u8054_u51FD_u6570" class="headerlink" title="宏与内联函数"></a>宏与内联函数</h3><p>宏实际上是一个简单的『查找并替换』的过程，会在编译前完成。一般用来定义常量以及简单的操作（这里很容易出错，下面会说）。</p>
<p>定义常量比较简单：<code>#define NUM_ENTRIES 100</code> 即可。</p>
<p>定义简单操作则需要注意，比如 <code>#define twice(x) 2*x</code> 这样写就是会出问题的，如果在代码中调用 <code>twice(x+1)</code> 期望得到的结果应该是 <code>2x+2</code>，但是因为宏只是简单的替换，所以会变成 <code>2x+1</code>。解决办法是一定要用括号包裹住会被替换的值，比如之前的例子应该改写成 <code>#define twice(x) (2*(x))</code>。</p>
<p>使用宏，可以避免函数调用，也就少了很多跳转和对应的栈处理。对于 <code>malloc</code> 来说，可以通过宏快速访问 header 信息（例如 payload size, valid）</p>
<p>宏的缺点也同样明显，能够执行的操作不如函数那么强大，并且不会进行拼写和类型检查，很容易出错，出错了也不容易找到问题所在。</p>
<p>内联函数会在编译的时候被写入到代码中，同样因为不需要真实的函数调用，所以效率也很高。一般来说，比较小的函数都可以设置为内联。</p>
<p>两者之间的差别在于：</p>
<ul>
<li>宏在编译前处理</li>
<li>内联函数在编译时处理（带有类型检查）</li>
<li>宏不能有返回值</li>
<li>宏可能会带来一些副作用</li>
<li>很难调试宏</li>
</ul>
<p>具体到这次作业：</p>
<ul>
<li>两个都需要使用</li>
<li>宏适合做小的工作，比方说让代码更加容易理解</li>
<li>如果宏没有办法完成，先考虑使用内联函数</li>
</ul>
<h3 id="u6307_u9488_u590D_u4E60"><a href="#u6307_u9488_u590D_u4E60" class="headerlink" title="指针复习"></a>指针复习</h3><p>指针恐怕是 C 语言最难的一部分了，这里会尽量解释得清楚一些。</p>
<p>先来看看类型转换可能带来的问题：</p>
<ul>
<li>从 <code>&lt;type_a&gt;*</code> 转换到 <code>&lt;type_b&gt;*</code>（一个类型的指针转换为另一个类型的指针）<ul>
<li>值并不会改变</li>
<li>改变的是解析引用的行为，比方说原来是 int 指针，那么一次会读 4 个字节，现在转换成了 char 指针，一次就读 1 个字节（这里具体的字节数看是 32 位还是 64 位系统）</li>
</ul>
</li>
<li>从 <code>&lt;type_a&gt;*</code> 转换到 integer / unsigned int<ul>
<li>指针的值实际上就是 8 字节的数字</li>
<li>这是一个很值得利用的特性！</li>
<li>不过也很容易出错就是了</li>
</ul>
</li>
<li>从 integer / unsigned int 转换到 <code>&lt;type_a&gt;*</code><ul>
<li>这种情况基本不会使用，因为没人知道转换后的指针会指向什么地方</li>
</ul>
</li>
</ul>
<p>对于指针进行算术运算时，一定要注意跟指针本身的类型是有关的，比方说</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type_a* pointer = ...;</span><br><span class="line">(<span class="keyword">void</span> *) pointer1 = (<span class="keyword">void</span> *)(pointer + a);</span><br></pre></td></tr></table></figure>
<p>实际上进行的运算是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer1 = pointer + (a * sizeof(type_a))</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea (pointer, a, sizeof(type_a)), pointer1</span><br></pre></td></tr></table></figure>
<p>这里需要注意，如果一个指针的类型是 <code>void *</code>，那么是不能对其进行算术操作的，因为我们没办法确定其大小。</p>
<p>下面是具体的几个例子，一定要仔细理解：</p>
<p><img src="/images/14585171655720.jpg" alt="Pointer arithmetic"></p>
<p><img src="/images/14585171934388.jpg" alt="More pointer arithmetic"></p>
<p>我们不能够对空指针进行解引用，来看一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">*ptr1 = <span class="number">0xdeadbeef</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val1 = *ptr1;</span><br><span class="line"><span class="keyword">int</span> val2 = (<span class="keyword">int</span>) *((<span class="keyword">char</span> *) ptr1);</span><br></pre></td></tr></table></figure>
<p>那么 <code>val1</code> 和 <code>val2</code> 的值分别是什么呢？</p>
<p><code>val1</code> 的值比较简单，因为没有改动，所以就是 <code>0xdeadbeef</code>，不过 <code>val2</code> 的值就比较特别了，我们具体来看一看，首先指针 <code>ptr1</code> 被转换成了 <code>char</code> 指针，按照小端规则，指针指向的值变成了 <code>0xef</code>，解引用之后在转换成 <code>int</code> 类型，前面会补上 <code>ffffff</code>，最后就是 <code>0xffffffef</code></p>
<h3 id="Malloc"><a href="#Malloc" class="headerlink" title="Malloc"></a>Malloc</h3><p>需要知道的概念：</p>
<ul>
<li>malloc / calloc / realloc</li>
<li>free</li>
<li>sbrk</li>
<li>payload</li>
<li>framentation (internal vs. external)</li>
<li>colescing<ul>
<li>Bi-directional</li>
<li>Immediate vs. Deferred</li>
</ul>
</li>
</ul>
<p>在 paylaod 比 block size 小的时候就会产生内部碎片，比方说</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *m1 = <span class="built_in">malloc</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">void</span> *m2 = <span class="built_in">malloc</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>因为 m1 和 m2 都需要以 8 bytes 对齐，所以都会有 5 个 bytes 的内部碎片。</p>
<p>实现是需要考虑的问题有：</p>
<ul>
<li>怎么知道 block 在哪里</li>
<li>怎么知道 block 多大</li>
<li>怎么知道 block 是否 free</li>
<li>注意：不能缓存 malloc/free 调用，必须实时处理</li>
<li>注意：调用 free 的时候只传入一个指针，不会有表示 size 的参数</li>
<li>我们需要一个数据结构来存储关于 block 的相关信息</li>
</ul>
<p>这个数据结构需要做到：</p>
<ul>
<li>block 的位置，block 的大小，以及 block 是否 free</li>
<li>在 malloc/free 调用的时候，需要能够改变这个数据结构</li>
<li>需要通过这个数据结构找到下一个合适的 block</li>
<li>能够快速标记一个 block 是 free 还是 allocated</li>
<li>能够检测是否有足够空间</li>
</ul>
<p>具体怎么实现就需要自己思考了，唯一需要注意的是内存就是我们存放这些信息的地方。课堂上介绍过三种方式：</p>
<p><img src="/images/14585192291308.jpg" alt="Common types"></p>
<p>最好实现一个堆检查器，方便我们写程序，具体如下：</p>
<p><img src="/images/14585192921490.jpg" alt="Headp Checker"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这个实验中，我们会实现自己的 <code>malloc</code>, <code>free</code>, <code>realloc</code>, <code>calloc</code> 函数，并借此深入理解堆中的内存分配机制。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="MallocLab" scheme="http://wdxtub.com/tags/MallocLab/"/>
    
      <category term="习题课" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98%E8%AF%BE/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[How to Write Fast Code 第 4 课 并行架构]]></title>
    <link href="http://wdxtub.com/2016/03/20/fastcode-4/"/>
    <id>http://wdxtub.com/2016/03/20/fastcode-4/</id>
    <published>2016-03-20T15:02:43.000Z</published>
    <updated>2016-03-20T19:27:09.000Z</updated>
    <content type="html"><![CDATA[<p>前面我们了解了并行程序的基本概念和写法，这节课我们从更大的角度来思考，如何去设计一个并行架构。</p>
<a id="more"></a>
<hr>
<p>这节课会涉及大量架构和设计模式的内容，具体可以参考我另一门课程的笔记。</p>
<p>假如我们要设计一个自动语音识别系统，我们需要考虑的东西至少有：</p>
<ul>
<li>算法的实现</li>
<li>并行处理</li>
<li>软件架构</li>
<li>硬件架构</li>
</ul>
<blockquote>
<p>A parallel software pattern is genralizable solution to a class of recurring problems that occurs in the design of parallel software</p>
</blockquote>
<p>主要的设计目标有三个：</p>
<ul>
<li>Define a set of vocabularies to communicate</li>
<li>Present a set of expert techniques for beginners to learn</li>
<li>Allows experts to more quickly design complex systems</li>
</ul>
<p>大的组织架构如下：</p>
<p><img src="/images/14585015567179.jpg" alt="OPL: The Organization"></p>
<p>上图中可以看到，有两种模式：结构模式与计算模式</p>
<blockquote>
<p>Structual Patterns define the structure of the SW but not what is computed</p>
</blockquote>
<p><img src="/images/14585016310482.jpg" alt="Identifying the SW Structure"></p>
<p>一些例子：</p>
<ul>
<li>Pipe and Filter</li>
<li>Iterative Refinement</li>
<li>MapReduce</li>
<li>还有很多，具体参考 CMU 18653 的笔记</li>
</ul>
<blockquote>
<p>Computational patterns describe the key computation but not how they are implemented.</p>
</blockquote>
<p><img src="/images/14585017094760.jpg" alt="Identifying Key Computations"></p>
<p>一些例子：</p>
<ul>
<li>Linear Algebra</li>
<li>Spectral Methods</li>
<li>Dynamic Programming</li>
<li>还有很多，具体是偏领域相关的</li>
</ul>
<p>最后可以用一张图总结</p>
<p><img src="/images/14585019273135.jpg" alt="A Pattern Language for Parallel Programming"></p>
<p>不同的描述模式的语言有很多，这里使用的是 OPL，具体的网址在<a href="http://parlab.eecs.berkeley.edu/wiki/patterns/patterns" target="_blank" rel="external">这里</a></p>
<p>这部分知识对于理解整个架构的概念很有帮助，我会专门新开一个系列来介绍这里的内容。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面我们了解了并行程序的基本概念和写法，这节课我们从更大的角度来思考，如何去设计一个并行架构。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构设计" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[How to Write Fast Code 第 3 课 Manycore 编程]]></title>
    <link href="http://wdxtub.com/2016/03/20/fastcode-3/"/>
    <id>http://wdxtub.com/2016/03/20/fastcode-3/</id>
    <published>2016-03-20T15:02:37.000Z</published>
    <updated>2016-03-20T15:54:54.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们主要来了解一下基于 CUDA 平台的 GPU 编程。</p>
<a id="more"></a>
<hr>
<p>首先需要理解的概念就是，CPU 中的每个核都很强大，但是 GPU 中的每个核都比较弱。下面是一个很好的类比：</p>
<p><img src="/images/14584867243585.jpg" alt="Multicore and Manycore Differences"></p>
<p>换成更清晰的设计图，更能体现两者的不同：</p>
<p><img src="/images/14584867762217.jpg" alt="Fundamentally different design philosophy"></p>
<p>对于 CPU 来说，具体的优化是针对于减小若干线程的执行延迟的，包含复杂的指令控制和较大的缓存，每个核心能够以极高的速度执行单一线程。</p>
<p>对于 GPU 来说，目的是提高并行数量，主要目标是提高总体的吞吐量，而不是某个具体核心的性能。下面是一个简单的比较：</p>
<p><img src="/images/14584869755317.jpg" alt="Significant Architectural Difference"></p>
<p>什么时候适合使用 GPU 呢？</p>
<ul>
<li>极高的并行计算数量，比方说需要同时计算几千个节点的状态</li>
<li>计算时对内存带宽有极高的要求，因为 GPU 的内存更大更快，所以往往会有更好的性能</li>
</ul>
<h2 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h2><p>CUDA 的全程是 Compute Unified Device Architecture，是一个由 NVIDIA 开发的并行计算框架。整个计算的流程大概是：</p>
<p><img src="/images/14584873704074.jpg" alt=""></p>
<p>串行和简单的并行部分在 host 中完成，高度并行的代码在 GPU 的 kernel 中执行。</p>
<p>这里说一下，我们知道 GPU 本质工作还是计算图形相关的东西，所以其架构决定了每个内核只能执行非常有限的工作（例如着色器渲染器这类计算量大但是不复杂的工作），我们在利用 CUDA 编程的时候，实际上最终也还是类似于渲染画面之类的感觉，只是结果不是图像，而是具体的数据了。</p>
<h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p>关于 GPU 的架构，有一个很有趣的地方，就是对应的 memory hierarchy 和 CPU 是相反的，如：</p>
<p><img src="/images/14584875853095.jpg" alt="NVIDIA Fermi Architecture"></p>
<p>寄存器 &gt; L1 缓存 &gt; L2 缓存，这是为什么呢？是为了解决现在处理器的速度和内存的速度相差越来越大的问题：</p>
<p><img src="/images/14584876919855.jpg" alt="Inversion in Mem Hierarchy"></p>
<p>为了利用好这些缓存，Fermi 内核会维护 48 个 warp，每个 warp 是一个用于计算的 32 位 SIMD 向量。每个线程大约有 20 个寄存器，我们来算一下：</p>
<p>4(Bytes/register) x 20(Registers) x 32 (SIMD lanes) x 48 (Warps) = 128KB/core x 16 (core) = 2MB register files</p>
<p>这也就是为什么有 2MB 的寄存器大小了。</p>
<p>使用 warp 作为计算单位可以认为是为了简化 GPU 编程模型所做的设计（毕竟和 CPU 会有很大不同），前面我们也看到，不同的核心数目其实跟寄存器大小都是有关的，也就是说，GPU 编程仍然是一个非常硬件相关的工作：</p>
<p><img src="/images/14584880244271.jpg" alt="不同的硬件配置"></p>
<h2 id="Thread_Block"><a href="#Thread_Block" class="headerlink" title="Thread Block"></a>Thread Block</h2><p>为了配合不同的硬件，并行的工作实际上是以线程块的形式来组织的，下面的例子中，对于 2 个核心的 GPU，每次执行倆；对于 4 个核心的，每次执行四个：</p>
<p><img src="/images/14584881432861.jpg" alt="Thread Blocks"></p>
<p>然后我们来看看具体的数据是如何存储的。首先每个核心都有自己的存储，在同一个 SIMD lane 进行计算的核心可以通过内存读写来进行交流。</p>
<p><img src="/images/14584882728749.jpg" alt="Shared Memory/L1 Cache"></p>
<p> 对于 Fermi 架构的 GPU 来说，有两种不同的配置：</p>
<ul>
<li>48KB scratch pad (Shared Memory), 16KB L1 cache</li>
<li>16KB scratch pad (Shared Memory), 48KB L1 cache</li>
</ul>
<p>具体编程的部分这里不再一一赘述，只列出一些关键的要点，提醒大家注意：</p>
<ul>
<li>什么工作在 CPU 里做，什么工作在 GPU 里做？</li>
<li>如何高效使用共享内存？</li>
<li>如何给 GPU 指定具体的工作？</li>
<li>如何保证线程同步？</li>
<li>如何保证操作的原子性？</li>
</ul>
<p>具体的执行模型是：</p>
<p><img src="/images/14584884803363.jpg" alt="The CUDA Platform"></p>
<p>其中：</p>
<ul>
<li>NVCC 是编译器，会调用需要调用的各种程序</li>
<li>NVCC 会输出给 CPU 执行的 C 代码，还需要进一步编译</li>
<li>还会输出 PTX，是对象代码，直接在 GPU 上进行执行</li>
</ul>
<p>更多的内容可以参考官网的指引（比较有时效性）</p>
<h2 id="u6027_u80FD_u8003_u8651"><a href="#u6027_u80FD_u8003_u8651" class="headerlink" title="性能考虑"></a>性能考虑</h2><p>有三个考量，这里大概列出具体的思路，细节请大家自己探究：</p>
<ul>
<li>Maximizing Memory Throughput<ul>
<li>SoA vs AoS</li>
<li>Memory coalescing</li>
<li>Use of Shared memory</li>
<li>Memory bank conflict</li>
<li>Padding</li>
</ul>
</li>
<li>Maximizing Instruction Throughput<ul>
<li>尽量减少分支部分的代码</li>
<li>Loop unrolling </li>
</ul>
</li>
<li>Maximizing Scheduling Throughput<ul>
<li>对于数学运算，可以使用 GPU 相关的函数，如下图所示</li>
</ul>
</li>
</ul>
<p><img src="/images/14584888892692.jpg" alt="SoA vs AoS"></p>
<p>根据应用的不同设计，看看这两种结构到底哪种更加适合</p>
<p><img src="/images/14584890246660.jpg" alt="Device-only CUDA intrinsic functions"></p>
<p>这一部分的内容最重要的是实践，一定要通过不断尝试理解具体的概念，不然真的会发现自己完完全全是纸上谈兵！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们主要来了解一下基于 CUDA 平台的 GPU 编程。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="CUDA" scheme="http://wdxtub.com/tags/CUDA/"/>
    
      <category term="GPU" scheme="http://wdxtub.com/tags/GPU/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
