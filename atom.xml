<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-04-07T03:40:28.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 22 课 Concurrent Programming]]></title>
    <link href="http://wdxtub.com/2016/04/06/csapp-22/"/>
    <id>http://wdxtub.com/2016/04/06/csapp-22/</id>
    <published>2016-04-07T02:16:36.000Z</published>
    <updated>2016-04-07T03:40:28.000Z</updated>
    <content type="html"><![CDATA[<p>如果想要充分利用硬件资源，就要尽可能让计算机同时处理多项事务，具体是怎么实现的？又哪些基本的策略？这节课会一一解答。</p>
<a id="more"></a>
<hr>
<p>首先一定要清楚地意识到：『并行编程不简单』！最主要的原因恐怕就是我们自己的大脑，人脑实际上是一个非常精妙的系统，所采取的并行策略是一明一暗两条线，但是对于明线来说，是线性的，于是就和计算机中并行的概念冲突了。另外时间这个概念也是线性的，这就导致了想要处理好并行程序可能出现的各种问题几乎是不可能的（或者常常要出错）。</p>
<p>常见的错误有仨：竞争条件、死锁和活锁，具体如下：</p>
<p><img src="/images/14599962597558.jpg" alt="Classical problem classes"></p>
<h2 id="u670D_u52A1_u5668_u7684_u4F8B_u5B50"><a href="#u670D_u52A1_u5668_u7684_u4F8B_u5B50" class="headerlink" title="服务器的例子"></a>服务器的例子</h2><p>我们前面实现的服务器，一次只能处理一个请求，只有当前的请求处理完了，才能继续处理下一个。</p>
<p><img src="/images/14599976220466.jpg" alt=""></p>
<p>这里具体讲解一下：Client 1 向 Server 发送连接请求(connect)，Server 接受(accept)之后开始等待 Client 1 发送请求（也就是开始 read），这之后 Client 1 发送具体的内容(write)后转为等待响应(call read)，Server 的 read 接收到了内容之后，发送响应(write) 后仅需进入等待(read)，而 Client 1 接收到了响应(ret read)，最后根据用户指令退出(close)。</p>
<p>而只有当 Client 1 断开之后，Server 才会处理 Client 2 的请求，从图中也可以看到这一点。具体是在哪里等待呢？因为 TCP 会缓存，所以实际上 Client 2 在 <code>ret read</code> 之前进行等待，如：</p>
<p><img src="/images/14599992829071.jpg" alt="Where Does Second Client Block"></p>
<p>为了解决这个问题，我们可以使用并行的策略，同时处理不同客户端发来的请求。</p>
<h2 id="u5E76_u884C_u65B9_u6CD5"><a href="#u5E76_u884C_u65B9_u6CD5" class="headerlink" title="并行方法"></a>并行方法</h2><p>总体来说，根据系统机制的层级和实现方式，有下面三大类方法：</p>
<ol>
<li>基于进程<ul>
<li>内核自动管理多个逻辑流</li>
<li>每个进程有其私有的地址空间（也就是说进程切换的时候需要保存和载入数据）</li>
</ul>
</li>
<li>基于事件<ul>
<li>由程序员手动控制多个逻辑流</li>
<li>所有的逻辑流共享同一个地址空间</li>
<li>这个技术称为 I/O multiplexing</li>
</ul>
</li>
<li>基于线程<ul>
<li>内核自动管理多个逻辑流</li>
<li>每个线程共享地址空间</li>
<li>属于基于进程和基于事件的混合体</li>
</ul>
</li>
</ol>
<h3 id="u57FA_u4E8E_u8FDB_u7A0B"><a href="#u57FA_u4E8E_u8FDB_u7A0B" class="headerlink" title="基于进程"></a>基于进程</h3><h3 id="u57FA_u4E8E_u4E8B_u4EF6"><a href="#u57FA_u4E8E_u4E8B_u4EF6" class="headerlink" title="基于事件"></a>基于事件</h3><h3 id="u57FA_u4E8E_u7EBF_u7A0B"><a href="#u57FA_u4E8E_u7EBF_u7A0B" class="headerlink" title="基于线程"></a>基于线程</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>如果想要充分利用硬件资源，就要尽可能让计算机同时处理多项事务，具体是怎么实现的？又哪些基本的策略？这节课会一一解答。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="并行" scheme="http://wdxtub.com/tags/%E5%B9%B6%E8%A1%8C/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 21 课 Network Programming II]]></title>
    <link href="http://wdxtub.com/2016/04/06/csapp-21/"/>
    <id>http://wdxtub.com/2016/04/06/csapp-21/</id>
    <published>2016-04-06T11:34:02.000Z</published>
    <updated>2016-04-07T00:44:41.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们来学习如何编写 web 服务器！</p>
<a id="more"></a>
<hr>
<h2 id="u67B6_u6784_u603B_u89C8"><a href="#u67B6_u6784_u603B_u89C8" class="headerlink" title="架构总览"></a>架构总览</h2><p>写服务器，最重要的就是理清思路，上节课我们介绍了诸多概念，尤其是最后提到的 <code>getaddrinfo</code> 和 <code>getnameinfo</code>，都是我们在搭建过程中必不可少的工具。这里先借下图来介绍具体的实现思路：</p>
<p><img src="/images/14599728555354.jpg" alt=""></p>
<p>整个的工作流程有 5 步：</p>
<ol>
<li>开启服务器（<code>open_listenfd</code> 函数，做好接收请求的准备）<ul>
<li><code>getaddrinfo</code>: 设置服务器的相关信息，具体可以参见 图1&amp;2</li>
<li><code>socket</code>: 创建 socket descriptor，也就是之后用来读写的 file descriptor<ul>
<li><code>int socket(int domain, int type, int protocol)</code></li>
<li>例如 <code>int clientfd = socket(AF_INET, SOCK_STREAM, 0);</code></li>
<li><code>AF_INET</code> 表示在使用 32 位 IPv4 地址</li>
<li><code>SOCK_STREAM</code> 表示这个 socket 将是 connection 的 endpoint</li>
<li>前面这种写法是协议相关的，建议使用 <code>getaddrinfo</code> 生成的参数来进行配置，这样就是协议无关的了</li>
</ul>
</li>
<li><code>bind</code>: 请求 kernel 把 socket address 和 socket descriptor 绑定<ul>
<li><code>int bind(int sockfd, SA *addr, socklen_t addrlen);</code></li>
<li>The process can read bytes that arrive on the connection whose endpoint is <code>addr</code> by reading from descriptor <code>sockfd</code></li>
<li>Similarly, writes to <code>sockfd</code> are transferred along connection whose endpoint is <code>addr</code></li>
<li>最好是用 <code>getaddrinfo</code> 生成的参数作为 <code>addr</code> 和 <code>addrlen</code> </li>
</ul>
</li>
<li><code>listen</code>: 默认来说，我们从 <code>socket</code> 函数中得到的 descriptor 默认是 active socket（也就是客户端的连接），调用 <code>listen</code> 函数告诉 kernel 这个 socket 是被服务器使用的<ul>
<li><code>int listen(int sockfd, int backlog);</code></li>
<li>把 <code>sockfd</code> 从 active socket 转换成 listening socket，用来接收客户端的请求</li>
<li><code>backlog</code> 的数值表示 kernel 在接收多少个请求之后（队列缓存起来）开始拒绝请求</li>
</ul>
</li>
<li>[*]<code>accept</code>: 调用 <code>accept</code> 函数，开始等待客户端请求<ul>
<li><code>int accept(int listenfd, SA *addr, int *addrlen);</code></li>
<li>等待绑定到 <code>listenfd</code> 的连接接收到请求，然后把客户端的 socket address 写入到 <code>addr</code>，大小写入到 <code>addrlen</code></li>
<li>返回一个 connected descriptor 用来进行信息传输（类似 Unix I/O）</li>
<li>具体的过程可以参考 图3</li>
</ul>
</li>
</ul>
</li>
<li>开启客户端（<code>open_clientfd</code> 函数，设定访问地址，尝试连接）<ul>
<li><code>getaddrinfo</code>: 设置客户端的相关信息，具体可以参见 图1&amp;2</li>
<li><code>socket</code>: 创建 socket descriptor，也就是之后用来读写的 file descriptor</li>
<li><code>connect</code>: 客户端调用 <code>connect</code> 来建立和服务器的连接<ul>
<li><code>int connect(int clientfd, SA *addr, socklen_t addrlen);</code></li>
<li>尝试与在 socker address <code>addr</code> 的服务器建立连接</li>
<li>如果成功 <code>clientfd</code> 可以进行读写</li>
<li>connection 由 socket 对描述 <code>(x:y, addr.sin_addr:addr.sin_port)</code></li>
<li><code>x</code> 是客户端地址，<code>y</code> 是客户端临时端口，后面的两个是服务器的地址和端口</li>
<li>最好是用 <code>getaddrinfo</code> 生成的参数作为 <code>addr</code> 和 <code>addrlen</code> </li>
</ul>
</li>
</ul>
</li>
<li>交换数据（主要是一个流程循环，客户端向服务器写入，就是发送请求；服务器向客户端写入，就是发送响应）<ul>
<li>[Client]<code>rio_writen</code>: </li>
<li>[Client]<code>rio_readlineb</code>: </li>
<li>[Server]<code>rio_readlineb</code>:</li>
<li>[Server]<code>rio_writen</code>: </li>
</ul>
</li>
<li>关闭客户端（主要是 <code>close</code>）<ul>
<li>[Client]<code>close</code>:</li>
</ul>
</li>
<li>断开客户端（服务接收到客户端发来的 EOF 消息之后，断开已有的和客户端的连接）<ul>
<li>[Server]<code>rio_readlineb</code>:</li>
<li>[Server]<code>close</code>: </li>
</ul>
</li>
</ol>
<p><img src="/images/14599747281009.jpg" alt="图 1 Generic socket address"></p>
<p><img src="/images/14599747501489.jpg" alt="图 2 Socket Address Structures"></p>
<p><img src="/images/14599774536738.jpg" alt="图3 `accept` Illustrated"></p>
<blockquote>
<p>[Client]Connected Descriptor vs. [Server]Listening Descriptors</p>
</blockquote>
<p> 这两个的差别还是需要注意一下：</p>
<p> <img src="/images/14599776259093.jpg" alt=""></p>
<p>之所以要有这样的差别，是因为这样服务器可以同时处理多个请求（只要 fork 即可）</p>
<h2 id="u4EE3_u7801_u8BB2_u89E3"><a href="#u4EE3_u7801_u8BB2_u89E3" class="headerlink" title="代码讲解"></a>代码讲解</h2><blockquote>
<p>[Client] <code>open_clientfd</code></p>
</blockquote>
<p>用来建立和服务器的连接，协议无关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_clientfd</span><span class="params">(<span class="keyword">char</span> *hostname, <span class="keyword">char</span> *port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clientfd;</span><br><span class="line">    <span class="keyword">struct</span> addrinfo hints, *listp, *p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Get a list of potential server address</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">// Open a connection</span></span><br><span class="line">    hints.ai_flags = AI_NUMERICSERV; <span class="comment">// using numeric port arguments</span></span><br><span class="line">    hints.ai_flags |= AI_ADDRCONFIG; <span class="comment">// Recommended for connections</span></span><br><span class="line">    getaddrinfo(hostname, port, &amp;hints, &amp;listp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Walk the list for one that we can successfully connect to</span></span><br><span class="line">    <span class="comment">// 如果全部都失败，才最终返回失败（可能有多个地址）</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">// Create a socket descriptor</span></span><br><span class="line">        <span class="comment">// 这里使用从 getaddrinfo 中得到的参数，实现协议无关</span></span><br><span class="line">        <span class="keyword">if</span> ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</span><br><span class="line">                               p-&gt;ai_protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// Socket failed, try the next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Connect to the server</span></span><br><span class="line">        <span class="comment">// 这里使用从 getaddrinfo 中得到的参数，实现协议无关</span></span><br><span class="line">        <span class="keyword">if</span> (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Success</span></span><br><span class="line">        </span><br><span class="line">        close(clientfd); <span class="comment">// Connect failed, try another</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">// All connections failed</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// The last connect succeeded</span></span><br><span class="line">        <span class="keyword">return</span> clientfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[Server] <code>open_listenfd</code></p>
</blockquote>
<p>创建 listening descriptor，用来接收来自客户端的请求，协议无关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_listenfd</span><span class="params">(<span class="keyword">char</span> *port)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> addrinfo hints, *listp, *p;</span><br><span class="line">    <span class="keyword">int</span> listenfd, optval=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Get a list of potential server addresses</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">// Accept connection</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; <span class="comment">// on any IP address</span></span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV; <span class="comment">// using port number</span></span><br><span class="line">    <span class="comment">// 因为服务器不需要连接，所以原来填写地址的地方直接是 NULL</span></span><br><span class="line">    getaddrinfo(<span class="literal">NULL</span>, port, &amp;hints, &amp;listp); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Walk the list for one that we can successfully connect to</span></span><br><span class="line">    <span class="comment">// 如果全部都失败，才最终返回失败（可能有多个地址）</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">// Create a socket descriptor</span></span><br><span class="line">        <span class="comment">// 这里使用从 getaddrinfo 中得到的参数，实现协议无关</span></span><br><span class="line">        <span class="keyword">if</span> ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</span><br><span class="line">                               p-&gt;ai_protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// Socket failed, try the next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Eliminates "Address already in use" error from bind</span></span><br><span class="line">        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR), </span><br><span class="line">                    (<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;optval, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Bind the descriptor to the address</span></span><br><span class="line">        <span class="keyword">if</span> (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Success</span></span><br><span class="line">        </span><br><span class="line">        close(listenfd); <span class="comment">// Bind failed, try another</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">// No address worked</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Make it a listening socket ready to accept connection requests</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, LISTENQ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(listenfd);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一个简单的 socket 服务器实例</p>
<blockquote>
<p>Echo Client: Main Routine</p>
</blockquote>
<p>这个客户端做得事情很简单，就是把一段用户输入的文字发送到服务器，然后再把从服务器接收到的内容显示到输出中，具体可以参见注释</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// echoclient.c</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clientfd;</span><br><span class="line">    <span class="keyword">char</span> *host, *port, buf[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line">    </span><br><span class="line">    host = argv[<span class="number">1</span>];</span><br><span class="line">    port = argv[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建立连接（前面已经详细介绍）</span></span><br><span class="line">    clientfd = Open_clientfd(host, port);</span><br><span class="line">    Rio_readinitb(&amp;rio, clientfd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (Fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 写入，也就是向服务器发送信息</span></span><br><span class="line">        Rio_writen(clientfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="comment">// 读取，也就是从服务器接收信息</span></span><br><span class="line">        Rio_readlineb(&amp;rio, buf, MAXLINE);</span><br><span class="line">        <span class="comment">// 把从服务器接收的信息显示在输出中</span></span><br><span class="line">        Fputs(buf, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(clientfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative Echo Server: Main Rountine</p>
</blockquote>
<p>服务器做得工作也很简单，接收到从客户端发送的信息，然后返回一个一模一样的。具体参加注释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// echoserveri.c</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_storage clientaddr; <span class="comment">// Enough room for any addr</span></span><br><span class="line">    <span class="keyword">char</span> client_hostname[MAXLINE], client_port[MAXLINE];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启监听端口，注意只开这么一次</span></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要具体的大小</span></span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage); <span class="comment">// Important!</span></span><br><span class="line">        <span class="comment">// 等待连接</span></span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="comment">// 获取客户端相关信息</span></span><br><span class="line">        Getnameinfo((SA *) &amp;clientaddr, clientlen, client_hostname,</span><br><span class="line">                     MAXLINE, client_port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Connected to (%s, %s)\n"</span>, client_hostname, client_port);</span><br><span class="line">        <span class="comment">// 服务器具体完成的工作</span></span><br><span class="line">        echo(coonfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取从客户端传输过来的数据</span></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span>((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server received %d bytes\n"</span>, (<span class="keyword">int</span>)n);</span><br><span class="line">        <span class="comment">// 把从 client 接收到的信息再写回去</span></span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6D4B_u8BD5_u5DE5_u5177"><a href="#u6D4B_u8BD5_u5DE5_u5177" class="headerlink" title="测试工具"></a>测试工具</h2><p>测试的时候，我们可以使用 <code>telnet</code> 应用来测试服务器（只传输 ASCII 字符串的话，命令行工具无法显示图片），例如：</p>
<p>使用方法 <code>$ telnet &lt;host&gt; &lt;portnumber&gt;</code>，例如</p>
<p><img src="/images/14599877200828.jpg" alt="Testing Echo Server with `telnet`"></p>
<h2 id="Web__u670D_u52A1_u5668"><a href="#Web__u670D_u52A1_u5668" class="headerlink" title="Web 服务器"></a>Web 服务器</h2><p>客户端和服务器通过 HyperText Transfer Protocol(HTTP) 协议进行传输，具体的步骤是</p>
<ul>
<li>客户端和服务器建立 TCP 连接</li>
<li>客户端请求内容</li>
<li>服务器响应所请求的内容<ul>
<li>content: a sequence of bytes with an associated MIME (Multipurporse Internet Mail Extensions) types</li>
</ul>
</li>
<li>（最终）客户端和服务器关闭连接</li>
</ul>
<p><img src="/images/14599884494825.jpg" alt="Web Server Basics"></p>
<p>目前的版本是 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html" target="_blank" rel="external">HTTP/1.1 RFC 2616, June, 1999</a></p>
<p>一些 MIME 类型，更详细可见<a href="http://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank" rel="external">这里</a></p>
<ul>
<li><code>text/html</code> HTML document</li>
<li><code>text/plain</code> Unformatted text</li>
<li><code>image/gif</code> Binary image encoded in GIF format</li>
<li><code>image/png</code> Binary image encoded in PNG format</li>
<li><code>imgae/jpeg</code> Binary image encoded in JPEG format</li>
</ul>
<blockquote>
<p>静态内容与动态内容</p>
</blockquote>
<p>这部分比较简单，直接上图</p>
<p><img src="/images/14599890887501.jpg" alt=""></p>
<blockquote>
<p>URL 相关</p>
</blockquote>
<p>这部分比较简单，直接上图</p>
<p><img src="/images/14599891181741.jpg" alt=""></p>
<blockquote>
<p>HTTP Request</p>
</blockquote>
<p>这部分比较简单，直接上图</p>
<p><img src="/images/14599892040565.jpg" alt=""></p>
<blockquote>
<p>HTTP Responses</p>
</blockquote>
<p>这部分比较简单，直接上图</p>
<p><img src="/images/14599892360582.jpg" alt=""></p>
<blockquote>
<p>Example HTTP Transaction</p>
</blockquote>
<p><img src="/images/14599895910357.jpg" alt=""></p>
<p>剩下的概念主要是 CGI 应用，地址中 GET 表达形式，具体会在之后的习题课结合例子进行讲解，这里就不赘述了。不过还是要提一个重要概念：代理</p>
<blockquote>
<p>Proxies</p>
</blockquote>
<p><img src="/images/14599898580384.jpg" alt=""></p>
<p><img src="/images/14599898773522.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们来学习如何编写 web 服务器！</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="网络" scheme="http://wdxtub.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 20 课 Network Programming I]]></title>
    <link href="http://wdxtub.com/2016/04/06/csapp-20/"/>
    <id>http://wdxtub.com/2016/04/06/csapp-20/</id>
    <published>2016-04-06T11:33:58.000Z</published>
    <updated>2016-04-06T15:53:03.000Z</updated>
    <content type="html"><![CDATA[<p>网络已经成为了我们『智能』生活中最重要的一部分，这两节课我们会通过 C API 来了解具体的网络相关编程（用更高层次的封装只会更轻松！）</p>
<a id="more"></a>
<hr>
<h2 id="u7F51_u7EDC_u67B6_u6784"><a href="#u7F51_u7EDC_u67B6_u6784" class="headerlink" title="网络架构"></a>网络架构</h2><p>计算机网络的知识可谓是非常『保值』的，因为这么多基础设备还在运行着，基本机制在短时间内很难改变，关于网络的另一个版本的讲解在<a href="/./2016/02/10/internet-protocol/">这里</a>，我觉得也非常不错，大家感兴趣可以看看。</p>
<p>客户端-服务器模型是网络应用最广泛使用的模型，作为耳熟能详的概念，这里不多提，相信通过下图就能大致明白：</p>
<p><img src="/images/14599482011858.jpg" alt=""></p>
<p>网络相关的处理，都是通过网络适配器来完成的，具体在硬件上为：</p>
<p><img src="/images/14599482515878.jpg" alt="Hardware Organization of a Network Host"></p>
<p>根据应用范围和架构层级，可以分成三个部分：</p>
<ul>
<li>SAN - System Area Network<ul>
<li>Switched Ethernet, Quadrics QSW, …</li>
</ul>
</li>
<li>LAN - Local Area Network<ul>
<li>Ethernet, ..</li>
</ul>
</li>
<li>WAN - Wide Area Network<ul>
<li>High speed point-to-point phone lines</li>
</ul>
</li>
</ul>
<blockquote>
<p>最底层 - Ethernet Segment</p>
</blockquote>
<p>Ethernet segment consists of a collection of <strong>hosts</strong> connected by wires (twisted pairs) to a <strong>hub</strong>.</p>
<p>通常范围是房间或一层楼</p>
<p><img src="/images/14599485111822.jpg" alt="Ethernet Segment"></p>
<ul>
<li>每个 Ethernet 适配器有一个唯一的 48 位的地址（也就是 MAC 地址），例如 <code>00:16:ea:e3:54:e6</code></li>
<li>不同主机间发送的数据称为帧(frame)</li>
<li>Hub 会把每个端口发来的所有数据复制到其他的端口<ul>
<li>所有的主机都可以看到所有的数据（注意安全问题）</li>
</ul>
</li>
</ul>
<blockquote>
<p>下一层 - Bridged Ethernet Segment</p>
</blockquote>
<p><img src="/images/14599487658645.jpg" alt="Bridged Ethernet Segment"></p>
<p>通常范围是一层楼，通过不同的 bridge 来连接不同的 ethernet segment。Bridge 知道从某端口出发可达的主机，并有选择的在端口间复制数据。</p>
<p>为了从概念上简化，我们可以认为，所有的 hub, bridge 可以抽象为一条线，如下图所示：</p>
<p><img src="/images/14599488669806.jpg" alt="Conceptual View of LANs"></p>
<blockquote>
<p>下一层 - internets</p>
</blockquote>
<p>不同的（也许不兼容）的 LAN 可以通过 router 来进行物理上的连接，这样连接起来的网络称为 internet（注意是小写，大写的 Internet 可以认为是最著名的 internet）</p>
<p><img src="/images/14599491906184.jpg" alt="internets"></p>
<blockquote>
<p>internet 的逻辑结构</p>
</blockquote>
<p><img src="/images/14599492763163.jpg" alt="Logical Structure of an internet"></p>
<ul>
<li>Ad hoc interconnection of networks<ul>
<li>没有特定的拓扑结构</li>
<li>不同的 router 和 link 差异可能很大</li>
</ul>
</li>
<li>通过在不同的网络间跳转来传递 packet<ul>
<li>Router 是不同网络间的连接</li>
<li>不同的 packet 可能会走不同的路线</li>
</ul>
</li>
</ul>
<h2 id="u7F51_u7EDC_u534F_u8BAE"><a href="#u7F51_u7EDC_u534F_u8BAE" class="headerlink" title="网络协议"></a>网络协议</h2><p>在不同的 LAN 和 WAN 中传输数据，就要守规矩，这个规矩就是协议。协议负责做的事情有：</p>
<ul>
<li>提供 naming scheme<ul>
<li>定义 host address 格式</li>
<li>每个主机和路由器都至少有一个独立的 internet 地址</li>
</ul>
</li>
<li>提供 delivery mechanism<ul>
<li>定义了标准的传输单元 - packet</li>
<li>Packet 包含 header 和 payload<ul>
<li>header 包括 packet size, source 和 destination address</li>
<li>payload 包括需要传输的数据  </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在这样的协议下，具体的数据传输是：</p>
<p><img src="/images/14599502534733.jpg" alt="Transferring internet Data Via Encapsulation"></p>
<p>PH = Internet packet header, FH = LAN frame header</p>
<blockquote>
<p>Globle IP Internet(upper case)</p>
</blockquote>
<p>Internet 是 internet 最为著名的例子。主要基于 TCP/IP 协议族：</p>
<ul>
<li>IP (Internet Protocal)<ul>
<li>Provides <strong>basic naming scheme</strong> and unreliable <strong>delivery capability</strong> of packets (datagrams) from <strong>host-to-host</strong></li>
</ul>
</li>
<li>UDP (Unreliable Datagram Protocol)<ul>
<li>Uses IP to provide <strong>unreliable</strong> datagram delivery from <strong>process-to-process</strong></li>
</ul>
</li>
<li>TCP (Transmission Control Protocol)<ul>
<li>Uses IP to provide <strong>reliable</strong> byte streams from <strong>process-to-process</strong> over <strong>connections</strong></li>
</ul>
</li>
</ul>
<p>Accessed via a mix of Unix file I/O and functions from <strong>sockets interface</strong>.（很多东西不是很好翻译，用原文比较准确）</p>
<p><img src="/images/14599506938536.jpg" alt="Hardware and Software Organization of an Internet Application"></p>
<h2 id="Internet__u7684_u7A0B_u5E8F_u5458_u89C6_u89D2"><a href="#Internet__u7684_u7A0B_u5E8F_u5458_u89C6_u89D2" class="headerlink" title="Internet 的程序员视角"></a>Internet 的程序员视角</h2><ul>
<li>主机有 32 位的 IP 地址 - 23.235.46.133<ul>
<li>IPv4 - 32 位地址，IPv6 - 128 位地址</li>
</ul>
</li>
<li>IP 地址被映射到域名 - 23.235.46.133 映射到 www.wdxtub.com</li>
<li>不同主机之间的进程，可以通过 connection 来交换数据</li>
</ul>
<blockquote>
<p>IP 地址</p>
</blockquote>
<p>我们会用一个叫做 IP address stuct 的东西来存储，并且 IP 地址是以 network byte order（也就是大端）来进行存储的</p>
<p><img src="/images/14599515895838.jpg" alt="IP Address"></p>
<p>为了方便读，一般用下图的形式来进行表示：</p>
<p><img src="/images/14599516332783.jpg" alt=""></p>
<p>具体的转换可以使用 <code>getaddrinfo</code> 和 <code>getnameinfo</code> 函数</p>
<blockquote>
<p>Internet 域名</p>
</blockquote>
<p><img src="/images/14599516793840.jpg" alt="Internet Domain Names"></p>
<p>这里主要需要了解的就是 Domain Naming System(DNS) 的概念，用来做 IP 地址到域名的映射。具体可以用 <code>nslookup</code> 命令来查看，下面是一些例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">wdxtub.local</span><br><span class="line"></span><br><span class="line">$ nslookup www.wdxtub.com</span><br><span class="line">Server:		<span class="number">8.8</span>.<span class="number">8.8</span></span><br><span class="line">Address:	<span class="number">8.8</span>.<span class="number">8.8</span><span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.wdxtub.com	canonical name = wdxtub.github.io.</span><br><span class="line">wdxtub.github.io	canonical name = github.map.fastly.net.</span><br><span class="line">Name:	github.map.fastly.net</span><br><span class="line">Address: <span class="number">23.235</span>.<span class="number">39.133</span></span><br><span class="line"></span><br><span class="line">$ nslookup www.twitter.com</span><br><span class="line">Server:		<span class="number">8.8</span>.<span class="number">8.8</span></span><br><span class="line">Address:	<span class="number">8.8</span>.<span class="number">8.8</span><span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.twitter.com	canonical name = twitter.com.</span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: <span class="number">199.16</span>.<span class="number">156.6</span></span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: <span class="number">199.16</span>.<span class="number">156.198</span></span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: <span class="number">199.16</span>.<span class="number">156.230</span></span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: <span class="number">199.16</span>.<span class="number">156.70</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Internet Connections</p>
</blockquote>
<p>客户端和服务器通过 connection 来发送字节流，特点是：</p>
<ul>
<li>Point-to-point: 连接一对进程</li>
<li>Full-duplex: 数据同时可以在两个方向流动</li>
<li>Reliable: 字节的发送的顺序和收到的一致</li>
</ul>
<p>Socket 则可以认为是 connection 的 endpoint，socket 地址是一个 <code>IPaddress:port</code> 对。</p>
<p>Port（端口）是一个 16 位的整数，用来标识不同的进程：</p>
<ul>
<li>Ephemeral port: Assigned automatically by client kernel when client makes a connection request</li>
<li>Well-known port: Associated with some <strong>service</strong> provided by a server（在 linux 系统上可以在 <code>/etc/services</code> 中查看具体的信息）<ul>
<li>echo server: 7/echo</li>
<li>ssh server: 22/ssh</li>
<li>email server: 25/smtp</li>
<li>web servers: 80/http</li>
</ul>
</li>
</ul>
<blockquote>
<p>Connection 详解</p>
</blockquote>
<p>A connection is uniquely identified by the socket addresses of its endpoints(socket pair - cliaddr:cliport, servaddr: servport)</p>
<p><img src="/images/14599531325600.jpg" alt="Anatomy of a Connection"></p>
<p>利用不同的端口来连接不同的服务：</p>
<p><img src="/images/14599534610996.jpg" alt="Using Ports to Identify Services"></p>
<blockquote>
<p>Socket Interface</p>
</blockquote>
<p>一系列系统级的函数，和 Unix I/O 配合构造网络应用（在所有的现代操作系统上都可用）。</p>
<p>对于 kernel 来说，socket 是 endpoint of communication；对于应用程序来说，socket 是 file descriptor，用来读写（回忆一下，STDIN 和 STDOUT 也是 file descriptor）。客户端和服务器通过读写对应的 socket descriptor 来进行。</p>
<p><img src="/images/14599559864957.jpg" alt=""></p>
<p>The main distinction between regular file I/O and socket I/O is how the application “opens” the socket descriptors.</p>
<blockquote>
<p>Generic socket address</p>
</blockquote>
<p><img src="/images/14599561357752.jpg" alt=""></p>
<blockquote>
<p>Internet-specific socket address</p>
</blockquote>
<p>实际上占用同样的空间，但是有更详细的信息</p>
<p><img src="/images/14599561803255.jpg" alt=""></p>
<p>总体的流程为：</p>
<p><img src="/images/14599565974716.jpg" alt=""></p>
<h2 id="u5E38_u7528_u51FD_u6570"><a href="#u5E38_u7528_u51FD_u6570" class="headerlink" title="常用函数"></a>常用函数</h2><p>接下来直接用 PPT 介绍两个重要函数 <code>getaddrinfo</code> 和 <code>getnameinfo</code></p>
<blockquote>
<p>getaddrinfo</p>
</blockquote>
<p>用来把 hostname, host address, port, service name 的字符串表示转换成 socket address 结构。</p>
<p><img src="/images/14599569037369.jpg" alt=""></p>
<p>函数原型为：</p>
<p><img src="/images/14599569254580.jpg" alt=""></p>
<p>这里具体说一下 <code>result</code> 这个链表：</p>
<p><img src="/images/14599569748746.jpg" alt="Linked List Returned by `getaddrinfo`"></p>
<p> 客户端需要遍历这个列表，按顺序访问每个 socket address，直到 <code>socket</code> 和 <code>connect</code> 函数调用成功。</p>
<p> 服务器需要遍历这个列表，直到 <code>socket</code> 和  <code>bind</code> 函数调用成功</p>
<p>每个 <code>addrinfo</code> 结构体为</p>
<p><img src="/images/14599573080061.jpg" alt="addrinfo Struct"></p>
<blockquote>
<p>getnameinfo</p>
</blockquote>
<p>刚好和 <code>getaddrinfo</code> 相反，把 socket address 转换成对应的字符串信息，函数原型为</p>
<p><img src="/images/14599575876044.jpg" alt=""></p>
<p>举个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hostinfo.c</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> addrinfo *p, *listp, hints;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> rc, flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Get a list of addrinfo records</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_family = AF_INET; <span class="comment">// IPv4 only</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">// Connections only</span></span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(argv[<span class="number">1</span>], <span class="literal">NULL</span>, &amp;hints, &amp;listp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"getaddrinfo error: %s\n"</span>, gai_strerror(rc));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Walk the list and display each IP address</span></span><br><span class="line">    flags = NI_NUMERICHOST; <span class="comment">// Display address instead of name</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        getnameinfo(p-&gt;ai_addr, p-&gt;ai_addrlen, buf, MAXLINE, <span class="literal">NULL</span>, <span class="number">0</span>, flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>网络已经成为了我们『智能』生活中最重要的一部分，这两节课我们会通过 C API 来了解具体的网络相关编程（用更高层次的封装只会更轻松！）</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="网络" scheme="http://wdxtub.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker 碎碎念]]></title>
    <link href="http://wdxtub.com/2016/04/03/docker-gossip/"/>
    <id>http://wdxtub.com/2016/04/03/docker-gossip/</id>
    <published>2016-04-03T19:14:10.000Z</published>
    <updated>2016-04-03T22:35:01.000Z</updated>
    <content type="html"><![CDATA[<p>这篇日志主要来自 Docker 的应用及部署实践，算是从感性的角度来了解 Docker。</p>
<a id="more"></a>
<hr>
<p>以 Docker 为代表的容器技术模糊了 IaaS 与 PaaS 之间的界限，为云计算的服务形式带来了一个开放的未来。</p>
<p>一些言论：</p>
<ul>
<li>对 Docker 大规模应用到生产环境需要谨慎，但是仅考虑测试和开发，是可以真正解决环境部署问题的好办法</li>
<li>将所有服务放在一个容器叫做 Fat Container</li>
<li>Docker 天然适合一个容器只运行一种服务（官方更推荐）<ul>
<li>为每个服务创建单独文件夹，并在每个文件夹下放一个 Dockerfile</li>
</ul>
</li>
<li>每个容器只运行单一服务，容器间的互相通信有两种办法：<ul>
<li>将容器端口绑定到一个本地端口，通过端口通讯</li>
<li>通过 Docker 提供的 Linking 功能，推荐使用 Docker-Compose</li>
</ul>
</li>
<li>当前容器技术面临的最大阻力是安全问题和管理工具</li>
<li>学习 Docker 的三个阶段<ul>
<li>Docker 本身功能的使用</li>
<li>驾驭 Docker 集群（使用 Kubernetes, Shipyard, Machine+Swarm+Compose）</li>
<li>为场景和业务深度定制</li>
</ul>
</li>
<li>Docker 面临的最大阻碍 <ul>
<li>Docker 所属公司本身的强势，想做一揽子事情的态度，这使得 Docker 现在非常臃肿</li>
<li>不要把眼光局限在 Docker 上面，让 Docker 只做容器的事情</li>
</ul>
</li>
</ul>
<blockquote>
<p>除非你不想做，不想做就算了，想做好的话就不可能不劳而获</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">差劲的叛逆者</th>
<th style="text-align:center">优秀的叛逆者</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">抱怨</td>
<td style="text-align:center">创造</td>
</tr>
<tr>
<td style="text-align:center">断言</td>
<td style="text-align:center">质疑</td>
</tr>
<tr>
<td style="text-align:center">关注个人</td>
<td style="text-align:center">关注任务</td>
</tr>
<tr>
<td style="text-align:center">悲观</td>
<td style="text-align:center">乐观</td>
</tr>
<tr>
<td style="text-align:center">愤怒</td>
<td style="text-align:center">热情</td>
</tr>
<tr>
<td style="text-align:center">耗费能量</td>
<td style="text-align:center">生成能量</td>
</tr>
<tr>
<td style="text-align:center">疏离</td>
<td style="text-align:center">吸引</td>
</tr>
<tr>
<td style="text-align:center">问题</td>
<td style="text-align:center">可能性</td>
</tr>
<tr>
<td style="text-align:center">抱怨问题</td>
<td style="text-align:center">寻找机会</td>
</tr>
<tr>
<td style="text-align:center">担心</td>
<td style="text-align:center">希冀</td>
</tr>
<tr>
<td style="text-align:center">指责他人</td>
<td style="text-align:center">指出原因</td>
</tr>
<tr>
<td style="text-align:center">困扰</td>
<td style="text-align:center">反抗</td>
</tr>
<tr>
<td style="text-align:center">说教</td>
<td style="text-align:center">倾听</td>
</tr>
</tbody>
</table>
<p>成功叛逆者的秘密</p>
<table>
<thead>
<tr>
<th style="text-align:left">策略：实现特定目标的行动</th>
<th style="text-align:left">行为：你的行为举止，特别是对他人时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">利用他人的才华，明白没人能独自完成意义重大的改变</td>
<td style="text-align:left">保持乐观，鼓舞他人加入解决问题的行列</td>
</tr>
<tr>
<td style="text-align:left">将自己的想法和组织的目标统一起来</td>
<td style="text-align:left">评论想法，不评论人；讨论想法和想法的价值</td>
</tr>
<tr>
<td style="text-align:left">展现改变带来的好处与代价相称</td>
<td style="text-align:left">从愤怒中学习：思考是什么引发了愤怒，避免陷入情绪闹剧</td>
</tr>
<tr>
<td style="text-align:left">有效利用冲突：探究分歧和冲突，学习如何完善和推进一个想法</td>
<td style="text-align:left">尊重他人并考虑不同的观点</td>
</tr>
<tr>
<td style="text-align:left">不操之过急：给他人实践来接受新想法并思考它的影响</td>
<td style="text-align:left">知道何时该放弃坚持，懂得权衡想法的重要性和固执的代价</td>
</tr>
</tbody>
</table>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.wolonge.com/zhuanlan/detail/117441" target="_blank" rel="external">Docker在PHP项目开发环境中的应用</a></li>
<li><a href="http://news.oneapm.com/mesos-docker-go/" target="_blank" rel="external">通过 Mesos、Docker 和 Go，使用 300 行代码创建一个分布式系统</a></li>
<li>《Docker 开发实践》</li>
<li>《Docker——容器与容器云》</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇日志主要来自 Docker 的应用及部署实践，算是从感性的角度来了解 Docker。</p>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://wdxtub.com/tags/Docker/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="平台" scheme="http://wdxtub.com/tags/%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker 基本概念]]></title>
    <link href="http://wdxtub.com/2016/04/03/docker-basic-concept/"/>
    <id>http://wdxtub.com/2016/04/03/docker-basic-concept/</id>
    <published>2016-04-03T10:03:09.000Z</published>
    <updated>2016-04-03T17:56:32.000Z</updated>
    <content type="html"><![CDATA[<p>在 <a href="/./2016/04/02/docker-first-step/">Docker 快速入门及试验环境配置</a>中我们通过一个例子简单了解了 docker 的使用。这篇文章会从基本概念出发，用实际操作去更加深入理解 docker。</p>
<a id="more"></a>
<hr>
<p>具体的安装部分这里不赘述，可以在 <a href="/./2016/04/02/docker-first-step/">Docker 快速入门及试验环境配置</a> 的『安装』部分找到。</p>
<p>先大概复习一下基本概念：</p>
<p>主要是三个：</p>
<ul>
<li>镜像(Image)<ul>
<li>一个只读的模板，镜像可以用来创建 Docker 容器</li>
<li>可以简单创建或更新现有镜像，或者直接下载使用其他人的</li>
</ul>
</li>
<li>容器(Container)<ul>
<li>容器是从镜像创建的运行实例，在启动的时候创建一层可写层作为最上层（因为镜像是只读的）</li>
<li>可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台</li>
<li>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序</li>
</ul>
</li>
<li>仓库(Repository)<ul>
<li>集中存放镜像文件的场所</li>
<li>最大的公开仓库是 <a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a></li>
<li>国内的公开仓库包括 <a href="http://www.dockerpool.com/" target="_blank" rel="external">Docker Pool</a> 等</li>
<li>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了</li>
<li>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务</li>
</ul>
</li>
</ul>
<h2 id="u955C_u50CF"><a href="#u955C_u50CF" class="headerlink" title="镜像"></a>镜像</h2><p>我们可以使用 <code>docker pull</code> 命令从仓库中获取所需要的镜像。比如说 <code>sudo docker pull ubuntu:12.04</code>，相当于 <code>sudo docker pull registry.hub.docker.com/ubuntu:12.04</code>，即从注册服务器 <code>registry.hub.docker.com</code> 中的 <code>ubuntu</code> 仓库来下载标记为<code>12.04</code> 的镜像。</p>
<p>如果想从其他仓库注册服务器下载，需要输入完成的地址，例如：<code>sudo docker pull dl.dockerpool.com:5000/ubuntu:12.04</code></p>
<p>下载完成之后就可以使用该镜像了，比如下面的语句就会创建容器，其中运行 <code>bash</code>：<code>sudo docker run -t -i ubuntu:12.04 /bin/bash</code></p>
<p>可以使用 <code>dokcer images</code> 来显示本地已有的镜像，如下</p>
<p><img src="/images/14596963929829.jpg" alt="docker images"></p>
<p>具体字段的意思一目了然，这里不再赘述。然后我们来运行官方例子 <code>whalesay</code> 镜像。</p>
<h3 id="u8FD0_u884C_u955C_u50CF"><a href="#u8FD0_u884C_u955C_u50CF" class="headerlink" title="运行镜像"></a>运行镜像</h3><p>打开浏览器，进入 <a href="https://hub.docker.com/?utm_source=getting_started_guide&amp;utm_medium=embedded_Linux&amp;utm_campaign=find_whalesay" target="_blank" rel="external">Docker Hub</a></p>
<p><img src="/images/14596967621449.jpg" alt="Docker Hub"></p>
<p>搜索 <code>whalesay</code> 这个镜像，就可以看到结果，点进去可以看到详细内容（基于 Ubuntu）</p>
<p><img src="/images/14596968187418.jpg" alt="whalesay image"></p>
<p>然后我们来运行一下，使用命令 <code>docker run docker/whalesay cowsay boo</code>，其中 <code>cowsay</code> 是要运行的命令，后面的 <code>boo</code> 是参数。</p>
<p>Docker 会先在本地查找有没有镜像，如果没有就从仓库中下载，具体的运行结果是：</p>
<p><img src="/images/14596971019958.jpg" alt="cowsay boo"></p>
<p>也可以让鲸鱼说不同的话，比如：</p>
<p><img src="/images/14596971443647.jpg" alt=""></p>
<h3 id="u5236_u4F5C_u955C_u50CF"><a href="#u5236_u4F5C_u955C_u50CF" class="headerlink" title="制作镜像"></a>制作镜像</h3><p>如果想要制作自己的镜像，需要自己写 Dockerfile。具体步骤如下</p>
<ol>
<li>创建一个文件夹 <code>mkdir wdxtub; cd wdxtub</code>，构造镜像所需的所有东西都会放在这个文件夹中</li>
<li>创建一个名为 <code>Dockerfile</code> 的文件 <code>gedit Dockerfile</code></li>
<li>添加第一句话 <code>FROM docker/whalesay:latest</code>，表示我们的镜像以 <code>whalesay</code> 为基础</li>
<li>添加需要运行的命令，如 <code>RUN apt-get -y update &amp;&amp; apt-get install -y fortunes</code>（<code>fortunes</code> 这个程序会输出名言警句）</li>
<li>通过 <code>CMD</code> 指定镜像载入之后需要执行的命令，如 <code>CMD /usr/games/fortune -a | cowsay</code></li>
<li>保存并关闭 Dockerfile</li>
<li>使用 <code>sudo docker build -t wdx-whale .</code> 来构造镜像，简单来说就是用 Dockerfile 中的内容按步骤构造</li>
<li>使用 <code>docker images</code> 应该就可以看到我们新创建的镜像</li>
</ol>
<p><img src="/images/14596980285832.jpg" alt="wdx-whale image"></p>
<p>然后我们就可以运行一下看看 <code>docker run wdx-whale</code></p>
<p><img src="/images/14596980932968.jpg" alt="搞笑句"></p>
<p>还有更贱的（感觉可以玩一天）</p>
<p><img src="/images/14596987783177.jpg" alt=""></p>
<p>如果想要把自己的镜像上传到网上，就需要注册一个 Docker Hub 帐号，然后点击 Create Repository，这里我创建了一个名为 <code>wdxtub/demo</code> 的公用仓库。</p>
<p>接下来我们需要打上 tag，目前 <code>docker images</code> 的情况是：</p>
<p><img src="/images/14596980285832.jpg" alt="wdx-whale image"></p>
<p>记住我们的 IMAGE ID 26ac9649d7da。用以下命令打 tag <code>docker tag 26ac9649d7da wdxtub/wdx-whale:latest</code>，然后再 <code>docker images</code> 一次：</p>
<p><img src="/images/14596998719751.jpg" alt=""></p>
<p>然后用这个命令登录 <code>docker login --username=yourhubusername --email=youremail@company.com</code>，对于我来说就是 <code>docker login --username=wdxtub --email=dacrocodilee@gmail.com</code></p>
<p>成功之后大概是这样：</p>
<p><img src="/images/14596999803535.jpg" alt="登录成功"></p>
<p>然后就可以 push 上去了 <code>docker push wdxtub/wdx-whale</code>，像下面这样</p>
<p><img src="/images/14597002872580.jpg" alt="push"></p>
<p>为了测试 pull 自己的镜像，我们先把本地上的 whale 镜像删掉：<code>docker rmi -f wdxtub/wdx-whale; docker rmi -f wdx-whale</code>（如果有其他的用不着的也都删掉），最后剩下（上课要用的镜像）：</p>
<p><img src="/images/14597004851281.jpg" alt=""></p>
<p>接着来运行一下 <code>docker run wdxtub/wdx-whale</code></p>
<h3 id="u7BA1_u7406_u955C_u50CF"><a href="#u7BA1_u7406_u955C_u50CF" class="headerlink" title="管理镜像"></a>管理镜像</h3><p>我们可以把镜像导出到本地文件，使用 <code>docker save</code> 命令即可，比如针对我现在有的镜像 <code>wdxtub/wdx-whale(id:26ac9649d7da)</code>，可以这样：<code>docker save -o wdx-local-whale.tar wdxtub/wdx-whale</code>。如果要载入的话，使用下面的命令即可（会载入相关的元数据信息）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker load --input wdx-local-whale.tar</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker load &lt; wdx-local-whale.tar</span><br></pre></td></tr></table></figure>
<p>在删除镜像之前要先用 <code>docker rm</code> 删掉依赖于这个镜像的所有容器.</p>
<p><code>sudo docker rmi $(docker images -q -f &quot;dangling=true&quot;)</code></p>
<blockquote>
<p>镜像的实现原理</p>
</blockquote>
<p>Docker 镜像是怎么实现增量的修改和维护的？ 每个镜像都由很多层次构成，Docker 使用 <a href="http://en.wikipedia.org/wiki/UnionFS" target="_blank" rel="external">Union FS</a> 将这些不同的层结合到一个镜像中去。</p>
<p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。 Docker 在 AUFS 上构建的容器也是利用了类似的原理。</p>
<h2 id="u5BB9_u5668"><a href="#u5BB9_u5668" class="headerlink" title="容器"></a>容器</h2><p>容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>
<p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器（对于初级应用来说后者更方便）。</p>
<p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<p>可以利用 <code>docker start</code> 命令，直接将一个已经终止的容器启动运行。<br>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p>
<h3 id="u542F_u52A8"><a href="#u542F_u52A8" class="headerlink" title="启动"></a>启动</h3><p>举个例子，我们来创建一个 ubuntu:14.04 的容器 <code>docker run ubuntu:14.04 /bin/echo &#39;Hello wdx!&#39;</code></p>
<p><img src="/images/14597044909422.jpg" alt=""></p>
<p>用 <code>docker run -t -i ubuntu:14.04 /bin/bash</code> 可以启动一个 bash 终端用来交互。其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。我们可以输入一些命令来测试</p>
<p><img src="/images/14597046071804.jpg" alt=""></p>
<p>我们用 <code>ps</code> 或 <code>top</code> 在伪终端中查看进程信息，可以看到：</p>
<p><img src="/images/14597046832387.jpg" alt=""></p>
<p>输入 <code>exit</code> 可以退出 docker</p>
<p>容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p>
<h3 id="u540E_u53F0_u8FD0_u884C"><a href="#u540E_u53F0_u8FD0_u884C" class="headerlink" title="后台运行"></a>后台运行</h3><p>更多的时候，需要让 Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。</p>
<p>下面举两个例子来说明一下。</p>
<p>如果不使用 -d 参数运行容器 <code>docker run ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code> 容器会把输出的结果(STDOUT)打印到宿主机上面</p>
<p><img src="/images/14597048507796.jpg" alt=""></p>
<p>如果使用了 -d 参数运行容器 <code>docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code>，则显示是这样：</p>
<p><img src="/images/14597049156842.jpg" alt=""></p>
<p>使用 <code>docker logs containerid</code> 可以查看输出，如：</p>
<p><img src="/images/14597049744299.jpg" alt=""></p>
<p>使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker ps 命令来查看容器信息。容器是否会长久运行，是和docker run指定的命令有关，和 -d 参数无关</p>
<p>在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作，有很多种方法，包括使用 docker attach 命令或 nsenter 工具等。具体参考<a href="https://yeasy.gitbooks.io/docker_practice/content/container/enter.html" target="_blank" rel="external">这里</a></p>
<h3 id="u7EC8_u6B62_u4E0E_u91CD_u65B0_u542F_u52A8"><a href="#u7EC8_u6B62_u4E0E_u91CD_u65B0_u542F_u52A8" class="headerlink" title="终止与重新启动"></a>终止与重新启动</h3><p>使用 <code>docker stop containerid</code> 来终止容器。终止状态的容器可以用 <code>docker ps -a</code> 命令看到。</p>
<p>另外，<code>docker restart containerid</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h3 id="u5BFC_u5165_u5BFC_u51FA_u4E0E_u5220_u9664"><a href="#u5BFC_u5165_u5BFC_u51FA_u4E0E_u5220_u9664" class="headerlink" title="导入导出与删除"></a>导入导出与删除</h3><p>如果要导出本地某个容器，可以使用 <code>docker export containerid</code> 命令。</p>
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat ubuntu.tar | sudo docker import - <span class="built_in">test</span>/ubuntu:v1.<span class="number">0</span></span><br><span class="line"><span class="comment"># 也可以通过指定 URL 或者某个目录来导入，例如</span></span><br><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>
<p>用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<p>可以使用 <code>docker rm</code> 来删除一个处于终止状态的容器。如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</p>
<p>用 <code>docker ps -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用 <code>docker rm $(docker ps -a -q)</code> 可以全部清理掉。</p>
<p>注意：这个命令其实会试图删除所有的包括还在运行中的容器，不过就像上面提过的<code>docker rm</code> 默认并不会删除运行中的容器。</p>
<h2 id="u4ED3_u5E93"><a href="#u4ED3_u5E93" class="headerlink" title="仓库"></a>仓库</h2><p>仓库（Repository）是集中存放镜像的地方。</p>
<p>一个容易混淆的概念是注册服务器（Registry）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址dl.dockerpool.com/ubuntu 来说，dl.dockerpool.com 是注册服务器地址，ubuntu是仓库名。</p>
<p>大部分时候，并不需要严格区分这两者的概念。相信信息可以直接看教程，这里不赘述了。</p>
<ul>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/dockerhub.html" target="_blank" rel="external">Docker Hub 指南</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/local_repo.html" target="_blank" rel="external">私有仓库指南</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/config.html" target="_blank" rel="external">配置文件指南</a></li>
</ul>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="/Find and run the whalesay image">Find and run the whalesay image</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/image/create.html" target="_blank" rel="external">创建镜像</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/container/enter.html" target="_blank" rel="external">进入容器</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 <a href="/./2016/04/02/docker-first-step/">Docker 快速入门及试验环境配置</a>中我们通过一个例子简单了解了 docker 的使用。这篇文章会从基本概念出发，用实际操作去更加深入理解 docker。</p>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://wdxtub.com/tags/Docker/"/>
    
      <category term="概念" scheme="http://wdxtub.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker 快速入门及试验环境配置]]></title>
    <link href="http://wdxtub.com/2016/04/02/docker-first-step/"/>
    <id>http://wdxtub.com/2016/04/02/docker-first-step/</id>
    <published>2016-04-03T00:11:29.000Z</published>
    <updated>2016-04-04T00:48:18.000Z</updated>
    <content type="html"><![CDATA[<p>借着课程的机会来了解一下 Docker，大部分内容来自官方文档以及课程指引。</p>
<a id="more"></a>
<hr>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Docker 最初 dotCloud 公司内部的一个业余项目</li>
<li>Docker 基于 Go 语言</li>
<li>Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案</li>
<li>Docker 的基础是 Linux 容器（LXC）等技术</li>
<li>Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多</li>
<li>Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器</li>
</ul>
<p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</p>
<p><img src="/images/14596424862659.png" alt=""></p>
<p><img src="/images/14596424920098.png" alt=""></p>
<p>容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。</p>
<p>主要优势为：</p>
<ul>
<li>更快速的交付和部署 - 容器成为了最小单位</li>
<li>更高效的虚拟化 - 内核级虚拟化</li>
<li>更轻松的迁移和拓展</li>
<li>更简单的管理</li>
</ul>
<h2 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h2><p>主要是三个：</p>
<ul>
<li>镜像(Image)<ul>
<li>一个只读的模板，镜像可以用来创建 Docker 容器</li>
<li>可以简单创建或更新现有镜像，或者直接下载使用其他人的</li>
</ul>
</li>
<li>容器(Container)<ul>
<li>容器是从镜像创建的运行实例，在启动的时候创建一层可写层作为最上层（因为镜像是只读的）</li>
<li>可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台</li>
<li>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序</li>
</ul>
</li>
<li>仓库(Repository)<ul>
<li>集中存放镜像文件的场所</li>
<li>最大的公开仓库是 <a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a></li>
<li>国内的公开仓库包括 <a href="http://www.dockerpool.com/" target="_blank" rel="external">Docker Pool</a> 等</li>
<li>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了</li>
<li>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务</li>
</ul>
</li>
</ul>
<h2 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h2><p>官方网站提供了 <a href="https://docs.docker.com/mac/" target="_blank" rel="external">Mac</a>, <a href="https://docs.docker.com/linux/" target="_blank" rel="external">Linux</a> 和 <a href="https://docs.docker.com/windows/" target="_blank" rel="external">Windows</a> 版本的安装教程。因为我打算使用虚拟机进行安装测试，所以这里主要走 Linux 的安装教程，不过其他的应该大同小异。我的 ubuntu 版本是 14.04 LTS, trusty</p>
<p>Docker 目前只能安装在 64 位平台上，并且要求内核版本不低于 3.10，实际上内核越新越好，过低的内核版本容易造成功能的不稳定。可以通过下面的命令来检查内核版本（两个方式，都可以）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parallels@ubuntu:~$ uname <span class="operator">-a</span>Linux ubuntu <span class="number">3.13</span>.<span class="number">0</span>-<span class="number">83</span>-generic <span class="comment">#127-Ubuntu SMP Fri Mar 11 00:25:37 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line">parallels@ubuntu:~$ cat /proc/versionLinux version <span class="number">3.13</span>.<span class="number">0</span>-<span class="number">83</span>-generic (buildd@lgw01-<span class="number">55</span>) (gcc version <span class="number">4.8</span>.<span class="number">2</span> (Ubuntu <span class="number">4.8</span>.<span class="number">2</span>-<span class="number">19</span>ubuntu1) ) <span class="comment">#127-Ubuntu SMP Fri Mar 11 00:25:37 UTC 2016</span></span><br></pre></td></tr></table></figure>
<p>这里我们按照官网的教程，不使用 <code>apt-get</code> 而是使用 <code>curl</code> 来进行安装。</p>
<ol>
<li>如果没有安装 <code>curl</code>，使用 <code>sudo apt-get update; sudo apt-get install curl</code> 来进行安装</li>
<li>下载最新的 Docker 包 <code>curl -fsSL https://get.docker.com/ | sh</code><ul>
<li>如果想要以 non-root 用户的角色来使用，请使用 <code>sudo usermod -aG docker parallels</code>（这里 <code>parallels</code> 是用户名），注意需要注销并重新登录以应用改动</li>
</ul>
</li>
<li>验证安装<ul>
<li>需要先启用 docker <code>sudo service docker start</code></li>
<li>然后可以用 <code>docker version</code> 来查看版本</li>
<li>最后使用 <code>docker run hello-world</code> 来测试</li>
</ul>
</li>
</ol>
<p>版本信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parallels@ubuntu:~$ docker versionClient: Version:      <span class="number">1.10</span><span class="number">.3</span> API version:  <span class="number">1.22</span> Go version:   go1<span class="number">.5</span><span class="number">.3</span> Git commit:   <span class="number">20f</span>81dd Built:        Thu Mar <span class="number">10</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">52</span> <span class="number">2016</span> OS/Arch:      linux/amd64Server: Version:      <span class="number">1.10</span><span class="number">.3</span> API version:  <span class="number">1.22</span> Go version:   go1<span class="number">.5</span><span class="number">.3</span> Git commit:   <span class="number">20f</span>81dd Built:        Thu Mar <span class="number">10</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">52</span> <span class="number">2016</span> OS/Arch:      linux/amd64</span><br></pre></td></tr></table></figure>
<p>成功运行 hello world 的结果</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parallels@ubuntu:~$ docker run hello-worldHello <span class="built_in">from</span> Docker.This message shows that your installation appears <span class="built_in">to</span> be working correctly.To generate this message, Docker took <span class="operator">the</span> following steps: <span class="number">1.</span> The Docker client contacted <span class="operator">the</span> Docker daemon. <span class="number">2.</span> The Docker daemon pulled <span class="operator">the</span> <span class="string">"hello-world"</span> image <span class="built_in">from</span> <span class="operator">the</span> Docker Hub. <span class="number">3.</span> The Docker daemon created <span class="operator">a</span> <span class="built_in">new</span> container <span class="built_in">from</span> that image which runs <span class="operator">the</span>    executable that produces <span class="operator">the</span> output you are currently reading. <span class="number">4.</span> The Docker daemon streamed that output <span class="built_in">to</span> <span class="operator">the</span> Docker client, which sent <span class="keyword">it</span>    <span class="built_in">to</span> your terminal.To <span class="keyword">try</span> something more ambitious, you can run <span class="operator">an</span> Ubuntu container <span class="operator">with</span>: $ docker run -<span class="keyword">it</span> ubuntu bashShare images, automate workflows, <span class="operator">and</span> more <span class="operator">with</span> <span class="operator">a</span> free Docker Hub account: <span class="keyword">https</span>://hub.docker.comFor more examples <span class="operator">and</span> ideas, visit: <span class="keyword">https</span>://docs.docker.com/userguide/</span><br></pre></td></tr></table></figure>
<p>这之后的部分是课程需求。</p>
<p>我们需要安装 docker machine 和 virtual box，具体步骤为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取权限</span></span><br><span class="line">$ sudo su</span><br><span class="line"><span class="comment"># 下载 Docker Machine 的二进制文件 </span></span><br><span class="line">$ curl -L https://github.com/docker/machine/releases/download/v0.<span class="number">6.0</span>/docker-machine-`uname <span class="operator">-s</span>`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-machine &amp;&amp; chmod +x /usr/<span class="built_in">local</span>/bin/docker-machine</span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">$ docker-machine version</span><br><span class="line">docker-machine version <span class="number">0.6</span>.<span class="number">0</span>, build e27fb87</span><br></pre></td></tr></table></figure>
<ul>
<li>添加源<ul>
<li>把这行添加到 <code>/etc/apt/sources.list</code> 文件中 <code>deb http://download.virtualbox.org/virtualbox/debian trusty contrib</code> </li>
<li><code>wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add -</code></li>
</ul>
</li>
<li>更新并安装 <code>sudo apt-get update; sudo apt-get install virtualbox-5.0</code></li>
</ul>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2><p>然后是一些配置，先重设默认的虚拟机 </p>
<ul>
<li>删除原来的默认（如果有的话）<code>docker-machine rm default</code></li>
<li>创建新的默认虚拟机 <code>docker-machine create --driver virtualbox default</code>（这一步可能需要等一下，我用的是 Parallel Desktop 11，还需要在虚拟机设置中开启 CPU 虚拟化，主要是支持 vt-x）</li>
</ul>
<p>然后如果直接在菜单中选择 Virtual Box 的话，就会发现什么都没有，技巧是要在刚才的命令行中输入 <code>virtualbox</code>，然后就可以看到下面的界面：</p>
<p><img src="/images/14596481872848.jpg" alt="default 就是我们刚才创建的虚拟机"></p>
<p>在 Settings - Network 中选择 Port Forwarding，然后按照如图所示添加记录</p>
<p><img src="/images/14596485001418.jpg" alt=""></p>
<p>这里的 Host Port: 9234 记为 A，Guest Port: 9001 记为 B。然后就可以启动 docker 中老师提供的镜像了：</p>
<p>命令为 <code>docker run -it -p 9001:9000 cmusvsc/apachecmda:1.1</code>（需要下载一段时间，然后再解压一段时间），这里 9001 记为 C，9000 记为 D。</p>
<p>接着就会直接连接到 docker 中的虚拟机，从之后的图中可以看到命令行前面的内容也变化了。然后我们输入命令开启前端 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/Spring2016/ApacheCMDA-Frontend</span><br><span class="line">./activator run <span class="comment"># 相当于在 9000 端口开启</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/14596510005751.jpg" alt="开启前端"></p>
<p>不要关现在的终端，开启一个新的终端。仍然 <code>docker run -it -p 9001:9000 cmusvsc/apachecmda:1.1</code></p>
<p>等待一段时间后，继续走以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/Spring2016/ApacheCMDA-Backend</span><br><span class="line">./activator <span class="string">"run 9034"</span></span><br></pre></td></tr></table></figure>
<p>然后可以见到 </p>
<p><img src="/images/14596503095705.jpg" alt="开启后端"></p>
<p>然后等待一段时间（第一运行需要编译），就可以见到主页面了：</p>
<p><img src="/images/14596510450895.jpg" alt="主界面"></p>
<p>还记得前面的端口转发吗？这里解释一下：</p>
<ul>
<li>A，也就是 9234，是用户访问的端口号</li>
<li>B，也就是 9001，我们通过虚拟机的端口转发从 9234 转到了 9001</li>
<li>C，也就是 9001（这个命令中的 <code>docker run -it -p 9001:9000 cmusvsc/apachecmda:1.1</code>），是虚拟机继续转发的端口</li>
<li>D，也就是 9000（这个命令中的 <code>docker run -it -p 9001:9000 cmusvsc/apachecmda:1.1</code>），是 Docker 容器中接收请求的端口。</li>
</ul>
<p>也就是说，B 和 C 一定要一样，A 和 D 可以在命令中设置。至于为什么后端需要运行在 9034 端口，是因为前端和后端通过这个端口通讯（应该是写死在代码里的）</p>
<p>挂载主机数据卷到容器内，可以通过如下命令进行文件夹映射</p>
<p><code>docker run -it -p 9999:9999 -p 9001:9000 -v ~/localFolder:/sharedFolder cmusvsc/apachecmda:1.1</code></p>
<p>从容器内拷贝文件到主机上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出 container</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 复制 这个不知道为啥不行</span></span><br><span class="line">docker cp &lt;containerId&gt;:/file/path/within/container /host/path/target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载映射</span></span><br><span class="line">docker run -it -v /home/parallels/Documents/code:/home/code cmusvsc/apachecmda:<span class="number">1.1</span></span><br><span class="line"><span class="comment"># 复制</span></span><br><span class="line">cp -r Spring2016/* ./code/</span><br></pre></td></tr></table></figure>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/docker/docker" target="_blank" rel="external">开源代码</a></li>
<li><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a></li>
<li><a href="https://docs.docker.com/machine/install-machine/" target="_blank" rel="external">Install Docker Machine</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>借着课程的机会来了解一下 Docker，大部分内容来自官方文档以及课程指引。</p>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://wdxtub.com/tags/Docker/"/>
    
      <category term="容器" scheme="http://wdxtub.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第十二周 - 正趣果上果]]></title>
    <link href="http://wdxtub.com/2016/04/02/the-fun/"/>
    <id>http://wdxtub.com/2016/04/02/the-fun/</id>
    <published>2016-04-02T12:58:28.000Z</published>
    <updated>2016-04-02T14:44:39.000Z</updated>
    <content type="html"><![CDATA[<p>人生在世三万天，趣果有间孤独无解，苦练含笑半步颠。心怀啮雪大志愿，被人称作小可怜。本欲歃血定风月，乌飞兔走光阴只负尾生约。</p>
<a id="more"></a>
<hr>
<p>习惯了没有四季的广州，在四季分明的匹兹堡，真的能感受到生机勃勃的味道。不过这都是用六个月的寒冬换来的，如果可以选的话，我宁愿放弃四季。虽然温差依然可以二十多度，好歹下午是可以开开心心去跑跑步了。离开之前，多看几眼。</p>
<p>对一个地方的感情，其实和在这个地方交到的朋友和自己的改变程度有关。在执信我既经历了自我的重大转变，也交到了许多挚友，理所当然是我感情密度最高的地方。</p>
<p>相对来说，在匹兹堡的这段时间，以另外的方式认识了很多朋友，也真正完成了一直以来想要完成的转身。华丽不华丽不知道，虽然还有这样那样的小问题，总体来说我是满意的。</p>
<p>陆陆续续在收拾行李，发现其实也没有多少要带回去的东西，因为一直都是以『游子』的心态在过日子，大件的东西不买，可能用到=不用，带不走的直接送人，轻轻来轻轻走。年年毕业季，年年卖闲置，我觉得为了几块钱几十块钱劳神费力真不值得，还不如以交朋友的心态直接送给有缘人。</p>
<p>慢慢熟悉了英文歌的套路之后，现在又开始听中文歌了，但是口味变了不少。从陈粒 Jam 程璧常石磊到屠洪刚韩磊刘欢，除了旋律之外，越来越在意歌词讲不讲究。除了标题是陈粒的『正趣果上果』外，我还想安利几首：</p>
<blockquote>
<p>给少年的歌 程璧</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">月亮悄悄蒙上一层纱 夜云悄悄隆起崖</span><br><span class="line">曾经年少的我啊 曾经痴心这么想</span><br><span class="line">如果有一天 如果有一个人</span><br><span class="line">陪我一起看花开 陪我一起看流霞</span><br><span class="line">我就想为谁 为谁唱起这首歌</span><br><span class="line">一首少年的歌 一首为你写的歌</span><br></pre></td></tr></table></figure>
<blockquote>
<p>晴日共剪窗 程璧</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">庭前花木满 院外小径芳</span><br><span class="line">四时常相往 晴日共剪窗</span><br></pre></td></tr></table></figure>
<blockquote>
<p>七月上 Jam</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我想你就站在，站在大漠边疆</span><br><span class="line">我想你就站在，站在七月上</span><br><span class="line">我化尘埃飞扬，追寻赤裸逆翔</span><br><span class="line">奔去七月刑场，时间烧灼滚烫</span><br><span class="line">回忆撕毁臆想，路上行走匆忙</span><br><span class="line">难能可贵世上，散播留香磁场</span><br></pre></td></tr></table></figure>
<blockquote>
<p>老爸 常石磊</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我在牵挂 你也在牵挂 是你引我走天涯</span><br><span class="line">你慢慢老 我渐渐长大 是你让我别想家</span><br><span class="line">你在牵挂 我也在牵挂 是你教我志在四方 什么都别怕 </span><br><span class="line">我不在家 你好好保重吧</span><br></pre></td></tr></table></figure>
<p>未来的选择，和选择的未来，更多是计划之后的顺其自然。</p>
<p>正趣果上果，归依天中天，一道长死生，有无离二边。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>人生在世三万天，趣果有间孤独无解，苦练含笑半步颠。心怀啮雪大志愿，被人称作小可怜。本欲歃血定风月，乌飞兔走光阴只负尾生约。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="反思" scheme="http://wdxtub.com/tags/%E5%8F%8D%E6%80%9D/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="选择" scheme="http://wdxtub.com/tags/%E9%80%89%E6%8B%A9/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Prolog 快速入门]]></title>
    <link href="http://wdxtub.com/2016/04/01/prolog-first-step/"/>
    <id>http://wdxtub.com/2016/04/01/prolog-first-step/</id>
    <published>2016-04-02T01:02:45.000Z</published>
    <updated>2016-04-02T15:45:43.000Z</updated>
    <content type="html"><![CDATA[<p>Prolog 是一门声明式编程语言，也是最早成功的逻辑编程语言之一。只需提供 fact 和 inference，程序会替我们进行推断。甚至不需要知道怎么做，只要告诉计算机要做什么即可。比方说，用不到 20 行代码解决数独问题。</p>
<a id="more"></a>
<hr>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><ul>
<li>1972 年由 Alain Colmerauer 和 Phillipe Roussel 开发完成</li>
<li>基于数据库，数据由逻辑规则和关系组成</li>
<li>包含两个部分：一部分用于描述数据，另一部分用于查询数据</li>
</ul>
<p>在 Prolog 中，数据以逻辑规则的形式存在，下面是基本构建单元：</p>
<ul>
<li>事实：关于真实世界的基本断言（Babe 是一头猪，猪喜欢泥巴）</li>
<li>规则：关于真实世界中的一些事实的推论（如果一个动物是猪，那么它喜欢泥巴）</li>
<li>查询：关于真实世界的一个问题（Babe 喜欢泥巴吗）</li>
</ul>
<p>事实和规则被放入一个知识库(knowledge base)。Prolog 编译器将这个知识库编译成一种适于高效查询的形式。</p>
<p>这里我们在 ubuntu 下做实验，直接 <code>sudo apt-get install gprolog</code> 即可</p>
<h2 id="u7F16_u7A0B_u6A21_u578B"><a href="#u7F16_u7A0B_u6A21_u578B" class="headerlink" title="编程模型"></a>编程模型</h2><p>Prolog 中，一个词以小写字母开头，就是一个原子(atom)——类似于 Ruby 中的符号(symbol)的固定值，如果一个词以大写字母或下划线开头，那么它就是一个变量。变量的值可以改变，原则则不能。</p>
<p>下面是一个简单的例子，先创建一个文件（比如 <code>friends.pl</code>），输入以下内容</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">likes</span>(<span class="atom">wallace</span>, <span class="atom">cheese</span>).</span><br><span class="line"><span class="atom">likes</span>(<span class="atom">grommit</span>, <span class="atom">cheese</span>).</span><br><span class="line"><span class="atom">likes</span>(<span class="atom">wendolene</span>, <span class="atom">sheep</span>).</span><br><span class="line"></span><br><span class="line"><span class="atom">friend</span>(<span class="name">X</span>, <span class="name">Y</span>) :- \+(<span class="name">X</span> = <span class="name">Y</span>), <span class="atom">likes</span>(<span class="name">X</span>, <span class="name">Z</span>), <span class="atom">likes</span>(<span class="name">Y</span>, <span class="name">Z</span>).</span><br></pre></td></tr></table></figure>
<p>上面这个文件就是由事实和规则组成的知识库。前三条语句是事实，最后一条语句是一个规则。<code>wallace</code>, <code>grommit</code> 和 <code>wendolene</code> 都是原子，翻译过来就是</p>
<ul>
<li><code>wallace</code> 喜欢 <code>cheese</code></li>
<li><code>grommit</code> 喜欢 <code>cheese</code></li>
<li><code>wendolene</code> 喜欢 <code>sheep</code></li>
</ul>
<p>具体执行时，先输入 <code>gprolog</code>，然后输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- [<span class="string">'friends.pl'</span>].compiling /home/parallels/Documents/friends.pl <span class="keyword">for</span> byte code.../home/parallels/Documents/friends.pl compiled, <span class="number">5</span> lines <span class="built_in">read</span> - <span class="number">976</span> bytes written, <span class="number">6</span> ms(<span class="number">1</span> ms) yes</span><br></pre></td></tr></table></figure>
<p>除非 Prolog 在等待一个中间结果，否则都会用 <code>yes</code> 或者 <code>no</code> 来回应，这一句里文件加载成功，所以返回 <code>yes</code>。而 <code>| ?-</code> 是命令前面的提示符，类似于命令行前的 <code>$</code>，不过这么有个性的，我还是第一次见</p>
<p>然后我们就可以让计算机自己进行逻辑推断了，比如：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- <span class="atom">likes</span>(<span class="atom">wallace</span>, <span class="atom">sheep</span>).<span class="atom">no</span></span><br></pre></td></tr></table></figure>
<p>通过前面的条件我们知道，并不能推断出 wallace 喜欢 sheep，所以返回 no。</p>
<blockquote>
<p>基本推论和变量</p>
</blockquote>
<p>来测试以下前面的 <code>friend</code> 规则：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| ?- <span class="atom">friend</span>(<span class="atom">wallace</span>, <span class="atom">wallace</span>).<span class="atom">no</span></span><br><span class="line">| ?- <span class="atom">friend</span>(<span class="atom">grommit</span>, <span class="atom">wallace</span>).<span class="atom">yes</span>| ?- <span class="atom">friend</span>(<span class="atom">wallace</span>, <span class="atom">grommit</span>).<span class="atom">yes</span></span><br></pre></td></tr></table></figure>
<p>我们来用自然语言翻译一下 <code>friend</code> 规则</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">friend</span>(<span class="name">X</span>, <span class="name">Y</span>) :- \+(<span class="name">X</span> = <span class="name">Y</span>), <span class="atom">likes</span>(<span class="name">X</span>, <span class="name">Z</span>), <span class="atom">likes</span>(<span class="name">Y</span>, <span class="name">Z</span>).</span><br></pre></td></tr></table></figure>
<p>如果 <code>X</code> 和 <code>Y</code> 是朋友，那么 X 就不能与 Y 相同。<code>:-</code> 右边的称为子目标(subgoal)。<code>\+</code> 是逻辑取反操作，所以第一个子目标 <code>\+(X=Y)</code> 的意思是 <code>X</code> 不等于 <code>Y</code>。后面的 <code>likes</code> 语句表示如果 <code>X</code> 喜欢 <code>Z</code>，并且 <code>Y</code> 也喜欢 <code>Z</code>，所以后面的子目标就是在 <code>X</code> 不等于 <code>Y</code> 的情况下，他们还喜欢同一个 <code>Z</code>。我们可以试验以下其他的组合，来看看 prolog 的工作机制。</p>
<p>上面的代码是一个具有三个变量 <code>X</code>, <code>Y</code> 和 <code>Z</code> 的 Prolog 规则，称为 <code>friend/2</code> 表示参数有 2 个，这个规则有三个子目标（条件）。只有都满足的时候，规则才为真。</p>
<blockquote>
<p>填空</p>
</blockquote>
<p>我们还可以利用 prolog 查询出所有可能的匹配，这时候我们就需要一个变量，打开一个新的文件 <code>food.pl</code>，并填入下面的代码：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">food_type</span>(<span class="atom">velveeta</span>, <span class="atom">cheese</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">ritz</span>, <span class="atom">cracker</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">spam</span>, <span class="atom">meat</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">sausage</span>, <span class="atom">meat</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">jolt</span>, <span class="atom">soda</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">twinkie</span>, <span class="atom">dessert</span>).</span><br><span class="line"></span><br><span class="line"><span class="atom">flavor</span>(<span class="atom">sweet</span>, <span class="atom">dessert</span>).</span><br><span class="line"><span class="atom">flavor</span>(<span class="atom">savory</span>, <span class="atom">meat</span>).</span><br><span class="line"><span class="atom">flavor</span>(<span class="atom">savory</span>, <span class="atom">cheese</span>).</span><br><span class="line"><span class="atom">flavor</span>(<span class="atom">sweet</span>, <span class="atom">soda</span>).</span><br><span class="line"></span><br><span class="line"><span class="atom">food_flavor</span>(<span class="name">X</span>, <span class="name">Y</span>) :- <span class="atom">food_type</span>(<span class="name">X</span>, <span class="name">Z</span>), <span class="atom">flavor</span>(<span class="name">Y</span>, <span class="name">Z</span>).</span><br></pre></td></tr></table></figure>
<p>其中 <code>food_type(velveeta, cheese)</code> 意思是 <code>velveeta</code> 属于 <code>cheese</code> 类食物；而 <code>flavor(sweet, dessert)</code> 则表示 <code>sweet</code> 是 <code>dessert</code> 的味道。最后的规则的意思是如果食物 <code>X</code> 属于类别 <code>Z</code> 并且 <code>Z</code> 的味道是 <code>Y</code>，那么食物 <code>X</code> 具有 <code>food_flavor</code> <code>Y</code>。编译一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- [<span class="string">'food.pl'</span>].compiling /home/parallels/Documents/food.pl <span class="keyword">for</span> byte code.../home/parallels/Documents/food.pl compiled, <span class="number">13</span> lines <span class="built_in">read</span> - <span class="number">1536</span> bytes written, <span class="number">5</span> msyes</span><br></pre></td></tr></table></figure>
<p>然后我们来问几个问题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- food_<span class="built_in">type</span>(What, meat).What = spam ? ;What = sausage ? ;no</span><br></pre></td></tr></table></figure>
<p>这里 prolog 会先找到 <code>spam</code>，然后输入 <code>;</code>，prolog 就会继续寻找下一个，也就是返回 <code>sausage</code>，继续输入 <code>;</code>，会发现返回了 <code>no</code>，这表示在未经更多计算的情况下不能判断是否还有更多选项。</p>
<p>另一个问题可以是 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- food_flavor(What, savory).What = velveeta ? ;What = spam ? ;What = sausage ? ;no</span><br></pre></td></tr></table></figure>
<p>这里要注意 <code>food_flavor(X,Y)</code> 是一个规则，而不是事实，逻辑引擎会遍历所有使目标为真的可能组合。</p>
<h2 id="u4E60_u9898"><a href="#u4E60_u9898" class="headerlink" title="习题"></a>习题</h2><h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://fengdidi.github.io/blog/2011/11/15/di-1zhang-pei-zhi-kai-fa-huan-jing/" target="_blank" rel="external">笨办法学Prolog</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Prolog 是一门声明式编程语言，也是最早成功的逻辑编程语言之一。只需提供 fact 和 inference，程序会替我们进行推断。甚至不需要知道怎么做，只要告诉计算机要做什么即可。比方说，用不到 20 行代码解决数独问题。</p>]]>
    
    </summary>
    
      <category term="Prolog" scheme="http://wdxtub.com/tags/Prolog/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="语言" scheme="http://wdxtub.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Io 快速入门]]></title>
    <link href="http://wdxtub.com/2016/04/01/io-first-step/"/>
    <id>http://wdxtub.com/2016/04/01/io-first-step/</id>
    <published>2016-04-01T15:33:13.000Z</published>
    <updated>2016-04-02T01:02:26.000Z</updated>
    <content type="html"><![CDATA[<p>原型语言我接触得其实非常少，Io 和 JavaScript/Lua 一样，每个对象都是另一个对象的复制品。这部分暂时我的兴趣不是特别大，所以简要记录一下，以后有兴趣再学。</p>
<a id="more"></a>
<hr>
<ul>
<li>Io 语言于 2002 年由 Steve Dekorte 发明</li>
<li>基于原型的语言，每个对象都不是类的复制品</li>
<li>带有微型虚拟机和丰富并发特性的可嵌入语言来推广</li>
<li>拥有大量可定制语法和函数，以及强有力的并发模型</li>
<li>万事万物皆为消息，且每条消息都会返回另一接收消息的对象</li>
<li>没有关键字，只有少量在行为上接近于关键字的字符</li>
</ul>
<h2 id="u7F16_u7A0B_u6A21_u578B"><a href="#u7F16_u7A0B_u6A21_u578B" class="headerlink" title="编程模型"></a>编程模型</h2><blockquote>
<p>优势</p>
</blockquote>
<ul>
<li>灵活，可以快速创建出想要的语法</li>
<li>强大的、现代的并发库</li>
<li>占用空间小，但功能强大且灵活，应用在嵌入式领域</li>
<li>语法简洁，灵活</li>
</ul>
<blockquote>
<p>劣势</p>
</blockquote>
<ul>
<li>社区规模小</li>
<li>单线程性能较差</li>
</ul>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://iolanguage.org/" target="_blank" rel="external">官方网站</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>原型语言我接触得其实非常少，Io 和 JavaScript/Lua 一样，每个对象都是另一个对象的复制品。这部分暂时我的兴趣不是特别大，所以简要记录一下，以后有兴趣再学。</p>]]>
    
    </summary>
    
      <category term="Io" scheme="http://wdxtub.com/tags/Io/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="语言" scheme="http://wdxtub.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聪明人的枷锁]]></title>
    <link href="http://wdxtub.com/2016/03/31/smart-lock/"/>
    <id>http://wdxtub.com/2016/03/31/smart-lock/</id>
    <published>2016-03-31T18:31:02.000Z</published>
    <updated>2016-04-01T04:23:31.000Z</updated>
    <content type="html"><![CDATA[<p>小聪明到大智慧之间，有一条看不见的横沟，只能用天赋、坚持和勤奋来填。如果硬要说有技巧，恐怕就是『元学习』、『元思考』、『元实践』和『元创造』。</p>
<a id="more"></a>
<hr>
<h2 id="u806A_u660E_u4E86_u5417_uFF1F"><a href="#u806A_u660E_u4E86_u5417_uFF1F" class="headerlink" title="聪明了吗？"></a>聪明了吗？</h2><p>聪明固然是一件好事，但是一旦被别人被自己贴上了『聪明人』的标签，也就戴上了枷锁。外在的枷锁随着时间的推移逐渐会被移去，但是内在的枷锁，想要解开，就没那么容易了。</p>
<p>内在的枷锁主要体现在以下两个方面：</p>
<ol>
<li>做事情凭借直觉，大多数情况下都能完成得不错。可是直觉也有范围，一旦超出，因为平时没有培养正确做事的能力，往往不尽如人意。</li>
<li>做事情依赖个人，在学生时代作业考试甚至是小组项目都可以自己扛，可是个人能力再大也有范围，一旦超出，因为平时没有培养合作的能力，常常功亏一篑。</li>
</ol>
<p>直觉是可以培养的，合作是可以学习的。小聪明若是想要转变为大智慧，得利用自己的聪明，用不依赖聪明的方法，在正确做事的前提下，扩大自己的直觉范围，优化自己的合作机制。</p>
<p>遗憾的是，市面上大部分的书，到这里就结束了，剩下的不是猛灌鸡汤，就是列举一堆『看起来有用但是实际没用』的技巧，基本属于作者自己都没想明白就出来忽悠。</p>
<p>这篇文章想说的就是各类畅销书没说清楚的东西：</p>
<ol>
<li>正确学习的方法</li>
<li>正确思考的方法</li>
<li>正确实践的方法</li>
<li>正确创造的方法</li>
</ol>
<p>就像大贤得出世再入世一样，想要成为『大智慧』，首先得有点『小聪明』。注意，这里的『小聪明』和大家通常理解的不一样，指的是相对于『大』智慧的『小』聪明，而不是原来略带贬义的意思。成为『小聪明』的第一步，就是认清自己的思维模式，要想以聪明的方式思考问题，就得善用自己的长处，认识并完善自己的弱点。</p>
<p>另外正如《穷查理宝典》中所说的那样：『我们必须掌握许多知识，让它们在头脑中形成一个思维框架，在随后的日子里能自动地运用它们。与之相反，如果不努力去实践这种跨科学的方法，许多最聪明的人只会取得中等成就，甚至生活在阴影中』。</p>
<h2 id="u6B63_u786E_u5B66_u4E60"><a href="#u6B63_u786E_u5B66_u4E60" class="headerlink" title="正确学习"></a>正确学习</h2><blockquote>
<p>Data is not information. Information is not knowledge. Knowledge is not expertise. Expertise is not execution.</p>
</blockquote>
<p>广义来说，所有的学习都是自学，毕竟没有任何一种科技可以直接把知识『灌输』到我们脑中，即使有老师，我们仍然需要自己去学习。当我仔细审视『自学能力』的时候，发现有以下几个重要的组成部分：</p>
<ul>
<li>阅读能力 - 基础技能 <ul>
<li>广泛阅读，略读结合精读</li>
</ul>
</li>
<li>理解能力 - 在阅读能力基础上的初级技能<ul>
<li>提取核心思想，按照章节逻辑堆阅读进行总结</li>
</ul>
</li>
<li>检索能力 - 在理解能力基础上的中级技能<ul>
<li>围绕核心思想，寻找相关材料，从多方面看问题</li>
</ul>
</li>
<li>写作能力 - 由输入到输出的重要技能<ul>
<li>写作实际上是一个思考的过程。把思维中的想法用文字写下来，本身就是一个整理、分类的过程</li>
</ul>
</li>
<li>思考能力 - 在写作能力基础上的高级技能<ul>
<li>勤于琢磨思考该事情的目标、实质、意义，而后再据此去思考做好这件事情的方法，并挖掘出更深层次的意义</li>
</ul>
</li>
<li>实践能力 - 把学习转化为价值的核心技能<ul>
<li>能够举一反三，能把所学应用于实践，并根据实际情况调整前进的方向</li>
</ul>
</li>
</ul>
<p>一定要脱离『学霸/学渣』的思维定式。学校的教育体系本来就是有缺陷的，我们需要做的就是通过自学能力，去弥补那些自己感兴趣但学校从未教授的东西。这样看来，我们应该成为『沙盒游戏』中的『自由探索者』，不要限定自己的角色，也不要被学校、专业所限制。多学科视角的思考方法能产生某种「共奏效应」，发现原本无法发现的深度见解。</p>
<p>学习关于学习本身的知识，就是元学习。</p>
<h2 id="u6B63_u786E_u601D_u8003"><a href="#u6B63_u786E_u601D_u8003" class="headerlink" title="正确思考"></a>正确思考</h2><blockquote>
<p>So avoid the temptation to master all the skills you need before taking on a challenge. </p>
</blockquote>
<p>应试教育，或者说以考试制度为核心的教育体系中，学生会自然而然被灌输『标准答案』的概念，写对有分写错没分，每个问题对应一个标准答案就被植入到我们的脑中。小聪明可能可以每次都填上标准答案，但大智慧会以标准答案为起点，开始探索的旅程。</p>
<p>差异在哪里？在于『思考无固定答案』的习惯。把纸上的问题映射到现实问题中，培养独立思考的能力，得到自己的答案。这里有一点需要强调，就是『独立』。思考时不要依靠网络，毕竟思考是思考，搜索是搜索。如果总是依赖网络，一旦遇到搜不出来的情况，就很难找到解决办法了。</p>
<p>当然，在有了自己的思考之后，还是需要借助搜索的力量，更加全面地看待问题。这个过程中千万不能『囫囵吞枣』，信息需要经过考虑、推敲后才能转化为想法。不同人看待同样的信息角度不同，得出的结论也不同，相信自己的判断，确认信息，独立思考，不能偷懒。我们还需要时刻拥抱不确定性，越是不习惯，越是要让自己站在正反两面去思考分析问题。</p>
<p>思考的时候一定要有的放矢，意识流看起来很美，但是不利于交流，思考的输出应当是他人容易重视、记住和接受的，也就是要有：</p>
<ul>
<li>逻辑推理能力 - 论点分解或总结</li>
<li>时间管理能力 - 区分优先性</li>
<li>交流能力 - 加强说服力</li>
</ul>
<p>至于思考的结果是对是错，反而不是重要的。一旦出现错误时，要学会追踪当初的思维轨迹，找到哪里出了差错，经验——错误的归纳模式是人类最根本也最可靠的学习方法。</p>
<p>思考关于思考本身的东西，就是元思考。</p>
<h2 id="u6B63_u786E_u5B9E_u8DF5"><a href="#u6B63_u786E_u5B9E_u8DF5" class="headerlink" title="正确实践"></a>正确实践</h2><blockquote>
<p>Whenever you can, as long as the water’s not too far over your head, just jump in, and figure it out as you go.</p>
</blockquote>
<p>知行合一，可能是正确实践的终极奥义。在实践的过程中，一定要时不时问自己下面几个问题：</p>
<ul>
<li>正在解决的问题是我需要解决的问题吗？<ul>
<li>沿着正确的方向前行通常并不会花很多时间，方向不清的情况下走冤枉路却是白费工夫</li>
</ul>
</li>
<li>为什么要这样做，这是最好的方式吗？<ul>
<li>实践过程中会出各种小差错，要从这些差错中学习并提高实践能力</li>
</ul>
</li>
<li>能不能利用前辈的经验减少重复劳动？<ul>
<li>太阳底下没有新鲜事，很多经验是共同的</li>
</ul>
</li>
<li>可能会遇到什么困难，对应的尝试思路是什么？<ul>
<li>遇到困难的时候已经有了准备，就不会慌乱</li>
</ul>
</li>
<li>信息流动顺畅吗？是不是团队的每个成员都真正参与了进来？<ul>
<li>让每个人都清楚明白，就是流程的『可视化』，能让工作更简洁、更有效率</li>
</ul>
</li>
</ul>
<p>实践是学习和思考的演戏场，前面提到的各种能力和技巧，都可以运用到实践中来。当我们遇到问题时，最高效的做法是：</p>
<ol>
<li>认识问题。思考问题背后的东西，背景、事物、条件、关系。通过重新定义问题本身来探索问题的本质。</li>
<li>独立思考。先不借助书本和网络，大胆假设，小心求证。试错的目的就是从中得到意外的收获。现实不比理论，遇到的问题往往具体而特殊，几乎没有什么现成的经验，还是那句话：主动思考大胆假设小心求证。书本和网络的资料可能会给人启发，但是也是枷锁，框住想象力。</li>
<li>全面观测。这个时候可以在书本或网络中找寻相关内容，可能的话尽量与他人交换想法。认知本身就是主观的，横看成岭侧成峰，要全面观测，才能得到更接近『真实』的认知。也就是主观的客观化。</li>
<li>形成框架。简单来说，就是要有自己的『套路』，不同类型的问题有不同的解法，通过具体的实践不断迭代优化自己的理论与套路。</li>
<li>魔鬼细节。仰望星空同时也要脚踏实地，实践难免把手弄脏，但也只有把手弄脏才能得到完备的解决方案，继而解决复杂的现实问题。</li>
<li>每次处理问题请重复上述步骤</li>
</ol>
<p>实践是问题导向的，不能为了做而做，面对动态世界的复杂系统，只有以未知作为起点进行思考，才可能拨开迷雾找到答案。</p>
<p>实践关于实践本身的东西，就是元实践。</p>
<h2 id="u6B63_u786E_u521B_u9020"><a href="#u6B63_u786E_u521B_u9020" class="headerlink" title="正确创造"></a>正确创造</h2><blockquote>
<p>The purpose of education is to provide you the toolsets that enable you take the data around you, make sense out of it and find out a way to create something productive out of that. As the amount of data around us explode, the necessity for education grows.</p>
</blockquote>
<p>创造性这个东西，说流淌在血液中一点也不为过。我们骨子里传下来的智慧、毅力、勤勉、奋发当然不能丢，但是更应该再来点浪漫主义，从超越功利的角度找回精神自主性，每个人都要是特立独行的个体，而不是流水线生产出来的千人一面脸谱化。</p>
<p>多元化的生活态度与人生哲学，对生活本身的富于诗情的理解，才能真正让自己『立体』，有广度也有深度，才能创造出更多新东西，而不是循规蹈矩墨守成规。</p>
<p>『当幸福来敲门』这个翻译我觉得特别好，很多东西不是去找就能找得到的，而是把该做好的都做好，然后静静等待那个时刻的到来。创造就是如此，尤其是下面提到的『酝酿』阶段，就是『当创意来敲门』。但是需要注意的是，不同阶段有不同的侧重点：</p>
<ul>
<li>准备阶段。搜集相关信息，缩小问题范围，直到看到障碍</li>
<li>酝酿阶段。将自己完全浸在问题里，运用潜意识思考，不要有寻找解决方案的压力</li>
<li>启发阶段。用直觉或有意识的思考处理问题，用直觉或洞察力来形成可能的解决方案</li>
<li>验证阶段。对可能的解决方案进行合理性检验，验证方案的正确性，并最终打磨完整</li>
</ul>
<p>创造关于创造本身的东西，就是元创造。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>Heroes inspire us for many reasons: they make tough decisions, they keep going and they get done what matters. But there’s another reason we love our heroes. Inside us all, we know we have the power to become one ourselves.</p>
</blockquote>
<p>英雄人物之所以能激励我们，是因为他们能够作出艰难的抉择，他们永不言弃，他们总能做出惊天动地的事情。但我们之所以崇拜英雄还有另一个原因。在内心深处，我们都相信自己有能力成为他们。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>小聪明到大智慧之间，有一条看不见的横沟，只能用天赋、坚持和勤奋来填。如果硬要说有技巧，恐怕就是『元学习』、『元思考』、『元实践』和『元创造』。</p>]]>
    
    </summary>
    
      <category term="创造" scheme="http://wdxtub.com/tags/%E5%88%9B%E9%80%A0/"/>
    
      <category term="感觉" scheme="http://wdxtub.com/tags/%E6%84%9F%E8%A7%89/"/>
    
      <category term="方法" scheme="http://wdxtub.com/tags/%E6%96%B9%E6%B3%95/"/>
    
      <category term="聪明" scheme="http://wdxtub.com/tags/%E8%81%AA%E6%98%8E/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 反思课 5 实时服务测试的策略与思考]]></title>
    <link href="http://wdxtub.com/2016/03/31/cc-rethink-5/"/>
    <id>http://wdxtub.com/2016/03/31/cc-rethink-5/</id>
    <published>2016-03-31T10:02:04.000Z</published>
    <updated>2016-03-31T11:19:15.000Z</updated>
    <content type="html"><![CDATA[<p>昨天我们的 Twitter Analysis Service 采用了新的测试方式，在大约两个半小时的时间内进行各类请求的压力测试，以确保系统能够应对复杂请求。虽然我做的部分表现非常糟糕，但是从中学到了很多东西，知耻而后勇。</p>
<a id="more"></a>
<hr>
<p>总得来说，因为有靠谱的队友（手动重启服务器几十次），整个测试不至于滑铁卢，但是这也暴露了我们在前后端设计处理的各种问题，接下来逐条分析。</p>
<blockquote>
<p>架构设计</p>
</blockquote>
<p>因为整套系统目前有 6 台机器，之前测试的时候使用 1 台前端 + 4 台后端是行得通的。但是因为之前并没有过多留意前后端机器的硬件利用情况（基本凭感觉），所以想当然得觉得后端是瓶颈（对 HBase 的特性不大了解，估计错误）。事实狠狠打了我的脸，前端的 CPU 利用率居高不下（接近满负荷运载）而后端的利用率分布不均（有的节点 60% 的 CPU 使用率，有的节点甚至只有 20%）。</p>
<p>当我意识到这个问题的时候，只能眼睁睁看着唯一的一台前端苦苦支撑，爆内存，和 HBase 的连接断开，每次都只能手动重启服务器（但是因为 CPU 占用满了，重启也需要几分钟）。这极大影响了正确率和吞吐量，最终得到的分数自然少得可怜。</p>
<p>参考其他组的先进经验，前端使用 ELB(负载均衡) + 2 台机器，后端使用 1(master) + 3(slave) 的模式可能是最科学的，这样可以尽可能得减轻前端单机压力。</p>
<blockquote>
<p>硬件监控</p>
</blockquote>
<p>好消息是，在同学的帮助之下，终于意识到了『监控』的重要性。虽然不难（每台机器开着 <code>top</code> 查看使用率即可），但是有没有这个意识就有天壤之别。简单粗暴来说，哪怕只通过 CPU 利用率一个指标，就能大概估计目前的硬件使用情况，可是我之前竟然拍脑袋想当然总觉得硬件不是问题。</p>
<p>这是很好的教训，我要吸取经验。</p>
<p>痛定思痛，至少可以从其他多个角度来利用监控数据：</p>
<ul>
<li>了解不同的监控命令，深入理解不同监控参数的意义，编写脚本抓取重点关注的数据</li>
<li>结合 CPU 利用率 + 内存利用率来优化代码，力求达到充分利用 CPU 以及内存</li>
<li>观察 CPU / 内存 / 网络的相关数据，来确定具体的瓶颈所在，然后对症下药，寻找可能的解决方案</li>
<li>在监控脚本的基础上，可以设定一些阈值，自动化提醒和记录日志（不用自己时刻盯着屏幕了）</li>
<li>提醒内容：CPU / 内存 / 网络满载警报，或者不均衡使用警报等</li>
<li>日志内容：在出现警报的时候，需要记录相关请求，查看日志的时候能够快速掌握上下文</li>
</ul>
<blockquote>
<p>数据统计</p>
</blockquote>
<p>一般来说，不同的 web 服务，用户的请求模式总体来说是有一定规律的。对于 Twitter 数据的分析，就有热门/冷门的用户/hashtag/单词/时间段（比方说有重大事件发生的日子，tweet 的数量可能会更多）</p>
<p>我们应该根据具体的需求，通过统计大致了解数据分布。比方说其中一个请求是返回某用户包含某 hashtag 的 tweet，那么我们最好需要了解哪些用户热门，哪些 hashtag 热门，然后根据这些特点来进行数据库 schema 的设计（就是 rowkey 和 value）以及数据库中不同 region 在不同 regionserver 的平衡。之前的设计方式会导致有些 region 访问次数非常多，有些却非常少，这样就没有充分利用 HBase 的能力。</p>
<p>这部分具体怎么实现还需要通过不断实践来摸索，但是想要获得更好的性能，总是逃不开这步的。</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>这一部分就是压力测试下暴露的代码问题了，主要是以下几点：</p>
<ul>
<li>请求的参数要进行检查，很可能为空。但是写起来的语法很麻烦，这个时候就开始怀念 Swift 中的语法糖了</li>
<li>对于 HBase 1.0 来说，连接池几乎没用，因为共用 HConnection 的 HTableInterface 并不会并行</li>
<li>线程池也不大需要，undertow 框架基本能够处理好，就不要画蛇添足（容易爆内存）</li>
</ul>
<p>最后写三句，从错误中学习比实现 web 服务本身更有意义，这是第二句，第三句也写完了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天我们的 Twitter Analysis Service 采用了新的测试方式，在大约两个半小时的时间内进行各类请求的压力测试，以确保系统能够应对复杂请求。虽然我做的部分表现非常糟糕，但是从中学到了很多东西，知耻而后勇。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="优化" scheme="http://wdxtub.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[tmux 指南]]></title>
    <link href="http://wdxtub.com/2016/03/30/tmux-guide/"/>
    <id>http://wdxtub.com/2016/03/30/tmux-guide/</id>
    <published>2016-03-30T22:55:27.000Z</published>
    <updated>2016-03-31T04:01:21.000Z</updated>
    <content type="html"><![CDATA[<p>今天试用了一下 tmux，发现简直是神器！以前还傻傻不停开窗口，现在一个窗口就可以都搞定啦！</p>
<a id="more"></a>
<hr>
<p>Tmux 简单来说就是终端里的『窗口管理器』，如果我使用终端登录到远程主机并运行前台程序，那么这个窗口等于就被占用了，想要看一下 CPU 的使用率，就得再连接一次。但是如果在远程主机上运行 tmux，那么就可以开启多个控制台（类似于窗口），相当高效，比方说可以像下面这样：</p>
<p><img src="/images/14593788571503.jpg" alt="一个面板监视服务器，一个面板查看硬件状况"></p>
<p>需要注意的是，这里是在我本地使用 tmux，最好在远程主机也安装 tmux，这样就只需要连接一次。</p>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>前面提到的窗口管理只是 tmux 功能的一小部分，另一个很有用的功能就是，连接到远程主机之后，一旦断开，那么当前账户登录的任务就被取消了，但是使用 tmux 可以在断开之后继续工作，下次登录可以查看。其他的功能还有：</p>
<ol>
<li>窗口切换，每个窗口里还可以分割面板</li>
<li>配置方便，可以使用脚本</li>
<li>类似 vim 的双层操作逻辑</li>
<li>复制粘贴缓冲区</li>
</ol>
<p>安装的话也很简单，在 mac 下直接 <code>brew install tmux</code>（前提需要安装 homebrew），ubuntu 下则直接 <code>sudo apt-get install tmux</code></p>
<p>在终端中输入 <code>tmux</code> 就可以打开一个新的 tmux session，tmux 的所有操作必须先使用一个前缀键（默认是 <code>ctrl + b</code>）进入命令模式，或者说进入控制台，就像 vim 中的 esc。</p>
<h2 id="u57FA_u672C_u64CD_u4F5C"><a href="#u57FA_u672C_u64CD_u4F5C" class="headerlink" title="基本操作"></a>基本操作</h2><blockquote>
<p>信息查询</p>
</blockquote>
<ul>
<li><code>tmux list-keys</code> 列出所有可以的快捷键和其运行的 tmux 命令</li>
<li><code>tmux list-commands</code> 列出所有的 tmux 命令及其参数</li>
<li><code>tmux info</code> 流出所有的 session, window, pane, 运行的进程号，等。</li>
</ul>
<blockquote>
<p>窗口控制</p>
</blockquote>
<p>先来看看在 tmux 之外如何进行控制</p>
<ul>
<li>session 会话：session是一个特定的终端组合。输入tmux就可以打开一个新的session<ul>
<li><code>tmux new -s session_name</code> 创建一个叫做 <code>session_name</code> 的 tmux session</li>
<li><code>tmux attach -t session_name</code> 重新开启叫做 <code>session_name</code> 的 tmux session</li>
<li><code>tmux switch -t session_name</code> 转换到叫做 <code>session_name</code> 的 tmux session</li>
<li><code>tmux list-sessions</code> / <code>tmux ls</code> 列出现有的所有 session</li>
<li><code>tmux detach</code> 离开当前开启的 session</li>
</ul>
</li>
<li>window 窗口：session 中可以有不同的 window（但是同时只能看到一个 window）<ul>
<li><code>tmux new-window</code> 创建一个新的 window</li>
<li><code>tmux list-windows</code> </li>
<li><code>tmux select-window -t :0-9</code> 根据索引转到该 window</li>
<li><code>tmux rename-window</code> 重命名当前 window</li>
</ul>
</li>
<li>pane 面板：window 中可以有不同的 pane（可以把 window 分成不同的部分）<ul>
<li><code>tmux split-window</code> 将 window 垂直划分为两个 pane</li>
<li><code>tmux split-window -h</code> 将 window 水平划分为两个 pane</li>
<li><code>tmux swap-pane -[UDLR]</code> 在指定的方向交换 pane</li>
<li><code>tmux select-pane -[UDLR]</code> 在指定的方向选择下一个 pane</li>
</ul>
</li>
</ul>
<p>更常用的是在 tmux 中直接通过默认前缀 <code>ctrl + b</code> 之后输入对应命令来操作，具体如下（这里只列出输入默认前缀之后需要输入的操作）：</p>
<blockquote>
<p>基本操作</p>
</blockquote>
<ul>
<li><code>?</code> 列出所有快捷键；按q返回</li>
<li><code>d</code> 脱离当前会话,可暂时返回Shell界面</li>
<li><code>s</code> 选择并切换会话；在同时开启了多个会话时使用</li>
<li><code>D</code> 选择要脱离的会话；在同时开启了多个会话时使用</li>
<li><code>:</code> 进入命令行模式；此时可输入支持的命令，例如 <code>kill-server</code> 关闭所有tmux会话</li>
<li><code>[</code> 复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q/Esc退出</li>
<li><code>]</code> 进入粘贴模式，粘贴之前复制的内容，按q/Esc退出</li>
<li><code>~</code> 列出提示信息缓存；其中包含了之前tmux返回的各种提示信息</li>
<li><code>t</code> 显示当前的时间</li>
<li><code>ctrl + z</code> 挂起当前会话</li>
</ul>
<blockquote>
<p>窗口操作</p>
</blockquote>
<ul>
<li><code>c</code> 创建新窗口</li>
<li><code>&amp;</code> 关闭当前窗口</li>
<li><code>[0-9]</code> 数字键切换到指定窗口</li>
<li><code>p</code> 切换至上一窗口</li>
<li><code>n</code> 切换至下一窗口</li>
<li><code>l</code> 前后窗口间互相切换</li>
<li><code>w</code> 通过窗口列表切换窗口</li>
<li><code>,</code> 重命名当前窗口，便于识别</li>
<li><code>.</code> 修改当前窗口编号，相当于重新排序</li>
<li><code>f</code> 在所有窗口中查找关键词，便于窗口多了切换</li>
</ul>
<blockquote>
<p>面板操作</p>
</blockquote>
<ul>
<li><code>&quot;</code> 将当前面板上下分屏（我自己改成了 <code>|</code>）</li>
<li><code>%</code> 将当前面板左右分屏（我自己改成了 <code>-</code>）</li>
<li><code>x</code> 关闭当前分屏</li>
<li><code>!</code> 将当前面板置于新窗口,即新建一个窗口,其中仅包含当前面板</li>
<li><code>ctrl+方向键</code> 以1个单元格为单位移动边缘以调整当前面板大小</li>
<li><code>alt+方向键</code> 以5个单元格为单位移动边缘以调整当前面板大小</li>
<li><code>q</code> 显示面板编号</li>
<li><code>o</code> 选择当前窗口中下一个面板</li>
<li><code>方向键</code> 移动光标选择对应面板</li>
<li><code>{</code> 向前置换当前面板</li>
<li><code>}</code> 向后置换当前面板</li>
<li><code>alt+o</code> 逆时针旋转当前窗口的面板</li>
<li><code>ctrl+o</code> 顺时针旋转当前窗口的面板</li>
<li><code>z</code> 最大化当前所在面板</li>
<li><code>page up</code> 向上滚动屏幕，q 退出</li>
<li><code>page down</code> 向下滚动屏幕，q 退出</li>
</ul>
<p>因为 iTerm2 的支持，很多切换的操作可以直接用鼠标进行，非常方便。具体大家可以自己尝试一下。</p>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2><p>我们可以先进行一些简单的配置，修改 <code>~/.tmux.conf</code> 即可，让整个使用更方便。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#<span class="comment">-- base --#</span></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">default</span>-terminal <span class="string">"screen-256color"</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> display-<span class="keyword">time</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> history-<span class="keyword">limit</span> <span class="number">10000</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> base-<span class="keyword">index</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> pane-base-<span class="keyword">index</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> -s escape-<span class="keyword">time</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> mouse <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line">#<span class="comment">-- bindkeys --#</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">split</span> windows <span class="keyword">like</span> vim.  - Note: vim<span class="string">'s definition of a horizontal/vertical split is reversed from tmux'</span>s</span><br><span class="line"></span><br><span class="line">unbind s</span><br><span class="line">bind s <span class="keyword">split</span>-window -v</span><br><span class="line">bind S <span class="keyword">split</span>-window -v -<span class="keyword">l</span> <span class="number">40</span></span><br><span class="line">bind v <span class="keyword">split</span>-window -h</span><br><span class="line">bind V <span class="keyword">split</span>-window -h -<span class="keyword">l</span> <span class="number">120</span></span><br><span class="line"></span><br><span class="line"># navigate panes <span class="keyword">with</span> hjkl</span><br><span class="line">bind h <span class="keyword">select</span>-pane -<span class="keyword">L</span></span><br><span class="line">bind j <span class="keyword">select</span>-pane -<span class="keyword">D</span></span><br><span class="line">bind <span class="keyword">k</span> <span class="keyword">select</span>-pane -U</span><br><span class="line">bind <span class="keyword">l</span> <span class="keyword">select</span>-pane -R</span><br><span class="line"></span><br><span class="line"># <span class="keyword">key</span> bindings <span class="keyword">for</span> horizontal <span class="keyword">and</span> vertical panes</span><br><span class="line">unbind %</span><br><span class="line">bind | <span class="keyword">split</span>-window -h      # 使用|竖屏，方便分屏</span><br><span class="line">unbind <span class="string">'"'</span></span><br><span class="line">bind - <span class="keyword">split</span>-window -v      # 使用-横屏，方便分屏</span><br><span class="line"></span><br><span class="line"># swap panes</span><br><span class="line">bind ^u swapp -U</span><br><span class="line">bind ^<span class="keyword">d</span> swapp -<span class="keyword">D</span></span><br><span class="line"></span><br><span class="line">bind q killp</span><br><span class="line">bind ^<span class="keyword">e</span> <span class="keyword">last</span></span><br><span class="line"></span><br><span class="line">unbind r</span><br><span class="line">bind r <span class="keyword">source</span>-<span class="keyword">file</span> ~/.tmux.conf \;</span> display "Configuration Reloaded!"</span><br><span class="line"></span><br><span class="line">#<span class="comment">-- statusbar --#</span></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-justify centre</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">left</span> <span class="string">"#[fg=red]s#S:w#I.p#P#[default]"</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">right</span> <span class="string">'[#(whoami)#(date +" %m-%d %H:%M ")]'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">left</span>-<span class="keyword">attr</span> bright</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">left</span>-<span class="keyword">length</span> <span class="number">120</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">right</span>-<span class="keyword">length</span> <span class="number">120</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-utf8 <span class="keyword">on</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="built_in">interval</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> visual-activity <span class="keyword">on</span></span><br><span class="line">setw -<span class="keyword">g</span> monitor-activity <span class="keyword">on</span></span><br><span class="line">setw -<span class="keyword">g</span> <span class="keyword">automatic</span>-<span class="keyword">rename</span> <span class="keyword">off</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">default</span> statusbar colors</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-bg colour235 #base02</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-fg colour136 #yellow</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">attr</span> <span class="keyword">default</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">default</span> window title colors</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-fg colour244</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-bg <span class="keyword">default</span></span><br><span class="line">#setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">attr</span> dim</span><br><span class="line"></span><br><span class="line"># active window title colors</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-fg colour166 #orange</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-bg <span class="keyword">default</span></span><br><span class="line">#setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-<span class="keyword">attr</span> bright</span><br><span class="line"></span><br><span class="line"># window title <span class="keyword">string</span> (uses statusbar <span class="keyword">variables</span>)</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">set</span>-titles-<span class="keyword">string</span> <span class="string">'#T'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-justify <span class="string">"centre"</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">format</span> <span class="string">'#I #W'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-<span class="keyword">format</span> <span class="string">' #I #W '</span></span><br><span class="line"></span><br><span class="line"># pane border</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> pane-active-border-fg <span class="string">'#55ff55'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> pane-border-fg <span class="string">'#555555'</span></span><br><span class="line"></span><br><span class="line"># message <span class="built_in">text</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> message-bg colour235 #base02</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> message-fg colour166 #orange</span><br><span class="line"></span><br><span class="line"># pane <span class="built_in">number</span> display</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> display-panes-active-colour colour33 #blue</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> display-panes-colour colour166 #orange</span><br><span class="line"></span><br><span class="line"># clock</span><br><span class="line">setw -<span class="keyword">g</span> clock-<span class="keyword">mode</span>-colour colour64 #green</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 修改进入命令模式按键</span><br><span class="line"># remap prefix <span class="keyword">to</span> Control + a</span><br><span class="line"># <span class="keyword">set</span> -<span class="keyword">g</span> prefix <span class="keyword">C</span>-a</span><br><span class="line"># unbind <span class="keyword">C</span>-b</span><br><span class="line"># bind <span class="keyword">C</span>-a send-prefix</span></span><br></pre></td></tr></table></figure>
<p>最终的效果是</p>
<p><img src="/images/14593965566247.jpg" alt=""></p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://foocoder.com/blog/zhong-duan-huan-jing-zhi-tmux.html/" target="_blank" rel="external">终端环境之tmux</a></li>
<li><a href="http://blog.jeswang.org/blog/2013/06/24/tmux-kuai-su-jiao-cheng/" target="_blank" rel="external">Tmux 快速教程</a></li>
<li><a href="http://kumu-linux.github.io/blog/2013/08/06/tmux/" target="_blank" rel="external">Linux下终端利器tmux</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天试用了一下 tmux，发现简直是神器！以前还傻傻不停开窗口，现在一个窗口就可以都搞定啦！</p>]]>
    
    </summary>
    
      <category term="命令行" scheme="http://wdxtub.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="效率" scheme="http://wdxtub.com/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="窗口" scheme="http://wdxtub.com/tags/%E7%AA%97%E5%8F%A3/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ruby 快速入门]]></title>
    <link href="http://wdxtub.com/2016/03/30/ruby-first-step/"/>
    <id>http://wdxtub.com/2016/03/30/ruby-first-step/</id>
    <published>2016-03-30T13:14:28.000Z</published>
    <updated>2016-04-01T15:07:09.000Z</updated>
    <content type="html"><![CDATA[<p>学编程就好比学有用，再好的理论也不如一头扎下水，扑腾着呼吸新鲜空气管用。这个系列的目的，就是帮助自己跳入水中，这一次我们来学 Ruby。</p>
<a id="more"></a>
<hr>
<p>获得任何新技能的第一步，是先别想着独立解决什么，而是重复一边前人已竟之事，这是最快的方法。每门语言都有自己的一套惯用方法，各有所长，各有所短。通过学习不同的编程语言，你会明白，哪门语言最适宜解决自己当下关注的问题。</p>
<p>精于禅宗的大师会告诉你，拉丁语学得越好，数学也就越好。编程也同样如此。通过研究逻辑式编程或函数式编程，你能领悟到面向对象编程的精华；通过学习汇编语言，你能更透彻地理解函数式编程。</p>
<p>学习新语言的时候，一定要弄清楚以下几个问题：</p>
<ul>
<li>语言的类型模型是什么？<ul>
<li>强类型/弱类型，静态类型/动态类型</li>
<li>类型模型会改变问题的处理方式，控制语言的运行方式</li>
</ul>
</li>
<li>语言的编程范型是什么？<ul>
<li>面向对象、函数式、过程式等等</li>
</ul>
</li>
<li>怎样和语言交互？<ul>
<li>编译、解释</li>
</ul>
</li>
<li>语言的判断结构(decision construct)和核心数据结构是什么？</li>
<li>哪些核心特性让这门语言与众不同？</li>
</ul>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><ul>
<li>由松本行弘(Yukihiro Matsumoto)大约在 1993 年发明</li>
<li>脚本语言、解释型、面向对象、动态类型</li>
</ul>
<p>现在我的机器上安装的 ruby 版本是 2.1，可以使用下面的命令来查询：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -v</span><br><span class="line">ruby <span class="number">2.1</span>.<span class="number">4</span>p265 (<span class="number">2014</span>-<span class="number">10</span>-<span class="number">27</span> revision <span class="number">48166</span>) [x86_64-darwin14.<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>具体的安装不做太多介绍，在<a href="https://www.ruby-lang.org/zh_cn/" target="_blank" rel="external">官方网站</a>查阅不同平台的相关资料即可，下面是一个简单的例子</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> properties = [<span class="string">'good'</span>, <span class="string">'bad'</span>, <span class="string">'clever'</span>, <span class="string">'stupid'</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"good"</span>, <span class="string">"bad"</span>, <span class="string">"clever"</span>, <span class="string">"stupid"</span>]</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> properties.each &#123;|property| puts <span class="string">"I am <span class="subst">#&#123;property&#125;</span>."</span>&#125;</span><br><span class="line"><span class="constant">I</span> am good.</span><br><span class="line"><span class="constant">I</span> am bad.</span><br><span class="line"><span class="constant">I</span> am clever.</span><br><span class="line"><span class="constant">I</span> am stupid.</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"good"</span>, <span class="string">"bad"</span>, <span class="string">"clever"</span>, <span class="string">"stupid"</span>]</span><br></pre></td></tr></table></figure>
<p>留意一下 ruby 是如何进行遍历及值替换的，之后我们也会深入了解。需要注意的是，这种写起来方便的语言，一般来说效率都不会太高。但是开发效率与执行效率常常是鱼与熊掌，很多时候不得不进行选择。</p>
<p>我们再来看一个长一点的例子：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> puts <span class="string">'hello, wdx'</span></span><br><span class="line">hello, wdx</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> friend = <span class="string">'Snake'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Snake"</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> puts <span class="string">"hello, <span class="subst">#&#123;friend&#125;</span>"</span></span><br><span class="line">hello, <span class="constant">Snake</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> friend = <span class="string">'Queit'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Queit"</span></span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> puts <span class="string">"hello, <span class="subst">#&#123;friend&#125;</span>"</span></span><br><span class="line">hello, <span class="constant">Queit</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到以下几点：</p>
<ul>
<li>不用声明变量</li>
<li>每条 ruby 代码都会返回某个值</li>
<li>单引号表示直接解释</li>
<li>双引号包含的字符串会进行字符串替换</li>
</ul>
<h2 id="u7F16_u7A0B_u6A21_u578B"><a href="#u7F16_u7A0B_u6A21_u578B" class="headerlink" title="编程模型"></a>编程模型</h2><p>Ruby 是一门纯面向对象语言。从下面的例子就可以看出来：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="number">233</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">233</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> <span class="number">233</span>.class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">Fixnum</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> <span class="number">233</span> + <span class="number">233</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">466</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> <span class="number">233</span>.methods</span><br><span class="line"><span class="status">=&gt;</span> [<span class="symbol">:to_s</span>, <span class="symbol">:inspect</span>, <span class="symbol">:-@</span>, <span class="symbol">:+</span>, <span class="symbol">:-</span>, <span class="symbol">:*</span>, <span class="symbol">:/</span>, <span class="symbol">:div</span>, <span class="symbol">:%</span>, <span class="symbol">:modulo</span>, <span class="symbol">:divmod</span>, <span class="symbol">:fdiv</span>, <span class="symbol">:**</span>, <span class="symbol">:abs</span>, <span class="symbol">:magnitude</span>, <span class="symbol">:==</span>, <span class="symbol">:===</span>, <span class="symbol">:&lt;=&gt;</span>, <span class="symbol">:&gt;</span>, <span class="symbol">:&gt;=</span>, <span class="symbol">:&lt;</span>, <span class="symbol">:&lt;=</span>, <span class="symbol">:~</span>, <span class="symbol">:&amp;</span>, <span class="symbol">:|</span>, <span class="symbol">:^</span>, <span class="symbol">:[]</span>, <span class="symbol">:&lt;&lt;</span>, <span class="symbol">:&gt;&gt;</span>, <span class="symbol">:to_f</span>, <span class="symbol">:size</span>, <span class="symbol">:bit_length</span>, <span class="symbol">:zero?</span>, <span class="symbol">:odd?</span>, <span class="symbol">:even?</span>, <span class="symbol">:succ</span>, <span class="symbol">:integer?</span>, <span class="symbol">:upto</span>, <span class="symbol">:downto</span>, <span class="symbol">:times</span>, <span class="symbol">:next</span>, <span class="symbol">:pred</span>, <span class="symbol">:chr</span>, <span class="symbol">:ord</span>, <span class="symbol">:to_i</span>, <span class="symbol">:to_int</span>, <span class="symbol">:floor</span>, <span class="symbol">:ceil</span>, <span class="symbol">:truncate</span>, <span class="symbol">:round</span>, <span class="symbol">:gcd</span>, <span class="symbol">:lcm</span>, <span class="symbol">:gcdlcm</span>, <span class="symbol">:numerator</span>, <span class="symbol">:denominator</span>, <span class="symbol">:to_r</span>, <span class="symbol">:rationalize</span>, <span class="symbol">:singleton_method_added</span>, <span class="symbol">:coerce</span>, <span class="symbol">:i</span>, <span class="symbol">:+@</span>, <span class="symbol">:eql?</span>, <span class="symbol">:remainder</span>, <span class="symbol">:real?</span>, <span class="symbol">:nonzero?</span>, <span class="symbol">:step</span>, <span class="symbol">:quo</span>, <span class="symbol">:to_c</span>, <span class="symbol">:real</span>, <span class="symbol">:imaginary</span>, <span class="symbol">:imag</span>, <span class="symbol">:abs2</span>, <span class="symbol">:arg</span>, <span class="symbol">:angle</span>, <span class="symbol">:phase</span>, <span class="symbol">:rectangular</span>, <span class="symbol">:rect</span>, <span class="symbol">:polar</span>, <span class="symbol">:conjugate</span>, <span class="symbol">:conj</span>, <span class="symbol">:between?</span>, <span class="symbol">:nil?</span>, <span class="symbol">:=~</span>, <span class="symbol">:</span>!~, <span class="symbol">:hash</span>, <span class="symbol">:class</span>, <span class="symbol">:singleton_class</span>, <span class="symbol">:clone</span>, <span class="symbol">:dup</span>, <span class="symbol">:taint</span>, <span class="symbol">:tainted?</span>, <span class="symbol">:untaint</span>, <span class="symbol">:untrust</span>, <span class="symbol">:untrusted?</span>, <span class="symbol">:trust</span>, <span class="symbol">:freeze</span>, <span class="symbol">:frozen?</span>, <span class="symbol">:methods</span>, <span class="symbol">:singleton_methods</span>, <span class="symbol">:protected_methods</span>, <span class="symbol">:private_methods</span>, <span class="symbol">:public_methods</span>, <span class="symbol">:instance_variables</span>, <span class="symbol">:instance_variable_get</span>, <span class="symbol">:instance_variable_set</span>, <span class="symbol">:instance_variable_defined?</span>, <span class="symbol">:remove_instance_variable</span>, <span class="symbol">:instance_of?</span>, <span class="symbol">:kind_of?</span>, <span class="symbol">:is_a?</span>, <span class="symbol">:tap</span>, <span class="symbol">:send</span>, <span class="symbol">:public_send</span>, <span class="symbol">:respond_to?</span>, <span class="symbol">:extend</span>, <span class="symbol">:display</span>, <span class="symbol">:method</span>, <span class="symbol">:public_method</span>, <span class="symbol">:singleton_method</span>, <span class="symbol">:define_singleton_method</span>, <span class="symbol">:object_id</span>, <span class="symbol">:to_enum</span>, <span class="symbol">:enum_for</span>, <span class="symbol">:equal?</span>, <span class="symbol">:</span>!, <span class="symbol">:</span>!=, <span class="symbol">:instance_eval</span>, <span class="symbol">:instance_exec</span>, <span class="symbol">:__send__</span>, <span class="symbol">:__id__</span>]</span><br></pre></td></tr></table></figure>
<p>看出来了吗，ruby 中一切皆为对象，比方说数字就是 <code>Fixnum</code> 类型的对象，我们也可以用 <code>.</code> 来调用对象的各种方法。</p>
<blockquote>
<p>判断</p>
</blockquote>
<p>我们同样可以通过例子来研究研究。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> x = <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">4</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> x &lt; <span class="number">5</span></span><br><span class="line"><span class="status">=&gt;</span> true</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> x &lt;= <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> true</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> x &gt; <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> false</span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> false.class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">FalseClass</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> true.class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">TrueClass</span></span><br><span class="line"><span class="prompt">irb(main):007:0&gt;</span> puts <span class="string">'This is false'</span> unless x == <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):008:0&gt;</span> puts <span class="string">'This is true'</span> if x == <span class="number">4</span></span><br><span class="line"><span class="constant">This</span> is <span class="keyword">true</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):009:0&gt;</span> if x == <span class="number">4</span></span><br><span class="line"><span class="prompt">irb(main):010:1&gt;</span>     puts <span class="string">'This is true'</span></span><br><span class="line"><span class="prompt">irb(main):011:1&gt;</span> end</span><br><span class="line"><span class="constant">This</span> is <span class="keyword">true</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):012:0&gt;</span> unless x == <span class="number">4</span></span><br><span class="line"><span class="prompt">irb(main):013:1&gt;</span>    puts <span class="string">'This is false'</span></span><br><span class="line"><span class="prompt">irb(main):014:1&gt;</span> else</span><br><span class="line">irb(main)<span class="symbol">:</span><span class="number">015</span><span class="symbol">:</span><span class="number">1</span>*    puts <span class="string">'This is true'</span></span><br><span class="line"><span class="prompt">irb(main):016:1&gt;</span> end</span><br><span class="line"><span class="constant">This</span> is <span class="keyword">true</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):017:0&gt;</span> puts <span class="string">'This is true'</span> if not true</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):018:0&gt;</span> puts <span class="string">'This is ture'</span> if !true</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>比较什么的和其他语言大同小异，条件判断的话，主要是 <code>if</code> 和 <code>unless</code>（当然 <code>!</code> 和 <code>not</code> 都可以用，但是建议用 <code>unless</code> 比较清晰），在 Ruby 的语法中可以直接一行搞定判断一句，这样至少写起来很清晰。</p>
<p>除了 <code>nil</code> 和 <code>false</code> 之外，其他值都代表 <code>true</code>，注意！0 也是 <code>true</code>！</p>
<p>循环语句可以使用 <code>while</code> 和 <code>until</code>，比较简单，这里直接看例子，需要注意的是，Ruby 中没种对戏那个都有自己的相等的概念，对于数字来说，值相等就是相等。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> x = <span class="number">2</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> x = x + <span class="number">1</span> while x &lt; <span class="number">10</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> x</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">10</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> x = x - <span class="number">1</span> until x == <span class="number">1</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> x</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> while x &lt; <span class="number">10</span></span><br><span class="line"><span class="prompt">irb(main):007:1&gt;</span>   x = x + <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):008:1&gt;</span>   puts x</span><br><span class="line"><span class="prompt">irb(main):009:1&gt;</span> end</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>逻辑运算符和 C++/Java 有少许不同，<code>and</code>(<code>&amp;&amp;</code>) 是逻辑与，<code>or</code>(<code>||</code>) 是逻辑或，都是短路求值的，如果想要整个表达式都执行的话，使用 <code>&amp;</code> 和 <code>|</code> 来比较，具体为</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> true and false</span><br><span class="line"><span class="status">=&gt;</span> false</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> true or false</span><br><span class="line"><span class="status">=&gt;</span> true</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> false &amp;&amp; false</span><br><span class="line"><span class="status">=&gt;</span> false</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> true &amp;&amp; this_will_cause_an_error</span><br><span class="line"><span class="constant">NameError</span><span class="symbol">:</span> undefined local variable <span class="keyword">or</span> method <span class="string">`this_will_cause_an_error' for main:Object</span><br><span class="line">	from (irb):4</span><br><span class="line">	from /usr/local/bin/irb:11:in `</span>&lt;main&gt;<span class="string">'</span><br><span class="line">irb(main):005:0&gt; false &amp;&amp; this_will_not_cause_an_error</span><br><span class="line">=&gt; false</span><br><span class="line">irb(main):006:0&gt; true or this_will_not_cause_an_error</span><br><span class="line">=&gt; true</span><br><span class="line">irb(main):007:0&gt; true || this_will_not_cause_an_error</span><br><span class="line">=&gt; true</span><br><span class="line">irb(main):008:0&gt; true | this_will_cause_an_error</span><br><span class="line">NameError: undefined local variable or method `this_will_cause_an_error'</span> <span class="keyword">for</span> <span class="symbol">main:</span><span class="constant">Object</span></span><br><span class="line">	from (irb)<span class="symbol">:</span><span class="number">8</span></span><br><span class="line">	from /usr/local/bin/<span class="symbol">irb:</span><span class="number">11</span><span class="symbol">:in</span> <span class="string">`&lt;main&gt;'</span><br><span class="line">irb(main):009:0&gt; true | false</span><br><span class="line">=&gt; true</span></span><br></pre></td></tr></table></figure>
<p>基本来说还是一目了然的，这里不再赘述</p>
<blockquote>
<p>鸭子类型</p>
</blockquote>
<p>Ruby 是强类型语言，直到真正执行代码时，才进行类型检查，称为『动态类型』，但是这也带来了一些好处：多个类不必继承自相同父类，就能以相同方式使用，如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> i = <span class="number">0</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> a = [<span class="string">'100'</span>, <span class="number">100.0</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"100"</span>, <span class="number">100.0</span>]</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> while i &lt; <span class="number">2</span></span><br><span class="line"><span class="prompt">irb(main):004:1&gt;</span>   puts a[i].to_i</span><br><span class="line"><span class="prompt">irb(main):005:1&gt;</span>   i = i + <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:1&gt;</span> end</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>这其实就是面向对象设计思想中的重要原则：对接口编码。举个例子，对象若有 <code>push</code> 和 <code>pop</code>，那么就可以当做栈来使用。</p>
<blockquote>
<p>函数</p>
</blockquote>
<p>函数的定义也和简单，并且，函数也是一个对象</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tell_the_truth</span></span></span><br><span class="line">    <span class="keyword">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组</p>
</blockquote>
<p>同样先来看实例</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> animals = [<span class="string">'lions'</span>, <span class="string">'tigers'</span>, <span class="string">'bears'</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>]</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> puts animals</span><br><span class="line">lions</span><br><span class="line">tigers</span><br><span class="line">bears</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> animals[<span class="number">2</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"bears"</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> animals[<span class="number">3</span>]</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> animals[-<span class="number">1</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"bears"</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> animals[<span class="number">0</span>..<span class="number">2</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>]</span><br><span class="line"><span class="prompt">irb(main):007:0&gt;</span> (<span class="number">0</span>..<span class="number">1</span>).class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">Range</span></span><br></pre></td></tr></table></figure>
<p>具体部分比较好明白，唯一需要注意的是 <code>0..1</code> 其实是个对象。另外 <code>[]</code> 是 <code>Array</code> 类的方法，所以 <code>[]</code> 和 <code>[]=</code> 其实是语法糖。想要用的话，必须先在变量里放一个空数组。数组元素不必具有相同类型。</p>
<blockquote>
<p>散列表</p>
</blockquote>
<p>其实就是键值对存储，来看例子</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> numbers = &#123;<span class="number">1</span> =&gt; <span class="string">'one'</span>, <span class="number">2</span> =&gt; <span class="string">'two'</span>&#125;</span><br><span class="line"><span class="status">=&gt;</span> &#123;<span class="number">1</span>=&gt;<span class="string">"one"</span>, <span class="number">2</span>=&gt;<span class="string">"two"</span>&#125;</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> numbers[<span class="number">1</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"one"</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> stuff = &#123;<span class="symbol">:array</span> =&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="symbol">:string</span> =&gt; <span class="string">'Hi, mom!'</span>&#125;</span><br><span class="line"><span class="status">=&gt;</span> &#123;<span class="symbol">:array=&gt;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="symbol">:string=&gt;<span class="string">"Hi, mom!"</span></span>&#125;</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> stuff[<span class="symbol">:string</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Hi, mom!"</span></span><br></pre></td></tr></table></figure>
<p>这里尤其需要注意 <code>stuff</code> 这个散列表，我们使用了 symbol 的概念，就是变量名称前面加个冒号。这样做的意义在于，相同的 symbol 会指向相同的物理对象，比如下面的例子，两次 <code>&#39;string&#39;</code> 的 id 值不一样，但是 <code>:string</code> 的值是一样的</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):005:0&gt;</span> <span class="string">'string'</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">70186296639880</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> <span class="string">'string'</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">70186296271240</span></span><br><span class="line"><span class="prompt">irb(main):007:0&gt;</span> <span class="symbol">:string</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">156648</span></span><br><span class="line"><span class="prompt">irb(main):008:0&gt;</span> <span class="symbol">:string</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">156648</span></span><br></pre></td></tr></table></figure>
<p>散列表的一个应用就是模拟命名参数（就是不同的参数有不同的名字，这样可以根据名字来引用，而不是根据预订好的位置类进行引用），例如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="function"><span class="keyword">def</span> <span class="title">tell_the_truth</span><span class="params">(options=&#123;&#125;)</span></span></span><br><span class="line"><span class="prompt">irb(main):002:1&gt;</span>   if options[<span class="symbol">:profession</span>] == <span class="symbol">:lawyer</span></span><br><span class="line"><span class="prompt">irb(main):003:2&gt;</span>     <span class="string">'oh you are a laywer'</span></span><br><span class="line"><span class="prompt">irb(main):004:2&gt;</span>   else</span><br><span class="line">irb(main)<span class="symbol">:</span><span class="number">005</span><span class="symbol">:</span><span class="number">2</span>*     <span class="string">'who you are'</span></span><br><span class="line"><span class="prompt">irb(main):006:2&gt;</span>   end</span><br><span class="line"><span class="prompt">irb(main):007:1&gt;</span> end</span><br><span class="line"><span class="status">=&gt;</span> <span class="symbol">:tell_the_truth</span></span><br><span class="line"><span class="prompt">irb(main):008:0&gt;</span> tell_the_truth</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"who you are"</span></span><br><span class="line"><span class="prompt">irb(main):009:0&gt;</span> tell_the_truth <span class="symbol">:profession</span> =&gt; <span class="symbol">:lawyer</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"oh you are a laywer"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>options</code> 表示可选参数，如果不传入，默认就是空散列表</li>
<li>散列表用作最后一个参数的时候可以省略大括号</li>
</ul>
<blockquote>
<p>代码块和 yield</p>
</blockquote>
<p>代码块就是匿名函数，可以作为参数传递，比如说</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="number">3</span>.times &#123;puts <span class="string">'great day!'</span>&#125;</span><br><span class="line">great day!</span><br><span class="line">great day!</span><br><span class="line">great day!</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">3</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> animals = [<span class="string">'lions'</span>, <span class="string">'tigers'</span>, <span class="string">'bears'</span>, <span class="string">'rabbits'</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>, <span class="string">"rabbits"</span>]</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> animals.each &#123;|a| puts a&#125;</span><br><span class="line">lions</span><br><span class="line">tigers</span><br><span class="line">bears</span><br><span class="line">rabbits</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>, <span class="string">"rabbits"</span>]</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> animals.each do |a| \</span><br><span class="line">irb(main)<span class="symbol">:</span><span class="number">005</span><span class="symbol">:</span><span class="number">1</span>*                 puts a <span class="keyword">end</span></span><br><span class="line">lions</span><br><span class="line">tigers</span><br><span class="line">bears</span><br><span class="line">rabbits</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>, <span class="string">"rabbits"</span>]</span><br></pre></td></tr></table></figure>
<p>代码块只占一行时用 <code>{ / }</code>，多行的话则使用 <code>do / end</code>。如果我们要实现自己的 <code>times</code> 函数要怎么做呢？其实也很简单，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Fixnum</span></span></span><br><span class="line"><span class="prompt">irb(main):002:1&gt;</span>   <span class="function"><span class="keyword">def</span> <span class="title">my_times</span></span></span><br><span class="line"><span class="prompt">irb(main):003:2&gt;</span>     i = self</span><br><span class="line"><span class="prompt">irb(main):004:2&gt;</span>     while i &gt; <span class="number">0</span></span><br><span class="line"><span class="prompt">irb(main):005:3&gt;</span>       i = i - <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:3&gt;</span>       yield</span><br><span class="line"><span class="prompt">irb(main):007:3&gt;</span>     end</span><br><span class="line"><span class="prompt">irb(main):008:2&gt;</span>   end</span><br><span class="line"><span class="prompt">irb(main):009:1&gt;</span> end</span><br><span class="line"><span class="status">=&gt;</span> <span class="symbol">:my_times</span></span><br><span class="line"><span class="prompt">irb(main):010:0&gt;</span> <span class="number">3</span>.my_times &#123;puts <span class="string">'my own times!'</span>&#125;</span><br><span class="line">my own times!</span><br><span class="line">my own times!</span><br><span class="line">my own times!</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>因为代码块可以作为参数，于是类似于函数指针，可以更加灵活进行调用。</p>
<blockquote>
<p>面向对象</p>
</blockquote>
<p>主要是类和模块，这里设计的知识点比较繁杂，可以自行阅读参考链接中的文档，这里不再赘述</p>
<blockquote>
<p>优劣</p>
</blockquote>
<p>使用 Ruby 可以用一致的方向处理对象，还有各种不同的语法糖，可以有效提高编程的效率，不过这也导致一定的性能损失。另外，ruby 在并发条件下会产生严重问题（资源竞争）</p>
<h2 id="u4E60_u9898"><a href="#u4E60_u9898" class="headerlink" title="习题"></a>习题</h2><blockquote>
<p>替换字符串某一部分</p>
</blockquote>
<p>字符串相关的操作可以在<a href="http://ruby-doc.org/core-2.3.0/String.html" target="_blank" rel="external">这里</a>查看（其他的类也可以通过这种方式来学习）</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> title = <span class="string">"This is DaWang."</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"This is DaWang."</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> title[<span class="number">0</span>,<span class="number">3</span>] = <span class="string">"That"</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"That"</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> title</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Thats is DaWang."</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> title[<span class="number">0</span>,<span class="number">5</span>] = <span class="string">"That"</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"That"</span></span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> title</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"That is DaWang."</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意字符串的位置索引，具体可以试验一下。</p>
<blockquote>
<p>在字符串 <code>Hello, dawang</code> 中，找到 <code>dawang</code> 所在下标 </p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> s = <span class="string">'Hello, dawang'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Hello, dawang"</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> i = s.index(<span class="string">'dawang'</span>)</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>打印名字十次，并输出序号</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> name = <span class="string">'dawang'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"dawang"</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> i = <span class="number">0</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> while i &lt; <span class="number">10</span></span><br><span class="line"><span class="prompt">irb(main):004:1&gt;</span>   puts <span class="string">"<span class="subst">#&#123;i+<span class="number">1</span>&#125;</span> <span class="subst">#&#123;name&#125;</span>"</span></span><br><span class="line"><span class="prompt">irb(main):005:1&gt;</span>   i = i + <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:1&gt;</span> end</span><br><span class="line"><span class="number">1</span> dawang</span><br><span class="line"><span class="number">2</span> dawang</span><br><span class="line"><span class="number">3</span> dawang</span><br><span class="line"><span class="number">4</span> dawang</span><br><span class="line"><span class="number">5</span> dawang</span><br><span class="line"><span class="number">6</span> dawang</span><br><span class="line"><span class="number">7</span> dawang</span><br><span class="line"><span class="number">8</span> dawang</span><br><span class="line"><span class="number">9</span> dawang</span><br><span class="line"><span class="number">10</span> dawang</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从文件运行 Ruby 程序</p>
</blockquote>
<p>类似 python，直接 <code>ruby filename</code> 即可，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [8:47:56]</span></span><br><span class="line">$ cat test.rb</span><br><span class="line">name = <span class="string">'dawang'</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span></span><br><span class="line">    puts <span class="string">"#&#123;i+1&#125; #&#123;name&#125;"</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [8:48:36]</span></span><br><span class="line">$ ruby test.rb</span><br><span class="line"><span class="number">1</span> dawang</span><br><span class="line"><span class="number">2</span> dawang</span><br><span class="line"><span class="number">3</span> dawang</span><br><span class="line"><span class="number">4</span> dawang</span><br><span class="line"><span class="number">5</span> dawang</span><br><span class="line"><span class="number">6</span> dawang</span><br><span class="line"><span class="number">7</span> dawang</span><br><span class="line"><span class="number">8</span> dawang</span><br><span class="line"><span class="number">9</span> dawang</span><br><span class="line"><span class="number">10</span> dawang</span><br></pre></td></tr></table></figure>
<blockquote>
<p>生成一个 0~9 的随机数，让用户猜，并告知结果</p>
</blockquote>
<p>具体可以直接看代码</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [9:07:47]</span></span><br><span class="line"><span class="variable">$ </span>cat test.rb</span><br><span class="line">puts <span class="string">'Please input a number between 0~9: '</span></span><br><span class="line">numstr = gets</span><br><span class="line">num = numstr.to_i(base=<span class="number">10</span>)</span><br><span class="line">puts <span class="string">'Generating random number..'</span></span><br><span class="line">target = rand(<span class="number">10</span>)</span><br><span class="line">puts <span class="string">"The target number is <span class="subst">#&#123;target&#125;</span>"</span></span><br><span class="line"><span class="keyword">if</span> num == target</span><br><span class="line">    puts <span class="string">'You made it!'</span></span><br><span class="line"><span class="keyword">elsif</span> num &lt; target</span><br><span class="line">    puts <span class="string">'Answer Too Small!'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    puts <span class="string">'Answer Too Large!'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [9:07:53]</span></span><br><span class="line"><span class="variable">$ </span>ruby test.rb</span><br><span class="line"><span class="constant">Please</span> input a number between <span class="number">0</span>~<span class="number">9</span><span class="symbol">:</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="constant">Generating</span> random number..</span><br><span class="line"><span class="constant">The</span> target number is <span class="number">6</span></span><br><span class="line"><span class="constant">Answer</span> <span class="constant">Too</span> <span class="constant">Small</span>!</span><br></pre></td></tr></table></figure>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://ruby-doc.org/core-2.3.0/" target="_blank" rel="external">Ruby APi</a></li>
<li><a href="http://ruby-doc.com/docs/ProgrammingRuby/" target="_blank" rel="external">Programming Ruby: The Pragmatic Programmer’s Guide</a></li>
<li><a href="http://www.runoob.com/ruby/ruby-regular-expressions.html" target="_blank" rel="external">Ruby 正则表达式</a></li>
<li><a href="http://www.runoob.com/ruby/ruby-range.html" target="_blank" rel="external">Ruby 区间(range)</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>学编程就好比学有用，再好的理论也不如一头扎下水，扑腾着呼吸新鲜空气管用。这个系列的目的，就是帮助自己跳入水中，这一次我们来学 Ruby。</p>]]>
    
    </summary>
    
      <category term="Ruby" scheme="http://wdxtub.com/tags/Ruby/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="语言" scheme="http://wdxtub.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 习题课 6 设计模式进阶练习]]></title>
    <link href="http://wdxtub.com/2016/03/30/sad-r6/"/>
    <id>http://wdxtub.com/2016/03/30/sad-r6/</id>
    <published>2016-03-30T11:11:03.000Z</published>
    <updated>2016-04-02T20:46:16.000Z</updated>
    <content type="html"><![CDATA[<p>接着上次的练习，这次给出具体场景，来进行设计模式的应用，咱们直接看习题。</p>
<a id="more"></a>
<hr>
<blockquote>
<p>简单来说就是不同等级的领导可以批不同价格的订单，超出了价格范围就需要提交给上一级审批，这个时候用什么设计模式呢？如果具体的限制因素不止价格一个呢？</p>
</blockquote>
<p>顾名思义，直接用『责任链模式』。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DecisionMaker.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DecisionMaker</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> director = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> vp = <span class="number">25000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> president = <span class="number">100000</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">protected</span> string title;</span><br><span class="line">    <span class="comment">// next element in the chain</span></span><br><span class="line">    <span class="keyword">protected</span> DecisionMaker nextDM;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextDM</span><span class="params">(DecisionMaker dm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextDM = dm;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeDecision</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.price &gt; <span class="number">0</span> &amp;&amp; price &lt;= <span class="keyword">this</span>.price)&#123;</span><br><span class="line">            System.out.println(title + <span class="string">"can make the decision for price "</span>  + price);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextDM != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Handle to higher level decision maker"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DirectorDM.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectorDM</span> <span class="keyword">extends</span> <span class="title">DecisionMaker</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectorDM</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VPDM.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VPDM</span> <span class="keyword">extends</span> <span class="title">DecisionMaker</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VPDM</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PresidentDM.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PresidentDM</span> <span class="keyword">extends</span> <span class="title">DecisionMaker</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PresidentDM</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExecutiveMeetingDM</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutiveMeetingDM</span> <span class="keyword">extends</span> <span class="title">DecisionMaker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutiveMeetingDM</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DMDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DMDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DecisionMaker <span class="title">getChainOfDMs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DecisionMaker director = <span class="keyword">new</span> DirectorDM(<span class="number">10000</span>);</span><br><span class="line">        DecisionMaker vp = <span class="keyword">new</span> VPDM(<span class="number">25000</span>);</span><br><span class="line">        DecisionMaker president = <span class="keyword">new</span> PresidentDM(<span class="number">100000</span>);</span><br><span class="line">        <span class="comment">// -1 means infinitive</span></span><br><span class="line">        DecisionMaker exemeet = <span class="keyword">new</span> ExecutiveMeetingDM(-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        director.setNextDM(vp);</span><br><span class="line">        vp.setNextDM(president);</span><br><span class="line">        prsident.setNextDM(exemeet);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> director;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DecisionMaker dmChain = getChainofDMs();</span><br><span class="line">        </span><br><span class="line">        dmChain.makeDecision(<span class="number">5000</span>);</span><br><span class="line">        dmChain.makeDecision(<span class="number">12000</span>);</span><br><span class="line">        dmChain.makeDecision(<span class="number">32000</span>);</span><br><span class="line">        dmChain.makeDecision(<span class="number">302000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>机场一般由塔台统一协调控制，各个飞机之间不会有练习沟通，这里更适合用什么设计模式？</p>
</blockquote>
<p>一般使用中介者模式，用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tower.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Plane plane)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"["</span> + plane.toString() + <span class="string">"] Requested."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Plane.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plane</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String company;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plane</span><span class="params">(String c, String co)</span></span>&#123;</span><br><span class="line">        company = c;</span><br><span class="line">        code = co;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">sendRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Tower.handleRequest(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toSring</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> company + <span class="string">"-"</span> + code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Airport.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Airport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Plane p1 = <span class="keyword">new</span> Plane(<span class="string">"AA"</span>, <span class="string">"1000"</span>);</span><br><span class="line">        Plane p2 = <span class="keyword">new</span> Plane(<span class="string">"Delta"</span>, <span class="string">"2000"</span>);</span><br><span class="line">        </span><br><span class="line">        p1.sendRequest();</span><br><span class="line">        p2.sendRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CPU 的调度算法一般是 Round Robin，什么设计模式比较合适呢？画出类图并写出伪代码。</p>
</blockquote>
<p>（注）这个模式我也不是很确定</p>
<p>前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。</p>
<p>图和伪代码略</p>
<blockquote>
<p>弄一个消息系统，可以广播给所有的订阅者，什么设计模式比较合适呢？画出类图并写出伪代码。</p>
</blockquote>
<p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。</p>
<p>图和伪代码略</p>
<blockquote>
<p>同一个社区的方法除了颜色基本一致，什么设计模式比较合适呢？画出类图并写出伪代码。</p>
</blockquote>
<p>（注）这个模式我也不是很确定</p>
<p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>
<p>图和伪代码略</p>
<blockquote>
<p>给出一个实际生活中使用状态模式的例子</p>
</blockquote>
<p>编译器的词法解析器</p>
<blockquote>
<p>给出一个实际生活中使用状态模式的例子</p>
</blockquote>
<p>JSON 解析器</p>
<blockquote>
<p>给出一个实际生活中使用命令模式的例子</p>
</blockquote>
<p>各种 shell</p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html" target="_blank" rel="external">责任链模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/mediator-pattern.html" target="_blank" rel="external">中介者模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/front-controller-pattern.html" target="_blank" rel="external">前端控制器模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/observer-pattern.html" target="_blank" rel="external">观察者模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/flyweight-pattern.html" target="_blank" rel="external">享元模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/state-pattern.html" target="_blank" rel="external">状态模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/visitor-pattern.html" target="_blank" rel="external">访问者模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/command-pattern.html" target="_blank" rel="external">命令模式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>接着上次的练习，这次给出具体场景，来进行设计模式的应用，咱们直接看习题。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="习题" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 反思课 4 HBase 优化的策略与思考]]></title>
    <link href="http://wdxtub.com/2016/03/29/cc-rethink-4/"/>
    <id>http://wdxtub.com/2016/03/29/cc-rethink-4/</id>
    <published>2016-03-30T00:18:51.000Z</published>
    <updated>2016-03-30T03:44:46.000Z</updated>
    <content type="html"><![CDATA[<p>优化的最大敌人，是反向优化。</p>
<a id="more"></a>
<hr>
<p>这次的小组作业还是挺费事费时的，虽然我也还没有做到满分，但是这两天的一些尝试还是值得记录一下的，也算是给大家提个醒。一个很深的感触：捷径就是把该走的该经历的都过完，想歪门邪道一步登天的，往往都是绕远路。</p>
<h2 id="u6570_u636E_u5904_u7406"><a href="#u6570_u636E_u5904_u7406" class="headerlink" title="数据处理"></a>数据处理</h2><p>这部分的任务可能是这次作业我做得最不好的地方，主要是因为没有在动手前设计好整个流程思路。因为时间紧，没有仔细分析问题和情境，但最终欲速则不达，像无头苍蝇一样试验各种方法出各种差错。盲目乐观和照搬 MySQL 部分的实现思路（我负责 HBase 部分），遇到问题之后依靠『侥幸』而不是『思考』来解决问题，实在是大失水准。</p>
<p>具体来看，主要有：</p>
<ol>
<li>合并数据时候实现算法不细致，用测试集测试的时候没有检查出错误，到最后导入完数据开始部署好了才发现错，每次导入+部署的半个多小时就因为这里的失误而浪费了</li>
<li>处理数据的流程没有事先规划好，遇到错误拆东墙补西墙，最后全部推倒重来才做好，以后不能再这样</li>
<li>没有设计好测试用例，导致每个步骤都不知道自己对不对，依靠『侥幸』写代码肯定要出大问题</li>
</ol>
<p>时间再紧也要谋定而后动，战略偷懒只会导致战术回旋空间变小，最终导致各种『无用功』。</p>
<h2 id="u5E73_u53F0_u9009_u62E9"><a href="#u5E73_u53F0_u9009_u62E9" class="headerlink" title="平台选择"></a>平台选择</h2><p>原先使用 Amazon EMR 来搭建 HBase，主要有几个问题：</p>
<ol>
<li>HBase 版本较低</li>
<li>没办法随时调整参数（虽然后来意识到参数是浮云）</li>
<li>性能糟糕（当然也可能是我不会用）</li>
<li>贵（除了机器本身的费用，EMR 也是要钱的）</li>
</ol>
<p>所以后来选择使用 Cloudera 来搭建自己的 Hadoop 框架平台。因为老师没有给出太多相关的资料，基本上就是一边看着文档，一个坑一个坑踩过来的。虽然没有 Amazon EMR 这么简单粗暴，但是后来看到性能明显提升，也就值得了。总的来说有以下的感觉：</p>
<ol>
<li>配置的过程其实已经尽可能简化了，基本需要手动操作的就是把交换空间设为 0，其他基本都可以在网络界面上完成（Cloudera 做得还是挺不错的，好顶赞）</li>
<li>根据自己的需要选择合适的服务，多的话用不上还占内存</li>
<li>多多利用 Cloudera 的监控表盘可以得到很多有用的信息，据此可以找到瓶颈所在</li>
<li>RegionServer 中 Region 的分布平衡很重要，Region 不能太少也不能太多，没有所谓定值，需要不断测试和优化（实在不行的话，多 split 几次也没啥问题）</li>
<li>很多参数其实不懂具体的含义，对于这种大的平台还是需要仔细研究才能真正把强大的工具用好</li>
<li>Cloudera 已经进行了一定的参数优化，基本上不用改动（尤其是在自己都不知道自己在干嘛的时候）</li>
</ol>
<p>最后就是想要强调监控数据的重要性，如何挑选需要的数据，如何去分析这些数据里面都有门道，要好好学习。</p>
<h2 id="u53C2_u6570_u8BBE_u7F6E"><a href="#u53C2_u6570_u8BBE_u7F6E" class="headerlink" title="参数设置"></a>参数设置</h2><p>忽然想到这么一句话</p>
<blockquote>
<p>按照大多数人数据库设计和代码实现的糟糕程度，根本轮不到拼参数</p>
</blockquote>
<p>像我这样的初学者，往往过分夸大了参数的重要性，只有当系统达到了瓶颈，然后对应去调整相关参数才是有意义的。按照我之前的做法，既不知道问题在哪，更谈不上硬件的充分利用，就盲目根据网上的教程来进行『优化』，所做的基本都是『反向优化』。</p>
<p>所以这个时候搜索相关网页以及请教同学都是非常有帮助的，有了大致的方向会好很多，不然在一无所知的情况下真的很容易病急乱投医。</p>
<p>不同参数的设置一定要弄清楚具体代表什么，什么时候需要改，改了会有什么影响这一系列问题之后，再进行修改测试。</p>
<p>总的来说还是学到不少东西的，以后早些开始，继续努力。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>优化的最大敌人，是反向优化。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="优化" scheme="http://wdxtub.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[范式转移]]></title>
    <link href="http://wdxtub.com/2016/03/27/paradigm-shift/"/>
    <id>http://wdxtub.com/2016/03/27/paradigm-shift/</id>
    <published>2016-03-28T00:18:45.000Z</published>
    <updated>2016-03-28T02:19:32.000Z</updated>
    <content type="html"><![CDATA[<p>所谓范式，是一套非常清晰的概念、思维模式、研究方法、假设和标准。从这些基准出发，我们可以推导演绎出『真理』。但假如有一天，基准改变了，是不是这些『真理』，也就不再『真』了？</p>
<a id="more"></a>
<hr>
<p>前段时间知道了『范式转移』这个概念，感觉很有意思，但是拖着拖着一直到今天才动笔。一是懒，二是最近生活中的一些变化也印证了『范式转移』本身，能够说道说道了。</p>
<p>简单来说，范式转移可以看做是一种根本假设的改变，继而带来翻天覆地的影响。对于我们来说，范式转移更应该接近于『范式升级』，我们要改变的不仅是思维，而是对事物对人情的更准确更基本的认识。</p>
<p>从去年九十月份开始一路面试了半年，了解了许多之前不熟悉的圈子，接触了不同的行业、公司、职位。虽然通过面试官来了解一个公司有些『管中窥豹』，但是至少要比从新闻中得来的要真实。毕竟新闻里说得都是最好的一面，刚入职的话，更可能接触的就是面试官一级的人。大公司选组更像是摇骰子，小公司更多时候是跟着创始人的想法走。我既不想把未来寄托于概率，也不想丢掉太多的自主性，那么正在发展转型期的已经证明自己的公司恐怕是最佳的选择，既可以通过自己的努力主导技术及业务方向，又可以不被各种制度流程所束缚。</p>
<p>从学生向社会人转变，其实就是一个『范式转移』的过程。校园是静态的，成绩、奖项以及几乎固定的同学；只要分数高，很多事儿都不是事儿；社会是动态的，环境、形势一直在变；前行路上难免磕磕碰碰，荣时知辱，逆时知顺。</p>
<p>在选择职业选择公司的时候，重要的是『三观一致』，知道自己的价值，去最能发光发热的地方去。</p>
<blockquote>
<p>一个人的命运，当然要靠自我奋斗，但是也要考虑到历史的行程。</p>
</blockquote>
<p>职业发展一定要从长远的角度思考，慢慢去摸索未来与趋势，顺势而为。俗一点说，在大家都能赚钱的时候才最好赚钱。与人相处，也更应该『职业』一些，以合作为主、待人接物自然（不要凡事都写在脸上），珍惜别人的时间，让身边的人变得更好，从更大的格局去看待问题。</p>
<p>另外，从课程考试向『做成事情』转变，也是重中之重。很多时候，我们是因为没有能力做好手头上的事情，所以才不喜欢。而越是工作做不好的无用之人，就越是会强调自己有多努力。</p>
<p>无论是在学校还是在公司，重要的不是分数的高低还是职位的级别，而是全身心投入，去验证自己的想法。不要专门去做那些证明自己的事情，事实会说明一切。</p>
<p>这也是为什么我决定从 iOS 开发转到后台系统的开发。iOS 实在太火了，各种培训班批量生产学员搞得乌烟瘴气（最近的前端热估计也是这个套路），开发一款基本的应用难度也越来越低。当然，高端人才总是稀缺的，但是有这样的大环境在，又岂能独善其身呢？</p>
<p>做成事情的重点是策略和坚持，而坚持就是最重要的策略。越来越觉得，无论是编程、雕刻还是建筑，都是技术加艺术的结晶，天赋固然重要，但刻苦练习也是不可或缺的。想要做成事情，不把手弄『脏』是不可能的。</p>
<p>于是主题就变成：范式转移了吗？手弄脏了吗？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>所谓范式，是一套非常清晰的概念、思维模式、研究方法、假设和标准。从这些基准出发，我们可以推导演绎出『真理』。但假如有一天，基准改变了，是不是这些『真理』，也就不再『真』了？</p>]]>
    
    </summary>
    
      <category term="改变" scheme="http://wdxtub.com/tags/%E6%94%B9%E5%8F%98/"/>
    
      <category term="范式" scheme="http://wdxtub.com/tags/%E8%8C%83%E5%BC%8F/"/>
    
      <category term="远见" scheme="http://wdxtub.com/tags/%E8%BF%9C%E8%A7%81/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【鸟哥的 Linux 私房菜 - 基础】学习笔记]]></title>
    <link href="http://wdxtub.com/2016/03/26/linux-basic-soup/"/>
    <id>http://wdxtub.com/2016/03/26/linux-basic-soup/</id>
    <published>2016-03-27T01:33:53.000Z</published>
    <updated>2016-03-27T17:20:41.000Z</updated>
    <content type="html"><![CDATA[<p>因为之后更多会涉及后台开发的部分，所以系统学习一下 Linux 还是很有必要的，这里就用《鸟哥的 Linux 私房菜》作为主要的学习材料。不过因为我本身已经有一定基础了，所以这里主要会记录个人觉得比较生疏和重要的地方。</p>
<a id="more"></a>
<hr>
<p>对于计算机的基本了解，可以参考我之前写的『深入理解计算机系统』系列日志。接下来主要是比较零散的知识点，具体可以参见目录。</p>
<h2 id="u5E38_u7528_u6280_u5DE7"><a href="#u5E38_u7528_u6280_u5DE7" class="headerlink" title="常用技巧"></a>常用技巧</h2><ul>
<li>遇到不懂的命令，一定先用 <code>man</code> 命令来了解一下，可以看到详细的介绍<ul>
<li><code>/string</code> 向下搜索 string 这个字符串</li>
<li><code>?string</code> 向上搜索这个字符串</li>
<li>搜索的时候输入 n, N 可以跳到下一个/上一个结果 ，q 可以退出</li>
</ul>
</li>
<li>遇到不懂的命令，可以使用 <code>info</code> 命令来查看<ul>
<li>n（下一个），p（前一个），u（上一层），h（帮助），q（退出）</li>
</ul>
</li>
<li>nano 是非常简单的编辑器，只需要 <code>nano filename</code> 即可，具体的操作会在终端中显示<ul>
<li><code>^</code> 表示 ctrl 按键</li>
</ul>
</li>
<li>改变文件属性与权限的命令<ul>
<li><code>chgrp</code>：改变文件所属群组</li>
<li><code>chown</code>：改变文件拥有者</li>
<li><code>chmod</code>：改变文件权限</li>
</ul>
</li>
<li>目录相关操作<ul>
<li><code>.</code>：代表此层目录</li>
<li><code>..</code>：代表上一层目录</li>
<li><code>-</code>：代表前一个工作目录</li>
<li><code>~</code>：代表“目前使用者身份”所在的主文件夹</li>
<li><code>~account</code>：代表 account 这个使用者的主文件夹（account是个帐号名称）</li>
<li>在所有目录下面都会存在的两个目录，分别是“.”与“..” 分别代表此层与上层目录的意思</li>
<li><code>cd</code>：变化目录</li>
<li><code>pwd</code>：显示目前目录</li>
<li><code>mkdir</code>：创建新目录</li>
<li><code>rmdir</code>：删除一个空的目录</li>
</ul>
</li>
<li>可执行文件路径变量 <code>$PATH</code><ul>
<li>当我们在执行一个指令的时候，举例来说“ls”好了，系统会依照PATH的设置去每个PATH定义的目录下搜寻文件名为ls的可执行文件， 如果在PATH定义的目录中含有多个文件名为ls的可可执行文件，那么先搜寻到的同名指令先被执行！</li>
<li><code>echo $PATH</code> 来查看当前的值</li>
</ul>
</li>
</ul>
<h2 id="u547D_u4EE4_3A_ls_2C_cp_2C_rm_2C_mv"><a href="#u547D_u4EE4_3A_ls_2C_cp_2C_rm_2C_mv" class="headerlink" title="命令: ls, cp, rm, mv"></a>命令: ls, cp, rm, mv</h2><blockquote>
<p>ls 用来查看文件与目录，选项与参数为：</p>
</blockquote>
<ul>
<li><code>-a</code>：全部的文件，连同隐藏文件（ 开头为 . 的文件） 一起列出来（常用）</li>
<li><code>-A</code>：全部的文件，连同隐藏文件，但不包括 . 与 .. 这两个目录</li>
<li><code>-d</code>：仅列出目录本身，而不是列出目录内的文件数据（常用）</li>
<li><code>-f</code>：直接列出结果，而不进行排序 （ls 默认会以文件名排序！）</li>
<li><code>-F</code>：根据文件、目录等信息，给予附加数据结构，例如：<code>*:</code> 代表可可执行文件； <code>/:</code> 代表目录； <code>=:</code> 代表 socket 文件； <code>|:</code> 代表 FIFO 文件；</li>
<li><code>-h</code>：将文件大小以人类较易读的方式（例如 GB, KB 等等）列出来；</li>
<li><code>-i</code>：列出 inode 号码，inode 的意义下一章将会介绍；</li>
<li><code>-l</code>：长数据串行出，包含文件的属性与权限等等数据；（常用）</li>
<li><code>-n</code>：列出 UID 与 GID 而非使用者与群组的名称 （UID与GID会在帐号管理提到！）</li>
<li><code>-r</code>：将排序结果反向输出，例如：原本文件名由小到大，反向则为由大到小；</li>
<li><code>-R</code>：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来；</li>
<li><code>-S</code>：以文件大小大小排序，而不是用文件名排序；</li>
<li><code>-t</code>：依时间排序，而不是用文件名。</li>
<li><code>--color=never</code>：不要依据文件特性给予颜色显示；</li>
<li><code>--color=always</code>：显示颜色</li>
<li><code>--color=auto</code>：让系统自行依据设置来判断是否给予颜色</li>
<li><code>--full-time</code>：以完整时间模式 （包含年、月、日、时、分） 输出</li>
<li><code>--time={atime,ctime}</code>：输出 access 时间或改变权限属性时间 （ctime） 而非内容变更时间 （modification time）</li>
</ul>
<blockquote>
<p>cp 用来复制文件或者创建链接，选项与参数为：</p>
</blockquote>
<ul>
<li><code>-a</code>：相当于 -dr –preserve=all 的意思，至于 dr 请参考下列说明；（常用）</li>
<li><code>-d</code>：若来源文件为链接文件的属性（link file），则复制链接文件属性而非文件本身；</li>
<li><code>-f</code>：为强制（force）的意思，若目标文件已经存在且无法打开，则移除后再尝试一次；</li>
<li><code>-i</code>：若目标文件（destination）已经存在时，在覆盖时会先询问动作的进行（常用）</li>
<li><code>-l</code>：进行硬式链接（hard link）的链接文件创建，而非复制文件本身；</li>
<li><code>-p</code>：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）；</li>
<li><code>-r</code>：递回持续复制，用于目录的复制行为；（常用）</li>
<li><code>-s</code>：复制成为符号链接文件 （symbolic link），亦即“捷径”文件；</li>
<li><code>-u</code>：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制。</li>
<li><code>--preserve=all</code>：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了。最后需要注意的，如果来源文件有两个以上，则最后一个目的文件一定要是“目录”才行！</li>
</ul>
<blockquote>
<p>mv 用来移动文件或者重命名，选项与参数为：</p>
</blockquote>
<ul>
<li><code>-f</code>：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li><code>-i</code>：若目标文件 （destination） 已经存在时，就会询问是否覆盖！</li>
<li><code>-u</code>：若目标文件已经存在，且 source 比较新，才会更新 （update）</li>
</ul>
<blockquote>
<p>rm 用来删除文件，选项与参数为：</p>
</blockquote>
<ul>
<li><code>-f</code>：就是 force 的意思，忽略不存在的文件，不会出现警告讯息；</li>
<li><code>-i</code>：互动模式，在删除前会询问使用者是否动作</li>
<li><code>-r</code>：递回删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
</ul>
<h2 id="u547D_u4EE4_3A_cat_2C_tac_2C_nl_2C_more_2C_less"><a href="#u547D_u4EE4_3A_cat_2C_tac_2C_nl_2C_more_2C_less" class="headerlink" title="命令: cat, tac, nl, more, less"></a>命令: cat, tac, nl, more, less</h2><blockquote>
<p>cat 由第一行开始显示文件内容</p>
</blockquote>
<ul>
<li><code>-A</code>：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li><code>-b</code>：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li><code>-E</code>：将结尾的断行字符 $ 显示出来；</li>
<li><code>-n</code>：打印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li><code>-T</code>：将 [tab] 按键以 ^I 显示出来；</li>
<li><code>-v</code>：列出一些看不出来的特殊字符</li>
</ul>
<blockquote>
<p>tac  从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</p>
</blockquote>
<p>具体的参数和 cat 是一致的，这里不赘述</p>
<blockquote>
<p>nl   显示的时候，顺道输出行号！</p>
</blockquote>
<ul>
<li><code>-b</code>：指定行号指定的方式，主要有两种：<ul>
<li><code>-b a</code>：表示不论是否为空行，也同样列出行号（类似 cat -n）；</li>
<li><code>-b t</code>：如果有空行，空的那一行不要列出行号（默认值）；</li>
</ul>
</li>
<li><code>-n</code>：列出行号表示的方法，主要有三种：<ul>
<li><code>-n ln</code>：行号在屏幕的最左方显示；</li>
<li><code>-n rn</code>：行号在自己字段的最右方显示，且不加 0 ；</li>
<li><code>-n rz</code>：行号在自己字段的最右方显示，且加 0 ；</li>
</ul>
</li>
<li><code>-w</code>：行号字段的占用的字符数。</li>
</ul>
<blockquote>
<p>more 一页一页的显示文件内容，支持的按键有</p>
</blockquote>
<ul>
<li><code>空格</code>：代表向下翻一页；</li>
<li><code>Enter</code>：代表向下翻“一行”；</li>
<li><code>/字串</code>：代表在这个显示的内容当中，向下搜寻“字串”这个关键字；</li>
<li><code>:f</code>：立刻显示出文件名以及目前显示的行数；</li>
<li><code>q</code>：代表立刻离开 more ，不再显示该文件内容。</li>
<li><code>b 或 [ctrl]-b</code>：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<blockquote>
<p>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！支持的按键有</p>
</blockquote>
<ul>
<li><code>空格</code>：向下翻动一页；</li>
<li><code>[pagedown]</code>：向下翻动一页；</li>
<li><code>[pageup]</code>：向上翻动一页；</li>
<li><code>/字串</code>：向下搜寻“字串”的功能；</li>
<li><code>?字串</code>：向上搜寻“字串”的功能；</li>
<li><code>n</code>：重复前一个搜寻 （与 / 或 ? 有关！）</li>
<li><code>N</code>：反向的重复前一个搜寻 （与 / 或 ? 有关！）</li>
<li><code>g</code>：前进到这个数据的第一行去；</li>
<li><code>G</code>：前进到这个数据的最后一行去 （注意大小写）；</li>
<li><code>q</code>：离开 less 这个程序；</li>
</ul>
<p>你是否会觉得 less 使用的画面与环境与 man page 非常的类似呢？没错啦！因为man这个指令就是调用 less 来显示说明文档的内容的！</p>
<h2 id="u547D_u4EE4_3A_head_2C_tail_2C_od_2C_touch"><a href="#u547D_u4EE4_3A_head_2C_tail_2C_od_2C_touch" class="headerlink" title="命令: head, tail, od, touch"></a>命令: head, tail, od, touch</h2><blockquote>
<p>head 只看头几行</p>
</blockquote>
<ul>
<li><code>-n</code>：后面接数字，代表显示几行的意思</li>
<li>另外那个 -n 选项后面的参数较有趣，如果接的是负数，例如上面范例的 -n -100时，代表列前的所有行数， 但不包括后面100行</li>
</ul>
<blockquote>
<p>tail 只看尾巴几行</p>
</blockquote>
<ul>
<li><code>-n</code>：后面接数字，代表显示几行的意思</li>
<li><code>-f</code>：表示持续侦测后面所接的文件名，要等到按下[ctrl]-c才会结束tail的侦测</li>
</ul>
<blockquote>
<p>od 以二进制的方式读取文件内容！</p>
</blockquote>
<ul>
<li><code>-t</code>：后面可以接各种“类型 （TYPE）”的输出，例如：<ul>
<li><code>a</code>：利用默认的字符来输出；</li>
<li><code>c</code>：使用 ASCII 字符来输出</li>
<li><code>d[size]</code>：利用十进制（decimal）来输出数据，每个整数占用 size Bytes ；</li>
<li><code>f[size]</code>：利用浮点数值（floating）来输出数据，每个数占用 size Bytes ；</li>
<li><code>o[size]</code>：利用八进位（octal）来输出数据，每个整数占用 size Bytes ；</li>
<li><code>x[size]</code>：利用十六进制（hexadecimal）来输出数据，每个整数占用 size Bytes ；</li>
</ul>
</li>
</ul>
<blockquote>
<p>touch 修改文件时间或创建新文件</p>
</blockquote>
<p>我们在 ls 这个指令的介绍时，有稍微提到每个文件在linux下面都会记录许多的时间参数， 其实是有三个主要的变动时间，那么三个时间的意义是什么呢？</p>
<ul>
<li>modification time （mtime）：<ul>
<li>当该文件的“内容数据”变更时，就会更新这个时间！内容数据指的是文件的内容，而不是文件的属性或权限喔！</li>
</ul>
</li>
<li>status time （ctime）：<ul>
<li>当该文件的“状态 （status）”改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间啊。</li>
</ul>
</li>
<li>access time （atime）：<ul>
<li>当“该文件的内容被取用”时，就会更新这个读取时间 （access）。举例来说，我们使用 cat 去读取 /etc/man_db.conf ， 就会更新该文件的 atime 了。</li>
</ul>
</li>
</ul>
<p>选项与参数</p>
<ul>
<li><code>-a</code>：仅修订 access time；</li>
<li><code>-c</code>：仅修改文件的时间，若该文件不存在则不创建新文件；</li>
<li><code>-d</code>：后面可以接欲修订的日期而不用目前的日期，也可以使用 –date=”日期或时间”</li>
<li><code>-m</code>：仅修改 mtime ；</li>
<li><code>-t</code>：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]</li>
</ul>
<h2 id="u547D_u4EE4_3A_file_2C_which_2C_whereis_2C_locate/updatedb_2C_find"><a href="#u547D_u4EE4_3A_file_2C_which_2C_whereis_2C_locate/updatedb_2C_find" class="headerlink" title="命令: file, which, whereis, locate/updatedb, find"></a>命令: file, which, whereis, locate/updatedb, find</h2><blockquote>
<p>file 观察文件类型</p>
</blockquote>
<p>如果你想要知道某个文件的基本数据，例如是属于 ASCII 或者是 data 文件，或者是 binary ， 且其中有没有使用到动态函数库 （share library） 等等的信息，就可以利用 file 这个指令来检阅喔！</p>
<blockquote>
<p>which 指令文件名的搜寻 </p>
</blockquote>
<p><code>which [-a] command</code> 选项或参数：</p>
<ul>
<li><code>-a</code>：将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称</li>
</ul>
<blockquote>
<p>whereis 由一些特定的目录中寻找文件文件名</p>
</blockquote>
<p><code>whereis [-bmsu] 文件或目录名</code>  选项或参数：</p>
<ul>
<li><code>-l</code>:可以列出 whereis 会去查询的几个主要目录而已</li>
<li><code>-b</code>:只找 binary 格式的文件</li>
<li><code>-m</code>:只找在说明文档 manual 路径下的文件</li>
<li><code>-s</code>:只找 source 来源文件</li>
<li><code>-u</code>:搜寻不在上述三个项目当中的其他特殊文件</li>
</ul>
<blockquote>
<p>locate 搜索包含指定词的文件</p>
</blockquote>
<p><code>locate [-ir] keyword</code> 选项与参数：</p>
<ul>
<li><code>-i</code>：忽略大小写的差异；</li>
<li><code>-c</code>：不输出文件名，仅计算找到的文件数量</li>
<li><code>-l</code>：仅输出几行的意思，例如输出五行则是 -l 5</li>
<li><code>-S</code>：输出 locate 所使用的数据库文件的相关信息，包括该数据库纪录的文件/目录数量等</li>
<li><code>-r</code>：后面可接正则表达式的显示方式</li>
</ul>
<p>locate 寻找的数据是由“已创建的数据库 /var/lib/mlocate/” 里面的数据所搜寻到的，所以不用直接在去硬盘当中存取数据。那么有什么限制呢？就是因为他是经由数据库来搜寻的，而数据库的创建默认是在每天执行一次 </p>
<p>那能否手动更新数据库哪？当然可以啊！更新 locate 数据库的方法非常简单，直接输入“ updatedb ”就可以了！ updatedb 指令会去读取 /etc/updatedb.conf 这个配置文件的设置，然后再去硬盘里面进行搜寻文件名的动作， 最后就更新整个数据库文件啰！因为 updatedb 会去搜寻硬盘，所以当你执行 updatedb 时，可能会等待数分钟的时间喔！</p>
<blockquote>
<p>find 查找具体文件</p>
</blockquote>
<p><code>find [PATH] [option] [action]</code> 选项与参数：</p>
<ul>
<li>与时间有关的选项：共有 -atime, -ctime 与 -mtime ，以 -mtime 说明<ul>
<li><code>-mtime  n</code>：n 为数字，意义为在 n 天之前的“一天之内”被更动过内容的文件；</li>
<li><code>-mtime +n</code>：列出在 n 天之前（不含 n 天本身）被更动过内容的文件文件名；</li>
<li><code>-mtime -n</code>：列出在 n 天之内（含 n 天本身）被更动过内容的文件文件名。</li>
<li><code>-newer file</code>：file 为一个存在的文件，列出比 file 还要新的文件文件名</li>
</ul>
</li>
<li>与使用者或群组名称有关的参数<ul>
<li><code>-uid n</code>：n 为数字，这个数字是使用者的帐号 ID，亦即 UID ，这个 UID 是记录在 /etc/passwd 里面与帐号名称对应的数字。</li>
<li><code>-gid n</code>：n 为数字，这个数字是群组名称的 ID，亦即 GID，这个 GID 记录在/etc/group</li>
<li><code>-user name</code>：name 为使用者帐号名称喔！例如 dmtsai </li>
<li><code>-group name</code>：name 为群组名称喔，例如 users ；</li>
<li><code>-nouser</code>：寻找文件的拥有者不存在 /etc/passwd 的人！</li>
<li><code>-nogroup</code>：寻找文件的拥有群组不存在于 /etc/group 的文件！</li>
<li>当你自行安装软件时，很可能该软件的属性当中并没有文件拥有者，这是可能的！在这个时候，就可以使用 -nouser 与 -nogroup 搜寻。</li>
</ul>
</li>
<li>与文件权限及名称有关的参数：<ul>
<li><code>-name filename</code>：搜寻文件名称为 filename 的文件；</li>
<li><code>-size [+-]SIZE</code>：搜寻比 SIZE 还要大（+）或小（-）的文件。这个 SIZE 的规格有：<ul>
<li><code>c</code>: 代表 Byte</li>
<li><code>k</code>: 代表 1024Bytes</li>
<li>所以，要找比 50KB 还要大的文件，就是 <code>-size +50k</code></li>
</ul>
</li>
<li><code>-type TYPE</code>：搜寻文件的类型为 TYPE 的，类型主要有：一般正规文件 （f）, 设备文件 （b, c）,目录 （d）, 链接文件 （l）, socket （s）, 及 FIFO （p） 等属性。</li>
<li><code>-perm mode</code>：搜寻文件权限“刚好等于” mode 的文件，这个 mode 为类似 chmod 的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！</li>
<li><code>-perm -mode</code>：搜寻文件权限“必须要全部囊括 mode 的权限”的文件，举例来说，我们要搜寻 <code>-rwxr--r--</code> ，亦即 0744 的文件，使用 <code>-perm -0744</code>，当一个文件的权限为 <code>-rwsr-xr-x</code> ，亦即 4755 时，也会被列出来，因为 <code>-rwsr-xr-x</code> 的属性已经囊括了 <code>-rwxr--r--</code> 的属性了。</li>
<li><code>-perm /mode</code>：搜寻文件权限“包含任一 mode 的权限”的文件，举例来说，我们搜寻 <code>-rwxr-xr-x</code> ，亦即 <code>-perm /755</code> 时，但一个文件属性为 <code>-rw-------</code> 也会被列出来，因为他有 <code>-rw....</code> 的属性存在！</li>
</ul>
</li>
</ul>
<h2 id="u547D_u4EE4_3A_gzip_2C_zcat/zmore/zless/zgrep"><a href="#u547D_u4EE4_3A_gzip_2C_zcat/zmore/zless/zgrep" class="headerlink" title="命令: gzip, zcat/zmore/zless/zgrep"></a>命令: gzip, zcat/zmore/zless/zgrep</h2><p>gzip 可以说是应用度最广的压缩指令了！目前 gzip 可以解开 compress, zip 与 gzip 等软件所压缩的文件。 至于 gzip 所创建的压缩文件为 *.gz 的文件名喔！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip [-cdtv<span class="comment">#] 文件名</span></span><br><span class="line">zcat 文件名.gz</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-c</code>：将压缩的数据输出到屏幕上，可通过数据流重导向来处理；</li>
<li><code>-d</code>：解压缩的参数；</li>
<li><code>-t</code>：可以用来检验一个压缩文件的一致性～看看文件有无错误；</li>
<li><code>-v</code>：可以显示出原文件/压缩文件的压缩比等信息；</li>
<li><code>-#</code>：# 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！默认是 -6</li>
</ul>
<p>当你使用 gzip 进行压缩时，在默认的状态下原本的文件会被压缩成为 .gz 的文件名，原始文件就不再存在了。 </p>
<p>cat/more/less 可以使用不同的方式来读取纯文本文件，那个 zcat/zmore/zless 则可以对应于 cat/more/less 的方式来读取纯文本文件被压缩后的压缩文件！ 由于 gzip 这个压缩指令主要想要用来取代 compress 的，所以不但 compress 的压缩文件可以使用 gzip 来解开，同时 zcat 这个指令可以同时读取 compress 与 gzip 的压缩文件呦！</p>
<h2 id="u547D_u4EE4_3A_bzip2_2C_bzcat/bzmore/bzless/bzgrep"><a href="#u547D_u4EE4_3A_bzip2_2C_bzcat/bzmore/bzless/bzgrep" class="headerlink" title="命令: bzip2, bzcat/bzmore/bzless/bzgrep"></a>命令: bzip2, bzcat/bzmore/bzless/bzgrep</h2><p>若说 gzip 是为了取代 compress 并提供更好的压缩比而成立的，那么 bzip2 则是为了取代 gzip 并提供更佳的压缩比而来的。 bzip2 真是很不错用的东西～这玩意的压缩比竟然比 gzip 还要好～至于 bzip2 的用法几乎与 gzip 相同！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bzip2 [-cdkzv<span class="comment">#] 文件名</span></span><br><span class="line">bzcat 文件名.bz2</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-c</code>：将压缩的过程产生的数据输出到屏幕上！</li>
<li><code>-d</code>：解压缩的参数</li>
<li><code>-k</code>：保留原始文件，而不会删除原始的文件喔！</li>
<li><code>-z</code>：压缩的参数 （默认值，可以不加）</li>
<li><code>-v</code>：可以显示出原文件/压缩文件的压缩比等信息；</li>
<li><code>-#</code>：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！</li>
</ul>
<h2 id="u547D_u4EE4_3A_tar"><a href="#u547D_u4EE4_3A_tar" class="headerlink" title="命令: tar"></a>命令: tar</h2><p>tar 可以将多个目录或文件打包成一个大文件，同时还可以通过 gzip/bzip2/xz 的支持，将该文件同时进行压缩！ 更有趣的是，由于 tar 的使用太广泛了，目前 Windows 的 WinRAR 也支持 .tar.gz 文件名的解压缩呢！</p>
<p>tar 的选项与参数非常的多！我们只讲几个常用的选项，更多选项您可以自行 man tar 查询啰！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar [-z|-j|-J] [cv] [<span class="operator">-f</span> 待创建的新文件名] filename... &lt;==打包与压缩</span><br><span class="line">tar [-z|-j|-J] [tv] [<span class="operator">-f</span> 既有的 tar文件名]             &lt;==察看文件名</span><br><span class="line">tar [-z|-j|-J] [xv] [<span class="operator">-f</span> 既有的 tar文件名] [-C 目录]   &lt;==解压缩</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-c</code>：创建打包文件，可搭配 -v 来察看过程中被打包的文件名（filename）</li>
<li><code>-t</code>：察看打包文件的内容含有哪些文件名，重点在察看“文件名”就是了；</li>
<li><code>-x</code>：解打包或解压缩的功能，可以搭配 -C （大写） 在特定目录解开特别留意的是， -c, -t, -x 不可同时出现在一串指令列中。</li>
<li><code>-z</code>：通过 gzip  的支持进行压缩/解压缩：此时文件名最好为 *.tar.gz</li>
<li><code>-j</code>：通过 bzip2 的支持进行压缩/解压缩：此时文件名最好为 *.tar.bz2</li>
<li><code>-J</code>：通过 xz    的支持进行压缩/解压缩：此时文件名最好为 *.tar.xz 特别留意， -z, -j, -J 不可以同时出现在一串指令列中</li>
<li><code>-v</code>：在压缩/解压缩的过程中，将正在处理的文件名显示出来！</li>
<li><code>-f filename</code>：-f 后面要立刻接要被处理的文件名！建议 -f 单独写一个选项啰！（比较不会忘记）</li>
<li><code>-C 目录</code>：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。</li>
<li><code>-p</code>：保留备份数据的原本权限与属性，常用于备份（-c）重要的配置文件</li>
<li><code>-P</code>：保留绝对路径，亦即允许备份数据中含有根目录存在之意；</li>
<li><code>--exclude=FILE</code>：在压缩的过程中，不要将 FILE 打包！ </li>
</ul>
<p>tar 并不会主动的产生创建的文件名喔！我们要自订啦！ 所以扩展名就显的很重要了！如果不加 <code>[-z|-j|-J]</code> 的话，文件名最好取为 <code>*.tar</code> 即可。如果是 <code>-j</code>选项，代表有 bzip2 的支持，因此文件名最好就取为 <code>*.tar.bz2</code> ，因为 bzip2 会产生 <code>.bz2</code> 的扩展名之故！ 至于如果是加上了 <code>-z</code> 的 gzip 的支持，那文件名最好取为 <code>*.tar.gz</code> 喔！</p>
<p>另外值得一提的是，tar 打包出来的文件有没有进行压缩所得到文件称呼不同喔！ 如果仅是打包而已，就是 <code>tar -cv -f file.tar</code>而已，这个文件我们称呼为 tarfile 。 如果还有进行压缩的支持，例如 <code>tar -jcv -f file.tar.bz2</code> 时，我们就称呼为 tarball （tar 球？）！这只是一个基本的称谓而已，不过很多书籍与网络都会使用到这个 tarball 的名称！所以得要跟您介绍介绍。</p>
<h2 id="u547D_u4EE4_3A_cut_2C_grep"><a href="#u547D_u4EE4_3A_cut_2C_grep" class="headerlink" title="命令: cut, grep"></a>命令: cut, grep</h2><blockquote>
<p>cut</p>
</blockquote>
<p>cut 不就是“切”吗？没错啦！这个指令可以将一段讯息的某一段给他“切”出来～ 处理的讯息是以“行”为单位喔！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cut <span class="operator">-d</span><span class="string">'分隔字符'</span> <span class="operator">-f</span> fields &lt;==用于有特定分隔字符</span><br><span class="line">cut -c 字符区间            &lt;==用于排列整齐的讯息</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-d</code>：后面接分隔字符。与 -f 一起使用；</li>
<li><code>-f</code>：依据 -d 的分隔字符将一段讯息分区成为数段，用 -f 取出第几段的意思；</li>
<li><code>-c</code>：以字符 （characters） 的单位取出固定字符区间；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 PATH 变量取出，我要找出第五个路径。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;PATH&#125;</span> | cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">5</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;PATH&#125;</span> | cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">3</span>,<span class="number">5</span> <span class="comment"># 找第 3 与第 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：将 export 输出的讯息，取得第 12 字符以后的所有字串</span></span><br><span class="line"><span class="built_in">export</span> | cut -c <span class="number">12</span>-</span><br><span class="line"><span class="comment"># 知道怎么回事了吧？用 -c 可以处理比较具有格式的输出数据！</span></span><br><span class="line"><span class="comment"># 我们还可以指定某个范围的值，例如第 12-20 的字符，就是 cut -c 12-20 等等！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：用 last 将显示的登陆者的信息中，仅留下使用者大名</span></span><br><span class="line">last | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 由输出的结果我们可以发现第一个空白分隔的字段代表帐号，所以使用如上指令：</span></span><br><span class="line"><span class="comment"># 但是因为 root   pts/1 之间空格有好几个，并非仅有一个，所以，如果要找出 </span></span><br><span class="line"><span class="comment"># pts/1 其实不能以 cut -d ' ' -f 1,2 喔！输出的结果会不是我们想要的。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>grep</p>
</blockquote>
<p>刚刚的 cut 是将一行讯息当中，取出某部分我们想要的，而 grep 则是分析一行讯息， 若当中有我们所需要的信息，就将该行拿出来～简单的语法是这样的：</p>
<p><code>grep [-acinv] [--color=auto] &#39;搜寻字串&#39; filename</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-a</code>：将 binary 文件以 text 文件的方式搜寻数据</li>
<li><code>-c</code>：计算找到 ‘搜寻字串’ 的次数</li>
<li><code>-i</code>：忽略大小写的不同，所以大小写视为相同</li>
<li><code>-n</code>：顺便输出行号</li>
<li><code>-v</code>：反向选择，亦即显示出没有 ‘搜寻字串’ 内容的那一行！</li>
<li><code>--color=auto</code>：可以将找到的关键字部分加上颜色的显示喔！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 last 当中，有出现 root 的那一行就取出来；</span></span><br><span class="line">last | grep <span class="string">'root'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：与范例一相反，只要没有 root 的就取出！</span></span><br><span class="line">last | grep -v <span class="string">'root'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：在 last 的输出讯息中，只要有 root 就取出，并且仅取第一栏</span></span><br><span class="line">last | grep <span class="string">'root'</span> | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span>1</span><br><span class="line"><span class="comment"># 在取出 root 之后，利用上个指令 cut 的处理，就能够仅取得第一栏啰！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例四：取出 /etc/man_db.conf 内含 MANPATH 的那几行</span></span><br><span class="line">grep --color=auto <span class="string">'MANPATH'</span> /etc/man_db.conf</span><br><span class="line">....（前面省略）....</span><br><span class="line">MANPATH_MAP     /usr/games              /usr/share/man</span><br><span class="line">MANPATH_MAP     /opt/bin                /opt/man</span><br><span class="line">MANPATH_MAP     /opt/sbin               /opt/man</span><br><span class="line"><span class="comment"># 神奇的是，如果加上 --color=auto 的选项，找到的关键字部分会用特殊颜色显示喔！</span></span><br></pre></td></tr></table></figure>
<h2 id="u547D_u4EE4_3A_sort_2C_wc_2C_uniq"><a href="#u547D_u4EE4_3A_sort_2C_wc_2C_uniq" class="headerlink" title="命令: sort, wc, uniq"></a>命令: sort, wc, uniq</h2><blockquote>
<p>sort</p>
</blockquote>
<p>sort 是很有趣的指令，他可以帮我们进行排序，而且可以依据不同的数据型态来排序喔！ 例如数字与文字的排序就不一样。此外，排序的字符与语系的编码有关，因此， 如果您需要排序时，建议使用 <code>LANG=C</code> 来让语系统一，数据排序比较好一些。</p>
<p><code>sort [-fbMnrtuk] [file or stdin]</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-f</code>：忽略大小写的差异，例如 A 与 a 视为编码相同；</li>
<li><code>-b</code>：忽略最前面的空白字符部分；</li>
<li><code>-M</code>：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；</li>
<li><code>-n</code>：使用“纯数字”进行排序（默认是以文字体态来排序的）；</li>
<li><code>-r</code>：反向排序；</li>
<li><code>-u</code>：就是 uniq ，相同的数据中，仅出现一行代表；</li>
<li><code>-t</code>：分隔符号，默认是用 [tab] 键来分隔；</li>
<li><code>-k</code>：以那个区间 （field） 来进行排序的意思</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：个人帐号都记录在 /etc/passwd 下，请将帐号进行排序。</span></span><br><span class="line">cat /etc/passwd | sort</span><br><span class="line"></span><br><span class="line">abrt:x:<span class="number">173</span>:<span class="number">173</span>::/etc/abrt:/sbin/nologin</span><br><span class="line">adm:x:<span class="number">3</span>:<span class="number">4</span>:adm:/var/adm:/sbin/nologin</span><br><span class="line">alex:x:<span class="number">1001</span>:<span class="number">1002</span>::/home/alex:/bin/bash</span><br><span class="line"><span class="comment"># 鸟哥省略很多的输出～由上面的数据看起来， sort 是默认“以第一个”数据来排序，</span></span><br><span class="line"><span class="comment"># 而且默认是以“文字”型态来排序的喔！所以由 a 开始排到最后啰！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：/etc/passwd 内容是以 : 来分隔的，我想以第三栏来排序，该如何？</span></span><br><span class="line">cat /etc/passwd | sort -t <span class="string">':'</span> -k <span class="number">3</span></span><br><span class="line"></span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">dmtsai:x:<span class="number">1000</span>:<span class="number">1000</span>:dmtsai:/home/dmtsai:/bin/bash</span><br><span class="line">alex:x:<span class="number">1001</span>:<span class="number">1002</span>::/home/alex:/bin/bash</span><br><span class="line">arod:x:<span class="number">1002</span>:<span class="number">1003</span>::/home/arod:/bin/bash</span><br><span class="line"><span class="comment"># 看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～</span></span><br><span class="line"><span class="comment"># 如果是以文字体态来排序的话，原本就会是这样，想要使用数字排序：</span></span><br><span class="line"><span class="comment"># cat /etc/passwd | sort -t ':' -k 3 -n</span></span><br><span class="line"><span class="comment"># 这样才行啊！用那个 -n 来告知 sort 以数字来排序啊！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：利用 last ，将输出的数据仅取帐号，并加以排序</span></span><br><span class="line">last | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span>1 | sort</span><br></pre></td></tr></table></figure>
<blockquote>
<p>wc</p>
</blockquote>
<p>如果我想要知道 /etc/man_db.conf 这个文件里面有多少字？多少行？多少字符的话， 可以怎么做呢？其实可以利用 wc 这个指令来达成喔！他可以帮我们计算输出的讯息的整体数据！</p>
<p><code>wc [-lwm]</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-l</code>：仅列出行；</li>
<li><code>-w</code>：仅列出多少字（英文单字）；</li>
<li><code>-m</code>  ：多少字符；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：那个 /etc/man_db.conf 里面到底有多少相关字、行、字符数？</span></span><br><span class="line">cat /etc/man_db.conf | wc </span><br><span class="line">    <span class="number">131</span>     <span class="number">723</span>    <span class="number">5171</span></span><br><span class="line"><span class="comment"># 输出的三个数字中，分别代表： “行、字数、字符数”</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：我知道使用 last 可以输出登陆者，但是 last 最后两行并非帐号内容，那么请问，我该如何以一行指令串取得登陆系统的总人次？</span></span><br><span class="line">last | grep [a-zA-Z] | grep -v <span class="string">'wtmp'</span> | grep -v <span class="string">'reboot'</span> | \</span><br><span class="line">&gt; grep -v <span class="string">'unknown'</span> |wc <span class="operator">-l</span> </span><br><span class="line"><span class="comment"># 由于 last 会输出空白行, wtmp, unknown, reboot 等无关帐号登陆的信息，因此，我利用</span></span><br><span class="line"><span class="comment"># grep 取出非空白行，以及去除上述关键字那几行，再计算行数，就能够了解啰</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>uniq</p>
</blockquote>
<p>如果我排序完成了，想要将重复的数据仅列出一个显示，可以怎么做呢？</p>
<p><code>uniq [-ic]</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-i</code>：忽略大小写字符的不同；</li>
<li><code>-c</code>：进行计数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：使用 last 将帐号列出，仅取出帐号栏，进行排序后仅取出一位；</span></span><br><span class="line">last | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span>1 | sort | uniq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：承上题，如果我还想要知道每个人的登陆总次数呢？</span></span><br><span class="line">last | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span>1 | sort | uniq -c</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">      <span class="number">6</span> （unknown</span><br><span class="line">     <span class="number">47</span> dmtsai</span><br><span class="line">      <span class="number">4</span> reboot</span><br><span class="line">      <span class="number">7</span> root</span><br><span class="line">      <span class="number">1</span> wtmp</span><br><span class="line"><span class="comment"># 从上面的结果可以发现 reboot 有 4 次， root 登陆则有 7 次！大部分是以 dmtsai 来操作！</span></span><br><span class="line"><span class="comment"># wtmp 与第一行的空白都是 last 的默认字符，那两个可以忽略的！</span></span><br></pre></td></tr></table></figure>
<h2 id="u547D_u4EE4_3A_tee_2C_split_2C_xargs"><a href="#u547D_u4EE4_3A_tee_2C_split_2C_xargs" class="headerlink" title="命令: tee, split, xargs"></a>命令: tee, split, xargs</h2><blockquote>
<p>tee</p>
</blockquote>
<p><img src="/images/14590942194893.jpg" alt="tee 的工作流程示意图"></p>
<p>tee 会同时将数据流分送到文件去与屏幕 （screen）；而输出到屏幕的，其实就是 stdout ，那就可以让下个指令继续处理喔！</p>
<p><code>tee [-a] file</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-a</code>：以累加 （append） 的方式，将数据加入 file 当中！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">last | tee last.list | cut <span class="operator">-d</span> <span class="string">" "</span> <span class="operator">-f</span>1</span><br><span class="line"><span class="comment"># 这个范例可以让我们将 last 的输出存一份到 last.list 文件中；</span></span><br><span class="line"></span><br><span class="line">ls <span class="operator">-l</span> /home | tee ~/homefile | more</span><br><span class="line"><span class="comment"># 这个范例则是将 ls 的数据存一份到 ~/homefile ，同时屏幕也有输出讯息！</span></span><br><span class="line"></span><br><span class="line">ls <span class="operator">-l</span> / | tee <span class="operator">-a</span> ~/homefile | more</span><br><span class="line"><span class="comment"># 要注意！ tee 后接的文件会被覆盖，若加上 -a 这个选项则能将讯息累加。</span></span><br></pre></td></tr></table></figure>
<p>tee 可以让 standard output 转存一份到文件内并将同样的数据继续送到屏幕去处理！ 这样除了可以让我们同时分析一份数据并记录下来之外，还可以作为处理一份数据的中间暂存盘记录之用！</p>
<blockquote>
<p>split 将一个大文件，依据文件大小或行数来分区</p>
</blockquote>
<p><code>split [-bl] file PREFIX</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-b</code>：后面可接欲分区成的文件大小，可加单位，例如 b, k, m 等；</li>
<li><code>-l</code>：以行数来进行分区。</li>
<li><code>PREFIX</code>：代表前置字符的意思，可作为分区文件的前导文字。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：我的 /etc/services 有六百多K，若想要分成 300K 一个文件时？</span></span><br><span class="line"><span class="built_in">cd</span> /tmp; split -b <span class="number">300</span>k /etc/services services</span><br><span class="line">ll -k services*</span><br><span class="line"></span><br><span class="line">-rw-rw-r--. <span class="number">1</span> dmtsai dmtsai <span class="number">307200</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">52</span> servicesaa</span><br><span class="line">-rw-rw-r--. <span class="number">1</span> dmtsai dmtsai <span class="number">307200</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">52</span> servicesab</span><br><span class="line">-rw-rw-r--. <span class="number">1</span> dmtsai dmtsai  <span class="number">55893</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">52</span> servicesac</span><br><span class="line"><span class="comment"># 那个文件名可以随意取的啦！我们只要写上前导文字，小文件就会以</span></span><br><span class="line"><span class="comment"># xxxaa, xxxab, xxxac 等方式来创建小文件的！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：如何将上面的三个小文件合成一个文件，文件名为 servicesback</span></span><br><span class="line">cat services* &gt;&gt; servicesback</span><br><span class="line"><span class="comment"># 很简单吧？就用数据流重导向就好啦！简单！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：使用 ls -al / 输出的信息中，每十行记录成一个文件</span></span><br><span class="line">ls -al / | split <span class="operator">-l</span> <span class="number">10</span> - lsroot</span><br><span class="line">wc <span class="operator">-l</span> lsroot*</span><br><span class="line"></span><br><span class="line">  <span class="number">10</span> lsrootaa</span><br><span class="line">  <span class="number">10</span> lsrootab</span><br><span class="line">   <span class="number">4</span> lsrootac</span><br><span class="line">  <span class="number">24</span> total</span><br><span class="line"><span class="comment"># 重点在那个 - 啦！一般来说，如果需要 stdout/stdin 时，但偏偏又没有文件，</span></span><br><span class="line"><span class="comment"># 有的只是 - 时，那么那个 - 就会被当成 stdin 或 stdout ～</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>xargs 参数代换</p>
</blockquote>
<p>xargs 是在做什么的呢？就以字面上的意义来看， x 是加减乘除的乘号，args 则是 arguments （参数） 的意思，所以说，这个玩意儿就是在产生某个指令的参数的意思！ xargs 可以读入 stdin 的数据，并且以空白字符或断行字符作为分辨，将 stdin 的数据分隔成为 arguments 。 因为是以空白字符作为分隔，所以，如果有一些文件名或者是其他意义的名词内含有空白字符的时候， xargs 可能就会误判了</p>
<p><code>xargs [-0epn] command</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-0</code>：如果输入的 stdin 含有特殊字符，例如 `, \, 空白键等等字符时，这个 -0 参数可以将他还原成一般字符。这个参数可以用于特殊状态喔！</li>
<li><code>-e</code>：这个是 EOF （end of file） 的意思。后面可以接一个字串，当 xargs 分析到这个字串时，就会停止继续工作！</li>
<li><code>-p</code>：在执行每个指令的 argument 时，都会询问使用者的意思；</li>
<li><code>-n</code>：后面接次数，每次 command 指令执行时，要使用几个参数的意思。</li>
<li>当 xargs 后面没有接任何的指令时，默认是以 echo 来进行输出喔！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 /etc/passwd 内的第一栏取出，仅取三行，使用 id 这个指令将每个帐号内容秀出来</span></span><br><span class="line">id root</span><br><span class="line"></span><br><span class="line">uid=<span class="number">0</span>（root） gid=<span class="number">0</span>（root） groups=<span class="number">0</span>（root）   <span class="comment"># 这个 id 指令可以查询使用者的 UID/GID 等信息</span></span><br><span class="line"></span><br><span class="line">id $（cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span>）</span><br><span class="line"><span class="comment"># 虽然使用 $（cmd） 可以预先取得参数，但可惜的是， id 这个指令“仅”能接受一个参数而已！</span></span><br><span class="line"><span class="comment"># 所以上述的这个指令执行会出现错误！根本不会显示用户的 ID 啊！</span></span><br><span class="line"></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | id</span><br><span class="line"></span><br><span class="line">uid=<span class="number">1000</span>（dmtsai） gid=<span class="number">1000</span>（dmtsai） groups=<span class="number">1000</span>（dmtsai）,<span class="number">10</span>（wheel）   <span class="comment"># 我不是要查自己啊！</span></span><br><span class="line"><span class="comment"># 因为 id 并不是管线命令，因此在上面这个指令执行后，前面的东西通通不见！只会执行 id！</span></span><br><span class="line"></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | xargs id</span><br><span class="line"><span class="comment"># 依旧会出现错误！这是因为 xargs 一口气将全部的数据通通丢给 id 处理～但 id 就接受 1 个啊最多！</span></span><br><span class="line"></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | xargs -n <span class="number">1</span> id</span><br><span class="line"></span><br><span class="line">uid=<span class="number">0</span>（root） gid=<span class="number">0</span>（root） groups=<span class="number">0</span>（root）</span><br><span class="line">uid=<span class="number">1</span>（bin） gid=<span class="number">1</span>（bin） groups=<span class="number">1</span>（bin）</span><br><span class="line">uid=<span class="number">2</span>（daemon） gid=<span class="number">2</span>（daemon） groups=<span class="number">2</span>（daemon）</span><br><span class="line"><span class="comment"># 通过 -n 来处理，一次给予一个参数，因此上述的结果就 OK 正常的显示啰！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：同上，但是每次执行 id 时，都要询问使用者是否动作？</span></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | xargs -p -n <span class="number">1</span> id</span><br><span class="line"></span><br><span class="line">id root ?...y</span><br><span class="line">uid=<span class="number">0</span>（root） gid=<span class="number">0</span>（root） groups=<span class="number">0</span>（root）</span><br><span class="line">id bin ?...y</span><br><span class="line">.....（下面省略）.....</span><br><span class="line"><span class="comment"># 呵呵！这个 -p 的选项可以让使用者的使用过程中，被询问到每个指令是否执行！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：将所有的 /etc/passwd 内的帐号都以 id 查阅，但查到 sync 就结束指令串</span></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | xargs <span class="operator">-e</span><span class="string">'sync'</span> -n <span class="number">1</span> id</span><br><span class="line"><span class="comment"># 仔细与上面的案例做比较。也同时注意，那个 -e'sync' 是连在一起的，中间没有空白键</span></span><br><span class="line"><span class="comment"># 上个例子当中，第六个参数是 sync 啊，那么我们下达 -e'sync' 后，则分析到 sync 这个字串时，</span></span><br><span class="line"><span class="comment"># 后面的其他 stdin 的内容就会被 xargs 舍弃掉了！</span></span><br></pre></td></tr></table></figure>
<p>其实，在 man xargs 里面就有三四个小范例，您可以自行参考一下内容。 此外， xargs 真的是很好用的一个玩意儿！您真的需要好好的参详参详！会使用 xargs 的原因是， 很多指令其实并不支持管线命令，因此我们可以通过 xargs 来提供该指令引用 standard input 之用！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例四：找出 /usr/sbin 下面具有特殊权限的文件名，并使用 ls -l 列出详细属性</span></span><br><span class="line">find /usr/sbin -perm /<span class="number">7000</span> | xargs ls <span class="operator">-l</span></span><br><span class="line"></span><br><span class="line">-rwx-<span class="operator">-s</span>--x. <span class="number">1</span> root lock      <span class="number">11208</span> Jun <span class="number">10</span>  <span class="number">2014</span> /usr/sbin/lockdev</span><br><span class="line">-rwsr-xr-x. <span class="number">1</span> root root     <span class="number">113400</span> Mar  <span class="number">6</span> <span class="number">12</span>:<span class="number">17</span> /usr/sbin/mount.nfs</span><br><span class="line">-rwxr-sr-x. <span class="number">1</span> root root      <span class="number">11208</span> Mar  <span class="number">6</span> <span class="number">11</span>:<span class="number">05</span> /usr/sbin/netreport</span><br><span class="line">.....（下面省略）.....</span><br><span class="line"><span class="comment"># 聪明的读者应该会想到使用“ ls -l $（find /usr/sbin -perm /7000） ”来处理这个范例！</span></span><br><span class="line"><span class="comment"># 都 OK！能解决问题的方法，就是好方法！</span></span><br></pre></td></tr></table></figure>
<h2 id="u547D_u4EE4_3A_tr_2C_col_2C_join_2C_paste_2C_expand"><a href="#u547D_u4EE4_3A_tr_2C_col_2C_join_2C_paste_2C_expand" class="headerlink" title="命令: tr, col, join, paste, expand"></a>命令: tr, col, join, paste, expand</h2><blockquote>
<p>tr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换！</p>
</blockquote>
<p><code>tr [-ds] SET1 ...</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-d</code>：删除讯息当中的 SET1 这个字串；</li>
<li><code>-s</code>：取代掉重复的字符！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 last 输出的讯息中，所有的小写变成大写字符：</span></span><br><span class="line">last | tr <span class="string">'[a-z]'</span> <span class="string">'[A-Z]'</span></span><br><span class="line"><span class="comment"># 事实上，没有加上单引号也是可以执行的，如：last | tr [a-z] [A-Z]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：将 /etc/passwd 输出的讯息中，将冒号 （:） 删除</span></span><br><span class="line">cat /etc/passwd | tr <span class="operator">-d</span> <span class="string">':'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：将 /etc/passwd 转存成 dos 断行到 /root/passwd 中，再将 ^M 符号删除</span></span><br><span class="line">cp /etc/passwd ~/passwd &amp;&amp; unix2dos ~/passwd</span><br><span class="line">file /etc/passwd ~/passwd</span><br><span class="line"></span><br><span class="line">/etc/passwd:         ASCII text</span><br><span class="line">/home/dmtsai/passwd: ASCII text, with CRLF line terminators  &lt;==就是 DOS 断行</span><br><span class="line"></span><br><span class="line">cat ~/passwd | tr <span class="operator">-d</span> <span class="string">'\r'</span> &gt; ~/passwd.linux</span><br><span class="line"><span class="comment"># 那个 \r 指的是 DOS 的断行字符，关于更多的字符，请参考 man tr</span></span><br><span class="line">ll /etc/passwd ~/passwd*</span><br><span class="line">-rw-r--r--. <span class="number">1</span> root   root   <span class="number">2092</span> Jun <span class="number">17</span> <span class="number">00</span>:<span class="number">20</span> /etc/passwd</span><br><span class="line">-rw-r--r--. <span class="number">1</span> dmtsai dmtsai <span class="number">2133</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">13</span> /home/dmtsai/passwd</span><br><span class="line">-rw-rw-r--. <span class="number">1</span> dmtsai dmtsai <span class="number">2092</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">13</span> /home/dmtsai/passwd.linux</span><br><span class="line"><span class="comment"># 处理过后，发现文件大小与原本的 /etc/passwd 就一致了！</span></span><br></pre></td></tr></table></figure>
<p>其实这个指令也可以写在“正则表达式”里头！因为他也是由正则表达式的方式来取代数据的！ 以上面的例子来说，使用 [] 可以设置一串字呢！也常常用来取代文件中的怪异符号！ 例如上面第三个例子当中，可以去除 DOS 文件留下来的 <code>^M</code> 这个断行的符号！这东西相当的有用！相信处理 Linux &amp; Windows 系统中的人们最麻烦的一件事就是这个事情啦！亦即是 DOS 下面会自动的在每行行尾加入 <code>^M</code> 这个断行符号！这个时候除了以前讲过的 dos2unix 之外，我们也可以使用这个 tr 来将 <code>^M</code> 去除！ <code>^M</code> 可以使用 <code>\r</code> 来代替之！</p>
<blockquote>
<p>col</p>
</blockquote>
<p><code>col [-xb]</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-x</code>：将 tab 键转换成对等的空白键</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">范例一：利用 cat -A 显示出所有特殊按键，最后以 col 将 [tab] 转成空白</span><br><span class="line"> cat -A /etc/man_db.conf  &lt;==此时会看到很多 ^I 的符号，那就是 tab</span><br><span class="line"> cat /etc/man_db.conf | col -x | cat -A | more</span><br><span class="line"><span class="comment"># 嘿嘿！如此一来， [tab] 按键会被取代成为空白键，输出就美观多了！</span></span><br></pre></td></tr></table></figure>
<p>虽然 col 有他特殊的用途，不过，很多时候，他可以用来简单的处理将 [tab] 按键取代成为空白键！ 例如上面的例子当中，如果使用 cat -A 则 [tab] 会以 <code>^I</code> 来表示。 但经过 col -x 的处理，则会将 [tab] 取代成为对等的空白键！</p>
<blockquote>
<p>join 处理两个文件之间的数据</p>
</blockquote>
<p><code>join [-ti12] file1 file2</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-t</code>：join 默认以空白字符分隔数据，并且比对“第一个字段”的数据，如果两个文件相同，则将两笔数据联成一行，且第一个字段放在第一个</li>
<li><code>-i</code>：忽略大小写的差异；</li>
<li><code>-1</code>：这个是数字的 1 ，代表“第一个文件要用那个字段来分析”的意思；</li>
<li><code>-2</code>：代表“第二个文件要用那个字段来分析”的意思。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：用 root 的身份，将 /etc/passwd 与 /etc/shadow 相关数据整合成一栏</span></span><br><span class="line">head -n <span class="number">3</span> /etc/passwd /etc/shadow</span><br><span class="line">==&gt; /etc/passwd &lt;==</span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin</span><br><span class="line"></span><br><span class="line">==&gt; /etc/shadow &lt;==</span><br><span class="line">root:<span class="variable">$6</span><span class="variable">$wtbCCce</span>/PxMeE5wm<span class="variable">$KE2IfSJr</span>...:<span class="number">16559</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">bin:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">daemon:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line"><span class="comment"># 由输出的数据可以发现这两个文件的最左边字段都是相同帐号！且以 : 分隔</span></span><br><span class="line"></span><br><span class="line">join -t <span class="string">':'</span> /etc/passwd /etc/shadow | head -n <span class="number">3</span></span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash:<span class="variable">$6</span><span class="variable">$wtbCCce</span>/PxMeE5wm<span class="variable">$KE2IfSJr</span>...:<span class="number">16559</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line"><span class="comment"># 通过上面这个动作，我们可以将两个文件第一字段相同者整合成一列！</span></span><br><span class="line"><span class="comment"># 第二个文件的相同字段并不会显示（因为已经在最左边的字段出现了啊！）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：我们知道 /etc/passwd 第四个字段是 GID ，那个 GID 记录在 /etc/group 当中的第三个字段，请问如何将两个文件整合？</span></span><br><span class="line">head -n <span class="number">3</span> /etc/passwd /etc/group</span><br><span class="line">==&gt; /etc/passwd &lt;==</span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin</span><br><span class="line"></span><br><span class="line">==&gt; /etc/group &lt;==</span><br><span class="line">root:x:<span class="number">0</span>:</span><br><span class="line">bin:x:<span class="number">1</span>:</span><br><span class="line">daemon:x:<span class="number">2</span>:</span><br><span class="line"><span class="comment"># 从上面可以看到，确实有相同的部分喔！赶紧来整合一下！</span></span><br><span class="line"></span><br><span class="line">join -t <span class="string">':'</span> -<span class="number">1</span> <span class="number">4</span> /etc/passwd -<span class="number">2</span> <span class="number">3</span> /etc/group | head -n <span class="number">3</span></span><br><span class="line"><span class="number">0</span>:root:x:<span class="number">0</span>:root:/root:/bin/bash:root:x:</span><br><span class="line"><span class="number">1</span>:bin:x:<span class="number">1</span>:bin:/bin:/sbin/nologin:bin:x:</span><br><span class="line"><span class="number">2</span>:daemon:x:<span class="number">2</span>:daemon:/sbin:/sbin/nologin:daemon:x:</span><br><span class="line"><span class="comment"># 同样的，相同的字段部分被移动到最前面了！所以第二个文件的内容就没再显示。</span></span><br><span class="line"><span class="comment"># 请读者们配合上述显示两个文件的实际内容来比对！</span></span><br></pre></td></tr></table></figure>
<p>这个 join 在处理两个相关的数据文件时，就真的是很有帮助的啦！ 例如上面的案例当中，我的 /etc/passwd, /etc/shadow, /etc/group 都是有相关性的， 其中 /etc/passwd, /etc/shadow 以帐号为相关性，至于 /etc/passwd, /etc/group 则以所谓的 GID （帐号的数字定义） 来作为他的相关性。根据这个相关性， 我们可以将有关系的数据放置在一起！这在处理数据可是相当有帮助的！ 但是上面的例子有点难，希望您可以静下心好好的看一看原因喔！</p>
<p>此外，需要特别注意的是，在使用 join 之前，你所需要处理的文件应该要事先经过排序 （sort） 处理！ 否则有些比对的项目会被略过呢！特别注意了！</p>
<blockquote>
<p>paste 直接将两行贴在一起，且中间以 [tab] 键隔开</p>
</blockquote>
<p><code>paste [-d] file1 file2</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-d</code>：后面可以接分隔字符。默认是以 [tab] 来分隔的！</li>
<li><code>-</code>：如果 file 部分写成 - ，表示来自 standard input 的数据的意思。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：用 root 身份，将 /etc/passwd 与 /etc/shadow 同一行贴在一起</span></span><br><span class="line">paste /etc/passwd /etc/shadow</span><br><span class="line"></span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash root:<span class="variable">$6</span><span class="variable">$wtbCCce</span>/PxMeE5wm<span class="variable">$KE2IfSJr</span>...:<span class="number">16559</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin        bin:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin daemon:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line"><span class="comment"># 注意喔！同一行中间是以 [tab] 按键隔开的！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：先将 /etc/group 读出（用 cat），然后与范例一贴上一起！且仅取出前三行</span></span><br><span class="line">cat /etc/group|paste /etc/passwd /etc/shadow - | head -n <span class="number">3</span></span><br><span class="line"><span class="comment"># 这个例子的重点在那个 - 的使用！那玩意儿常常代表 stdin 喔！</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>expand 将 [tab] 按键转成空白键</p>
</blockquote>
<p><code>expand [-t] file</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-t</code>：后面可以接数字。一般来说，一个 tab 按键可以用 8 个空白键取代。我们也可以自行定义一个 [tab] 按键代表多少个字符呢！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 /etc/man_db.conf 内行首为 MANPATH 的字样就取出；仅取前三行；</span></span><br><span class="line">grep <span class="string">'^MANPATH'</span> /etc/man_db.conf | head -n <span class="number">3</span></span><br><span class="line"></span><br><span class="line">MANPATH_MAP     /bin                    /usr/share/man</span><br><span class="line">MANPATH_MAP     /usr/bin                /usr/share/man</span><br><span class="line">MANPATH_MAP     /sbin                   /usr/share/man</span><br><span class="line"><span class="comment"># 行首的代表标志为 ^ ，这个我们留待下节介绍！先有概念即可！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：承上，如果我想要将所有的符号都列出来？（用 cat）</span></span><br><span class="line">grep <span class="string">'^MANPATH'</span> /etc/man_db.conf | head -n <span class="number">3</span> |cat -A</span><br><span class="line"></span><br><span class="line">MANPATH_MAP^I/bin^I^I^I/usr/share/man$</span><br><span class="line">MANPATH_MAP^I/usr/bin^I^I/usr/share/man$</span><br><span class="line">MANPATH_MAP^I/sbin^I^I^I/usr/share/man$</span><br><span class="line"><span class="comment"># 发现差别了吗？没错～ [tab] 按键可以被 cat -A 显示成为 ^I </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：承上，我将 [tab] 按键设置成 6 个字符的话？</span></span><br><span class="line">grep <span class="string">'^MANPATH'</span> /etc/man_db.conf | head -n <span class="number">3</span> | expand -t <span class="number">6</span> - | cat -A</span><br><span class="line"></span><br><span class="line">MANPATH_MAP /bin              /usr/share/man$</span><br><span class="line">MANPATH_MAP /usr/bin          /usr/share/man$</span><br><span class="line">MANPATH_MAP /sbin             /usr/share/man$</span><br><span class="line"><span class="number">123456123456123456123456123456123456123456123456</span>...</span><br><span class="line"><span class="comment"># 仔细看一下上面的数字说明，因为我是以 6 个字符来代表一个 [tab] 的长度，所以，</span></span><br><span class="line"><span class="comment"># MAN... 到 /usr 之间会隔 12 （两个 [tab]） 个字符喔！如果 tab 改成 9 的话，</span></span><br><span class="line"><span class="comment"># 情况就又不同了！这里也不好理解～您可以多设置几个数字来查阅就晓得！</span></span><br></pre></td></tr></table></figure>
<h2 id="vi__u4E0E_vim"><a href="#vi__u4E0E_vim" class="headerlink" title="vi 与 vim"></a>vi 与 vim</h2><p>基本上 vi 共分为三种模式，分别是“一般指令模式”、“编辑模式”与“指令列命令模式”。 这三种模式的作用分别是：</p>
<ul>
<li>一般指令模式 （command mode）<ul>
<li>以 vi 打开一个文件就直接进入一般指令模式了（这是默认的模式，也简称为一般模式）。在这个模式中， 你可以使用“上下左右”按键来移动光标，你可以使用“删除字符”或“删除整列”来处理文件内容， 也可以使用“复制、贴上”来处理你的文件数据。</li>
</ul>
</li>
<li>编辑模式 （insert mode）<ul>
<li>在一般指令模式中可以进行删除、复制、贴上等等的动作，但是却无法编辑文件内容的！ 要等到你按下 <code>i, I, o, O, a, A, r, R</code> 等任何一个字母之后才会进入编辑模式。注意了！通常在 Linux 中，按下这些按键时，在画面的左下方会出现“ INSERT 或 REPLACE ”的字样，此时才可以进行编辑。而如果要回到一般指令模式时， 则必须要按下“Esc”这个按键即可退出编辑模式。</li>
</ul>
</li>
<li>指令列命令模式 （command-line mode）<ul>
<li>在一般模式当中，输入 <code>: / ?</code> 三个中的任何一个按钮，就可以将光标移动到最下面那一列。在这个模式当中， 可以提供你“搜寻数据”的动作，而读取、存盘、大量取代字符、离开 vi 、显示行号等等的动作则是在此模式中达成的！</li>
</ul>
</li>
</ul>
<p><img src="/images/14590796988736.jpg" alt=""></p>
<blockquote>
<p>一般指令模式可用的按钮说明</p>
</blockquote>
<ul>
<li>光标移动<ul>
<li><code>h 或 向左方向键（←）</code>：光标向左移动一个字符</li>
<li><code>j 或 向下方向键（↓）</code>：光标向下移动一个字符</li>
<li><code>k 或 向上方向键（↑）</code>：光标向上移动一个字符</li>
<li><code>l 或 向右方向键（→）</code>：光标向右移动一个字符</li>
<li>如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 列，可以使用 <code>30j</code> 或 <code>30↓</code> 的组合按键， 亦即加上想要进行的次数（数字）后，按下动作即可！</li>
<li><code>[Ctrl] + [f]</code>：屏幕“向下”移动一页，相当于 [Page Down]按键 （常用）</li>
<li><code>[Ctrl] + [b]</code>：屏幕“向上”移动一页，相当于 [Page Up] 按键 （常用）</li>
<li><code>[Ctrl] + [d]</code>：屏幕“向下”移动半页</li>
<li><code>[Ctrl] + [u]</code>：屏幕“向上”移动半页</li>
<li><code>+</code>：光标移动到非空白字符的下一列</li>
<li><code>-</code>：光标移动到非空白字符的上一列</li>
<li><code>n&lt;space&gt;</code>：那个 n 表示“数字”，例如 20 。按下数字后再按空白键，光标会向右移动这一列的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</space></li>
<li><code>0 或功能键[Home]</code>：这是数字“ 0 ”：移动到这一列的最前面字符处 （常用）</li>
<li><code>$ 或功能键[End]</code>：移动到这一列的最后面字符处（常用）</li>
<li><code>H</code>：光标移动到这个屏幕的最上方那一列的第一个字符</li>
<li><code>M</code>：光标移动到这个屏幕的中央那一列的第一个字符</li>
<li><code>L</code>：光标移动到这个屏幕的最下方那一列的第一个字符</li>
<li><code>G</code>：移动到这个文件的最后一列（常用）</li>
<li><code>nG</code>：n 为数字。移动到这个文件的第 n 列。例如 20G 则会移动到这个文件的第 20 列（可配合 <code>:set nu</code>）</li>
<li><code>gg</code>：移动到这个文件的第一列，相当于 1G 啊！ （常用）</li>
<li><code>n&lt;Enter&gt;</code>：n 为数字。光标向下移动 n 列（常用）</li>
</ul>
</li>
<li>复制粘贴<ul>
<li><code>x, X</code>：在一列字当中，x 为向后删除一个字符 （相当于 [del] 按键）， X 为向前删除一个字符（相当于 [backspace] 亦即是倒退键） （常用）</li>
<li><code>nx</code>：n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， “10x”</li>
<li><code>dd</code>：删除光标所在的那一整列（常用）</li>
<li><code>ndd</code>：n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列 （常用）</li>
<li><code>d1G</code>：删除光标所在到第一列的所有数据</li>
<li><code>dG</code>：删除光标所在到最后一列的所有数据</li>
<li><code>d$</code>：删除光标所在处，到该列的最后一个字符</li>
<li><code>d0</code>：那个是数字的 0 ，删除光标所在处，到该列的最前面一个字符</li>
<li><code>yy</code>：复制光标所在的那一列（常用）</li>
<li><code>nyy</code>：n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20 列（常用）</li>
<li><code>y1G</code>：复制光标所在列到第一列的所有数据</li>
<li><code>yG</code>：复制光标所在列到最后一列的所有数据</li>
<li><code>y0</code>：复制光标所在的那个字符到该列行首的所有数据</li>
<li><code>y$</code>：复制光标所在的那个字符到该列行尾的所有数据</li>
<li><code>p, P</code>：p 为将已复制的数据在光标下一列贴上，P 则为贴在光标上一列！ 举例来说，我目前光标在第 20 列，且已经复制了 10 列数据。则按下 p 后， 那 10 列数据会贴在原本的 20 列之后，亦即由 21 列开始贴。但如果是按下 P 呢？ 那么原本的第 20 列会被推到变成 30 列。 （常用）</li>
<li><code>J</code>：将光标所在列与下一列的数据结合成同一列</li>
<li><code>c</code>：重复删除多个数据，例如向下删除 10 列，[ 10cj ]</li>
<li><code>u</code>：复原前一个动作。（常用）</li>
<li><code>[Ctrl]+r</code>：重做上一个动作。（常用）这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</li>
<li><code>.</code>：不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点“.”就好了！ （常用）</li>
</ul>
</li>
<li>搜寻取代<ul>
<li><code>/word</code>：向光标之下寻找一个名称为 word 的字串。例如要在文件内搜寻 vbird 这个字串，就输入 <code>/vbird</code> 即可！ （常用）</li>
<li><code>?word</code>：向光标之上寻找一个字串名称为 word 的字串。</li>
<li><code>n</code>：这个 n 是英文按键。代表“重复前一个搜寻的动作”。举例来说， 如果刚刚我们执行 <code>/vbird</code> 去向下搜寻 vbird 这个字串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字串。如果是执行 <code>?vbird</code> 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字串！</li>
<li><code>N</code>：这个 N 是英文按键。与 n 刚好相反，为“反向”进行前一个搜寻动作。 例如 <code>/vbird</code> 后，按下 N 则表示“向上”搜寻 vbird 。</li>
<li>使用 <code>/word</code> 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键字！</li>
<li><code>:n1,n2s/word1/word2/g</code>：n1 与 n2 为数字。在第 n1 与 n2 列之间寻找 word1 这个字串，并将该字串取代为 word2 ！举例来说，在 100 到 200 列之间搜寻 vbird 并取代为 VBIRD 则：<code>:100,200s/vbird/VBIRD/g</code>（常用）</li>
<li><code>:1,$s/word1/word2/g</code>：从第一列到最后一列寻找 word1 字串，并将该字串取代为 word2 ！（常用）</li>
<li><code>:1,$s/word1/word2/gc</code>：从第一列到最后一列寻找 word1 字串，并将该字串取代为 word2 ！且在取代前显示提示字符给使用者确认 （confirm） 是否需要取代！（常用）</li>
</ul>
</li>
</ul>
<blockquote>
<p>进入插入或取代的编辑模式</p>
</blockquote>
<ul>
<li><code>i, I</code>：进入插入模式（Insert mode）<ul>
<li>i 为“从目前光标所在处插入”， I 为“在目前所在列的第一个非空白字符处开始插入”。 （常用）</li>
</ul>
</li>
<li><code>a, A</code>：进入插入模式（Insert mode）<ul>
<li>a 为“从目前光标所在的下一个字符处开始插入”， A 为“从光标所在列的最后一个字符处开始插入”。（常用）</li>
</ul>
</li>
<li><code>o, O</code>：进入插入模式（Insert mode）<ul>
<li>这是英文字母 o 的大小写。o 为“在目前光标所在的下一列处插入新的一列”； O 为在目前光标所在处的上一列插入新的一列！（常用）</li>
</ul>
</li>
<li><code>r, R</code>：进入取代模式（Replace mode）<ul>
<li>r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；（常用）</li>
</ul>
</li>
<li>上面这些按键中，在 vi 画面的左下角处会出现“–INSERT–”或“–REPLACE–”的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在文件里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</li>
<li><code>[Esc]</code>：退出编辑模式，回到一般指令模式中（常用）</li>
</ul>
<blockquote>
<p>一般指令模式切换到指令列模式的可用按钮说明</p>
</blockquote>
<ul>
<li>指令列模式的储存、离开等指令<ul>
<li><code>:w</code>：将编辑的数据写入硬盘文件中（常用）</li>
<li><code>:w!</code>：若文件属性为“只读”时，强制写入该文件。不过，到底能不能写入， 还是跟你对该文件的文件权限有关啊！</li>
<li><code>:q</code>：离开 vi （常用）</li>
<li><code>:q!</code>：若曾修改过文件，又不想储存，使用 ! 为强制离开不储存盘案。</li>
<li><code>:wq</code>：储存后离开，若为 <code>:wq!</code> 则为强制储存后离开 （常用）</li>
<li><code>ZZ</code>：这是大写的 Z 喔！若文件没有更动，则不储存离开，若文件已经被更动过，则储存后离开！</li>
<li><code>:w [filename]</code>：将编辑的数据储存成另一个文件（类似另存新文件）</li>
<li><code>:r [filename]</code>：在编辑的数据中，读入另一个文件的数据。亦即将 “filename” 这个文件内容加到光标所在列后面</li>
<li><code>:n1,n2 w [filename]</code>：将 n1 到 n2 的内容储存成 filename 这个文件。</li>
<li><code>:! command</code>：暂时离开 vi 到指令列模式下执行 command 的显示结果！例如 <code>:! ls /home</code> 即可在 vi 当中察看 /home 下面以 ls 输出的文件信息！</li>
</ul>
</li>
<li>vim 环境的变更<ul>
<li><code>:set nu</code>：显示行号，设置之后，会在每一列的字首显示该列的行号</li>
<li><code>:set nonu</code>：与 set nu 相反，为取消行号！</li>
</ul>
</li>
</ul>
<blockquote>
<p>区块选择（Visual Block）</p>
</blockquote>
<ul>
<li><code>v</code>：字符选择，会将光标经过的地方反白选择！</li>
<li><code>V</code>：列选择，会将光标经过的列反白选择！</li>
<li><code>[Ctrl]+v</code>：区块选择，可以用长方形的方式选择数据</li>
<li><code>y</code>：将反白的地方复制起来</li>
<li><code>d</code>：将反白的地方删除掉</li>
<li><code>p</code>：将刚刚复制的区块，在光标所在处贴上！</li>
</ul>
<blockquote>
<p>多文件编辑</p>
</blockquote>
<p>通过 <code>vim file1 file2</code> 指令来使用一个 vim 打开两个文件</p>
<ul>
<li><code>:n</code>：编辑下一个文件</li>
<li><code>:N</code>：编辑上一个文件</li>
<li><code>:files</code>：列出目前这个 vim 的打开的所有文件</li>
</ul>
<blockquote>
<p>多窗口功能</p>
</blockquote>
<p>如何分区窗口并放入文件呢？ 很简单啊！在指令列模式输入“:sp {filename}”即可！那个 filename 可有可无， 如果想要在新窗口启动另一个文件，就加入文件名，否则仅输入 :sp 时， 出现的则是同一个文件在两个窗口间！</p>
<ul>
<li><code>:sp [filename]</code>：打开一个新窗口，如果有加 filename， 表示在新窗口打开一个新文件，否则表示两个窗口为同一个文件内容（同步显示）。</li>
<li><code>[ctrl]+w+j</code> / <code>[ctrl]+w+↓</code> ：按键的按法是：先按下 [ctrl] 不放， 再按下 w 后放开所有的按键，然后再按下 j （或向下方向键），则光标可移动到下方的窗口。</li>
<li><code>[ctrl]+w+k</code> / <code>[ctrl]+w+↑</code>：同上，不过光标移动到上面的窗口。</li>
<li><code>[ctrl]+w+q</code>：其实就是 :q 结束离开啦！ 举例来说，如果我想要结束下方的窗口，那么利用 <code>[ctrl]+w+↓</code> 移动到下方窗口后，按下 <code>:q</code> 即可离开， 也可以按下 <code>[ctrl]+w+q</code> 啊！</li>
</ul>
<blockquote>
<p>vim 环境设置与记录</p>
</blockquote>
<p>主要是修改 <code>~/.vimrc</code> 和 <code>~/.viminfo</code></p>
<ul>
<li><code>:set nu</code> / <code>:set nonu</code>：就是设置与取消行号啊！</li>
<li><code>:set hlsearch</code> / <code>:set nohlsearch</code>：hlsearch 就是 high light search（高亮度搜寻）。 这个就是设置是否将搜寻的字串反白的设置值。默认值是 hlsearch</li>
<li><code>:set autoindent</code> / <code>:set noautoindent</code>：是否自动缩排？autoindent 就是自动缩排。</li>
<li><code>:set backup</code>：是否自动储存备份文件？一般是 nobackup 的， 如果设置 backup 的话，那么当你更动任何一个文件时，则原始文件会被另存成一个文件名为 filename~ 的文件。 举例来说，我们编辑 hosts ，设置 <code>:set backup</code>，那么当更动 hosts 时，在同目录下，就会产生 hosts~ 文件名的文件，记录原始的 hosts 文件内容</li>
<li><code>:set ruler</code>：还记得我们提到的右下角的一些状态列说明吗？ 这个 ruler 就是在显示或不显示该设置值的啦！</li>
<li><code>:set showmode</code>：这个则是，是否要显示 <code>--INSERT--</code> 之类的字眼在左下角的状态列。</li>
<li><code>:set backspace=（012）</code>：一般来说， 如果我们按下 i 进入编辑模式后，可以利用倒退键 （backspace） 来删除任意字符的。 但是，某些 distribution 则不许如此。此时，我们就可以通过 backspace 来设置啰～ 当 backspace 为 2 时，就是可以删除任意值；0 或 1 时，仅可删除刚刚输入的字符， 而无法删除原本就已经存在的文字了！</li>
<li><code>:set all</code>：显示目前所有的环境参数设置值。</li>
<li><code>:set</code>：显示与系统默认值不同的设置参数， 一般来说就是你有自行变动过的设置参数啦！</li>
<li><code>:syntax on</code> / <code>:syntax off</code>：是否依据程序相关语法显示不同颜色？ 举例来说，在编辑一个纯文本文件时，如果开头是以 # 开始，那么该列就会变成蓝色。 如果你懂得写程序，那么这个 <code>:syntax on</code> 还会主动的帮你除错呢！但是， 如果你仅是编写纯文本，要避免颜色对你的屏幕产生的干扰，则可以取消这个设置 。</li>
<li><code>:set bg=dark</code> / <code>:set bg=light</code>：可用以显示不同的颜色色调，默认是 light 。如果你常常发现注解的字体深蓝色实在很不容易看， 那么这里可以设置为 dark 喔！试看看，会有不同的样式呢！</li>
</ul>
<p>总之，这些设置值很有用处的啦！但是…我是否每次使用 vim 都要重新设置一次各个参数值？ 这不太合理吧？没错啊！所以，我们可以通过配置文件来直接规定我们习惯的 vim 操作环境呢！ 整体 vim 的设置值一般是放置在 <code>/etc/vimrc</code> 这个文件，不过，不建议你修改他！ 你可以修改 <code>~/.vimrc</code> 这个文件 （默认不存在，请你自行手动创建！），将你所希望的设置值写入！ 举例来说，可以是这样的一个文件：</p>
<p><img src="/images/14590898239987.jpg" alt=""></p>
<p>很多朋友常常哀嚎，说他们的 vim 里面怎么无法显示正常的中文啊？其实这很有可能是因为编码的问题！ 因为中文编码有 big5 与 utf8 两种，如果你的文件是使用 big5 编码制作的，但在 vim 的终端接口中你使用的是万国码（utf8）， 由于编码的不同，你的中文文件内容当然就是一堆乱码了！怎么办？这时你得要考虑许多东西啦！有这些：</p>
<ol>
<li>你的 Linux 系统默认支持的语系数据：这与 <code>/etc/locale.conf</code> 有关；</li>
<li>你的终端接口 （bash） 的语系： 这与 <code>LANG</code>, <code>LC_ALL</code> 这几个变量有关；</li>
<li>你的文件原本的编码；</li>
<li>打开终端机的软件，例如在 GNOME 下面的窗口接口。</li>
</ol>
<p>事实上最重要的是上头的第三与第四点，只要这两点的编码一致，你就能够正确的看到与编辑你的中文文件。 否则就会看到一堆乱码啦！</p>
<h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2><p>默认的指令记忆功能可以到达 1000 个！也就是说，你曾经下达过的指令几乎都被记录下来了。<br>这么多的指令记录在哪里呢？在你的主文件夹内的 <code>.bash_history</code> 啦！ 不过，需要留意的是，<code>~/.bash_history</code> 记录的是前一次登陆以前所执行过的指令， 而至于这一次登陆所执行的指令都被暂存在内存中，当你成功的登出系统后，该指令记忆才会记录到 <code>.bash_history</code> 当中！</p>
<p>bash 的配置文件主要分为 login shell 与 non-login shell。login shell 主要读取 <code>/etc/profile</code> 与 <code>~/.bash_profile</code>， non-login shell 则仅读取 <code>~/.bashrc</code></p>
<blockquote>
<p>命令别名设置功能 alias</p>
</blockquote>
<p>假如我需要知道这个目录下面的所有文件 （包含隐藏文件） 及所有的文件属性，那么我就必须要下达 <code>ls -al</code> 这样的指令串，唉！真麻烦，有没有更快的取代方式？呵呵！就使用命令别名呀！例如鸟哥最喜欢直接以 lm 这个自订的命令来取代上面的命令，也就是说， lm 会等于 <code>ls -al</code> 这样的一个功能，嘿！那么要如何作呢？就使用 alias 即可！你可以在指令列输入 alias 就可以知道目前的命令别名有哪些了！也可以直接下达命令来设置别名呦：<code>alias lm=&#39;ls -al&#39;</code></p>
<blockquote>
<p>查询指令是否为 Bash shell 的内置命令 type</p>
</blockquote>
<p><code>type [-tpa] name</code> 选项与参数：</p>
<ul>
<li>不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内置指令</li>
<li><code>-t</code>：当加入 -t 参数时，type 会将 name 以下面这些字眼显示出他的意义：<ul>
<li><code>file</code>：表示为外部指令；</li>
<li><code>alias</code>：表示该指令为命令别名所设置的名称；</li>
<li><code>builtin</code>：表示该指令为 bash 内置的指令功能；</li>
</ul>
</li>
<li><code>-p</code>：如果后面接的 name 为外部指令时，才会显示完整文件名；</li>
<li><code>-a</code>：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 alias</li>
</ul>
<blockquote>
<p>指令的下达与快速编辑按钮</p>
</blockquote>
<p>上面这个指令用途是将三个文件复制到 <code>/root</code> 这个目录下而已。不过，因为指令太长， 于是鸟哥就利用 <code>\[Enter]</code> 来将 [Enter] 这个按键“跳脱！”开来，让 [Enter] 按键不再具有“开始执行”的功能！好让指令可以继续在下一行输入。 需要特别留意， [Enter] 按键是紧接着反斜线 <code>\</code> 的，两者中间没有其他字符。 因为 <code>\</code> 仅跳脱“紧接着的下一个字符”而已！</p>
<p>另外，当你所需要下达的指令特别长，或者是你输入了一串错误的指令时，你想要快速的将这串指令整个删除掉，一般来说，我们都是按下删除键的。 有没有其他的快速组合键可以协助呢？是有的！常见的有下面这些：</p>
<ul>
<li><code>[ctrl]+u</code> / <code>[ctrl]+k</code><ul>
<li>分别是从光标处向前删除指令串 （[ctrl]+u） 及向后删除指令串 （[ctrl]+k）。</li>
</ul>
</li>
<li><code>[ctrl]+a</code> / <code>[ctrl]+e</code><ul>
<li>分别是让光标移动到整个指令串的最前面 （[ctrl]+a） 或最后面 （[ctrl]+e）。</li>
</ul>
</li>
</ul>
<p>Shell 相关的部分会另外进行学习，这里暂时略过</p>
<blockquote>
<p>万用字符</p>
</blockquote>
<ul>
<li><code>*</code>：代表“ 0 个到无穷多个”任意字符</li>
<li><code>?</code>：代表“一定有一个”任意字符</li>
<li><code>[ ]</code>：同样代表“一定有一个在括号内”的字符（非任意字符）。例如 [abcd] 代表“一定有一个字符， 可能是 a, b, c, d 这四个任何一个”</li>
<li><code>[ - ]</code>：若有减号在中括号内时，代表“在编码顺序内的所有字符”。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！</li>
<li><code>[^ ]</code>：若中括号内的第一个字符为指数符号（<code>^</code>），那表示“反向选择”，例如 <code>[^abc]</code> 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。</li>
</ul>
<blockquote>
<p>特殊符号</p>
</blockquote>
<ul>
<li><code>#</code> 注解符号：这个最常被使用在 script 当中，视为说明！在后的数据均不执行</li>
<li><code>\</code> 跳脱符号：将“特殊字符或万用字符”还原成一般字符</li>
<li><code>|</code> 管线 （pipe）：分隔两个管线命令的界定（后两节介绍）；</li>
<li><code>;</code> 连续指令下达分隔符号：连续性命令的界定 （注意！与管线命令并不相同）</li>
<li><code>~</code> 使用者的主文件夹</li>
<li><code>$</code> 取用变量前置字符：亦即是变量之前需要加的变量取代值</li>
<li><code>&amp;</code> 工作控制 （job control）：将指令变成背景下工作</li>
<li><code>!</code> 逻辑运算意义上的“非” not 的意思！</li>
<li><code>/</code> 目录符号：路径分隔的符号</li>
<li><code>&gt;</code>, <code>&gt;&gt;</code> 数据流重导向：输出导向，分别是“取代”与“累加”</li>
<li><code>&lt;</code>, <code>&lt;&lt;</code> 数据流重导向：输入导向 （这两个留待下节介绍）</li>
<li><code>&#39; &#39;</code> 单引号，不具有变量置换的功能（<code>$</code> 变为纯文本）</li>
<li><code>&quot; &quot;</code> 具有变量置换的功能！（<code>$</code> 可保留相关功能）</li>
<li>` ` 两个 ` 中间为可以先执行的指令，亦可使用 $（ ）</li>
<li><code>（ ）</code> 在中间为子 shell 的起始与结束</li>
<li><code>{ }</code> 在中间为命令区块的组合！</li>
</ul>
<blockquote>
<p>重定向</p>
</blockquote>
<p>简单的说，标准输出指的是“指令执行所回传的正确的讯息”，而标准错误输出可理解为“ 指令执行失败后，所回传的错误讯息”。举个简单例子来说，我们的系统默认有 <code>/etc/crontab</code> 但却无 <code>/etc/vbirdsay</code>， 此时若下达 <code>cat /etc/crontab /etc/vbirdsay</code> 这个指令时，cat 会进行：</p>
<ul>
<li>标准输出：读取 <code>/etc/crontab</code> 后，将该文件内容显示到屏幕上；</li>
<li>标准错误输出：因为无法找到 <code>/etc/vbirdsay</code>，因此在屏幕上显示错误讯息</li>
</ul>
<p>不管正确或错误的数据都是默认输出到屏幕上，所以屏幕当然是乱乱的！那能不能通过某些机制将这两股数据分开呢？ 当然可以啊！那就是数据流重导向的功能啊！数据流重导向可以将 standard output （简称 stdout） 与 standard error output （简称 stderr） 分别传送到其他的文件或设备去，而分别传送所用的特殊字符则如下所示：</p>
<ol>
<li>标准输入　　（stdin） ：代码为 0 ，使用 <code>&lt;</code> 或 <code>&lt;&lt;</code> ；</li>
<li>标准输出　　（stdout）：代码为 1 ，使用 <code>&gt;</code>（覆盖） 或 <code>&gt;&gt;</code>（累加） ；</li>
<li>标准错误输出（stderr）：代码为 2 ，使用 <code>2&gt;</code>（覆盖） 或 <code>2&gt;&gt;</code>（累加） ；</li>
</ol>
<p>想像一下，如果我知道错误讯息会发生，所以要将错误讯息忽略掉而不显示或储存呢？ 这个时候黑洞设备 /dev/null 就很重要了！这个 /dev/null 可以吃掉任何导向这个设备的信息喔！</p>
<p>如：<code>find /home -name .bashrc 2&gt; /dev/null</code></p>
<blockquote>
<p>命令执行的判断依据： <code>;</code> , <code>&amp;&amp;</code>, <code>||</code></p>
</blockquote>
<ul>
<li><code>cmd ; cmd</code> 不考虑指令相关性的连续指令下达</li>
<li><code>$? （指令回传值） 与 &amp;&amp; 或 ||</code></li>
</ul>
<blockquote>
<p>管线命令 pipe</p>
</blockquote>
<p>在每个管线后面接的第一个数据必定是“指令”喔！而且这个指令必须要能够接受 standard input 的数据才行，这样的指令才可以是为“管线命令”，例如 less, more, head, tail 等都是可以接受 standard input 的管线命令啦。至于例如 ls, cp, mv 等就不是管线命令了！因为 ls, cp, mv 并不会接受来自 stdin 的数据。 也就是说，管线命令主要有两个比较需要注意的地方：</p>
<ul>
<li>管线命令仅会处理 standard output，对于 standard error output 会予以忽略</li>
<li>管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行。</li>
</ul>
<blockquote>
<p>关于减号 - 的用途</p>
</blockquote>
<p>管线命令在 bash 的连续的处理程序中是相当重要的！另外，在 log file 的分析当中也是相当重要的一环， 所以请特别留意！另外，在管线命令当中，常常会使用到前一个指令的 stdout 作为这次的 stdin ， 某些指令需要用到文件名称 （例如 tar） 来进行处理时，该 stdin 与 stdout 可以利用减号 “-“ 来替代， 举例来说：</p>
<p>``bash<br>mkdir /tmp/homeback<br>tar -cvf - /home | tar -xvf - -C /tmp/homeback<br>```</p>
<p>上面这个例子是说：“我将 /home 里面的文件给他打包，但打包的数据不是纪录到文件，而是传送到 stdout； 经过管线后，将 <code>tar -cvf - /home</code> 传送给后面的 <code>tar -xvf -</code> ”。后面的这个 <code>-</code> 则是取用前一个指令的 <code>stdout</code>，因此，我们就不需要使用 filename 了！这是很常见的例子喔！注意注意！</p>
<h2 id="Linux__u76EE_u5F55_u7684_u542B_u4E49"><a href="#Linux__u76EE_u5F55_u7684_u542B_u4E49" class="headerlink" title="Linux 目录的含义"></a>Linux 目录的含义</h2><ul>
<li><code>bin</code><ul>
<li>系统有很多放置可执行文件的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin下面的指令可以被root与一般帐号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。</li>
</ul>
</li>
<li><code>/boot</code><ul>
<li>这个目录主要在放置开机会使用到的文件，包括Linux核心文件以及开机菜单与开机所需配置文件等等。 Linux kernel常用的文件名为：vmlinuz，如果使用的是grub2这个开机管理程序， 则还会存在/boot/grub2/这个目录喔！</li>
</ul>
</li>
<li><code>/dev</code><ul>
<li>在Linux系统上，任何设备与周边设备都是以文件的型态存在于这个目录当中的。 你只要通过存取这个目录下面的某个文件，就等于存取某个设备啰～ 比要重要的文件有 <code>/dev/null</code>, <code>/dev/zero</code>, <code>/dev/tty</code>, <code>/dev/loop*</code>, <code>/dev/sd*</code> 等等 </li>
</ul>
</li>
<li><code>/etc</code><ul>
<li>系统主要的配置文件几乎都放置在这个目录内，例如人员的帐号密码档、 各种服务的启始档等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的， 但是只有root有权力修改。FHS建议不要放置可可执行文件（binary）在这个目录中喔。比较重要的文件有： /etc/modprobe.d/, /etc/passwd, /etc/fstab, /etc/issue 等等。另外 FHS 还规范几个重要的目录最好要存在 /etc/ 目录下喔：</li>
<li>/etc/opt（必要）：这个目录在放置第三方协力软件 /opt 的相关配置文件</li>
<li>/etc/X11/（建议）：与 X Window 有关的各种配置文件都在这里，尤其是 xorg.conf 这个 X Server 的配置文件。</li>
<li>/etc/sgml/（建议）：与 SGML 格式有关的各项配置文件</li>
<li>/etc/xml/（建议）：与 XML 格式有关的各项配置文件</li>
</ul>
</li>
<li><code>/lib</code><ul>
<li>系统的函数库非常的多，而/lib放置的则是在开机时会用到的函数库， 以及在/bin或/sbin下面的指令会调用的函数库而已。 什么是函数库呢？你可以将他想成是“外挂”，某些指令必须要有这些“外挂”才能够顺利完成程序的执行之意。 另外 FSH 还要求下面的目录必须要存在：</li>
<li>/lib/modules/：这个目录主要放置可抽换式的核心相关模块（驱动程序）喔！</li>
</ul>
</li>
<li><code>/media</code><ul>
<li>media是“媒体”的英文，顾名思义，这个/media下面放置的就是可移除的设备啦！ 包括软盘、光盘、DVD等等设备都暂时挂载于此。常见的文件名有：/media/floppy，/media/cdrom等等。</li>
</ul>
</li>
<li><code>/mnt</code><ul>
<li>如果你想要暂时挂载某些额外的设备，一般建议你可以放置到这个目录中。 在古早时候，这个目录的用途与/media相同啦！只是有了/media之后，这个目录就用来暂时挂载用了。</li>
</ul>
</li>
<li><code>/opt</code><ul>
<li>这个是给第三方协力软件放置的目录。什么是第三方协力软件啊？ 举例来说，KDE这个桌面管理系统是一个独立的计划，不过他可以安装到Linux系统中，因此KDE的软件就建议放置到此目录下了。 另外，如果你想要自行安装额外的软件（非原本的distribution提供的），那么也能够将你的软件安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！ </li>
</ul>
</li>
<li><code>/run</code><ul>
<li>早期的 FHS 规定系统开机后所产生的各项信息应该要放置到 /var/run 目录下，新版的 FHS 则规范到 /run 下面。 由于 /run 可以使用内存来仿真，因此性能上会好很多！</li>
</ul>
</li>
<li><code>/sbin</code><ul>
<li>Linux有非常多指令是用来设置系统环境的，这些指令只有root才能够利用来“设置”系统，其他使用者最多只能用来“查询”而已。 放在/sbin下面的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序，一般则放置到/usr/sbin/当中。至于本机自行安装的软件所产生的系统可执行文件（system binary）， 则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, mkfs等等。</li>
</ul>
</li>
<li><code>/srv</code><ul>
<li>srv可以视为“service”的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如WWW, FTP等等。举例来说，WWW服务器需要的网页数据就可以放置在/srv/www/里面。 不过，系统的服务数据如果尚未要提供给网际网络任何人浏览的话，默认还是建议放置到 /var/lib 下面即可。 </li>
</ul>
</li>
<li><code>/tmp</code><ul>
<li>这是让一般使用者或者是正在执行的程序暂时放置文件的地方。 这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！ 因为FHS甚至建议在开机时，应该要将/tmp下的数据都删除唷！</li>
</ul>
</li>
<li><code>/usr</code><ul>
<li>第二层 FHS 设置，后续介绍</li>
</ul>
</li>
<li><code>/var</code><ul>
<li>第二层 FHS 设置，主要为放置变动性的数据，后续介绍</li>
</ul>
</li>
</ul>
<p>FHS 建议可以存在的目录</p>
<ul>
<li><code>/home</code><ul>
<li>这是系统默认的使用者主文件夹（home directory）。在你新增一个一般使用者帐号时， 默认的使用者主文件夹都会规范到这里来。比较重要的是，主文件夹有两种代号喔：</li>
<li><code>~</code>：代表目前这个使用者的主文件夹</li>
<li><code>~dmtsai</code>：则代表 dmtsai 的主文件夹！</li>
</ul>
</li>
<li><code>/lib&lt;qual&gt;</code><ul>
<li>用来存放与 /lib 不同的格式的二进制函数库，例如支持 64 位的 /lib64 函数库等</li>
</ul>
</li>
<li><code>/root</code><ul>
<li>系统管理员（root）的主文件夹。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有root的主文件夹，所以我们会希望root的主文件夹与根目录放置在同一个分区中。</li>
</ul>
</li>
</ul>
<p>事实上FHS针对根目录所定义的标准就仅有上面的咚咚，不过我们的Linux下面还有许多目录你也需要了解一下的。 下面是几个在Linux当中也是非常重要的目录喔</p>
<ul>
<li><code>/lost+found</code><ul>
<li>这个目录是使用标准的ext2/ext3/ext4文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。不过如果使用的是 xfs 文件系统的话，就不会存在这个目录了！</li>
</ul>
</li>
<li><code>/proc</code><ul>
<li>这个目录本身是一个“虚拟文件系统（virtual filesystem）”喔！他放置的数据都是在内存当中， 例如系统核心、行程信息（process）、周边设备的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的文件例如：<code>/proc/cpuinfo</code>, <code>/proc/dma</code>, <code>/proc/interrupts</code>, <code>/proc/ioports</code>, <code>/proc/net/*</code> 等等。</li>
</ul>
</li>
<li><code>/sys</code><ul>
<li>这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录核心与系统硬件信息较相关的信息。 包括目前已载入的核心模块与核心侦测到的硬件设备信息等等。这个目录同样不占硬盘容量喔！</li>
</ul>
</li>
</ul>
<p>早期 Linux 在设计的时候，若发生问题时，救援模式通常仅挂载根目录而已，因此有五个重要的目录被要求一定要与根目录放置在一起， 那就是 /etc, /bin, /dev, /lib, /sbin 这五个重要目录。现在许多的 Linux distributions 由于已经将许多非必要的文件移出 /usr 之外了， 所以 /usr 也是越来越精简，同时因为 /usr 被建议为“即使挂载成为只读，系统还是可以正常运行”的模样，所以救援模式也能同时挂载 /usr 喔！ </p>
<h3 id="/usr__u4ECB_u7ECD"><a href="#/usr__u4ECB_u7ECD" class="headerlink" title="/usr 介绍"></a>/usr 介绍</h3><p>依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的（shareable, static）。usr是Unix Software Resource的缩写， 也就是“Unix操作系统软件资源”所放置的目录，而不是使用者的数据啦！这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行创建该软件自己独立的目录。</p>
<p>一般来说，/usr的次目录建议有下面这些：</p>
<ul>
<li><code>/usr/bin/</code><ul>
<li>所有一般用户能够使用的指令都放在这里！目前新的 CentOS 7 已经将全部的使用者指令放置于此，而使用链接文件的方式将 /bin 链接至此！ 也就是说， /usr/bin 与 /bin 是一模一样了！另外，FHS 要求在此目录下不应该有子目录！</li>
</ul>
</li>
<li><code>/usr/lib/</code><ul>
<li>基本上，与 /lib 功能相同，所以 /lib 就是链接到此目录中的！</li>
</ul>
</li>
<li><code>/usr/local/</code><ul>
<li>系统管理员在本机自行安装自己下载的软件（非distribution默认提供者），建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦！ 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录喔！</li>
</ul>
</li>
<li><code>/usr/sbin/</code><ul>
<li>非系统正常运行所需要的系统指令。最常见的就是某些网络服务器软件的服务指令（daemon）啰！不过基本功能与 /sbin 也差不多， 因此目前 /sbin 就是链接到此目录中的。</li>
</ul>
</li>
<li><code>/usr/share/</code><ul>
<li>主要放置只读架构的数据文件，当然也包括共享文件。在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文字文件嘛！在此目录下常见的还有这些次目录：</li>
<li>/usr/share/man：线上说明文档</li>
<li>/usr/share/doc：软件杂项的文件说明</li>
<li>/usr/share/zoneinfo：与时区有关的时区文件</li>
</ul>
</li>
</ul>
<p>FHS 建议可以存在的目录</p>
<ul>
<li><code>/usr/games/</code><ul>
<li>与游戏比较相关的数据放置处</li>
</ul>
</li>
<li><code>/usr/include/</code><ul>
<li>c/c++等程序语言的文件开始（header）与包含档（include）放置处，当我们以tarball方式 （<code>*.tar.gz</code> 的方式安装软件）安装某些数据时，会使用到里头的许多包含档喔！</li>
</ul>
</li>
<li><code>/usr/libexec/</code><ul>
<li>某些不被一般使用者惯用的可执行文件或脚本（script）等等，都会放置在此目录中。例如大部分的 X 窗口下面的操作指令， 很多都是放在此目录下的。</li>
</ul>
</li>
<li><code>/usr/lib&lt;qual&gt;/</code><ul>
<li>与 <code>/lib&lt;qual&gt;/</code> 功能相同，因此目前 <code>/lib&lt;qual&gt;</code> 就是链接到此目录中 </li>
</ul>
</li>
<li><code>/usr/src/</code><ul>
<li>一般源代码建议放置到这里，src有source的意思。至于核心源代码则建议放置到/usr/src/linux/目录下。</li>
</ul>
</li>
</ul>
<h3 id="/var__u4ECB_u7ECD"><a href="#/var__u4ECB_u7ECD" class="headerlink" title="/var 介绍"></a>/var 介绍</h3><p>如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运行后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括高速缓存（cache）、登录文件（log file）以及某些软件运行所产生的文件， 包括程序文件（lock file, run file），或者例如MySQL数据库的文件等等。常见的次目录有：</p>
<ul>
<li><code>/var/cache/</code><ul>
<li>应用程序本身运行过程中会产生的一些暂存盘；</li>
</ul>
</li>
<li><code>/var/lib/</code><ul>
<li>程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去！</li>
</ul>
</li>
<li><code>/var/lock/</code><ul>
<li>某些设备或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该设备时， 就可能产生一些错误的状况，因此就得要将该设备上锁（lock），以确保该设备只会给单一软件所使用。 举例来说，烧录机正在烧录一块光盘，你想一下，会不会有两个人同时在使用一个烧录机烧片？ 如果两个人同时烧录，那片子写入的是谁的数据？所以当第一个人在烧录时该烧录机就会被上锁， 第二个人就得要该设备被解除锁定（就是前一个人用完了）才能够继续使用啰。目前此目录也已经挪到 /run/lock 中！</li>
</ul>
</li>
<li><code>/var/log/</code><ul>
<li>重要到不行！这是登录文件放置的目录！里面比较重要的文件如/var/log/messages, /var/log/wtmp（记录登陆者的信息）等。</li>
</ul>
</li>
<li><code>/var/mail/</code><ul>
<li>放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中！ 通常这两个目录是互为链接文件啦！</li>
</ul>
</li>
<li><code>/var/run/</code><ul>
<li>某些程序或者是服务启动后，会将他们的PID放置在这个目录下喔！至于PID的意义我们会在后续章节提到的。 与 /run 相同，这个目录链接到 /run 去了！</li>
</ul>
</li>
<li><code>/var/spool/</code><ul>
<li>这个目录通常放置一些伫列数据，所谓的“伫列”就是排队等待其他程序使用的数据啦！ 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作调度数据（crontab），就会被放置到/var/spool/cron/目录中！</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为之后更多会涉及后台开发的部分，所以系统学习一下 Linux 还是很有必要的，这里就用《鸟哥的 Linux 私房菜》作为主要的学习材料。不过因为我本身已经有一定基础了，所以这里主要会记录个人觉得比较生疏和重要的地方。</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://wdxtub.com/tags/Linux/"/>
    
      <category term="基础" scheme="http://wdxtub.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="服务器" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【启示录：打造用户喜爱的产品】读书笔记]]></title>
    <link href="http://wdxtub.com/2016/03/26/inspired-create-product/"/>
    <id>http://wdxtub.com/2016/03/26/inspired-create-product/</id>
    <published>2016-03-26T20:53:01.000Z</published>
    <updated>2016-03-26T20:56:23.000Z</updated>
    <content type="html"><![CDATA[<p>这本书基本上说清楚了打造好产品的方方面面，很值得一看。</p>
<a id="more"></a>
<hr>
<p>我们汲取了深刻教训：如果开发的产品没有市场价值，那么无论开发团队多么优秀也无济于事。不仅如此，我们认识到仅仅做出产品并不够，还要确认产品是有价值的、可用的、可行的。</p>
<p>从担任网景高级产品经理开始，我的日常工作明确分为三块：人员、流程、产品。</p>
<ul>
<li>人员是指负责定义和开发产品的团队成员的角色和职责。</li>
<li>流程是指探索、开发富有创意的产品时，反复应用的步骤和成功的实践经验。</li>
<li>产品是指富有创意的产品具有的鲜明特性。</li>
</ul>
<p>这三个部分是探索和开发用户喜爱的产品必不可少的。项目都是由人完成的，流程则保证大家持续开发出用户喜爱的产品。</p>
<hr>
<p>我从不认为富有创意的产品来自偶然。成功的产品都遵循一定的规律。以下是我总结的十条规律。</p>
<ol>
<li>产品经理的任务是探索产品的价值、可用性、可行性。</li>
<li>探索（定义）产品需要产品经理、交互设计师、软件架构师通力合作。</li>
<li>开发人员不擅长用户体验设计，因为开发人员脑子里想的是实现模型，而用户看重的是产品的概念模型。</li>
<li>用户体验设计就是交互设计、视觉设计（对硬件设备来说，则是工业设计）。</li>
<li>功能（产品需求）和用户体验设计密不可分。</li>
<li>产品创意必须尽早地、反复地接受目标用户的试用，以便获取有效的用户体验。</li>
<li>为了验证产品的价值和可用性，必须尽早地、反复地请目标用户测试产品创意。</li>
<li>采用高保真的产品原型是全体团队成员了解用户需求和用户体验最有效的途径。</li>
<li>产品经理的目标是在最短的时间内把握复杂的市场/用户需求，确定产品的基本要求——价值、可用性、可行性。</li>
<li>一旦认定产品符合以上基本要求，它就是一个完整的概念，去掉任何因素，都不可能达到预期的结果。</li>
</ol>
<h2 id="u5173_u952E_u89D2_u8272_u53CA_u5176_u804C_u8D23"><a href="#u5173_u952E_u89D2_u8272_u53CA_u5176_u804C_u8D23" class="headerlink" title="关键角色及其职责"></a>关键角色及其职责</h2><p>产品经理的主要职责分为两项：评估产品机会（product opportunity）；定义要开发的产品。</p>
<p>产品创意的来源很多，比如，公司高管的意见、用户的反馈、可用性测试的结果、产品团队和营销团队的点子、业内人士的分析等。应该有人严格审核这些创意，判断是否值得采纳。产品经理就是负责这项评估的人。许多公司借助市场需求文档（market requirements document，MRD）来完成这项工作。我更愿意使用一种简化的方法，我称之为机会评估（opportunity assessment）。</p>
<p>确定有价值且符合公司发展要求的产品机会后，还需要探索产品的解决方案，包括基本的产品特征和功能、产品的用户体验、产品的发布标准。这些也属于产品经理的工作范畴，而且是产品经理的核心职责。有些公司借助产品需求文档（product requirements document，PRD）来完成这项工作，也有人称其为产品说明文档或功能说明文档。同样，我主张采用简化的文档，围绕产品原型来展开这项工作。注意，文档应该清晰地描述产品的功能和属性，避免讨论产品的实现方法。</p>
<p>用户体验设计团队由多种角色组成，稍后我会详细说明。这里只谈谈最关键的角色——交互设计师（也称为信息架构师、用户界面设计师、用户体验架构师）。交互设计师负责深入理解目标用户，设计有价值的、可用的功能，以及用户导航和产品使用流程。交互设计师与产品经理密切合作，将功能与设计相结合，满足用户需求。目标是确保产品同时具有可用性和价值（可用性指的是用户明白如何使用产品，价值指的是用户对产品的渴求程度）。</p>
<p>产品经理完成产品定义后，开发团队承接项目，开始开发产品。项目管理的核心任务是制订计划和跟踪进度。项目管理工作常常由不同的角色承担，可能由专职的项目经理操刀，也可能由开发经理兼任（因为开发团队占有大部分项目资源），还可能由产品经理披挂上阵。这通常取决于公司文化和项目规模。规模较大的项目最好安排经验丰富的专职项目经理管理。</p>
<p>软件工程师也称为产品开发人员或软件开发人员，负责开发产品。开发团队在有些公司被称为IT（信息技术）团队。注意不要混淆这两个概念，区分的关键是看他们是为顾客开发软件，还是为公司内部（如人力资源部门）开发软件。IT团队通常指的是为内部员工提供技术支持的团队，而开发团队指的是为外部客户开发和维护产品的团队。</p>
<p>互联网服务产品通常运行在服务器上，用户通过web访问服务。运维团队负责保证服务正常运行。虽然有些公司将这项任务交给开发团队负责，但是运维工作需要一系列专业技能，很难由开发团队单独承担。</p>
<p>产品营销团队负责对外发布信息、宣传产品，为拓展市场销售渠道、组织重点营销活动（如在线营销）、促进产品销售提供支持。有些公司让一个人同时负责产品管理（产品定义）和产品营销。这两项工作内容相差很大，这样做实在不明智。</p>
<p>顺便提一下，微软把负责制定产品说明文档和管理项目进度的人称为项目经理（program manager）。由于这些“可怜”的人要同时应付多个项目，因此业界现在已经习惯用这个头衔称呼同时管理多个项目的管理人员。在微软，产品经理指的是那些负责产品营销的人。虽然我不喜欢微软对这两个头衔的用法，但我认为他们定义产品的工作做得非常棒。</p>
<h2 id="u4EA7_u54C1_u7BA1_u7406_u4E0E_u4EA7_u54C1_u8425_u9500"><a href="#u4EA7_u54C1_u7BA1_u7406_u4E0E_u4EA7_u54C1_u8425_u9500" class="headerlink" title="产品管理与产品营销"></a>产品管理与产品营销</h2><p>产品经理负责详细定义待开发的产品，让真实的用户测试产品。产品营销人员负责向外界宣传和推广产品，负责产品发布，为拓展市场销售渠道、组织重点营销活动（如在线营销）、促进产品销售提供支持。</p>
<h2 id="u4EA7_u54C1_u7BA1_u7406_u4E0E_u9879_u76EE_u7BA1_u7406"><a href="#u4EA7_u54C1_u7BA1_u7406_u4E0E_u9879_u76EE_u7BA1_u7406" class="headerlink" title="产品管理与项目管理"></a>产品管理与项目管理</h2><p>有些项目经理以为管理能力等同于使用微软Project软件的能力，他们没有领悟项目管理的真谛。以下是我从琳·丽迪这样优秀的项目经理身上总结出的七个特点。</p>
<p><strong>工作紧迫感</strong></p>
<p>只要琳走进房间，立刻就能传达给大家一种紧迫感。每次会议大约60秒闲话开场白后，马上转入正题。这种效果表面看来是因为她独特的身体语言和气质，但事实上，紧迫感和高效率是eBay企业文化的核心，而且已经升华为琳人格的一部分。</p>
<p><strong>善于捕捉问题</strong></p>
<p>有无数原因导致会议效率低下、毫无建设性，其中最主要的原因是会议目的不明确，不清楚要解决什么问题，也不知道难点在哪。优秀的项目经理能够迅速地、准确地指出问题及其要害，改善会议效果。</p>
<p><strong>思路清晰</strong></p>
<p>引发典型业务问题的原因多种多样，比如政治因素、日程安排有冲突、同事个性不合等，如果置之不理，稍作拖延就会导致整个项目一团糟。项目经理需要排除感情因素，放下思想包袱，拨云见日，把待解决的问题逐一独立分离出来，分配给每位同事，专注解决。</p>
<p><strong>用数据说话</strong></p>
<p>优秀的项目经理明白数据的重要性，懂得利用数据识别项目方向，确认项目进度。他们知道改善产品和开发流程必须从测量、收集数据开始。在时间紧迫的情况下，最容易仅凭直觉草率行事。为避免出现这种情况，项目经理务必坚持根据数据和事实制定决策。</p>
<p><strong>果断</strong></p>
<p>在多数公司里，产品团队成员不必向项目经理汇报工作，但项目经理必须驱动同事作出决策。项目经理必须向大家传达一种紧迫感，及时向团队收集数据和建议，适时向上级部门汇报情况，把问题理顺，用理性的思路和清晰的理由帮助大家，利用数据作出决策。</p>
<p><strong>判断力</strong></p>
<p>以上这些特点都基于良好的判断力。项目经理必须清楚何时催促进度，何时向上级汇报，何时需要收集更多信息，何时找个别成员私下交流。判断力很难言传身教，只能靠自己积累经验获得。</p>
<p><strong>态度</strong></p>
<p>如果产品不能按时交付，我们总能听到各种理由：可行性太差、资源不足、时间不够、资金匮乏等等。项目经理绝不能为自己找借口，必须克服所有障碍，解决所有问题，一往无前、愈挫愈勇，直到梦想成真。</p>
<h2 id="u4EA7_u54C1_u7BA1_u7406_u4E0E_u4EA7_u54C1_u8BBE_u8BA1"><a href="#u4EA7_u54C1_u7BA1_u7406_u4E0E_u4EA7_u54C1_u8BBE_u8BA1" class="headerlink" title="产品管理与产品设计"></a>产品管理与产品设计</h2><p>好产品必须提供舒适的用户体验。舒适的用户体验是产品管理和用户体验设计共同作用的结果。这是个很大的话题，我们先从了解设计包括哪些角色、分工开始。这里我给出与用户体验设计密切相关的分工。注意我描述的是工作角色而不是个人，因为有的人可能承担多项工作。</p>
<p><strong>用户研究</strong></p>
<p>专门研究、分析用户，评估产品或产品原型是否符合特定用户的使用习惯。其具体工作包括拟订恰当的测试项目，监督测试，评估测试结果，提出改进方案。</p>
<p><strong>交互设计</strong></p>
<p>在理解目标用户的基础上设计有价值的、可用的目标功能、用户导航和产品使用流程。交互设计师通常用线框绘制产品需求，然后交给视觉设计师。</p>
<p><strong>视觉设计</strong></p>
<p>根据线框设计可见的用户界面（页面），包括严格的布局、颜色和字体设置等。视觉设计能够传达并唤起产品蕴含的情感（其重要性常常被低估）。</p>
<p><strong>原型制作</strong></p>
<p>迅速制作融合了产品经理和设计师创意的产品原型，让用户试用，并根据反馈意见反复修正原型。</p>
<p>对大型产品（尤其是大众互联网服务）来说，这四种角色缺一不可。开发企业级应用软件的公司如果想从众多竞争对手中脱颖而出，最简单的办法是提供优秀的用户体验。用户体验是大部分企业级产品的弱项。对小型产品来说，可以让一位设计师身兼多职。例如，我最近与一家创业型公司合作，开发针对大众的Web 2.0服务。对方只有三个人：一位产品经理、一位交互设计师（同时负责用户研究）、一位视觉设计师（同时负责开发原型）。他们的工作非常出色，很快就拿出了可供目标用户测试的产品原型。</p>
<p>很多公司希望改善产品的用户体验，把用户体验设计外包给设计公司。这在一定程度上是可行的，但是有些工作不适合外包。例如，我认为交互设计不能外包，原因如下。</p>
<ol>
<li>深入理解用户需求非常费时间，需要多个项目的经验积累。设计公司没时间深入了解客户需求，就算他们做到了，这些经验也很难保存下来，用到下一个版本里。</li>
<li>交互设计师必须现场深度参与项目开发，从立项直到产品发布。开发和测试过程中会出现各种细节问题，必须有一名交互设计师迅速作出决定。</li>
<li>产品的用户体验是公司的核心竞争力，必须在内部完成。如果让我选择，质量检验更适合外包。 只要团队中有一位称职的交互设计师，视觉设计也可以外包，毕竟视觉设计公司很多，完全可以满足需求。此外，用户研究和可用性测试也可以外包，只是成本较高，对我这种重视测试反馈（参考第22章）的人来说更是如此，所以我建议让产品经理和交互设计师分担这项工作。</li>
</ol>
<h2 id="u4EA7_u54C1_u7BA1_u7406_u4E0E_u8F6F_u4EF6_u5F00_u53D1"><a href="#u4EA7_u54C1_u7BA1_u7406_u4E0E_u8F6F_u4EF6_u5F00_u53D1" class="headerlink" title="产品管理与软件开发"></a>产品管理与软件开发</h2><p>产品经理负责定义产品方案；开发团队最了解哪些产品构思是可行的，他们负责产品的开发与实现。作为产品经理，你很快能体会到，只有与开发团队融洽合作，才有可能开发出合格的产品；否则等待你的将是一段漫长、难挨的日子。形成合作关系的关键是双方承认彼此平等——任何一方不从属于另一方。产品经理负责定义正确的产品，开发团队负责正确地开发产品，双方相互依赖。你要求开发团队完成任务，必须先取得他们的认可，确信为了达到产品质量标准必须这么做；开发团队也要留给你足够的空间，设计有价值、可用的产品。</p>
<p>开发人员帮助产品经理完善产品定义的方式有如下三种。</p>
<ol>
<li>让开发人员直接面对用户或顾客，体会用户的困惑和疑虑，了解问题的严重性，这样好点子常常会随之而来，譬如，可以邀请一名开发人员参加产品原型测试。</li>
<li>向开发人员了解最新的技术发展动向，讨论哪些新技术可以用到产品里。开展头脑风暴，看看目前已实现的技术或即将实现的技术能不能解决手头的问题。</li>
<li>让开发人员在探索（定义）产品的初期阶段参与评估产品设计，协助策划方案。产品经理常犯一类错误，即完成产品定义后，便扔给开发团队，置之不理。这样做只会贻误协调需求与可行性的最佳时机，等到发现问题时，为时已晚。</li>
</ol>
<p>同样，产品经理也应该配合开发人员的工作，方式如下。</p>
<ol>
<li>产品经理只定义满足基本要求的产品。产品经理应该意识到，自己要定义的不是最终产品，而是满足基本要求的产品。只有这样，产品管理与软件开发之间才能形成良好的互动。</li>
<li>一旦产品进入开发阶段，要尽可能避免修改产品的需求和设计。虽然有些事情超出你的控制范围，导致项目波动是不可避免的（开发人员也能理解），但是千万不要在此时尝试突发奇想的点子。</li>
<li>产品开发阶段难免会产生诸多问题，比如，用例丢失，用例设计考虑不周全等，这很正常，最优秀的团队也避免不了。产品经理应该迅速采取行动，在维持产品基本功能、尽量避免修改的原则上，拿出解决方案。</li>
</ol>
<p>与开发团队合作应该遵循以下原则：在产品管理上为开发团队预留20%的自主时间，让他们自由支配。开发团队可以利用这些时间重写代码、完善架构、重构代码库中有缺陷的部分，或者更换数据库管理系统，提高系统性能，避免“需要停下来重写代码”的情形发生。</p>
<p>如果你的糟糕处境已经初现端倪，就应该拿出至少20%的资源进行调整。我担心有些团队连20%都不愿意拿出来。如果你已经身陷重写代码的困境，说明公司危在旦夕，这里给出一点建议供你参考。</p>
<p>第一，针对开发团队确定的产品修改目标制订切实可行的计划和时间表。通常，有经验的开发团队估计的开发时间八九不离十，但是重写代码是例外，因为多数团队没有重写代码的实际经验，估计往往过于乐观。你必须审时度势，仔细检查每处细节，确保计划切实可行。</p>
<p>第二，只要有可能，最好把重写目标分成几大块，实现递增修改，让用户感受到产品的改进，哪怕会因此把九个月的工作时间延长至两年，也一定要采用这种方式。重写代码时，保证让用户看到功能的改进——即使会占用少则25%，多则50%的开发资源——对保持产品（尤其是互联网产品）的市场占有率至关重要。</p>
<p>第三，由于开发用户可见功能的资源有限，必须谨慎选择正确的产品特性，确保产品定义的正确性。</p>
<h2 id="u62DB_u8058_u4EA7_u54C1_u7ECF_u7406"><a href="#u62DB_u8058_u4EA7_u54C1_u7ECF_u7406" class="headerlink" title="招聘产品经理"></a>招聘产品经理</h2><p><strong>个人素质和态度</strong></p>
<p>技术可以学习，素质却难以培养，有些素质是成功的产品经理必不可少的。</p>
<p><strong>对产品的热情</strong></p>
<p>有这样一群人，他们对产品有一种本能的热爱，把自己生活中的一切事物都看成产品，怀揣对优秀的产品的热爱和尊重。这份热情是产品经理必备的素质，是他们夜以继日克服困难、完善产品的动力。这份热情能感染团队成员，激励所有人。</p>
<p><strong>用户立场</strong></p>
<p>理想的产品经理不一定来自产品的目标市场（这种情况有利也有弊），但是他必须融入目标市场。这一特质对制造大众产品的高科技企业尤为难得。我们倾向于从自己的角度去理解用户和市场。事实上，目标用户的经验、喜好、价值观、知觉能力、忍受程度、技术理解很可能与我们的大相径庭。</p>
<p><strong>智力</strong></p>
<p>人的智力水平是无法替换的。产品管理需要洞察力和判断力，因此必须具备敏锐的头脑。勤奋当然是必需的，但从事这项工作光有勤奋还远远不够。</p>
<p><strong>职业操守</strong></p>
<p>每种团队角色承担的义务和付出的努力都不相同。产品经理肩负着产品的前途和命运，绝不适合贪图安逸的人担任。即便掌握了时间管理和产品管理的技巧，产品经理依然要为产品投入大量精力。成功的产品经理能拥有时间享受清闲的家庭生活吗？只要具备足够的经验，我相信可以做到。但是，如果你期望的是一周只工作四十个小时，下班后把工作抛诸脑后，那是不现实的。</p>
<p><strong>正直</strong></p>
<p>在所有产品团队成员里，产品经理最能体现公司和产品的价值观。通常产品经理不直接管理团队成员，不能要求别人执行命令，所以他必须通过行动影响、说服身边的同事。这种影响基于相互的信任和尊重，要求产品经理必须是个正直的人。</p>
<p><strong>信心</strong></p>
<p>很多人相信经验可以让人产生自信。如果仅凭经验可以建立信心，为什么许多工作多年的产品经理却毫无自信？相反，刚刚步入社会的大学毕业生却往往充满自信（虽然这种自信通常源自对自身状况的无知）。 自信是很重要的素质。公司高管、产品团队、销售团队都需要看到产品经理的信心，确信他们投入的时间、金钱、努力不会付之东流。自信的人更有说服力，更容易成为人们愿意追随的领导者。</p>
<p><strong>态度</strong></p>
<p>称职的产品经理把自己当成产品的CEO，愿意为产品的最终成败承担全部责任，绝不找借口。虽然他清楚产品按时成功上市要克服许多困难——开发难度大、开发时间长、成本过高、产品复杂等，但他明白预见和解决这些问题是他的责任。</p>
<p><strong>技能</strong></p>
<p>掌握一些重要的技能是打造成功产品的关键。我相信，只要具备优秀的个人素质，所有技能都可以习得。</p>
<p><strong>运用技术的能力</strong></p>
<p>很多成功的产品经理是工程师出身，因为策划产品在很大程度上取决于对新技术的理解，以及如何应用技术解决相关的问题。出色的产品经理并不需要自己发明或实现新技术，但必须有能力理解技术，发掘技术的应用潜力。</p>
<p><strong>注意力</strong></p>
<p>产品经理要优先解决重要问题。研发产品的过程中有很多干扰。能否集中注意力解决关键问题、克制不断增加功能的冲动、不受关键人物或重要客户的影响，取决于产品经理是否有足够强的自律性——不但要遵守公司制度，还要严格要求自己。</p>
<p><strong>时间管理</strong></p>
<p>电子邮件、即时消息和手机构成的世界充满了干扰。你可能一大早就来上班，拼命工作一整天，连吃饭喝水都顾不上，深夜回到家却发现到头来没完成一件重要工作。时间都用来“救火”和处理“紧急”事件了。熟练、迅速地区分重要任务和紧急任务，合理地规划和安排时间是产品经理必备的技能。如果产品经理无法集中精力完成真正重要的任务，那产品就难免命运多舛了。</p>
<p><strong>沟通技能</strong></p>
<p>虽然沟通技巧可以学习，但要做到出类拔萃需要经年累月的练习。沟通（包括口头表达和书面表达）能力是产品经理必备的技能，如前所述，产品经理只能以理服人，绝不能靠职位压制他人。口头表达能力可以在面试中测试，测试书面表达能力则需另寻他法。我常建议应聘者随身携带文字材料证明其书面表达能力，比如，不涉及专利的产品策划文档。</p>
<p><strong>商业技能</strong></p>
<p>作为产品团队的发言人，产品经理要协调团队与财务部门、营销部门、销售团队、公司高管之间的工作——必须使用这些人听得懂的概念和术语。 我认为产品经理应该具备双语技能。这并非指中文和英文，而是指产品经理既能与程序员讨论技术，又能与管理层和营销人员讨论成本结构、边际效应、市场份额、产品定位和品牌。</p>
<p>技术发展很快，所以产品经理必须善于快速学习新技术，解决新问题。我面试应聘者时，不关心他们已掌握的知识，只看重他们的学习思路。比如，让他们回忆研发产品之前，他们需要学习哪些知识，需要多长时间学习，如何利用这些知识。</p>
<h2 id="u5DF4_u987F_u5C06_u519B_u7684_u5FE0_u544A"><a href="#u5DF4_u987F_u5C06_u519B_u7684_u5FE0_u544A" class="headerlink" title="巴顿将军的忠告"></a>巴顿将军的忠告</h2><p>永远不要告诉别人怎么做。告诉他们做什么，他们自然会发挥天赋，给你惊喜。 ——乔治·史密斯·巴顿</p>
<p>优秀的用户体验设计师，特别是交互设计师可谓凤毛麟角。如果你发现了这样的人选，就一定要给予足够的创作空间，充分发挥其才能，使设计师成为产品团队的重要组成部分，让他们探索各种设计方案，倾听他们分析用户的行为和喜好。</p>
<p>总之，你留给用户体验设计师和开发人员的空间越大，他们就越有可能打造出用户喜爱的产品。</p>
<h2 id="u4EA7_u54C1_u526F_u7ECF_u7406"><a href="#u4EA7_u54C1_u526F_u7ECF_u7406" class="headerlink" title="产品副经理"></a>产品副经理</h2><p>我有一点工作体会，做产品要找公司最聪明的人合作。我发现每个公司都有几个聪明绝顶的人，这些人是公司的潜在资源，关键看你能不能发现他们。如果有幸能找到他们，就应该不拘一格地任用。我把这些人看做产品副经理，甚至公开授予他们头衔，把他们招进产品团队。</p>
<p>产品经理还可以向自己的领导借力，听取他们对产品的建议，虽然他们不太可能参与具体工作，但并不表示他们会袖手旁观。你需要的帮手可能隐身于公司各处——开发部门、销售部门、客户服务部门，甚至董事会。如何发现他们呢？</p>
<ol>
<li>打听！多问问同事，肯定会有收获。</li>
<li>采用走动式管理模式。这源于惠普的做法。管理者要走出自己的办公室和圈子，花时间与员工相处。</li>
<li>认真倾听与会者的对话与发言。</li>
<li>敞开办公室的门，让大家知道你随时欢迎他们向你提出产品建议。</li>
<li>坦率地把你的烦恼告诉同事，大家会热情地帮助你。</li>
<li>一起泡吧。工作之余，产品经理总是与产品经理一起消遣，高管总是与高管为伍，这是司空见惯的事。如果你能抽出时间与普通员工一起休息、娱乐，一定能发现“埋在沙里的金子”。</li>
</ol>
<h2 id="u7BA1_u7406_u4E0A_u53F8"><a href="#u7BA1_u7406_u4E0A_u53F8" class="headerlink" title="管理上司"></a>管理上司</h2><p>下面我介绍管理上司的十条经验。</p>
<ol>
<li>为项目波动做好准备 我用项目波动代指让你心烦意乱的各种返工、计划变更。不要企图消灭项目波动，但是可以尽量降低其负面影响。方法是提高警惕，记录工作进度，比如，记录每周、每月、每季度有多少时间项目在往前推进，掌握项目波动的规律，寻找对策。制订项目计划时，预留出时间应对变化和调整，做好“做无用功”的心理准备。这个方法不仅能缓解压力，提高计划的准确度，还有助于挖掘有待改善的细节。</li>
<li>注意沟通的方式与频率 千人千面，管理者也不例外的。有些管理者喜欢事无巨细亲力亲为；有些则希望尽量不被打扰。有些喜欢你用邮件介绍工作进展；有些则喜欢简短的口头汇报。弄清上司的喜好，对症下药。</li>
<li>会前沟通很多公司频繁开会。公司的高管、股东越多，汇报进度和评估工作的会议就越多。为了让大家了解进展，必须确保人人到场。组织好会议的诀窍是在正式会议召开前充分沟通，即在会前逐一会见与会的高管和股东，提出你的观点，征询他们的意见，确保会议召开前你们已经达成一致意见。如果会前沟通顺利，可以大大缩短正式会议的时间，结果也将毫无悬念。正式会议的作用只是让与会人员认识到大家取得了一致意见。</li>
<li>多提建议，少谈问题 管理者希望听到解决问题的方法，而不是听你报怨。最好根据问题的重要性列举出多种解决方案，并附上你的依据和建议。</li>
<li>向上司借力 许多员工不懂得向上司借力。假如你通过分析得出了解决方案，公司高管没有时间与你进行会前沟通，但你的上司能找到机会与他们交流，你可以把想法告诉上司，请他帮你转达建议。上司也想尽早结束会议，因而会乐于帮你。</li>
<li>充分准备 管理者通常聪明过人，能够立马发现你思路和计划上的漏洞。你最好准备充分，弄清问题所在，做到有备无患。</li>
<li>缩短邮件篇幅 产品经理喜欢写长篇的邮件向上司汇报工作，这是大忌。上司每天可能会收到上百封邮件，他更希望用简明扼要的方式进行交流。收件人的级别越高，邮件的篇幅就该越短。你可以添加附件，但不要让正文篇幅过长。</li>
<li>多用数据和事实说话 与上司（尤其是高管）打交道时，务必要提供数据和事实。网景公司前CEO吉姆·巴克斯德尔（Jim Barksdale）说过一句名言：如果我们依照个人看法来做决定，那就是臆断。多做准备工作，收集事实和数据，你的建议才有说服力。</li>
<li>内部宣传 向公司同事宣传产品，让大家认可你的工作，乐于帮助你。充分、有效的宣传，可以大大降低与其他部门合作的成本。</li>
<li>做让领导省心的员工 管理者的工作是保证团队高效运作，他们时间有限。不要劳烦你的上司做你的导师，但可以在你的直接管理层外另寻导师。思考如何节省上司的时间，你会获益匪浅。</li>
</ol>
<h2 id="u8BC4_u4F30_u4EA7_u54C1_u673A_u4F1A"><a href="#u8BC4_u4F30_u4EA7_u54C1_u673A_u4F1A" class="headerlink" title="评估产品机会"></a>评估产品机会</h2><p>市场给予新产品诸多机会，即使成熟的市场也不例外。因为市场环境充满变数：竞争对手不断被淘汰，新技术、新创意不断涌现……产品经理必须用他灵敏的“嗅觉”，从纷至沓来的机遇中迅速评估、挑选出有市场潜力、可行的创意，过滤那些没有价值或时机尚不成熟的点子。</p>
<p>为了评估产品机会，我要求产品经理回答如下十个问题。</p>
<ol>
<li>产品要解决什么问题？（产品价值）</li>
<li>为谁解决这个问题？（目标市场）</li>
<li>成功的机会有多大？（市场规模）</li>
<li>怎样判断产品成功与否？（度量指标或收益指标）</li>
<li>有哪些同类产品？（竞争格局）</li>
<li>为什么我们最适合做这个产品？（竞争优势）</li>
<li>时机合适吗？（市场时机）</li>
<li>如何把产品推向市场？（营销组合策略）</li>
<li>成功的必要条件是什么？（解决方案要满足的条件）</li>
<li>根据以上问题，给出评估结论。（继续或放弃）</li>
</ol>
<p>开发新产品能为老用户提供更多选择，还能吸纳新用户；改善原有产品能提高老用户的满意度，也能吸纳新用户。两者各有千秋。</p>
<h2 id="u4EA7_u54C1_u63A2_u7D22"><a href="#u4EA7_u54C1_u63A2_u7D22" class="headerlink" title="产品探索"></a>产品探索</h2><p>管理层坚持给产品探索设定期限，主要有如下原因。</p>
<ol>
<li>探索产品的过程不可预测。管理层担心花几个月研究解决方案，最后却做不出产品，而如果按计划进入开发阶段，至少有事可做。</li>
<li>开发人员是紧缺资源，开发团队无事可做会让管理层抓狂。问题是，这反而导致开发资源被浪费。 不管大家意识到没有，所有的公司都会执行探索产品的流程，只不过有些公司不是利用产品原型完成这项工作，而是孤注一掷，用实际产品搭上全部开发时间进行产品探索。他们开发的是一款非常昂贵的原型，让不知情的用户掏钱参与原型测试。这些公司需要一两年时间（发布几个版本）才能赢利。</li>
</ol>
<h2 id="u4EA7_u54C1_u539F_u5219"><a href="#u4EA7_u54C1_u539F_u5219" class="headerlink" title="产品原则"></a>产品原则</h2><p>产品原则是对团队信仰和价值观的总结，用来指导产品团队作出正确的决策和取舍。它体现了产品团队的目标和愿景，是产品战略的重要组成部分。从形式上看，它是一系列明确的、体现团队特色的产品价值准则。</p>
<p>每次加入新团队，我要做的第一件事就是制定产品原则。制定产品原则意味着决定什么重要、什么不重要，哪些原则是根本的、战略性的，哪些是临时的、战术性的。产品原则不是产品功能的清单，不依赖于任何单独的产品，它是整个产品线的战略指南，是公司的价值宣言。好的产品原则甚至可以激发设计产品的灵感。制定产品原则的过程也是学习的过程，我可以从中了解新公司的企业文化，以及公司创始人设立的企业目标。产品原则是一套价值判断的框架，帮助公司作出正确的决策。</p>
<p>制定产品原则时容易出现两类错误。第一类是原则过于空泛，失去了指导作用。第二类是把设计原则误当成产品原则，比如，为用户提供清晰的导航路径（方便用户完成下一步操作）属于常见的设计原则，不是产品原则。</p>
<p>不少产品经理向我抱怨说，他们受够了没完没了的会议（既无议程也无结果），以及会议中的那些争论、冲突。公司高管还时不时打断会议进程，扔下没头没脑的意见，然后拂袖而去，留下他们丈二和尚摸不着头脑。 这种情况在产品决策过程中经常发生，原因主要有以下几点：第一，每位同事对公司的产品都有自己的看法；第二，大家都非常在乎产品，明白公司营利得靠用户，只有产品才能吸引用户；第三，许多人以为自己比其他人了解目标用户，事实上并非如此。</p>
<p>务必认真分析产品目标的优先级（从最重要到最不重要逐项排序），让团队达成共识。切不可囫囵吞枣地把所有目标都贴上“关键”和“重要”的标签。一定要区分什么最重要，什么第二重要…… 我常被请去解决产品决策中出现的争议，我发现，多数团队跳过了这关键的一步。由于缺少基本评估标准，每个人对目标和优先级的理解都不同，大家往往情绪激动，在细枝末节上争执不下。</p>
<p>即使大家已经达成共识，也应该在讨论开始前再次予以强调，最好把目标按优先级顺序写在白板上，这样每位同事都可以看到评估方案和制定决策的确切依据。制定决策的过程和依据必须完全透明，不要让人觉得你只凭直觉判断。务必告诉大家决策的依据和理由，清楚地展示每一个决策环节。激烈的会议争论会影响大伙的斗志和工作效率。如果再出现这种情况，请先回顾产品目标和目标优先级，确保大家达成共识。</p>
<h2 id="u4EA7_u54C1_u8BC4_u5BA1_u56E2"><a href="#u4EA7_u54C1_u8BC4_u5BA1_u56E2" class="headerlink" title="产品评审团"></a>产品评审团</h2><p>产品评审团并不是设计和开发产品的团队，它的职责是监督产品研发流程，制定关键决策。 它根据研发产品的四个里程碑来评审产品，制定决策。</p>
<ol>
<li>评审产品战略和产品路线图，启动评估产品机会的工作，即选择值得投入精力的产品，请产品经理开始评估产品机会。</li>
<li>根据评估产品机会的结果，决定是否开始定义产品的解决方案。</li>
<li>评审产品原型、用户测试结果、成本估算明细，决定是否开始开发产品。</li>
<li>评审最终产品、产品品质、发布计划、社会效应，决定是否发布产品。</li>
</ol>
<h2 id="u7279_u7EA6_u7528_u6237"><a href="#u7279_u7EA6_u7528_u6237" class="headerlink" title="特约用户"></a>特约用户</h2><p>组织特约用户的注意事项</p>
<ol>
<li>不要向特约用户收取参与费用，否则合作关系将会变味。产品经理需要的是开发产品的伙伴，不要变成为特约用户开发产品。如果特约用户愿意，你尽可以等正式产品发布后再向他们收取费用。</li>
<li>由于可以免费试用产品，通常会有大量的申请者申请成为特约用户。公司的销售部门为了提高业绩，可能会要求产品经理招募更多的用户。这会消耗产品经理大量的精力，而且这些用户不一定符合要求。为了满足大批心急的用户，公司可以发布预览版产品。特约用户的人数绝不能超过十个，否则产品经理不可能有时间和精力与每位用户深入沟通。</li>
<li>如果在寻找特约用户时遇到困难，很可能是因为产品要解决的问题不像产品经理想象的那么重要，将来也很难销售出去。这可以初步验证产品创意是否有价值。出现这种情况，产品经理应该重新考虑产品计划。</li>
<li>产品经理需要确保特约用户是产品的潜在目标用户。我们很容易把产品尝鲜者（early adopter）误当成特约用户。产品尝鲜者常常能容忍产品的不足和缺陷，根据他们的建议研发的产品，很可能只适合他们自己，无法满足大众的需求（参见第35章）。</li>
<li>产品经理务必向特约用户说明，我们要开发的是面向大众的通用产品，不是为某家公司开发的定制产品。特约用户也不希望出现这种情况，因为小众产品的生命周期比较短，一旦产品被淘汰，售后服务也将被取消。产品经理应该向特约用户承诺产品不会昙花一现。</li>
<li>产品经理应该把特约用户当成开发伙伴对待，视他们为同事，互相帮助。许多特约用户和我结下了深厚持久的友谊。</li>
<li>产品经理与特约用户的合作贯穿产品研发的每个环节：向他们展示产品原型，请他们参加测试，向他们请教产品的细节问题，让他们帮你部署、测试待发布产品的备选版本。</li>
<li>正式产品发布之前，一定要先请特约用户试用，确保每个人都满意，一旦发布，他们会坚定不移地向大众推荐产品。</li>
<li>产品经理还要和产品营销团队紧密合作。一方面，营销团队可以帮助你物色特约用户；另一方面，他们可以协助你提高特约用户受关注的程度。</li>
<li>如果是平台产品，特约用户的作用就更突出了，只不过六个特约用户要换成六个应用。产品经理要与特约应用的开发者紧密合作，确保在平台上构建的应用让用户感到满意，最好鼓励应用开发者发展自<br>己的特约用户。</li>
</ol>
<h2 id="u5E02_u573A_u8C03_u7814"><a href="#u5E02_u573A_u8C03_u7814" class="headerlink" title="市场调研"></a>市场调研</h2><p><strong>用户调查</strong></p>
<p>网络降低了用户调查的难度，提高了调查的效率，以至于现在几乎所有产品都要求做用户调查。做用户调查要注意两点。第一，设计调查问卷需要技巧和经验，不是一件容易的事。要结合具体情景，仔细设置问题，如果调查问卷措辞不清、先入为主，其他部门的同事就会质疑调查结果。第二，调查结果为获得解决方案提供了一条途径，但不是解决方案本身。哪怕所有用户都回答喜欢X特性，我们还是可以通过提供Y特性更实际地解决他们的需求。</p>
<p><strong>产品使用分析</strong></p>
<p>如果你的产品是网站，有很多实用的工具可以分析用户访问网站的行为。这些工具正确安装和配置后即可使用，非常划算。越早使用分析工具越好，不断地观察学习，然后调整产品。如果你的产品不是网站，可以在产品中添加分析工具，记录用户使用产品的行为。应该明确告知用户分析工具的用途，声明只收集统计数据，不涉及用户隐私。这样做虽然麻烦，但很值得。</p>
<p><strong>数据挖掘</strong></p>
<p>收集数据的渠道很多，除了上面提到的产品使用分析，还有用户的账单和账户信息、产品数据等。新的数据分析工具的功能越来越强。想知道同时使用几项服务的用户性别比例？想知道特定人物角色的活跃程度和分布情况？新的数据分析工具可以轻松回答这类问题。</p>
<p><strong>拜访用户</strong></p>
<p>没有一种方法可以替代前往用户使用产品的场所（家、办公室）实地考察的作用。虽然拜访用户成本高、耗时长，但我每次都能收集到从其他途径无法了解的信息。拜访用户很有效，但出于对资金和时间成本的考虑，建议谨慎使用。</p>
<p><strong>人物角色</strong></p>
<p>我喜欢在定义和设计产品的过程中使用人物角色。市场调研也可以借助人物角色展开。请记住，你要面对的绝不是单一类型的用户，务必找出若干主要用户类型，深入了解他们，弄清哪些是当前的用户，哪些是潜在的用户。具体内容请参考第17章。</p>
<p><strong>可用性测试</strong></p>
<p>我主张尽早、反复地进行可用性测试（请参考第22章）。观察用户使用现有产品的反应，收集反馈意见，了解他们的真实想法。从用户的视角重新审视产品，不光阅读反馈信息，更要观察、记录用户的行为和反应（比如兴奋、沮丧）。现在还有工具带有远程功能，可以在异地进行可用性测试，记录、分析用户行为。</p>
<p><strong>同类产品分析</strong></p>
<p>产品团队常常低估了竞争对手。就我的经验而言，每款产品都有做得好的地方。有必要找出竞争对手的优势，学习对手的成功经验。</p>
<p>合理地利用市场调研工具和方法可以回答以下几个关键问题。</p>
<ol>
<li>谁是目标用户？</li>
<li>用户会怎样使用产品？</li>
<li>用户能想明白怎样使用产品吗？障碍在哪里？</li>
<li>用户为什么选用你的产品？</li>
<li>用户喜欢产品的哪些特点？</li>
<li>用户希望如何改进产品，增加哪些功能</li>
</ol>
<p>探索（定义）产品的过程则要回答如下问题。</p>
<ol>
<li>采用什么技术来更好地解决产品要解决的问题？</li>
<li>设计什么样的用户体验？</li>
</ol>
<h2 id="u4EA7_u54C1_u4EBA_u7269_u89D2_u8272"><a href="#u4EA7_u54C1_u4EBA_u7269_u89D2_u8272" class="headerlink" title="产品人物角色"></a>产品人物角色</h2><p>作为产品管理的工具，人物角色的主要用途如下。</p>
<ol>
<li>人物角色可以用来筛选重要的产品功能。假设目标用户是“玛丽”，就该添加对“玛丽”重要的功能；如果某项功能只是针对“山姆”的，就该被淘汰。人物角色既有助于决定谁是目标用户，也有助于决定谁不是目标用户，两者同样重要。面面倶到的产品往往一无是处，使用人物角色可以避免犯这种错误。</li>
<li>产品团队常常把自己的需求当成用户需求，我在别处讨论过这个问题，使用人物角色可以避免犯这类的错误。</li>
<li>许多产品的用户类型不止一种。如果只是简单地针对每种用户添加功能，结果会是一团乱麻。这主要是设计上的问题，使用人物角色有助于对用户类型的优先级进行排序，识别需要重点考虑用户体验的地方。</li>
<li>有了人物角色，可以方便地向团队描述产品的目标用户是谁，他们怎样使用产品，他们关心产品的哪些方面。</li>
<li>和产品原则一样，人物角色可以帮助团队成员达成共识。产品发布之前有数以千计的细节问题要解决，产品经理和设计师不可能事必躬亲。如果产品经理、设计师、文案创作人员、开发人员、测试人员在产品原则和人物角色上达成共识，解决问题的效率会更高。</li>
</ol>
<h2 id="u91CD_u65B0_u5B9A_u4E49_u4EA7_u54C1_u8BF4_u660E_u6587_u6863"><a href="#u91CD_u65B0_u5B9A_u4E49_u4EA7_u54C1_u8BF4_u660E_u6587_u6863" class="headerlink" title="重新定义产品说明文档"></a>重新定义产品说明文档</h2><p>我认为理想的产品说明文档应该满足以下要求。</p>
<ol>
<li>产品说明文档应该完整地描述用户体验——不只是用户需求，还包括交互设计和视觉设计。希望大家已经明白用户需求和用户体验是密不可分的。</li>
<li>产品说明文档必须准确地描述软件的行为。文字和图片的表达能力实在有限，不足以完成这项任务。</li>
<li>产品说明文档的受众较广——开发人员、测试人员、客服人员、市场营销人员、运维人员、销售人员、管理层等等。因此，产品说明文档必须以某种直观的方式把产品信息和产品行为告诉所有人。</li>
<li>产品说明文档应该可以修改。虽然进入开发阶段后，应该尽量避免修改产品说明文档，但总有意想不到的问题出现，需要修改产品说明文档以适应新情况。</li>
<li>撰写产品说明文档的过程中会出现许多衍生物，比如，按优先级排列的需求列表、线框图、实体模型，但应该有一个主体来代表产品，避免混淆不清，版本错乱。在我看来，只有一种形式的产品说明文档可以满足以上所有要求，那就是高保真产品原型。</li>
</ol>
<h2 id="u7528_u6237_u4F53_u9A8C_u8BBE_u8BA1_u4E0E_u5B9E_u73B0"><a href="#u7528_u6237_u4F53_u9A8C_u8BBE_u8BA1_u4E0E_u5B9E_u73B0" class="headerlink" title="用户体验设计与实现"></a>用户体验设计与实现</h2><p>许多团队把用户体验设计和软件开发放在一起进行，这是行不通的。原因如下。</p>
<ol>
<li>与软件开发团队合作的人要记住一点：一旦产品进入开发阶段，再修改设计思路是非常困难的，而且越往后修改的成本越高。因为开发团队必须根据确定的用户需求和产品定义设计软件架构，然后进行开发。前期架构决策极大地制约着后期的开发工作，事后修改软件架构，无异于推翻重来。另外，从心理上说，事后修改设计会打击开发人员的斗志，引发消极的心态。随着时间一分一秒过去，返工和波动会增加团队的压力。尽管敏捷方法提倡不断修改和完善，但并非所有的修改都受欢迎。</li>
<li>用户体验设计要保证产品同时具备可用性和价值，任务很重。为了拿出既可用又具有价值的设计，必须尽早、反复地验证设计思路。有些人觉得可以等到每个迭代周期结束再观察设计思路是否合适，甚至等到产品公开测试时再收集用户反馈，这样低效的验证方法肯定是行不通的。优秀的用户体验设<br>计师一两天内要尝试几十个点子，哪怕只是2～4周的迭代周期都会慢得让人无法忍受。</li>
<li>我认为验证设计思路必须使用高保真原型。有人说，迭代结果和公开测试的产品可以当做原型。抛开要等很长时间不谈，这些开发中的产品与产品原型有很大的区别，不能混用。为了验证各种设计思路，产品原型应该可以随意修改，完成其任务后应该被丢弃。而开发中的产品应该以固定的原型为基础。</li>
<li>尽管产品开发可以分成多次迭代（这样做可以降低风险，提高质量，便于产品集成），用户体验设计却不能拆分。设计师必须全面地、连贯地看待用户体验，考虑以往用户的使用习惯。让用户放弃不可用的软件很容易，要他们放弃使用习惯却很难。</li>
<li>用户体验设计不一定是最费时间的工作（像软件开发一样，所需时间取决于具体的方法、特定的产品需求，以及从业者的技能和经验），但至少需要一两周时间。</li>
</ol>
<p>只有在开发人员要开发大量后台基础软件的情况下，用户体验设计和软件开发才能并行展开。在这种情况下，开发团队可以利用设计师设计产品的时间完成这部分工作。虽然双方的工作会有一些依赖关系，但可以解决。多给设计师一些时间定义详细的待开发任务。</p>
<h2 id="u57FA_u672C_u4EA7_u54C1"><a href="#u57FA_u672C_u4EA7_u54C1" class="headerlink" title="基本产品"></a>基本产品</h2><p>我号召产品团队放弃老式的产品设计方式。比如，不再试图定义最终产品，转而定义只满足基本要求（价值、可用性、可行性）的产品，简称基本产品。一旦基本产品定义完成，通过了用户测试，它就是一个不可分割的整体，去掉任何元素，都不可能获得预期的效果。</p>
<h2 id="u4EA7_u54C1_u9A8C_u8BC1"><a href="#u4EA7_u54C1_u9A8C_u8BC1" class="headerlink" title="产品验证"></a>产品验证</h2><p><strong>可行性测试</strong></p>
<p>首先要明确在现有的技术条件下，能否成功开发出产品。邀请架构师和开发人员深度参与技术调研，寻找可行的方案。有些方案通向死胡同，但总有些是可行的。重点是让开发人员寻找产品设计里那些难以克服的障碍，现在发现远比损失了时间和资金后发现来得好。有些产品的技术风险较大，如果你的产品存在可行性风险，一定要提前解决这些问题。</p>
<p><strong>可用性测试</strong></p>
<p>交互设计师应该与产品经理密切合作，想方设法突出产品的功能特性，让不同类型的用户都能明白如何使用。可用性测试往往能发现没能成功实现的产品需求，如果测试得当的话，甚至能发现原本被忽略的产品需求。最好规划多次迭代测试，确保实现最佳的用户体验效果。一定要请真实的用户来试用可用性原型，从目标用户那里可以得到宝贵的反馈信息。虽然产品经理和设计师也能从设计和使用原型的过程中掌握大量信息，但这些都不能代替让真实用户体验原型的作用。</p>
<p>请注意，为了测试可用性，即使要模拟复杂的后台处理过程也是值得的，关键是要评估用户体验的实际效果。</p>
<p><strong>价值测试</strong></p>
<p>最后，仅仅知道产品能够开发出来、方便使用，这还不够。同样要紧的是知道用户是否觉得你的产品有用，是否愿意购买，有多喜欢产品的设计。价值测试可以和可用性测试同时进行，使用的原型也是一样的。只不过可用性测试重在观察用户如何设法完成必要的操作，而价值测试重在观察用户是否喜欢这些功能，是否满意功能的具体实现方式。</p>
<p>简单的产品也许在纸上画画原型就够了，但对于大多数采用复杂用户界面、运用新技术的产品来说，必须借助产品原型评估设计是否符合要求。不同的产品有不同的原型，比如，常见的原型是可点击的页面，当然，原型也可能是物理设备，或是软件与硬件的结合。无论哪种形式的原型都必须足够真实（高保真），可以提供给目标用户测试，并获取有效的用户反馈信息。</p>
<p>使用原型并非验证产品（尤其是互联网服务）的唯一方式，还有其他简单有效的方法，但它们都强调在正式开发软件前验证产品设计，因为设计总有考虑不周、出人意料的情况。越早发现问题越好，不要等到产品公开测试，甚至正式发布才醒悟。一旦进入开发阶段，修改产品设计的难度和成本会越来越高。</p>
<h2 id="u6539_u8FDB_u73B0_u6709_u4EA7_u54C1"><a href="#u6539_u8FDB_u73B0_u6709_u4EA7_u54C1" class="headerlink" title="改进现有产品"></a>改进现有产品</h2><p>产品经理应该时刻关注这些指标，与交互设计师、用户研究人员、主程序员密切合作，分析改善产品的可能性。想要进一步了解产品情况，还可以进行网站分析，请用户测试产品，向客服人员、销售人员了解情况，做盈亏分析，估算净推荐值。在互联网服务领域，可以获得几乎实时的数据反馈。通过分析这些数据改进产品，往往能收到事半功倍的效果。</p>
<p>记住，改进产品不是简单地满足个别用户的要求，也不能对用户调查的结果照单全收。能提高指标的功能才是你关注的重点。你应该找准方向，分析关键指标，有针对性地改进产品。</p>
<h2 id="u5E73_u6ED1_u90E8_u7F72"><a href="#u5E73_u6ED1_u90E8_u7F72" class="headerlink" title="平滑部署"></a>平滑部署</h2><p>毫无征兆地更新不必要的版本会令用户产生反感。有件事你可能觉得难以置信，但的确是事实：不是所有用户都喜欢新版本的产品。用户产生反感主要有以下几个原因。</p>
<ol>
<li>事前没有收到更新通知，用户觉得措手不及。</li>
<li>用户没时间学习、适应新版本，产品公司也没有提供旧版本方便用户在过渡阶段使用。</li>
<li>新版本无法正常运行。</li>
<li>新旧版本不兼容（比如新版本无法访问旧版本的数据）。</li>
<li>虽然新版本可以正常运行，但用户认为添加的功能和特性毫无必要。</li>
<li>应付接二连三的版本更新，用户感到疲惫不堪。</li>
<li>新版本修改了用户已经习惯的使用方式和操作流程，用户不得不重新调整适应。通常情况下，用户不喜欢变化。虽然他们也希望产品更完善，功能更丰富，但前提是不改变已有的使用习惯，大多数人不愿意花时间学习、适应新的使用方式。</li>
</ol>
<p>为了将版本更新带来的负面影响降到最低，可以采取以下几种措施。</p>
<ol>
<li>通过公告、群发邮件、在线教程等方式提前通知用户，但是很多人既没时间也没兴趣阅读这些内容，所以这个方法效果有限。</li>
<li>加倍做好测试工作，避免新版本存在影响正常使用的隐患，比如可靠性问题、扩展性问题、性能问题。确保将来不会陷入被迫返回旧版本的窘境，为用户增加不必要的麻烦。</li>
<li>如果更新版本会影响大规模的用户，应该采取并行部署或者增量部署的方式来降低风险。平滑部署的方式很多，比如发布两个并行的版本，邀请有兴趣、有时间的用户试用新版本。如果新版本运行正常，大部分用户习惯新版本后，再将新版本设为默认版本。同时将旧版本保留一段时间，公示为旧版本提供支持的最后期限，以便没来得及习惯新版本的用户在这段时间内能照常使用产品。</li>
</ol>
<p>对于用户数量庞大的服务和产品，这个过渡可能需要几个月的时间。产品经理还要准备好承担来自开发团队和运维团队的压力，毕竟支持并行版本不是件容易的事。另一种平滑部署的方式是区域性逐步部署，首先在某个区域内部署新版本，然后逐步扩大范围。还有一种方式是增量部署，将更新项分割成几个较小的部分逐步发布。无论采用哪种处理方式，关键要全面考虑更新可能带来的“副作用”，为用户提供便利，方便他们在空闲时适应变化，同时尽可能降低新版本带来的负面影响。</p>
<h2 id="u5FEB_u901F_u54CD_u5E94_u9636_u6BB5"><a href="#u5FEB_u901F_u54CD_u5E94_u9636_u6BB5" class="headerlink" title="快速响应阶段"></a>快速响应阶段</h2><p>我反复强调发布产品不等于大获全胜，交付产品后依然需要保持高度警惕。本章详细介绍产品交付后的收尾工作。产品发布后，多数公司会迅速撤走为研发产品和发布产品整合的资源，急于投入下一个项目，殊不知此时正是收集反馈信息、改进产品的最佳时机。急于“撤军”是项目管理和产品开发流程中的大忌，只要稍微延长项目周期，观察用户对产品的反应，效果就会有天壤之别。这样做投资之小、回报之高会令你瞠目结舌，绝非其他项目阶段可比。</p>
<p>我向来坚持产品发布后的几天至一周内，所有项目成员应该留出时间作为快速响应阶段。这个阶段的主要工作是快速响应、处理产品发布后的用户反馈意见。快速响应阶段最早是针对大众网络服务的，因为大众网络服务特别重视用户的反馈意见。我相信它同样适用于平台产品、基础设施类产品、企业级产品。</p>
<h2 id="u5408_u7406_u8FD0_u7528_u654F_u6377_u65B9_u6CD5"><a href="#u5408_u7406_u8FD0_u7528_u654F_u6377_u65B9_u6CD5" class="headerlink" title="合理运用敏捷方法"></a>合理运用敏捷方法</h2><p>注意这些诀窍只适用于产品软件团队，不适用于定制软件团队。</p>
<ol>
<li>产品经理即是产品负责人（product owner），他代表了客户的需求，因而需要与产品开发团队保持密切的联系，协助督促开发进程，及时解决出现的问题。有些产品经理以为敏捷方法可以让工作变得轻松，这是大错特错的。如果产品经理和产品负责人不是由一个人担任，通常会埋下隐患（参见第2章）。</li>
<li>使用敏捷方法绝不等于省略产品规划。产品经理仍然要明白产品的方向和目标，设定衡量产品成功与否的标准。只不过在敏捷环境里，规划周期应该适度缩短，反复迭代，采用轻量级的机会评估方法替代冗长的市场需求文档（参见第11章）。</li>
<li>产品经理和设计师的工作进度应该比开发团队领先一两个迭代周期，确保你们有足够的时间攻克难题。让交互设计师和视觉设计师提前设计产品，充分发挥他们主导设计的作用，不能一边设计一边开发（参见第19章）。另外，始终让开发人员参与评估产品设计和产品原型，及时反馈关于可行性、成本、解决方案的建议。</li>
<li>尽量把产品设计工作拆分成独立的部分，分而治之，但也不能拆得太细——好比设计建筑不能一次只设计一个房间。目标是设计出符合基本要求的产品（参见第20章）。值得注意的是，在敏捷环境里，设计师必须加快工作速度，采用迅速制作原型的方法更能适应敏捷环境。</li>
<li>产品经理的主要任务是定义有价值、可用的产品原型和用户故事（user story），作为开发的基础。用产品原型和用户故事替代厚厚的产品需求文档和功能说明文档有三个优势：①可以请用户测试；②强迫产品经理全面认真地思考问题；③向开发团队明确地描述每次迭代周期需要完成的任务。请用户测试原型，根据反馈意见反复迭代修改原型设计，确保交给开发团队的是有价值的结果，避免任何浪费，哪怕只是一个迭代周期。</li>
<li>让开发人员自主划分迭代周期。有的产品功能可以在一个迭代周期完成，有的却需要好几次迭代才能完成。好的原型可以提高估算工作量和开发时间的精度。别忘了，开发团队必须考虑产品的质量、性能、扩展性，应该让他们自行决定如何划分迭代周期。</li>
<li>产品经理和交互设计师必须出席每天的晨会。晨会是一天沟通过程的开始，而不是结束，关于产品的讨论会持续一整天。设计师向开发人员和测试人员展示产品功能；开发人员互相展示完成的代码，让测试人员测试，请设计师和产品经理过目；测试人员和开发人员在制作原型的阶段识别潜在的问题，协助产品经理制定更合理的决策，解决产品设计、开发的问题。</li>
<li>除非达到了产品经理的要求，否则不要轻易发布新版本。产品经理必须确保交给用户的产品能正常运行。过度频繁更新版本会让用户感到不安（参见第24章）。</li>
<li>在每次迭代完成后，产品经理应该向团队展示产品现状，以及下次迭代的产品原型，让大家看到工作成果，同时加深大家对产品的理解，增强团队对这种开发方式的信心。</li>
<li>在团队内展开敏捷培训。聘请敏捷顾问协助你们完成向敏捷团队转型的目标，但是要确保敏捷顾问有过类似的工作经验，理解产品软件与定制软件的差别。只有每位团队成员都真正理解敏捷方法，你才能把工作重心放在执行上，否则敏捷方法就只能停留在教条式的理论层面。</li>
</ol>
<h2 id="u5408_u7406_u8FD0_u7528_u7011_u5E03_u5F0F_u5F00_u53D1_u65B9_u6CD5"><a href="#u5408_u7406_u8FD0_u7528_u7011_u5E03_u5F0F_u5F00_u53D1_u65B9_u6CD5" class="headerlink" title="合理运用瀑布式开发方法"></a>合理运用瀑布式开发方法</h2><p>瀑布式开发方法的基本原则</p>
<p>传统瀑布式开发方法的理念很简单，主要有两点。</p>
<ol>
<li>采用阶段式开发 软件开发过程被事先分成固定的几个阶段：撰写书面的需求说明文档、设计高层软件架构、设计低层细节、编写代码、测试、部署。</li>
<li>采用阶段式评审 每个阶段结束后，对该阶段提交的成果进行评审，评审通过后才能进入下一阶段。</li>
</ol>
<h2 id="u5927_u516C_u53F8_u5982_u4F55_u521B_u65B0"><a href="#u5927_u516C_u53F8_u5982_u4F55_u521B_u65B0" class="headerlink" title="大公司如何创新"></a>大公司如何创新</h2><p>臭鼬工程是工程界的行话，原指秘密军事行动，现指在受限制的条件下，利用自己的时间，低调地进行创新研究。臭鼬工程拯救了很多大公司。在大公司里，普通员工很难凭空获得允许从事创新研究。如果你能拿出阶段性的成果来，获得许可会容易得多。在这种情况下，只要不耽误本职工作，管理层通常会支持你的做法。</p>
<p>有一点要提醒大家，有些公司规定员工在职期间研究出来的成果都归公司所有，所以不要随意拿研究成果自行创业。如果公司因为某些原因不愿意帮助你，你才能尝试谋求其他途径来实现自己的创意。了解硅谷历史的人知道，当年斯蒂夫·沃兹尼亚克（Steve Wozniak）因为惠普公司不愿意进入个人电脑市场，所以离职创业，才有了后来的苹果公司。</p>
<h2 id="u5728_u5927_u516C_u53F8_u65BD_u5C55_u62F3_u811A"><a href="#u5728_u5927_u516C_u53F8_u65BD_u5C55_u62F3_u811A" class="headerlink" title="在大公司施展拳脚"></a>在大公司施展拳脚</h2><p>理解这两点后，我再介绍在大公司施展拳脚的方法。</p>
<ol>
<li>了解公司制定决策的方式 每家公司的企业文化都不相同，制定决策的方式也千差万别。如果公司制定决策的方式不符合你的习惯，不要老想着改变大家来适应自己，要学着融入其中。有些公司虽然有明确的民主决策制度，但最终决策还是要请某位大人物拍板。你千万不要纠缠大家有没有没按照制度办事，与其抱怨，不如主动利用这一点。知道决策权在谁手里，你的工作目标就更明确了。了解他制定决策的方式，他是更看重原型演示、市场数据，还是客户的承诺和评价。如果你需要公司的支持，只需要说服他就行了。</li>
<li>建立人脉网络 在大公司工作必须与人合作，如果你喜欢单枪匹马工作，创业型公司更适合你。你需要同事的协助才能完成设计、开发、发布工作。主动与各个部门的同事结交朋友，聊聊工作的事，向大家介绍你手头的项目，不要等到有事才去找人家。主动帮助他人，积累人脉关系。</li>
<li>臭鼬工程 在大公司里，凭空申请创新资源很困难（参见第29章）。想靠几张画着产品构想的幻灯片说服老板是不切实际的。更可行的方法是找三五个志趣相投的同事在工作之余做出产品原型来。产品原型具有超出想象的说服效果。比起枯燥的陈述，生动形象的演示更有吸引力。数不清的优秀产品是这样诞生的。</li>
<li>自己顶上 说出来你也许不信，大公司里虽然员工众多，但真正需要帮手的时候，却总找不到人。即使是公司高管重视的项目，也难免资源不齐。遇到这种情况，你就得自己想办法了，比如，打电话找人帮忙，甚至自己顶上。在凡事都需要提交材料，有严格流程要求的大公司，与其对抗流程，不如自己主动填写、提交需要的材料。很多时候产品经理还要协助编写技术文档，组织销售培训，提供客户服务。一切为了推出产品，不要计较个人得失。</li>
<li>有选择地据理力争 在大公司工作，多一个敌人不如多一个朋友。如果你不满意同事的工作，或者与他人意见不同，不要随便发脾气，除非这件事对你确实重要，值得你据理力争，撕破脸也在所不惜。与人辩论，要小心措辞，做到对事不对人，不要把对方逼到死角。你的目标是完成产品，别为了一场战役输掉整场战争。</li>
<li>会前沟通，形成默契 在重要的决策会议上，如果有人公开反对你的提议，你会变得非常被动。在这种公开场合下发表的意见，反对者很难改口，你想再挽回就很难了。与其临渴掘井，不如未雨绸缪，设法在会前达成一致意见。会议的主要作用是让与会者认识到大家取得了一致意见。所以会前应该逐一找与会者聊聊，了解每个人的立场，如果有不同的意见，对症下药及时化解，确保他们会投赞成票。</li>
<li>合理分配时间 大公司频繁开会，有些人每天忙于参加大大小小的会议，深夜回家还要回复邮件，忙得不可开交，产品却毫无起色。产品经理应该重新检查会议日程，划掉无关紧要的会议；学会充分信任同事，让他们自己拿主意。产品经理应该留下时间完成自己的本职工作：制定产品战略，构思产品路线图，研究产品原型，分析竞争对手。</li>
<li>分享信息 不管在哪种组织里，沟通都是难题，大公司尤其如此——信息俨然变成了某种货币，大家只想获取，不愿支出。许多人把它看成私有财产，藏起来不愿与人分享。其实有舍才有得，分享信息会让你获得更多的朋友和资源，作为交换，别人也会毫无保留地分享信息给你。充分共享信息对你自己和公司都有好处，这叫共赢。</li>
<li>向上司借力 学会利用上司的关系，可以更好地开展工作。如果你的上司在公司里威望很高，你应该学会向他借力，利用他的人脉关系，传播你的理念，多向他请教，了解公司文化和组织结构。如果需要上司出面说服公司高管，你一定要事前做好充分的准备，为他提供翔实可靠的资料和信息，用实力取得他的信任，让他放心地当你的说客。</li>
<li>传播你的产品理念 多向同事传播你的产品理念，向大家描绘产品愿景，介绍产品策略，演示产品原型，分享用户反馈信息。不要低估了内部宣传潜移黙化的作用。让大家（包括没有直接业务联系的部门同事）不遗余力地支持你。</li>
</ol>
<h2 id="u82F9_u679C_u516C_u53F8_u7ED9_u6211_u7684_u542F_u793A"><a href="#u82F9_u679C_u516C_u53F8_u7ED9_u6211_u7684_u542F_u793A" class="headerlink" title="苹果公司给我的启示"></a>苹果公司给我的启示</h2><ol>
<li>硬件为软件服务 与其他硬件公司不同，苹果公司明白硬件必须为软件服务，这种关系不能颠倒。软件直接服务用户，满足用户需求。采用多点触控显示屏、重力加速器、距离传感器这些硬件技术是为了配合软件满足用户需求，而不是花哨的噱头。苹果公司明白，仅凭华丽的硬件技术和软件效果无法真正吸引用户，一旦消费者过了尝鲜的阶段，就会对产品失去兴趣。要抓住消费者的心，需要更深层的东西。</li>
<li>软件为用户体验服务 所有公司都把用户体验挂在嘴边，只有苹果公司把它放在心里。苹果公司的所有工作都围绕着产品的可用性、交互设计、视觉设计、工业设计展开。研发一款iPhone手机要两年半时间，设计用户体验几乎占了大部分时间。设计团队明白用户体验的重要性，即使阻力重重，也不轻言放弃。公司各个部门不遗余力地支持用户体验设计。相比之下，微软就差得远了，改善Vista用户体验的工作不但效果差，而且进展缓慢。苹果公司明白用户体验是产品立足之本。</li>
<li>用户体验为情感服务 如果非要举出苹果公司成功的秘诀，我相信是这一点：他们比谁都清楚是什么让消费者为产品疯狂，他们知道怎样抓住用户的情感需求。人人都想拥有一台iPhone手机，哪怕是四百美元的天价也心甘情愿！没人把iPhone和RAZR、Treo做比较，它们完全不是一个“重量级”的。我在机场候机时，常常暗中比较人们对待苹果电脑和其他品牌电脑的态度——前者像是宝马，后者像是租来的二手车。如果你胆敢从街头少年手里抢他的iPod，那一定是吃了熊心豹子胆。</li>
<li>产品为真正的需求服务 手机并非苹果公司首创，但他们挖掘出尚未被满足的用户需求。市面上的手机品种成百上千，却没几款让人爱不释手。十几年不变的语音邮件系统、不兼容的地址簿、蹩脚的网页浏览器和电子邮箱，只会让用户抓狂。苹果公司逐一完善这些功能，成功的产品应运而生。在数码音乐播放器领域，他们做得一样出色。很少公司像苹果公司那样理解和运用以上四点。竞相模仿其产品的大有人在，这些公司不过是在照猫画虎，形似神非。</li>
</ol>
<h2 id="u65B0_u74F6_u88C5_u8001_u9152"><a href="#u65B0_u74F6_u88C5_u8001_u9152" class="headerlink" title="新瓶装老酒"></a>新瓶装老酒</h2><p>成功的产品往往不是什么新鲜事物，只是新瓶装老酒，之所以成功，是因为这个“新瓶”做得更好、更方便、更便宜，改变了消费者对“老酒”的印象。</p>
<p>想在成熟的市场抢占一席之地，精明的公司至少要手握两件“法宝”。</p>
<p>第一，对目标市场了如指掌，对现有产品的缺陷洞若观火。我喜欢通过产品可用性测试掌握产品情况（包括自己的产品和竞争对手的产品）。</p>
<p>第二，跟踪最新的技术趋势。新技术层出不穷，让之前无法实现的方案变得可能。虽然谁都没有把握永远走在技术的前列，把最新的技术融入产品设计中，但是只要做到一次，你的产品将所向披靡。</p>
<h2 id="u6050_u60E7_u3001_u8D2A_u5A6A_u3001_u6B32_u671B"><a href="#u6050_u60E7_u3001_u8D2A_u5A6A_u3001_u6B32_u671B" class="headerlink" title="恐惧、贪婪、欲望"></a>恐惧、贪婪、欲望</h2><p>多数软件产品行业的从业者都是理工科或经济学背景，我们每天的工作却和研究人类情感的心理学有关。虽然很少有人意识到这一点，但事实如此。消费者购买产品大多源于情感需求。优秀的产品经理和销售人员明白其中的道理，懂得产品应该满足用户的情感需求。</p>
<p>企业级消费者出于恐惧和贪婪购买产品：如果不买这款产品，竞争对手会超过我，黑客会攻破我的防火墙、客户将弃我而去；如果买了，我会赚得更多、省得更多</p>
<h2 id="u60C5_u611F_u63A5_u7EB3_u66F2_u7EBF"><a href="#u60C5_u611F_u63A5_u7EB3_u66F2_u7EBF" class="headerlink" title="情感接纳曲线"></a>情感接纳曲线</h2><p>杰弗里·摩尔（Geoffrey Moore）在他的作品《跨越鸿沟》中提出了一个颇具影响力的概念——技术接纳曲线，这条曲线涉及了技术创新者、尝鲜者、早期消费大众、后期消费大众和跟随者。这本书尝试解释为什么很少有产品能越过鸿沟——获得尝鲜者以外消费者的青睐。</p>
<p>不要一味从技术角度看待产品，多从用户的角度考虑问题。是什么问题让他们头痛？是什么让他们垂头丧气、愁眉苦脸？比如，如今大家都讨厌旅行——旅行的过程变得毫无乐趣可言；又比如，人人都讨厌电话公司——复杂的话费清单几乎没人能看懂。电话公司仿佛存心为难消费者，每个月月底大家都得提高警惕，免得被忽悠。</p>
<h2 id="u5927_u4F17_u7F51_u7EDC_u670D_u52A1_u4EA7_u54C1"><a href="#u5927_u4F17_u7F51_u7EDC_u670D_u52A1_u4EA7_u54C1" class="headerlink" title="大众网络服务产品"></a>大众网络服务产品</h2><ol>
<li>可用性 在我看来，多数公司不够重视产品的可用性，尤其是开发企业级软件的公司。大众网络服务产品必须具备良好的用户体验。如果用户不清楚怎样使用产品，也不知道产品的优势何在，你就等着关门歇业吧。另外，别忘了产品性能是最重要的一条可用性指标，页面加载缓慢让用户无法忍受，也是糟糕的用户体验。</li>
<li>人物角色 网站用户数量过百万后，产品经理不可能再逐个研究每位用户，只能按典型特征将用户分类，抽象出有代表性的用户类型（人物角色），加以分析。产品每增加一项新功能，都要请典型用户参与测试，根据反馈信息加以完善（参见第17章）。</li>
<li>扩展性 激增的用户数量会带来莫明其妙的问题：数据库崩溃、系统出现性能瓶颈、用户界面罢工。网站上线前进行压力测试虽然可以发现部分问题，但正式使用时总有意想不到的情况出现。实现扩展性需要产品经理、设计人员、开发人员、运维人员的通力协作，最好利用部分开发资源和运维资源（我建议分配20%的资源）专门为系统扩展做好准备。不要到系统承受不了压力，即将崩溃才追悔莫及。从设计系统的第一天开始，就应该不间断地考虑扩展性问题，永远留有余地，不到万不得已不要满负载运行（参见第5章）。</li>
<li>持续可用性 大众网络服务要求一刻也不能停歇，但迄今为止我还没见过哪家网站能做到24×7小时无故障运行。系统中止服务是件痛苦的事，对那些负责解决系统故障的人来说更是如此，不是所有人都适合干这一行。系统出故障的时间没个准，工作日、节假日、周末、深夜，随时可能发生，从业者的压力相当大。在系统设计上保证持续可用性与规划扩展性一样重要。</li>
<li>客户服务 另一件让大众网络服务公司头痛的事是客户服务。传统的客户服务完全无法应付数量庞大的网络用户，收费的网络服务情况更严重。要想降低客服压力，除了尽量减少系统故障和缺陷外别无他法。在这个问题上，节省开支只是一方面，更重要的是维持良好的用户体验。</li>
<li>保护用户隐私 大众网络服务公司容易因侵犯或泄露用户隐私被迫停业。虽然你收集用户资料的初衷可能是好的，比如提供个性化用户体验，但如今电子邮件信息、信用卡卡号等用户数据都是敏感资料，一旦不小心泄露出去，后果不堪设想——接踵而来的负面报道、法律制裁，还有用户的满腔怒火。应尽早树立保护用户隐私的意识，设置用户资料保护机制，千万不能辜负用户对你的信任。最近美国在线的案件给我们敲响了警钟，我们需要警惕，提防自己的员工泄露用户资料。</li>
<li>口碑营销 用户如果喜欢产品，就会主动向家人、朋友、同事推荐。这是宣传产品的最佳方式。令我费解的是，很少有公司充分利用这种营销手段。我建议为用户提供便利，方便他们（通过邮件、短信、社交网络等）向熟人推荐产品。许多公司愿意为吸引新用户支付报酬，不妨向踊跃推荐产品的用户发放奖金。当然奖金激励还是次要的，最重要的是让用户易于向家人、朋友、同事、网友推荐产品。</li>
<li>全球化 优秀的互联网产品很快会被其他国家、地区的用户接受，迅速在互联网覆盖的范围内传播开。易于本地化的产品设计可以大大节省开发成本和开发时间，避免为了语言、货币、文化差异大量改写程序。这样随着产品业务的拓展，你可以迅速适应当地用户的需求。</li>
<li>平滑部署 网站用户数量过百万后，任何小小的变化都会影响大面积的用户，要三思而行。我详细讲述过平滑部署的要点（参见第24章），请大家务必谨慎小心。部署前要仔细测试，逐步过渡，步幅不可过大，为用户留出足够的时间来适应变化。有些公司让新老版本同时运行一段时间，让用户适应过渡，这是个好办法。最后，尽量减少不必要的更新，用户消化、吸收新事物不是件容易的事。</li>
<li>用户社区管理 所有的商业公司都依靠用户生存，这一点对大众网络服务公司来说显得尤为突出，水能载舟亦能覆舟。如果用户认可你的产品，他们会很乐意成为用户社区的一员，同时希望得到重视和认可。与用户交流的方法有很多，多和他们接触，了解他们希望如何改进产品。多用类似于“回馈用户”的活动表达对他们的重视。让公司上下认识到用户的重要性，真正从行动上把用户当做“上帝”。</li>
</ol>
<h2 id="u6253_u9020_u5E73_u53F0_u4EA7_u54C1_u7684_u7ECF_u9A8C"><a href="#u6253_u9020_u5E73_u53F0_u4EA7_u54C1_u7684_u7ECF_u9A8C" class="headerlink" title="打造平台产品的经验"></a>打造平台产品的经验</h2><p>产品管理中难度最大，也最能体现产品经理实力的是定义成功的平台产品。所谓平台产品，是指一类基础软件，应用开发者能在其基础上开发应用程序。平台有很多种，例如，操作系统（如Window操作系统、Mac操作系统、Palm智能手机操作系统）、运行环境（如Java、Flash）、web服务（如亚马逊和eBay的集成应用程序接口）、游戏开发平台（如XNA），以及应用平台（如Facebook和Salesforce.com）。</p>
<h2 id="u6700_u4F73_u5B9E_u8DF5_u7ECF_u9A8C"><a href="#u6700_u4F73_u5B9E_u8DF5_u7ECF_u9A8C" class="headerlink" title="最佳实践经验"></a>最佳实践经验</h2><p>从业二十多年来，我一直在总结打造富有创意产品的方法。这里分享我认为最重要的十个要点。每个要点在书中都有详细描述，希望这里的汇总能加深读者的印象，建议大家结合实际工作来体会。</p>
<ol>
<li>产品管理的职责 许多产品经理将大把的时间浪费在与产品管理无关的工作上，比如，营销管理和项目管理，这些都不是产品经理应该干的活。</li>
<li>用户体验 对于大多数软件产品来说，用户体验就是产品的生命。产品经理应该与交互设计师、开发人员密切合作，设计良好的用户体验，打造有实用价值的产品。</li>
<li>机会评估 用方便快捷的机会评估方法取代过时的市场需求文档。动手设计产品前，先明确产品要解决什么问题，为谁解决问题，以及评估产品的标准。</li>
<li>特约用户 有些产品团队企图绕过用户，直接设计、开发产品，这种想法可笑至极。打造优秀的产品没有任何捷径，只能请用户反复试用产品，不断改进。</li>
<li>产品原则 产品管理工作的主要内容是制定决策。明确的产品原则可以帮助产品经理和产品团队树立清晰的价值标准，作出果断的决策。</li>
<li>人物角色 人物角色是协助产品经理制定决策的另一项工具。把目标用户按特征分类，逐一分析、理解其情感和行为，以此作为决策的依据。</li>
<li>探索（定义）产品 产品经理的主要职责是探索（定义）有价值的、可用的、可行的产品。除非产品经理确定这三点，否则同事的努力都将付之东流。</li>
<li>使用原型 使用高保真原型是探索（定义）产品的关键步骤。原因如下：第一，迫使产品经理深入定义解决方案；第二，可以让真实的用户参与测试、验证产品创意；第三，可以直观地向团队展示产品的设计思路。</li>
<li>用户参与原型测试 有了产品原型，产品经理可以方便地请用户验证产品创意。原型测试是所有产品经理和产品设计师都必须掌握的工作技能。获取有效的用户反馈是产品经理最重要的工作。</li>
<li>根据数据改进产品 成功的产品经理懂得利用数据来改进现有产品。改进产品不是根据客户要求一味增加新功能，而是根据产品的实际应用情况，不断地提升产品的各项指标，逐步完善产品。</li>
</ol>
<h2 id="u4EA7_u54C1_u7ECF_u7406_u7684_u53CD_u7701_u6E05_u5355"><a href="#u4EA7_u54C1_u7ECF_u7406_u7684_u53CD_u7701_u6E05_u5355" class="headerlink" title="产品经理的反省清单"></a>产品经理的反省清单</h2><p>出色的产品经理会时刻关注产品的现状与未来。以下是产品经理无时无刻不在思考的问题。</p>
<ol>
<li>产品能吸引目标消费者的关注吗？</li>
<li>产品的设计是否人性化，是否易于操作？</li>
<li>产品能在竞争中取胜吗？即使是面对未来风云变化的市场，依旧有取胜的把握吗？</li>
<li>我了解目标用户吗？产品（不是理想的产品，而是实际开发出来的产品）是否能得到他们的认可？</li>
<li>产品是否有别于市面上的其他产品？我能在两分钟内向公司高管清楚地阐明这些差别吗？能在一分钟内向客户解释清楚吗？能在半分钟内向经验丰富的行业分析师解释清楚吗？</li>
<li>产品能正常运行吗？</li>
<li>产品是否完整？用户对产品的印象如何？销售业绩如何？销售任务能否顺利完成？</li>
<li>产品的特色是否与目标用户的需求一致？产品特色是否鲜明？</li>
<li>产品值钱吗？值多少钱？为什么值这么多钱？用户会选择更便宜的产品吗？</li>
<li>我了解其他团队成员对产品的看法吗？他们觉得产品好在哪里？他们的看法是否与我的观点一致？为什么每天的思考时间如此重要，为什么产品经理的工作如此费时？原因就在于这十个问题等着他不断地去琢磨。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>这本书基本上说清楚了打造好产品的方方面面，很值得一看。</p>]]>
    
    </summary>
    
      <category term="产品" scheme="http://wdxtub.com/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="方法" scheme="http://wdxtub.com/tags/%E6%96%B9%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【编程珠玑】读书笔记]]></title>
    <link href="http://wdxtub.com/2016/03/26/programming-pearls/"/>
    <id>http://wdxtub.com/2016/03/26/programming-pearls/</id>
    <published>2016-03-26T20:35:57.000Z</published>
    <updated>2016-03-26T20:41:16.000Z</updated>
    <content type="html"><![CDATA[<p>编程珠玑算是比较有年头的一套程序员进阶的书籍，这里是我的读书笔记。</p>
<a id="more"></a>
<hr>
<h2 id="u5F00_u7BC7"><a href="#u5F00_u7BC7" class="headerlink" title="开篇"></a>开篇</h2><p>一开头就拿出了这么一个例子，给10000000个7位整数排序（无重复的整数），但是你可能只有1MB的主存，怎么办又快又好呢？通常的想法是归并，多几次就可以了。但是其实还有更好的方法，就是利用位图的位向量。例如如果集合是{1，2，3，5，8，13}，那么可以存储在下面这个字符串中：</p>
<pre><code>0 1 1 1 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0
</code></pre><p>集合中代表数字的各个位设置为1，而其他的位全部都设置为0。这时候如果要个这10000000个整数排序，就可以分成这三步：1）初始化一个大数组。2）遍历一遍这10000000个数，出现过的就在数组中标注为1。3）最后再遍历一遍这个数组，把出现1的对应位置的数字输出一遍即可。</p>
<p>瞬间什么排序都不用了，而且只需要两次遍历，豁然开朗，柳暗花明之感。从这个例子可以总结出一些值得以后借鉴的经验：</p>
<p><strong>正确的问题</strong>。明确了问题，就更能找到最佳的解答。</p>
<p><strong>位图数据结构</strong>。该数据结构描述了一个有限定义域内的稠密集合，其中的每一个元素最多出现一次并且没有任何其他数据与该元素相关联。即使这些条件没有完全满足(例如，存在重复元素或额外的数据)，也可以用有限定义域内的键作为一个表项更复杂的表格的索引。</p>
<p><strong>多趟算法</strong>。多趟读入其输入数据，每次完成一步。</p>
<p><strong>时间-空间折中与双赢</strong>。只有在原始的设计远非最佳方案时，才有可能时空双赢。</p>
<p><strong>简单的设计</strong>。设计者确定其设计已经达到了完美的标准不是不能再增加任何东西，而是不能再减少任何东西。</p>
<blockquote>
<p>1.如果不缺内存，如何使用一个具有库的语言来实现一种排序算法以表示和排序集合？</p>
</blockquote>
<p>python 的 list 的 sort 方法就挺好，简单粗暴</p>
<pre><code>list = [1,2,3,4,5]
list.sort()
</code></pre><blockquote>
<p>2.如何使用位逻辑运算(与，或，移位)来实现位向量？</p>
</blockquote>
<p>位向量的实现就是用比特位0,1来表示一些特定信息，通常是用数组，每个int中包含32个bits，当我们定位某个位置时，先确定索引是在哪个int中，然后再确定int中的那个位对应索引。</p>
<p>c++中有现成的 bitset，原理应该差不多</p>
<blockquote>
<p>3.实现位图排序并度量运行时间</p>
</blockquote>
<p>位图的实现我用了三种，一个是c语言的（简称cvec），一个是c++的（简称cppvec），还有时c++现成的bitset（简称bitset）。系统排序用的是sort命令，加上-n选项。排序用了c的qsort，c++的sort和c++的set。</p>
<pre><code>cvec  1.737 1.001
cppvec 1.769 1.033
bitset 2.644 1.908
系统sort命令 5.290 4.554
qsort 2.081 1.345
sort 2.802 2.066
set 5.921 5.185
</code></pre><p>输入输出的时间是0.736s。左右分别为带输入输出和不带的。</p>
<p>可以看出两种语言位图的实现都是效率最高的，c++中的bitset，set，sort虽然效率上差了点，但是实现上非常方便，而且能保证一定的正确性。系统的排序实在方便，一句命令就可以搞定(<code>sort -n &lt; in -o out</code>).</p>
<blockquote>
<p>4.如何生成小于 n 且没有重复的 k 个整数？</p>
</blockquote>
<p>如果要想生成这样一个数组，可以直接从头到尾循环，每个数随机位置交换值就可以。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N = 10000000;
const int K = 10000000;
int randint( int l, int r ){
    return rand() % ( r-l ) + l;
}
int a[ N ];
int main(void){
    for( int i = 0; i &lt; N; i++ )
        a[i] = i;
    for( int i = 0; i &lt; K; i++ ){
        swap( a[i], a[ randint(i,N) ] );
        printf(&quot;%d\n&quot;,a[i]);
    }
    return 0;
}
</code></pre><blockquote>
<p>5.如果存储[0,10000000]大概需要1.25MB，但内存限定为1MB，要如何处理呢？</p>
</blockquote>
<p>可以将输入文件分成两分，第一份保存[0,5000000)的数，第二个文件保存[5000000,10000000)的数字，然后分别进行排序，所用内存就可以降到1MB以内。如果我们把文件分成k份（每份都存一定区间的数），那么就可以在n的时间，n/k的空间内完成排序。</p>
<blockquote>
<p>6.如果每个整数不只是出现一次而是最多可能出现十次，那么要如何修改算法呢？</p>
</blockquote>
<p>每个整数最多出现10次，那么保存每个数字信息的空间不再是1bit了，可以用4bits来保存，可以类比第五题，可以分成4份，在n/4的空间内完成。同样，当保存数字信息的量变化时，分成更多份，就可以在更小的空间内完成。</p>
<blockquote>
<p>7.程序还需要进行哪些错误检测，如何处理？</p>
</blockquote>
<p><strong>数出现超过一次</strong>。当第二次更新的时候，相应位已经是1了，这个时候提示错误。</p>
<p><strong>当输入小于0或者大于等于n</strong>。当输入数字时候对其进行范围判断，忽略或者提示错误。</p>
<p><strong>不是数值</strong>。忽略，给出提示</p>
<blockquote>
<p>8.之前的电话数据区号都是800，现在免费电话的区号还包括877和888并且可能还会增多，那么如何排序呢？如何将免费电话存储在一个集合中，要求可以实现非常快速的查找来判定是否已经存在？</p>
</blockquote>
<p>一个想法是把区号作为前缀加入到每个号码后面，然后利用bitmap进行存储，又或者维护另一个区号的映射表，这样可以减少编码的长度。检索的时候就看对应值是不是为1就行。</p>
<blockquote>
<p>!!9.使用更多的空间来换取更少的运行时间存在一个问题：初始化空间本身需要消耗大量的时间。如果数据很稀疏，那么要如何存储？</p>
</blockquote>
<p>初始化空间需要大量时间，不过我们的应用只需要其中一点点空间，比如1000000的位图，我们只用到其中的10位，怎样节省时间？题目中提示，可以用额外的正比于向量大小的空间。</p>
<p>解决方法使用了两个额外的向量，<code>from</code>和<code>to</code>，变量<code>top</code>。如果对i位置进行初始化，进行以下步骤：</p>
<pre><code>from[i] = top;
to[top] = i;
data[i] = 0;
top++;
</code></pre><p><code>from[i]=top</code>的目的是将<code>i</code>在<code>to</code>中的索引放入<code>to</code>中，<code>to[top]=i</code>的意思是，这个<code>top</code>位置对应的是<code>i</code>，这时data就可以做相应的操作，然后top右移。</p>
<p>判断一个位置是否初始化过的条件是<code>from[i] &lt; top &amp;&amp; to[from[i]] == i</code>,<code>from[i]&lt;top</code>的意思是<code>from[i]</code>对应的<code>to</code>中的位置已经被处理过了，但是<code>from[i]</code>可能是随机值，也只能会小于<code>top</code>，那么这时就需要第二个条件了，<code>to[from[i]] == i</code>的意思是，<code>to[from[i]]</code> 所指向的位置就是<code>i</code>，这种双向的指向性的内容确保了能确定<code>i</code>位置是否被初始化过。</p>
<blockquote>
<p>10.如何组织电话号码以允许高效的插入和检索操作？</p>
</blockquote>
<p>类似于取快递，根据电话号码的最后一位或者最后两位进行分类，类似于哈希的思想，用顺序遍历来处理碰撞。不能用开头的原因是很多电话号码的前面都是一样的，比如手机号码都是以1开头的。而且最后一位的分布比较随机、均匀。</p>
<blockquote>
<p>11.汽车每天运送图纸需要一个小时，有什么办法可以减少时间或者费用？</p>
</blockquote>
<p>飞鸽传书，答案也是醉</p>
<blockquote>
<p>12.外太空写字的笔</p>
</blockquote>
<p>铅笔</p>
<blockquote>
<p>深入阅读</p>
</blockquote>
<p>Michael Jackson \<software requirements="" &="" specifications\=""></software></p>
<p>程序员的主要问题与其说是技术问题，还不如说是心理问题。很多时候没有办法解决问题是因为想要解决错误的问题。问题的最终解决，是通过打破概念壁垒，进而去解决一个较简单的问题而实现的。</p>
<p>James L. Adams <conceptual blockbusting=""></conceptual></p>
<h2 id="u554A_u54C8_uFF01_u7B97_u6CD5"><a href="#u554A_u54C8_uFF01_u7B97_u6CD5" class="headerlink" title="啊哈！算法"></a>啊哈！算法</h2><p>看起来很困难的问题解决起来可能很简单，并且还很可能出人意料之外。只有经过广泛的研究之后才能对算法具备那种出神入化的理解力。任何愿意在编码前、编码期间以及编码后任职思考的程序员都可具备这种能力。</p>
<p>算法与其他哪些深奥的思想一样重要，但在更一般的编程层面上具有更重要的影响</p>
<blockquote>
<p>三个问题</p>
</blockquote>
<ol>
<li>给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中的32位整数。在具有足够内存的情况下，如何解决？如果有几个外部的临时文件可用，但是只有几百字节的内存，又该如何解决？</li>
<li>将一个 n 元一维向量向左旋转 i 个位置。简单的代码使用一个 n 元的中间向量在 n 步内完成工作。你能否仅适用数十个额外字节的存储空间，在正比于 n 的时间内完成向量的旋转？</li>
<li>给定一个英语词典，找出其中的所有变位词集合，例如<code>pots</code>,<code>stop</code>,<code>tops</code>互为变位词。</li>
</ol>
<blockquote>
<p>问题 1</p>
</blockquote>
<p>采用已知包含至少一个缺失元素的一系列整数作为范围，并使用包含所有这些整数在内的文件表示这个范围，通过统计中间点之上和之下的元素来探测范围：或者上面或者下面的范围具有至多全部范围的一半元素。由于整个范围中有一个缺失元素，因此我们所需的那一半范围中必然也包含缺失的元素</p>
<p>问题是这样的，给定一个包含32位整数的顺序文件，它至多只能包含40亿个这样的整数，并且整数的次序是随机的。请查找一个此文件中不存在的32位整数。</p>
<p>这个时候二分查找法就非常有用，首先遍历一遍这40亿个数字，并分为两组，一组是左边第一位为1的，一组是左边第一位为0的，正常来说，上下应该各占据一半，但因为总范围内有遗漏元素（假设只有一个），那么比较小的那一组必包含此遗漏元素。继续在比较小的那一组使用1与0的分组，很快就可以找到这个遗漏的整数。</p>
<blockquote>
<p>问题 2</p>
</blockquote>
<p>简单的方法就不说了，另一个想法是给出了旋转的位数其实每个字母的最终位置是确定的，只需要一个临时变量，把对应的放过去即可。但是这种方法比较容易出错，不容易维护。</p>
<p>另一个方法是把问题看做数组 ab 转换成 ba。</p>
<p>ab - a’b - a’b’ - (a’b’)’ - ba</p>
<pre><code>假设原来是 abcdefgh，向左旋转 3 位
reverse(0, i-1) // cbadefgh
reverse(i, n-1) // cbahgfed
reverse(0, n-1) // defghabc
</code></pre><p>这种方法高效且简短</p>
<blockquote>
<p>问题 3</p>
</blockquote>
<p>直接处理的话，问题非常复杂，需要大量的计算。因为我们只是需要找到同位词，那其实只要把拥有同样字母的单词贴上同样的标志即可。比如说，把每个单词里的字母按照字典序排序，而在具体的标志过程其实也有一些技巧，比如说good可以简化为go2d，这种标识法在长单词多重复时可以减少编码的长度。</p>
<p>具体的映射方式很多，这里不一一赘述</p>
<blockquote>
<p>1.考虑查找给定输入单词的所有变位词的问题。仅给定单词和字典的情况下，如何解决该问题？如果有一些时间和空间可以在响应任何查询之前预先处理字典，又会如何？</p>
</blockquote>
<p>在给定单词和字典的情况下，遍历字典，计算每个的标签，然后与给定的单词的标签比较。可以预处理的话就好说了，将所有单词按照标签排序，然后可以用equal_range求出区间，O(logN)。</p>
<blockquote>
<p>2.给定包含 4300000000 个 32 位整数的顺序文件，如何找出一个出现至少两次的整数？</p>
</blockquote>
<p>可以类比如何找出没有出现的整数。4300000000 大于int的表示范围。可以先扫描一遍，把第一位为0的和第一位为1的放到两个不同的文件中，看哪个文件里面的数多，就开始处理这个文件，把第二位的0和1的数字放到两个文件中，看哪个的数字多，依此类推，最后肯定得到一个数，他出现了不止一次。</p>
<blockquote>
<p>3.前面涉及了两个需要精确代码来实现的旋转算法，写出代码。在每个程序中，i 和 n 的最大公约数如何出现</p>
</blockquote>
<p>gao函数是那个杂技算法，gaogao是块交换算法。经过简单的测试还没有发现什么问题。n和len的最大公约数就是置换的次数。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
int gcd( int a, int b ){
    return b==0?a:gcd(b, a%b);
}
int gao( int *start, int *end, int n ){
    int len = end - start;
    int d = gcd( n, len );
    for( int i = 0; i &lt; d; i++ ){
        int t = *(start+i);
        int next = i;
        while( (next+n)%len != i ){
            *(start+next) = *(start+(next+n)%len);
            next = (next+n)%len;
        }
        *(start+next) = t;
    }
}
</code></pre><p>gaogao函数用到了一个辅助函数，rangeswap，就是将[start1,start1+n)和[start2,start2+n)的值进行交换。</p>
<pre><code>void rangeswap( int *start1, int *start2, int n ){
    for( int i = 0; i &lt; n; i++ )
        swap( *(start1+i), *(start2+i) );
}

void gaogao( int *start, int *end, int shift ){
    int len = end - start;
    shift = ( shift%len + shift )%len;
    if( len &lt;= 1 ) return;
    if( shift &lt;= len / 2 ){
        rangeswap( start, end - shift, shift );
        gaogao( start, end - shift, shift );
    }
    else{
        rangeswap( start, start+shift, len - shift );
        gaogao( end - shift, end, shift - len );
    }
}

const int n = 1000000;
int main(void){
    int a[n];
    for( int i = 0; i &lt; n; i++ )
        a[i] = i;
    gao( a, a+n, 6);
    for( int i = 0; i &lt; n; i++ )
        cout &lt;&lt; a[i] &lt;&lt; &apos; &apos;;
    cout &lt;&lt; endl;
    return 0;
}
</code></pre><p>STL中还有一种更bt的实现方法，algorithm中有个rotate，他用及其简单的代码就实现了循环位移。代码如下：</p>
<pre><code>template &lt;class ForwardIterator&gt;
void rotate ( ForwardIterator first, ForwardIterator middle, ForwardIterator last )
{
  ForwardIterator next = middle;
  while (first!=next)
  {
    swap (first++,next++);
    if (next==last) next=middle;
    else if (first == middle) middle=next;
  }
}
</code></pre><p>除了Orz我已经无话可说了。。</p>
<blockquote>
<p>4.比较三种不同的旋转算法</p>
</blockquote>
<p>暂略</p>
<blockquote>
<p>5.向量旋转函数将向量 ab 变为 ba，如何将 abc 变为 cba？</p>
</blockquote>
<p>对每一块儿进行翻转，然后对整体进行翻转即可。</p>
<blockquote>
<p>6.如何实现以一个名字的按键编码为参数，并返回所有可能的匹配名字的函数？</p>
</blockquote>
<p>计算出所有人名的按键信息（标识），然后按照标识进行排序，查询的时候二分即可。答案中提示更多使用的是hash和数据库。</p>
<blockquote>
<p>7.如何快速转置一个存储在磁带上的 4000x4000 的矩阵，从原来的50个小时缩减到半小时？</p>
</blockquote>
<p>可能是因为磁带的读写问题所导致的，具体不清楚</p>
<blockquote>
<p>8.给定一个 n 元实数集合、一个实数 t 和一个整数 k，如何快速确定是否存在一个 k 元子集，其元素之和不超过 t？</p>
</blockquote>
<p>第一感觉想到的是排序，然后看前k个数的和是否不超过t，不超过的话肯定存在。更优的方法用O(N)的选择算法求出第k大的数，然后把数组扫描一遍，求出小于第k大数的数的和sum，加上第k大。这样看似没有什么错误，但是仔细想想，如果第k-1大，第k大，第k+1大的数一样，肿么办？easy~扫描的时候顺便统计小于第k大数的数的个数a，和第k大的数的个数b，嗯，然后如果<code>a&lt;k-1</code>,就从b中取出m个，直到<code>a+m == k-1</code>。</p>
<blockquote>
<p>9.顺序搜索和二分搜索代表了搜索时间和预处理时间之间的折中。处理一个 n 元表格时，需要执行多少次二分搜索才能弥补对表进行排序所消耗的预处理时间？</p>
</blockquote>
<p>这个，具体让我来算一算</p>
<blockquote>
<p>10.爱迪生的故事</p>
</blockquote>
<p>用水来测体积</p>
<h2 id="u6570_u636E_u51B3_u5B9A_u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u51B3_u5B9A_u6570_u636E_u7ED3_u6784" class="headerlink" title="数据决定数据结构"></a>数据决定数据结构</h2><p>合适的数据结构确实构造了程序。本章描述了各种不同的程序，通过重构它们的内部数据，使其变得更加简短（而且更好）。数据结构本该短小、干净、漂亮，而不是巨大、混乱、丑陋不堪的。</p>
<p>能用小程序实现，就不要编写大程序。</p>
<p>程序员在节省空间方面无计可施时，将自己从代码中解脱出来，退回起点并集中心力研究数据，常常能有奇效，(数据的)表示形式是程序设计的根本。</p>
<p>下面是退回起点进行思考时的几条原则：</p>
<ul>
<li><strong>使用数组重新编写重复代码</strong>。冗长的相似代码常常可以使用最简单的数据结构——数组来更好地表述。</li>
<li><strong>封装复杂结构</strong>。当需要非常复杂的数据结构时，使用抽象术语进行定义，并将操作表示为类。</li>
<li><strong>尽可能使用高级工具</strong>。超文本、名字-值对、电子表格、数据库、编程语言等都是特定问题领域中的强大的工具。</li>
<li><strong>从数据得出程序的结构</strong>。彻底理解输入、输出和中间数据结构，并围绕这些结构创建程序。</li>
</ul>
<blockquote>
<p>1.税收分段计费</p>
</blockquote>
<p>使用数组来简化循环。数组中每个点表明一个阶段，用level[i]表示阶段i的起始点，tax[i]表示阶段i的税率，用have [i]表示这个阶段已经有的税收，然后得到收入后二分到相应的阶段，计算税收。</p>
<blockquote>
<p>2.k 阶常系数线性递归</p>
</blockquote>
<p>真心没看懂题目，也是醉</p>
<blockquote>
<p>3.编写一个“banner”函数，该函数的输入为大写字母，输出为一个字符数组，该数组以图形化的方式表示该字母</p>
</blockquote>
<p>这个就是用数组画图呗，三维数组即可。</p>
<p>原来要求的就是对三维数组进行信息压缩，自定一种格式显示即可。</p>
<blockquote>
<p>4.编写处理如下日期问题的函数：给定两个日期，计算两者之间的天数；给定一个日期，返回值为周几；给定月和年，使用字符数组生成该月的日历</p>
</blockquote>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;
int month[13] = {
0,  31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
//  1   2   3   4   5   6   7   8   9   10  11  12
};

class D{
public:
    int year,mon,day;// 1900 &lt;= year, 1 &lt;= mon &lt;= 12,
                    // 1 &lt;= day &lt;= 31
    D(){}
    D(int y, int m, int d):
        year(y),mon(m),day(d){}

    int yearday(void){//返回这一天是这一年的第几天
        int sum = day;
        for( int i = 1; i &lt; mon; i++ )
            sum += month[i];
        if( isrun() &amp;&amp; mon &gt; 2 )
            sum ++;
        return sum;
    }
    bool isrun( void ){//是否是闰年
        return (year%4==0&amp;&amp;year%100!=0)||(year%400==0);
    }
};

int dist( D d1, D d2 ){//两个日期相差的天数
    int sum = -(d1.yearday());
    for( ; d1.year &lt; d2.year ; d1.year++ )
        sum += d1.isrun()?366:365;
    return sum + d2.yearday();
}

int xingqiji( D d ){//某一天是星期几
    D temp(1900,1,1);
    return dist( temp, d )%7+1;
}

int print(int year, int mon ){//输出某月日历
    D d(year, mon, 1 );
    int week = xingqiji(d);
    int sum = month[ mon ];
    for( int i = 1; i &lt; week; i++ )
        cout &lt;&lt; &quot;   &quot;;
    for( int i = 1; i &lt;= sum; i++){
        cout &lt;&lt; i &lt;&lt; &quot;  &quot;;
        if( week == 7 ){
            week = 1;
            cout &lt;&lt; endl;
        }
        else week++;
    }
    cout &lt;&lt; endl;
}

int main(void){
    D a(2012,6,3);
    cout &lt;&lt; xingqiji(a) &lt;&lt; endl;
    print(1990,2);
    return 0;
</code></pre><blockquote>
<p>5.处理英语中的一小部分连字符问题。</p>
</blockquote>
<p>从前到后进行比较，符合一个输出就行。</p>
<blockquote>
<p>6.题目略</p>
</blockquote>
<p>回答略</p>
<blockquote>
<p>7.其实我没有看懂题目的意思</p>
</blockquote>
<p>所以我也没办法回答</p>
<blockquote>
<p>8.编写一个使用 5 个七段显示数字来显示十六位正整数的程序。输出为一个 5 字节的数组，当且仅当数字 j 中的第 i 段点亮时，字节 j 中的位 i 置 1。</p>
</blockquote>
<p>转化为一道题目，是zoj1146</p>
<blockquote>
<p>深入阅读</p>
</blockquote>
<p>数据可以结构化程序，但是只有聪明的程序员才能结构化大型软件系统。</p>
<h2 id="u7F16_u5199_u6B63_u786E_u7684_u7A0B_u5E8F"><a href="#u7F16_u5199_u6B63_u786E_u7684_u7A0B_u5E8F" class="headerlink" title="编写正确的程序"></a>编写正确的程序</h2><p>二分查找并不像想象中简单。</p>
<p>二分搜索的关键思想是如果 t 在 x[0…n-1] 中，那么它就一定存在于 x 的某个特定范围之内。这里使用 mustbe(range) 来表示。逻辑函数 mustbe(l, u) 是说：如果 t 在数组中，t 就一定在(闭区间)范围 x[l…u] 内。</p>
<p>最终的函数为</p>
<pre><code>l = 0; u = n - 1
loop
    { mustbe(l, u) }
    if l &gt; u
        p = -1; break;
    m = (l + u) / 2
    case
        x[m] &lt; t: l = m+1
        x[m] == t: P = m; break
        x[m] &gt; t: u = m-1
</code></pre><blockquote>
<p>1.如何证明二分搜索没有运行时错误(例如除数为0、数值溢出、变量值超出声明范围或者数组下标越界)？</p>
</blockquote>
<p>为了保证范围不超过范围，我们需要在初始化的时候，让变量不超出范围。这样每次循环得到的新的范围是慢慢缩小的，不会越界。</p>
<blockquote>
<p>!!2.把 t 在数组 x 中地一次出现的位置返回给 p(如果存在多个的话，原始的算法会任意返回其中的一个)。要求代码对数组元素进行对数次比较(在log~2 n 次比较内完成)</p>
</blockquote>
<pre><code>int bs( int *a, int l, int r, int v ){
    while( l &lt;= r ){
        if( a[l] == v ) return l;
        int mid = (l+r)/2;
        if( a[mid] &lt; v ) l = mid+1;
        if( a[mid] == v )r = mid;
        if( a[mid] &gt; v ) r = mid-1;
    }
    return -1;
}
</code></pre><p>这个二分可以返回所需要查询的元素第一次出现的位置，如果不存在，则返回-1.在每个循环内，我们假定元素第一次出现的范围是闭区间[l，r]内，当循环体内语句执行完之后，我们得到了一个新的区间。新的区间的范围是一直在收敛的（不会存在r，l执行完循环之后大小没有变化。），所以程序可以终止，得到正确结果。</p>
<blockquote>
<p>3.编写一个递归的二分搜索程序</p>
</blockquote>
<pre><code>int bss( int *a, int l, int r, int v ){
    if( l &gt; r ) return -1;
    if( a[l] == v ) return l;
    int mid = (l+r)/2;
    if( a[mid] &lt; v ) return bss( a, mid+1, r, v );
    if( a[mid] == v )return bss( a, l, mid, v );
    if( a[mid] &gt; v ) return bss( a, l, mid-1, v );
}
</code></pre><p>递归每加深一层，[l,r]的范围就减小。本层的后置条件要和下一层的前置条件吻合。</p>
<blockquote>
<p>4.验证运行时间是对数的</p>
</blockquote>
<p>略</p>
<blockquote>
<p>5.证明下面的程序在输入 x 为正整数时能够终止</p>
</blockquote>
<pre><code>while x != 1 do
    if even(x)
        x = x/2
    else
        x = 3 * x + 1
</code></pre><p>找一下规律</p>
<p>从 2 开始: 2 1 4 2 1 4….无法终止<br>从 3 开始: 3 10 5 16 8 4 2 1 4 2 1 4…无法终止</p>
<p>最终都会归于 214 循环</p>
<blockquote>
<p>6.咖啡罐问题：给定一个装有一些黑豆子和一些白豆子的咖啡罐以及一大堆额外的黑豆子，重复下面过程直到罐中只剩一颗豆子为止——从罐中选取两个豆子，如果颜色相同，就都扔掉并放入一个额外的黑色豆子，如果颜色不同，将白色的留下，黑色的扔掉。证明该过程会停止，最后留在罐中的豆子颜色与最初白豆子和黑豆子的数量有何函数关系？</p>
</blockquote>
<p>每次执行一次，罐子中的豆子数量就减去1,所以此过程可以终止。</p>
<p>化简到最后的阶段</p>
<pre><code>1 白 1 黑 -&gt; 白
2 白 -&gt; 黑
2 黑 -&gt; 白
可得出以下结论：
</code></pre><p>如果最后留下的是白色的，那么开始时候白色的个数为奇数，否则为偶数。</p>
<blockquote>
<p>7.确定点与线段的位置关系</p>
</blockquote>
<p>先是给一个线段的范围。然后选取中间的线，看点在他上面还是下面，然后可以缩小一半的查找范围。类似于二分查找</p>
<blockquote>
<p>8.如何在不改变二次比较次数的前提下让代码运行得更快？</p>
</blockquote>
<p>暂时没有想到什么</p>
<blockquote>
<p>9.证明程序有效性的题目</p>
</blockquote>
<p>两个n维的向量相加。初开始时：i=0表示前i个维度的都已经计算好了。在循环之中，计算一个维度，然后i加一，计算下一个维度，每个循环结束表明前i个维度已经计算完毕。i一直在增大，证明这个过程是可以终止的。当最后一个循环执行完毕的时候，i的值是n，表明前n个维度已经计算好了。所以其代码是正确的。</p>
<p>求x数组的最大值。初开始时候，max=x[0]表示最大值是第一个数，i=1表示前i个数的最大值已经求出。每次循环时候，如果有比max大的数，就替换，当循环结束时候，前i个数的最大值就知道了。当整个过程结束时，i==n，所以前n个数的最大值可以求出。</p>
<p>当循环找个一个t的时候，就停止循环，或者当i超出范围的时候停止。i在每一次循环的时候值都增加，所以这个算法是可以结束的。当超出范围的时候，返回-1，否则返回的就是第一次出现的位置，因为i的值是从小到大递增的。</p>
<p>每次递归，问题的规模都是缩小的，所以问题可以在有限步骤内结束。每次递归完成一次，就可以得到上次层想要的运算结果，接着向上传递。</p>
<h2 id="u7F16_u7A0B_u5C0F_u4E8B"><a href="#u7F16_u7A0B_u5C0F_u4E8B" class="headerlink" title="编程小事"></a>编程小事</h2><p><strong>脚手架</strong>。最好的脚手架通常是最容易构建的脚手架。</p>
<p><strong>编码</strong>。对于比较难写的函数，我发现最容易的方法是使用方便的高级伪代码来构建程序框架，然后将伪代码翻译成要实现的语言。</p>
<p><strong>测试</strong>。在脚手架中对组件进行测试要比在大系统中更容易、更彻底。</p>
<p><strong>调试</strong>。对隔离在其脚手架中的程序进行调试是很困难的，但是若将其嵌入真实运行环境中，调试工作会更困难。</p>
<p><strong>计时</strong>。用以测试达到预期的性能</p>
<h2 id="u7A0B_u5E8F_u6027_u80FD_u5206_u6790"><a href="#u7A0B_u5E8F_u6027_u80FD_u5206_u6790" class="headerlink" title="程序性能分析"></a>程序性能分析</h2><p>可以通过以下几个不同层次的改进，来获得巨大的加速：</p>
<ul>
<li><strong>算法和数据结构</strong>。改进访问的效率，分治法</li>
<li><strong>算法调优</strong>。配合数据结构进行优化</li>
<li><strong>数据结构重组</strong></li>
<li><strong>代码调优</strong>。对于不需要特别高精度的计算，可以用精度较低的类型代替</li>
<li><strong>硬件</strong>。升级性能我会乱说</li>
</ul>
<blockquote>
<p>原理</p>
</blockquote>
<ul>
<li>计算机系统中最廉价、最快速且可靠的元件是根本不存在的</li>
<li>如果仅需要较小的加速，就对效果最佳的层面做改进</li>
<li>如果需要较大的加速，就对多个层面做改进</li>
</ul>
<h2 id="u7C97_u7565_u4F30_u7B97"><a href="#u7C97_u7565_u4F30_u7B97" class="headerlink" title="粗略估算"></a>粗略估算</h2><blockquote>
<p>基本技巧</p>
</blockquote>
<ul>
<li><strong>两个答案比一个答案好</strong>。如果两种方法得到的估算结果比较接近，那么很可能答案是靠谱的。</li>
<li><strong>快速检验</strong>。量纲检验</li>
<li><strong>经验法则</strong>。比如说，假设以年利率 r% 投资一笔钱 y 年，如果 r x y = 72，那么你的投资差不多会翻倍。</li>
</ul>
<p>计算的输入决定了其输出的质量。基于良好的数据，简单的计算也可以得到精确的计算结果。</p>
<p>Brooklyn Bridge的设计者John Reobling是一个很有趣的人，在1940年左右，有许多桥因为暴风雨断裂了，那时候因为科学的限制并没有办法具体算出气动上升现象究竟需要多少的承载力。但是John Roebling充分意识到他不知道某些东西，所以在他意识到气动上升现象时，知道自己不足以对其建模，于是将Brooklyn Bridge桥上的铁索强度设计成基于已知的静态和动态负载的常规计算所要求强度的六倍。</p>
<p>Roebling是一名优秀的工程师，他使用一个巨大的安全系数来补偿他对某些方面的无知，从而使得Brooklyn Bridge成为当时所建现在唯一没有垮掉的桥。所以在对软件系统进行性能计算时，最好按照2、4或6的系数降低性能，以补偿我们的无知。</p>
<p><strong>Little 定律</strong>：队列中物体的平均数量为进入速率与平均停留时间的乘积。</p>
<p>下面举三个例子来说明利特尔法则：</p>
<p>有一个非常火爆的夜总会，你现在在排队，前面有20个人，你知道这个地方可以容纳60个人，平均来说每个人进去待3个小时，所以进入率就是每小时20个人，你大概就知道你大约需要等待1个小时。（同样可以推广到在游乐场等待游戏设施，不过最好别算，算了总是让人伤心）</p>
<p>假如我在地下室中存有150个酒瓶，我每年会喝掉25瓶并买回新的25瓶酒，那么每个容器我要保存多少年。应用利特尔法则，150除以25，得到每个容器保存六年。</p>
<p>假设平均思考时间为z的n个用户连接到了一个任意的系统中，其响应时间为r。每个用户都在思考和等待响应之间循环，所以总计作业数都是n。如果切断系统输出到用户之间的路径，你就能看到一个元系统，其平均负载为n，平均响应时间为z+r，吞吐量x=n/(r+z)</p>
<p><strong>任何事都应尽量简单，但不宜过于简单。</strong></p>
<blockquote>
<p>1.贝尔实验室距离狂野的密西西比河大约有1000英里，而我们距离平时比较温和的帕塞伊克河只有几英里。在一个星期的倾盆大雨后，报纸说“帕塞伊克河的流速为200英里每小时，大约是平时的五倍”，你有何评论？</p>
</blockquote>
<p>什么叫温和，我觉得可能是流速大约在跑步与汽车低速之间，假设是20英里每小时好了。一条河的流速的影响因素很多，比方说总流量，宽度，还有水量。经过综合考虑，我觉得报道上的流速太夸张了，200英里，吓死人。</p>
<p>常见流速其实是每小时2英里。也许200英里是一天的流速，是常见的一天40英里的五倍</p>
<blockquote>
<p>2.在什么距离下骑自行车的送信人使用移动存储介质传递信息的速度高于高速数据线的传输速度？</p>
</blockquote>
<p>假设这个移动存储介质的容量是无限的，要传递的信息的大小是 N mb，然后高速数据线的传输速率是 V mb/h，骑车的速度是 S km/h</p>
<p>可以转化为 N / V x S = 临界距离，具体找几个可能的数值代入进去算，考虑一些额外消耗即可。</p>
<blockquote>
<p>3.手动录入文字来填满一张软盘需要多长时间？</p>
</blockquote>
<p>考虑到软盘几近灭绝，我们就拿填满 1MB 为例子吧。</p>
<p>一个汉字占两个字节，我的打字速度大概是一分钟80个字，也就是一分钟可以填充160个字节，那么 1 MB = 1024 KB = 1024 x 1024 B</p>
<p>1024 x 1024 / 160 = 6553 min = 109 hour</p>
<blockquote>
<p>4.假设整个世界变慢为原来的百万分之一。你的计算机执行一条指令需要多长时间？你的磁盘旋转一周需要多长时间？磁盘臂在磁盘上搜索需要多长时间？键入自己的名字又需要多长时间？</p>
</blockquote>
<p>CPU的时钟频率为5MHz，即一个时钟周期为0.2μs，那么一条指令大约需要6-20个周期。现在的硬盘大约是7200转或者5400转，后面的类推即可</p>
<blockquote>
<p>5.如何进一步检验 72 法则？</p>
</blockquote>
<p>增长速率介于 5% 和 10% 之间，72法则估算的误差在1%以内。</p>
<blockquote>
<p>6.联合国估算1998年的世界人口为59亿，年增长率为1.33%。如果按照这个速率，到2050年世界人口会是多少？</p>
</blockquote>
<p>2050-1998=52； 52*1.33≈70</p>
<p>因此根据72法则，2050年人口约为59*2=118亿。</p>
<blockquote>
<p>10.请估计一下你所在城市的死亡率，用每年的总人口百分比来度量</p>
</blockquote>
<p>通过报纸上的死亡通告并估算本地人口来估算死亡率。或者是利用 Little 定律以及对平均寿命的估算。例如，如果平均寿命为70年，那么每年有1/70或1.4%的人口死亡</p>
<blockquote>
<p>11.给出 Little 定律的概要证明</p>
</blockquote>
<p>具体看官方解答吧</p>
<blockquote>
<p>12.一些报纸称，25美分硬币的平均寿命是30年，该如何检验真伪呢？</p>
</blockquote>
<p>抽样统计，平均数的两倍大约为寿命</p>
<h2 id="u7B97_u6CD5_u8BBE_u8BA1_u6280_u672F"><a href="#u7B97_u6CD5_u8BBE_u8BA1_u6280_u672F" class="headerlink" title="算法设计技术"></a>算法设计技术</h2><p>算法领悟可以使程序更加简单。复杂算法有时可以极大地提高性能。</p>
<blockquote>
<p>问题的提出</p>
</blockquote>
<p>一个具有n个浮点数字的数组x，目标是要找到之中连在一起的数组元素中找到最大和。例如如果输入的数组是以下这十个元素：</p>
<pre><code>31  -41  59  26  -53  58  97  -93  -23  84
</code></pre><p>那么程序应该返回从59到97的综合，也就是187。第一个算法迭代了所有满足 0 ≤ i ≤ j ＜ n 的 i 和 j 整数对，分别计算总和，最终找到综合最大的组合。</p>
<blockquote>
<p>最初的算法（算法1）</p>
</blockquote>
<pre><code>maxsofar = 0
for i = [0, n)
    for j = [i, n)
        sum = 0
        for k = [i, j]
            sum += x[k]
            maxsofar = max(maxsofar, sum)
</code></pre><p>这段代码比较简短、直观并且易于理解，唯一遗憾的就是——慢。基本上来说可以判断这个算法的大O是n的三次方。</p>
<blockquote>
<p>二次算法（算法2）</p>
</blockquote>
<p>第一个二次算法注意到 x[i..j]中的总和与前面已计算的 x[i..j-1] 的总和密切相关，从而减少了计算量。</p>
<pre><code>maxsofar = 0
for i = [0, n)
    sum = 0
    for j = [i, n)
        sum += x[j]
        maxsofar = max(maxsofar, sum)
</code></pre><p>外循环和内循环都要执行n次，所以大O是n的平方。但是如果这样我们依然觉得不够，因为检测所有值肯定需要花费二次方时间，如何可以避开这个问题？</p>
<blockquote>
<p>分治算法（算法3）</p>
</blockquote>
<p>分治法的思想是这样的：要解决规模为 n 的问题，可递归解决两个规模近似为 n/2 的子问题，然后将它们的答案进行合并以得到整个问题的答案。</p>
<p>具体到这个问题上，可以把整个数组分为两个大约相等的部分，就叫 a 和 b。然后递归找出 a 和 b 中元素和最大的子数组，称为 ma 与 mb。然后再找到 ma 与 mb 之间的最大子数组称为 mc。最后找到最大的一个即可。代码如下：</p>
<pre><code>float maxsum3(l, u)
    if (l &gt; u)    return 0
    if (l == u )    return max(0, x[l])
    m = (l + u) / 2
    lmax = sum = 0
    for (i = m; i &gt;= l; i--)
         sum += x[i]
         lmax = max (lmax, sum)
    rmax = sum = 0

    for i = (m, u]
         sum += x[i]
         rmax = max (rmax, sum)

    return max(lmax+rmax, maxsum(l, m), maxsum3(m+1, u))
</code></pre><p>代码非常微妙，也就意味着非常容易出错，但是复杂度是O(n log n)。</p>
<blockquote>
<p>扫描算法（算法4）</p>
</blockquote>
<p>从最左端（元素 x[0]）开始，一直扫描到最右端（元素 x[n-1]），记下所碰到过的最大总和子数组。最大值初始为0.假设我们已经解决了针对 x[0..i-1] 的问题，现在需要拓展到 x[i] 中。可以使用类似分治法中的道理，前 i 个元素中，最大总和子数组要么在 i-1 个元素中（存储在 maxsofar 中），要么截止到位置 i（存储在 maxendinghere中）。下面就是扫描算法：</p>
<pre><code>maxsofar = 0
maxendinghere = 0

for i = [0, n)
    maxendinghere = max(maxendinghere + x[i], 0)
    maxsofar = max(maxsofar, maxendinghere)
</code></pre><p>这个算法代码更加简短，但是运行起来是最快的，运行时间是O(n)，已经是线性算法，不可能再快了。</p>
<blockquote>
<p>原则</p>
</blockquote>
<p>这个问题的原型其实是Grenander面对的模式匹配问题（在最大子数组问题中，给定 n x n 的实数数组，如何找出任意具有最大总和的举行子数组）。为了简便，所以化为一维，并且经过不同人的努力，得到了最后的扫描算法。总这里我们就可以看出来几个重要的算法设计技术。</p>
<ul>
<li><strong>保存状态，避免重新计算</strong>。算法2和4使用了简单的动态编程形式。</li>
<li><strong>将信息预处理到数据结构中</strong></li>
<li><strong>分治算法</strong></li>
<li><strong>扫描算法</strong></li>
<li><strong>累积</strong></li>
<li><strong>下限</strong></li>
</ul>
<p>只有经过广泛地研究和实践，才能熟练地使用算法设计技术</p>
<h2 id="u4EE3_u7801_u8C03_u4F18"><a href="#u4EE3_u7801_u8C03_u4F18" class="headerlink" title="代码调优"></a>代码调优</h2><p>优秀的程序员会保持代码效率：效率在软件中只是众多问题中的一个，但有时也是极其重要的一个。代码优化确定现有程序中的开销昂贵的部分并提高其速度，虽然并不总是适当的方法，并且很少能吸引人，但是有时确实可以使程序的性能大不一样。</p>
<blockquote>
<p>问题1：整数取模</p>
</blockquote>
<p>原来的代码</p>
<pre><code>k = (j + rotdist) % n;
</code></pre><p>但在C语言中取模(其实大部分语言都是)的开销很大，使用下面代码可以减少时间</p>
<pre><code>k = j + rotdist;
if (k &gt;= n)
    k -= n;
</code></pre><p>如果程序的运行时间主要消耗在输入输出上，那么对程序中的计算进行加速是毫无意义的。</p>
<blockquote>
<p>问题2：函数、宏和内联代码</p>
</blockquote>
<p>因为现代编译器的优化，小心出现很难发现的错误</p>
<blockquote>
<p>问题3：顺序搜索</p>
</blockquote>
<p>原来的代码是这样的</p>
<pre><code>int ssearch1(t)
    for i = [0,n)
        if x[i] == t
            return i
    return -1
</code></pre><p>可以使用 loop unrooling 技术减少分支判断提高速度</p>
<blockquote>
<p>问题4：计算球面距离</p>
</blockquote>
<p>这个问题就是地理或集合数据处理方面的典型应用场合。先输入一个由球面上5000个点组成的S集，每个点都由经度和纬度表示。然后读入20000个点组成的序列，每个点都由经度和纬度表示。对于该序列中的每个点，程序需要指出S集中哪个点最接近它，其中的距离是以球体中心到两个点的连线之间的角度来度量的。</p>
<p>如果想要利用别出心裁的算法（很可能需要好几百行代码），那么可能付出很大的代价。为什么不是用简单的数据结构？于是更换成三维坐标系而不是精度纬度。这样只需要几十行的代码优化，运行时间从几个小时降低为半分钟。</p>
<blockquote>
<p>问题5：二分查找</p>
</blockquote>
<p>代码优化在二分查找中通常不是必需的，因为二分查找算法的效率已经较高了。但是对于特定问题其实仍有优化的空间，比如如果一个序列中同一数字出现多次的情况，这里就不细说。</p>
<blockquote>
<p>原则</p>
</blockquote>
<p>有关代码优化最重要的原则就是尽量少用代码优化。总的来说可以概括为以下几点：</p>
<ul>
<li><strong>效率的角色</strong>。软件的许多其他属性和效率一样重要，甚至更重要。不成熟的优化是大量编程灾害的根源。</li>
<li><strong>度量工具</strong>。当效率变得重要时，第一步就是对系统进行配置，找出花费时间的位置。对程序进行剖析将指出关键的区域；对于其他区域，“没有坏的话就不要修复它”。</li>
<li><strong>设计层次</strong>。在优化代码以前，我们应该确保其他方法不会提供更加有效的解决方案。</li>
<li><strong>双刃剑</strong>。有时候使用if语句替换%求余运算符可以得到两倍的加速，而有时候则没有什么差别。“咬人的人也应该提防被咬”。</li>
</ul>
<h2 id="u8282_u7701_u7A7A_u95F4"><a href="#u8282_u7701_u7A7A_u95F4" class="headerlink" title="节省空间"></a>节省空间</h2><p>时常努力考虑压缩程序是很有利的。有时这种思考会带来新的启示，使程序变得更加简单。减少空间通常带来运行时间上合理的副作用：程序越小，加载的时候也越快，也越容易填充到高速缓存中；需要操作的数据越少，操作时所花的时间通常也就越少。</p>
<blockquote>
<p>关键在于简单性</p>
</blockquote>
<p>简单性可以产生功能性、健壮性以及速度和空间。简单性也可以减少代码的空间。</p>
<p>例如遇到稀疏数组，就有多种方法可以进行空间的压缩，一种就是把一个二维数组转化为一个一维数组+链表的组合。</p>
<blockquote>
<p>数据空间技术</p>
</blockquote>
<p><strong>不存储，重新计算</strong>。如果我们在需要某一给定对象的任何时候，都对其进行重新计算而不保存，那么所需空间就可以急剧减少。</p>
<p><strong>稀疏数据结构</strong>。使用指针来共享大型对象可以消除存储同一对象的众多副本所需的开销。</p>
<p><strong>数据压缩</strong></p>
<p><strong>分配策略</strong>。动态分配</p>
<p><strong>垃圾回收</strong></p>
<h2 id="u6392_u5E8F"><a href="#u6392_u5E8F" class="headerlink" title="排序"></a>排序</h2><p>使用库排序函数并不总是有效的，有时使用起来会非常麻烦，这种时候，手动编写排序函数就成为了唯一的选择。</p>
<blockquote>
<p>插入排序</p>
</blockquote>
<p>伪代码</p>
<pre><code>for i = [1,n)
    for (j=i; j&gt;0 &amp;&amp; x[j-1] &gt; x[j]; j--)
        swap(j-1, j)
</code></pre><p>swap 函数调用会带来很大的额外开销，内联之后还可以进一步优化</p>
<pre><code>for i = [1, n)
    t = x[i]
    for (j=i; j&gt;0 &amp;&amp; x[j-1] &gt; t; j--)
        x[j] = x[j-1]
    x[j] = t
</code></pre><blockquote>
<p>一种简单的快速排序</p>
</blockquote>
<p>排序数组时，将数组分成两个小部分，然后对它们递归排序。</p>
<pre><code>void qsort(l, u)
    if l &gt;= u then
        /* at most one element, do nothing */
        return
    /* goal:partition array around a particular value,
       which is eventually placed in its correct position p
    */
    qsort(l, p-1)
    qsort(p+1, u)
</code></pre><p>更详细一点的代码是 qsort1，可以通过调用 qsort1(0, n-1) 来排序数组 x[n]</p>
<pre><code>void qsort2(l, u)
    if (l &gt;= u)
        return
    m = l
    for i = [l+1, u]
        /* invariant: x[l+1..m] &lt; x[l] &amp;&amp; x[m+1..i-1] &gt;= x[l] */
        if (x[i] &lt; x[l])
            swap(++m, i)
    swap(l, m)
    /* x[1..m-1] &lt; x[m] &lt;= x[m+1..u] */
    qsort2(l, m-1)
    qsort2(m+1, u)
</code></pre><p>当输入数组是不同元素的随机排列时，该快速排序平均需要 O(n log n) 的时间和 O(log n) 的栈空间。</p>
<blockquote>
<p>更好的几种快速排序</p>
</blockquote>
<p>考虑一种极端的情况：n 个相同元素组成的数组，对于这种输入，qsort1 的性能非常糟糕，总的性能为O(n^2)</p>
<p>使用双向划分可以避免这个问题，下标 i 和 j 初始化为待划分数组的两端。主循环内有两个内循环，第一个内循环将 i 向右移过小元素，遇到大元素时停止；第二个内循环将 j 向左移过大元素，遇到小元素时停止。然后主循环测试这两个下标是否交叉并交换它们的值。</p>
<p>遇到相同的元素时停止扫描，并交换 i 和 j 的值。虽然这样做使交换的次数增加了，但却将所有元素都相同的最坏情况变成了比较好的情况</p>
<pre><code>void qsort3(l, u)
    if l &gt;= u
        return
    t = x[l]; i = 1; j = u+1
    loop
        do i++ while i &lt;= u &amp;&amp; x[i] &lt; t
        do j-- while x[j] &gt; t
        if i &gt; j
            break
        swap(i, j)
    swap(l, j)
    qsort3(l, j-1)
    qsort3(j+1, u)
</code></pre><p>我们的快盘程序花费了大量的时间来排序很小的子数组。如果用插入排序之类的简单方法来排序这些很小的数组，程序的速度会更快。</p>
<pre><code>void qsort4(l, u)
    if u-l &lt; cutoff
        return
    swap(l, randint(l, u))
    t = x[l]; i = 1; j = u+1
    loop
        do i++ while i &lt;= u &amp;&amp; x[i] &lt; t
        do j-- while x[j] &gt; t
        if i &gt; j
            break
        temp = x[i]; x[i] = x[j]; x[j] = temp
    swap(l, j)
    qsort4(l, j-1)
    qsort4(j+1, u)

qsort4(0, n-1)
isort3() // 再用插入排序
</code></pre><blockquote>
<p>3.在特定的系统上如何求出最佳的 cutoff 值？</p>
</blockquote>
<p>做测试，都跑一次，然后找到最佳性能的点</p>
<blockquote>
<p>4.虽然快速排序平均只需要 O(log n) 的栈空间，但是在最坏情况下需要线性空间，请解释原因。修改程序，使得最坏情况下仅使用对数空间。</p>
</blockquote>
<p>参考算法书</p>
<blockquote>
<p>5.编写程序，在O(n)时间内从数组 x[0..n-1] 中找出第 k 个最小的元素。算法可以对 x 中的元素进行排序</p>
</blockquote>
<p>这个参考July的博客</p>
<h2 id="u53D6_u6837_u95EE_u9898"><a href="#u53D6_u6837_u95EE_u9898" class="headerlink" title="取样问题"></a>取样问题</h2><p>编写程序从 0 到 n-1 中随机输出 m 个有序整数</p>
<pre><code>void gensets(int m, int n){
    set&lt;int&gt; S;
    while(S.size() &lt; m)
        S.inseart(bigrand() % n);
    set&lt;int&gt;iterator i;
    for (i = S.begin(); i != S.end(); ++i)
        cout &lt;&lt; *i &lt;&lt; &quot;\n&quot;;
}
</code></pre><p>但是用 set 的话，时间开销比较大。</p>
<p>另一种方法是把包含 0 到 n-1 的数组顺序打乱，然后把前 m 个元素排序输出</p>
<pre><code>for i = [0, n)
    swap(i, randint(i, n-1))
</code></pre><p>其实只需要打乱前 m 个元素即可</p>
<pre><code>void genshuf(int m, int n){
    int i, j;
    int *x = new int[n];
    for (i = 0; i &lt; n; i++)
        x[i] = i;
    for (i = 0; i &lt; m; i++){
        j = randint(i, n-1)
        int t = x[i]; x[i] = x[j]; x[j] = t;
    }
    sort(x, x+m);
    for (i = 0; i &lt; m; i++)
        cout &lt;&lt; x[i] &lt;&lt; &quot;\n&quot;;
}
</code></pre><blockquote>
<p>原理</p>
</blockquote>
<p><strong>正确理解所遇到的问题</strong>。与用户讨论问题产生的北京。问题的陈述通常就包含了与解决方案有关的想法。</p>
<p><strong>提炼出抽象问题</strong>。简洁、明确的问题陈述不仅可以帮助我们解决当前遇到的问题，还有助于我们把解决方案应用到其他问题中。</p>
<p><strong>考虑尽可能多的解法</strong></p>
<p><strong>实现一种解决方案</strong></p>
<blockquote>
<p>1.C库函数 rand() 通常返回约15个随机位。使用该函数实现函数 bigrand() 和 randint(l,u)，要求前者至少返回30个随机位，后者返回[l,u]范围内的一个随机整数</p>
</blockquote>
<pre><code>int bigrand(){
    return RAND_MAX*rand() + rand();
}

int randint(int l, int u){
    return l + bigrand() % (u-l+1);
}
</code></pre><blockquote>
<p>8.如何从 0 到 n-1 中随机选择 m 个整数，使得最终的输出顺序是随机的？如果有序列表中允许有重复整数，如何生成该列表？如果既允许重复，又要求按随机顺序输出，情况又如何？</p>
</blockquote>
<p>第一次生成整数时就输出</p>
<blockquote>
<p>9.[R. W. Floyd] 当 m 接近于 n 时，基于集合的算法生成的很多随机数都要丢掉，因为它们之前已经存在于集合中了。能否给出一个算法，使得即使在最坏情况下也只使用 m 个随机数？</p>
</blockquote>
<pre><code>void genfloyd(int m, int n){
    set&lt;int&gt; S;
    set&lt;int&gt;::iterator i;
    for (int j = n - m; j &lt; n; j++){
        int t = bigrand() % (j+1);
        if (S.find(t) == S.end())
            S.insert(t); // t is not in S
        else
            S.insert(j); // t is in S
    }
    for(i = S.begin(); i != S.end(); ++i)
        cout &lt;&lt; *i &lt;&lt; &quot;\n&quot;;
}
</code></pre><blockquote>
<p>10.如何从 n 个对象(可以依次看到这 n 个对象，但事先不知道 n 的值)中随机选择一个？具体说来，如何在事先不知道文本文件行数的情况下读取该文件，从中随机选择并输出一行？</p>
</blockquote>
<p>总选择第一行，然后以1/2的概率选择第2行，然后1/3几率选择第三行。在这一过程是，每一行选中的概率都是相等的</p>
<pre><code>i = 0
while more input lines
    with probability 1.0/++i
        choice = this input line
print choise
</code></pre><h2 id="u641C_u7D22"><a href="#u641C_u7D22" class="headerlink" title="搜索"></a>搜索</h2><p><strong>空间的重要性</strong>。调优得很好的链表虽然完成的工作只有数组的一半，但却需要两倍于数组的时间。因为数组中每个元素所占的内存只有链表的一半，而且数组是顺序访问内存的。</p>
<p><strong>代码调优方法</strong>。最显著的改进就是用只分配一个较大的内存块的方案来替换通用内存分配。这样就消除了很多开销较大的调用，而且也使空间的利用更加有效。对大多数结构来说，引入哨兵可以获得清晰、简单的代码，并缩短运行时间。</p>
<blockquote>
<p>10.在完成类似于生成随机数的任务时，可以使用其他哪些数据结构来表示整数集合？</p>
</blockquote>
<p>混合并匹配多种数据结构来表示随机集合</p>
<h2 id="u7B2C_14__u7AE0_uFF1A"><a href="#u7B2C_14__u7AE0_uFF1A" class="headerlink" title="第 14 章："></a>第 14 章：</h2><p>解决两个重要问题：<strong>排序</strong>和<strong>优先级队列</strong></p>
<h2 id="u5B57_u7B26_u4E32"><a href="#u5B57_u7B26_u4E32" class="headerlink" title="字符串"></a>字符串</h2><p><strong>散列</strong>。这一结构的平均速度很快，且易于实现</p>
<p><strong>平衡树</strong>。这些结构在最坏情况下也有较好的性能</p>
<p><strong>后缀数组</strong></p>
<blockquote>
<p>!!9.给定两个输入文本，找出它们的共有的最长字符串</p>
</blockquote>
<p>把第一个字符串读入数组c，记录器结束的位置并在其最后填入空字符；然后读入第二个字符串并进行同样的处理。跟以前一样进行排序。扫描数组时，使用异或来确保恰有一个字符串是从过渡点前面开始的。</p>
<h2 id="u7B97_u6CD5_u5206_u7C7B"><a href="#u7B97_u6CD5_u5206_u7C7B" class="headerlink" title="算法分类"></a>算法分类</h2><blockquote>
<p>排序</p>
</blockquote>
<p>通用函数</p>
<ul>
<li>插入排序。稳定排序算法</li>
<li>快速排序。递归</li>
<li>堆排序。非递归，仅适用固定大小额外空间</li>
</ul>
<p>专用函数</p>
<ul>
<li>基数排序。对字符串排序</li>
<li>位图排序。待排序整数通常在小范围内，无重复也没有多余数据</li>
</ul>
<blockquote>
<p>搜索</p>
</blockquote>
<p>通用函数</p>
<ul>
<li>顺序搜索</li>
<li>二分搜索</li>
<li>散列</li>
<li>二分搜索树</li>
</ul>
<p>专用函数</p>
<ul>
<li>关键字索引</li>
</ul>
<blockquote>
<p>其他集合算法</p>
</blockquote>
<ul>
<li>优先级队列</li>
<li>选择</li>
</ul>
<blockquote>
<p>字符串算法</p>
</blockquote>
<ul>
<li>变位词</li>
<li>最长重复子串</li>
<li>生成随机文本</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>编程珠玑算是比较有年头的一套程序员进阶的书籍，这里是我的读书笔记。</p>]]>
    
    </summary>
    
      <category term="技巧" scheme="http://wdxtub.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【深入理解计算机系统】读书笔记]]></title>
    <link href="http://wdxtub.com/2016/03/26/csapp-book-note/"/>
    <id>http://wdxtub.com/2016/03/26/csapp-book-note/</id>
    <published>2016-03-26T19:55:57.000Z</published>
    <updated>2016-03-26T20:32:15.000Z</updated>
    <content type="html"><![CDATA[<p>这是我之前自学时的笔记，本文的内容为第二版，现在最新是第三版。</p>
<p><em>Notes from Da Wang, Feb.2 2015</em></p>
<a id="more"></a>
<hr>
<p>从程序员的角度来学习计算机系统是如何工作的会非常有趣，主要是因为你可以主动地来做这件事情。无论何时你学到一些新的东西，都可以马上试验并且直接看到运行结果。事实上，我们相信学习系统的唯一方法就是做(do)系统，即再真正的系统上解决具体的问题，或是编写和运行程序。</p>
<p>本书起源于1998年秋季，作者在 CMU 开设的编号为15-213的介绍性课程：计算机系统导论(Introduction to Computer Systems, ICS)，是大多数高级系统课程的先行必修课。宗旨是用一种不同的方式向学生介绍计算机，只讨论那些影响用户级 C 语言程序的性能、正确性或实用性的主题。</p>
<h1 id="u8BA1_u7B97_u673A_u7CFB_u7EDF_u6F2B_u6E38"><a href="#u8BA1_u7B97_u673A_u7CFB_u7EDF_u6F2B_u6E38" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h1><p>我们通过跟踪 helloworld 程序的生命周期来开始对系统的学习——从它被程序员创建，到在系统上运行，输出简单的消息，然后终止。</p>
<h2 id="u4FE1_u606F_u5C31_u662F_u4F4D_+__u4E0A_u4E0B_u6587"><a href="#u4FE1_u606F_u5C31_u662F_u4F4D_+__u4E0A_u4E0B_u6587" class="headerlink" title="信息就是位 + 上下文"></a>信息就是位 + 上下文</h2><p><img src="/images/csapp1.1.jpg" alt="csapp1.1"></p>
<p>hello.c 程序以字节序列的方式存储在文件中。每个字节都有一个整数值，而该整数值对应于某个字符。</p>
<p><img src="/images/csapp1.2.jpg" alt="csapp1.2"></p>
<p>hello.c 的表示方法说明了一个基本的思想：系统中所有的信息——包括磁盘文件、存储器中的程序、存储器中存放的用户数据以及网络上传送的数据，都是由一串位表示的。区分不同数据对象的唯一方式是我们读到这些数据对象时的上下文。</p>
<p><strong>C 编程语言的起源</strong></p>
<ul>
<li>贝尔实验室的 Dennis Ritchie 于 1969-1973 年创建</li>
<li>C 语言与 Unix 操作系统关系密切</li>
<li>C 语言小而简单</li>
<li>C 语言是为实践目的而设计的</li>
<li>C 语言是系统级编程的首选，同时它也非常适用于应用级程序的编写。然而，它也并非适用于所有的程序员和所有的情况。C 语言的指针是造成困惑和程序错误的一个常见原因。同时，C 语言还缺乏对非常有用的抽象（类、对象和异常）的显式支持。</li>
</ul>
<h2 id="u7A0B_u5E8F_u88AB_u5176_u4ED6_u7A0B_u5E8F_u7FFB_u8BD1_u6210_u4E0D_u540C_u7684_u683C_u5F0F"><a href="#u7A0B_u5E8F_u88AB_u5176_u4ED6_u7A0B_u5E8F_u7FFB_u8BD1_u6210_u4E0D_u540C_u7684_u683C_u5F0F" class="headerlink" title="程序被其他程序翻译成不同的格式"></a>程序被其他程序翻译成不同的格式</h2><p>hello 程序的生命周期是从一个高级 C 语言程序开始的，因为这种形式能够被人读懂。为了在系统上运行，每条 C 语句都必须被其他程序转化为一系列的低级<strong>机器语言</strong>指令。然后这些指令按照一种称为<strong>可执行目标程序</strong>的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为<strong>可执行目标文件</strong>。</p>
<p>在 Unix 系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：</p>
<pre><code>unix&gt; gcc -o hello hello.c
</code></pre><p>这个翻译过程可分为四个阶段。这行这四个阶段的程序（预处理器cpp、编译器ccl、汇编器as和链接器ld）一起构成了编译系统（compilation system）。</p>
<p><img src="/images/csapp1.3.jpg" alt="csapp1.3"></p>
<p><strong>GNU 项目</strong></p>
<p>GCC 是 GNU(GNU’s Not Unix) 项目开发出来的众多有用工具之一。GNU 项目已经开发出了一个包含 Unix 操作系统的所有主要部件的环境，但内核除外，内核是由 Linux 项目独立发展而来的。GNU 环境包括 EMACS 编辑器、GCC 编译器、GDB 调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件。</p>
<h2 id="u4E86_u89E3_u7F16_u8BD1_u7CFB_u7EDF_u5982_u4F55_u5DE5_u4F5C_u662F_u5927_u6709_u76CA_u5904_u7684"><a href="#u4E86_u89E3_u7F16_u8BD1_u7CFB_u7EDF_u5982_u4F55_u5DE5_u4F5C_u662F_u5927_u6709_u76CA_u5904_u7684" class="headerlink" title="了解编译系统如何工作是大有益处的"></a>了解编译系统如何工作是大有益处的</h2><p>知道编译系统是如何工作非常重要，原因如下：</p>
<ul>
<li><strong>优化程序性能</strong>。了解一些机器代码以及编译器将不同的 C 语句转换为机器代码的方式。<ul>
<li>一个 <code>switch</code> 语句是否总是比一系列 <code>if-else</code> 语句高效得多？</li>
<li>一个函数调用的开销有多大？</li>
<li><code>while</code> 循环比 <code>for</code> 循环更有效吗？</li>
<li>指针引用比数组索引更有效吗？</li>
</ul>
</li>
<li><strong>理解链接时出现的错误</strong>。一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。<ul>
<li>无法解析一个引用是什么意思？</li>
<li>静态变量和全局变量的区别是什么？</li>
<li>在不同 C 文件中定义的名字相同的两个全局变量会发生什么？</li>
<li>静态库和动态库的区别是什么？</li>
<li>我们在命令行上排列库的顺序有什么影响？</li>
</ul>
</li>
<li><strong>避免安全漏洞</strong>。学习安全变成的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。</li>
</ul>
<h2 id="u5904_u7406_u5668_u8BFB_u5E76_u89E3_u91CA_u5B58_u50A8_u5728_u5B58_u50A8_u5668_u4E2D_u7684_u6307_u4EE4"><a href="#u5904_u7406_u5668_u8BFB_u5E76_u89E3_u91CA_u5B58_u50A8_u5728_u5B58_u50A8_u5668_u4E2D_u7684_u6307_u4EE4" class="headerlink" title="处理器读并解释存储在存储器中的指令"></a>处理器读并解释存储在存储器中的指令</h2><p>要想在 Unix 系统上运行可执行目标文件 hello，将文件名输入到 shell 中：</p>
<pre><code>unix&gt; ./hello
hello, world
unix&gt;
</code></pre><p>shell 是一个命令行解释器，它输出一个提示符，等待你输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的 shell 命令，那么 shell 就会假设这是一个可执行文件的名字，它将加载并运行这个文件。</p>
<blockquote>
<p>系统的硬件组成</p>
</blockquote>
<p>下图是 Intel Pentium 系统产品系列的模型：</p>
<p><img src="/images/csapp1.4.jpg" alt="csapp1.4"></p>
<ol>
<li><strong>总线</strong>：贯穿整个系统的电子管道，携带信息字节并负责在各个部件间传递。通常总线呗设计成传送定长的字节块，也就是字(word)。假设字长为 4 个字节，并且总线每次只传送 1 个字。</li>
<li><strong>I/O 设备</strong>：系统与外部世界的联系通道。每个 I/O 设备都通过一个<strong>控制器</strong>或<strong>适配器</strong>与 I/O 总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是置于 I/O 设备本身的或者系统的主板上的芯片组，而适配器则是一块插在主板插槽上的卡。</li>
<li><strong>主存</strong>：临时存储设备，由一组动态随机存取存储器(DRAM)芯片组成。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一地址。</li>
<li><strong>处理器</strong>：解释(或执行)存储在主存中指令的引擎。核心是一个字长的存储设备(或寄存器)，称为程序计数器(PC)。在任何时刻，PC 都指向主存中的某条机器语言指令。从系统痛点开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，在更新程序计数器，使其指向下一条指令。</li>
</ol>
<blockquote>
<p>运行 hello 程序</p>
</blockquote>
<p>当我们输入“./hello”后，shell 程序将字符逐一读入寄存器，再把它存放到存储器中，如下图所示：</p>
<p><img src="/images/csapp1.5.jpg" alt="csapp1.5"></p>
<p>利用直接存储器存取(DMA)技术，数据可以不通过处理器而直接从磁盘到达主存</p>
<p><img src="/images/csapp1.6.jpg" alt="csapp1.6"></p>
<p>一旦目标文件中的代码和数据被加载到主存，处理器就开始执行 hello 程序的 main 程序中的机器语言指令。这些指令将“hello, world\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。</p>
<p><img src="/images/csapp1.7.jpg" alt="csapp1.7"></p>
<h2 id="u9AD8_u901F_u7F13_u5B58_u81F3_u5173_u91CD_u8981"><a href="#u9AD8_u901F_u7F13_u5B58_u81F3_u5173_u91CD_u8981" class="headerlink" title="高速缓存至关重要"></a>高速缓存至关重要</h2><p>这个简单的例子揭示了一个重要的问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。因此，系统设计者的一个主要目的就是使这些复制操作尽可能快地完成。</p>
<p><img src="/images/csapp1.8.jpg" alt="csapp1.8"></p>
<p>较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。针对这种差异，系统设计者采用了更小、更快的存储设备，即<strong>高速缓存存储器</strong>，作为暂时的集结区域，用一种叫<strong>做静态随机访问存储器(SRAM)</strong>的硬件技术实现。</p>
<h2 id="u5B58_u50A8_u8BBE_u5907_u5F62_u6210_u5C42_u6B21_u7ED3_u6784"><a href="#u5B58_u50A8_u8BBE_u5907_u5F62_u6210_u5C42_u6B21_u7ED3_u6784" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h2><p>从上至下，设备的访问速度越来越慢、容量越来越大，每字节的造价也越来越便宜。</p>
<p><img src="/images/csapp1.9.jpg" alt="csapp1.9"></p>
<h2 id="u64CD_u4F5C_u7CFB_u7EDF_u7BA1_u7406_u786C_u4EF6"><a href="#u64CD_u4F5C_u7CFB_u7EDF_u7BA1_u7406_u786C_u4EF6" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h2><p>我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。操作系统有两个基本功能：</p>
<ol>
<li>防止硬件被失控的应用程序滥用。</li>
<li>向应用程序提供简单一致的机制来控制复杂而又通常大相径庭的低级硬件设备。</li>
</ol>
<p><img src="/images/csapp1.10.jpg" alt="csapp1.10"></p>
<p>操作系统通过几个基本的抽象概念(进程、虚拟存储器和文件)来实现这两个功能。</p>
<p><strong>Unix 和 Posix</strong></p>
<p>20 世纪 60 年代是大型、复杂操作系统盛行的年代，如 IBM 的 OS/360 和 Honeywell 的 Multics 系统。贝尔实验室曾经是 Multics 项目的最初参与者，但是因为项目复杂和缺乏进展于 1969 年退出。这之后一组贝尔实验室的研究人员(Ken Thompson, Dennis Ritchie, Doug Mcllroy &amp; Joe Ossanna)从1969年开始在 DEC PDP-7 计算机上完全用机器语言编写了一个简单得多的系统，1970 年 Brian Kernighan 命名为“Unix”。1973 年用 C 语言重新编写内核，1974年开始对外发布。</p>
<p>发布之后不同的 Unix 厂商加入新的、往往不兼容的特性来使它们的程序与众不同，也带来很多麻烦，为了阻止这种趋势，IEEE 开始努力标准化 Unix 的开发，后来由 Richard Stallman 命名为“Posix”，称为 Posix 标准。</p>
<blockquote>
<p>进程</p>
</blockquote>
<p><strong>进程</strong>是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。无论是在单核还是多核系统中，一个 CPU 看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的，这种交错执行的机制称为<strong>上下文切换</strong>。</p>
<p>操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是<strong>上下文</strong>，它包括许多信息，例如 PC 和寄存器文件的当前值，以及主存的内容。</p>
<p><img src="/images/csapp1.12.jpg" alt="csapp1.12"></p>
<blockquote>
<p>线程</p>
</blockquote>
<p>一个进程实际上可以由多个称为<strong>线程</strong>的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器对并行处理的需求，线程称为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，一般来说也更高效。</p>
<blockquote>
<p>虚拟存储器</p>
</blockquote>
<p><strong>虚拟存储器</strong>是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的是一致的存储器，称为<strong>虚拟地址空间</strong>。</p>
<p>在 Linux 中，地址空间最上面的区域是为操作系统中的代码和数据保留的，这对所有进程来说都是一样的。地址空间的底部区域存放用户进程定义的代码和数据，请注意，图中的地址是从下往上增大的。</p>
<p><img src="/images/csapp1.13.jpg" alt="csapp1.13"></p>
<p>从最低的地址开始，逐步向上介绍：</p>
<ul>
<li><strong>程序代码和数据</strong>。对于所有的进程来说，代码是从同一固定地址开始，紧接着是和 C 全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。</li>
<li><strong>堆</strong>。代码和数据区后紧随着的是运行时堆。代码和数据区是在进程一开始运行就被规定了大小，与此不同，当调用如 <code>malloc</code> 和 <code>free</code> 这样的 C 标准库函数时，对可以在运行时动态地扩展和收缩。</li>
<li><strong>共享库</strong>。大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。</li>
<li><strong>栈</strong>。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。</li>
<li><strong>内核虚拟存储器</strong>。内核总是主流在内存中，是操作系统的一部分。地址空间顶部的区域是为内核保留的，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。</li>
</ul>
<blockquote>
<p>文件</p>
</blockquote>
<p><strong>文件</strong>就是字节序列，仅此而已。这个简单而精致的概念拥有极其丰富的内涵，它向应用程序提供了一个统一的视角，来看待系统中可能含有的所有 I/O 设备。</p>
<h2 id="u7CFB_u7EDF_u4E4B_u95F4_u5229_u7528_u7F51_u7EDC_u901A_u4FE1"><a href="#u7CFB_u7EDF_u4E4B_u95F4_u5229_u7528_u7F51_u7EDC_u901A_u4FE1" class="headerlink" title="系统之间利用网络通信"></a>系统之间利用网络通信</h2><p>从一个单独的系统来看，网络可视为一个 I/O 设备。当系统从主存将一串字节复制到网络适配器时，数据流经过网络到达另一台机器，而不是其他地方。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。</p>
<p><img src="/images/csapp1.14.jpg" alt="csapp1.14"></p>
<h2 id="u91CD_u8981_u4E3B_u9898"><a href="#u91CD_u8981_u4E3B_u9898" class="headerlink" title="重要主题"></a>重要主题</h2><p>系统不仅仅只是硬件，而是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序的最终目的。下面是几个贯穿计算机系统所有方面的重要概念：</p>
<blockquote>
<p>并发和并行</p>
</blockquote>
<p><strong>并发(concurrency)</strong>是一个通用的概念，指一个同时具有多个活动的系统；<strong>并行(parallelism)</strong>指的是用并发使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。</p>
<p><strong>1.线程级并发</strong></p>
<p>传统意义上，这种并发执行只是模拟出来的，是通过正在执行的进程间快速切换的方式实现的，这种配置称为<strong>单处理器系统</strong>。</p>
<p><img src="/images/csapp1.16.jpg" alt="csapp1.16"></p>
<p>当构建一个由单操作系统内核控制的多处理器组成的系统时，就得到了一个<strong>多处理器系统</strong>。超线程，有时称为<strong>同时多线程(simultaneous multi-threading)</strong>，是一项允许一个 CPU 执行多个控制流的技术。</p>
<p><img src="/images/csapp1.17.jpg" alt="csapp1.17"></p>
<p>多处理器的使用可以从两个方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。其次，它可以使应用程序运行得更快。</p>
<p><strong>2.指令级并行</strong></p>
<p>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为<strong>指令级并行</strong>。流水线(pipelining)的引入使得指令并行成为可能。如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为<strong>超标量(superscalar)</strong>处理器。</p>
<p><strong>3.单指令、多数据并行</strong></p>
<p>在最低层次上，许多处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，即 SIMD 并行。</p>
<blockquote>
<p>计算机系统中抽象的重要性</p>
</blockquote>
<p><strong>抽象</strong>的使用是计算机科学中最为重要的概念之一。</p>
<p><img src="/images/csapp1.18.jpg" alt="csapp1.18"></p>
<p>在处理器里，<strong>指令集结构</strong>提供了对实际处理器硬件的抽象。在操作系统中：<strong>文件</strong>是对 I/O 的抽象，<strong>虚拟存储器</strong>是对程序存储器的抽象，而<strong>进程</strong>是对一个正在运行的程序的抽象。虚拟机则是对整个计算机(包括操作系统、处理器和程序)的抽象。</p>
<hr>
<p><strong>第一部分：程序结构和执行</strong></p>
<p>计算机由处理器和存储器子系统组成。在核心部分，我们需要方法来表示基本数据类型，比如整数和实数运算的近似值。然后，我们考虑机器级指令如何操作这样的数据，以及编译器如何将 C 程序翻译成这样的指令。这一部分将帮助你深入了解如何表示和执行应用程序。</p>
<h1 id="u4FE1_u606F_u7684_u8868_u793A_u548C_u5904_u7406"><a href="#u4FE1_u606F_u7684_u8868_u793A_u548C_u5904_u7406" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h1><p>单个 bit 不是非常有用，然而，当把 bit 组合在一起，再加上某种解释(interpretation)，即给不同的可能位模式赋予含义，就能够表示任何有限集合的元素。计算机的表示法适用有限数量的 bit 来对一个数字编码，因此，当结果太大以至于不能表示时，某些运算就会<strong>溢出(overflow)</strong>。</p>
<p>浮点运算有完全不同的数学属性，由于精度有限，浮点运算是不可结合的。整数的表示虽然只能编码一个相对较小的数值范围，但这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但这种表示只是近似的。</p>
<p><strong>C 编程语言的演变</strong></p>
<p>C -> ANSI C -> ISO C90 -> ISO C99</p>
<p>GNU 编译器套装(GNU Compiler Collection, GCC)可以基于不同的命令行选项，依照多个不同版本的 C 语言规则来编译程序。</p>
<p><img src="/images/csapp2.1.jpg" alt="csapp2.1"></p>
<h2 id="u4FE1_u606F_u5B58_u50A8"><a href="#u4FE1_u606F_u5B58_u50A8" class="headerlink" title="信息存储"></a>信息存储</h2><p>大多数计算机使用8位的块，或者 byte 作为最小的可寻址的存储器单位，而不是在存储器中访问单独的 bit。机器级程序将存储器视为一个非常大的字节数组，称为<strong>虚拟存储器(virtual memory)</strong>。存储器的每个字节都由一个唯一的数字来标识，称为它的<strong>地址(address)</strong>，所有可能的地址集合称为<strong>虚拟地址空间(virtual address space)</strong>。</p>
<blockquote>
<p>十六进制表示法</p>
</blockquote>
<p>一个 byte 由 8 个 bit 组成。在二进制表示法中，它的值域是 00000000(2) ~ 11111111(2)；如果用十进制整数表示，它的值域就是 0 ~ 255。用十六进制书写，一个字节的值域为 00(16) ~ FF(16)。</p>
<p><img src="/images/csapp2.2.jpg" alt="csapp2.2"></p>
<blockquote>
<p>字</p>
</blockquote>
<p>每台计算机都有一个<strong>字长(word size)</strong>，指明整数和指针数据的<strong>标称大小(nominal size)</strong>。因为虚拟地址是以这样一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长尾 w 位的机器而言，虚拟地址的范围为 0 ~ 2^(w-1)，程序最多访问 2^w 个字节。现在的 32 位机器指的就是字长是 32 位，就限定了虚拟地址空间为 4GB。</p>
<blockquote>
<p>数据大小</p>
</blockquote>
<p>计算机和编译器支持多种不同方式编码的数字格式，如整数和浮点数，以及其他长度的数字。</p>
<p><img src="/images/csapp2.3.jpg" alt="csapp2.3"></p>
<p>程序员应该力图使他们的程序在不同的机器和编译器上是可移植的。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。</p>
<blockquote>
<p>寻址和字节顺序</p>
</blockquote>
<p>对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在存储器中如何排列这些字节。</p>
<p>某些机器选择在存储器中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则——最低有效字节在最前面的方式，称为<strong>小端法(little endian)</strong>。后一种规则——最高有效字节在最前面的方式，称为<strong>大端法(big endian)</strong>。许多比较新的微处理器使用<strong>双端法(bi-edian)</strong>，也就是说可以把它们配置成作为大端或者小端的机器运行。</p>
<p>几种机器所使用的字节顺序会成为问题的情况：</p>
<ol>
<li>在不同类型的机器之间通过网络传送二进制数据。</li>
<li>当阅读表示整数数据的字节序列时，字节顺序也很重要。</li>
<li>当编写规避正常的类型的系统时。</li>
</ol>
<p><strong>使用 typedef 命名数据类型</strong></p>
<p>C 语言中的 typedef 声明提供了一种给数据类型命名的方式。这能够极大地改善代码的可读性，因为深度嵌套的类型声明很难读懂。typedef 的语法与声明变量的语法十分相似，除了它使用的是类型名，而不是变量名。</p>
<blockquote>
<p>表示字符串</p>
</blockquote>
<p>C 语言中字符串被编码为一个以 null(其值为 0)字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是 ASCII 字符码。在使用 ASCII 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关，因此文本数据比二进制数据具有更强的平台独立性。</p>
<p><img src="/images/csapp0.2.jpg" alt="csapp0.2"></p>
<blockquote>
<p>表示代码</p>
</blockquote>
<p>考虑下面的 C 函数：</p>
<pre><code>int sum(int x, int y) {
    return x + y;
}
</code></pre><p>当我们在示例机器上编译时，生成如下字节表示的机器代码：</p>
<p><img src="/images/csapp0.3.jpg" alt="csapp0.3"></p>
<p>可以看到指令编码是不同的。不同的机器类型使用不同的且不兼容的指令和编码方式。因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。</p>
<blockquote>
<p>布尔代数简介</p>
</blockquote>
<p>二进制是计算机编码、存储和操作信息的核心，所以围绕 0 和 1 的研究演化出了丰富的数学知识体系。</p>
<p><img src="/images/csapp2.7.jpg" alt="csapp2.7"></p>
<blockquote>
<p>C 语言中的位级运算</p>
</blockquote>
<p>C 语言支持按位布尔运算，确定一个位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制并执行二进制运算，然后转换回十六进制。</p>
<p>位级运算的一个常见用法就是实现<strong>掩码</strong>运算，这里的掩码是一个位模式，表示从一个字中选出的位的集合。</p>
<blockquote>
<p>C 语言中的逻辑运算</p>
</blockquote>
<p>C 语言还提供了一组逻辑运算符 ||、&amp;&amp; 和 !，分别对应于命题逻辑中的 OR、AND 和 NOT 运算。</p>
<blockquote>
<p>C 语言中的移位运算</p>
</blockquote>
<p>C 语言还提供了一组移位运算，以便向左或者向右移动位模式：\&lt;\&lt;、>>。</p>
<p>x \&lt;\&lt; k 会生成一个值，x 向左移动 k 位，丢弃最高的 k 位，并在右端补 k 个 0。</p>
<p>右移 x >> k 比较微妙，一般而言，机器支持两种形式的右移：逻辑右移(补 0)和算术右移(补 1)。对于无符号数据，右移必须是逻辑的。对于有符号数据，几乎所有的编译器 / 机器组合都使用算术右移。</p>
<h2 id="u6574_u6570_u8868_u793A"><a href="#u6574_u6570_u8868_u793A" class="headerlink" title="整数表示"></a>整数表示</h2><blockquote>
<p>整型数据类型</p>
</blockquote>
<p>C 语言支持多种整型数据类型——表示有限范围的整数。C 语言标准定义了每种数据类型必须能够表示的最小的取值范围。</p>
<p><img src="/images/csapp2.8.jpg" alt="csapp2.8"></p>
<p><img src="/images/csapp2.9.jpg" alt="csapp2.9"></p>
<p><img src="/images/csapp2.10.jpg" alt="csapp2.10"></p>
<blockquote>
<p>无符号数的编码</p>
</blockquote>
<p>假设一共有 w 位，每个介于 0 ~ 2^w -1 之间的数都有唯一一个 w 位的值编码，即这个函数映射是一个双射。</p>
<blockquote>
<p>补码(two’s-complement)编码</p>
</blockquote>
<p>字的最高有效位解释为负权(negative weight)。</p>
<p><img src="/images/csapp2.13.jpg" alt="csapp2.13"></p>
<p>C 语言标准并没有要求用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。</p>
<p>其他的表示方法有<strong>反码(ones’ complement)</strong>和<strong>原码(sign-magnitude)</strong>，这两种表示方法都有一个奇怪的属性，就是对于数字 0 有两种不同的编码方式。</p>
<blockquote>
<p>有符号数和无符号数之间的转换</p>
</blockquote>
<p><img src="/images/csapp2.17.jpg" alt="csapp2.17"></p>
<blockquote>
<p>C 语言中的有符号数与无符号数</p>
</blockquote>
<p>C 语言允许无符号数和有符号数之间的转换。转换的原则是底层的位表示保持不变。</p>
<p><img src="/images/csapp2.18.jpg" alt="csapp2.18"></p>
<blockquote>
<p>扩展一个数字的位表示</p>
</blockquote>
<p>将一个无符号数转换为一个更大的数据类型，我们只需要简单地在表示的开头添加 0，这种运算称为<strong>零扩展(zero extension)</strong>。将一个补码数字转换为一个更大的数据类型可以执行<strong>符号扩展(sign extension)</strong>，规则是在表示中添加最高有效位的值的副本。</p>
<blockquote>
<p>截断数字</p>
</blockquote>
<p>截断一个数字可能会改变它的值——溢出的一种形式。</p>
<blockquote>
<p>关于有符号树与无符号数的建议</p>
</blockquote>
<p>有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换细微差别的错误很难被发现。因为这种强制类型转换是在代码中没有明确指示的情况下发生的，程序员经常忽视了它的影响。</p>
<p>避免这类错误的一种方法就是绝不使用无符号数。实际上，除了 C 以外，很少有语言支持无符号整数。</p>
<h2 id="u6574_u6570_u8FD0_u7B97"><a href="#u6574_u6570_u8FD0_u7B97" class="headerlink" title="整数运算"></a>整数运算</h2><p>理解计算机运算的细微之处能够帮助程序员编写更可靠的代码。</p>
<blockquote>
<p>无符号加法</p>
</blockquote>
<p>考虑两个非负整数 x 和 y，满足 $0 ≤ x, y ≤ 2^w - 1$。每个数都能表示为 w 位无符号数字。如果计算它们的和，我们就有一个可能的范围 $0 ≤ x + y ≤ 2^(w+1) - 2$，表示这个和可能需要 w + 1位。无符号运算可以被视为一种模运算形式。</p>
<blockquote>
<p>补码加法</p>
</blockquote>
<p>必须确定当结果太大(为正)或者太小(为负)时，应该做些什么。</p>
<p><img src="/images/csapp2.24.jpg" alt="csapp2.24"></p>
<blockquote>
<p>补码乘法</p>
</blockquote>
<p><img src="/images/csapp2.26.jpg" alt="csapp2.26"></p>
<blockquote>
<p>乘以常数</p>
</blockquote>
<p>在大多数机器上，整数乘法指令相当慢，需要 10 个或者更多的时钟周期，然而其他整数运算(例如加法、减法、位级运算和移位)只需要 1 个时钟周期。因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。</p>
<p>例如，假设一个程序包含表达式 x * 14。利用等式 $14 = 2^3 + 2^2 + 2^1$，编译器会将乘法重写为 (x \&lt;\&lt; 3) + (x \&lt;\&lt; 2) + (x \&lt;\&lt; 1)，实现了将一个乘法替换为三个移位和两个加法。更好的方法是 $14 = 2^4 - 2^1$，将乘法重写为(x \&lt;\&lt; 4) - (x \&lt;\&lt; 1)，这时只需要两个移位和一个减法。</p>
<blockquote>
<p>除以 2 的幂</p>
</blockquote>
<p>在大多数机器上，整数除法要比整数乘法更慢——需要 30 个或者更多的周期。除以 2 的幂也可以用移位运算右移来实现，无符号和补码数分别使用逻辑移位和算术移位来达到目的。</p>
<blockquote>
<p>关于整数运算的最后思考</p>
</blockquote>
<p>计算机执行“整数”运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。补码表示提供了一种既能表示负数也能表示正数的灵活方法，同时使用了与执行无符号算术相同的位级实现。</p>
<h2 id="u6D6E_u70B9_u6570"><a href="#u6D6E_u70B9_u6570" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点表示对形如 V = x * 2^y 的有理数进行编码，IEEE 标准 754 规定了如何表示浮点数及其运算。</p>
<blockquote>
<p>二进制小数</p>
</blockquote>
<p><img src="/images/csapp2.30.jpg" alt="csapp2.30"></p>
<p>增加二进制表示的长度可以提高表示的精度。</p>
<blockquote>
<p>IEEE 浮点表示</p>
</blockquote>
<p>用 V = (-1)^s * M * 2^E 的形式来表示一个数：</p>
<ul>
<li>符号(sign) s决定这个数是负数(s=1)还是正数(s=0)，对于数值 0 的符号位解释作为特殊情况处理。</li>
<li>尾数(significand) M 是一个二进制小数，它的范围是 1 ~ 2 - ε，或者是 0 ~ 1 - ε。</li>
<li>阶码(exponent) E 的作用是对浮点数加权，这个权重是 2 的 E 次幂(可能是负数)</li>
</ul>
<p>将浮点数的位表示划分为三个字段，分别对这些值进行编码：</p>
<ul>
<li>一个单独的符号位 s 直接编码符号 s。</li>
<li>k 位的阶码字段 exp = e(k-1)…e(1)e(0) 编码阶码 E。</li>
<li>n 位小数字段 frac = f(n-1)…f(1)f(0) 编码尾数 M，但是编码出来的值也依赖于阶码字段的值是否等于 0。</li>
</ul>
<p><img src="/images/csapp2.31.jpg" alt="csapp2.31"></p>
<p><img src="/images/csapp2.32.jpg" alt="csapp2.32"></p>
<blockquote>
<p>2.4.3 数字示例</p>
</blockquote>
<p><img src="/images/csapp2.33.jpg" alt="csapp2.33"></p>
<p><img src="/images/csapp2.34.jpg" alt="csapp2.34"></p>
<blockquote>
<p>2.4.4 舍入(rounding)</p>
</blockquote>
<p>因为表示方法限制类浮点数的范围和精度，浮点运算只能近似地表示实数运算。因此，对于值 x，我们一般想用一种系统的方法，能够找到“最接近的”匹配值，这就是舍入运算的任务。</p>
<blockquote>
<p>2.4.5 浮点运算</p>
</blockquote>
<p>浮点加法不具有结合性。浮点乘法在加法上不具备分配性。对于科学计算程序员和编译器编写者来说，这是很严重的问题，即使为了在三维空间中确定两条线是否交叉而写代码这样看上去很简单的任务，也可能成为一个很大的挑战。</p>
<blockquote>
<p>2.4.6 C 语言中的浮点数</p>
</blockquote>
<p>float 和 double。在 int、float 和 double 格式之间进行强制类型转换时，程序改变数值和位模式的原则如下(假设 int 是 32 位的)：</p>
<ul>
<li>从 int 转换成 float，不会溢出，可能被舍入。</li>
<li>从 int 或 float 转换成 double，能够保留精确的数值。</li>
<li>从 double 转换成 float，可能溢出成为正无穷或负无穷，也可能被舍入。</li>
<li>从 float 或者 double 转换成 int，值会向零舍入。例如 1.999 将被转换成 1。</li>
</ul>
<h2 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h2><p>计算机将信息按位编码，通常组织成字节序列。用不同的编码方式表示整数、实数和字符串。不同的计算机模型在编码数字和多字节数据中的字节排序时使用不同的约定。</p>
<p>由于编码的长度有限，与传统整数和实数运算想必，计算机运算具有完全不同的属性。当超出表示范围时，有限长度能够引起数值溢出。当浮点数非常接近于 0.0，从而转换成零时，也会瞎溢。</p>
<p>必须非常小心地使用浮点运算，因为浮点运算只有有限的范围和精度，而且不遵守普遍的算术属性，比如结合性。</p>
<h1 id="u7A0B_u5E8F_u7684_u673A_u5668_u7EA7_u8868_u793A"><a href="#u7A0B_u5E8F_u7684_u673A_u5668_u7EA7_u8868_u793A" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h1><p>计算机执行<strong>机器代码</strong>，用字节序列编码低级的操作，包括处理数据、管理存储器、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的原则、目标机器的指令集和操作系统遵循的规则，经过一系列的阶段产生机器代码。GCC C 语言汇编器以<strong>汇编代码</strong>的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后 GCC 调用<strong>汇编器</strong>和<strong>链接器</strong>，从而根据汇编代码生成可执行的机器代码。</p>
<h2 id="u5386_u53F2_u89C2_u70B9"><a href="#u5386_u53F2_u89C2_u70B9" class="headerlink" title="历史观点"></a>历史观点</h2><p>Intel 处理器系列俗称 x86，经历了一个长期的、不断进化的发展过程。</p>
<h2 id="u7A0B_u5E8F_u7F16_u7801"><a href="#u7A0B_u5E8F_u7F16_u7801" class="headerlink" title="程序编码"></a>程序编码</h2><p>假设一个 C 程序，有两个文件 p1.c 和 p2.c。我们在一台 IA32 机器上，用 Unix 命令行编译这些代码如下：</p>
<pre><code>unix&gt; gcc -O1 -o p p1.c p2.c
</code></pre><p>编译选项 -O1 告诉编译器使用第一级优化。使用更高级别的优化产生的代码会严重改变形式，以至于产生的机器代码和初始源代码之间的关系非常难以理解。实际中，从得到的程序性能方面考虑，第二级优化(-O2)被认为是较好的选择。</p>
<p>实际上 gcc 命令调用了一系列程序，将源代码转化成可执行代码。首先，<strong>C 预处理器</strong>扩展源代码，插入所有用 #include 命令指定的文件，并扩展所有用 #define 声明指定的宏。然后，<strong>编译器</strong>产生两个源代码的汇编代码，名字分别为 p1.s 和 p2.s。接下来，<strong>汇编器</strong>将汇编代码转化成二进制目标代码，文件名为 p1.o 和 p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入地址的全局值。最后，<strong>链接器</strong>将两个目标代码文件与实现库函数(例如 printf )的代码合并，并产生最终的可执行代码文件 p。</p>
<blockquote>
<p>机器级代码</p>
</blockquote>
<p>对于机器级变成来说，有两种抽象非常重要。第一种是机器级程序的格式和行为，定义为指<strong>令集体系结构(Instruction set architecture, ISA)</strong>，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。第二种抽象是，机器级程序使用的存储器地址是虚拟地址，提供的存储器模型看上去是一个非常大的字节数组。</p>
<p>在整个编译过程中，编译器会完成大部分的工作，将把用 C 语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。汇编代码非常接近于机器代码，与机器代码的二进制格式相比，汇编代码有一个主要特点，即它用可读性更好的文本格式来表示。能够理解汇编代码和它与原始的 C 代码的联系，是理解计算机如何执行程序的关键一步。</p>
<p>IA32 机器代码和原始的 C 代码差别非常大。一些通常对 C 语言程序员隐藏的处理器状态是可见的：</p>
<ul>
<li><strong>程序计数器</strong>(PC，用 %eip 表示)指示将要执行的下一条指令在存储器中的地址。</li>
<li>整数<strong>寄存器</strong>文件包含 8 个命名的位置，分别存储 32 位的值。这些寄存器可以存储地址(对应于 C 语言的指针)或证书数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器则用来保存临时数据。</li>
<li>条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化。</li>
<li>一组浮点寄存器存放浮点数据。</li>
</ul>
<p>汇编代码不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分指针和整数。</p>
<p>程序存储器(program memory)包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的存储器块。</p>
<p>一条指令只执行一个非常基本的操作。例如，将存放在寄存器中的两个数字相加，在存储器和寄存器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从而实现(像算术表达式求值、循环或过程调用和返回这样的)程序结构。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>假设我们写了一个 C 语言代码文件 code.c，内容如下：</p>
<pre><code>int accum = 0;

int sum(int x, int y){
    int t = x + y;
    accum += t;
    return t;
}
</code></pre><p>在命令行上使用 <code>-S</code> 选项，就能得到 C 语言编译器产生的汇编代码：</p>
<pre><code>unix&gt; gcc -O1 -S code.c
</code></pre><p>GCC 会运行编译器，产生一个汇编文件 code.s，但是不做其他进一步的工作。如果我们使用 <code>-c</code> 命令行选项，GCC 会编译并汇编该代码：</p>
<pre><code>unix&gt; gcc -O1 -c code.c
</code></pre><p>这就会产生目标代码文件 code.o，它是二进制格式，无法直接查看。机器实际执行的程序只是对一系列指令进行编码的字节序列。及其对产生这些指令的源代码几乎一无所知。</p>
<blockquote>
<p>关于格式的注释</p>
</blockquote>
<p>所有以 <code>.</code> 开头的行都是指导汇编器和链接器的命令，我们通常可以忽略这些行。</p>
<blockquote>
<p>数据格式</p>
</blockquote>
<p>由于是从 16 位体系结构扩展成 32 位的，Intel 用术语 word 表示 16 位数据类型。因此，称 32 位数为 double words，称 64 位数为 quad words。后面遇到的大多数指令都是对 word 或者 double words 操作的。</p>
<p><img src="/images/csapp3.1.jpg" alt="csapp3.1"></p>
<h2 id="u8BBF_u95EE_u4FE1_u606F"><a href="#u8BBF_u95EE_u4FE1_u606F" class="headerlink" title="访问信息"></a>访问信息</h2><p>一个 IA32 CPU 包含一组 8 个存储 32 位值的寄存器。这些寄存器用来存储整数数据和指针。它们的名字都以 %e 开头，不过它们都另有特殊的名字。</p>
<p><img src="/images/csapp3.2.jpg" alt="csapp3.2"></p>
<p>对前三个寄存器(%eax, %ecx, %edx)的保存和恢复惯例不同于接下来的三个寄存器(%ebx, %edi, %esi)。最后两个寄存器(%ebp, %esp)保存着指向程序栈中重要位置的指针。只有根据栈管理的标准惯例才能修改这两个寄存器中的值。</p>
<p>字节操作指令可以独立地读写前 4 个寄存器的 2 个低位字节。8086 中提供这样的特性是为了兼容 8008 和 8080。当一条字节指令更新这些单字节“寄存器元素”中的一个时，余下的 3 个字节不会改变。</p>
<blockquote>
<p>操作数指示符</p>
</blockquote>
<p>大多数指令有一个或多个<strong>操作数(operand)</strong>，指示出执行一个操作中要引用的源数据值，以及放置结果的目标位置。操作数可能被分为三种类型：</p>
<ol>
<li>立即数(immediate)，也就是常数值</li>
<li>寄存器(register)，表示某个寄存器的内容</li>
<li>存储器(memory)引用，它会根据计算出来的地址访问某个存储器位置</li>
</ol>
<p><img src="/images/csapp3.3.jpg" alt="csapp3.3"></p>
<blockquote>
<p>数据传送指令</p>
</blockquote>
<p>将数据从一个位置复制到另一个位置的指令是最频繁使用的指令。操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条指令才能完成的功能。</p>
<p><img src="/images/csapp3.4.jpg" alt="csapp3.4"></p>
<h2 id="u7B97_u672F_u548C_u903B_u8F91_u64CD_u4F5C"><a href="#u7B97_u672F_u548C_u903B_u8F91_u64CD_u4F5C" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h2><p>给出的每个指令类都有对字节、字和双字数据进行操作的指令。这些操作被分为四组：加载有效地址、亿元操作、二元操作和移位。</p>
<blockquote>
<p>加载有效地址</p>
</blockquote>
<p>加载有效地址(load effective address)指令 leal 实际上是 movl 指令的变形。它的指令形式是从存储器读数据到寄存器，但实际上它根本就没有引用存储器。它的第一个操作数看上去是一个存储器引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。</p>
<p><img src="/images/csapp3.7.jpg" alt="csapp3.7"></p>
<blockquote>
<p>一元操作和二元操作</p>
</blockquote>
<p>一元操作：一个操作数既是源又是目的</p>
<p>二元操作：第二个操作数既是源又是目的</p>
<blockquote>
<p>移位操作</p>
</blockquote>
<p>先给出移位量，第二项给出的是要移位的位数，可以进行算术和逻辑右移。</p>
<blockquote>
<p>讨论</p>
</blockquote>
<p><img src="/images/csapp3.8.jpg" alt="csapp3.8"></p>
<blockquote>
<p>特殊的算术操作</p>
</blockquote>
<p><img src="/images/csapp3.9.jpg" alt="csapp3.9"></p>
<h2 id="u63A7_u5236"><a href="#u63A7_u5236" class="headerlink" title="控制"></a>控制</h2><p>机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。</p>
<blockquote>
<p>条件码</p>
</blockquote>
<p>除了整数寄存器，CPU 还维护着一组单个 bit 的<strong>条件码(condition code)</strong> 寄存器，他们描述了最近的算术或逻辑操作的属性。</p>
<p><img src="/images/csapp0.4.jpg" alt="csapp0.4"></p>
<p><img src="/images/csapp3.10.jpg" alt="csapp3.10"></p>
<blockquote>
<p>访问条件码</p>
</blockquote>
<p>条件码通常不会直接读取，常用的使用方法有三种：</p>
<ol>
<li>可以根据条件码的某个组合，将一个字节设置为 0 或者 1</li>
<li>可以条件跳转到程序的某个其他的部分</li>
<li>可以有条件地传送数据</li>
</ol>
<p><img src="/images/csapp3.11.jpg" alt="csapp3.11"></p>
<blockquote>
<p>跳转指令及其编码</p>
</blockquote>
<p>跳转(jump)指令会导致执行切换到程序中的一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号(label)指明。</p>
<p><img src="/images/csapp3.12.jpg" alt="csapp3.12"></p>
<blockquote>
<p>翻译条件分支</p>
</blockquote>
<p>将条件表达式和语句从 C 语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转</p>
<p><img src="/images/csapp3.13.jpg" alt="csapp3.13"></p>
<blockquote>
<p>循环</p>
</blockquote>
<p>汇编中没有循环结构的指令存在，可以用条件测试和跳转组合起来实现循环的效果。大多数汇编器根据一个循环的 do-while形式来产生循环代码，即使在实际程序中这种形式用得相对较少。</p>
<p><img src="/images/csapp3.14.jpg" alt="csapp3.14"></p>
<p><img src="/images/csapp3.15.jpg" alt="csapp3.15"></p>
<blockquote>
<p>条件传送指令</p>
</blockquote>
<p>实现条件操作的传统方法是利用控制的条件转移。当条件满足时，程序沿着一条执行路径进行，反之走另一条路径。这种机制简单而通用，但是在现代处理器上，它可能会非常低效率。</p>
<p>数据的条件转移是一种替代的策略。这种方法先计算一个条件操作的两种结果，然后再根据条件是否满足从而选取一个。只有在一些受限制的情况下，这种策略才可行，但是如果可行，就可以用一条简单的条件传送指令来实现它。条件传送指令更好地匹配了现代处理器的性能特征。</p>
<p><img src="/images/csapp3.16.jpg" alt="csapp3.16"></p>
<p>这个机制和分支预测紧密相关。</p>
<p><img src="/images/csapp3.17.jpg" alt="csapp3.17"></p>
<blockquote>
<p>switch 语句</p>
</blockquote>
<p>switch 语句可以根据一个整数索引值进行多重分支(multi-way branching)。不仅提高了 C 代码的可读性，而且通过使用<strong>跳转表(jump table)</strong>和使用一组很长的 if-else 语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。GCC 根据开关情况的数量和开关情况值的 sprsity 来翻译开关语句。</p>
<p><img src="/images/csapp3.18.jpg" alt="csapp3.18"></p>
<h2 id="u8FC7_u7A0B"><a href="#u8FC7_u7A0B" class="headerlink" title="过程"></a>过程</h2><p>一个过程调用包括将数据和控制从代码的一部分传递到另一部分。另外，它还必须在进入时为过程的局部变量分配空间，并在退出时释放这些空间。大多数机器，包括 IA32，只提供转移控制到过程和从过程转移出控制这种简单的指令。数据传递、局部变量的分配和释放通过操纵程序栈来实现。</p>
<blockquote>
<p>栈帧结构</p>
</blockquote>
<p>IA32 程序用程序栈来支持过程调用。机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后回复，以及本地存储。为单个过程分配的那部分栈称为<strong>栈帧(stack frame)</strong>。</p>
<p><img src="/images/csapp3.21.jpg" alt="csapp3.21"></p>
<p>假设过程 P(调用者)调用过程 Q(被调用者)，则 Q 的参数放在 P 的栈帧中。另外，当 P 调用 Q 时，P 中的<strong>返回地址</strong>被压入栈中，形成 P 的栈帧的末尾。返回地址就是当程序从 Q 返回时应该继续执行的地方。</p>
<blockquote>
<p>转移控制</p>
</blockquote>
<p><img src="/images/csapp3.22.jpg" alt="csapp3.22"></p>
<blockquote>
<p>寄存器使用惯例</p>
</blockquote>
<p>程序寄存器组是唯一能够被所有过程共享的资源。虽然在给定时刻只能有一个过程是活动的，但是我们必须保证当一个过程调用另一个过程时，被调用者不会覆盖某个调用者稍后会使用的寄存器的值。</p>
<p>根据惯例，寄存器 %eax、%edx、%ecx 被划分为<strong>调用者保存</strong>寄存器。当过程 P 调用 Q 时，Q 可以覆盖这些寄存器，而不会破坏任何 P 所需要的数据。另一方面， 寄存器 %ebx、%esi、%edi 被划分为<strong>被调用者保存</strong>寄存器。</p>
<blockquote>
<p>过程示例</p>
</blockquote>
<p><img src="/images/csapp3.24.jpg" alt="csapp3.24"></p>
<blockquote>
<p>递归过程</p>
</blockquote>
<p><img src="/images/csapp3.25.jpg" alt="csapp3.25"></p>
<p><img src="/images/csapp3.27.jpg" alt="csapp3.27"></p>
<h2 id="u6570_u7EC4_u5206_u914D_u548C_u8BBF_u95EE"><a href="#u6570_u7EC4_u5206_u914D_u548C_u8BBF_u95EE" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h2><p>C 语言实现数组的方式非常简单，因此很容易翻译成机器代码。C 语言一个不同寻常的特点是可以产生指向数组中元素的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译成地址计算。</p>
<p>优化编译器非常善于简化数组索引所使用的地址计算。不过这使得 C 代码和它机器代码的翻译之间的对应关系有些难以理解。</p>
<blockquote>
<p>基本原则</p>
</blockquote>
<p>对于数据类型 T 和整型常数 N，声明如下：</p>
<pre><code>T A[N];
</code></pre><p>它有两个效果。首先，它在存储器中分配一个 L*N 字节的连续区域；这里 L 是数据类型 T 的大小(单位为字节)。可以用从 0 到 N-1 之间的整数索引来访问数组元素。数组元素 i 会被存放在地址为 xa + L * i 的地方(xa 为指向数组开头的指针)</p>
<p><img src="/images/csapp0.5.jpg" alt="csapp0.5"></p>
<blockquote>
<p>指针运算</p>
</blockquote>
<p>C 语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。也就是说，如果 p 是一个指向类型为 T 的数据的指针，p 的值为 xp，那么表达式 p+i 的值为 xp+L*i，这里 L 是数据类型 T 的大小。</p>
<p><img src="/images/csapp0.6.jpg" alt="csapp0.6"></p>
<blockquote>
<p>嵌套的数组</p>
</blockquote>
<pre><code>int A[5][3];
</code></pre><p>等价于下面的声明</p>
<pre><code>typedef int row3_t[3];
row3_t A[5];
</code></pre><p>数据类型<code>row3_t</code>被定义为一个 3 个整数的数组。数组 A 包含 5 个这样的元素，每个元素需要 12 个字节来存储 3 个整数。整个数组的大小就是 4x5x3=60 字节。</p>
<p><img src="/images/csapp0.7.jpg" alt="csapp0.7"></p>
<blockquote>
<p>定长数组</p>
</blockquote>
<p>C 语言编译器能够优化定长多维数组上的操作代码。</p>
<p><img src="/images/csapp3.28.jpg" alt="csapp3.28"></p>
<blockquote>
<p>变长数组</p>
</blockquote>
<p><img src="/images/csapp3.29.jpg" alt="csapp3.29"></p>
<h2 id="u5F02_u8D28_u7684_u6570_u636E_u7ED3_u6784"><a href="#u5F02_u8D28_u7684_u6570_u636E_u7ED3_u6784" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h2><p>C 语言提供了两种结合不同类型的对象来创建数据类型的机制：<strong>结构(structure)</strong>，用关键字<code>struct</code>声明，将多个对象集合到一个单位中；<strong>联合(union)</strong>，用关键字<code>union</code>声明，允许用几种不同的类型来引用一个对象。</p>
<blockquote>
<p>结构</p>
</blockquote>
<p>创建一个数据类型，将可能不同类型的对象聚合到一个对象中。结构的各个组成部分用名字来引用。类似于数组的实现，结构的所有组成部分都存放在存储器中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段(field)的字节偏移。它以这些偏移作为存储器引用指令中的位移，从而产生对结构元素的引用。</p>
<blockquote>
<p>联合</p>
</blockquote>
<p>提供了一种方式，能够规避 C 语言的类型系统，允许以多种类型来引用一个对象。联合声明的语法与结构的语法一样，只不过语义相差比较大。它们是用不同的字段来引用相同的存储器块。</p>
<blockquote>
<p>数据对齐</p>
</blockquote>
<p>许多计算机系统对基本数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是某个值 K(通常是 2、4、8)。这种对齐限制简化了形成处理器和存储器系统之间接口的硬件设计</p>
<p><strong>强制对齐的情况</strong></p>
<p>对于大多数 IA32 指令来说，保持数据对齐能够提高效率，但是它不会影响程序的行为。另一方面，如果数据未对齐，有些实现多媒体操作的 SSE 指令就无法正确工作。</p>
<h2 id="u7EFC_u5408_uFF1A_u7406_u89E3_u6307_u9488"><a href="#u7EFC_u5408_uFF1A_u7406_u89E3_u6307_u9488" class="headerlink" title="综合：理解指针"></a>综合：理解指针</h2><p>指针是 C 语言的一个重要特征。它们以一种统一方式，对不同数据结构中的元素产生引用。这里介绍一些指针和它们映射到机器代码的关键原则。</p>
<ul>
<li><strong>每个指针都对应一个类型。</strong>这个类型表明指针指向哪一类对象。</li>
<li><strong>每个指针都有一个值。</strong>这个值是某个指定类型对象的地址。特殊的 NULL(0) 值表示该指针没有指向任何地方</li>
<li><strong>指针用 &amp; 运算符创建。</strong>这个运算符可以应用到任何 lvalue 类的 C 表达式上。</li>
<li><strong>操作符用于指针的间接引用。</strong>其结果是一个值，它的类型与该指针的类型相关。间接引用是通过存储器引用来实现的，要么是存储到一个指定的地址，要么是从指定的地址读取。</li>
<li><strong>数组与指针紧密联系。</strong>一个数组的名字可以像一个指针变量一样引用(但是不能修改)。数组引用与指针运算和间接引用有一样的效果。数组引用和指针运算都需要用对象大小对偏移量进行伸缩。</li>
<li><strong>将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。</strong>强制类型转换的一个效果是改变指针运算的伸缩。来看一个例子，如果 p 是一个 char* 类型的指针，那么表达式(int<em>)p+7 计算为 p+28, 而(int</em>)(p+7)计算为 p+7。</li>
<li>指针也可以指向函数。这提供了一个很强大的存储和向代码传递引用的功能，这些引用可以被程序的某个其他部分调用。</li>
</ul>
<p><strong>函数指针</strong></p>
<p>假如我们有一个函数<code>int fun(int x, int *p)</code>，然后我们可以声明一个指针<code>fp</code>，将它赋值为这个函数：</p>
<pre><code>(int)(*fp)(int, int *);
fp = fun;
</code></pre><p>然后用以下真真来调用这个函数</p>
<pre><code>int y = 1;
int result = fp(3, &amp;y);
</code></pre><h2 id="u5E94_u7528_uFF1A_u4F7F_u7528_GDB__u8C03_u8BD5_u5668"><a href="#u5E94_u7528_uFF1A_u4F7F_u7528_GDB__u8C03_u8BD5_u5668" class="headerlink" title="应用：使用 GDB 调试器"></a>应用：使用 GDB 调试器</h2><p>启动 GDB:</p>
<pre><code>unix&gt; gdb prog
</code></pre><h2 id="u5B58_u50A8_u5668_u7684_u8D8A_u754C_u5F15_u7528_u548C_u7F13_u51B2_u533A_u6EA2_u51FA"><a href="#u5B58_u50A8_u5668_u7684_u8D8A_u754C_u5F15_u7528_u548C_u7F13_u51B2_u533A_u6EA2_u51FA" class="headerlink" title="存储器的越界引用和缓冲区溢出"></a>存储器的越界引用和缓冲区溢出</h2><p>C 对于数组引用不进行任何边界检查，而局部变量和状态信息，都存放在栈中。这两种情况结合到一起就可能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行 ret 指令时，就会出现很严重的错误。</p>
<p>缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击系统安全的方法。通常，输入和程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为**攻击代码(exploit code)，另外还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么执行 ret 指令的效果就是跳转到攻击代码。</p>
<p>一种攻击形式，攻击代码会使用系统调用启动一个外壳程序，给攻击者提供一组操作系统函数。另一种攻击形式是，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行 ret 指令，(表面上)正常返回给调用者。</p>
<p><strong>对抗缓冲区溢出攻击</strong></p>
<p>1.<strong>栈随机化</strong></p>
<p>为了在系统中插入攻击代码，攻击者不但要插入代码，还需要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。在过去，程序的栈地址非常容易预测。对于所有运行同样程序和操作系统版本的系统来说，在不同的机器之间，栈的位置是相当固定的。用传染病来打比方，许多系统都容易受到同一种病毒的攻击，这种现象常称作<strong>安全单一化(security monoculture)</strong>。</p>
<p><strong>栈随机化</strong>的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。实现的方式是：程序开始时，在栈上分配一段 0-n 字节之间的随机大小的空间。</p>
<p>在 Linux 系统中，栈随机化已经变成了标准行为。它是更大一类技术中的一种，这类技术称为**地址空间布局随机化(Address-Space Layout Randomization)，或者简称 ASLR。</p>
<p>然而一个执着的攻击者总是能够用蛮力克服随机化，他可以反复地用不同的地址进行攻击。一种常见的把戏就是在实际的攻击代码前插入很长一段的 nop 指令。执行这种指令除了对程序计数器加一，使指针指向下一条指令之外，没有任何的效果。只要攻击者能够猜中这段序列中的某个地址，程序就会经过这个序列，到达攻击代码。这个序列常用的术语是“空操作雪橇”(nop sled)。</p>
<p>2.<strong>栈破坏检测</strong></p>
<p><strong>栈保护者(stack protector)</strong>机制，用来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的<strong>金丝雀(canary)</strong>值，也称为<strong>哨兵值(guard value)</strong>，如下图所示。这个值是在程序每次运行时随机产生的，因此，攻击者没有简单的办法能够知道它是什么。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个函数的某个操作改变了。如果是，那么程序异常终止。</p>
<p>3.限制可执行代码区域</p>
<p>消除攻击者向系统中插入可执行代码的能力，只有保存编译器产生的代码的那部分妇女初期才是可执行的，其他部分可以被限制为只允许读和写</p>
<p><img src="/images/csapp3.33.jpg" alt="csapp3.33"></p>
<h2 id="x86-64_3A__u5C06_IA32__u6269_u5C55_u5230_64__u4F4D"><a href="#x86-64_3A__u5C06_IA32__u6269_u5C55_u5230_64__u4F4D" class="headerlink" title="x86-64: 将 IA32 扩展到 64 位"></a>x86-64: 将 IA32 扩展到 64 位</h2><p>IA32 的 32 位字长已经成为限制微处理器能力不断增长的主要因素。最重要的是，机器的字长定义了程序能够使用的虚拟地址范围，32 位字长就是 4GB 虚拟地址空间。现在机器很容易就可以配置 4G 以上 RAM，但是系统却不能有效利用它。</p>
<p>Intel 和 AMD 提供的新硬件和以这些为目标的 GCC 新版本的组合，使得 x86-64 代码与为 IA32 机器生成的代码有极大的不同。主要特性如下：</p>
<ul>
<li>指针和长整数是 64 位长。整数运算支持 8/16/32/64 位数据类型</li>
<li>通用目的寄存器组从 8 个扩展到 16 个</li>
<li>许多程序状态都保存在寄存器中，而不是栈上</li>
<li>如果可能，条件操作用条件传送指令实现，会得到比传统分支代码更好的性能</li>
<li>浮点操作用面向寄存器的指令集来实现</li>
</ul>
<p><img src="/images/csapp3.34.jpg" alt="csapp3.34"></p>
<h2 id="u6D6E_u70B9_u7A0B_u5E8F_u7684_u673A_u5668_u7EA7_u8868_u793A"><a href="#u6D6E_u70B9_u7A0B_u5E8F_u7684_u673A_u5668_u7EA7_u8868_u793A" class="headerlink" title="浮点程序的机器级表示"></a>浮点程序的机器级表示</h2><p>我们把存储模型、指令和传递规则的组合称为机器的<strong>浮点体系结构</strong>。由于 x86 处理器有很长的发展演变历史，它提供了多种浮点体系结构，目前有两种还在使用：x87 和 SSE</p>
<h2 id="u5C0F_u7ED3-1"><a href="#u5C0F_u7ED3-1" class="headerlink" title="小结"></a>小结</h2><p>机器级程序和它们的汇编代码表示，与 C 程序的差别很大。在汇编语言程序中，各种数据类型之间的差别很小。程序是以指令序列来表示的，每条指令都完成一个单独的操作。部分程序状态，如寄存器和运行时栈，对程序员来说是直接可见的。</p>
<p>C 语言中缺乏边界检查，使得许多程序容易出现缓冲区溢出。虽然最近的运行时系统提供了安全保护，而且编译器帮助使得程序更加安全，但是这已经使许多系统容易收到入侵者的恶意攻击。</p>
<h1 id="u5904_u7406_u5668_u4F53_u7CFB_u7ED3_u6784"><a href="#u5904_u7406_u5668_u4F53_u7CFB_u7ED3_u6784" class="headerlink" title="处理器体系结构"></a>处理器体系结构</h1><p>现代微处理器可以称得上时人类创造的最复杂的系统之一。一个处理器支持的指令和指令的字节级编码称为它的<strong>指令集体系结构(Instruction-Set Architecture, ISA)</strong>。不同的处理器家族，有不同的 ISA。一个程序编译成在一种机器上运行。</p>
<p>注：这一章偏硬件实现部分将较为简略，具体参看原书。</p>
<h2 id="Y86__u6307_u4EE4_u96C6_u4F53_u7CFB_u7ED3_u6784"><a href="#Y86__u6307_u4EE4_u96C6_u4F53_u7CFB_u7ED3_u6784" class="headerlink" title="Y86 指令集体系结构"></a>Y86 指令集体系结构</h2><p>定义一个指令集体系结构，包括定义各种状态元素、指令集和它们的编码、一组编程规范和异常事件处理。</p>
<blockquote>
<p>程序员可见的状态</p>
</blockquote>
<p>如下图所示，Y86 程序中的每条指令都会读取或修改处理器状态的某些部分，这称为<strong>程序员可见状态</strong>。在处理器视线中，只要我们保证机器级程序能够访问程序员可见状态，就不需要完全按照 ISA 隐含的方式来表示和组织这个处理器状态。</p>
<p><img src="/images/csapp4.1.jpg" alt="csapp4.1"></p>
<p>Y86 处理器有 8 个程序寄存器(每个存储一个字，%esp 被入栈、出栈、调用和返回指令作为栈指针)，3 个一位的条件码(保存最近的算术或逻辑指令所造成影响的有关信息)，程序计数器 PC 存放当前正在执行指令的地址。</p>
<p>存储器，从概念上说就是一个很大的数组，保存这程序和数据。 Y86 程序使用<strong>虚拟地址</strong>来引用存储器位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或<strong>物理地址</strong>，指明数据实际保存在存储器中的哪个地方。</p>
<p>状态码 Stat 表明程序执行的总体状态，它会指示是正常运行，还是出现了某种异常。</p>
<blockquote>
<p>Y86 指令</p>
</blockquote>
<p><img src="/images/csapp4.2.jpg" alt="csapp4.2"></p>
<p>具体说明</p>
<ul>
<li>4 个 movl 相关指令，显式指明源和目的的格式。源可以是立即数(i)、寄存器(r)或存储器(m)。指令名字的第一个字母表明了源的类型，第二个字母指明了目的类型</li>
<li>4 个整数操作指令，即上图的 OPl，它们是 addl、subl、andl 和 xorl。它们只对寄存器数据进行操作，并设置 3 个条件码 ZF、SF 和 OF(零、符号和一处)</li>
<li>7 个跳转指令，即上图的 jXX，它们是 jmp、jle、jl、je、jne、jge 和 jg。根据分支指令的类型和条件码的设置来选择分支</li>
<li>6 个条件传送指令，即上图的 cmovXX：cmovle、cmovl、cmove、cmovne、cmovge 和 cmovg，只有当条件码满足所需要的约束时，才会更新目的寄存器的值</li>
<li>call 指令将返回地址入栈，然后跳到目的地址。ret 指令从这样的过程调用中返回</li>
<li>pushl 和 popl 指令实现了入栈和出栈</li>
<li>halt 指令停止指令的执行</li>
</ul>
<blockquote>
<p>指令编码</p>
</blockquote>
<p>每条指令需要 1~6 个字节不等，每条指令的第一个字节表明指令的类型。这个字节分为两个部分，每部分 4 位：高 4 位是<strong>代码(code)</strong>部分，低 4 位是<strong>功能(function)部分</strong>。</p>
<p><img src="/images/csapp4.3.jpg" alt="csapp4.3"></p>
<p>CISC vs RISC</p>
<p><img src="/images/csapp0.8.jpg" alt="csapp0.8"></p>
<h2 id="u903B_u8F91_u8BBE_u8BA1_u548C_u786C_u4EF6_u63A7_u5236_u8BED_u8A00_HCL"><a href="#u903B_u8F91_u8BBE_u8BA1_u548C_u786C_u4EF6_u63A7_u5236_u8BED_u8A00_HCL" class="headerlink" title="逻辑设计和硬件控制语言 HCL"></a>逻辑设计和硬件控制语言 HCL</h2><p>在硬件设计中，用电子电路来计算来计算对位进行运算的函数，以及在各种存储器元素中存储位。大多数现代电路技术都用信号线上的高电压或低电压来表示不同的位值。</p>
<blockquote>
<p>逻辑门</p>
</blockquote>
<p>逻辑门是数字电路的基本计算元素。它们产生的输出，等于它们输入位值的某个布尔函数。</p>
<blockquote>
<p>组合电路和 HCL 布尔表达式</p>
</blockquote>
<p>将很多的逻辑门组合成一个网，就能构建计算块(computational block)，称为<strong>组合电路(combinational circuits)</strong>。构建这些网有两条限制：</p>
<ul>
<li>两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障</li>
<li>这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的回路会导致该网络计算的函数有歧义。</li>
</ul>
<blockquote>
<p>字级的组合电路和 HCL 整数表达式</p>
</blockquote>
<p>通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。</p>
<h2 id="Y86__u7684_u987A_u5E8F_u5B9E_u73B0"><a href="#Y86__u7684_u987A_u5E8F_u5B9E_u73B0" class="headerlink" title="Y86 的顺序实现"></a>Y86 的顺序实现</h2><p>将处理组织成阶段</p>
<p>取指(fetch)、译码(decode)、执行(execute)、访存(memory)、写回(write back)、更新 PC(PC update)</p>
<h2 id="u6D41_u6C34_u7EBF_u7684_u901A_u7528_u539F_u7406"><a href="#u6D41_u6C34_u7EBF_u7684_u901A_u7528_u539F_u7406" class="headerlink" title="流水线的通用原理"></a>流水线的通用原理</h2><p>参考 Foundation of Computer Architecture，此略</p>
<h2 id="u5C0F_u7ED3-2"><a href="#u5C0F_u7ED3-2" class="headerlink" title="小结"></a>小结</h2><p>有关处理器设计的几个重要经验：</p>
<ul>
<li>管理复杂性是首要问题。想要优化使用硬件资源，在最小的成本下获得最大的性能</li>
<li>我们不需要直接实现 ISA</li>
<li>硬件设计人员必须非常谨慎小心</li>
</ul>
<h1 id="u4F18_u5316_u7A0B_u5E8F_u6027_u80FD"><a href="#u4F18_u5316_u7A0B_u5E8F_u6027_u80FD" class="headerlink" title="优化程序性能"></a>优化程序性能</h1><blockquote>
<p>你能获得的对程序最大的加速比就是当你第一次让它工作起来的时候。 —— John K.Ousterhout</p>
</blockquote>
<p>写程序最主要的目标就是使它在所有可能的情况下都正确工作。程序员必须写出清晰简洁的代码，这样做不仅是为了程序员能够看懂代码，也是为了在检查代码和今后需要修改代码时，其他人能够读懂和理解代码。</p>
<p>编写高效程序需要几类活动：第一，我们必须选择一组合适的算法和数据结构。第二，我们必须编写出编译器能够有效优化以转换成搞笑可执行代码的源代码。对于第二点，理解优化编译器的能力和局限性是很重要的。</p>
<p>在程序开发和优化的过程中，我们必须考虑代码使用的方式，以及影响它的关键因素。通常，程序员必须在实现和维护程序的简单性与它的运行速度之间做出权衡。</p>
<p>程序优化的第一步就是消除不必要的内容，让代码尽可能有效地执行它期望的工作。这包括消除不必要的函数调用、条件测试和存储器引用。这些优化不依赖于目标机器的任何具体属性。</p>
<p>研究程序的汇编代码表示，是理解编译器，以及产生的代码如何运行的最有效的手段之一。仔细研究内循环的代码是一个很好的开端。</p>
<h2 id="u4F18_u5316_u7F16_u8BD1_u5668_u7684_u80FD_u529B_u548C_u5C40_u9650_u6027"><a href="#u4F18_u5316_u7F16_u8BD1_u5668_u7684_u80FD_u529B_u548C_u5C40_u9650_u6027" class="headerlink" title="优化编译器的能力和局限性"></a>优化编译器的能力和局限性</h2><p>现代编译器运用复杂精细的算法来确定一个程序中计算的是什么值，以及它们是被如何使用的。然后它们会利用一些机会来简化表达式，在几个不同的地方使用同一个计算，以及降低一个给定的计算必须被执行的次数。</p>
<p>限制编译器只进行安全的优化，消除了一些造成不希望的运行时行为的可能原因，但这也意味着程序员必须花费更大的力气写出程序使编译器能够将之转换成有效机器代码。请看下面这个例子</p>
<pre><code>void twiddle1(int *xp, int *yp){
    *xp += *yp;
    *xp += *yp;
}

void twiddle2(int *xp, int *yp){
    *xp += 2* *yp
}
</code></pre><p>初看这两个函数似乎有相同的行为，都是将存储在由指针 yp 指示的位置除的值两次加到指针 xp 指示的位置处的值。另一方面，函数 twiddle2 的效率更高一些，它只要求 3 次存储器引用(读 <code>*xp</code>，读 <code>*yp</code>，写 <code>*xp</code>)，而 twiddle1 需要 6 次。不过，当 xp 等于 yp 时，这两个函数的执行结果则会不一致，twiddle1 使 xp 的值增加 4 倍，而 twiddle2 则是 3 倍，因此，编译器不能产生 twiddle2 风格的代码作为 twiddle1 的优化版本。</p>
<p>这种两个指针可能指向同一个存储器位置的情况称为<strong>存储器别名使用(memory aliasing)</strong>。在只执行安全的优化中，编译器必须假设不同的指针可能会指向存储器中同一个位置。</p>
<p>第二个妨碍优化的因素是函数调用，例如：</p>
<pre><code>int f();

int func1(){
    return f() + f() + f() + f();
}

int func2(){
    return 4*f();
}
</code></pre><p>最初看上去两个过程计算都是相同的结果，但是 func2 只调用 f1 一次，比 func2 的四次要好。不过，考虑下面 f 的代码：</p>
<pre><code>int counter = 0;

int f(){
    return counter++;
}
</code></pre><p>这个函数有个副作用——它修改了全局程序状态的一部分。改变调用它的次数会改变程序的行为。所以，编译器会假设最早的情况，并保持所有函数调用不变。</p>
<h2 id="u8868_u793A_u7A0B_u5E8F_u6027_u80FD"><a href="#u8868_u793A_u7A0B_u5E8F_u6027_u80FD" class="headerlink" title="表示程序性能"></a>表示程序性能</h2><p>我们引入度量标准<strong>每元素的周期数(Cycles Per Element, CPE)</strong>作为一种表示性能并指导我们改进代码的方法。处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用<strong>千兆赫兹(GHz)</strong>，即十亿周期每秒来表示。CPE 越小越好。</p>
<p>许多过程含有在一组元素上迭代的循环。如下图中的函数 psum1 和 psum2 计算都是一个长度为 n 的向量的前置和(prefix sum)，对于向量 a={a0,a1,…,an-1}，前置和 p={p0,p1,…pn-1}定义为</p>
<pre><code>p0 = a0
pi = pi-1 + ai, 1&lt;= i &lt; n
</code></pre><p>函数 psum1 每次迭代计算结果向量的一个元素，第二个函数使用<strong>循环展开(loop unrolling)</strong>的技术，每次迭代计算两个元素。</p>
<p><img src="/images/csapp5.1.jpg" alt="csapp5.1"></p>
<p>我们发现，psum1 和 psum2 的运行时间(以时钟周期为单位)分辨近似于等式 496+10.0n 和 500+6.5n。</p>
<p><img src="/images/csapp5.2.jpg" alt="csapp5.2"></p>
<h2 id="u7A0B_u5E8F_u793A_u4F8B"><a href="#u7A0B_u5E8F_u793A_u4F8B" class="headerlink" title="程序示例"></a>程序示例</h2><p>考虑如下图所示的简单向量数据结构，由两个存储器块表示：头部和数据数组。头部是一个声明如下的结构</p>
<p><img src="/images/csapp5.3.jpg" alt="csapp5.3"></p>
<p>这个声明用数据类型 data_t 作为基本元素的数据类型。例如 <code>typedef int data_t</code>。</p>
<p><img src="/images/csapp5.4.jpg" alt="csapp5.4"></p>
<p>对向量元素求和</p>
<pre><code>#define IDENT 0
#define OP +
</code></pre><p>对向量元素求积</p>
<pre><code>#define IDENT 1
#define OP *
</code></pre><p><img src="/images/csapp5.5.jpg" alt="csapp5.5"></p>
<p>我们会进行一组变换，发现有很多智能带来很小的性能提高，而其他的能带来更巨大的效果。确定该使用哪些变换的组合确实是编写快速代码的魔术(black art)。</p>
<p>未经优化的代码是从 C 语言代码到机器代码的直接翻译，通常有明显的低效率。简单地使用命令行选项 <code>-O1</code>，就会进行一些基本的优化，可以显著提高性能。</p>
<h2 id="u6D88_u9664_u5FAA_u73AF_u7684_u4F4E_u6548_u7387"><a href="#u6D88_u9664_u5FAA_u73AF_u7684_u4F4E_u6548_u7387" class="headerlink" title="消除循环的低效率"></a>消除循环的低效率</h2><p>可以观察到，过程 combine1 调用函数 <code>vec_length</code> 作为 for 循环的测试条件。我们其实可以只计算一次向量的长度，然后在我们的测试条件中都使用这个值。如下图所示：</p>
<p><img src="/images/csapp5.6.jpg" alt="csapp5.6"></p>
<p>这个优化是一类常见的优化的一个例子，称为<strong>代码移动(code motion)</strong>。这类优化包括识别要执行多次(例如在循环里)但是计算结果不会改变的计算。因而可以将计算移动到代码前面不会被多次求值的部分。</p>
<p>编程时一个常见的问题就是一个看上去无足轻重的代码片段有隐藏的渐进低效率(asymptotic inefficiency)</p>
<h2 id="u51CF_u5C11_u8FC7_u7A0B_u8C03_u7528"><a href="#u51CF_u5C11_u8FC7_u7A0B_u8C03_u7528" class="headerlink" title="减少过程调用"></a>减少过程调用</h2><p>过程调用会代码相当大的开销，而且妨碍大多数形式的程序优化。从上图可以看出，每次循环迭代都会调用 <code>get_vec_element</code> 来获取下一个向量元素。我们可以直接访问数组，而不是利用函数调用并加上边界检查：</p>
<p><img src="/images/csapp5.9.jpg" alt="csapp5.9"></p>
<h2 id="u6D88_u9664_u4E0D_u5FC5_u8981_u7684_u5B58_u50A8_u5668_u5F15_u7528"><a href="#u6D88_u9664_u4E0D_u5FC5_u8981_u7684_u5B58_u50A8_u5668_u5F15_u7528" class="headerlink" title="消除不必要的存储器引用"></a>消除不必要的存储器引用</h2><p>累加过程中其实没有必要每次都把结果写入到 dest 中，可以使用一个临时变量，消除不必要的存储器引用：</p>
<p><img src="/images/csapp5.10.jpg" alt="csapp5.10"></p>
<h2 id="u7406_u89E3_u73B0_u4EE3_u5904_u7406_u5668"><a href="#u7406_u89E3_u73B0_u4EE3_u5904_u7406_u5668" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h2><p>要想获得充分提高的性能，需要仔细地分析程序，同时代码的生成也要针对目标处理器进行调整。由于可以将大量的晶体管继承到一块新品啊上，现代微处理器采用了复杂的硬件，试图使程序性能最大化。带来的一个后果就是处理器的实际操作与观察机器级程序锁察觉到的大相径庭。在代码级上，看上去似乎是一次执行一条指令，每条指令都包括从寄存器或存储器取值，执行一个操作，并把结果存回到一个寄存器或存储器位置。在实际的处理器中，是同时对多条指令求值，这个现象称为<strong>指令级并行</strong>。现代微处理器取得的了不起的功绩之一是：它们采用复杂而奇异的微处理器结构，其中，多条指令可以并行地执行，同时又呈现一种简单地顺序执行指令的表象。</p>
<p>两种下界描述了程序的最大性能。当一系列操作必须按照严格顺序执行时，就会遇到<strong>延迟界限(latency bound)</strong>，因为在下一条指令开始之前，这条指令必须结束。当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限定程序性能。<strong>吞吐量界限(throughput bound)</strong>刻画了处理器功能单元的原始计算能力。这个界限是程序性能的终极限制。</p>
<blockquote>
<p>整体操作</p>
</blockquote>
<p>Nehalem 微体系结构是 20 世纪 90 年代以来，许多制造商生产的典型的高端处理器。在工业界称为超标量(superscalar)，意思是可以在每个时钟周期执行多个操作，而且是乱序的(out-of-order)，意思就是指令执行的顺序不一定要与它们在机器级程序中的顺序一致。整个设计有两个主要部分：指令控制单元(Instruction Control Unit, ICU)和执行单元(Execution Unit, EU)。前者负责从存储器中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作；而后执行这些操作。</p>
<p>ICU 从指令高速缓存(instruction cache)中读取指令。指令高速缓存是一个特殊的高速缓存存储器，它包含最近访问的指令。通常，ICU 会在当前正在的指令很早之前取指，这样它才有足够的时间对指令译码，并把操作发送到 EU。不过，一个问题是党程序遇到分支时，程序有两个可能的前进方向。一种可能会选择分支，控制被传递到分支目标。另一种可能是，不选择分支，控制被传递到指令序列的下一条指令。现代处理器采用了一种称为<strong>分支预测(branch prediction)</strong>的技术<strong>，处理区会猜测是否会选择分支，同时还预测分支的目标地址。使用</strong>投机执行(speculative execution)**的技术，处理器会开始取出位于它预测的分支会跳到的地方的指令，并对指令译码，甚至在它确定分支预测是否正确之前就开始执行这些操作。如果过后确定分支预测错误，会将状态重新设置到分支点的状态，并开始取出和执行另一个方向上的指令。</p>
<blockquote>
<p>功能单元的特性</p>
</blockquote>
<p>每个运算都是由两个周期计数值来刻画的：一个是延迟(latency)，它表示完成运算所需要的总时间；另一个是发射时间(issue time)，它表示两个连续的同类型运算之间需要的最小时钟周期数。随着字长的增加，对于更复杂的数据类型，对于更复杂的运算，延迟也会增加。</p>
<blockquote>
<p>处理器操作的抽象模型</p>
</blockquote>
<p>我们会使用程序的数据流(data-flow)表示，作为分析在现代处理器上执行的机器级程序性能的一个工具，这是一种图形化的表示方法，展现了不同操作之间的数据相关是如何限制它们的执行顺序的。这种限制形成了图中的<strong>关键路径(critical path)</strong>，这是执行一组机器指令所需时钟周期数的一个下界。</p>
<h2 id="u5FAA_u73AF_u5C55_u5F00"><a href="#u5FAA_u73AF_u5C55_u5F00" class="headerlink" title="循环展开"></a>循环展开</h2><p>循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。循环展开能够从两个方面改善程序的性能。首先，它减少了不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支。其次，它提供了一些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。</p>
<h2 id="u63D0_u9AD8_u5E76_u884C_u6027"><a href="#u63D0_u9AD8_u5E76_u884C_u6027" class="headerlink" title="提高并行性"></a>提高并行性</h2><p>对于一个可结合和可交互的合并运算来说，比如说整数加法或乘法，我们可以通过将一组合并运算分割成两个或更多的部分，并在最后合并结果来提高性能。</p>
<h2 id="u4E00_u4E9B_u9650_u5236_u56E0_u7D20"><a href="#u4E00_u4E9B_u9650_u5236_u56E0_u7D20" class="headerlink" title="一些限制因素"></a>一些限制因素</h2><ul>
<li>寄存器溢出</li>
<li>分支预测和预测错误处罚</li>
</ul>
<p>通用原则：</p>
<ul>
<li>不要过分关心可预测的分支</li>
<li>书写适合用条件传送实现的代码</li>
</ul>
<p><img src="/images/csapp0.9.jpg" alt="csapp0.9"></p>
<h2 id="u7406_u89E3_u5B58_u50A8_u5668_u6027_u80FD"><a href="#u7406_u89E3_u5B58_u50A8_u5668_u6027_u80FD" class="headerlink" title="理解存储器性能"></a>理解存储器性能</h2><p>现代处理器有专门的功能单元来执行加载和存储操作，这些单元有内部的缓冲区来保存未完成的存储器操作请求集合。</p>
<blockquote>
<p>加载的性能</p>
</blockquote>
<p>一个包含加载操作的程序的性能既依赖于流水线的能力，也依赖于加载单元的延迟</p>
<blockquote>
<p>存储的性能</p>
</blockquote>
<p>存储操作将一个寄存器值写到存储器。</p>
<h2 id="u5E94_u7528_uFF1A_u6027_u80FD_u63D0_u9AD8_u6280_u672F"><a href="#u5E94_u7528_uFF1A_u6027_u80FD_u63D0_u9AD8_u6280_u672F" class="headerlink" title="应用：性能提高技术"></a>应用：性能提高技术</h2><ol>
<li>高级设计。为遇到的问题选择适当的算法和数据结构。要特别警觉，避免使用那些会渐进地产生糟糕性能的算法或编码技术。</li>
<li>基本编码原则。避免限制优化的因素，这样编译器就能产生高效的代码。<ul>
<li>消除连续的函数调用。在可能时，将计算移到循环外。考虑有选择地拖鞋程序的模块性以获得更大的效率</li>
<li>消除不必要的存储器引用。引入临时变量来保存中间结果。只有在最后的值计算出来时，才将结果存放到数组或全局变量中</li>
</ul>
</li>
<li>低级优化<ul>
<li>展开循环，降低开销，并且使得进一步的优化成为可能</li>
<li>通过使用多个累积变量和重新结合等技术，找到方法提高指令级并行</li>
<li>用功能的风格重写条件操作，使得编译采用条件数据传送</li>
</ul>
</li>
</ol>
<h2 id="u786E_u5B9A_u548C_u6D88_u9664_u6027_u80FD_u74F6_u9888"><a href="#u786E_u5B9A_u548C_u6D88_u9664_u6027_u80FD_u74F6_u9888" class="headerlink" title="确定和消除性能瓶颈"></a>确定和消除性能瓶颈</h2><p>系统优化的通用原则：Amdahl’s law</p>
<p>Unix 的程序剖析(profiling)工具 GPROF。这个程序产生两种形式的信息。首先，它确定程序中每个函数花费了多少 CPU 时间。其次，它计算每个函数被调用的次数，以执行调用的函数来分类。</p>
<p>运行时需要三个步骤</p>
<ol>
<li>程序必须为剖析而编译和链接，加上 <code>-pg</code>: <code>unix&gt; gcc -O1 -pg prog.c -o prog</code></li>
<li>然后像往常一样执行：<code>unix&gt; ./prog file.txt</code>，会产生额外的文件 <code>gmon.out</code></li>
<li>调用 GPROF 来分析 <code>gmon.out</code> 中的数据：<code>unix&gt; gprof prog</code></li>
</ol>
<p>具体的用法请参考书本或者网上的例子，此略</p>
<h2 id="u5C0F_u7ED3-3"><a href="#u5C0F_u7ED3-3" class="headerlink" title="小结"></a>小结</h2><p>没有任何编译器能用一个好的算法或数据结构代替低效率的算法或数据结构，因此程序设计时的这些方面仍然应该是程序员主要关心的。</p>
<h1 id="u5B58_u50A8_u5668_u5C42_u6B21_u7ED3_u6784"><a href="#u5B58_u50A8_u5668_u5C42_u6B21_u7ED3_u6784" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><p>存储器系统(memory system)是一个具有不同容量、成本和访问时间的存储设备的层次结构。CPU 寄存器保存着最常用的数据。靠近 CPU 的晓得、快速的<strong>高速缓存存储器(cache memory)</strong>作为一部分存储在相对慢速的主存储器(main memory)中的数据和指令的缓冲区域。主存暂时存放在容量较大的、慢速磁盘上的数据，而这些磁盘常常又作为存储在通过网络连接的其他机器的磁盘或磁带上的区域的缓冲区域。</p>
<p>如果你理解了系统是如何将数据在存储器层次结构中上上下下移动的，那么你就可以编写你的应用程序，使得它们的数据项存储在层次结构中较高的地方，在那里 CPU 能更快地访问到它们。</p>
<p>这个思想围绕着计算机程序的一个称为<strong>局部性(locality)</strong>的基本属性。具有良好局部性的程序倾向于一次又一次地访问相同的数据项集合，或是倾向于访问临近的数据项集合。</p>
<h2 id="u5B58_u50A8_u6280_u672F"><a href="#u5B58_u50A8_u6280_u672F" class="headerlink" title="存储技术"></a>存储技术</h2><p>计算机技术的成功很大程度上源自于存储技术的巨大进步。</p>
<blockquote>
<p>随机访问存储器</p>
</blockquote>
<p>随机访问存储器   (Random-Access Memory, RAM)分为两类：静态的和懂啊提的。SRAM 比 DRAM 更快，但也贵得多。SRAM 用来作为高速缓存存储器，既可以在 CPU 芯片上，也可以在片下。DRAM 用来作为主存以及图形系统的帧缓冲区。</p>
<blockquote>
<p>固态硬盘</p>
</blockquote>
<p>固态硬盘(Solid State Disk, SSD)是一种基于闪存的存储技术。一个 SSD 包由一个或多个闪存芯片和闪存翻译层(flash translation layer)组成，闪存芯片代替传统旋转磁盘中的机械驱动器，而闪存翻译层是一个硬件/固件设备，扮演与磁盘控制器相同的角色，将对逻辑块的清酒翻译成对底层物理设备的访问。</p>
<p><img src="/images/csapp6.16.jpg" alt="csapp6.16"></p>
<p>SSD 有着与旋转磁盘不同的性能特征。顺序读和写性能相当，不过，当按照随机顺序访问逻辑块时，写比读慢一个数量级。随机读和写的性能差别是由底层闪存基本属性决定的。如上图所示，一个闪存由 B 个块的序列组成，每个块由 P 页组成。通常，页的大小是 512~4KB，块是由 32~128 页组成的，块的大小为 16~512 KB。数据是以页为单位读写的。只有在一页所属的块整个被擦除之后，才能写这一页。不过，一旦一个块被擦除了，块中的每一个页都可以不需要再进行擦除就写一次。在大约进行 100000 次重复写之后，块就会磨损坏。</p>
<blockquote>
<p>存储技术趋势</p>
</blockquote>
<ul>
<li>不同的存储技术有不同的价格和性能折中</li>
<li>不同的存储技术的价格和性能属性一截然不同的速率变化着</li>
<li>DRAM 和磁盘的性能滞后于 CPU 的性能</li>
</ul>
<h2 id="u5C40_u90E8_u6027"><a href="#u5C40_u90E8_u6027" class="headerlink" title="局部性"></a>局部性</h2><p>一个编写良好的计算机程序常常具有良好的局部性(locality)。也就是说，它们倾向于引用临近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性，被称为<strong>局部性原理(principle of locality)</strong>，是一个持久的概念，对硬件和软件系统的设计和性能都有着极大的影响。</p>
<p>局部性通常有两种不同的形式：<strong>时间局部性(temporal locality)</strong>和<strong>空间局部性(spatial locality)</strong>。有良好局部性的程序比局部性差的程序运行得更快。</p>
<ul>
<li>重复引用同一个变量的程序有良好的时间局部性</li>
<li>对于具有步长为 k 的引用模式的程序，步长越小，空间局部性越好</li>
<li>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好</li>
</ul>
<h2 id="u5B58_u50A8_u5668_u5C42_u6B21_u7ED3_u6784-1"><a href="#u5B58_u50A8_u5668_u5C42_u6B21_u7ED3_u6784-1" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h2><p>存储器层次结构(memory hierarchy)如下图所示</p>
<p><img src="/images/csapp6.23.jpg" alt="csapp6.23"></p>
<blockquote>
<p>存储器层次结构中的缓存</p>
</blockquote>
<p>一般而言，高速缓存(cache)是一个小而快速的存储设备。使用高速缓存的过程称为缓存(caching)。</p>
<p>存储器层次结构的中心思想是，对于每个 k，位于 k 层的更快更小的存储设备作为位于 k+1 层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一次都缓存来自较低一层的数据对象。</p>
<p>数据总是以块大小为<strong>传送单元(transfer unit)</strong>在第 k 层和第 k+1 层之间来回拷贝的。虽然在层次结构中任何一对相邻的层次之间块大小是固定的，但是其他的层次对之间可以用不同的块大小。一般而言，层次结构较低的层(离 CPU 较远)的设备访问时间较长，因此为了补偿这些较长的访问时间，倾向于使用较大的块。</p>
<p><img src="/images/csapp6.24.jpg" alt="csapp6.24"></p>
<p><strong>缓存命中</strong></p>
<p>当程序需要第 k+1 层的某个数据对象 d 时，它首先在当前存储的第 k 层的一个块中查找 d。如果 d 刚好缓存在第 k 层中，那么就是<strong>缓存命中(cache hit)</strong>。</p>
<p><strong>缓存不命中</strong></p>
<p>如果第 k 层中没有缓存数据对象 d，那么就是<strong>缓存不命中(cache miss)</strong>。当发生 cache miss 时，会从下一次取出包含 d 的那个块，如果第 k 层的缓存已经满了的话，可能就会覆盖现存的一个块。</p>
<p>覆盖一个现存的块的过程称为<strong>替换(replacing)</strong>或<strong>驱逐(evicting)</strong>。被驱逐的看这个块有时也称为<strong>牺牲块(victim block)</strong>。决定该替换那个块是由缓存的<strong>替换策略(replacement policy)</strong>来控制的。(LRU, LFU 等等替换策略在这里可以使用)</p>
<p><strong>缓存不命中的种类</strong></p>
<p>一个空的缓存有时称为<strong>冷缓存(cold cache)</strong>，此类不命中称为<strong>compulsory miss</strong> 或 <strong>cold miss</strong>。</p>
<p>只要发生了 cache miss，第 k 层的缓存就必须执行某个<strong>放置策略(placement policy)</strong>，确定把它从第 k+1 层中取出的块放在哪里。一般来说是用映射来确定放在哪里，如果两个不同的块映射到同一个位置，就引起了 conflict miss。当工作集的大小超过缓存的大小时，就会有 capacity miss。</p>
<p><img src="/images/csapp6.25.jpg" alt="csapp6.25"></p>
<h2 id="u9AD8_u901F_u7F13_u5B58_u5B58_u50A8_u5668"><a href="#u9AD8_u901F_u7F13_u5B58_u5B58_u50A8_u5668" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h2><p>早期计算机系统的存储器结构只有三层：CPU 寄存器、DRAM 主存储器和磁盘存储。不过，由于 CPU 和主存之间逐渐增大的差距，系统设计者被迫在 CPU 寄存器文件和主存之间插入了一个小的 SRAM 高速缓存存储器，称为 L1 高速缓存。之后又插入了一个更大的高速缓存，称为 L2 高速缓存，之后还有 L3 高速缓存。周期数：L1(2~4), L2(~10), L3(~30~40)</p>
<h2 id="u7F16_u5199_u9AD8_u901F_u7F13_u5B58_u53CB_u597D_u7684_u4EE3_u7801"><a href="#u7F16_u5199_u9AD8_u901F_u7F13_u5B58_u53CB_u597D_u7684_u4EE3_u7801" class="headerlink" title="编写高速缓存友好的代码"></a>编写高速缓存友好的代码</h2><ul>
<li>让最常见的情况运行得快</li>
<li>在每个循环内部缓存不命中数量最小</li>
</ul>
<h2 id="u7EFC_u5408_uFF1A_u9AD8_u901F_u7F13_u5B58_u5BF9_u7A0B_u5E8F_u6027_u80FD_u7684_u5F71_u54CD"><a href="#u7EFC_u5408_uFF1A_u9AD8_u901F_u7F13_u5B58_u5BF9_u7A0B_u5E8F_u6027_u80FD_u7684_u5F71_u54CD" class="headerlink" title="综合：高速缓存对程序性能的影响"></a>综合：高速缓存对程序性能的影响</h2><blockquote>
<p>存储器山</p>
</blockquote>
<p>一个程序从存储系统中读数据的速率称为<strong>度吞吐量(read throughput)</strong>，或者有时称为<strong>读带宽(read bandwidth)</strong>。</p>
<p><img src="/images/csapp6.43.jpg" alt="csapp6.43"></p>
<blockquote>
<p>重新排列循环以提高空间局部性</p>
</blockquote>
<p>矩阵的循环优化，略</p>
<blockquote>
<p>在程序中利用局部性</p>
</blockquote>
<ul>
<li>将你的注意力集中在内循环上，大部分计算和存储器访问都发生在这里</li>
<li>通过按照数据对象存储在存储器中的顺序、以步长为 1 的来读数据，从而使得程序中的空间局部性最大</li>
<li>一旦从存储器中读入了一个数据对象，就尽可能多地使用它，从而使得程序中的时间局部性最大</li>
</ul>
<h2 id="u5C0F_u7ED3-4"><a href="#u5C0F_u7ED3-4" class="headerlink" title="小结"></a>小结</h2><p>程序员可以通过编写有良好空间和时间局部性的程序来显著地改进程序的运行时间。利用基于 SRAM 的高速缓存存储器特别重要。</p>
<h1 id="u94FE_u63A5"><a href="#u94FE_u63A5" class="headerlink" title="链接"></a>链接</h1><p>链接(linking)是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载到存储器并执行。链接可以执行于编译时(compile time)，也可以执行于加载时(load time)，甚至执行于运行时(run time)。</p>
<p>链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译(separate compilation)成为可能。</p>
<h2 id="u7F16_u8BD1_u5668_u9A71_u52A8_u7A0B_u5E8F"><a href="#u7F16_u8BD1_u5668_u9A71_u52A8_u7A0B_u5E8F" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h2><p>大多数编译系统提供<strong>编译驱动程序(compiler driver)</strong>，它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。</p>
<h2 id="u9759_u6001_u8FDE_u63A5"><a href="#u9759_u6001_u8FDE_u63A5" class="headerlink" title="静态连接"></a>静态连接</h2><p>静态链接器(static linker)以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节(section)组成。指令在一个 section 中，初始化的全局变量在另一个 section 中，而未初始化的变量又在另一个 section 中。</p>
<p><img src="/images/csapp7.2.jpg" alt="csapp7.2"></p>
<p>为了构造可执行文件，链接器必须完成两个主要任务：</p>
<ul>
<li>符号解析(symbol resolution)。目标文件定义和引用符号。符号解析的目的是将每个符号引用刚好和一个符号定义联系起来。</li>
<li>重定位(relocation)。编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义域一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定位这些节。</li>
</ul>
<p>关于链接器的一些基本事实：目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包含指导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。</p>
<h2 id="u76EE_u6807_u6587_u4EF6"><a href="#u76EE_u6807_u6587_u4EF6" class="headerlink" title="目标文件"></a>目标文件</h2><p>目标文件有三种形式：</p>
<ul>
<li>可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li>
<li>可执行目标文件。包含二进制代码和数据，其形式可以被直接拷贝到存储器并执行。</li>
<li>共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载到存储器并链接。</li>
</ul>
<h2 id="u53EF_u91CD_u5B9A_u4F4D_u76EE_u6807_u6587_u4EF6"><a href="#u53EF_u91CD_u5B9A_u4F4D_u76EE_u6807_u6587_u4EF6" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h2><p>下图是一个典型的 ELF 可重定位目标文件的格式。ELF 头(ELF header)以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。</p>
<p><img src="/images/csapp7.3.jpg" alt="csapp7.3"></p>
<h2 id="u7B26_u53F7_u548C_u7B26_u53F7_u8868"><a href="#u7B26_u53F7_u548C_u7B26_u53F7_u8868" class="headerlink" title="符号和符号表"></a>符号和符号表</h2><p>每个可重定位目标模块 m 都有一个符号表，它包含 m 所定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：</p>
<ul>
<li>由 m 定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的 C 函数以及被定义为不带 C static 属性的全局变量</li>
<li>由其他模块定义的并被模块 m 引用的全局符号。这些符号称为外部符号(external)，对应于定义在其他模块中的 C 函数和变量。</li>
<li>只被模块 m 定义和引用的本地符号。有的本地链接器符号对应于带 static 属性的 C 函数和全局变量。</li>
</ul>
<p>C 程序员使用 static 属性在模块内部隐藏变量和函数声明。</p>
<h2 id="u7B26_u53F7_u89E3_u6790"><a href="#u7B26_u53F7_u89E3_u6790" class="headerlink" title="符号解析"></a>符号解析</h2><p>链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义联系起来。对那些和引用定义在相同模块中的本地符号的引用，符号解析是非常简单明了的。编译器只允许每个模块中每个本地符号只有一个定义。编译器还确保静态本地变量，它们也会有本地链接器符号，拥有唯一的名字。</p>
<h2 id="u91CD_u5B9A_u4F4D"><a href="#u91CD_u5B9A_u4F4D" class="headerlink" title="重定位"></a>重定位</h2><p>一旦链接器完成了符号解析这一步，它就把代码中的每个符号引用和确定的一个符号定义联系起来。在此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。重定位由两步组成：</p>
<ul>
<li>重定位节和符号定义</li>
<li>重定位节中的符号引用</li>
</ul>
<h2 id="u53EF_u6267_u884C_u76EE_u6807_u6587_u4EF6"><a href="#u53EF_u6267_u884C_u76EE_u6807_u6587_u4EF6" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h2><p>可执行目标文件的格式类似于可重定位目标文件的格式，如下图所示。ELF 头部描述文件的总体格式。它还包括程序的入口点(entry point)，也就是当程序要执行的第一条指令的地址。</p>
<p><img src="/images/csapp7.11.jpg" alt="csapp7.11"></p>
<h2 id="u52A0_u8F7D_u53EF_u6267_u884C_u76EE_u6807_u6587_u4EF6"><a href="#u52A0_u8F7D_u53EF_u6267_u884C_u76EE_u6807_u6587_u4EF6" class="headerlink" title="加载可执行目标文件"></a>加载可执行目标文件</h2><p>要允许可执行目标文件 p，可以在 Unix 外壳的命令行中输入它的名字</p>
<pre><code>unix&gt; ./p
</code></pre><p>因为 p 不是一个内置的外壳命令，所以外壳会认为 p 是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器(loader)的操作系统代码来运行它。任何 Unix 程序都可以通过调用 execve 函数来调用加载器。加载器将可执行目标文件中的代码和数据从磁盘拷贝到存储器，然后通过跳转到程序的第一条指令或入口点(entry point)来运行该程序。这个将程序拷贝到存储器并运行的过程叫做加载(loading)。</p>
<p><img src="/images/csapp7.13.jpg" alt="csapp7.13"></p>
<p>每个 Unix 程序都有一个运行时存储器映像，如上图所示。在 32 位 Linux 系统中，代码段总是从地址 0x08048000 处开始。数据段是在接下来的下一个 4KB 对齐的地址处。运行时<strong>堆</strong>再读/写段之后接下来的第一个 4KB 对齐的地址处，并通过调用 malloc 库往上增长。还有一个段是为共享库保留的。用户栈总是从最大的合法用户地址开始，向下增长的(向低存储器地址方向增长)。从栈的上部开始的段是为操作系统主流存储器的部分(也就是内核)的代码和数据保留的。</p>
<h2 id="u52A8_u6001_u94FE_u63A5_u5171_u4EAB_u5E93"><a href="#u52A8_u6001_u94FE_u63A5_u5171_u4EAB_u5E93" class="headerlink" title="动态链接共享库"></a>动态链接共享库</h2><p>共享库(shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行时，可以加载到任意的存储器地址，并和一个在存储器中的程序链接起来。这个过程称为<strong>动态链接(dynamic linking)</strong>，是由一个叫做<strong>动态链接器</strong>的程序来执行的。</p>
<p>共享库也称为<strong>共享目标(shared object)</strong>，在 Unix 系统中通常用 .so 后缀来表示。微软的操作系统大量地利用了共享库，它们称为 DLL。</p>
<p><img src="/images/csapp7.15.jpg" alt="csapp7.15"></p>
<p>共享库是以两种不同方式来“共享”的。首先，在任何给定的文件系统中，对于一个库只有一个 .so 文件。所有引用该库的可执行目标文件共享这个 .so 文件中的代码和数据，而不是像静态库的内容那样被拷贝和嵌入到引用它们的可执行的文件中。</p>
<h2 id="u4E0E_u4F4D_u7F6E_u65E0_u5173_u7684_u4EE3_u7801_28PIC_29"><a href="#u4E0E_u4F4D_u7F6E_u65E0_u5173_u7684_u4EE3_u7801_28PIC_29" class="headerlink" title="与位置无关的代码(PIC)"></a>与位置无关的代码(PIC)</h2><p>PIC 数据引用；PIC 函数调用</p>
<h2 id="u5904_u7406_u76EE_u6807_u6587_u4EF6_u7684_u5DE5_u5177"><a href="#u5904_u7406_u76EE_u6807_u6587_u4EF6_u7684_u5DE5_u5177" class="headerlink" title="处理目标文件的工具"></a>处理目标文件的工具</h2><p>在 Unix 系统中有大量可用的工具可以帮助你理解和处理目标文件。特别的，GNU binutils 包尤其有帮助，而且可以运行在每个 Unix 平台上。</p>
<ul>
<li>AR: 创建静态库，插入、删除、列出和提取成员</li>
<li>STRINGS: 列出一个目标文件中所有可打印的字符串</li>
<li>STRIP: 从目标文件中删除符号表信息</li>
<li>NM: 列出一个目标文件的符号表中定义的符号</li>
<li>SIZE: 列出目标文件中节的名字和大小</li>
<li>READELF: 显示一个目标文件的完整结构，包括 ELF 头中编码的所有信息。包含 SIZE 和 NM 的功能</li>
<li>OBJDUMP: 二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编 .text 节中的二进制命令</li>
<li>LDD: 列出一个可执行文件在运行时所需要的共享库</li>
</ul>
<h2 id="u5C0F_u7ED3-5"><a href="#u5C0F_u7ED3-5" class="headerlink" title="小结"></a>小结</h2><p>链接可以在编译时由静态编译器来完成，也可以在加载时和运行时由动态链接器来完成。链接器处理称为目标文件的二进制文件，它又三种不同的形式：可重定位的、可执行的和共享的。可重定位的目标文件由静态链接器合并成一个可执行的目标文件，它可以加载到存储器中并执行。共享目标文件(共享库)是在运行时由动态链接器链接和加载的，或者隐含地在调用程序被加载和开始执行时，或者根据需要在程序调用 dlopen 库的函数时。</p>
<p>链接器的两个主要任务是符号解析和重定位，符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义，而重定位确定每个符号的最终存储器地址，并修改对那些目标的引用。</p>
<p>静态链接器是由像 GCC 这样的编译驱动器调用的。它们将多个可重定位目标文件合并成一个单独的可执行目标文件。多个目标文件可以定义相同的符号，而链接器用来悄悄地解析这些多重定义的规则可能在用户程序中引入的微妙错误。</p>
<p>多个目标文件可以被连接到一个单独的静态库中。链接器用库来解析其他目标模块中的符号引用。许多链接器通过从左到右的顺序扫描来解析符号引用，这是另一个引起迷惑的链接时错误来源。</p>
<p>加载器将可执行文件的内容映射到存储器，并运行这个程序。链接器还可能生成部分链接的可执行目标文件，这样的文件中有对定义在共享库中的程序和数据的未解析的引用。在加载时，加载器将部分链接的可执行文件映射到存储器，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链接任务。</p>
<p>被编译为位置无关代码的共享库可以加载到任何地方，也可以在运行时被多个进程共享。为了加载、链接和访问共享库的函数和数据，应用程序还可以在运行时使用动态链接器。</p>
<h1 id="u5F02_u5E38_u63A7_u5236_u6D41"><a href="#u5F02_u5E38_u63A7_u5236_u6D41" class="headerlink" title="异常控制流"></a>异常控制流</h1><p>系统必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。当子进程终止时，创造这些子进程的父进程必须得到通知。</p>
<p>线代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为<strong>异常控制流(Exceptional Control Flow, ECF)</strong>。异常控制流发生在计算机系统的各个层次。比如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文转换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送<strong>信号</strong>到另一个进程，而接受者会将控制突然转移到它的一个信号处理程序。一个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。</p>
<h2 id="u5F02_u5E38"><a href="#u5F02_u5E38" class="headerlink" title="异常"></a>异常</h2><p>异常是异常控制流的一种形式，它一部分是由硬件实现的，一部分是由操作系统实现的。因为它们有一部分是由硬件实现的，所以具体细节将随系统的不同而有所不同。然而，对于每个系统而言，基本的思想都是相同的。</p>
<p>异常(exception)就是控制流中的突变，用来响应处理器状态中的某些变化。如下图所示：</p>
<p><img src="/images/csapp8.1.jpg" alt="csapp8.1"></p>
<p>在图中，当处理器状态中发生一个重要的变化时，处理器正在执行某个当前指令。在处理器中，状态被编码为不同的位和信号。状态变化称为<strong>事件(event)</strong>。事件可能和当前指令的执行直接相关。比如，发生虚拟存储器缺页、算术溢出，或者一条指令试图除以零。另一方面，事件也可能和当前指令的执行没有关系。比如，一个系统定时器产生信号或者一个 I/O 请求完成。</p>
<p>在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做<strong>异常表(exception table)</strong>的跳转表，进行一个间接过程调用(异常)，到一個专门设计用来处理这类事件的操作系统子程序(异常处理程序, exception handler)</p>
<p>当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下三种情况中的一种：</p>
<ol>
<li>处理程序将控制返回给当前指令 I(curr)，即当事件发生时正在执行的指令。</li>
<li>处理程序将控制返回给 I(next)，即如果没有发生异常将会执行的下一条指令。</li>
<li>处理程序被中断的程序</li>
</ol>
<blockquote>
<p>异常处理</p>
</blockquote>
<p>系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号(exception number)。其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核的设计者分配的。前者的示例包括被零除、缺页、存储器访问违例以及算术溢出。后者的示例包括系统调用和来自外部 I/O 设备的信号。</p>
<p>在系统启动时，操作系统分配和初始化一张称为<strong>异常表</strong>的跳转表，使得条目 k 包含异常 k 的处理程序的地址。如下图所示</p>
<p><img src="/images/csapp8.2.jpg" alt="csapp8.2"></p>
<p>在运行时，处理器检测到发生了一个事件，并且确定了相应的异常号 k。随后，处理器触发异常，方法是执行间接过程调用，通过异常表的条目 k 转到相应的处理程序。下图展示了处理器如何使用异常表来形成适当的异常处理程序的地址。异常号是到异常表中的索引，异常表的起始地址放在一个叫做<strong>异常表基址寄存器(exception table base register)</strong>的特殊 CPU 寄存器里。</p>
<p><img src="/images/csapp8.3.jpg" alt="csapp8.3"></p>
<blockquote>
<p>异常的类别</p>
</blockquote>
<p>异常可以分为四类：中断(interrupt)、陷阱(trap)、故障(fault)和终止(abort)。下图是一些总结</p>
<p><img src="/images/csapp8.4.jpg" alt="csapp8.4"></p>
<p><strong>中断</strong></p>
<p>中断是异步发生的，是来自处理器外部的 I/O 设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序通常称为中断处理程序(interrupt handler)</p>
<p><img src="/images/csapp8.5.jpg" alt="csapp8.5"></p>
<p>剩下的异常类型(陷阱、故障和终止)是同步发生的，是执行当前指令的结果。我们把这类指令叫做故障指令(faulting instruction)。</p>
<p>陷阱和系统调用</p>
<p>陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做<strong>系统调用</strong>。</p>
<p>用户程序经常需要向内核请求服务，比如读一个文件(read)、创建一个新的进程(fork)、记在一个新的程序(execve)，或者终止当前进程(exit)。为了允许对这些内核服务的受控范文，处理器提供一条特殊的 <code>syscall n</code> 指令，当用户程序想要请求服务 n 时，可以执行这条指令。执行 <code>syscall</code> 指令会导致一个到异常处理程序的陷阱，这个处理程序对参数解码，并调用适当的内核程序。</p>
<p><img src="/images/csapp8.6.jpg" alt="csapp8.6"></p>
<p><strong>故障</strong></p>
<p>故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort 例程，abort 例程会终止引起故障的应用程序，如下图所示：</p>
<p><img src="/images/csapp8.7.jpg" alt="csapp8.7"></p>
<p>一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在存储器中，因此必须从磁盘中取出时，就会发生故障。就像我们将在第 9 章中看到的那样，一个页面就是虚拟存储器的一个连续的块。缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在存储器中了，指令就可以没有故障地运行完成了。</p>
<p><strong>终止</strong></p>
<p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者 SRAM 位被损坏时发生的奇偶错误。终止程序从不将控制返回给应用程序。如下图所示</p>
<p><img src="/images/csapp8.8.jpg" alt="csapp8.8"></p>
<blockquote>
<p>Linux/IA32 系统中的异常</p>
</blockquote>
<p>IA32 系统有高达256种不同的异常类型。0-31的号码对应的是由 Intel 架构师定义的异常，因此对任何 IA32 系统都是一样的。32-255的号码对应的是操作系统定义的终端和陷阱，如下图所示</p>
<p><img src="/images/csapp8.9.jpg" alt="csapp8.9"></p>
<p><strong>Linux/IA32 故障和终止</strong></p>
<ul>
<li>除法错误。当应用试图除以零时，或者当一个除法指令的结果对于目标操作数来说太大的时候，就会发生除法错误(异常0)。Unix 不会试图从除法错误中恢复，而是选择终止程序。Linux shell 通常会把除法错误报告为浮点异常(Floating exception)。</li>
<li>一般保护故障。许多原因都会导致不为人知的一般保护故障(异常13)，通常是因为一个程序引用了一个未定义的虚拟存储器区域，或者因为程序视图写一个只读的文本段。Linux 不会尝试恢复这类故障。Linux shell 通常会把这种一般保护故障报告为段故障(Segmentation fault)。</li>
<li>缺页(异常14)是会重新执行产生故障的指令的一个异常示例。</li>
<li>机器检查(异常18)是在导致故障的指令中检测到致命的硬件错误时发生的。机器检查处理程序从不返回控制给应用程序</li>
</ul>
<p><strong>Linux/IA32 系统调用</strong></p>
<p>每个系统调用都有一个唯一的整数号，对应于一个到内核中跳转表的偏移量。</p>
<p><img src="/images/csapp8.10.jpg" alt="csapp8.10"></p>
<h2 id="u8FDB_u7A0B"><a href="#u8FDB_u7A0B" class="headerlink" title="进程"></a>进程</h2><p>异常是允许操作系统提供<strong>进程(process)</strong>的概念所需要的基本构造块，进程是计算机可续重最深刻最成功的概念之一。当我们在一个现代系统上运行一个程序时，会得到一个假象，就好像我们的程序是系统中当前运行着的唯一的程序。</p>
<p>进程的经典定义就是一个<strong>执行中的程序的实例</strong>。系统中的每个程序都是运行在某个进程的<strong>上下文(context)</strong>中的。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在存储器中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p>
<p>每次用户通过向外壳输入一个可执行目标文件的名字，并运行一个程序时，shell 就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，且在这个新进程的上下文中运行它们自己的代码或其他应用程序。</p>
<blockquote>
<p>逻辑控制流</p>
</blockquote>
<p>即使在系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，好像它在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器(PC)的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或者是包含在运行时动态链接到程序的共享对象的指令。这个 PC 值的序列叫做<strong>逻辑控制流</strong>，或者简称<strong>逻辑流</strong>。</p>
<p><img src="/images/csapp8.12.jpg" alt="csapp8.12"></p>
<p>每个进程执行它的流的一部分，然后被<strong>抢占(preempted，暂时挂起)</strong>，然后轮到其他进程。</p>
<blockquote>
<p>并发流</p>
</blockquote>
<p>一个逻辑流的执行在时间上与另一个流重叠，称为<strong>并发流(concurrent flow)</strong>，这两个流被称为并发地运行。更准确地说，流 X 和 Y 互相并发，当且仅当 X 在 Y 开始之后和 Y 结束之前开始，或者 Y 在 X 开始之后和 X 结束之前开始。</p>
<p>多个流并发地执行的一般现象称为<strong>并发(concurrency)</strong>。一个进程和其他进程轮流运行的概念称为<strong>多任务(multitasking)</strong>。一个进程执行它的控制流的一部分的每一时间段叫做<strong>时间片(time slice)</strong>。因此，多任务也叫做<strong>时间分片(time slicing)</strong></p>
<p>注意，并发的思想与流运行的处理器核数或者计算机无关。如果两个流再时间上重叠，那么它们就是并发的，即使它们是运行在同一个处理器上的。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为<strong>并行流(parallel flow)</strong>。</p>
<blockquote>
<p>私有地址空间</p>
</blockquote>
<p>进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。尽管和每个私有地址空间相关联的存储器的内容一般是不同的，但是每个这样的空间都有相同的通用结构，如下图所示。</p>
<p><img src="/images/csapp8.13.jpg" alt="csapp8.13"></p>
<blockquote>
<p>用户模式和内核模式</p>
</blockquote>
<p>为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。</p>
<p>处理器通常是用某个控制寄存器中的一个<strong>模式位(mode bit)</strong>来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位，进程就运行在<strong>内核模式(超级用户模式)</strong>。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中任何存储器位置。</p>
<p>没有设置模式位时，进程就运行在<strong>用户模式</strong>中。用户模式中的进程不允许执行<strong>特权指令(priviledged instruction)</strong>，比如停止处理器、改变位模式，或者发起一个 I/O 操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。</p>
<p>Linux 提供了一种聪明的机制，叫做 /proc 文件系统，它允许用户模式进程访问内核数据结构的内容。/proc文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构。</p>
<blockquote>
<p>上下文切换</p>
</blockquote>
<p>操作系统内核使用一种称为<strong>上下文切换(context switch)</strong>的较高层形式的异常控制流来实现多任务。上下文切换机制是建立在8.1节中那些较低层异常机制之上的。</p>
<p>内核为每个进程维持一个<strong>上下文(context)</strong>。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描绘地址空间的页表、包含有关当前进程信息的<strong>进程表</strong>，以及包含进程已打开文件的信息的<strong>文件表</strong>。</p>
<p>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程。这种决定就叫做<strong>调度(schedule)</strong>，是由内核中称为<strong>调度器(scheduler)</strong>的代码处理的。当内核选择一个新的进程运行时，我们就说内核调度了这个进程。</p>
<p><img src="/images/csapp8.14.jpg" alt="csapp8.14"></p>
<h2 id="u7CFB_u7EDF_u8C03_u7528_u9519_u8BEF_u5904_u7406"><a href="#u7CFB_u7EDF_u8C03_u7528_u9519_u8BEF_u5904_u7406" class="headerlink" title="系统调用错误处理"></a>系统调用错误处理</h2><p>当 Unix 系统级函数遇到错误时，它们典型地会返回 -1，并设置全局帧数变量 errno 来表示什么出错了。通过使用<strong>错误处理包装(error-handling wrapper)</strong>函数，可以简化错误处理代码。</p>
<h2 id="u8FDB_u7A0B_u63A7_u5236"><a href="#u8FDB_u7A0B_u63A7_u5236" class="headerlink" title="进程控制"></a>进程控制</h2><p>Unix 提供了大量从 C 程序中操作进程的系统调用。</p>
<blockquote>
<p>获取进程 ID</p>
</blockquote>
<p>每个进程都有一个唯一的正数进程 ID(PID)。<code>getpid</code> 函数返回调用进程的 PID。<code>getppid</code> 函数返回它的父进程的 PID。</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t getpid(void);
pit_t getppid(void);
</code></pre><blockquote>
<p>创建和终止进程</p>
</blockquote>
<p>从程序员的角度，我们可以认为进程总是处于下面三种状态之一：</p>
<ul>
<li>运行。进程要么在 CPU 上执行，要么在等待被执行且最终会被内核调度。</li>
<li>停止。进程的执行被<strong>挂起(suspend)</strong>，且不会被调度。当收到 <code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIDTTIN</code> 或者 <code>SIGTTOU</code> 信号时，进程就停止，并且保持停止直到它收到一个 <code>SIGCONT</code> 信号，在这个时刻，进程再次开始运行。</li>
<li>终止。进程永远地停止了。进程会因为三种原因终止：1）收到一个默认行为是终止进程的信号，2）从主程序返回，3）调用 exit 函数</li>
</ul>
<p>该程序无返回值，<code>exit</code> 函数以 status 退出来终止进程。</p>
<pre><code>#include &lt;stdlib.h&gt;

void exit(int status);
</code></pre><p>父进程通过调用 <code>fork</code> 函数创建一个新的运行子进程，子进程返回0，父进程返回子进程的 PID，如果出错则为 -1。</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t fork(void);
</code></pre><p>新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份拷贝，包括文本、数据和 bss 段、以及用户栈。子进程还获得与父进程任何打开文件描述符相同的拷贝。父进程和新创建的子进程最大的区别在于他们有不同的 PID。</p>
<p><code>fork</code> 函数只被调用一次，却会返回两次(父进程与子进程)。因为子进程的 PID 总是非零的，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。</p>
<p><img src="/images/csapp8.15.jpg" alt="csapp8.15"></p>
<ul>
<li>调用一次，返回两次</li>
<li>并发执行。顺序不能保证</li>
<li>相同但是独立的地址空间，所以变量是分别独立的</li>
<li>共享文件，输出是指向同一个地方</li>
</ul>
<p><img src="/images/csapp8.16.jpg" alt="csapp8.16"></p>
<blockquote>
<p>回收子进程</p>
</blockquote>
<p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一中已终止的状态中，直到被它的父进程<strong>回收(reap)</strong>。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个终止了但还未被回收的进程称为<strong>僵死进程(zombie)</strong>。</p>
<p>如果父进程没有回收它的僵死子进程就终止了，那么内核就会安排 init 进程来回收它们。init 进程的 PID 为 1，并且是在系统初始化时由内核创建的。长时间运行的程序，比如 shell 或者服务器，总是应该回收它们的僵死子进程。即使僵死子进程没有运行，它们仍然小号系统的存储器资源。</p>
<p>一个进程可以通过调用 <code>waitpid</code> 函数来等待它的子进程终止或者停止。如果成功，则返回子进程的 PID，如果 WHOHANG ，则为 0，如果其他错误，则为 -1。</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

pit_t waitpid(pid_t pid, int *status, int options);
</code></pre><p>具体用法略</p>
<blockquote>
<p>让进程休眠</p>
</blockquote>
<p><code>sleep</code> 函数让一个进程挂起一段指定的时间。返回还要休眠的秒数。</p>
<pre><code>#include &lt;unistd.h&gt;
unsigned int sleep(unsigned int secs);
</code></pre><p>如果请求的时间量已经到了，<code>sleep</code>返回 0，否则返回还剩下要休眠的秒数。我们会发现很有用的另一个函数是 <code>pause</code> 函数，该函数让调用函数休眠，直到该进程收到一个信号。总是返回 -1。</p>
<pre><code>#include &lt;unistd.h&gt;
int pause(void);
</code></pre><blockquote>
<p>加载并运行程序</p>
</blockquote>
<p><code>execve</code> 函数子啊当前进程的上下文中加载并运行一个新程序。如果成功则不返回，如果错误，则返回 -1。</p>
<pre><code>#include &lt;unistd.h&gt;

int execve(const char *filename, const char *argv[], const char *envp[]);
</code></pre><p><code>execve</code> 函数加载并运行可执行目标文件 filename，且带参数列表 argv 和环境变量列表 envp。只有当出现错误时，<code>execve</code> 才会返回到调用程序。<code>execve</code> 调用一次并从不返回。</p>
<p><img src="/images/csapp8.19.jpg" alt="csapp8.19"></p>
<p>当 <code>main</code> 开始在一个 32 位 Linux 进程中执行时，用户栈有如下图所示的组织结构。</p>
<p><img src="/images/csapp8.21.jpg" alt="csapp8.21"></p>
<p><strong>程序与进程</strong></p>
<p>程序是一堆代码和数据；程序可以作为目标模块存在于磁盘上，或者作为段存在于地址空间中。进程执行中程序的一个具体的实例；程序总是运行在某个进程的上下文中。<code>fork</code>函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品。<code>execve</code> 函数在当前进程的上下文中加载并运行一个新的程序，会覆盖当前进程的地址空间，但并没有创建一个新进程。新的程序仍然拥有相同的 PID，并且继承了调用 <code>execve</code> 函数时已打开的所有文件描述符。</p>
<blockquote>
<p>利用 fork 和 execve 运行程序</p>
</blockquote>
<p>Shell 是一个交互型的应用级程序，它代表用户运行其他程序。最早的 shell 是 sh 程序，后面出现了一些变种，比如 csh, tcsh, ksh 和 bash。Shell 执行一系列的<strong>读/求值(read/evaluate)</strong>步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并代表用户运行程序。</p>
<h2 id="u4FE1_u53F7"><a href="#u4FE1_u53F7" class="headerlink" title="信号"></a>信号</h2><p>一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。下图是 Linux 系统支持的 30 种不同类型的信号。在 shell 中输入 <code>man 7 signal</code> 就能得到这个列表。</p>
<p><img src="/images/csapp8.25.jpg" alt="csapp8.25"></p>
<p>每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。比如，如果一个进程试图除以 0，那么内核就发送给他一个 <code>SIGFPE</code> 信号(8)。其他信号对应于内核或者其他用户进程中较高层的软件事件。比如，如果当进程在前台运行时，按下 ctrl-c，那么内核就会发送一个 <code>SIGINT</code> 信号(2)给这个前台进程。</p>
<blockquote>
<p>信号术语</p>
</blockquote>
<p>传送一个信号到目的进程是由两个不同步骤组成的：</p>
<ul>
<li><strong>发送信号</strong>。内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。发送信号可以用如下两个原因：1）内核检测到一个系统事件，比如被零除错误或者子进程终止。2）一个进程调用 kill 函数，显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。</li>
<li><strong>接收信号</strong>。当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为<strong>信号处理程序(signal handler)</strong>的用户层函数捕获这个信号。如下图所示</li>
</ul>
<p><img src="/images/csapp8.26.jpg" alt="csapp8.26"></p>
<p>一个只发出而没有被接收的信号叫做<strong>待处理信号(pending signal)</strong>。在任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为 k 的待处理信号，那么任何接下来发送到这个进程的类型为 k 的信号都不会排队等待，它们只是被简单地丢弃。一个进程可以有选择地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。</p>
<p>一个待处理信号最多只能被接收一次。内核为每个进程在 pending 位向量中维护着待处理信号的集合，而在 blocked 位向量中维护着被阻塞的信号集合。只要传送了一个类型为 k 的信号，内核就会设置 pending 中的第 k 位，而只要接收了一个类型为 k 的信号，内核就会清除 pending 中的第 k 位。</p>
<blockquote>
<p>发送信号</p>
</blockquote>
<p>Unix 系统提供了大量向进程发送信号的机制。所有这些机制都是基于<strong>进程组(process group)</strong>这个概念的。</p>
<p><strong>进程组</strong></p>
<p>每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的。<code>getpgrp</code> 函数返回当前进程的进程组 ID。</p>
<pre><code>#include &lt;unistd.h&gt;

pid_t getpgrp(void);
</code></pre><p>默认的，一个子进程和它的父进程同属一个进程组。一个进程可以通过使用 <code>setpgid</code> 函数来改变自己或者其他进程的进程组，成功则返回 0，否则返回 -1。</p>
<pre><code>#include &lt;unistd.h&gt;

int setpgid(pid_t pid, pid_t pgid);
</code></pre><p><strong>用 /bin/kill 程序发送信号</strong></p>
<p><code>/bin/kill</code> 程序可以向另外的进程发送任意的信号。比如</p>
<pre><code>unix&gt; /bin/kill -9 15213
</code></pre><p>发送信号9(SIGKILL)给进程 15213。</p>
<p><strong>从键盘发送信号</strong></p>
<p>Unix shell 使用<strong>作业(job)</strong>这个抽象概念来表示为对一个命令行求值而创建的进程。在任何时刻，至多只有一个前台作业和 0 个或多个后台作业。比如：</p>
<pre><code>unix&gt; ls | sort
</code></pre><p>创建一个由两个进程组成的前台作业，这两个进程是通过 Unix 管道连接起来的：一个进程运行 ls 程序，另一个运行 sort 程序。Shell 为每个作业创建一个独立的进程组。</p>
<p><strong>用 kill 函数发送信号</strong></p>
<p>进程通过调用 <code>kill</code> 函数发送信号给其他进程(包括它们自己)。如果 pid 大于零，那么 <code>kill</code> 函数发送信号 sig 给进程 pid。如果 pid 小于零，那么 kill 发送信号 sig 给进程组 abs(pid) 中的每个进程。</p>
<p><img src="/images/csapp8.28.jpg" alt="csapp8.28"></p>
<p><strong>用 alarm 函数发送信号</strong></p>
<p>进程可以通过调用 <code>alarm</code> 函数向它自己发送 SIGALRM 信号。返回前一次闹钟剩余的秒数，若以前没有设定闹钟，则为 0。</p>
<pre><code>#include &lt;unistd.h&gt;

unsigned int alarm(unsigned int secs);
</code></pre><blockquote>
<p>接收信号</p>
</blockquote>
<p>当内核从一个异常处理程序返回，准备将控制传递给进程 p 时，它会检查进程 p 的未被阻塞的待处理信号的集合(pending&amp;~blocked)。如果这个集合为空(通常情况下)，那么内核将控制传递到 p 的逻辑控制流中的下一条指令。</p>
<blockquote>
<p>信号处理问题</p>
</blockquote>
<p>当一个程序要补货多个信号时，一些细微的问题就产生了：</p>
<ul>
<li>待处理信号被阻塞</li>
<li>待处理信号不会排队等待</li>
<li>系统调用可以被中断</li>
</ul>
<p>不可以用信号来对其他进程中发生的事件计数。</p>
<blockquote>
<p>可移植的信号处理</p>
</blockquote>
<p>不同系统之间，信号处理语义的差异是 Unix 信号处理的一个缺陷。为了处理这个问题，Posix 标准定义了 <code>sigaction</code> 函数，它允许用户明确指定他们想要的信号处理语义。</p>
<blockquote>
<p>显式地阻塞和取消阻塞信号</p>
</blockquote>
<p>使用 <code>sigprocmask</code> 函数</p>
<blockquote>
<p>同步流以避免讨厌的并发错误</p>
</blockquote>
<p><strong>竞争(race)</strong>，经典同步错误</p>
<h2 id="u975E_u672C_u5730_u8DF3_u8F6C"><a href="#u975E_u672C_u5730_u8DF3_u8F6C" class="headerlink" title="非本地跳转"></a>非本地跳转</h2><p>C 语言提供了一种用户级一场控制流形式，称为<strong>非本地跳转(nonlocal jump)</strong>，它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用——返回序列，通过 <code>setjmp</code> 和 <code>longjmp</code> 函数来提供的。</p>
<pre><code>#include &lt;setjmp.h&gt;

int setjmp(jmp_buf env);
int sigsetjmp(sigjmp_buf env, int savesigs);
</code></pre><p><code>setjmp</code> 函数在 env 缓冲区中保存当前调用环境，以供后面 <code>longjmp</code> 使用，并返回 0。调用环境包括程序计数器、栈指针和通用目的寄存器。</p>
<pre><code>#include &lt;setjmp.h&gt;

void longjmp(jmp_buf env, int retval);
void siglongjmp(sigjmp_buf env, int retval);
</code></pre><p><code>longjmp</code> 函数从 env 缓冲区中恢复调用环境，然后触发一个从最近一次初始化 env 的 <code>setjmp</code> 调用的返回。然后 <code>setjmp</code> 返回，并带有非零的返回值 retval。</p>
<p><code>setjmp</code> 函数只被调用一次，但是返回<strong>多次</strong>：一次是当第一次调用 <code>setjmp</code>，而调用环境保存在缓冲区 env 时；一次是为每个相应的 <code>longjmp</code> 调用。另一方面，<code>longjmp</code> 函数被调用一次，但从不返回。</p>
<p>非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。如果在一个深层嵌套的函数调用中发现了一个错误，我们可以使用非本地跳转直接返回到一个普通的本地化的错误处理程序，而不是费力地解开调用栈。</p>
<p>非本地跳转的另一个重要应用是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。</p>
<p><img src="/images/csapp8.39.jpg" alt="csapp8.39"></p>
<h2 id="u64CD_u4F5C_u8FDB_u7A0B_u7684_u5DE5_u5177"><a href="#u64CD_u4F5C_u8FDB_u7A0B_u7684_u5DE5_u5177" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h2><p>Linux 系统提供了大量的监控和操作进程的有用工具：</p>
<ul>
<li>STRACE：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。用 <code>-static</code> 编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的 trace</li>
<li>PS：列出当前系统中的进程(包括僵死进程)</li>
<li>TOP：打印出关于当前进程资源使用的信息</li>
<li>PMAP：显示进程的存储器映射</li>
<li>/proc：一个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容，用户可以读取这些内容</li>
</ul>
<h2 id="u5C0F_u7ED3-6"><a href="#u5C0F_u7ED3-6" class="headerlink" title="小结"></a>小结</h2><p>异常控制流(ECF)发生在计算机系统的各个层次，是计算机系统中提供并发的基本机制。</p>
<p>在硬件层，异常是由处理器中的事件触发的控制流中的突变。控制流传递给一个软件处理程序，该处理程序进行一些处理，然后返回控制给被中断的控制流。</p>
<p>有四种不同类型的异常：中断、故障、终止和陷阱。</p>
<p>在操作系统层，内核用 ECF 提供进程的基本概念。进程提供给应用两个重要的抽象：1）逻辑控制流，它提供给每个程序一个假象，好像它是在独占地使用处理器，2）私有地址空间，它提供给每个程序一个假象，好像它是在独占地使用主存。</p>
<p>在操作系统和应用程序之间的接口处，应用程序可以创建子进程，等待它们的子进程停止或者终止，运行新的程序，以及不活来自其他进程的信号。信号处理的语义是微妙的，并且随着系统不同而不同。然而，在与 Posix 兼容的系统上存在着一些机制，允许程序清楚地指定期望的信号处理语义。</p>
<h1 id="u865A_u62DF_u5B58_u50A8_u5668"><a href="#u865A_u62DF_u5B58_u50A8_u5668" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><p>一个系统中的进程是与其他进程共享 CPU 和主存资源的。然而，共享主存会形成一些特殊的挑战。随着对 CPU 需求的增长，进程以某种合理的平滑方式慢了下来。但是如果太多的进程需要太多的存储器，那么它们中的一些就根本无法运行。当一个程序没有空间可用时，那就是它运气不好了。存储器还很容易被破坏。如果某个进程不小心写了另一个进程使用的存储器，它就可能以某种完全和程序逻辑无关的令人迷惑的方式失败。</p>
<p>为了更加有效地管理存储器并且少出错，现代系统提供了一种对主存的抽象概念，叫做<strong>虚拟存储器(VM)</strong>。虚拟存储器是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟存储器提供了三个重要的能力：1）它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。2）它为每个进程提供了一致的地址空间，从而简化了存储器管理。3）它保护了每个进程的地址空间不被其他进程破坏。</p>
<p>虚拟存储器是计算机系统最重要的概念之一。它成功的一个主要原因就是因为它是沉默地、自动地工作的，不需要应用程序员的任何干涉。</p>
<h2 id="u7269_u7406_u548C_u865A_u62DF_u5BFB_u5740"><a href="#u7269_u7406_u548C_u865A_u62DF_u5BFB_u5740" class="headerlink" title="物理和虚拟寻址"></a>物理和虚拟寻址</h2><p>计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的<strong>物理地址(Physical Address, PA)</strong>。第一个字节的地址为 0，接下来的字节地址为 1，再下一个为 2，以此类推。给定这种简单的结构，CPU 访问存储器的最自然的方式就是使用物理地址。我们把这种方式称为<strong>物理寻址(physical addressing)</strong>。如下图所示</p>
<p><img src="/images/csapp9.1.jpg" alt="csapp9.1"></p>
<p>当 CPU 执行这条加载指令时，它会生成一个有效物理地址，通过存储器总线，把它传递给主存。主存取出从物理地址 4 处开始的 4 字节的字，并将它返回给 CPU，CPU 会将它存放在一个寄存器里。</p>
<p>早起的 PC 使用 物理寻址，现代处理器使用的是一种称为<strong>虚拟寻址(virtual addressing)</strong>的寻址形式，如下图所示：</p>
<p><img src="/images/csapp9.2.jpg" alt="csapp9.2"></p>
<p>使用虚拟寻址时，CPU 通过生成一个<strong>虚拟地址(Virtual Address, VA)</strong>来访问主存，这个虚拟地址在被送到存储器之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做<strong>地址翻译(address translation)</strong>。就像异常处理一样，地址翻译需要 CPU 硬件和操作系统之间的紧密合作。CPU 芯片上叫做<strong>存储器管理单元(Memory Management Unit, MMU)</strong>的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容是由操作系统管理的。</p>
<h2 id="u5730_u5740_u7A7A_u95F4"><a href="#u5730_u5740_u7A7A_u95F4" class="headerlink" title="地址空间"></a>地址空间</h2><p><strong>地址空间(address space)</strong>是一个非负整数地址的有序集合：{0, 1, 2, …}。如果地址空间中的整数是连续的，那么我们说它是一个<strong>线性地址空间(linear address space)</strong>。</p>
<p>地址空间的概念是很重要的，因为它清楚地区分了数据对象(字节)和它们的属性(地址)。</p>
<h2 id="u865A_u62DF_u5B58_u50A8_u5668_u4F5C_u4E3A_u7F13_u5B58_u7684_u5DE5_u5177"><a href="#u865A_u62DF_u5B58_u50A8_u5668_u4F5C_u4E3A_u7F13_u5B58_u7684_u5DE5_u5177" class="headerlink" title="虚拟存储器作为缓存的工具"></a>虚拟存储器作为缓存的工具</h2><p>概念上而言，虚拟存储器(VM)被组织为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，这个唯一的虚拟地址是作为到数组的索引的。VM 系统通过将虚拟存储器分割为<strong>虚拟页(Virtual Page, VP)</strong>的大小固定的块来处理这个问题。每个虚拟页的大小为 P=2^p 字节。类似地，物理存储器被分割为<strong>物理页(Physical Page, PP)</strong>，大小也为 P 字节(物理页也称为<strong>页帧(page frame)</strong>)。</p>
<p>在任意时刻，虚拟页面的集合部分都分为三个不相交的子集：</p>
<ul>
<li>未分配的：VM 系统还未分配(或者创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。</li>
<li>缓存的：当前缓存在物理存储器中的已分配页。</li>
<li>未缓存的：没有缓存在物理存储器中的已分配页。</li>
</ul>
<p><img src="/images/csapp9.3.jpg" alt="csapp9.3"></p>
<blockquote>
<p>DRAM 缓存的组织结构</p>
</blockquote>
<p>这里用<strong>SRAM 缓存</strong>来表示位于 CPU 和主存之间的 L1, L2 和 L3 高速缓存，并且用<strong>DRAM 缓存</strong>来表示虚拟存储器系统的缓存，它在主存中缓存虚拟页。</p>
<p>DRAM 缓存的组织结构完全是由巨大的不命中开销驱动的。因为大的不命中处罚和访问第一字节的开销，虚拟页往往很大，典型地是<br>4KB-2MB。由于大的不命中处罚，DRAM 缓存是全相连的，也就是说，任何虚拟页都可以放置在任何的物理页中。不命中时的替换策略也很重要，因为替换错了虚拟页的出发也非常高。因此，与硬件对 SRAM 缓存相比，操作系统对 DRAM 缓存使用了更复杂精密的替换算法。最后，因为对磁盘的访问时间很长，DRAM 缓存总是使用写回(write back)，而不是直写。</p>
<blockquote>
<p>页表</p>
</blockquote>
<p>同任何缓存一样，虚拟存储器系统必须有某种方法来判定一个虚拟页是否存放在 DRAM 中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理存储器中选择一个牺牲页，并将虚拟页从磁盘拷贝到 DRAM 中，替换这个牺牲页。</p>
<p>这些功能是由许多软硬件联合提供的，包括操作系统软、MMU(存储器管理单元)中的地址翻译硬件和一个存放在物理存储器中叫做<strong>页表(page table)</strong>的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。</p>
<p>下图展示了一个页表的基本组织结构。页表就是一个<strong>页表条目(Page Table Entry, PTE)</strong>的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。</p>
<p><img src="/images/csapp9.4.jpg" alt="csapp9.4"></p>
<blockquote>
<p>页命中</p>
</blockquote>
<p><img src="/images/csapp9.5.jpg" alt="csapp9.5"></p>
<blockquote>
<p>缺页</p>
</blockquote>
<p>DRAM 缓存不命中称为<strong>缺页(page fault)</strong>。在虚拟存储器的习惯说法中，块被称为页。在磁盘和存储器之间传送页的活动叫做<strong>交换(swapping)</strong>或者<strong>页面调度(paging)</strong>。</p>
<p><img src="/images/csapp9.6.jpg" alt="csapp9.6"></p>
<p><img src="/images/csapp9.7.jpg" alt="csapp9.7"></p>
<blockquote>
<p>分配页面</p>
</blockquote>
<p><img src="/images/csapp9.8.jpg" alt="csapp9.8"></p>
<blockquote>
<p>又是局部性救了我们</p>
</blockquote>
<p>尽管在整个运行过程中程序引用的不同页面的总数可能超出物理存储器总的大小，但是局部性原则保证了在任意时刻，程序往往在一个较小的<strong>活动页面(active page)</strong>集合上工作，这个集合叫做<strong>工作集(working set)</strong>或者<strong>常驻集(resident set)</strong>。</p>
<h2 id="u865A_u62DF_u5B58_u50A8_u5668_u4F5C_u4E3A_u5B58_u50A8_u5668_u7BA1_u7406_u7684_u5DE5_u5177"><a href="#u865A_u62DF_u5B58_u50A8_u5668_u4F5C_u4E3A_u5B58_u50A8_u5668_u7BA1_u7406_u7684_u5DE5_u5177" class="headerlink" title="虚拟存储器作为存储器管理的工具"></a>虚拟存储器作为存储器管理的工具</h2><p>操作系统为每个进程提供了一个独立的页表，因为也就是一个独立的虚拟地址空间。如下图所示：</p>
<p><img src="/images/csapp9.9.jpg" alt="csapp9.9"></p>
<h2 id="u865A_u62DF_u5B58_u50A8_u5668_u4F5C_u4E3A_u5B58_u50A8_u5668_u4FDD_u62A4_u7684_u5DE5_u5177"><a href="#u865A_u62DF_u5B58_u50A8_u5668_u4F5C_u4E3A_u5B58_u50A8_u5668_u4FDD_u62A4_u7684_u5DE5_u5177" class="headerlink" title="虚拟存储器作为存储器保护的工具"></a>虚拟存储器作为存储器保护的工具</h2><p>如果一条指令违反了许可操作，那么 CPU 就出发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Unix shell 一般将这种异常报告为<strong>段错误(sgmentation fault)</strong>。</p>
<p><img src="/images/csapp9.10.jpg" alt="csapp9.10"></p>
<h2 id="u5730_u5740_u7FFB_u8BD1"><a href="#u5730_u5740_u7FFB_u8BD1" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>地址翻译的基础知识。</p>
<p><img src="/images/csapp9.11.jpg" alt="csapp9.11"></p>
<p><img src="/images/csapp9.12.jpg" alt="csapp9.12"></p>
<p>后面的暂略，几乎很少接触</p>
<h1 id="u7CFB_u7EDF_u7EA7_I/O"><a href="#u7CFB_u7EDF_u7EA7_I/O" class="headerlink" title="系统级 I/O"></a>系统级 I/O</h1><p>输入/输出是在主存和外部设备之间拷贝数据的过程。所有语言的运行时系统都提供执行 I/O 的较高级别的工具。</p>
<h2 id="Unix_I/O"><a href="#Unix_I/O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p>一个 Unix 文件就是一个 m 字节的序列。所有的 I/O 设备，如网络、磁盘和终端，都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许 Unix 内核引出一个简单、低级的应用接口，称为 Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行：</p>
<ul>
<li>打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O 设备。内核返回一个小的非负整数，叫做<strong>描述符</strong>，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。</li>
<li>改变当前的文件位置。</li>
<li>读写文件</li>
<li>关闭文件</li>
</ul>
<h2 id="u6253_u5F00_u548C_u5173_u95ED_u6587_u4EF6"><a href="#u6253_u5F00_u548C_u5173_u95ED_u6587_u4EF6" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h2><p>进程是通过调用 <code>open</code> 函数来打开一个已存在的文件或者创建一个新文件的。若成功则返回新文件描述符，否为返回 -1。</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int open(char *filename, int flags, mode_t mode);
</code></pre><p>进程通过调用 <code>close</code> 函数关闭一个打开的文件。若成功则返回 0，否则 -1。</p>
<pre><code>#include &lt;unistd.h&gt;

int close(int fd);
</code></pre><h2 id="u8BFB_u548C_u5199_u6587_u4EF6"><a href="#u8BFB_u548C_u5199_u6587_u4EF6" class="headerlink" title="读和写文件"></a>读和写文件</h2><p>应用程序是通过分别调用 <code>read</code> 和 <code>write</code> 函数来执行输入和输出的。</p>
<pre><code>#include &lt;unistd.h&gt;

ssize_t read(int fd, void *buf, size_t n);
ssize_t write(int fd, const void *buf, size_t n);
</code></pre><h2 id="u7528_RIO__u5305_u5065_u58EE_u5730_u8BFB_u5199"><a href="#u7528_RIO__u5305_u5065_u58EE_u5730_u8BFB_u5199" class="headerlink" title="用 RIO 包健壮地读写"></a>用 RIO 包健壮地读写</h2><p>提供两类不同的函数：无缓冲的输入输出函数与带缓冲的输入函数。</p>
<h2 id="u8BFB_u53D6_u6587_u4EF6_u5143_u6570_u636E"><a href="#u8BFB_u53D6_u6587_u4EF6_u5143_u6570_u636E" class="headerlink" title="读取文件元数据"></a>读取文件元数据</h2><p>应用程序能够通过调用 <code>stat</code> 和 <code>fstat</code> 函数，检索到关于文件的信息，有时也称为文件的<strong>元数据(metadata)</strong>。</p>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;

int stat(const char *filename, struct stat *buf);
int fstat(int fd, struct stat *buf);
</code></pre><p><img src="/images/csapp10.8.jpg" alt="csapp10.8"></p>
<h2 id="u5171_u4EAB_u6587_u4EF6"><a href="#u5171_u4EAB_u6587_u4EF6" class="headerlink" title="共享文件"></a>共享文件</h2><p>可以用许多不同的方式来共享 Unix 文件。内核用三个相关的数据结构来表示打开的文件：</p>
<ul>
<li>描述符表(descriptor table)。每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表指向<strong>文件表</strong>中的一个表项。</li>
<li>文件表(file table)。打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项包括当前的文件位置、**引用计数(reference count)，以及一个指向 <code>v-node 表</code>中对应表项的指针。</li>
<li>v-node 表(v-node table)。同文件表一样，所有的进程共享这张表。每个表项包含 stat 结构中的大多数信息。</li>
</ul>
<p><img src="/images/csapp10.11.jpg" alt="csapp10.11"></p>
<p><img src="/images/csapp10.12.jpg" alt="csapp10.12"></p>
<p><img src="/images/csapp10.13.jpg" alt="csapp10.13"></p>
<h2 id="I/O__u91CD_u5B9A_u5411"><a href="#I/O__u91CD_u5B9A_u5411" class="headerlink" title="I/O 重定向"></a>I/O 重定向</h2><p>Unix shell 提供了 I/O 重定向操作符，允许用户将磁盘文件和标准输入输出联系起来，例如</p>
<pre><code>unix&gt; ls &gt; foo.txt
</code></pre><p><img src="/images/csapp10.14.jpg" alt="csapp10.14"></p>
<h2 id="u6807_u51C6_I/O"><a href="#u6807_u51C6_I/O" class="headerlink" title="标准 I/O"></a>标准 I/O</h2><p>ANSI C 定义了一组高级输入输出函数，称为<strong>标准 I/O 库</strong>，为程序员提供了 Unix I/O 的较高级别的替代。这个库(libc)提供了打开和关闭文件的函数(<code>fopen</code>和<code>fclose</code>)，读和写字节的函数(<code>fread</code>和<code>fwrite</code>)，读和写字符串的函数(<code>fgets</code>和<code>fputs</code>)，以及复杂的格式化的 I/O 函数(<code>scanf</code>和<code>printf</code>)。</p>
<p>标准 I/O 库将一个打开的文件模型化为一个<strong>流</strong>。对于程序员而言，一个流就是一个指向 FILE 类型的结构的指针。</p>
<h2 id="u7EFC_u5408_uFF1A_u8BE5_u4F7F_u7528_u54EA_u4E9B_I/O__u51FD_u6570"><a href="#u7EFC_u5408_uFF1A_u8BE5_u4F7F_u7528_u54EA_u4E9B_I/O__u51FD_u6570" class="headerlink" title="综合：该使用哪些 I/O 函数"></a>综合：该使用哪些 I/O 函数</h2><p><img src="/images/csapp10.15.jpg" alt="csapp10.15"></p>
<p>标准 I/O 流，从某种意义上而言是<strong>全双工</strong>的，因为程序能够在同一个流上执行输入和输出。然而，对流的限制和对套接字的限制，有时候会互相冲突：</p>
<ul>
<li>限制一：跟在输出函数之后的输入函数。如果中间没有插入对 <code>fflush</code>, <code>fseek</code>, <code>fsetpos</code> 或者 <code>rewind</code> 的调用，一个输入函数不能跟随在一个输出函数之后。<code>fflush</code> 函数清空与流相关的缓冲区。后三个函数使用 Unix I/O <code>lseek</code> 函数来重置当前的文件位置。</li>
<li>限制二：跟在输入函数之后的输出函数。如果中间没有插入对 <code>fseek</code>, <code>fsetpos</code> 或者 <code>rewind</code> 的调用，一个输出函数不能跟随在一个输入函数之后，除非该输入函数遇到了一个 EOF。</li>
</ul>
<p>这些限制给网络应用带来了一个问题，因为对套接字使用 <code>lseek</code> 函数是非法的，所以在网络套接字上不要使用标准 I/O 进行输入和输出，而要使用健壮的 <code>RIO</code> 函数。</p>
<h2 id="u5C0F_u7ED3-7"><a href="#u5C0F_u7ED3-7" class="headerlink" title="小结"></a>小结</h2><p>Unix 提供了少量的系统级函数，它们允许应用程序打开、关闭、读和写文件，提取文件的元数据，以及执行 I/O 重定向。 Unix 的读和写操作会出现不足值，应用程序必须能正确地预计和处理这种情况。应用程序不应直接调用 Unix I/O 函数，而应该使用 RIO 包，RIO 包通过反复执行读写操作，直到传送完所有的请求数据，自动处理不足值。</p>
<p>Unix 内核使用三个相关的数据结构来表示打开的文件。描述符表中的表项指向打开文件表中的表项，而打开文件表中的表项又指向 v-node 表中的表项。</p>
<p>标准 I/O 库是基于 Unix I/O 实现的，并提供了一组强大的高级 I/O 例程。对于大多数应用程序而言，标准 I/O 更简单，是优于 Unix I/O 的选择。然而，因为对标准 I/O 和网络文件的一些相互不兼容的限制，Unix I/O 比标准 I/O 更适用于网络应用程序。</p>
<h1 id="u7F51_u7EDC_u7F16_u7A0B"><a href="#u7F51_u7EDC_u7F16_u7A0B" class="headerlink" title="网络编程"></a>网络编程</h1><p>网络应用随处可见。有趣的是，所有的网络应用都是基于相同的基本编程模型，有着相似的整体逻辑结构，并且一来相同的编程接口。</p>
<p>网络应用依赖于很多在系统研究正已经学习过的概念，例如，进程、信号、字节顺序、存储器映射以及动态存储分配，都扮演着重要的角色。</p>
<h2 id="u5BA2_u6237_u7AEF-_u670D_u52A1_u5668_u7F16_u7A0B_u6A21_u578B"><a href="#u5BA2_u6237_u7AEF-_u670D_u52A1_u5668_u7F16_u7A0B_u6A21_u578B" class="headerlink" title="客户端-服务器编程模型"></a>客户端-服务器编程模型</h2><p>每个网络应用都是基于<strong>客户端-服务器模型</strong>模型的。采用这个模型，一个应用是由一个<strong>服务器</strong>进程和一个或者多个<strong>客户端</strong>进程组成。服务器管理某种<strong>资源</strong>，并且通过操作这种资源来为它的客户端提供某种<strong>服务</strong>。</p>
<p>客户端-服务器模型中的基本操作是<strong>事务(transaction)</strong>，由四步组成，如下图所示：</p>
<p><img src="/images/csapp11.1.jpg" alt="csapp11.1"></p>
<h2 id="u7F51_u7EDC"><a href="#u7F51_u7EDC" class="headerlink" title="网络"></a>网络</h2><p>客户端和服务器通常运行在不同的主机上，并且通过<strong>计算机网络</strong>的硬件和软件资源来通信。对于一台主机而言，网络只是又一种 I/O 设备，作为数据源和数据接收方，如下图所示。</p>
<p><img src="/images/csapp11.2.jpg" alt="csapp11.2"></p>
<p>物理上而言，网络是一个按照地理远近组成的层次系统。最底层是 LAN(Local Area Network, 局域网)，在一个建筑或者校园范围内。迄今为止，最流行的局域网技术是<strong>以太网(Ethernet)</strong>。</p>
<p>每个以太网适配器都有一个全球唯一的 48 位地址，一台主机可以发送一段位，称为<strong>帧(frame)</strong>，到这个网段内的其他任何主机。每个帧包括一些固定数量的<strong>头部(header)</strong>位，用来标识此帧的源和目的地址以及此帧的长度，伺候紧随的就是数据位的<strong>有效载荷</strong>。每个主机适配器都能看到这个帧，但是只有目的主机实际读取它。</p>
<p>使用一些电缆和叫做网桥(bridge)的小盒子，多个以太网段可以连接成较大的局域网，称为**桥接以太网(bridged Ethernet)，如下图所示：</p>
<p><img src="/images/csapp11.4.jpg" alt="csapp11.4"></p>
<p>在层次更高的级别中，多个不兼容的局域网可以通过叫做<strong>路由器(router)</strong>的忒书计算机连接起来，组成一个<strong>internet(互联网络)</strong>。</p>
<p><img src="/images/csapp11.6.jpg" alt="csapp11.6"></p>
<p>协议软件消除了不同网络之间的差异，必须具备两种基本能力：命名机制和传送机制。</p>
<p>每台因特网主机都运行实现 <strong>TCP/IP 协议(Transmission Control Protocol/Internet Protocol)</strong>的软件，几乎每个现代计算机系统都支持这个协议。</p>
<p><img src="/images/csapp11.8.jpg" alt="csapp11.8"></p>
<p>TCP/IP 实际上是一个协议族，其中每一个都提供不同的功能。从程序员角度，我们可以把因特网看做一个世界范围的主机集合，满足以下特性：</p>
<ul>
<li>主机集合被映射为一组 32 位的 IP 地址</li>
<li>这组 IP 地址被映射为一组称为<strong>因特网域名(Internet domain name)</strong>的标识符</li>
<li>因特网主机上的进程能够通过<strong>连接(connection)</strong>和任何其他因特网主机上的进程通信</li>
</ul>
<blockquote>
<p>IP 地址</p>
</blockquote>
<p>一个 IP 地址就是一个 32 位无符号整数。IP 地址通常是以一种称为<strong>点分十进制表示法</strong>来表示的，这里，每个字节由它的十进制值表示，并且用句点和其他字节间分开。</p>
<p>因特网程序使用 <code>inet_aton</code> 和 <code>inet_ntoa</code> 函数来实现 IP 地址和点分十进制串之间的转换</p>
<pre><code>#include &lt;arpa/inet.h&gt;

int inet_aton(const char *cp, struct in_addr *inp);
char *inet_ntoa(struct in_addr in);
</code></pre><p>n 表示网络(network)，a 表示应用(application)。</p>
<blockquote>
<p>因特网域名</p>
</blockquote>
<p>域名集合形成了一个层次结构，每个域名编码了它在这个层次中的位置。</p>
<p><img src="/images/csapp11.10.jpg" alt="csapp11.10"></p>
<blockquote>
<p>因特网连接</p>
</blockquote>
<p>因特网客户端和服务器通过在<strong>连接</strong>上发送和接收字节流来通信。从连接一对进程的意义上而言，连接是点对点的。从数据可以同时双向流动的角度来说，它是<strong>全双工</strong>的。并且由源进程发出的字节流最终被目的进程以它发出的顺序收到它的角度来说，它是可靠的。</p>
<p>一个<strong>套接字</strong>是连接的一个端点。每个套接字都有相应的<strong>套接字地址</strong>，是由一个因特网地址和一个 16 位的整数<strong>端口</strong>组成的，用<code>地址:端口</code>来表示。当客户端发起一个连接请求时，客户端套接字地址中的端口是由内核自动分配的，称为<strong>临时端口(ephemeral port)</strong>。然而，服务器套接字地址中的端口通常是某个<strong>知名的端口</strong>，是和这个服务相对应的。例如，Web 服务器通常使用端口 80，而电子邮件服务器使用端口 25。在 Unix 机器上，文件 <code>/etc/services</code> 包含一张这台机器提供的服务以及它们的知名端口号的综合列表。</p>
<p>一个连接由它两端的套接字地址唯一确定。这对套接字地址叫做<strong>套接字对(socket pair)</strong>，由下列元组来表示：</p>
<pre><code>(cliaddr:cliport, servaddr:servport)
</code></pre><p><img src="/images/csapp11.13.jpg" alt="csapp11.13"></p>
<h2 id="u5957_u63A5_u5B57_u63A5_u53E3"><a href="#u5957_u63A5_u5B57_u63A5_u53E3" class="headerlink" title="套接字接口"></a>套接字接口</h2><p><strong>套接字接口(socket interface)</strong>是一组函数，它们和 Unix I/O 函数结合起来，用以创建网络应用。</p>
<p><img src="/images/csapp11.14.jpg" alt="csapp11.14"></p>
<blockquote>
<p>套接字地址结构</p>
</blockquote>
<p>从 Unix 内核的角度来看，一个套接字就是通信的一个端点。从 Unix 程序的角度来看，套接字就是一个有相应描述符的打开文件。</p>
<blockquote>
<p>socket 函数</p>
</blockquote>
<p>客户端和服务器使用 <code>socket</code> 函数来创建一个<strong>套接字描述符(socket descriptor)</strong></p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol);
</code></pre><blockquote>
<p>connect 函数</p>
</blockquote>
<p>客户端通过调用 <code>connect</code> 函数来建立和服务器的连接。</p>
<pre><code>#include &lt;sys/socket.h&gt;

int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);
</code></pre><p>剩下还有<code>bind</code>, <code>listen</code>, <code>accept</code> 等函数，略</p>
<h2 id="Web__u670D_u52A1_u5668"><a href="#Web__u670D_u52A1_u5668" class="headerlink" title="Web 服务器"></a>Web 服务器</h2><blockquote>
<p>Web 基础</p>
</blockquote>
<p>Web 客户端和服务器之间的交互用的是一个基于文本的应用级协议，叫做 HTTP(Hypertext Transfer Protocol)。HTTP 是一个简单的协议。一个 Web客户端打开一个到服务器的因特网连接，并且请求某些内容。服务器响应所请求的内容，然后关闭连接。浏览器读取这些内容，并把它显示在屏幕上。</p>
<blockquote>
<p>Web 内容</p>
</blockquote>
<p>对于 Web 客户端和服务器而言，内容是一个与 MIME(Multipurpose Internet Mail Extensions)类型相关的字节序列。</p>
<p><img src="/images/csapp11.22.jpg" alt="csapp11.22"></p>
<p>Web 服务器以两种不同的方式向客户端提供内容：</p>
<ul>
<li>取一个磁盘文件，并将它的内容返回给客户端。磁盘文件称为<strong>静态内容(static content)</strong>，而返回文件给客户端的过程称为<strong>服务静态内容(serving static content)</strong>。</li>
<li>运行一个可执行文件，并将它的输出返回给客户端。运行时可执行文件产生的输出称为<strong>动态内容(dynamic content)</strong>，而运行程序并返回它的输出到客户端的过程称为<strong>服务动态内容(serving dynamic content)</strong>。</li>
</ul>
<p>每条由 Web 服务器返回的内容都是和它管理的某个文件相关联的。这些文件中的每一个都有一个唯一的名字，叫做 URL(Universal Resource Locator)。</p>
<p>关于服务器如何解释一个 URL 的后缀，以下几点需要理解：</p>
<ul>
<li>确定一个 URL 指向的是静态内容还是动态内容没有标准的规则。每个服务器对它所管理的文件都有自己的规则。一种常见方法是，确定一组目录，例如 cgi-bin，所有的可执行文件都必须存放这些目录中。</li>
<li>后缀中的最开始的那个 <code>/</code> 不表示 Unix 的根目录。相反，它表示的是被请求内容类型的主目录。例如，可以将一个服务器配置成这样：所有的静态内容存放在目录 <code>/usr/httpd/html</code> 下。</li>
<li>最小的 URL 后缀是 <code>/</code> 字符，所有服务器将其扩展为某个默认的主页，例如 <code>/index.html</code>。这解释了为什么在浏览器中键入一个域名就可以取出一个网站的主页。浏览器在 URL 后添加缺失的 <code>/</code>，之后服务器把 <code>/</code> 扩展到某个默认的文件名。</li>
</ul>
<blockquote>
<p>HTTP 事务</p>
</blockquote>
<p>因为 HTTP 是基于在因特网连接上传送的文本行的，我们可以使用 Unix 的 TELNET 程序来和因特网上的任何 Web 服务器执行事务。</p>
<p><img src="/images/csapp11.23.jpg" alt="csapp11.23"></p>
<p><strong>HTTP 请求</strong></p>
<p>一个 HTTP 请求的组成是这样的：一个<strong>请求行(request line)</strong>(line 5)，后面跟随零个或更多个<strong>请求报头(request header)</strong>(line 6)，在跟随一个空的文本行来终止报头列表(line 7)。一个请求行的形式是</p>
<pre><code>&lt;method&gt; &lt;url&gt; &lt;version&gt;
</code></pre><p>HTTP 支持不同的方法，包括 GET, POST, OPTIONS, HEAD, PUT, DELETE 和 TRACE。主要应用的是 GET 方法。</p>
<p><strong>HTTP 响应</strong></p>
<p>HTTP 响应和 HTTP 请求是相似的。一个 HTTP 响应的组成是这样的：一个<strong>响应行(response line)</strong>(line 8)后面跟随着零个或者更多的<strong>响应报头(response header)</strong>(line 9-13)，再跟随一个终止报头的空行(line 14)，在跟随一个<strong>响应主体(response body)</strong>(line 15-17)。一个响应行的格式是</p>
<pre><code>&lt;version&gt; &lt;status code&gt; &lt;status message&gt;
</code></pre><p>版本字段描述的是响应所遵循的 HTTP 版本。<strong>状态码(status code)</strong>是一个三位数的正整数，指明对请求的处理。<strong>状态消息(status message)</strong>给出与错误代码等价的英文描述。第9-13行的响应报头提供了关于响应的附加信息。针对我们的目的，两个最重要的报头是 <code>Content-Type</code>(line 12)，它告诉客户端响应主体中内容 MIME 类型；以及 <code>Content-Length</code>(line 13)，用来指示响应主体的字节大小。</p>
<p><img src="/images/csapp11.24.jpg" alt="csapp11.24"></p>
<h2 id="u5C0F_u7ED3-8"><a href="#u5C0F_u7ED3-8" class="headerlink" title="小结"></a>小结</h2><p>Web 服务器使用 HTTP 协议和它们的客户端彼此通信。浏览器向服务器请求静态或者动态内容。CGI 标准提供了一组规则，来管理客户端如何将程序参数传递给服务器，服务器如何将这些参数以及其他信息传递给子进程，以及子进程如何将它的输出发送会客户端。</p>
<h1 id="u5E76_u53D1_u7F16_u7A0B"><a href="#u5E76_u53D1_u7F16_u7A0B" class="headerlink" title="并发编程"></a>并发编程</h1><p>应用级并发在以下情况下很有用：</p>
<ul>
<li>访问慢速 I/O 设备</li>
<li>与人交互</li>
<li>通过推迟工作以降低延迟</li>
<li>服务多个网络客户端</li>
<li>在多核机器上进行并行计算</li>
</ul>
<p>使用应用级并发的应用程序称为<strong>并发程序(concurrent program)</strong>。现代操作系统提供了三种基本的构造并发程序的方法：</p>
<ul>
<li>进程。用这种方法，每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显式的**进程间通信(interprocess communication, IPC)机制。</li>
<li>I/O 多路复用。在这种形式的并发编程中，应用程序在一个进程的上下文中显式地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态。因为程序是一个单独的进程，所以所有的流都共享同一个地址空间。</li>
<li>线程。线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。你可以把线程看成是其他两种方式的混合体，像进程流一样由内核进行调度，而像 I/O 多路复用一样共享同一个虚拟地址空间。</li>
</ul>
<h2 id="u57FA_u4E8E_u8FDB_u7A0B_u7684_u5E76_u53D1_u7F16_u7A0B"><a href="#u57FA_u4E8E_u8FDB_u7A0B_u7684_u5E76_u53D1_u7F16_u7A0B" class="headerlink" title="基于进程的并发编程"></a>基于进程的并发编程</h2><p>构造并发程序最简单的方法就是用进程，使用那些大家都很熟悉的函数，像 <code>fork</code>, <code>exec</code> 和 <code>waitpid</code>。</p>
<p><img src="/images/csapp12.1.jpg" alt="csapp12.1"></p>
<p><img src="/images/csapp12.2.jpg" alt="csapp12.2"></p>
<p><img src="/images/csapp12.3.jpg" alt="csapp12.3"></p>
<p><img src="/images/csapp12.4.jpg" alt="csapp12.4"></p>
<p>对于在父、子进程间共享状态信息，进程有一个非常清晰的模型：共享文件表，但是不共享用户地址空间。进程有独立的地址空间既是优点也是缺点。这样一来，一个进程不可能不小心覆盖另一个进程的虚拟存储器，这就消除了许多令人迷惑的错误。</p>
<p>另一方面，独立的地址空间使得进程共享状态信息变得更加困难。为了共享信息，它们必须使用显式的 IPC 机制。基于进程的设计的另一个缺点是，它们往往比较慢，因为进程控制和 IPC 的开销很高。</p>
<h2 id="u57FA_u4E8E_I/O__u591A_u8DEF_u590D_u7528_u7684_u5E76_u53D1_u7F16_u7A0B"><a href="#u57FA_u4E8E_I/O__u591A_u8DEF_u590D_u7528_u7684_u5E76_u53D1_u7F16_u7A0B" class="headerlink" title="基于 I/O 多路复用的并发编程"></a>基于 I/O 多路复用的并发编程</h2><p>I/O 多路复用可以用作并发<strong>事件驱动(event-driven)</strong>程序的基础，在事件驱动程序中，流是因为某种事件而前进的。一般概念是将逻辑流模型化为状态机。不严格地说，一个<strong>状态机(state machine)</strong>就是一组<strong>状态(state)</strong>、<strong>输入事件(input event)</strong>和<strong>转移(transition)</strong>，其中转移就是将状态和输入事件映射到状态。每个状态都将一个(输入状态，输入事件)对映射到一个输出状态。<strong>自循环(self-loop)</strong>是同一组输入和输出状态之间的转移。通常把状态机花城有向图，其中节点表示状态，有向弧表示转移，而弧上的标号表示输入事件。一个状态机从某种初始状态开始执行。每个输入事件都会引发一个从当前状态到下一状态的转移。</p>
<p>事件驱动设计的一个优点是，它比基于进程的设计给了程序员更多的对程序行为的控制。另一个优点是在流之间共享数据变得很容易，而且事件驱动设计常常比基于进程的设计要高效得多，因为它们不需要进程上下文切换来调度新的流。</p>
<p>事件驱动设计的一个明显的缺点就是编码复杂，另一重大缺点时它们不能充分利用多核处理器。</p>
<h2 id="u57FA_u4E8E_u7EBF_u7A0B_u7684_u5E76_u53D1_u7F16_u7A0B"><a href="#u57FA_u4E8E_u7EBF_u7A0B_u7684_u5E76_u53D1_u7F16_u7A0B" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h2><p><strong>线程(thread)</strong>就是运行在进程上下文中的逻辑流，由内核自动调度。每个线程都有它自己的<strong>线程上下文(thread context)</strong>，包括一个唯一的整数<strong>线程ID(Thread ID, TID)</strong>、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。</p>
<p><img src="/images/csapp12.12.jpg" alt="csapp12.12"></p>
<h2 id="u591A_u7EBF_u7A0B_u7A0B_u5E8F_u4E2D_u7684_u5171_u4EAB_u53D8_u91CF"><a href="#u591A_u7EBF_u7A0B_u7A0B_u5E8F_u4E2D_u7684_u5171_u4EAB_u53D8_u91CF" class="headerlink" title="多线程程序中的共享变量"></a>多线程程序中的共享变量</h2><p>从一个程序员的角度来看，线程很有吸引力的一个方面就是多个线程很容易共享相同的程序变量。然而，这种共享也是很棘手的。</p>
<blockquote>
<p>线程存储器模型</p>
</blockquote>
<p>一组并发线程运行在一个进程的上下文中。每个线程都有它自己独立的<strong>线程上下文</strong>，包括线程 ID、栈、栈指针、程序计数器、条件码和通用目的寄存器。每个线程和其他线程一个共享进程上下文的剩余部分。这包括整个用户虚拟地址空间，它是由只读文本(代码)、读/写数据、堆以及所有的共享库代码和数据区域组成的。</p>
<p>从实际操作的角度来说，让一个线程去读写另一个线程的寄存器是不可能的。寄存器是从不共享的，而虚拟存储器总是共享的。</p>
<blockquote>
<p>将变量映射到存储器</p>
</blockquote>
<p>线程化的 C 程序中变量根据它们的存储类型被映射到虚拟存储器：</p>
<ul>
<li>全局变量：在运行时，虚拟存储器的读/写区域只包含每个全局变量的一个实例，任何线程都可以引用</li>
<li>本地自动变量：定义在函数内部但是没有 static 属性的变量。在运行时，每个线程的栈都包含它自己的所有本地自动变量的实例</li>
<li>本地静态变量：定义在函数内部并有 static 属性的变量，和全局变量一样</li>
</ul>
<h2 id="u7528_u4FE1_u53F7_u91CF_u540C_u6B65_u7EBF_u7A0B"><a href="#u7528_u4FE1_u53F7_u91CF_u540C_u6B65_u7EBF_u7A0B" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h2><p>共享变量是十分方便的，但是它们也引入了<strong>同步错误(synchronization error)</strong>的可能性。一般而言，你没有办法预测操作系统是否将为你的线程选择一个正确的顺序。</p>
<p>一些关键词：进度图，信号量，使用信号量来实现互斥，生产者-消费者问题，两类读者-写者问题</p>
<h2 id="u5176_u4ED6_u5E76_u53D1_u95EE_u9898"><a href="#u5176_u4ED6_u5E76_u53D1_u95EE_u9898" class="headerlink" title="其他并发问题"></a>其他并发问题</h2><p>这些典型问题是任何类型的并发流操作共享资源时都会出现的。</p>
<blockquote>
<p>线程安全</p>
</blockquote>
<p>四个(不相交的)线程不安全函数类：</p>
<ul>
<li>不保护共享变量的函数</li>
<li>保持跨越多个调用的状态的函数</li>
<li>返回指向静态变量的指针的函数</li>
<li>调用线程不安全函数的函数</li>
</ul>
<blockquote>
<p>可重入性</p>
</blockquote>
<p>其特点在于当被多个线程调用时，不会引入任何共享数据。</p>
<p><img src="/images/csapp12.37.jpg" alt="csapp12.37"></p>
<blockquote>
<p>在线程化的程序中使用已存在的库函数</p>
</blockquote>
<p>大多数 Unix 函数，包括定义在标准 C 库中的函数都是线程安全，只有一小部分是例外：</p>
<p><img src="/images/csapp12.39.jpg" alt="csapp12.39"></p>
<blockquote>
<p>竞争</p>
</blockquote>
<p>当一个程序的正确性依赖于一个线程要在另一个线程达到 y 点之前达到它的控制流中的 x 点时，就会发生<strong>竞争(race)</strong>。</p>
<blockquote>
<p>死锁</p>
</blockquote>
<p>指的是一组线程被阻塞了，等待一个永远也不会为真的条件。进度图对于理解死锁是一个无价的工具。</p>
<p><img src="/images/csapp12.42.jpg" alt="csapp12.42"></p>
<p><img src="/images/csapp12.43.jpg" alt="csapp12.43"></p>
<p>重叠的禁止区域引起了一组称为<strong>死锁区域(deadlock region)</strong>的状态。</p>
<h2 id="u5C0F_u7ED3-9"><a href="#u5C0F_u7ED3-9" class="headerlink" title="小结"></a>小结</h2><p>无论哪种并发机制，同步对于共享数据的并发访问都是一个困难的问题。提出对信号的 P 和 V 操作就是为了帮助解决这个问题。信号量操作可以用来提供对共享数据的互斥访问，也对诸如生产者-消费者程序中有限缓冲区和读者-写者系统中的共享对象这样的资源访问进行调度。</p>
<p>并发也引入了其他一些困难的问题。被线程调用的函数必须具有一种称为线程安全的属性。竞争和死锁是并发程序中出现的另一些困难的问题。当程序员错误地假设逻辑流该如何调度时，就会发生竞争。当一个流等待一个永远不会发生的事件时，就会产生死锁。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是我之前自学时的笔记，本文的内容为第二版，现在最新是第三版。</p>
<p><em>Notes from Da Wang, Feb.2 2015</em></p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="原理" scheme="http://wdxtub.com/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
