<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-03-20T13:37:01.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[iTerm2 指南]]></title>
    <link href="http://wdxtub.com/2016/03/20/iterm2-guide/"/>
    <id>http://wdxtub.com/2016/03/20/iterm2-guide/</id>
    <published>2016-03-20T13:36:10.000Z</published>
    <updated>2016-03-20T13:37:01.000Z</updated>
    <content type="html"><![CDATA[<p>这里是 iTerm2 的基本入门操作，熟悉之后可以大幅提高效率。</p>
<a id="more"></a>
<hr>
<h2 id="u5149_u6807_u63A7_u5236"><a href="#u5149_u6807_u63A7_u5236" class="headerlink" title="光标控制"></a>光标控制</h2><ul>
<li>ctrl + a: 到行首</li>
<li>ctrl + e: 行末</li>
<li>ctrl + f/b: 前进后退，相当于左右方向键，但是显然比移开手按方向键更快</li>
<li>ctrl + p: 上一条命令，相当于方向键上</li>
<li>ctrl + r: 搜索命令历史，这个大家都应该很熟悉了</li>
<li>ctrl + d: 删除当前字符</li>
<li>ctrl + h: 删除之前的字符</li>
<li>ctrl + w: 删除光标前的单词</li>
<li>ctrl + k: 删除到文本末尾</li>
<li>ctrl + t: 交换光标处文本</li>
<li>⌘ + —/+/0: 调整字体大小</li>
<li>⌘ + r:清屏，其实是滚到新的一屏，并没有清空。ctrl + l 也可以做到。</li>
</ul>
<h2 id="u7A97_u53E3_u64CD_u4F5C"><a href="#u7A97_u53E3_u64CD_u4F5C" class="headerlink" title="窗口操作"></a>窗口操作</h2><ul>
<li>新建窗口：shift + command + d（横向）command + d（竖向）</li>
<li>关闭窗口：shift + command + w</li>
<li>前一个窗口：command + `</li>
<li>后一个窗口：command + ~</li>
<li>进入窗口 1,2,3：option + command + 编号</li>
</ul>
<h2 id="u6807_u7B7E_u9875_u64CD_u4F5C"><a href="#u6807_u7B7E_u9875_u64CD_u4F5C" class="headerlink" title="标签页操作"></a>标签页操作</h2><ul>
<li>新建标签页: Command + T</li>
<li>关闭标签页: Command + W</li>
<li>前一个标签页: Command + 左方向键，Shift + Command + [</li>
<li>后一个标签页: Command + 右方向键，Shitf + Command + ]</li>
<li>进入标签页1，2，3…: Command + 标签页编号</li>
<li>Expose 标签页: Option + Command + E（将标签页打撒到全屏，并可以全局搜索所有的标签页）</li>
</ul>
<h2 id="u9762_u677F_u64CD_u4F5C"><a href="#u9762_u677F_u64CD_u4F5C" class="headerlink" title="面板操作"></a>面板操作</h2><ul>
<li>垂直分割: Command + D</li>
<li>水平分割: Shift + Command + D</li>
<li>前一个面板: Command + [</li>
<li>后一个面板: Command + ]</li>
<li>切换到上/下/左/右面板: Option + Command + 上下左右方向键</li>
</ul>
<h2 id="u5176_u4ED6_u529F_u80FD"><a href="#u5176_u4ED6_u529F_u80FD" class="headerlink" title="其他功能"></a>其他功能</h2><ul>
<li>支持自定义全局快捷键用于显示和隐藏iTerm2 Preference -&gt; Keys －&gt; Show/hide iTerm2 with a system-wide hotkey 打上勾之后</li>
<li>进入和退出全屏: Command + Enter</li>
<li>查看当前终端中光标的位置: Command + /</li>
<li>命令自动补全: Command + ;（很少用这个，还是感觉Zsh的补全更好用）</li>
<li>开启和关闭背景半透明: Command + u</li>
<li>清屏（重置当前终端）: Command + r</li>
</ul>
<h2 id="u6587_u672C_u9009_u53D6"><a href="#u6587_u672C_u9009_u53D6" class="headerlink" title="文本选取"></a>文本选取</h2><p>文本选取有使用鼠标和不使用鼠标两种方式。</p>
<p>使用鼠标</p>
<p>默认情况下，选取的文字会自动复制到剪切板，可以使用以下方式进行文本选取：</p>
<ul>
<li>常见的点击并拖拽方式</li>
<li>双击选取整个单词</li>
<li>三击选取整行</li>
<li>选取某一部分，按住Shift，再点击某处，可以选取整个矩形内的文本（类似Windows下按住Shift可以批量选取图标）</li>
<li>按住Command + Option，可以用鼠标画出一个矩形，用类似截图的方式选取文本 另外，还可以使用鼠标完成以下操作： 按住Command然后点击某个URL，会在浏览器中打开这个URL，点击某个文件夹，会在Finder里打开这个文件夹（再也不用open . 啦），点击某个文件名，会打开这个文件（文本文件支持MacVim，TextMate和BBEdit，如果后面跟随一个冒号和行号，文件会在行号处打开，其它格式的文件似乎不能调用默认程序打开） 选取文本之后，按住Command 同时拖动文本，可以将文本粘贴到目标位置（Drag and Drop） 鼠标中键粘贴（这个太感人了，一下子找回Linux的感觉了）</li>
</ul>
<p>不使用鼠标</p>
<p>(这种方式最多只能选取一行文本) 使用 Command + f，会呼出一个搜索框，可以在当前面板中进行搜索，输入想要选取的部分内容，输入过程中，按Tab可以将选取部分向右扩展，按Shift + Tab向左扩展，按回车转到下一个匹配位置。使用Tab或Shift+Tab扩展得到想要的内容之后，选取内容会自动复制到剪切板，再次按Command + f隐藏搜索框。</p>
<h2 id="u4F4D_u7F6E_u4E66_u7B7E"><a href="#u4F4D_u7F6E_u4E66_u7B7E" class="headerlink" title="位置书签"></a>位置书签</h2><p>在当前会话中按Command + Shift + m可以保存当前位置，之后可以按Command + Shift + j跳回这个位置。</p>
<h2 id="u7C98_u8D34_u5386_u53F2"><a href="#u7C98_u8D34_u5386_u53F2" class="headerlink" title="粘贴历史"></a>粘贴历史</h2><p>使用Command + Shift + h 可以呼出粘贴历史，支持模糊检索。还可以设置将粘贴历史保存在磁盘上（Preferences -&gt; General）</p>
<h2 id="u5373_u65F6_u56DE_u653E"><a href="#u5373_u65F6_u56DE_u653E" class="headerlink" title="即时回放"></a>即时回放</h2><p>使用Command + Opt + b 打开即时回放，按Esc退出。即时回放可以记录终端输出的状态，让你“穿越时间”查看终端内容。默认每个会话最多储存4MB的内容，可以在设置中更改（Preferences -&gt; Genernal -&gt; Instant Replay）。</p>
<h2 id="u7A97_u53E3_u72B6_u6001"><a href="#u7A97_u53E3_u72B6_u6001" class="headerlink" title="窗口状态"></a>窗口状态</h2><p>通过 Window -&gt; Save Window Arrangement 可以保存当前窗口状态的快照，包括打开的窗口，标签页和面板。通过 Window -&gt; Restore Window Arrangement 还原。还可以在 Preferences -&gt; General -&gt; Open saved window arrangement 中设置在启动iTerm2时自动恢复窗口状态</p>
<h2 id="u7279_u8272_u529F_u80FD"><a href="#u7279_u8272_u529F_u80FD" class="headerlink" title="特色功能"></a>特色功能</h2><ul>
<li>command+; 根据上下文呼出自动完成窗口，上下键选择</li>
<li>全屏 command+enter</li>
<li>光标去哪了？command+/</li>
<li>用鼠标选中某个路径或者某个词汇就自动复制</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里是 iTerm2 的基本入门操作，熟悉之后可以大幅提高效率。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://wdxtub.com/tags/Mac/"/>
    
      <category term="Shell" scheme="http://wdxtub.com/tags/Shell/"/>
    
      <category term="iTerm2" scheme="http://wdxtub.com/tags/iTerm2/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Make 与 GCC 指南]]></title>
    <link href="http://wdxtub.com/2016/03/20/make-gcc-guide/"/>
    <id>http://wdxtub.com/2016/03/20/make-gcc-guide/</id>
    <published>2016-03-20T13:33:49.000Z</published>
    <updated>2016-03-20T13:35:45.000Z</updated>
    <content type="html"><![CDATA[<p>Make 可以简化编译过程，如果有一个近百个源文件的项目，如果有个文件更改后工程需要重新编译，那么一直用gcc -c a.c这些个命令敲来敲去会屎人的。运行make时候，他会寻找指定目录下（默认是 .）的 Makefile 文件并且分析依赖关系进行必要的编译。</p>
<a id="more"></a>
<hr>
<p>Makefile文件的基本格式很简单：</p>
<pre><code>目标文件： 依赖文件1 依赖文件2 依赖文件3 。。。。
[tab]编译命令
</code></pre><p>他的意思是目标文件是依赖于冒号后面几个文件的，如果这些依赖文件有更新的，那么其目标文件也需要更新。</p>
<p>Makefile 中可能有很多以上条目，他们共同组成了一个有向无回路图（DAG图），这样可以传递依赖。make 命令会把 Makefile 文件的第一个目标文件作为默认目标，当执行 make 命令时，make 会考察这个目标文件的依赖关系，进行编译。也可以指定，比如这个 Makefile：</p>
<pre><code>main: a.o b.o
[tab]gcc -o main a.o b.o
a.o : a.c c.h
[tab]gcc -c a.c -o a.o
b.o: b.c c.h
[tab]gcc -c b.c -o b.o

// [tab]的意思是这里用tab字符代替，不能有其他的什么字符
</code></pre><p>在命令行里执行make，分析关系并生成main，如果是make a.o那么他只会编译到 a.o 。</p>
<p>当然我们还可以设定伪目标，比如：</p>
<pre><code>clean：
[tab]rm a.o b.o
</code></pre><p>这样执行make clean的时候就把.o文件清除了,这里不会生成什么文件,只进行一些操作,更清楚的做法是在前面加上以下语句:</p>
<pre><code>.PHONY : clean install dest [其他伪目标]
</code></pre><p>下面来说下变量，Makefile 里的变量按惯例是大写，包括数字字母下划线。当我们需要一个变量的值的时候，通常用 ${NAME} 或者 $(NAME)。他有好几种变量定义的方法。</p>
<p>首先是常规法，就是A=content，等号两边可以有空格，和shell不一样。</p>
<p>其次是递归法，比如A=$(B)，B=$(C)，C=haha，那么当寻找A的定义的时候就会去找B，然后再找C，变量展开的时候就是当他被引用的时候，这种方法效率比较低，因为如果他引用了函数，那么每次展开都要调用函数，而且可能会出现无限递归（A=$(B),B=$(A)）。</p>
<p>然后是直接展开法。这个很容易理解，就像是c语言是按照顺序执行的，当变量定义的时候这个变量就已经展开了（如果他引用了变量A，引用的是他定义时候A的值），当被引用的时候就直接用他代表的字符串替代。但是他用的不是等号 是 := ,比如 A:=hello，A:=$(B)。</p>
<p>还有嵌套定义： A=B,B=haha,V=$($(A))类似于这种的V的值是haha</p>
<p>最后是替换引用定义，他会替换后缀，有个例子很好 foo := a.o b.o c.o ,bar := $(foo:.o=.c),我们可以知道bar的值就是 a.c b.c c.c。</p>
<p>变量还有分类：</p>
<p>1.预定义变量，当使用隐式规则的时候他会派上用场，常用的有以下几个：</p>
<pre><code>CC   c编译器的名称（默认gcc？）
CPP    c预编译器名称（默认$(CC) -E）
CXX c++编译器的名称(默认g++)
CFLAGS c编译器选项,无默认值
CXXFLAGS c++编译器选项,无默认值
</code></pre><p>2.自动变量,常用有以下:</p>
<pre><code>$@:表示当前规则中的完整目标文件名
$*:不包含扩展名的目标文件名
$&lt;:当前规则中第一个依赖文件名
$^:当前规则所有文件列表
$%:当目标为库文件时,表示库文件名
</code></pre><p>3.环境变量,Makefile对环境变量是可见的,可以引用.</p>
<p>Makefile还有个常用的东东就是隐式规则,make会自己推导.比如说</p>
<pre><code>c：a.o b.o
[tab]gcc -o c a.o b.o
</code></pre><p>这时我们可以省略下面的命令，直接用第一行就行。make自动分析生成a，此时预定义变量就有用了，CC，CFLAGS等也派上了用场。</p>
<p>由于把握不了隐式规则的底线和能力，我还是觉得隐式规则应用的不要太多太复杂影响阅读为好。。</p>
<p>make的工作过程大概是一下几步</p>
<ol>
<li>读取Makefile，根据make的选项查找Makefile</li>
<li>初始化Makefile，将Makefile中的变量进行替换，如果Makefile中包含其他文件，则加载他</li>
<li>解释规则，对其中的执行规则进行解析，推导隐藏规则，为目标建立关系链</li>
<li>分析变更，根据依赖关系和时间戳，判断有木有变化。</li>
<li>执行。</li>
</ol>
<h2 id="u7F16_u8BD1_u7684_u57FA_u672C_u6D41_u7A0B"><a href="#u7F16_u8BD1_u7684_u57FA_u672C_u6D41_u7A0B" class="headerlink" title="编译的基本流程"></a>编译的基本流程</h2><p>基本过程是以下四步：</p>
<p>1.<code>c(.c)</code>和<code>c++(.cc, .cpp, .cxx)</code>的源文件</p>
<pre><code>gcc -E a.c -o a.i
// 如果不加-o参数，gcc会把处理过的源文件放到标准输出中
</code></pre><p>2.预处理后的源文件。c源文件预处理后后缀为<code>.i</code>, c++为<code>.ii</code> 。</p>
<pre><code>gcc -S a.i
//会在当前文件夹下生成a.s
</code></pre><p>3.编译后生成的汇编源代码。后缀为<code>.s</code>,<code>.S</code>。</p>
<pre><code>gcc -c a.s
//只进行汇编生成目标文件,.o结尾的目标文件可以用
//(ar crv libabc.a a.o b.o c.o )打包成形如lib×××.a的静态库
</code></pre><p>4.目标文件与库文件进行链接，生成可执行文件。</p>
<pre><code>gcc a.o //在当前文件夹下生成a.out
</code></pre><p>其中任何一种状态，用 gcc 如果不加 <code>-c</code>，<code>-E</code>，<code>-S</code> 选项都会直接生成可执行文件，如果加上了选项，可以由之前任一状态生成所需要的文件（如<code>gcc -S a.c</code>可以直接生成<code>a.s，gcc -c a.i</code>可以直接生成<code>a.o</code> ）。如果是c++直接换用g++命令就行。</p>
<p>另外<code>gcc -v</code>可以输出编译过程的配置和版本信息。</p>
<h2 id="gcc__u8B66_u544A_u63D0_u793A"><a href="#gcc__u8B66_u544A_u63D0_u793A" class="headerlink" title="gcc 警告提示"></a>gcc 警告提示</h2><pre><code>-fsyntax-only   检查程序中的语法错误，不产生输出信息
-w 禁止所有警告信息
-Wunused 声明了木有用
-Wmain main函数定义不常规
-Wall 提供所有警告
-pedantic-errors 允许ansi c标准列出的全部信息
</code></pre><p>实际用的话，所有错误用一个“墙”就可以了</p>
<h2 id="u5176_u4ED6_u5E38_u7528_u9009_u9879"><a href="#u5176_u4ED6_u5E38_u7528_u9009_u9879" class="headerlink" title="其他常用选项"></a>其他常用选项</h2><ul>
<li>-g 加入调试信息，gdb调试的时候要用。</li>
<li>-On 优化选项。这里的n可以用0-3来替代。数字越大优化效果越好，-O0表示不进行优化。优化可能针对硬件进行优化，也可能针对代码优化（删除公共表达式，循环优化，删除无用信息）。优化可能大大增加编译时间和内存，他通常会将循环或函数展开，使他们以内联的方式进行，不是通过函数调用，这样可以显著提高性能，不过调试最好不要用优化选项。</li>
<li>-l 指定要用到的库，注意这里之后要加的是库的名字，如果是多线程，可能要用到pthread库，那么此时就要加上 -lpthread ，这样gcc就会到库目录中找名为libpthread.so（lib×××.so）的文件，如果是静态库的话是libpthread.a( lib×××.a)（貌似gcc先找动态库，再找静态库？）。</li>
<li>-L 指定所需要的库所在的文件夹。系统先寻找标准位置，再寻找指定位置（标准库一般在/lib或/usr/lib）。</li>
<li>-I 指定头文件的寻找路径。先找标准的，后找指定的（标准的一般在/usr/include）。</li>
<li>-static 只用静态库,再拿上面那个例子，如果加上-static，系统就会只寻找libpthread.a文件。</li>
<li>-shared 生成动态库（共享库）文件，形如 libxxx.so （gcc -shared dang.o -o libdang.so）</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Make 可以简化编译过程，如果有一个近百个源文件的项目，如果有个文件更改后工程需要重新编译，那么一直用gcc -c a.c这些个命令敲来敲去会屎人的。运行make时候，他会寻找指定目录下（默认是 .）的 Makefile 文件并且分析依赖关系进行必要的编译。</p>]]>
    
    </summary>
    
      <category term="Gcc" scheme="http://wdxtub.com/tags/Gcc/"/>
    
      <category term="Make" scheme="http://wdxtub.com/tags/Make/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ubuntu 工作环境搭建]]></title>
    <link href="http://wdxtub.com/2016/03/20/ubuntu-work-env/"/>
    <id>http://wdxtub.com/2016/03/20/ubuntu-work-env/</id>
    <published>2016-03-20T13:31:58.000Z</published>
    <updated>2016-03-20T13:33:12.000Z</updated>
    <content type="html"><![CDATA[<p>考虑到 mac 升级之后各种坑，latex 什么鬼都用不了，所以痛定思痛决定在 Ubuntu 上搞一个工作环境。基本就是云同步+markdown+pandoc+sublime 高亮编辑器。环境 Ubuntu 14.04 64-bit</p>
<a id="more"></a>
<hr>
<h2 id="u4E2D_u6587_u8F93_u5165_u6CD5"><a href="#u4E2D_u6587_u8F93_u5165_u6CD5" class="headerlink" title="中文输入法"></a>中文输入法</h2><p>首先当然是要安装输入法，现在搜狗已经在 linux 上出了输入法，直接用即可。<a href="http://pinyin.sogou.com/linux/help.php" target="_blank" rel="external">安装指南</a></p>
<p>下载 deb 包直接安装即可</p>
<p>安装完之后需要重启，在 language support 中把默认引擎改成 fcitx，然后选择搜狗拼音即可</p>
<h2 id="Dropbox"><a href="#Dropbox" class="headerlink" title="Dropbox"></a>Dropbox</h2><p>从<a href="https://www.dropbox.com/install?os=lnx" target="_blank" rel="external">这里</a>下载对应版本，然后登录设置正常使用即可</p>
<h2 id="Pandoc"><a href="#Pandoc" class="headerlink" title="Pandoc"></a>Pandoc</h2><p>从<a href="http://pandoc.org/installing.html" target="_blank" rel="external">这里</a> 下载 deb 包安装即可。</p>
<p>具体转换过程</p>
<pre><code>pandoc -s source.md -o target.pdf
</code></pre><p>注意目前纯英文才可以，图片需要是 PNG 格式</p>
<h2 id="Latex__u53CA_u4E2D_u6587_u652F_u6301"><a href="#Latex__u53CA_u4E2D_u6587_u652F_u6301" class="headerlink" title="Latex 及中文支持"></a>Latex 及中文支持</h2><p>各位阅读前，先说明以下总体上我们要做的几件事。</p>
<ol>
<li>安装TexLive。我们知道Latex只是一套排版的宏定义，为实现Latex，需要在各种操作系统上提供软件支持。TexLive就是实现此目的一个跨平台软件包。</li>
<li>Latex支持的字体非常多，自然包括中文。不过，为了更好地支持中日韩（因为这些是方块型的字符集，与字母类型的文字不同），需要安装CJK扩展包。</li>
<li>为了使用额外的中文字体，需要配置Latex以便使用它们。</li>
<li>使用测试文档，确认安装的字体不是已经生效了。</li>
</ol>
<p>打开终端，安装以下TexLive和常用的一些Latex宏包（可以根据自己的需要增改）：</p>
<pre><code>sudo apt-get install texlive texlive-math-extra texlive-latex-base texlive-latex-extra texlive-latex-recommended texlive-pictures texlive-science latex-beamer texlive-base texlive-bibtex-extra texlive-xetex texlive-latex-extra
</code></pre><p>如果硬盘充裕的话，直接完整安装也可以：</p>
<pre><code>sudo apt-get install texlive-full latex-beamer
</code></pre><p>安装完后，就可以安装CJK的相关软件包了，如果只需要获得中文支持，那么执行：</p>
<pre><code>sudo apt-get install latex-cjk-chinese ttf-arphic-* hbf-*
</code></pre><p>否则，建议安装 latex-cjk-all 以获取完整支持。</p>
<pre><code>sudo apt-get install latex-cjk-all
</code></pre><p>Linux下的中文字体，对于Ubuntu来说有现成的。因此，只要第一步正常安装完毕，就可以用下面的测试文件进行测试。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage&#123;CJKutf8&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gkai&#125;</span><br><span class="line">这是一个楷体中文测试，处理简体字。</span><br><span class="line">\<span class="keyword">end</span>&#123;CJK&#125;</span><br><span class="line">\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gbsn&#125;</span><br><span class="line">这是一个宋体中文测试，处理简体字。</span><br><span class="line">\<span class="keyword">end</span>&#123;CJK&#125;</span><br><span class="line">\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;bkai&#125;</span><br><span class="line">這是一個big5編碼的楷體中文測試，處理繁體文字。</span><br><span class="line">\<span class="keyword">end</span>&#123;CJK&#125;</span><br><span class="line">\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;bsmi&#125;</span><br><span class="line">這是一個个big5編碼的明體中文測試，處理繁體文字。</span><br><span class="line">\<span class="keyword">end</span>&#123;CJK&#125;</span><br><span class="line">\<span class="keyword">end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>将这部分代码粘贴到文本文件中，然后保存将其保存为test.tex。然后使用下面的命令生成PDF文档。</p>
<pre><code>pdflatex test.tex
evince test.pdf
</code></pre><h2 id="u5728_u5F53_u524D_u76EE_u5F55_u4E0B_u6253_u5F00_u7EC8_u7AEF"><a href="#u5728_u5F53_u524D_u76EE_u5F55_u4E0B_u6253_u5F00_u7EC8_u7AEF" class="headerlink" title="在当前目录下打开终端"></a>在当前目录下打开终端</h2><p>直接安装一个软件包nautilus-open-terminal</p>
<p>终端输入：<code>sudo apt-get install nautilus-open-terminal</code></p>
<p>重启系统！</p>
<h2 id="u5B89_u88C5_sublime_3"><a href="#u5B89_u88C5_sublime_3" class="headerlink" title="安装 sublime 3"></a>安装 sublime 3</h2><p>简单粗暴</p>
<pre><code>sudo add-apt-repository ppa:webupd8team/sublime-text-3
sudo apt-get update
sudo apt-get install sublime-text-installer
</code></pre><p>然后需要配置一下环境</p>
<p>先安装 package control，<a href="https://packagecontrol.io/installation" target="_blank" rel="external">教程</a></p>
<h3 id="u63D2_u4EF6_u7CBE_u9009"><a href="#u63D2_u4EF6_u7CBE_u9009" class="headerlink" title="插件精选"></a>插件精选</h3><ul>
<li>Theme: Gravity</li>
<li>Color Theme: Monokai Extended</li>
<li>MarkdownTOC</li>
<li><a href="https://github.com/titoBouzout/SideBarEnhancements" target="_blank" rel="external">SideBarEnhancements</a>: 侧边栏增强</li>
<li><a href="https://github.com/wbond/sublime_alignment" target="_blank" rel="external">Alignment</a>: 等号对齐</li>
<li><a href="https://github.com/BoundInCode/AutoFileName" target="_blank" rel="external">AutoFileName</a>: 文件路径自动提示</li>
</ul>
<h3 id="u5E38_u7528_u6280_u80FD"><a href="#u5E38_u7528_u6280_u80FD" class="headerlink" title="常用技能"></a>常用技能</h3><ol>
<li>按住 <code>ctrl</code> 键，鼠标单击就是多重选择。</li>
<li><a href="http://baelabs.duapp.com/Sublime/multiple_selection_with_the_keyboard.html" target="_blank" rel="external">键盘多重选择</a></li>
<li>根据选择文本自动添加 ‘, “”,(),[] 匹配。</li>
<li>搜索按钮的功能说明 (<a href="http://hi.baidu.com/chaoxinggsc/item/904a471aa937bc35f6625c42" target="_blank" rel="external">冷风贡献</a>)</li>
</ol>
<h3 id="u5E38_u7528_u5FEB_u6377_u952E"><a href="#u5E38_u7528_u5FEB_u6377_u952E" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><ol>
<li>Ctrl+L             选择整行（按住-继续选择下行）</li>
<li>Ctrl+Shift+K(shhift+del)     删除整行，  ctrl + KK 从光标处删之行尾，Ctrl+K Backspace 从光标处删除至行首</li>
<li>Ctrl+Shift+D       复制光标所在整行，插入在该行之前</li>
<li>Ctrl+D             选词 （按住-继续选择下个相同的字符串，再按，可跳到相应的方法定义处</li>
<li>Ctrl+Shift+M       选择括号内的内容（按住-继续选择父括号）</li>
<li>Ctrl+/             注释整行（如已选择内容，同“Ctrl+Shift+/”效果）</li>
<li>Ctrl + alt + /     取消注释</li>
<li>Ctrl+Shift+UP      与上行互换  ctrl + shift + up: 列模式编辑</li>
<li>Ctrl + R           跳转当前页的目标方法</li>
<li>Ctrl+K + U        大写</li>
<li>Ctrl+K + L        小写</li>
<li>鼠标中间           列模式编辑</li>
<li>Ctrl+Shift+[]     代码折叠</li>
<li>ctrl+k ctrl+1:    折叠所有代码</li>
<li>Ctrl + K,B        打开侧边栏</li>
<li>ctrl + 回车：　　   光标后插入行，　Ctrl+Shift+Enter 光标前插入行</li>
<li>ctrl + m:         匹配括号</li>
<li>vim mode下        查找上一个下一个的快捷键是 是* #</li>
<li>ctrl +z, y:       撤销，恢复撤销</li>
<li>alt + .:          闭合当前标签</li>
<li>Ctrl+F2:          设置书签</li>
<li>F2:               下一个书签</li>
<li>Shift+F2:         上一个书签</li>
<li>ctrl + p:         即时的文件切换</li>
<li>ctrl + shift + a: 选择标签内的内容</li>
<li>ctrl + 单击：      多行随意位置添加光标</li>
<li>alt + F3( mac: ctrl + command + g): 选择页面中所有相同的词</li>
<li>ctrl + F3:        跳转到下一个选中的词</li>
<li>Ctrl+Shift+P Set Syntax:html : 设置文件类型</li>
<li>Shift + 右键:     连续多行光标选中 (by Gary Gauh)</li>
</ol>
<h3 id="u914D_u7F6E_u66F4_u6539"><a href="#u914D_u7F6E_u66F4_u6539" class="headerlink" title="配置更改"></a>配置更改</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">caret_style</span>": <span class="value"><span class="string">"phase"</span></span>,</span><br><span class="line">    "<span class="attribute">color_scheme</span>": <span class="value"><span class="string">"Packages/Monokai Extended/Monokai Extended.tmTheme"</span></span>,</span><br><span class="line">    "<span class="attribute">draw_white_space</span>": <span class="value"><span class="string">"all"</span></span>,</span><br><span class="line">    "<span class="attribute">ensure_newline_at_eof_on_save</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">    "<span class="attribute">fade_fold_buttons</span>": <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">    "<span class="attribute">file_exclude_patterns</span>":</span><br><span class="line">    <span class="value">[</span><br><span class="line">        <span class="string">"*.Ulysses-Group.plist"</span>,</span><br><span class="line">        <span class="string">"*.pyc"</span>,</span><br><span class="line">        <span class="string">"*.pyo"</span>,</span><br><span class="line">        <span class="string">"*.exe"</span>,</span><br><span class="line">        <span class="string">"*.dll"</span>,</span><br><span class="line">        <span class="string">"*.obj"</span>,</span><br><span class="line">        <span class="string">"*.o"</span>,</span><br><span class="line">        <span class="string">"*.a"</span>,</span><br><span class="line">        <span class="string">"*.lib"</span>,</span><br><span class="line">        <span class="string">"*.so"</span>,</span><br><span class="line">        <span class="string">"*.dylib"</span>,</span><br><span class="line">        <span class="string">"*.ncb"</span>,</span><br><span class="line">        <span class="string">"*.sdf"</span>,</span><br><span class="line">        <span class="string">"*.suo"</span>,</span><br><span class="line">        <span class="string">"*.pdb"</span>,</span><br><span class="line">        <span class="string">"*.idb"</span>,</span><br><span class="line">        <span class="string">".DS_Store"</span>,</span><br><span class="line">        <span class="string">"*.class"</span>,</span><br><span class="line">        <span class="string">"*.psd"</span>,</span><br><span class="line">        <span class="string">"*.db"</span>,</span><br><span class="line">        <span class="string">"*.sublime-workspace"</span></span><br><span class="line">    ]</span>,</span><br><span class="line">    "<span class="attribute">folder_exclude_patterns</span>":</span><br><span class="line">    <span class="value">[</span><br><span class="line">        <span class="string">".svn"</span>,</span><br><span class="line">        <span class="string">".git"</span>,</span><br><span class="line">        <span class="string">".hg"</span>,</span><br><span class="line">        <span class="string">"CVS"</span></span><br><span class="line">    ]</span>,</span><br><span class="line">    "<span class="attribute">font_size</span>": <span class="value"><span class="number">19</span></span>,</span><br><span class="line">    "<span class="attribute">highlight_color_blue</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">    "<span class="attribute">highlight_line</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">    "<span class="attribute">highlight_modified_tabs</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">    "<span class="attribute">ignored_packages</span>":</span><br><span class="line">    <span class="value">[</span><br><span class="line">        <span class="string">"ActionScript"</span>,</span><br><span class="line">        <span class="string">"AppleScript"</span>,</span><br><span class="line">        <span class="string">"ASP"</span>,</span><br><span class="line">        <span class="string">"Clojure"</span>,</span><br><span class="line">        <span class="string">"D"</span>,</span><br><span class="line">        <span class="string">"Erlang"</span>,</span><br><span class="line">        <span class="string">"Go"</span>,</span><br><span class="line">        <span class="string">"Graphviz"</span>,</span><br><span class="line">        <span class="string">"Groovy"</span>,</span><br><span class="line">        <span class="string">"OCaml"</span>,</span><br><span class="line">        <span class="string">"OmniMarkupPreviewer"</span>,</span><br><span class="line">        <span class="string">"Pascal"</span>,</span><br><span class="line">        <span class="string">"R"</span>,</span><br><span class="line">        <span class="string">"Rails"</span>,</span><br><span class="line">        <span class="string">"Tag"</span>,</span><br><span class="line">        <span class="string">"TCL"</span>,</span><br><span class="line">        <span class="string">"Vintage"</span></span><br><span class="line">    ]</span>,</span><br><span class="line">    "<span class="attribute">rulers</span>":</span><br><span class="line">    <span class="value">[</span><br><span class="line">        <span class="number">80</span>,</span><br><span class="line">        <span class="number">100</span></span><br><span class="line">    ]</span>,</span><br><span class="line">    "<span class="attribute">soda_folder_icons</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">    "<span class="attribute">spell_check</span>": <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">    "<span class="attribute">theme</span>": <span class="value"><span class="string">"Gravity.sublime-theme"</span></span>,</span><br><span class="line">    "<span class="attribute">translate_tabs_to_spaces</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">    "<span class="attribute">trim_trailing_white_space_on_save</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">    "<span class="attribute">word_wrap</span>": <span class="value"><span class="literal">true</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>最后是屌丝license, Build 3083</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">—– BEGIN LICENSE —–</span><br><span class="line">Andrew Weber</span><br><span class="line">Single User License</span><br><span class="line">EA7E-<span class="number">855605</span></span><br><span class="line"><span class="number">813</span>A03DD <span class="number">5E4</span>AD9E6 <span class="number">6</span>C0EEB94 BC99798F</span><br><span class="line"><span class="number">942194</span>A6 <span class="number">02396E98</span> E62C9979 <span class="number">4</span>BB979FE</span><br><span class="line"><span class="number">91424</span>C9D A45400BF F6747D88 <span class="number">2F</span>B88078</span><br><span class="line"><span class="number">90F</span>5CC94 <span class="number">1</span>CDC92DC <span class="number">8457107</span>A F151657B</span><br><span class="line"><span class="number">1</span>D22E383 A997F016 <span class="number">42397640</span> <span class="number">33F</span>41CFC</span><br><span class="line">E1D0AE85 A0BBD039 <span class="number">0E9</span>C8D55 E1B89D5D</span><br><span class="line"><span class="number">5</span>CDB7036 E56DE1C0 EFCC0840 <span class="number">650</span>CD3A6</span><br><span class="line">B98FC99C <span class="number">8F</span>AC73EE D2B95564 DF450523</span><br><span class="line">—— END LICENSE ——</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>考虑到 mac 升级之后各种坑，latex 什么鬼都用不了，所以痛定思痛决定在 Ubuntu 上搞一个工作环境。基本就是云同步+markdown+pandoc+sublime 高亮编辑器。环境 Ubuntu 14.04 64-bit</p>]]>
    
    </summary>
    
      <category term="Ubuntu" scheme="http://wdxtub.com/tags/Ubuntu/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop 指南]]></title>
    <link href="http://wdxtub.com/2016/03/20/hadoop-guide/"/>
    <id>http://wdxtub.com/2016/03/20/hadoop-guide/</id>
    <published>2016-03-20T13:16:50.000Z</published>
    <updated>2016-03-20T13:31:06.000Z</updated>
    <content type="html"><![CDATA[<p>这里简要介绍一下 Hadoop 的基本原理及用法。</p>
<a id="more"></a>
<hr>
<h2 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h2><p>Hadoop Map/Reduce 是一个使用简易的软件框架，基于它写出来的应用程序能够运行在由上千个商用机器组成的大型集群上，并以一种可靠容错的方式并行处理上T级别的数据集。</p>
<p>一个 Map/Reduce 作业（job） 通常会把输入的数据集切分为若干独立的数据块，由  map 任务（task）以完全并行的方式处理它们。框架会对 map 的输出先进行排序， 然后把结果输入给 reduce 任务。通常作业的输入和输出都会被存储在文件系统中。 整个框架负责任务的调度和监控，以及重新执行已经失败的任务。</p>
<p>通常，Map/Reduce 框架和分布式文件系统是运行在一组相同的节点上的，也就是说，计算节点和存储节点通常在一起。这种配置允许框架在那些已经存好数据的节点上高效地调度任务，这可以使整个集群的网络带宽被非常高效地利用。</p>
<p>Map/Reduce 框架由一个单独的 master JobTracker 和每个集群节点一个 slave TaskTracker共同组成。master 负责调度构成一个作业的所有任务，这些任务分布在不同的 slave 上，master 监控它们的执行，重新执行已经失败的任务。而 slave 仅负责执行由 master 指派的任务。</p>
<p>应用程序至少应该指明输入/输出的位置（路径），并通过实现合适的接口或抽象类提供 map 和 reduce 函数。再加上其他作业的参数，就构成了作业配置（job configuration）。然后，Hadoop 的 job client 提交作业（jar包/可执行程序等）和配置信息给 JobTracker，后者负责分发这些软件和配置信息给 slave、调度任务并监控它们的执行，同时提供状态和诊断信息给 job-client。</p>
<p>虽然 Hadoop 框架是用 JavaTM 实现的，但 Map/Reduce 应用程序则不一定要用 Java 来写 。</p>
<h2 id="u8F93_u5165_u4E0E_u8F93_u51FA"><a href="#u8F93_u5165_u4E0E_u8F93_u51FA" class="headerlink" title="输入与输出"></a>输入与输出</h2><p>Map/Reduce框架运转在<code>&lt;key, value&gt;</code> 键值对上，也就是说， 框架把作业的输入看为是一组<code>&lt;key, value&gt;</code> 键值对，同样也产出一组 <code>&lt;key, value&gt;</code> 键值对做为作业的输出，这两组键值对的类型可能不同。</p>
<p>框架需要对 key 和 value 的类(classes)进行序列化操作， 因此，这些类需要实现 Writable接口。另外，为了方便框架执行排序操作，key 类必须实现 WritableComparable接口。</p>
<p>一个Map/Reduce 作业的输入和输出类型如下所示：</p>
<pre><code>(input) &lt;k1, v1&gt; -&gt; map -&gt; &lt;k2, v2&gt; -&gt; combine -&gt; &lt;k2, v2&gt; -&gt; reduce -&gt; &lt;k3, v3&gt; (output)
</code></pre><h2 id="u6838_u5FC3_u529F_u80FD_u63CF_u8FF0"><a href="#u6838_u5FC3_u529F_u80FD_u63CF_u8FF0" class="headerlink" title="核心功能描述"></a>核心功能描述</h2><p>应用程序通常会通过提供map和reduce来实现 Mapper 和 Reducer 接口，它们组成作业的核心。</p>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><p>Mapper 将输入键值对(key/value pair)映射到一组中间格式的键值对集合。</p>
<p>Map 是一类将输入记录集转换为中间格式记录集的独立任务。 这种转换的中间格式记录集不需要与输入记录集的类型一致。一个给定的输入键值对可以映射成0个或多个输出键值对。</p>
<p>Hadoop Map/Reduce 框架为每一个 InputSplit 产生一个map任务，而每个InputSplit是由该作业的InputFormat产生的。</p>
<p>概括地说，对 Mapper 的实现者需要重写 JobConfigurable.configure(JobConf) 方法，这个方法需要传递一个 JobConf 参数，目的是完成 Mapper 的初始化工作。然后，框架为这个任务的 InputSplit 中每个键值对调用一次 map(WritableComparable, Writable, OutputCollector, Reporter)操作。应用程序可以通过重写 Closeable.close() 方法来执行相应的清理工作。</p>
<p>输出键值对不需要与输入键值对的类型一致。一个给定的输入键值对可以映射成0个或多个输出键值对。通过调用 OutputCollector.collect(WritableComparable,Writable)可以收集输出的键值对。</p>
<p>应用程序可以使用Reporter报告进度，设定应用级别的状态消息，更新Counters（计数器），或者仅是表明自己运行正常。</p>
<p>框架随后会把与一个特定 key 关联的所有中间过程的值（value）分成组，然后把它们传给 Reducer 以产出最终的结果。用户可以通过 JobConf.setOutputKeyComparatorClass(Class) 来指定具体负责分组的 Comparator。</p>
<p>Mapper 的输出被排序后，就被划分给每个 Reducer。分块的总数目和一个作业的 reduce 任务的数目是一样的。用户可以通过实现自定义的 Partitioner 来控制哪个key被分配给哪个 Reducer。</p>
<p>用户可选择通过 JobConf.setCombinerClass(Class)指定一个 combiner，它负责对中间过程的输出进行本地的聚集，这会有助于降低从 Mapper 到 Reducer 数据传输量。</p>
<p>这些被排好序的中间过程的输出结果保存的格式是(key-len, key, value-len, value)，应用程序可以通过JobConf控制对这些中间结果是否进行压缩以及怎么压缩，使用哪种 CompressionCodec。</p>
<h3 id="u9700_u8981_u591A_u5C11_u4E2AMap_uFF1F"><a href="#u9700_u8981_u591A_u5C11_u4E2AMap_uFF1F" class="headerlink" title="需要多少个Map？"></a>需要多少个Map？</h3><p>Map的数目通常是由输入数据的大小决定的，一般就是所有输入文件的总块（block）数。</p>
<p>Map 正常的并行规模大致是每个节点（node）大约 10 到 100 个 map，对于 CPU 消耗较小的map 任务可以设到300个左右。由于每个任务初始化需要一定的时间，因此，比较合理的情况是 map 执行的时间至少超过1分钟。</p>
<p>这样，如果你输入 10TB 的数据，每个块（block）的大小是128MB，你将需要大约82,000个map来完成任务，除非使用 setNumMapTasks(int)（注意：这里仅仅是对框架进行了一个提示(hint)，实际决定因素见这里）将这个数值设置得更高。</p>
<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>Reducer 将与一个 key 关联的一组中间数值集归约（reduce）为一个更小的数值集。</p>
<p>用户可以通过 JobConf.setNumReduceTasks(int) 设定一个作业中 reduce 任务的数目。</p>
<p>概括地说，对 Reducer 的实现者需要重写 JobConfigurable.configure(JobConf) 方法，这个方法需要传递一个 JobConf 参数，目的是完成 Reducer 的初始化工作。然后，框架为成组的输入数据中的每个<code>&lt;key, (list of values)&gt;</code>对调用一次 reduce(WritableComparable, Iterator, OutputCollector, Reporter)方法。之后，应用程序可以通过重写 Closeable.close() 来执行相应的清理工作。</p>
<p>Reducer 有3个主要阶段：shuffle、sort 和 reduce。</p>
<h3 id="Shuffle"><a href="#Shuffle" class="headerlink" title="Shuffle"></a>Shuffle</h3><p>Reducer 的输入就是 Mapper 已经排好序的输出。在这个阶段，框架通过 HTTP 为每个 Reducer 获得所有 Mapper 输出中与之相关的分块。</p>
<h3 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h3><p>这个阶段，框架将按照 key 的值对 Reducer 的输入进行分组 （因为不同 mapper 的输出中可能会有相同的 key）。</p>
<p>Shuffle 和 Sort 两个阶段是同时进行的；map 的输出也是一边被取回一边被合并的。</p>
<h3 id="Secondary_Sort"><a href="#Secondary_Sort" class="headerlink" title="Secondary Sort"></a>Secondary Sort</h3><p>如果需要中间过程对 key 的分组规则和 reduce 前对 key 的分组规则不同，那么可以通过 JobConf.setOutputValueGroupingComparator(Class) 来指定一个 Comparator。再加上 JobConf.setOutputKeyComparatorClass(Class)可用于控制中间过程的 key 如何被分组，所以结合两者可以实现按值的二次排序。</p>
<h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><p>在这个阶段，框架为已分组的输入数据中的每个 <code>&lt;key, (list of values)&gt;</code>对调用一次 reduce(WritableComparable, Iterator, OutputCollector, Reporter)方法。</p>
<p>Reduce任务的输出通常是通过调用 OutputCollector.collect(WritableComparable, Writable)写入 文件系统的。</p>
<p>应用程序可以使用 Reporter 报告进度，设定应用程序级别的状态消息，更新 Counters（计数器），或者仅是表明自己运行正常。</p>
<p>Reducer 的输出是没有排序的。</p>
<h3 id="u9700_u8981_u591A_u5C11_u4E2AReduce_uFF1F"><a href="#u9700_u8981_u591A_u5C11_u4E2AReduce_uFF1F" class="headerlink" title="需要多少个Reduce？"></a>需要多少个Reduce？</h3><p>Reduce的数目建议是0.95或1.75乘以 <code>&lt;no. of nodes&gt; * mapred.tasktracker.reduce.tasks.maximum</code>。</p>
<p>用 0.95，所有 reduce 可以在 maps 一完成时就立刻启动，开始传输 map 的输出结果。用1.75，速度快的节点可以在完成第一轮 reduce 任务后，可以开始第二轮，这样可以得到比较好的负载均衡的效果。</p>
<p>增加 reduce 的数目会增加整个框架的开销，但可以改善负载均衡，降低由于执行失败带来的负面影响。</p>
<p>上述比例因子比整体数目稍小一些是为了给框架中的推测性任务（speculative-tasks） 或失败的任务预留一些 reduce 的资源。</p>
<h3 id="u65E0_Reducer"><a href="#u65E0_Reducer" class="headerlink" title="无 Reducer"></a>无 Reducer</h3><p>如果没有归约要进行，那么设置 reduce 任务的数目为零是合法的。</p>
<p>这种情况下，map任务的输出会直接被写入由 setOutputPath(Path)指定的输出路径。框架在把它们写入 FileSystem 之前没有对它们进行排序。</p>
<h3 id="Partitioner"><a href="#Partitioner" class="headerlink" title="Partitioner"></a>Partitioner</h3><p>Partitioner 用于划分键值空间（key space）。</p>
<p>Partitioner 负责控制 map 输出结果 key 的分割。Key（或者一个key子集）被用于产生分区，通常使用的是 Hash 函数。分区的数目与一个作业的 reduce 任务的数目是一样的。因此，它控制将中间过程的key（也就是这条记录）应该发送给 m 个 reduce 任务中的哪一个来进行 reduce操作。</p>
<p>HashPartitioner 是默认的 Partitioner。</p>
<h3 id="Reporter"><a href="#Reporter" class="headerlink" title="Reporter"></a>Reporter</h3><p>Reporter 是用于 Map/Reduce 应用程序报告进度，设定应用级别的状态消息， 更新 Counters（计数器）的机制。</p>
<p>Mapper 和 Reducer 的实现可以利用Reporter 来报告进度，或者仅是表明自己运行正常。在那种应用程序需要花很长时间处理个别键值对的场景中，这种机制是很关键的，因为框架可能会以为这个任务超时了，从而将它强行杀死。另一个避免这种情况发生的方式是，将配置参数 <code>mapred.task.timeout</code> 设置为一个足够高的值（或者干脆设置为零，则没有超时限制了）。</p>
<p>应用程序可以用 Reporter 来更新 Counter（计数器）。</p>
<h3 id="OutputCollector"><a href="#OutputCollector" class="headerlink" title="OutputCollector"></a>OutputCollector</h3><p>OutputCollector 是一个 Map/Reduce 框架提供的用于收集 Mapper 或 Reducer输出数据的通用机制（包括中间输出结果和作业的输出结果）。</p>
<p>Hadoop Map/Reduce 框架附带了一个包含许多实用型的 mapper、reducer 和 partitioner 的类库。</p>
<h2 id="u4F5C_u4E1A_u914D_u7F6E"><a href="#u4F5C_u4E1A_u914D_u7F6E" class="headerlink" title="作业配置"></a>作业配置</h2><p>JobConf 代表一个 Map/Reduce 作业的配置。</p>
<p>JobConf 是用户向 Hadoop 框架描述一个 Map/Reduce 作业如何执行的主要接口。框架会按照 JobConf 描述的信息忠实地去尝试完成这个作业，然而：</p>
<ul>
<li>一些参数可能会被管理者标记为 final，这意味它们不能被更改。</li>
<li>一些作业的参数可以被直截了当地进行设置（例如： setNumReduceTasks(int)），而另一些参数则与框架或者作业的其他参数之间微妙地相互影响，并且设置起来比较复杂（例如： setNumMapTasks(int)）。</li>
</ul>
<p>通常，JobConf会指明Mapper、Combiner(如果有的话)、 Partitioner、Reducer、InputFormat和 OutputFormat的具体实现。JobConf还能指定一组输入文件 (setInputPaths(JobConf, Path…) /addInputPath(JobConf, Path)) 和(setInputPaths(JobConf, String) /addInputPaths(JobConf, String)) 以及输出文件应该写在哪儿 (setOutputPath(Path))。</p>
<p>JobConf可选择地对作业设置一些高级选项，例如：设置Comparator； 放到DistributedCache上的文件；中间结果或者作业输出结果是否需要压缩以及怎么压缩； 利用用户提供的脚本(setMapDebugScript(String)/setReduceDebugScript(String)) 进行调试；作业是否允许预防性（speculative）任务的执行 (setMapSpeculativeExecution(boolean))/(setReduceSpeculativeExecution(boolean)) ；每个任务最大的尝试次数 (setMaxMapAttempts(int)/setMaxReduceAttempts(int)) ；一个作业能容忍的任务失败的百分比 (setMaxMapTaskFailuresPercent(int)/setMaxReduceTaskFailuresPercent(int)) ；等等。</p>
<p>当然，用户能使用 set(String, String)/get(String, String) 来设置或者取得应用程序需要的任意参数。然而，DistributedCache的使用是面向大规模只读数据的。</p>
<h2 id="u4EFB_u52A1_u7684_u6267_u884C_u548C_u73AF_u5883"><a href="#u4EFB_u52A1_u7684_u6267_u884C_u548C_u73AF_u5883" class="headerlink" title="任务的执行和环境"></a>任务的执行和环境</h2><p>TaskTracker是在一个单独的jvm上以子进程的形式执行 Mapper/Reducer任务（Task）的。</p>
<p>子任务会继承父TaskTracker的环境。用户可以通过JobConf中的 mapred.child.java.opts配置参数来设定子jvm上的附加选项，例如： 通过-Djava.library.path=&lt;&gt; 将一个非标准路径设为运行时的链接用以搜索共享库，等等。如果mapred.child.java.opts包含一个符号@taskid@， 它会被替换成map/reduce的taskid的值。</p>
<p>下面是一个包含多个参数和替换的例子，其中包括：记录jvm GC日志； JVM JMX代理程序以无密码的方式启动，这样它就能连接到jconsole上，从而可以查看子进程的内存和线程，得到线程的dump；还把子jvm的最大堆尺寸设置为512MB， 并为子jvm的java.library.path添加了一个附加路径。</p>
<pre><code>&lt;property&gt;
  &lt;name&gt;mapred.child.java.opts&lt;/name&gt;
  &lt;value&gt;
     -Xmx512M -Djava.library.path=/home/mycompany/lib -verbose:gc -Xloggc:/tmp/@taskid@.gc
     -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false
  &lt;/value&gt;
&lt;/property&gt;
</code></pre><p>用户或管理员也可以使用mapred.child.ulimit设定运行的子任务的最大虚拟内存。mapred.child.ulimit的值以（KB)为单位，并且必须大于或等于-Xmx参数传给JavaVM的值，否则VM会无法启动。</p>
<p>注意：mapred.child.java.opts只用于设置task tracker启动的子任务。为守护进程设置内存选项请查看 cluster_setup.html</p>
<h1 id="Hadoop__u539F_u7406_u5B66_u4E60"><a href="#Hadoop__u539F_u7406_u5B66_u4E60" class="headerlink" title="Hadoop 原理学习"></a>Hadoop 原理学习</h1><p>Hadoop 是 Apache 下的一个项目，由 HDFS、MapReduce、HBase、Hive 和 ZooKeeper 等成员组成。其中，HDFS 和 MapReduce 是两个最基础最重要的成员。</p>
<p>HDFS 是 Google GFS 的开源版本，一个高度容错的分布式文件系统，它能够提供高吞吐量的数据访问，适合存储海量(PB 级)的大文件(通常超过64M)，其原理如下图所示：</p>
<p><img src="/media/14521186972719/hadoop1.jpg" alt="hadoop1"></p>
<p>采用 Master/Slave 结构。NameNode 维护集群内的元数据，对外提供创建、打开、删除和重命名文件或目录的功能。DataNode 存储数据，并提负责处理数据的读写请求。DataNode 定期向 NameNode 上报心跳，NameNode 通过响应心跳来控制 DataNode。</p>
<p>Hadoop MapReduce的实现也采用了Master/Slave 结构。Master 叫做 JobTracker，而 Slave 叫做TaskTracker。用户提交的计算叫做 Job，每一个 Job 会被划分成若干个 Tasks。JobTracker 负责 Job 和 Tasks 的调度，而 TaskTracker 负责执行 Tasks。</p>
<h2 id="Shuffle__u548C_Sort__u5206_u6790"><a href="#Shuffle__u548C_Sort__u5206_u6790" class="headerlink" title="Shuffle 和 Sort 分析"></a>Shuffle 和 Sort 分析</h2><p>MapReduce 框架的核心步骤主要分两部分：Map 和 Reduce。当你向 MapReduce 框架提交一个计算作业时，它会首先把计算作业拆分成若干个 Map 任务，然后分配到不同的节点上去执行，每一个 Map 任务处理输入数据中的一部分，当 Map 任务完成后，它会生成一些中间文件，这些中间文件将会作为 Reduce 任务的输入数据。Reduce 任务的主要目标就是把前面若干个 Map 的输出汇总到一起并输出。从高层抽象来看，MapReduce 的数据流图如下图所示：</p>
<p><img src="/media/14521186972719/hadoop2.jpg" alt="hadoop2"></p>
<p>在本文中，Shuffle 是指从 Map 产生输出开始，包括系统执行排序以及传送 Map 输出到 Reducer 作为输入的过程。在这里我们将去探究 Shuffle 是如何工作的，因为对基础的理解有助于对 MapReduce 程序进行调优。</p>
<p>首先从 Map 端开始分析，当 Map 开始产生输出的时候，他并不是简单的把数据写到磁盘，因为频繁的操作会导致性能严重下降，他的处理更加复杂，数据首先是写到内存中的一个缓冲区，并作一些预排序，以提升效率，如图：</p>
<p><img src="/media/14521186972719/hadoop3.jpg" alt="hadoop3"></p>
<p>每个 Map 任务都有一个用来写入输出数据的循环内存缓冲区，这个缓冲区默认大小是 100M，可以通过 <code>io.sort.mb</code> 属性来设置具体的大小，当缓冲区中的数据量达到一个特定的阀值 <code>(io.sort.mb * io.sort.spill.percent，其中io.sort.spill.percent 默认是0.80)</code>时，系统将会启动一个后台线程把缓冲区中的内容 spill 到磁盘。在 spill 过程中，Map 的输出将会继续写入到缓冲区，但如果缓冲区已经满了，Map 就会被阻塞直到 spill 完成。spill 线程在把缓冲区的数据写到磁盘前，会对他进行一个二次排序，首先根据数据所属的 partition 排序，然后每个 partition 中再按 Key 排序。输出包括一个索引文件和数据文件，如果设定了Combiner，将在排序输出的基础上进行。Combiner 就是一个 Mini Reducer，它在执行 Map 任务的节点本身运行，先对 Map 的输出作一次简单的 Reduce，使得 Map 的输出更紧凑，更少的数据会被写入磁盘和传送到 Reducer。Spill 文件保存在由 <code>mapred.local.dir</code> 指定的目录中，Map 任务结束后删除。</p>
<p>每当内存中的数据达到 spill 阀值的时候，都会产生一个新的 spill 文件，所以在 Map 任务写完他的最后一个输出记录的时候，可能会有多个 spill 文件，在 Map 任务完成前，所有的 spill 文件将会被归并排序为一个索引文件和数据文件。如下图所示。这是一个多路归并过程，最大归并路数由 <code>io.sort.factor</code> 控制(默认是10)。如果设定了 Combiner，并且 spill 文件的数量至少是 3（由<code>min.num.spills.for.combine</code> 属性控制），那么 Combiner 将在输出文件被写入磁盘前运行以压缩数据。</p>
<p><img src="/media/14521186972719/hadoop4.jpg" alt="hadoop4"></p>
<p>对写入到磁盘的数据进行压缩（这种压缩同 Combiner 的压缩不一样）通常是一个很好的方法，因为这样做使得数据写入磁盘的速度更快，节省磁盘空间，并减少需要传送到 Reducer 的数据量。默认输出是不被压缩的，但可以很简单的设置 <code>mapred.compress.map.output</code> 为 <code>true</code> 启用该功能。压缩所使用的库由 <code>mapred.map.output.compression.codec</code> 来设定</p>
<p>当 spill 文件归并完毕后，Map 将删除所有的临时 spill 文件，并告知 TaskTracker 任务已完成。Reducers 通过 HTTP 来获取对应的数据。用来传输 partitions 数据的工作线程个数由 <code>tasktracker.http.threads</code> 控制，这个设定是针对每一个 TaskTracker 的，并不是单个 Map，默认值为 40，在运行大作业的大集群上可以增大以提升数据传输速率。</p>
<p>现在让我们转到 Shuffle 的 Reduce 部分。Map 的输出文件放置在运行 Map 任务的 TaskTracker 的本地磁盘上（注意：Map 输出总是写到本地磁盘，但是 Reduce 输出不是，一般是写到 HDFS），它是运行 Reduce 任务的 TaskTracker 所需要的输入数据。Reduce 任务的输入数据分布在集群内的多个 Map 任务的输出中，Map 任务可能会在不同的时间内完成，只要有其中一个 Map 任务完成，Reduce 任务就开始拷贝他的输出。这个阶段称为拷贝阶段，Reduce 任务拥有多个拷贝线程，可以并行的获取 Map 输出。可以通过设定 <code>mapred.reduce.parallel.copies</code> 来改变线程数。</p>
<p>Reduce 是怎么知道从哪些 TaskTrackers 中获取 Map 的输出呢？当 Map 任务完成之后，会通知他们的父 TaskTracker，告知状态更新，然后 TaskTracker 再转告 JobTracker，这些通知信息是通过心跳通信机制传输的，因此针对以一个特定的作业，jobtracker 知道 Map 输出与 tasktrackers 的映射关系。Reducer 中有一个线程会间歇的向 JobTracker 询问 Map 输出的地址，直到把所有的数据都取到。在 Reducer 取走了 Map 输出之后，TaskTracker 不会立即删除这些数据，因为 Reducer 可能会失败，他们会在整个作业完成之后，JobTracker 告知他们要删除的时候才去删除。</p>
<p>如果 Map 输出足够小，他们会被拷贝到 Reduce TaskTracker 的内存中（缓冲区的大小由 <code>mapred.job.shuffle.input.buffer.percnet</code> 控制），或者达到了 Map 输出的阀值的大小(由 <code>mapred.inmem.merge.threshold</code> 控制)，缓冲区中的数据将会被归并然后 spill 到磁盘。</p>
<p>拷贝来的数据叠加在磁盘上，有一个后台线程会将它们归并为更大的排序文件，这样做节省了后期归并的时间。对于经过压缩的 Map 输出，系统会自动把它们解压到内存方便对其执行归并。</p>
<p>当所有的 Map 输出都被拷贝后，Reduce 任务进入排序阶段（更恰当的说应该是归并阶段，因为排序在 Map 端就已经完成），这个阶段会对所有的 Map 输出进行归并排序，这个工作会重复多次才能完成。</p>
<p>假设这里有 50 个 Map 输出（可能有保存在内存中的），并且归并因子是 10（由 <code>io.sort.factor</code> 控制，就像 Map 端的 merge 一样），那最终需要 5 次归并。每次归并会把 10 个文件归并为一个，最终生成 5 个中间文件。在这一步之后，系统不再把 5 个中间文件归并成一个，而是排序后直接“喂”给 Reduce 函数，省去向磁盘写数据这一步。最终归并的数据可以是混合数据，既有内存上的也有磁盘上的。由于归并的目的是归并最少的文件数目，使得在最后一次归并时总文件个数达到归并因子的数目，所以每次操作所涉及的文件个数在实际中会更微妙些。譬如，如果有 40 个文件，并不是每次都归并 10 个最终得到 4 个文件，相反第一次只归并 4 个文件，然后再实现三次归并，每次 10 个，最终得到 4 个归并好的文件和 6 个未归并的文件。要注意，这种做法并没有改变归并的次数，只是最小化写入磁盘的数据优化措施，因为最后一次归并的数据总是直接送到 Reduce 函数那里。在Reduce 阶段，Reduce 函数会作用在排序输出的每一个 key 上。这个阶段的输出被直接写到输出文件系统，一般是 HDFS。在 HDFS 中，因为 TaskTracker 节点也运行着一个 DataNode 进程，所以第一个块备份会直接写到本地磁盘。到此，MapReduce 的 Shuffle 和 Sort 分析完毕。</p>
<h2 id="u5DE5_u4F5C_u539F_u7406"><a href="#u5DE5_u4F5C_u539F_u7406" class="headerlink" title="工作原理"></a>工作原理</h2><ul>
<li>Client: 作业提交发起者。</li>
<li>JobTracker: 初始化作业，分配作业，与 TaskTracker 通信，协调整个作业。</li>
<li>TaskTracker: 保持 JobTracker 通信，在分配的数据片段上执行 MapReduce 任务。</li>
</ul>
<p>提交作业</p>
<ul>
<li>在作业提交之前，需要对作业进行配置</li>
<li>程序代码，主要是自己书写的 MapReduce 程序。</li>
<li>输入输出路径</li>
<li>其他配置，如输出压缩等。</li>
<li>配置完成后，通过 JobClinet 来提交</li>
</ul>
<p>作业的初始化</p>
<ul>
<li>客户端提交完成后，JobTracker 会将作业加入队列，然后进行调度，默认的调度方法是 FIFO 调试方式。</li>
</ul>
<p>任务的分配</p>
<ul>
<li>TaskTracker 和 JobTracker 之间的通信与任务的分配是通过心跳机制完成的。</li>
<li>TaskTracker 会主动向 JobTracker 询问是否有作业要做，如果自己可以做，那么就会申请到作业任务，这个任务可以是 Map 也可能是 Reduce 任务。</li>
</ul>
<p>任务的执行</p>
<ul>
<li>申请到任务后，TaskTracker 会做如下事情：<ul>
<li>拷贝代码到本地</li>
<li>拷贝任务的信息到本地</li>
<li>启动JVM运行任务</li>
</ul>
</li>
</ul>
<p>状态与任务的更新</p>
<ul>
<li>任务在运行过程中，首先会将自己的状态汇报给 TaskTracker，然后由 TaskTracker 汇总告知 JobTracker。</li>
<li>任务进度是通过计数器来实现的。</li>
</ul>
<p>作业的完成</p>
<ul>
<li>JobTracker 是在接受到最后一个任务运行完成后，才会将任务标志为成功。</li>
<li>此时会做删除中间结果等善后处理工作。</li>
</ul>
<h2 id="u9519_u8BEF_u5904_u7406"><a href="#u9519_u8BEF_u5904_u7406" class="headerlink" title="错误处理"></a>错误处理</h2><p>任务失败</p>
<ul>
<li>MapReduce 在设计之出，就假象任务会失败，所以做了很多工作，来保证容错。</li>
<li>一种情况: 子任务失败</li>
<li>另一种情况: 子任务的 JVM 突然退出</li>
<li>任务的挂起</li>
</ul>
<p>TaskTracker 失败</p>
<ul>
<li>TaskTracker 崩溃后会停止向 Jobtracker 发送心跳信息。</li>
<li>Jobtracker 会将该 TaskTracker 从等待的任务池中移除。并将该 TaskTracker 上的任务，移动到其他地方去重新运行。</li>
<li>TaskTracker 可以被 JobTracker 放入到黑名单，即使它没有失败。</li>
</ul>
<p>JobTracker失败</p>
<ul>
<li>单点故障，Hadoop 新的0.23版本解决了这个问题。</li>
</ul>
<h2 id="u4F5C_u4E1A_u8C03_u5EA6"><a href="#u4F5C_u4E1A_u8C03_u5EA6" class="headerlink" title="作业调度"></a>作业调度</h2><ul>
<li>FIFO: Hadoop 中默认的调度器，它先按照作业的优先级高低，再按照到达时间的先后选 择被执行的作业</li>
<li>公平调度器: 为任务分配资源的方法，其目的是随着时间的推移，让提交的作业获取等量的集 群共享资源，让用户公平地共享集群。具体做法是：当集群上只有一个任务在运行 时，它将使用整个集群，当有其他作业提交时，系统会将 TaskTracker 节点空间的时 间片分配给这些新的作业，并保证每个任务都得到大概等量的CPU时间。</li>
<li>容量调度器: 支持多个队列，每个队列可配置一定的资源量，每个队列采用 FIFO 调度策略，为了防止同一个用户的作业独占队列中的资源，该调度器会对同一用户提交的作业所占资源量进行限定。调度时，首先按以下策略选择一个合适队列：计算每个队列中正在运行的任务数与其应该分得的计算资源之间的比值，选择一个该比值最小的队列；然后按以下策略选择该队列中一个作业：按照作业优先级和提交时间顺序选择 ，同时考虑用户资源量限制和内存限制。但是不可剥夺式</li>
</ul>
<h2 id="Shuffle__26amp_3B_Sort"><a href="#Shuffle__26amp_3B_Sort" class="headerlink" title="Shuffle &amp; Sort"></a>Shuffle &amp; Sort</h2><p>Mapreduce 的 map 结束后，把数据重新组织，作为 reduce 阶段的输入，该过程称之为 shuffle – 洗牌。而数据在 Map 与 Reduce 端都会做排序。</p>
<p>Map</p>
<ul>
<li>Map 的输出是由 collector 控制的</li>
<li>我们从 collect 函数入手</li>
</ul>
<p>Reduce</p>
<ul>
<li>reduce 的 Shuffle 过程，分成三个阶段：复制 Map 输出、排序合并、reduce 处理。</li>
<li>主要代码在 reduce的 run 函数</li>
</ul>
<p>Shuffle优化</p>
<ul>
<li>首先 Hadoop 的 Shuffle 在某些情况并不是最优的，例如，如果需要对2集合合并，那么其实排序操作时不需要的。</li>
<li>我们可以通过调整参数来优化 Shuffle</li>
<li>Map端: io.sort.mb</li>
<li>Reduce端: mapred.job.reduce.input.buffer.percent</li>
</ul>
<h2 id="u4EFB_u52A1_u7684_u6267_u884C_u65F6_u7684_u4E00_u4E9B_u7279_u6709_u7684_u6982_u5FF5"><a href="#u4EFB_u52A1_u7684_u6267_u884C_u65F6_u7684_u4E00_u4E9B_u7279_u6709_u7684_u6982_u5FF5" class="headerlink" title="任务的执行时的一些特有的概念"></a>任务的执行时的一些特有的概念</h2><p>推测式执行</p>
<ul>
<li>每一道作业的任务都有运行时间，而由于机器的异构性，可能会会造成某些任务会比所有任务的平均运行时间要慢很多。</li>
<li>这时 MapReduce 会尝试在其他机器上重启慢的任务。为了是任务快速运行完成。</li>
<li>该属性默认是启用的。</li>
</ul>
<p>JVM重用</p>
<ul>
<li>启动 JVM 是一个比较耗时的工作，所以在 MapReduce 中有 JVM 重用的机制。</li>
<li>条件是统一个作业的任务。</li>
<li>可以通过 <code>mapred.job.reuse.jvm.num.tasks</code>定义重用次数，如果属性是 -1 那么为无限制。</li>
</ul>
<p>跳过坏记录</p>
<ul>
<li>数据的一些记录不符合规范，处理时抛出异常，MapReduce 可以讲次记录标为坏记录。重启任务时会跳过该记录。</li>
<li>默认情况下该属性是关闭的。</li>
</ul>
<p>任务执行环境</p>
<ul>
<li>Hadoop 为 Map 与 Reduce 任务提供运行环境。</li>
<li>如：Map 可以知道自己的处理的文件</li>
<li>问题：多个任务可能会同时写一个文件</li>
<li>解决办法：将输出写到任务的临时文件夹。目录为：{mapred.out. put.dir}/temp/${mapred.task.id}</li>
</ul>
<h2 id="u6D41_u7A0B_u5206_u6790"><a href="#u6D41_u7A0B_u5206_u6790" class="headerlink" title="流程分析"></a>流程分析</h2><p>Map端：</p>
<ol>
<li>每个输入分片会让一个 map 任务来处理，默认情况下，以 HDFS 的一个块的大小（默认为 64M）为一个分片，当然我们也可以设置块的大小。map 输出的结果会暂且放在一个环形内存缓冲区中（该缓冲区的大小默认为 100M，由 <code>io.sort.mb</code> 属性控制），当该缓冲区快要溢出时（默认为缓冲区大小的80%，由 <code>io.sort.spill.percent</code> 属性控制），会在本地文件系统中创建一个溢出文件，将该缓冲区中的数据写入这个文件。</li>
<li>在写入磁盘之前，线程首先根据 reduce 任务的数目将数据划分为相同数目的分区，也就是一个 reduce 任务对应一个分区的数据。这样做是为了避免有些 reduce 任务分配到大量数据，而有些 reduce 任务却分到很少数据，甚至没有分到数据的尴尬局面。其实分区就是对数据进行 hash 的过程。然后对每个分区中的数据进行排序，如果此时设置了 Combiner，将排序后的结果进行 Combiner 操作，这样做的目的是让尽可能少的数据写入到磁盘。</li>
<li>当 map 任务输出最后一个记录时，可能会有很多的溢出文件，这时需要将这些文件合并。合并的过程中会不断地进行排序和 combiner 操作，目的有两个：1.尽量减少每次写入磁盘的数据量；2.尽量减少下一复制阶段网络传输的数据量。最后合并成了一个已分区且已排序的文件。为了减少网络传输的数据量，这里可以将数据压缩，只要将 <code>mapred.compress.map.out</code> 设置为 true 就可以了。</li>
<li>将分区中的数据拷贝给相对应的 reduce 任务。有人可能会问：分区中的数据怎么知道它对应的 reduce 是哪个呢？其实 map 任务一直和其父 TaskTracker 保持联系，而 TaskTracker 又一直和 JobTracker 保持心跳。所以 JobTracker 中保存了整个集群中的宏观信息。只要 reduce 任务向 JobTracker 获取对应的 map 输出位置就ok了哦。</li>
</ol>
<p>到这里，map 端就分析完了。那到底什么是 Shuffle 呢？Shuffle 的中文意思是“洗牌”，如果我们这样看：一个 map 产生的数据，结果通过 hash 过程分区却分配给了不同的 reduce 任务，是不是一个对数据洗牌的过程呢？呵呵。</p>
<p>Reduce端：</p>
<ol>
<li>Reduce 会接收到不同 map 任务传来的数据，并且每个 map 传来的数据都是有序的。如果 reduce 端接受的数据量相当小，则直接存储在内存中（缓冲区大小由 <code>mapred.job.shuffle.input.buffer.percent</code> 属性控制，表示用作此用途的堆空间的百分比），如果数据量超过了该缓冲区大小的一定比例（由 <code>mapred.job.shuffle.merge.percent</code> 决定），则对数据合并后溢写到磁盘中。</li>
<li>随着溢写文件的增多，后台线程会将它们合并成一个更大的有序的文件，这样做是为了给后面的合并节省时间。其实不管在 map 端还是 reduce 端，MapReduce 都是反复地执行排序，合并操作，现在终于明白了有些人为什么会说：排序是 hadoop 的灵魂。</li>
<li>合并的过程中会产生许多的中间文件（写入磁盘了），但 MapReduce 会让写入磁盘的数据尽可能地少，并且最后一次合并的结果并没有写入磁盘，而是直接输入到 reduce 函数。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里简要介绍一下 Hadoop 的基本原理及用法。</p>]]>
    
    </summary>
    
      <category term="Hadoop" scheme="http://wdxtub.com/tags/Hadoop/"/>
    
      <category term="MapReduce" scheme="http://wdxtub.com/tags/MapReduce/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SQL 指南]]></title>
    <link href="http://wdxtub.com/2016/03/20/sql-guide/"/>
    <id>http://wdxtub.com/2016/03/20/sql-guide/</id>
    <published>2016-03-20T12:59:34.000Z</published>
    <updated>2016-03-20T13:00:27.000Z</updated>
    <content type="html"><![CDATA[<p>这里记录一下对于 SQL 基本操作的理解和优化。</p>
<a id="more"></a>
<hr>
<h2 id="SQL__u662F_u4E00_u79CD_u58F0_u660E_u5F0F_u8BED_u8A00"><a href="#SQL__u662F_u4E00_u79CD_u58F0_u660E_u5F0F_u8BED_u8A00" class="headerlink" title="SQL 是一种声明式语言"></a>SQL 是一种声明式语言</h2><p>首先要把这个概念记在脑中：“声明”。 SQL 语言是为计算机声明了一个你想从原始数据中获得什么样的结果的一个范例，而不是告诉计算机如何能够得到结果。这是不是很棒？</p>
<p>（译者注：简单地说，SQL 语言声明的是结果集的属性，计算机会根据 SQL 所声明的内容来从数据库中挑选出符合声明的数据，而不是像传统编程思维去指示计算机如何操作。）</p>
<pre><code>SELECT first_name, last_name FROM employees WHERE salary &gt; 100000
</code></pre><p>上面的例子很容易理解，我们不关心这些雇员记录从哪里来，我们所需要的只是那些高薪者的数据（译者注： salary&gt;100000 ）。</p>
<p>我们从哪儿学习到这些？</p>
<p>如果 SQL 语言这么简单，那么是什么让人们“闻 SQL 色变”？主要的原因是：我们潜意识中的是按照命令式编程的思维方式思考问题的。就好像这样：“电脑，先执行这一步，再执行那一步，但是在那之前先检查一下是否满足条件 A 和条件 B ”。例如，用变量传参、使用循环语句、迭代、调用函数等等，都是这种命令式编程的思维惯式。</p>
<h2 id="SQL__u7684_u8BED_u6CD5_u5E76_u4E0D_u6309_u7167_u8BED_u6CD5_u987A_u5E8F_u6267_u884C"><a href="#SQL__u7684_u8BED_u6CD5_u5E76_u4E0D_u6309_u7167_u8BED_u6CD5_u987A_u5E8F_u6267_u884C" class="headerlink" title="SQL 的语法并不按照语法顺序执行"></a>SQL 的语法并不按照语法顺序执行</h2><p>SQL 语句有一个让大部分人都感到困惑的特性，就是：SQL 语句的执行顺序跟其语句的语法顺序并不一致。SQL 语句的语法顺序是：</p>
<ul>
<li>SELECT[DISTINCT]</li>
<li>FROM</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>UNION</li>
<li>ORDER BY</li>
</ul>
<p>为了方便理解，上面并没有把所有的 SQL 语法结构都列出来，但是已经足以说明 SQL 语句的语法顺序和其执行顺序完全不一样，就以上述语句为例，其执行顺序为：</p>
<ul>
<li>FROM</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>SELECT</li>
<li>DISTINCT</li>
<li>UNION</li>
<li>ORDER BY</li>
</ul>
<p>关于 SQL 语句的执行顺序，有三个值得我们注意的地方：</p>
<p>1、 FROM 才是 SQL 语句执行的第一步，并非 SELECT 。数据库在执行 SQL 语句的第一步是将数据从硬盘加载到数据缓冲区中，以便对这些数据进行操作。（译者注：原文为“The first thing that happens is loading data from the disk into memory, in order to operate on such data.”，但是并非如此，以 Oracle 等常用数据库为例，数据是从硬盘中抽取到数据缓冲区中进行操作。）</p>
<p>2、 SELECT 是在大部分语句执行了之后才执行的，严格的说是在 FROM 和 GROUP BY 之后执行的。理解这一点是非常重要的，这就是你不能在 WHERE 中使用在 SELECT 中设定别名的字段作为判断条件的原因。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> A.x + A.y <span class="keyword">AS</span> z</span><br><span class="line"><span class="keyword">FROM</span> A</span><br><span class="line"><span class="keyword">WHERE</span> z = <span class="number">10</span></span></span><br></pre></td></tr></table></figure>
<p>z 在此处不可用，因为SELECT是最后执行的语句！<br>如果你想重用别名z，你有两个选择。要么就重新写一遍 z 所代表的表达式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> A.x + A.y <span class="keyword">AS</span> z</span><br><span class="line"><span class="keyword">FROM</span> A</span><br><span class="line"><span class="keyword">WHERE</span> (A.x + A.y) = <span class="number">10</span></span></span><br></pre></td></tr></table></figure>
<p>或者求助于衍生表、通用数据表达式或者视图，以避免别名重用。请看下文中的例子。</p>
<p>3、 无论在语法上还是在执行顺序上， UNION 总是排在在 ORDER BY 之前。很多人认为每个 UNION 段都能使用 ORDER BY 排序，但是根据 SQL 语言标准和各个数据库 SQL 的执行差异来看，这并不是真的。尽管某些数据库允许 SQL 语句对子查询（subqueries）或者派生表（derived tables）进行排序，但是这并不说明这个排序在 UNION 操作过后仍保持排序后的顺序。</p>
<p>注意：并非所有的数据库对 SQL 语句使用相同的解析方式。如 MySQL、PostgreSQL和 SQLite 中就不会按照上面第二点中所说的方式执行。</p>
<p>我们学到了什么？</p>
<p>既然并不是所有的数据库都按照上述方式执行 SQL 预计，那我们的收获是什么？我们的收获是永远要记得： SQL 语句的语法顺序和其执行顺序并不一致，这样我们就能避免一般性的错误。如果你能记住 SQL 语句语法顺序和执行顺序的差异，你就能很容易的理解一些很常见的 SQL 问题。</p>
<p>当然，如果一种语言被设计成语法顺序直接反应其语句的执行顺序，那么这种语言对程序员是十分友好的，这种编程语言层面的设计理念已经被微软应用到了 LINQ 语言中。</p>
<h2 id="SQL__u8BED_u8A00_u7684_u6838_u5FC3_u662F_u5BF9_u8868_u7684_u5F15_u7528_uFF08table_references_uFF09"><a href="#SQL__u8BED_u8A00_u7684_u6838_u5FC3_u662F_u5BF9_u8868_u7684_u5F15_u7528_uFF08table_references_uFF09" class="headerlink" title="SQL 语言的核心是对表的引用（table references）"></a>SQL 语言的核心是对表的引用（table references）</h2><p>由于 SQL 语句语法顺序和执行顺序的不同，很多同学会认为SELECT 中的字段信息是 SQL 语句的核心。其实真正的核心在于对表的引用。</p>
<p>根据 SQL 标准，FROM 语句被定义为：</p>
<pre><code>&lt;from clause&gt; ::= FROM &lt;table reference&gt; [ { &lt;comma&gt; &lt;table reference&gt; }... ]
</code></pre><p>FROM 语句的“输出”是一张联合表，来自于所有引用的表在某一维度上的联合。我们们慢慢来分析：</p>
<pre><code>FROM a, b
</code></pre><p>上面这句 FROM 语句的输出是一张联合表，联合了表 a 和表 b 。如果 a 表有三个字段， b 表有 5 个字段，那么这个“输出表”就有 8 （ =5+3）个字段。</p>
<p>这个联合表里的数据是 <code>a*b</code>，即 a 和 b 的笛卡尔积。换句话说，也就是 a 表中的每一条数据都要跟 b 表中的每一条数据配对。如果 a 表有3 条数据， b 表有 5 条数据，那么联合表就会有 <code>15（=5*3）</code>条数据。</p>
<p>FROM 输出的结果被 WHERE 语句筛选后要经过 GROUP BY 语句处理，从而形成新的输出结果。我们后面还会再讨论这方面问题。</p>
<p>如果我们从集合论（关系代数）的角度来看，一张数据库的表就是一组数据元的关系，而每个 SQL 语句会改变一种或数种关系，从而产生出新的数据元的关系（即产生新的表）。</p>
<p>我们学到了什么？</p>
<p>思考问题的时候从表的角度来思考问题提，这样很容易理解数据如何在 SQL 语句的“流水线”上进行了什么样的变动。</p>
<h2 id="u7075_u6D3B_u5F15_u7528_u8868_u80FD_u4F7F_SQL__u8BED_u53E5_u53D8_u5F97_u66F4_u5F3A_u5927"><a href="#u7075_u6D3B_u5F15_u7528_u8868_u80FD_u4F7F_SQL__u8BED_u53E5_u53D8_u5F97_u66F4_u5F3A_u5927" class="headerlink" title="灵活引用表能使 SQL 语句变得更强大"></a>灵活引用表能使 SQL 语句变得更强大</h2><p>灵活引用表能使 SQL 语句变得更强大。一个简单的例子就是 JOIN 的使用。严格的说 JOIN 语句并非是 SELECT 中的一部分，而是一种特殊的表引用语句。 SQL 语言标准中表的连接定义如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">table</span> <span class="attribute">reference</span>&gt;</span> ::=</span><br><span class="line">    <span class="tag">&lt;<span class="title">table</span> <span class="attribute">name</span>&gt;</span></span><br><span class="line">  | <span class="tag">&lt;<span class="title">derived</span> <span class="attribute">table</span>&gt;</span></span><br><span class="line">  | <span class="tag">&lt;<span class="title">joined</span> <span class="attribute">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就拿之前的例子来说：</p>
<pre><code>FROM a, b
</code></pre><p>a 可能输如下表的连接：</p>
<pre><code>a1 JOIN a2 ON a1.id = a2.id
</code></pre><p>将它放到之前的例子中就变成了：</p>
<pre><code>FROM a1 JOIN a2 ON a1.id = a2.id, b
</code></pre><p>尽管将一个连接表用逗号跟另一张表联合在一起并不是常用作法，但是你的确可以这么做。结果就是，最终输出的表就有了 a1+a2+b 个字段了。</p>
<p>（译者注：原文这里用词为 degree ，译为维度。如果把一张表视图化，我们可以想象每一张表都是由横纵两个维度组成的，横向维度即我们所说的字段或者列，英文为columns；纵向维度即代表了每条数据，英文为 record ，根据上下文，作者这里所指的应该是字段数。）</p>
<p>在 SQL 语句中派生表的应用甚至比表连接更加强大，下面我们就要讲到表连接。</p>
<p>我们学到了什么？</p>
<p>思考问题时，要从表引用的角度出发，这样就很容易理解数据是怎样被 SQL 语句处理的，并且能够帮助你理解那些复杂的表引用是做什么的。</p>
<p>更重要的是，要理解 JOIN 是构建连接表的关键词，并不是 SELECT 语句的一部分。有一些数据库允许在 INSERT 、 UPDATE 、 DELETE 中使用 JOIN 。</p>
<h2 id="SQL__u8BED_u53E5_u4E2D_u63A8_u8350_u4F7F_u7528_u8868_u8FDE_u63A5"><a href="#SQL__u8BED_u53E5_u4E2D_u63A8_u8350_u4F7F_u7528_u8868_u8FDE_u63A5" class="headerlink" title="SQL 语句中推荐使用表连接"></a>SQL 语句中推荐使用表连接</h2><p>我们先看看刚刚这句话：</p>
<pre><code>FROM a, b
</code></pre><p>高级 SQL 程序员也许学会给你忠告：尽量不要使用逗号来代替 JOIN 进行表的连接，这样会提高你的 SQL 语句的可读性，并且可以避免一些错误。</p>
<p>利用逗号来简化 SQL 语句有时候会造成思维上的混乱，想一下下面的语句：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM <span class="tag">a</span>, <span class="tag">b</span>, c, d, e, f, g, h</span><br><span class="line">WHERE <span class="tag">a</span><span class="class">.a1</span> = <span class="tag">b</span><span class="class">.bx</span></span><br><span class="line">AND <span class="tag">a</span><span class="class">.a2</span> = c<span class="class">.c1</span></span><br><span class="line">AND d<span class="class">.d1</span> = <span class="tag">b</span><span class="class">.bc</span></span><br><span class="line">-- etc...</span><br></pre></td></tr></table></figure>
<p>我们不难看出使用 JOIN 语句的好处在于：</p>
<ul>
<li>安全。 JOIN 和要连接的表离得非常近，这样就能避免错误。</li>
<li>更多连接的方式，JOIN 语句能去区分出来外连接和内连接等。</li>
</ul>
<p>我们学到了什么？</p>
<p>记着要尽量使用 JOIN 进行表的连接，永远不要在 FROM 后面使用逗号连接表。</p>
<h2 id="SQL__u8BED_u53E5_u4E2D_u4E0D_u540C_u7684_u8FDE_u63A5_u64CD_u4F5C"><a href="#SQL__u8BED_u53E5_u4E2D_u4E0D_u540C_u7684_u8FDE_u63A5_u64CD_u4F5C" class="headerlink" title="SQL 语句中不同的连接操作"></a>SQL 语句中不同的连接操作</h2><p>SQL 语句中，表连接的方式从根本上分为五种：</p>
<ul>
<li>EQUI JOIN</li>
<li>SEMI JOIN</li>
<li>ANTI JOIN</li>
<li>CROSS JOIN</li>
<li>DIVISION</li>
</ul>
<h3 id="EQUI_JOIN"><a href="#EQUI_JOIN" class="headerlink" title="EQUI JOIN"></a>EQUI JOIN</h3><p>这是一种最普通的 JOIN 操作，它包含两种连接方式：</p>
<ul>
<li>INNER JOIN（或者是 JOIN ）</li>
<li>OUTER JOIN（包括： LEFT 、 RIGHT、 FULL OUTER JOIN）</li>
</ul>
<p>用例子最容易说明其中区别：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">- <span class="constant">This</span> table reference contains authors <span class="keyword">and</span> their books.</span><br><span class="line"></span>-<span class="ruby">- <span class="constant">There</span> is one record <span class="keyword">for</span> each book <span class="keyword">and</span> its author.</span><br><span class="line"></span>-<span class="ruby">- authors without books are <span class="constant">NOT</span> included</span><br><span class="line"></span>author JOIN book ON author.id = book.author_id</span><br><span class="line"></span><br><span class="line">-<span class="ruby">- <span class="constant">This</span> table reference contains authors <span class="keyword">and</span> their books</span><br><span class="line"></span>-<span class="ruby">- <span class="constant">There</span> is one record <span class="keyword">for</span> each book <span class="keyword">and</span> its author.</span><br><span class="line"></span>-<span class="ruby">- ... <span class="constant">OR</span> there is an <span class="string">"empty"</span> record <span class="keyword">for</span> authors without books</span><br><span class="line"></span>-<span class="ruby">- (<span class="string">"empty"</span> meaning that all book columns are <span class="constant">NULL</span>)</span><br><span class="line"></span>author LEFT OUTER JOIN book ON author.id = book.author_id</span><br></pre></td></tr></table></figure>
<h3 id="SEMI_JOIN"><a href="#SEMI_JOIN" class="headerlink" title="SEMI JOIN"></a>SEMI JOIN</h3><p>这种连接关系在 SQL 中有两种表现方式：使用 IN，或者使用 EXISTS。“ SEMI ”在拉丁文中是“半”的意思。这种连接方式是只连接目标表的一部分。这是什么意思呢？再想一下上面关于作者和书名的连接。我们想象一下这样的情况：我们不需要作者 / 书名这样的组合，只是需要那些在书名表中的书的作者信息。那我们就能这么写：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- <span class="keyword">Using</span> <span class="keyword">IN</span></span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> author.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> book.author_id <span class="keyword">FROM</span> book)</span><br><span class="line"></span><br><span class="line">-- <span class="keyword">Using</span> EXISTS</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> EXISTS (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> book.author_id = author.id)</span><br></pre></td></tr></table></figure>
<p>尽管没有严格的规定说明你何时应该使用 IN ，何时应该使用 EXISTS ，但是这些事情你还是应该知道的：</p>
<ul>
<li>IN 比 EXISTS 的可读性更好</li>
<li>EXISTS 比IN 的表达性更好（更适合复杂的语句）</li>
<li>二者之间性能没有差异（但对于某些数据库来说性能差异会非常大）</li>
</ul>
<p>因为使用 INNER JOIN 也能得到书名表中书所对应的作者信息，所以很多初学者机会认为可以通过 DISTINCT 进行去重，然后将 SEMI JOIN 语句写成这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Find only those authors who also have books</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> first_name, last_name</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">JOIN</span> book <span class="keyword">ON</span> author.<span class="keyword">id</span> = book.author_id</span></span><br></pre></td></tr></table></figure>
<p>这是一种很糟糕的写法，原因如下：</p>
<ul>
<li>SQL 语句性能低下：因为去重操作（ DISTINCT ）需要数据库重复从硬盘中读取数据到内存中。（译者注： DISTINCT 的确是一种很耗费资源的操作，但是每种数据库对于 DISTINCT 的操作方式可能不同）。</li>
<li>这么写并非完全正确：尽管也许现在这么写不会出现问题，但是随着 SQL 语句变得越来越复杂，你想要去重得到正确的结果就变得十分困难。</li>
</ul>
<h3 id="ANTI_JOIN"><a href="#ANTI_JOIN" class="headerlink" title="ANTI JOIN"></a>ANTI JOIN</h3><p>这种连接的关系跟 SEMI JOIN 刚好相反。在 IN 或者 EXISTS 前加一个 NOT 关键字就能使用这种连接。举个例子来说，我们列出书名表里没有书的作者：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- <span class="keyword">Using</span> <span class="keyword">IN</span></span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> author.id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> book.author_id <span class="keyword">FROM</span> book)</span><br><span class="line"></span><br><span class="line">-- <span class="keyword">Using</span> EXISTS</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> EXISTS (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> book.author_id = author.id)</span><br></pre></td></tr></table></figure>
<p>关于性能、可读性、表达性等特性也完全可以参考 SEMI JOIN。</p>
<h3 id="CROSS_JOIN"><a href="#CROSS_JOIN" class="headerlink" title="CROSS JOIN"></a>CROSS JOIN</h3><p>这个连接过程就是两个连接的表的乘积：即将第一张表的每一条数据分别对应第二张表的每条数据。我们之前见过，这就是逗号在 FROM 语句中的用法。在实际的应用中，很少有地方能用到 CROSS JOIN，但是一旦用上了，你就可以用这样的 SQL语句表达：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- Combine <span class="keyword">every</span> author with <span class="keyword">every</span> book</span><br><span class="line">author CROSS <span class="keyword">JOIN</span> book</span><br></pre></td></tr></table></figure>
<h3 id="DIVISION"><a href="#DIVISION" class="headerlink" title="DIVISION"></a>DIVISION</h3><p>DIVISION 的确是一个怪胎。简而言之，如果 JOIN 是一个乘法运算，那么 DIVISION 就是 JOIN 的逆过程。DIVISION 的关系很难用 SQL 表达出来，介于这是一个新手指南，解释 DIVISION 已经超出了我们的目的。</p>
<p>我们学到了什么？</p>
<p>学到了很多！让我们在脑海中再回想一下。 SQL 是对表的引用， JOIN 则是一种引用表的复杂方式。但是 SQL 语言的表达方式和实际我们所需要的逻辑关系之间是有区别的，并非所有的逻辑关系都能找到对应的 JOIN 操作，所以这就要我们在平时多积累和学习关系逻辑，这样你就能在以后编写 SQL 语句中选择适当的 JOIN 操作了。</p>
<h2 id="SQL__u4E2D_u5982_u540C_u53D8_u91CF_u7684_u6D3E_u751F_u8868"><a href="#SQL__u4E2D_u5982_u540C_u53D8_u91CF_u7684_u6D3E_u751F_u8868" class="headerlink" title="SQL 中如同变量的派生表"></a>SQL 中如同变量的派生表</h2><p>在这之前，我们学习到过 SQL 是一种声明性的语言，并且 SQL 语句中不能包含变量。但是你能写出类似于变量的语句，这些就叫做派生表：</p>
<p>说白了，所谓的派生表就是在括号之中的子查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- A derived table</span></span><br><span class="line">FROM (<span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> author)</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是有些时候我们可以给派生表定义一个相关名（即我们所说的别名）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- A derived table with an alias</span></span><br><span class="line">FROM (<span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> author) a</span></span><br></pre></td></tr></table></figure>
<p>派生表可以有效的避免由于 SQL 逻辑而产生的问题。举例来说：如果你想重用一个用 SELECT 和 WHERE 语句查询出的结果，这样写就可以（以 Oracle 为例）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Get authors' first and last names, and their age in days</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> first_name, last_name, age</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> first_name, last_name, <span class="keyword">current_date</span> - date_of_birth age</span><br><span class="line">  <span class="keyword">FROM</span> author</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- If the age is greater than 10000 days</span></span><br><span class="line"><span class="keyword">WHERE</span> age &gt; <span class="number">10000</span></span></span><br></pre></td></tr></table></figure>
<p>需要我们注意的是：在有些数据库，以及 SQL ： 1990 标准中，派生表被归为下一级——通用表语句（ common table experssion）。这就允许你在一个 SELECT 语句中对派生表多次重用。上面的例子就（几乎）等价于下面的语句：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> a <span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> first_name, last_name, current_date - date_of_birth age</span><br><span class="line">  <span class="keyword">FROM</span> author</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> a</span><br><span class="line"><span class="keyword">WHERE</span> age &gt; <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>当然了，你也可以给“ a ”创建一个单独的视图，这样你就可以在更广泛的范围内重用这个派生表了。更多信息可以阅读下面的文章（<a href="http://en.wikipedia.org/wiki/View_%28SQL%29）。" target="_blank" rel="external">http://en.wikipedia.org/wiki/View_%28SQL%29）。</a></p>
<p>我们学到了什么？</p>
<p>我们反复强调，大体上来说 SQL 语句就是对表的引用，而并非对字段的引用。要好好利用这一点，不要害怕使用派生表或者其他更复杂的语句。</p>
<h2 id="SQL__u8BED_u53E5_u4E2D_GROUP_BY__u662F_u5BF9_u8868_u7684_u5F15_u7528_u8FDB_u884C_u7684_u64CD_u4F5C"><a href="#SQL__u8BED_u53E5_u4E2D_GROUP_BY__u662F_u5BF9_u8868_u7684_u5F15_u7528_u8FDB_u884C_u7684_u64CD_u4F5C" class="headerlink" title="SQL 语句中 GROUP BY 是对表的引用进行的操作"></a>SQL 语句中 GROUP BY 是对表的引用进行的操作</h2><p>让我们再回想一下之前的 FROM 语句：</p>
<pre><code>FROM a, b
</code></pre><p>现在，我们将 GROUP BY 应用到上面的语句中：</p>
<pre><code>GROUP BY A.x, A.y, B.z
</code></pre><p>上面语句的结果就是产生出了一个包含三个字段的新的表的引用。我们来仔细理解一下这句话：当你应用 GROUP BY 的时候， SELECT 后没有使用聚合函数的列，都要出现在 GROUP BY 后面。（译者注：原文大意为“当你是用 GROUP BY 的时候，你能够对其进行下一级逻辑操作的列会减少，包括在 SELECT 中的列”）。</p>
<p>需要注意的是：其他字段能够使用聚合函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT A<span class="class">.x</span>, A<span class="class">.y</span>, <span class="function"><span class="title">SUM</span><span class="params">(A.z)</span></span></span><br><span class="line">FROM A</span><br><span class="line">GROUP BY A<span class="class">.x</span>, A.y</span><br></pre></td></tr></table></figure>
<p>还有一点值得留意的是： MySQL 并不坚持这个标准，这的确是令人很困惑的地方。（译者注：这并不是说 MySQL 没有 GROUP BY 的功能）但是不要被 MySQL 所迷惑。 GROUP BY 改变了对表引用的方式。你可以像这样既在 SELECT 中引用某一字段，也在 GROUP BY 中对其进行分组。</p>
<p>我们学到了什么？</p>
<p>GROUP BY，再次强调一次，是在表的引用上进行了操作，将其转换为一种新的引用方式。</p>
<h2 id="SQL__u8BED_u53E5_u4E2D_u7684_SELECT__u5B9E_u8D28_u4E0A_u662F_u5BF9_u5173_u7CFB_u7684_u6620_u5C04"><a href="#SQL__u8BED_u53E5_u4E2D_u7684_SELECT__u5B9E_u8D28_u4E0A_u662F_u5BF9_u5173_u7CFB_u7684_u6620_u5C04" class="headerlink" title="SQL 语句中的 SELECT 实质上是对关系的映射"></a>SQL 语句中的 SELECT 实质上是对关系的映射</h2><p>我个人比较喜欢“映射”这个词，尤其是把它用在关系代数上。（译者注：原文用词为 projection ，该词有两层含义，第一种含义是预测、规划、设计，第二种意思是投射、映射，经过反复推敲，我觉得这里用映射能够更直观的表达出 SELECT 的作用）。一旦你建立起来了表的引用，经过修改、变形，你能够一步一步的将其映射到另一个模型中。 SELECT 语句就像一个“投影仪”，我们可以将其理解成一个将源表中的数据按照一定的逻辑转换成目标表数据的函数。</p>
<p>通过 SELECT语句，你能对每一个字段进行操作，通过复杂的表达式生成所需要的数据。</p>
<p>SELECT 语句有很多特殊的规则，至少你应该熟悉以下几条：</p>
<ul>
<li>你仅能够使用那些能通过表引用而得来的字段；</li>
<li>如果你有 GROUP BY 语句，你只能够使用 GROUP BY 语句后面的字段或者聚合函数；</li>
<li>当你的语句中没有 GROUP BY 的时候，可以使用开窗函数代替聚合函数；</li>
<li>当你的语句中没有 GROUP BY 的时候，你不能同时使用聚合函数和其它函数；</li>
<li>有一些方法可以将普通函数封装在聚合函数中；</li>
<li>……</li>
</ul>
<p>一些更复杂的规则多到足够写出另一篇文章了。比如：为何你不能在一个没有 GROUP BY 的 SELECT 语句中同时使用普通函数和聚合函数？（上面的第 4 条）</p>
<p>原因如下：</p>
<ul>
<li>凭直觉，这种做法从逻辑上就讲不通。</li>
<li>如果直觉不能够说服你，那么语法肯定能。 SQL : 1999 标准引入了 GROUPING SETS，SQL： 2003 标准引入了 group sets : GROUP BY() 。无论什么时候，只要你的语句中出现了聚合函数，而且并没有明确的 GROUP BY 语句，这时一个不明确的、空的 GROUPING SET 就会被应用到这段 SQL 中。因此，原始的逻辑顺序的规则就被打破了，映射（即 SELECT ）关系首先会影响到逻辑关系，其次就是语法关系。（译者注：这段话原文就比较艰涩，可以简单理解如下：在既有聚合函数又有普通函数的 SQL 语句中，如果没有 GROUP BY 进行分组，SQL 语句默认视整张表为一个分组，当聚合函数对某一字段进行聚合统计的时候，引用的表中的每一条 record 就失去了意义，全部的数据都聚合为一个统计值，你此时对每一条 record 使用其它函数是没有意义的）。</li>
</ul>
<p>糊涂了？是的，我也是。我们再回过头来看点浅显的东西吧。</p>
<p>我们学到了什么？</p>
<p>SELECT 语句可能是 SQL 语句中最难的部分了，尽管他看上去很简单。其他语句的作用其实就是对表的不同形式的引用。而 SELECT 语句则把这些引用整合在了一起，通过逻辑规则将源表映射到目标表，而且这个过程是可逆的，我们可以清楚的知道目标表的数据是怎么来的。</p>
<p>想要学习好 SQL 语言，就要在使用 SELECT 语句之前弄懂其他的语句，虽然 SELECT 是语法结构中的第一个关键词，但它应该是我们最后一个掌握的。</p>
<h2 id="SQL__u8BED_u53E5_u4E2D_u7684_u51E0_u4E2A_u7B80_u5355_u7684_u5173_u952E_u8BCD_uFF1A_DISTINCT__uFF0C_UNION__uFF0C_ORDER_BY__u548C_OFFSET"><a href="#SQL__u8BED_u53E5_u4E2D_u7684_u51E0_u4E2A_u7B80_u5355_u7684_u5173_u952E_u8BCD_uFF1A_DISTINCT__uFF0C_UNION__uFF0C_ORDER_BY__u548C_OFFSET" class="headerlink" title="SQL 语句中的几个简单的关键词： DISTINCT ， UNION ， ORDER BY 和 OFFSET"></a>SQL 语句中的几个简单的关键词： DISTINCT ， UNION ， ORDER BY 和 OFFSET</h2><p>在学习完复杂的 SELECT 之后，我们再来看点简单的东西：</p>
<ul>
<li>集合运算（ DISTINCT 和 UNION ）</li>
<li>排序运算（ ORDER BY，OFFSET…FETCH）</li>
<li>集合运算（ set operation）：</li>
</ul>
<p>集合运算主要操作在于集合上，事实上指的就是对表的一种操作。从概念上来说，他们很好理解：</p>
<ul>
<li>DISTINCT 在映射之后对数据进行去重</li>
<li>UNION 将两个子查询拼接起来并去重</li>
<li>UNION ALL 将两个子查询拼接起来但不去重</li>
<li>EXCEPT 将第二个字查询中的结果从第一个子查询中去掉</li>
<li>INTERSECT 保留两个子查询中都有的结果并去重</li>
</ul>
<p>排序运算（ ordering operation）：</p>
<p>排序运算跟逻辑关系无关。这是一个 SQL 特有的功能。排序运算不仅在 SQL 语句的最后，而且在 SQL 语句运行的过程中也是最后执行的。使用 ORDER BY 和 OFFSET…FETCH 是保证数据能够按照顺序排列的最有效的方式。其他所有的排序方式都有一定随机性，尽管它们得到的排序结果是可重现的。</p>
<p>OFFSET…SET是一个没有统一确定语法的语句，不同的数据库有不同的表达方式，如 MySQL 和 PostgreSQL 的 LIMIT…OFFSET、SQL Server 和 Sybase 的 TOP…START AT 等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里记录一下对于 SQL 基本操作的理解和优化。</p>]]>
    
    </summary>
    
      <category term="SQL" scheme="http://wdxtub.com/tags/SQL/"/>
    
      <category term="数据库" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CUDA 简明指南]]></title>
    <link href="http://wdxtub.com/2016/03/20/cuda-note/"/>
    <id>http://wdxtub.com/2016/03/20/cuda-note/</id>
    <published>2016-03-20T12:05:36.000Z</published>
    <updated>2016-03-20T12:07:36.000Z</updated>
    <content type="html"><![CDATA[<p>For CMU 18-645 How to write fast code. Learn CUDA in an hour!</p>
<a id="more"></a>
<hr>
<h2 id="CUDA_u67B6_u6784"><a href="#CUDA_u67B6_u6784" class="headerlink" title="CUDA架构"></a>CUDA架构</h2><p>在 CUDA 的架构下,一个程序分为两个部份:host 端和 device 端。Host 端是指在 CPU 上执行 的部份,而 device 端则是在显示芯片上执行的部份。Device 端的程序又称为 “kernel(核心)”。 通常 host 端程序会将数据准备好后,复制到显卡的内存中,再由显示芯片执行 device 端程序,完 成后再由 host 端程序将结果从显卡的内存中取回。</p>
<p>在 CUDA 架构下,显示芯片执行时的最小单位是 thread(线程)。数个 thread 可以组成一个 block(块)。一个 block 中的 thread 能存取同一块共享的内存,而且可以快速进行同步的动作。</p>
<p>每一个 block 所能包含的 thread 数目是有限的。不过,执行相同程序的 block,可以组成 grid(格子)。不同 block 中的 thread 无法存取同一个共享的内存,因此无法直接互通或进行同步。因此, 不同 block 中的 thread 能合作的程度是比较低的。不过,利用这个模式,可以让程序不用担心显示芯片实际上能同时执行的 thread 数目限制。例如,一个具有很少量执行单元的显示芯片,可能会 把各个 block 中的 thread 顺序执行,而非同时执行。不同的 grid 则可以执行不同的程序(即 kernel)。</p>
<p>每个 thread 都有自己的一份 register 和 local memory 的空间。同一个 block 中的每个 thread 则有共享的一份 share memory。此外,所有的 thread(包括不同 block 的 thread)都共享一份 global memory、constant memory、和 texture memory。不同的 grid 则有各自的 global memory、 constant memory 和 texture memory。</p>
<h2 id="u6267_u884C_u6A21_u5F0F"><a href="#u6267_u884C_u6A21_u5F0F" class="headerlink" title="执行模式"></a>执行模式</h2><p>由于显示芯片大量并行计算的特性,它处理一些问题的方式,和一般 CPU 是不同的。主要的特点包括:</p>
<ol>
<li>内存存取 latency 的问题:CPU 通常使用 cache 来减少存取主内存的次数,以避免内存 latency 影响到执行效率。显示芯片则多半没有 cache(或很小),而利用并行化执行的方式来隐藏内存的 latency(即,当第一个 thread 需要等待内存读取结果时,则开始执行第二 个 thread,依此类推)。</li>
<li>分支指令的问题:CPU 通常利用分支预测等方式来减少分支指令造成的 pipeline bubble。显示芯片则多半使用类似处理内存 latency 的方式。不过,通常显示芯片处理分支的效率会比较差</li>
</ol>
<p>最适合利用 CUDA 处理的问题,是可以大量并行化的问题,才能有效隐藏内存的 latency, 并有效利用显示芯片上的大量执行单元。使用 CUDA 时,同时有上千个 thread 在执行是很正常的。 因此,如果不能大量并行化的问题,使用 CUDA 就没办法达到最好的效率了。</p>
<h2 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>streaming processor, sp: 最基本的处理单元，最后具体的指令和任务都是在 sp 上处理的。GPU 进行并行计算，也就是很多个 sp 同时做处理</li>
<li>streaming multiprocessor, sm: 多个 sp 加上存储资源组成一个 sm</li>
<li>warp: GPU 执行程序时的调度单位，目前 CUDA 的 warp 大小为32，同在一个 warp 的线程，以不同数据资源执行相同的指令。</li>
<li>thread, block, grid: 利用 CUDA 进行编程时，一个 grid 分为多个 block，一个 block 分为多个 thread (From a programmer’s perspective)</li>
</ul>
<h3 id="Some_Restrictions_First"><a href="#Some_Restrictions_First" class="headerlink" title="Some Restrictions First"></a>Some Restrictions First</h3><ul>
<li>All threads in a grid execute the same kernel function</li>
<li>A grid is organized as a 2D array of blocks(gridDim.X and gridDim.y)</li>
<li>Each block is organized as 3D array of threads(blockDim.x, blockDim.y, and blockDim.z)</li>
<li>Once a kernel is launched, its dimensions cannot change.</li>
<li>All blocks in a grid have the same dimension</li>
<li>The total size of a block is limited to 512 threads(? I’m not sure?)</li>
<li>Once assigned to an SM, the block must execute in its entirey by the SM.</li>
<li>Thread ID is unique within a block</li>
<li>Using block ID and thread ID we can make unique ID for each thread per kernel</li>
<li>Threads assigned to execution resources on a block-by-block basis</li>
<li>CUDA runtime automatically reduces number of blocks assigned to each SM</li>
<li>until resource usage is under limit.</li>
</ul>
<h3 id="SM_-Streaming_multi-processors_with_multiple_processing_cores"><a href="#SM_-Streaming_multi-processors_with_multiple_processing_cores" class="headerlink" title="SM -Streaming multi-processors with multiple processing cores"></a>SM -Streaming multi-processors with multiple processing cores</h3><ul>
<li>Each SM contains 32 processing cores</li>
<li>Execute in a Single Instruction Multiple Thread (SIMT) fashion</li>
<li>Up to 16 SMs on a card cor a maximum of 512 compute cores</li>
</ul>
<h3 id="Warps"><a href="#Warps" class="headerlink" title="Warps"></a>Warps</h3><ul>
<li>Once a block is assigned to an SM, it is divided into units called warps.</li>
<li>Thread IDs within a warp are consecutive and increasing</li>
<li>Warp 0 starts with Thread ID 0</li>
<li>Warp is unit of thread scheduling in SMs</li>
<li>Partitioning is always the same</li>
<li>DO NOT rely on any ordering between warps</li>
<li>Each warp is executed in a SIMD fashion (all threads within a warp must execute the same instruction at any given time)</li>
<li>Problem: branch divergence</li>
</ul>
<h3 id="Latency_Tolerance"><a href="#Latency_Tolerance" class="headerlink" title="Latency Tolerance"></a>Latency Tolerance</h3><ul>
<li>When an instruction executed by the threads in a warp must wait for the result of a previously initiated long-latency operation, the warp is not selected for execution -&gt; lantency hiding</li>
<li>Priority mechanism used to schedule ready warps</li>
<li>Scheduling does not introduce idle time -&gt; zero-overhead thread scheduling</li>
<li>Scheduling is used for tolerating long-latency operations, such as:</li>
<li>piplined floating-point arithmetic</li>
<li>branch instructions</li>
</ul>
<p>The only safe way to synchronize threads in different blocks is to terminate the kernel and start a new kernel for the acitivities after the synchronization point.</p>
<h2 id="u4EE3_u7801_u76F8_u5173"><a href="#u4EE3_u7801_u76F8_u5173" class="headerlink" title="代码相关"></a>代码相关</h2><ul>
<li>通过 cudaGetDeviceProperties 函数可以取得许多数据，除了装置支持的 CUDA 版本之外, 还有装置的名称、内存的大小、最大的 thread 数目、执行单元的频率等等</li>
<li>需要包含头文件<code>&lt;cuda_runtime.h&gt;</code></li>
<li>编译直接可以<code>nvcc xxx.cu</code></li>
<li>nvcc 是 CUDA 的 compile 工具,它会将 .cu 檔拆解出在 GPU 上执行的部份,及在 host 上执 行的部份,并呼叫适当的程序进行 compile 动作。在 GPU 执行的部份会透过 NVIDIA 提供的 compiler 编译成中介码,而 host 执行的部份则会透过系统上的 C++ compiler 编译(在 Windows 上使用 Visual C++ 而在 Linux 上使用 gcc)</li>
<li>cudaMalloc 和 cudaMemcpy 的用法和一般的 malloc 及 memcpy 类似,不过 cudaMemcpy 则多出一个参数,指示复制内存的方向。从主内存复制到显卡内存,所以使用 cudaMemcpyHostToDevice。如果是从显卡内存到主内存,则使用 cudaMemcpyDeviceToHost。</li>
<li>在 CUDA 中，在函数前面加上 <code>__global__</code> 表示这个函数是要在显示芯片上执行的。</li>
<li>在显卡上执行的程序有一些限制，例如它不能有返回值</li>
<li>让 CUDA 执行函数的语法<ul>
<li><code>function&lt;&lt;&lt;# block, # thread, shared memory size&gt;&gt;&gt;(para....)</code></li>
</ul>
</li>
<li>在 CUDA 中,一般的数据复制到的显卡内存的部份,称为 global memory。这些内存是没有 cache 的,而且,存取 global memory 所需要的时间(即 latency)是非常长的,通常是数百个 cycles。由于我们的程序只有一 个 thread,所以每次它读取 global memory 的内容,就要等到实际读取到数据、累加到 sum 之后, 才能进行下一步。</li>
<li>由于 global memory 并没有 cache,所以要避开巨大的 latency 的方法,就是要利用大量的 threads。假设现在有大量的 threads 在同时执行,那么当一个 thread 读取内存,开始等待结果的 时候,GPU 就可以立刻切换到下一个 thread,并读取下一个内存位置。因此,理想上当 thread 的 数目够多的时候,就可以完全把 global memory 的巨大 latency 隐藏起来了。</li>
<li>显卡上的内存是 DRAM,因此最有效率的存取方式,是以连续的方式存取。前面的程序,虽然看起 来是连续存取内存位置(每个 thread 对一块连续的数字计算平方和),但是我们要考虑到实际上 thread 的执行方式。前面提过,当一个 thread 在等待内存的数据时,GPU 会切换到下一个 thread。 也就是说,实际上执行的顺序是类似 thread0 -&gt; thread1 -&gt; thread2。因此,在同一个 thread 中连续存取内存,在实际执行时反而不是连续了。要让实际执行结果是连续 的存取,我们应该要让 thread 0 读取第一个数字,thread 1 读取第二个数字…依此类推。</li>
<li>在 CUDA 中,thread 是可以分组的,也就是 block。一个 block 中的 thread,具有一个共享的 shared memory,也可以进行同步工作。不同 block 之间的 thread 则不行。在我们的程序中,其 实不太需要进行 thread 的同步动作,因此我们可以使用多个 block 来进一步增加 thread 的数目</li>
<li>利用 <code>__shared__</code> 声明的变量表示这是 shared memory,是一个 block 中每个 thread 都共享的 内存。它会使用在 GPU 上的内存,所以存取的速度相当快,不需要担心 latency 的问题。</li>
<li>`__syncthreads()`` 是一个 CUDA 的内部函数,表示 block 中所有的 thread 都要同步到这个点,才能继续执行。</li>
</ul>
<h2 id="u7ECF_u9A8C_u6280_u5DE7"><a href="#u7ECF_u9A8C_u6280_u5DE7" class="headerlink" title="经验技巧"></a>经验技巧</h2><ul>
<li>利用 <code>threadIdx.x</code> 来分 thread 执行，考虑好邻接性。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>For CMU 18-645 How to write fast code. Learn CUDA in an hour!</p>]]>
    
    </summary>
    
      <category term="CUDA" scheme="http://wdxtub.com/tags/CUDA/"/>
    
      <category term="教程" scheme="http://wdxtub.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 学习笔记]]></title>
    <link href="http://wdxtub.com/2016/03/20/java-note/"/>
    <id>http://wdxtub.com/2016/03/20/java-note/</id>
    <published>2016-03-20T12:00:19.000Z</published>
    <updated>2016-03-20T12:55:05.000Z</updated>
    <content type="html"><![CDATA[<p>这里是我学习 Java 黄皮书时记录整理的笔记，时间比较久远，不保证时效性。</p>
<a id="more"></a>
<hr>
<h2 id="Java_u7A0B_u5E8F_u8BBE_u8BA1_u6982_u8FF0"><a href="#Java_u7A0B_u5E8F_u8BBE_u8BA1_u6982_u8FF0" class="headerlink" title="Java程序设计概述"></a>Java程序设计概述</h2><p>简要地介绍一下Java语言的发展历史。</p>
<p>Java并不只是一种语言，Java是一个完整的平台，有一个庞大的库，其中包含了很多可重用的代码和一个提供诸如安全性、跨操作系统的可一直性以及自动垃圾收集等服务的执行环境。</p>
<p>感兴趣的话可以参见<a href="http://java.sun.com/docs/white/langenv/" target="_blank" rel="external">这里</a></p>
<p><strong>简单性</strong></p>
<p>人们希望构建一个无需社脑的专业训练就可以进行编程的系统，并且要符合当今的标准惯例。Java提出了C++中许多很少使用、难以理解、易混淆的特性。在目前看来，这些特性带来的麻烦远远多于其带来的好处。</p>
<p><code>Java语法是C++语法的一个纯净”版本</code>。没有头文件、指针运算、结构、联合、操作符重载、虚基类等等。</p>
<p>简单的另一个方面是小。Java的目标之一是支持开发能够在小型机器上独立运行的软件。</p>
<p><strong>面向对象</strong></p>
<p>面向对象设计是一种程序设计技术。它将重点放在数据(即对象)和对象的接口上。具体来说，就是关注的是要做出什么，而不是用什么做出来。在本质上，Java的面向对象能力与C++是一样的。</p>
<p>Java与C++的主要不同点在于<code>多继承</code>，在Java中，取而代之的是简单的接口概念，以及Java的<code>元类(metaclass)</code>模型。</p>
<p><strong>网络技能</strong></p>
<p>Java又一个拓展的例程库，用于处理像HTTP和FTP这类的TCP/IP协议。Java应用程序能够通过URL打开和访问网络上的对象，其边界程度就好像访问本地文件一样。</p>
<p><strong>健壮性</strong></p>
<p>Java的设计目标之一在于使得Java编写的程序具有多方面的可靠性。Java和C++的最大不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能性。</p>
<p>Java编译器能够检测许多在其他语言中仅在运行时刻才能够检测出来的问题。</p>
<p><strong>安全性</strong></p>
<p>一开始Java就设计成能够防范各种袭击，其中包括</p>
<ol>
<li>运行时堆栈溢出。如，蠕虫等病毒常用的袭击手段。</li>
<li>在子集的处理空间之外破坏内存</li>
<li>未经授权读写文件。</li>
</ol>
<p><strong>体系结构中立</strong></p>
<p>编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码，只要有Java运行时系统，就可以在许多处理器上运行。Java编译器通过生成与特定的计算机体系结构无关的字节码指令来实现这一特性。精心设计的字节码不仅可以很容易地在任何机器上解释执行，而且还可以迅速地翻译成本地机器的代码。</p>
<p>解释字节码肯定会比全速地运行机器指令慢很多，但是虚拟机有一个选项，可以将使用最贫乏的字节码序列翻译成机器码，这一过程被称为即时编译。这一策略已经证明十分有效。</p>
<p><strong>可移植性</strong></p>
<p>与C和C++不同，Java规范中没有依赖具体实现”的地方，数据类型具有固定的大小，这消除了代码移植时令人头痛的主要问题。</p>
<p><strong>解释型</strong></p>
<p>Java解释器可已在任何移植了解释器的机器上执行Java字节码。由于链接是一个增值而简便的过程，所以开发过程也变得更加快捷</p>
<p><strong>高性能</strong></p>
<p>尽管对解释后的字节码性能已经比较满意，但在有些场合下却需要更加高效的性能。字节码可以(在运行时刻)快速地翻译成运行这个应用程序的特定CPU的机器码。</p>
<p><strong>多线程</strong></p>
<p>多线程可以带来更好的交互响应和实时行为。在不同的机器上，只是调用多线程的代码完全相同；Java把多线程的实现交给了底层的操作系统或线程库来完成。多线程编译的简单性是Java称为颇具魅力的服务器端开发语言的主要原因之一。</p>
<p><strong>动态性</strong></p>
<p>Java与C或C++相比更加具有动态性。它能够适应不断发展的环境。库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。在Java中找出运行时类型信息十分简单。</p>
<p><strong>Java Applet与Internet</strong></p>
<p>这里的想法很简单：用户从Internet下载Java字节码，并在子集的机器上运行。在网页中运行Java程序称为applet。为了使用applet，需要启用Java的Web浏览器执行字节码。由于Sun公司负责发放Java源代码的许可证，并坚持不允许对语言和基本类库的结构做出任何修改，因此，Java的applet应该可以运星在任何启用Java的浏览器上，并且无论何时访问包含applet的网页，都会得到程序的最终版本。</p>
<p>现在，当需要在浏览器中显示动态效果时，大多数网页都直接使用JavaScript或Flash。</p>
<h3 id="Java_u53D1_u5C55_u7B80_u53F2"><a href="#Java_u53D1_u5C55_u7B80_u53F2" class="headerlink" title="Java发展简史"></a>Java发展简史</h3><ul>
<li>1991年，由Patrick Naughton及其伙伴James Gosling带领的Sun公司的工程师小组想要设计一种小型的计算机语言，主要用于像有限电视转换盒这种设备。这种语言的关键是不能与任何特定的体系结构捆绑在一起，这个项目被命名为Green”。</li>
<li>代码短小、紧凑且与平台无关，这些要求促使开发团队联想起很早以前的一种模型，某些Pascal的实现曾经在早期的PC上尝试过这种模型。</li>
<li>不过，Sun公司的人都具有UNIX的应用背景。因此，所开发的语言以C++为基础，而不是Pascal。Gosling把这种语言称为Oak”。Sun公司的人后来发现Oak是一种已有的计算机语言的名字，于是将其改名为Java。</li>
<li>1992年，Green项目发布了它的第一个产品，称之为 <code>*7</code>，具有非常智能的远程控制，但是Sun公司对生产这个产品没有兴趣。</li>
<li>Green项目(这时换了一个新名字──Fist Person”公司)整个1993年和1994年上半年都在苦苦寻求其技术的买家。但是，一个也没有。1994年First Person公司解散了。</li>
<li>1994年中期，Java语言的开发者意识到它们能够建立一个最酷的浏览器。在1995年5月23日的SunWorld展示后，引发了人们延续至今的对Java的狂热追逐。</li>
<li>1996年初，Sun发布了Java的第1个版本。Java1.1弥补了其中的大多部分明显的缺陷。</li>
<li>1998年，Sun发布了Java1.2，后改名为Java2标准版软件开发工具箱1.2版”。</li>
<li>除了标准版之外，还有两个其他的版本，一个是用于手机等嵌入式设备的微型版”，另一个是用于服务器端处理的企业版”。</li>
<li>标准版的1.3和1.4版本对最初的Java 2版本做出了某些改进，拓展了标准类库，提高系统性能。</li>
<li>5.0版是自1.1版依赖第一个对Java语言做出重大改进的版本。</li>
<li>版本6(没有后缀.0)与2006年末发布。这个版本没有对语言方面再进行改进，而是改进了其他性能，并增强了类库。</li>
</ul>
<h3 id="u5173_u4E8EJava_u7684_u5E38_u89C1_u8BEF_u89E3"><a href="#u5173_u4E8EJava_u7684_u5E38_u89C1_u8BEF_u89E3" class="headerlink" title="关于Java的常见误解"></a>关于Java的常见误解</h3><blockquote>
<p>Java是HTML的拓展。</p>
</blockquote>
<p>Java是一种程序设计语言；HTML是一种描述网页结构的方式。</p>
<blockquote>
<p>使用XML，就不需要Java。</p>
</blockquote>
<p>Java是一种程序设计语言；XML是一种描述数据的方式。可以使用任何一种程序设计语言处理XML数据。</p>
<blockquote>
<p>Java是一种非常容易学习的程序设计语言。</p>
</blockquote>
<p>像Java这种功能强大的语言大都不太容易学习。</p>
<blockquote>
<p>Java将成为适用于所有平台的通用性编程语言。</p>
</blockquote>
<p>很多在桌面计算机上已经工作良好的应用程序，通常是用C或C++编写的，用Java重写一次似乎对于用户来说没有什么特别的好处。</p>
<blockquote>
<p>Java只不过是另外一种程序设计语言。</p>
</blockquote>
<p>程序设计语言的成功更多地取决于其支撑系统的能力，而不是优美的语法。Java的成功源于其类库能够让人们轻松地完成原本有一定难度的事情</p>
<blockquote>
<p>现在有了C#，Java过时了。</p>
</blockquote>
<p>C#借鉴了Java许多好的思想，例如：清晰的语言结构、虚拟机和垃圾收集器。最重要的是安全性和平台无关性。但是从求职广告判定，Java仍然是大多数开发者选择的语言。</p>
<blockquote>
<p>Java有专利，应该避免使用。</p>
</blockquote>
<p>Sun声称Java未来的版本将在General Public License下可用。Linux使用的是同一个开放源代码许可。开放源代码会使Java的生存期延长很多年。</p>
<blockquote>
<p>Java是解释型的，因此对于关键的应用程序速度太慢了。</p>
</blockquote>
<p>Java所写的代码某些程度上其运行速度与C++相差无几。Java有一些C++没有的额外开销。但是，硬件的发展很快的。</p>
<blockquote>
<p>所有的Java程序都是在网页中运行的。</p>
</blockquote>
<p>所有的Java applet都在网页浏览器中运行的。然而，大多数Java程序是运行在Web浏览器之外的独立应用程序。</p>
<blockquote>
<p>Java程序是主要的安全风险。</p>
</blockquote>
<p>相当可笑，不解释。</p>
<blockquote>
<p>JavaScript是Java的简易版。</p>
</blockquote>
<p>JavaScript是一种在网页中使用的脚本语言。JavaScript的语言类似Java，除此之外，两者无任何关系。额，名字有点像。更多可查阅<a href="http://www.apl.jhu.edu/~hall/java/FAQs-and-Tutorials.html" target="_blank" rel="external">Java FAQ(Java Frequently Question)</a></p>
<h2 id="Java_u57FA_u672C_u7684_u7A0B_u5E8F_u8BBE_u8BA1_u7ED3_u6784"><a href="#Java_u57FA_u672C_u7684_u7A0B_u5E8F_u8BBE_u8BA1_u7ED3_u6784" class="headerlink" title="Java基本的程序设计结构"></a>Java基本的程序设计结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstSample</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(Hello! I’m wdxtub”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是一个最简单的Java应用程序，但是所有的Java应用程序都具有这种结构。</p>
<p>Java对<code>大小写敏感</code>。关键字<code>public</code>称为<code>访问修饰符(access modifier)</code>，用于控制程序的其他部分对这段代码的访问级别。</p>
<p><code>类</code>是构建所有Java应用程序和applet的构建块。Java应用程序中的全部内容都必须放置在类中。关键字class后面紧跟类名。Java中定义类名的规则很宽松。名字必须以<code>字母开头</code>，后面可以跟字母和数字的任意组合。长度基本上没有限制。但是不能使用Java的保留字。</p>
<p>源代码的文件名必须与公有类的名字相同，并用<code>.java</code>作为扩展名。</p>
<p>运行编译程序时，Java 虚拟机将从指定类中的<code>main</code>方法开始执行，并且<code>main</code>方法必须声明为<code>public</code>。</p>
<p>注释有三种方法：</p>
<ol>
<li><code>//</code> 单行的注释，内容从 <code>//</code> 开始到本行结尾</li>
<li><code>/*...*/</code> 长篇的注释</li>
<li><code>/**...*/</code> 用于自动生成文档</li>
</ol>
<p>Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。Java中一共有8种基本类型(primitive type)。其中4种整型，2种浮点类型，1种char型，1种boolean类型。</p>
<p>整型表示没有小数部分的数值，可以是复数。分别为<code>int(4字节)</code>，<code>short(2字节)</code>，<code>long(8字节)</code>，<code>byte(1字节)</code>。由于Java程序必须保证在所有机器都能得到相同的运行结果，所以每一种数据类型的取值范围必须固定。</p>
<p>浮点类型用于表示有小数部分的数值。分别是<code>float(4字节，有效位数6～7位)</code>，<code>double(8字节，有效位数15位)</code>。</p>
<p><code>double</code>表示这种类型的数值精度是<code>float</code>的两倍。绝大部分程序都采用<code>double</code>类型。<code>float</code>类型的数值有一个后缀F，没有<code>后缀F</code>的浮点数值默认为<code>double</code>类型。</p>
<p>三个特殊的浮点数值：</p>
<ul>
<li>正无穷大</li>
<li>负无穷大</li>
<li>NaN(不是一个数字，Not a Number)</li>
</ul>
<p><code>char</code>类型用于表示单个字符。通常用来表示字符常量。</p>
<p><strong>我们强烈建议不要在程序中使用char类型，除非确实需要对UTF-16代码单元进行操作。最好将需要处理的字符串用抽象数据类型表示。</strong></p>
<p><code>boolean(布尔)</code>类型有两个值：<code>false</code>和<code>true</code>，用来判定逻辑条件。整型和布尔值之间不能进行相互转换。</p>
<p>每一个变量属于一种类型(type)。声明变量时，变量所属的类型位于变量名之前，每个声明以分号结束。</p>
<p>可以在一行中声明多个变量，不过不提倡使用这种风格。逐一声明每一个变量可以提高程序的可读性。</p>
<p>声明一个变量之后，必须用赋值语句对变量进行显式的初始化，千万不要使用未被初始化的变量。可以将声明放在代码中的任何地方，变量的声明应尽可能地靠近变量第一次使用的地方。</p>
<p>利用关键字final声明常量，表示这个变量只能被赋值一次。一旦被赋值后就不能再更改了。习惯上，常量名使用大写。</p>
<p>若希望某个常量可以在一个类中的多个方法中使用，通常将这些常量称为类常量，使用static final设置。</p>
<p>类常量的定义位于main方法的外部，所以在同一个类的其他方法中也可以使用这个常量。</p>
<h3 id="u8FD0_u7B97_u7B26"><a href="#u8FD0_u7B97_u7B26" class="headerlink" title="运算符"></a>运算符</h3><p>Java程序设计语言承认了最优性能与理想结果之间存在的冲突，并给予了改进。在默认情况下，虚拟机设计者允许中间结果采用拓展的精度。但对于strictfp关键字标记的方法必须使用严格的浮点计算来产生理想的结果。</p>
<p>自增运算符与自减运算符 前缀方式<code>先进行加一或减一</code>的运算，后缀方式则使用变量原来的值。建议不要在其他表达式的内部使用++，使人迷惑，产生bug。</p>
<p>关系运算符与boolean运算符，其中<code>==</code>，<code>!=</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code>，<code>||</code>，<code>&amp;&amp;</code>均与C++一致。</p>
<p>位运算符</p>
<ul>
<li><code>&amp;</code>(与)，<code>|</code>(或)，<code>^</code>(异或)，<code>-</code>(非)</li>
<li><code>&gt;&gt;</code>和<code>&lt;&lt;</code>运算符进行右移或左移操作，屏蔽某些位。</li>
<li><code>&gt;&gt;&gt;</code>运算符用0填充高位；<code>&gt;&gt;</code>运算符用符号填充高位，没有<code>&lt;&lt;&lt;</code>运算符。</li>
</ul>
<p>在Math类中，包含各种的数学函数。若得到一个完全可预测的结果比运行速度更重要的话，就应该使用StrictMath类。</p>
<p>整型转换为float或double型很有可能损失精度。</p>
<p>在圆括号中给出想要转换的目标类型，后面紧跟待转换的变量名，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">9.998</span>;</span><br><span class="line"><span class="keyword">int</span> nx = (<span class="keyword">int</span>)x;</span><br></pre></td></tr></table></figure>
<p>若想进行四舍五入计算，使用 <code>Math.round</code> 方法。</p>
<p>括号与运算符级别与正常情况下一致。少数结合性是从右向左的。</p>
<p>枚举类型包括有限个命名的值。</p>
<p>如 <code>enum Size{SMALL,MEDIUM,LARGE,EXTRA_LARGE}</code>。</p>
<p>Java字符串就是Unicode字符序列。</p>
<p>String类的substring方法可以从一个较大的字符串提取一个子串，容易计算子串长度，语句：<code>s.substring(a,b)</code>，长度即为<code>b-a</code>。</p>
<p>允许使用<code>+</code>号连接(拼接)两个字符串。</p>
<p><code>String</code>类没有提供用于修改字符串的方法，所以在Java文档中将String类对象称为<code>不可变字符串</code>。</p>
<p>不可变字符又一个优点：编译器可以让<code>字符串共享</code>。Java的设计者认为共享带来的高效率远远胜过于提取。</p>
<p>使用<code>equals</code>方法检测两个字符串是否相等。<code>s.equals(t)</code>，若 <code>s</code> 与 <code>t</code> 相等，则返回<code>true</code>，否则返回<code>false</code>。<code>s</code> 和 <code>t</code> 可以是字符串变量也可以是字符串常量，如<code>”Hello”.equals(greeting)</code>。</p>
<p>如果向不区分大小写，使用<code>equalsIgnoreCase</code>方法。一定不能使用 <code>==</code> 运算符检测两个字符串是否相等！这个运算符只能够确定两个字符是否放置在同一个位置上。</p>
<p>大多数的常用Unicode字符使用一个代码单元就可以表示，而辅助字符则需要一对代码来表示。</p>
<p><code>s.charAt(n)</code>将返回位置 <code>n</code> 的代码单元，<code>n</code>介于<code>0～s.length()-1</code>之间。对于那些一对代码单元表示的字符，就会出现问题。而<code>codePointAt</code>可以解决这个问题。</p>
<p>Java中的String类包含了50多个方法并且绝大多数都很有用。</p>
<p><strong>java.lang.string</strong></p>
<ul>
<li><code>char charAt( int index )</code><ul>
<li>返回给定位置的代码单元。除非对底层的代码单元感兴趣，否则不需要调用这个方法。</li>
</ul>
</li>
<li><code>int codePointAt( int index )</code><ul>
<li>返回从给定位置开始或结束的代码点。</li>
</ul>
</li>
<li><code>int offsetByCodePoints( int startIndex, int cpCount )</code><ul>
<li>返回从 startIndex 代码点开始，位移 cpCount 后的代码点索引。</li>
</ul>
</li>
<li><code>int compareTo( String other )</code><ul>
<li>按照字典顺序，如果字符串位于other之前，返回一个负数；位于other之后，返回一个正数；如果两个字符串相等，返回0。</li>
</ul>
</li>
<li><code>boolean endsWith( String suffix )</code><ul>
<li>如果字符串以suffix结尾，返回true。</li>
</ul>
</li>
<li><code>boolean equals( Object other )</code><ul>
<li>如果字符串以other相等，返回true。</li>
</ul>
</li>
<li><code>boolean equalsIgnoreCase( String other )</code><ul>
<li>如果字符串与other相等(忽略大小写)，返回true。</li>
</ul>
</li>
<li><code>int indexOf( String str )</code></li>
<li><code>int indexOf( String, int fromIndex )</code></li>
<li><code>int indexOf( int cp )</code></li>
<li><code>int indexOf( int cp, int fromIndex )</code><ul>
<li>返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromIndex开始计算。如果在原始串中不存在str，返回-1。</li>
</ul>
</li>
<li><code>int lastIndexOf( String str )</code></li>
<li><code>int lastIndexOf( String str, int  fromIndex )</code></li>
<li><code>int lastIndexOf( int cp )</code></li>
<li><code>int lastIndexOf( int cp, int fromIndex )</code><ul>
<li>返回与字符串str或代码点cp匹配的最后一个子串的开始位置。这个位置从原始串尾端或fromIndex开始计算。</li>
</ul>
</li>
<li><code>int length()</code><ul>
<li>返回字符串的长度。</li>
</ul>
</li>
<li><code>int codePointCount( int startIndex, int endIndex)</code><ul>
<li>返回startIndex和endIndex-1之间的代码点数量。没有配成对的代用字符将计入代码点。</li>
</ul>
</li>
<li><code>String replace(CharSequence oldString, CharSequence newString)</code><ul>
<li>返回一个新字符串。这个字符串用newString代替原始字符串中的所有oldString。可以用String或StringBuilder对象作为CharSequence参数。</li>
</ul>
</li>
<li><code>boolean startsWith( String prefix )</code><ul>
<li>如果字符串以prefix字符串开始，返回true。</li>
</ul>
</li>
<li><code>String substring( int beginIndex )</code></li>
<li><code>String substring( int beginIndex, int  endIndex )</code><ul>
<li>返回一个新字符串。这个字符串包含原始字符串中从beginIndex到串尾或endIndex-1的所有代码点。</li>
</ul>
</li>
<li><code>String toLowerCase()</code><ul>
<li>返回一个新字符串，这个字符串将原始字符串中的所有大写字母改成了小写字母。</li>
</ul>
</li>
<li><code>String toUpperCase()</code><ul>
<li>返回一个新字符串，这个字符串将原始字符串中的所有小写字母改成了大写字母。</li>
</ul>
</li>
<li><code>String trim()</code><ul>
<li>返回一个新字符串。这个字符串将山除了原始字符串头部和尾部的空格。</li>
</ul>
</li>
</ul>
<p>如果需要用许多小段的字符串构建一个字符串，那么应该按照下列步骤进行。首先，构建一个空的字符串构建器：</p>
<p><code>StringBuilder builder = new StringBuilder();</code></p>
<p>当每次需要添加一部分内容时，就调用append方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">builder.append(ch); <span class="comment">// appends a single character</span></span><br><span class="line">builder.append(str);    <span class="comment">// appends a string</span></span><br></pre></td></tr></table></figure>
<p><strong>java.lang.StringBuilder</strong></p>
<ul>
<li><code>StringBuilder()</code><ul>
<li>构造一个空的字符串构建器。</li>
</ul>
</li>
<li><code>int length()</code><ul>
<li>返回构建器或缓冲器中的代码单元数量。</li>
</ul>
</li>
<li><code>StringBuilder append( String str )</code><ul>
<li>追加一个字符串并返回this。</li>
</ul>
</li>
<li><code>StringBuilder append( char c )</code><ul>
<li>追加一个代码单元并返回this。</li>
</ul>
</li>
<li><code>StringBuilder appendCodePoint( int cp )</code><ul>
<li>追加一个代码点，并将其转换为一个或两个代码单元并返回this。</li>
</ul>
</li>
<li><code>void setCharAt( int i,char c )</code><ul>
<li>将第 i 个代码单元设置为 c。</li>
</ul>
</li>
<li><code>StringBuilder insert( int offset,String str )</code><ul>
<li>在offset位置插入一个字符串并返回this。</li>
</ul>
</li>
<li><code>StringBuilder insert( int offset,Char c )</code><ul>
<li>在offset位置插入一个代码单元并返回this。</li>
</ul>
</li>
<li><code>StringBuilder delete( int startIndex,int endIndex )</code><ul>
<li>删除偏移量从startIndex到-endIndex-1的代码单元并返回this。</li>
</ul>
</li>
<li><code>String toString()</code><ul>
<li>返回一个与构建器或缓冲器内容相同的字符串。</li>
</ul>
</li>
</ul>
<h3 id="u8F93_u5165_u8F93_u51FA"><a href="#u8F93_u5165_u8F93_u51FA" class="headerlink" title="输入输出"></a>输入输出</h3><p>要想通过控制台进行输入，首先需要构造一个<code>Scanner</code>对象，并与标准输入流”<code>System.in</code>关联。</p>
<pre><code>Scanner in = new Scanner(System.in);
</code></pre><p>现在就可以使用<code>Scanner</code>类的各种方法实现输入操作。例如可以用<code>nextLine</code>方法将输入一行(包括输入行中有空格的情况)，若想读取一个单词(以空格作为分隔符)，就调用next方法；想读取一个整数，就调用<code>nextInt</code>方法；想读取一个浮点数，就调用<code>nextDouble</code>方法。</p>
<pre><code>String name = in.nextLine();
String firstName = in.next();
int age = in.nextInt();
double salary = in.nextDouble();
</code></pre><p>最后在程序最开始加上 <code>import java.util.*;</code></p>
<p>当使用的类不是定义在基本<code>java.lang</code>包中时，一定要使用<code>import</code>指示将相应的包加载进来。</p>
<p><strong>java.util.Scanner</strong></p>
<ul>
<li><code>Scanner( InputStream in)</code><ul>
<li>用给定的输入流创建一个Scanner对象。</li>
</ul>
</li>
<li><code>String nextLine()</code><ul>
<li>读取输入的下一行内容。</li>
</ul>
</li>
<li><code>String next()</code><ul>
<li>读取输入的下一个单词(以空格作为分隔符)</li>
</ul>
</li>
<li><code>int nextInt()</code></li>
<li><code>double nextDouble()</code><ul>
<li>读取并转换下一个表示整数或浮点数的字符序列。</li>
</ul>
</li>
<li><code>boolean hasNext()</code><ul>
<li>检测输入中是否还有其他单词。</li>
</ul>
</li>
<li><code>boolean hasNextInt()</code></li>
<li><code>boolean hasNextDouble()</code><ul>
<li>检测是否还有表示整数或浮点数的下一个字符序列。</li>
</ul>
</li>
<li><code>Scanner( File f )</code><ul>
<li>构造一个从给定文件读取数据的Scanner。</li>
</ul>
</li>
<li><code>Scanner( String data)</code><ul>
<li>构造一个从给定字符串读取数据的Scanner。</li>
</ul>
</li>
</ul>
<p><strong>java.util.System</strong></p>
<ul>
<li><code>static Console console()</code><ul>
<li>如果有可能进行交互操作，就通过控制台窗口为交互的用户返回一个Console对象，否则返回null。</li>
</ul>
</li>
</ul>
<p><strong>java.io.Console</strong></p>
<ul>
<li><code>static char[] readPassword( String prompt, Object...args )</code></li>
<li><code>static String readLine( String prompt, Object...args)</code><ul>
<li>显示字符串prompt并且读取用户输入，直到输入行结束。args参数可以用来提供输入格式。</li>
</ul>
</li>
</ul>
<p>格式化输出沿用了C语言库函数中的printf方法，另外还可以给出控制格式化输出的各种标志</p>
<p>可以采用一个格式化的字符串指出要被格式化的参数索引。紧跟在%后面，并以$终止。还可以选择使用&lt;标志。它指示前面格式说明中的参数将再次使用。</p>
<p>文件输入与输出。要想对文件进行读取，就需要一个用<code>File</code>对象构造一个<code>Scanner</code>对象，例如：<code>Scanner in = new Scanner(new File(myfile.txt”));</code></p>
<p>如果文件名中包含反斜杠符号，就要记住在每个反斜杠之前再价一个额外的反斜杠：<code>c:\\mydirectory\\myfile.txt”</code>。</p>
<p>要想写入文件，就需要构造一个<code>PrintWriter</code>对象。在构造器中，主需要提供文件名：<code>PrintWriter out = new PrintWriter(myfile.txt”);</code></p>
<p>可以向输出到<code>System.out</code>一样使用<code>print</code>、<code>pinrtln</code>以及<code>printf</code>命令。</p>
<p><strong>java.io.PrintWriter</strong></p>
<ul>
<li><code>PrintWriter( File f)</code><ul>
<li>构造一个将数据写入给定文件的PrintWriter。</li>
</ul>
</li>
<li><code>PrintWriter( String fileName )</code><ul>
<li>构造一个将数据写入文件的PrintWriter。文件名由参数指定。</li>
</ul>
</li>
</ul>
<p><strong>java.io.File</strong></p>
<ul>
<li><code>File( String fileName )</code></li>
</ul>
<p>用给定的文件名，构造一个描述文件的File对象。注意这个文件当前不必存在。</p>
<p>有可能出发多个<code>case</code>分支。如果在<code>case</code>分支语句的末尾没有<code>break</code>语句，那么就会接着执行下一个<code>case</code>分支语句。这种情况相当危险，常常会引发错误。为此，尽量不要使用<code>switch</code>语句。</p>
<p>当在<code>switch</code>语句中使用枚举常量时，不必在每个标签中指明枚举名，可以由<code>switch</code>的表达式确定。例如：</p>
<pre><code>Size sz = {SMALL,LARGE,...}
switch (sz){
    case SMALL: // no need to use Size.SMALL
    ...
    break;
}
</code></pre><p>无限制地使用goto语句确实是导致错误的根源，但偶尔地使用goto跳出循环是有益处的，Java中增加了一条带标签的break以支持这种跳出。</p>
<p>请注意，标签必须放在希望跳出的最外层循环之前，必须紧跟一个冒号。如下所示：</p>
<pre><code>int n;
read_data:
while(...){ // this loop statement is tagged with the label
    ...
    for(...){ // this inner loop is not labeled
        if(...) break read_data; // break out of read_data loop
    }
}
// this statement is executed immediately after the labeled break

if(....){.....}
</code></pre><p>即可以直接跳出所标记的循环，继续执行下面的语句。</p>
<p>带标签的continue将跳到与标签匹配的循环首部。</p>
<h3 id="u5927_u6570_u503C"><a href="#u5927_u6570_u503C" class="headerlink" title="大数值"></a>大数值</h3><p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用<code>java.math</code>包中的两个很有用的类：<code>BigInterger</code>(任意精度的整数运算)和<code>BigDecimal</code>(任意精度的浮点数运算)。</p>
<p>使用静态的<code>valueOf</code>方法可以将普通的数值转换为大数值：</p>
<pre><code>BigInterger a = BigInteger.valueOf(100);
</code></pre><p>但是不能使用算数运算符，有专门的运算方法。</p>
<p><strong>java.math.BigInterger</strong></p>
<ul>
<li><code>BigInteger add( BigInteger other )</code></li>
<li><code>BigInteger subtract( BigInteger other)</code></li>
<li><code>BigInteger multiply( BigInteger other)</code></li>
<li><code>BigInteger divide( BigInteger other)</code></li>
<li><code>BigInteger mod( BigInteger other)</code><ul>
<li>返回这个大整数和另一个大整数other的和、差、积、商和余数。</li>
</ul>
</li>
<li><code>int compareTo( BigInteger other )</code><ul>
<li>如果这个大整数和另一个大整数other相等，返回0；如果这个大整数小于另一个大整数，返回负数；大于的话，返回正数。</li>
</ul>
</li>
<li><code>static BigInteger valueOf(long x)</code><ul>
<li>返回值等于x的大整数。</li>
</ul>
</li>
</ul>
<p><strong>java.math.BiDecimal</strong></p>
<ul>
<li><code>BigDecimal add( BigDecimal other )</code></li>
<li><code>BigDecimal subtract( BigDecimal other)</code></li>
<li><code>BigDecimal multiply( BigDecimal other)</code></li>
<li><code>BigDecimal divide( BigDecimal other, RoundingMode mode)</code><ul>
<li>返回这个大实数和另一个大实数other的和、差、积、商和余数。要想计算商，必须给出舍入方式(rounding mode)。RoundingMode.HALF_UP是四舍五入方式，其他的舍入方式参见API文档。</li>
</ul>
</li>
<li><code>int compareTo( BigDecimal other )</code><ul>
<li>如果这个大实数和另一个大实数other相等，返回0；如果这个大实数小于另一个大实数，返回负数；大于的话，返回正数。</li>
</ul>
</li>
<li><code>static BigDecimal valueOf( long x)</code></li>
<li><code>static BigDecimal valueOf( long x, int scale)</code><ul>
<li>返回值等于x或x/10scale的一个大实数。</li>
</ul>
</li>
</ul>
<h3 id="u6570_u7EC4"><a href="#u6570_u7EC4" class="headerlink" title="数组"></a>数组</h3><p>应该使用<code>new</code>运算符创建数组：<code>int[] a = new int[100];</code></p>
<p>要想获得数组中的元素个数，可以使用<code>array.length</code>。</p>
<p>一旦创建了数组，就不能再改变它的大小。如果经常需要在运行过程中拓展数组的大小，就应该使用另一种数据结构─数组列表(array list)。</p>
<p>Java SE 5.0增加了一种功能很强的循环结构，可以用来一次处理数组中的每个元素(其他类型的元素集合亦可)而不必为指定下标值而分心。</p>
<p>语句格式为：<code>for( variable : collection ) statement</code>    例如：</p>
<pre><code>for( int element : a )
    System.out.println( element );
</code></pre><p>就可以打印数组a的每一个元素。</p>
<p>有个更加简单的方式打印数组中的所有值，即利用Arrays类的toString方法。调用<code>Arrays.toString(a)</code>，返回一个包含数组元素的字符串，这些元素被放置在括号内，并用逗号分隔。</p>
<p>提供一种创建数组对象并同时赋予初始值的简化书写形式，如：</p>
<pre><code>int[] smallPrimes = { 2, 3, 5, 6};
</code></pre><p>使用这种语句时就不用调用<code>new</code>。</p>
<p>还可以初始化一个匿名的数组：<code>new int[]{ 11, 12, 14, 15};</code> 这种表示法将创建一个新数组并利用括号中提供的值进行初始化，数组的大小就是初始值的个数。使用这种语法形式可已在不创建新变量的情况下重新初始化一个数组。例如：<code>smallPrimes = new int[]{ 11, 12, 14, 15};</code></p>
<p>允许将一个数组变量拷贝给另一个数组变量。这是，两个变量就引用同一个数组：<code>int[] luckyNumbers = smallPrimes;</code></p>
<p>如果希望将一个数组的所有值拷贝到一个新的数组中，就要使用<code>Arrays</code>类的<code>copyOf</code>方法：<code>int[] copiedLuckyNumbers = Arrays.copyOf( luckyNumbers, luckyNumbers.length );</code></p>
<p>第二个参数是新数组的长度。这个方法通常用来增加数组的大小：<code>luckyNumbers = Arrays.copyOf( luckyNumbers, 2 * luckyNumbers.length);</code></p>
<p>如果数组元素是数值型，那么多余的元素将被赋值为<code>0</code>；如果数组元素是是布尔型，则将赋值为<code>false</code>。如果长度小于原始数组的长度，则只拷贝最前面的数据元素。</p>
<p>在Java SE 6之前，用<code>System</code>类的<code>arraycopy</code>方法将一个数组的元素拷贝到另一个数组中。调用这个方法的格式为：</p>
<pre><code>System.arraycopy( from, fromIndex, to, toIndex, count);
</code></pre><p>数组<code>to</code>必须有足够的空间存放拷贝的元素。意思为，从<code>from</code>数组的下标为<code>fromIndex</code>元素开始，拷贝<code>count</code>个元素到<code>to</code>数组，从<code>to</code>数组的下标为<code>toIndex</code>的元素开始变成被拷贝过来的元素。</p>
<p>可以使用Arrays类中的sort方法对数值型数组进行排序：</p>
<pre><code>int[] a = new int[1000];
...
</code></pre><p><code>Arrays.sort(a);</code> 这个方法使用了优化的快速排序算法，效率是比较高的。</p>
<p><strong>java.util.Arrays</strong></p>
<ul>
<li><code>static String toString( type[] a )</code><ul>
<li>返回包含a中数据元素的字符串，这些数据元素被放在括号内，并用逗号分隔。</li>
</ul>
</li>
<li><code>static type copyOf( type[] a, int length )</code></li>
<li><code>static type copyOf( type[] a, int start, int end )</code><ul>
<li>返回与a类型相同的一个数组，其长度为length或者 end-start，数组元素为a的值。</li>
</ul>
</li>
<li><code>static void sort( type[] a )</code><ul>
<li>采用优化的快速排序算法对数组进行排序。</li>
</ul>
</li>
<li><code>static int binarySearch( type[] a, type v)</code></li>
<li><code>static int binarySearch( type[] a, int start, int end, type v )</code><ul>
<li>采用二分搜索法查找值v。如果查找成功，则返回相应的下标值；否则，返回一个负数值r。-r-1是为保持a有序v应插入的位置。</li>
</ul>
</li>
<li><code>static void fill( type[] a, type v )</code><ul>
<li>将数组的所有数据元素值设置为v。</li>
</ul>
</li>
<li><code>static boolean equals( type[] a, type[] b)</code><ul>
<li>如果两个数组大小相同，并且下标相同的元素都对应相等，返回true。</li>
</ul>
</li>
<li><code>static int hashCode( type[] a )</code><ul>
<li>计算数组a的散列码。可以是int、long、short、char、byte、boolean、float或double的数组。</li>
</ul>
</li>
</ul>
<p><strong>java.lang.System</strong></p>
<ul>
<li><code>static void arraycopy( Object from, int fromIndex, Object to, int toIndex, int count )</code><ul>
<li>将第一个数组中的元素拷贝到第二个数组中。</li>
</ul>
</li>
</ul>
<p>多维数组使用<code>new</code>进行初始化：<code>balances = new double[NSIZE][MSIZE];</code></p>
<p>或者是：<code>int[][] magicSquare = { {16, 3, 2, 13},{5, 10, 11,8} };</code></p>
<p>一旦数组被初始化，就可以利用两个方括号访问每个元素。</p>
<p><code>for each</code>循环语句不能自动处理二维数组的每一个元素。它是按照行，也就是一维数组处理的。要想访问二维数组a的所有元素，需要使用两个嵌套的循环：</p>
<pre><code>for( double[] row: a )
    for( double value : row )
        do something with value
</code></pre><p>想要快速打印一个二维数组的数据元素列表，可以调用：<code>System.out.println( Arrays.deepToString(a));</code></p>
<h2 id="u5BF9_u8C61_u4E0E_u7C7B"><a href="#u5BF9_u8C61_u4E0E_u7C7B" class="headerlink" title="对象与类"></a>对象与类</h2><p>数据被放在第一位，然后再考虑操作数据的算法。</p>
<p><code>类(class)</code>是构造对象的模板或蓝图。由类<code>构造(construct)</code>对象的过程称为创建类的<code>实例(instance)</code>。</p>
<p><code>封装(encapsulation，有时称为数据隐藏)</code>是与对象功能有关的一个重要概念。对象中的数据称为<code>实例域(instance fields)</code>，操纵数据的过程称为<code>方法(method)</code>。对于每个特定的类实例(对象)都有一组特定的实例域值。这些值的集合就是这个对象的当前<code>状态(state)</code>。无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。</p>
<p>封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。</p>
<p>在对于一个已有的类扩展时，这个扩展后的新类具有所拓展的类的全部属性和方法。在新类中，只需要提供哪些仅适用于这个类的新方法和数据域就可以了。</p>
<p>要想使用OOP，一定要清楚对象的三个主要特性：</p>
<ol>
<li>对象的行为(behavior)──可以对对象施加哪些操作，或可以对对象施加哪些方法？</li>
<li>对象的状态(state)──当施加那些方法时，对象如何响应？</li>
<li>对象标识(identity)──如何辨别具有相同行为与状态的不同对象？</li>
</ol>
<p>此外，每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变，但这种改变不会是自发的。</p>
<p>对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份(identity)。需要注意，作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。对象的这些关键特性在彼此之间相互影响着。</p>
<p>识别类的简单规则是在分析问题的过程中寻找名词，而方法对应动词。在创建类的时候，哪些名词和动词是重要的完全取决于个人的开发经验。</p>
<p>在类之间最常见的关系有</p>
<ul>
<li>依赖(uses-a)</li>
<li>聚合(has-a)</li>
<li>继承(is-a)</li>
</ul>
<p><code>依赖(dependence)</code>，是一种最明显的、最常见的关系。如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。应该尽可能将相互依赖的类减至最少，即类之间的耦合度最小。</p>
<p><code>聚合(aggregation)</code>，是一种具体且易于理解的关系。集合意味着类A的对象包含类B的对象。</p>
<p><code>继承(inheritance)</code>，是一种表示特殊与一般的关系。一般而言，如果类A扩展类B，类A不但包含从类B继承的方法，还会拥有一些额外的功能。</p>
<p>要想使用对象，就必须首先构造对象，并指定其初状态。然后，对对象施加方法。在Java程序设计语言中，使用<code>构造器(constructor)</code>构造新实例。</p>
<p>构造器的名字应与类名相同，并且使用<code>new</code>操作符进行构造；也可以将这个对象传递给一个方法；另外<code>Date</code>类中有一个<code>toString</code>方法，返回日期的字符串描述，如下</p>
<pre><code>new Date(); // 被初始化为当前的日期和时间
System.out.println(new Date());
String s = new Date().toString();
</code></pre><p>如果希望构造的对象可以多次使用，就要把对象放在一个变量中：</p>
<pre><code>Date birthday = new Date();
</code></pre><p>可以让一个变量引用一个已存在的变量：<code>Date deadline = birthday;</code>则这两个变量引用同一个对象。</p>
<p>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用。可以显式地将对象变量设置为<code>null</code>，表明这个对象变量目前没有任何引用对象：<code>deadline = null;</code>变量不会自动初始化为<code>null</code>，而必须通过调用<code>new</code>或将它们设置为<code>null</code>进行初始化。</p>
<p>Date类只提供了少量的方法用来比较两个时间点。例如<code>before</code>和<code>after</code>方法分别表示一个时间点是否早于另一个时间点，或者晚于另一个时间点。</p>
<pre><code>if( today.before(birthday) )
    System.out.println(Still time to shop for a gift.”);
</code></pre><p><code>GregorianCalendar</code>类所包含的方法比<code>Date</code>类多得多，并且封装了实例域。</p>
<p>对实例域作出修改的方法被称为<code>更改器方法(mutator method)</code>，仅访问实例域而不进行修改的方法称为<code>访问器方法(accessor method)</code>。</p>
<p>通常的习惯是在访问器方法前面加上前缀<code>get</code>，在更改器方法前面加上前缀<code>set</code>。</p>
<p><strong>java.util.GregorianCalendar</strong></p>
<ul>
<li><code>GregorianCalendar()</code><ul>
<li>构造一个日历对象，用来表示默认地区、默认时区的当前时间。</li>
</ul>
</li>
<li><code>GregorianCalendar( int year, int month, int day )</code></li>
<li><code>GregorianCalendar( int year, int month, int day, int hour, int minutes, int seconds )</code><ul>
<li>用给定的日期和时间构造一个Gregorian日历对象。</li>
</ul>
</li>
<li><code>int get( int field )</code><ul>
<li>返回给定区域的值</li>
</ul>
</li>
<li><code>void set( int field, int value )</code></li>
<li><code>void set( int year, int month, int day )</code></li>
<li><code>void set( int year, int month, int day, int hour, int minutes, int seconds )</code><ul>
<li>将日期域和时间域设置为新值。</li>
</ul>
</li>
<li><code>void add( int field, int amount)</code><ul>
<li>对给定的时间域增加指定数量的时间。</li>
</ul>
</li>
<li><code>int getFistDayOfWeek()</code><ul>
<li>获得当前用户所在地区，一个星期中的第一天。</li>
</ul>
</li>
<li><code>void setTime( Date time )</code><ul>
<li>将日历设置为指定的时间点。</li>
</ul>
</li>
<li><code>Date getTime()</code><ul>
<li>获得这个日历对象当前值所表达的时间点</li>
</ul>
</li>
</ul>
<p><strong>java.text.DateFormatSymbols</strong></p>
<ul>
<li><code>String[] getShortWeekdays()</code></li>
<li><code>String[] getShortMonths()</code></li>
<li><code>String[] getWeekdays()</code></li>
<li><code>String[] getMonths()</code><ul>
<li>获得当前地区的星期几或月份的名称。利用Calendar的星期和月份常量作为数组索引值。</li>
</ul>
</li>
</ul>
<h3 id="u7528_u6237_u81EA_u5B9A_u4E49_u7C7B"><a href="#u7528_u6237_u81EA_u5B9A_u4E49_u7C7B" class="headerlink" title="用户自定义类"></a>用户自定义类</h3><p>复杂应用程序需要各种<code>主力类(workhorse class)</code>。通常这些类没有main方法，而却有自定义的实例域和实例方法。要想创建一个完整的程序，应该将若干类组合在一起，其中只有一个类有main方法。</p>
<p>在Java的类中最简单的类定义形式为：</p>
<pre><code>class ClassName{
    constructor1
    constructor2
    …
    Method1
    Method2
    …
    Field1
    Field2
…
}
</code></pre><p>文件名必须与<code>public</code>类的名字相匹配。在一个文件中，只能有一个公有类，但可以有任意数目的非公有类。</p>
<p>如果习惯于将每一个类存在一个单独的源文件中，将可以有两种编译源程序的方法。</p>
<p>一种是使用通配符调用编译器，即<code>*</code>代表不定的字符串。另一种是只对含有公有类的文件进行<code>javac</code>操作，如果在这里使用了某个类，那么会自动搜索这个类的源文件，进行编译。</p>
<p>可以认为Java编译器内置了<code>make</code>功能。</p>
<p>关键字<code>public</code>意味着任何类的任何方法都可以调用这些方法。关键字<code>private</code>确保只有该类自身的方法能够访问这些实例域，而其他类的方法不能够读取这些域。</p>
<p>构造器与类同名，将实例域初始化为所希望的状态。构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。</p>
<p>方法用于操作对象以及存取它们的实例域。例如，方法：</p>
<pre><code>public void raiseSalary( double byPercent ){
    double raise = salary * byPercent / 100;
    salary += raise;
}
</code></pre><p>将调用这个方法的对象的<code>salary</code>实例域设置为新值，看看下面这个调用：<code>number007.raiseSalary(5);</code> 它的结果将<code>number007.salary</code>域的值增加5%。<code>raiseSalary</code>方法有两个参数。第一个参数被称为<code>隐式(implicit)</code>参数，是出现在方法名前的类对象。第二个参数位于方法名后面括号中的数值，这是一个<code>显式(explicit)</code>参数。<br>在每个方法中，关键字<code>this</code>表示隐式参数。如果需要的话，可以用下列方式编写<code>raiseSalary</code>方法：</p>
<pre><code>public void raiseSalary( double by Percent ){
    double raise = this.salary * byPercent / 100;
    this.salary += raise;
}
</code></pre><p>有些程序员更偏爱这样的风格，因为这样可以将实例域与局部变量明显区分开来。</p>
<p>封装应提供下面三项内容：</p>
<ol>
<li>一个私有的数据域</li>
<li>一个公有的域访问器</li>
<li>一个公有的域更改器方法</li>
</ol>
<p>这样做有如下的好处：</p>
<ul>
<li>可以改变内部实现，除了该类的方法之外，不会影响其他代码。</li>
<li>更改器方法可以执行错误检查，然而直接对域进行赋值将不会进行这些处理。</li>
</ul>
<p>一个方法可以访问所属类的所有对象的私有数据，而不仅限于访问隐式参数的私有特性。C++也有同样的原则。</p>
<p>尽管绝大多数方法都被设计为公有的，但在某些特殊情况下，也可能设计为私有的。</p>
<p>可以将实例域定义为<code>final</code>。构建对象时必须初始化这样的域。也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。</p>
<p><code>final</code>修饰符大都应用于<code>基本数据(primitive)</code>类型域，或<code>不可变类(immutable)</code>的域。对于可变的类，使用<code>final</code>修饰符可能会造成混乱。</p>
<h3 id="u9759_u6001_u57DF_u4E0E_u9759_u6001_u65B9_u6CD5"><a href="#u9759_u6001_u57DF_u4E0E_u9759_u6001_u65B9_u6CD5" class="headerlink" title="静态域与静态方法"></a>静态域与静态方法</h3><p>如果将域定义为<code>static</code>，每个类中只有一个这样的域。它属于类，而不属于任何独立的对象。</p>
<p>静态变量使用得比较少，但静态常量却使用得比较多。例如，在<code>Math</code>类中定义一个静态常量：<code>public static final double PI = 3.1415926;</code>在程序中，可以用<code>Math.PI</code>的形式获得这个常量。</p>
<p>另一个多次使用的静态常量是<code>System.out</code>。</p>
<p>静态方法是一种不能向对象实施操作的方法。例如，Math类的pow方法就是一个静态方法。表达式<code>Math.pow(x,a);</code>计算<code>X^a</code>。在运算时，不使用任何<code>Math</code>的对象，即没有隐式的参数。因为静态方法不能操作对象，所以不能在静态方法中访问实例域。但是，静态方法可以访问自身类中的静态域。</p>
<p>静态方法的一种常见用途。相当于创建实例对象的new。即把创建对象的过程抽象封装出来，可以创建不同名字和返回类型的对象，并且使程序的扩展性和安全性更强。</p>
<p><code>main</code>方法部队任何对象进行操作。事实上，在启动程序时还没有任何一个对象。静态的main方法将执行并创建程序所需要的对象。</p>
<h3 id="u65B9_u6CD5_u53C2_u6570"><a href="#u65B9_u6CD5_u53C2_u6570" class="headerlink" title="方法参数"></a>方法参数</h3><p>Java程序设计语言总是采用值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。</p>
<p>把对象引用作为参数可以改变对象参数状态，因为方法得到的是对象引用的拷贝，对象引用和它的拷贝引用的是同一个对象，所以在对其拷贝进行了更改之后，原来的对象引用也会发生变化。</p>
<p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用进行的是值传递，传递的值是一个拷贝的对象引用并且和原来的对象引用指向的是同一个对象，也因为如此，对这个拷贝的对象引用进行修改，也会对原来的对象产生影响。</p>
<h3 id="u5BF9_u8C61_u6784_u9020"><a href="#u5BF9_u8C61_u6784_u9020" class="headerlink" title="对象构造"></a>对象构造</h3><p>如果多个方法有相同的名字、不同的参数，便产生了重载。编译器通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来判断选择对应的方法。如果编译器找不到匹配的参数，或者找出多个可能的匹配，就会产生编译时错误(此过程称为重载解析(overloading resolution))。</p>
<p>如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值：数值为0、布尔值为false、对象引用为null。这是很不好的习惯。</p>
<p>如果在编写一个类时没有编写构造器，那么系统就会提供一个默认构造器。这个默认构造器将所有的实例域设置为默认值。</p>
<p>如果类中提供了至少一个构造器，但是没有提供默认的构造器，则在构造对象时如果没有提供构造函数参数就会被视为不合法。</p>
<p>由于类的构造器方法可以重载，所以可以采用多种形式设置类的实例域的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值。这是一种很好的设计习惯。</p>
<p>可以在类定义中，直接将一个值赋给任何域。当一个类的所有构造器都希望把相同的值赋给某个特定的实例域时，这种方式特别有用。</p>
<p>初始值不一定是常量。可以调用方法对域进行初始化。</p>
<p>编写很小的构造器时，常常用单个字符命名：</p>
<pre><code>public Employee( String n, double s){
    name = n;
    salary = s;
}
</code></pre><p>这样的话，就只有阅读代码才能了解参数n和s的含义，所以可以用aName和aSalary来代替，这样就可以一眼看出参数的含义。</p>
<p>还有一种常用的技巧，原理如下：参数变量用同样的名字将实例域屏蔽起来，再利用this隐式参数(即被构造的对象)访问实例域：</p>
<pre><code>public Employee( String name, double salary){
    this.name = name;
    this.salary = salary;
}
</code></pre><p>关键字<code>this</code>引用方法的隐式参数。然而这个关键字还有另外一个含义。</p>
<p>如果构造器的第一个语句形如this(…)，这个构造器将调用同一个类的另一个构造器，例子如下：</p>
<pre><code>public Employee(double s){
    // calls Employee( String, double )
    this( Employee #” + nextId, s);
    nextId++;
}
</code></pre><p>当调用new Employee(6000)时，会调用Employee(String,double)构造器。采用这种方式使用this关键字非常有用，这样对公共的构造器代码部分只编写一次即可。</p>
<p>除了在构造器中设置值和在声明中赋值，Java还有第三种机制，称为<code>初始化块(initialization block)</code>。在一个类的声明中可以包含多个代码块。只要构造类的对象，这些块就会被执行。例如：</p>
<pre><code>class Employee{
    public Employee( String n, double s ){
        name = n;
        salary = s;
    }

    public Employee(){
        name = ”;
        salary = 0;
    }
    ........
    private static int nextId;
    private int id;
    private String name;
    private double salary;
    ........
    // object initialization block
    {
        id = nextId;
        nextId++;
    }
}
</code></pre><p>在这个例子中，无论使用哪个构造器构造对象，id域都在对象初始化块(最后的一段)中被初始化。首先运行初始化块，然后才运行构造器的主体部分。这种机制不是必须的，也不常见。建议将初始化块放在域定义之后。</p>
<p><strong>java.util.Random</strong></p>
<ul>
<li><code>Random()</code><ul>
<li>构造一个新的随机数生成器。</li>
</ul>
</li>
<li><code>int nextInt( int n )</code><ul>
<li>返回一个0~n-1之间的随机数。</li>
</ul>
</li>
</ul>
<p>有些面向对象的程序设计语言，特别是C++，有显式的析构器方法，其中反之一些当对象不在使用时需要执行的清理代码。在析构器中，最常见的操作是回收分配格对象的存储空间。由于Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器。</p>
<p>当然，某些对象使用了内存之外的其他资源，例如，文件或使用了系统资源的另一个句柄。在这种情况下，当资源不再需要时，将其回收和再利用将显得十分重要。</p>
<p>可以为任何一个类添加finalize方法。finalize方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能够调用。</p>
<p>如果某个资源需要在使用后立即被关闭，那么就需要人工来管理。可以应用一个类似<code>dispose</code>或<code>close</code>的方法完成相应的清理操作。如果一个类使用了这样的方法，使用完毕一定要记得调用它。</p>
<h3 id="u5305"><a href="#u5305" class="headerlink" title="包"></a>包</h3><p>Java允许使用包(package)将类组织起来。借助于包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。</p>
<p>标准的Java类库分布在多个包中，包括<code>java.lang</code>、<code>java.util</code>、<code>java.net</code>等。标准的Java包具有一个层次结构，所有标准的Java包都在java和javax包层次中。</p>
<p>使用包的主要原因是确保类名的唯一性。Sun公司建议将公司的因特网域名以逆序的形式作为包名，并且不同的项目使用不同的子包。若域名为www.wdx.cn，则包的名字就叫做 cn.wdx。</p>
<p>从编译器的角度来看，嵌套的包之间没有任何关系，每一个都拥有独立的类集合。</p>
<p>一个类可以使用所属包中的所有类，以及其他包中的公有类(public class)。可以使用两种方式访问包中的公有类。第一种就是每个类名前添加完整包名。另一种是使用import语句，可以用import语句导入一个特定的类或者整个包。import语句应位于源文件的顶部(但位于package语句后面)。</p>
<p>还可以使用<code>星号(*)</code>导入一个包：<code>import java.util.*</code></p>
<p>若两个不同包中有相同的类名，则可以添加特定的<code>import</code>语句来解决：<code>import java.util.Date;</code>若有冲突的类名都要用，则在每个类名的前面加上完整的包名。</p>
<p>从Java SE 5.0开始，import语句可以导入静态方法和静态域的功能。例如：<code>import static java.lang.System.*;</code>就可以使用<code>System</code>类的静态方法和静态域，而不必加类名前缀：</p>
<pre><code>out.println(GoodBye!My friend!”);  // i.e,System.out
exit(0);    // i.e., System.exit
</code></pre><p>静态导入的两个最实际的应用：</p>
<ol>
<li>算数函数：如果对Math类使用静态导入，就可以采用更加自然的方式使用静态导入：<code>sqrt( pow( x, 2 ) + pow( y, 2 ))</code></li>
<li>笨重的常量：如果需要使用大量带有冗长名字的常量，就应该使用静态导入，例如<code>calendar</code>类。</li>
</ol>
<p>要想将一个类放入包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前：<code>package cn.wdx;</code></p>
<p>如果没有在源文件中放置package语句，这个源文件中的类就被放置在一个默认包中(default package)。默认包是一个没有名字的包。</p>
<p>标记为<code>public</code>的部分可以被任意的类使用；标记为<code>private</code>的部分只能被定义它们的类使用。如果没有指定<code>public</code>或<code>private</code>，这个部分(类、方法或变量)可以被同一个包中的所有方法访问。</p>
<p>可以通过<code>包密封(package sealing)</code>机制来解决将各种包混杂在一起的问题。如果将一个包密封起来，就不能再向这个包添加类了。</p>
<p>类文件也可以存储在<code>JAR(Java归档)</code>文件中，JAR文件使用ZIP格式组织文件和子目录。<br>为了能使类能够被多个程序共享，需要做到下面几点：</p>
<ul>
<li>把类放到一个目录中。</li>
<li>将JAR文件放在一个目录中</li>
<li>设置类路径(class path)。类路径是所有包含类文件的路径的集合。</li>
</ul>
<p>如果在源代码中添加以专用的界定符/**开始的注释，那么可以很容易地生成一个看上去具有专业水准的文档。</p>
<p>javadoc实用程序(utility)从下面几个特性中抽取信息：</p>
<ul>
<li>包</li>
<li>公有类与接口</li>
<li>公有的和受保护的方法</li>
<li>公有的和受保护的域</li>
</ul>
<p>应该为上面几部分编写注释。注释应该放置在所描述的特性的前面。注释以<code>/**</code>开始，并以<code>*/</code>结束。</p>
<p>每个<code>/**...*/</code>文档注释在标记之后紧跟着自由格式文本(free-form text)。标记由@开始，如<code>@author</code>或<code>@param</code>。</p>
<p>自由格式文本的第一句应该是一个概要性的句子。<code>javadoc</code>实用程序自动地将这些句子抽取出来形成概要页。</p>
<p>在自由格式文本中，可以使用HTML修饰符，例如，用于强调的<code>&lt;em&gt;...&lt;/em&gt;</code>、用于设置等宽打字机”字体的<code>&lt;code&gt;...&lt;/code&gt;</code>、用于着重强调的<code>&lt;strong&gt;...&lt;/strong&gt;</code>以及包含图像的<code>&lt;img...&gt;</code>等。不过一定不要使用<code>&lt;h1&gt;</code>或<code>&lt;hr&gt;</code>，因为它们会与文档的格式产生冲突。</p>
<p>类注释必须放在import语句之后，类定义之前。例子如下：</p>
<pre><code>/**
 * A &lt;code&gt;Card&lt;/code&gt; object represents a playing card,such
 * as Queen of Hearts”. A card has a suit (Diamond, Heart,
 * Spade or Club) and a value ( 1 = Ace, 2....10,11 = Jack,
 * 12 = Queen, 13 = King).
 */
public class Card{
    .....
}
</code></pre><p>每一个方法在注释是必须放在所描述的方法之前。除了通用标记之外，还可以使用下面的标记：</p>
<pre><code>@param variable description
</code></pre><p>这个标记将对当前方法的<code>param(参数)</code>部分添加一个条目。这个描述可以占据多行，并可以使用HTML标记。一个方法的所有<code>@param</code>标记必须放在一起。</p>
<pre><code>@return description
</code></pre><p>这个标记将对当前方法添加<code>return(返回)</code>部分。这个描述可以跨越多行，并可以使用HTML标记。</p>
<pre><code>@throws class description
</code></pre><p>这个标记将添加一个注释，用于表示这个方法有可能抛出异常。</p>
<p>只需要对公有域(通常指的是静态常量)建立文档。例如：</p>
<pre><code>/**
 *  The Hearts” card suit
 */
public static final int HEARTS = 1;
</code></pre><p>用于类文档的注释</p>
<pre><code>@author name
</code></pre><p>这个标记将产生一个author”(作者)条目。可以使用多个@author标记，每个标记对应一个作者。</p>
<pre><code>@version text
</code></pre><p>这个标记将产生一个version”(版本)条目。这里的text可以是对当前版本的任何描述。<br>用于所有文档的注释</p>
<pre><code>@since text
</code></pre><p>这个标记将产生一个since”(始于)条目。这里的text可以是对引入特性的版本描述，例如<code>@since version 1.3.3</code>。</p>
<pre><code>@deprecated text
</code></pre><p>这个标记将对类、方法或变量添加一个不再使用的注释。text中给出了取代的建议。</p>
<pre><code>@see reference
</code></pre><p>这个标记将在see also”部分增加一个超级链接。它可以用于类中，也可以用于方法中。这里的reference可以选择下列情形之一：</p>
<ul>
<li>第一种情况最常见，只要提供类、方法或变量的名字，<code>javadoc</code>就在文档中插入一个超链接。例如，<code>@see cn.wdx.HelloWorld#text()</code> 就会建立一个链接到<code>cn.wdx.HelloWorld</code>类的<code>text</code>方法的超链接。注意要用#”分隔类名与方法名，或类名与变量名。</li>
<li>如果在<code>@see</code>标记后面有一个<code>&lt;</code>字符，就需要指定一个超链接。如果在<code>@see</code>标记后面有一个双引号字符，文本就会显示在<code>see also</code>部分。</li>
<li>可以为一个特性添加多个<code>@see</code>标记，但必须将它们放在一起。</li>
</ul>
<p>想要产生包注释，就需要在每一个包目录中添加一个单独的文件，可以有如下两个选择：</p>
<ol>
<li>提供一个以package.html命名的HTML文件。在标记<code>&lt;BODY&gt;...&lt;/BODY&gt;</code>之间的所有文本都会被抽取出来。</li>
<li>提供一个以<code>package-info.java</code>命名的Java文件。这个文件必须包含一个初始的以<code>/**和*/</code>界定的<code>Javadoc</code>注释，跟随在一个包语句之后。它不应该包含更多的代码或注释。</li>
</ol>
<p>还可以为所有的源文件提供一个概述性的注释。</p>
<p>这个注释被放置在一个名为<code>overview.html</code>的文件中，这个文件位于包含所有源文件的父目录中。标记<code>&lt;BODY&gt;...&lt;/BODY&gt;</code>之间的所有文本都会被抽取出来。</p>
<h3 id="u7C7B_u7684_u8BBE_u8BA1_u6280_u5DE7"><a href="#u7C7B_u7684_u8BBE_u8BA1_u6280_u5DE7" class="headerlink" title="类的设计技巧"></a>类的设计技巧</h3><ul>
<li>一定将数据设计为私有</li>
<li>一定要对数据初始化</li>
<li>不要在类中使用过多的基本数据类型。</li>
<li>不是所有的域都需要独立的域访问器和域更改器。</li>
<li>使用标准格式进行类的定义。</li>
</ul>
<p>采用下列顺序书写类的内容：</p>
<ul>
<li>公有访问特性部分</li>
<li>包作用域访问特性部分</li>
<li>私有访问特性部分</li>
</ul>
<p>在每一部分中应该按照下列顺序列出</p>
<ul>
<li>实例方法</li>
<li>静态方法</li>
<li>实例域</li>
<li>静态域</li>
</ul>
<p>将职责过多的类进行分解</p>
<p>类名和方法名要能够体现它们的职责</p>
<h2 id="u7EE7_u627F"><a href="#u7EE7_u627F" class="headerlink" title="继承"></a>继承</h2><h3 id="u7C7B_u3001_u8D85_u7C7B_u548C_u5B50_u7C7B"><a href="#u7C7B_u3001_u8D85_u7C7B_u548C_u5B50_u7C7B" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h3><p>is-a”关系是继承的一个明显特征，关键字extends表示继承。例如：</p>
<pre><code>class Manager extends Employee{
    .... // Manager类继承了Employee类
}
</code></pre><p>关键字<code>extends</code>表明正在构造的新类派生于一个已存在的类。已存在的类被称为<code>超类(superclass)</code>、<code>基类(base class)</code>或<code>父类(parent class)</code>；新类被称为<code>子类(subclass)</code>、<code>派生类(derived class)</code>或<code>孩子类(child class)</code>。超类和子类是Java程序员最常用的两个术语。</p>
<p>在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。因此在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。</p>
<p>若超类中的某些方法对于子类中并不适用，就需要提供一个新的方法来<code>覆盖(override)</code>超类中的这个方法。但如果在这个新的方法中需要调用超类中的同名方法的时候，可以用<code>super</code>来调用，例如：</p>
<pre><code>public double getSalary(){
    double baseSalary = super.getSalary();
    return baseSalary + bonus;
}
</code></pre><p>在子类中可以增加域、增加方法或覆盖超类的方法，然而绝不能删除继承的任何域和方法。<br>super在构造器中用来调用超类的构造器，例如：</p>
<pre><code>public Manager( String n, double s, int year ){
    super( n, s, year );
    bonus = 0;
}
</code></pre><p>如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则Java编译器将报告错误。</p>
<p>继承并不仅限于一个层次，由一个公共超类派生出来的所有类的集合被称为<code>继承层次(inheritance hierarchy)</code>。在继承层次中，从某个特定的类到其祖先的路径被称为该类的<code>继承链(inheritance chain)</code>。</p>
<p>通常，一个祖先类可以拥有多个子孙继承链。Java不支持多继承。</p>
<p>有一个用来判断是否应该设计为继承关系的简单规则，这就是<code>is-a</code>规则，它表明子类的每个对象也是超类的对象。</p>
<p><code>is-a</code>规则的另一种表述方式是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象置换。</p>
<p>在Java程序设计语言中，对象变量是多态的。一个超类变量既可以引用一个超类对象，也可以引用一个此超类的任何一个子类的对象。然而，不能将一个超类的引用赋给子类变量。</p>
<p>弄清调用对象方法的执行过程十分重要。下面是调用过程的描述：</p>
<p>编译器查看对象的声明类型和方法名。假设调用<code>x.f(param)</code>，且隐式参数<code>x</code>声明为C类的对象。编译器将会一一列举所有<code>C</code>类中名为<code>f</code>的方法和其他超类中访问属性为<code>public</code>且名为<code>f</code>的方法。</p>
<p>至此，编译器已获得所有可能被调用的候选方法。</p>
<p>接下来，编译器查看调用方法时提供的参数类型。如果在所有名为<code>f</code>的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为<code>重载解析(overloading resolution)</code>。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。</p>
<p>至此，编译器已获得需要调用的方法名字和参数类型。</p>
<p>如果是<code>private</code>方法、<code>static</code>方法、<code>final</code>方法或者构造器，那么编译器可以准确地知道应该调用哪个方法，这种调用方式称为静态绑定(static binding)。与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。</p>
<p>当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与<code>x</code>所引用对象的实际类型最合适的那个类的方法。</p>
<p>每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表(method table)，与C++中的VTABLE类似，其中列出了所有方法的签名和实际调用的方法。实际调用时查找此表即可。</p>
<p>动态绑定有一个非常重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展。</p>
<p>不允许扩展的类被称为<code>final</code>类。如果在定义类的时候使用了<code>final</code>修饰符就表明这个类是final类。可以阻止人们定义其子类，如：</p>
<pre><code>final class Executive extends Manager{...}
</code></pre><p>类中的方法也可以被声明为final如果这样做，子类就不能覆盖这个方法(<code>final</code>类中的所有方法自动成为<code>final</code>方法)。如：<code>public final int getValue()</code></p>
<p>将方法或类声明为final的意义在于：确保它们不会在子类中改变语义。</p>
<p>对象引用的转换语法与数值表达式的类型转换类似，仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。</p>
<p>在进行类型转换之前，先查看以下是否能够成功地转换。可以简单地使用instanceof运算符实现，如：</p>
<pre><code>if( staff[1] instanceof Manager){
    boss = (Manager) staff[1];
    ......
}
</code></pre><p>综上所述，有两个原则：</p>
<ol>
<li>只能在继承层次内进行类型转换。</li>
<li>在超类传唤成子类之前，应该使用<code>instanceof</code>检查。</li>
</ol>
<p>一般情况下，应该尽量少用类型转换和<code>instanceof</code>运算符。</p>
<p>如果自下而上仰视类的继承层次结构，位于上层的类更具有通用性，甚至可能更加抽象。从某种角度看，祖先类更加通用，人们只将它作为派生其他类的基类，而不作为想使用的特定实例类。</p>
<p>使用<code>abstract</code>关键字来声明抽象类。</p>
<pre><code>public abstract String getDescription();
// no implementation required
</code></pre><p>为了提高程序的清晰读，包含一个或多个抽象方法的类本身必须被声明为抽象的。除了抽象方法之外，抽象类还可以包含具体数据和具体方法。</p>
<p>抽象方法充当占位的角色，它们的具体实现在子类中。扩展抽象类可以有两种选择。一种是在子类中定义部分抽象方法或抽象方法也不定义，这样就必须将子类也标记为抽象类；另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。</p>
<p>类即使不含抽象方法，也可以将类声明为抽象类。</p>
<p>抽象类不能被实例化，即不能创建抽象类的对象。但是可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。</p>
<ul>
<li>仅对本类可见──private。</li>
<li>对所有类可见──public。</li>
<li>对本包和所有子类可见──protected。</li>
<li>对本包可见──默认。</li>
</ul>
<p>Java中的protected概念要比C++中的安全性差。</p>
<h3 id="Object__u6240_u6709_u7C7B_u7684_u8D85_u7C7B"><a href="#Object__u6240_u6709_u7C7B_u7684_u8D85_u7C7B" class="headerlink" title="Object 所有类的超类"></a>Object 所有类的超类</h3><p><code>Object</code>类是Java中所有类的最终祖先，在Java中每个类都是由它扩展而来的。如果没有明确地指出超类，<code>Object</code>就被认为是这个类的超类。</p>
<p>可以使用<code>Object</code>类型的变量引用任何类型的对象。当然，<code>Object</code>类型的变量只能用于作为各种值的通用持有者。要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的类型转换。</p>
<p>在Java中，只有<code>基本类型(primitive types)</code>不是对象。</p>
<p><code>Object</code>类中的<code>equals</code>方法用于检测一个对象是否等于另一个对象。在<code>Object</code>类中，这个方法将判断两个对象是否具有相同的引用。</p>
<p>Java语言规范要求equals方法具有下面的特性：</p>
<ul>
<li>自反性：对于任何非空引用<code>x</code>，<code>x.equals(x)</code>应该返回<code>true</code>。</li>
<li>对称性：对于任何引用<code>x</code>和<code>y</code>，当且仅当<code>y.equals(x)</code>返回<code>true</code>，<code>x.equals(y)</code>也应该返回<code>true</code>。</li>
<li>传递性：对于任何引用<code>x</code>、<code>y</code>和<code>z</code>，如果<code>x.equals(y)</code>返回<code>true</code>，<code>y.equals(z)</code>返回<code>true</code>，<code>x.equals(z)</code>也应该返回<code>true</code>。</li>
<li>一致性：如果<code>x</code>和<code>y</code>引用的对象没有发生变化，反复调用<code>x.equals(y)</code>应该返回同样的结果。</li>
<li>对于任意非空引用<code>x</code>，<code>x.equals(null)</code>应该返回<code>false</code>。</li>
</ul>
<p>可以从两个截然不同的情况看待getClass的使用：</p>
<ol>
<li>如果子类能够拥有子集的相等概念，则对称性需求将强制采用getClass进行检测。</li>
<li>如果由超类决定相等的概念，那么就可以使用instanceof进行检测，这样就可以在不同子类对象之间进行相等的比较。</li>
</ol>
<p>下面给出编写一个完美的equals方法的建议：</p>
<ul>
<li>显式参数命名为<code>otherObject</code>，稍后需要将它转换称另一个叫做<code>other</code>的变量。</li>
<li>检测<code>this</code>与<code>otherObject</code>是否引用同一个对象：<code>if( this == otherObject ) return true;</code></li>
<li>检测<code>otherObject</code>是否为<code>null</code>，如果为<code>null</code>，返回<code>false</code>。<code>if( otherObject == null ) return false;</code></li>
<li>比较<code>this</code>与<code>otherObject</code>是否属于同一个类。</li>
<li>如果<code>equals</code>语义在每个子类中有所改变，就使用<code>getClass</code>检测：<code>if (getClass() != otherObject.getClass()) return false;</code></li>
<li>如果所有的子类拥有统一的语义，就使用<code>instanceof</code>检测：<code>if( ! ( otherObject instanceof ClassName )) return false;</code></li>
<li>将<code>otherObject</code>转换相应的类型变量：<code>ClassName other = ( ClassName )otherObject;</code></li>
</ul>
<p>现在开始对所有需要比较的域进行比较。使用 <code>==</code> 比较基本类型域，使用<code>equals</code>比较对象域。如果所有都匹配，就返回<code>true</code>，否则返回<code>false</code></p>
<pre><code>return field1 == other.field1
    &amp;&amp; field2.equals(other.field2)
    &amp;&amp; ...;
</code></pre><p>如果在子类中重新定义<code>equals</code>，就要在其中包含调用<code>super.equals(other)</code>。</p>
<p><code>散列码(hash code)</code>是由对象导出的一个整型值，是没有规律的。可以用做来判断对象是否相等。</p>
<p><strong>java.lang.Object</strong></p>
<ul>
<li><code>int hashCode()</code><ul>
<li>返回对象的散列码。散列码可以是任意的整数，包括正数或负数。两个相等的对象要求返回相等的散列码。</li>
</ul>
</li>
<li><code>Class getClass()</code><ul>
<li>返回包含对象信息的类对象。Java提供了类运行时的描述，被封装在Class类中。</li>
</ul>
</li>
<li><code>boolean equals( Object otherObject )</code><ul>
<li>比较两个对象是否相等，如果两个对象指向同一块存储区域，方法放回true；否则方法返回false。在自定义类中，应该覆盖这个方法。</li>
</ul>
</li>
<li><code>String toString()</code><ul>
<li>返回描述该对象值的字符串。在自定义类中，应该覆盖这个方法。</li>
</ul>
</li>
<li><code>Object clone()</code><ul>
<li>创建一个对象的副本。Java运行时系统将为新实例分配存储空间，并将当前的对象复制到这块存储区域中。</li>
</ul>
</li>
</ul>
<p><strong>java.lang.Class</strong></p>
<ul>
<li><code>String getName()</code><ul>
<li>返回这个类的名字。</li>
</ul>
</li>
<li><code>Class getSuperclass()</code><ul>
<li>以Class对象的形式返回这个类的超类信息。</li>
</ul>
</li>
</ul>
<p>在<code>Object</code>中还有一个重要的方法，就是<code>toString</code>方法，它用于返回表示对象值的字符串。绝大多数的<code>toString</code>方法都遵循这样的格式：类的名字，随后是一对方括号括起来的域值。</p>
<p>如果<code>x</code>是任意一个对象，并调用<code>System.out.println(x)</code>; 就会直接调用<code>x.toString()</code>，并打印输出得到的字符串。</p>
<h3 id="u6CDB_u578B_u6570_u7EC4_u5217_u8868"><a href="#u6CDB_u578B_u6570_u7EC4_u5217_u8868" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h3><p>在Java SE 5.0中，<code>ArrayList</code>是一个采用<code>类型参数(type parameter)</code>的<code>泛型类(generic class)</code>。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面。下面声明和构造一个保存<code>Employee</code>对象的数组列表：</p>
<pre><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;();
</code></pre><p>使用<code>add</code>方法可以将元素添加到数组列表中。如果调用<code>add</code>且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。</p>
<p>如果已经清楚或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用<code>ensureCapacity</code>方法：</p>
<pre><code>staff.ensureCapacity(100);
</code></pre><p>这个方法调用将分配一个包含100个对象的内部数组。然后调用100次add，而不用重新分配空间。</p>
<p><strong>java.util.ArrayList<t></t></strong></p>
<ul>
<li><code>ArrayList&lt;T&gt;</code><ul>
<li>构造一个空数组列表</li>
</ul>
</li>
<li><code>ArrayList&lt;T&gt;(int initialCapacity)</code><ul>
<li>用指定容量initialCapacity构造一个空数组列表</li>
</ul>
</li>
<li><code>boolean add(T obj)</code><ul>
<li>在数组列表的尾端添加一个元素obj。永远返回true。</li>
</ul>
</li>
<li><code>int size()</code><ul>
<li>返回存储在数组列表中的当前元素数量。(这个值将小于或等于数组列表的容量)</li>
</ul>
</li>
<li><code>void ensureCapacity(int capacity)</code><ul>
<li>确保数组列表在不重新分配存储空间的情况下就能够保存给定数量的元素。</li>
</ul>
</li>
<li><code>void trimToSize()</code><ul>
<li>将数组列表的存储容量削减到当前尺寸。</li>
</ul>
</li>
<li><code>void set( int index, T obj )</code><ul>
<li>设置数组列表指定位置的元素值，此操作将覆盖这个位置的原有内容。</li>
</ul>
</li>
<li><code>T get( int index )</code><ul>
<li>获得指定位置的元素值。</li>
</ul>
</li>
<li><code>void add( int index, T obj )</code><ul>
<li>向后移动元素，以便插入元素。</li>
</ul>
</li>
<li><code>T remove( int index )</code><ul>
<li>删除一个元素并将后面的元素向前移动。被删除的元素由返回值返回。</li>
</ul>
</li>
</ul>
<p>数组列表自动扩展容量的便利增加了访问元素语法的复杂程度。使用<code>get</code>和<code>set</code>方法实现访问或改变数组元素的操作。例如：</p>
<pre><code>staff.set(i,harry);
Employee e = staff.get(i);
</code></pre><p>使用<code>add</code>方法为数组添加新元素，而不要使用<code>set</code>方法，它只能替换数组中已经存在的元素内容。</p>
<p>也可以使用<code>for each</code>循环对数组列表遍历：</p>
<pre><code>for(Employee e : staff)
    do something with e
</code></pre><p>请注意下面的变化：</p>
<ul>
<li>不必指出数组的大小。</li>
<li>使用<code>add</code>将任意多的元素添加到数组中。</li>
<li>使用<code>size()</code>替代<code>length</code>计算元素的数目。</li>
<li>使用<code>a.get(i)</code>替代<code>a[i]</code>访问元素。</li>
</ul>
<h3 id="u5BF9_u8C61_u5305_u88C5_u5668_u4E0E_u81EA_u52A8_u6253_u5305"><a href="#u5BF9_u8C61_u5305_u88C5_u5668_u4E0E_u81EA_u52A8_u6253_u5305" class="headerlink" title="对象包装器与自动打包"></a>对象包装器与自动打包</h3><p>有时，需要将int这样的基本类型转换为对象。所有的基本类型都有一个与之对应的类。例如，Integer类对应基本类型int。通常，这些类称为包装器(wrapper)。对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。对象包装器类还是final，因此不能定义它们的子类。</p>
<p>假设想定义一个整型数组列表。而尖括号中的类型参数不允许是基本类型，也就是说，不允许写成<code>ArrayList&lt;int&gt;</code>。这里就用到了<code>Integer</code>对象包装器类。我们可以声明一个<code>Integer</code>对象的数组列表。</p>
<pre><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
</code></pre><p>Java SE 5.0的另一个改进之处是更加便于添加或获得数组元素。</p>
<p><code>list.add(3);</code> 将自动变成 <code>list.add(new Integer(3));</code></p>
<p>这种变换被称为<code>自动打包(autoboxing)</code>。</p>
<p>相反的，当将一个<code>Integer</code>对象赋给一个<code>int</code>值时，会自动地拆包。包含在包装器中的内容不会改变。不能使用这些使用这些包装器类创建修改数值参数的方法。如果想要修改参数值的方法，就要使用<code>持有者(holder)</code>类型。</p>
<p>最后强调以下，打包和拆包是<strong>编译器</strong>认可的，而不是虚拟机。</p>
<p><strong>java.lang.Integer</strong></p>
<ul>
<li><code>int intValue()</code><ul>
<li>以int的形式返回Integer对象的值。</li>
</ul>
</li>
<li><code>static String toString( int i )</code><ul>
<li>以一个新String对象的形式返回给定数值 i 的十进制表示。</li>
</ul>
</li>
<li><code>static String toString( int i, int radix )</code><ul>
<li>返回数值 i 的基于给定radix参数进制的表示。</li>
</ul>
</li>
<li><code>static int parseInt( String s )</code></li>
<li><code>static int parseInt( String s, int radix )</code><ul>
<li>返回字符串 s 表示的整型数值，给定字符串表示的十进制的整数，或者是radix参数进制的整数。</li>
</ul>
</li>
<li><code>static Integer valueOf( String s )</code></li>
<li><code>static Integer valueOf( String s, int radix )</code><ul>
<li>返回用 s 表示的整型数值进行初始化后的一个新Integer对象，给定字符串表示的是十进制的整数，或者是radix参数进制的整数。</li>
</ul>
</li>
</ul>
<p><strong>java.text.NumberFormat</strong></p>
<ul>
<li><code>Number parse( String s )</code><ul>
<li>返回数字值，假设给定的String表示了一个数值。</li>
</ul>
</li>
</ul>
<h3 id="u53C2_u6570_u6570_u91CF_u53EF_u53D8_u7684_u65B9_u6CD5"><a href="#u53C2_u6570_u6570_u91CF_u53EF_u53D8_u7684_u65B9_u6CD5" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h3><p>可以用省略号…表明这个方法可以接收任意数量的对象。例如</p>
<pre><code>public static double max( double... values){
    double largest = Double.MIN_VALUE;
    for( double v : values) if (v &gt; largest ) largest = v;
    return largest;
}
</code></pre><h3 id="u679A_u4E3E_u7C7B"><a href="#u679A_u4E3E_u7C7B" class="headerlink" title="枚举类"></a>枚举类</h3><pre><code>public enum Size{ SMALL, MEDIUM, LARGE, EXTRA_LARGE };
</code></pre><p>实际上，这个声明定义的类型是一个类，它刚好有4个实例，在此尽量不要构造新对象。如果需要的话，可以在枚举类型中添加一些构造器、方法和域。当然构造器只是在构造枚举常量的时候被调用。</p>
<p>每个枚举类型都有一个静态的<code>values</code>方法，它将返回一个包含全部枚举值的数组。</p>
<p><strong>java.lang.Enum<e></e></strong></p>
<ul>
<li><code>static Enum valueOf( Class enumClass, String name )</code><ul>
<li>返回指定名字、给定类的枚举常量。</li>
</ul>
</li>
<li><code>String toString()</code><ul>
<li>返回枚举常量名。</li>
</ul>
</li>
<li><code>int ordinal()</code><ul>
<li>返回枚举常量在enum声明中的位置，位置从 0 开始计数。</li>
</ul>
</li>
<li><code>int compareTo(E other)</code><ul>
<li>如果枚举常量出现在other之前，则返回一个负值；如果this == other，则返回 0；否则，返回正值。枚举常量的出现次序在enum声明中给出。</li>
</ul>
</li>
</ul>
<h3 id="u53CD_u5C04"><a href="#u53CD_u5C04" class="headerlink" title="反射"></a>反射</h3><p><code>反射库(reflection library)</code>提供了一个非常丰富且精心设计的工具集，以便能编写能够动态操纵Java代码的程序。使用反射，Java可以支持Visual Basic用户习惯使用的工具。特别是在设计或运行中添加新类时，能够快速地应用开发工具动态地查询新添加类的能力。</p>
<p>能够分析类能力的程序被称为反射(reflective)。反射机制的功能极其强大。可以用反射机制：</p>
<ul>
<li>在运行中分析类的能力。</li>
<li>在运行中查看对象，例如，编写一个toString方法供所有类使用。</li>
<li>实现数组的操作代码。</li>
<li>利用Method对象，这个对象很像C++中的函数指针。</li>
<li>反射是一种功能强大且复杂的机制。使用它的主要对象是工具构造者。</li>
</ul>
<h2 id="u9644_u5F551_Cpp_u6CE8_u91CA"><a href="#u9644_u5F551_Cpp_u6CE8_u91CA" class="headerlink" title="附录1 Cpp注释"></a>附录1 Cpp注释</h2><blockquote>
<p>Java的类与C++的类</p>
</blockquote>
<p>Java中的所有函数都属于某个类的方法(标准术语称其为方法，而不是成员函数)。因此，Java中的所有函数都必须有一个外壳类并且<code>main</code>方法必须是静态的。如果<code>main</code>方法正确退出，那么Java应用程序的退出代码为0，如果想要在终止程序的时候返回其他代码，那就需要调用<code>System.exit</code>方法。</p>
<blockquote>
<p>Java的整型与C++的整型</p>
</blockquote>
<ul>
<li>在C和C++中，int表示的整型与目标机器相关。Java没有任何无符号类型(unsigned type)。</li>
<li>boolean值的不同</li>
<li>在C++中，数值或指针可以代替boolean值。0相当于false，非0值相当于true。在Java中就不行。</li>
</ul>
<blockquote>
<p>变量的声明与定义</p>
</blockquote>
<p>C和C++中变量的声明与定义是不同的。在Java中，不区分变量的声明与定义。</p>
<blockquote>
<p>const</p>
</blockquote>
<p><code>const</code>是Java的保留关键字，但目前并未使用，必须用<code>final</code>定义常量。</p>
<blockquote>
<p>移位操作</p>
</blockquote>
<p>在C和C++中无法确定 <code>&gt;&gt;</code> 操作执行的是算数移位(扩展符号位)，还是逻辑移位(高位填0)。实际上在C和C++中，<code>&gt;&gt;</code> 运算符实际上是只为非负数定义的。Java消除了这种含糊性。</p>
<blockquote>
<p>boolean的强制类型转换</p>
</blockquote>
<p>不要在boolean类型与任何数值类型之间进行强制类型转换，这样可能防止发生错误。</p>
<blockquote>
<p>逗号运算符？</p>
</blockquote>
<p>与C和C++不同，Java不使用逗号运算符，不过可以在for语句中用逗号隔开表达式列表。</p>
<blockquote>
<p>Java中的字符串</p>
</blockquote>
<p>与C++不同，Java字符串更加像char*指针，自动的垃圾回收也可以避免内存泄露。</p>
<blockquote>
<p>流程结构</p>
</blockquote>
<p>Java的控制流程功能结构与C和C++的控制流程结构一样，只有很少的例外情况。没有goto语句，但break语句可以带标签，可以利用它实现从内层循环跳出的目的。还有一种变形的for循环，类似于C#中的foreach循环。</p>
<blockquote>
<p>嵌套的块</p>
</blockquote>
<p>在C++中，可以在嵌套的块中重定义一个变量。在内层定义的变量会覆盖在外层定义的变量。这样，有可能导致程序设计错误，因此在Java中不允许这样做。</p>
<blockquote>
<p>运算符重载</p>
</blockquote>
<p>与C++不同，Java没有提供运算符重载功能。Java语言的设计者确实为字符串的连接重载了+运算符，但是没有重载其他运算符，也没有给Java程序员自己重载运算符的权利。</p>
<blockquote>
<p>Java数组与C++数组</p>
</blockquote>
<p>Java数组与C++数组在堆栈上有很大不同，但基本上与分配在堆(heap)上的数组指针一样。Java中的[]运算符被预定义为检查数组边界，而且没有指针运算，不能通过数组名加1来得到数组的下一个元素。</p>
<blockquote>
<p>Java对象变量</p>
</blockquote>
<p>在C++中没有空引用，并且引用不能被赋值。我们可以将Java的对象看作C++的对象指针。在Java中指针问题不再困扰。如果使用一个没有初始化的指针，系统就会产生一个运行时错误，而不是随机的结果。垃圾收集器会处理内存管理问题。</p>
<blockquote>
<p>更改器和访问器</p>
</blockquote>
<p>在C++中，带有const后缀的方法是访问器方法；默认为更改器方法。Java中，访问器方法与更改器方法语法上没有明显的区别。</p>
<blockquote>
<p>Java的构造器</p>
</blockquote>
<p>Java构造器的工作方式与C++一样。但是，要记住所有的Java对象都是在堆中构造的，构造器总是伴随着new操作符一起使用。C++程序员最容易犯得作物就是忘记new操作符。</p>
<blockquote>
<p>Java的内部定义</p>
</blockquote>
<p>在C++中，通常在类的外面定义方法，如果在类的内部定义方法，这个方法就自动成为内联方法。在Java中，所有的方法都必须在类的内部定义，但并不表示它们是内联方法。</p>
<blockquote>
<p>static的不同含义</p>
</blockquote>
<p>Java中的静态域与静态方法在功能上与C++相同。但是语法却有不同。C中static有三种含义：</p>
<ul>
<li>表示退出一个块后依然存在的局部变量。</li>
<li>不能被其他文件访问的全局变量和函数。</li>
<li>属于类且不属于类对象的变量和函数。这个含义与Java相同。</li>
</ul>
<blockquote>
<p>值调用和引用调用</p>
</blockquote>
<p>C++有值调用和引用调用，用<code>&amp;</code>符号标记，可以实现修改它们的引用参数的目的。而Java则不行，Java只有值调用。</p>
<blockquote>
<p>初始化</p>
</blockquote>
<p>在C++中，不能直接初始化实例域。所有的域必须在构造器中设置。但是，有一个特殊的初始化器列表语法。C++使用这种特殊的语法来调用域构造器。在Java中没有这种必要，因为对象没有子对象，只有指向其他对象的指针。</p>
<blockquote>
<p>构造器</p>
</blockquote>
<p>在Java中，this引用等价于C++的this指针。但是，在C++中，一个构造器不能调用另一个构造器。在C++中，必须将抽取初的公共初始代码编写成一个独立的方法。</p>
<blockquote>
<p><code>#include与import</code></p>
</blockquote>
<p>这两者并没有共同之处。在C++中，必须使用#include将外部特性的声明加载近来，因为C++编译器无法查看任何文件的内部，除了正在编译的文件以及在头文件中明确包含的文件。Java编译器可以查看其他文件的内部。</p>
<p>在Java中，通过显式地给出包名，就可以不使用import；而在C++中，无法避免使用#include。</p>
<p>在C++中，与包机制类似的是命名空间(namespace)。在Java中，package与import语句类似C++中的namespace和using指令(directive)。</p>
<blockquote>
<p>Java的继承和C++的继承</p>
</blockquote>
<p>Java与C++定义继承类的方式十分相似。Java用关键字extends代替了C++的冒号(:)。在Java中，所有的继承都是公有继承，而没有C++中的私有继承和保护继承。</p>
<blockquote>
<p>调用超类及虚拟方法</p>
</blockquote>
<p>在Java中使用关键字super调用超类的方法，而在C++中则采用超类名加上::操作符的形式。</p>
<p>在Java中，不需要将方法声明为虚拟方法。动态绑定是默认的处理方式。如果不希望让一个方法具有虚拟特性，可以将它标记为final。</p>
<blockquote>
<p>根类</p>
</blockquote>
<p>C++中没有类似Java中Object的根类，不过每个指针都可以转换成<code>void*</code>。</p>
<h2 id="u9644_u5F552_Java_u6CE8_u91CA_u4E0E_u8B66_u544A"><a href="#u9644_u5F552_Java_u6CE8_u91CA_u4E0E_u8B66_u544A" class="headerlink" title="附录2 Java注释与警告"></a>附录2 Java注释与警告</h2><ul>
<li><code>System.out</code>中的<code>println</code>方法输出后自动换行，而<code>print</code>方法不换行。</li>
<li><code>/*...*/</code>注释不能嵌套。</li>
<li>Java有一个能够表示任意精度的算数包，通常称为大数值”(big number)，并不是一种新的类型，而是一个Java对象。</li>
<li>在JDK5.0中，可以使用十六进制表示浮点数值，使用p表示指数，尾数采用十六进制，指数采用十进制。指数的基数是2。</li>
<li>浮点数值不适用于禁止出现舍入误差的金融计算中。</li>
<li><code>&amp;</code> 和 <code>|</code> 运算符应用于布尔值，得到的结果也是布尔值，不按短路”方式计算。</li>
<li>如果试图将一个数值从一种类型强制转换为另一种类型，而又超出了目标类型的表示范围，就会成为一个完全不同的值。</li>
</ul>
<p>因为输入是可见的，所有Scanner类不适用于从控制台读取密码。Java SE 6特别引入了Console类实现这个目的。要想读取一个密码，可以采用下列代码</p>
<pre><code>Console cons = System.console();
String username = cons.readLine(User name: ”);
char[] passwd = cons.readPassword(Password: ”);
</code></pre><p>为了安全起见，返回的密码存放在一维字符数组中，而不是字符串中。在对密码进行处理后，应该马上用一个填充值覆盖数组元素。采用Console对象处理输入不如采用Scanner对象方便。</p>
<ul>
<li>可以构造一个带有字符串参数的Scanner，但这个Scanner将字符串解释为数据，而不是文件名。</li>
<li>在循环中，检测两个浮点数是否相等需要格外小心。</li>
<li>可以使用下面两种形式声明数组：<code>int[] a;</code> 或 <code>int a[];</code> 大多数Java应用程序员喜欢第一种。</li>
<li>在Java中允许数组长度为0。数组长度为0与null不同。</li>
<li>类的方法在前面，域在后面这种风格有易于促使人们更加关注接口的概念，削减对实现的注意。</li>
<li>不要在构造器中定义与实例域重名的局部变量。</li>
<li>注意不要编写返回引用可变对象的访问器方法，这样会破坏封装性！如果需要返回一个可变对象的引用，应该首先对它进行克隆(clone)。</li>
<li>在绝大多数的面型对象程序设计语言中，静态域被称为类域。术语<code>static</code>只是沿用了C++的叫法，并无实际意义。</li>
<li>可以使用对象调用静态方法。不过这种方式很容易造成混淆，建议使用类名来调用静态方法。</li>
<li>每一个类可以有一个<code>main</code>方法。这是一个常用于对类进行单元测试的技巧。</li>
<li>Java允许重载任何方法。因此，要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的签名(signature)。返回类型不是方法签名的一部分。</li>
<li>如果文档中有到其他文件的链接，例如，图像文件(用户界面的组建的图表或图像等)，就应该将这些文件放到子目录<code>doc-files</code>中。<code>javadoc</code>实用程序将从源目录拷贝这些目录中及其中的文件到文档目录中。在联接种需要使用<code>doc-files</code>目录，例如：<code>&lt;img src=doc-files/uml.png” alt = UML diagram”&gt;</code>。</li>
<li>注释时没必要在每一行开始用星号<code>*</code>，大部分IDE会自动添加星号<code>*</code>。</li>
<li>关键字<code>this</code>有两个用途：一是引用隐式参数，二是调用该类其他的构造器。同样，<code>super</code>关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。</li>
<li>在覆盖一个方法时，子类方法不能低于超类方法的可见性。特别是，如果超类方法是<code>public</code>，子类方法一定要声明为<code>public</code>。</li>
<li>域也可以被声明为<code>final</code>，一旦如此，构造对象之后就不允许修改其值了。不过如果将一个类声明为<code>final</code>，只有其中的方法自动称为<code>final</code>，而不包括域。</li>
<li>强烈建议为自定义的每一个类增加<code>toString</code>方法。这样做不仅自己受益，而且所有使用这个类的程序员也会受益匪浅。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里是我学习 Java 黄皮书时记录整理的笔记，时间比较久远，不保证时效性。</p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://wdxtub.com/tags/Java/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cpp 学习笔记]]></title>
    <link href="http://wdxtub.com/2016/03/20/cpp-note/"/>
    <id>http://wdxtub.com/2016/03/20/cpp-note/</id>
    <published>2016-03-20T12:00:11.000Z</published>
    <updated>2016-03-20T12:49:03.000Z</updated>
    <content type="html"><![CDATA[<p>这里是我学习《Thinking in C++》时记录整理的笔记，时间比较久远，不保证时效性。</p>
<a id="more"></a>
<hr>
<h2 id="u7B2C1_u7AE0__u5BF9_u8C61_u5BFC_u8A00"><a href="#u7B2C1_u7AE0__u5BF9_u8C61_u5BFC_u8A00" class="headerlink" title="第1章 对象导言"></a>第1章 对象导言</h2><p>本章将介绍面向对象程序设计(OOP)的基本概念，包括OOP开发方法的概述。</p>
<p>所有的程序语言都提供抽象。可以说，人们能解决的问题的复杂性直接与抽象的类型和质量有关。汇编语言时对底层机器的小幅度抽象。其后的许多所谓“命令式”语言(例如Fortran、Basic和C)都是对汇编语言的抽象。OPP允许程序员用问题本市的术语来描述问题，而不是用要运行解决方案的计算机的术语来描述问题。每个对象看上去像一台小计算机，它有状态，有可执行的运算。这似乎是现实世界中对象的很好类比，它们都有特性和行为。</p>
<p>面向对象语言的五个基本特性：</p>
<ol>
<li>万物皆对象。</li>
<li>程序就是一组对象，对象之间通过发送消息互相通知做什么。</li>
<li>每个对象都有它子集的由其他对象构成的存储区。</li>
<li>每个对象都有一个类型。</li>
<li>一个特定类型的所有对象都能接收相同的消息。</li>
</ol>
<p>创建抽象数据类型是面向对象程序设计的基本思想。抽象数据类型几乎能完全像内部类型一样工作。</p>
<p>类描述了一组有相同特性(数据元素)和相同行为(功能)的对象，因此类实际上就是数据类型。面向对象程序设计的难题之一，是在问题空间中的元素和解空间中的对象之间建立一对一的映射。</p>
<p>必须有一种方法能向对象作出请求，使得它能做某些事情。可以向对象发出的请求是由它的<code>接口(interface)</code>定义的，而接口由类型确定。接口规定我们能向特定的对象发出什么请求。然后，必须有代码满足这种请求，再加上隐藏的数据，就组成了<code>实现(implementation)</code>。</p>
<p>C++语言使用了三个明确的关键字来设置类中的边界：<code>public</code>、<code>private</code>和<code>protected</code>。<code>public</code>意味着随后的定义对所有人都可用。相反，<code>private</code>关键字则意味着，除了该类型的创建者和该类型的内部成员函数之外，任何人都不能访问这些定义。继承的类可以访问<code>protected</code>成员，但不能访问<code>private</code>成员。</p>
<p>代码重用是面向对象程序设计语言的最大优点之一。可以用任何数量和类型的其他对象组成新类，通过组合得到新类所希望的功能。因为这是由已经存在的类组成新类，所以称为<code>组合(composition)</code>【或者更通常称为<code>聚合(aggregation)</code>】。组合常常被称为<code>has-a(有)</code>关系。</p>
<p>当创建新类时，程序员应当首先考虑组合，因为它更简单和更灵活。如果采用组合的方法，设计将变得清晰。</p>
<p>克服许多困难去创造一个类，并随后强制性地创造一个有类似功能地全新地类，似乎很愚蠢。如果能选取已存在地类、克隆它，然后对这个克隆增加和修改，则是再好不过地事。这是<code>继承(inheritance)</code>带来地好处，缺点是，如果原来的类(称为基类、超类或父类)被修改，则这个修改过的“克隆”(称为派生类、继承类或子类)也会表现出这些改变。</p>
<p>当我们从已经存在的类型来继承时，我们就创造了一个新类型。这个新类性不仅包含那个已经存在的类型的所有成员，还复制了这个基类的接口，这意味着这个派生类与这个基类是相同类型的。</p>
<p>有两种方法能使新派生类区别于原始基类。第一种相当直接，简单地向派生类添加全新的函数。这些新函数不是基类接口的一部分。着意味着，这个基类不能做我们希望它做的事情，所以必须添加函数。</p>
<p>虽然继承有时意味着向接口添加新函数，但这未必真的需要。是新类有别于基类的第二个和更重要的方法是，改变已经存在的基类函数的行为，这称为<code>重载(overriding)</code>这个函数。为了重载函数，可以简单地再派生类中创建新定义。相当于说：“我正再使用同一个接口函数，但是我希望它为我做不同的事情。”</p>
<p>只重载基类(并且不添加基类中没有的新成员函数)的继承意味着派生类和基类是完全相同的类型，因为它们有相同的接口。结果是，我们可以用派生类的对象代替基类的对象。因此这被认为是<code>纯代替(pure substitution)</code>，常常被称为<code>代替原则(substitution principle)</code>。这种情况下，我们常把基类和派生类直接的关系看作是一个<code>is-a(是)</code>关系。</p>
<p>有时需要向一个派生类型添加新的接口元素，这样就扩展了接口并创建了新类型。这个新类型仍然可以代替这个基类，但这个代替不是完美的，因为这些新函数不能从基类访问，这可以描述为“is-like-a(像)”关系。</p>
<p>如果试图把派生类型的对象看做是比它们自身更一般的基本类型(圆形看做形体，自行车看做车辆)，这里就有一个问题：如果一个函数告诉一个一般的形体去绘制它子集，或者告诉一个一般的车辆去行驶，则编译器再编译时就不能确切地知道应当执行哪段代码。同样地问题是，消息发送时，程序员并不想知道将执行哪段代码。编译器不能确切地知道执行哪段代码，那么它应该怎么办呢？</p>
<p>在面向对象的程序设计中，答案非常新奇：编译器并不做传统意义上的函数调用。非OOP编译器产生的函数调用会导致与被调用代码的<code>早捆绑(early binding)</code>，其意思是：编译器会对特定的函数名产生调用，而连接器将这个调用解析为要执行代码的绝对地址。</p>
<p>在OOP中，知道程序运行时，编译器才能确定执行代码的地址，所以，当消息被发送给一般对象时，需要采用其他的方案。为了解决这一问题，面向对象语言采用<code>晚捆绑(late binding)</code>的思想。当给对象发送消息时，在程序运行时才去确定被调用的代码。编译器保证这个被调用的函数存在，并执行参数和返回值的类型检查【其中不采用这种处理方式的语言称为<code>弱类型(weakly typed)</code>语言】，但是它并不知道将执行的确切代码。</p>
<p>为了执行晚捆绑，C++编译器在真正调用的地方插入一段特殊的二进制代码。通过使用存放在对象自身中的信息，这段代码在运行时计算被调用函数函数体的地址(详见第15章)。这样每个对象就能根据这段二进制代码的内容有不同的行为。当一个对象接收到消息时，它根据这个消息判断应当做什么。</p>
<p>我们可以用关键字<code>virtual</code>声明他希望某个函数有晚捆绑的灵活性。在C++中，必须记住添加<code>virtual</code>关键字，因为根据规定，默认情况下成员函数不能动态捆绑。<code>virtual</code>函数(虚函数)可用来表示出在相同家族中的类具有不同的行为。这些不同是产生多态行为的原因。<br>我们把处理派生类型就如同处理其基类型的过程称为<code>向上类型转换(upcasting)</code>。编译器和运行系统可以处理这些细节，我们只需要知道它会这样做和知道如何用它设计程序就行了。如果一个成员函数是<code>virtual</code>的，则当我们给一个对象发送消息时，这个对象将做正确的事情，即使是在有向上类型转换的情况下。</p>
<p>对象的数据存放在何处？如何控制对象的生命期？不同的设计语言有不同的处理方式。C++才去的方法是把效率控制作为最重要的问题，所以它为程序员提供了一个选择。为了最大化运行速度，通过将对象存放在栈中或静态存储区域中，存储和生命期可以在编写程序时确定。栈是内存中的一个区域，可以直接由微处理器在程序执行期间存放数据。在栈中的变量有时称<code>自动变量(automatic variable)</code>或<code>局部变量(scoped variable)</code>。静态存储区简单说是内存的一个固定块，在程序开始执行以前分配。使用栈或静态存储区，可以快速分配和释放，但是我们因此也牺牲了灵活性。</p>
<p>第二种方法是在称为<code>堆(heap)</code>的区域动态创建对象。用这种方法，可以直到运行时还不知道需要多少个对象，它们的生命期是什么和他们的准确数据类型是什么。这些决定是在程序运行之中作出的。如果需要心的对象，直接使用<code>new</code>关键字让它在堆上生成。当使用结束时，用关键字<code>delete</code>释放。</p>
<p>另一个问题是对象的生命期。如果在栈上或在静态存储上创建一个对象，编译器决定这个对象持续多长时间并能自动销毁它。然后，如果在堆上创建它，编译器则不知道它的生命期。在C++中，程序员必须编程决定何时销毁此对象。作为一个替换，运行环境可以提供一个称为<code>垃圾收集器(garbage collector)</code>的功能。当然，使用垃圾收集器编写程序是非常方便的，但是它需要所有应用软件能承受垃圾收集器的存在及垃圾收集的系统开销。</p>
<p>从程序设计语言出现开始，错误处理就是最重要的问题之一。因为设计一个好的错误处理方案非常困难，许多语言忽略这个问题，将这个问题转交给库的设计者，而库的设计者往往采取不彻底的措施，即可以在许多情况下起作用，但很容易被绕考，通常是被忽略。</p>
<p><code>异常处理(exception handling)</code>将错误处理直接与程序设计语言甚至有时是操作系统联系起来。异常是一个对象，它在出错的地方被抛出，并且被一段用以处理特定类型错误的<code>异常处理代码(exception handler)</code>所接收。异常处理似乎是另一个并行的执行路径，在出错的时候被调用。由于它使用一个单独的执行路径，它并不需要干涉正常的执行代码。因为不需经常检查错误，代码可以很简洁。另外，异常并不同于一个由函数返回的错误值或标记，后两者可以被忽略，而异常不能被忽略，必须保证它们在某些点上进行处理。最后，异常提供了一个从错误状态中进行可靠恢复的方法。除了从这个程序中退出以外，我们常常还可以作出正确的设置，并且回复程序执行，这有助于产生更健壮的系统。</p>
<p><code>方法(method)</code>［通常称为方法论(methodology)］是一系列的过程和探索，用以降低程序设计问题的复杂性。</p>
<p>经历开发过程时，最重要的问题是：不要迷路。如果不定因素不止一个，在没有创建一个能工作的原型之前，不要计划它将用多长时间和花费多少，这里的自由度太大了。</p>
<p>应当牢记我们正在努力寻找的是什么：</p>
<ul>
<li>什么是对象(如何将项目分成多个组成部分？)</li>
<li>它们的接口是什么？(需要向每个对象发送什么信息？)</li>
<li>整个过程可以分5个阶段完成，阶段0只是使用一些结构的初始约定。</li>
</ul>
<p>我们必须首先决定在此过程中应当有哪些步骤。无论建造什么系统，不管如何复杂，都有其基本的目的，有其要处理的业务，有所满足的基本需要。通过各种观察，我们将最终找出它的核心，通常简单而又直接。</p>
<p>这个相当重要，因为它设定了项目的基调，这是一种任务陈述。我们不必一开始就让它正确，但是要不停地努力使其越来越正确。</p>
<p>这一阶段我们有必要把注意力始终放在核心问提上：确定这个系统要做什么。为此，最有价值的工具是一组所谓的<code>用例(use case)</code>。用例之明了系统中的关键特性，它们将展现我们使用的一些节本的类。它们实际上是对类似于下列问题的描述性回答：</p>
<ul>
<li>“谁将使用这个系统？”</li>
<li>“执行者用这个系统做什么？”</li>
<li>“执行者如何用这个系统工作？”</li>
<li>“如果其他人也做这件事，或者同一个执行者有不同的目标，该怎么办？(揭示变化)”</li>
<li>“当使用这个系统时，会发生什么问题？(揭示异常)”</li>
</ul>
<p>只要符合用户的使用感受，系统实际上如何实现并不重要。</p>
<p>在这一阶段，我们必须作出设计，描述这些类和它们如何交互。确定类和交互的出色技术就是：<strong>类职责协同(Class-Responsibility-Collaboration，CRC)卡片</strong>。</p>
<p>这个技术非常简单：只要有一组小空白卡片，在上面书写。每张卡片描述一个类，所写的内容有：</p>
<ul>
<li>类的名字。体现类行为的本质，一目了然的作用。</li>
<li>类的职责。它应当做什么。通常，它可以仅由成员函数的名字陈述。</li>
<li>类的协同：它与其他类有哪些交互？如果一张小卡片上放不下类所需要的信息，那么这个类就太复杂了(或者是考虑过细了，或者应当创建多个类)。理想的类应该一目了然。</li>
</ul>
<p>对象开发准则：</p>
<ul>
<li>让特定问题生成一个类，然后在解决其他问题期间让这个类生长和成熟。</li>
<li>记住，发现所需要的类(和它们的接口)，是设计系统的主要内容。如果已经有了那些类，这个项目就不困难了。</li>
<li>不要强迫自己在一开始就知道每一件事情，应当不断学习。</li>
<li>开始编程，让一部分能够运行，这样就可以证明或否定已生成的设计。不要害怕过程型大杂烩式的代码──类的隔离性可以控制它们。坏的类不会破坏好的类。</li>
<li>尽量保持简单。具有明显用途的不太清楚的对象比很复杂的接口好。从小的和简单的类开始，当我们对它有了较好的理解时再拓展这个类接口，但是很难从一个类中删去元素。</li>
</ul>
<p>这是从粗线条设计向便宜和执行可执行代码体的最初转换阶段，特别是，它将证明或者否定我们的体系结构。这不是一遍的过程，而是反复地建立系统的一系列步骤的开始。</p>
<p>一旦代码框架运行起来，我们增加的每一组特征本身就是一个小项目。在一次<code>迭代(iteration)</code>期间，我们增加一组特征，一次迭代是一个相当短的开发时期。</p>
<p>理想情况下，每次迭代为一到三个星期，在这个期间的最后，我们得到一个集成的、测试过的、比前一周期有更多功能的系统。</p>
<p>通过这些过程，我们可以更早地揭露和解决严重问题，客户有足够的机会改变它们的意见，程序员会更满意，能更精确地掌握项目。</p>
<p>这是开发周期中，传统上称为“维护”的一个阶段。我们不可能第一次就使软件正确，所以应当为学习、返工和修改留有余地。</p>
<p>“使软件正确”的意思不只是使程序按照要求和用例工作，还意味着我们理解代码的内部结构，并且认识到它能很好地协同工作，没有拙笨的语法和过大的对象，也没有难看的暴露的代码。</p>
<p>提出一个漂亮的方案感觉上更接近于艺术，而不是技术。精致总是有回报的，这不是一种虚浮的追求。它不仅给除了一个容易建造和调试的程序，而且容易理解和维护，这就是其经济价值的体现。</p>
<p>XP既是程序设计工作的哲学，又是做程序设计的一组原则。有两个原则最重要：“先写测试”和“结对编程”。</p>
<p>先写测试有两个及其重要的作用：</p>
<ul>
<li>它强制类的接口有清楚的定义。</li>
<li>能在每次编连软件时运行这些测试。</li>
</ul>
<p><code>结对编程(pair programming)</code>反对深植于我们心中的个人主义，一个人编写代码时另一个人在思考。思考者的头脑中保持总体概念，不仅是手头问题这一段，而且还有XP指导方针。这种结对方式，使事情顺畅、有章可循。</p>
<h2 id="u7B2C2_u7AE0__u5BF9_u8C61_u7684_u521B_u5EFA_u4E0E_u4F7F_u7528"><a href="#u7B2C2_u7AE0__u5BF9_u8C61_u7684_u521B_u5EFA_u4E0E_u4F7F_u7528" class="headerlink" title="第2章 对象的创建与使用"></a>第2章 对象的创建与使用</h2><h3 id="u8BED_u8A00_u7684_u7FFB_u8BD1_u8FC7_u7A0B"><a href="#u8BED_u8A00_u7684_u7FFB_u8BD1_u8FC7_u7A0B" class="headerlink" title="语言的翻译过程"></a>语言的翻译过程</h3><p>任何一种计算机语言都要从某种人们理解的形式(源代码)转化成计算机能执行的形式(机器指令)。通常，翻译器分为两类：<code>解释器(interpreter)</code>和<code>编译器(compiler)</code>。</p>
<p><strong>解释器(interpreter)</strong></p>
<p>将源代码转化成一些动作并立即执行这些动作。使用解释器有许多好处。从写代码到执行代码的转换几乎能立即完成，并且源代码总是显存，所以一旦出现错误，解释器能很容易地指出。另外的优点是较好的交互性和适于快速程序开发。</p>
<p>做大项目时候就有某些局限性。要求一次输入整个源代码，一旦出现错误，就很难调试。</p>
<p><strong>编译器(compiler)</strong></p>
<p>编译器直接把源代码转化成汇编语言或机器指令。某些语言可以分别编译各段程序，最后使用<code>连接器(linker)</code>把各段程序连接成一个完整的可执行程序。这个过程称为<code>分段编译(separate compilation)</code>。</p>
<p>某些语言(特别是C/C++)编译时，首先要对源代码执行预处理。<code>预处理器(preprocessor)</code>是一个简单的程序，用程序员(利用预处理器指令)定义好的模式代替源代码中的模式。</p>
<p>编译一般分两遍进行。首先，对预处理过的代码进行语法分析。编译器把源代码分解成小的单元并把它们按树形结构组织起来。有时候会在编译的第一遍和第二遍之间使用<code>全局优化器(global optimizer)</code>来生成更短、更快的代码。</p>
<p>编译的第二遍由<code>代码生成器(code generator)</code>遍历语法分析树，把树的每个节点转化成汇编语言或机器代码。</p>
<p><code>类型检查(type checking)</code>是编译器在第一遍中完成的。类型检查是检查函数参数是否正确使用，以防止许多程序设计错误。由于类型检查是在编译阶段而不是程序运行阶段进行的，所以称之为<code>静态类型检查(static type checking)</code>。在C++里可以不使用静态类型检查。我们可以自己做动态类型检查──这只需要写一些代码。</p>
<h2 id="u7B2C3_u7AE0_C++_u4E2D_u7684C"><a href="#u7B2C3_u7AE0_C++_u4E2D_u7684C" class="headerlink" title="第3章 C++中的C"></a>第3章 C++中的C</h2><p>全局变量是在所有函数体的外部定义的，程序的所有部分(甚至其他文件中的代码)都可以使用。全局变量不受作用域的影响，总是可用的(也就是说，全局变量的生命期一直到程序的结束)。如果在一个文件中存在全局变量，那么这个文件可以使用这个数据。</p>
<p>局部变量出现在一个作用域内，它们是局限于一个函数的。局部变量经常被称为<code>自动变量(automatic variable)</code>，因为它们在进入作用域时自动生成，离开作用域时自动消失。<br>寄存器变量是一种局部变量，最好避免使用关键字<code>register</code>。</p>
<p>关键字<code>static</code>有一些独特的意义。通常，函数中定义的局部变量在函数作用域结束时小时。当再次调用这个函数时，会重新创建该变量的存储空间，其值会被重新初始化。如果想使局部变量的值在程序的整个生命期里仍然存在，就可以定义函数的局部变量为<code>static</code>，并给它一个初始值。初始化只在函数第一次调用时执行，函数调用之间变量的值保持不变。用这种方式，函数可以“记住”函数调用之间的一些信息片段。</p>
<p><code>static</code>变量的优点是在函数范围之外它是不可用的，所以它不可能被轻易地改变。这会使错误局部化。</p>
<p><code>static</code>的第二层意思和前面的含义相关，即“在某个作用域外不可访问”。当应用<code>static</code>于函数名和所有函数外部的变量时，它的意思是“在文件的外部不可以使用这个名字”。函数名或变量是局部于文件的；我们说它具有<code>文件作用域(file scope)</code>。即使在另一个文件用<code>extern</code>声明，连接器也不会找到它。</p>
<p><code>extern</code>关键字告诉编译器存在着一个变量和函数，即使编译器在当前编译的文件中没有看到它，这个变量或函数可能在另一个文件中或者在当前文件的后面定义。</p>
<p><strong>连接(linkage)</strong></p>
<p>连接用连接器所见的方式描述存储空间。连结方式有两种：<code>内部连接(internal linkage)</code>和<code>外部连接(external linkage)</code>。内部连接意味着只对正被编译的文件创建存储空间。用内部连接，别的文件可以使用相同的标识符或全局变量，连接器不会发现冲突──也就是为每一个标识符创建单独的存储空间。在C和C++中，内部连接是由关键字static指定的。</p>
<p>外部连接意味着所有被编译过的文件创建一片单独的存储空间。一旦创建存储空间，连接器必须解决所有对这片存储空间的引用。</p>
<p>所有的运算符都会从它们的操作数中产生一个值。除了赋值、自增、自减运算符之外，运算符所产生的值不会修改操作数。修改操作数被称为<code>副作用(side effect)</code>。一般使用修改操作数的运算就是为了产生这种副作用。</p>
<p>可以作为一个运算符用于分隔表达式。在这种情况下，它只产生最后一个表达式的值。在逗号分隔的列表中，其余的表达式的计算只完成它们的副作用。</p>
<p>通常，除了作为一个分隔符，逗号最好不作他用，因为人们不习惯把它看作是运算符。</p>
<h2 id="u7B2C4_u7AE0__u6570_u636E_u62BD_u8C61"><a href="#u7B2C4_u7AE0__u6570_u636E_u62BD_u8C61" class="headerlink" title="第4章 数据抽象"></a>第4章 数据抽象</h2><p>库只是他人已经写好的一些代码，按照某种方式包装在一起。通常，最小的包是带有拓展名(如lib)的文件和向编译器声明库中有什么的一个或多个头文件。在跨越多种体系结构的平台(例如Linux和Unix)上，通常，提供库的最明智的方法是使用源代码，这样它就能在心的目标机上被重新配置和编译。</p>
<p>所以，库大概是改进生产效率的最重要的方法。C++的主要设计目标之一就是使库使用起来更加容易。</p>
<p>在C++中，对象就是变量，它的最纯正的定义是“一块存储区”(更明确的说法是，“对象必须有惟一的标识”，在C++中是一个惟一的地址)。它是一块空间，在这里能存放数据，而且还隐含着对这些数据进行处理的操作。</p>
<p>将数据连同函数捆绑在一起的能力可以用于创建新的数据类型。这常常被称为封装(encapsulation)。称为抽象数据类型(abstract data type)，也许这是因为它能允许从问题空间抽象概念到解空间。对抽象数据类型[有时称为用户定义类型(user-defined type)]的类型检查就像对内建类型的类型检查一样严格。</p>
<p>头文件是我们和我们的库的用户之间的合约。这份合约描述了我们的数据结构，为函数调用贵点了参数和返回值。</p>
<p>通过要求我们在使用结构和函数之前声明所有这些结构和函数，在定义成员函数之前声明这些成员函数，编译器强制履行这个合约。</p>
<p>放到头文件中的基本原则是“只限于声明”，即只限于对编译器的信息，不涉及通过生成代码或创建变量而分配存储的任何信息。</p>
<p>对于包含结构的每个头文件，应当首先检查这个头文件是否已经包含在特定的cpp文件中，如：</p>
<pre><code>#ifndef HEADER_FLAG
#define HEADER_FLAG
// Type declaration here...
#endif // HEADER_FLAG
</code></pre><p>防止多次包含的这些预处理器语句常常称为包含守卫(include guard)。</p>
<h2 id="u7B2C5_u7AE0__u9690_u85CF_u5B9E_u73B0"><a href="#u7B2C5_u7AE0__u9690_u85CF_u5B9E_u73B0" class="headerlink" title="第5章 隐藏实现"></a>第5章 隐藏实现</h2><p>在任何关系中，设立相关各方面都遵从的边界是很重要的。需要控制对结构成员的访问有两个理由：一是让客户程序员远离一些它们不需要使用的工具，这些工具对数据类型内部的处理来说是必需的，但对客户程序员解决特定问题的接口却不是必须的。另一个理由是允许库的设计者改变struct的内部实现，而不必担心会对客户程序员产生影响。</p>
<p>引进了三个<code>访问说明符(access specifier)</code>：<code>public</code>、<code>private</code>和<code>protected</code>。无论什么时候使用访问说明符，后面必须加一个冒号。</p>
<ul>
<li><code>public</code>意味着在其后声明的所有成员可以被所有的人访问。</li>
<li><code>private</code>关键字则意味着，除了该类型的创建者和类的内部成员函数之外，任何人都不能访问。</li>
<li><code>protected</code>与<code>private</code>基本相似，只有一点不同：继承的结构可以访问<code>protected</code>成员，但不能访问<code>private</code>成员。</li>
</ul>
<p>如果想允许显示地不属于当前结构的一个成员函数访问当前结构中的数据，可以在该结构内部声明这个函数为<code>friend(友元)</code>。注意，一个<code>friend</code>必须在一个结构内声明，这一点很重要。</p>
<p>嵌套的结构并不能自动获得访问private成员的权限。要获得访问私有成员的权限，必须存手特定的规则：首先声明(而不定义)一个嵌套的结构，然后声明它是全局范围使用的一个<code>friend</code>，最后定义这个结构。结构的定义必须与<code>friend</code>声明分开，否则编译器将不把它看做成员。</p>
<p>C++不是完全的面向对象语言，而只是一个混合产品。增加friend关键字就是为了用来解决一些实际问题。这也说明了这种语言是不纯的。毕竟C++语言的设计目的是使用，而不是追求理想的抽象。</p>
<p>访问说明符是结构的一部分，它们并不影响从这个结构创建的对象。程序开始运行之前，所有的访问说明信息都消失了。访问说明信息通常是在编译期间消失的。</p>
<p>一般说来，在程序员编写程序时，依赖特定实现的任何东西都是不合适的。如确有必要，这些特定实现部分应封装在一个结构之内，这样当环境改变时，只需修改一个地方就行了。</p>
<p>访问控制通常是指<code>实现细节的隐藏(implementation hiding)</code>。将函数包含到一个结构内(常称为封装)来产生一种带数据和操作的数据类型，由访问控制在该数据类型之内确定边界。</p>
<p>然后在C++中的<code>class</code>逐渐变成了一个非必要的关键字。它和<code>struct</code>的每个方面都是一样的，除了class中的成员默认为<code>private</code>，而<code>struct</code>中的成员默认为<code>public</code>。</p>
<p>C++中的访问控制允许将实现部分与接口部分分开，但实现部分的隐藏是不完全的。编译器仍然必须知道一个对象所有部分的声明。但C++要尽可能多地在编译期间作静态类型检查。这意味着尽早捕获错误，也意味着程序具有更高的效率。然后包含似有实现部分会带来两个影响：一是既是客户程序员不能轻易地访问私有实现部分，但可以看到它；二是造成一些不必要的重复编译。</p>
<p>有些项目不可让最终客户程序员看到其实现部分，就有必要把一个变一号的实际结构放在实现文件中，而不是让其暴露在头文件中。</p>
<p>在我们的编译环境中，当一个文件被修改，或它所依赖的头文件被修改时，项目管理员需要重复编译该文件。这意味着程序员无论何时修改了一个类，无论修改的是公共的接口部分，还是私有成员的声明部分，他都必须再次编译包含头文件的所有文件。这就是通常所说的<code>易碎的基类问题(fragile base-class problem)</code>。对于一个大的项目而言，在开发初期这可能非常难以处理，因为内部实现部分可能需要经常改动。如果这个项目非常大，用于编译的时间过多可能妨碍项目的快速转型。</p>
<p>解决这个问题的技术有时称为<code>句柄类(handle class)</code>或称为<code>Cheshire cat</code>。有关实现的任何东西都消失了，只剩一个单指针“smile”。该指针指向一个结构，该结构的定义与其所有的成员函数的定义一同出现在实现文件中。这样，只要接口部分不改变，头文件就不需变动，而实现部分可以按需要任意更改，完成后只需要对实现文件进行重新编译，然后重新连接到项目中。</p>
<h3 id="u7B2C6_u7AE0__u521D_u59CB_u5316_u4E0E_u6E05_u9664"><a href="#u7B2C6_u7AE0__u521D_u59CB_u5316_u4E0E_u6E05_u9664" class="headerlink" title="第6章 初始化与清除"></a>第6章 初始化与清除</h3><p>C++中，初始化和清楚的概念是简化库的使用的关键所在，并可以减少那些在客户程序员忘记去完成这些操作时会引起的细微错误。</p>
<p>类的设计者可以通过提供一个叫做构造函数(constructor)的特殊函数来保证每个对象都被初始化。如果一个类有构造函数，编译器在创建对象时就自动调用这一函数。构造函数的名字与类的名字一样。这样的函数在初始化时会被自动调用。</p>
<p>构造函数和析构函数是两个非常特殊的函数：它们没有返回值。</p>
<p>在程序中创建和消除一个对象的行为非常特殊，就像出生和死亡，而且总是由编译器来调用这些函数以确保它们被执行。如果它们有返回值，要么编译器必须知道如何处理返回值，要么就只能由客户程序员子集来显式的调用构造函数与析构函数，这样一来，安全性就被破坏了。</p>
<p>在一个库中，对于一个曾经用过的对象，如果不做处理，对象就永远不会消失。在C++中，清除就像初始化一样重要，它通过析构函数来保证清除的执行。</p>
<p>析构函数的语言与构造函数一样，用类的名字作为函数名。然而析构函数前面加上一个代字号(～)，以和构造函数区别。</p>
<p>当对象超出它的作用域时，编译器将自动调用析构函数。</p>
<p>在C++中，应该在尽可能靠近变量的使用点处定义变量，并在定义时就初始化。这是出于安全性的考虑，通过减少变量在块中的生命周期，就可以减少该变量在块的其他地方被误用的机会。</p>
<p>集合(aggregate)就是多个事物聚集在一起。这个定义包括混合类型的集合。</p>
<p><code>默认构造函数(default constructor)</code>就是不带任何参数的构造函数。一旦有了一个构造函数，编译器就会确保不关在什么情况下它总是会被调用。</p>
<p>尽管编译器会创建一个默认的构造函数，但是编译器合成的构造函数的行为很少是我们期望的。我们应该把这个特征看成是一个安全网，但尽量少用它。一般说来，应该明确地定义子集的构造函数，而不让编译器来完成。</p>
<h2 id="u7B2C7_u7AE0__u51FD_u6570_u91CD_u8F7D_u4E0E_u9ED8_u8BA4_u53C2_u6570"><a href="#u7B2C7_u7AE0__u51FD_u6570_u91CD_u8F7D_u4E0E_u9ED8_u8BA4_u53C2_u6570" class="headerlink" title="第7章 函数重载与默认参数"></a>第7章 函数重载与默认参数</h2><p>能使名字方便使用，是任何程序设计语言的一个重要特征。</p>
<p>尽管函数重载对构造函数来说是必须的，但是它仍然是一个通用的方便手段，并可以与任意函数一起使用。另外，函数重载意味着，我们有两个库，它们都有同名的函数，只要它们的参数列表不同就不会发生冲突。</p>
<p>可以对不同的函数用同样的名字，只要求函数的参数不同，编译器会修饰这些名字、范围和参数来产生内部名以供它和连接器使用。</p>
<p>仅仅依靠返回值来重载函数实在过于微妙，所以在C++中禁止这样做。</p>
<p>对名字修饰还可以带来一个额外的好处。在C中，如果用户错误地声明了一个函数，或者更糟糕地，一个函数还没声明就调用了，而编译器则按照函数被调用的方式去推断函数的声明。若这样的推断不正确，那么就会变成一个很难发现的错误。</p>
<p>在C++中，所有的恶函数在被使用前都必须事先声明，因此出现上述情况的机会大大减少了。名字修饰会给我们提供一个安全网，这也就是人们常说的<code>类型安全连接(type-safe linkage)</code>。</p>
<p><code>默认参数(default argument)</code>是在函数声明时就已给定的一个值，如果在调用函数时没有指定这一参数的值，编译器就会自动地插上这个值。</p>
<p>在使用默认参数时必须记住两条规则。第一，只有参数列表的后部参数才是可默认的，也就是说，不可以在一个默认参数后面又跟一个非默认的参数。第二，一旦在一个函数调用中开始使用默认参数，那么这个参数后面的所有参数都必须是默认的。</p>
<p>默认参数只能放在函数声明中，通常在一个头文件中。编译器必须在使用该函数之前知道默认值。有时人们为了阅读方便在函数定义处放上你一些默认的注释值。</p>
<h2 id="u7B2C8_u7AE0__u5E38_u91CF"><a href="#u7B2C8_u7AE0__u5E38_u91CF" class="headerlink" title="第8章 常量"></a>第8章 常量</h2><p>常量概念(由关键字const表示)是为了使程序员能够在变和不变之间画一条界线。这在C++程序设计项目中提供了安全性和可控性。</p>
<p>可以使指针成为<code>const</code>。当处理<code>const</code>指针时，编译器仍将努力避免存储分配并进行常量折叠。如果程序员以后想在程序代码中改变<code>const</code>这种指针的使用，编译器将给出通知。这大大增加了安全性。</p>
<p>当使用带有指针的<code>const</code>时，有两种选择：<code>const</code>修饰指针正指向的对象，或者<code>const</code>修饰在指针里存储的地址。</p>
<p>定义指针的技巧是在标识符的开始处读它并从里向外读。<code>const</code>修饰“最靠近”它的那个。如：<code>const int* u;</code> 可以读成：u是一个指针，它指向一个<code>const int</code>。</p>
<p>使指针本身称为一个<code>const</code>指针，必须把<code>const</code>标明的部分放在<em>的右边。如：`int d = 1; int </em> const w = &d;<code>可以读成</code>w<code>是一个</code>const<code>指针指向一个</code>int`。</p>
<p>因为指针本事现在是<code>const</code>指针，编译器要求给它一个初始值，这个值在指针生命期内不变。然而要干煸它所指向的值是可以的：<code>*w = 2;</code></p>
<p>当然也可以把一个<code>const</code>指针指向一个<code>const</code>对象。</p>
<p>如果可能的话，一行只定义一个指针，并尽可能在定义时初始化。</p>
<p>可以把一个非<code>const</code>对象的地址赋给一个<code>const</code>指针，因为也许有时不想改变某些可以改变的东西。然后不能把一个<code>const</code>对象的地址赋给一个非<code>const</code>指针，因为这样做可能通过被赋值的指针改变这个对象的值。</p>
<p>如果函数是按值传递，则可用指定参数是<code>const</code>的。这里参数不能被改变。所以它其实是函数创建者的工具，而不是函数调用者的工具。</p>
<p>为了不使调用者很小，在函数内部用<code>const</code>限定参数优于在参数表里用<code>const</code>限定参数。可以用一个指针来实现，但更好的语法形式是“引用”。简而言之，引用相一个被自动间接引用的常量指针，它的作用是成为对象的别名。为建立一个引用，在定义里使用<code>&amp;</code>。</p>
<p>如果一个函数的返回值是一个常量(const)，这就约定了函数框架里的原变量不会被修改。另外，因为这是按值返回的，所以这个变量被制成副本，舍得初值不会被返回值所修改。</p>
<p>对于内部类型来说，按值返回的是否是一个const，是无关紧要的，所以按值返回一个内部类型时，应该去掉const，从而不使客户程序员混淆。</p>
<p>当处理用户定义的类型时，按值返回常量是很重要的。如果一个函数按值返回一个类对象为const时，那么这个函数的返回值不能是一个左值(不能被赋值或修改)。</p>
<p>如果传递或返回一个地址(一个指针或一个引用)，客户程序员去取地址并修改其初值是可能的。如果使这个指针或者引用成为const，就会阻止这类事的发生，这是非常重要的事情，事实上，无论什么时候传递一个地址给一个函数，都应该尽可能用const修饰它。如果不这样做，就不能以const指针参数的方式使用这个函数。</p>
<p>常数表达式使用常量的地方之一是在类里。典型的例子是在一个类里建立一个数组，并用const代替#define设置数组大小。数组大小一直隐藏在类里，这样，如果用size表示数组大小，就可以把size这个名字用在另一个类里而不发生冲突。</p>
<p>读者可能认为合乎逻辑的选择是把一个const放在类里。但这样不会产生预期的效果。在一个类里，const又部分恢复到它在C语言中的含义。它在每个类对象里分配存储并代表一个值，这个值一旦被初始化以后就不能改变。在一个类里使用const意味着“在这个对象生命期内，它是一个常量”。然而，对这个常量来讲，每个不同的对象可以含有一个不同的值。</p>
<p>这样，在一个类里建立一个普通的(非static的)const时，不能给它初值。这个初始化工作比须在构造函数里进行，当然，要在构造函数的某个特别的地方进行。因为const必须在建立它的地方被初始化，所以在构造函数的主体里，const必定已被初始化了。否则，就只有等待，直到在构造函数主体以后的某个地方给它初始化，这意味着过一会儿才给const初始化。当然，无法防止在构造函数主体的不同地方改变const的值。</p>
<p><strong>构造函数初始化列表</strong></p>
<p>在构造函数里有个专门初始化的地方，这就是<code>构造函数初始化列表(constructor initializer list)</code>，起初用在机成立。构造函数初始化列表是一个出现在函数参数表和冒号后，但在构造函数主体开头的花括号前的“函数调用列表”。这提醒人们，表里的初始化发生在构造函数的任何代码执行之前。这是初始化所有<code>const</code>的地方，若<code>size</code>是<code>Fred</code>类的一个<code>const</code>成员的话，其正确形式是：</p>
<pre><code>Fred::Fred(int sz) : size(sz){}
</code></pre><p>把一个内部类型风装载一个类里以保证用构造函数初始化，这是很有用的。</p>
<p>若要让类有编译期间的常量成员，就要求使用另外一个关键字<code>static</code>。在这种情况下，关键字<code>static</code>意味着“不管类的对象被创建多少次，都只有一个实例”。因此，一个内部类型的<code>static const</code>可以看作一个编译期间的常量。</p>
<p>必须在<code>static const</code>定义的地方对它进行初始化。</p>
<p>如果声明一个成员函数为<code>const</code>(修饰符<code>const</code>放在函数参数表的后面)，则等于告诉编译器该成员函数可以为一个<code>const</code>对象所调用。一个没有被明确声明为<code>const</code>的成员函数被堪称是将要修改数据成员的函数，而且编译器不允许它为一个<code>const</code>对象所调用。</p>
<p>关键字<code>const</code>必须同样的方式重复出现在定义里，否则编译器把它看成一个不同的函数！<br>一个<code>const</code>成员函数调用<code>const</code>和非<code>const</code>对象是安全的，因此，可以把它看做成员函数的最一般形式。不修改数据成员的任何函数都应该把它们声明为<code>const</code>，这样它可以和<code>const</code>对象一起使用。</p>
<p><code>volatile</code>的语法与<code>const</code>是一样的，但是<code>volatile</code>的意思是“在编译器认识的范围外，这个数据可以被改变”。不知何故，环境正在改变数据(可能通过多任务、多线程或者中断处理)，所以，<code>volatile</code>告诉编译器不要擅自作出有关该数据的任何假定，优化期间尤其如此。</p>
<h2 id="u7B2C9_u7AE0__u5185_u8054_u51FD_u6570"><a href="#u7B2C9_u7AE0__u5185_u8054_u51FD_u6570" class="headerlink" title="第9章 内联函数"></a>第9章 内联函数</h2><p>C++从C中集成的一个重要特征是效率。加入C++的效率显著地低于C的效率，那么就会有很大一批程序员不去使用它。</p>
<p>为了既保持预处理器宏的效率又增加安全性、而且还能像一般成员函数一样可以在类里访问自如，C++引入了内联函数(inline function)</p>
<p>预处理器宏存在问题的关键是我们可能认为预处理器的行为和编译器的行为一样。</p>
<p>在解决C++中宏访问private类成员的问题过程中，所有和预处理器宏有关的问题也随之排除了。这是通过使宏被编译器控制来实现的。在C++中，宏的概念是作为内联函数(inline function)来实现的，而内联函数无论从哪一方面上说都是真正的函数。</p>
<p>任何在类中定义的函数自动成为内联函数，但也可以在非类的函数前面加上inline关键字使之称为内联函数。但为了使之有效，必须使函数体和声明结合在一起，否则，编译器将它作为普通函数对待。</p>
<p>一般应该把内联定义放在头文件里。当编译器看到这个定义时，它把函数类型(函数名+返回值)和函数体放到符号表里。当使用函数时，编译器检查以确保调用是正确的且返回值被正确使用，然后将函数调用替换为函数体，因而消除了开销。内联代码的确占用空间，但假如函数较小，这实际上比为了一个普通函数调用而产生的代码(参数压栈和执行CALL)占用的空间还小。</p>
<p>类内部的内联函数节省了在外部定义成员函数的额外步骤，所以我们一定想在类声明内每一处都使用内联函数。但应记住，使用内联函数的目的是减少函数调用的开销。但是，假如函数较大，由于需要在调用函数的每一处重复复制代码，这样将使代码膨胀，在速度方面获得的好处就会减少。</p>
<p>在类中内联函数的最重要的使用之一是用做<code>访问函数(access function)</code>。这是一个小函数，它容许读或修改对象状态──即一个或几个内部变量。即最通常所说的<code>set</code>与<code>get</code>方法(修改器和访问器)。</p>
<p>对于函数，编译器在它的符号表里放入函数类型(即包括名字和参数类型的函数原型及函数的返回类型)。另外，当编译器看到内联函数和对内联函数体的分析没有发现错误时，就将对应于函数体的代码也放入符号表。代码是以源程序形式存放还是以编译过的汇编指令形式存放取决于编译器。</p>
<p>当调用一个内联函数时，编译器首先确保调用正确，即所有的参数类型必须满足：要么与函数参数表中的参数类型一样，要么编译器能够将其转换为正确类型，并且返回值在目标表达式里应该是正确类型或可改变为正确类型。</p>
<p>有两种编译器不能执行内联的情况。在这些情况下，它就像对非内联函数一样，根据内联函数定义和为函数建立存储空间，简单地将其转换为函数的普通形式。</p>
<p>加入函数太复杂，编译器将不能执行内联。这取决于特定的编译器，但对大多数编译器这时都回放弃内联方式，因为这时内联可能不能提高任何效率。一般地，任何种类的循环都被认为太复杂。</p>
<p>内联仅是编译器的一个建议，编译器不会被强迫内联任何代码。一个好的编译器将会内联小的、简单的函数，同时明智地忽略那些太复杂的内联。这将给我们想要的结果──具有宏效率的函数调用的真正语义学。</p>
<p>当一个内联函数在类中向前引用一个还没有声明的函数时，是可以正常工作的，因为C++语言规定：只有在类声明结束后，其中的内联函数才会被计算。</p>
<h2 id="u7B2C10_u7AE0__u540D_u5B57_u63A7_u5236"><a href="#u7B2C10_u7AE0__u540D_u5B57_u63A7_u5236" class="headerlink" title="第10章 名字控制"></a>第10章 名字控制</h2><p>创建名字是程序设计过程中一项最基本的活动，当一个项目很大时，它会不可避免地包含大量的名字。</p>
<p>关于static的所有使用最基本的概念是指“位置不变的某个东西”，不管这里是指在内存中的物理位置还是指在文件中的可见性。</p>
<p>在C和C++中，static都有两种基本的含义，并且这两种含义经常是相互冲突的：</p>
<ul>
<li>在固定的地址上进行存储分配，也就是说对象是在一个特殊的静态数据区(static data area)上创建的，而不是每次函数调用时在堆栈上产生的。这也是静态存储的概念。</li>
<li>对一个特定的编译单位来说是局部的。这样，static控制名字的可见性(visibility)，所以这个名字在这个单元或类外是不可见的。这也描述了连接的概念，它决定连接器将看到哪些名字。</li>
</ul>
<p>通常，在函数体内定义一个局部变量时，编译器在每次函数调用时使堆栈的指针下移到一个适当的位置，为这些局部变量非配内存。如果这个变量又一个初始化表达式，那么每当程序运行到此处，初始化就被执行。</p>
<p>然而，有时想在两次函数调用之间保留一个变量的值，可以通过定义一个全局变量来实现，但这样一来，这个变量就不仅仅只受到这个函数的控制。C和C++都允许在函数内部定义一个static对象，这个对象将存储在静态数据区中，而不是在堆栈中。这个对象只在第一次调用是初始化一次，以后它将在两次函数调用之间保持它的值。</p>
<p>一般情况下，在<code>文件作用域(file scope)</code>内的所有名字(即不嵌套在类或函数中的名字)对程序中的所有翻译单元来说都是可见的。这就是所谓的<code>外部连接(external linkage)</code>，因为在连接时这个名字对连接器来说是可见的，对单独的翻译单元来说，它是外部的。全局变量和普通函数都有外部连接。</p>
<p>在文件作用域内，一个被明确声明为static的对象或函数的名字对翻译单元来说是局部于该单元的。这些名字有<code>内部连接(internal linkage)</code>。</p>
<p>内部连接的一个好处是这个名字可以放在一个头文件中</p>
<h2 id="u7B2C11_u7AE0__u5F15_u7528_u548C_u62F7_u8D1D_u6784_u9020_u51FD_u6570"><a href="#u7B2C11_u7AE0__u5F15_u7528_u548C_u62F7_u8D1D_u6784_u9020_u51FD_u6570" class="headerlink" title="第11章 引用和拷贝构造函数"></a>第11章 引用和拷贝构造函数</h2><p>C不允许随便地把一个类型的指针赋给另一个类型，但允许通过<code>void*</code>来实现。由于C的这种功能允许把任何一种类型看做别的类型处理，这就在类型系统中流下了一个大的漏洞。C++不允许这样做，如果真想把某种类型当作别的类型处理，则必须显示地使用类型转换。</p>
<p>引用(reference)(&amp;)就像能自动地被编译器间接引用的常量型指针。它常用于函数的参数表中和函数的返回值，但也可以独立使用。</p>
<p>使用引用时有一定的规则：</p>
<ul>
<li>当引用被创建时，它必须被初始化(指针则可以在任何时候被初始化)。</li>
<li>一旦一个引用被初始化为指向一个对象，它就不能改变为另一个对象的引用(指针则可以在任何时候指向另一个对象)。</li>
<li>不可能有NULL引用。必须确保引用是和一块合法的存储单元关联。</li>
</ul>
<p>最经常看见引用的地方是在函数参数和返回值中。当引用被用做函数参数时，在函数内任何对引用的更改将对函数外的参数产生改变。当然，可以通过传递一个指针来做相同的事情，但引用具有更清晰的语法。</p>
<p>如果从函数中返回一个引用，必须像从函数中返回一个指针来一样对待。当函数返回时，无论引用关连的是什么都应该存在，否则，将不知道指向哪一个内存。</p>
<p>若想要改变指针本身而不是它所指向的内容，函数参数变成指针的引用，用不着取得指针的地址。</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
void increment(int*&amp; i){i++}
int main(){
    int *i = 0;
    cout &lt;&lt; “i = ” &lt;&lt; i &lt;&lt; endl;
    increment(i);
    cout &lt;&lt; “i = ” &lt;&lt; i &lt;&lt; endl;
}
</code></pre><p>当给函数传递参数时，人们习惯上是通过常量引用来传递。这种简单习惯可以大大提高效率：传值方式需要调用构造函数和析构函数，然而，如果不想改变参数，则可以通过常量引用传递，它仅需要将地址压栈。</p>
<p>拷贝构造函数是一个更令人混淆的概念，常被称为<code>X(X&amp;)(“X引用的X”)</code>，在函数调用时，这个构造函数是控制通过传值方式传递和返回用户定义类型的根本所在。这是很重要的。</p>
<p>在C和C++中，参数是从右向左进栈的，然后调用函数，调用代码负责清理栈中的参数。但是要注意，通过按值传递方式传递参数时，编译器简单地将参数拷贝压栈──编译器知道拷贝有多大，并知道如何对参数压栈，对它们正确拷贝。</p>
<p>当编译器为函数调用产生代码时，它首先把所有的参数压栈，然后调用函数。在函数内部，产生代码，向下移动栈指针为函数局部变量提供存储单元。</p>
<h2 id="u7B2C13_u7AE0__u52A8_u6001_u5BF9_u8C61_u521B_u5EFA"><a href="#u7B2C13_u7AE0__u52A8_u6001_u5BF9_u8C61_u521B_u5EFA" class="headerlink" title="第13章 动态对象创建"></a>第13章 动态对象创建</h2><p>有时我们能知道程序中对象的确切数量、类型和生命期。但情况不总是这样。为了解决这个普遍的编程问题，在运行时可以创建和销毁对象是最基本的要求。C提供了<code>动态内存分配(dynamic memory allocation)</code>函数<code>malloc()</code>和<code>free()</code>，这些函数在运行时从堆(也称自由内存)中分配存储单元。</p>
<p>然而，在C++中这些函数将不能很好的运行。因为构造函数不允许我们向它传递内存地址来进行初始化。</p>
<p>C++是如何保证正确的初始化和清理，有允许我们在堆上动态创建对象呢？</p>
<p>答案是，使动态对象称为语言的核心。malloc和free是库函数，因此不在编译器控制范围之内。然而，如果我们有一个完成动态内存分配及初始化组合动作的运算符和另一个完成清理及释放内存组合动作的运算符，编译器仍可以保证所有对象的构造函数和析构函数会被调用。</p>
<p>当创建一个C++对象，会发生两件事：</p>
<ul>
<li>为对象分配内存。</li>
<li>调用构造函数来初始化那个内存。</li>
</ul>
<p>到目前为止，因该确保步骤2一定发生。C++强迫这样做是因为未初始化的对象是程序出错的主要原因。对象在那里和如何创建无关紧要──构造函数总是需要被调用。</p>
<p>然而，步骤1可以用几种方式或在可选择的时间发生：</p>
<ul>
<li>在静态存储区域，存储空间在程序开始之前就可以分配。这个存储空间在整个程序运行期间都存在。</li>
<li>无论何时到达一个特殊的执行点(左大括号)时，存储单元都可以在栈上被创建。除了执行点(右大括号)，这个存储单元自动被释放。这些栈分配运算内置于处理器的指令集中，非常有效。然而，在写程序时，必须知道需要多少个存储单元，以便编译器生成正确的指令。</li>
</ul>
<p>存储单元也可以从一块称为堆(也被称为自由存储单元)的地方分配。这被称为动态内存分配。在运行时调用程序分配这些内存。这意味着可以在任何时候决定分配内存及分配多少内存。当然也需负责决定何时释放内存。这块内存的生存期由我们选择决定──而不受范围决定。</p>
<p>为了在运行时动态分配内存，如<code>malloc()</code>和<code>free()</code>。这些函数是有效的但较原始的，需要编程人员理解和小心使用。例如，必须对分配的空间进行显式地类型转换，还需要自行调用初始化的函数(构造函数并不能被显式地调用)。这很容易出错。所以，C程序设计者常常在静态内存区域使用虚拟内存机制分配很大的变量数组以避免使用动态内存分配。为了在C++中使得一般的程序员可以安全使用库函数而不费力，所以C的动态内存方法是不可接受的。</p>
<p>C++中的解决方案是把船舰一个对象所需的所有动作都结合在一个称为new的运算符里。当用new(new的表达式)创建一个对象时，它就在堆里为对象分配内存并为这块内存调用构造函数。等价于调用malloc()函数并调用构造函数。返回一个指向该对象的this指针。</p>
<pre><code>MyType *fp = new MyType;
</code></pre><p>默认的new还进行检查以确信在传递地址给构造函数之前内存分配是成功的，所以不必显式地确定调用是否成功。</p>
<p>我们可以看到，在堆里创建对象的过程变得简单了──只是一个简单的表达式，它带有内置的长度计算、类型转换和安全检查。这样在堆里创建一个对象何在栈里创建一个对象一样容易。</p>
<p><code>delete</code>表达式首先调用析构函数，然后释放内存(常调用free())。正如<code>new</code>表达式返回一个指向对象的指针一样，<code>delete</code>表达式需要一个对象的地址。</p>
<pre><code>delete fp；
</code></pre><p><code>delete</code>只用于删除由<code>new</code>创建的对象。</p>
<p>当在堆栈里自动创建对象时，对象的大小和它们的生存期被准确地内置在生成的代码里，这是因为编译器知道确切的类型、数量和范围。而在堆里创建的对象还包括另外的时间和空间的开销。以下是一个典型情况：</p>
<p>调用<code>malloc()</code>，即从堆里搜索一块足够大的内存来满足请求，可以通过检查按某种方式排列的映射或目录来实现，这样的映射或目录用以显示内存的使用情况。这个过程很快但可能要试探几次，所以它可能是不确定的──即每次运行<code>malloc()</code>并不是花费了相同的时间。</p>
<p>在栈或堆上创建一个对象数组是同样容易的。但这里有一个限制条件：由于不带参数的构造函数必须被每一个对象调用，所以除了在栈上整体初始化外还必须有一个默认的构造函数。</p>
<pre><code>MyType *fp = new MyType[100];
MyType *fp2 = new MyType;
</code></pre><p>我们知道其实fp和fp2是数组的起始地址。</p>
<pre><code>delete fp2; // OK
delete fp; // Not the desired effect
</code></pre><p>对于<code>fp</code>来说，另外99个析构函数没有调用，正确应该这样：</p>
<pre><code>delete []fp；
</code></pre><p>空的方括号告诉编译器产生代码，该代码的任务是将从数组创建时存放在某处的对象数量取回，并为数组的所有对象调用析构函数。</p>
<p>上面定义的fp可以被修改指向任何类型，但这对于一个数组的起始地址来说没有什么意义。一般来讲，把它定义为常量会更好些，因为这样任何修改指针的企图都会被认为出错。</p>
<p>使得指针指向的int不能修改(指针可以修改)：</p>
<pre><code>int const* q = new int[10];   or
const int* q = new int[10];
</code></pre><p>使得指针不能被修改(数组可以修改)：</p>
<pre><code>int * const q = new int[10];
</code></pre><p>当<code>operator new()</code>找不到组够大的连续内存块来安排对象时，一个称为<code>new-handler</code>的特殊函数将会被调用。首先，检查指向函数的指针，如果指针非0，那么它指向的函数将被调用。</p>
<p><code>new-handler</code>的默认动作是产生一个<code>异常(throw an exception)</code>。</p>
<h2 id="u7B2C14_u7AE0__u7EE7_u627F_u548C_u7EC4_u5408"><a href="#u7B2C14_u7AE0__u7EE7_u627F_u548C_u7EC4_u5408" class="headerlink" title="第14章 继承和组合"></a>第14章 继承和组合</h2><p>C++中最重要的特征之一是代码重用。但是如果希望更进一步，就不能仅仅用拷贝代码和修改代码的方法，而是要做更多的工作。</p>
<p>关键技巧是使用这些类，但不修改已存在的代码。第一种方法很直接：我们简单地在心类中创建已存在类的对象。因为新类是由已存在的类的对象组合而成，所以这种方法称为<code>组合(composition)</code>。</p>
<p>第二种方法要复杂些。我们创建一个新类作为一个已存在类的类型。我们不修改已存在的类，而是采取这个已存在类的形式，并将代码加入其中。这种巧妙方法称为<code>继承(inheritance)</code>，其中大量的工作是由编译器完成。继承是面向对象程序设计的基石。</p>
<p>在语法上和行为上，组合和继承大部分是相似的。</p>
<p>组合语法 直接把子对象放入新对象的组成中即可。</p>
<p>访问嵌入对象(称为子对象)的成员的成员函数只需再一次的成员选择。更常见的是把嵌入的对象设为私有，因此它们将称为内部实现的一部分(这意味着如果我们原因，可以改变这个实现)。新类的公有接口函数包括了对嵌入对象的使用，但没有必要模仿这个对象的接口。</p>
<p>当继承时，我们会发现“这个新类很像原来的类”。我们规定，在代码中和原来一样给出该类的名字，但在类的左括号的前面，加一个冒号和基类的名字(对于多重继承，要给出多个基类名，它们之间用逗号分开)。当昨晚这些时，将会自动地得到基类中的所用数据成员和成员函数。</p>
<pre><code>class Y：public X{//......}
</code></pre><p>我们可以看到<code>Y</code>对<code>X</code>进行了继承，这意味着Y将包含X中的所有数据成员和成员函数。所有<code>X</code>中的私有成员在<code>Y</code>中仍然是私有的，因为<code>Y</code>对<code>X</code>进行了继承并不意味着<code>Y</code>可以不遵守保护机制。</p>
<p>这里基类前面是<code>public</code>。由于在继承时，基类中所有的成员都是被预设为私有的，所以如果基类的前面没有<code>public</code>，这意味着基类的所有公有成员将在派生类中变为私有的。这显然不是所希望的，我们希望基类中的所有公有成员在派生类中仍是公有的，这可以在继承时通过使用关键字<code>public</code>来实现。</p>
<p>倘若<code>X</code>和<code>Y</code>类中均有一个<code>set()</code>函数，那么将会使用Y中重新定义的版本。这也就是说，如果不想使用某个继承而来的函数，我们可以改变它的内容。然而，当我们重新定义了一个函数之后，仍可能想调用基类的函数，为了调用基类<code>X</code>的<code>set()</code>函数，必须使用作用域运算符来显示地表明基类名。</p>
<p>在C++中保证正确的初始化是多么重要，这一点在组合和继承中也是一样。当创建一个对象时，编译器确保调用了所有子对象的构造函数。</p>
<p>但是，如果子对象没有默认构造函数或如果想改变构造函数的某个默认参数，就会出现问题，因为这个新类的构造函数没有权利访问这个子对象的私有数据成员，所以不能直接对它们初始化。</p>
<p>解决的方法很简单：对于子函数调用构造函数，C++为此提供了专门的语法，即构造函数的初始化表达式表。构造函数的初始化表达式的形式模仿继承活动。</p>
<p>对于继承，我们把基类至于冒号和这个类体的左括号之间。而在构造函数的初始化表达式中，可以将对子对象构造函数的调用语句放在构造函数参数表和冒号之后，在函数体的左括号之前。对于从Bar继承来的类MyType，如果Bar的构造函数只有一个int型参数，则可以表示为：</p>
<pre><code>MyType::MyType(int i) : Bar(i) { // ...
</code></pre><p>对于组合，也可以对成员对象使用同样语法，只是所给出的不是类名，而是对象的名字。如果在初始化表达式表中有多个构造函数的调用，应当用逗号加以隔开：</p>
<pre><code>MyType2::MyType(int i) : Bar(i), m(i+1) { // ...
</code></pre><p>这是类<code>MyType2</code>构造函数的开头，该类是从<code>Bar</code>继承来的，并且包含一个称为<code>m</code>的成员对象。请注意，虽然可以在这个构造函数的初始化表达式表中看到基类的类型，但只能看到成员对象的标识符。</p>
<p>构造函数的初始化表达式表允许我们显式地调用成员对象的构造函数。它的主要思想是，在进入新类的构造函数体之前调用所有其他的构造函数。这样，对于子对象的成员函数所做的任何调用都总是转到了这个被初始化的对象中。即使编译器可以隐藏地调用默认的构造函数，但在没有对所有的成员对象和基类对象的构造函数进行调用之前，就没有办法进入该构造函数体。这是C++的一个强化的机制，它确保了，如果没有调用对象的构造函数，就别想向下进行。</p>
<p>对于哪些没有构造函数的内部类型嵌入对象，这一切会怎么样？</p>
<p>为了使语法一致，可以把内部类型看做这样一种类型，它只有一个取单个参数的构造函数，而这个参数与正在初始化的变量类型相同。于是可以这么写：</p>
<pre><code>class X {
    int i;
    float f;
    char c;
    char* s;
public:
    X() : i(7), f(1.4), c(‘x’), s(“howdy”) {}
};
</code></pre><p>这些“伪构造函数调用”操作可以进行简单的赋值。这种方法很方便，并且具有良好的编码风格。甚至在类之外创建内部类型的变量是，也可以使用伪构造函数语法。</p>
<p>这使得内部类型的操作有点类似于对象，但是这些并不是真正的构造函数。特别地，如果没有显式的进行伪构造函数调用，初始化是不会执行的。</p>
<p>还可以把组合和继承放在一起使用。</p>
<p><strong>自动析构函数调用</strong></p>
<p>虽然常常需要在初始化表达式表中显式构造函数调用，但并不需要做显式的析构函数调用，因为对于任何类型只有一个析构函数，并且它并不取任何参数。然而，编译器仍要保证所有的析构函数被调用，这意味着，在整个层次中的所有析构函数中，从派生类最底层的析构函数开始调用，一直到根层。</p>
<p>构造是从类层次的最根处开始，而在每一层，首先会调用基类构造函数，然后调用成员对象构造函数。调用析构函数则严格按照构造函数相反的次序──这是很重要的，因为要考虑潜在的相关性(对于派生类中的构造函数和析构函数，必须假设基类子对象仍然可供使用并且已经被构造了──或者还未被消除)。</p>
<p>另一个有趣现象是，对于成员对象，构造函数调用的次序完全不受构造函数的初始化表达式表中的次序影响。该次序是由成员对象在类中声明的次序所决定的。</p>
<p>如果继承一个类并且对它的成员函数重新进行定义，可能会出现两种情况：</p>
<ul>
<li>第一种是正如在基类中所进行的定义一样，在派生类的定义中明确地定义操作和返回类型。这称之为对普通成员函数的重定义(redefining)，而如果基类的成员函数是虚函数的情况，又可称之为重写(overriding)。</li>
<li>任何时候重新定义了基类中的一个重载函数，在新类之中所有其他版本则被自动地隐藏了。</li>
</ul>
<p>如果通过修改基类中一个成员函数的操作与/或返回类型来改变了基类的接口，我们就没有使用继承通常所提供的功能，而是按另一种方式来重用了该类。这并不一定意味着做错了，只是由于继承的最终目标是为了实现<code>多态性(polymorphism)</code>。</p>
<p>不是所有的函数都能自动地从基类继承到派生类中的。构造函数和析构函数用来处理对象的创建和析构操作，但它们只知道对它们的特定层次上的的对象做些什么。所以，在该类以下各个层次中的所有构造函数和析构函数都必须被调用，也就是说，构造函数和析构函数不能被继承，必须为每一个特定的派生类分别创建。</p>
<p>另外，<code>operator=</code>也不能被继承，因为它完成类似于构造函数的活动。</p>
<p>静态(static)成员函数与非静态成员函数的共同点：</p>
<ul>
<li>它们均可被继承到派生类中。</li>
<li>如果我们重新定义了一个静态成员，所有在基类中的其他重载函数会被隐藏。</li>
<li>如果我们改变了基类中一个函数的特征，所有使用该函数名字的基类版本都将会被隐藏。然而，<code>静态(static)</code>成员函数不可以是<code>虚函数(virtual)</code>。</li>
</ul>
<p>组合通常是在希望新类内部具有已存在类的功能时使用，而不是希望已存在类作为它的接口。这就是说，嵌入一个对象用以实现新类的功能，而新类的用户看到的是新定义的接口而不是来自老类的接口。为此，在新类的内部嵌入已存在的<code>private</code>对象。</p>
<p>有时，又希望允许类用户直接访问新类的组成，这就让成员对象是<code>public</code>。由于成员对象使用自己的访问控制，所以是安全的，而当用户了结了我们所做的组装工作时，会更容易理解接口。</p>
<p><code>is-a</code>关系用继承表达，<code>has-a</code>关系用组合表达。</p>
<p>如果由一个已存在的类创建一个新类，并且希望这个类的每件东西都进来，就称为<code>子类型化(subtyping)</code>。这个新类与已存在的类有着严格相同的接口(希望增加任何我们想要加入的其他成员函数)，所以能在已经用过这个已存在的类的任何地方使用这个新类，这就是必须使用继承的地方。</p>
<p>通过在基类表中去掉<code>public</code>或通过显式地声明<code>private</code>，可以私有地继承基类。当私有继承时，我们是“照此实现”；也就是说，创建的新类具有基类的所有数据和功能，但这些功能是隐藏的，所以它只是部分的内部实现。该类的用户访问不到这些内部功能，并且一个对象不能被看做是这个基类的实例。</p>
<p>为了完整性，private继承被包含在该语言中。但是通常希望使用组合而不是private继承。</p>
<p>私有继承时，基类的所有public成员都变成了private。如果希望其中的任何一个是可视的，只要用派生类的public部分声明它们的名字即可</p>
<pre><code>using Pet::eat;
</code></pre><p>其中<code>Pet</code>是私有继承的类，这样就可以使用<code>Pet</code>类中的<code>eat</code>成员函数。</p>
<p>这样，如果想要隐藏基类的部分功能，则private继承是有用的。注意给出一个重载函数的名字将使基类中的所有它的重载版本公有化。</p>
<p>在使用private继承取代组合之前，应当仔细考虑，当与运行时类型标识相连时，私有继承特别复杂。</p>
<p>实际项目中，有时希望某些东西隐藏起来，但仍允许其派生类的成员访问，此时可用protected。它的意思是：“就这个类的用户而言，它是private的，但它可被从这个类继承来的任何类使用”。</p>
<p>最好让数据成员是<code>private</code>，因为我们应该保留改变内部实现的权利。然后才能通过<code>protected</code>成员函数控制对该类的继承者的访问。</p>
<p>保护继承的派生类意味着对其他类来说是“照此实现”，但它是对于派生类和友元是<code>is-a</code>。它是不常用的，它的存在只是为了语言的完备性。</p>
<p>除了赋值运算符以外，其余的运算符可以自动地继承到派生类中。</p>
<p>直到我们已经很好地学会程序设计并完全理解这个语言时，我们才能试着去用多重继承。不管我们如何认为我们必须用多重继承，我们总是能通过单继承完成。</p>
<p>多重继承引起很多含糊的可能性。</p>
<p>继承和组合的优点之一是它支持渐增式开发(incremental development)，它允许在已存在的代码中引进代码，而不会给原来的代码带来错误。</p>
<p>认识到程序开发就像人的学习过程一样，是一个渐增的过程，这是很重要的。我们能做尽可能多的分析，但当开始一个项目时，我们仍不可能知道所有的答案。</p>
<p>记住，继承首先是表示一种关系，即“新类属于老类的类型(a type of)”。我们的程序不应当关心怎样怎样摆布位，而应当关心如何创建和处理各类型的对象，以便用问题空间的术语表示模型。</p>
<p>继承最重要的方面不是它为新类提供了成员函数，而是它是基类与新类之间的关系，这种关系可被描述为：“新类属于原有类的类型”。</p>
<p>这个描述不仅仅是一种想象的解释继承的方法──它直接由编译器支持。将新类的引用或指针转变成基类的引用或指针的活动被称为<code>向上类型转换(upcasting)</code>。</p>
<p>为什么要“向上类型转换” 这个术语的引入是有其历史原因的，而且它也与类继承图的传统画法有关：在顶部是根，向下生长。</p>
<p>向上类型转换总是安全的。因为是从更专门的类型到更一般的类型──对于这个类接口可能出现的唯一事情是它失去成员函数，而不是获得它们。这就是编译器允许向上类型转换而不需要显式地说明或做其他标记的原因。</p>
<p>必须记住无论何时我们在创建了子集的拷贝构造函数时，都要正确地调用基类拷贝构造函数(正如编译器所作的)。</p>
<h2 id="u7B2C15_u7AE0__u591A_u6001_u6027_u548C_u865A_u51FD_u6570"><a href="#u7B2C15_u7AE0__u591A_u6001_u6027_u548C_u865A_u51FD_u6570" class="headerlink" title="第15章 多态性和虚函数"></a>第15章 多态性和虚函数</h2><p>多态性(在C++中通过虚函数来实现)是面向对象程序设计语言中数据抽象和继承之外的第三个基本特性。</p>
<p><code>多态性(polymorphism)</code>提供了接口与具体实现之间的另一层隔离，从而将<code>what</code>与<code>how</code>分离开来。多态性改善了代码的组织性和可读性，同时也使创建的程序具有可拓展性。</p>
<p><code>封装(encapsulation)</code>通过组合特性和行为来生成心的数据类型。访问控制通过使细节数据设为private，将接口从具体实现中分离开来。</p>
<p>C程序员可以用三步演变为C++程序员。</p>
<ol>
<li>第一步：简单地把C++作为一个“更好的C”。</li>
<li>第二步：进入“基于对象”的C++。</li>
<li>第三步：了解和使用虚函数，这是理解面向对象程序设计的转折点。不用虚函数，就等于还不懂得面向对象程序设计(OOP)，虚函数增强了类型概念，而不只是在结构内部隐蔽地封装代码。</li>
</ol>
<p>取一个对象的地址(指针或引用)，并将其作为基类的地址来处理，这被称为向上类型转换(upcasting)，因为继承树的绘制方式是以基类为顶点的。</p>
<p>把函数体与函数调用相联系称为捆绑(binding)。当捆绑在程序运行之前(由编译器和连接器)完成时，这称为早捆绑(early binding)。C编译只有一种函数调用方式，就是早捆绑。晚捆绑(late binding)意味着捆绑根据对象的类型，发生在运行时。晚捆绑又称为动态捆绑(dynamic binding)或运行时捆绑(runtime binding)。对于一种编译语言，编译器并不知道实际的对象类型，但它插入能找到和调用正确函数体的代码。</p>
<p>对于特定的函数，为了引起晚捆绑，C++要求在基类中声明这个函数时使用<code>virtual</code>关键字。晚捆绑只对<code>virtual</code>函数起作用，而且只在使用含有<code>virtual</code>函数的基类的地址时发生，尽管它们也可以在更早的基类中定义。</p>
<p>为了创建一个像<code>virtual</code>这样的成员函数，可以简单地在声明这个函数时使用<code>virtual</code>关键字。仅仅在声明的时候需要使用关键字virtual，定义时并不需要。如果一个函数在基类中被声明为<code>virtual</code>，那么在所有的派生类中它都是<code>virtual</code>的。在派生类中<code>virtual</code>函数的重定义通常称为<code>重写(overriding)</code>。</p>
<p>注意，仅需要在基类中声明一个函数为virtual。调用所有匹配基类声明行为的派生类函数都将使用虚机制。</p>
<p>在一个设计风格良好的OOP程序中，大多数甚至所有的函数都可以沿用基类的某个模型，只需与基类接口通信。这样的程序是可拓展的(extensible)，因为可以通过从公共基类继承新数据类型而增加新功能。操作基类接口的函数完全不需要改变就可以适合于这些新类。</p>
<p>关键字<code>virtual</code>告诉编译器它不应当执行早捆绑，相反，它应当自动安装对于实现晚捆绑必需的所有机制。</p>
<p>为了达到这个目的，典型的编译器对每个包含虚函数的类创建一个<code>表(VTABLE)</code>。在<code>VTABLE</code>中，编译器放置特定类的虚函数的地址。在每个带有虚函数的类中，编译器秘密地防止一个指针，称为<code>vpointer(缩写为VPTR)</code>，指向这个对象<code>VTABLE</code>。当通过基类指针做虚函数调用时(也就是做多台调用时)，编译器静态地插入能取得这个<code>VPTR</code>并在<code>VTABLE</code>表中查找函数地址的代码，这样就能调用正确的函数并引起晚捆绑的发生。</p>
<p>为每个类设置<code>VTABLE</code>，初始化<code>VPTR</code>、为虚函数调用插入代码，所有这些都是自动发生的。利用虚函数，即使在编译器还不知道这个对象的特定类型的情况下，也能调用这个对象中正确的函数。</p>
<p>如果有一个或多个虚函数，编译器都只在这个结构中插入一个单个指针(VPTR)，指向一个存放函数地址的表。我们只需要一个表，因为所有虚函数地址都包含在这个但个表里。</p>
<p>C++并不是对于绝对地址的一个简单的CALL，而是为设置虚函数调用需要两条以上的复杂的汇编指令。这既需要代码空间，又需要执行时间。</p>
<p>一些面向对象的语言已经接受了这种途径，即晚捆绑对于面向对象程序设计是性质所固有的，所以应当总是出现，它不应当是可选的，而且用户并不一定需要知道它。这是在创造语言的设计时决定的，而这种特殊的方法对于许多语言是适合的(smalltalk、Java和Python)。</p>
<p><code>virtual</code>关键字可以改变程序的效率。当设计类时，我们不应当为效率问题担心。如果使用多态，就处处使用虚函数。当试图加速代码时，只需寻找可以不使用虚函数的函数。</p>
<p>有些证据表明，C++中的规模和速度改进效果是在C的规模和速度的10%之内，并且常常更接近。能够得到更小的规模和更高速度的原因是C++可以有比C更快的方法设计程序，而且设计的程序更小。</p>
<p>在设计时，常常希望基类仅仅作为其派生类的一个接口。这就是说，仅想对基类进行向上类型转换，使用它的接口，而不希望用户实际地创建一个基类对象。就可以在基类中加入至少一个纯虚函数(pure virtual function)，来使基类成为抽象(abstract)类。纯虚函数使用关键字virtual，并且在其后面加上= 0。如果试着生成一个抽象类的对象，编译器会制止他。</p>
<p>当继承一个抽象类时，必须实现所有的纯虚函数，否则继承出的类也将是一个抽象类。创建一个纯叙述函数允许在接口中放置成员函数，而不一定要提供一段可能对这个函数毫无意义的代码。同时纯虚函数要求继承出的类对它提供一个定义。</p>
<p>建立公共接口的唯一原因是它能对于每个不同的子类有不同的表示。它建立一个基本的格式，用来确定什么是对于所有派生类是公共的──除此之外，别无用途。当仅希望通过一个公共接口来操纵一组类，且这个公共接口不需要实现(或者不需要完全实现)时，可以创建一个抽象类。语法为：</p>
<pre><code>virtual void f() = 0;
</code></pre><p>这样做，等于告诉编译器在VTABLE中为函数保留一个位置，但在这个特定位置中不放地址。只要有一个函数在类中被声明为纯虚函数，则VTABLE就是不完全的。</p>
<p>如果一个类的VTABLE是不完全的，当试图创建这个类的对象时，编译器就发出一个出错信息。这样，编译器就保证了抽象类的纯洁性，就不会被误用了。</p>
<p>一个类若全是纯虚函数，就称为纯抽象类(pure abstract class)。纯序函数是非常有用的，因为它们使得类有明显的抽象性，并告诉用户和编译器打算如何使用。</p>
<p>注意，纯虚函数禁止对抽象类的函数以传值方式调用。这也是防止对象切片(object slicing)的一种方法。通过抽象类，可以保证在向上类型转换期间总是使用指针或引用。</p>
<p>当实现继承和重新定义一些虚函数时，编译器对新类创建一个新的VTABLE表，并且插入新函数的地址，对于没有重新定义的虚函数使用基类函数的地址。无论如何，对于可被创建的每个对象(即它的类不含有纯虚函数)，在VTABLE中纵有一个函数地址的全集，所以绝对不能对不在其中的地址进行调用(否则结果将是灾难性的)。</p>
<p>若在派生(derived)类中继承或增加新的虚函数，那么通过基类的指针是无法进行调用的。</p>
<p>如果知道保存在一般容器中的所有对象的确切类型，会使我们的设计工作在最佳状态(或者没有选择)。这就是运行时类型辨认(Run-Time Type Identification,RTTI)问题。RTTI是有关向下类型转换基类指针到派生类指针的问题。向上类型转换是自动发生的，不需强制，因为它是绝对安全的。向下类型转换是不安全的，因为这里没有关于实际类型的编译时信息，所以必须准确地知道这个类实际是什么类型。如果把它转换称错误的类型，就会出现麻烦。</p>
<p>当多态地处理对象时，传地址与传值有明显的不同。如果对一个对象进行向上类型转换，而不使用地址或引用，这个对象将会被“切片”，直到剩下来的是适合于目的的子对象。确切地来说，派生类对象会被切片成一个基类对象。</p>
<p>对象切片实际上是当它拷贝到一个新的对象时，去掉原来对象的一部分，而不是像使用指针或引用那样简单地改变地址和内容。因此，不常使用对象向上类型转换，事实上，通常要提防或防止这种操作。</p>
<p>重新定义一个基类中的重载函数将会隐藏所有该函数的其他基类版本。而当对虚函数进行这些操作的时候，情况会有点不同。</p>
<p>编译器不允许我们改变重新定义过的虚函数的返回值(如果不是虚函数，则是允许的)。这是一个非常重要的限制，因为编译器必须保证我们能够多态地通过基类调用函数，若返回值不同，那么就会产生问题。</p>
<p>如果重新定义了基类中的一个重载成员函数，则在派生类中其他的重载函数将会被隐藏。例如，基类中有f(int)和f(string)这样的重载函数，如果我在派生类中重新定义了f(int)，那么对于这个派生类来说，f(string)就被隐藏了，不可用了。</p>
<p>通常，我们不能在重新定义过程中修改虚函数的返回类型，但是也有特例，如果返回一个指向基类的指针或引用，则该函数的重新定义版本可以从基类返回的内容中返回一个指向派生类的指针或引用。</p>
<p>当创建一个报含有虚函数的对象时，必须初始化它的VPTR以指向相应的VTABLE。这必须在对虚函数进行任何调用之前完成。编译器在构造函数开头部分秘密地插入能初始化VPTR的代码。</p>
<p>当寻找效率漏洞时，我们必须明白，编译器正在插入隐藏代码到我们构造函数中。这些隐藏代码不仅必须初始化VPTR，而且还必须检查this的值(以免operator new返回零)和调用基类构造函数。放在一起，这些代码可以影响我们认为是一个小内联函数的调用。特别是，构造函数的规模会抵消函数调用代价的减少。如果做大量的内联构造函数调用，代码长度就会增长，而在速度上没有任何好处。</p>
<p>当然，也许并不会立即把所有这些小构造函数都变成非内联，因为它们更容易写为内联构造函数。但是，当我们正在调整我们的代码时，务必去掉这些内联构造函数。</p>
<p>所有基类构造函数总是在继承类构造函数中被调用。派生类只访问它自己的成员，而不访问基类的成员。只有基类构造函数能正确地初始化它自己的成员。如果不在构造函数初始化表达式表中显式地调用基类构造函数，他就调用默认构造函数。如果没有默认构造函数，编译器将报告错误。</p>
<p>构造函数调用的顺序是重要的。当继承时，必须知道基类的全部成员并能访问基类的任何<code>public</code>和<code>protected</code>成员。在通常的成员函数中，构造已经发生，所以这个对象的所有部分的成员都已经建立。然而，在构造函数中，必须想办法保证所有成员都已经建立。保证它的惟一方法是让基类构造函数首先被调用。</p>
<p>只要可能，我们应当在构造函数初始化表达式表中初始化所有的成员对象。只要遵从这个做法，我们就能保证初始化所有基类成员和当前对象的成员对象。</p>
<p>对于在构造函数中调用一个虚函数的情况，被调用的只是这个函数的本地版本。也就是说，虚机制在构造函数中不工作。</p>
<p>构造函数的工作是生成一个对象。在任何构造函数中，可能只是部分形成对象──我们只能知道基类已被初始化，但并不能知道哪个类是从这个基类继承来的。然而，虚函数在继承层次上是“向前”和“向外”进行调用。它可以调用在派生类中的函数。如果我们在构造函数中也这样做，那么我们所调用的函数可能操作还没有被初始化的成员。这将导致灾难的发生。</p>
<p>当一个构造函数被调用时，它做的首要事情之一就是初始化它的<code>VPTR</code>。然而，它只能知道它属于“当前”类──即构造函数所在类。于是它完全忽视这个对象是否是基于其他类的。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码──既不是为基类，也不是为它的派生类。<code>VPTR</code>的状态是由被最后调用的构造函数确定的。</p>
<p>当这一系列构造函数调用正发生时，每个构造函数都已经设置<code>VPTR</code>指向子集的<code>VTABLE</code>。如果函数调用使用虚机制，它将只产生通过它自己的<code>VTABLE</code>的调用，而不是最后派生的<code>VTABLE</code>。</p>
<p>总之，在构造函数中调用虚函数都不能得到预期的结果。</p>
<p>构造函数是不能为虚函数的。但析构函数能够且常常必须是虚的。</p>
<p>构造函数有一项特殊工作，即一块一块地组合成一个对象。它首先调用基类构造函数，然后调用在继承顺序中的更晚派生的构造函数。类似地，析构函数也有一项特殊工作，即它必须拆卸属于某层次类的对象。析构函数自最晚派生的类开始，并向上到基类。</p>
<p>如果通过指向某个对象基类的指针操纵这个对象(也就是通过它的一般接口操纵这对象)，当我们想在<code>delete</code>在栈中已经用<code>new</code>创建的对象的指针时，就会出现这个问题。如果这个指针是指向基类的，在<code>delete</code>期间，编译器只能知道调用这个析构函数的基类版本，幸运的是，析构函数可以是虚函数。</p>
<p>不把析构函数设为虚函数是一个隐匿的错误，因为它常常不会对程序有直接的影响，但是会不知不觉引入存储器泄露(关闭程序时内存未释放)。同样，这样的析构操作还有可能掩盖发生的问题。</p>
<p>尽管纯虚析构函数在标准C++中是合法的，但在使用的时候有一个额外的限制：必须为纯虚析构函数提供一个函数体。纯虚析构函数和非纯虚虚构函数之间的唯一不同之处在于纯虚析构函数使得基类是抽象类，所以不能创建一个基类的对象(如果基类的任何其他函数是纯虚函数，也是具有同样的效果)。</p>
<p>当从某个含有虚析构函数的类中继承出一个类，情况变得有点复杂。不像其他的纯虚函数，我们不要求在派生类中提供纯虚函数的定义。</p>
<p>一般来说，如果在派生类中基类的纯虚函数(和所有其他纯虚函数)没有重新定义，则派生类将会成为抽象类。但是这里编译器将会自动地为每个类生成一个析构函数定义，基类的析构函数被重写(重新定义)，因此编译器会提供定义并且派生类实际上不会成为抽象类。</p>
<p>当我们的类仅含有一个纯虚函数时，就会发现这个唯一的差别：析构函数。这里析构函数的纯虚性的唯一效果是阻止基类的实例化。如果有其他的纯虚函数，则它们会阻止基类的实例化。</p>
<p>作为一个准则，任何时候我们的类中都要有一个虚函数，我们应当立即增加一个虚析构函数(即使它什么也不做)。这样，我们保证在后面不会出现问题。</p>
<p>在析构期间，有一些我们可能不希望马上发生的情况。如果正在一个普通的成员函数中，并且调用一个虚函数，则会使用晚捆绑机制来调用这个函数。而对于析构函数，这样不行，不论是虚的还是非虚的。在析构函数中，只有成员函数的“本地”版本被调用；虚机制被忽略。</p>
<p>负责动态对象创建(使用<code>new</code>)的对象进行<code>delete</code>调用的称之为“所有者”。在使用容器时的问题是，它们需要足够的灵活性用来接收不同类型的对象。为了做到这一点，容器使用<code>void</code>指针，因此它们并不知道所包容对象的类型。删除一个<code>void</code>指针并不调用析构函数，所以容器并不负责清除它的对象。</p>
<p>一种方法要求我们要为想在容器中容纳的每一种类型都派生出新类。</p>
<p>问题是我们希望容器可以容纳更多的类型，但我们不想使用void指针。另外一种解决方法是使用多态性，它通过强制容器内的所有对象从同一个基类继承而来。也就是说，容器容纳了具有同一基类的对象，并随后调用虚函数──特别地，我们可以调用虚析构函数来解决所有权问题。</p>
<p>这种解决方法使用<code>单根继承(singly-rooted hierarchy)</code>或<code>基于对象的继承(object-based hierarchy)</code>。事实上，除了C++，每种面向对象的语言都强制使用这样的体系──当创建一个类时，都会直接或间接地从一个公共基类中继承出它，这个基类是由该语言的创建者生成的。C++中认为，强制地使用这个公共基类会引起太多的开销，所有便没有使用它。</p>
<p>就像对成员函数那样，我们可以使用virtual运算符。然而，因为我们可能对两个不知道类型的对象进行操作，所以实现virtual运算符通常会很复杂。这通常用于处理数学部分。</p>
<p>C++提供了一个特殊的称为<code>dynamic_cast</code>的<code>显式类型转换(explicit cast)</code>，它就是一种<code>安全类型向下类型转换(type-safe downcast)</code>的操作。当使用<code>dynamic_cast</code>来试着向下类型转换一个特定的类型，仅当类型转换是正确的并且是成功的时，返回值会是一个指向所需类型的指针，否则它将会返回0来表示这并不是正确的类型。<br>当使用<code>dynamic_cast</code>时，必须对一个真正多态的层次进行操作──它含有虚函数──这因为<code>dynamic_cast</code>使用了存储在<code>VTABLE</code>中的信息来判断实际的类型，所以运行时需要一点额外的开销。</p>
<h2 id="u7B2C16_u7AE0__u6A21_u677F_u4ECB_u7ECD"><a href="#u7B2C16_u7AE0__u6A21_u677F_u4ECB_u7ECD" class="headerlink" title="第16章 模板介绍"></a>第16章 模板介绍</h2><p>继承和组合提供了重用对象代码的方法，而C++的模板特征提供了重用源代码的方法。</p>
<p>在一般程序设计问题中，程序员在编写程序时并不知道将来需要创建多少个对象。C++中有更好的解决方法：用new创建所需要的对象，将其指针放入容器中，待实际实用时将其取出并进行处理。用这种方法，所创建的只是确实需要的对象。通常，在启动程序时没有可用的初始化条件。new允许等待，直到在环境中相关事件发生后，再实际地创建这个对象。</p>
<p>有三种源代码重用的方法：</p>
<ul>
<li>C方法：应该摒弃，由于它表现繁琐、易发生错误、缺乏美感，是非常低效的技术。</li>
<li>Smalltalk方法：通过继承来实现代码重用，既简单又直观。每个容器类包含通用的基类Object的项目。这是一种单纯的技巧，因为Smalltalk类层次上的任何类都源于Object的派生，任何容器可容纳任何类(包括容器本身)。这种基于通用的基类(常称为Object，在Java中也有类似情况)的单树形层次类型称为“基于对象的层次结构”。</li>
</ul>
<p>尽管具有多重继承的基于对象的层次结构在概念上是直观的，但是在实践上较为困难。</p>
<p>模板对源代码进行重用，而不是通过继承和组合重用目标代码。容器不再存放称为Object的通用基类，而是存放一个未指明的参数。当用户使用模板时，参数由编译器来替换。</p>
<p>C++中，模板实现了参数化类型(parameterized type)的概念。模板方法的另一个优点是，使对继承不熟悉、不适应的新程序员也能正确地使用密封的容器类。</p>
<p>template这个关键字会告诉编译器，随后的类定义将操作一个或更多未指明的类型。当由这个模板产生实际类代码时，必须指定这些类型以使编译器能够替换它们。</p>
<pre><code>template&lt;class T&gt;
class Array{
    enum{ size = 100 };
    T A[size];
public:
    T&amp; operator[](int index){....}
};
int main(){
    Array&lt;int&gt; ia;
    Array&lt;double&gt; da;
    ...
}
</code></pre><p>这里T是替换参数，它代表一个类型名称。在容器类中，它将出现在那些原本由某以特定类型出现的地方。</p>
<p>有时我们希望有非内联成员函数的定义。这时编译器需要在成员函数定义之前看到<code>template</code>声明。</p>
<pre><code>template&lt;class T&gt;
class Array{
    enum{ size = 100 };
    T A[size];
public:
    T&amp; operator[](int index);
};
template&lt;class T&gt;
T&amp; Array&lt;T&gt;::operator[] (int index) {...}
</code></pre><p>注意在引用模板的类名的地方，必须伴游该模板的参数列表。可以想象，在内部，使用模板参数列表中的参数修饰类名，以便为每一个模板实例产生唯一的类名标识符。</p>
<p>在template&lt;…&gt;之后的任何东西都意味着编译器在当时不为它分配存储空间，而是一直处于等待状态直到被一个模板示例告知。在编译器和连接器中有机制能去掉同一模板的多重定义。所以为了使用方便，几乎总是在头文件中放置全部的模板声明和定义。</p>
<p>可以认为模板为C++提供了一种弱类型(weak typing)机制，C++通常是强类型语言。</p>
<p>模板参数并不局限于类定义的类型，可以使用编译器内置类型。这些参数值在编译期间编程模板的特定示例的常量。我们甚至可以对这些参数使用默认值。</p>
<pre><code>template&lt;class T, int size = 100&gt;
class Array{
    T array[size];
public:
    int length() const { return size; }
};
</code></pre><p>这里的<code>size</code>决不存放在类中，但对它的使用就如同是成员函数中的数据成员。</p>
<p>如果某个类有一个指向<code>Array</code>的指针，而不是指向类型<code>Array</code>的嵌入对象。该指针在构造函数中不被初始化，而是推迟到第一次访问时。这称为<code>懒惰初始化(lazy initialization)</code>。如果创造大量的对象，但不访问每一个对象，为了节省存储，可以使用懒惰初始化技术。</p>
<p>以值包含对象的容器通常无需担心所有权问题，因为它们清晰地拥有它们所包含的对象。但是，如果容器内包含指向对象的指针(这种情况在C++中相当普遍，有其在多态的情况下)，而这些指针很可能用于程序的其他地方，那么删除该指针指向的对象会导致在程序的其他地方的指针对已销毁的对象进行引用。为了避免上述情况，在设计和使用容器时必须考虑所有权问题。</p>
<p>处理所有权问题的最好方法是由客户程序员来选择。这常常通过构造函数的一个参数来完成，它默认地指明所有权。</p>
<p>如果我们没有模板，那么在一个一般的容器内创建对象的一个拷贝是一个复杂的问题。使用模板，事情噢那个就相对简单了，只要说我们存放对象而不是指针就行了。</p>
<p><code>迭代器(iterator)</code>是一个对象，它在其他对象的容器上遍历，每此选择它们中的一个，不需要提供对这个容器的实现的直接访问。迭代器提供了一种访问元素的标准方法，无论容器是否提供了直接访问元素的方法。迭代器常常与容器类联合使用，而且迭代器在标准C++容器的设计和使用中是一个基本概念。迭代器也是一种<code>设计模式(design pattern)</code>。</p>
<p>迭代器通常模仿大多数指针的运算。然而，不同的是，迭代器的设计更安全，所以数组越界的可能性更小。</p>
<p>习惯上，用构造函数来创建迭代器，并把它与一个容器对象联系，并且在它的生命期中，不把它与不同的容器联系。</p>
<h2 id="u7B2C19_u7AE0__u6DF1_u5165_u7406_u89E3_u6A21_u677F"><a href="#u7B2C19_u7AE0__u6DF1_u5165_u7406_u89E3_u6A21_u677F" class="headerlink" title="第19章 深入理解模板"></a>第19章 深入理解模板</h2><p>C++模板应用的便利性远远超出了它只是一种<code>T类型容器”(containers of T)</code>的范畴。尽管其最初的设计动机是为了能产生类型安全的通用容器，但在现在C++中，模板也用来生成自定义代码，这些代码通过编译时的程序设计构造来优化程序的执行。</p>
<p>模板有两类：函数模板和类模板。二者都是由它们的参数来完全地描绘模板的特性。每个模板参数描述了下述内容之一：</p>
<ul>
<li>类型(或者是系统固有类型或者是用户自定义类型)。</li>
<li>编译时常数值(例如，整数、指针和某些静态实体的引用，通常是作为无类型参数的引用)。</li>
</ul>
<p>其他模板。</p>
<p>一个无类型模板参数必须是一个编译时所知的整数值。</p>
<pre><code>template&lt;class T, size_t N&gt;
</code></pre><p>在类模板中，可以为模板参数提供默认(缺省)参数，但是在函数模板中却不行。作为默认的模板参数，它们只能被定义一次，编译器会知道第一次的模板声明或定义。一旦引入了一个默认参数，所有它之后的模板参数也必须具有默认值。</p>
<h1 id="C++__u6280_u5DE7"><a href="#C++__u6280_u5DE7" class="headerlink" title="C++ 技巧"></a>C++ 技巧</h1><p>变量定义指定了变量的类型和标识符，也可以为对象提供初始值。定义时制定了初始值的对象被成为是<code>已初始化的（initialized）</code>。C++支持两种初始化变量的形式：<code>复制初始化（copy－initialization）</code>和<code>直接初始化（direct－initialization）</code>。复制初始化语法用等号，直接初始化则是把初始化式放在括号中</p>
<pre><code>int ival（1024）； //direct-initialization
int ival = 1024；    //copy-initialization
</code></pre><p>C++中初始化和赋值是两种不同的操作，请注意。并且直接初始化语法更灵活而且效率更高。</p>
<hr>
<p>定义如何进行初始化的成员函数称为<code>构造函数（constructor）</code>。和其他函数一样，构造函数能接受多个参数。一个类可以定义几个构造函数，每个构造函数必须接受不同数目或者不同类型的参数。</p>
<hr>
<p>内置类型（如int）变量是否自动初始化取决于变量定义的位置。在函数体外定义的变量都初始化为0，在函数体里定义的内置类型变量不进行自动初始化。除了用作赋值操作符的左操作数，未初始化变量用作任何其他用途都是没有定义的。未初始化变量引起的错误难以发现，永远不要依赖未定义行为。</p>
<hr>
<p>建议每个内置类型的对象都要初始化。虽然这样做并不总是必需的，但是会更加容易和安全，除非你确定忽略初始化式不会带来风险。</p>
<hr>
<p>如果定义某个类的变量时没有提供初始化式，这个类也可以定义初始化时的操作。它是通过定义一个特殊的构造函数即<code>默认构造函数（default constructor）</code>来实现的。如果没有提供初始化式，那么就会使用默认构造函数。不管变量在哪里定义，默认构造函数都会被使用。</p>
<hr>
<p><code>变量的定义（definition）</code>用于为变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量有且仅有一个定义。<code>声明（declaration）</code>用于项程序表明变量的类型和名字。定义也是声明；当定义变量时我们声明了它的类型和名字。可以通过使用<code>extern</code>关键字声明变量而不定义它。不定义变量的声明包括对象名。对象类型和对象类型前的关键字<code>extern</code>。</p>
<hr>
<p>在C++语言中，变量必须且仅能定义一次，而且在使用变量之前必须定义或者声明变量。</p>
<hr>
<p>用来区分名字的不同意义的上下文称为<code>作用域（scope）</code>。作用域是程序的一段区域。一个名称可以和不同作用域中的不同实体相关联。C++语言中，大多数作用域是用花括号来界定的。一般来说，名字从其声明点开始直到其声明所在的作用域结束处都是可见的。</p>
<hr>
<p>定义在所有函数外部的名字具有<code>全局作用域（global scope）</code>，可以在程序中的任何地方访问。定义在<code>main</code>函数的作用域，则在整个<code>main</code>函数中可以使用，具有<code>局部作用域（local scope）</code>。而在某个语句中定义的（例如for语句中），则只能在语句中使用，具有<code>语句作用域（statement scope）</code>。</p>
<hr>
<p>C++中作用域可嵌套，若先定义了全局变量s1，而又在main中定义了局部变量s1，那么，局部变量s1就会屏蔽全局变量s1。要注意的是，像上面这样的定义方法很可能让他人大惑不解，同名总是不好的，建议局部变量最好使用不同的名字。</p>
<hr>
<p>一般来说，变量的定义或声明可以放在程序中能摆放语句的任何位置。变量在使用前必须先声明或定义。通常把一个对象定义在它首次使用的地方是一个很好的办法。</p>
<hr>
<p>定义一个变量代表某一常数的方法仍然有一个严重的问题。此变量是可以被修改的。<code>const</code>限定符提供了一个解决办法，它把一个对象转换成一个常量。如下：</p>
<pre><code>const int bufsize ＝ 512；
</code></pre><p>此时变量<code>bufsize</code>是不可修改的，任何修改<code>bufsize</code>的尝试都会导致编译错误。因为常量在定义后就不能被修改，所以定义时必须初始化。</p>
<hr>
<p><code>const</code>对象默认为文件的局部变量，此变量只存在于那个文件中，不能被其他文件访问。非<code>const</code>变量默认为<code>extern</code>。要使<code>const</code>变量能够在其他文件中访问，必须显式地指定它为<code>extern</code>。</p>
<hr>
<p><code>引用（reference）</code>就是对象的另一个名字。在实际程序中，引用主要用作函数的形式参数。引用式一种<code>复合类型（compound type）</code>，通过在变量名前添加<code>&amp;</code>符号来定义。复合类型是指用其他类型定义的类型。在引用的情况下，每一种引用类型都“关联到”某一其他类型。不能定义引用类型的引用，但可以定义其他任何类型的引用。引用必须用与该引用同类型的对象初始化：</p>
<pre><code>int ival ＝ 1024；
int &amp;refVal = ival; //ok: refVal refers to ival
int &amp;refVal2;       //error: a reference must be initialized
int &amp;refVal3 = 10;  //error: initializer must be an object
</code></pre><hr>
<p>引用只是它绑定的对象的另一个名字，作用在引用上的所有操作事实上都是作用在该引用绑定的对象上。当引用初始化后，只要该引用存在，它就保持绑定到初始化时指向的对象。不可能将引用绑定到另一个对象。</p>
<hr>
<p>const引用是指向const对象的引用</p>
<pre><code>const int ival ＝ 1024；
const int &amp;refVal = ival;   //ok: both reference and object are const
int &amp;ref2 = ival;       //error: nonconst reference of a const object
</code></pre><p>可以读取但是不能修改refVal，任何对refVal的赋值都是不合法的。同理，用ival初始化ref2也是不合法的：ref2是普通的非const引用（nonconst reference）。</p>
<hr>
<p>const引用可以初始化为不同类型的对象或者初始化为右值，如字面值常量：</p>
<pre><code>int i = 42;
// legal for const references only
const &amp;r = 42;
const &amp;r2 = r + i;
</code></pre><p>同样的初始化对于非const引用却是不合法的，而且会导致编译时错误。这里稍微解释一下</p>
<pre><code>double dval = 3.14;
const int &amp;ri = dval;
</code></pre><p>编译器会把这些代码转换成如以下形式的编码：</p>
<pre><code>int temp = dval;     // create temporary int from the double
const int &amp;ri = temp;   // bind ri to that temporary
</code></pre><p>如果<code>ri</code>不是<code>const</code>，那么可以给<code>ri</code>赋一个新值。这样做不会修改dval，而是修改了temp。期望对ri的赋值会修改dval的程序员会发现dval并没有被修改。仅允许const引用绑定到需要临时使用的值完全避免了这个问题，因为const引用是只读的。</p>
<hr>
<p>typedef可以用来定义类型的同义词：</p>
<pre><code>typedef double wages;   // wages is a synonym for double
typedef int exam_score; // exam_score is a synonym for int
</code></pre><p>typedef名字可以用作类型说明符：</p>
<pre><code>wages hourly,  weekly;  // double hourly, weekly;
</code></pre><hr>
<p>typedef通常被用于以下三种目的：为了隐藏特定类型的实现，强调使用类型的目的；简化复杂的类型定义，使其更易理解；允许一种类型用于多个目的，同时使得每次使用该类型的目的明确。</p>
<hr>
<p>枚举的定义包括关键字 enum，其后是一个可选的枚举类型名，和一个用花括号括起来、用逗号分开的枚举成员（enumerator）列表。</p>
<pre><code>// input is 0, output is 1, and append is 2
enum open_mode {input, output, append};
</code></pre><p> 默认地，第一个枚举成员赋值为0，后面地每个枚举成员赋的值比前面的大1。</p>
<pre><code>//shape is 1, sphere is 2, cylinder is 3, polygon is 4
enum Forms {shape = 1, sphere, cylinder, polygon};
</code></pre><p>枚举成员值可以是不唯一的。每个enum都定义一种唯一的类型。</p>
<hr>
<p>每个类都定义了一个接口（interface）和一个实现（implementation）。接口由使用该类的代码需要执行的操作组成。实现一般包括该类所需要的数据。实现还包括定义该类需要的但又不供一般性使用的函数。定义类时，通常先定义该类的接口，即该类所提供的操作，可以决定该类完成其功能所需要的数据，以及是否需要定义一些函数来支持该类的实现。</p>
<hr>
<p>类定义以关键字class开始，其后是该类的名字标识符。类体位于花括号里面。花括号后面必须要跟一个分号。类体可以为空，类体定义了组成该类型的数据和操作。这些操作和数据是类的一部分，也称为类的成员（member）。操作称为成员函数，而数据则称为数据成员（data member）。</p>
<hr>
<p>用class和struct关键字定义类的唯一差别在于默认访问级别：默认情况下，struct的成员为public，而class的成员为private。</p>
<hr>
<p>因为头文件包含在多个源文件中，所以不应该含有变量或函数的定义。如果const变量不是用常量表达式初始化，那么它就不应该在头文件定义。相反，和其他的变量一样，该const变量应该在一个源文件中定义并初始化。应在头文件中为它添加extern声明，以使其能被多个文件共享。</p>
<hr>
<p>使得头文件安全的通用做法，是使用预处理器定义头文件保护符（header guard）。</p>
<pre><code>#ifndef someheader.h
#define someheader.h
#endif
</code></pre><p>头文件应该含有保护符，即使这些头文件不会被其他头文件包含。编写头文件保护符并不困难，而且如果头文件被包含多次，它可以避免难以理解的编译错误。</p>
<hr>
<p>C++提供了更简洁的方式来使用命名空间成员。这里介绍一种最安全的机制：using声明。形式为：using namespace：：name；</p>
<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
using std::cin;
using std::cout;
int main()
{
.......
}
</code></pre><hr>
<p>一个using声明一次只能作用于一个命名空间成员。每个名字都需要一个using声明。</p>
<hr>
<p>标准库string类型支持长度可变的字符串。一般的声明格式如下：</p>
<pre><code>#include &lt;string&gt;
using std::string;
</code></pre><p>string标准库支持几个构造函数，如下：</p>
<pre><code>string s1；              默认构造函数，s1为空串
string s2（s1）；          将s2初始化为s1的一个副本
string s3（“value”）；     将s3初始化为一个字符串字面值副本
string s4（n，‘c’）；       将s4初始化为字符‘c’的n个副本
</code></pre><p>因为历史原因以及为了与C语言兼容，字符串字面值与标准库string类型不是同一种类型，编程时一定要注意区别。</p>
<hr>
<p>string类型的输入操作符：读取并忽略开头所有的空白字符（如空格，换行符，制表符）；读取字符直至再次遇到空白字符，读取中止。</p>
<hr>
<p>读入未知数目的string对象</p>
<pre><code>while(cin &gt;&gt; word)
    cout &lt;&lt; word &lt;&lt; endl;
</code></pre><hr>
<p>用getline读取整行文本，该函数接受两个参数：一个输入流对象和一个string对象。getline函数从输入流的下一行读取，并保存读取的内容到string中，但不包括换行符。</p>
<pre><code>string line;
while (getline(cin, line))
    cout &lt;&lt; line &lt;&lt; endl;
</code></pre><p>因为line不含换行符，如果需要逐行输出则需要自行添加。</p>
<hr>
<p>VC 6和Xcode中对于getline的使用都存在bug。具体的表现是VC6里要输入两次回车才能输出，而Xcode的出错则是释放了未分配的指针。具体的解决方案如下</p>
<p>VC6：</p>
<p>X:\Program Files\Microsoft Visual Studio\VC98\Include\string(注意是string文件，不是string.h)找到165行，下面的代码从163行开始</p>
<pre><code>else if (_Tr::eq((_E)_C, _D)) //163行
{_Chg = true;
//  _I.rdbuf()-&gt;snextc(); // 把这一行注释掉,添加下一行.
_I.rdbuf()-&gt;sbumpc(); //添加
break;}
</code></pre><p>Xcode：有两种方案，其实差不多，第一种是在代码最前面加上</p>
<pre><code>#define _GLIBCXX_FULLY_DYNAMIC_STRING 1 
#undef _GLIBCXX_DEBUG 
#undef _GLIBCXX_DEBUG_PEDANTIC
</code></pre><p>第二种如下：</p>
<p>The solution is to double-click on the target to open its Info window, go to the Build tab, and scroll down to the “GCC 4.2 - Preprocessing” section. In this section is a setting named “Preprocessor Macros” that by default has two entries, “_GLIBCXX_DEBUG=1” and “_GLIBCXX_DEBUG_PEDANTIC=1”. Remove these entries.</p>
<hr>
<p>string的size和empty操作。可以通过size操作获取。</p>
<pre><code>int main(){
    string st(“The expense of spirit\n”);
    cout &lt;&lt;  “The size of ” &lt;&lt;  st &lt;&lt;  “is ” &lt;&lt;  st.size() &lt;&lt; endl;
    return 0;}
</code></pre><p>empty成员函数将返回bool值，如果string对象为空则返回ture，否则返回false。</p>
<hr>
<p>size操作返回的是string::size_type类型的值。string类类型和许多其他库类型都定义了一些配套类型（companion type）。通过这些配套类型，库类型的使用就能与机器无关（machine－independent）。size_type就是这些配套类型的一种。定义为与unsigned型具有相同的含义，而且可以保证足够大能够存储任意string对象的长度。为了使用类型定义的size_type类型，程序员必须加上作用域操作符来说明所使用的size_type类型是由string类定义的。即std::size_type类型。不要把size的返回值赋给int变量！</p>
<hr>
<p>对string对象来说，可以把一个string对象赋值给另一个string对象。string对象的加法被定义为（concatenation）。如下</p>
<pre><code>string s1(“hello, ”);
string s2(“world\n”);
string s3 = s1 + s2;        // s3 is hello, world\n
</code></pre><p>如果要把s2直接追加到s1的末尾，就用＋＝</p>
<pre><code>s1 += s2;
</code></pre><hr>
<p>当进行string对象和字符串字面值混合连接操作时，＋操作符的左右操作数必须至少有一个是string类型的：</p>
<pre><code>string s4 = “hello” + “, ”;     // error: no string operand
string s5 = s1 + “, ” + “world ”;   // ok: each + has string operand
string s6 = “hello” + “,” + s2; // error: can’t add string literals
</code></pre><p>顺序是从左到右的，所以s5中的s1先和第二个加，还是string类型，然后和第二个加；而s6中的第一个和第二个相加就不满足条件了。</p>
<hr>
<p>string类型通过下标操作符（ [] ）来访问string对象中的单个字符。下标操作符需要取一个size_type类型的值，来标明要访问字符的位置。着下标中的值通常被称为“下标”或“索引（index）”。string对象的下标从0开始而s[s.size()-1]就是最后一个字符。</p>
<hr>
<p>vector是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。我们把vector称为容器，是 因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型的。在使用vector之前，必须包含相应的头文件。声明如下</p>
<pre><code>#include &lt;vector&gt;
using std::vector;
</code></pre><hr>
<p>vector是一个类模板（class template）。使用模板可以编写一个类定义或函数定义，而用于多个不同的数据类型。声明从类模板生产的某种类型的对象，需要提供附加信息，信息的种类取决于模板。以vector为例，必须说明vector保存何种对象的类型，通过将类型放在类模板名称后面的尖括号中来指定类型：</p>
<pre><code>vector&lt;int&gt; ivec;               // ivec holds objects of type int
vector&lt;Sales_item&gt; Sales_vec        // holds Sale_itmes
</code></pre><p>和其他变量定义一样，定义vector对象要指定类型和一个变量的列表。上面的第一个定义，类型是vector<int>，该类型即是含有若干int类型对象的vector，变量名为ivec。</int></p>
<hr>
<p>vector不是一种数据类型，而只是一个类模板，可用来定义多种数据类型。vector类型的每一种都指定了其保存元素的类型。因此，vector<int>和vector<string>都是数据类型。</string></int></p>
<hr>
<p>vector对象的初始化方式</p>
<pre><code>vector&lt;T&gt;  v1；          vector保存类型为T的对象，默认构造函数v1为空
vector&lt;T&gt;  v2；          v2是v1的一个副本
vector&lt;T&gt;  v3（n，i）；     v3包含n个值为i的元素
vector&lt;T&gt;  v4（n）；       v4含有值初始化的元素的n个副本
</code></pre><hr>
<p>vector对象（以及其他标准库容器对象）的重要属性就在于可以在运行时高效地添加元素。因为vector增长地效率高，在元素值已知的情况下，最好是动态地添加元素。</p>
<hr>
<p>vector对象的size</p>
<p>empty和size操作类似于string类型的相关操作。成员函数size返回相应vector类定义的size_type值。使用size_type类型时，必须指出该类型时在哪里定义的。vector类型总是包括vector的元素类型：</p>
<pre><code>vector&lt;int&gt;::size_type      // ok
vector::size_type           // error
</code></pre><hr>
<p>向vector添加元素。push_back()操作接受一个元素值，并将它作为一个新的元素添加到vector对象的后面。</p>
<pre><code>// read words from the standard input and store them as elements in vector
string word;
vector&lt;string&gt; text;                // empty vector
while(cin &gt;&gt; word){
    text.push_back(word);       // append word to text
}
</code></pre><hr>
<p>vector中的对象是没有命名的壳以按vector中对象的位置来访问它们。通常使用下标操作符来获取元素。vector元素的位置从0开始。</p>
<hr>
<p>必须是已存在的元素才能用下标操作符进行索引。通过下标操作进行赋值时，不会添加任何元素。如果想要插入新元素，写法如下：</p>
<pre><code>for (vector&lt;int&gt;::size_type ix = 0; ix != 10; ++ix)  //这样的话就保证了索引和实际一致
    ivec.push_back(ix);
</code></pre><hr>
<p>除了使用下标来访问vector对象的元素外，标准库还提供了另外一种访问元素的方式：使用迭代器（iterator），迭代器时一种检查容器内元素并遍历元素的数据类型。标准库为每一种标准容器（包括vector）定义了一种迭代器类型。迭代器类型提供了比下标操作更通用化的方法：所有的标准库容器都定义了相应的迭代器类型，而只有少数的容器支持下标操作。因此，现代C++程序更倾向于使用迭代器而不是下标来访问容器元素。</p>
<hr>
<p>容器的iterator类型，定义如下（以vector为例）</p>
<pre><code>vector&lt;int&gt;::iterator iter；
</code></pre><p>每种容器都定义了一对名为begin和end的函数，用于返回迭代器。如果容器中有元素的话，由begin返回的迭代器指向第一个元素：</p>
<pre><code>vector&lt;int&gt;::iterator iter ＝ ivec.begin();
</code></pre><p>上述语句把iter初始化为ivec[0]。由end操作返回的迭代器指向vector的“末端元素的下一个”。通常称为超出末端迭代器（off－the －end iterator），只是起一个哨兵（sentinel）的作用，表示我们已经处理完了vector中的所有元素。</p>
<hr>
<p>迭代器可以使用解引用操作符（*操作符）来访问迭代器所指向的元素</p>
<pre><code>*iter ＝ 0；  //即把iter当前指向的元素赋值为0
</code></pre><p>迭代器使用自增操作符向前移动迭代器指向容器中的下一个元素。</p>
<p>由于end操作返回的迭代器不指向任何元素，因此不能对它进行解引用或自增操作。</p>
<hr>
<p>用 == 或者 != 操作符来比较两个迭代器，如果两个迭代器对象指向同一个元素，则它们相等，否则就不相等。</p>
<hr>
<p>应用迭代器来编写的初始化为0的循环</p>
<pre><code>for(vector&lt;int&gt;::iterator iter = ivec.begin(); iter != ivec.end(); ++iter )
    *iter = 0;
</code></pre><hr>
<p>若定义为const_iterator类型，就只能用于读取容器内元素，但不能改变其值。而如果时const的iterator对象，那么这个迭代器就不能改变，这样基本就无用的。下面是一个const_iterator的例子：</p>
<pre><code>for(vector&lt;string&gt;::const_iterator iter = text.begin(); iter != text.end(); ++iter)
    cout &lt;&lt;  *iter &lt;&lt; endl;
</code></pre><hr>
<p>迭代器的算术操作（iterator arithmetic）：iter ＋ n与 iter － n。iter1 － iter2 用来计算两个迭代器对象的距离，该距离时名为difference_type的signed类型的值。例如求最靠近正中的元素，可用以下代码：</p>
<pre><code>vector&lt;int&gt;::iterator mid = vi.begin() + vi.size()/2;
</code></pre><p>任何改变vector长度的操作都会使已存在的迭代器失效。例如，在调用push_back后，就不能再信赖指向vector的迭代器的值了。</p>
<hr>
<p>标准库bitset类型可以用来处理二进制位的有序集，可以使用bitset处理，声明如下：</p>
<pre><code>#include &lt;bitset&gt;
using std::bitset;
</code></pre><hr>
<p>类似于vector，bitset类是一种类模板；而与vector不一样的是bitset类型对象的区别仅在其长度而不在其类型。定义bitset时，要明确bitset含有多少位，要在尖括号内给出它的长度值：</p>
<pre><code>bitset&lt;32&gt; bitvec;  // 32 bits, all zero
</code></pre><p>长度值必须定义为整型字面值常量或者是已用常量值初始化的整型的const对象。bitset中的位是没有命名的，程序员只能按位置访问。位集合的位置编号从0开始，以0位开始的位串是低阶位（low-order bit），以31位结束的位串是高阶位（high-order bit)。</p>
<hr>
<p>用unsigned值初始化bitset对象时，该值将转化为二进制的位模式。而bitset对象中的位集作为这种位模式的副本。如果bitset类型长度大于unsigned long值的二进制位数，则其余的高阶位将置为0；如果小于，则只使用unsigned值中的低阶位，其余的被丢弃。</p>
<hr>
<p>用string对象初始化bitset对象时，string对象直接表示为位模式。从string对象读入位集的顺序时从右向左：</p>
<pre><code>string strval(“111000”);
bitset&lt;32&gt; bitvec4(strval);
</code></pre><p>那么这时bitvec4的表示为：0000000000···000111（共32位）</p>
<pre><code>string str（“1111111000000011001101”）；
bitset&lt;32&gt; bitvec5(str, 5, 4);      //从str[5]开始的4个位。即1100
bitset&lt;32&gt; bitvec6（str，str.size()-4）    //取最后的四位。即1101
</code></pre><hr>
<p>现代C++程序应尽量使用vector和迭代器类型，而避免使用低级的数组和指针。设计良好的程序只有在强调速度时才在类实现的内部使用数组和指针。指针和数组容易产生不可预料的错误。其中一部分是概念上的问题：指针用于低级操作，容易产生与繁琐细节相关的（bookkeeping）错误。其他错误则源于使用指针的语法规则，特别是声明指针的语法。许多有用的程序都可不使用数组或指针实现，现代C++采用vector类型和迭代器取代一般的数组、采用string类型取代C风格字符串。</p>
<hr>
<p>如果可能的话，除非所指向的对象已经存在，否则不要先定义指针，这样可以避免定义一个未初始化的指针。如果必须分开定义指针和其所指向的对象，则将指针初始化未0。因为编译器可检测出0值的指针，程序可判断该指针并未指向一个对象。</p>
<hr>
<p>C++提供了一种特殊的指针类型 <code>void*</code>，它可以保存任何类型对象的地址。<code>void*</code>表明改指针与一地址值相关，但不清楚存储在此地址上的对象的类型。<code>void*</code>指针只支持几种有限的操作：与另一个指针进行比较；向函数传递<code>void*</code>指针或从函数返回<code>void*</code>指针；给另一个<code>void*</code>指针赋值。不允许使用<code>void*</code>指针操纵它所指向的对象。</p>
<hr>
<p>如果对左操作数进行解引用，则修改的是指针所指对象的值；如果没有使用解引用操作，则修改的是指针本身的值。</p>
<hr>
<p>如果指针指向const对象，则不允许用指针来改变其所指的const值。为了保证这个特性，C++语言强制要求指向const对象的指针也必须具有const特性：</p>
<pre><code>const double *cptr ;        // cptr may point to a double that is const
</code></pre><p>这里cptr是一个指向double类型const对象的指针，const限定了cptr指针所指向的对象类型，而并非cptr本身。也就是说cptr本身并不是const（这里推荐从右向左读以上语句，就可以理解为cptr指向一个const的double类型）。在定义的时候不需要初始化，也可以对其重新赋值，但不能通过cptr修改其所指向对象的值；把你个const对象的地址赋给一个普通的、非const对象的指针也会导致编译时的错误；不能使用<code>void*</code>指针保存const对象的地址，而必须使用<code>const void*</code>类型的指针保存const对象的地址；允许把const对象的地址赋给指向const对象的指针。</p>
<hr>
<p>不能使用指向const对象的指针修改基础对象，然后如果该指针指向的是一个非const对象，可用其他方法修改其所指的对象。</p>
<pre><code>const double *cptr;
dval = 3.14159;     // dval is not const
*cptr = 3.14159;        // error: cptr is a pointer to const
double *ptr = &amp;dval;        // ok: ptr points at non-const double
*ptr = 2.72;            // ok: ptr is plain pointer
cout &lt;&lt; *cptr;          // ok: prints 2.72
</code></pre><hr>
<p>从本质上说，由于没有方法分辨cptr所指的对象是否为const，系统会把它所有对象都视为const。如果指向const的指针所指的对象并非const，则可直接给该对象赋值或间接地利用普通地非const指针修改其值：毕竟这个值不是const。就是说不能保证指向const地指针所指对象的值一定不能修改。</p>
<hr>
<p>C++还提供了const指针——本身的值不能修改。任何企图给const指针赋值的行为（即使是赋同样的值）都会导致编译时的错误。定义方式如下：</p>
<pre><code>const double pi ＝ 3.14159；
const double *const pi_ptr = &amp; pi;
// pi_ptr is const and points to a const object
</code></pre><hr>
<p>C风格字符串（C-style character string）是以空字符null结束的字符数组。尽管C++支持C风格字符串，但不应该在C++程序中使用这个类型。C风格字符串常常带来许多错误，是导致大量安全问题的根源。</p>
<hr>
<p>可以这么样利用循环测试C风格字符串：</p>
<pre><code>const char *cp = “some value”;
while (*cp){
++cp；//注意一定是C风格字符串，因为这样才能保证结尾是null，否则不能结束
}
</code></pre><hr>
<p>用关系操作符（&gt; &lt; ==）来比较C风格字符串时，比较的时指针上存放的地址值，而不是它们所指向的字符串。</p>
<hr>
<p>调用者必须确保目标字符串具有足够的大小，但是却有潜在的严重错误。如果必须使用C风格字符串，strncat和strncpy比strcat和strcpy函数更安全。诀窍就是可以适当地控制复制字符地个数。特别是在复制和串联字符串时，一定要时刻记住算上结束符null。所以尽可能使用标准库类型string，不但安全性增强了，效率也提高了。</p>
<hr>
<p>数组类型的变量有三个重要的限制：数组长度固定不变，在编译时必须直到其长度，数组只有在定义它的块语句内存在。每一个程序在执行时都占用一块可用的内存空间，用于存放动态分配的对象，此内存空间称为程序的自由存储区（free store）或堆（heap）。C语言程序使用一对标准库函数malloc和free在自由存储区中分配存储空间，而C++语言则使用new和delete表达式实现相同的功能。</p>
<hr>
<p>允许动态分配空数组（编译的时候并不知道数组的长度）。可以用以下代码实现</p>
<pre><code>size_t n = get_size()   // get_size returns of elements needed
int* p = new int[n];
for(int* q = p; q !=p+n; ++q)
.........(可见ex3.17-3.21)
</code></pre><p>有趣的是，即使get_size返回的是0，代码依然可以正确执行。C++虽然不允许定义长度为0的数组变量，但明确指出，调用new动态创建长度为0的数组是合法的，返回有效的非零指针。</p>
<hr>
<p>动态分配的内存最后必须进行释放。C++为指针提供了delete []表达式释放指针所指向的数组空间。如 delete [ ] pia；就回收了pia指向的数组。如果遗漏了空方括号对，就无法告诉编译器该指针指向的是数组，将导致程序在运行时出错。</p>
<hr>
<p>使用数组初始化vector对象，必须指出用于初始化式的第一个元素以及数组最后一个元素的下一位置的地址：</p>
<pre><code>const size_t arr_size = 6;
int int_arr[arr_size] = {0,1,2,3,4,5};
// ivec has 6 elements: each a copy of the corresponding element in int_arr
vector&lt;int&gt; ivec(int_arr, int_arr + arr_size);
</code></pre><p>传递给ivec的两个指针标出了vector初值的范围。第二个指针指向被复制的最后一个元素之后的地址空间。</p>
<hr>
<p>用typedef简化指向多维数组的指针</p>
<pre><code>typedef int int_array[4];
int_array *ip = ia;
for (int_array *p = ia; p != ia + 3; ++p)
    for(int *q = *p; q != *p + 4; ++q)
        cout &lt;&lt; *q &lt;&lt; endl;
</code></pre><hr>
<p>逻辑与和逻辑或操作符总是先计算其左操作数，然后再计算其右操作数。只有仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解其右操作数。我们称这种求值策略为“短路求值（short-circuit evaluation）”。这么就引出了一个很有价值的用法：如果某边界条件使expr2的计算变得危险，那么显然expr1的计算结果为false。（expr1 &amp;&amp;(||)expr2）</p>
<hr>
<p>不应该串接使用关系操作符，虽然是左结合，但是由于其返回bool类型的结果，如果多个关系操作符串接起来使用，结果往往出乎意料。</p>
<hr>
<p>val本身是bool类型，或者val具有可转换为bool类型的数据类型。如果val是bool类型，那么if（val == true ）等价于 if（val）。</p>
<p>若val不是bool值，val和true的比较等效于 if （val == 1）</p>
<hr>
<p>位操作符使用整型的操作数。位操作符将其整型操作数视为二进制位的集合，为每一位提供检验和设置的功能（也可用于bitset类型）。位操作符操纵的整数的类型可以是有符号的也可以是没有符号的。如果操作数为负数，具体的处理情况就要依照机器的情况来判定，所以保险起见，用unsigned整型操作数。</p>
<hr>
<p>一般而言，标准库提供的bitset操作更直接，更容易阅读和书写、正确使用的可能性更高。而且，bitset对象的大小不受unsigned数的位数限制。通常来说，bitset优于整形术句的低级直接位操作。</p>
<hr>
<p>在赋值操作上加圆括号是必需的，因为赋值操作符的优先级低于不等操作符。</p>
<hr>
<p>对于for循环来说，例如：for（语句1；条件；增殖）这样的，先执行语句1，再判断是否满足条件，满足的话执行完循环体，再进行增殖，这里使用++i与i++的效果是一样的。但是只有再必要时才使用后置操作符（i++），因为前置操作需要做的工作更少。只需加1后返回加1后的结果即可。而后置操作符则必须先保存操作数原来的值，以便返回未加1之前的值作为操作的结果。对于int型对象和指针，编译器可优化掉这项额外工作。但是对于更多的复杂迭代器类型，这种额外工作可能花费更大的代价。因此，养成使用前置操作这个好习惯，就不必担心性能差异的问题。</p>
<hr>
<p>sizeof操作符的作用是返回一个对象或类型名的长度，返回值的类型为size_t，长度的单位是字节。sizeof表达式的结果是编译时常量。</p>
<hr>
<p>对char类型或值为char类型的表达式做sizeof操作保证得1。</p>
<p>对引用类型做sizeof操作将返回存放此引用类型对象所需的内存空间大小。</p>
<p>对指针做sizeof操作将返回存放指针所需的内存大小；注意，如果要获取该指针所指向的对象的大小，则必须对该指针进行解引用。</p>
<p>对数组做sizeof操作等效于将对其元素类型做sizeof的结果乘上数组元素的个数。所以用sizeof数组的结果除以sizeof其元素类型的结果，即可求得数组元素的个数。</p>
<hr>
<p>逗号表达式是一组由逗号分隔的表达式，这些表达式从左向右计算。逗号表达式的结果是其最右边表达式的值。</p>
<hr>
<p>含有两个或更多操作符的表达式称为复合表达式（compound expression）。在复合表达式中，操作数和操作符的结合方式决定了整个表达式的值。表达式的结果会因为操作符和操作数的分组结合方式的不同而不同。操作数的分组结合方式决定了整个表达式的值。表达式的结果会因为操作符和操作数的分组结合方式的不同而不同。优先级规定的是操作数的结合方式，但并没有说明操作数的计算顺序。在大多数情况下，操作数一般以最方便的次序求解。</p>
<hr>
<p>以下两个指导原则有助于处理复合表达式：</p>
<p>（1）如果有怀疑，则在表达式上按程序逻辑要求使用圆括号强制操作数的组合。</p>
<p>（2）如果要修改才做数的值，则不要在同一个语句的其他地方使用该操作数。如果必须使用改变的值，则把该表达式分割成两个独立语句：在一个语句中改变操作数的值，再在下一个语句使用它。</p>
<p>一个表达式里，不要在两个或更多的子表达式中对同一对象做自增或自减操作。</p>
<hr>
<p>定义变量时，必须指定其数据类型和名字。而动态创建对象时，只需指定其数据类型，而不必为该对象命名。取而代之的是，new表达式返回指向新创建对象的指针，我们通过该指针来访问此对象：</p>
<pre><code>int *pi = new int;  //pi points to dynamically allocated, unnamed, uninitialized int
</code></pre><p>这个new表达式在自由存储区中分配创建了一个整型对象，并返回此对象的地址，并用该地值初始化指针pi。</p>
<hr>
<p>动态创建的对象可用初始化变量的方式实现初始化：</p>
<pre><code>int *pi = new int(1024);        // object to which pi points is 1024
string *ps = new string(10, ‘9’);   // *ps is “9999999999”
</code></pre><p>正如我们（几乎）总是要初始化定义为变量的对象一样，在动态创建对象时，（几乎）总是对它做初始化也是一个好办法。</p>
<hr>
<p>动态创建的对象用完后，程序员必须显式地将该对象占用地内存返回给自由存储区。可以使用delete表达式释放指针所指向地地址空间。如：</p>
<pre><code>delete pi；该命令释放pi指向的int型对象占用的内存空间。
</code></pre><p>若指针指向不是用new分配的内存地址，则在该指针上使用delete是不合法的。C++没有明确定义如何释放指向不是用new分配的内存地址的指针。</p>
<hr>
<p>执行语句 delete p；之后，p变成没有定义。在很多机器上，尽管p没有定义，但仍然存放了它之前所指向的地址，然而p所指向的内存已经被释放，因此p不再有效。删除指针后，该指针变成悬垂指针（dangling pointer）。悬垂指针指向曾经存放对象的内存，但该对象已经不再存在了。悬垂指针往往导致程序错误，而且很难检测出来。</p>
<p>一旦删除了指针所指向的对象，立即将指针置为0，这样就非常清楚地表明指针不再指向任何对象。</p>
<hr>
<p>const对象地动态分配和回收</p>
<pre><code>const int *pic = new const int(1024);
</code></pre><p>动态创建的const对象必须在创建时初始化，并且一经初始化，其值就不能修改。</p>
<pre><code>delete pic；// ok: deletes a const object
</code></pre><hr>
<p>将enum对象或枚举成员提升为什么类型由机器定义，并且依赖于枚举成员的最大值。无论其最大值时什么，enum对象或枚举成员至少提升为int型。</p>
<hr>
<p>当使用非const对象初始化const对象的引用时，系统将非const对象转化为const对象。此外，还可以将非const对象的地址（或非const指针）转换为const类型的指针。</p>
<hr>
<p>显式转换也称为强制类型转换（cast），包括以下名字命名的强制类型转换操作符：static_cast、dynamic_cast、const_cast和reinterpret_cast。</p>
<p>虽然有时候确实需要强制类型转换，但是它们本质上是非常危险的。</p>
<hr>
<p>因为要覆盖通常的标准转换，所以需要显式使用强制类型转换</p>
<pre><code>double dval;
int ival;   //这里要先将ival转换称double型，然后再把double型的结果
ival *= dval;   //截取为int型，再赋值给ival。
</code></pre><p>为了去掉这个不必要的转换，可以强制将ival转换为int型<br>    ival *= static_cast<int>(dval);</int></p>
<p>显式使用强制类型转换的另一个原因是可能存在多种转换，需要选择一种特定的类型转换。</p>
<hr>
<p>const_cast，将转换掉表达式的const性质。dynamic_cast支持运行时识别指针或引用所指向的对象。reinterpret_cast通常为操作数的位模式提供较低层次的重新解释。</p>
<p>reinterpret_cast本质上依赖于机器。为了安全地使用reinterpret_cast，要求程序员完全理解所设计地数据类型，以及编译器实现强制类型转换的细节。</p>
<hr>
<p>编译器隐式执行的任何类型转换都可以由static_cast显式完成</p>
<pre><code>double d = 97.0;
char ch = static_cast&lt;char&gt;(d);
</code></pre><p>当需要将一个较大的算术类型赋值给较小的类型时，使用强制转换非常有用。此时强制类型转换告诉程序的读者和编译器：我知道并且不关心潜在的精度损失。这样警告信息就会消失。如果编译器不提供自动转换，使用<code>static_cast</code>来执行类型转换也是很有用的。例如下面的程序使用<code>static_cast</code>找回存放在<code>void*</code>指针中的值：</p>
<pre><code>void *p = &amp;d;
double *dp = static_cast&lt;double*&gt;p;
</code></pre><hr>
<p>强制类型转换关闭或挂起了正常的类型检查。强烈建议程序员避免使用强制类型转换，不依赖强制类型转换也能写出很好的C++程序。这个建议再如何看待<code>reinterpret_cast</code>的使用时非常重要。此类强制转换总是非常危险的。相似地，使用<code>const_cast</code>也总是预示着设计缺陷。设计合理的系统不需要使用强制类型转换抛弃const特性。如果非强制转换不可，则应限制强制转换值的作用域，并且记录所有假定涉及的类型，这样能减少错误发生的机会。</p>
<hr>
<p>如果在程序的某个地方，语法上需要一个语句，但逻辑上并不需要，此时应该使用空余句。这种用法常见于在循环条件判断部分就能完成全部循环工作的情况。</p>
<p>使用空语句时应该加上注释，以便任何读这段代码的人都知道该语句是有意义的。</p>
<hr>
<p>在条件表达式中定义的变量必须初始化，该条件检验的就是初始化对象的值。这种变量的作用域限制在语句体内。通常，语句体本身就是一个块语句，其中也可能包含了其他的块。一个在控制结构里引入的名字是该语句的局部变量，其作用域限在语句内部。</p>
<hr>
<p>很多编辑器和开发环境都提供工具自动根据语句结构缩排源代码。有效地利用这些工具将是一种很好的编程方法。</p>
<hr>
<p>所有语言的if语句普遍存在着潜在的二义性。这种情况往往称为悬垂else（dangling-else）问题，C++中悬垂else问题带来的二义性，通过将else匹配给最后出现的尚未匹配的if子句来解决。</p>
<hr>
<p>尽管没有严格要求在switch结构的最后一个标号之后指定break语句，但是，为了安全起见，最好在每个标号后面提供一个break语句，即使是最后一个标号也一样。如果以后在switch结构的末尾又需要添加一个新的case标号，则不用再前面添加break语句了。</p>
<p>故意省略case后面的break语句是很罕见的，因此应该提供一些注释说明其逻辑。</p>
<hr>
<p>default标号（default label）提供了相当于else子句的功能。如果所有的case标号与switch表达式的值都不匹配，并且default标号存在，则执行default标号后面的语句。哪怕没有语句要在default标号下执行，定义default标号仍然是有用的。定义default标号是为了告诉它的读者，表明这种情况已经考虑到了，只是没有什么要执行的。</p>
<hr>
<p>再循环条件中定义的变量再每次循环里都要经历创建和撤销的过程。</p>
<hr>
<p>do while循环保证循环体至少执行一次，并且总是以分号结束。</p>
<hr>
<p>goto语句提供了函数内部的无条件跳转，实现从goto语句跳转到同一函数内某个带标号的语句。语法规则位：    goto label； 其中label是用于标识带标号的语句的标识符。再任何语句前提供一个标识符和冒号，即得带标号得语句（labeled statement）：</p>
<pre><code>end： return；    // labeled statement, may be target of a goto
</code></pre><p>goto语句不能跨越变量得定义语句向前跳转：</p>
<pre><code>//  ...
goto end;
int ix = 10;        // error: goto bypasses declaration statement

end:
// error: code here could use ix but the goto bypassed its declaration
ix =  42;
</code></pre><p>如果确实需要再goto和其跳转对应得标号之间定义变量，则定义必须放在一个块语句中：</p>
<pre><code>// ...
goto end;
{
    int ix = 10;
    // ...code using ix
}
end: // ix no longer visible here
</code></pre><p>向后跳过已经执行得变量定义语句是合法的。</p>
<p>再涉及各种软件系统的过程中，处理程序中的错误和其他反常行为是最困难的部分之一。异常就是运行时出现的不正常，例如运行时耗尽了内存或遇到意外的非法输入。异常存在于程序的正常功能之外，并要求程序立即处理。在设计良好的系统中，异常是程序错误处理的一部分。当程序代码检查到无法处理的问题时，异常处理就特别有用。在这些情况下，检测出问题的那部分程序需要一种方法把控制权转到可以处理这个问题的那部分程序。错误检测程序还必须指出具体出现了什么问题，并且可能需要提供一些附加信息。</p>
<hr>
<p>异常机制提供程序中错误检测与错误处理部分之间的通信。C++的异常处理中包括：</p>
<p>throw表达式（throw expression），错误检测部分使用这种表达式来说明遇到了不可处理的错误。可以说，throw引发（raise）了异常条件。</p>
<p>try块（try block），错误处理部分使用它来处理异常。try语句块以try关键字开始，并以一个或多个catch子句（catch clause）结束。在try块中执行的代码所抛出（throw）的异常，通常会被其中一个catch子句处理。由于它们“处理”异常，catch子句也称为处理代码（handler）</p>
<p>由标准库定义的一组异常类（exception class），用来在throw和相应的catch之间传递有关的错误信息。</p>
<hr>
<p>系统通过throw表达式抛出异常。throw表达式由关键字throw以及尾随的表达式组成，通常以分号结束，这样它就称为了表达式语句。throw表达式的类型决定了所抛出异常的类型。下面是用throw抛出异常来改写检测代码(判断是否是同一本书，如果不是就输出信息并退出)：</p>
<pre><code>// first check that data is for the same item
if(!item1.same_isbn(item2))
    throw runtime_error(“Data must refer to same ISBN”);
// ok, if we’re still here the ISBNs are the same
std::cout &lt;&lt; item1 + item2 &lt;&lt; std::endl;
</code></pre><p>throw语句使用了一个表达式。这里是用的是runtime_error类型的对象，此类型是标准库异常类中的一种，在stdexcept头文件中定义，这样就可以提供更多相关信息。</p>
<hr>
<p>try块的通用语法形式是：</p>
<pre><code>try{
    program-statements
} catch (exception-specifier){
    handler-statements
} catch (exception-specifier){
    handler-statements
}   //......
</code></pre><p>try块以关键字try开始，后面是用花括号括起来的语句序列块。try块后面是一个或多个catch子句。每个catch子句包括三部分：关键字catch，圆括号内单个类型或者单个对象的声明，称为异常说明符（exception specifier），以及通常用花括号括起来的语句块。如果选择了一个catch子句来处理异常，则执行相关的块语句。一旦catch子句执行结束，程序流程立即继续执行紧随着最后一个catch子句的语句。try语句内的program-statement形成程序的正常逻辑。这里面可以包含任意C++语句，包括变量声明。与其他语句一样，try块引入局部作用域，在try块中声明的变量，包括catch子句中声明的变量，不能在try外面引用。</p>
<hr>
<p>对于111中抛出的错误，与用户交互的部分可能会包括以下代码：</p>
<p>   while(cin &gt;&gt; item1 &gt;&gt; item2 ){<br>        try{<br>        // execute code that will add the two Sales_items<br>        // if the addition fails, the code throws a runtime_error exception<br>    } catch(runtime_error err){<br>        // remind the user that ISBN must match and prompt for another pair<br>        cout &lt;&lt; err.what()<br>                &lt;&lt; “\nTry Again? Enter y or n” &lt;&lt; endl;<br>        char c;<br>        cin &gt;&gt; c;<br>        if(cin &amp;&amp; c == ‘n’)<br>            break;      //break out of the while loop<br>        }<br>    }</p>
<p>通过输出err.what()的返回值提示用户。这里what返回的C风格字符串，是用于初始化runtime_error的string对象的副本。</p>
<hr>
<p>在复杂的系统中，程序的执行路径也许在遇到抛出异常的代码之前，就已经经过了多个try块。例如一个try块可能调用了包含另一try块的函数，它的try块又调用了含有try块的另一函数，如此类推。</p>
<p>寻找处理代码的过程与函数调用链刚好相反。抛出一个异常时，首先要搜索的是抛出异常的函数。如果没有找到匹配的catch，则终止这个函数的执行，并在调用这个函数的函数中寻找相配的catch。如果仍然没有找到相应的处理代码，该函数同样要终止，搜索调用它的函数。如此类推，继续按执行路径回退，直到找到适当类型的catch为止。</p>
<p>如果不存在处理该异常的catch子句，程序的运行就要跳转到名为terminate的标准库函数，该函数在exception头文件中定义。通常情况下，其执行将导致程序非正常退出。</p>
<p>抛出异常的语句要在try中···不然会挂掉的。</p>
<hr>
<p>C++标准库定义了一组类，用于报告在标准库中函数遇到的问题。程序员可在自己编写的程序中使用这些标准异常类。exception头文件定义了最常见的异常类，类名是exception。这个类只通知异常的产生，不会提供更多的信息。stdexcept头文件定义了几种常见的异常类。new头文件定义了bad_alloc异常类型，提供因无法分配内存而由new抛出的异常。type_info头文件定义了bad_cast异常类型。</p>
<p>标准库异常类只提供很少的操作，包括创建、赋值异常类型对象以及异常类型对象的赋值。exception、bad_alloc以及bad_cast类型只定义了默认构造函数，无法在创建这些类型的对象时为它们提供初值。其他的异常类则只定义了一个使用string初始化式的构造函数，用于为所发生的错误提供更多的信息。</p>
<p>异常类型只定义了一个名为what的操作。这个函数不需要任何参数，并且返回const char*类型的值。它返回的指针指向一个C风格字符串，用来提供对异常的更详细的文字描述。</p>
<hr>
<p>C++程序员有时候也会使用预处理技术来有条件地执行用于调试的代码。这种想法是：程序所包含的调试代码仅在开发过程中执行，当应用程序已经完成，并且准备提交时，就会将调试代码关闭。可使用NDEBUG预处理变量实现有条件的调试代码。</p>
<pre><code>int main(){
#ifndef NDEBUG
cerr &lt;&lt; “starting main” &lt;&lt; endl;
#endif
// .......
</code></pre><p>如果NDEBUG未定义，那么程序就会将信息写到cerr中。如果NDEBUG已经定义了，那么程序执行时将会跳过#ifndef和#endif之间的代码。</p>
<hr>
<p>预处理器还定义了其余四在调试时非常有用的常量：</p>
<pre><code>_ _FILE_ _ 文件名              _ _LINE_ _ 当前行号
_ _TIME_ _ 文件被编译的时间     _ _DATE_ _ 文件被编译的日期
</code></pre><p>另一个常见的调试技术是使用NDEBUG预处理变量以及assert（断言）预处理宏（preprocessor macro）。assert宏是在cassert头文件中定义的。预处理宏有点像函数调用。assert宏需要一个表达式作为它的条件： assert（expr）<br>只要NDEBUG未定义，assert宏就求解表达式expr，如果结果为false，assert输出信息并且终止程序的执行。如果该表达式有一个非零，则assert不做任何操作。在成品代码中，assert语句不做任何工作，因此也没有任何运行时的代价。当然，也不会引起任何运行时的检查。assert仅用于检查确实不可能的条件，这只对程序的测试有帮助，但不能用来代替运行时的逻辑检查，也不能代替对程序可能产生的错误检测。</p>
<hr>
<p>函数可以看作程序员定义的操作。与内置操作符相同的是，每个函数都会实现一系列的计算。但与操作符不同的是，函数是有自己的函数名，而且操作数没有数量限制。与操作符一样，函数可以重载，这意味着同样的函数名可以对应多个不同的函数。</p>
<hr>
<p>函数不能返回另一个函数或者内置数组类型，但可以返回指向函数的指针，或者指向数组元素的指针的指针。C++是一种静态强类型语言，对于每一次的函数调用，编译时都会检查其实参。</p>
<hr>
<p>每次调用函数时，都会重新创建该函数所有的形参，此时所传递的实参将会初始化对应的形参。型材的初始化与变量的初始化一样：如果形参具有非引用类型，则赋值实参的值，如果形参为引用类型，则它只是实参的别名。</p>
<hr>
<p>普通的非引用类型的参数通过复制对应的实参实现初始化。当用实参副本初始化形参时，函数并没有访问调用所传递的实参本身，因此不会修改实参的值。非引用形参表示对应实参的局部副本。对这类形参的修改仅仅改变了局部副本的值。一旦函数执行结束，这些局部变量的值也就没有了。</p>
<hr>
<p>指针形参是指向const类型还是非const类型，将影响函数调用所使用的实参。在调用函数时，如果该函数使用非引用的非const形参，则既可给该函数传递const实参，也可传递非const的实参。</p>
<hr>
<p>复制实参并不是在所有的情况下都适合，不适合复制实参的情况包括：<br>当需要在函数中修改实参的值时。</p>
<p>当需要以大型对象作为实参传递时。对实际的应用而言，复制对象所付出的时间和存储空间代价往往过大。</p>
<p>当没有办法实现对象的复制时。</p>
<p>对于上述几种情况，有效的解决办法是将形参定义为引用或指针类型。</p>
<hr>
<p>如果想要在函数中交换实参的值，需要将形参定义为引用类型：</p>
<pre><code>void swap(int &amp;v1,int &amp;v2){
int temp = v2; v2 = v1; v1 =  temp;
}
</code></pre><p>与所有引用一样，引用形参直接关联到其所绑定的对象，而非这些对象的副本。定义引用时，必须用与该引用绑定的对象初始化该引用。引用形参完全以相同的方式工作。每次调用函数，引用形参被创建并与相应实参关联。</p>
<hr>
<p>使用引用形参返回额外的信息。例如，定义一个<code>find_val</code>函数，在一个整型vector对象的元素中搜索某个特定值。如果找到满足要求的元素，则返回指向该元素的迭代器；否则返回一个迭代器，执行该vector对象的end操作返回的元素。此外，如果该值出现了不止一次，我们还希望函数可以返回其出现的次数。在这种情况下，返回的迭代器应该指向具有要寻找的值的第一个元素。</p>
<p>我们可以定义一种包含一个迭代器和一个计数器的新类型。而更简便的解决方案给<code>find_val</code>传递一个额外的引用实参，用于返回出现册数的统计结果。</p>
<pre><code>// returns an iterator that refers to the first occurrence of value
// the reference parameter occurs contains a second return value
vector&lt;int&gt;::const_iterator find_val(
    vector&lt;int&gt;::const_iterator beg,        // first element
    vector&lt;int&gt;::const_iterator end,        // one past last element
    int value,                  // the value we want
    vector&lt;int&gt;::size_type &amp;occurs)     // number of times it occurs
{
    // res_iter will hold first occurrence, if any
    vector&lt;int&gt;::const_iterator res_iter = end;
    occurs = 0;                 // set occurrence count parameter
    for( ; beg != end; ++beg)
        if(*beg == value) {
            // remember first occurrence of value
            if(res_iter == end)
            res_iter = beg;
            ++occurs;               // increment occurrence count
    }
    return res_iter;                // count returned implicitly in occurs
}
</code></pre><p>调用<code>find_val</code>时，需传递四个实参：一对标识vector对象中要搜索的元素范围的迭代器，所查找的值，以及用于存储出现次数的<code>size_type</code>类型对象。假设ivec是vecter<int>类型的对象，it是一个适当类型的迭代器，而ctr则是size_type类型的变量，则可如此调用该函数：  </int></p>
<pre><code>it = find_val(ivec.begin(), ivec.end(), 42, ctr);
</code></pre><p>调用后，ctr的值将是42出现的次数，如果42在ivec中出现了，则it将指向其第一次出现的位置；否则it的值为ivec.end()，而ctr则为0。</p>
<hr>
<p>在向函数传递大型对象时，需要使用引用形参，对于大部分的类类型或者大型数组，复制实参的效率就太低了，此时就可以利用const引用直接访问实参对象，无须复制。</p>
<p>如果使用引用形参的唯一目的是避免复制实参，则应将形参定义为const引用。</p>
<hr>
<p>应该将不需要修改的引用形参定义为const引用。普通的非const引用形参在使用时不太灵活。这样的形参既不能用const对象初始化，也不能用字面值或产生右值的表达式实参初始化。</p>
<hr>
<p>通常，函数不应该有vector或其他标准库容器类型的形参。。调用含有普通的非引用vector形参的函数将会复制vector的每一个元素。从避免复制vector的角度出发，应考虑将形参声明为引用类型。事实上，C++程序员倾向于通过传递指向容器中需要处理的元素的迭代器来传递容器。</p>
<pre><code>// pass iterators to the first and one past the last element to print
void print(vector&lt;int&gt;::const_iterator beg,
    vector&lt;int&gt;::const_iterator end){
    while (beg != end){
        cout &lt;&lt; *beg++;
        if (beg != end)   cout &lt;&lt; “ ”;  // no space after last element
    }
cout &lt;&lt; endl;
}
</code></pre><hr>
<p>通常，将数组形参直接定义为指针要比使用数组语法定义更好。这样就明确地表示，函数操纵的是指向数组元素的指针，而不是数组本身。由于护绿了数组长度，形参定义中如果包含了数组长度则特别容易引起误解。当编译器检查数组形参关联的实参时，它只会检查实参是不是指针、指针的类型和数组元素的类型是否匹配，而不会检查数组的长度。</p>
<hr>
<p>若形参是数组的引用，编译器不会将数组实参抓化为指针，而是传递数组的引用本身。在这种情况下，数组大小称为形参和实参类型的一部分。编译器检查数组实参的大小与形参大小是否相配。</p>
<hr>
<p>和其他数组一样，多为数组以指向0号元素的指针方式传递。多维数组的元素本身就是数组。除了第一维以外的所有维德长度都是元素类型的一部分，必须明确指定：</p>
<pre><code>// first parameter is an array whose elements are arrays of 10 ints
void printValues(int (matrix*)[10], int rowSize);
</code></pre><p>除了第一维以外的所有维德长度都是元素类型的一部分，必须明确指定。我们也可以用数组语法定义多维数组。与一维数组一样，编译器忽略第一维的长度，所以最好不要把它包括在形参表内。</p>
<hr>
<p>非引用数组形参的类型检查只是确保实参是和数组元素具有同样类型的指针，而不会检查实参实际上是否指向指定大小的数组。任何处理数组的程序都要确保程序停留在数组的边界内。</p>
<hr>
<p>有三种常见的编程技巧确保函数的操作部超出数组实参的边界。第一种方法是在数组本身放置一个标记来检测数组的结束。C风格字符串就是采用这种方法的一个例子。第二种方法是传递指向数组第一个和最后一个元素的下一个位置的指针，这样就可以确定一个元素范围，程序就会安全。点钟方法是将第二个形参定义为表示数组的大小，即显示传递表示数组大小的形参。</p>
<hr>
<p>return语句用于结束当前正在执行的函数，并将控制权返回给调用此函数的函数。可以返回值，也可以不返回。不带返回值的return语句只能用于返回类型为void的函数。在返回类型为void的函数中，return返回语句不是必需的，隐式的return发生在函数的最后一个语句完成时。一般情况下，返回类型是void的函数使用return语句是为了引起函数的强制结束。在含有return语句的循环后没有提供return语句是很危险的，因为大部分的编译器不能检测出这个漏洞，运行时会出现什么问题是不确定的。</p>
<hr>
<p>返回类型不是void的函数必需返回一个值，但此规则有一个例外情况：允许主函数main没有返回值就可结束。</p>
<hr>
<p>返回非引用类型的时候，return都会在调用该函数的时候复制返回的对象。而返回引用类型的时候则是不复制的。</p>
<hr>
<p>理解返回引用至关重要的是：千万不能返回局部变量的引用。当函数执行完毕时，将释放分配给局部对象的存储空间。此时，对局部对象的引用就会指向不确定的内存。</p>
<p>确保返回引用安全的一个好方法是：请自问，这个引用指向哪个在此之前存在的对象？</p>
<hr>
<p>函数定义就是写明具体的执行过程，声明就是告诉编译器要使用这个函数。函数声明由函数返回类型、函数名和形参列表组成。形参列表必须包括形参类型，但是不必对形参命名。这三个元素被称为函数原型（function prototype），函数原型描述了函数的接口。</p>
<hr>
<p>函数也应当在头文件中声明，并在源文件中定义。定义函数的源文件应包含声明该函数的头文件。</p>
<hr>
<p>因为char是整形，因此把一个char值传递给int型形参是合法的，反之亦然。</p>
<hr>
<p>在C++语言中，每个名字都有作用域，而每个对象都有生命期（lifetime）。要弄清楚函数是怎么运行的，理解这两个概念十分重要。名字的作用域指的是知道该名字的程序文本区。对象的生命期则是在程序执行过程中对象存在的时间。</p>
<hr>
<p>默认情况下，局部变量的生命期局限于所在函数的每次执行期间。只有当定义它的函数被调用时才存在的对象称为自动对象（automatic object）。自动对象在每次调用函数时创建和撤销。在函数结束后，自动对象和形参的值都不能再访问了。</p>
<hr>
<p>一个变量如果位于函数的作用域内，但是生命期却跨域了这个函数的多次调用，这种变量往往很有用。则应该将这样的对象定义为static（静态的）。static局部对象（static local object）确保不迟于在程序执行流程第一经过该对象的定义语句时进行初始化。这种对象一旦被创建，在程序结束前都不会被撤销。当定义静态局部对象的函数结束时，静态对象不会被撤销。</p>
<pre><code>size_t count_calls(){
    static size_t ctr = 0;  // value will persist across calls
    return ++ctr;
}
int main(){
    for(size_t i = 0; i != 10; ++i)
        cout &lt;&lt; cout_calls() &lt;&lt; endl;
    return 0;
}
</code></pre><p>依次输出1到10（包含10）的整数。</p>
<hr>
<p>内联函数避免函数调用的开销，相当于在调用函数的时候用函数体替换，就可以加快速度。在函数返回类型前加上关键字inline就可以指定为内联函数。内联说明（inline specification）对于编译器来说只是一个建议，编译器可以选择忽略这个建议。一般来说，内联机制适用于优化小的、只有几行而且经常被调用的函数。大多数编译器都不支持递归函数的内联。</p>
<hr>
<p>内联函数应该在头文件中定义，这一点不同于其他函数。在头文件中加入或修改内联函数时，使用了该头文件的所有泊文件都必须得重新编译。</p>
<hr>
<p>成员函数的定义与普通函数的定义类似。和任何函数一样，成员函数也包含下面四个部分：函数返回类型、函数名、用逗号隔开的形参表（也可能是空的）、包含在一对花括号里面的函数体。函数原型必须在类中定义。但是，函数体则既可以在类中也可以在类外定义。类的所有成员都必须在类定义的花括号里声明，此后，就不能再为类增加任何成员。类的成员函数必须如声明的一般定义。类的成员函数既可以在类的定义内也可以在类的定义外定义。编译器隐式地将在类内定义的成员函数当作内联函数。类的成员函数可以访问该类的private成员。</p>
<hr>
<p>每个成员函数（除static成员函数外）都有一个额外的、隐含的形参this。在调用成员函数时，形参this初始化为调用函数的对象的地址。</p>
<hr>
<p>const对象、指向const对象的指针或引用只能调用其const成员函数，如果尝试用它们来调用非const成员函数，则是错误的。</p>
<hr>
<p>在成员函数中，不必显式地使用this指针来访问被调用函数所属对象的成员。对这个类的成员的任何没有前缀的引用，都被假定为通过指针this实现的引用。</p>
<hr>
<p>在类外定义成员函数就必须指明它们是类的成员</p>
<pre><code>double Sales_item::avg_price() const{
if (units_sold)
    return revenue/units_sold;
else
    return 0;
}
</code></pre><p>使用作用域操作符指明函数avg_price是在类Sales_item的作用域范围内定义的。</p>
<hr>
<p>构造函数（constructor）是特殊的成员函数，与其他成员函数不同，构造函数和类同名，而且没有返回类型。而与其他成员函数相同的是，构造函数也有形参表（可能为空）和函数体。一个类可以有多个构造函数，每个构造函数必须有与其他构造函数不同数目或类型的形参。构造函数也必须在类中声明，但是可以在类中或类外定义。构造函数放在类的public部分。</p>
<hr>
<p>如果没有为一个类显式定义任何构造函数，编译器将自动为这个类生成默认构造函数。合成的默认构造函数一般适用于仅包含类类型成员的类。而对于含有内置类型或复合类型成员的类。则通常应该定义他们自己的默认构造函数初始化这些成员。</p>
<hr>
<p>出现在相同作用域中的两个函数，如果具有相同的名字而形参表不同，则成为重载函数（overloaded function）。如果两个函数声明的返回类型和形参表完全匹配，则将第二个函数声明视为第一个的重复声明。如果两个函数的形参表完全相同，但返回类型不同，则第二个声明是错误的。</p>
<hr>
<p>一般作用域规则同样适用于重载函数名。如果局部地声明一个函数，则该函数将屏蔽而不是重载在外层作用域中声明的同名函数。所以，每一个版本的重载函数都应在同一个作用域中声明。一般来说，局部地声明函数时一种不明智的选择。函数的声明应放在头文件中。在C++中，名字查找发生在类型检查之前。</p>
<hr>
<p>函数重载确定（overload resolution，即函数匹配function matching）是将函数调用与重载函数集合中的一个函数相关联的过程。通过自动提取函数调用中实际使用的实参与重载集合中各个函数提供的形参做比较，编译器实现该调用与函数的匹配。</p>
<hr>
<p>为了确定最佳匹配，编译器将实参类型到相应形参类型的转换划分等级。转换等级以降序排列如下：精确匹配（exact match），实参与形参类型相同。通过类型提升（promotion）实现的匹配。通过标准转换（standard conversion）实现的匹配。通过类类型转换（class-type conversion）实现的匹配。</p>
<p>内置类型的提升和转换可能会使函数匹配产生意想不到的结果。但幸运的是，设计良好的系统很少会包含形参类型相当接近的函数。</p>
<hr>
<p>类型提升或转换适用于实参类型可通过某种标准转换提升或转换为适当的形参类型的情况。通过类型提升实现的转换优于其他标准的转换。</p>
<pre><code>void ff(int);
void ff(short);
ff(‘a’);            // char promotes to int, so matches ff(int)
</code></pre><hr>
<p>枚举类型enum的对象只能用同一枚举类型的另一个对象或一个枚举成员（enumerator）进行初始化。整数对象即使具有与枚举元素相同的值也不能用于调用期望获得枚举类型实参的函数。虽然无法将整型值传递给枚举类型的形参，但可以将枚举值传递给整数形参。此时，枚举值被提升为int型或更大的整形。具体的提升类型取决于枚举成员的值。</p>
<hr>
<p>仅当形参是引用或指针时，形参是否为const才有影响。</p>
<hr>
<p>函数指针是指指向函数而非指向对象的指针。像其他指针一样，函数指针也指向某个特定的类型。函数类型由其返回类型以及形参表确定，而与函数名无关。</p>
<pre><code>// pf points to function returning bool that takes two const string references
bool (*pf)(const string &amp;, const string &amp;);
</code></pre><p>其中<code>*pf</code>两侧的括号是必需的。或者是使用typedef为指针类型定义同义词，可将函数指针的使用大大简化。</p>
<pre><code>typedef bool (*cmpFcn) (const string &amp;, const string &amp;);
</code></pre><p>以后使用则直接用cmpFcn即可。</p>
<hr>
<p>在引用函数名但又没有调用该函数时，函数名将被自动解释为指向函数的指针。函数指针只能通过同类型的函数或函数指针或0值常量表达式进行初始化或赋值。</p>
<hr>
<p>指向函数的指针可用于调用它所指向的函数。可以不需要使用解引用操作符，直接通过指针调用函数。函数的形参可以是指向函数的指针。</p>
<hr>
<p>endl操纵符用于输出一个换行符并刷新缓冲区。而flush，用于刷新流，但不在输出中添加任何字符。还有一个比较少用的ends，这个操作符在缓冲区插入空字符null，然后刷新它。如果需要刷新所有输出，最好使用unitbuf操作符。这个操作符在每次执行完写操作后都刷新流： </p>
<pre><code>cout &lt;&lt; unitbuf &lt;&lt; “first” &lt;&lt; “ second” &lt;&lt; nounitbuf;   
</code></pre><p>等价于：</p>
<pre><code>cout &lt;&lt; “first” &lt;&lt; flush &lt;&lt; “second” &lt;&lt; flush;
</code></pre><p>nounitbuf操纵符将流恢复为使用正常的、由系统管理的缓冲区刷新方式。</p>
<hr>
<p>如果程序不正常结束，输出缓冲区将不会刷新。在尝试调试已崩溃的程序时，通常会根据最后的输出找出程序发生错误的区域。如果崩溃出现在某个特定的输出语句后面，则可知是在程序的这个位置之后出错。</p>
<p>调试程序时，必须保证期待写入的每个输出都确实被刷新了。如果需要使用最后的输出给程序错误定位，则必须确定所有要输出地都已经输出。为了确保用户看到程序实际上处理的所有输出，最好的方法是保证所有的输出操作都显式地调用了flush或endl。如果仅因为缓冲区没有刷新，程序员将浪费大量的时间跟踪调试并没有执行的代码。基于这个原因，输出时应多使用endl而非‘\n’。</p>
<hr>
<p>当输入流与输出流绑在一起时，任何读输入流的尝试都将首先刷新其输出流关联的缓冲区。交互式系统通常应确保它们的输入和输出流失绑在一起的。这样做意味着可以保证任何输出，包括给用户的提示，都在试图读之前输出。</p>
<hr>
<p>打开文件后，通常要检验打开是否成功，这是一个好习惯。</p>
<pre><code>// check that the open succeeded
if (!infile){
    cerr &lt;&lt; “error: unable to open input file : ”
        &lt;&lt; ifile &lt;&lt; endl;
    return -1;
}
</code></pre><p>如果程序员需要重用文件流读写多个文件，必须在读另一个文件之前调用clear清楚该流的状态。</p>
<hr>
<p>C++提供了使用抽象进行高效率编程的方式。标准库就是一个很好的例子：标准库定义了许多容器类以及一系列泛型算法，使程序员可以更简洁、抽象和有效地编写程序。这样可以让标准库操心那些繁琐的细节，特别是内存管理，我们的程序只需关注要解决的实际问题就行了。泛型算法中，所谓“泛型(generic)”指的是两个方面：这些算法可作用于各种不同的容器类型，而这些容器又可以容纳多种不同类型的元素。</p>
<p>为容器类型提供通用接口是设计库的目的。容器提供的操作和算法是一致定义的，这使得学习标准库更容易：只需理解一个操作如何工作，就能将该操作应用于其他的容器。更重要的是，接口的一致性使程序变得更灵活。</p>
<hr>
<p>标准库定义了三种顺序容器类型：vector（支持快速随机访问）、list（支持快速插入、删除）和deque（是双端队列“double-ended queue”的简写，发音为 “deck”）。它们的差别在于访问元素的方式，以及添加或删除元素相关操作的运行代价。标准库还提供了三种容器适配器（adaptor）。实际上，适配器是根据原始的容器类型所提供的操作，通过定义新的操作接口，来适应基础的容器类型。顺序容器适配器包括stack（后进先出LIFO栈）、queue（先进先出FIFO）和priority_queue类型（有优先级管理的队列）。容器只定义了少量操作。大多数额外操作则由算法库提供。标准库为由容器类型定义的操作加强了公共的接口。</p>
<hr>
<p>为了定义一个容器类型的对象，必须先包含相关的头文件<vector><list><deque>所有的容器都是类模板。要定义某种特殊的容器，必须在容器名后加一对尖括号，尖括号里面提供容器中存放的元素的类型。所有的容器类型都定义了默认构造函数，用于创建指定类型的空容器对象。为了使程序更清晰、简短，容器类型最常用的构造函数是默认构造函数。在大多数的程序中，使用默认构造函数能达到最佳运行时性能，并且使容器更容易使用。</deque></list></vector></p>
<hr>
<p>将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同。尽管不能将一种容器内的元素复制给另一种容器，但系统允许通过传递一对迭代器间接实现该功能。使用迭代器时，不要求容器类型相同。容器内的元素类型也可以不相同，只要他们相互兼容，能够将要复制的元素转换为所构建的新容器的元素类型，即可实现复制。</p>
<hr>
<p>创建顺序容器时，可显式指定容器大小和一个（可选的）元素初始化式。容器大小可以使常量或非常量表达式，元素初始化式则必须是可用于初始化其元素类型的对象的值。接受容器大小做形参的构造函数只适用于顺序容器，而关联容器不支持这种初始化。</p>
<hr>
<p>C++语言中，大多数类型都可用作容器的元素类型。容器元素类型必须满足以下两个约束：元素类型必须支持赋值运算；元素类型的对象必须可以复制。</p>
<hr>
<p>因为容器受容器元素类型的约束，所以可定义元素是容器类型的容器。例如</p>
<pre><code>vector&lt; vector&lt;string&gt; &gt; lines;     // vector of vectors
</code></pre><p>必须用空格隔开两个相邻的 &gt; 符号，以示这是两个分开的符号，否则，系统会认为&gt;&gt;是单个符号，为右移操作符，并结果导致编译时错误。</p>
<hr>
<p>在整个标准库中，经常使用形参为一对迭代器的构造函数。关系操作符只适用于vector和deque容器，这是因为只有这两种容器为其元素提供快速、随机的访问。它们确保可根据元素位置直接有效地访问指定的容器元素。</p>
<hr>
<p>迭代器范围这个概念是标准库的基础。C++语言使用一对迭代器标记迭代器范围（iterator range），这两个迭代器分别指向同一个容器中的两个元素或超出末端的下一位置，通常将它们命名为first和last，或beg和end，用于标记容器中的一段元素范围。称为左闭合区间（left-inclusive interval），其标准方式为：</p>
<pre><code>// to be read as: includes first and each element up to but not including last
[ first, last )
</code></pre><p>当first与last相等时，迭代器范围为空；</p>
<p>当first与last不相等时，迭代器范围内至少有一个元素，而且first指向该区间中的第一个元素。</p>
<hr>
<p>修改容器的内在状态或移动容器内的元素等操作使所有指向呗移动的元素的迭代器时效，也可能同时使其他迭代器失效。使用无效迭代器时没有定义的，可能会导致与悬垂指针相同的问题。使用迭代器编写程序时，必须留意那些操作会使迭代器失效。使用无效迭代器将会导致严重的运行时错误。</p>
<hr>
<p>使用迭代器时，通常可以编写程序使得要求迭代器有效地代码发内相对较短。然后，在该范围内，严格检查每一条语句，判断是否有元素添加或删除，从而相应地调整迭代器的值。</p>
<hr>
<p>除了push_back运算，list和deque容器类型还提供了类似的操作：push_front。这个操作实现再容器首部插入新元素的功能。</p>
<hr>
<p>再容器中添加元素时，系统是将元素值复制到容器里。类似地，使用一段元素初始化新容器时，新荣期存放的是原始元素的副本。被复制的原始值与新荣期中的元素各不相关，此后，容器内元素值发生变化时，被复制的原值不会收到影响，反之亦然。</p>
<hr>
<p>insert曹走提供了一组更通用的插入方法，实现在容器的任意指定位置插入新元素。</p>
<p>c.insert(p,t) 在迭代器p所指向的元素前面插入值为t的新元素。返回指向新添加元素的迭代器</p>
<p>c.insert(p,n,t) 在迭代器p所指向的元素前面插入n个值为t的新元素。返回void类型</p>
<p>c.insert(p,b,e) 在迭代器p所指向的元素前面插入由迭代器b和e标记的范围内的元素。返回void类型</p>
<hr>
<p>任何insert或push操作都可能导致迭代器失效。当编写循环将元素插入到vector或deque容器中时，程序必须确保迭代器在每次循环后都得到更新。</p>
<hr>
<p>在vector或deque容器中添加元素时，可能会导致某些或全部迭代器失效。假设所有迭代器失效是最安全的做法。这个建议特别适用于由end操作返回的迭代器。在容器的任何位置插入任何元素都会使该迭代器失效。为了避免存储end迭代器，可以在每次做完插入运算后重新计算。</p>
<pre><code>// safer:recalculate end on each trip whenever the loop adds/erases elements
while (first != v.end()){
      // do some processing
      first = v.insert(first, 42); // insert new value
      ++first; // advance first just past the element we added
}
</code></pre><hr>
<p>所有的容器类型都支持用关系操作符来实现两个容器的比较。比较的容器必须具有相同的容器类型，而且其元素类型也必须相同。</p>
<p>如果两个容器具有相同的长度而且所有元素都相等，那么这两个容器就相等；否则，它们就不相等。</p>
<p>如果两个容器的长度不相同，但较短的容器中所有元素都等于较长容器中对应的元素，则称较短的容器小于另一个容器。</p>
<p>如果两个容器都不是对方的初始子序列，则它们的比较结果取决于所比较的第一个不相等的元素。</p>
<hr>
<p>顺序容器大小的操作</p>
<pre><code>c.max_size()      返回容器c可容纳的最多元素个数，返回类型为c::size_type
c.resize(n)          调整容器c的长度大小，使其能容纳n个元素，如果n&lt;c.size()，则删除多出来的元素；否则，添加采用值初始化的新元素
c.resize(n,t)        调整容器c的大小，使其能容纳n个元素。所有新添加的元素值都为t
</code></pre><hr>
<p>resize操作可能会使迭代器失效。在vector或deque容器上做resize操作有可能会使所有的迭代器都失效。对于所有的容器类型，如果resize操作压缩了容器，则指向已删除的元素的迭代器失效。</p>
<hr>
<p>如果容器非空，那么容器类型的front和back成员将返回容器内第一个或最后一个元素的引用。使用越界的下标，或调用空容器的front或back函数，都会导致程序出现严重的错误。使用下标运算的另一个可选方案是at成员函数。这个函数的行为和下标运算相似，但是如果给出的下标无效，at函数将会抛出out_of_range异常。</p>
<hr>
<p>容器类型提供了通用的insert操作在容器的任何位置插入元素，并支持特定的push_front和push_back操作在容器首部或尾部插入新元素。类似地，容器类型提供了通用的erase操作和特定的pop_front和pop_back操作来删除容器内的元素。</p>
<pre><code>c.erase( k )            
</code></pre><p>删除迭代器 k 所指向的元素。返回一个迭代器，它指向被删除元素后面的元素，若 k 指向容器容器内的最后一个元素，则返回的迭代器指向容器的超出末端的下一位置。如果 k 本身就是指向超出末端的下一位置的迭代器，则该函数未定义。</p>
<pre><code>c.erase( b,e )         
</code></pre><p>删除迭代器 b 和 e 所标记的范围内所有的元素。返回一个迭代器，它指向被删除元素段后面的元素。如果 e 本身就是指向超出末端的下一位置的迭代器，那么返回的迭代器也指向容器超出末端的下一位置。</p>
<pre><code>c.clear()                 
</code></pre><p>删除容器 c 内的所有元素。返回void</p>
<pre><code>c.pop_back()         
</code></pre><p>删除容器 c 的最后一个元素。返回void。如果 c 为空容器，则该函数未定义。</p>
<pre><code>c.pop_front()          
</code></pre><p>删除容器 c 的第一个元素。返回void。如果 c 为空容器，则该函数未定义。</p>
<p>以上两个只能用于list或deque容器</p>
<hr>
<p>pop_front操作通常与front操作配套使用，实现以桟的方式处理容器：</p>
<pre><code>while (!ilist.empty()) {
    process(ilist.front());      // do something with the current top of ilist
    ilist.pop_front();       // done;remove first element
}
</code></pre><p>这个循环非常简单：使用front操作获取要处理的元素，然后调用pop_front函数从容器list中删除该元素。pop_front和pop_back函数的返回值并不是删除的元素的值，而是void。要获取删除的元素值，则必须在删除元素之前调用front或back函数。</p>
<hr>
<p>删除一个或一段元素更通用的方法是erase操作。如同其他操作一样，erase操作也不会检查它的参数。必须确保迭代器是有效的。</p>
<hr>
<p>赋值和 assign 操作使得作操作数容器的所有迭代器失效。swap 操作则不会使迭代器失效。完成 swap 后，尽管被交换的元素已经存放在另一容器中，但迭代器仍然指向相同的元素。</p>
<hr>
<p>顺序容器的赋值操作</p>
<pre><code>c1 ＝ c2            删除容器 c1 的所有元素，然后将 c2 的元素复制给 c1。c1 和 c2 的类型（包括容器类型和元素类型）必须相同。
c1.swap(c2)      交换内容：调用完该函数后，c1 中存放的是 c2 原来的元素，c2中存放的则是 c1原来的元素。c1 和 c2 的类型必须相同。该函数的执行速度通常要比将 c2 的元素复制到 c1 的操作快。
c.assign(b,e)     重新设置 c 中的元素：将迭代器 b 和 e 标记的范围内所有的元素复制到 c 中。b 和 e 必须不是指向 c 中元素的迭代器。
c.assign(n,t)      将容器 c 重新设置为存储 n 各值为 t 的元素
</code></pre><hr>
<p>是用 swap 操作以节省删除元素的成本，并且迭代器不会失效，原来指向哪里，现在还是指向哪里。</p>
<hr>
<p>在容器对象中 insert 或压入一个元素时，该对象的大小增加 1。类似地，如果 resize 容器以扩充其容量，则必须在容器中添加额外的元素。比起 list 和 deque 容器，vector 的增长效率通常会更高。会为 vector 预留额外的存储区。</p>
<hr>
<p>capacity 操作获取在容器需要分配更多的存储空间之前能够存储的元素总数，而 reserve 操作则告诉 vector 容器应该预留多少个元素的存储空间。size 指容器当前拥有的元素个数。每当 vector 容器不得不分配新的存储空间时，以加倍当前容量分配策略实现重新分配。vector 的每种实现都可自由地选择自己的内存分配策略。然后，它们都必须提供 reserve 和 capacity 函数，而且必须时到必要时才分配新的内存空间。分配多少内存取决于其实现方式。不同的库采用不同的策略实现。此外，每种实现都要求遵循以下原则：确保 <code>push_back</code> 操作高效地在 vector 中添加元素。从技术上说，在原来为空的 vector 容器上 n 次调用 <code>push_back</code> 函数，从而创建拥有 n 个元素的 vector 容器，其执行时间永远不能超过 n 的常量倍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里是我学习《Thinking in C++》时记录整理的笔记，时间比较久远，不保证时效性。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://wdxtub.com/tags/Cpp/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenMP 入门指南]]></title>
    <link href="http://wdxtub.com/2016/03/20/openmp-guide/"/>
    <id>http://wdxtub.com/2016/03/20/openmp-guide/</id>
    <published>2016-03-20T11:58:43.000Z</published>
    <updated>2016-03-20T12:14:30.000Z</updated>
    <content type="html"><![CDATA[<p>For CMU 18-645 How to write fast code. Learn openmp in an hour!  <a href="http://blog.csdn.net/donhao" target="_blank" rel="external">主要来源</a></p>
<a id="more"></a>
<hr>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><p>这门课作为 ECE 中少有的跟计算机科学相关的课，自然是必上不可。不过无论是 OpenMP 还是 CUDA，对于平时极少接触并行编程的我来说，都是十分吃力的，第一次作业的 OpenMP 编程已经让意识到了个中的差别，当然，在单个核心的计算速度基本达到极致的现在，掌握并行编程可以算是程序员的基本素养，而 OpenMP 其实是一个非常好的开始，简单，易懂，见效飞快。所以我们的旅程，就从这里开始吧。</p>
<h2 id="Hello_OpenMP"><a href="#Hello_OpenMP" class="headerlink" title="Hello OpenMP"></a>Hello OpenMP</h2><p>OpenMP是一种面向共享内存以及分布式共享内存的多处理器多线程并行编程语言。一段简单的代码如下：</p>
<pre><code>#include &lt;omp.h&gt;
#include &lt;iostream&gt;
using namespace std;

int main(){
    #pragma omp parallel for 
    for (int i = 0; i &lt; 10; ++i)
    {
        cout &lt;&lt; i;
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre><p>通过#pragma omp预处理指示符指定要采用OpenMP</p>
<p>通过#pragma omp parallel for来指定下方的for循环采用多线程执行，此时编译器会根据CPU的个数来创建线程数，对于双核系统，编译器会默认创建两个线程执行并行区域的代码。</p>
<p>这段程序的输入如下（省略前面的终端信息）</p>
<pre><code>dawang$ ./a.out
3680479152
dawang$ ./a.out
8603971425
dawang$ ./a.out
3086419752
dawang$ ./a.out
6038714925
</code></pre><h3 id="u5E38_u7528_u7684_u5E93_u51FD_u6570"><a href="#u5E38_u7528_u7684_u5E93_u51FD_u6570" class="headerlink" title="常用的库函数"></a>常用的库函数</h3><p>函数原型 / 功能</p>
<pre><code>返回当前可用的处理器个数
int omp_get_num_procs(void) 

返回当前并行区域中的活动线程个数，如果在并行区域外部调用，返回1
int omp_get_num_threads(void)

返回当前的线程号（个人感觉这里为omp_get_thread_ID好一些）
int omp_get_thread_num(void) 

设置进入并行区域时，将要创建的线程个数
int omp_set_num_threads(void)
</code></pre><p>下面的这个例子演示了四个库函数</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;omp.h&gt;
using namespace std;

int main(){
    cout &lt;&lt; &quot;CPU number: &quot; &lt;&lt; omp_get_num_procs() &lt;&lt; endl;

    cout &lt;&lt; &quot;Parallel area 1: &quot; &lt;&lt; endl;

    #pragma omp parallel //下面大括号内部为并行区域
    {
        cout &lt;&lt; &quot;Num of threads is: &quot; &lt;&lt; omp_get_num_threads();
        cout &lt;&lt; &quot;; This thread ID is &quot; &lt;&lt; omp_get_thread_num() &lt;&lt; endl;
    }

    cout &lt;&lt; &quot;Parallel area 2:&quot; &lt;&lt; endl;
    omp_set_num_threads(4); // 设置为并行区域创建4个线程
    #pragma omp parallel //下面大括号内部为并行区域
    {
        cout &lt;&lt; &quot;Num of threads is: &quot; &lt;&lt; omp_get_num_threads();
        cout &lt;&lt; &quot;; This thread ID is &quot; &lt;&lt; omp_get_thread_num() &lt;&lt; endl;
    }

    return 0;
}
</code></pre><p>大家可以自己运行一次看看自己的输出</p>
<h2 id="u6570_u636E_u76F8_u5173_u6027"><a href="#u6570_u636E_u76F8_u5173_u6027" class="headerlink" title="数据相关性"></a>数据相关性</h2><p>在循环并行化时，由于多个线程同时执行循环，迭代的顺序是不确定的。如果是数据不相关的，则可以采用基本的#pragma omp parallel for预处理器指示符。</p>
<p>如果语句S2与语句S1相关，那么必然存在以下两种情况之一：</p>
<ol>
<li>语句S1在一次迭代中访问存储单元L，而S2在随后的一次迭代中访问统一存储单元，称之为循环迭代相关（Loop-Carried Dependence）；</li>
<li>S1和S2在同一循环迭代中访问统一存储单元L，但S1的执行在S2之前，称之为非循环迭代相关（Loop-Independent Dependence）。</li>
</ol>
<h3 id="for__u5FAA_u73AF_u5E76_u884C_u5316_u7684_u58F0_u660E_u5F62_u5F0F"><a href="#for__u5FAA_u73AF_u5E76_u884C_u5316_u7684_u58F0_u660E_u5F62_u5F0F" class="headerlink" title="for 循环并行化的声明形式"></a>for 循环并行化的声明形式</h3><pre><code>#include &lt;iostream&gt;
#include &lt;omp.h&gt;
using namespace std;

int main(){
    // for 循环并行化声明形式1
    #pragma omp parallel
    {
        #pragma omp for
        for (int i = 0; i &lt; 10; ++i){
            cout &lt;&lt; i &lt;&lt; endl;
        }
    }

    // for 循环并行化声明形式2
    #pragma omp parallel for
    for (int j = 0; j &lt; 10; ++j){
        cout &lt;&lt; j &lt;&lt; endl;
    }
    return 0;
}
</code></pre><p>上边代码的两种声明形式是一样的，很显然第二种声明形式更为简洁紧凑。但是第一种声明形式有一个好处，即可以在并行区域内、for循环以外写其他并行代码。</p>
<h3 id="for__u5FAA_u73AF_u5E76_u884C_u5316_u7684_u7EA6_u675F_u6761_u4EF6"><a href="#for__u5FAA_u73AF_u5E76_u884C_u5316_u7684_u7EA6_u675F_u6761_u4EF6" class="headerlink" title="for 循环并行化的约束条件"></a>for 循环并行化的约束条件</h3><p>尽管OpenMP可以方便地对for循环进行并行化，但并不是所有的for循环都可以进行并行化。以下几种情况不能进行并行化：</p>
<ol>
<li>for循环中的循环变量必须是有符号整形。例如，for (unsigned int i = 0; i &lt; 10; ++i){}会编译不通过；</li>
<li>for循环中比较操作符必须是&lt;, &lt;=, &gt;, &gt;=。例如for (int i = 0; i != 10; ++i){}会编译不通过；</li>
<li>for循环中的第三个表达式，必须是整数的加减，并且加减的值必须是一个循环不变量。例如for (int i = 0; i != 10; i = i + 1){}会编译不通过；感觉只能++i; i++; –i; 或i–；</li>
<li>如果for循环中的比较操作为&lt;或&lt;=，那么循环变量只能增加；反之亦然。例如for (int i = 0; i != 10; –i)会编译不通过；</li>
<li>循环必须是单入口、单出口，也就是说循环内部不允许能够达到循环以外的跳转语句，exit除外。异常的处理也必须在循环体内处理。例如：若循环体内的break或goto会跳转到循环体外，那么会编译不通过。</li>
</ol>
<h3 id="u57FA_u672C_for__u5FAA_u73AF_u5E76_u884C_u5316_u4E3E_u4F8B"><a href="#u57FA_u672C_for__u5FAA_u73AF_u5E76_u884C_u5316_u4E3E_u4F8B" class="headerlink" title="基本 for 循环并行化举例"></a>基本 for 循环并行化举例</h3><pre><code>#include &lt;iostream&gt;
#include &lt;omp.h&gt;

int main(){
    int a[10] = {1};
    int b[10] = {2};
    int c[10] = {0};

    #pragma omp parallel
    {
        #pragma omp for
        for (int i = 0; i &lt; 10; ++i){
            // c[i] 只跟 a[i] 和 b[i] 有关
            c[i] = a[i] + b[i];
        }
    }

    return 0;
}
</code></pre><h3 id="u5D4C_u5957_for__u5FAA_u73AF_u5E76_u884C_u5316_u4E3E_u4F8B"><a href="#u5D4C_u5957_for__u5FAA_u73AF_u5E76_u884C_u5316_u4E3E_u4F8B" class="headerlink" title="嵌套 for 循环并行化举例"></a>嵌套 for 循环并行化举例</h3><pre><code>#include &lt;omp.h&gt;

int main(){
    int a[10][5] = {1};
    int b[10][5] = {2};
    int c[10][5] = {3};

    #pragma omp parallel
    {
        #pragma omp for
        for (int i = 0; i &lt; 10; ++i){
            for (int j = 0; j &lt; 5; ++j){
                // c[i][j] 只跟 a[i][j] 和 b[i][j] 有关
                c[i][j] = a[i][j] + b[i][j];
            }
        }
    }

    return 0;
}
</code></pre><p>对于双核 CPU 来说，编译器会让第一个cpu完成：</p>
<pre><code>for (int i = 0; i &lt; 5; ++i){
    for (int j = 0; j &lt; 5; ++j){
        // c[i][j] 只跟 a[i][j] 和 b[i][j] 有关
        c[i][j] = a[i][j] + b[i][j];
    }
}
</code></pre><p>会让第二个 cpu 完成：</p>
<pre><code>for (int i = 5; i &lt; 10; ++i){
    for (int j = 0; j &lt; 5; ++j){
        // c[i][j] 只跟 a[i][j] 和 b[i][j] 有关
        c[i][j] = a[i][j] + b[i][j];
    }
}
</code></pre><h2 id="u6570_u636E_u7684_u5171_u4EAB_u4E0E_u79C1_u6709_u5316"><a href="#u6570_u636E_u7684_u5171_u4EAB_u4E0E_u79C1_u6709_u5316" class="headerlink" title="数据的共享与私有化"></a>数据的共享与私有化</h2><p>在并行区域中，若多个线程共同访问同一存储单元，并且至少会有一个线程更新数据单元中的内容时，会发送数据竞争。本节的数据共享与私有化对数据竞争做一个初步的探讨，后续会在同步、互斥相关章节中进行进一步描述。</p>
<p>除了以下三种情况外，并行区域中的所有变量都是共享的：</p>
<ol>
<li>并行区域中定义的变量</li>
<li>多个线程用来完成循环的循环变量</li>
<li>private、firstprivate、lastprivate或reduction字句修饰的变量</li>
</ol>
<p>例如：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;omp.h&gt;
using namespace std;

int main(){
    int share_a = 0; // 共享变量
    int share_to_private_b = 1; // 通过 private 子句修饰该变量之后在并行区域内变为私有变量

    #pragma omp parallel
    {
        int private_c = 2;

        #pragma omp for private(share_to_private_b)
        for (int i = 0; i &lt; 10; ++i) //该循环变量是私有的，若为两个线程，则一个线程执行0~4，另一个执行5~9
            cout &lt;&lt; i &lt;&lt; endl;

    }

    return 0;
}
</code></pre><p>声明方法 / 功能</p>
<pre><code>并行区域中变量val是私有的，即每个线程拥有该变量的一个拷贝
private(val1, val2, ...)

与private不同的是，每个线程在开始的时候都会对该变量进行一次初始化。
first_private(val1, val2, ...)      

与private不同的是，并发执行的最后一次循环的私有变量将会拷贝到val
last_private(val1, val2, ...)      

声明val是共享的
shared(val1, val2, ...)              
</code></pre><p>如果使用private，无论该变量在并行区域外是否初始化，在进入并行区域后，该变量均不会初始化。</p>
<h2 id="Reduction__u7684_u7528_u6CD5"><a href="#Reduction__u7684_u7528_u6CD5" class="headerlink" title="Reduction 的用法"></a>Reduction 的用法</h2><p>直接上例子</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;
using namespace std;

int main(){
    int sum = 0;
    cout &lt;&lt; &quot;Before: &quot; &lt;&lt; sum &lt;&lt; endl;

    #pragma omp parallel for reduction(+:sum)
    for (int i = 0; i &lt; 10; ++i){
        sum = sum + i;
        printf(&quot;%d\n&quot;, sum);
    }

    cout &lt;&lt; &quot;After: &quot; &lt;&lt; sum &lt;&lt; endl;

    return 0;
}
</code></pre><p>其中sum是共享的，采用reduction之后，每个线程根据reduction（+: sum）的声明算出自己的sum，然后再将每个线程的sum加起来。</p>
<p>reduction声明可以看作：</p>
<ol>
<li>保证了对sum的原则操作</li>
<li>多个线程的执行结果通过reduction中声明的操作符进行计算，以加法操作符为例：</li>
</ol>
<p>假设sum的初始值为10，reduction（+: sum）声明的并行区域中每个线程的sum初始值为0（规定），并行处理结束之后，会将sum的初始化值10以及每个线程所计算的sum值相加。</p>
<p>我们在上边已经了解了reduction的声明形式，其具体如下：</p>
<p>reduction (operator: var1, val2, …)</p>
<p>其中operator以及约定变量的初始值如下：</p>
<pre><code>运算符            数据类型            默认初始值
  +              整数、浮点             0
  -              整数、浮点             0
  *              整数、浮点             1
  &amp;                整数             所有位均为1
  |                整数                0
  ^                整数                0
  &amp;&amp;               整数                1
  ||               整数                0
</code></pre><h2 id="u7EBF_u7A0B_u540C_u6B65_u4E4B_atomic"><a href="#u7EBF_u7A0B_u540C_u6B65_u4E4B_atomic" class="headerlink" title="线程同步之 atomic"></a>线程同步之 atomic</h2><p>在OpenMP中，线程同步机制包括互斥锁同步机制和事件同步机制。互斥锁同步的概念类似于Windows中的临界区（CriticalSection）以及Windows和Linux中的Mutex，以及VxWorks中的SemTake何SemGive（初始化时信号量为满），即对某一块代码操作进行保护，以保证同时只能有一个线程执行该段代码。</p>
<h3 id="atomic_uFF08_u539F_u5B50_uFF09_u64CD_u4F5C_u8BED_u6CD5"><a href="#atomic_uFF08_u539F_u5B50_uFF09_u64CD_u4F5C_u8BED_u6CD5" class="headerlink" title="atomic（原子）操作语法"></a>atomic（原子）操作语法</h3><pre><code>#pragma omp atomic
x&lt; + or * or - or * or / or &amp; or | or &lt;&lt; or &gt;&gt; &gt;=expr
(例如x &lt;&lt;= 1; or x *=2;)
</code></pre><p>或</p>
<pre><code>#pragma omp atomic
x++ //or x--, --x, ++x
</code></pre><p>可以看到atomic的操作仅适用于两种情况：</p>
<ol>
<li>自加减操作</li>
<li>x&lt;上述列出的操作符&gt;=expr</li>
</ol>
<p>例如</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;omp.h&gt;
using namespace std;

int main(){
    int sum = 0;
    cout &lt;&lt; &quot;Before: &quot; &lt;&lt; sum &lt;&lt; endl;

    #pragma omp parallel for
    for (int i = 0; i &lt; 20000; ++i){
        #pragma omp atomic
        sum++;
    }
    cout &lt;&lt; &quot;Atomic-After: &quot; &lt;&lt; sum &lt;&lt; endl;

    sum = 0;
    #pragma omp parallel for
    for (int i = 0; i &lt; 20000; ++i){
        sum++;
    }
    cout &lt;&lt; &quot;None-atomic-After: &quot; &lt;&lt; sum &lt;&lt; endl;
    return 0;
}
</code></pre><p>输出20000。如果将#pragma omp atomic声明去掉，则输出值不确定。</p>
<h2 id="u7EBF_u7A0B_u540C_u6B65_u4E4B_critical"><a href="#u7EBF_u7A0B_u540C_u6B65_u4E4B_critical" class="headerlink" title="线程同步之 critical"></a>线程同步之 critical</h2><p>这里的临界区与Windows下的CriticalSection类似。<br>临界区声明方法</p>
<pre><code>#pragma omp critical [(name)] //[]表示名字可选
{
//并行程序块，同时只能有一个线程能访问该并行程序块
}
</code></pre><p>例如</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;omp.h&gt;
using namespace std;

int main(){
    int sum = 0;
    cout &lt;&lt; &quot;Before: &quot; &lt;&lt; sum &lt;&lt; endl;

    #pragma omp parallel for
    for (int i = 0; i &lt; 100; ++i){
        #pragma omp critical(a)
        {
            sum = sum + i;
            sum = sum + i * 2;
        }
    }

    cout &lt;&lt; &quot;After: &quot; &lt;&lt; sum &lt;&lt; endl;

    return 0;
}
</code></pre><p>critical 与 atomic 的区别在于，atomic 仅适用于上一节规定的两种类型操作，而且 atomic 所防护的仅为一句代码。critical 可以对某个并行程序块进行防护。</p>
<p>For a simple increment to a shared variable, atomic and critical are semantically equivalent, but atomic allows the compiler more opportunities for optimisation (using hardware instructions, for example). </p>
<p>In other cases, there are differences. If incrementing array elements (e.g. a[i]++ ), atomic allows different threads to update different elements of the array concurrently whereas critical does not. If there is a more complicated expression on the RHS (e.g. a+=foo() ) then the evaluation of foo() is protected from concurrent execution with critical but not with atomic. </p>
<p>Using a critical section is a legitimate way of implementing atomics inside the compiler/runtime, but most current OpenMP compilers do a better job than this. </p>
<h2 id="u7EBF_u7A0B_u540C_u6B65_u4E4B_u4E8B_u4EF6_u540C_u6B65_u673A_u5236"><a href="#u7EBF_u7A0B_u540C_u6B65_u4E4B_u4E8B_u4EF6_u540C_u6B65_u673A_u5236" class="headerlink" title="线程同步之事件同步机制"></a>线程同步之事件同步机制</h2><p>互斥锁同步包括atomic、critical、mutex函数，其机制与普通多线程同步的机制类似。而事件同步则通过nowait、sections、single、master等预处理器指示符声明来完成。</p>
<h3 id="u9690_u5F0F_u6805_u969C"><a href="#u9690_u5F0F_u6805_u969C" class="headerlink" title="隐式栅障"></a>隐式栅障</h3><p>barrier为隐式栅障，即并行区域中所有线程执行完毕之后，主线程才继续执行。</p>
<h3 id="nowait__u7528_u6765_u53D6_u6D88_u6805_u969C"><a href="#nowait__u7528_u6765_u53D6_u6D88_u6805_u969C" class="headerlink" title="nowait 用来取消栅障"></a>nowait 用来取消栅障</h3><p>其用法如下：</p>
<pre><code>#pragma omp for nowait //不能用#pragma omp parallel for nowait
或
#pragma omp single nowait
</code></pre><p>例如</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main(){
    #pragma omp parallel
    {
        #pragma omp for nowait
        for (int i = 0; i &lt; 1000; ++i){
            printf(&quot;%d+\n&quot;, i);
        }

        #pragma omp for
        for (int j = 0; j &lt; 10; ++j){
            printf(&quot;%d-\n&quot;, j);
        }
    }
    return 0;
}
</code></pre><p>第一个 for 循环的两个线程中的一个执行完之后，继续往下执行，因此同时打印出了第一个循环的 + 和第一个循环的 - 。</p>
<p>可以看到，第二个 for 循环的两个线程都执行完之后，才开始同时执行第三个 for 循环，并没有交叉。也就是说，通过 #pragma omp for 声明的 for 循环结束时有一个默认的栅障。</p>
<h3 id="u663E_u5F0F_u540C_u6B65_u6805_u969C__23pragma_omp_barrier"><a href="#u663E_u5F0F_u540C_u6B65_u6805_u969C__23pragma_omp_barrier" class="headerlink" title="显式同步栅障 #pragma omp barrier"></a>显式同步栅障 #pragma omp barrier</h3><pre><code>#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main(){
    #pragma omp parallel
    {
        for (int i = 0; i &lt; 100; ++i){
        printf(&quot;%d+\n&quot;, i);
        }
        #pragma omp barrier
        for (int j = 0; j &lt; 10; ++j){
            printf(&quot;%d-\n&quot;, j);
        }
    }    
}
</code></pre><p>两个线程(具体数目不同 CPU 不同)执行了第一个for循环，当两个线程同时执行完第一个for循环之后，在barrier处进行了同步，然后执行后边的for循环。</p>
<h3 id="master__u901A_u8FC7_23pragma_omp_mater_u6765_u58F0_u660E_u5BF9_u5E94_u7684_u5E76_u884C_u7A0B_u5E8F_u5757_u53EA_u7531_u4E3B_u7EBF_u7A0B_u5B8C_u6210_u3002"><a href="#master__u901A_u8FC7_23pragma_omp_mater_u6765_u58F0_u660E_u5BF9_u5E94_u7684_u5E76_u884C_u7A0B_u5E8F_u5757_u53EA_u7531_u4E3B_u7EBF_u7A0B_u5B8C_u6210_u3002" class="headerlink" title="master 通过#pragma omp mater来声明对应的并行程序块只由主线程完成。"></a>master 通过#pragma omp mater来声明对应的并行程序块只由主线程完成。</h3><pre><code>#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main(){
    #pragma omp parallel
    {
        #pragma omp master
        {
            for (int j = 0; j &lt; 10; ++j){
                printf(&quot;%d-\n&quot;, j);
            }
        }

        printf(&quot;This will be shown two or more times\n&quot;);
    }
    return 0;
}
</code></pre><p>进入 parallel 声明的并行区域之后，创建了两个(或更多)线程，主线程执行了 for 循环，而另一个线程没有执行 for 循环，而直接进入了 for 循环之后的打印语句，然后执行 for 循环的线程随后还会再执行一次后边的打印语句。</p>
<h3 id="section__u7528_u6765_u6307_u5B9A_u4E0D_u540C_u7684_u7EBF_u7A0B_u6267_u884C_u4E0D_u540C_u7684_u90E8_u5206"><a href="#section__u7528_u6765_u6307_u5B9A_u4E0D_u540C_u7684_u7EBF_u7A0B_u6267_u884C_u4E0D_u540C_u7684_u90E8_u5206" class="headerlink" title="section 用来指定不同的线程执行不同的部分"></a>section 用来指定不同的线程执行不同的部分</h3><p>通过一个示例说明其使用方法：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main(){
    #pragma omp parallel sections // 声明该区域分为若干个 section, section 之间的运行顺序为并行的关系
    {
        #pragma omp section // 第一个 section, 由某个线程单独完成
        for (int i = 0; i &lt; 5; ++i){
            printf(&quot;%d+\n&quot;, i);
        }

        #pragma omp section // 另一个 section, 由某个线程单独完成
        for (int j = 0; j &lt; 5; ++j){
            printf(&quot;%d-\n&quot;, j);
        }
    }
    return 0;
}
</code></pre><p>因为并行区域中有两个线程，所以两个section同时执行。</p>
<h2 id="u7EBF_u7A0B_u7684_u8C03_u5EA6_u4F18_u5316"><a href="#u7EBF_u7A0B_u7684_u8C03_u5EA6_u4F18_u5316" class="headerlink" title="线程的调度优化"></a>线程的调度优化</h2><p>通过前边的介绍，知道了并行区域，默认情况下会自动生成与CPU个数相等的线程，然后并行执行并行区域中的代码，对于并行区域中的for循环，有特殊的声明方式，这样不同的线程可以分别运行for循环变量的不同部分。通过锁同步（atomic、critical、mutex函数）或事件同步（nowait、signal、section、master）来实现并行区域的同步控制。</p>
<p>具体的调度策略均由底层完成，本节介绍几种可以在上层对for循环进行控制的调度策略。</p>
<p>determines which iterations are executed by each thread</p>
<ul>
<li>STATIC<ul>
<li>The iteration space is broken in chunks of approximately size N/(num of threads). Then these chunks are assigned to the threads in a Round-Robin fashion.    </li>
</ul>
</li>
<li>STATIC, CHUNK<ul>
<li>The iteration space is broken in chunks of size N. Then these chunks are assigned to the threads in a Round-Robin fashion.</li>
</ul>
</li>
<li>Characteristics of static schedules<ul>
<li>Low overhead</li>
<li>Good locality (usually)</li>
<li>Can have load imbalance problems</li>
</ul>
</li>
<li>DYNAMIC[,chunk]<ul>
<li>Threads dynamically grab chunks of N iterations until all iterations have been executed. If no chunk is specified, N = 1</li>
</ul>
</li>
<li>GUIDED[,chunk]<ul>
<li>Variant of dynamic. The size of the chunks deceases as the threads grab iterations, but it is at least of size N. If no chunk is specified, N = 1.</li>
</ul>
</li>
<li>Characteristics of static schedules<ul>
<li>Higher overhead</li>
<li>Not very good locality (usually)</li>
<li>Can solve imbalance problems</li>
</ul>
</li>
<li>AUTO<ul>
<li>The implementation is allowed to do whatever it wishes. (Do not expect much of it as of now)</li>
</ul>
</li>
<li>RUNTIME<ul>
<li>The decision is delayed until the program is run through the sched-nvar ICV. It can be set with:</li>
<li>The <code>OMP_SCHEDULE</code> environment variable</li>
<li>The <code>omp_set_schedule()</code> API call</li>
</ul>
</li>
</ul>
<p>能看到这里，如果都跑过一遍的话，应该也就差不多了。上课过程中有啥想法再追加吧。我要去改代码了再见。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>For CMU 18-645 How to write fast code. Learn openmp in an hour!  <a href="http://blog.csdn.net/donhao">主要来源</a></p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="OpenMP" scheme="http://wdxtub.com/tags/OpenMP/"/>
    
      <category term="整理" scheme="http://wdxtub.com/tags/%E6%95%B4%E7%90%86/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 19 课 Dynamic Memory Allocation - Advanced Concept]]></title>
    <link href="http://wdxtub.com/2016/03/19/csapp-19/"/>
    <id>http://wdxtub.com/2016/03/19/csapp-19/</id>
    <published>2016-03-19T21:32:34.000Z</published>
    <updated>2016-03-20T03:32:44.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们来看看关于内存分配的延伸话题，包括更加复杂的选择机制以及垃圾回收等相关内容。</p>
<a id="more"></a>
<hr>
<p>这节课主要介绍后面三种方法，都是用来记录未分配空间的，具体如下：</p>
<p><img src="/images/14584386982186.jpg" alt="Keeping Track of Free Blocks"></p>
<h2 id="u663E_u5F0F_free__u5217_u8868"><a href="#u663E_u5F0F_free__u5217_u8868" class="headerlink" title="显式 free 列表"></a>显式 free 列表</h2><p>主要的改动在于，只记录 free block，而不是所有的 block。因为是指针，所以不仅需要记录后一个也需要记录前一个；与此同时，仍然需要 boundary tag 来作为合并的辅助信息。具体的结构如下：</p>
<p><img src="/images/14584389197608.jpg" alt="Explicit Free Lists"></p>
<p>因为是指针，逻辑上是连续的，但实际上可以是无序的，如下图：</p>
<p><img src="/images/14584389533544.jpg" alt="Logically vs Physically"></p>
<p>分配空间的过程就是指针重新指向的过程：</p>
<p><img src="/images/14584389995555.jpg" alt="Allocating From Explicit Free Lists"></p>
<p>然后我们来看看，当释放空间的时候，具体要把刚释放的 block，放在列表中的哪个位置呢？有两种策略：后入先出或按照地址排序。</p>
<p><img src="/images/14584390706378.jpg" alt="Freeing With Explicit Free Lists"></p>
<p>接下来是 LIFO 策略的几个不同的情况，灰色表示已经分配的空间：</p>
<p>Case 1</p>
<p><img src="/images/14584391317448.jpg" alt="Case 1"></p>
<p>Case 2</p>
<p><img src="/images/14584391482644.jpg" alt="Case 2"></p>
<p>Case 3</p>
<p><img src="/images/14584391607445.jpg" alt="Case 3"></p>
<p>Case 4</p>
<p><img src="/images/14584391818093.jpg" alt="Case 4"></p>
<p>总结一下，与隐式列表相比</p>
<ul>
<li>因为只记录 free block，在内存几乎满的时候效率很高</li>
<li>因为需要切分 block 以及维护列表，所以稍微复杂一点</li>
<li>对于每个链接来说需要 2 个额外的 word 来记录前面一个 free block 和后面一个 free block</li>
</ul>
<h2 id="Segregated_free__u5217_u8868"><a href="#Segregated_free__u5217_u8868" class="headerlink" title="Segregated free 列表"></a>Segregated free 列表</h2><blockquote>
<p>Most common use of linked lists is in conjunction with segregated free lists. Keep multiple linked lists of different size classes, or possibly for different types of objects.</p>
</blockquote>
<p>也就是说，每个不同大小 block 会在不同的列表里，对于较小的 size，一般会有单独的列表，对于稍大的 size，列表的范围也会更大，如下图所示：</p>
<p><img src="/images/14584404151349.jpg" alt="Each size class of blocks has its own free list"></p>
<p>要分配一个大小为 n 的 block：</p>
<ul>
<li>搜索比 n 大的 free list 列表</li>
<li>如果找到了合适的，切分 block 并且把剩余的放到对应的列表中（可选）</li>
<li>如果没有合适的 block，找更大的 size</li>
<li>重复上述过程，直到找到为止</li>
</ul>
<p>如果确实找不到：</p>
<ul>
<li>向系统请求额外的堆内存（使用 <code>sbrk()</code>）</li>
<li>在新的内存中分配对应的空间</li>
<li>把剩余的空间放到最大 size 的列表中</li>
</ul>
<p>释放空间时：</p>
<ul>
<li>合并 block 并放到对应的列表中</li>
</ul>
<p>Seglist allocator 的优势：</p>
<ul>
<li>更高的吞吐量(log time for power-of-two size classes)</li>
<li>更好的内存利用率<ul>
<li>First-fit search of segregated free list approximates a best-fit search of entire heap</li>
<li>Extreme case: Giving each block its own size class is equivalent to best-fit</li>
</ul>
</li>
</ul>
<h2 id="u5783_u573E_u56DE_u6536"><a href="#u5783_u573E_u56DE_u6536" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>所谓垃圾回收，就是我们不再需要显式释放所申请内存空间了，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* p block is now garbage*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种机制在许多动态语言中都有实现：Python, Ruby, Java, Perl, ML, Lisp, Mathematica。C 和 C++ 中也有类似的变种，但是需要注意的是，是不可能回收所有的垃圾的。</p>
<p>我们如何知道什么东西才是『垃圾』呢？简单！只要没有任何指针指向的地方，不管有没有用，因为都不可能被使用，当然可以直接清理掉啦。不过这其实是需要一些前提条件的：</p>
<ul>
<li>我们可以知道哪里是指针，哪里不是指针</li>
<li>每个指针都指向 block 的开头</li>
<li>指针不能被隐藏(by coercing them to an <code>int</code>, and then back again)</li>
</ul>
<p>相关的算法如下：</p>
<p><img src="/images/14584417083434.jpg" alt="Classical GC Algorithms"></p>
<p>这里我们主要讨论第一种 Mark-and-sweep collection 算法（居然已经有五十多年的历史了）</p>
<p>内存具体的分布，可以看做是一个有向图，每个 block 相当于一个节点，每个指针相当于一条边。那些不在堆中的且指向堆的指针称为根节点（如寄存器，栈，全局变量等），如下图所示：</p>
<p><img src="/images/14584420668262.jpg" alt="Memory as a Graph"></p>
<h3 id="Mark_and_Sweep_Collecting"><a href="#Mark_and_Sweep_Collecting" class="headerlink" title="Mark and Sweep Collecting"></a>Mark and Sweep Collecting</h3><p>这个机制可以在 malloc/free 的基础上实现。当空间不够的时候， 在每个 block 的头部增加一个额外的 mark bit。</p>
<ul>
<li>Mark: Start at roots and set mark bit on each reachable block</li>
<li>Sweep: Scan all blocks and free blocks that are not marked</li>
</ul>
<p>整个过程如下：</p>
<p><img src="/images/14584422740964.jpg" alt="Mark and Sweep Collecting"></p>
<p>一个简易实现的思路：</p>
<p><img src="/images/14584424812466.jpg" alt="Assumptions For a Simple Iimplementation"></p>
<p>代码如下：</p>
<p><img src="/images/14584426898133.jpg" alt=""></p>
<p>在 C 语言中，我们可以使用 <code>is_ptr()</code> 来判断是否为指针，但我们也知道，C 指针可能指向 block 的中间，这个时候我们要如何找到 block 的开头呢？</p>
<p><img src="/images/14584429046281.jpg" alt="指向中间"></p>
<p> 可以这么做</p>
<ul>
<li>Can use a balanced binary tree to keep track of all allocated blocks (key is start-of-block)</li>
<li>Balanced-tree pointers can be stored in header (use two additional words)</li>
</ul>
<p><img src="/images/14584429821424.jpg" alt="存储结构"></p>
<h2 id="u5185_u5B58_u76F8_u5173_u9677_u9631"><a href="#u5185_u5B58_u76F8_u5173_u9677_u9631" class="headerlink" title="内存相关陷阱"></a>内存相关陷阱</h2><p>关于内存的使用需要注意避免以下问题：</p>
<ul>
<li>Dereferencing bad pointers</li>
<li>Reading uninitialized memory</li>
<li>Overwriting memory</li>
<li>Referencing nonexistent variables</li>
<li>Freeing blocks multiple times</li>
<li>Referencing freed blocks</li>
<li>Failing to free blocks</li>
</ul>
<p>具体看上述问题前，我们先来了解 C 语言中操作符的顺序以及优先级：</p>
<p><img src="/images/14584431989892.jpg" alt="C operators"></p>
<p>下面是一些例子，一定要好好理解（指针什么的真的头疼）</p>
<p><img src="/images/14584433625063.jpg" alt="C Pointer Declarations"></p>
<h3 id="Dereferencing_Bad_Pointers"><a href="#Dereferencing_Bad_Pointers" class="headerlink" title="Dereferencing Bad Pointers"></a>Dereferencing Bad Pointers</h3><p>这是非常常见的例子，没有引用对应的地址，少了 <code>&amp;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, val);</span><br></pre></td></tr></table></figure>
<h3 id="Reading_Uninitialized_Memory"><a href="#Reading_Uninitialized_Memory" class="headerlink" title="Reading Uninitialized Memory"></a>Reading Uninitialized Memory</h3><p>不能假设堆中的数据会自动初始化为 0，下面的代码就会出现奇怪的问题</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* return y = Ax */</span><br><span class="line">int *matvec(int **A, int *x) &#123;</span><br><span class="line">    int *y = malloc(N * sizeof(int));</span><br><span class="line">    int i, j;</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; N; i++)</span><br><span class="line">        for (j = 0; j &lt; N; j++)</span><br><span class="line">            y[i] += A[i][j] * x[j];</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Overwriting_Memory"><a href="#Overwriting_Memory" class="headerlink" title="Overwriting Memory"></a>Overwriting Memory</h3><p>这里有挺多问题，第一种是分配了错误的大小，下面的例子中，一开始不能用 <code>sizeof(int)</code>，因为指针的长度不一定和 int 一样。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int **p;</span><br><span class="line">p = malloc(N * sizeof(int));</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; N; i++) </span><br><span class="line">    p[i] = malloc(M * sizeof(int));</span><br></pre></td></tr></table></figure>
<p>第二个问题是超出了分配的空间，下面代码的 for 循环中，因为使用了 <code>&lt;=</code>，会写入到其他位置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int **p;</span><br><span class="line"></span><br><span class="line">p = malloc(N * sizeof (int *));</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt;= N; i++)</span><br><span class="line">    p[i] = malloc(M * sizeof(int));</span><br></pre></td></tr></table></figure>
<p>第三种是因为没有检查字符串的长度，超出部分就写到其他地方去了（经典的缓冲区溢出攻击也是利用相同的机制）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">gets(s); <span class="comment">/* reads "123456789" from stdin */</span></span><br></pre></td></tr></table></figure>
<p>第四种是没有正确理解指针的大小以及对应的操作，应该使用 <code>sizeof(int *)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">search</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*p &amp;&amp; *p != null)</span><br><span class="line">        p += <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第五种是引用了指针，而不是其指向的对象，下面的例子中，<code>*size--</code> 一句因为 <code>--</code> 的优先级比较高，所以实际上是对指针进行了操作，正确的应该是 <code>(*size)--</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">BinheapDelete</span><span class="params">(<span class="keyword">int</span> **binheap, <span class="keyword">int</span> *size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *packet;</span><br><span class="line">    packet = binheap[<span class="number">0</span>];</span><br><span class="line">    binheap[<span class="number">0</span>] = binheap[*size - <span class="number">1</span>];</span><br><span class="line">    *size--;</span><br><span class="line">    Heapify(binheap, *size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Referencing_Nonexistent_Variables"><a href="#Referencing_Nonexistent_Variables" class="headerlink" title="Referencing Nonexistent Variables"></a>Referencing Nonexistent Variables</h3><p>下面的情况中，没有注意到局部变量会在函数返回的时候失效（所以对应的指针也会无效），这是传引用和返回引用需要注意的，传值的话则不用担心</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Freeing_Blocks_Multiple_Times"><a href="#Freeing_Blocks_Multiple_Times" class="headerlink" title="Freeing Blocks Multiple Times"></a>Freeing Blocks Multiple Times</h3><p>这个不用多说，不能重复搞两次</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = malloc(N * sizeof(int));</span><br><span class="line">//  &lt;manipulate x&gt;</span><br><span class="line">free(x);</span><br><span class="line"></span><br><span class="line">y = malloc(M * sizeof(int));</span><br><span class="line">//  &lt;manipulate y&gt;</span><br><span class="line">free(x);</span><br></pre></td></tr></table></figure>
<h3 id="Referencing_Freed_Blocks"><a href="#Referencing_Freed_Blocks" class="headerlink" title="Referencing Freed Blocks"></a>Referencing Freed Blocks</h3><p>同样是很明显的错误，不要犯</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = malloc(N * sizeof(int));</span><br><span class="line">//  &lt;manipulate x&gt;</span><br><span class="line">free(x);</span><br><span class="line">//  ....</span><br><span class="line"></span><br><span class="line">y = malloc(M * sizeof(int));</span><br><span class="line">for (i = 0; i &lt; M; i++)</span><br><span class="line">    y[i] = x[i]++;</span><br></pre></td></tr></table></figure>
<h3 id="Memory_Leaks"><a href="#Memory_Leaks" class="headerlink" title="Memory Leaks"></a>Memory Leaks</h3><p>用完没有释放，就是内存泄露啦</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo() &#123;</span><br><span class="line">    int *x = malloc(N * sizeof(int));</span><br><span class="line">    // ...</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者只释放了数据结构的一部分：</p>
<p><img src="/images/14584447178117.jpg" alt="Freeing only part of a data structure"></p>
<h3 id="u5BF9_u7B56"><a href="#u5BF9_u7B56" class="headerlink" title="对策"></a>对策</h3><p>我们可以使用下面的工具和方法来处理内存的 bug</p>
<p><img src="/images/14584447590453.jpg" alt="Dealing With Memory Bugs"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们来看看关于内存分配的延伸话题，包括更加复杂的选择机制以及垃圾回收等相关内容。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="内存分配" scheme="http://wdxtub.com/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 18 课 Dynamic Memory Allocation - Basic Concept]]></title>
    <link href="http://wdxtub.com/2016/03/19/csapp-18/"/>
    <id>http://wdxtub.com/2016/03/19/csapp-18/</id>
    <published>2016-03-19T21:32:26.000Z</published>
    <updated>2016-03-20T00:16:19.000Z</updated>
    <content type="html"><![CDATA[<p>前面了解了虚拟内存的相关知识，这节课我们来看看动态内存分配的基本概念，相信这之后就知道诸如 <code>malloc</code> 和 <code>new</code> 这类方法是怎么做的了。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u7840_u6982_u5FF5"><a href="#u57FA_u7840_u6982_u5FF5" class="headerlink" title="基础概念"></a>基础概念</h2><p>程序员通过动态内存分配（例如 <code>malloc</code>）来让程序在运行时得到虚拟内存。动态内存分配器会管理一个虚拟内存区域，称为堆(heap)，如下图所示：</p>
<p><img src="/images/14584238419962.jpg" alt="Dynamic Memory Allocation"></p>
<p>分配器以 block 为单位来维护 heap，可以进行 allocate 或 free。有两种类型的分配器：</p>
<ul>
<li>显式分配器：应用分配并且回收空间（C 语言中的 <code>malloc</code> 和 <code>free</code>）</li>
<li>隐式分配器：应用只负责分配，但是不负责回收（Java 中的垃圾收集）</li>
</ul>
<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>我们来看看 <code>malloc</code> 函数：</p>
<p><img src="/images/14584242618725.jpg" alt="The malloc Package"></p>
<p>一个简单的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void foo(int n) &#123;</span><br><span class="line">    int i, *p;</span><br><span class="line">    </span><br><span class="line">    /* Allocate a block of n ints */</span><br><span class="line">    p = (int *) malloc(n * sizeof(int));</span><br><span class="line">    if (p == NULL) &#123;</span><br><span class="line">        perror("malloc");</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* Initialize allocated block */</span><br><span class="line">    for (i=0; i&lt;n; i++)</span><br><span class="line">        p[i] = i;</span><br><span class="line"></span><br><span class="line">    /* Return allocated block to the heap */</span><br><span class="line">    free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这节课中，为了讲述方便，我们做如下假设：</p>
<ul>
<li>Memory is word addressed</li>
<li>Words are int-sized</li>
</ul>
<p><img src="/images/14584252386542.jpg" alt="Assumptions Made in This Lecture"></p>
<p>具体的例子：</p>
<p><img src="/images/14584253826838.jpg" alt="Allocation Example"></p>
<p>程序可以用任意的顺序发送 <code>malloc</code> 和 <code>free</code> 请求，<code>free</code> 请求必须作用与已被分配的 block。</p>
<p>分配器有如下的限制：</p>
<ul>
<li>不能控制已分配 block 的数量和大小</li>
<li>必须立即响应 <code>malloc</code> 请求（不能缓存或者给请求重新排序）</li>
<li>必须在未分配的内存中分配</li>
<li>不同的 block 需要对齐（32 位中 8 byte，64 位中 16 byte）</li>
<li>只能操作和修改未分配的内存</li>
<li>不能移动已分配的 block</li>
</ul>
<h2 id="u6027_u80FD_u6307_u6807"><a href="#u6027_u80FD_u6307_u6807" class="headerlink" title="性能指标"></a>性能指标</h2><p>现在我们可以来看看如何去评测具体的分配算法了。假设给定一个 <code>malloc</code> 和 <code>free</code> 的请求的序列：</p>
 $$R_0, R_1, ..., R_k, ..., R_{n-1}$$ 
<p>目标是尽可能提高吞吐量以及内存利用率（注意，这两个目标常常是冲突的）</p>
<p>吞吐量是在单位时间内完成的请求数量。假设在 10 秒中之内进行了 5000 次 <code>malloc</code> 和 5000 次 <code>free</code> 调用，那么吞吐量是 1000 operations/second</p>
<p>另外一个目标是 Peak Memory Utilization，就是最大的内存利用率，具体如下：</p>
<p><img src="/images/14584265326302.jpg" alt="Peak Memory Utilization"></p>
<p>影响内存利用率的主要因素就是『内存碎片』，有两种类型：</p>
<ul>
<li>internal fragmentation</li>
<li>external fragmentation0</li>
</ul>
<h3 id="u5185_u90E8_u788E_u7247"><a href="#u5185_u90E8_u788E_u7247" class="headerlink" title="内部碎片"></a>内部碎片</h3><p>对于给定的 block，internal fragmentation 主要是因为 payload 小于 block size 造成的，如下图所示：</p>
<p><img src="/images/14584268109274.jpg" alt="internal fragmentation"></p>
<p>主要是由以下原因导致；</p>
<ul>
<li>Overhead of maintaining heap data structures</li>
<li>Padding for alignment purposes</li>
<li>Explicit policy decisions</li>
</ul>
<p>只依赖于上一个请求的具体模式，所以比较容易测量。</p>
<h3 id="u5916_u90E8_u788E_u7247"><a href="#u5916_u90E8_u788E_u7247" class="headerlink" title="外部碎片"></a>外部碎片</h3><p>指的是内存中没有足够的连续空间，如下图所示：</p>
<p><img src="/images/14584269418830.jpg" alt="External Fragmentation"></p>
<p>依赖于未来的请求模式，所以比较难测量。</p>
<h3 id="u5B9E_u73B0_u7EC6_u8282"><a href="#u5B9E_u73B0_u7EC6_u8282" class="headerlink" title="实现细节"></a>实现细节</h3><p>在具体实现之前，需要考虑以下问题：</p>
<ul>
<li>给定一个指针，我们如何知道需要释放多少内存？</li>
<li>如何记录未分配的 block ？</li>
<li>实际需要的空间比未分配的空间要小的时候，剩下的空间怎么办？</li>
<li>如果有多个区域满足条件，如何选择？</li>
<li>释放空间之后如何进行记录？</li>
</ul>
<p>一个标准的方式是在指针的前一个  word 中保存 block 的大小，通常称之为 header field 或 header，这种方式需要额外的一个 word，具体如下：</p>
<p><img src="/images/14584273450722.jpg" alt="Standard method"></p>
<p>这里我们先给出常用的四种方式，这节课主要介绍第一种，下节课会介绍后面的方法：</p>
<p><img src="/images/14584273923045.jpg" alt="Keeping Track of Free Blocks"></p>
<h2 id="u9690_u5F0F_free__u5217_u8868"><a href="#u9690_u5F0F_free__u5217_u8868" class="headerlink" title="隐式 free 列表"></a>隐式 free 列表</h2><p>对于每个 block 来说，我们需要知道大小和具体的状态（已分配/未分配），可以用两个 word 来存储，但是这样太浪费了。</p>
<p>如果一个 block 已经对其，低位地址一定是 0，所以我们可以用来当做 allocated/free 标志，当读入 word 大小的时候，需要标记出这个值。</p>
<p><img src="/images/14584304354717.jpg" alt="Implicit List"></p>
<p><img src="/images/14584304662424.jpg" alt="Detailed Implicit Free List Example"></p>
<p>寻找未分配的空间的方式如下，主要有三种：</p>
<p><img src="/images/14584305912848.jpg" alt="Finding a Free Block"></p>
<p>确定空间之后，具体进行分配如下：</p>
<p><img src="/images/14584306987840.jpg" alt="Allocating in Free Block"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addblock</span><span class="params">(ptr p, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newsize = ((len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;  <span class="comment">// round up to even</span></span><br><span class="line">    <span class="keyword">int</span> oldsize = *p &amp; -<span class="number">2</span>;                <span class="comment">// mask out low bit</span></span><br><span class="line">    *p = newsize | <span class="number">1</span>;                     <span class="comment">// set new length</span></span><br><span class="line">    <span class="keyword">if</span> (newsize &lt; oldsize)</span><br><span class="line">        *(p+newsize) = oldsize - newsize; <span class="comment">// set length in remaining</span></span><br><span class="line">                                          <span class="comment">// part of block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在释放空间的时候如果 block 后面也是未分配的空间，只做基本的处理的话，会出现有足够的位置，但是因为多余的分隔而找不到对应的位置，如下所示：</p>
<p><img src="/images/14584314075261.jpg" alt="Freeing a Block"></p>
<p>解决的办法是 Coalescing：</p>
<p><img src="/images/14584314805605.jpg" alt="coalesce"></p>
<p>另一种方法是双向 coalescing：</p>
<p><img src="/images/14584318651163.jpg" alt="Bidirectional Coalescing"></p>
<p>具体 coalescing 的时候有四种情况：</p>
<p><img src="/images/14584319803616.jpg" alt="Constant Time Coalescing"></p>
<p>下面是四种情况的：</p>
<p>Case 1：</p>
<p><img src="/images/14584322811295.jpg" alt="Case 1"></p>
<p>Case 2：</p>
<p><img src="/images/14584322969946.jpg" alt="Case 2"></p>
<p>Case 3：</p>
<p><img src="/images/14584323407555.jpg" alt="Case 3"></p>
<p>Case 4：</p>
<p><img src="/images/14584323554767.jpg" alt="Case 4"></p>
<p>Boundary Tags 的坏处就是会导致 internal fragmentation。</p>
<p>总结一下：</p>
<p><img src="/images/14584328927396.jpg" alt="Summary of Key Allocator Policies"></p>
<p>最后是 implicit list 的总结：</p>
<p><img src="/images/14584329366933.jpg" alt="Implicit Lists: Summary"></p>
<p>总体来说这一部分还是比较简单的，虽然简单，但是一定要理解清楚，因为下节课会介绍更加复杂的机制。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面了解了虚拟内存的相关知识，这节课我们来看看动态内存分配的基本概念，相信这之后就知道诸如 <code>malloc</code> 和 <code>new</code> 这类方法是怎么做的了。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="内存分配" scheme="http://wdxtub.com/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第十周 - Deacon Blue]]></title>
    <link href="http://wdxtub.com/2016/03/18/deacon-blue/"/>
    <id>http://wdxtub.com/2016/03/18/deacon-blue/</id>
    <published>2016-03-19T02:37:13.000Z</published>
    <updated>2016-03-19T11:55:43.000Z</updated>
    <content type="html"><![CDATA[<p>You can’t control what life presents. Keep it moving man, one day you’ll make it through.</p>
<a id="more"></a>
<hr>
<p>不知不觉就来到了第十周，回顾上个学期的周记，清楚地意识到，恐怕再写六周，就真的要告别『校园生活』了。没有太多不舍，因为已经尽力去体验了校园中的各种角色；没有太多遗憾，因为很多事情已经做到了足够好；甚至没有太多期待，人来人往，熙熙攘攘，桃源室外，锦城何在？</p>
<p>万万没想到，记录一下对于课程的理解，翻译一下逻辑混乱语句不同的课程资料，竟收到了老师的『警告』：因为涉及题目的思路以及相关课程内容，必须把相关日志都删掉，否则老师很生气，后果很严重。我其实没有任何选择，人在屋檐下，不得不低头，二十多篇很用心写的日志不得不『消失』，虽有些气不过，但是更多的是失望。既然都写到这儿了，一不做二不休，来说说所谓的『老师』，和所谓的『课程』：</p>
<ol>
<li>我不知道老师到底干了啥，如果他真的有看课程资料的话，是如何容忍毫无逻辑且经常前后矛盾的作业说明的？</li>
<li>我不知道助教到底是为啥一肚子坏水，说明写得不清不楚就算了，样例代码写得像下水道大学出来的一样就算了，但是拿着鸡毛当令箭真的好吗？</li>
<li>我不知道作业中为啥老师和助教工作的不严谨，要让全体同学的时间来买单，很多明显是故意设置出来『浪费』大家时间的设定，我真心觉得这已经背离了『传道授业解惑』的范畴？</li>
</ol>
<p>日志就是我的武器，用重新组织的逻辑清晰的描述完备的文字，让大家尽可能明白每次的作业到底是要做什么，把时间节约起来，去做自己真正想做的事情。然而这个不知道在哪『梦游』的老师直接用行政压力让我缴械。势单力薄，除了投降我还能做什么？</p>
<p>缺乏基本的语文能力是理工科学生的通病，又或者因为平时的生活学习节奏压根没有太多的表达训练，我真的真的遇到了太多哭笑不得的沟通障碍。举个例子，一旦走到专业之外，文化的范畴中，很多人就成了盲人。他们感受不到不同词汇不同句法背后蕴藏的深意，他们不去思考专业外的东西，眼中只有短期目标，一旦视线离开这个点，就成了无头苍蝇。</p>
<p>跟六七十岁的教授讨论起文化、哲学、历史相关的话题，才真正有『沟通』的体验：一点即通，不会在细枝末节上浪费太多精力；一针见血，直接把最核心的问题拿出来打磨讨论，用思考来切磋。</p>
<p>最近一直在玩《合金装备 5：幻痛》，整个剧情及世界观的设定和《白鲸记》《一九八四》以及《蝇王》有非常深的联系，跟同学聊起，没有人读过这些书，根本没办法进入游戏理念已经具体通过游戏来表达想法的技术讨论。</p>
<p>这真的是很痛苦的事情。聊得来是非常高的标准，至少需要双方有同等水平的思维能力。</p>
<p>最近也慢慢进入了找到工作互相请客的状态，看着大家一路坚持过来到最终实现自己的目标，我还是很开心的。借由自己的疏离感带来的观察，更加深刻理解了『性格即命运』。</p>
<p>各种各样的性格，面对问题的时候也有各种各样的解法。从我的角度来说，除了一种人需要远离之外，其他怎么折腾都行。</p>
<blockquote>
<p>远离那些野心很大，自己却配不上这份野心的人。</p>
</blockquote>
<p>他们是最可能放弃一切尊严和道德，用力把你拉下水或者会为了一丁点微不足道的东西铤而走险的人。</p>
<p>估计是因为没睡够的缘故，整篇周记的风格竟然成了这样，最后当然还是要 look on the bright side。</p>
<p>很久没有聊过这么久的电话，即使特别困也想要多说两句，高质量的沟通真的是非常愉快的事情，找到加速度差不多的人真的不容易。</p>
<p>最后说一句，AI 能取代的终究是那些思维强度太低的人，最好的做法就是多读多写多思考，人类在推动技术发展的同时，技术也在引导着人类进步的方向，跟不上时代的注定要淘汰，物竞天择，优胜劣汰。</p>
<p>Set your goal high. Be sure to stay true.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>You can’t control what life presents. Keep it moving man, one day you’ll make it through.</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="变化" scheme="http://wdxtub.com/tags/%E5%8F%98%E5%8C%96/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="春天" scheme="http://wdxtub.com/tags/%E6%98%A5%E5%A4%A9/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 17 课 Virtual Memory - System]]></title>
    <link href="http://wdxtub.com/2016/03/18/csapp-17/"/>
    <id>http://wdxtub.com/2016/03/18/csapp-17/</id>
    <published>2016-03-18T13:48:57.000Z</published>
    <updated>2016-03-19T02:21:36.000Z</updated>
    <content type="html"><![CDATA[<p>了解了基本的虚拟内存概念，这节课我们来具体看看 Core i7 和 Linux 的内存系统，相信会对虚拟内存这一套机制有更深刻的认识。</p>
<a id="more"></a>
<hr>
<p>开始之前我们还是先复习一下基本的概念：</p>
<p><img src="/images/14583183552533.jpg" alt="Review of Symbols"></p>
<h2 id="u5730_u5740_u7FFB_u8BD1_u5B9E_u4F8B"><a href="#u5730_u5740_u7FFB_u8BD1_u5B9E_u4F8B" class="headerlink" title="地址翻译实例"></a>地址翻译实例</h2><p>然后来看一个简单的例子：</p>
<ul>
<li>14 位的虚拟地址</li>
<li>12 位的物理地址</li>
<li>page size 为 64 字节</li>
</ul>
<p>如下图所示</p>
<p><img src="/images/14583359973808.jpg" alt="Addressing"></p>
<p>TLB 的配置为：</p>
<ul>
<li>16 entries</li>
<li>4-way associative</li>
</ul>
<p>如下图所示</p>
<p><img src="/images/14583376303817.jpg" alt="TLB"></p>
<p>然后来看看 page table，一共有 256 个 entry，这里列出前 16 个：</p>
<p><img src="/images/14583376858566.jpg" alt="Page Table"></p>
<p>最后来看看系统本身缓存：</p>
<ul>
<li>16 lines, 4-byte block size</li>
<li>Physically addressed</li>
<li>Direct mapped</li>
</ul>
<p><img src="/images/14583377349696.jpg" alt="Cache"></p>
<p>一定要注意好不同部分的所代表的位置，这里我也会尽量写得清楚一些，来看第一个例子：</p>
<blockquote>
<p>虚拟地址为 <code>0x03D4</code></p>
</blockquote>
<p>具体的转换过程如下图所示：</p>
<p><img src="/images/14583479163395.jpg" alt="第一个例子"></p>
<p>具体来梳理一次：</p>
<p>先看 TLB 中有没有对应的条目，所以先看虚拟地址的第 6-13 位，在前面的 TLB 表中，根据 TLBI 为 3 这个信息，去看这个 set 中有没有 tag 为 3 的项目，发现有，并且对应的 PPN 是 0x0D，所以对应到物理地址，就是 PPN 加上虚拟地址的 0-5 位，而具体的物理地址又可以在缓存中找到（利用 cache memory 的机制），就可以获取到对应的数据了。</p>
<p>下面的例子同样可以按照这个方法来进行分析</p>
<p><img src="/images/14583493888490.jpg" alt="第二个例子"></p>
<h2 id="u6848_u4F8B_u5B66_u4E60_uFF1ACore_i7"><a href="#u6848_u4F8B_u5B66_u4E60_uFF1ACore_i7" class="headerlink" title="案例学习：Core i7"></a>案例学习：Core i7</h2><p>我们先来看看整体的架构</p>
<p><img src="/images/14583495456299.jpg" alt="Intel Core i7 Memory System"></p>
<p>这里先留意一点，为什么 L1 d-cache 比上 L2 unified cache，和 L1 d-TLB 比上 L2 unified TLB 的比例一样呢？</p>
<p><img src="/images/14583500587332.jpg" alt="End-to-end Core i7 Address Translation"></p>
<p>可以清楚地看到，从 TLB 到 Page table 以及对应 cache 的转换，结合上面的说明仔细体会下。接下来的内容比较偏理论，大家有一个基本的认识即可（因为平时编程理论上也不会涉及到这些）</p>
<p>Core i7 有 4 层的 page table，前 3 层的结构一样，如下图所示</p>
<p><img src="/images/14583503794880.jpg" alt="Core i7 Level 1-3 Page Table Entries"></p>
<p>第四层有少许不同，具体看下面的说明：</p>
<p><img src="/images/14583505732854.jpg" alt="Core i7 Level 4 Page Table Entries"></p>
<p>具体的翻译过程为：</p>
<p><img src="/images/14583506241439.jpg" alt="Core i7 Page Table Translation"></p>
<p>接下来就可以回答前面的问题了，为啥是成比例的呢？原因很简单！用来加速 L1 的访问！</p>
<blockquote>
<p>Virtually indexed, physically tagged</p>
</blockquote>
<p><img src="/images/14583509113693.jpg" alt="Cute Trick for Speeding Up L1 Access"></p>
<h2 id="u6848_u4F8B_u5B66_u4E60_uFF1ALinux_Process"><a href="#u6848_u4F8B_u5B66_u4E60_uFF1ALinux_Process" class="headerlink" title="案例学习：Linux Process"></a>案例学习：Linux Process</h2><p>这一部分也是了解一下即可（具体可以不用太深究）</p>
<p><img src="/images/14583511838723.jpg" alt="Virtual Address Space of a Linux Process"></p>
<p>Linux 以不同的『区域』来组织虚拟内存</p>
<p><img src="/images/14583514430157.jpg" alt="Linux Organizes VM as Collection of &quot;Areas&quot;"></p>
<p>下面是处理 page fault 的机制：</p>
<p><img src="/images/14583519002966.jpg" alt="Linux Page Fault Handling"></p>
<h2 id="u5185_u5B58_u6620_u5C04"><a href="#u5185_u5B58_u6620_u5C04" class="headerlink" title="内存映射"></a>内存映射</h2><p>初始化虚拟内存的过程，实际上就是把对应的虚拟内存和磁盘上的对象关联起来的过程，称之为内存映射(memory mapping)</p>
<p><img src="/images/14583529040142.jpg" alt=""></p>
<p>Linux 中所谓的『交换分区』就是这么来的（我估计）</p>
<p><img src="/images/14583530219645.jpg" alt="Shared Objects"></p>
<ul>
<li>Process 1 maps the shared object</li>
<li>Process 2 maps the shared object</li>
<li>Two processes mapping a <strong>private copy-on-write(COW)</strong> object</li>
<li>Area flagged as private copy-on-write</li>
<li>PTEs in private areas are flagged as read-only</li>
</ul>
<p><img src="/images/14583530323902.jpg" alt="Private Copy-on-write(COW) Objects"></p>
<ul>
<li>Instruction writing to private page triggers protection fault</li>
<li>Handler creates new R/W page</li>
<li>Instruction restarts upon handler return</li>
<li>Copying deferred as long as possible!</li>
</ul>
<p>Fork 函数就是这种机制的一个很好的例子：</p>
<p><img src="/images/14583534506790.jpg" alt="The `fork` Function"></p>
<p>接着来看看 <code>execve</code> 函数</p>
<p><img src="/images/14583535882515.jpg" alt="The `execve` Function"></p>
<p>最后介绍了 <code>mmap</code> 函数，这里不赘述了。</p>
<p>这一部分比较偏向实际，主要还是要理解虚拟内存的机制（具体现代的处理器和操纵系统已经『太』复杂了）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解了基本的虚拟内存概念，这节课我们来具体看看 Core i7 和 Linux 的内存系统，相信会对虚拟内存这一套机制有更深刻的认识。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="虚拟内存" scheme="http://wdxtub.com/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 16 课 Virtual Memory - Concepts]]></title>
    <link href="http://wdxtub.com/2016/03/18/csapp-16/"/>
    <id>http://wdxtub.com/2016/03/18/csapp-16/</id>
    <published>2016-03-18T13:48:52.000Z</published>
    <updated>2016-03-18T16:11:31.000Z</updated>
    <content type="html"><![CDATA[<p>这节课开始，我们会接触到计算机系统中另外一个非常重要的概念：虚拟内存。这个机制提供给了上层应用一个统一的地址空间，而无须操心物理内存的位置。</p>
<a id="more"></a>
<hr>
<p>在具体讲述之前，我们先来看看什么是物理地址，什么是虚拟地址。</p>
<p><img src="/images/14583091815694.jpg" alt="物理地址"></p>
<p>物理地址一般应用在简单的嵌入式微控制器中（汽车、电梯、电子相框等），因为应用的范围有严格的限制，不需要在内存管理中引入过多的复杂度。</p>
<p>但是对于计算机（以及其他智能设备）来说，虚拟地址则是必不可少的，通过 MMU(Memory management unit)把虚拟地址(Virtual Address, VA)转换为物理地址(Physical Address, PA)，再由此进行实际的数据传输。大致的过程如下图所示</p>
<p><img src="/images/14583093850630.jpg" alt="虚拟地址"></p>
<p>使用虚拟内存主要是基于下面三个考虑：</p>
<ol>
<li>可以更有效率的使用内存：使用 DRAM 当做部分的虚拟地址空间的缓存</li>
<li>简化内存管理：每个进程都有统一的线性地址空间</li>
<li>隔离地址控件：进程之间不会相互影响；用户程序不能访问内核信息和代码</li>
</ol>
<h2 id="u4F5C_u4E3A_u7F13_u5B58_u5DE5_u5177"><a href="#u4F5C_u4E3A_u7F13_u5B58_u5DE5_u5177" class="headerlink" title="作为缓存工具"></a>作为缓存工具</h2><p>概念上来说，虚拟内存就是存储在磁盘上的 N 个连续字节的数组。这个数组的部分内容，会缓存在 DRAM 中，在 DRAM 中的每个 cache block 就称为 page（页），具体的大小为 $P=2^p$（这里 p 表示具体的位数），如下图所示：</p>
<p><img src="/images/14583098368523.jpg" alt=""></p>
<p>大致的思路和之前的 cache memory 是类似的，就是利用 DRAM 比较快的特性，把最常用的数据换缓存起来。如果要访问磁盘的话，大约会比访问 DRAM 慢一万倍，所以我们的目标就是尽可能从 DRAM 中拿数据。为此，我们需要：</p>
<ul>
<li>更大的 page size：通常是 4KB，有的时候可以达到 4MB</li>
<li>全相联 Fully associative：每一个 virual page 可以放在任意的 physical page 中，没有限制。</li>
<li>映射函数非常复杂，所以没有办法用硬件实现</li>
<li>通常使用 Write-back 而非 Write-through 机制<ul>
<li>Write-through: 命中后更新缓存，同时写入到内存中</li>
<li>Write-back: 直到这个缓存需要被置换出去，才写入到内存中（需要额外的 dirty bit 来表示缓存中的数据是否和内存中相同，因为可能在其他的时候内存中对应地址的数据已经更新，那么重复写入就会导致原有数据丢失）</li>
</ul>
</li>
</ul>
<p>具体怎么做呢？通过 page table。每个 page table 实际上是一个数组，数组中的每个元素称为 page table entry(PTE)，每个 PTE 负责把 virtual page 映射到 physical page 上。在 DRAM 中，每个进程都有自己的 page table，具体如下</p>
<p><img src="/images/14583104118576.jpg" alt="Page Table"></p>
<p>因为有一个表可以查询，就会遇到两种情况，一种是 Page Hit，另一种则是 Page Fault。</p>
<blockquote>
<p>Page hit: reference to VM word that is in physical memory (DRAM cache hit)</p>
</blockquote>
<p>访问到 page table 中蓝色条目的地址时，因为在 DRAM 中有对应的数据，可以直接访问。</p>
<blockquote>
<p>Page fault: reference to VM word that is not in physical memory (DRAM cache miss)</p>
</blockquote>
<p>访问到 page table 中灰色条目的时候，因为在 DRAM 中并没有对应的数据，所以需要执行一系列操作（从磁盘复制到 DRAM 中），具体为：</p>
<ul>
<li>触发 Page fault，也就是一个异常</li>
<li>Page fault handler 会选择 DRAM 中需要被置换的 page，并把数据从磁盘复制到 DRAM 中</li>
<li>重新执行访问指令，这时候就会是 page hit</li>
</ul>
<p>复制过程中的等待时间称为 demand paging。</p>
<p>仔细留意上面的 page table，会发现有一个条目是 null，也就是没有分配。具体的分配过程（比方说声明了一个大数组），就是让该条目指向虚拟内存（在磁盘上）的某个 page（但并不复制到 DRAM，只有当出现 page fault 的时候才需要赋值）</p>
<p>看起来『多此一举』，但是由于局部性原理，虚拟内存其实是非常高效的机制，这一部分最后提到了 working set 的概念，比较简单，这里不再赘述：</p>
<p><img src="/images/14583113431902.jpg" alt="working set"></p>
<h2 id="u4F5C_u4E3A_u5185_u5B58_u7BA1_u7406_u5DE5_u5177"><a href="#u4F5C_u4E3A_u5185_u5B58_u7BA1_u7406_u5DE5_u5177" class="headerlink" title="作为内存管理工具"></a>作为内存管理工具</h2><p>前面提到，每个进程都有自己的虚拟地址空间，这样一来，对于进程来说，它们看到的就是简单的线性空间（但实际上在物理内存中可能是间隔、支离破碎的），具体的映射过程可以用下图表示：</p>
<p><img src="/images/14583114512897.jpg" alt="maping"></p>
<p>在内存分配中没有太多限制，每个 virtual page 都可以被映射到任何的 physical page 上。这样也带来一个好处，如果两个进程间有共享的数据，那么直接指向同一个 physical page 即可（也就是上图 PP 6 的状况，只读数据）</p>
<p>虚拟内存带来的另一个好处就是可以简化链接和载入的结构（因为有了统一的抽象，不需要纠结细节），如下图所示：</p>
<p><img src="/images/14583116383432.jpg" alt="Simplifying Linking and Loading"></p>
<h2 id="u4F5C_u4E3A_u5185_u5B58_u4FDD_u62A4_u5DE5_u5177"><a href="#u4F5C_u4E3A_u5185_u5B58_u4FDD_u62A4_u5DE5_u5177" class="headerlink" title="作为内存保护工具"></a>作为内存保护工具</h2><p>Page table 中的每个条目的高位部分是表示权限的位，MMU 可以通过检查这些位来进行权限控制（读、写、执行）</p>
<p><img src="/images/14583120873244.jpg" alt="Permission bits"></p>
<h2 id="u5730_u5740_u7FFB_u8BD1"><a href="#u5730_u5740_u7FFB_u8BD1" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>开始之前先来了解以下概念：</p>
<p><img src="/images/14583133332593.jpg" alt="Summary of Address Translation Symbols"></p>
<p>然后我们通过一个具体的例子来说明如何进行地址翻译</p>
<p><img src="/images/14583134329438.jpg" alt="Address Translation With a Page Table"></p>
<p>具体的访问过程为：</p>
<ul>
<li>通过虚拟地址找到 page table 中对应的条目</li>
<li>检查 valid bit，是否需要触发 page fault</li>
<li>然后根据 page table 中的 physical page number 找到内存中的对应地址</li>
<li>最后把 virtual page offset 和前面的实际地址拼起来，就是最终的物理地址了</li>
</ul>
<p>这里又分两种情况：Page Hit 和 Page Fault，具体过程如下：</p>
<p><img src="/images/14583139236125.jpg" alt="Page Hit"></p>
<ol>
<li>Processor sends virtual address to MMU</li>
<li>MMU fetches PTE from page table in memory</li>
<li>MMU fetches PTE from page table in memory</li>
<li>MMU sends physical address to cache/memory</li>
<li>Cache/memory sends data word to processor</li>
</ol>
<p><img src="/images/14583140218329.jpg" alt="Page Fault"></p>
<ol>
<li>Processor sends virtual address to MMU</li>
<li>MMU fetches PTE from page table in memory</li>
<li>MMU fetches PTE from page table in memory</li>
<li>Valid bit is zero, so MMU triggers page fault exception</li>
<li>Handler identifies victim (and, if dirty, pages it out to disk)</li>
<li>Handler pages in new page and updates PTE in memory</li>
<li>Handler returns to original process, restarting faulting instruction</li>
</ol>
<p>把这个和我们前面提到的 cache memory 结合起来就是：</p>
<p><img src="/images/14583153762095.jpg" alt="Integrating VM and Cache"></p>
<ul>
<li>VA: virtual address, PA: physical address</li>
<li>PTE: page table entry, PTEA = PTE address</li>
</ul>
<p>但是我们会发现，这样其实还不够快，L1 cache 虽然快，为什么不能直接在 MMU 进行一部分的工作呢？于是就有了另外一个设计：Translation Lookaside Buffer(TLB)</p>
<ul>
<li>Small set-associative hardware cache in MMU</li>
<li>Maps virtual page numbers to physical page numbers</li>
<li>Contains complete page table entries for small number of pages</li>
</ul>
<p>我们使用 Virtual Page Number 部分当做访问 TLB 的索引，具体如下（和 cache memory 非常相似）：</p>
<p><img src="/images/14583156462414.jpg" alt="Accessing the TLB"></p>
<p>同样分两个情况：TLB Hit 和 TLB Miss</p>
<blockquote>
<p>A TLB hit eliminates a memory access</p>
</blockquote>
<p><img src="/images/14583156886189.jpg" alt="TLB Hit"></p>
<blockquote>
<p>A TLB miss incurs an additional memory access(the PTE)</p>
</blockquote>
<p><img src="/images/14583157195012.jpg" alt="TLB Miss"></p>
<h3 id="Multi-Level_Page_Tables"><a href="#Multi-Level_Page_Tables" class="headerlink" title="Multi-Level Page Tables"></a>Multi-Level Page Tables</h3><p>Page table 的另一个问题就是，因为往往虚拟地址的位数比物理内存的位数要大得多，所以保存 page table entry(PTE) 也是一个问题。举个例子：</p>
<p>假设一个 page 的大小是 4KB($2^12$)，每个地址有 48 位，一条 PTE 记录有 8 个字节，那么要全部保存下来，需要的大小是：</p>
<p>$$2^{48} \times 2^{-12} \times 2^3 = 2^{39} bytes$$</p>
<p>整整 512 GB!</p>
<p>所以解决办法就是，多层的 page table，第一层的 page table 中的条目指向其他的 page table，然后再去寻找具体的地址：</p>
<p><img src="/images/14583164443493.jpg" alt="A Two-Level Page Table Hierarchy"></p>
<p>具体的翻译过程如下：</p>
<p><img src="/images/14583165384715.jpg" alt="Translating with a k-level Page Table"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Programmer’s view of virtual memory<ul>
<li>Each process has its own private linear address space</li>
<li>Cannot be corrupted by other processes</li>
</ul>
</li>
<li>System view of virtual memory<ul>
<li>Use memory efficiently by caching virtual memory pages<ul>
<li>Efficient only because of locality </li>
</ul>
</li>
<li>Simplifies memory management and programming</li>
<li>Simplifies protection by providing a convenient interpositioning point to check permissions</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课开始，我们会接触到计算机系统中另外一个非常重要的概念：虚拟内存。这个机制提供给了上层应用一个统一的地址空间，而无须操心物理内存的位置。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="虚拟内存" scheme="http://wdxtub.com/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 20 课 设计模式]]></title>
    <link href="http://wdxtub.com/2016/03/17/sad-20/"/>
    <id>http://wdxtub.com/2016/03/17/sad-20/</id>
    <published>2016-03-17T17:33:55.000Z</published>
    <updated>2016-03-18T01:30:19.000Z</updated>
    <content type="html"><![CDATA[<p>前面讲了这么多『玄学』概念，这一次终于回到软件开发的主战场——设计模式！</p>
<a id="more"></a>
<hr>
<p>设计模式可以算得上是软件架构中最有门道的一部分，也是大家最熟悉却又最陌生的一部分。熟悉是因为任何软件工程的课一定会提到，陌生则是因为『纸上得来终觉浅』，往往在实际应用中，会出现很多问题。总体来说，设计模式可以看作是解决某种特定问题的成功经验的提炼，学习设计模式，等于是站在巨人的肩膀上，能看得更远。</p>
<p>因为自己对这个话题也很有兴趣，所以就不按照老师课堂的讲述来编排了（实话说我觉得她讲的非常一般），课堂上主要介绍了工厂模式、单例模式、建造者模式和原型模式（本文都会涉及）。</p>
<p>本文主要写自己对不同模式，以及模式之间的一些思考。</p>
<h2 id="u5148_u5520_u53E8_u4E24_u53E5"><a href="#u5148_u5520_u53E8_u4E24_u53E5" class="headerlink" title="先唠叨两句"></a>先唠叨两句</h2><p>从前提到『设计模式』，总觉得是特别高大上的东西。随着代码越写越多，接触的事物越来越广泛，慢慢开始意识到这些所谓的『规则』，是保护，也是束缚。也开始怀疑过去不知道为什么就会去『相信』的东西，比如说本文的『设计模式』，以及与之密切相关的『面向对象』。</p>
<p>学术界的一大问题在于，有的时候为了凸现自己的不同，会强行『发明』一些东西。层出不穷的理论与技术，结合不同时代的主题，颇有种『一代补丁一代神』的循环感。最近特别火的 AlphaGO，最终不可避免会遇到 PS4 的尴尬——是在模拟地球，还是在模拟地球仪？</p>
<p>最近几年听到看到的各路流派给自己贴光环的故事已经太多，从 OO 到 SOA，从 Vim 到 Emac，从 Windows 到 Linux/Unix，例子不胜枚举。问题在于，它们都想用一个东西解决所有问题，但是真有这么个东西，早就解决了你想要解决这个解决问题的问题了（是不是被绕了？）。不能只有一种声音，不能只有一种思路，甚至可以从《一九八四》中『偷』来这么个概念——双重思想。</p>
<p>C++ STL 库的作者关于面向对象说过这么一段话（虽有断章取义之嫌，但应该还是能表达出他的理念）：</p>
<blockquote>
<p>I find OOP technically unsound. It attempts to decompose the world in terms of interfaces that vary on a single type. To deal with the real problems you need multisorted algebras – families of interfaces that span multiple types. I find OOP philosophically unsound. It claims that everything is an object. Even if it is true it is not very interesting – saying that everything is an object is saying nothing at all. I find OOP methodologically wrong. It starts with classes. It is as if mathematicians would start with axioms. You do not start with axioms – you start with proofs. Only when you have found a bunch of related proofs, can you come up with axioms. You end with axioms. The same thing is true in programming: you have to start with interesting algorithms. Only when you understand them well, can you come up with an interface that will let them work.</p>
</blockquote>
<p>就拿 Java 来说，所有东西都是对象，这跟所有东西都不是对象又有什么区别呢？纵观《设计模式》一书所说的 23 种设计模式，说白了就是：</p>
<ul>
<li>多组合少继承</li>
<li>面向接口而非实现</li>
<li>高内聚低耦合</li>
</ul>
<p>其实都是平时听得太多以至于不太在意的概念。或者很多时候我们被『想当然』封印住了思考，本能就往 OO 或者 SOA 的方向跳了。</p>
<p>然后说说 SOA，从大三刚开始接触的时候，我就感觉非常不科学。SOA 的想法很好，方向也很好，但是遇到的一个悖论就是，在业务复杂到足以体现 SOA 的优势的时候，往往 SOA 本身已经复杂得没人弄得懂了。因为大家都是提供一个服务给别人调用，那么调用背后发生的事情就是一团乱麻了，基本上一个功能完成后就只有两个命运：用一段时间，需要更新的时候直接重写。</p>
<p>这种时候不妨回过头来看看『传统』的数据驱动编程，就会发现只有一直抓住问题的本质，才不至于人为增加太多复杂度（所以这个学期的云计算课程人为浪费大家时间我真心感受到了助教的恶意）。</p>
<blockquote>
<p>Keep It Simple, Stupid!</p>
</blockquote>
<h2 id="u5E38_u89C1_u6A21_u5F0F"><a href="#u5E38_u89C1_u6A21_u5F0F" class="headerlink" title="常见模式"></a>常见模式</h2><ul>
<li>工厂模式的本质，实际上是以一个统一的角度去理解所有的资源，具体根据特定的标志符来进行对应处理</li>
<li>抽象工厂的本质，其实就是一组配置文件，搞得那么玄乎，真心还就是几个文本文件可以解决的问题</li>
<li>原型模式的本质，Unix 中的 <code>fork</code> 可以说是完美体现，反正我先原样搞出来一个，剩下的自己继续处理</li>
<li>单例模式的本质，更像是中央集权，可以通过穿透层级进行信息的快速传递，减少消耗</li>
<li>适配器模式的本质，就是带面具，和病毒欺骗细胞完成匹配一个意思</li>
</ul>
<p>这样列下去还有很多，术语之所以存在，是为大家提供一个概念上的平台，在平台之上，就可以放开手脚自由发挥，而不是被平台所限制。</p>
<blockquote>
<p>人法地、地法天、天法道、道法自然</p>
</blockquote>
<p>多去观察，多去思考，而不是借由所谓的『权威』代替自己的劳动，才是不断进步的动力。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>那些我们习以为常觉得『自然』的东西，其实才是最重要的『模式』。</p>
<p>（这真是一篇头重脚轻的日志，实在没意思赘述概念了，具体在后面的参考链接都有）</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://design-patterns.readthedocs.org/zh_CN/latest/" target="_blank" rel="external">图说设计模式</a></li>
<li><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="external">Java之美从菜鸟到高手演变之设计模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="external">设计模式</a></li>
<li><a href="http://coolshell.cn/articles/8961.html" target="_blank" rel="external">从面向对象的设计模式看软件设计</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面讲了这么多『玄学』概念，这一次终于回到软件开发的主战场——设计模式！</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高级语法教程 2 The nature of grammar and grammar errors]]></title>
    <link href="http://wdxtub.com/2016/03/17/advanced-grammar-monitoring-2/"/>
    <id>http://wdxtub.com/2016/03/17/advanced-grammar-monitoring-2/</id>
    <published>2016-03-17T16:02:24.000Z</published>
    <updated>2016-03-17T22:06:06.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们通过一些具体的例子，来复习基本的语法概念，以及寻找为什么我们会出现语法错误的原因。</p>
<a id="more"></a>
<hr>
<p>课前回顾了之前的作业，就是一定要意识到自己到底是在哪里不熟悉，然后有针对性的用对自己有意义的事情来练习。并且尽可能多读英文书，找寻多样的表达方式</p>
<h2 id="u540D_u8BCD"><a href="#u540D_u8BCD" class="headerlink" title="名词"></a>名词</h2><blockquote>
<p>Divide this list of nouns into three categoreis, giving a heading to each.</p>
</blockquote>
<p>Word List: elephant, hope, September, delay, Diana, humor, car, marmalade, radio, Poland, truth, telephone, pole, mirror, oak, excitement</p>
<p>仔细查看各个选项之后，直觉的分类就是：抽象名词、具体名词和其他专有名词（月份/名字/国家）</p>
<p>不过除了专有名词之外，还有另一种思路，就是按照『可以当动词』的名词，和『不可以当动词』的名词，具体大家可以查查看</p>
<h2 id="u52A8_u8BCD"><a href="#u52A8_u8BCD" class="headerlink" title="动词"></a>动词</h2><blockquote>
<p>Divide the verbs in these utterances into two categories, stating a reason for your allocation</p>
</blockquote>
<p>这里主要是帮助大家区分及物动词(transitive)和不及物动词(intransitive)</p>
<ol>
<li>You’ve finished your tea.</li>
<li>They are eating cake.</li>
<li>They are eating at home.</li>
<li>She wants to watch TV.</li>
<li>I’m going to bed.</li>
<li>I’m reparing the car.</li>
<li>Cortez conquered Mexico.</li>
<li>Many leading politicians have died violently.</li>
<li>I can’t think clearly!</li>
<li>I hate this exersise!</li>
</ol>
<p>这里还出现了完成时，具体之后会详细说。</p>
<h2 id="u53E5_u5B50_u7ED3_u6784"><a href="#u53E5_u5B50_u7ED3_u6784" class="headerlink" title="句子结构"></a>句子结构</h2><blockquote>
<p>Why do these nonsense sentences sound acceptable</p>
</blockquote>
<p>这里需要注意英语的结构：SVO(Subject + Verb + Object)，想想为什么下面这一堆乱七八糟的也能构成『像样』的句子</p>
<ol>
<li>He crattled his splot and scrot out a neelying groal.</li>
<li>They strentered folicly until a magan veened to famble them.</li>
</ol>
<p>有主语，有类似过去式的动词，有借此，有形容词，有类似的短语结构。</p>
<h2 id="u5F85_u7EED"><a href="#u5F85_u7EED" class="headerlink" title="待续"></a>待续</h2><p>还有下半部分，不过由于今天老师迟到，暂时等下次上课后再补。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们通过一些具体的例子，来复习基本的语法概念，以及寻找为什么我们会出现语法错误的原因。</p>]]>
    
    </summary>
    
      <category term="结构" scheme="http://wdxtub.com/tags/%E7%BB%93%E6%9E%84/"/>
    
      <category term="英语" scheme="http://wdxtub.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="语法" scheme="http://wdxtub.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="错误" scheme="http://wdxtub.com/tags/%E9%94%99%E8%AF%AF/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Presentation Basics 2 展示问题及解决方案]]></title>
    <link href="http://wdxtub.com/2016/03/16/presentation-basics-2/"/>
    <id>http://wdxtub.com/2016/03/16/presentation-basics-2/</id>
    <published>2016-03-17T00:25:23.000Z</published>
    <updated>2016-03-17T01:00:52.000Z</updated>
    <content type="html"><![CDATA[<p>第二课主要是具体实践的过程，我们被要求选取一个自己领域的问题，按照给定的逻辑结构，来完成『背景，问题，解决方案，评估』这样一个完整体系的展示。</p>
<a id="more"></a>
<hr>
<p>因为主要是通过具体的小组练习来进行概念的掌握，所以这里列出相关的概念，感兴趣的同学可以自己找时间练习。老师推荐了一个方法：用手机把自己说话的内容录制下来，再回头看就会发现很多问题（因为我们说的时候是不可能一边说一边听，发现自己的问题的）</p>
<blockquote>
<p>Problem-solution presentations are often organized into the following parts:</p>
</blockquote>
<ul>
<li>Description of the situation or context that the problem exists in<ul>
<li>Give the background and the consequences of the problem, so that the audience will appreciate why the solution is important</li>
</ul>
</li>
<li>Description of the problem<ul>
<li>talk about all relevant parts of the problem so that in the next section the audience will see how your solution solves the problem</li>
</ul>
</li>
<li>Discussion of the solution(s)<ul>
<li>make sure to refer back to the description of the context and the problem in order to link the solution effectively to the previous parts of the presentation</li>
</ul>
</li>
<li>Evaluation of the solution(s)<ul>
<li>you may want to discuss both the positives and the negatives of the solution you are discussing. However, in a persuasive speech, presenters tend to downplay the negatives so that their audience does not focus on the negatives</li>
</ul>
</li>
</ul>
<p>总结起来其实就是下面四个要点：</p>
<ul>
<li>Context：用平易近人的口气和例子来让大家进入节奏</li>
<li>Problem：说明问题的严重性，借此引出解决方案的重要性</li>
<li>Solution：多个角度来说明解决方案如何对应问题的各个方面</li>
<li>Evaluation：正反两面说明，更加可信</li>
</ul>
<p>注意不同要点之间的过渡要自然，并且用明显的转折词和关键字来让受众跟上节奏。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第二课主要是具体实践的过程，我们被要求选取一个自己领域的问题，按照给定的逻辑结构，来完成『背景，问题，解决方案，评估』这样一个完整体系的展示。</p>]]>
    
    </summary>
    
      <category term="展示" scheme="http://wdxtub.com/tags/%E5%B1%95%E7%A4%BA/"/>
    
      <category term="英语" scheme="http://wdxtub.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高级语法教程 1 Challenging your grammar assumptions]]></title>
    <link href="http://wdxtub.com/2016/03/15/advanced-grammar-monitoring-1/"/>
    <id>http://wdxtub.com/2016/03/15/advanced-grammar-monitoring-1/</id>
    <published>2016-03-15T17:09:17.000Z</published>
    <updated>2016-03-15T20:06:32.000Z</updated>
    <content type="html"><![CDATA[<p>最近在上的另一门课程叫做 Advanced Grammar Monitoring。主要是针对英语不是母语的人群，帮助我们了解为什么会出现各类语法错误，以及如何改正它们。</p>
<a id="more"></a>
<hr>
<h2 id="u8BFE_u7A0B_u603B_u89C8"><a href="#u8BFE_u7A0B_u603B_u89C8" class="headerlink" title="课程总览"></a>课程总览</h2><p>这门课主要专注于我们在口语中出现的各类语法错误，帮助我们建立起语法的感觉，以及识别出对应的语法错误。语法在语言中的作用，类似于某种范式，是 guideline（我觉得 trend 也合适）而非 rule。</p>
<p>课程目标是让我们建立起：</p>
<ul>
<li>the way grammar is used in communicative settings</li>
<li>the kins of errors that are commonly made in academic language, and why those errors are made</li>
<li>useful monitoring strategies that allow you to address your own errors</li>
</ul>
<p>具体的上课方式是：</p>
<ul>
<li>learning about the role that grammar plays in language use</li>
<li>identifying, interpreting and correcting grammar errors in written material and from video tapes</li>
<li>monitoring peers and ourselves for grammar errors in discussion</li>
<li>developing strategies to control grammar errors while speaking</li>
</ul>
<p>这个系列课程一共有六次，主题分别是：</p>
<ol>
<li>Challenging your grammar assumptions</li>
<li>The nature of grammar and grammar errors</li>
<li>Patterns of language and the importance of context</li>
<li>Building a greater understanding of grammar usage</li>
<li>What are your own grammar needs</li>
<li>Integration of theory and practice</li>
</ol>
<h2 id="u8BFE_u7A0B_u5185_u5BB9"><a href="#u8BFE_u7A0B_u5185_u5BB9" class="headerlink" title="课程内容"></a>课程内容</h2><p>八十分钟的课上除了小组讨论之外，还是有很多有意思的内容的，这里挑选三个核心问题来进行说明</p>
<h3 id="u8BED_u6CD5_u9519_u8BEF_u662F_u600E_u4E48_u6765_u7684"><a href="#u8BED_u6CD5_u9519_u8BEF_u662F_u600E_u4E48_u6765_u7684" class="headerlink" title="语法错误是怎么来的"></a>语法错误是怎么来的</h3><p>对于母语不是英语的人来说，表达自己的时候通常需要『并行思考』，一面要组织表达的逻辑与句子结构，一面需要选择正确的词语以及合适的语法，正是『鱼与熊掌不可得兼』。用老师的话来说，这属于 “too much cognitive load”，我们没办法在短时间内完美处理好 vocabulary, pronounciation, grammar, intent 这四个项目。</p>
<p>另外一个导致语法错误的原因，是母语本身和英语的差异，比方在中文里时态很多时候是隐含的（或者我们本能理解的），但是对应到英文中，各种不同类型的时态，就很容易选择错误（跟我们一开始学习英语时的习惯有关）。而且在日常的交流中，毕竟主要目的是互相弄懂意思，别人也不会特地去纠正我们的语法错误，也就意味着我们即使很多时候不知道自己说错了。</p>
<p>按照老师的说法，我们在描述复杂概念和想法的时候，说的其实是介于母语与第二语言的 interlanguage，想要跨越这个鸿沟并不简单，需要抛弃从前的习惯，转为养成新的习惯（当然这也不是上几次课就可以解决的，需要『刻意练习』）。不过也有好消息，至少我们可以通过训练，在跨域鸿沟之前也能把话说清楚。</p>
<h3 id="u8BED_u6CD5_u5230_u5E95_u662F_u4EC0_u4E48"><a href="#u8BED_u6CD5_u5230_u5E95_u662F_u4EC0_u4E48" class="headerlink" title="语法到底是什么"></a>语法到底是什么</h3><p>这部分就以判断对错的形式来进行说明（虽然想都不用想肯定都是错的叙述）</p>
<blockquote>
<p>True or false? Grammar is a set of rules, which are defined by experts in grammar books.</p>
</blockquote>
<p>当然是不对的，首先语法不是 rule，而是 guideline(agreement)，并且也不可能有所谓的一群『专家』来决定大家要怎么说话。从概念上来说，作为一种约定俗成的方式，其实不能被定义，只能被描述</p>
<blockquote>
<p>True or false? Most errors in grammar are caused by interference from the first language, so the best way to prevent these errors is for the teacher to contrast the two languages.</p>
</blockquote>
<p>前半句是对的，但是后半句就不对了。首先语言之间的对比是很难的，即使花了大力气对比成功了，似乎也没什么用。作为男生，我了解男生和女生的不同，但这并不意味着我就了解女生。</p>
<blockquote>
<p>True or false? Grammar is a problem for non-native speakers of a language because they are lazy and they didn’t study the rules hard enough.</p>
</blockquote>
<p>也是错的。我觉得问题有二：一是思维过载（前面提过），二是很多时候我们都不知道自己在犯错（所以需要帮助我们建立起意识到自己犯错的能力）</p>
<blockquote>
<p>True or false? Grammar errors always interfere with meaning.</p>
</blockquote>
<p>以偏概全。对于比较简单的描述，哪怕只是蹦几个词出来，对方应该都能够明白意思。但是对于更加细腻的感情和复杂的思维来说，语法错误可能就会导致大问题。</p>
<blockquote>
<p>True or false? In grammar, it is the rules that are most important for correct usage; context and the intent of the speaker are not important.</p>
</blockquote>
<p>这个问题引出了这门课最重要的一个观念：</p>
<p>Context + Intent = Grammar</p>
<p>语法应当是为我们服务的，而不是反过来，重要的是上下文和我们要表达的意思</p>
<blockquote>
<p>True or false? A grammar error occurs when a speaker breaks a rule.</p>
</blockquote>
<p>这里需要注意一个概念到底是 Grammar as Fact 还是 Grammar as Choice 呢？</p>
<p>目前我也没有特别好的答案（或者说知道是 Grammar as Choice 但是没有办法把背后的问题搞清楚）</p>
<p>所谓语法的规则，在初学者阶段需要强制培养出某种刻板的语感，但是到后来就不能拘泥于此了。</p>
<h3 id="u8868_u8FBE_u80FD_u529B_u516C_u5F0F"><a href="#u8868_u8FBE_u80FD_u529B_u516C_u5F0F" class="headerlink" title="表达能力公式"></a>表达能力公式</h3><p>这个其实是我自己想出来的一个公式：</p>
<p>表达能力 = 结构 + 词汇 + 语法 + 思维</p>
<p>暂时先卖个关子，不详细解释，来看下面的例子</p>
<blockquote>
<p>Discuss an interesting event that happened this semester</p>
</blockquote>
<p>需要注意以下三点：</p>
<ol>
<li>Tense: past tense</li>
<li>Finish the sentence</li>
<li>Awkward phrases</li>
</ol>
<p>老师随后举了一个例子，她是这么描述『昨天』的一件事的：</p>
<blockquote>
<p>Yesterday afteroon, I was on a bus. I was reading a book. Then a man punches me in the head!</p>
</blockquote>
<p>这里为什么最后用了现在时而不是继续过去时呢？老师的解释是这样的：动词的时态，其实不单单只是用来表达时间，更可以表示距离。如果我这里的 punch 也用过去时，给人的感觉就是现在已经没什么事儿了，但是如果我要表达即使到现在也非常不爽的感情，就要用动词来明确表示出这种感觉，也就是用现在时。</p>
<hr>
<p>总体来说这个系列课程参与的人数更多，同学也更踊跃，整体氛围更好，希望能多学到一点东西。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在上的另一门课程叫做 Advanced Grammar Monitoring。主要是针对英语不是母语的人群，帮助我们了解为什么会出现各类语法错误，以及如何改正它们。</p>]]>
    
    </summary>
    
      <category term="口语" scheme="http://wdxtub.com/tags/%E5%8F%A3%E8%AF%AD/"/>
    
      <category term="英语" scheme="http://wdxtub.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="语法" scheme="http://wdxtub.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 反思课 3 提高 Web 服务性能的策略与思考]]></title>
    <link href="http://wdxtub.com/2016/03/15/cc-rethink-3/"/>
    <id>http://wdxtub.com/2016/03/15/cc-rethink-3/</id>
    <published>2016-03-15T12:17:53.000Z</published>
    <updated>2016-03-15T13:37:57.000Z</updated>
    <content type="html"><![CDATA[<p>学习是一个不断改进方法论的过程，<a href="http://wdxtub.com/2016/03/11/cc-p6/">课程项目 6 MySQL 和 HBase 配置及测试</a>，因为自己对于搭建基于 NoSQL 数据库的 Web 服务缺乏足够的经验，在具体对前后端进行优化的时候走了很多弯路，也意识到了没有目的的优化很可能是劣化，这里主要整理一下自己对于优化问题的思考。</p>
<a id="more"></a>
<hr>
<h2 id="u5E94_u7528_u573A_u666F"><a href="#u5E94_u7528_u573A_u666F" class="headerlink" title="应用场景"></a>应用场景</h2><p>因为涉及到具体的问题，所以先大概说明一下应用场景，方便之后的叙述。事情大概是这样的：</p>
<ul>
<li>数据是 5100W 条左右带 tag 的 tweet</li>
<li>这些 tweet 有各种语言</li>
<li>只有读请求，每次需要返回指定用户用指定 tag 发送的 tweet</li>
<li>前端使用 Undertow，后端是部署在 Amazon EMR 的 HBase</li>
<li>有一定的预算限制（不能开多台机器来凑）</li>
</ul>
<p>难点在于，优化问题其实是一个涉及多层级多组件的『复杂』问题，需要考虑的东西很多，更纠结的是，整个系统是符合『木桶理论』的，也就是最短板决定了系统的整体性能。那么就牵扯出两个关键问题：短板在哪里？短板怎么解决。</p>
<h2 id="u4E00_u4E9B_u601D_u8003"><a href="#u4E00_u4E9B_u601D_u8003" class="headerlink" title="一些思考"></a>一些思考</h2><p>对于 Web 服务来说，所谓优化，可以简单粗暴分为两个子类，一是增加吞吐量，二是增加并发数。优化的整体思路，按照实施的顺序来看，大概是这样的：</p>
<ol>
<li>充分理解应用场景<ul>
<li>服务具体接收的请求的格式和具体需要返回的内容是什么</li>
<li>是偏向于读，还是偏向于写，亦或者是读写比较均衡</li>
<li>数据量大概是多少，分布式集群（如果要用）的基本配置是什么</li>
</ul>
</li>
<li>数据格式设计<ul>
<li>根据具体的场景，需要思考具体数据库的设计</li>
<li>如果是读比较多，可以考虑对数据进行预处理，用空间换时间</li>
<li>如果是写比较多，则需要尽可能减少冗余，减少改动时需要同步更新的记录</li>
</ul>
</li>
<li>分析服务瓶颈（慢在哪里）<ul>
<li>使用什么工具，监控什么指标来寻找瓶颈</li>
<li>根据输出的日志（这里需要自己决定输出什么）来找寻请求的规律</li>
<li>根据日志的数据统计，找到短板所在</li>
<li>这一步其实并不简单，更可怕的是，如果在这里分析错误，就会把整个优化带入死胡同（去优化并不需要优化的问题）</li>
</ul>
</li>
<li>充分利用硬件资源<ul>
<li>在预算限制下有没有开够机器</li>
<li>对于每台机器，其 CPU，内存，带宽等资源有没有尽可能使用</li>
<li>如果没有尽量利用，就说明钱没有花在刀刃上，可以考虑更换不同类型的机器，Amazon 提供了『通用』，『内存优化』和『计算优化』这几种不同的机器，可以根据监控的数据，根据前后端不同的任务来决定具体使用什么类型的机器</li>
</ul>
</li>
<li>解决木桶效应，不同层优化<ul>
<li>算法 + 数据结构优化</li>
<li>事务处理逻辑优化，尽可能减少单次请求需要的资源（包括计算、内存和带宽资源）</li>
<li>硬件优化，vertical scaling 或者 horizontal scaling</li>
<li>分布式结构优化，采用 ELB 或 Hadoop</li>
</ul>
</li>
</ol>
<h2 id="u4E00_u4E9B_u7B56_u7565"><a href="#u4E00_u4E9B_u7B56_u7565" class="headerlink" title="一些策略"></a>一些策略</h2><p>前面从总体的思路切入，这里因为涉及到具体的指标要求，所以会从细节方面切入。</p>
<p>首先要意识到从我们在浏览器中输入网址，到最后看到显示的内容之间发生了什么。因为这里不是网络分析课（Amazon 的网络我们能调优的范围也有限），所以 DNS 路由之类的内容这里不提，具体可以参考<a href="http://wdxtub.com/2016/02/10/internet-protocol/">计算机网络</a>一文。</p>
<p>那么到底中间的过程是什么呢？其实就 3 步：</p>
<ol>
<li>页面模板根据实际内容渲染成网页。这部分我们不需要考虑，并没有用任何渲染引擎，就是单纯返回一段数据而已</li>
<li>业务逻辑部分。显示内容之前做的预处理，对应配套的缓存，连接池等等内容。这部分理论上是需要考虑的，但是在具体的测试中，影响不算特别大（和后面相比）</li>
<li>数据库与网络传输部分。这部分是主要的瓶颈所在，接下来会细说。</li>
</ol>
<p>网络部分优化，其实是比较简单粗暴的，因为是只读操作，所以不需要考虑一致性问题，努力增加并发数即可，另一个角度则是减少每次传输所需要的带宽，综合来看，有下面的策略：</p>
<ul>
<li>使用 ELB 增加多台前端，多台机器并发请求</li>
<li>每台机器增加线程数（当然要在内存的允许范围内），但是加到一定程度也就足够了（毕竟带宽是有限的）</li>
<li>在后端对数据进行压缩，在前端进行解压缩，这样就减少了需要网络传输的数据</li>
</ul>
<p>（这部分策略我还没有具体尝试，因为用下面的方法已经满足要求了）</p>
<p>后台数据库和前台缓存实际上类似于 Memory Hierarchy，需要利用看似不大存在的 Locality 来获得最快的访问速度（经过测试如果缓存命中基本上可以认为是无延迟）。这里的 Locality，可以认为是具体流量模式的 Locality，而并非是在数据库中顺序访问。</p>
<p>有缓存，那么肯定就有预热，预热的重要性在于，把常用的记录缓存下来，具体缓存要多大呢？我也不知道，反正可能情况下，越大是越好的（这就是为啥最好开一个内存优化的机器，比其他系列多一倍内存）</p>
<p>最后说一下数据库的参数优化，不知道是不是 Amazon EMR 本身根据不同的配置会进行一定的优化，我并没有改动 HBase 的任何设置。这里的问题在于，因为刚接触 HBase，很多内容不熟悉，所以看着网上的教程瞎折腾很容易弄巧成拙，在优化的时候，一定要确定每一步都清楚自己在干嘛，不然就会出现自己以为正确的错误，而这种错误往往是最难解决的（因为自己压根不知道错了）</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>总体来说，这次的任务还是很有趣的，我也已经意识到了优化真心是一个牵一发动全身的问题，还是要有更加清晰的大局观和思路，才不至于迷失方向。不过话说回来，遇到不懂的问题，最好的方法是停下来，把相关的概念都捋一遍（比方说官方文档就不错），思考具体的问题所在，大胆假设小心验证，才更能找到令自己满意的答案。</p>
<p>另外，对于分析 web 服务的各类工具一头雾水（甚至都不知道有啥），还是得抽空研究一下，不然依靠手动输出计算时间效率太低，得到的数据可能也不准确。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>学习是一个不断改进方法论的过程，<a href="http://wdxtub.com/2016/03/11/cc-p6/">课程项目 6 MySQL 和 HBase 配置及测试</a>，因为自己对于搭建基于 NoSQL 数据库的 Web 服务缺乏足够的经验，在具体对前后端进行优化的时候走了很多弯路，也意识到了没有目的的优化很可能是劣化，这里主要整理一下自己对于优化问题的思考。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="优化" scheme="http://wdxtub.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Presentation Basics 1 理解美国式演讲风格]]></title>
    <link href="http://wdxtub.com/2016/03/14/presentation-basics-1/"/>
    <id>http://wdxtub.com/2016/03/14/presentation-basics-1/</id>
    <published>2016-03-14T23:15:12.000Z</published>
    <updated>2016-03-15T01:13:46.000Z</updated>
    <content type="html"><![CDATA[<p>最近开始上一门名为 Presentation Basics 课程，其目标是: Helping nonnative English speakers build the fluency to give successful presentations。虽然风格是比较美式的，但是对于我们平日里沟通和写作都有一定的指导意义。</p>
<a id="more"></a>
<hr>
<h2 id="u8BFE_u7A0B_u603B_u89C8"><a href="#u8BFE_u7A0B_u603B_u89C8" class="headerlink" title="课程总览"></a>课程总览</h2><p>这门课主要是为我们这种外国留学生（英语不是母语）而准备的，会教给我们基本的做展示的技术已经帮助我们在展示中更流畅地表达自己。因为是小班教学（九个人），所以会有充足的展示和反馈的机会。在整个课程中，每个人都需要做 4 次 mini-talk 和 1 次 presentation。课程结束后，我们应该能做到：</p>
<ul>
<li>Becoming more aware of your own speaking strengths and weaknesses and developing a plan for improving your speaking skills</li>
<li>Recognizing the importance of understanding an audience and how to engage that audience</li>
<li>Using organizational language to help guide your audience and emphasize key information</li>
<li>Using non-verbal cues to help convey information successfully</li>
<li>Becoming more comfortable in the role of presenter</li>
</ul>
<p>当站在台前，被大家注视的时候，感觉害羞尴尬不自在都是非常正常的表现，我们需要做的是慢慢去习惯适应，即所谓 comfortable with uncomfortable。</p>
<p>简单来说，一周两节课，第一节课会学习相关技巧，第二节课用来练习和展示，具体的上课方法是：</p>
<ul>
<li>Watching videotaped presentations that can serve as models of strong presenting in the US academic style</li>
<li>Identifying the way key content information is conveyed in presentations</li>
<li>Focusing on the way information is organized so that it is clear for listeners</li>
<li>Practicing presentation techniques through in-class activities and in a prepared presentation</li>
<li>Meeting individually with the instructor for detailed feedback on your videotaped presentation</li>
</ul>
<p>其实从中我们可以总结出交流沟通的几个重要技巧：首先是确定重要信息是什么，然后思考如何去组织这些信息，让受众更容易理解，之后就是通过不断练习来磨练自己的技艺。</p>
<h2 id="u8BFE_u7A0B_u5B89_u6392_u4E0E_u53C2_u8003_u8D44_u6599"><a href="#u8BFE_u7A0B_u5B89_u6392_u4E0E_u53C2_u8003_u8D44_u6599" class="headerlink" title="课程安排与参考资料"></a>课程安排与参考资料</h2><p>下面是具体八次课的安排以及每节课的目标</p>
<ol>
<li>Understanding the US discourse style<ul>
<li>To recognize your audience’s expectations and how to communicate effectively with your audience</li>
</ul>
</li>
<li>First mini-talk: Define a problem and its solution<ul>
<li>To identify the parts of a problem-solution presentation and to practice this organization in a mini-talk</li>
</ul>
</li>
<li>Linking &amp; organizing language<ul>
<li>To practice using linking and organizing language to help structure your presentations</li>
</ul>
</li>
<li>Second mini-talk: Describing a process<ul>
<li>To apply what you know about organization strategies and linking language to clearly explain a process </li>
</ul>
</li>
<li>Attention-getting openers<ul>
<li>To identify qualities of successful introductions and to practice using them</li>
</ul>
</li>
<li>Third mini-talk: Defining a concept<ul>
<li>To identify qualities of clear definitions and to practice defining a term from your field</li>
</ul>
</li>
<li>Pronunciation and presenting<ul>
<li>To understand the importance of stress and intonation to give clarity to your presentations</li>
</ul>
</li>
<li>Videotaped presentations<ul>
<li>To synthesize skills learned in this class to present a concept from your field</li>
</ul>
</li>
</ol>
<p>参考资料</p>
<ul>
<li>Alley, <the craft="" of="" scientific="" presentations=""></the></li>
<li>Reinhart, <giving academic="" presentations=""></giving></li>
<li>Smith, <communicate: strategies="" fro="" international="" teaching="" assistants=""></communicate:></li>
<li>Sterns, Breaking the Accent Barrier(Video)</li>
<li>Winston, How to Speak(<a href="https://vimeo.com/101543862" target="_blank" rel="external">Video</a>)</li>
</ul>
<h2 id="u4E0A_u8BFE_u5185_u5BB9_u53CA_u611F_u60F3"><a href="#u4E0A_u8BFE_u5185_u5BB9_u53CA_u611F_u60F3" class="headerlink" title="上课内容及感想"></a>上课内容及感想</h2><p>具体的上课内容是大家一起看 <a href="https://vimeo.com/101543862" target="_blank" rel="external">How to Speak</a> 这个视频，然后讨论其使用的各种技巧，具体的内容我在 <a href="http://wdxtub.com/2016/02/22/how-to-speak/">How to Speak 日志</a> 中已经有总结，这里不再赘述，主要记录一下我上课时的感想。</p>
<ul>
<li>展示开头直接开门见山，告诉听众可以期待什么，并且列举出接下来要说的要点，有清晰的组织结构</li>
<li>为了解释复杂的问题和概念，尽量使用比喻，来帮助人们建立起基本的认知</li>
<li>如果想要听众印象深刻，可以考虑使用排比句，精炼展示的内容</li>
<li>很多时候我们不欠缺日常生活共同以及专业学术讨论的能力，但是给非本领域的人介绍相关内容时，往往容易出问题，这是我们需要着重去准备的</li>
<li>从纯技术领域开始，进行简化，最后应用 KISS(Keep It Simple &amp; Stupid) 原则</li>
<li>这里的 Stupid 很有意思，不是蠢，而是指 hard to break，例如没有任何机械部分的东西就比有机械部分的东西 stupid，从这个角度来说，静态网站比动态网站 stupid，所以我用静态网站生成器做博客，也算是 stay stupid</li>
<li>除了总体的结构，还需要注意每个段落之间每句话的结构和联系，总而言之，就是通通都是逻辑，不要拐弯抹角，不要随意用『显然』跳过推理过程</li>
</ul>
<p>第一节课的内容就这么多，我们下次再见。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近开始上一门名为 Presentation Basics 课程，其目标是: Helping nonnative English speakers build the fluency to give successful presentations。虽然风格是比较美式的，但是对于我们平日里沟通和写作都有一定的指导意义。</p>]]>
    
    </summary>
    
      <category term="展示" scheme="http://wdxtub.com/tags/%E5%B1%95%E7%A4%BA/"/>
    
      <category term="英语" scheme="http://wdxtub.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
</feed>
