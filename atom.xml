<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-02-26T21:11:00.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 18 课 Deployment and Mobility]]></title>
    <link href="http://wdxtub.com/2016/02/26/sad-18/"/>
    <id>http://wdxtub.com/2016/02/26/sad-18/</id>
    <published>2016-02-26T21:06:57.000Z</published>
    <updated>2016-02-26T21:11:00.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
<hr>
 公式 
]]>
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 17 课 Security and Trust]]></title>
    <link href="http://wdxtub.com/2016/02/26/sad-17/"/>
    <id>http://wdxtub.com/2016/02/26/sad-17/</id>
    <published>2016-02-26T21:06:50.000Z</published>
    <updated>2016-02-26T21:10:32.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
<hr>
 公式 
]]>
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 16 课 Non-Functional Property]]></title>
    <link href="http://wdxtub.com/2016/02/26/sad-16/"/>
    <id>http://wdxtub.com/2016/02/26/sad-16/</id>
    <published>2016-02-26T21:06:46.000Z</published>
    <updated>2016-02-26T21:10:05.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
<hr>
 公式 
]]>
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 15 课 Applied Architectures]]></title>
    <link href="http://wdxtub.com/2016/02/26/sad-15/"/>
    <id>http://wdxtub.com/2016/02/26/sad-15/</id>
    <published>2016-02-26T21:06:41.000Z</published>
    <updated>2016-02-26T21:08:23.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
<hr>
 公式 
]]>
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 课程项目 1 搭建高性能数据获取网络服务]]></title>
    <link href="http://wdxtub.com/2016/02/25/cc-p1/"/>
    <id>http://wdxtub.com/2016/02/25/cc-p1/</id>
    <published>2016-02-26T00:35:05.000Z</published>
    <updated>2016-02-26T17:49:26.000Z</updated>
    <content type="html"><![CDATA[<p>从这次作业开始，就要小组作业和个人作业并行了。这次的项目主要是在云上分析 Twitter 的相关内容，与以前 GB 级数据不一样，这次我们要处理 TB 级的数据，还是很刺激的。另，这是小组作业，在此先感谢我的队友 @leiyu 和 @shushanc</p>
<a id="more"></a>
<hr>
<p>主要任务是：Twitter Analytics on the Cloud</p>
<h2 id="u4EFB_u52A1_u76EE_u6807"><a href="#u4EFB_u52A1_u76EE_u6807" class="headerlink" title="任务目标"></a>任务目标</h2><ol>
<li>在一定预算限制下利用所学知识搭建一个性能高可靠性又好的 web 服务</li>
<li>设计、开发、部署和优化服务器以处理比较高的负载（大约每秒上万次请求）</li>
<li>在一个大数据集上（约 1TB）实现 Extract Transform and Load (ETL) 并载入到 MySQL  和 HBase 中</li>
<li>设计 MySQL 和 HBase 的 schema 并优化配置来提高性能</li>
<li>探索寻找基于云的 web 服务中潜在瓶颈的方法，并提高性能</li>
</ol>
<p>我们需要搭建并优化一个有两个组件的 web 服务，前端负责处理请求，后端负责查询数据，架构如图：</p>
<p><img src="/images/14564545973314.jpg" alt="系统架构"></p>
<ol>
<li>前端：能够接收和响应查询请求的 web 服务<ul>
<li>用过通过指定网址发送 HTTP GET 请求来访问 web 服务。不同的请求有不同的地址，后面跟有不同的参数</li>
<li>要返回适当的响应，并且一定要按照指定的格式</li>
<li>Web 服务需要在持续若干小时的测试中正常运行</li>
<li>Web 服务不能拒绝请求，应该能够承受高负载</li>
</ul>
</li>
<li>后端：保存用来查询的数据文件<ul>
<li>需要评估 SQL(MySQL) 和 NoSQL(HBase)</li>
<li>比较不同数据集不同查询类型的性能表现，然后由此来决定如何实现后端</li>
</ul>
</li>
<li>Web 服务应该在不超过预算的情况下达到指定的吞吐量</li>
<li>钱花得越少越好</li>
<li>前端和后端均使用 M 系列的实例，批量处理的时候注意使用竞价实例（总之就是要省钱）</li>
</ol>
<blockquote>
<p>数据集</p>
</blockquote>
<ul>
<li>数据集地址为：<code>s3://cmucc-datasets/twitter/s16/</code></li>
<li>大小超过 1 TB，还会有重复和损坏的记录</li>
<li><a href="http://en.wikipedia.org/wiki/JSON" target="_blank" rel="external">JSON</a> 格式，每行表示一个 tweet，具体看<a href="https://dev.twitter.com/docs/platform-objects/tweets" target="_blank" rel="external">Twitter API</a>.</li>
<li>字符编码是 unicode，建议使用下面的库<ul>
<li>simple json/gson(Java)</li>
<li>标准库中的 json module(python)</li>
</ul>
</li>
</ul>
<blockquote>
<p>进度安排及制品</p>
</blockquote>
<p>项目分三个阶段，每个阶段完成不同的任务，每个阶段完成之后都需要提交制品：</p>
<ol>
<li>性能数据</li>
<li>开销分析</li>
<li>源代码</li>
<li>问答题的答案</li>
<li>阶段报告，包括设计选择和制品描述 </li>
</ol>
<h3 id="u5E38_u89C1_u95EE_u9898"><a href="#u5E38_u89C1_u95EE_u9898" class="headerlink" title="常见问题"></a>常见问题</h3><blockquote>
<p>如何提交测试请求？</p>
</blockquote>
<p>提交 web 服务的地址即可开始测试，提供不同时间长度的测试，可以有针对性进行选择，比方说如果只是为了检测服务能否正常运行，那么可能几分钟的测试就够了；如果想要看看长时间能否工作，就需要长时间的测试。</p>
<blockquote>
<p>到底测试什么？</p>
</blockquote>
<p>简单来说，每次提交测试请求之后，系统会产生特定的请求并发送到之前填写的地址，会检测性能和正确性。</p>
<blockquote>
<p>为什么提交不了请求了？</p>
</blockquote>
<p>为了省钱，每个队伍同时只能用一个测试在跑（或者在排队）</p>
<p>还可以取消当前的测试请求并重新提交</p>
<blockquote>
<p>如何计算分数？</p>
</blockquote>
<p>主要考察下面几点</p>
<ul>
<li>吞吐量：测试期间平均 RPS</li>
<li>延迟：平均每个请求的延迟</li>
<li>错误率：不返回 2XX 都是错误</li>
<li>正确率：检测是否返回正确的内容，注意仔细检查格式</li>
</ul>
<p>具体计算公式为：</p>
<ul>
<li>有效吞吐量 = 吞吐量 <em> (100 - 错误率 / 100) </em> (正确率 / 100)</li>
<li>原始分 = 有效吞吐量 / 目标吞吐量</li>
</ul>
<p>注意，错误率与正确率都会极大影响最后的分数</p>
<h2 id="u4EFB_u52A1_u6982_u89C8"><a href="#u4EFB_u52A1_u6982_u89C8" class="headerlink" title="任务概览"></a>任务概览</h2><h3 id="u524D_u7AEF"><a href="#u524D_u7AEF" class="headerlink" title="前端"></a>前端</h3><p>接收 RESTful 请求并返回响应，不限制所使用的 web 框架，但是需要至少使用两种，并比较他们的异同，最好使用竞价实例，省钱。</p>
<p>最好考虑使用 auto-scaling，因为测试的过程中会有波动。设计前端的时候要考虑到开销，并且写好测试脚本，不然每次都要部署一次很麻烦。</p>
<p>不同的 web 框架的性能也很不一样，如果一开始就选择了比较慢的框架，就相当于选择了 hard 模式，所以开始之前不妨看看主流框架的对比，详情参阅 <a href="https://www.techempower.com/benchmarks/" target="_blank" rel="external">Techempower</a></p>
<p>还有一个需要考虑的问题是，选择的前端框架最好有支持 MySQL 和  HBase 的 API，不然可能后面会很麻烦。在报告中注意写清楚为什么选择用某个框架。</p>
<h3 id="ETL"><a href="#ETL" class="headerlink" title="ETL"></a>ETL</h3><p>这部分的工作，需要使用 extract, transform and load (ETL) 把 Twitter 的数据集载入到数据仓库中。先从 S3 中获取大约 200 million tweets，然后把数据存储到目标数据库中，具体的操作取决于数据库设计。最好使用竞价实例，不然很可能会超支。</p>
<p>我们需要使用 AWS 精心设计 ETL 过程，选择合适的实例数量来完成这个工作，完成这个工作后，最好把数据库备份起来，不然每次都要做一次非常浪费钱，使用 EMR 的话，可以用下面这条命令把 HBase 备份到 S3 中</p>
<p><code>aws emr create-hbase-backup --cluster-id j-3AEXXXXXX16F2 --dir s3://mybucket/backups/j-3AEXXXXXX16F2 --consistent</code></p>
<p>详情请参阅<a href="http://docs.aws.amazon.com/ElasticMapReduce/latest/DeveloperGuide/emr-hbase-backup-restore.html" target="_blank" rel="external">这里</a></p>
<p>最好先用小数据集（比如说 200MB）来测试 ETL，不然每次失误的代价就太大了。载入数据库之后最好测试不同的请求类型，确保无误之后再开始后面的工作。</p>
<p>一定要仔细设计数据库的 schema，并据此好好设计 ETL，并确保 ETL 正确工作。因为每次都需要 10-30 个小时，如果需要做几次的话，很痛苦（虽然难以避免，很多时候可能在开发中会修改设计）</p>
<p>早点开始，多多利用并行，比较推荐使用 map reduce 来完成这个工作</p>
<h3 id="u540E_u7AEF"><a href="#u540E_u7AEF" class="headerlink" title="后端"></a>后端</h3><p>实际上就是所有数据存放的地方，前端会连接到后端来进行查询，最后返回对应结果。</p>
<p>这里我们会使用 MySQL 和 HBase，记得阅读提供的资料，可以快速上手。因为预算问题，还是多使用竞价实例。</p>
<p>在导入整个数据集之前，一定要用小数据集做一些测试，并确保后端数据库能返回正确的内容。</p>
<p>详情参考 <a href="http://dev.mysql.com/doc/" target="_blank" rel="external">MySQL</a> 和 <a href="https://hbase.apache.org/" target="_blank" rel="external">HBase</a></p>
<h3 id="u76F8_u5173_u8D44_u6E90_u4E0E_u53C2_u8003_u8D44_u6599"><a href="#u76F8_u5173_u8D44_u6E90_u4E0E_u53C2_u8003_u8D44_u6599" class="headerlink" title="相关资源与参考资料"></a>相关资源与参考资料</h3><p>Resources</p>
<ol>
<li><a href="https://www.techempower.com/benchmarks/" target="_blank" rel="external">Benchmarks of web servers</a></li>
<li><a href="http://www.percona.com/blog/2010/05/04/goal-driven-performance-optimization-white-paper-available/" target="_blank" rel="external">Schwartz, B., and P. Zaitsev. “A brief introduction to goal-driven performance optimization.” White paper, Percona (2010).</a></li>
<li><a href="http://www.percona.com/resources/mysql-webinars/practical-mysql-performance-optimization" target="_blank" rel="external">Practical MySQL Performance Optimization</a></li>
<li><a href="http://refcardz.dzone.com/refcardz/hbase" target="_blank" rel="external">HBase Cheat Sheet</a></li>
</ol>
<p>Architecting web servers</p>
<ol>
<li><a href="http://vts.uni-ulm.de/docs/2012/8082/vts_8082_11772.pdf" target="_blank" rel="external">Erb, Benjamin. “Concurrent programming for scalable web architectures.” Informatiktage. 2012.</a></li>
<li><a href="https://www.ece.cmu.edu/~ece845/docs/pariag-2007.pdf" target="_blank" rel="external">Pariag, David, et al. “Comparing the performance of web server architectures.” ACM SIGOPS Operating Systems Review. Vol. 41. No. 3. ACM, 2007.</a></li>
<li><a href="http://mmcgrana.github.io/2010/07/threaded-vs-evented-servers.html" target="_blank" rel="external">McGranaghan, Mark. “Threaded vs Evented Servers”</a></li>
<li><a href="https://www.dre.vanderbilt.edu/~schmidt/PDF/globalinternet.pdf" target="_blank" rel="external">Hu, James C., Irfan Pyarali, and Douglas C. Schmidt. “Measuring the impact of event dispatching and concurrency models on web server performance over high-speed networks.” Global Telecommunications Conference, 1997. GLOBECOM’97., IEEE. Vol. 3. IEEE, 1997.</a></li>
</ol>
<p>Clustering web servers</p>
<ol>
<li><a href="http://digitalcommons.unl.edu/cgi/viewcontent.cgi?article=1083&amp;context=csearticles" target="_blank" rel="external">Schroeder, Trevor, Steve Goddard, and Byrov Ramamurthy. “Scalable web server clustering technologies.” Network, IEEE 14.3 (2000): 38-45.</a></li>
<li><a href="http://www.ics.uci.edu/~cs230/reading/DLB.pdf" target="_blank" rel="external">Cardellini, Valeria, Michele Colajanni, and S. Yu Philip. “Dynamic load balancing on web-server systems.” IEEE Internet computing 3.3 (1999): 28-39.</a></li>
<li><a href="http://uu.diva-portal.org/smash/get/diva2:443102/FULLTEXT01.pdf" target="_blank" rel="external">Paudyal, Umesh. “Scalable web application using node.js and couchdb.” (2011).</a></li>
</ol>
<p>Optimizing a Multi-tier System</p>
<ol>
<li><a href="http://www.linuxjournal.com/article/7451" target="_blank" rel="external">Fitzpatrick, Brad. “Distributed caching with memcached.” Linux journal 2004.124 (2004): 5.</a></li>
<li><a href="http://www.linuxjournal.com/content/speed-your-web-site-varnish" target="_blank" rel="external">Graziano, Pablo. “Speed up your web site with Varnish.” Linux Journal 2013.227 (2013): 4.</a></li>
<li><a href="http://www.linuxjournal.com/magazine/nginx-high-performance-web-server-and-reverse-proxy" target="_blank" rel="external">Reese, Will. “Nginx: the high-performance web server and reverse proxy.” Linux Journal 2008.173 (2008): 2.</a></li>
</ol>
<p>Scalable and Performant Data Stores</p>
<ol>
<li><a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" target="_blank" rel="external">DeCandia, Giuseppe, et al. “Dynamo: amazon’s highly available key-value store.” ACM SIGOPS Operating Systems Review. Vol. 41. No. 6. ACM, 2007.</a></li>
<li><a href="http://www.cattell.net/datastores/Datastores.pdf" target="_blank" rel="external">Cattell, Rick. “Scalable SQL and NoSQL data stores.” ACM SIGMOD Record 39.4 (2011): 12-27.</a></li>
</ol>
<p>Web Server Performance Measurement</p>
<ol>
<li><a href="http://www.oocities.org/webserverperformance/webmodel.pdf" target="_blank" rel="external">Slothouber, Louis P. “A model of web server performance.” Proceedings of the 5th International World wide web Conference. 1996.</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.61.3268&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">Banga, Gaurav, and Peter Druschel. “Measuring the Capacity of a Web Server.” USENIX Symposium on Internet Technologies and Systems. 1997.</a></li>
<li><a href="https://www.mnot.net/blog/2011/05/18/http_benchmark_rules" target="_blank" rel="external">Nottingham, Mark. “On HTTP Load Testing”</a></li>
</ol>
<h2 id="u57FA_u672C_u8981_u6C42"><a href="#u57FA_u672C_u8981_u6C42" class="headerlink" title="基本要求"></a>基本要求</h2><ul>
<li>给所有的实例打上 <code>15619project:phase1</code> 的标签</li>
<li>另外，HBase 实例需要打上 <code>15619backend:hbase</code> 标签；MySQL 实例需要打上 <code>15619backend:mysql</code> 标签</li>
<li>ETL 部分可以选择任何类型的实例</li>
<li>前端和后端只能只用 M 系列不超过 large 的实例（large 也是可以用的）</li>
<li>可以选择任何免费的镜像，这次需要自己搭建整个系统</li>
<li>Web 服务的所有开销加起来不能超过每小时 <code>$0.85</code>（包括 EC2 实例，存储，EMR 和 ELB，不包括网络和磁盘 IO）</li>
<li>这个阶段每组有 <code>$40</code> 的预算</li>
</ul>
<p>虽然这一部分只占 10%，但是打下的基础很重要，尽可能多学多了解一些。</p>
<p><img src="/images/14564602178732.jpg" alt="任务要求"></p>
<p><img src="/images/14564603584769.jpg" alt="惩罚措施"></p>
<p>我们也提供了一个 <a href="http://q1-1848733628.us-east-1.elb.amazonaws.com/" target="_blank" rel="external">reference server</a> 方便大家检查结果的正确性，强烈建议在开始导入到数据库之前用 reference server 测试好。也可以利用这个服务器来检测可能出现的编码问题。</p>
<p>这一阶段我们要处理两类请求，从存储系统中获取数据（这一部分我们需要设计和控制），web service 需要能够连接到两个不同的后端存储系统(MySQL 和 HBase)，前端需要通过端口 80 接收 HTTP GET 请求。</p>
<p>这次的项目中，我们会设计并开发一个高并行的 web 服务器，可以连接到两种不同类型的数据库。在整个过程中，应该能够了解到不同后端实现的优势和劣势。</p>
<p>最后需要撰写报告，模板在 <a href="https://docs.google.com/document/d/1VOjU9JRAZG49PSrKnJtMOjSj5e1Ugbv_cQj7Mc_krd0/edit?usp=sharing" target="_blank" rel="external">这里</a></p>
<p>报告中需要包括 web 框架的如下信息：</p>
<ul>
<li>达到的 RPS</li>
<li>资源利用(CPU, Memory)</li>
<li>编程难度</li>
<li>两个框架的异同</li>
<li>适用的不同场景和优劣分析</li>
<li>为什么选择这些 web 框架</li>
</ul>
<h2 id="Query_1__28Heartbeat_and_Authentication_29"><a href="#Query_1__28Heartbeat_and_Authentication_29" class="headerlink" title="Query 1 (Heartbeat and Authentication)"></a>Query 1 (Heartbeat and Authentication)</h2><blockquote>
<p>目标吞吐量：25000 rps</p>
</blockquote>
<p>这部分的请求会询问 web 服务的状态，前端只需要返回 team id, AWS id, 时间戳以及一段加密的信息。这种机制通常称为心跳机制，但是也可以用来测试前端处理请求的能力。</p>
<p>q1 中的每个请求都包含 key <code>Y</code> 和一段由 key <code>Z</code> 加密的文本，<code>Z</code> 是 <code>X</code> 和 <code>Y</code> 的最大公约数（这里 <code>X</code> 是私钥）。这里我们使用 mythical Phaistos Disc Cipher (PDC) 来加密和解密</p>
<p>PDC 是为长度为完全平方数(4,9,16,25…)的大写英文字母(A-Z)组成的信息所设计的加密方式。我们需要自己进行解密的工作，也就是给定 key 和密文，获取原始的文本</p>
<p>PDC 的过程有三个步骤：KeyGen, Caesarify 和 Spiralize.</p>
<ol>
<li>KeyGen 阶段：随机选择一个大整数 <code>Y</code>，计算 <code>Y</code> 和我们的密钥 <code>X</code> 的最大公约数，记为 <code>Z</code> </li>
<li>Caesarify 阶段：利用 <code>Z</code> 生成一个 minikey <code>K = 1 + Z % 25</code>。我们把消息 <code>M</code> 中的每个字符都『偏移』<code>K</code> 个值，生成中间文本 <code>I</code></li>
<li>Spiralize 阶段：把消息选择写成正方形矩阵（参考下面的例子），然后再一行一行读出来，重排之后的消息就是密文<code>C</code>.</li>
</ol>
<p><img src="/images/14564607523532.jpg" alt="Spiral Matrix Example"></p>
<p>密文是：1,2,3,4,12,13,14,5,11,16,15,6,10,9,8,7（因为这里是数字，所以加上逗号方便区分）</p>
<p>Phaistos Disc Cipher encryption 的例子</p>
<p><img src="/images/14564607621256.jpg" alt="Phaistos Disc Cipher"></p>
<p>我们需要做的是解密，也就是给定密文 <code>C</code> 和 key <code>Y</code>，需要利用私钥 <code>X</code> 生成 <code>Z</code>，然后用 <code>Z</code> 来还原消息</p>
<blockquote>
<p>请求格式</p>
</blockquote>
<p><code>GET /q1?key=&lt;large_number&gt;&amp;message=&lt;uppercase_ciphertext_message_C&gt;</code></p>
<p>样例</p>
<p><code>GET /q1?key=4024123659485622445001958636275419709073611535463684596712464059093821&amp;message=URYEXYBJB</code></p>
<blockquote>
<p>响应格式（美东时间 EST）</p>
</blockquote>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEAMID,TEAM_AWS_ACCOUNT_ID\<span class="keyword">n</span></span><br><span class="line">yyyy-MM-dd HH:mm:ss\<span class="keyword">n</span></span><br><span class="line">[The decrypted message <span class="keyword">M</span>]\<span class="keyword">n</span></span><br></pre></td></tr></table></figure>
<p>样例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TeamCoolCloud,<span class="number">1234</span>-<span class="number">0000</span>-<span class="number">0001</span></span><br><span class="line"><span class="number">2004</span>-<span class="number">08</span>-<span class="number">15</span> <span class="number">16</span>:<span class="number">23</span>:<span class="number">42</span></span><br><span class="line">HELLOWORK</span><br></pre></td></tr></table></figure>
<p>这一部分我们只需要处理前端的问题，暂时不用考虑后端。</p>
<h2 id="Query_2__28Text_Cleaning_and_Analysis_29"><a href="#Query_2__28Text_Cleaning_and_Analysis_29" class="headerlink" title="Query 2 (Text Cleaning and Analysis)"></a>Query 2 (Text Cleaning and Analysis)</h2><p>目标吞吐量: 10000 rps</p>
<p>不允许使用任何已有的缓存应用 (Redis, Memcached, etc.) 或除了 MySQL 和 HBase 之外的数据库。但是可以自己写缓存应用。</p>
<p>在 ETL 阶段可以使用任何类型的实例，比如 <code>c family (Compute Optimized)</code> 和 <code>r family (Memory Optimized)</code>，不必只局限于 <code>m family (General Purpose)</code></p>
<p>MySQL 可以参考官方的优化文档，如果需要的话也可以使用其他版本的 MySQL</p>
<p>HBase: 可以选择用 EMR 来设置 HBase，或者自己搭建，不过自己搭建就要装 zookeeper 之类的，可以自行研究一下。</p>
<p>这里我们会对 Twitter 数据集进行分析，地址是 <code>s3://cmucc-datasets/twitter/s16/part-00XXX</code>，XXX 从 000 到 661。</p>
<p>会查询某个用户用指定的 hashtag 发的 tweet，主要考察如何设计一个高效的后端来处理大量的请求。</p>
<p>我们会提供 user id 和 hashtag（具体参考<a href="https://support.twitter.com/articles/49309?lang=en" target="_blank" rel="external">这里</a>），需要返回该用户所有带此 hashtag 的 tweet，具体格式如下：</p>
<ul>
<li>tweet 的 sentiment density</li>
<li>tweet 的发布时间</li>
<li>tweet id</li>
<li>审查修改过的的 tweet 内容，这里有很多可能出问题的地方，比如 emoji 表情、反斜杠、其他语言的字符等等，都需要小心处理</li>
</ul>
<p>Here is how you can obtain this information:</p>
<ol>
<li>利用 tweet 的内容来计算 sentiment density</li>
<li>tweet id 可以从 <code>id</code> 或 <code>id_str</code> 里获取</li>
<li>时间可以从 <code>created_at</code> 里获取</li>
<li>Tweet 的内容可以从 <code>text</code> 里获取，应该在计算完 sentiment density 再进行内容审查</li>
<li>hashtag(s) 可以从 <code>entities</code> 里获取，如果同一个 hashtag 在一条 tweet 中出现多次，只应该返回那条 tweet 一次</li>
</ol>
<p>注意事项：</p>
<ul>
<li>需要过滤掉重复的 Tweets（有相同的 id），返回响应的时候一条 tweet 只应该出现一次</li>
<li>满足下面条件的 tweet 也应该被过滤掉<ul>
<li><code>id</code> 和 <code>id_str</code> 为空或者没有这两个域</li>
<li><code>created_at</code>、<code>text</code> 或 <code>entities</code> 为空或者直接没有这几个域</li>
<li>无法被解析为 JSON 对象的记录</li>
</ul>
</li>
<li>Hashtag matching 需要百分百匹配（每个字节都一致），例如 “Naive”, “naive” 和 “naïve” 是不匹配的</li>
</ul>
<h3 id="u60C5_u611F_u5BC6_u5EA6"><a href="#u60C5_u611F_u5BC6_u5EA6" class="headerlink" title="情感密度"></a>情感密度</h3><p>按照下面四个步骤来计算 Sentiment Density</p>
<ol>
<li>文本切分：把推文分隔成一个一个词，注意，这里堆单词的定义是：one or more consecutive alphanumeric characters ([a-zA-Z0-9]+) separated by non-alphanumeric character(s) ([^a-zA-Z0-9])</li>
<li>计算情感得分：简单来说，就是有一个小写字母的英文单词情感词典，只要推文中的某个词在这个词典里，就加上这个词的情感得分（初始分为零），情感词典来自 <a href="http://www2.imm.dtu.dk/pubdb/views/publication_details.php?id=6010" target="_blank" rel="external">AFINN</a> 数据集，在<a href="https://cmucc-datasets.s3.amazonaws.com/15619/f15/afinn.txt" target="_blank" rel="external">这里</a>下载 <ul>
<li>例如：”I love Cloud Computing” 这句话的得分是 3，因为 love 这个单词在情感词典中，且分值为 3</li>
</ul>
</li>
<li>计算有效词数量：也就是过滤掉 stop words。所谓 Effective Word Count(EWC) 可以这样计算 EWC = 总单词数目 - 停止词的数目<ul>
<li>例如：”I love Cloud Computing” 的 EWC 是 3，因为 “I” 是一个停止词</li>
</ul>
</li>
<li>计算 Sentiment Density：如果 EWC 是 0，那么 Sentiment Density 就是 0，如果 EWC 不为 0，那么计算公式是 Sentiment Score / EWC</li>
</ol>
<p>所有的计算结果都四舍五入保留三位小数 (1 -&gt; 1.000, 1.1-&gt;1.100, 1.0005 -&gt; 1.001, 1.9999 -&gt; 2.000, -1 -&gt; -1.000, -1.1-&gt; -1.100, -1.0005 -&gt; -1.001, -1.9999 -&gt; -2.000, etc.)</p>
<p>一个完整的例子：</p>
<p>“I love Cloud Computing” 的 Sentiment Density 为 1.000, 因为它的 Sentimental Score(3) 除以 EWC(3) 是 1.000.</p>
<h3 id="u6587_u672C_u5BA1_u67E5"><a href="#u6587_u672C_u5BA1_u67E5" class="headerlink" title="文本审查"></a>文本审查</h3><p>简单来说就是有敏感词，列表是经过 <a href="http://en.wikipedia.org/wiki/ROT13" target="_blank" rel="external">ROT13ed</a> 处理的。例如，假如一个敏感词是 <code>15619ppgrfg</code> 那么原文就是 <code>15619cctest</code>。具体的敏感词列表在<a href="https://cmucc-datasets.s3.amazonaws.com/15619/f15/banned.txt" target="_blank" rel="external">这里</a>下载</p>
<p>一定要先计算情感值然后再进行文本审查，遇到敏感词，把除第一个和最后一个单词都替换成星号(<code>*</code>).</p>
<p>例如，假设 cloud 是敏感词，如果原文是</p>
<p><code>I love Cloud compz... cloud TAs are the best... Yinz shld tell yr frnz: TAKE CLOUD COMPUTING NEXT SEMESTER!!! Awesome. It&#39;s cloudy tonight.</code></p>
<p>那么返回的时候，应该是这样：</p>
<p><code>I love C***d compz... c***d TAs are the best... Yinz shld tell yr frnz: TAKE C***D COMPUTING NEXT SEMESTER!!! Awesome. It&#39;s cloudy tonight.</code></p>
<p>可以选择在 ETL 过程中完成所有的运算（MapReduce 的时间更长，花费也就更高），或者在每次返回请求的时候运算（如果你写的代码足够快的话）</p>
<p>ETL 的过程中需要处理很多 corner case，可能会出现很多不清晰的地方，所以<a href="https://cmucc-datasets.s3.amazonaws.com/twitter/ref/part-00000-reference" target="_blank" rel="external">这里</a>提供了一个参考文件（小数据集），是第一个数据集(<code>s3://cmucc-datasets/twitter/s16/part-00000</code>) ETL之后的结果，每一行对应输入文件的的一行，每一列以 <code>\t</code> 分隔，具体如下；</p>
<ul>
<li>第 1 列：tweet id.</li>
<li>第 2 列：user id.</li>
<li>第 3 列：tweet date.</li>
<li>第 4 列：sentiment density.</li>
<li>第 5 列：审查后的 tweet 内容，去掉了某些字符，如 newline (\n), tab (\t) etc</li>
<li>第 6 列：hashtags（可能为空）</li>
</ul>
<p>注意处理好各种可能的奇奇怪怪的情况，注意处理好各种可能的奇奇怪怪的情况，注意处理好各种可能的奇奇怪怪的情况。</p>
<blockquote>
<p>请求格式</p>
</blockquote>
<p><code>GET /q2?userid=uid&amp;hashtag=hashtag</code></p>
<p>样例</p>
<p><code>GET /q2?userid=2324314004&amp;hashtag=LinkedIn</code></p>
<blockquote>
<p>响应格式（如果有对应的推文）</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">TEAMID</span>,<span class="tag">TEAM_AWS_ACCOUNT_ID</span>\<span class="tag">n</span></span><br><span class="line"><span class="tag">Sentiment_density1</span><span class="pseudo">:Tweet_time1</span><span class="pseudo">:Tweet_id1</span><span class="pseudo">:Cencored_text1</span>\<span class="tag">n</span></span><br><span class="line"><span class="tag">Sentiment_density2</span><span class="pseudo">:Tweet_time2</span><span class="pseudo">:Tweet_id2</span><span class="pseudo">:Cencored_text2</span>\<span class="tag">n</span></span><br><span class="line"><span class="tag">Sentiment_density3</span><span class="pseudo">:Tweet_time3</span><span class="pseudo">:Tweet_id3</span><span class="pseudo">:Cencored_text3</span>\<span class="tag">n</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>样例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TeamSecret,<span class="number">1123</span>-<span class="number">5813</span>-<span class="number">2134</span></span><br><span class="line"><span class="number">0.308</span>:<span class="number">2014</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">11</span>-<span class="number">42</span>-<span class="number">18</span>:<span class="number">456034778891169793</span>:RT @AlexanderCrepin: How To Find The Best <span class="preprocessor">#LinkedIn Groups To Join - - #personalbranding #jobhunt - - http:<span class="comment">//t.co/ixH5dOf88E</span></span></span><br><span class="line"><span class="number">0.267</span>:<span class="number">2014</span>-<span class="number">06</span>-<span class="number">01</span> <span class="number">19</span>-<span class="number">34</span>-<span class="number">25</span>:<span class="number">473185820636356608</span>:RT @tonyrestell: How To Build Relationships And Win Interviews Through <span class="preprocessor">#LinkedIn http:<span class="comment">//t.co/ELZgPnp4gY #jobhunt tips from @mocksource</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>响应格式（如果没有对应的推文）</p>
</blockquote>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TEAMID,TEAM_AWS_ACCOUNT_ID<span class="string">\n</span></span><br><span class="line"><span class="string">\n</span></span><br></pre></td></tr></table></figure>
<p>一些细节</p>
<ul>
<li><code>Tweet_time</code> 的时间格式是 format:yyyy-MM-dd HH-mm-ss (UTC time, 24-hour clock)</li>
<li>\n 应该被替换成换行符 ‘\n’ 而不是原来的两个符号 ‘\’ + ‘n’.</li>
<li>排序规则<ul>
<li>首先看 <code>Sentimental_density</code>，降序</li>
<li>如果前面数值相同，那么看 <code>Tweet_time</code>，时间按照升序排列</li>
<li>如果还相同，看 <code>Tweet_id</code>，id 按照升序排列，小的在前面</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>从这次作业开始，就要小组作业和个人作业并行了。这次的项目主要是在云上分析 Twitter 的相关内容，与以前 GB 级数据不一样，这次我们要处理 TB 级的数据，还是很刺激的。另，这是小组作业，在此先感谢我的队友 @leiyu 和 @shushanc</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="数据" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="服务" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 9 课 递归]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-9/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-9/</id>
    <published>2016-02-24T16:51:34.000Z</published>
    <updated>2016-02-26T00:08:31.000Z</updated>
    <content type="html"><![CDATA[<p>递归之所以成为大家比较头疼的问题，主要还是其思维模式和我们惯常思考问题的方式不大一致，这里简要写下一些关于递归的碎碎念，希望能有所帮助。</p>
<a id="more"></a>
<hr>
<p>我们一直在写程序，但是拿什么来证明程序本身的正确性呢？调试、测试用例、检查输出等等方法都没有办法保证百分百的正确性（黑天鹅效应）。</p>
<p>那怎么办呢？我们结合常见的编程模式来说明</p>
<ul>
<li>Imperative Programming: Java 中常见的编程模式，大部分时间大部分人都是在按这种方式编程</li>
<li>Applicative Programming: 也就是比较出名的『函数式编程』，这里不具体展开，详情参阅<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80" target="_blank" rel="external">这里</a></li>
</ul>
<p>其中函数式编程因为每个函数没有副作用，所以在概念上是比较好证明正确性的。接下来看看递归。</p>
<p>通用的模式是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">recursive_fn(params)&#123;</span><br><span class="line">    <span class="keyword">if</span> (...) <span class="keyword">return</span> some_value;</span><br><span class="line">    <span class="keyword">else</span> ... recursive_fn(new_params)..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种模式是尾递归 tail recursion</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tail_recursive_fn(params)&#123;</span><br><span class="line">    <span class="keyword">if</span> (...) <span class="keyword">return</span> some_value;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> tail_recursive_fn(new_params)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常来说，尾递归会更有效率一些，并且也更容易证明正确性。</p>
<p>另外一个比较常用的方法是回溯法，通用模式是：</p>
<ul>
<li>Test if current position satisfies goal</li>
<li>If not, mark current position as visited and make a recursive call to search procedure on neighboring points</li>
<li>Exhaustive search, terminates as soon as goal is found</li>
</ul>
<p>具体可以参阅我的『编程起跑线系列』</p>
<p>最后说一下递归的好处：</p>
<ul>
<li>实现起来比较简洁</li>
<li>尾递归对栈空间也需求较少</li>
</ul>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>花了比较短的时间把这门课过了一次，总体来说不算特别全面，课件也是东拼西凑勉强合格，除了比较多的作业之外，感觉还是挺一般的。不过话说回来，除了名声在外的几门课，很多课程的教学质量也是堪忧的，唉。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>递归之所以成为大家比较头疼的问题，主要还是其思维模式和我们惯常思考问题的方式不大一致，这里简要写下一些关于递归的碎碎念，希望能有所帮助。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 8 课 有限状态机]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-8/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-8/</id>
    <published>2016-02-24T16:49:42.000Z</published>
    <updated>2016-02-25T23:26:43.000Z</updated>
    <content type="html"><![CDATA[<p>《模仿游戏》的大热让图灵为更多人所知，不过电影中更多说的是图灵破解密码，却对图灵的另一个伟大设想——图灵机所言甚少。图灵机可以看作是某种有限状态机，虽然这个名词听起来比较陌生，但也许这是计算机学科中最重要的概念之一。</p>
<a id="more"></a>
<hr>
<p>最先知道有限状态机，是在本科学习编译原理的时候，实话说，这类概念其实是很难理解的，不过第一次看不懂也不要紧，指不定哪天就悟道了。</p>
<p>我们先来看看常见的集中语言类别及其对应的计算模型：</p>
<p><img src="/images/14564350412980.jpg" alt=""></p>
<h2 id="u57FA_u7840_u6982_u5FF5"><a href="#u57FA_u7840_u6982_u5FF5" class="headerlink" title="基础概念"></a>基础概念</h2><p>我们从最基本的概念说起，为之后进入更加抽象的概念打一些基础。</p>
<p>$\Sigma$: 一个有限的符号集合称为字母表。在 $\Sigma$(字母表)中的每个符号我们称为字母，通常用小写表示，如 a, b, c, …</p>
<p>一个单词 w 是一个字符串，字符串中的字符都来自于 $\Sigma$，$|w|$ 表示单词 w 的长度，一个空的字符串不包含任何字母，并且用 $\varepsilon$ 表示。</p>
<p>一门语言 L 是一个由 $\Sigma$ 中的单词组成的集合，给定字母表 $\Sigma$，所有可能的字符串记为 $\Sigma^<em>$。例如，如果 $\Sigma={a}$，那么 $\Sigma^</em> = {\varepsilon, a, aa, aaa, \dots}$</p>
<p>给定字母表 $\Sigma$，所有可能的长度为 i 的字符串记为 $\Sigma^i$。例如，如果 $\Sigma={a,b}$，那么 $L = \Sigma^2 = {ab, ba, aa, bb}$</p>
<p>然后我们定义一些基本操作</p>
<ul>
<li>Concatenation: putting two strings together。如 $x=aa;y=bb;xy=aabb$</li>
<li>Power: concatenating multiple copies of a letter or word。如 $a^n=a·a^{n-1};a^1 = a; a^2 = a·a$，若 $x=ab;x^3=ababab$</li>
<li>Kleene Star: zero or more copies of a letter or word。如 $a^<em>={\varepsilon, a, aa, aaa, \dots}$, $x=ab;x^</em>={\varepsilon, ab, abab, ababab, \dots }$</li>
</ul>
<h2 id="Finite-state_automaton"><a href="#Finite-state_automaton" class="headerlink" title="Finite-state automaton"></a>Finite-state automaton</h2><p>接下来的定义部分为了避免翻译不准确带来的歧义，这里都使用英文原文。</p>
<p>A <strong>finite-state automaton comprises the following elements:</strong></p>
<ul>
<li>A sequence of <strong>input symbols</strong> (the input “tape”)</li>
<li>The <strong>current location in the input</strong>, which indicates the current input symbol (the read “head”)</li>
<li>The <strong>current state of the machine</strong> (denoted q0, q1,…, qn)</li>
<li>A <strong>transition function</strong> which inputs the current state and the current input, and outputs a new (next) state</li>
</ul>
<p>在计算过程中</p>
<ul>
<li>FSA 在初始状态开始（通常称为 q0）</li>
<li>每一步，状态转移方程会接受当前的输入符号和当前的状态，并且更新到一个新的状态，指针指向下一个符号</li>
<li>在 FSA 到达输入的末尾时，计算过程结束</li>
</ul>
<p>一个或多个状态可以被标记为最终状态，只有计算停止在这些状态时，才认为是计算成功。更多的细节及符号形式请参考<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA" target="_blank" rel="external">这里</a></p>
<h3 id="Regular_Languages"><a href="#Regular_Languages" class="headerlink" title="Regular Languages"></a>Regular Languages</h3><p><img src="/images/14564392411172.jpg" alt=""></p>
<h3 id="NDFSA__u4E0E_DFSA"><a href="#NDFSA__u4E0E_DFSA" class="headerlink" title="NDFSA 与 DFSA"></a>NDFSA 与 DFSA</h3><p>实话说这部分不是特别看得懂，所以只能给出参考链接了</p>
<ul>
<li>NDFSA - <a href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA" target="_blank" rel="external">非确定有限状态自动机</a></li>
<li>DFSA - <a href="https://zh.wikipedia.org/wiki/%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA" target="_blank" rel="external">确定有限状态自动机</a></li>
</ul>
<h2 id="Pushdown_Automaton__u4E0B_u63A8_u81EA_u52A8_u673A"><a href="#Pushdown_Automaton__u4E0B_u63A8_u81EA_u52A8_u673A" class="headerlink" title="Pushdown Automaton 下推自动机"></a>Pushdown Automaton 下推自动机</h2><p>下推自动机比有限状态自动机复杂：除了有限状态组成部分外，还包括一个长度不受限制的栈；下推自动机的状态迁移不但要参考有限状态部分，也要参照栈当前的状态；状态迁移不但包括有限状态的变迁，还包括一个栈的出栈或入栈过程。</p>
<p>具体的解释仍然是比较抽象，这里也没办法展开了，详情参考<a href="https://zh.wikipedia.org/wiki/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA" target="_blank" rel="external">这里</a></p>
<h2 id="Turing_Machines__u56FE_u7075_u673A"><a href="#Turing_Machines__u56FE_u7075_u673A" class="headerlink" title="Turing Machines 图灵机"></a>Turing Machines 图灵机</h2><p>接下来的定义部分为了避免翻译不准确带来的歧义，这里都使用英文原文。</p>
<ul>
<li>The basic model of a Turing machine has a finite control, an input tage that is divided into cells, and a tape head that scans one celll of the tape at a time</li>
<li>The tage has a left most cell but is infinite to the right</li>
<li>Each cell of the tape may hold exactly one of a finite number of tape symbols</li>
<li>Initially, the n leftmost cells, for some finite n &gt;= 0, hold the input, which is a string of symbols chosen from a subset of the tape symbols called the input symbols</li>
<li>The remaining infinity of cells each hold the blank, which is a special symbol that is not an input symbol</li>
</ul>
<p>如下图所示：</p>
<p><img src="/images/14564420943465.jpg" alt=""></p>
<p>具体的解释还是参考<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA" target="_blank" rel="external">维基</a></p>
<h2 id="NP"><a href="#NP" class="headerlink" title="NP"></a>NP</h2><p>最后是更加理论化的一个概念，非定常多项式（英语：non-deterministic polynomial，缩写NP）时间复杂性类，或称非确定性多项式时间复杂性类，包含了可以在多项式时间内，对一个判定性算法问题的实例，一个给定的解是否正确的算法问题。</p>
<p>具体请参考<a href="https://zh.wikipedia.org/wiki/NP_(%E8%A4%87%E9%9B%9C%E5%BA%A6" target="_blank" rel="external">维基</a>)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《模仿游戏》的大热让图灵为更多人所知，不过电影中更多说的是图灵破解密码，却对图灵的另一个伟大设想——图灵机所言甚少。图灵机可以看作是某种有限状态机，虽然这个名词听起来比较陌生，但也许这是计算机学科中最重要的概念之一。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 7 课 数据压缩]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-7/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-7/</id>
    <published>2016-02-24T16:48:25.000Z</published>
    <updated>2016-02-25T21:08:14.000Z</updated>
    <content type="html"><![CDATA[<p>这一部分主要介绍一下两种常见的压缩算法：霍夫曼编码和 LZW，因为我对这个领域研究不算太多，所以更多可能给出一些参考链接，和我对算法思想的理解。</p>
<a id="more"></a>
<hr>
<p>数据压缩是一门非常『应用』的技术，目的是为了提高信息的『密度』，用最小的容量存储最多有意义的数据。记得之前还看过类似『世界压缩大赛』的作品，十多 K 的程序就可以不重复弄出非常浮夸的过场动画。</p>
<p>既然是信息的『密度』，就需要有一个度量来衡量『信息』本身，这就是我们所说的『熵』了（霍夫曼编码就是熵的应用）。</p>
<p>总体来看，可以分为无损压缩和有损压缩，有损压缩适用与图片、声音、视频等领域，在许多字节顺序不允许出错的应用中，都只能使用无损压缩。</p>
<p>无损压缩的两个具体思路，一是通过字典进行映射，二是通过熵来进行『密度』的提升。这节课要说的 LZW 属于字典类压缩，霍夫曼编码属于熵压缩。</p>
<p>具体的细节可以参考：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/LZW" target="_blank" rel="external">LZW</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81" target="_blank" rel="external">霍夫曼编码</a></li>
</ul>
<p>这里不班门弄斧了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一部分主要介绍一下两种常见的压缩算法：霍夫曼编码和 LZW，因为我对这个领域研究不算太多，所以更多可能给出一些参考链接，和我对算法思想的理解。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 6 课 搜索]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-6/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-6/</id>
    <published>2016-02-24T16:46:54.000Z</published>
    <updated>2016-02-25T20:42:30.000Z</updated>
    <content type="html"><![CDATA[<p>排序和搜索可能是互联网中应用最广泛的算法，大到搜索引擎，小到帖子排序，都离不开算法的帮助。这一课我们会简要了解一下各个常见算法，具体实现还是参考给出的链接，这里主要提算法背后的思想。</p>
<a id="more"></a>
<hr>
<p>搜索其实是一个比较宽泛的概念，两个比较大的范畴是：</p>
<ul>
<li>在静态数据库中搜索，如找到某个已索引的网页或找到磁盘上的某个文件</li>
<li>评估一个动态的假设集合，如象棋中搜索下一步或语音识别</li>
</ul>
<p>这里我们主要讨论第一种情形。</p>
<h2 id="u987A_u5E8F_u67E5_u627E"><a href="#u987A_u5E8F_u67E5_u627E" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>这是最简单粗暴的搜索方式了，比方说从数组的第一个元素一直搜索到最后一个元素。</p>
<ul>
<li>Best case: O(1)</li>
<li>Worst case: O(N)</li>
<li>Average case: O(N)</li>
</ul>
<h2 id="u4E8C_u5206_u67E5_u627E"><a href="#u4E8C_u5206_u67E5_u627E" class="headerlink" title="二分查找"></a>二分查找</h2><p>当数据是完全有序的时候，就可以进行二分查找。实现简单，通常也『足够快』不过一定要小心处理 boundary cases，是一个典型的 divide-and-conquer 算法</p>
<p>注意完全正确的二分并不好写，一定要注意可能出错的地方，具体可以参加<a href="https://zh.wikipedia.org/wiki/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95" target="_blank" rel="external">这里</a></p>
<h2 id="u54C8_u5E0C"><a href="#u54C8_u5E0C" class="headerlink" title="哈希"></a>哈希</h2><p>前面提到的两个算法，最快的二分平均时间也要 O(logN)，有没有办法更快呢？</p>
<p>有！使用哈希，可以把时间复杂度降到 O(1)。</p>
<p>最重要的就是哈希函数的选择，以及如果哈希冲突的时候如何解决。一个比较常见的方式是，如果发生了冲突，那么在随机移动若干个位置，具体的值由另一个哈希函数决定。</p>
<p>其他一些常见的哈希：</p>
<ul>
<li>Double Hashing</li>
<li>O-A Hashing</li>
<li>Chained Hashing</li>
</ul>
<p>哈希与二叉树的对比：</p>
<ul>
<li>通常来说更倾向于哈希，因为更快</li>
<li>二叉树是纯动态的，不需要任何相关信息</li>
<li>二叉搜索树保证了 worst case，哈希函数可能会很糟糕</li>
<li>二叉搜索树支持更多操作，如排序</li>
</ul>
<p>另外一个变种是 Radix-Search，类似于与 Trie Tree，这里也不展开了</p>
<h2 id="Bubble_Sort__u5192_u6CE1_u6392_u5E8F"><a href="#Bubble_Sort__u5192_u6CE1_u6392_u5E8F" class="headerlink" title="Bubble Sort 冒泡排序"></a>Bubble Sort 冒泡排序</h2><p>冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p>
<p>步骤：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(arry)</span>:</span></span><br><span class="line">    n = len(arry)                   <span class="comment">#获得数组的长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n-i):</span><br><span class="line">            <span class="keyword">if</span>  arry[j-<span class="number">1</span>] &gt; arry[j] :       <span class="comment">#如果前者比后者大</span></span><br><span class="line">                arry[j-<span class="number">1</span>],arry[j] = arry[j],arry[j-<span class="number">1</span>]      <span class="comment">#则交换两者</span></span><br><span class="line">    <span class="keyword">return</span> arry</span><br></pre></td></tr></table></figure>
<p>针对上述代码还有两种优化方案。</p>
<p>优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。</span></span><br><span class="line"><span class="comment">#用一个标记记录这个状态即可。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort2</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        flag = <span class="number">1</span>                    <span class="comment">#标记</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n-i):</span><br><span class="line">            <span class="keyword">if</span>  ary[j-<span class="number">1</span>] &gt; ary[j] :</span><br><span class="line">                ary[j-<span class="number">1</span>],ary[j] = ary[j],ary[j-<span class="number">1</span>]</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> flag :                   <span class="comment">#全排好序了，直接跳出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<p>优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序了。</span></span><br><span class="line"><span class="comment"># 因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort3</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    k = n                           <span class="comment">#k为循环的范围，初始值n</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,k):        <span class="comment">#只遍历到最后交换的位置即可</span></span><br><span class="line">            <span class="keyword">if</span>  ary[j-<span class="number">1</span>] &gt; ary[j] :</span><br><span class="line">                ary[j-<span class="number">1</span>],ary[j] = ary[j],ary[j-<span class="number">1</span>]</span><br><span class="line">                k = j               <span class="comment">#记录最后交换的位置</span></span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> flag :</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="Selection_Sort__u9009_u62E9_u6392_u5E8F"><a href="#Selection_Sort__u9009_u62E9_u6392_u5E8F" class="headerlink" title="Selection Sort 选择排序"></a>Selection Sort 选择排序</h2><p>选择排序无疑是最简单直观的排序。它的工作原理如下。</p>
<p>步骤：</p>
<ol>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>以此类推，直到所有元素均排序完毕。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">        min = i                             <span class="comment">#最小元素下标标记</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> ary[j] &lt; ary[min] :</span><br><span class="line">                min = j                     <span class="comment">#找到最小值的下标</span></span><br><span class="line">        ary[min],ary[i] = ary[i],ary[min]   <span class="comment">#交换两者</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="Insertion_Sort__u63D2_u5165_u6392_u5E8F"><a href="#Insertion_Sort__u63D2_u5165_u6392_u5E8F" class="headerlink" title="Insertion Sort 插入排序"></a>Insertion Sort 插入排序</h2><p>插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>步骤：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        <span class="keyword">if</span> ary[i] &lt; ary[i-<span class="number">1</span>]:</span><br><span class="line">            temp = ary[i]</span><br><span class="line">            index = i           <span class="comment">#待插入的下标</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):  <span class="comment">#从i-1 循环到 0 (包括0)</span></span><br><span class="line">                <span class="keyword">if</span> ary[j] &gt; temp :</span><br><span class="line">                    ary[j+<span class="number">1</span>] = ary[j]</span><br><span class="line">                    index = j   <span class="comment">#记录待插入下标</span></span><br><span class="line">                <span class="keyword">else</span> :</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            ary[index] = temp</span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="Shell_Sort__u5E0C_u5C14_u6392_u5E8F"><a href="#Shell_Sort__u5E0C_u5C14_u6392_u5E8F" class="headerlink" title="Shell Sort 希尔排序"></a>Shell Sort 希尔排序</h2><p>希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。</p>
<p>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。</p>
<p>例如，假设有这样一组数<code>[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]</code>，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<pre><code>13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
</code></pre><p>然后我们对每列进行排序：</p>
<pre><code>10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45
</code></pre><p>将上述四行数字，依序接在一起时我们得到：<code>[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]</code>。这时10已经移至正确位置了，然后再以3为步长进行排序：</p>
<pre><code>10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
</code></pre><p>排序之后变为：</p>
<pre><code>10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
</code></pre><p>最后以1步长进行排序（此时就是简单的插入排序了）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    gap = round(n/<span class="number">2</span>)       <span class="comment">#初始步长 , 用round四舍五入取整</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap,n):        <span class="comment">#每一列进行插入排序 , 从gap 到 n-1</span></span><br><span class="line">            temp = ary[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> ( j &gt;= gap <span class="keyword">and</span> ary[j-gap] &gt; temp ):    <span class="comment">#插入排序</span></span><br><span class="line">                ary[j] = ary[j-gap]</span><br><span class="line">                j = j - gap</span><br><span class="line">            ary[j] = temp</span><br><span class="line">        gap = round(gap/<span class="number">2</span>)                     <span class="comment">#重新设置步长</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<p>上面源码的步长的选择是从n/2开始，每次再减半，直至为0。步长的选择直接决定了希尔排序的复杂度</p>
<h2 id="Merge_Sort__u5F52_u5E76_u6392_u5E8F"><a href="#Merge_Sort__u5F52_u5E76_u6392_u5E8F" class="headerlink" title="Merge Sort 归并排序"></a>Merge Sort 归并排序</h2><p>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p>
<p>先考虑合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p>
<p>再考虑递归分解，基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(ary) &lt;= <span class="number">1</span> : <span class="keyword">return</span> ary</span><br><span class="line">    num = int(len(ary)/<span class="number">2</span>)       <span class="comment">#二分分解</span></span><br><span class="line">    left = merge_sort(ary[:num])</span><br><span class="line">    right = merge_sort(ary[num:])</span><br><span class="line">    <span class="keyword">return</span> merge(left,right)    <span class="comment">#合并数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left,right)</span>:</span></span><br><span class="line">    <span class="string">'''合并操作，</span><br><span class="line">    将两个有序数组left[]和right[]合并成一个大的有序数组'''</span></span><br><span class="line">    l,r = <span class="number">0</span>,<span class="number">0</span>           <span class="comment">#left与right数组的下标指针</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> l &lt; len(left) <span class="keyword">and</span> r &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[l] &lt; right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">    result += left[l:]</span><br><span class="line">    result += right[r:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="Quick_Sort__u5FEB_u901F_u6392_u5E8F"><a href="#Quick_Sort__u5FEB_u901F_u6392_u5E8F" class="headerlink" title="Quick Sort 快速排序"></a>Quick Sort 快速排序</h2><p>快速排序通常明显比同为Ο(n log n)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。</p>
<p>步骤：</p>
<ol>
<li>从数列中挑出一个元素作为基准数。</li>
<li>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。</li>
<li>再对左右区间递归执行第二步，直至各区间只有一个数。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> qsort(ary,<span class="number">0</span>,len(ary)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(ary,left,right)</span>:</span></span><br><span class="line">    <span class="comment">#快排函数，ary为待排序数组，left为待排序的左边界，right为右边界</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right : <span class="keyword">return</span> ary</span><br><span class="line">    key = ary[left]     <span class="comment">#取最左边的为基准数</span></span><br><span class="line">    lp = left           <span class="comment">#左指针</span></span><br><span class="line">    rp = right          <span class="comment">#右指针</span></span><br><span class="line">    <span class="keyword">while</span> lp &lt; rp :</span><br><span class="line">        <span class="keyword">while</span> ary[rp] &gt;= key <span class="keyword">and</span> lp &lt; rp :</span><br><span class="line">            rp -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> ary[lp] &lt;= key <span class="keyword">and</span> lp &lt; rp :</span><br><span class="line">            lp += <span class="number">1</span></span><br><span class="line">        ary[lp],ary[rp] = ary[rp],ary[lp]</span><br><span class="line">    ary[left],ary[lp] = ary[lp],ary[left]</span><br><span class="line">    qsort(ary,left,lp-<span class="number">1</span>)</span><br><span class="line">    qsort(ary,rp+<span class="number">1</span>,right)</span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="Heap_Sort__u5806_u6392_u5E8F"><a href="#Heap_Sort__u5806_u6392_u5E8F" class="headerlink" title="Heap Sort 堆排序"></a>Heap Sort 堆排序</h2><p>堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 。</p>
<p><strong>二叉堆具有以下性质：</strong></p>
<ol>
<li>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</li>
<li>每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</li>
</ol>
<p><strong>步骤：</strong></p>
<ol>
<li>构造最大堆（<code>Build_Max_Heap</code>）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</li>
<li>堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0…n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0…n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</li>
<li>最大堆调整（<code>Max_Heapify</code>）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(ary)</span> :</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    first = int(n/<span class="number">2</span>-<span class="number">1</span>)       <span class="comment">#最后一个非叶子节点</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(first,-<span class="number">1</span>,-<span class="number">1</span>) :     <span class="comment">#构造大根堆</span></span><br><span class="line">        max_heapify(ary,start,n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> range(n-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):           <span class="comment">#堆排，将大根堆转换成有序数组</span></span><br><span class="line">        ary[end],ary[<span class="number">0</span>] = ary[<span class="number">0</span>],ary[end]</span><br><span class="line">        max_heapify(ary,<span class="number">0</span>,end-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ary</span><br><span class="line"></span><br><span class="line"><span class="comment">#最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点</span></span><br><span class="line"><span class="comment">#start为当前需要调整最大堆的位置，end为调整边界</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_heapify</span><span class="params">(ary,start,end)</span>:</span></span><br><span class="line">    root = start</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span> :</span><br><span class="line">        child = root*<span class="number">2</span> +<span class="number">1</span>               <span class="comment">#调整节点的子节点</span></span><br><span class="line">        <span class="keyword">if</span> child &gt; end : <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> child+<span class="number">1</span> &lt;= end <span class="keyword">and</span> ary[child] &lt; ary[child+<span class="number">1</span>] :</span><br><span class="line">            child = child+<span class="number">1</span>             <span class="comment">#取较大的子节点</span></span><br><span class="line">        <span class="keyword">if</span> ary[root] &lt; ary[child] :     <span class="comment">#较大的子节点成为父节点</span></span><br><span class="line">            ary[root],ary[child] = ary[child],ary[root]     <span class="comment">#交换</span></span><br><span class="line">            root = child</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="u6307_u6807_u5BF9_u6BD4"><a href="#u6307_u6807_u5BF9_u6BD4" class="headerlink" title="指标对比"></a>指标对比</h2><table>
<thead>
<tr>
<th style="text-align:center">排序方法</th>
<th style="text-align:center">平均情况</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">辅助空间</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">O(nlogn)~O(n2)</td>
<td style="text-align:center">O(n1.3)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(logn)~O(n)</td>
<td style="text-align:center">不稳定</td>
</tr>
</tbody>
</table>
<h2 id="Bucket_Sort__u6876_u6392_u5E8F"><a href="#Bucket_Sort__u6876_u6392_u5E8F" class="headerlink" title="Bucket Sort 桶排序"></a>Bucket Sort 桶排序</h2><p>桶排序和归并排序有那么点点类似，也使用了归并的思想。大致步骤如下：</p>
<ol>
<li>设置一个定量的数组当作空桶。</li>
<li>Divide - 从待排序数组中取出元素，将元素按照一定的规则塞进对应的桶子去。</li>
<li>对每个非空桶进行排序，通常可在塞元素入桶时进行插入排序。</li>
<li>Conquer - 从非空桶把元素再放回原来的数组中。”</li>
</ol>
<h2 id="Counting_Sort__u8BA1_u6570_u6392_u5E8F"><a href="#Counting_Sort__u8BA1_u6570_u6392_u5E8F" class="headerlink" title="Counting Sort 计数排序"></a>Counting Sort 计数排序</h2><p>计数排序，顾名思义，就是对待排序数组按元素进行计数。使用前提是需要先知道待排序数组的元素范围，将这些一定范围的元素置于新数组中，新数组的大小为待排序数组中最大元素与最小元素的差值。</p>
<p>维基上总结的四个步骤如下：</p>
<ol>
<li>定新数组大小——找出待排序的数组中最大和最小的元素</li>
<li>统计次数——统计数组中每个值为i的元素出现的次数，存入新数组C的第i项</li>
<li>对统计次数逐个累加——对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>
<li>反向填充目标数组——将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>
<li>其中反向填充主要是为了避免重复元素落入新数组的同一索引处。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>排序和搜索可能是互联网中应用最广泛的算法，大到搜索引擎，小到帖子排序，都离不开算法的帮助。这一课我们会简要了解一下各个常见算法，具体实现还是参考给出的链接，这里主要提算法背后的思想。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 5 课 图]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-5/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-5/</id>
    <published>2016-02-24T16:45:48.000Z</published>
    <updated>2016-02-25T19:09:05.000Z</updated>
    <content type="html"><![CDATA[<p>前面我们介绍了几种不同类型的树，这一课我们在原来的基础上延伸一下，就能得到图的概念。相对于树，因为不同节点之间的关系更多，无论是表达形式或者是算法细节都会复杂不少，就更需要仔细揣摩。不过究其根本，实际上可以看做是不同矩阵间的信息检索，一定要注意细节。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u672C_u4ECB_u7ECD"><a href="#u57FA_u672C_u4ECB_u7ECD" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>图的话，从类别来看可以分为有向图与无向图，而最关键的操作，图的遍历，有深度优先（递归或者栈）和广度优先（队列）。</p>
<p>图由两类元素组成，一是节点(vertex)，二是边(edge)，下面是一个无向图的例子：</p>
<p><img src="/images/14564071906087.jpg" alt="无向图，边和节点都有对应标记"></p>
<p>无向图和有向图都是一个有限的节点集合加上一个有限的边集合，每条边连接两个节点。不同的地方在于，无向图中连接的顺序是无关紧要的，而有向图中连接的顺序是重要的，是从 source 到 target 的方向，下面是一个有向图的例子：</p>
<p><img src="/images/14564073738319.jpg" alt="有向图的例子，注意箭头的方向"></p>
<p>其他一些需要知道的术语：</p>
<ul>
<li>Loops: edges that connect a vertex to itself</li>
<li>Paths: sequences of vertices p0, p1, …, pm such that each adjacent pair of vertices are connected by an edge</li>
<li>Multiple Edges: two nodes may be connected by &gt;1 edge</li>
<li>Simple Graphs: have no loops and no multiple edges</li>
</ul>
<h2 id="u56FE_u7684_u8868_u793A"><a href="#u56FE_u7684_u8868_u793A" class="headerlink" title="图的表示"></a>图的表示</h2><p>这里介绍三种常见的方式，其实还有其他几种自定义的表示法，这里不拓展了</p>
<h3 id="u90BB_u63A5_u77E9_u9635_Adjacency_Matrix"><a href="#u90BB_u63A5_u77E9_u9635_Adjacency_Matrix" class="headerlink" title="邻接矩阵 Adjacency Matrix"></a>邻接矩阵 Adjacency Matrix</h3><p>用一个二维矩阵来表示点和点之间的连接关系，如果一个图有 N 个节点，那么这个矩阵就是 NxN 的，对于节点 I 和节点 J，如果有一条边连接他们，那么第 I 行第 J 列的值为 true，否则是 false（如果是无向图的话，第 J 行第 I 列的值需要保持一致，也就是说以对角线为轴对称），下面是一个有向图的例子：</p>
<p><img src="/images/14564128326067.jpg" alt="有向图的邻接矩阵"></p>
<h3 id="u8FB9_u5217_u8868_Edge_Lists"><a href="#u8FB9_u5217_u8868_Edge_Lists" class="headerlink" title="边列表 Edge Lists"></a>边列表 Edge Lists</h3><p>另外一种表达方式是每个节点有一个链表，表示它所连接的其他节点，如下图所示：</p>
<p><img src="/images/14564132564620.jpg" alt=""></p>
<h3 id="u8FB9_u96C6_Edge_Sets"><a href="#u8FB9_u96C6_Edge_Sets" class="headerlink" title="边集 Edge Sets"></a>边集 Edge Sets</h3><p>Edge Lists 中我们主要存储的是节点的信息，而在 Edge sets 中我们保存的是边的信息，包含每条边的 source 和 target。</p>
<h3 id="u6027_u80FD_u5206_u6790"><a href="#u6027_u80FD_u5206_u6790" class="headerlink" title="性能分析"></a>性能分析</h3><p>这里主要看一下最坏情况</p>
<ul>
<li>添加或删除边：<ul>
<li>adjacency matrix: O(1)</li>
<li>edge list: O(N)</li>
<li>edge set: O(logN) - 使用 B-Tree</li>
</ul>
</li>
<li>检查某条边是否存在：<ul>
<li>adjacency matrix: O(1)</li>
<li>edge list: O(N)</li>
<li>edge set: O(logN) - 使用 B-Tree 或 红黑树</li>
</ul>
</li>
<li>遍历某个节点的边：<ul>
<li>adjacency matrix: O(N)</li>
<li>edge list: O(E) - 其中 E 是边的数目</li>
<li>edge set: O(E) - 使用 B-Tree 或 红黑树</li>
</ul>
</li>
</ul>
<h2 id="u56FE_u7684_u5B9E_u73B0"><a href="#u56FE_u7684_u5B9E_u73B0" class="headerlink" title="图的实现"></a>图的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] edges;</span><br><span class="line">    <span class="keyword">private</span> Object[] labels;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span> <span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        labels = <span class="keyword">new</span> Object[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span> <span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        edges[s][t] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getLabel</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> labels[v];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[s][t];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] neighbors(<span class="keyword">int</span> v) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">int</span>[] answer;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; labels.length; i++&#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v][i]) count++;</span><br><span class="line">        &#125;    </span><br><span class="line">        answer = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; labels.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v][i]) answer[count++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        edges[s][t] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLabel</span><span class="params">(<span class="keyword">int</span> v, Object n)</span></span>&#123;</span><br><span class="line">        labels[v] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> labels.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u56FE_u7684_u904D_u5386"><a href="#u56FE_u7684_u904D_u5386" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>这个是图问题中比较常见的，一般来说，是从一个特定的节点开始，找到所有可能到达的节点。图和树的区别在于，我们可能会遇到环，所以就需要一种方法来处理这种情况。</p>
<p>我们可以用一个另外的数组来记录一个节点是否被访问过。</p>
<ul>
<li>深度搜索 - Stack</li>
<li>广度搜索 - Queue</li>
</ul>
<p>这一部分比较基础，大家可以自己找一个例子来边输出边测试，这里不再赘述。</p>
<h2 id="u6700_u77ED_u8DEF_u5F84"><a href="#u6700_u77ED_u8DEF_u5F84" class="headerlink" title="最短路径"></a>最短路径</h2><p>最短路径一般应用在有权有向图，如下所示：</p>
<p><img src="/images/14564267263106.jpg" alt=""></p>
<p>我们要找的是路径最短的，但不一定是经过的边最少的，所以 BFS 在这里就不适用了。</p>
<p>我们可以使用 <a href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95" target="_blank" rel="external">Dijkstra’s 算法</a>来处理，wiki 中有比较详细的说明，这里不再赘述。</p>
<p>对于比较稀疏的图，我们用堆来表示图会更好；反之，用邻接矩阵比较好。</p>
<p>另外一个利用动态规划的解法是 <a href="https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95" target="_blank" rel="external">Floyd Warshall 算法</a></p>
<p>索引中的各类算法也可以对应了解一下：</p>
<p><img src="/images/14564271316392.jpg" alt=""></p>
<h2 id="u6700_u5C0F_u751F_u6210_u6811_Minimum_Spanning_Tree__28MST_29"><a href="#u6700_u5C0F_u751F_u6210_u6811_Minimum_Spanning_Tree__28MST_29" class="headerlink" title="最小生成树 Minimum Spanning Tree (MST)"></a>最小生成树 Minimum Spanning Tree (MST)</h2><p>我们一般用 <a href="https://zh.wikipedia.org/wiki/%E6%99%AE%E6%9E%97%E5%A7%86%E7%AE%97%E6%B3%95" target="_blank" rel="external">Prim’s 算法</a>，来寻找最小生成树，是一个贪心算法</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面我们介绍了几种不同类型的树，这一课我们在原来的基础上延伸一下，就能得到图的概念。相对于树，因为不同节点之间的关系更多，无论是表达形式或者是算法细节都会复杂不少，就更需要仔细揣摩。不过究其根本，实际上可以看做是不同矩阵间的信息检索，一定要注意细节。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 4 课 树]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-4/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-4/</id>
    <published>2016-02-24T16:44:36.000Z</published>
    <updated>2016-02-25T13:11:50.000Z</updated>
    <content type="html"><![CDATA[<p>从这一讲开始，慢慢就有点难度了，树的每个节点虽然看起来比较简单，但是不同结点以不同规则进行组合就使得难度指数级增长，后面的红黑树因为涉及到结点的调整，一定要按照前面提到的 5 个步骤来过一次，才能清晰理解。</p>
<a id="more"></a>
<hr>
<h2 id="u6811_u7684_u5E94_u7528"><a href="#u6811_u7684_u5E94_u7528" class="headerlink" title="树的应用"></a>树的应用</h2><p>这次我们换个方式，先从不同的应用角度来了解一下树的用途。</p>
<p><strong>表示数学表达式</strong></p>
<p>我们可以用下面的树来表示 <code>b + a * b</code></p>
<p><img src="/images/14563638168396.jpg" alt=""></p>
<p><strong>XML Document Object Model</strong></p>
<p>XML 实际上也是一个树结构：</p>
<p><img src="/images/14563638734277.jpg" alt=""></p>
<p><strong>表示迁移路径的概率</strong></p>
<p>下图可以认为，从 S 出发，有 p 的概率到 Su，有 1-p 的概率到 Sd</p>
<p><img src="/images/14563639875028.jpg" alt=""></p>
<h2 id="u6811_u7684_u5B9A_u4E49"><a href="#u6811_u7684_u5B9A_u4E49" class="headerlink" title="树的定义"></a>树的定义</h2><p>下面介绍几种不同类型的树</p>
<h3 id="Free_tree"><a href="#Free_tree" class="headerlink" title="Free tree"></a>Free tree</h3><p>指的是相互连接的无环无向图</p>
<p><img src="/images/14563645014537.jpg" alt="Free Tree"></p>
<p>假设 G = (V, E) 是一个无向图，那么下面的语句是等价的：</p>
<ol>
<li>G 是一个 free tree</li>
<li>G 中的任意两个节点间都有唯一的一条路径</li>
<li>G 是连通的的，但是如果去掉任何一条边，G 就不连通了</li>
<li>G 是连通的，并且 $|E|=|V|-1$</li>
<li>G 是无环的，并且 $|E|=|V|-1$</li>
<li>G 是无环的，但是加入任何一条新的边，就会变成有环的</li>
</ol>
<h3 id="Forest__u68EE_u6797"><a href="#Forest__u68EE_u6797" class="headerlink" title="Forest 森林"></a>Forest 森林</h3><p>同样是无环无向图，但不是所有的节点都是连通的</p>
<p><img src="/images/14563646007700.jpg" alt="Forest"></p>
<p>下图中包含一个环，所以不能算是森林：</p>
<p><img src="/images/14563646456272.jpg" alt="包含环的例子"></p>
<h3 id="Rooted_Tree"><a href="#Rooted_Tree" class="headerlink" title="Rooted Tree"></a>Rooted Tree</h3><p>有根的树也是一棵 free tree，但是其中一个节点和其他不同，称为根，下图中的 7 号节点就是根：</p>
<p><img src="/images/14563698058000.jpg" alt=""></p>
<p>有根树中有一些概念需要理解清楚，这里只列举出来不再赘述：ancestor, descendant, proper ancestor, proper descendant, parent, child, siblings, external node(leaf), internal node。</p>
<p>一个节点的孩子数量称之为节点的度(degree)，从根到某节点的要经过的边的数量就是该节点的深度，最大的深度称为树的高度，如下图所示：</p>
<p><img src="/images/14563702807914.jpg" alt=""></p>
<p>根树有几个特例，也非常常用，需要理解清楚，这里列举如下：</p>
<ul>
<li>Binary tree</li>
<li>Full binary tree: each node is either a leaf or has degree exactly 2</li>
<li>Complete k-ary tree: a k-ary tree in which all leaves have the same depth and all internal nodes have degree k</li>
<li>Binary search tree: 一个节点的左右子节点和节点本身满足一定的大小关系</li>
</ul>
<p><img src="/images/14563707343954.jpg" alt="Complete Binary Tree"></p>
<h3 id="Catalan_Numbers"><a href="#Catalan_Numbers" class="headerlink" title="Catalan Numbers"></a>Catalan Numbers</h3><p>先来看公式</p>
<p><img src="/images/14563710814940.jpg" alt=""></p>
<p>然后我们就发现，Catalan 数对应的是有 n 节点的二叉树的数量（根据左右子树的位置可以有不同的结构）</p>
<h2 id="u6811_u7684_u904D_u5386"><a href="#u6811_u7684_u904D_u5386" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>这一部分也是非常重要的内容，基本来说各类考点都在这里，不但需要对概念的清晰理解，还需要利用递归来解决问题（虽然不用递归也可以），主要有下面这四类：</p>
<ol>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层次遍历</li>
</ol>
<p>具体的概念可以在 wiki 上查看，注意一下层次遍历可能需要一些特殊处理即可。</p>
<h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h2><p>如果我们想要表示一个 complete binary tree 的话，其实可以用数组来完成，这种结构其实也可以看成是一个堆。堆的话需要理解的不算特别多，注意下最大堆最小堆，以及对应的操作即可。另外前面提到的优先队列也可以认为是堆，不过这个不展开了。</p>
<p>这一部分我们着重来看看 B-Tree，这是一类搜索树，在给定 n 个节点的条件下，尽可能减少树的高度，相对于原来的二叉搜索树，B-Tree 做了两个调整：</p>
<ol>
<li>节点可以有多于两个子节点</li>
<li>节点中可以保存多个元素</li>
</ol>
<p>因为需要保存不定数量的元素，所以一般用 set 来实现（这种情况下不允许有重复的元素，重复的情况这里暂时不考虑）。稍微提一下，许多数据库都是用 B-Tree 实现的。</p>
<p>所有的 B-Tree 都有一个非常重要的常数 MINIMUM，决定了每个节点中需要保存多少元素，具体的规则如下：</p>
<ol>
<li>根节点有 0 或 1 个元素，其他的节点至少需要保存 MINIMUM 个元素</li>
<li>一个节点中最多可以保存 <code>2*MINIMUM</code> 个元素</li>
<li>一个节点中保存的元素是有序的，从最小到最大</li>
<li>假设一个非叶节点中存有 N 个元素，那么它会有 N+1 个子树</li>
<li>对于任何一个非叶节点：<ul>
<li>第 I 个元素比其第 I 个子树的所有元素都要大</li>
<li>第 I 个元素比其第 I+1 个子树的所有元素都要小</li>
<li><img src="/images/14563744343036.jpg" alt=""></li>
</ul>
</li>
<li>每个叶节点都有相同的深度，也就是说 B-Tree 总是平衡的</li>
</ol>
<p>下图是一个例子，其中 MINIMUM = 1，注意，根节点的每个子节点也是一颗 B-Tree</p>
<p><img src="/images/14563745325794.jpg" alt="B-Tree 的例子"></p>
<p>对应的数据结构是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntBalancedSet</span></span>&#123;</span><br><span class="line">    <span class="comment">// constants</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MINIMUM = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MAXIMUM = <span class="number">2</span> * MINIMUM;</span><br><span class="line">    <span class="comment">// info about root node</span></span><br><span class="line">    <span class="keyword">int</span> dataCount;</span><br><span class="line">    <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[MAXIMUM + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> childCount;</span><br><span class="line">    <span class="comment">// info about children</span></span><br><span class="line">    IntBalancedSet[] subset = <span class="keyword">new</span> IntBalancedSet[MAXIMUM+<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<p><img src="/images/14563980237017.jpg" alt=""></p>
<p>利用 B-Tree 进行搜索的方法如下：</p>
<ul>
<li>找到这样一个 set，满足 <code>data[I] &gt;= target</code> 且 I 尽可能小，如果找不到，则 <code>I = dataCount</code></li>
<li>如果 <code>data[I] == target</code> 返回 true，如果不等于且没有子节点，返回 false</li>
<li>如果不等于但是有子节点，则返回 <code>subset[I].contains(target)</code></li>
</ul>
<p><img src="/images/14563990361014.jpg" alt="利用 B-Tree 进行搜索的例子"></p>
<p>一般来说，结构比较复杂的数据结构，进行修改都会比较麻烦（因为结构中内在的约束太多，变动的话需要满足所有约束），在 B-Tree 中添加和删除节点是比较复杂的操作。这里讲详细一些，用一个具体的例子来做说明（MINIMUM=1）</p>
<p>删除操作的伪代码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">Delete</span>(<span class="keyword">T</span>, X, <span class="keyword">success</span>)</span><br><span class="line">    // 从树 <span class="keyword">T</span> 中删除 <span class="keyword">key</span> 为 X 的节点，如果没有对应节点，则操作失败</span><br><span class="line">    // 操作结果可以从 <span class="keyword">success</span> 变量中获悉</span><br><span class="line">    </span><br><span class="line">    // 先找到 <span class="keyword">key</span> 为 X 的节点的位置</span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">I</span> <span class="keyword">is</span> <span class="keyword">present</span> <span class="keyword">THEN</span></span><br><span class="line">        swap item <span class="keyword">I</span> <span class="keyword">into</span> leaf <span class="keyword">L</span> which contains the inorder successor <span class="keyword">of</span> <span class="keyword">I</span></span><br><span class="line">        // 从 leaf <span class="keyword">L</span> 开始删除操作</span><br><span class="line">        <span class="keyword">IF</span> <span class="keyword">L</span> has <span class="keyword">no</span> items <span class="keyword">THEN</span> Fix(<span class="keyword">L</span>)</span><br><span class="line">        <span class="keyword">success</span> := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        <span class="keyword">success</span> := <span class="literal">false</span></span></span><br></pre></td></tr></table></figure>
<p>然后是其中的 Fix 函数，用来处理没有子节点的节点，保证符合 B-Tree 的基本性质</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Fix(N)</span><br><span class="line">    // N 是一个没有子节点的节点</span><br><span class="line">    // 如果 N 是一个 internal node，那么它有一个子节点</span><br><span class="line">    </span><br><span class="line">    Let P be the parent of N. If N is the root, <span class="operator"><span class="keyword">delete</span> it <span class="keyword">and</span> <span class="keyword">return</span>.</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">some</span> sibling <span class="keyword">of</span> <span class="keyword">N</span> has two items <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">distribute</span> items among <span class="keyword">N</span>, the sibling, <span class="keyword">and</span> <span class="keyword">P</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">IF</span> <span class="keyword">N</span> <span class="keyword">is</span> internal <span class="keyword">THEN</span></span><br><span class="line">            <span class="keyword">move</span> the appropriate <span class="keyword">child</span> <span class="keyword">from</span> the sibling <span class="keyword">to</span> <span class="keyword">N</span></span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        // 如果其兄弟没有两个子节点，就必须要进行融合</span><br><span class="line">        <span class="keyword">Choose</span> an adjancent sibling S <span class="keyword">of</span> <span class="keyword">N</span></span><br><span class="line">        </span><br><span class="line">        Bring the appropriate item down <span class="keyword">from</span> <span class="keyword">P</span> <span class="keyword">into</span> S</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">IF</span> <span class="keyword">N</span> <span class="keyword">is</span> internal <span class="keyword">THEN</span></span><br><span class="line">            <span class="keyword">Move</span> <span class="keyword">N</span><span class="string">'s child to S</span><br><span class="line">        </span><br><span class="line">        Delete node N</span><br><span class="line">        </span><br><span class="line">        IF P is now without an item THEN Fix(P)</span></span></span><br></pre></td></tr></table></figure>
<p>然后我们看看插入操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">Insert</span>(<span class="keyword">T</span>, newitem)</span><br><span class="line">    // 把 newitem 插入到树 <span class="keyword">T</span> 中</span><br><span class="line">    Let X be the <span class="keyword">search</span> <span class="keyword">key</span> <span class="keyword">of</span> <span class="keyword">new</span> item</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">Locate</span> the leaf <span class="keyword">L</span> <span class="keyword">in</span> which X belongs</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">Add</span> newitem <span class="keyword">to</span> <span class="keyword">L</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">L</span> <span class="keyword">now</span> has three items <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">Split</span>(<span class="keyword">L</span>)</span></span><br></pre></td></tr></table></figure>
<p>继续来看看这里的 Split 函数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Split(N)</span><br><span class="line">    // 分割那些有 3 个子节点的节点。注意如果 N 是 internal 的，它可以有 4 个孩子</span><br><span class="line">    Let P be the parent of N</span><br><span class="line">        // 如果 N 是根，那么创建一个新节点 P</span><br><span class="line">        </span><br><span class="line">    <span class="operator"><span class="keyword">Replace</span> node <span class="keyword">N</span> <span class="keyword">by</span> two nodes, N1 <span class="keyword">and</span> N2</span><br><span class="line">    </span><br><span class="line">    Give N1 the item <span class="keyword">in</span> <span class="keyword">N</span> <span class="keyword">with</span> the smallest <span class="keyword">search</span> <span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line">    Give N2 the item <span class="keyword">in</span> <span class="keyword">N</span> <span class="keyword">with</span> the largest <span class="keyword">search</span> <span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">N</span> <span class="keyword">is</span> an iternal node <span class="keyword">THEN</span></span><br><span class="line">        N1 becomes the <span class="keyword">parent</span> <span class="keyword">of</span> <span class="keyword">N</span><span class="string">'s two leftmost children</span><br><span class="line">        N2 becomes the parent of N'</span>s two rightmost children</span><br><span class="line">    </span><br><span class="line">    Send up <span class="keyword">to</span> <span class="keyword">P</span> the item <span class="keyword">in</span> <span class="keyword">N</span> <span class="keyword">with</span> the middle <span class="keyword">search</span> <span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">P</span> <span class="keyword">now</span> has <span class="number">3</span> items <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">Split</span>(<span class="keyword">P</span>)</span></span><br></pre></td></tr></table></figure>
<p>我们给定如下一颗 B-Tree</p>
<p><img src="/images/14564007797015.jpg" alt=""></p>
<p>插入 39 之后（插入总是在叶节点）为</p>
<p><img src="/images/14564008049100.jpg" alt="插入 39 之后"></p>
<p>再插入 38，会发现有一个节点有多于 2 个子节点，需要 split</p>
<p><img src="/images/14564008689598.jpg" alt="插入 38，split 之前"></p>
<p>可以看到我们通过 split 操作把 39 提上去了（注意对照前面的 split 函数的伪代码来进行操作和理解）：</p>
<p><img src="/images/14564009041532.jpg" alt="插入 38，split 之后"></p>
<p>我们再插入 37 与 36，这会导致树高改变，需要进行更多操作，过程如下：</p>
<p><img src="/images/14564011447526.jpg" alt="插入 37 与 36"></p>
<p>插入之后我们发现又出现了非法的节点，依照 split 规则更新之后，上层的节点再次非法，这里属于有四个子节点的情况，左右分开，把中间的 37 移上一层，就成为最后一个形态。</p>
<p>我们再多插入一些，比如 34，35，36，整个过程如下：</p>
<p><img src="/images/14564014630573.jpg" alt=""></p>
<p>最后就得到</p>
<p><img src="/images/14564015026747.jpg" alt=""></p>
<p>注意，因为向下传播的关系，高度是从顶层开始增长的。</p>
<p>然后我们来看看删除操作，还是用刚才的例子，给定：</p>
<p><img src="/images/14564016695179.jpg" alt=""></p>
<p>这次我们删除 50，因为是根节点，所以需要找一个节点放到原来根的位置，并且需要把 70 下移以满足条件</p>
<p><img src="/images/14564016869839.jpg" alt="删除 50"></p>
<p>我们再删除 100 试试看：</p>
<p><img src="/images/14564018498766.jpg" alt=""></p>
<p>同样对照前面的 Fix 函数进行操作即可。然后我们再删除 60，这里需要涉及的变动就会比较多，如下：</p>
<p><img src="/images/14564020922018.jpg" alt=""></p>
<p>然后我们再删除 70 看看，就会变成这样：</p>
<p><img src="/images/14564021367330.jpg" alt="删除 70"></p>
<p>最后再删除 80，又会进行一次融合</p>
<p><img src="/images/14564021619408.jpg" alt="删除 80"></p>
<p>删除操作总是从 leaf 开始的，把要删除的节点和其 inorder successor 换位置。具体的操作如果还不明白，可以找一些视频来看看，这里不赘述了。</p>
<h2 id="u7EA2_u9ED1_u6811_Red_Black_Tree"><a href="#u7EA2_u9ED1_u6811_Red_Black_Tree" class="headerlink" title="红黑树 Red Black Tree"></a>红黑树 Red Black Tree</h2><p>这里只给出基本性质的说明，具体的细节可以查看<a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="external">这里</a></p>
<p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ol>
<p><img src="/images/14564058100039.jpg" alt="红黑树的例子"></p>
<p>这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。</p>
<p>还是那句话对于约束较多的数据结构，进行插入和删除都是比较复杂的操作，最好通过例子掌握整个过程。</p>
<p>最后提一下复杂度，因为树的分叉设计，所以基本来说复杂度都是 log 的，但是需要注意，在最坏情况下，复杂度很可能是 O(n)，</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从这一讲开始，慢慢就有点难度了，树的每个节点虽然看起来比较简单，但是不同结点以不同规则进行组合就使得难度指数级增长，后面的红黑树因为涉及到结点的调整，一定要按照前面提到的 5 个步骤来过一次，才能清晰理解。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 3 课 链表、栈和队列]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-3/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-3/</id>
    <published>2016-02-24T15:58:50.000Z</published>
    <updated>2016-02-25T04:32:38.000Z</updated>
    <content type="html"><![CDATA[<p>链表、栈和队列是非常基本的数据结构，万丈高楼平地起，即使简单，也要认真对待。</p>
<a id="more"></a>
<hr>
<h2 id="u94FE_u8868"><a href="#u94FE_u8868" class="headerlink" title="链表"></a>链表</h2><p>链表是非常基础和常用的一个数据结构，尤其是在解析器(parser)、游戏和搜索算法中。而且很多时候会用来实现下面的 ADT(Abstract Data Type)：</p>
<ul>
<li>堆栈 Stack</li>
<li>集合 Set</li>
<li>哈希表 Hash Table</li>
</ul>
<p>我们来重温一下实现某个数据结构要做的五个事情：</p>
<ol>
<li>Understand it Abstractly</li>
<li>Write a Specification</li>
<li>Write Applications</li>
<li>Select, Design, Implement</li>
<li>Analyze the Implementation</li>
</ol>
<p>接下来我们以链表为例子，具体来过一遍前三个步骤，后面两个步骤属于实现的细节和实现之后的分析，这里暂时不涉及。</p>
<h3 id="1-Understand_it_Abstractly"><a href="#1-Understand_it_Abstractly" class="headerlink" title="1.Understand it Abstractly"></a>1.Understand it Abstractly</h3><p>因为链表比较简单，所以一幅图就可以解释清楚：</p>
<p><img src="/images/14563356077459.jpg" alt="黄色部分是数据，绿色部分是指针"></p>
<h3 id="2-Specification"><a href="#2-Specification" class="headerlink" title="2.Specification"></a>2.Specification</h3><p>明确的规格说明包括：</p>
<ul>
<li>构造器，公有方法和属性的说明</li>
<li>每个方法包含前条件/后条件</li>
<li>说明应该与实现无关</li>
</ul>
<p>这里用一个 <code>IntNode</code> 为例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;     <span class="comment">// data</span></span><br><span class="line">    <span class="keyword">private</span> IntNode link; <span class="comment">// pointer</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntNode</span><span class="params">(<span class="keyword">int</span> initialData, IntNode initialLink)</span></span>&#123;</span><br><span class="line">        data = initialData;</span><br><span class="line">        link = initialLink;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IntNode <span class="title">getLink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> link;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> newdata)</span></span>&#123;</span><br><span class="line">        data = newdata;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLink</span><span class="params">(IntNode newlink)</span></span>&#123;</span><br><span class="line">        link = newlink;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Application"><a href="#3-Application" class="headerlink" title="3.Application"></a>3.Application</h3><p>根据前面的规格说明，具体来使用我们创建的数据结构。这里我们不直接把变量声明为公有，而是通过 getter 和 setter 来进行访问，等于是把变量名称和这个变量本身进行了解耦，即使改变了变量名，只要函数接口不变，对外的行为仍旧是不变的</p>
<h3 id="u94FE_u8868_u5C0F_u7ED3"><a href="#u94FE_u8868_u5C0F_u7ED3" class="headerlink" title="链表小结"></a>链表小结</h3><p>需要掌握的链表操作：</p>
<ul>
<li>插入</li>
<li>删除</li>
<li>检查是否有环</li>
<li>保证程序的健壮性（主要是头为空的时候）</li>
</ul>
<p>其他比较特别的操作：</p>
<ul>
<li>合并 N 个链表</li>
<li>反转链表</li>
<li>截取链表的一部分</li>
<li>寻找链表的 1/N</li>
</ul>
<h2 id="u6808_u4E0E_u961F_u5217"><a href="#u6808_u4E0E_u961F_u5217" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>栈和队列是比较典型的 ADT，所谓 ADT，就是实际上内存中没有类似的数据结构对应，具体的操作是人为增加的设定，是为 Abstract，但是同时它们也被当做数据类型来用，是为 Data Type，于是就成为 ADT。</p>
<p>因为比较简单的缘故，这里大概说一下要点：</p>
<h3 id="u6808"><a href="#u6808" class="headerlink" title="栈"></a>栈</h3><p>性质</p>
<ul>
<li>后入先出</li>
<li>Last-In / First-Out</li>
</ul>
<p>支持的操作：</p>
<ul>
<li>push - 入栈</li>
<li>peek - 查看栈顶</li>
<li>pop - 弹出栈顶元素</li>
</ul>
<p>常见应用</p>
<ul>
<li>程序执行 - 函数调用和返回实际上就是入栈出栈的内容，详情见我的『深入理解计算机系统』系列</li>
<li>解析 - Parsing</li>
<li>计算 postfix 表达式的值 - 例如 <code>4 + 3</code> 可以写成 <code>4 3 +</code></li>
</ul>
<p>需要注意的问题</p>
<ul>
<li>在栈为空的时候执行 pop，会导致 underflow</li>
</ul>
<p>实现方式</p>
<ul>
<li>数组实现 - 需要一个变量来标记栈顶位置</li>
<li>链表实现 - 插入元素时对表头操作需要注意</li>
</ul>
<p>常见题目</p>
<ul>
<li>括号匹配</li>
<li>翻转字符串</li>
<li>模拟递归（N 皇后问题）</li>
</ul>
<h3 id="u961F_u5217"><a href="#u961F_u5217" class="headerlink" title="队列"></a>队列</h3><p>性质</p>
<ul>
<li>先入先出</li>
<li>First-In / First-Out</li>
</ul>
<p>支持的操作：</p>
<ul>
<li>Enqueue - 入队列</li>
<li>Dequeue - 出队列</li>
</ul>
<p>常见应用</p>
<ul>
<li>Round-robin 调度机制 - 处理器处理进程或服务器处理请求（负载均衡）</li>
<li>输入/输出 处理</li>
<li>网络中 packet 的排队处理</li>
</ul>
<p>实现方式</p>
<ul>
<li>数组实现 - 需要一个变量来标记队列头及队列尾的位置</li>
<li>链表实现 - 需要保存表尾，处理表头的时候注意操作顺序</li>
</ul>
<p>与栈的组合</p>
<ul>
<li>利用一个栈和一个队列可以用来判断回文串</li>
</ul>
<p>队列的进阶使用</p>
<ul>
<li>优先队列<ul>
<li>插入队列的元素有一定的顺序要求</li>
<li>每次插入实际上是某种意义上搜索和排序的过程</li>
<li>可以用数组来模拟实现</li>
<li>可以看作是『最大堆』或『最小堆』</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>链表、栈和队列是非常基本的数据结构，万丈高楼平地起，即使简单，也要认真对待。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 2 课 基础知识]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-2/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-2/</id>
    <published>2016-02-24T15:35:52.000Z</published>
    <updated>2016-02-24T16:42:20.000Z</updated>
    <content type="html"><![CDATA[<p>这一课我们不会涉及具体的数据结构或算法，而是先了解一些分析数据结构和算法的基本知识，如前条件/后条件，时间空间复杂度分析。</p>
<a id="more"></a>
<hr>
<h2 id="u524D_u6761_u4EF6/_u540E_u6761_u4EF6"><a href="#u524D_u6761_u4EF6/_u540E_u6761_u4EF6" class="headerlink" title="前条件/后条件"></a>前条件/后条件</h2><p>建议在写具体的函数之前，都要先想好（写好）前条件和后条件，这样可以确定问题的边界。</p>
<ul>
<li>前条件：在函数调用之前一定为真的条件</li>
<li>后条件：在函数执行完之后为真的条件</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Precondition: x &gt;= 0</span></span><br><span class="line"><span class="comment">// Postcondition: The square root of x has</span></span><br><span class="line"><span class="comment">// been written to the standard output</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Big_O"><a href="#Big_O" class="headerlink" title="Big O"></a>Big O</h2><p>在具体介绍之前，先来一些基本的数学公式复习</p>
 $$log_b(x_1·x_2)=log_bx_1+log_bx_2$$ 
 $$log_b(\frac{x_1}{x_2})=log_bx_1-log_bx_2$$ 
 $$log_b(x^c)=c·log_bx$$ 
<p>事实上除了我们常用的 Big O，还有另外两种表示的方法：Big Omega($Big- \Omega$) 和 Big Theta($Big - \theta$)</p>
<p>这里只介绍它们的差别，具体的定义可以自行查看。</p>
<p>Big-O 实际上只表示上限，比如说，我们知道 $17n^2\in O(n^2)$，但是同时我们也可以说 $17n^2\in O(n^37)$ 和 $17n^2\in O(2^n)$</p>
<p>Big omega 则是表示下限，例如 $f(n) = n$，那么下面两个式子都成立 $f(n) \in O(n^2)$ 与 $n^2 \in \Omega(n)$</p>
<p>总结一下：</p>
<p><img src="/images/14563304975385.jpg" alt=""></p>
<p>而 Big theta(Big $\theta$) 则是前面两个的交集：</p>
<p>$$\theta(f)=O(f) \cap \Omega(f)$$</p>
<p>举例来说，函数 $f(n) = 4n$，则</p>
<p>$$f(n)\in O(n)$$</p>
<p>$$f(n) \in \Omega(n)$$</p>
<p>所以</p>
<p>$$f(n)\in \theta(n)$$</p>
<p>简单来说就是</p>
<ol>
<li>Big O 是一个算法最坏情况的度量</li>
<li>Big Omega 是一个算法最好情况的度量</li>
<li>Big Theta 表达了一个算法的区间，给定了一个函数的渐近的逼近(asymptotically tight bound)</li>
</ol>
<p>但是一般来说用 Big O 也就足够了</p>
<h2 id="u9762_u5411_u5BF9_u8C61_u7F16_u7A0B"><a href="#u9762_u5411_u5BF9_u8C61_u7F16_u7A0B" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><blockquote>
<p>Class = Data + Methods</p>
</blockquote>
<p>具体要说的话，内容就太多了，需要深入理解『继承』『多态』和『封装』，也不是一篇日志能说清楚的，所以就大概有一个印象，慢慢领悟吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一课我们不会涉及具体的数据结构或算法，而是先了解一些分析数据结构和算法的基本知识，如前条件/后条件，时间空间复杂度分析。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 1 课 总览]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-1/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-1/</id>
    <published>2016-02-24T14:59:07.000Z</published>
    <updated>2016-02-24T15:23:24.000Z</updated>
    <content type="html"><![CDATA[<p>数据结构与算法是编程中基础中的基础，重要的不是具体某个结构或者算法本身，而是通过理解数据结构和算法在解决问题中发挥的作用，掌握如何用计算机解决问题的方法，进而练就一套自己观察问题，思考问题，解决问题的招式。</p>
<a id="more"></a>
<hr>
<p>网上相关的资料其实蛮多的，之所以打算『重复造轮子』，一是之前的<a href="http://wdxtub.com/2016/01/22/programmer-startline-1/">编程起跑线系列</a>有很多具体的算法思想没有详细说明，二是借着课程的体系重新梳理一下自己的思路。所以整个系列可能会给出大量的参考链接，用于说明基本的概念，而对于数据结构和算法背后的思想，则是我想要着重讨论的。</p>
<p>这门课的编程语言是 Java（CMU 感觉啥课都是 Java），学习目标是：</p>
<ol>
<li>根据特定问题设计或选择合适的算法</li>
<li>根据特定问题设计或选择合适的数据结构</li>
<li>在程序中使用：stacks, queues, linked lists, trees, graphs, 以及 hash tables. </li>
<li>能够用 Big O, Big Omega, 和 Big Theta 分析程序的性能</li>
<li>理解 worse case, best case, average case</li>
<li>理解程序正确性和性能的差异</li>
<li>理解 NP-completeness 理论</li>
<li>能够区分出哪里问题是可以通过计算解决的，哪些不是</li>
</ol>
<p>参考书目：</p>
<ul>
<li>《Data Structures &amp; Other Objects Using Java》 Michael Main, Fourth Edition (Addison-Wesley Longman, ISBN-13 978-0132576246)</li>
<li>《Introduction to Algorithms》Corman, et al., 1990, MIT Press, ISBN 0262031418</li>
</ul>
<p>总体来看是比较中规中矩的一门课，老师给出的课件也是比较凌乱，我会按照自己的理解重新进行组织。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>数据结构与算法是编程中基础中的基础，重要的不是具体某个结构或者算法本身，而是通过理解数据结构和算法在解决问题中发挥的作用，掌握如何用计算机解决问题的方法，进而练就一套自己观察问题，思考问题，解决问题的招式。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="信息处理" scheme="http://wdxtub.com/tags/%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[英语口语中的『噪声』]]></title>
    <link href="http://wdxtub.com/2016/02/23/pronunciation-stress/"/>
    <id>http://wdxtub.com/2016/02/23/pronunciation-stress/</id>
    <published>2016-02-24T02:33:28.000Z</published>
    <updated>2016-02-24T04:05:39.000Z</updated>
    <content type="html"><![CDATA[<p>一个人觉得自己不再需要改变的时候，最大的改变就已经发生了——他变成了没有未来的人。</p>
<a id="more"></a>
<hr>
<p>这个学期给一门研究生课程当助教，宾夕法尼亚州有这么一条法律，英语不是母语的同学当助教的话，必须要达到一定的沟通交流水平，否则学校要被罚款。具体到 CMU，就意味着我需要通过一门叫 ITA 的测试（之前的<a href="http://wdxtub.com/2016/02/19/ita-test/">日志</a>也有提及）。因为是专门负责英语教学的部门，我的英语虽然能应付日常交际，但是细化到讲课上，就有些捉襟见肘了，所以必须进行一些课程培训。</p>
<p>昨天完成了个人作业，已经感觉有了很大收获（见<a href="http://wdxtub.com/2016/02/22/how-to-speak/">这里</a>），今天去上了关于发音的培训课（主要是重音），更是感觉醍醐灌顶，小班教学，寓教于乐，原本担心两个小时太长的我，到最后还觉得时间过得太快，想让老师多讲一会儿。</p>
<p>所以在这篇日志中，讲讲如何快速掌握英语口语中的『重音』。掌握了重音，就可以最大程度减少表达中的『噪声』，让自己的表达更容易被听懂。</p>
<h2 id="u91CD_u97F3_u4E0E_u8BED_u8C03_28stress_and_intonation_29"><a href="#u91CD_u97F3_u4E0E_u8BED_u8C03_28stress_and_intonation_29" class="headerlink" title="重音与语调(stress and intonation)"></a>重音与语调(stress and intonation)</h2><p>以汉语为母语的我们，长期浸淫在汉语环境中（汉语属于 monotone），无论从生理还是心理上都难以完全转换到英语模式。但是我们真的需要说得跟以英语为母语的人一样吗？并不需要！我们需要的是让的表达更加清晰，更容易理解，至于带一点点口音其实无伤大雅，甚至有时候还能成为个人特色（生活大爆炸中的 Raj）。</p>
<p>如果说完整的表达是 100 分的话，那么口音其实只占 25 分，剩下的 75 分是重音与语调。但是奇怪的是，大多数英语学习者都忽略了这 75 分，有种舍本逐末的感觉。</p>
<p>举个例子，15(fifteen) 和 50(fifty) 是我们很容易说不清的，问题不在于我们发音不够准，而是我们重音不对。正确的读法应该是：</p>
<p>15 - fifTEEN, 50 - FIFty（大写的部分表示重音），通过重音的变换，别人可以轻松地明白我们在说 15 还是 50。</p>
<p>有重音，相对来说，肯定也有轻读的，甚至我们可以吞掉某些音节，看下面两个例子：</p>
<blockquote>
<p>Give a man a horse he can ride</p>
</blockquote>
<p>这里的 can，实际的发音类似 kon，尾音甚至可以省略</p>
<blockquote>
<p>His rank and wealth, his strenth and health</p>
</blockquote>
<p>这里的 and，实际的发音就剩下 n，大家可以自己读一下试一试。</p>
<p>再举一个对比：</p>
<blockquote>
<p>I can || go. 与 I || can’t || go. (这里 || 表示停顿)</p>
</blockquote>
<p>第一个句子，go 需要重音，第二个句子，can’t 需要重音。说了这么多，到底要怎么重音呢？有下面三个基本原则：</p>
<ol>
<li><strong>Louder</strong> (more air = more volume)</li>
<li><strong>Longer</strong> (s-t-r-e-t-c-h out the word, especially the vowel)</li>
<li><strong>Pause</strong> (before or after the stress to make it stand out)</li>
</ol>
<h2 id="u54EA_u4E9B_u8BCD_u9700_u8981_u91CD_u97F3"><a href="#u54EA_u4E9B_u8BCD_u9700_u8981_u91CD_u97F3" class="headerlink" title="哪些词需要重音"></a>哪些词需要重音</h2><p>重音本身是和说话的意思紧密相关的，所以大原则就是，要利用重音突出表达某个意思，也就是说，哪个词的信息量大，哪个词就需要重音。</p>
<p>总体来看可以这样划分：</p>
<ul>
<li>Content words are stressed: Nouns, verbs, adjectives and adverbs, question words, demonstratives(these, those, etc), negatives</li>
<li>Function words are not stressed: Prepositions, pronouns, articles, verb “to be”, conjunctions(and, but), auxiliaries(do, should, can)</li>
</ul>
<p>对于每个单词，其实也有重音，规则还是一样：louder, longer, pause。对于类似 AI, DNA 这种缩写，每个单词都需要重音。</p>
<p>对于复合名词，每个单词都需要重音，但是前面的可以再重一点，比如 “quantum || mechanics”</p>
<h2 id="u5229_u7528_u91CD_u97F3_u6765_u5F3A_u8C03_u4FE1_u606F"><a href="#u5229_u7528_u91CD_u97F3_u6765_u5F3A_u8C03_u4FE1_u606F" class="headerlink" title="利用重音来强调信息"></a>利用重音来强调信息</h2><p>对一个句子不同单词重音，可以有不同的强调效果，比如</p>
<ul>
<li>Did John study Chemical Engineering last semester? (normal yes/no question stress)</li>
<li>Did John study Chemical Engineering || <strong>last</strong> || semester? (no, three semesters ago)</li>
<li>Did John study || <strong>Chemical</strong> || Engineering last semester? (no, electrical)</li>
<li>Did John || <strong>study</strong> || Chemical Engineering last semester? (no, he taught)</li>
<li>Did || <strong>John</strong> || study Chemical Engineering last semester? (no, Bob did)</li>
</ul>
<p>另一种情形，是利用重音来区别比较近似的两个词，如：</p>
<ul>
<li>Did you study MICRO or MACROeconomics?</li>
<li>Did you say INput or OUTput?</li>
<li>Did you say SUPER or SEMIconductor?</li>
<li>Are we talking about FISion or FUSion?</li>
<li>Are you working with HARDware or SOFTware?</li>
<li>Was the result a POSITIVE or a NEGATIVE integer?</li>
<li>Is the curve conVEX or conCAVE?</li>
<li>Is that elastic or INelastic?</li>
<li>Did you say reFLECtion or reFRACtion</li>
</ul>
<p>这里大写表示要重音的部分，仔细感受一下。</p>
<p>最后一个情况是需要纠正别人的话，那么对于纠正的地方就需要重音，比方说：</p>
<ul>
<li>Boston is a state -&gt; No, it’s a || <strong>city</strong>.</li>
<li>Tokyo is in Korea -&gt; No, it’s in || <strong>Japan</strong>.</li>
</ul>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>给我震动最大的，不是精心准备的上课材料，不是精细到位的指导，而是去思考如何做好一件事情，并用最好的方式传达出去感染更多的人。这种教育模式是我在国内很少见到的（也就我爸妈教我的时候是这样），有这样的老师，学生又如何能不『尊师重道』呢？</p>
<p>信噪比是一个很重要的思路，生活中的方方面面都可以从这个角度来切入，思考并改进已有的方法。</p>
<p>最后说一个很有意思的看问题的角度，在强调语调和重音的作用时，老师让我们试着去模仿英语为母语的人如何说中文，通过仔细揣摩个中不同，就会发现他们即使说中文也带着说英文时的重音和语调，我们听起来就觉得有点怪（虽然意思可以明白），反之亦然。</p>
<p>这种通过反向模仿来进行思考和比较的思路，其实还可以应用在很多方面，这堂课哪怕我只听了这么一句话，这两个小时也值了，更何况整堂课干货满满毫无尿点呢！</p>
<p>还有很长的路要走，我要加油。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个人觉得自己不再需要改变的时候，最大的改变就已经发生了——他变成了没有未来的人。</p>]]>
    
    </summary>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 第 14 课 文件 vs 数据库]]></title>
    <link href="http://wdxtub.com/2016/02/22/cc-14/"/>
    <id>http://wdxtub.com/2016/02/22/cc-14/</id>
    <published>2016-02-22T14:46:58.000Z</published>
    <updated>2016-02-24T02:35:04.000Z</updated>
    <content type="html"><![CDATA[<p>从这一课起，我们要开始使用数据库了。通过数据库和文件的性能对比以及 SQL 与 NoSQL 的对比，学会选择最合适的技术。</p>
<a id="more"></a>
<hr>
<h2 id="u5B66_u4E60_u76EE_u6807"><a href="#u5B66_u4E60_u76EE_u6807" class="headerlink" title="学习目标"></a>学习目标</h2><ol>
<li>了解使用文件来存储信息的优势和劣势</li>
<li>增加使用 <code>awk</code>, <code>grep</code> 等命令修改文件的经验</li>
<li>了解使用数据库来存储信息的优势和劣势</li>
<li>了解 MySQL (SQL) 和 HBase (NoSQL) 的不同</li>
<li>学会如何把数据载入到数据库中(MySQL, HBase)</li>
<li>学会使用 JDBC 连接 MySQL</li>
<li>学会使用 Java API 来操作 HBase</li>
<li>了解 vertical scaling 的在持久云存储（磁盘, 固态硬盘）的性能</li>
</ol>
<p>这次的作业主要用 Bash 和 Java(MySQL &amp; HBase) 在 AWS 平台上完成。</p>
<h2 id="u80CC_u666F_u77E5_u8BC6"><a href="#u80CC_u666F_u77E5_u8BC6" class="headerlink" title="背景知识"></a>背景知识</h2><p>近年来『数据』越来越被重视，这之中很重要的一环就是——如何存储这些数据。这一课中我们会接触常见的存储数据的方式，并学会在实际场景中根据需要选择合适的技术。</p>
<p>我们先会介绍<a href="https://en.wikipedia.org/wiki/Flat_file_database" target="_blank" rel="external">『文件』</a>以及『关系型数据库』</p>
<p>通常来说，我们用文件来保存非结构化的数据，用数据库来保存结构化的数据，我们来看看下面这个例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件中的一行</span></span><br><span class="line">Name: Carnegie, Course: Cloud Computing, Section: A, Year: <span class="number">2015</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库中的一行（有四列）</span></span><br><span class="line">Name           Course         Section     Year</span><br><span class="line">Carnegie    Cloud Computing      A        <span class="number">2015</span></span><br></pre></td></tr></table></figure>
<p>在数据库中，数据以表的形式存储，访问不同的元素比较简单，但是在文件中，就需要做一定的解析工作。文件和数据库各有所长，重要的还是具体问题具体分析，不能一概而论。</p>
<p>除了文件和传统的关系型数据库，NoSQL 数据库现在也越来越流行了。因为大数据面临的挑战，NoSQL 数据库在扩展性上比传统方法更好，但是却不得牺牲一些一致性和结构性来换取性能和可拓展性。</p>
<p>这节课我们同样会尝试在 HBase 上做一些操作。完成之后，应该能够对这三种方式有更加清晰的理解，以及能够根据实际使用场景来选择对应的方法。</p>
<h2 id="u80CC_u666F_u8BBE_u5B9A"><a href="#u80CC_u666F_u8BBE_u5B9A" class="headerlink" title="背景设定"></a>背景设定</h2><p>我们的目标是打造一个关于音乐和电影的社交网络，作为一个菜鸟，我拿到的第一个任务是分析音乐数据。在把服务部署到云上之前，公司希望我能评估一下用文件和用关系型数据库的性能比较。提供的数据文件如下：</p>
<p><img src="/images/14561603284363.jpg" alt=""></p>
<p>其中 <code>million_songs_metadata.csv</code> 包含所有歌曲的信息，<code>million_songs_sales_data.csv</code> 包含一段时间内每首歌的每日销量。具体的格式如下：</p>
<p><img src="/images/14561643038821.jpg" alt="Schema for file `million_songs_metadata.csv`"></p>
<p><img src="/images/14561643402177.jpg" alt="Schema for file `million_songs_sales_data.csv`"></p>
<p>最后注意要给所有用到的资源打上 <code>Project: 3.1</code> 的标签</p>
<h2 id="u6587_u4EF6_u64CD_u4F5C"><a href="#u6587_u4EF6_u64CD_u4F5C" class="headerlink" title="文件操作"></a>文件操作</h2><p>这一部分主要是使用 <code>grep</code> 和 <code>awk</code> 来进行一些简单的数据处理工作，关于这两个命令的使用，本来是打算专门写日志来说明的（然而一直没抽出时间），所以就尽量在这里介绍得清晰一点。</p>
<p>Grep 命令可以用来查找文件中出现的关键词或者某种固定的模式，如果我们要找到一个文件中包含 “The Beatles” 的记录，那么可以用以下命令：</p>
<p><code>grep -P &#39;The Beatles&#39; million_songs_metadata.csv</code></p>
<p>具体的查找过程可以有不同的参数进行设置，比方说下面的语句就会忽略大小写进行匹配：</p>
<p><code>grep -i -P &#39;The Beatles&#39; million_songs_metadata.csv</code></p>
<p>关于不同参数的意义，可以直接在命令行中输入 <code>man grep</code> 进行查看。</p>
<p>利用管道，我们可以统计具体的行数，比如：</p>
<p><code>grep -P &#39;The Beatles&#39; million_songs_metadata.csv | wc -l</code></p>
<p>用 grep 得到的结果，只要某一行出现了要找的内容，就算找到，但是如果我们想在指定的列中寻找特定的字符，就可以使用 awk 命令了。比方说，我们只想找出 <code>artist_name</code> 那一列中出现 “The Beatles” 的记录，就可以用下面的命令：</p>
<p><code>awk &#39; BEGIN {FS = &quot;,&quot;} ; {if ($7 ~ /The Beatles/) { print; }}&#39; million_songs_metadata.csv</code></p>
<p>这里 <code>$7</code> 表示是第 7 列，而 <code>FS = &quot;,&quot;</code> 表示分隔符是 <code>,</code></p>
<p>如果我们想要更复杂一点的逻辑，比如要找到 Michael Jacksn 80 年代的歌曲，就可以用这个命令：</p>
<p><code>awk &#39; BEGIN {FS = &quot;,&quot;} ; {if (tolower($7) ~ /michael jackson/ &amp;&amp; $11 &gt;= 1980 &amp;&amp; $11 &lt; 1990) { print; }}&#39; million_songs_metadata.csv</code></p>
<p>随着问题越来越复杂，可能很多时候都没有办法在一行内解决问题，不过在这一部分，我们还是尽量试试看用 grep 和 awk 解决问题。</p>
<p>做好准备之后可以开启一个 <code>ami-ca685ba0</code> 的 <code>t1.micro</code> 实例来完成下面的任务。</p>
<p>基本我们要做的就是把 <code>runner.sh</code> 补充完整，仔细读题，仔细读题，仔细读题（比如是否区别大小写）。</p>
<p>第五题可以写一个程序或者若干命令，以 <code>million_songs_metadata.csv</code> 和 <code>million_songs_sales_data.csv</code> 中相同 <code>track_id</code> 为标准，合并两个文件。生成一个 <code>million_songs_metadata_and_sales.csv</code> 数据集，其中第 1 列是 <code>track_id</code>，第 2 列是 <code>sales_date</code>，第 3 列是 <code>sales_count</code>，第 4 - 13 列是 <code>million_songs_metadata.csv</code> 的其他列。</p>
<p>完成问题之后，可以使用 <code>./runner.sh files</code> 来检查输出结果</p>
<p><strong>提示</strong></p>
<ol>
<li>搜索找到一个能够完成合并文件的 unix 命令</li>
<li>只能用命令行脚本完成</li>
<li>不要使用 Java 和 Python</li>
<li>没有特别声明，所有的匹配都是大小写敏感的</li>
<li>第六题中，一个歌手可能有多个 <code>artist_names</code>，但是只会有一个唯一的 <code>artist_id</code>，应该根据 <code>artist_id</code> 来找到最大的销量，并返回所有 <code>artist_name</code></li>
<li>注意保存好 <code>runner.sh</code></li>
</ol>
<h3 id="u89E3_u9898_u653B_u7565"><a href="#u89E3_u9898_u653B_u7565" class="headerlink" title="解题攻略"></a>解题攻略</h3><p>首先先创建一个 <code>ami-ca685ba0</code> 的 <code>t1.micro</code> 实例。就绪之后 ssh 过去：<code>ssh -i demo.pem ubuntu@ec2-54-175-177-74.compute-1.amazonaws.com</code>，即可见到这次作业的相关文件：</p>
<p><img src="/images/14561733687303.jpg" alt=""></p>
<p>这部分我们只需要用 <code>runner.sh</code>，所以把它搞到本地 <code>scp -i demo.pem ubuntu@dns.compute-1.amazonaws.com:~/Project3_1/runner.sh ./</code></p>
<p>打开 <code>runner.sh</code> 文件，可以看到需要回答的问题是：</p>
<ol>
<li>在文件 <code>million_songs_metadata.csv</code> 中，有多少行包含 <code>Aerosmith</code>，大小写敏感</li>
<li>在文件 <code>million_songs_metadata.csv</code> 中，<code>artist_name</code> 包含 <code>Bob Marley</code> 的 <code>track_id</code> 有多少个，大小写敏感</li>
<li>在文件 <code>million_songs_metadata.csv</code> 中，第 7 列中包含 <code>The Beatles</code> 的有多少行，大小写敏感</li>
<li>写出与 SQL 命令 <code>SELECT AVG(duration) FROM songs</code> 等价的命令行命令</li>
<li>把两个 csv 文件合并为 <code>million_songs_metadata_and_sales.csv</code>，以相同 <code>track_id</code> 为标准</li>
<li>在文件 <code>million_songs_metadata_and_sales.csv</code> 中，找到销量最高的 artist，一个歌手可能有多个 <code>artist_names</code>，但是只会有一个唯一的 <code>artist_id</code>，应该根据 <code>artist_id</code> 来找到最大的销量，并返回所有 <code>artist_name</code></li>
</ol>
<p>写好之后传到服务器上：<code>scp -i demo.pem ./runner.sh ubuntu@dns.compute-1.amazonaws.com:~/Project3_1/</code></p>
<p>测试的话用 <code>./runner.sh files</code>，确定无误后使用 <code>./submitter -a dawang</code> 来进行提交，代码运行完成后输入提交密码即可。</p>
<h2 id="MySQL__u64CD_u4F5C"><a href="#MySQL__u64CD_u4F5C" class="headerlink" title="MySQL 操作"></a>MySQL 操作</h2><p>同样是使用 <code>ami-ca685ba0</code> 的 <code>t1.micro</code> 实例来完成这部分的内容</p>
<p>先通过<a href="https://youtu.be/x73HknyUGIM" target="_blank" rel="external">视频</a>来了解 MySQL 的基础知识</p>
<p>远程机器中已经安装配置好了 MySQL，使用下面的命令可以开启 MySQL 命令行客户端并且连接到数据库：</p>
<p><code>mysql -u root -pdb15319root song_db</code></p>
<p>上面的命令中，用户名是 <code>root</code> 密码是 <code>db15319root</code>，使用是数据名称是 <code>song_db</code></p>
<p>数据库的相关知识可以参考<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="external">这里</a>，就不在日志中赘述。</p>
<p>我们需要根据前面给出 schemas 来创建对应的表，作业文件中提供了 <code>~/Project3_1/create_tables.sql</code> 文件，可以从这里开始</p>
<blockquote>
<p>远程主机中的 MySQL 版本是 5.5，注意查看对应的文档</p>
</blockquote>
<p>创建好之后，可以使用下面的命令来查看表的 schema</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">DESCRIBE</span> songs;</span></span><br><span class="line"><span class="operator"><span class="keyword">DESCRIBE</span> sales;</span></span><br></pre></td></tr></table></figure>
<p>然后和前面给出的表格进行比较，看看是否一致。</p>
<p>所以我要做的是找到合适的命令，把 <code>million_songs_metadata.csv</code> 和 <code>million_songs_sales.csv</code> 导入到 MySQL 中。可以在 MySQL 命令行工具中使用 SQL 命令导入，也可以用 mysqlimport 工具来导入，记下所使用的命令即可。</p>
<p>想要验证是否导入成功的话，可以列出前十条记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> songs </span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure>
<p>SQL 的语法可以参考<a href="http://www.w3school.com.cn/sql/sql_syntax.asp" target="_blank" rel="external">这里</a>，下面选出一些简单的例子进行介绍。</p>
<p>比如说下面的命令就会从表中选出 <code>artist_name</code> 一列中包含 <code>The Beatles</code> 的表项：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> songs </span><br><span class="line"><span class="keyword">WHERE</span> artist_name </span><br><span class="line"></span><br><span class="line"><span class="keyword">LIKE</span> <span class="string">'%The Beatles%'</span>;</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>%</code> 表示任何字符出现任意次数，前面提到的寻找 <code>Michael Jackson</code> 的例子可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> songs </span><br><span class="line"><span class="keyword">WHERE</span> artist_name </span><br><span class="line"><span class="keyword">LIKE</span> <span class="string">'%michael jackson%'</span><span class="keyword">AND</span> <span class="keyword">year</span> &gt;= <span class="number">1980</span> <span class="keyword">AND</span> <span class="keyword">year</span> &lt; <span class="number">1990</span>;</span></span><br></pre></td></tr></table></figure>
<p>如果需要计算平均时间，就不需要使用 <code>awk</code> 命令那么复杂，可以直接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">duration</span>) <span class="keyword">FROM</span> songs;</span></span><br></pre></td></tr></table></figure>
<p>带索引的数据库可以极大提高查询的性能，在 MySQL 中，所有的主键都会自动成为索引。</p>
<p>Aggregate Functions 允许你在多个记录中执行运算并返回一个单一值，比较常用的有 <code>SUM</code>, <code>AVG</code>, <code>MAX</code>, <code>MIN</code> 和 <code>COUNT</code>. Aggregate functions 通常和 MySQL 的 GROUP BY 关键字一起使用来为不同的 subgroup 执行运算并返回对应结果。GROUP BY 非常有用，下面是一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> c1, c2, ... cn, aggregate_function(expression)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">WHERE</span> where_conditions</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2, ... cn;</span></span><br></pre></td></tr></table></figure>
<p>例如，要统计最近十天总销量排名，可以用下面的 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> sales_date, <span class="keyword">SUM</span>(sales_count) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sales_date</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sales_date <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure>
<p>MySQL 的 JOIN 关键字可以用来在两个或两个以上相关的表中进行查询。在 MySQL 中 <code>JOIN</code>, <code>CROSS JOIN</code> 和 <code>INNER JOIN</code> 是等价的，下面是一个例子：syntax:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#<span class="operator"><span class="keyword">select</span> <span class="keyword">statement</span></span><br><span class="line">    <span class="keyword">SELECT</span> c1,c2,....cn</span><br><span class="line">    <span class="keyword">FROM</span> join_table;</span></span><br><span class="line">#join_table</span><br><span class="line">    table1 [INNER|CROSS] JOIN table2 [join_condition]</span><br><span class="line">#join_condition:</span><br><span class="line">    ON conditional_expr</span><br><span class="line">  | USING (column_list)</span><br></pre></td></tr></table></figure>
<p><code>INNER JOIN</code> 会构造指定的表的笛卡尔乘积，也就是第一个表中的每一行通过 join condition 和第二个表中的每一行组合。因为我们的 songs 表中的所有 <code>track_ids</code> 在 sales 表中都有对应的记录，所以这里只用 <code>INNER JOIN</code> 即可。</p>
<p>例如，下面的 SQL 语句会返回销量最高的 10 首歌的名字：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> songs.title, <span class="keyword">SUM</span>(sales_count) <span class="keyword">AS</span> total_sale</span><br><span class="line"><span class="keyword">FROM</span> songs</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> sales <span class="keyword">ON</span> songs.track_id = sales.track_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sales.track_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> total_sale</span><br><span class="line"><span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于 OUTER JOIN</p>
</blockquote>
<p>和 INNER JOIN 不同的是可能会出现列的值为空的情况，根据提供不匹配的数据的表所在的位置，分为 LEFT 和 RIGHT JOINS。在 LEFT JOIN 中，会返回左边表中不匹配的记录，反之亦然。没有匹配的话，会把对应的列设为 NULL。如果想要保留不匹配的数据，这种方法就很有用了。</p>
<h3 id="JDBC__u548C_MySQL"><a href="#JDBC__u548C_MySQL" class="headerlink" title="JDBC 和 MySQL"></a>JDBC 和 MySQL</h3><p>Java Database Connectivity (JDBC) API 可以用来访问数据库，并且由于是一个跨平台的标准，在不同的平台上可以使用相同的代码。这一部分我们会使用 MySQL Connector/J。</p>
<p>第一步就是与数据建立连接，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">Connection conn = DriverManager.getConnection(URL, DB_USER, DB_PWD);</span><br></pre></td></tr></table></figure>
<p>第一行载入并初始化 MySQL 的 JDBC 驱动，然后我们就可以建立与数据库的连接（参数比较简单这里略过）</p>
<p>为了执行 SQL 操作以及获取执行完毕的结果，我们需要创建 Statement(用来执行 SQL 命令的对象)，并且在执行完成后得到一个 ResultSet 对象，下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line">ResultSet rs = stmt.executeQuery(<span class="string">"select count(*) as cnt from songs;"</span>);</span><br></pre></td></tr></table></figure>
<p>可以通过调用 <code>rs.next()</code> 来遍历结果：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (rs.<span class="keyword">next</span>()) &#123;</span><br><span class="line">    <span class="keyword">int</span> rowCount = rs.getInt(<span class="string">"cnt"</span>);</span><br><span class="line">    System.out.<span class="keyword">println</span>(<span class="string">"Total number of lines in songs is "</span> + rowCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完对应操作后，还需要关闭我们用到的 Statement 和 Connection，注意关闭 Statement 之后对应的 ResultSet 也会被关闭。</p>
<h3 id="u89E3_u9898_u653B_u7565-1"><a href="#u89E3_u9898_u653B_u7565-1" class="headerlink" title="解题攻略"></a>解题攻略</h3><p>和之前一样，我们要做的就是完成 7-11 题，需要修改 <code>MySQLTasks.java</code> 文件。仔细读题，仔细读题，仔细读题。</p>
<p>第 7-9 题我们需要为 songs 表创建索引。那么应该选择哪一列作为索引呢？</p>
<p>记录下使用的命令已经对应更新 <code>INDEX_NAME</code> 变量，建立索引需要花一点时间，不过可以换取比较大的性能提升，建立完索引后，使用下面的命令重启 mysql：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure>
<p>在第 9 题中，我们会使用和第 7 题一样的指令，就可以看到建立索引之后的性能提升。</p>
<p>开始写代码之前，可以先运行一下样例，了解 java 如何和 MySQL 交互。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac MySQLTasks<span class="class">.java</span></span><br><span class="line">java MySQLTasks demo</span><br></pre></td></tr></table></figure>
<p>会输出 songs 表中的行数（如果存在的话），做完之后可以用 <code>./runner.sh mysql</code> 来检查。</p>
<p><strong>Bonus</strong></p>
<p>如果完成 <code>MySQLTasks.java</code> 中的 <code>loadData</code> 函数，有 5 分的加分，可以通过下面代码进行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac MySQLTasks.java</span><br><span class="line">java MySQLTasks load_data</span><br></pre></td></tr></table></figure>
<p><strong>一些提示</strong></p>
<ul>
<li>SQL 的 LIKE 操作符默认是大小写不敏感的</li>
<li>记得把所有的答案输出到同一行</li>
<li>下一部分也可以用同一个远程机器，终止之前保存好所有的代码</li>
</ul>
<p>文件更灵活，可以存放结构或非结构数据，并且容易实现和修改；数据库则稍微笨重一些。对于文件来说，安全只能通过文件权限来控制，但是数据库有更加完善的权限管理。对文件的访问没有办法并行，但是数据库访问则可以。其他的不同基本上可以认为数据库有一套完整的管理接口和语法，而文件的话都需要自己实现，下表是一个总结：</p>
<p><img src="/images/14561824166535.jpg" alt="文件 vs 数据库"></p>
<p>首先我们把对应的文件复制到本地：<code>scp -i demo.pem ubuntu@dns.compute-1.amazonaws.com:~/Project3_1/MySQLTasks.java ./</code></p>
<p>然后我们可以用给出的 <code>create_tables.sql</code> 来新建数据表，先进入 MySQL 的命令行：<code>mysql -u root -pdb15319root song_db</code></p>
<p>然后输入 <code>source ./create_tables.sql</code> 来执行新建表格的命令。接着可以用 <code>DESCRIBE songs;</code> 和 <code>DESCRIBE sales;</code> 来查看是否成功创建（注意一定要最后的分号），如图</p>
<p><img src="/images/14561876662637.jpg" alt="songs 表"><br><img src="/images/14561876858760.jpg" alt="sales 表"></p>
<p>然后需要找到合适的命令，把 <code>million_songs_metadata.csv</code> 和 <code>million_songs_sales.csv</code> 导入到 MySQL 中（这里推荐用 <code>mysqlimport</code> 来导入，另一个有点问题）。命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要先更改两个 scv 文件的名字，这样才能载入到对应的表中</span></span><br><span class="line">cp million_songs_metadata.csv songs.csv</span><br><span class="line">cp million_songs_sales_data.csv sales.csv</span><br><span class="line"><span class="comment"># 然后进行载入</span></span><br><span class="line">mysqlimport -u root -pdb15319root --local --fields-terminated-by=<span class="string">","</span> --lines-terminated-by=<span class="string">"\n"</span> song_db songs.csv</span><br><span class="line">mysqlimport -u root -pdb15319root --local --fields-terminated-by=<span class="string">","</span> --lines-terminated-by=<span class="string">"\n"</span> song_db sales.csv</span><br></pre></td></tr></table></figure>
<p>然后我们用下面的命令来看看是否成功（如果不成功，就重新用前面的脚本生成一次对应的表）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> songs <span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sales <span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure>
<p>大概应该看到</p>
<p><img src="/images/14561903279207.jpg" alt=""></p>
<p>然后就可以进入写 java 代码的阶段了，先大概看一下已有的代码，发现已经帮我们初始化过了，实际上只要在代码中填写对应的 SQL 语句即可。问题为（第 7-11 题）：</p>
<ol>
<li>(7)返回 duration 最长的歌的 trackid</li>
<li>(8)选择一列作为索引，并建立索引</li>
<li>(9)返回 duration 最长的歌的 trackid（和第 1 个题目相同，用来比较性能）</li>
<li>(10)写一条与 <code>grep -P &#39;The Beatles&#39; million_songs_metadata.csv | wc -l</code> 等价的 sql 语句，这里注意大小写的问题，提示：<code>BINARY</code>（感谢 @jiexing）</li>
<li>(11)哪个 artist 的歌曲数目是第三多的，返回其名字，如果有多个，任意一个都可以</li>
</ol>
<p>其实主要就是写出对应的 SQL 语句，执行起来都是一样的，前面也有给出例子。然后就可以上传回服务器：<code>scp -i demo.pem ./MySQLTasks.java ubuntu@dns.compute-1.amazonaws.com:~/Project3_1/</code></p>
<p>测试的话用 <code>./runner.sh mysql</code>，确定无误后使用 <code>./submitter -a dawang</code> 来进行提交，代码运行完成后输入提交密码即可。</p>
<h2 id="Vertical_Scaling__u5B58_u50A8"><a href="#Vertical_Scaling__u5B58_u50A8" class="headerlink" title="Vertical Scaling 存储"></a>Vertical Scaling 存储</h2><p>那么问题来了，我们的数据到底保存在哪里呢？当然是物理世界的硬盘上，但是我们之前好像都没有考虑到这个事情，事实上，不同的硬盘对性能也有极大的影响。</p>
<p>接下来的部分我们会了解一些 Linux 下的磁盘操作命令并且利用 AWS 提供的存储设备来进行 vertical scaling。并且用常见的 benchmarking 工具来进行测试，通过整个过程，应该就能了解为什么实际存储数据的设备也对性能有极大的影响。</p>
<p>因为大多数命令都需要 root 权限，所以开始之前 <code>sudo su</code> 一下是比较方便的选择。</p>
<p>这个<a href="https://youtu.be/8Bwg_wUVhkE" target="_blank" rel="external">视频</a>介绍如何在 EC2 实例中使用 EBS</p>
<ul>
<li>一般来说在创建 EC2 实例的时候会自动创建一个 EBS 并挂载到 EC2 实例上</li>
<li>先进入 EBS Volume 页面，Create Volume -&gt; 选择不同的大小 -&gt; 选择 Availablility Zone(要和 EC2 在同一个区域) -&gt; Create</li>
<li>点击 Action -&gt; Attach Volumn -&gt; 选择已有的实例 -&gt; 填写挂载点 <code>/dev/sdf</code></li>
<li>ssh 到机器上，输入命令 <code>sudo parted -l</code> 可以发现并没有成功挂载</li>
<li>我们在磁盘上新建一个文件系统：<code>sudo mkfs.ext4 /dev/xvdf</code></li>
<li>再次运行 <code>sudo parted -l</code>，发现一切正常</li>
<li>然后创建文件夹用来挂载 <code>sudo mkdir /mnt/ebs1</code></li>
<li>接着进行挂载 <code>sudo mount /dev/xvdf /mnt/ebs1</code></li>
<li>就可以访问对应文件夹了 <code>cd /mnt/ebs1/</code></li>
<li>最后可以用 <code>df -h</code> 来进行查看</li>
</ul>
<p>GNU <code>parted</code> 是用来创建、销毁、改变大小、检查状态、复制分区的命令，可以操作分区表（取代原来的 <code>fdisk</code>），并支持如 GUID Partition Table(GPT) 等的新特性。想要了解更多可以参考<a href="https://www.gnu.org/software/parted/manual/html_chapter/parted_1.html" target="_blank" rel="external">这里</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parted <span class="operator">-l</span></span><br><span class="line">/dev/xvda1 – this is the OS partition</span><br><span class="line">/dev/xvdb – this is the first Ephemeral (instance store) drive</span><br><span class="line">/dev/xvdc – this is the second Ephemeral (instance store) drive</span><br></pre></td></tr></table></figure>
<p>创建并格式化一个分区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">umount /dev/xvdX <span class="comment">#where “X” - is a,b,c..etc (You should use your device’s name)</span></span><br><span class="line">parted /dev/xvdX mklabel gpt</span><br><span class="line">parted /dev/xvdX mkpart db ext4 <span class="number">0</span>% <span class="number">10</span>G</span><br><span class="line">mkfs.ext4 /dev/xvdX1</span><br></pre></td></tr></table></figure>
<p>对于比较小的 volume，可以直接整个格式化，不用分区</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs<span class="class">.ext4</span> /dev/xvdX</span><br></pre></td></tr></table></figure>
<p>创建挂载点并挂载</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="regexp">/storage/m</span>ountpoint</span><br><span class="line">mount <span class="regexp">/dev/y</span>ourdevice <span class="regexp">/storage/m</span>ountpoint</span><br></pre></td></tr></table></figure>
<p>到底用不用挂载点可以自己决定，不过一般来说 Linux 会挂载到 <code>/mnt</code>（EC2 也是这么做的）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount</span><br></pre></td></tr></table></figure>
<p>不带任何参数的话会显示所有的挂载点，可以用来判断是否挂载成功。</p>
<h3 id="u89E3_u9898_u653B_u7565-2"><a href="#u89E3_u9898_u653B_u7565-2" class="headerlink" title="解题攻略"></a>解题攻略</h3><p>简单来说就是比较传统硬盘和固态硬盘的性能差别，测试的场景如下：</p>
<p><img src="/images/14561980518607.jpg" alt=""></p>
<p>Sysbench 是一个包含多个测试的评测。这里我们使用的评测程序和 sysbench 唯一不同的是可以选择 [SSD|Magnetic]。</p>
<p>根据下面的指示完成不同配置的测试，记录下不同的 RPS，把数字填写到对应的位置即可。</p>
<blockquote>
<p>提示：使用比较慢的硬件时，准备 10GB 的数据可能要花费很长时间，用最好的的机器（比如 large）来准备数据</p>
</blockquote>
<p><strong>准备测试数据</strong></p>
<p>步骤如下</p>
<ol>
<li>用 <code>ami-ca685ba0</code> 启动一个 <code>t1.micro</code> 或 <code>m3.large</code> 的实例</li>
<li>创建一个 20GB 的 EBS volume (磁盘或固态硬盘) 。确保和 EC2 实例在同一个区域</li>
<li>把 EBS volume 挂载到 EC2 实例上</li>
<li>SSH 到 EC2 实例，格式化并挂载 EBS volume</li>
<li>进入挂载文件夹</li>
<li>用下面的命令生成测试数据 <code>sudo /home/ubuntu/Project3_1/sysbench --test=fileio --file-total-size=10G prepare</code></li>
</ol>
<p>上面的命令会在 EBS volume 上生成 10GB 的测试数据，在接下来的步骤中都可以重复使用</p>
<p><strong>试验 1 (上表中 Scenarios 1 &amp; 2 )</strong></p>
<p>执行以下步骤：</p>
<ol>
<li>启动一个 <code>ami-ca685ba0</code> 的 <code>t1.micro</code> 实例</li>
<li>挂载上 EBS volume </li>
<li>确保挂载成功</li>
<li>执行下面的代码 3 次（中间不要间隔太长时间）<code>sudo /home/ubuntu/Project3_1/sysbench --test=fileio --file-total-size=10G --file-test-mode=rndrw --max-time=300 --max-requests=0 run</code></li>
<li>把结果写到 <code>runner.sh</code> 中</li>
<li>使用另外的磁盘类型进行测试</li>
</ol>
<blockquote>
<p>暂时不要删除 EBS volume，之后还有用</p>
</blockquote>
<p><strong>试验 2 (上表中 Scenarios 3 &amp; 4 )</strong></p>
<ol>
<li>启动一个 <code>ami-ca685ba0</code> 的 <code>m3.large</code> 实例</li>
<li>挂载上 EBS volume </li>
<li>确保挂载成功</li>
<li>执行下面的代码 3 次（中间不要间隔太长时间）<code>sudo /home/ubuntu/Project3_1/sysbench --test=fileio --file-total-size=10G --file-test-mode=rndrw --max-time=300 --max-requests=0 run</code></li>
<li>把结果写到 <code>runner.sh</code> 中</li>
<li>使用另外的磁盘类型进行测试</li>
</ol>
<p>测试的话用 <code>./runner.sh scaling</code>，确定无误后使用 <code>./submitter -a dawang</code> 来进行提交，代码运行完成后输入提交密码即可。</p>
<h2 id="HBase__u64CD_u4F5C"><a href="#HBase__u64CD_u4F5C" class="headerlink" title="HBase 操作"></a>HBase 操作</h2><p>Apache HBase 是一个开源版本的 Google BigTable 分布式存储系统，其特点是分布式，可拓展，高性能，为大数据而生，在 Hadoop Distributed File System (HDFS) 上工作。HBase 在不同的服务器上把文件保存为重复的块，HDFS 保证其扩展性和可靠性。</p>
<p>在 HBase 中，输入按照行列排列，如下图所示：</p>
<p><img src="/images/14562066176431.jpg" alt="HBase table 的典型架构"></p>
<p>HBase 中的每一行都有对应的 row key，类似于主键，必须是唯一的。HBase 会自动根据 row key 来排列数据，默认按照字节顺序排序。</p>
<p>如上图所示，每一行包括：<code>rowkey</code>, <code>column_family</code>, <code>column</code> 和 <code>timestamp</code>，所以整个的映射变成 <code>(rowkey, column family, column, timestamp) -&gt; value</code>。Rowkey 和 value 都是简单的字节，所以只要能序列化成字节的都可以保存在 cell 中。这些 cell 会按照字典序排列，这是一个非常重要的特性，使得 HBase 支持快速搜索。</p>
<p>HBase 中的每一列都有列名，还可以进一步组织成 column family。所有的 column family 成员拥有共同的前缀，如上图所示，列 Metadata:Type 和列 Metadata:Language 都是 Metadata column family 的成员，而列 Content:Data 则属于 Content family。默认来说用冒号来分隔 column family 的前缀，这个前缀必须由能够打印的字符组成，后面的部分可以是任何字节。</p>
<p><strong>HBase 操作</strong></p>
<p>HBase 有四个主要的操作：Get, Put, Scan, 和 Delete.</p>
<ul>
<li>Get 操作会返回指定行的所有 cell</li>
<li>Put 操作可以添加新的记录或者更新已有记录</li>
<li>Scan 操作会根据条件遍历多行记录</li>
<li>Delete 操作会移除一条记录</li>
</ul>
<p>Get 和 Scan 操作的返回都是排好序的，依据为 rowkey, column family, family 成员，和时间戳（也就是最新的值会在最前面）。默认来说，Get, Scan 和  Delete 操作都是在数据最新的版本上的（也可以指定其他版本的数据）。Delete 操作一般来说会删除整行，但是也可以删除指定的 cell。</p>
<p><strong>HBase 架构</strong></p>
<p>HBase 是以 HBase 节点集群来进行组织的，节点有两种类型：master 和 slave（也叫 RegionServers）</p>
<p><img src="/images/14562066977793.jpg" alt="HBase 集群架构"></p>
<p>HBase 会动态分配数据表，这样支持大量的并行访问。一个 HBase 表在太大时会被分成多个 Region，一个 HBase Region 是一个 HBase 表的子集，但是 rowkey 的范围是连续的。每个  RegionServer 可以保存多个 Regions，但是一个 Region 只会在一个 RegionServer 上。</p>
<p>虽然一个 Region 只会在一个 RegionServer 上，但是这不意味着该 Region 部分的数据只能存在于一个 RegionServer 上。事实上，因为 HDFS 的复制机制，每个 Region 都会在其他 RegionServer 上有几份一模一样的拷贝。想要了解更多？查看 <a href="http://hbase.apache.org/book.html" target="_blank" rel="external">HBase Reference Guide</a> 以及 <a href="https://blogs.apache.org/hbase/" target="_blank" rel="external">HBase 博客</a>.</p>
<p>HBase 使用 Apache ZooKeeper 来协调控制整个 HBase 集群。Apache ZooKeeper 需要做的事情有：选择 master 节点，寻找 -ROOT- catalog table 以及节点注册（当新的 RegionServer 加入的时候）。由 ZooKeeper 选择出来的 master 节点会处理诸如 region 分配，失败处理，负载均衡等任务。</p>
<p>HBase 使用 HDFS 作为存储，但是同样支持其他文件系统（本地文件系统，甚至 Amazon S3）。</p>
<p>这个 <a href="https://youtu.be/lUOFLa0DKdc" target="_blank" rel="external">HBase Demo</a> 视频会介绍 HBase 的基本使用，虽然视频中的 EMR 版本较旧，但是对我们这次的任务没有什么影响。</p>
<ul>
<li>Costs = Instance + EMR costs</li>
<li>进入 EMR 页面 -&gt; 创建集群 -&gt; 输入名字 -&gt; 开启关闭保护 </li>
<li>选择 S3 的 log bucket -&gt; 打上标签 -&gt; 去掉 pig 和 hive，改为 HBase </li>
<li>选择 spot -&gt; 指定 keypair -&gt; 需要等待一段时间开启</li>
<li>ssh 到 master public dns，注意这里用户名是 hadoop 而不是 ubuntu</li>
<li><code>hbase shell</code> -&gt; <code>&gt; help</code> 查看帮助 -&gt; <code>&gt; status</code> 查看状态</li>
<li><code>create &#39;users&#39;, &#39;info&#39;</code> 创建表格</li>
<li><code>describe &#39;users&#39;</code> 可以查看表格内容</li>
<li><code>put &#39;user&#39;, &#39;johndeo&#39;, &#39;info&#39;, &#39;regularUser&#39;</code> 插入一条记录</li>
<li><code>get &#39;users&#39;, &#39;johndoe&#39;</code> 获取一条记录</li>
<li><code>scan &#39;users&#39;</code> 遍历某个表并输出</li>
<li><code>count &#39;users&#39;</code> 统计表的行数</li>
</ul>
<blockquote>
<p>注意：EMR 很贵，最好使用 spot instance</p>
</blockquote>
<h3 id="u4F7F_u7528_EMR__u521B_u5EFA_HBase__u96C6_u7FA4"><a href="#u4F7F_u7528_EMR__u521B_u5EFA_HBase__u96C6_u7FA4" class="headerlink" title="使用 EMR 创建 HBase 集群"></a>使用 EMR 创建 HBase 集群</h3><p>我们将使用 EMR 创建 HBase 集群。HBase 使用 Hadoop Distributed File System (HDFS) 来存储数据。默认来说 AWS 会直接用 EC2 内置的存储给 HDFS 使用，下面是具体的使用步骤：</p>
<ol>
<li>启动 EMR 集群：1 master &amp; 1 core <ul>
<li>在创建页面中选择 “Go to advanced options”</li>
<li>确保所有的实例都是 m1.large</li>
<li>确保 EMR 集群和存放 <code>runner.sh</code> 的实例在同一个区域</li>
<li>选择 AMI version 3.11.0 (hadoop version 2).</li>
<li>移除所有的已有服务(Pig &amp; Hive)并选择安装 HBase version 0.94.</li>
<li>指定 key-pair 以便 SSH 到 master 实例，ssh 的时候注意用户名是 hadoop</li>
<li>不要忘记设置标签</li>
<li>开启 “termination protection” 和 “keep-alive”</li>
</ul>
</li>
<li>master 和 core 节点的安全组都允许所有流量，使用 Master public DNS 来进行连接</li>
<li>ssh 到 master 节点之后，运行 <code>hadoop dfsadmin -report</code> 检查 HDFS 的状态</li>
</ol>
<h3 id="u8F7D_u5165_u6570_u636E_u5230_HBase"><a href="#u8F7D_u5165_u6570_u636E_u5230_HBase" class="headerlink" title="载入数据到 HBase"></a>载入数据到 HBase</h3><p>HBase 支持多种数据导入方法，这里我们介绍 Bulk Load 方法。</p>
<p>最直接的载入办法可以是在 MapReduce job 中使用 <code>TableOutputFormat</code> 类，也可以使用client APIs，但是这可能不是最有效率，因为 API 不支持 bulk loading.</p>
<p>Bulk Importing 会越过 HBase API 直接写入到数据文件中(HFiles)。使用 bulk load 可以减少 CPU 和网络带宽的占用。<code>ImportTsv</code> 就可以完成这个任务，虽然原本是为 TSV (Tab Separated Value) 格式设计的，但是通过设置参数，同样支持 CSV 文件，步骤如下：</p>
<ol>
<li>把 TSV/CSV 格式的数据集上传到 HDFS (Hadoop Distributed File System)<ul>
<li>File System (FS) shell 支持基本的文件操作比如 <code>Local FS</code>, <code>HFTP FS</code>, <code>S3 FS</code> 等等，可以通过 <code>hadoop fs &lt;args&gt;</code> 来调用</li>
<li>从 S3 bucket 获取 <code>million_songs_metadata.csv</code> 文件<ul>
<li><code>mkdir P3_1</code></li>
<li><code>cd P3_1</code></li>
<li><code>wget https://s3.amazonaws.com/15319-p31/million_songs_metadata.csv</code></li>
</ul>
</li>
<li>把下载下来的文件保存到 HDFS 中以便导入，具体命令需要自己寻找</li>
<li>可以用 <code>hadoop fs -ls /path/containing/your/uploaded/file</code> 来检测是否上传成功</li>
</ul>
</li>
<li>打开 HBase shell (<code>HBase shell</code>)并新建一个名为 songdata 的表(使用 <code>create</code> 命令，后面跟 column family name 的名字)。建立成功之后使用 <code>exit</code> 命令退出</li>
<li>为 HBase 表准备好 HFiles。使用 <code>ImportTsv</code> 命令把文件 <code>million_songs_metadata.csv</code> 中的数据传到 HDFS 中，名为 <code>importtsv.bulk.outputHbase</code>。这些 StoreFiles 之后会被载入到 HBase 中。注意这里我们使用 <code>track_id</code> 作为 row key，其他的列会成为 column family name (这里使用 ‘data’)。要了解 <code>ImportTsv</code> 的更多信息，请参考 <a href="http://hbase.apache.org/0.94/book/ops_mgt.html#importtsv" target="_blank" rel="external">official reference</a>.</li>
<li>正常启动的话，我们可以看到 MapReduce 工作的进程</li>
<li>检查 Map 步骤的输出来验证结果。通常来说应该会与数据集中的数据数量相等。注意，对应的输出文件应该是不存在的（不然会导致任务失败）</li>
<li>前面所做的所有工作都只是为了把数据保存到 HBase 中，但是此时 HBase 的表仍旧是空的（还没有添加对应的记录）</li>
<li>需要使用 CompleteBulkLoad 工具来完成数据上传，参考官方文档来使用</li>
<li>现在可以验证数据是否成功上传，打开 HBase shell 然后用以下命令来查看 <code>scan &#39;songdata&#39;</code></li>
<li>用 Ctrl-C 结束输出</li>
</ol>
<p>当然，除了这个方法，也可以在 MapReduce job 中使用 <code>TableOutputFormat</code> 或者其他 HBase client API。</p>
<h3 id="HBase__u67E5_u8BE2"><a href="#HBase__u67E5_u8BE2" class="headerlink" title="HBase 查询"></a>HBase 查询</h3><p>与 MySQL 类似，HBase 提供了查询的工具。在 HBase 中，数据存在 column 中，多个 column 组成 column family。我们可以用下面的指令来进行查询：</p>
<p><code>scan ‘table_name’, {COLUMNS =&gt; [‘column1’, ‘column2’, …], FILTER =&gt; “(FILTER1) … (FILTER2)”}</code></p>
<p>我们来做一个和之前类似的查询，找到所有 <code>artist_name</code> 以 “The Beatles” 开头的记录（是一个前缀匹配，不是子串匹配），查询如下：</p>
<p><code>scan &#39;songdata&#39;, {COLUMNS =&gt; &#39;data:artist_name&#39;, FILTER =&gt; &quot;SingleColumnValueFilter(&#39;data&#39;, &#39;artist_name&#39;, = , &#39;regexstring:^The Beatles.*&#39;)&quot;}</code></p>
<p>这里的列名的格式是 <code>(column family name):(column qualifier name)</code>。并且返回的数据中只包含了 <code>artist_name</code> 的数据，如果我们想多看一些数据，在 COLUMNS 部分多加一些内容，如：</p>
<p><code>scan &#39;songdata&#39;, {COLUMNS =&gt; [&#39;data:artist_name&#39;, &#39;data:title&#39;], FILTER =&gt; &quot;SingleColumnValueFilter(&#39;data&#39;, &#39;artist_name&#39;, = , &#39;regexstring:^The Beatles.*&#39;)&quot;}</code></p>
<p>同样，我们也可以添加更多的 FILTER，用逻辑运算符 AND, OR, WHILE 等来进行组合。比如说，如果我们想在原来条件的基础上增加另一个条件：其 title 以 W 或者以 W 之后的字母开头，那么命令就可以这么写：</p>
<p><code>scan &#39;songdata&#39;, {COLUMNS =&gt; [&#39;data:artist_name&#39;, &#39;data:title&#39;], FILTER =&gt; &quot;SingleColumnValueFilter(&#39;data&#39;, &#39;artist_name&#39;, = , &#39;regexstring:^The Beatles.*&#39;) AND SingleColumnValueFilter(&#39;data&#39;, &#39;title&#39;, &gt;= , &#39;binaryprefix:W&#39;)&quot;}</code></p>
<p>另外提一点，在 FILTER 中使用了某一列，就需要在 COLUMNS 列表中也加入对应的列名，不然就会被忽略的，更多信息可以参阅<a href="http://www.cloudera.com/content/cloudera/en/documentation/core/latest/topics/admin_hbase_filtering.html" target="_blank" rel="external">这篇日志</a>.</p>
<h3 id="HBase_Java_API"><a href="#HBase_Java_API" class="headerlink" title="HBase Java API"></a>HBase Java API</h3><p>HBase 也有其 Java API，可以用来创建、查看、修改和删除表，同样也可以插入和查询。</p>
<p><strong>建立连接</strong></p>
<p>首先我们需要建立连接，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Configuration conf = HBaseConfiguration.create();</span><br><span class="line">conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, zookeeperAddress);</span><br><span class="line">conf.set(<span class="string">"hbase.zookeeper.property.clientport"</span>, <span class="string">"2181"</span>);</span><br><span class="line">HConnection conn = HConnectionManager.createConnection(conf);</span><br><span class="line">HTableInterface table = conn.getTable(tableName);</span><br></pre></td></tr></table></figure>
<p>前三行配置地址和端口，这里需要填写 master node 的 IP 地址。然后就可以创建 <code>HConnection</code> 并得到一个 <code>HTableInterface</code> 对象（用来处理特定 HBase 表）。</p>
<p>另一个创建 HBase table handler 的方法是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTable table = <span class="keyword">new</span> HTable(conf, tableName);</span><br></pre></td></tr></table></figure>
<p>不过在新版本中已经被弃用了（所以直接不写出来不就好了嘛）</p>
<p>最常见的操作是 Get 和 Scan，get 用来获取某一行，scan 用来对多行操作，一般来说 scan 比 get 慢。不过我们这里会使用 scan。</p>
<p>下面是一个简单的例子，我们打印出所有 <code>artist_name</code> 以 “The Beatles” 开头的记录。更多详细的使用方法请参考 <a href="https://hbase.apache.org/0.94/apidocs/" target="_blank" rel="external">HBase Java API 文档</a>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new Scan object. By calling the default constructor, the entire table will be scanned.</span></span><br><span class="line">Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Binary representation of the column family name</span></span><br><span class="line"><span class="keyword">byte</span>[] bColFamily = Bytes.toBytes(<span class="string">"data"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Binary representation of the column name.</span></span><br><span class="line"><span class="keyword">byte</span>[] bCol = Bytes.toBytes(<span class="string">"artist_name"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is used for regular expression matching. You should use different comparators based on specific requirements.</span></span><br><span class="line">RegexStringComparator comp = <span class="keyword">new</span> RegexStringComparator(<span class="string">"^The Beatles.*"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This defines the filtering rules of our Scan object.</span></span><br><span class="line">Filter filter = <span class="keyword">new</span> SingleColumnValueFilter(bColFamily, bCol, CompareFilter.CompareOp.EQUAL, comp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Associate the filtering rules to our Scan object.</span></span><br><span class="line">scan.setFilter(filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use this if your query will return multiple rows.</span></span><br><span class="line">scan.setBatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the scan result.</span></span><br><span class="line">ResultScanner rs = songsTable.getScanner(scan);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Each call of rs.next() will return one row.</span></span><br><span class="line"><span class="keyword">for</span> (Result r = rs.next(); r != <span class="keyword">null</span>; r = rs.next()) &#123;</span><br><span class="line">    <span class="comment">// r represents one row in the table. r.getValue returns the specific cell (determined by column family</span></span><br><span class="line">    <span class="comment">// and column name.</span></span><br><span class="line">    System.out.println(Bytes.toString(r.getValue(bColFamily, bCol)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cleanup</span></span><br><span class="line">rs.close();</span><br></pre></td></tr></table></figure>
<p>看看 <a href="http://hbase.apache.org/0.94/book/client.filter.html" target="_blank" rel="external">HBase tutorial on Client Request Filters</a> 对完成这部分的任务也很有帮助。</p>
<h3 id="u89E3_u9898_u653B_u7565-3"><a href="#u89E3_u9898_u653B_u7565-3" class="headerlink" title="解题攻略"></a>解题攻略</h3><p>这部分的任务就是完成 <code>runner.sh</code> 中的 17-21 题，需要改动的文件是 <code>HBaseTasks.java</code>。可以用下面的代码来运行 demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac HBaseTasks.java</span><br><span class="line">java HBaseTasks demo</span><br></pre></td></tr></table></figure>
<p>会打印出所有 <code>artist_name</code> 以 “The Beatles” 开头的记录（大小写敏感）</p>
<p>先把需要的文件 scp 到本地 <code>scp -i demo.pem ubuntu@ec2-54-209-165-121.compute-1.amazonaws.com:~/Project3_1/HBaseTasks.java ./</code></p>
<p>问题列表(17 题开始)：</p>
<ol>
<li>(17)找到以 “Total” 开头 “Water 结尾的歌名</li>
<li>(18)找到 “Kanye West” 的歌曲的歌名，名称以 “Apologies” 或 “Confessions” 开头，大小写敏感</li>
<li>(19)找到歌手名以 “Bob Marley” 为前缀的一首歌的歌名，长度大于 400，年份是 2000 年之后（包括 2000 年）</li>
<li>(20)找到歌手名包含 “Consequence” 的一首歌的歌名，歌名包含 “Family” 并且 <code>artist_hotttnesss</code> 要大于 1</li>
<li>(21)找到歌手名以 “Gwen Guthrie” 为前缀的一首歌的歌名，歌名包含 “Love” 但不包含 “Bitter” 或者 “Never”，年份为 1990</li>
</ol>
<p>然后按照前面的指引开一个 EMR，注意一定要开启 SSH，不然开了等于白开，开启之后连接上去 <code>ssh -i demo.pem hadoop@ec2-52-90-21-43.compute-1.amazonaws.com</code></p>
<p>然后用 <code>hadoop dfsadmin -report</code> 检查状态，不过说已经弃用这种命令写法了，如下：</p>
<p><img src="/images/14562658234752.jpg" alt=""></p>
<p>然后我们创建一个文件夹并下载对应的 csv 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir P3_1</span><br><span class="line"><span class="built_in">cd</span> P3_1</span><br><span class="line">wget https://s3.amazonaws.com/<span class="number">15319</span>-p31/million_songs_metadata.csv</span><br></pre></td></tr></table></figure>
<p>然后创建对应的 HDFS 目录，再把 csv 文件移过去：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir /dawang</span><br><span class="line">hadoop fs -mkdir /dawang/csv</span><br><span class="line">hadoop fs -put ./million_songs_metadata.csv /dawang/csv/</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">hadoop fs -ls /dawang/csv/</span><br></pre></td></tr></table></figure>
<p><img src="/images/14562663033381.jpg" alt="hadoop fs -ls 结果"></p>
<p>然后进入 HBase Shell 操作 <code>hbase shell</code></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">001</span>:<span class="number">0</span>&gt; create <span class="string">'songdata'</span>,<span class="string">'data'</span></span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">002</span>:<span class="number">0</span>&gt; list</span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">003</span>:<span class="number">0</span>&gt; describe <span class="string">'songdata'</span></span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">004</span>:<span class="number">0</span>&gt; exit</span><br></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<p><img src="/images/14562664950809.jpg" alt=""></p>
<p>然后就需要具体的导入了，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hbase org.apache.hadoop.hbase.mapreduce.ImportTsv -Dimporttsv.separator=<span class="string">","</span> -Dimporttsv.bulk.output=/hfile_p31 -Dimporttsv.columns=HBASE_ROW_KEY,data:title,data:song_id,data:release,data:artist_id,data:artist_mbid,data:artist_name,data:duration,data:artist_familiarity,data:artist_hotttnesss,data:year songdata /dawang/csv/million_songs_metadata.csv</span><br><span class="line"></span><br><span class="line">hbase org.apache.hadoop.hbase.mapreduce.LoadIncrementalHFiles /hfile_p31 songdata</span><br></pre></td></tr></table></figure>
<p>完成之后测试一下 <code>hbase shell</code>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">001</span>:<span class="number">0</span>&gt; scan <span class="string">'songdata'</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/14562672790636.jpg" alt="结果输出"></p>
<p>有很多需要注意的地方，尤其是比较字符串的时候，有些坑是一定要踩的（爆炸感谢 @jiexing）。</p>
<p>测试的话用 <code>./runner.sh hbase</code>，确定无误后使用 <code>./submitter -a dawang</code> 来进行提交，代码运行完成后输入提交密码即可。</p>
<p>一些需要注意的地方：</p>
<ol>
<li>Java 代码中需要填写 HBase 的 master node 的 dns</li>
<li>每题的答案在一行里输出</li>
<li>设置正确的日志级别来防止不必要的输出</li>
</ol>
<blockquote>
<p>SCAN 操作是 O(N) 的，GET 操作是 O(logN)，比较好的方式是，通过精心设计的数据库，用两次 GET 操作拿到起始和结束的 rowkey，这样就有极大的效率提高，详情参考<a href="https://blog.cloudera.com/blog/2013/04/how-scaling-really-works-in-apache-hbase/" target="_blank" rel="external">这里</a></p>
</blockquote>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.runoob.com/linux/linux-comm-join.html" target="_blank" rel="external">Linux join命令</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>从这一课起，我们要开始使用数据库了。通过数据库和文件的性能对比以及 SQL 与 NoSQL 的对比，学会选择最合适的技术。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="数据库" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="文件" scheme="http://wdxtub.com/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[How to Speak]]></title>
    <link href="http://wdxtub.com/2016/02/22/how-to-speak/"/>
    <id>http://wdxtub.com/2016/02/22/how-to-speak/</id>
    <published>2016-02-22T14:14:09.000Z</published>
    <updated>2016-02-22T14:27:35.000Z</updated>
    <content type="html"><![CDATA[<p>因为要当助教的缘故，需要进行语言培训，其中一部分就是如何做展示，这篇日志主要介绍相关的技巧，主要来源自 MIT 的 Patrick Winston 的『How to Speak』小课程。</p>
<a id="more"></a>
<hr>
<h2 id="u5982_u4F55_u5F00_u59CB"><a href="#u5982_u4F55_u5F00_u59CB" class="headerlink" title="如何开始"></a>如何开始</h2><ul>
<li>了解知识本身加上练习，可以弥补大部分天赋上的差距</li>
<li>不要用讲笑话来开头，因为听众其实还没有准备好 </li>
<li>可以用一个承诺来开头，比方说告诉听众，听完我的演讲你们会得到很多有用的东西，这能让听众意识到你要说的内容的价值，并更加认真去听</li>
<li>列出大纲，第一告诉大家演讲要开始了，第二用清晰的结构让听众意识到现在所处的位置</li>
</ul>
<h2 id="u56DB_u5927_u65B9_u6CD5"><a href="#u56DB_u5927_u65B9_u6CD5" class="headerlink" title="四大方法"></a>四大方法</h2><ul>
<li>Cycling：重复去说一个事情，一次一次又一次<ul>
<li>从心理学角度来看，重复有助于形成长期记忆</li>
<li>从概率角度来看，重复可以让之前走神没听到的听众听到</li>
</ul>
</li>
<li>Verbal punctuation：用明确的分隔词来界定架构（首先，其次，等等）<ul>
<li>能够让因为走神不知道听到哪里的人重新跟上节奏</li>
</ul>
</li>
<li>Near-Miss：在解释复杂概念的时候，用具体的类似的例子，来清晰界定概念的范围<ul>
<li>比如说要介绍正方形的话，可以顺带介绍长方形，并指出为什么长方形不是正方形，这样就有了明确的区分条件</li>
</ul>
</li>
<li>Ask Quesitions：用常见且易于回答的问题来引导听众<ul>
<li>一般来说等待 5 秒钟，虽然对于演讲者来说感觉很长，但其实对于回答问题的来说很短    </li>
<li>注意，目的不是刁难人，而是让大家跟上演讲的节奏</li>
</ul>
</li>
</ul>
<h2 id="u65F6_u95F4_u548C_u5730_u70B9"><a href="#u65F6_u95F4_u548C_u5730_u70B9" class="headerlink" title="时间和地点"></a>时间和地点</h2><ul>
<li>最佳时间是早上十点半，如果要在下午三点之后进行演讲，最好准备些吃的，帮助听众补充能量，集中精神</li>
<li>要足够明亮，如果灯光太暗的话，听众容易睡着</li>
<li>尽量要选择人能坐满的地方，空着的位置很影响效果</li>
</ul>
<h2 id="u4F7F_u7528_u9ED1_u677F"><a href="#u4F7F_u7528_u9ED1_u677F" class="headerlink" title="使用黑板"></a>使用黑板</h2><ul>
<li>除了语言系统，视觉系统也是我们学习理解新知识非常重要的输入，利用黑板可以增加视觉上的冲击，帮助听众更好地理解内容</li>
<li>可以在黑板上写写画画，可以列表用作大纲，更重要的是，不用担心手放在哪里了，可以指着黑板上具体的内容进行讲述，就很自然</li>
</ul>
<h2 id="u4F7F_u7528_u6295_u5F71_u4EEA"><a href="#u4F7F_u7528_u6295_u5F71_u4EEA" class="headerlink" title="使用投影仪"></a>使用投影仪</h2><ul>
<li>应该…<ul>
<li>具体列出每一部分的标题</li>
<li>使用不同的颜色</li>
</ul>
</li>
<li>不应该…<ul>
<li>纯粹读 PPT（听众认字儿）</li>
<li>站到一边（你才是演讲的中心，而不是 PPT，要让观众把注意力集中在你身上）</li>
<li>把指点棒甩来甩去，分散注意力，所以干脆直接用手就好</li>
<li>遮住部分内容然后再掀开，这会让部分观众不爽</li>
</ul>
</li>
</ul>
<h2 id="u9053_u5177"><a href="#u9053_u5177" class="headerlink" title="道具"></a>道具</h2><ul>
<li>使用道具来增加演示效果，但是注意不要喧宾夺主</li>
</ul>
<h2 id="u98CE_u683C"><a href="#u98CE_u683C" class="headerlink" title="风格"></a>风格</h2><ul>
<li>从成功的演讲者身上学到适合自己的方法，而不是照搬</li>
<li>可以考虑的：用自己的特质（个性化装束）以及讲故事来吸引听众</li>
</ul>
<h2 id="u5982_u4F55_u7ED3_u5C3E"><a href="#u5982_u4F55_u7ED3_u5C3E" class="headerlink" title="如何结尾"></a>如何结尾</h2><ul>
<li>不要长篇大论说谢谢</li>
<li>可以用玩笑来结尾</li>
<li>提醒听众开头所提到的承诺，点题</li>
<li>Salute the audience</li>
</ul>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://vimeo.com/101543862" target="_blank" rel="external">How to Speak: Lecture Tips from Patrick Winston</a></li>
<li><a href="http://sixminutes.dlugan.com/speaking-tips-patrick-henry-winston-speak/" target="_blank" rel="external">How to Speak: 7 Speaking Tips from Patrick Henry Winston</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为要当助教的缘故，需要进行语言培训，其中一部分就是如何做展示，这篇日志主要介绍相关的技巧，主要来源自 MIT 的 Patrick Winston 的『How to Speak』小课程。</p>]]>
    
    </summary>
    
      <category term="技巧" scheme="http://wdxtub.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="演讲" scheme="http://wdxtub.com/tags/%E6%BC%94%E8%AE%B2/"/>
    
      <category term="英语" scheme="http://wdxtub.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C 格致余论 2 - Category]]></title>
    <link href="http://wdxtub.com/2016/02/21/dive-in-objc-2/"/>
    <id>http://wdxtub.com/2016/02/21/dive-in-objc-2/</id>
    <published>2016-02-22T01:07:23.000Z</published>
    <updated>2016-02-22T03:02:14.000Z</updated>
    <content type="html"><![CDATA[<p>Objective-C 中的 Category 和 Swift 中的 Extension 还是挺类似的，但是仍有一些区别，所以具体了解一下，也是有必要的。</p>
<a id="more"></a>
<hr>
<p>一般来说，在 C++ 或者 Java 中，如果我们想改变一个已有类型的行为，可以继承之后重写或者添加对应的方法。不过在 Objective-C 中，可以不用继承，就直接添加新的方法或替换已有的方法。</p>
<p>当然，前一篇文章中提到过 <code>class_addMethod</code> 方法，不过还是用 category 更加规范和方便。这里需要注意，正常情况下，我们只能添加新的方法，却不能增加新的变量。</p>
<h2 id="u4EC0_u4E48_u65F6_u5019_u7528"><a href="#u4EC0_u4E48_u65F6_u5019_u7528" class="headerlink" title="什么时候用"></a>什么时候用</h2><p>一般来说，继承是最正规的做法，可以很方便地重用。但是也有一些情况，继承不大容易，这时候用 category 就比较合适了，比如：</p>
<ol>
<li>Foundation 对象</li>
<li>用工厂模式创造的对象</li>
<li>单例对象</li>
<li>在 app 中已经使用很多次的自定对象（继承的话很容易因为漏改而出错）</li>
</ol>
<p>下面我们分别介绍这几种情况</p>
<h3 id="Foundation__u5BF9_u8C61"><a href="#Foundation__u5BF9_u8C61" class="headerlink" title="Foundation 对象"></a>Foundation 对象</h3><p>Foundation 中的类，比如 <code>NSString</code>, <code>NSArray</code>, <code>NSDictionary</code> 除了可以通过 Objective-C 的接口调用外，其实也可以用另一个 C 的接口调用。例如 <code>NSString</code> 会对应到 Core Foundation 中的 <code>CFStringRef</code>。</p>
<p>所以在实际生成的时候，其实具体的类别是难以确定的，也就是说，我们继承了一个 <code>NSString</code> 类创建了一个 <code>MyString</code>， 新建实例的时候，其实并不能保证新建的就是一个 <code>MyString</code>，所以这种情况下，不是很适合用继承，而是 category 直接进行拓展比较合适。</p>
<h3 id="u5DE5_u5382_u6A21_u5F0F_u5BF9_u8C61"><a href="#u5DE5_u5382_u6A21_u5F0F_u5BF9_u8C61" class="headerlink" title="工厂模式对象"></a>工厂模式对象</h3><p>工厂模式本身的机制就是，不用关心具体的子类，只要传入所需要的类型，会自动生成我们需要的类。</p>
<p>就拿 <code>UIButton</code> 来说，即使我们继承了，在具体生成的时候，也不能保证得到我们继承后的子类，从这个角度来看，和上一个情境是类似的。</p>
<p>或者说，我们想要改变一个父类的行为，让所有的子类都增加新的方法，当时实际上我们没办法改动这个父类的时候，就应该采用 category。</p>
<p>这种因为具体生成什么类不确定的情况，会导致很多奇奇怪怪的问题，一定要小心使用，或者直接用 Swift，真心的。</p>
<h3 id="u5355_u4F8B_u5BF9_u8C61"><a href="#u5355_u4F8B_u5BF9_u8C61" class="headerlink" title="单例对象"></a>单例对象</h3><p>这也是非常出名的设计模式了，比如 <code>UIApplication</code>, <code>NSUserDefault</code>, <code>NSNotificationCenter</code> 等都是这种设计。因为单例实现机制的问题，使其本身很难被继承，我们先来看看如何声明一个单例。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (MyClass *)sharedInstance;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现部分</span></span><br><span class="line"><span class="keyword">static</span> MyClass *sharedInstance = <span class="literal">nil</span>;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">+ (MyClass *)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> sharedInstance ? sharedInstance : (sharedInstance = [[MyClass alloc] init]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>(注意，其实一般 Singleton 会使用 GCD 的 <code>dispatch_once</code> 实现，不过暂时为了理解简单，先用上面的写法)</p>
<p>假如我们继承 MyClass 之后却没有重写覆盖 sharedInstance 方法，首先可能还是会返回原来的对象，另外如果我们覆盖的话，那么可能就会漏过放在原来的实现中的一些操作（因为我们可能看不到源代码），产生与预期不符的结果。</p>
<h2 id="Category__u7684_u5199_u6CD5"><a href="#Category__u7684_u5199_u6CD5" class="headerlink" title="Category 的写法"></a>Category 的写法</h2><p>语法还是很简单的，只要记住括号里是 category 的名称即可，我们用给 NSString 添加一个 <code>strokeCompare:</code> 为例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> (<span class="title">CustomCompare</span>)</span></span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>)strokeCompare:(<span class="built_in">NSString</span> *)anotherString;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSString</span> (<span class="title">CustomCompare</span>)</span></span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>)strokeCompare:(<span class="built_in">NSString</span> *)anotherString </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLocale</span> *strokeSortingLocale = [[[<span class="built_in">NSLocale</span> alloc]</span><br><span class="line">                    initWithLocaleIdentifier:<span class="string">@"zh@collation=stroke"</span>]</span><br><span class="line">                    autorelease];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> compare:anotherString</span><br><span class="line">                 options:<span class="number">0</span></span><br><span class="line">                   range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, [<span class="keyword">self</span> length])</span><br><span class="line">                  locale:strokeSortingLocale];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>惯例的命名方式是 <code>NSString+CustomCompare.h</code> 和 <code>NSString+CustomCompare.m</code></p>
<p>除了添加新方法，以下情况也很适合用 category</p>
<ul>
<li>将一个很大的类切分成几个部分，代码组织更清晰，也更易于跨平台</li>
<li>替换原来的实现，实现方法的重写，但是这种方式比较危险，推荐不要使用</li>
</ul>
<h2 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h2><p>另一个类似的设计是 extensions，可以认为 extensions 是一个没有名字的 category，在 extensions 中定义的方法，需要放在原本的类的实现中，是类名后面跟一对空括号，下面是一个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span>()</span></span><br><span class="line">- (<span class="keyword">void</span>)doSomething;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">- (<span class="keyword">void</span>)doSomething</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p> 具体有什么用呢，比方说可以：</p>
<ul>
<li>拆分 header</li>
<li>管理私有方法</li>
</ul>
<p>Swift 中的做法就更加简单粗暴，直接用类名，加上不同的关键字即可，如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，extension 也可以用来扩展 protocol 和 struct，不过这里暂时先不展开。</p>
<h2 id="u589E_u52A0_u53D8_u91CF_u4E0E_u5C5E_u6027"><a href="#u589E_u52A0_u53D8_u91CF_u4E0E_u5C5E_u6027" class="headerlink" title="增加变量与属性"></a>增加变量与属性</h2><p>虽然前面提到不能增加变量或者属性，但是其实还是有办法的，既然我们是用 virtual table 来记录相关的方法，同样可以用另一个表格来记录相关的变量和方法嘛，这就是 Associated Objects。具体的使用方式如下：</p>
<p><img src="/images/14561097124357.jpg" alt=""></p>
<p>另外，虽然 category 不能增加成员变量，但是 extension 可以，甚至也可以直接在 <code>@implementation</code> 中加入。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.gitbook.com/book/zonble/kkbox-ios-dev/details" target="_blank" rel="external">KKBOX iOS/Mac OS X 基本开发教材</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html" target="_blank" rel="external">Customizing Existing Classes</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html" target="_blank" rel="external">Category</a></li>
<li><a href="http://nshipster.com/associated-objects/" target="_blank" rel="external">Associated Objects</a></li>
<li><a href="http://kingscocoa.com/tutorials/associated-objects/" target="_blank" rel="external">Objective-C Associated Objects</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/" target="_blank" rel="external">Objective-C Runtime Reference</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Objective-C 中的 Category 和 Swift 中的 Extension 还是挺类似的，但是仍有一些区别，所以具体了解一下，也是有必要的。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://wdxtub.com/tags/Mac/"/>
    
      <category term="Objective-C" scheme="http://wdxtub.com/tags/Objective-C/"/>
    
      <category term="category" scheme="http://wdxtub.com/tags/category/"/>
    
      <category term="iOS" scheme="http://wdxtub.com/tags/iOS/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iTerm2 Version3 动手玩]]></title>
    <link href="http://wdxtub.com/2016/02/21/iterm-v3-preview/"/>
    <id>http://wdxtub.com/2016/02/21/iterm-v3-preview/</id>
    <published>2016-02-21T13:53:13.000Z</published>
    <updated>2016-02-21T16:20:32.000Z</updated>
    <content type="html"><![CDATA[<p>经过 18 个月的等待，iTerm2 终于迎来了第三个主要版本！虽然现在还在最后的 Beta 测试，不过很多超强功能已经可以体验了。这篇文章就带大家大致浏览下新功能，以及非常强大的 Shell integration。</p>
<a id="more"></a>
<hr>
<h2 id="u4E3B_u8981_u65B0_u7279_u6027"><a href="#u4E3B_u8981_u65B0_u7279_u6027" class="headerlink" title="主要新特性"></a>主要新特性</h2><p>这一部分先概要介绍一下 3.0 中的主要改进（相当令人惊喜）</p>
<ul>
<li>全新的界面设计<ul>
<li>配合最新 OSX 的扁平设计风格，和系统的整体基调更搭，更好看</li>
</ul>
</li>
<li>Shell Integration<ul>
<li>基本上可以认为是 login script 的超级强化版本，可以做很多超有意思的事情：命令提示符、命令执行完成的通知、拖拽上传和下载文件等等，这一部分会在后面详细介绍</li>
</ul>
</li>
<li>自动切换 profile<ul>
<li>比方说在 ssh 到远程机器上，或者进入 root 权限，或者进入某些特定的文件夹都可以自动切换 profile（至少可以变个配色）</li>
</ul>
</li>
<li>Session 恢复<ul>
<li>简单来说就是不用 tmux 的 tmux</li>
</ul>
</li>
<li>内部显示图片<ul>
<li>可以使用 <code>imgcat</code> 脚本来在 iTerm2 中显示图片（甚至 GIF 都可以），这一部分会在后面详细介绍</li>
</ul>
</li>
<li>Badges<ul>
<li>这是一个全新的功能！可以在当前的命令行的右上角显示一些相关信息（比如当前的主机名称或者 git 分支名称），这一部分后面会详细介绍</li>
</ul>
</li>
<li>密码管理器<ul>
<li>内置的密码管理器可以保存密码到 Mac OS 的 keychain 中，甚至可以在需要输入密码的时候自动打开密码管理器</li>
</ul>
</li>
<li>撤销关闭（回到过去）<ul>
<li>假如不小心关闭了一个窗口，command + z 就可以重新打开它（记得要在 5 秒之内按）</li>
</ul>
</li>
<li>标签栏现在可以放在左边，即使有很多 tab 也不怕了</li>
<li>动态 Profiles，可以把 profiles 保存在 JSON 文件中</li>
<li>不会再找不到光标了，可以高亮当前行或者让其他颜色变暗，总而言之就是显眼</li>
<li>时间戳功能能够让我看到不同命令的执行时间以及错误在何时发生</li>
<li>捕获输出，基本上来说，可以用这个功能实现部分 IDE 的便捷操作了</li>
</ul>
<p>注：虽然我不用 Alfred，但是新版的 iTerm2 也提供了对应支持，具体请查看官网文档。</p>
<h2 id="u67E5_u770B_u56FE_u7247"><a href="#u67E5_u770B_u56FE_u7247" class="headerlink" title="查看图片"></a>查看图片</h2><p>非常简单，只要使用 <code>imgcat imagename</code> 就可以显示图片，例如：</p>
<p><img src="/images/14560666426444.jpg" alt=""></p>
<p>不过使用之前还是需要配置一下：</p>
<ol>
<li>下载两个对应插件 <a href="https://raw.github.com/gnachman/iTerm2/master/tests/imgls" target="_blank" rel="external">imgls</a> <a href="https://raw.github.com/gnachman/iTerm2/master/tests/imgcat" target="_blank" rel="external">imgcat</a></li>
<li>去掉后缀名，把文件拷贝到 <code>/usr/local/bin</code> 中，并修改权限 <code>chmod 755 /usr/local/bin/imgls /usr/local/bin/imgcat</code></li>
</ol>
<p>然后就可以使用啦，如上图所示。另外一种用法是 <code>cat avatar.jpg | imgcat</code>，也是同样的效果：</p>
<h2 id="Badges"><a href="#Badges" class="headerlink" title="Badges"></a>Badges</h2><p>简单来说就是显示当前终端的信息，如下所示</p>
<p><img src="/images/14560679607791.jpg" alt=""></p>
<p>具体的设置也很简单，如果要像我这样显示的话，在 <code>Preferences&gt;Profiles&gt;General&gt;Badge</code> 输入 <code>\(session.username)@\(session.hostname)</code> 即可（这个依赖于 Shell Integration 功能）</p>
<p>更详细的文档可以查阅<a href="https://iterm2.com/badges.html" target="_blank" rel="external">这里</a></p>
<h2 id="Shell_Integration"><a href="#Shell_Integration" class="headerlink" title="Shell Integration"></a>Shell Integration</h2><p>这个算是重头戏了，不过需要先安装一下（支持 tcsh, zsh, bash 和 fish）。我是直接在菜单栏里选择 <code>iTerm2 &gt; Install Shell Integration</code> 进行安装的，实际上就是执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://iterm2.com/misc/install_shell_integration.sh | bash</span><br></pre></td></tr></table></figure>
<p>具体详细的文档在<a href="https://iterm2.com/shell_integration.html" target="_blank" rel="external">这里</a>，本文只挑选一些当下对我很有用的功能</p>
<h3 id="u5386_u53F2_u547D_u4EE4"><a href="#u5386_u53F2_u547D_u4EE4" class="headerlink" title="历史命令"></a>历史命令</h3><p>有四种方式可以查看：</p>
<ol>
<li><code>Edit&gt;Open Command History</code> (快捷键 Shift-Cmd-;)</li>
<li>自动完成功能（快捷键 Cmd-;）</li>
<li>Toolbet 中可以显示（这个后面介绍）</li>
<li>代码提示功能（View&gt;开启 Command Completion）</li>
</ol>
<p><img src="/images/14560694592327.jpg" alt="历史命令查看"></p>
<h3 id="Toolbelt"><a href="#Toolbelt" class="headerlink" title="Toolbelt"></a>Toolbelt</h3><p>在菜单栏中可以进行选择，然后就会出现在侧边栏，功能很多，很好用：</p>
<p><img src="/images/14560695283473.jpg" alt=""></p>
<p>选择之后的效果大概是：</p>
<p><img src="/images/14560695539493.jpg" alt=""></p>
<h3 id="u5BC6_u7801_u7BA1_u7406_u5668"><a href="#u5BC6_u7801_u7BA1_u7406_u5668" class="headerlink" title="密码管理器"></a>密码管理器</h3><p>我们先设置一个 trigger，如下图所示：</p>
<p><img src="/images/14560715131681.jpg" alt=""></p>
<p>然后在需要输入密码的时候，密码管理器会自动弹出：</p>
<p><img src="/images/14560715581287.jpg" alt=""></p>
<p>选择对应的帐号密码然后点击 Enter Password，就可以免去输入密码的烦恼了。</p>
<hr>
<p>还有很多功能没有摸索出来，网上的资料也比较少，以后有机会再慢慢补充吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>经过 18 个月的等待，iTerm2 终于迎来了第三个主要版本！虽然现在还在最后的 Beta 测试，不过很多超强功能已经可以体验了。这篇文章就带大家大致浏览下新功能，以及非常强大的 Shell integration。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://wdxtub.com/tags/Mac/"/>
    
      <category term="iTerm2" scheme="http://wdxtub.com/tags/iTerm2/"/>
    
      <category term="终端" scheme="http://wdxtub.com/tags/%E7%BB%88%E7%AB%AF/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C 格致余论 1 - Selector]]></title>
    <link href="http://wdxtub.com/2016/02/20/dive-in-objc-1/"/>
    <id>http://wdxtub.com/2016/02/20/dive-in-objc-1/</id>
    <published>2016-02-21T03:50:09.000Z</published>
    <updated>2016-02-22T00:56:48.000Z</updated>
    <content type="html"><![CDATA[<p>Selector 作为 Objective-C 中一个非常重要的概念，虽然在 Swift 中几乎已经不见踪影，但是在某些混编的项目中仍旧起到举足轻重的作用，所以仍然有必要深入理解一下。</p>
<a id="more"></a>
<hr>
<h2 id="Selector__u662F_u4EC0_u4E48"><a href="#Selector__u662F_u4EC0_u4E48" class="headerlink" title="Selector 是什么"></a>Selector 是什么</h2><p>所谓对概念的掌握，一定是能够用简短的语言描述出核心含义。并且还要理解这个概念的应用场景和常见上下文，这才算是『掌握』。</p>
<p>在我的理解来看，所谓 selector，实际上是函数指针的一种实现形式，我们用一个 C string 来表示对象中的某个函数，所以就可以把这个函数作为参数，传到其他的方法中去进行调用。</p>
<p>为了理解 selector，就先要搞明白，Objective-C 中的 Object，或者说 Class，到底是什么。我们知道 C 语言中是没有『类』这个概念的，只有 struct，所以 Objective-C 的 Class 在编译时会变成 C struct，Class 中包含的方法也会转换成 C function。之后在运行的时候，runtime 会建立起从 Objective-C Method 到 C function 的映射（可以认为是一个 virtual table）。</p>
<p>举个例子，我们写了一个简单的类</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Wdx</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>编译之后会变成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> mode;</span><br><span class="line">&#125; Wdx;</span><br></pre></td></tr></table></figure>
<p>所以你会发现，其实用无论用 Objective-C 还是 C 的方式进行调用，都没有问题：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wdx *wdx = [[Wdx alloc] init];</span><br><span class="line">wdx-&gt;mode = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>具体发生了什么？其实也很简单。Runtime 会为每个类准备一个 virtual table，里面是一个个键值对，key 称为 selector，类型是 <code>SEL</code>，value 实际上是 C function 的函数指针，类型是 <code>IMP</code>。而这里的 <code>SEL</code> 类型实际上就是 C string，可以用下面语句来进行输出：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, (<span class="keyword">char</span> *)(<span class="keyword">@selector</span>(doSomething)));</span><br></pre></td></tr></table></figure>
<p>了解了这个之后，我们就会发现，实际上调用某个方法，至少有以下三种方式：</p>
<ol>
<li>直接通过对象进行调用：<code>[myObject doSomething];</code></li>
<li>通过 <code>performSelector:</code> 调用：<code>[myObject performSelector:@selector(doSomething)];</code><ul>
<li>这里 <code>performSelector</code> 是基类 <code>NSObject</code> 的方法</li>
</ul>
</li>
<li>使用 <code>objc_msgSend</code> 调用：<code>objc_msgSend(myObject, @selector(doSomething), NULL);</code></li>
</ol>
<p>这里一定要清楚的意识到，其实一个类中有什么方法，是在 runtime 里决定的，既然如此，肯定有某种方法动态添加方法（比如说 category 和 swift 中的 extension，不过这里不展开）</p>
<p>也是因为这个机制，所以编译的时候，即使编译器没有发现类中对应的方法，也只是会发出警告而已；甚至如果使用 <code>performSelector:</code> 的话，连警告的不会有，只有在运行的时候才会发生 unrecognized selector sent to instance 错误导致程序崩溃。</p>
<p>比方说，我们可以通过 <code>class_addMethod</code> 方法来动态给一个类添加方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> myMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个文件</span></span><br><span class="line"><span class="preprocessor"># import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">class_addMethod([MyClass class], <span class="keyword">@selector</span>(myMethod), (IMP)myMethodIMP, <span class="string">"v@:"</span>);</span><br></pre></td></tr></table></figure>
<p>接下来就可以这么用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass *myObejct = [[MyClass alloc] init];</span><br><span class="line">[myObject myMethod];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然，直接这么做 Xcode 会给出警告的，这里只是用来介绍基本原理，实际开发中除非确实需要，否则不要这么做</p>
</blockquote>
<h2 id="Selector__u7528_u5728_u54EA"><a href="#Selector__u7528_u5728_u54EA" class="headerlink" title="Selector 用在哪"></a>Selector 用在哪</h2><p>因为 selector 可以看做是函数的另一个名字，所以很多需要调用函数或者建立连接的地方，都可以用到，以下是一些具体的使用场景</p>
<h3 id="Target/Action__u6A21_u5F0F"><a href="#Target/Action__u6A21_u5F0F" class="headerlink" title="Target/Action 模式"></a>Target/Action 模式</h3><p>这个模式非常常用，比方说我们新建的一个按钮，通过把 controller 中对应的 IBAction 方法和它连接，整个过程就是一个 Target/Action 模式，这个 controller 是 Button 的 target，而对应执行的方法，就是 action。</p>
<p>所以现在我们知道，其实在 storyboard 中做得代码和界面元素的连接，实际上就是建立一个 Target/Action 模式。不过 UIKit，也就是 iOS 上的 Target/Action 会稍微复杂一些（因为可以一次建立多个），这里用 AppKit 做例子（一次建立一个），比方说我们想要让一个按钮有自定义的行为，可以这么做：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyButton</span> : <span class="title">NSView</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> target;</span><br><span class="line">    SEL action;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">IBOutlet</span> <span class="keyword">id</span> target;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) SEL action;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyButton</span></span></span><br><span class="line">- (<span class="keyword">void</span>)mouseDown:(<span class="built_in">NSEvent</span> *)e</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> mouseDown:e];</span><br><span class="line">    [target performSelector:action withObject:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@synthesize</span> target, action;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面代码的意思是，在鼠标按下的时候，执行之前指定的 action，所以整个绑定的过程用下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[(MyButton *)button setTarget:<span class="keyword">self</span>];</span><br><span class="line">[(MyButton *)button setAction:<span class="keyword">@selector</span>(clickAction:)];</span><br></pre></td></tr></table></figure>
<p>我们可以看到在 Objective-C 中是用字符串来作为不同方法的标识符，在 C 语言会直接传递指针，其他抽象层级更高的语言有不同的处理方式，比如说把一段代码当做字符串传递，然后使用的时候去 evaluate，也可以把函数本身看做对象，直接像传递对象一样使用（也就是匿名函数），Objective-C 中的匿名函数实际上就是 block，不过这里不展开。</p>
<h3 id="u68C0_u67E5_method__u662F_u5426_u5B58_u5728"><a href="#u68C0_u67E5_method__u662F_u5426_u5B58_u5728" class="headerlink" title="检查 method 是否存在"></a>检查 method 是否存在</h3><p>这里一般用来配合向下兼容，比方说我们的代码需要调用一个新版本 iOS 才有的 API，那么最好先检查下对应方法是否存在，如果不存在，则做一些额外的处理，不然程序在较低版本的 iOS 就会崩溃，具体的检测方法也很简单，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> scale = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">if</span> ([[<span class="built_in">UIScreen</span> mainScreen] respondsToSelector:<span class="keyword">@selector</span>(scale)])&#123;</span><br><span class="line">    scale = [<span class="built_in">UIScreen</span>]<span class="variable">.scale</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过一般来说，在其他语言里，try catch 的方法是最常用的处理 method 是否存在的方式，不过因为 Objective-C 不算原生支持垃圾回收，try catch 可能会导致比较严重的内存泄露。好在 iOS 通过 runtime 提供了 ARC(Automatic Reference Conter) 来管理内存。</p>
<p>传统 Objective-C 使用 auto-release 的机制来释放内存（然而并不算太『自动』），会把要释放的内存放到下一轮 runloop 进行释放，这也是为什么不建议使用 try catch，因为实际上 try catch 是程序流中的非可控跳转，跳出了原来的 runloop，就会导致原来应该释放的内存没有释放。</p>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>另一个常见的用法是延迟调用某个方法，我们可以使用 <code>NSObject</code> 中的 <code>performSelector:withObject:afterDelay:</code> 在一定的延迟后调用某个方法，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(doSomething) withObject:<span class="literal">nil</span> afterDelay:<span class="number">1.0</span>];</span><br></pre></td></tr></table></figure>
<p>甚至还可以在方法执行之前取消方法的执行，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:<span class="keyword">self</span>];</span><br></pre></td></tr></table></figure>
<p>具体的实现方法可以是通过 <code>NSTimer</code>，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># timer 要做的事情</span></span><br><span class="line">- (<span class="keyword">void</span>)doSomething:(<span class="built_in">NSTimer</span> *)timer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Do Something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过 <code>doSomething:</code> 的 selector 来建立 timer：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span></span><br><span class="line">                          target:someObject</span><br><span class="line">                          selector:<span class="keyword">@selector</span>(doSomething:)</span><br><span class="line">                          userInfo:<span class="literal">nil</span></span><br><span class="line">                          repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<p>也可以通过 <code>NSInvocation</code> 来进行调用，实际上是把 target, action 和参数这三个东西包装成一个对象，然后进行调用，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMethodSignature</span> *sig = [MyClass instanceMethodSignatureForSelector: </span><br><span class="line">                           <span class="keyword">@selector</span>(doSomething:)];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:sig];</span><br><span class="line">[invocation setTarget:someObject];</span><br><span class="line">[invocation setSelector:<span class="keyword">@selector</span>(doSomething:)];</span><br><span class="line">[invocation setArgument:&amp;anArgument atIndex:<span class="number">2</span>];</span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span></span><br><span class="line">                          invocation:invocation</span><br><span class="line">                          repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<p>注意设置参数位置的时候要从 2 开始，参数 0 是 self, 参数 1 是 selector。</p>
<h3 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h3><p>通知的机制其实也依赖于 selector，相当于指定一个回调函数在接收到通知的时候执行对应的操作，这部分后面会专门介绍，这里就不过分展开了。</p>
<h3 id="u5728_u7EBF_u7A0B_u4E2D_u6267_u884C_u65B9_u6CD5"><a href="#u5728_u7EBF_u7A0B_u4E2D_u6267_u884C_u65B9_u6CD5" class="headerlink" title="在线程中执行方法"></a>在线程中执行方法</h3><p><code>NSObject</code> 实际上还有很多多线程执行的方法，如：</p>
<p><img src="/images/14560963965355.jpg" alt=""></p>
<p>一般来说，如果一个操作需要的时间比较多，应该放到不同线程去执行</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(doSomething) withObject:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>注意在线程中需要建立 auto-release pool，执行完毕之后通过 <code>performSelectorOnMainThread:withObjectwaitUntilDone:</code> 通知主线程，如</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSomething</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">        <span class="comment">// 在这里执行需要时间比较久的工作</span></span><br><span class="line">        [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(doAnotherThing)</span><br><span class="line">                                          withObject:<span class="literal">nil</span></span><br><span class="line">                                          waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u6570_u7EC4_u6392_u5E8F"><a href="#u6570_u7EC4_u6392_u5E8F" class="headerlink" title="数组排序"></a>数组排序</h3><p>我们实际上也可以把一个 comparator 传给排序函数，<code>NSString</code>, <code>NSDate</code>, <code>NSNumber</code>, <code>NSIndexPath</code> 都有 <code>compare:</code> 方法，可以用来进行排序，比较有用的方法是 <code>localizedCompare:</code>，会自动根据当前语言来排序。</p>
<p>这里简单列出两个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *sortedArray = [anArray sortedArrayUsingSelector:<span class="keyword">@selector</span>(localizedCompare:)];</span><br></pre></td></tr></table></figure>
<p>也可以利用 selector 让数组中的每个元素都做一次指定的操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[anArray makeObjectsPerformSelector:<span class="keyword">@selector</span>(doSomething)];</span><br></pre></td></tr></table></figure>
<h3 id="u4EE3_u66FF_if_else_/_switch"><a href="#u4EE3_u66FF_if_else_/_switch" class="headerlink" title="代替 if else / switch"></a>代替 if else / switch</h3><p>因为 selector 其实就是 C string，所以可以放在数组或者字典中备用，因为如此可以用来做条件选择来代替 if else 或者 switch，比如下面这个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(condition) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        [object doSomething];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        [object doAnotherThing];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以改写为</span></span><br><span class="line">[object performSelector:<span class="built_in">NSSelectorFromString</span>(@[<span class="string">@"doSomething"</span>, <span class="string">@"doAnotherThing"</span>][condition])];</span><br></pre></td></tr></table></figure>
<h3 id="u8C03_u7528_u79C1_u6709_API_08"><a href="#u8C03_u7528_u79C1_u6709_API_08" class="headerlink" title="调用私有 API"></a>调用私有 API</h3><p>这里的私有 API，值得就是官方文档里没有说明，但是实际上可以通过 <code>performSelector:</code> 来调用的内部方法，不过如果打算上架的话，是不能使用的，可以平时用来测试或了解系统本身的运作机制。</p>
<h2 id="u6CE8_u610F_u4E8B_u9879"><a href="#u6CE8_u610F_u4E8B_u9879" class="headerlink" title="注意事项"></a>注意事项</h2><p>使用 selector 时也有一些需要注意的地方，比方说我们使用 <code>super</code> 来调用父类的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">super</span> doSomething];</span><br></pre></td></tr></table></figure>
<p>会执行父类的 doSomething 方法，而如果是用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">super</span> performSelector:<span class="keyword">@selector</span>(doSomething)];</span><br></pre></td></tr></table></figure>
<p>实际的效果等同于 <code>[self doSomething]</code></p>
<h2 id="u4F18_u52BF_u4E0E_u9650_u5236"><a href="#u4F18_u52BF_u4E0E_u9650_u5236" class="headerlink" title="优势与限制"></a>优势与限制</h2><p>Selector 的机制本身有其便捷性，但是反过来，也造成了一定的限制。</p>
<p>在 Objective-C 中，一个对象的方法都会保存在 virtual table 中，而因为这个表是在 runtime 决定的，所以其实是非常动态的，比如说不用继承就可以增加方法，或者是直接交换不同的 selector 的指向（也就是 method swizzling）。</p>
<p>但是因为一个 selector 能且仅能对应一个方法，所以不会有 C++, Java, C# 中的重载功能，这也是为什么 Objective-C 的函数名称普遍比较长，毕竟不能根据参数列表来具体判断要执行的函数，只能在起名字上下功夫了。如果有同一个名称的方法，那么新的会覆盖旧的。</p>
<p>在 Objective-C 中，我们调用某个方法，实际上是在 virtual table 中找寻对应这个 selector 的方法，而 C++ 或 Java 则是直接指定执行 vitual table 中的某个方法。问题就来了，每次函数调用都要查表，那效率肯定不会很高，这也是为什么之前 Objective-C 一直不流行的原因。</p>
<p>不过这样做也有好处，实际上 Objective-C 没有所谓固定版本的 runtime，只要 selector 不变，通过查表一样可以找到，新系统不用保留旧系统的库，避免了 C++ 等语言中 <a href="https://zh.wikipedia.org/zh/DLL地獄" target="_blank" rel="external">dll 地狱</a>的问题</p>
<p>而最新的 Swift 中，实际上苹果放弃了这个做法，选择了和 C++, Java 类似的设计，这也是为什么 Swift 的性能反而会更好一些的原因，不过这样一样，就需要包含对应版本的 swift runtime 了，这也是为什么 swift 会出现更多因为版本不一致而导致的兼容问题的原因。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.gitbook.com/book/zonble/kkbox-ios-dev/details" target="_blank" rel="external">KKBOX iOS/Mac OS X 基本开发教材</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html" target="_blank" rel="external">Programming with Objective-C</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">Objective-C Runtime Programming Guide</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/DevPedia-CocoaCore/Selector.html" target="_blank" rel="external">Cocoa Core Competencies - Selector</a></li>
<li><a href="http://cocoasamurai.blogspot.tw/2010/01/understanding-objective-c-runtime.html" target="_blank" rel="external">Understanding the Objective-C Runtime</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Selector 作为 Objective-C 中一个非常重要的概念，虽然在 Swift 中几乎已经不见踪影，但是在某些混编的项目中仍旧起到举足轻重的作用，所以仍然有必要深入理解一下。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://wdxtub.com/tags/Mac/"/>
    
      <category term="Objective-C" scheme="http://wdxtub.com/tags/Objective-C/"/>
    
      <category term="iOS" scheme="http://wdxtub.com/tags/iOS/"/>
    
      <category term="selector" scheme="http://wdxtub.com/tags/selector/"/>
    
      <category term="理解" scheme="http://wdxtub.com/tags/%E7%90%86%E8%A7%A3/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
