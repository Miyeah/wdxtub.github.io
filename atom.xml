<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-04-02T02:44:55.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Prolog 快速入门]]></title>
    <link href="http://wdxtub.com/2016/04/01/prolog-first-step/"/>
    <id>http://wdxtub.com/2016/04/01/prolog-first-step/</id>
    <published>2016-04-02T01:02:45.000Z</published>
    <updated>2016-04-02T02:44:55.000Z</updated>
    <content type="html"><![CDATA[<p>Prolog 是一门声明式编程语言，也是最早成功的逻辑编程语言之一。只需提供 fact 和 inference，程序会替我们进行推断。甚至不需要知道怎么做，只要告诉计算机要做什么即可。比方说，用不到 20 行代码解决数独问题。</p>
<a id="more"></a>
<hr>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><ul>
<li>1972 年由 Alain Colmerauer 和 Phillipe Roussel 开发完成</li>
<li>基于数据库，数据由逻辑规则和关系组成</li>
<li>包含两个部分：一部分用于描述数据，另一部分用于查询数据</li>
</ul>
<p>在 Prolog 中，数据以逻辑规则的形式存在，下面是基本构建单元：</p>
<ul>
<li>事实：关于真实世界的基本断言（Babe 是一头猪，猪喜欢泥巴）</li>
<li>规则：关于真实世界中的一些事实的推论（如果一个动物是猪，那么它喜欢泥巴）</li>
<li>查询：关于真实世界的一个问题（Babe 喜欢泥巴吗）</li>
</ul>
<p>事实和规则被放入一个知识库(knowledge base)。Prolog 编译器将这个知识库编译成一种适于高效查询的形式。</p>
<p>这里我们在 ubuntu 下做实验，直接 <code>sudo apt-get install gprolog</code> 即可</p>
<h2 id="u7F16_u7A0B_u6A21_u578B"><a href="#u7F16_u7A0B_u6A21_u578B" class="headerlink" title="编程模型"></a>编程模型</h2><p>Prolog 中，一个词以小写字母开头，就是一个原子(atom)——类似于 Ruby 中的符号(symbol)的固定值，如果一个词以大写字母或下划线开头，那么它就是一个变量。变量的值可以改变，原则则不能。</p>
<p>下面是一个简单的例子，先创建一个文件（比如 <code>friends.pl</code>），输入以下内容</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">likes</span>(<span class="atom">wallace</span>, <span class="atom">cheese</span>).</span><br><span class="line"><span class="atom">likes</span>(<span class="atom">grommit</span>, <span class="atom">cheese</span>).</span><br><span class="line"><span class="atom">likes</span>(<span class="atom">wendolene</span>, <span class="atom">sheep</span>).</span><br><span class="line"></span><br><span class="line"><span class="atom">friend</span>(<span class="name">X</span>, <span class="name">Y</span>) :- \+(<span class="name">X</span> = <span class="name">Y</span>), <span class="atom">likes</span>(<span class="name">X</span>, <span class="name">Z</span>), <span class="atom">likes</span>(<span class="name">Y</span>, <span class="name">Z</span>).</span><br></pre></td></tr></table></figure>
<p>上面这个文件就是由事实和规则组成的知识库。前三条语句是事实，最后一条语句是一个规则。<code>wallace</code>, <code>grommit</code> 和 <code>wendolene</code> 都是原子，翻译过来就是</p>
<ul>
<li><code>wallace</code> 喜欢 <code>cheese</code></li>
<li><code>grommit</code> 喜欢 <code>cheese</code></li>
<li><code>wendolene</code> 喜欢 <code>sheep</code></li>
</ul>
<p>具体执行时，先输入 <code>gprolog</code>，然后输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- [<span class="string">'friends.pl'</span>].compiling /home/parallels/Documents/friends.pl <span class="keyword">for</span> byte code.../home/parallels/Documents/friends.pl compiled, <span class="number">5</span> lines <span class="built_in">read</span> - <span class="number">976</span> bytes written, <span class="number">6</span> ms(<span class="number">1</span> ms) yes</span><br></pre></td></tr></table></figure>
<p>这里 <code>| ?-</code> 是命令前面的提示符，类似于命令行前的 <code>$</code>，不过这么有个性的，我还是第一次见</p>
<h2 id="u4E60_u9898"><a href="#u4E60_u9898" class="headerlink" title="习题"></a>习题</h2><h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://fengdidi.github.io/blog/2011/11/15/di-1zhang-pei-zhi-kai-fa-huan-jing/" target="_blank" rel="external">笨办法学Prolog</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Prolog 是一门声明式编程语言，也是最早成功的逻辑编程语言之一。只需提供 fact 和 inference，程序会替我们进行推断。甚至不需要知道怎么做，只要告诉计算机要做什么即可。比方说，用不到 20 行代码解决数独问题。</p>]]>
    
    </summary>
    
      <category term="Prolog" scheme="http://wdxtub.com/tags/Prolog/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="语言" scheme="http://wdxtub.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Io 快速入门]]></title>
    <link href="http://wdxtub.com/2016/04/01/io-first-step/"/>
    <id>http://wdxtub.com/2016/04/01/io-first-step/</id>
    <published>2016-04-01T15:33:13.000Z</published>
    <updated>2016-04-02T01:02:26.000Z</updated>
    <content type="html"><![CDATA[<p>原型语言我接触得其实非常少，Io 和 JavaScript/Lua 一样，每个对象都是另一个对象的复制品。这部分暂时我的兴趣不是特别大，所以简要记录一下，以后有兴趣再学。</p>
<a id="more"></a>
<hr>
<ul>
<li>Io 语言于 2002 年由 Steve Dekorte 发明</li>
<li>基于原型的语言，每个对象都不是类的复制品</li>
<li>带有微型虚拟机和丰富并发特性的可嵌入语言来推广</li>
<li>拥有大量可定制语法和函数，以及强有力的并发模型</li>
<li>万事万物皆为消息，且每条消息都会返回另一接收消息的对象</li>
<li>没有关键字，只有少量在行为上接近于关键字的字符</li>
</ul>
<h2 id="u7F16_u7A0B_u6A21_u578B"><a href="#u7F16_u7A0B_u6A21_u578B" class="headerlink" title="编程模型"></a>编程模型</h2><blockquote>
<p>优势</p>
</blockquote>
<ul>
<li>灵活，可以快速创建出想要的语法</li>
<li>强大的、现代的并发库</li>
<li>占用空间小，但功能强大且灵活，应用在嵌入式领域</li>
<li>语法简洁，灵活</li>
</ul>
<blockquote>
<p>劣势</p>
</blockquote>
<ul>
<li>社区规模小</li>
<li>单线程性能较差</li>
</ul>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://iolanguage.org/" target="_blank" rel="external">官方网站</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>原型语言我接触得其实非常少，Io 和 JavaScript/Lua 一样，每个对象都是另一个对象的复制品。这部分暂时我的兴趣不是特别大，所以简要记录一下，以后有兴趣再学。</p>]]>
    
    </summary>
    
      <category term="Io" scheme="http://wdxtub.com/tags/Io/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="语言" scheme="http://wdxtub.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聪明人的枷锁]]></title>
    <link href="http://wdxtub.com/2016/03/31/smart-lock/"/>
    <id>http://wdxtub.com/2016/03/31/smart-lock/</id>
    <published>2016-03-31T18:31:02.000Z</published>
    <updated>2016-04-01T04:23:31.000Z</updated>
    <content type="html"><![CDATA[<p>小聪明到大智慧之间，有一条看不见的横沟，只能用天赋、坚持和勤奋来填。如果硬要说有技巧，恐怕就是『元学习』、『元思考』、『元实践』和『元创造』。</p>
<a id="more"></a>
<hr>
<h2 id="u806A_u660E_u4E86_u5417_uFF1F"><a href="#u806A_u660E_u4E86_u5417_uFF1F" class="headerlink" title="聪明了吗？"></a>聪明了吗？</h2><p>聪明固然是一件好事，但是一旦被别人被自己贴上了『聪明人』的标签，也就戴上了枷锁。外在的枷锁随着时间的推移逐渐会被移去，但是内在的枷锁，想要解开，就没那么容易了。</p>
<p>内在的枷锁主要体现在以下两个方面：</p>
<ol>
<li>做事情凭借直觉，大多数情况下都能完成得不错。可是直觉也有范围，一旦超出，因为平时没有培养正确做事的能力，往往不尽如人意。</li>
<li>做事情依赖个人，在学生时代作业考试甚至是小组项目都可以自己扛，可是个人能力再大也有范围，一旦超出，因为平时没有培养合作的能力，常常功亏一篑。</li>
</ol>
<p>直觉是可以培养的，合作是可以学习的。小聪明若是想要转变为大智慧，得利用自己的聪明，用不依赖聪明的方法，在正确做事的前提下，扩大自己的直觉范围，优化自己的合作机制。</p>
<p>遗憾的是，市面上大部分的书，到这里就结束了，剩下的不是猛灌鸡汤，就是列举一堆『看起来有用但是实际没用』的技巧，基本属于作者自己都没想明白就出来忽悠。</p>
<p>这篇文章想说的就是各类畅销书没说清楚的东西：</p>
<ol>
<li>正确学习的方法</li>
<li>正确思考的方法</li>
<li>正确实践的方法</li>
<li>正确创造的方法</li>
</ol>
<p>就像大贤得出世再入世一样，想要成为『大智慧』，首先得有点『小聪明』。注意，这里的『小聪明』和大家通常理解的不一样，指的是相对于『大』智慧的『小』聪明，而不是原来略带贬义的意思。成为『小聪明』的第一步，就是认清自己的思维模式，要想以聪明的方式思考问题，就得善用自己的长处，认识并完善自己的弱点。</p>
<p>另外正如《穷查理宝典》中所说的那样：『我们必须掌握许多知识，让它们在头脑中形成一个思维框架，在随后的日子里能自动地运用它们。与之相反，如果不努力去实践这种跨科学的方法，许多最聪明的人只会取得中等成就，甚至生活在阴影中』。</p>
<h2 id="u6B63_u786E_u5B66_u4E60"><a href="#u6B63_u786E_u5B66_u4E60" class="headerlink" title="正确学习"></a>正确学习</h2><blockquote>
<p>Data is not information. Information is not knowledge. Knowledge is not expertise. Expertise is not execution.</p>
</blockquote>
<p>广义来说，所有的学习都是自学，毕竟没有任何一种科技可以直接把知识『灌输』到我们脑中，即使有老师，我们仍然需要自己去学习。当我仔细审视『自学能力』的时候，发现有以下几个重要的组成部分：</p>
<ul>
<li>阅读能力 - 基础技能 <ul>
<li>广泛阅读，略读结合精读</li>
</ul>
</li>
<li>理解能力 - 在阅读能力基础上的初级技能<ul>
<li>提取核心思想，按照章节逻辑堆阅读进行总结</li>
</ul>
</li>
<li>检索能力 - 在理解能力基础上的中级技能<ul>
<li>围绕核心思想，寻找相关材料，从多方面看问题</li>
</ul>
</li>
<li>写作能力 - 由输入到输出的重要技能<ul>
<li>写作实际上是一个思考的过程。把思维中的想法用文字写下来，本身就是一个整理、分类的过程</li>
</ul>
</li>
<li>思考能力 - 在写作能力基础上的高级技能<ul>
<li>勤于琢磨思考该事情的目标、实质、意义，而后再据此去思考做好这件事情的方法，并挖掘出更深层次的意义</li>
</ul>
</li>
<li>实践能力 - 把学习转化为价值的核心技能<ul>
<li>能够举一反三，能把所学应用于实践，并根据实际情况调整前进的方向</li>
</ul>
</li>
</ul>
<p>一定要脱离『学霸/学渣』的思维定式。学校的教育体系本来就是有缺陷的，我们需要做的就是通过自学能力，去弥补那些自己感兴趣但学校从未教授的东西。这样看来，我们应该成为『沙盒游戏』中的『自由探索者』，不要限定自己的角色，也不要被学校、专业所限制。多学科视角的思考方法能产生某种「共奏效应」，发现原本无法发现的深度见解。</p>
<p>学习关于学习本身的知识，就是元学习。</p>
<h2 id="u6B63_u786E_u601D_u8003"><a href="#u6B63_u786E_u601D_u8003" class="headerlink" title="正确思考"></a>正确思考</h2><blockquote>
<p>So avoid the temptation to master all the skills you need before taking on a challenge. </p>
</blockquote>
<p>应试教育，或者说以考试制度为核心的教育体系中，学生会自然而然被灌输『标准答案』的概念，写对有分写错没分，每个问题对应一个标准答案就被植入到我们的脑中。小聪明可能可以每次都填上标准答案，但大智慧会以标准答案为起点，开始探索的旅程。</p>
<p>差异在哪里？在于『思考无固定答案』的习惯。把纸上的问题映射到现实问题中，培养独立思考的能力，得到自己的答案。这里有一点需要强调，就是『独立』。思考时不要依靠网络，毕竟思考是思考，搜索是搜索。如果总是依赖网络，一旦遇到搜不出来的情况，就很难找到解决办法了。</p>
<p>当然，在有了自己的思考之后，还是需要借助搜索的力量，更加全面地看待问题。这个过程中千万不能『囫囵吞枣』，信息需要经过考虑、推敲后才能转化为想法。不同人看待同样的信息角度不同，得出的结论也不同，相信自己的判断，确认信息，独立思考，不能偷懒。我们还需要时刻拥抱不确定性，越是不习惯，越是要让自己站在正反两面去思考分析问题。</p>
<p>思考的时候一定要有的放矢，意识流看起来很美，但是不利于交流，思考的输出应当是他人容易重视、记住和接受的，也就是要有：</p>
<ul>
<li>逻辑推理能力 - 论点分解或总结</li>
<li>时间管理能力 - 区分优先性</li>
<li>交流能力 - 加强说服力</li>
</ul>
<p>至于思考的结果是对是错，反而不是重要的。一旦出现错误时，要学会追踪当初的思维轨迹，找到哪里出了差错，经验——错误的归纳模式是人类最根本也最可靠的学习方法。</p>
<p>思考关于思考本身的东西，就是元思考。</p>
<h2 id="u6B63_u786E_u5B9E_u8DF5"><a href="#u6B63_u786E_u5B9E_u8DF5" class="headerlink" title="正确实践"></a>正确实践</h2><blockquote>
<p>Whenever you can, as long as the water’s not too far over your head, just jump in, and figure it out as you go.</p>
</blockquote>
<p>知行合一，可能是正确实践的终极奥义。在实践的过程中，一定要时不时问自己下面几个问题：</p>
<ul>
<li>正在解决的问题是我需要解决的问题吗？<ul>
<li>沿着正确的方向前行通常并不会花很多时间，方向不清的情况下走冤枉路却是白费工夫</li>
</ul>
</li>
<li>为什么要这样做，这是最好的方式吗？<ul>
<li>实践过程中会出各种小差错，要从这些差错中学习并提高实践能力</li>
</ul>
</li>
<li>能不能利用前辈的经验减少重复劳动？<ul>
<li>太阳底下没有新鲜事，很多经验是共同的</li>
</ul>
</li>
<li>可能会遇到什么困难，对应的尝试思路是什么？<ul>
<li>遇到困难的时候已经有了准备，就不会慌乱</li>
</ul>
</li>
<li>信息流动顺畅吗？是不是团队的每个成员都真正参与了进来？<ul>
<li>让每个人都清楚明白，就是流程的『可视化』，能让工作更简洁、更有效率</li>
</ul>
</li>
</ul>
<p>实践是学习和思考的演戏场，前面提到的各种能力和技巧，都可以运用到实践中来。当我们遇到问题时，最高效的做法是：</p>
<ol>
<li>认识问题。思考问题背后的东西，背景、事物、条件、关系。通过重新定义问题本身来探索问题的本质。</li>
<li>独立思考。先不借助书本和网络，大胆假设，小心求证。试错的目的就是从中得到意外的收获。现实不比理论，遇到的问题往往具体而特殊，几乎没有什么现成的经验，还是那句话：主动思考大胆假设小心求证。书本和网络的资料可能会给人启发，但是也是枷锁，框住想象力。</li>
<li>全面观测。这个时候可以在书本或网络中找寻相关内容，可能的话尽量与他人交换想法。认知本身就是主观的，横看成岭侧成峰，要全面观测，才能得到更接近『真实』的认知。也就是主观的客观化。</li>
<li>形成框架。简单来说，就是要有自己的『套路』，不同类型的问题有不同的解法，通过具体的实践不断迭代优化自己的理论与套路。</li>
<li>魔鬼细节。仰望星空同时也要脚踏实地，实践难免把手弄脏，但也只有把手弄脏才能得到完备的解决方案，继而解决复杂的现实问题。</li>
<li>每次处理问题请重复上述步骤</li>
</ol>
<p>实践是问题导向的，不能为了做而做，面对动态世界的复杂系统，只有以未知作为起点进行思考，才可能拨开迷雾找到答案。</p>
<p>实践关于实践本身的东西，就是元实践。</p>
<h2 id="u6B63_u786E_u521B_u9020"><a href="#u6B63_u786E_u521B_u9020" class="headerlink" title="正确创造"></a>正确创造</h2><blockquote>
<p>The purpose of education is to provide you the toolsets that enable you take the data around you, make sense out of it and find out a way to create something productive out of that. As the amount of data around us explode, the necessity for education grows.</p>
</blockquote>
<p>创造性这个东西，说流淌在血液中一点也不为过。我们骨子里传下来的智慧、毅力、勤勉、奋发当然不能丢，但是更应该再来点浪漫主义，从超越功利的角度找回精神自主性，每个人都要是特立独行的个体，而不是流水线生产出来的千人一面脸谱化。</p>
<p>多元化的生活态度与人生哲学，对生活本身的富于诗情的理解，才能真正让自己『立体』，有广度也有深度，才能创造出更多新东西，而不是循规蹈矩墨守成规。</p>
<p>『当幸福来敲门』这个翻译我觉得特别好，很多东西不是去找就能找得到的，而是把该做好的都做好，然后静静等待那个时刻的到来。创造就是如此，尤其是下面提到的『酝酿』阶段，就是『当创意来敲门』。但是需要注意的是，不同阶段有不同的侧重点：</p>
<ul>
<li>准备阶段。搜集相关信息，缩小问题范围，直到看到障碍</li>
<li>酝酿阶段。将自己完全浸在问题里，运用潜意识思考，不要有寻找解决方案的压力</li>
<li>启发阶段。用直觉或有意识的思考处理问题，用直觉或洞察力来形成可能的解决方案</li>
<li>验证阶段。对可能的解决方案进行合理性检验，验证方案的正确性，并最终打磨完整</li>
</ul>
<p>创造关于创造本身的东西，就是元创造。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>Heroes inspire us for many reasons: they make tough decisions, they keep going and they get done what matters. But there’s another reason we love our heroes. Inside us all, we know we have the power to become one ourselves.</p>
</blockquote>
<p>英雄人物之所以能激励我们，是因为他们能够作出艰难的抉择，他们永不言弃，他们总能做出惊天动地的事情。但我们之所以崇拜英雄还有另一个原因。在内心深处，我们都相信自己有能力成为他们。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>小聪明到大智慧之间，有一条看不见的横沟，只能用天赋、坚持和勤奋来填。如果硬要说有技巧，恐怕就是『元学习』、『元思考』、『元实践』和『元创造』。</p>]]>
    
    </summary>
    
      <category term="创造" scheme="http://wdxtub.com/tags/%E5%88%9B%E9%80%A0/"/>
    
      <category term="感觉" scheme="http://wdxtub.com/tags/%E6%84%9F%E8%A7%89/"/>
    
      <category term="方法" scheme="http://wdxtub.com/tags/%E6%96%B9%E6%B3%95/"/>
    
      <category term="聪明" scheme="http://wdxtub.com/tags/%E8%81%AA%E6%98%8E/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 反思课 5 实时服务测试的策略与思考]]></title>
    <link href="http://wdxtub.com/2016/03/31/cc-rethink-5/"/>
    <id>http://wdxtub.com/2016/03/31/cc-rethink-5/</id>
    <published>2016-03-31T10:02:04.000Z</published>
    <updated>2016-03-31T11:19:15.000Z</updated>
    <content type="html"><![CDATA[<p>昨天我们的 Twitter Analysis Service 采用了新的测试方式，在大约两个半小时的时间内进行各类请求的压力测试，以确保系统能够应对复杂请求。虽然我做的部分表现非常糟糕，但是从中学到了很多东西，知耻而后勇。</p>
<a id="more"></a>
<hr>
<p>总得来说，因为有靠谱的队友（手动重启服务器几十次），整个测试不至于滑铁卢，但是这也暴露了我们在前后端设计处理的各种问题，接下来逐条分析。</p>
<blockquote>
<p>架构设计</p>
</blockquote>
<p>因为整套系统目前有 6 台机器，之前测试的时候使用 1 台前端 + 4 台后端是行得通的。但是因为之前并没有过多留意前后端机器的硬件利用情况（基本凭感觉），所以想当然得觉得后端是瓶颈（对 HBase 的特性不大了解，估计错误）。事实狠狠打了我的脸，前端的 CPU 利用率居高不下（接近满负荷运载）而后端的利用率分布不均（有的节点 60% 的 CPU 使用率，有的节点甚至只有 20%）。</p>
<p>当我意识到这个问题的时候，只能眼睁睁看着唯一的一台前端苦苦支撑，爆内存，和 HBase 的连接断开，每次都只能手动重启服务器（但是因为 CPU 占用满了，重启也需要几分钟）。这极大影响了正确率和吞吐量，最终得到的分数自然少得可怜。</p>
<p>参考其他组的先进经验，前端使用 ELB(负载均衡) + 2 台机器，后端使用 1(master) + 3(slave) 的模式可能是最科学的，这样可以尽可能得减轻前端单机压力。</p>
<blockquote>
<p>硬件监控</p>
</blockquote>
<p>好消息是，在同学的帮助之下，终于意识到了『监控』的重要性。虽然不难（每台机器开着 <code>top</code> 查看使用率即可），但是有没有这个意识就有天壤之别。简单粗暴来说，哪怕只通过 CPU 利用率一个指标，就能大概估计目前的硬件使用情况，可是我之前竟然拍脑袋想当然总觉得硬件不是问题。</p>
<p>这是很好的教训，我要吸取经验。</p>
<p>痛定思痛，至少可以从其他多个角度来利用监控数据：</p>
<ul>
<li>了解不同的监控命令，深入理解不同监控参数的意义，编写脚本抓取重点关注的数据</li>
<li>结合 CPU 利用率 + 内存利用率来优化代码，力求达到充分利用 CPU 以及内存</li>
<li>观察 CPU / 内存 / 网络的相关数据，来确定具体的瓶颈所在，然后对症下药，寻找可能的解决方案</li>
<li>在监控脚本的基础上，可以设定一些阈值，自动化提醒和记录日志（不用自己时刻盯着屏幕了）</li>
<li>提醒内容：CPU / 内存 / 网络满载警报，或者不均衡使用警报等</li>
<li>日志内容：在出现警报的时候，需要记录相关请求，查看日志的时候能够快速掌握上下文</li>
</ul>
<blockquote>
<p>数据统计</p>
</blockquote>
<p>一般来说，不同的 web 服务，用户的请求模式总体来说是有一定规律的。对于 Twitter 数据的分析，就有热门/冷门的用户/hashtag/单词/时间段（比方说有重大事件发生的日子，tweet 的数量可能会更多）</p>
<p>我们应该根据具体的需求，通过统计大致了解数据分布。比方说其中一个请求是返回某用户包含某 hashtag 的 tweet，那么我们最好需要了解哪些用户热门，哪些 hashtag 热门，然后根据这些特点来进行数据库 schema 的设计（就是 rowkey 和 value）以及数据库中不同 region 在不同 regionserver 的平衡。之前的设计方式会导致有些 region 访问次数非常多，有些却非常少，这样就没有充分利用 HBase 的能力。</p>
<p>这部分具体怎么实现还需要通过不断实践来摸索，但是想要获得更好的性能，总是逃不开这步的。</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>这一部分就是压力测试下暴露的代码问题了，主要是以下几点：</p>
<ul>
<li>请求的参数要进行检查，很可能为空。但是写起来的语法很麻烦，这个时候就开始怀念 Swift 中的语法糖了</li>
<li>对于 HBase 1.0 来说，连接池几乎没用，因为共用 HConnection 的 HTableInterface 并不会并行</li>
<li>线程池也不大需要，undertow 框架基本能够处理好，就不要画蛇添足（容易爆内存）</li>
</ul>
<p>最后写三句，从错误中学习比实现 web 服务本身更有意义，这是第二句，第三句也写完了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天我们的 Twitter Analysis Service 采用了新的测试方式，在大约两个半小时的时间内进行各类请求的压力测试，以确保系统能够应对复杂请求。虽然我做的部分表现非常糟糕，但是从中学到了很多东西，知耻而后勇。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="优化" scheme="http://wdxtub.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[tmux 指南]]></title>
    <link href="http://wdxtub.com/2016/03/30/tmux-guide/"/>
    <id>http://wdxtub.com/2016/03/30/tmux-guide/</id>
    <published>2016-03-30T22:55:27.000Z</published>
    <updated>2016-03-31T04:01:21.000Z</updated>
    <content type="html"><![CDATA[<p>今天试用了一下 tmux，发现简直是神器！以前还傻傻不停开窗口，现在一个窗口就可以都搞定啦！</p>
<a id="more"></a>
<hr>
<p>Tmux 简单来说就是终端里的『窗口管理器』，如果我使用终端登录到远程主机并运行前台程序，那么这个窗口等于就被占用了，想要看一下 CPU 的使用率，就得再连接一次。但是如果在远程主机上运行 tmux，那么就可以开启多个控制台（类似于窗口），相当高效，比方说可以像下面这样：</p>
<p><img src="/images/14593788571503.jpg" alt="一个面板监视服务器，一个面板查看硬件状况"></p>
<p>需要注意的是，这里是在我本地使用 tmux，最好在远程主机也安装 tmux，这样就只需要连接一次。</p>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>前面提到的窗口管理只是 tmux 功能的一小部分，另一个很有用的功能就是，连接到远程主机之后，一旦断开，那么当前账户登录的任务就被取消了，但是使用 tmux 可以在断开之后继续工作，下次登录可以查看。其他的功能还有：</p>
<ol>
<li>窗口切换，每个窗口里还可以分割面板</li>
<li>配置方便，可以使用脚本</li>
<li>类似 vim 的双层操作逻辑</li>
<li>复制粘贴缓冲区</li>
</ol>
<p>安装的话也很简单，在 mac 下直接 <code>brew install tmux</code>（前提需要安装 homebrew），ubuntu 下则直接 <code>sudo apt-get install tmux</code></p>
<p>在终端中输入 <code>tmux</code> 就可以打开一个新的 tmux session，tmux 的所有操作必须先使用一个前缀键（默认是 <code>ctrl + b</code>）进入命令模式，或者说进入控制台，就像 vim 中的 esc。</p>
<h2 id="u57FA_u672C_u64CD_u4F5C"><a href="#u57FA_u672C_u64CD_u4F5C" class="headerlink" title="基本操作"></a>基本操作</h2><blockquote>
<p>信息查询</p>
</blockquote>
<ul>
<li><code>tmux list-keys</code> 列出所有可以的快捷键和其运行的 tmux 命令</li>
<li><code>tmux list-commands</code> 列出所有的 tmux 命令及其参数</li>
<li><code>tmux info</code> 流出所有的 session, window, pane, 运行的进程号，等。</li>
</ul>
<blockquote>
<p>窗口控制</p>
</blockquote>
<p>先来看看在 tmux 之外如何进行控制</p>
<ul>
<li>session 会话：session是一个特定的终端组合。输入tmux就可以打开一个新的session<ul>
<li><code>tmux new -s session_name</code> 创建一个叫做 <code>session_name</code> 的 tmux session</li>
<li><code>tmux attach -t session_name</code> 重新开启叫做 <code>session_name</code> 的 tmux session</li>
<li><code>tmux switch -t session_name</code> 转换到叫做 <code>session_name</code> 的 tmux session</li>
<li><code>tmux list-sessions</code> / <code>tmux ls</code> 列出现有的所有 session</li>
<li><code>tmux detach</code> 离开当前开启的 session</li>
</ul>
</li>
<li>window 窗口：session 中可以有不同的 window（但是同时只能看到一个 window）<ul>
<li><code>tmux new-window</code> 创建一个新的 window</li>
<li><code>tmux list-windows</code> </li>
<li><code>tmux select-window -t :0-9</code> 根据索引转到该 window</li>
<li><code>tmux rename-window</code> 重命名当前 window</li>
</ul>
</li>
<li>pane 面板：window 中可以有不同的 pane（可以把 window 分成不同的部分）<ul>
<li><code>tmux split-window</code> 将 window 垂直划分为两个 pane</li>
<li><code>tmux split-window -h</code> 将 window 水平划分为两个 pane</li>
<li><code>tmux swap-pane -[UDLR]</code> 在指定的方向交换 pane</li>
<li><code>tmux select-pane -[UDLR]</code> 在指定的方向选择下一个 pane</li>
</ul>
</li>
</ul>
<p>更常用的是在 tmux 中直接通过默认前缀 <code>ctrl + b</code> 之后输入对应命令来操作，具体如下（这里只列出输入默认前缀之后需要输入的操作）：</p>
<blockquote>
<p>基本操作</p>
</blockquote>
<ul>
<li><code>?</code> 列出所有快捷键；按q返回</li>
<li><code>d</code> 脱离当前会话,可暂时返回Shell界面</li>
<li><code>s</code> 选择并切换会话；在同时开启了多个会话时使用</li>
<li><code>D</code> 选择要脱离的会话；在同时开启了多个会话时使用</li>
<li><code>:</code> 进入命令行模式；此时可输入支持的命令，例如 <code>kill-server</code> 关闭所有tmux会话</li>
<li><code>[</code> 复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q/Esc退出</li>
<li><code>]</code> 进入粘贴模式，粘贴之前复制的内容，按q/Esc退出</li>
<li><code>~</code> 列出提示信息缓存；其中包含了之前tmux返回的各种提示信息</li>
<li><code>t</code> 显示当前的时间</li>
<li><code>ctrl + z</code> 挂起当前会话</li>
</ul>
<blockquote>
<p>窗口操作</p>
</blockquote>
<ul>
<li><code>c</code> 创建新窗口</li>
<li><code>&amp;</code> 关闭当前窗口</li>
<li><code>[0-9]</code> 数字键切换到指定窗口</li>
<li><code>p</code> 切换至上一窗口</li>
<li><code>n</code> 切换至下一窗口</li>
<li><code>l</code> 前后窗口间互相切换</li>
<li><code>w</code> 通过窗口列表切换窗口</li>
<li><code>,</code> 重命名当前窗口，便于识别</li>
<li><code>.</code> 修改当前窗口编号，相当于重新排序</li>
<li><code>f</code> 在所有窗口中查找关键词，便于窗口多了切换</li>
</ul>
<blockquote>
<p>面板操作</p>
</blockquote>
<ul>
<li><code>&quot;</code> 将当前面板上下分屏（我自己改成了 <code>|</code>）</li>
<li><code>%</code> 将当前面板左右分屏（我自己改成了 <code>-</code>）</li>
<li><code>x</code> 关闭当前分屏</li>
<li><code>!</code> 将当前面板置于新窗口,即新建一个窗口,其中仅包含当前面板</li>
<li><code>ctrl+方向键</code> 以1个单元格为单位移动边缘以调整当前面板大小</li>
<li><code>alt+方向键</code> 以5个单元格为单位移动边缘以调整当前面板大小</li>
<li><code>q</code> 显示面板编号</li>
<li><code>o</code> 选择当前窗口中下一个面板</li>
<li><code>方向键</code> 移动光标选择对应面板</li>
<li><code>{</code> 向前置换当前面板</li>
<li><code>}</code> 向后置换当前面板</li>
<li><code>alt+o</code> 逆时针旋转当前窗口的面板</li>
<li><code>ctrl+o</code> 顺时针旋转当前窗口的面板</li>
<li><code>z</code> 最大化当前所在面板</li>
<li><code>page up</code> 向上滚动屏幕，q 退出</li>
<li><code>page down</code> 向下滚动屏幕，q 退出</li>
</ul>
<p>因为 iTerm2 的支持，很多切换的操作可以直接用鼠标进行，非常方便。具体大家可以自己尝试一下。</p>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2><p>我们可以先进行一些简单的配置，修改 <code>~/.tmux.conf</code> 即可，让整个使用更方便。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#<span class="comment">-- base --#</span></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">default</span>-terminal <span class="string">"screen-256color"</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> display-<span class="keyword">time</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> history-<span class="keyword">limit</span> <span class="number">10000</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> base-<span class="keyword">index</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> pane-base-<span class="keyword">index</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> -s escape-<span class="keyword">time</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> mouse <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line">#<span class="comment">-- bindkeys --#</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">split</span> windows <span class="keyword">like</span> vim.  - Note: vim<span class="string">'s definition of a horizontal/vertical split is reversed from tmux'</span>s</span><br><span class="line"></span><br><span class="line">unbind s</span><br><span class="line">bind s <span class="keyword">split</span>-window -v</span><br><span class="line">bind S <span class="keyword">split</span>-window -v -<span class="keyword">l</span> <span class="number">40</span></span><br><span class="line">bind v <span class="keyword">split</span>-window -h</span><br><span class="line">bind V <span class="keyword">split</span>-window -h -<span class="keyword">l</span> <span class="number">120</span></span><br><span class="line"></span><br><span class="line"># navigate panes <span class="keyword">with</span> hjkl</span><br><span class="line">bind h <span class="keyword">select</span>-pane -<span class="keyword">L</span></span><br><span class="line">bind j <span class="keyword">select</span>-pane -<span class="keyword">D</span></span><br><span class="line">bind <span class="keyword">k</span> <span class="keyword">select</span>-pane -U</span><br><span class="line">bind <span class="keyword">l</span> <span class="keyword">select</span>-pane -R</span><br><span class="line"></span><br><span class="line"># <span class="keyword">key</span> bindings <span class="keyword">for</span> horizontal <span class="keyword">and</span> vertical panes</span><br><span class="line">unbind %</span><br><span class="line">bind | <span class="keyword">split</span>-window -h      # 使用|竖屏，方便分屏</span><br><span class="line">unbind <span class="string">'"'</span></span><br><span class="line">bind - <span class="keyword">split</span>-window -v      # 使用-横屏，方便分屏</span><br><span class="line"></span><br><span class="line"># swap panes</span><br><span class="line">bind ^u swapp -U</span><br><span class="line">bind ^<span class="keyword">d</span> swapp -<span class="keyword">D</span></span><br><span class="line"></span><br><span class="line">bind q killp</span><br><span class="line">bind ^<span class="keyword">e</span> <span class="keyword">last</span></span><br><span class="line"></span><br><span class="line">unbind r</span><br><span class="line">bind r <span class="keyword">source</span>-<span class="keyword">file</span> ~/.tmux.conf \;</span> display "Configuration Reloaded!"</span><br><span class="line"></span><br><span class="line">#<span class="comment">-- statusbar --#</span></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-justify centre</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">left</span> <span class="string">"#[fg=red]s#S:w#I.p#P#[default]"</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">right</span> <span class="string">'[#(whoami)#(date +" %m-%d %H:%M ")]'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">left</span>-<span class="keyword">attr</span> bright</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">left</span>-<span class="keyword">length</span> <span class="number">120</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">right</span>-<span class="keyword">length</span> <span class="number">120</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-utf8 <span class="keyword">on</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="built_in">interval</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> visual-activity <span class="keyword">on</span></span><br><span class="line">setw -<span class="keyword">g</span> monitor-activity <span class="keyword">on</span></span><br><span class="line">setw -<span class="keyword">g</span> <span class="keyword">automatic</span>-<span class="keyword">rename</span> <span class="keyword">off</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">default</span> statusbar colors</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-bg colour235 #base02</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-fg colour136 #yellow</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">attr</span> <span class="keyword">default</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">default</span> window title colors</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-fg colour244</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-bg <span class="keyword">default</span></span><br><span class="line">#setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">attr</span> dim</span><br><span class="line"></span><br><span class="line"># active window title colors</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-fg colour166 #orange</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-bg <span class="keyword">default</span></span><br><span class="line">#setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-<span class="keyword">attr</span> bright</span><br><span class="line"></span><br><span class="line"># window title <span class="keyword">string</span> (uses statusbar <span class="keyword">variables</span>)</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">set</span>-titles-<span class="keyword">string</span> <span class="string">'#T'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-justify <span class="string">"centre"</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">format</span> <span class="string">'#I #W'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-<span class="keyword">format</span> <span class="string">' #I #W '</span></span><br><span class="line"></span><br><span class="line"># pane border</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> pane-active-border-fg <span class="string">'#55ff55'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> pane-border-fg <span class="string">'#555555'</span></span><br><span class="line"></span><br><span class="line"># message <span class="built_in">text</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> message-bg colour235 #base02</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> message-fg colour166 #orange</span><br><span class="line"></span><br><span class="line"># pane <span class="built_in">number</span> display</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> display-panes-active-colour colour33 #blue</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> display-panes-colour colour166 #orange</span><br><span class="line"></span><br><span class="line"># clock</span><br><span class="line">setw -<span class="keyword">g</span> clock-<span class="keyword">mode</span>-colour colour64 #green</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 修改进入命令模式按键</span><br><span class="line"># remap prefix <span class="keyword">to</span> Control + a</span><br><span class="line"># <span class="keyword">set</span> -<span class="keyword">g</span> prefix <span class="keyword">C</span>-a</span><br><span class="line"># unbind <span class="keyword">C</span>-b</span><br><span class="line"># bind <span class="keyword">C</span>-a send-prefix</span></span><br></pre></td></tr></table></figure>
<p>最终的效果是</p>
<p><img src="/images/14593965566247.jpg" alt=""></p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://foocoder.com/blog/zhong-duan-huan-jing-zhi-tmux.html/" target="_blank" rel="external">终端环境之tmux</a></li>
<li><a href="http://blog.jeswang.org/blog/2013/06/24/tmux-kuai-su-jiao-cheng/" target="_blank" rel="external">Tmux 快速教程</a></li>
<li><a href="http://kumu-linux.github.io/blog/2013/08/06/tmux/" target="_blank" rel="external">Linux下终端利器tmux</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天试用了一下 tmux，发现简直是神器！以前还傻傻不停开窗口，现在一个窗口就可以都搞定啦！</p>]]>
    
    </summary>
    
      <category term="命令行" scheme="http://wdxtub.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="效率" scheme="http://wdxtub.com/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="窗口" scheme="http://wdxtub.com/tags/%E7%AA%97%E5%8F%A3/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ruby 快速入门]]></title>
    <link href="http://wdxtub.com/2016/03/30/ruby-first-step/"/>
    <id>http://wdxtub.com/2016/03/30/ruby-first-step/</id>
    <published>2016-03-30T13:14:28.000Z</published>
    <updated>2016-04-01T15:07:09.000Z</updated>
    <content type="html"><![CDATA[<p>学编程就好比学有用，再好的理论也不如一头扎下水，扑腾着呼吸新鲜空气管用。这个系列的目的，就是帮助自己跳入水中，这一次我们来学 Ruby。</p>
<a id="more"></a>
<hr>
<p>获得任何新技能的第一步，是先别想着独立解决什么，而是重复一边前人已竟之事，这是最快的方法。每门语言都有自己的一套惯用方法，各有所长，各有所短。通过学习不同的编程语言，你会明白，哪门语言最适宜解决自己当下关注的问题。</p>
<p>精于禅宗的大师会告诉你，拉丁语学得越好，数学也就越好。编程也同样如此。通过研究逻辑式编程或函数式编程，你能领悟到面向对象编程的精华；通过学习汇编语言，你能更透彻地理解函数式编程。</p>
<p>学习新语言的时候，一定要弄清楚以下几个问题：</p>
<ul>
<li>语言的类型模型是什么？<ul>
<li>强类型/弱类型，静态类型/动态类型</li>
<li>类型模型会改变问题的处理方式，控制语言的运行方式</li>
</ul>
</li>
<li>语言的编程范型是什么？<ul>
<li>面向对象、函数式、过程式等等</li>
</ul>
</li>
<li>怎样和语言交互？<ul>
<li>编译、解释</li>
</ul>
</li>
<li>语言的判断结构(decision construct)和核心数据结构是什么？</li>
<li>哪些核心特性让这门语言与众不同？</li>
</ul>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><ul>
<li>由松本行弘(Yukihiro Matsumoto)大约在 1993 年发明</li>
<li>脚本语言、解释型、面向对象、动态类型</li>
</ul>
<p>现在我的机器上安装的 ruby 版本是 2.1，可以使用下面的命令来查询：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -v</span><br><span class="line">ruby <span class="number">2.1</span>.<span class="number">4</span>p265 (<span class="number">2014</span>-<span class="number">10</span>-<span class="number">27</span> revision <span class="number">48166</span>) [x86_64-darwin14.<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>具体的安装不做太多介绍，在<a href="https://www.ruby-lang.org/zh_cn/" target="_blank" rel="external">官方网站</a>查阅不同平台的相关资料即可，下面是一个简单的例子</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> properties = [<span class="string">'good'</span>, <span class="string">'bad'</span>, <span class="string">'clever'</span>, <span class="string">'stupid'</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"good"</span>, <span class="string">"bad"</span>, <span class="string">"clever"</span>, <span class="string">"stupid"</span>]</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> properties.each &#123;|property| puts <span class="string">"I am <span class="subst">#&#123;property&#125;</span>."</span>&#125;</span><br><span class="line"><span class="constant">I</span> am good.</span><br><span class="line"><span class="constant">I</span> am bad.</span><br><span class="line"><span class="constant">I</span> am clever.</span><br><span class="line"><span class="constant">I</span> am stupid.</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"good"</span>, <span class="string">"bad"</span>, <span class="string">"clever"</span>, <span class="string">"stupid"</span>]</span><br></pre></td></tr></table></figure>
<p>留意一下 ruby 是如何进行遍历及值替换的，之后我们也会深入了解。需要注意的是，这种写起来方便的语言，一般来说效率都不会太高。但是开发效率与执行效率常常是鱼与熊掌，很多时候不得不进行选择。</p>
<p>我们再来看一个长一点的例子：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> puts <span class="string">'hello, wdx'</span></span><br><span class="line">hello, wdx</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> friend = <span class="string">'Snake'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Snake"</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> puts <span class="string">"hello, <span class="subst">#&#123;friend&#125;</span>"</span></span><br><span class="line">hello, <span class="constant">Snake</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> friend = <span class="string">'Queit'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Queit"</span></span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> puts <span class="string">"hello, <span class="subst">#&#123;friend&#125;</span>"</span></span><br><span class="line">hello, <span class="constant">Queit</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到以下几点：</p>
<ul>
<li>不用声明变量</li>
<li>每条 ruby 代码都会返回某个值</li>
<li>单引号表示直接解释</li>
<li>双引号包含的字符串会进行字符串替换</li>
</ul>
<h2 id="u7F16_u7A0B_u6A21_u578B"><a href="#u7F16_u7A0B_u6A21_u578B" class="headerlink" title="编程模型"></a>编程模型</h2><p>Ruby 是一门纯面向对象语言。从下面的例子就可以看出来：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="number">233</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">233</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> <span class="number">233</span>.class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">Fixnum</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> <span class="number">233</span> + <span class="number">233</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">466</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> <span class="number">233</span>.methods</span><br><span class="line"><span class="status">=&gt;</span> [<span class="symbol">:to_s</span>, <span class="symbol">:inspect</span>, <span class="symbol">:-@</span>, <span class="symbol">:+</span>, <span class="symbol">:-</span>, <span class="symbol">:*</span>, <span class="symbol">:/</span>, <span class="symbol">:div</span>, <span class="symbol">:%</span>, <span class="symbol">:modulo</span>, <span class="symbol">:divmod</span>, <span class="symbol">:fdiv</span>, <span class="symbol">:**</span>, <span class="symbol">:abs</span>, <span class="symbol">:magnitude</span>, <span class="symbol">:==</span>, <span class="symbol">:===</span>, <span class="symbol">:&lt;=&gt;</span>, <span class="symbol">:&gt;</span>, <span class="symbol">:&gt;=</span>, <span class="symbol">:&lt;</span>, <span class="symbol">:&lt;=</span>, <span class="symbol">:~</span>, <span class="symbol">:&amp;</span>, <span class="symbol">:|</span>, <span class="symbol">:^</span>, <span class="symbol">:[]</span>, <span class="symbol">:&lt;&lt;</span>, <span class="symbol">:&gt;&gt;</span>, <span class="symbol">:to_f</span>, <span class="symbol">:size</span>, <span class="symbol">:bit_length</span>, <span class="symbol">:zero?</span>, <span class="symbol">:odd?</span>, <span class="symbol">:even?</span>, <span class="symbol">:succ</span>, <span class="symbol">:integer?</span>, <span class="symbol">:upto</span>, <span class="symbol">:downto</span>, <span class="symbol">:times</span>, <span class="symbol">:next</span>, <span class="symbol">:pred</span>, <span class="symbol">:chr</span>, <span class="symbol">:ord</span>, <span class="symbol">:to_i</span>, <span class="symbol">:to_int</span>, <span class="symbol">:floor</span>, <span class="symbol">:ceil</span>, <span class="symbol">:truncate</span>, <span class="symbol">:round</span>, <span class="symbol">:gcd</span>, <span class="symbol">:lcm</span>, <span class="symbol">:gcdlcm</span>, <span class="symbol">:numerator</span>, <span class="symbol">:denominator</span>, <span class="symbol">:to_r</span>, <span class="symbol">:rationalize</span>, <span class="symbol">:singleton_method_added</span>, <span class="symbol">:coerce</span>, <span class="symbol">:i</span>, <span class="symbol">:+@</span>, <span class="symbol">:eql?</span>, <span class="symbol">:remainder</span>, <span class="symbol">:real?</span>, <span class="symbol">:nonzero?</span>, <span class="symbol">:step</span>, <span class="symbol">:quo</span>, <span class="symbol">:to_c</span>, <span class="symbol">:real</span>, <span class="symbol">:imaginary</span>, <span class="symbol">:imag</span>, <span class="symbol">:abs2</span>, <span class="symbol">:arg</span>, <span class="symbol">:angle</span>, <span class="symbol">:phase</span>, <span class="symbol">:rectangular</span>, <span class="symbol">:rect</span>, <span class="symbol">:polar</span>, <span class="symbol">:conjugate</span>, <span class="symbol">:conj</span>, <span class="symbol">:between?</span>, <span class="symbol">:nil?</span>, <span class="symbol">:=~</span>, <span class="symbol">:</span>!~, <span class="symbol">:hash</span>, <span class="symbol">:class</span>, <span class="symbol">:singleton_class</span>, <span class="symbol">:clone</span>, <span class="symbol">:dup</span>, <span class="symbol">:taint</span>, <span class="symbol">:tainted?</span>, <span class="symbol">:untaint</span>, <span class="symbol">:untrust</span>, <span class="symbol">:untrusted?</span>, <span class="symbol">:trust</span>, <span class="symbol">:freeze</span>, <span class="symbol">:frozen?</span>, <span class="symbol">:methods</span>, <span class="symbol">:singleton_methods</span>, <span class="symbol">:protected_methods</span>, <span class="symbol">:private_methods</span>, <span class="symbol">:public_methods</span>, <span class="symbol">:instance_variables</span>, <span class="symbol">:instance_variable_get</span>, <span class="symbol">:instance_variable_set</span>, <span class="symbol">:instance_variable_defined?</span>, <span class="symbol">:remove_instance_variable</span>, <span class="symbol">:instance_of?</span>, <span class="symbol">:kind_of?</span>, <span class="symbol">:is_a?</span>, <span class="symbol">:tap</span>, <span class="symbol">:send</span>, <span class="symbol">:public_send</span>, <span class="symbol">:respond_to?</span>, <span class="symbol">:extend</span>, <span class="symbol">:display</span>, <span class="symbol">:method</span>, <span class="symbol">:public_method</span>, <span class="symbol">:singleton_method</span>, <span class="symbol">:define_singleton_method</span>, <span class="symbol">:object_id</span>, <span class="symbol">:to_enum</span>, <span class="symbol">:enum_for</span>, <span class="symbol">:equal?</span>, <span class="symbol">:</span>!, <span class="symbol">:</span>!=, <span class="symbol">:instance_eval</span>, <span class="symbol">:instance_exec</span>, <span class="symbol">:__send__</span>, <span class="symbol">:__id__</span>]</span><br></pre></td></tr></table></figure>
<p>看出来了吗，ruby 中一切皆为对象，比方说数字就是 <code>Fixnum</code> 类型的对象，我们也可以用 <code>.</code> 来调用对象的各种方法。</p>
<blockquote>
<p>判断</p>
</blockquote>
<p>我们同样可以通过例子来研究研究。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> x = <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">4</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> x &lt; <span class="number">5</span></span><br><span class="line"><span class="status">=&gt;</span> true</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> x &lt;= <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> true</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> x &gt; <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> false</span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> false.class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">FalseClass</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> true.class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">TrueClass</span></span><br><span class="line"><span class="prompt">irb(main):007:0&gt;</span> puts <span class="string">'This is false'</span> unless x == <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):008:0&gt;</span> puts <span class="string">'This is true'</span> if x == <span class="number">4</span></span><br><span class="line"><span class="constant">This</span> is <span class="keyword">true</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):009:0&gt;</span> if x == <span class="number">4</span></span><br><span class="line"><span class="prompt">irb(main):010:1&gt;</span>     puts <span class="string">'This is true'</span></span><br><span class="line"><span class="prompt">irb(main):011:1&gt;</span> end</span><br><span class="line"><span class="constant">This</span> is <span class="keyword">true</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):012:0&gt;</span> unless x == <span class="number">4</span></span><br><span class="line"><span class="prompt">irb(main):013:1&gt;</span>    puts <span class="string">'This is false'</span></span><br><span class="line"><span class="prompt">irb(main):014:1&gt;</span> else</span><br><span class="line">irb(main)<span class="symbol">:</span><span class="number">015</span><span class="symbol">:</span><span class="number">1</span>*    puts <span class="string">'This is true'</span></span><br><span class="line"><span class="prompt">irb(main):016:1&gt;</span> end</span><br><span class="line"><span class="constant">This</span> is <span class="keyword">true</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):017:0&gt;</span> puts <span class="string">'This is true'</span> if not true</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):018:0&gt;</span> puts <span class="string">'This is ture'</span> if !true</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>比较什么的和其他语言大同小异，条件判断的话，主要是 <code>if</code> 和 <code>unless</code>（当然 <code>!</code> 和 <code>not</code> 都可以用，但是建议用 <code>unless</code> 比较清晰），在 Ruby 的语法中可以直接一行搞定判断一句，这样至少写起来很清晰。</p>
<p>除了 <code>nil</code> 和 <code>false</code> 之外，其他值都代表 <code>true</code>，注意！0 也是 <code>true</code>！</p>
<p>循环语句可以使用 <code>while</code> 和 <code>until</code>，比较简单，这里直接看例子，需要注意的是，Ruby 中没种对戏那个都有自己的相等的概念，对于数字来说，值相等就是相等。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> x = <span class="number">2</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> x = x + <span class="number">1</span> while x &lt; <span class="number">10</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> x</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">10</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> x = x - <span class="number">1</span> until x == <span class="number">1</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> x</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> while x &lt; <span class="number">10</span></span><br><span class="line"><span class="prompt">irb(main):007:1&gt;</span>   x = x + <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):008:1&gt;</span>   puts x</span><br><span class="line"><span class="prompt">irb(main):009:1&gt;</span> end</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>逻辑运算符和 C++/Java 有少许不同，<code>and</code>(<code>&amp;&amp;</code>) 是逻辑与，<code>or</code>(<code>||</code>) 是逻辑或，都是短路求值的，如果想要整个表达式都执行的话，使用 <code>&amp;</code> 和 <code>|</code> 来比较，具体为</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> true and false</span><br><span class="line"><span class="status">=&gt;</span> false</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> true or false</span><br><span class="line"><span class="status">=&gt;</span> true</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> false &amp;&amp; false</span><br><span class="line"><span class="status">=&gt;</span> false</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> true &amp;&amp; this_will_cause_an_error</span><br><span class="line"><span class="constant">NameError</span><span class="symbol">:</span> undefined local variable <span class="keyword">or</span> method <span class="string">`this_will_cause_an_error' for main:Object</span><br><span class="line">	from (irb):4</span><br><span class="line">	from /usr/local/bin/irb:11:in `</span>&lt;main&gt;<span class="string">'</span><br><span class="line">irb(main):005:0&gt; false &amp;&amp; this_will_not_cause_an_error</span><br><span class="line">=&gt; false</span><br><span class="line">irb(main):006:0&gt; true or this_will_not_cause_an_error</span><br><span class="line">=&gt; true</span><br><span class="line">irb(main):007:0&gt; true || this_will_not_cause_an_error</span><br><span class="line">=&gt; true</span><br><span class="line">irb(main):008:0&gt; true | this_will_cause_an_error</span><br><span class="line">NameError: undefined local variable or method `this_will_cause_an_error'</span> <span class="keyword">for</span> <span class="symbol">main:</span><span class="constant">Object</span></span><br><span class="line">	from (irb)<span class="symbol">:</span><span class="number">8</span></span><br><span class="line">	from /usr/local/bin/<span class="symbol">irb:</span><span class="number">11</span><span class="symbol">:in</span> <span class="string">`&lt;main&gt;'</span><br><span class="line">irb(main):009:0&gt; true | false</span><br><span class="line">=&gt; true</span></span><br></pre></td></tr></table></figure>
<p>基本来说还是一目了然的，这里不再赘述</p>
<blockquote>
<p>鸭子类型</p>
</blockquote>
<p>Ruby 是强类型语言，直到真正执行代码时，才进行类型检查，称为『动态类型』，但是这也带来了一些好处：多个类不必继承自相同父类，就能以相同方式使用，如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> i = <span class="number">0</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> a = [<span class="string">'100'</span>, <span class="number">100.0</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"100"</span>, <span class="number">100.0</span>]</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> while i &lt; <span class="number">2</span></span><br><span class="line"><span class="prompt">irb(main):004:1&gt;</span>   puts a[i].to_i</span><br><span class="line"><span class="prompt">irb(main):005:1&gt;</span>   i = i + <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:1&gt;</span> end</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>这其实就是面向对象设计思想中的重要原则：对接口编码。举个例子，对象若有 <code>push</code> 和 <code>pop</code>，那么就可以当做栈来使用。</p>
<blockquote>
<p>函数</p>
</blockquote>
<p>函数的定义也和简单，并且，函数也是一个对象</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tell_the_truth</span></span></span><br><span class="line">    <span class="keyword">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组</p>
</blockquote>
<p>同样先来看实例</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> animals = [<span class="string">'lions'</span>, <span class="string">'tigers'</span>, <span class="string">'bears'</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>]</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> puts animals</span><br><span class="line">lions</span><br><span class="line">tigers</span><br><span class="line">bears</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> animals[<span class="number">2</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"bears"</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> animals[<span class="number">3</span>]</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> animals[-<span class="number">1</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"bears"</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> animals[<span class="number">0</span>..<span class="number">2</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>]</span><br><span class="line"><span class="prompt">irb(main):007:0&gt;</span> (<span class="number">0</span>..<span class="number">1</span>).class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">Range</span></span><br></pre></td></tr></table></figure>
<p>具体部分比较好明白，唯一需要注意的是 <code>0..1</code> 其实是个对象。另外 <code>[]</code> 是 <code>Array</code> 类的方法，所以 <code>[]</code> 和 <code>[]=</code> 其实是语法糖。想要用的话，必须先在变量里放一个空数组。数组元素不必具有相同类型。</p>
<blockquote>
<p>散列表</p>
</blockquote>
<p>其实就是键值对存储，来看例子</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> numbers = &#123;<span class="number">1</span> =&gt; <span class="string">'one'</span>, <span class="number">2</span> =&gt; <span class="string">'two'</span>&#125;</span><br><span class="line"><span class="status">=&gt;</span> &#123;<span class="number">1</span>=&gt;<span class="string">"one"</span>, <span class="number">2</span>=&gt;<span class="string">"two"</span>&#125;</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> numbers[<span class="number">1</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"one"</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> stuff = &#123;<span class="symbol">:array</span> =&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="symbol">:string</span> =&gt; <span class="string">'Hi, mom!'</span>&#125;</span><br><span class="line"><span class="status">=&gt;</span> &#123;<span class="symbol">:array=&gt;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="symbol">:string=&gt;<span class="string">"Hi, mom!"</span></span>&#125;</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> stuff[<span class="symbol">:string</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Hi, mom!"</span></span><br></pre></td></tr></table></figure>
<p>这里尤其需要注意 <code>stuff</code> 这个散列表，我们使用了 symbol 的概念，就是变量名称前面加个冒号。这样做的意义在于，相同的 symbol 会指向相同的物理对象，比如下面的例子，两次 <code>&#39;string&#39;</code> 的 id 值不一样，但是 <code>:string</code> 的值是一样的</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):005:0&gt;</span> <span class="string">'string'</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">70186296639880</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> <span class="string">'string'</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">70186296271240</span></span><br><span class="line"><span class="prompt">irb(main):007:0&gt;</span> <span class="symbol">:string</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">156648</span></span><br><span class="line"><span class="prompt">irb(main):008:0&gt;</span> <span class="symbol">:string</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">156648</span></span><br></pre></td></tr></table></figure>
<p>散列表的一个应用就是模拟命名参数（就是不同的参数有不同的名字，这样可以根据名字来引用，而不是根据预订好的位置类进行引用），例如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="function"><span class="keyword">def</span> <span class="title">tell_the_truth</span><span class="params">(options=&#123;&#125;)</span></span></span><br><span class="line"><span class="prompt">irb(main):002:1&gt;</span>   if options[<span class="symbol">:profession</span>] == <span class="symbol">:lawyer</span></span><br><span class="line"><span class="prompt">irb(main):003:2&gt;</span>     <span class="string">'oh you are a laywer'</span></span><br><span class="line"><span class="prompt">irb(main):004:2&gt;</span>   else</span><br><span class="line">irb(main)<span class="symbol">:</span><span class="number">005</span><span class="symbol">:</span><span class="number">2</span>*     <span class="string">'who you are'</span></span><br><span class="line"><span class="prompt">irb(main):006:2&gt;</span>   end</span><br><span class="line"><span class="prompt">irb(main):007:1&gt;</span> end</span><br><span class="line"><span class="status">=&gt;</span> <span class="symbol">:tell_the_truth</span></span><br><span class="line"><span class="prompt">irb(main):008:0&gt;</span> tell_the_truth</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"who you are"</span></span><br><span class="line"><span class="prompt">irb(main):009:0&gt;</span> tell_the_truth <span class="symbol">:profession</span> =&gt; <span class="symbol">:lawyer</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"oh you are a laywer"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>options</code> 表示可选参数，如果不传入，默认就是空散列表</li>
<li>散列表用作最后一个参数的时候可以省略大括号</li>
</ul>
<blockquote>
<p>代码块和 yield</p>
</blockquote>
<p>代码块就是匿名函数，可以作为参数传递，比如说</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="number">3</span>.times &#123;puts <span class="string">'great day!'</span>&#125;</span><br><span class="line">great day!</span><br><span class="line">great day!</span><br><span class="line">great day!</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">3</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> animals = [<span class="string">'lions'</span>, <span class="string">'tigers'</span>, <span class="string">'bears'</span>, <span class="string">'rabbits'</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>, <span class="string">"rabbits"</span>]</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> animals.each &#123;|a| puts a&#125;</span><br><span class="line">lions</span><br><span class="line">tigers</span><br><span class="line">bears</span><br><span class="line">rabbits</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>, <span class="string">"rabbits"</span>]</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> animals.each do |a| \</span><br><span class="line">irb(main)<span class="symbol">:</span><span class="number">005</span><span class="symbol">:</span><span class="number">1</span>*                 puts a <span class="keyword">end</span></span><br><span class="line">lions</span><br><span class="line">tigers</span><br><span class="line">bears</span><br><span class="line">rabbits</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>, <span class="string">"rabbits"</span>]</span><br></pre></td></tr></table></figure>
<p>代码块只占一行时用 <code>{ / }</code>，多行的话则使用 <code>do / end</code>。如果我们要实现自己的 <code>times</code> 函数要怎么做呢？其实也很简单，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Fixnum</span></span></span><br><span class="line"><span class="prompt">irb(main):002:1&gt;</span>   <span class="function"><span class="keyword">def</span> <span class="title">my_times</span></span></span><br><span class="line"><span class="prompt">irb(main):003:2&gt;</span>     i = self</span><br><span class="line"><span class="prompt">irb(main):004:2&gt;</span>     while i &gt; <span class="number">0</span></span><br><span class="line"><span class="prompt">irb(main):005:3&gt;</span>       i = i - <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:3&gt;</span>       yield</span><br><span class="line"><span class="prompt">irb(main):007:3&gt;</span>     end</span><br><span class="line"><span class="prompt">irb(main):008:2&gt;</span>   end</span><br><span class="line"><span class="prompt">irb(main):009:1&gt;</span> end</span><br><span class="line"><span class="status">=&gt;</span> <span class="symbol">:my_times</span></span><br><span class="line"><span class="prompt">irb(main):010:0&gt;</span> <span class="number">3</span>.my_times &#123;puts <span class="string">'my own times!'</span>&#125;</span><br><span class="line">my own times!</span><br><span class="line">my own times!</span><br><span class="line">my own times!</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>因为代码块可以作为参数，于是类似于函数指针，可以更加灵活进行调用。</p>
<blockquote>
<p>面向对象</p>
</blockquote>
<p>主要是类和模块，这里设计的知识点比较繁杂，可以自行阅读参考链接中的文档，这里不再赘述</p>
<blockquote>
<p>优劣</p>
</blockquote>
<p>使用 Ruby 可以用一致的方向处理对象，还有各种不同的语法糖，可以有效提高编程的效率，不过这也导致一定的性能损失。另外，ruby 在并发条件下会产生严重问题（资源竞争）</p>
<h2 id="u4E60_u9898"><a href="#u4E60_u9898" class="headerlink" title="习题"></a>习题</h2><blockquote>
<p>替换字符串某一部分</p>
</blockquote>
<p>字符串相关的操作可以在<a href="http://ruby-doc.org/core-2.3.0/String.html" target="_blank" rel="external">这里</a>查看（其他的类也可以通过这种方式来学习）</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> title = <span class="string">"This is DaWang."</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"This is DaWang."</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> title[<span class="number">0</span>,<span class="number">3</span>] = <span class="string">"That"</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"That"</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> title</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Thats is DaWang."</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> title[<span class="number">0</span>,<span class="number">5</span>] = <span class="string">"That"</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"That"</span></span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> title</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"That is DaWang."</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意字符串的位置索引，具体可以试验一下。</p>
<blockquote>
<p>在字符串 <code>Hello, dawang</code> 中，找到 <code>dawang</code> 所在下标 </p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> s = <span class="string">'Hello, dawang'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Hello, dawang"</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> i = s.index(<span class="string">'dawang'</span>)</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>打印名字十次，并输出序号</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> name = <span class="string">'dawang'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"dawang"</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> i = <span class="number">0</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> while i &lt; <span class="number">10</span></span><br><span class="line"><span class="prompt">irb(main):004:1&gt;</span>   puts <span class="string">"<span class="subst">#&#123;i+<span class="number">1</span>&#125;</span> <span class="subst">#&#123;name&#125;</span>"</span></span><br><span class="line"><span class="prompt">irb(main):005:1&gt;</span>   i = i + <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:1&gt;</span> end</span><br><span class="line"><span class="number">1</span> dawang</span><br><span class="line"><span class="number">2</span> dawang</span><br><span class="line"><span class="number">3</span> dawang</span><br><span class="line"><span class="number">4</span> dawang</span><br><span class="line"><span class="number">5</span> dawang</span><br><span class="line"><span class="number">6</span> dawang</span><br><span class="line"><span class="number">7</span> dawang</span><br><span class="line"><span class="number">8</span> dawang</span><br><span class="line"><span class="number">9</span> dawang</span><br><span class="line"><span class="number">10</span> dawang</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从文件运行 Ruby 程序</p>
</blockquote>
<p>类似 python，直接 <code>ruby filename</code> 即可，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [8:47:56]</span></span><br><span class="line">$ cat test.rb</span><br><span class="line">name = <span class="string">'dawang'</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span></span><br><span class="line">    puts <span class="string">"#&#123;i+1&#125; #&#123;name&#125;"</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [8:48:36]</span></span><br><span class="line">$ ruby test.rb</span><br><span class="line"><span class="number">1</span> dawang</span><br><span class="line"><span class="number">2</span> dawang</span><br><span class="line"><span class="number">3</span> dawang</span><br><span class="line"><span class="number">4</span> dawang</span><br><span class="line"><span class="number">5</span> dawang</span><br><span class="line"><span class="number">6</span> dawang</span><br><span class="line"><span class="number">7</span> dawang</span><br><span class="line"><span class="number">8</span> dawang</span><br><span class="line"><span class="number">9</span> dawang</span><br><span class="line"><span class="number">10</span> dawang</span><br></pre></td></tr></table></figure>
<blockquote>
<p>生成一个 0~9 的随机数，让用户猜，并告知结果</p>
</blockquote>
<p>具体可以直接看代码</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [9:07:47]</span></span><br><span class="line"><span class="variable">$ </span>cat test.rb</span><br><span class="line">puts <span class="string">'Please input a number between 0~9: '</span></span><br><span class="line">numstr = gets</span><br><span class="line">num = numstr.to_i(base=<span class="number">10</span>)</span><br><span class="line">puts <span class="string">'Generating random number..'</span></span><br><span class="line">target = rand(<span class="number">10</span>)</span><br><span class="line">puts <span class="string">"The target number is <span class="subst">#&#123;target&#125;</span>"</span></span><br><span class="line"><span class="keyword">if</span> num == target</span><br><span class="line">    puts <span class="string">'You made it!'</span></span><br><span class="line"><span class="keyword">elsif</span> num &lt; target</span><br><span class="line">    puts <span class="string">'Answer Too Small!'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    puts <span class="string">'Answer Too Large!'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [9:07:53]</span></span><br><span class="line"><span class="variable">$ </span>ruby test.rb</span><br><span class="line"><span class="constant">Please</span> input a number between <span class="number">0</span>~<span class="number">9</span><span class="symbol">:</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="constant">Generating</span> random number..</span><br><span class="line"><span class="constant">The</span> target number is <span class="number">6</span></span><br><span class="line"><span class="constant">Answer</span> <span class="constant">Too</span> <span class="constant">Small</span>!</span><br></pre></td></tr></table></figure>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://ruby-doc.org/core-2.3.0/" target="_blank" rel="external">Ruby APi</a></li>
<li><a href="http://ruby-doc.com/docs/ProgrammingRuby/" target="_blank" rel="external">Programming Ruby: The Pragmatic Programmer’s Guide</a></li>
<li><a href="http://www.runoob.com/ruby/ruby-regular-expressions.html" target="_blank" rel="external">Ruby 正则表达式</a></li>
<li><a href="http://www.runoob.com/ruby/ruby-range.html" target="_blank" rel="external">Ruby 区间(range)</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>学编程就好比学有用，再好的理论也不如一头扎下水，扑腾着呼吸新鲜空气管用。这个系列的目的，就是帮助自己跳入水中，这一次我们来学 Ruby。</p>]]>
    
    </summary>
    
      <category term="Ruby" scheme="http://wdxtub.com/tags/Ruby/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="语言" scheme="http://wdxtub.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 习题课 6 设计模式进阶练习]]></title>
    <link href="http://wdxtub.com/2016/03/30/sad-r6/"/>
    <id>http://wdxtub.com/2016/03/30/sad-r6/</id>
    <published>2016-03-30T11:11:03.000Z</published>
    <updated>2016-03-30T11:15:07.000Z</updated>
    <content type="html"><![CDATA[<p>接着上次的练习，这次给出具体场景，来进行设计模式的应用，咱们直接看习题。</p>
<a id="more"></a>
<hr>
<blockquote>
<p>Consider this scenario. The business decision process of a company involves several decision makers.Each position has can have its own set of rules which orders they can approve. In more detail, each executive can respond to a purchase request within a certain price range. Beyond the range, the executive needs to hand it off to her superior. A director can approve a purchase order within <code>$10K</code>; a VP can approve within <code>$25K</code>; and a President can approve within <code>$100K</code>. Beyond that, an executive meeting has to be called to make the decision. To solve this scenario, which design pattern would you like to use? Develop a program to implement this scenario associated with test code.</p>
</blockquote>
<p>TODO</p>
<blockquote>
<p>At an airport, typically there is an airport control tower. All airplanes talk to the control tower instead of having plane-to-plane communication. The control tower looks after which airplane can take off and land. In order to implement such a scenario, which design pattern would you suggest to use? Briefly implement your idea associated with test code.</p>
</blockquote>
<p>TODO</p>
<blockquote>
<p>Which design pattern is suitable to enable the round-robin CPU scheduling strategy? A CPU typically serves multiple applications simultaneously. Applications will be loaded to memory in a waiting queue. When it is its turn, it will be loaded to CPU to execute. After a common time unit, the application will be swapped out of the CPU and wait for its next turn, and the next application in the queue will be loaded into the CPU to execute. In order for an application to be resumed execution from the last time it was paused, it is important that its context be stored before being moved out of CPU and be recovered before it is loaded into CPU once again. Which design pattern is suitable to realize this context switch scenario? Draw class diagram and write pseudo code.</p>
</blockquote>
<p>TODO</p>
<blockquote>
<p>Company is trying to implement a message bus between services, supporting different types of multi-casting and broadcasting communication scenarios. A service can broadcast a message to all services registered in the message bus. In addition, services can form interest groups, and a service can send messages to its group member services. Which design pattern is suitable to design such a message bus? Draw class diagram and write pseudo code.</p>
</blockquote>
<p>TODO</p>
<blockquote>
<p>In the real world you usually find buildings in a community look similar. For example, the buildings appear in the same shape and structures, but each has specific color. It is reasonable to think they share a basic house plan, while have variations. Which design pattern is reflected here? Draw class diagram and write pseudo code.</p>
</blockquote>
<p>TODO</p>
<blockquote>
<p>Describe a real-life example that illustrates an application of the state design pattern.</p>
</blockquote>
<p>TODO</p>
<blockquote>
<p>Describe a real-life example that illustrates an application of the visitor design pattern.</p>
</blockquote>
<p>TODO</p>
<blockquote>
<p>Describe a real-life example that illustrates an application of the command design pattern.</p>
</blockquote>
<p>TODO</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接着上次的练习，这次给出具体场景，来进行设计模式的应用，咱们直接看习题。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="习题" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 反思课 4 HBase 优化的策略与思考]]></title>
    <link href="http://wdxtub.com/2016/03/29/cc-rethink-4/"/>
    <id>http://wdxtub.com/2016/03/29/cc-rethink-4/</id>
    <published>2016-03-30T00:18:51.000Z</published>
    <updated>2016-03-30T03:44:46.000Z</updated>
    <content type="html"><![CDATA[<p>优化的最大敌人，是反向优化。</p>
<a id="more"></a>
<hr>
<p>这次的小组作业还是挺费事费时的，虽然我也还没有做到满分，但是这两天的一些尝试还是值得记录一下的，也算是给大家提个醒。一个很深的感触：捷径就是把该走的该经历的都过完，想歪门邪道一步登天的，往往都是绕远路。</p>
<h2 id="u6570_u636E_u5904_u7406"><a href="#u6570_u636E_u5904_u7406" class="headerlink" title="数据处理"></a>数据处理</h2><p>这部分的任务可能是这次作业我做得最不好的地方，主要是因为没有在动手前设计好整个流程思路。因为时间紧，没有仔细分析问题和情境，但最终欲速则不达，像无头苍蝇一样试验各种方法出各种差错。盲目乐观和照搬 MySQL 部分的实现思路（我负责 HBase 部分），遇到问题之后依靠『侥幸』而不是『思考』来解决问题，实在是大失水准。</p>
<p>具体来看，主要有：</p>
<ol>
<li>合并数据时候实现算法不细致，用测试集测试的时候没有检查出错误，到最后导入完数据开始部署好了才发现错，每次导入+部署的半个多小时就因为这里的失误而浪费了</li>
<li>处理数据的流程没有事先规划好，遇到错误拆东墙补西墙，最后全部推倒重来才做好，以后不能再这样</li>
<li>没有设计好测试用例，导致每个步骤都不知道自己对不对，依靠『侥幸』写代码肯定要出大问题</li>
</ol>
<p>时间再紧也要谋定而后动，战略偷懒只会导致战术回旋空间变小，最终导致各种『无用功』。</p>
<h2 id="u5E73_u53F0_u9009_u62E9"><a href="#u5E73_u53F0_u9009_u62E9" class="headerlink" title="平台选择"></a>平台选择</h2><p>原先使用 Amazon EMR 来搭建 HBase，主要有几个问题：</p>
<ol>
<li>HBase 版本较低</li>
<li>没办法随时调整参数（虽然后来意识到参数是浮云）</li>
<li>性能糟糕（当然也可能是我不会用）</li>
<li>贵（除了机器本身的费用，EMR 也是要钱的）</li>
</ol>
<p>所以后来选择使用 Cloudera 来搭建自己的 Hadoop 框架平台。因为老师没有给出太多相关的资料，基本上就是一边看着文档，一个坑一个坑踩过来的。虽然没有 Amazon EMR 这么简单粗暴，但是后来看到性能明显提升，也就值得了。总的来说有以下的感觉：</p>
<ol>
<li>配置的过程其实已经尽可能简化了，基本需要手动操作的就是把交换空间设为 0，其他基本都可以在网络界面上完成（Cloudera 做得还是挺不错的，好顶赞）</li>
<li>根据自己的需要选择合适的服务，多的话用不上还占内存</li>
<li>多多利用 Cloudera 的监控表盘可以得到很多有用的信息，据此可以找到瓶颈所在</li>
<li>RegionServer 中 Region 的分布平衡很重要，Region 不能太少也不能太多，没有所谓定值，需要不断测试和优化（实在不行的话，多 split 几次也没啥问题）</li>
<li>很多参数其实不懂具体的含义，对于这种大的平台还是需要仔细研究才能真正把强大的工具用好</li>
<li>Cloudera 已经进行了一定的参数优化，基本上不用改动（尤其是在自己都不知道自己在干嘛的时候）</li>
</ol>
<p>最后就是想要强调监控数据的重要性，如何挑选需要的数据，如何去分析这些数据里面都有门道，要好好学习。</p>
<h2 id="u53C2_u6570_u8BBE_u7F6E"><a href="#u53C2_u6570_u8BBE_u7F6E" class="headerlink" title="参数设置"></a>参数设置</h2><p>忽然想到这么一句话</p>
<blockquote>
<p>按照大多数人数据库设计和代码实现的糟糕程度，根本轮不到拼参数</p>
</blockquote>
<p>像我这样的初学者，往往过分夸大了参数的重要性，只有当系统达到了瓶颈，然后对应去调整相关参数才是有意义的。按照我之前的做法，既不知道问题在哪，更谈不上硬件的充分利用，就盲目根据网上的教程来进行『优化』，所做的基本都是『反向优化』。</p>
<p>所以这个时候搜索相关网页以及请教同学都是非常有帮助的，有了大致的方向会好很多，不然在一无所知的情况下真的很容易病急乱投医。</p>
<p>不同参数的设置一定要弄清楚具体代表什么，什么时候需要改，改了会有什么影响这一系列问题之后，再进行修改测试。</p>
<p>总的来说还是学到不少东西的，以后早些开始，继续努力。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>优化的最大敌人，是反向优化。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="优化" scheme="http://wdxtub.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[范式转移]]></title>
    <link href="http://wdxtub.com/2016/03/27/paradigm-shift/"/>
    <id>http://wdxtub.com/2016/03/27/paradigm-shift/</id>
    <published>2016-03-28T00:18:45.000Z</published>
    <updated>2016-03-28T02:19:32.000Z</updated>
    <content type="html"><![CDATA[<p>所谓范式，是一套非常清晰的概念、思维模式、研究方法、假设和标准。从这些基准出发，我们可以推导演绎出『真理』。但假如有一天，基准改变了，是不是这些『真理』，也就不再『真』了？</p>
<a id="more"></a>
<hr>
<p>前段时间知道了『范式转移』这个概念，感觉很有意思，但是拖着拖着一直到今天才动笔。一是懒，二是最近生活中的一些变化也印证了『范式转移』本身，能够说道说道了。</p>
<p>简单来说，范式转移可以看做是一种根本假设的改变，继而带来翻天覆地的影响。对于我们来说，范式转移更应该接近于『范式升级』，我们要改变的不仅是思维，而是对事物对人情的更准确更基本的认识。</p>
<p>从去年九十月份开始一路面试了半年，了解了许多之前不熟悉的圈子，接触了不同的行业、公司、职位。虽然通过面试官来了解一个公司有些『管中窥豹』，但是至少要比从新闻中得来的要真实。毕竟新闻里说得都是最好的一面，刚入职的话，更可能接触的就是面试官一级的人。大公司选组更像是摇骰子，小公司更多时候是跟着创始人的想法走。我既不想把未来寄托于概率，也不想丢掉太多的自主性，那么正在发展转型期的已经证明自己的公司恐怕是最佳的选择，既可以通过自己的努力主导技术及业务方向，又可以不被各种制度流程所束缚。</p>
<p>从学生向社会人转变，其实就是一个『范式转移』的过程。校园是静态的，成绩、奖项以及几乎固定的同学；只要分数高，很多事儿都不是事儿；社会是动态的，环境、形势一直在变；前行路上难免磕磕碰碰，荣时知辱，逆时知顺。</p>
<p>在选择职业选择公司的时候，重要的是『三观一致』，知道自己的价值，去最能发光发热的地方去。</p>
<blockquote>
<p>一个人的命运，当然要靠自我奋斗，但是也要考虑到历史的行程。</p>
</blockquote>
<p>职业发展一定要从长远的角度思考，慢慢去摸索未来与趋势，顺势而为。俗一点说，在大家都能赚钱的时候才最好赚钱。与人相处，也更应该『职业』一些，以合作为主、待人接物自然（不要凡事都写在脸上），珍惜别人的时间，让身边的人变得更好，从更大的格局去看待问题。</p>
<p>另外，从课程考试向『做成事情』转变，也是重中之重。很多时候，我们是因为没有能力做好手头上的事情，所以才不喜欢。而越是工作做不好的无用之人，就越是会强调自己有多努力。</p>
<p>无论是在学校还是在公司，重要的不是分数的高低还是职位的级别，而是全身心投入，去验证自己的想法。不要专门去做那些证明自己的事情，事实会说明一切。</p>
<p>这也是为什么我决定从 iOS 开发转到后台系统的开发。iOS 实在太火了，各种培训班批量生产学员搞得乌烟瘴气（最近的前端热估计也是这个套路），开发一款基本的应用难度也越来越低。当然，高端人才总是稀缺的，但是有这样的大环境在，又岂能独善其身呢？</p>
<p>做成事情的重点是策略和坚持，而坚持就是最重要的策略。越来越觉得，无论是编程、雕刻还是建筑，都是技术加艺术的结晶，天赋固然重要，但刻苦练习也是不可或缺的。想要做成事情，不把手弄『脏』是不可能的。</p>
<p>于是主题就变成：范式转移了吗？手弄脏了吗？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>所谓范式，是一套非常清晰的概念、思维模式、研究方法、假设和标准。从这些基准出发，我们可以推导演绎出『真理』。但假如有一天，基准改变了，是不是这些『真理』，也就不再『真』了？</p>]]>
    
    </summary>
    
      <category term="改变" scheme="http://wdxtub.com/tags/%E6%94%B9%E5%8F%98/"/>
    
      <category term="范式" scheme="http://wdxtub.com/tags/%E8%8C%83%E5%BC%8F/"/>
    
      <category term="远见" scheme="http://wdxtub.com/tags/%E8%BF%9C%E8%A7%81/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【鸟哥的 Linux 私房菜 - 基础】学习笔记]]></title>
    <link href="http://wdxtub.com/2016/03/26/linux-basic-soup/"/>
    <id>http://wdxtub.com/2016/03/26/linux-basic-soup/</id>
    <published>2016-03-27T01:33:53.000Z</published>
    <updated>2016-03-27T17:20:41.000Z</updated>
    <content type="html"><![CDATA[<p>因为之后更多会涉及后台开发的部分，所以系统学习一下 Linux 还是很有必要的，这里就用《鸟哥的 Linux 私房菜》作为主要的学习材料。不过因为我本身已经有一定基础了，所以这里主要会记录个人觉得比较生疏和重要的地方。</p>
<a id="more"></a>
<hr>
<p>对于计算机的基本了解，可以参考我之前写的『深入理解计算机系统』系列日志。接下来主要是比较零散的知识点，具体可以参见目录。</p>
<h2 id="u5E38_u7528_u6280_u5DE7"><a href="#u5E38_u7528_u6280_u5DE7" class="headerlink" title="常用技巧"></a>常用技巧</h2><ul>
<li>遇到不懂的命令，一定先用 <code>man</code> 命令来了解一下，可以看到详细的介绍<ul>
<li><code>/string</code> 向下搜索 string 这个字符串</li>
<li><code>?string</code> 向上搜索这个字符串</li>
<li>搜索的时候输入 n, N 可以跳到下一个/上一个结果 ，q 可以退出</li>
</ul>
</li>
<li>遇到不懂的命令，可以使用 <code>info</code> 命令来查看<ul>
<li>n（下一个），p（前一个），u（上一层），h（帮助），q（退出）</li>
</ul>
</li>
<li>nano 是非常简单的编辑器，只需要 <code>nano filename</code> 即可，具体的操作会在终端中显示<ul>
<li><code>^</code> 表示 ctrl 按键</li>
</ul>
</li>
<li>改变文件属性与权限的命令<ul>
<li><code>chgrp</code>：改变文件所属群组</li>
<li><code>chown</code>：改变文件拥有者</li>
<li><code>chmod</code>：改变文件权限</li>
</ul>
</li>
<li>目录相关操作<ul>
<li><code>.</code>：代表此层目录</li>
<li><code>..</code>：代表上一层目录</li>
<li><code>-</code>：代表前一个工作目录</li>
<li><code>~</code>：代表“目前使用者身份”所在的主文件夹</li>
<li><code>~account</code>：代表 account 这个使用者的主文件夹（account是个帐号名称）</li>
<li>在所有目录下面都会存在的两个目录，分别是“.”与“..” 分别代表此层与上层目录的意思</li>
<li><code>cd</code>：变化目录</li>
<li><code>pwd</code>：显示目前目录</li>
<li><code>mkdir</code>：创建新目录</li>
<li><code>rmdir</code>：删除一个空的目录</li>
</ul>
</li>
<li>可执行文件路径变量 <code>$PATH</code><ul>
<li>当我们在执行一个指令的时候，举例来说“ls”好了，系统会依照PATH的设置去每个PATH定义的目录下搜寻文件名为ls的可执行文件， 如果在PATH定义的目录中含有多个文件名为ls的可可执行文件，那么先搜寻到的同名指令先被执行！</li>
<li><code>echo $PATH</code> 来查看当前的值</li>
</ul>
</li>
</ul>
<h2 id="u547D_u4EE4_3A_ls_2C_cp_2C_rm_2C_mv"><a href="#u547D_u4EE4_3A_ls_2C_cp_2C_rm_2C_mv" class="headerlink" title="命令: ls, cp, rm, mv"></a>命令: ls, cp, rm, mv</h2><blockquote>
<p>ls 用来查看文件与目录，选项与参数为：</p>
</blockquote>
<ul>
<li><code>-a</code>：全部的文件，连同隐藏文件（ 开头为 . 的文件） 一起列出来（常用）</li>
<li><code>-A</code>：全部的文件，连同隐藏文件，但不包括 . 与 .. 这两个目录</li>
<li><code>-d</code>：仅列出目录本身，而不是列出目录内的文件数据（常用）</li>
<li><code>-f</code>：直接列出结果，而不进行排序 （ls 默认会以文件名排序！）</li>
<li><code>-F</code>：根据文件、目录等信息，给予附加数据结构，例如：<code>*:</code> 代表可可执行文件； <code>/:</code> 代表目录； <code>=:</code> 代表 socket 文件； <code>|:</code> 代表 FIFO 文件；</li>
<li><code>-h</code>：将文件大小以人类较易读的方式（例如 GB, KB 等等）列出来；</li>
<li><code>-i</code>：列出 inode 号码，inode 的意义下一章将会介绍；</li>
<li><code>-l</code>：长数据串行出，包含文件的属性与权限等等数据；（常用）</li>
<li><code>-n</code>：列出 UID 与 GID 而非使用者与群组的名称 （UID与GID会在帐号管理提到！）</li>
<li><code>-r</code>：将排序结果反向输出，例如：原本文件名由小到大，反向则为由大到小；</li>
<li><code>-R</code>：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来；</li>
<li><code>-S</code>：以文件大小大小排序，而不是用文件名排序；</li>
<li><code>-t</code>：依时间排序，而不是用文件名。</li>
<li><code>--color=never</code>：不要依据文件特性给予颜色显示；</li>
<li><code>--color=always</code>：显示颜色</li>
<li><code>--color=auto</code>：让系统自行依据设置来判断是否给予颜色</li>
<li><code>--full-time</code>：以完整时间模式 （包含年、月、日、时、分） 输出</li>
<li><code>--time={atime,ctime}</code>：输出 access 时间或改变权限属性时间 （ctime） 而非内容变更时间 （modification time）</li>
</ul>
<blockquote>
<p>cp 用来复制文件或者创建链接，选项与参数为：</p>
</blockquote>
<ul>
<li><code>-a</code>：相当于 -dr –preserve=all 的意思，至于 dr 请参考下列说明；（常用）</li>
<li><code>-d</code>：若来源文件为链接文件的属性（link file），则复制链接文件属性而非文件本身；</li>
<li><code>-f</code>：为强制（force）的意思，若目标文件已经存在且无法打开，则移除后再尝试一次；</li>
<li><code>-i</code>：若目标文件（destination）已经存在时，在覆盖时会先询问动作的进行（常用）</li>
<li><code>-l</code>：进行硬式链接（hard link）的链接文件创建，而非复制文件本身；</li>
<li><code>-p</code>：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）；</li>
<li><code>-r</code>：递回持续复制，用于目录的复制行为；（常用）</li>
<li><code>-s</code>：复制成为符号链接文件 （symbolic link），亦即“捷径”文件；</li>
<li><code>-u</code>：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制。</li>
<li><code>--preserve=all</code>：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了。最后需要注意的，如果来源文件有两个以上，则最后一个目的文件一定要是“目录”才行！</li>
</ul>
<blockquote>
<p>mv 用来移动文件或者重命名，选项与参数为：</p>
</blockquote>
<ul>
<li><code>-f</code>：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li><code>-i</code>：若目标文件 （destination） 已经存在时，就会询问是否覆盖！</li>
<li><code>-u</code>：若目标文件已经存在，且 source 比较新，才会更新 （update）</li>
</ul>
<blockquote>
<p>rm 用来删除文件，选项与参数为：</p>
</blockquote>
<ul>
<li><code>-f</code>：就是 force 的意思，忽略不存在的文件，不会出现警告讯息；</li>
<li><code>-i</code>：互动模式，在删除前会询问使用者是否动作</li>
<li><code>-r</code>：递回删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
</ul>
<h2 id="u547D_u4EE4_3A_cat_2C_tac_2C_nl_2C_more_2C_less"><a href="#u547D_u4EE4_3A_cat_2C_tac_2C_nl_2C_more_2C_less" class="headerlink" title="命令: cat, tac, nl, more, less"></a>命令: cat, tac, nl, more, less</h2><blockquote>
<p>cat 由第一行开始显示文件内容</p>
</blockquote>
<ul>
<li><code>-A</code>：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li><code>-b</code>：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li><code>-E</code>：将结尾的断行字符 $ 显示出来；</li>
<li><code>-n</code>：打印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li><code>-T</code>：将 [tab] 按键以 ^I 显示出来；</li>
<li><code>-v</code>：列出一些看不出来的特殊字符</li>
</ul>
<blockquote>
<p>tac  从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</p>
</blockquote>
<p>具体的参数和 cat 是一致的，这里不赘述</p>
<blockquote>
<p>nl   显示的时候，顺道输出行号！</p>
</blockquote>
<ul>
<li><code>-b</code>：指定行号指定的方式，主要有两种：<ul>
<li><code>-b a</code>：表示不论是否为空行，也同样列出行号（类似 cat -n）；</li>
<li><code>-b t</code>：如果有空行，空的那一行不要列出行号（默认值）；</li>
</ul>
</li>
<li><code>-n</code>：列出行号表示的方法，主要有三种：<ul>
<li><code>-n ln</code>：行号在屏幕的最左方显示；</li>
<li><code>-n rn</code>：行号在自己字段的最右方显示，且不加 0 ；</li>
<li><code>-n rz</code>：行号在自己字段的最右方显示，且加 0 ；</li>
</ul>
</li>
<li><code>-w</code>：行号字段的占用的字符数。</li>
</ul>
<blockquote>
<p>more 一页一页的显示文件内容，支持的按键有</p>
</blockquote>
<ul>
<li><code>空格</code>：代表向下翻一页；</li>
<li><code>Enter</code>：代表向下翻“一行”；</li>
<li><code>/字串</code>：代表在这个显示的内容当中，向下搜寻“字串”这个关键字；</li>
<li><code>:f</code>：立刻显示出文件名以及目前显示的行数；</li>
<li><code>q</code>：代表立刻离开 more ，不再显示该文件内容。</li>
<li><code>b 或 [ctrl]-b</code>：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<blockquote>
<p>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！支持的按键有</p>
</blockquote>
<ul>
<li><code>空格</code>：向下翻动一页；</li>
<li><code>[pagedown]</code>：向下翻动一页；</li>
<li><code>[pageup]</code>：向上翻动一页；</li>
<li><code>/字串</code>：向下搜寻“字串”的功能；</li>
<li><code>?字串</code>：向上搜寻“字串”的功能；</li>
<li><code>n</code>：重复前一个搜寻 （与 / 或 ? 有关！）</li>
<li><code>N</code>：反向的重复前一个搜寻 （与 / 或 ? 有关！）</li>
<li><code>g</code>：前进到这个数据的第一行去；</li>
<li><code>G</code>：前进到这个数据的最后一行去 （注意大小写）；</li>
<li><code>q</code>：离开 less 这个程序；</li>
</ul>
<p>你是否会觉得 less 使用的画面与环境与 man page 非常的类似呢？没错啦！因为man这个指令就是调用 less 来显示说明文档的内容的！</p>
<h2 id="u547D_u4EE4_3A_head_2C_tail_2C_od_2C_touch"><a href="#u547D_u4EE4_3A_head_2C_tail_2C_od_2C_touch" class="headerlink" title="命令: head, tail, od, touch"></a>命令: head, tail, od, touch</h2><blockquote>
<p>head 只看头几行</p>
</blockquote>
<ul>
<li><code>-n</code>：后面接数字，代表显示几行的意思</li>
<li>另外那个 -n 选项后面的参数较有趣，如果接的是负数，例如上面范例的 -n -100时，代表列前的所有行数， 但不包括后面100行</li>
</ul>
<blockquote>
<p>tail 只看尾巴几行</p>
</blockquote>
<ul>
<li><code>-n</code>：后面接数字，代表显示几行的意思</li>
<li><code>-f</code>：表示持续侦测后面所接的文件名，要等到按下[ctrl]-c才会结束tail的侦测</li>
</ul>
<blockquote>
<p>od 以二进制的方式读取文件内容！</p>
</blockquote>
<ul>
<li><code>-t</code>：后面可以接各种“类型 （TYPE）”的输出，例如：<ul>
<li><code>a</code>：利用默认的字符来输出；</li>
<li><code>c</code>：使用 ASCII 字符来输出</li>
<li><code>d[size]</code>：利用十进制（decimal）来输出数据，每个整数占用 size Bytes ；</li>
<li><code>f[size]</code>：利用浮点数值（floating）来输出数据，每个数占用 size Bytes ；</li>
<li><code>o[size]</code>：利用八进位（octal）来输出数据，每个整数占用 size Bytes ；</li>
<li><code>x[size]</code>：利用十六进制（hexadecimal）来输出数据，每个整数占用 size Bytes ；</li>
</ul>
</li>
</ul>
<blockquote>
<p>touch 修改文件时间或创建新文件</p>
</blockquote>
<p>我们在 ls 这个指令的介绍时，有稍微提到每个文件在linux下面都会记录许多的时间参数， 其实是有三个主要的变动时间，那么三个时间的意义是什么呢？</p>
<ul>
<li>modification time （mtime）：<ul>
<li>当该文件的“内容数据”变更时，就会更新这个时间！内容数据指的是文件的内容，而不是文件的属性或权限喔！</li>
</ul>
</li>
<li>status time （ctime）：<ul>
<li>当该文件的“状态 （status）”改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间啊。</li>
</ul>
</li>
<li>access time （atime）：<ul>
<li>当“该文件的内容被取用”时，就会更新这个读取时间 （access）。举例来说，我们使用 cat 去读取 /etc/man_db.conf ， 就会更新该文件的 atime 了。</li>
</ul>
</li>
</ul>
<p>选项与参数</p>
<ul>
<li><code>-a</code>：仅修订 access time；</li>
<li><code>-c</code>：仅修改文件的时间，若该文件不存在则不创建新文件；</li>
<li><code>-d</code>：后面可以接欲修订的日期而不用目前的日期，也可以使用 –date=”日期或时间”</li>
<li><code>-m</code>：仅修改 mtime ；</li>
<li><code>-t</code>：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]</li>
</ul>
<h2 id="u547D_u4EE4_3A_file_2C_which_2C_whereis_2C_locate/updatedb_2C_find"><a href="#u547D_u4EE4_3A_file_2C_which_2C_whereis_2C_locate/updatedb_2C_find" class="headerlink" title="命令: file, which, whereis, locate/updatedb, find"></a>命令: file, which, whereis, locate/updatedb, find</h2><blockquote>
<p>file 观察文件类型</p>
</blockquote>
<p>如果你想要知道某个文件的基本数据，例如是属于 ASCII 或者是 data 文件，或者是 binary ， 且其中有没有使用到动态函数库 （share library） 等等的信息，就可以利用 file 这个指令来检阅喔！</p>
<blockquote>
<p>which 指令文件名的搜寻 </p>
</blockquote>
<p><code>which [-a] command</code> 选项或参数：</p>
<ul>
<li><code>-a</code>：将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称</li>
</ul>
<blockquote>
<p>whereis 由一些特定的目录中寻找文件文件名</p>
</blockquote>
<p><code>whereis [-bmsu] 文件或目录名</code>  选项或参数：</p>
<ul>
<li><code>-l</code>:可以列出 whereis 会去查询的几个主要目录而已</li>
<li><code>-b</code>:只找 binary 格式的文件</li>
<li><code>-m</code>:只找在说明文档 manual 路径下的文件</li>
<li><code>-s</code>:只找 source 来源文件</li>
<li><code>-u</code>:搜寻不在上述三个项目当中的其他特殊文件</li>
</ul>
<blockquote>
<p>locate 搜索包含指定词的文件</p>
</blockquote>
<p><code>locate [-ir] keyword</code> 选项与参数：</p>
<ul>
<li><code>-i</code>：忽略大小写的差异；</li>
<li><code>-c</code>：不输出文件名，仅计算找到的文件数量</li>
<li><code>-l</code>：仅输出几行的意思，例如输出五行则是 -l 5</li>
<li><code>-S</code>：输出 locate 所使用的数据库文件的相关信息，包括该数据库纪录的文件/目录数量等</li>
<li><code>-r</code>：后面可接正则表达式的显示方式</li>
</ul>
<p>locate 寻找的数据是由“已创建的数据库 /var/lib/mlocate/” 里面的数据所搜寻到的，所以不用直接在去硬盘当中存取数据。那么有什么限制呢？就是因为他是经由数据库来搜寻的，而数据库的创建默认是在每天执行一次 </p>
<p>那能否手动更新数据库哪？当然可以啊！更新 locate 数据库的方法非常简单，直接输入“ updatedb ”就可以了！ updatedb 指令会去读取 /etc/updatedb.conf 这个配置文件的设置，然后再去硬盘里面进行搜寻文件名的动作， 最后就更新整个数据库文件啰！因为 updatedb 会去搜寻硬盘，所以当你执行 updatedb 时，可能会等待数分钟的时间喔！</p>
<blockquote>
<p>find 查找具体文件</p>
</blockquote>
<p><code>find [PATH] [option] [action]</code> 选项与参数：</p>
<ul>
<li>与时间有关的选项：共有 -atime, -ctime 与 -mtime ，以 -mtime 说明<ul>
<li><code>-mtime  n</code>：n 为数字，意义为在 n 天之前的“一天之内”被更动过内容的文件；</li>
<li><code>-mtime +n</code>：列出在 n 天之前（不含 n 天本身）被更动过内容的文件文件名；</li>
<li><code>-mtime -n</code>：列出在 n 天之内（含 n 天本身）被更动过内容的文件文件名。</li>
<li><code>-newer file</code>：file 为一个存在的文件，列出比 file 还要新的文件文件名</li>
</ul>
</li>
<li>与使用者或群组名称有关的参数<ul>
<li><code>-uid n</code>：n 为数字，这个数字是使用者的帐号 ID，亦即 UID ，这个 UID 是记录在 /etc/passwd 里面与帐号名称对应的数字。</li>
<li><code>-gid n</code>：n 为数字，这个数字是群组名称的 ID，亦即 GID，这个 GID 记录在/etc/group</li>
<li><code>-user name</code>：name 为使用者帐号名称喔！例如 dmtsai </li>
<li><code>-group name</code>：name 为群组名称喔，例如 users ；</li>
<li><code>-nouser</code>：寻找文件的拥有者不存在 /etc/passwd 的人！</li>
<li><code>-nogroup</code>：寻找文件的拥有群组不存在于 /etc/group 的文件！</li>
<li>当你自行安装软件时，很可能该软件的属性当中并没有文件拥有者，这是可能的！在这个时候，就可以使用 -nouser 与 -nogroup 搜寻。</li>
</ul>
</li>
<li>与文件权限及名称有关的参数：<ul>
<li><code>-name filename</code>：搜寻文件名称为 filename 的文件；</li>
<li><code>-size [+-]SIZE</code>：搜寻比 SIZE 还要大（+）或小（-）的文件。这个 SIZE 的规格有：<ul>
<li><code>c</code>: 代表 Byte</li>
<li><code>k</code>: 代表 1024Bytes</li>
<li>所以，要找比 50KB 还要大的文件，就是 <code>-size +50k</code></li>
</ul>
</li>
<li><code>-type TYPE</code>：搜寻文件的类型为 TYPE 的，类型主要有：一般正规文件 （f）, 设备文件 （b, c）,目录 （d）, 链接文件 （l）, socket （s）, 及 FIFO （p） 等属性。</li>
<li><code>-perm mode</code>：搜寻文件权限“刚好等于” mode 的文件，这个 mode 为类似 chmod 的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！</li>
<li><code>-perm -mode</code>：搜寻文件权限“必须要全部囊括 mode 的权限”的文件，举例来说，我们要搜寻 <code>-rwxr--r--</code> ，亦即 0744 的文件，使用 <code>-perm -0744</code>，当一个文件的权限为 <code>-rwsr-xr-x</code> ，亦即 4755 时，也会被列出来，因为 <code>-rwsr-xr-x</code> 的属性已经囊括了 <code>-rwxr--r--</code> 的属性了。</li>
<li><code>-perm /mode</code>：搜寻文件权限“包含任一 mode 的权限”的文件，举例来说，我们搜寻 <code>-rwxr-xr-x</code> ，亦即 <code>-perm /755</code> 时，但一个文件属性为 <code>-rw-------</code> 也会被列出来，因为他有 <code>-rw....</code> 的属性存在！</li>
</ul>
</li>
</ul>
<h2 id="u547D_u4EE4_3A_gzip_2C_zcat/zmore/zless/zgrep"><a href="#u547D_u4EE4_3A_gzip_2C_zcat/zmore/zless/zgrep" class="headerlink" title="命令: gzip, zcat/zmore/zless/zgrep"></a>命令: gzip, zcat/zmore/zless/zgrep</h2><p>gzip 可以说是应用度最广的压缩指令了！目前 gzip 可以解开 compress, zip 与 gzip 等软件所压缩的文件。 至于 gzip 所创建的压缩文件为 *.gz 的文件名喔！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip [-cdtv<span class="comment">#] 文件名</span></span><br><span class="line">zcat 文件名.gz</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-c</code>：将压缩的数据输出到屏幕上，可通过数据流重导向来处理；</li>
<li><code>-d</code>：解压缩的参数；</li>
<li><code>-t</code>：可以用来检验一个压缩文件的一致性～看看文件有无错误；</li>
<li><code>-v</code>：可以显示出原文件/压缩文件的压缩比等信息；</li>
<li><code>-#</code>：# 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！默认是 -6</li>
</ul>
<p>当你使用 gzip 进行压缩时，在默认的状态下原本的文件会被压缩成为 .gz 的文件名，原始文件就不再存在了。 </p>
<p>cat/more/less 可以使用不同的方式来读取纯文本文件，那个 zcat/zmore/zless 则可以对应于 cat/more/less 的方式来读取纯文本文件被压缩后的压缩文件！ 由于 gzip 这个压缩指令主要想要用来取代 compress 的，所以不但 compress 的压缩文件可以使用 gzip 来解开，同时 zcat 这个指令可以同时读取 compress 与 gzip 的压缩文件呦！</p>
<h2 id="u547D_u4EE4_3A_bzip2_2C_bzcat/bzmore/bzless/bzgrep"><a href="#u547D_u4EE4_3A_bzip2_2C_bzcat/bzmore/bzless/bzgrep" class="headerlink" title="命令: bzip2, bzcat/bzmore/bzless/bzgrep"></a>命令: bzip2, bzcat/bzmore/bzless/bzgrep</h2><p>若说 gzip 是为了取代 compress 并提供更好的压缩比而成立的，那么 bzip2 则是为了取代 gzip 并提供更佳的压缩比而来的。 bzip2 真是很不错用的东西～这玩意的压缩比竟然比 gzip 还要好～至于 bzip2 的用法几乎与 gzip 相同！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bzip2 [-cdkzv<span class="comment">#] 文件名</span></span><br><span class="line">bzcat 文件名.bz2</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-c</code>：将压缩的过程产生的数据输出到屏幕上！</li>
<li><code>-d</code>：解压缩的参数</li>
<li><code>-k</code>：保留原始文件，而不会删除原始的文件喔！</li>
<li><code>-z</code>：压缩的参数 （默认值，可以不加）</li>
<li><code>-v</code>：可以显示出原文件/压缩文件的压缩比等信息；</li>
<li><code>-#</code>：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！</li>
</ul>
<h2 id="u547D_u4EE4_3A_tar"><a href="#u547D_u4EE4_3A_tar" class="headerlink" title="命令: tar"></a>命令: tar</h2><p>tar 可以将多个目录或文件打包成一个大文件，同时还可以通过 gzip/bzip2/xz 的支持，将该文件同时进行压缩！ 更有趣的是，由于 tar 的使用太广泛了，目前 Windows 的 WinRAR 也支持 .tar.gz 文件名的解压缩呢！</p>
<p>tar 的选项与参数非常的多！我们只讲几个常用的选项，更多选项您可以自行 man tar 查询啰！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar [-z|-j|-J] [cv] [<span class="operator">-f</span> 待创建的新文件名] filename... &lt;==打包与压缩</span><br><span class="line">tar [-z|-j|-J] [tv] [<span class="operator">-f</span> 既有的 tar文件名]             &lt;==察看文件名</span><br><span class="line">tar [-z|-j|-J] [xv] [<span class="operator">-f</span> 既有的 tar文件名] [-C 目录]   &lt;==解压缩</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-c</code>：创建打包文件，可搭配 -v 来察看过程中被打包的文件名（filename）</li>
<li><code>-t</code>：察看打包文件的内容含有哪些文件名，重点在察看“文件名”就是了；</li>
<li><code>-x</code>：解打包或解压缩的功能，可以搭配 -C （大写） 在特定目录解开特别留意的是， -c, -t, -x 不可同时出现在一串指令列中。</li>
<li><code>-z</code>：通过 gzip  的支持进行压缩/解压缩：此时文件名最好为 *.tar.gz</li>
<li><code>-j</code>：通过 bzip2 的支持进行压缩/解压缩：此时文件名最好为 *.tar.bz2</li>
<li><code>-J</code>：通过 xz    的支持进行压缩/解压缩：此时文件名最好为 *.tar.xz 特别留意， -z, -j, -J 不可以同时出现在一串指令列中</li>
<li><code>-v</code>：在压缩/解压缩的过程中，将正在处理的文件名显示出来！</li>
<li><code>-f filename</code>：-f 后面要立刻接要被处理的文件名！建议 -f 单独写一个选项啰！（比较不会忘记）</li>
<li><code>-C 目录</code>：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。</li>
<li><code>-p</code>：保留备份数据的原本权限与属性，常用于备份（-c）重要的配置文件</li>
<li><code>-P</code>：保留绝对路径，亦即允许备份数据中含有根目录存在之意；</li>
<li><code>--exclude=FILE</code>：在压缩的过程中，不要将 FILE 打包！ </li>
</ul>
<p>tar 并不会主动的产生创建的文件名喔！我们要自订啦！ 所以扩展名就显的很重要了！如果不加 <code>[-z|-j|-J]</code> 的话，文件名最好取为 <code>*.tar</code> 即可。如果是 <code>-j</code>选项，代表有 bzip2 的支持，因此文件名最好就取为 <code>*.tar.bz2</code> ，因为 bzip2 会产生 <code>.bz2</code> 的扩展名之故！ 至于如果是加上了 <code>-z</code> 的 gzip 的支持，那文件名最好取为 <code>*.tar.gz</code> 喔！</p>
<p>另外值得一提的是，tar 打包出来的文件有没有进行压缩所得到文件称呼不同喔！ 如果仅是打包而已，就是 <code>tar -cv -f file.tar</code>而已，这个文件我们称呼为 tarfile 。 如果还有进行压缩的支持，例如 <code>tar -jcv -f file.tar.bz2</code> 时，我们就称呼为 tarball （tar 球？）！这只是一个基本的称谓而已，不过很多书籍与网络都会使用到这个 tarball 的名称！所以得要跟您介绍介绍。</p>
<h2 id="u547D_u4EE4_3A_cut_2C_grep"><a href="#u547D_u4EE4_3A_cut_2C_grep" class="headerlink" title="命令: cut, grep"></a>命令: cut, grep</h2><blockquote>
<p>cut</p>
</blockquote>
<p>cut 不就是“切”吗？没错啦！这个指令可以将一段讯息的某一段给他“切”出来～ 处理的讯息是以“行”为单位喔！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cut <span class="operator">-d</span><span class="string">'分隔字符'</span> <span class="operator">-f</span> fields &lt;==用于有特定分隔字符</span><br><span class="line">cut -c 字符区间            &lt;==用于排列整齐的讯息</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-d</code>：后面接分隔字符。与 -f 一起使用；</li>
<li><code>-f</code>：依据 -d 的分隔字符将一段讯息分区成为数段，用 -f 取出第几段的意思；</li>
<li><code>-c</code>：以字符 （characters） 的单位取出固定字符区间；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 PATH 变量取出，我要找出第五个路径。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;PATH&#125;</span> | cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">5</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;PATH&#125;</span> | cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">3</span>,<span class="number">5</span> <span class="comment"># 找第 3 与第 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：将 export 输出的讯息，取得第 12 字符以后的所有字串</span></span><br><span class="line"><span class="built_in">export</span> | cut -c <span class="number">12</span>-</span><br><span class="line"><span class="comment"># 知道怎么回事了吧？用 -c 可以处理比较具有格式的输出数据！</span></span><br><span class="line"><span class="comment"># 我们还可以指定某个范围的值，例如第 12-20 的字符，就是 cut -c 12-20 等等！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：用 last 将显示的登陆者的信息中，仅留下使用者大名</span></span><br><span class="line">last | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 由输出的结果我们可以发现第一个空白分隔的字段代表帐号，所以使用如上指令：</span></span><br><span class="line"><span class="comment"># 但是因为 root   pts/1 之间空格有好几个，并非仅有一个，所以，如果要找出 </span></span><br><span class="line"><span class="comment"># pts/1 其实不能以 cut -d ' ' -f 1,2 喔！输出的结果会不是我们想要的。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>grep</p>
</blockquote>
<p>刚刚的 cut 是将一行讯息当中，取出某部分我们想要的，而 grep 则是分析一行讯息， 若当中有我们所需要的信息，就将该行拿出来～简单的语法是这样的：</p>
<p><code>grep [-acinv] [--color=auto] &#39;搜寻字串&#39; filename</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-a</code>：将 binary 文件以 text 文件的方式搜寻数据</li>
<li><code>-c</code>：计算找到 ‘搜寻字串’ 的次数</li>
<li><code>-i</code>：忽略大小写的不同，所以大小写视为相同</li>
<li><code>-n</code>：顺便输出行号</li>
<li><code>-v</code>：反向选择，亦即显示出没有 ‘搜寻字串’ 内容的那一行！</li>
<li><code>--color=auto</code>：可以将找到的关键字部分加上颜色的显示喔！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 last 当中，有出现 root 的那一行就取出来；</span></span><br><span class="line">last | grep <span class="string">'root'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：与范例一相反，只要没有 root 的就取出！</span></span><br><span class="line">last | grep -v <span class="string">'root'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：在 last 的输出讯息中，只要有 root 就取出，并且仅取第一栏</span></span><br><span class="line">last | grep <span class="string">'root'</span> | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span>1</span><br><span class="line"><span class="comment"># 在取出 root 之后，利用上个指令 cut 的处理，就能够仅取得第一栏啰！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例四：取出 /etc/man_db.conf 内含 MANPATH 的那几行</span></span><br><span class="line">grep --color=auto <span class="string">'MANPATH'</span> /etc/man_db.conf</span><br><span class="line">....（前面省略）....</span><br><span class="line">MANPATH_MAP     /usr/games              /usr/share/man</span><br><span class="line">MANPATH_MAP     /opt/bin                /opt/man</span><br><span class="line">MANPATH_MAP     /opt/sbin               /opt/man</span><br><span class="line"><span class="comment"># 神奇的是，如果加上 --color=auto 的选项，找到的关键字部分会用特殊颜色显示喔！</span></span><br></pre></td></tr></table></figure>
<h2 id="u547D_u4EE4_3A_sort_2C_wc_2C_uniq"><a href="#u547D_u4EE4_3A_sort_2C_wc_2C_uniq" class="headerlink" title="命令: sort, wc, uniq"></a>命令: sort, wc, uniq</h2><blockquote>
<p>sort</p>
</blockquote>
<p>sort 是很有趣的指令，他可以帮我们进行排序，而且可以依据不同的数据型态来排序喔！ 例如数字与文字的排序就不一样。此外，排序的字符与语系的编码有关，因此， 如果您需要排序时，建议使用 <code>LANG=C</code> 来让语系统一，数据排序比较好一些。</p>
<p><code>sort [-fbMnrtuk] [file or stdin]</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-f</code>：忽略大小写的差异，例如 A 与 a 视为编码相同；</li>
<li><code>-b</code>：忽略最前面的空白字符部分；</li>
<li><code>-M</code>：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；</li>
<li><code>-n</code>：使用“纯数字”进行排序（默认是以文字体态来排序的）；</li>
<li><code>-r</code>：反向排序；</li>
<li><code>-u</code>：就是 uniq ，相同的数据中，仅出现一行代表；</li>
<li><code>-t</code>：分隔符号，默认是用 [tab] 键来分隔；</li>
<li><code>-k</code>：以那个区间 （field） 来进行排序的意思</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：个人帐号都记录在 /etc/passwd 下，请将帐号进行排序。</span></span><br><span class="line">cat /etc/passwd | sort</span><br><span class="line"></span><br><span class="line">abrt:x:<span class="number">173</span>:<span class="number">173</span>::/etc/abrt:/sbin/nologin</span><br><span class="line">adm:x:<span class="number">3</span>:<span class="number">4</span>:adm:/var/adm:/sbin/nologin</span><br><span class="line">alex:x:<span class="number">1001</span>:<span class="number">1002</span>::/home/alex:/bin/bash</span><br><span class="line"><span class="comment"># 鸟哥省略很多的输出～由上面的数据看起来， sort 是默认“以第一个”数据来排序，</span></span><br><span class="line"><span class="comment"># 而且默认是以“文字”型态来排序的喔！所以由 a 开始排到最后啰！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：/etc/passwd 内容是以 : 来分隔的，我想以第三栏来排序，该如何？</span></span><br><span class="line">cat /etc/passwd | sort -t <span class="string">':'</span> -k <span class="number">3</span></span><br><span class="line"></span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">dmtsai:x:<span class="number">1000</span>:<span class="number">1000</span>:dmtsai:/home/dmtsai:/bin/bash</span><br><span class="line">alex:x:<span class="number">1001</span>:<span class="number">1002</span>::/home/alex:/bin/bash</span><br><span class="line">arod:x:<span class="number">1002</span>:<span class="number">1003</span>::/home/arod:/bin/bash</span><br><span class="line"><span class="comment"># 看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～</span></span><br><span class="line"><span class="comment"># 如果是以文字体态来排序的话，原本就会是这样，想要使用数字排序：</span></span><br><span class="line"><span class="comment"># cat /etc/passwd | sort -t ':' -k 3 -n</span></span><br><span class="line"><span class="comment"># 这样才行啊！用那个 -n 来告知 sort 以数字来排序啊！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：利用 last ，将输出的数据仅取帐号，并加以排序</span></span><br><span class="line">last | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span>1 | sort</span><br></pre></td></tr></table></figure>
<blockquote>
<p>wc</p>
</blockquote>
<p>如果我想要知道 /etc/man_db.conf 这个文件里面有多少字？多少行？多少字符的话， 可以怎么做呢？其实可以利用 wc 这个指令来达成喔！他可以帮我们计算输出的讯息的整体数据！</p>
<p><code>wc [-lwm]</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-l</code>：仅列出行；</li>
<li><code>-w</code>：仅列出多少字（英文单字）；</li>
<li><code>-m</code>  ：多少字符；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：那个 /etc/man_db.conf 里面到底有多少相关字、行、字符数？</span></span><br><span class="line">cat /etc/man_db.conf | wc </span><br><span class="line">    <span class="number">131</span>     <span class="number">723</span>    <span class="number">5171</span></span><br><span class="line"><span class="comment"># 输出的三个数字中，分别代表： “行、字数、字符数”</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：我知道使用 last 可以输出登陆者，但是 last 最后两行并非帐号内容，那么请问，我该如何以一行指令串取得登陆系统的总人次？</span></span><br><span class="line">last | grep [a-zA-Z] | grep -v <span class="string">'wtmp'</span> | grep -v <span class="string">'reboot'</span> | \</span><br><span class="line">&gt; grep -v <span class="string">'unknown'</span> |wc <span class="operator">-l</span> </span><br><span class="line"><span class="comment"># 由于 last 会输出空白行, wtmp, unknown, reboot 等无关帐号登陆的信息，因此，我利用</span></span><br><span class="line"><span class="comment"># grep 取出非空白行，以及去除上述关键字那几行，再计算行数，就能够了解啰</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>uniq</p>
</blockquote>
<p>如果我排序完成了，想要将重复的数据仅列出一个显示，可以怎么做呢？</p>
<p><code>uniq [-ic]</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-i</code>：忽略大小写字符的不同；</li>
<li><code>-c</code>：进行计数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：使用 last 将帐号列出，仅取出帐号栏，进行排序后仅取出一位；</span></span><br><span class="line">last | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span>1 | sort | uniq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：承上题，如果我还想要知道每个人的登陆总次数呢？</span></span><br><span class="line">last | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span>1 | sort | uniq -c</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">      <span class="number">6</span> （unknown</span><br><span class="line">     <span class="number">47</span> dmtsai</span><br><span class="line">      <span class="number">4</span> reboot</span><br><span class="line">      <span class="number">7</span> root</span><br><span class="line">      <span class="number">1</span> wtmp</span><br><span class="line"><span class="comment"># 从上面的结果可以发现 reboot 有 4 次， root 登陆则有 7 次！大部分是以 dmtsai 来操作！</span></span><br><span class="line"><span class="comment"># wtmp 与第一行的空白都是 last 的默认字符，那两个可以忽略的！</span></span><br></pre></td></tr></table></figure>
<h2 id="u547D_u4EE4_3A_tee_2C_split_2C_xargs"><a href="#u547D_u4EE4_3A_tee_2C_split_2C_xargs" class="headerlink" title="命令: tee, split, xargs"></a>命令: tee, split, xargs</h2><blockquote>
<p>tee</p>
</blockquote>
<p><img src="/images/14590942194893.jpg" alt="tee 的工作流程示意图"></p>
<p>tee 会同时将数据流分送到文件去与屏幕 （screen）；而输出到屏幕的，其实就是 stdout ，那就可以让下个指令继续处理喔！</p>
<p><code>tee [-a] file</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-a</code>：以累加 （append） 的方式，将数据加入 file 当中！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">last | tee last.list | cut <span class="operator">-d</span> <span class="string">" "</span> <span class="operator">-f</span>1</span><br><span class="line"><span class="comment"># 这个范例可以让我们将 last 的输出存一份到 last.list 文件中；</span></span><br><span class="line"></span><br><span class="line">ls <span class="operator">-l</span> /home | tee ~/homefile | more</span><br><span class="line"><span class="comment"># 这个范例则是将 ls 的数据存一份到 ~/homefile ，同时屏幕也有输出讯息！</span></span><br><span class="line"></span><br><span class="line">ls <span class="operator">-l</span> / | tee <span class="operator">-a</span> ~/homefile | more</span><br><span class="line"><span class="comment"># 要注意！ tee 后接的文件会被覆盖，若加上 -a 这个选项则能将讯息累加。</span></span><br></pre></td></tr></table></figure>
<p>tee 可以让 standard output 转存一份到文件内并将同样的数据继续送到屏幕去处理！ 这样除了可以让我们同时分析一份数据并记录下来之外，还可以作为处理一份数据的中间暂存盘记录之用！</p>
<blockquote>
<p>split 将一个大文件，依据文件大小或行数来分区</p>
</blockquote>
<p><code>split [-bl] file PREFIX</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-b</code>：后面可接欲分区成的文件大小，可加单位，例如 b, k, m 等；</li>
<li><code>-l</code>：以行数来进行分区。</li>
<li><code>PREFIX</code>：代表前置字符的意思，可作为分区文件的前导文字。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：我的 /etc/services 有六百多K，若想要分成 300K 一个文件时？</span></span><br><span class="line"><span class="built_in">cd</span> /tmp; split -b <span class="number">300</span>k /etc/services services</span><br><span class="line">ll -k services*</span><br><span class="line"></span><br><span class="line">-rw-rw-r--. <span class="number">1</span> dmtsai dmtsai <span class="number">307200</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">52</span> servicesaa</span><br><span class="line">-rw-rw-r--. <span class="number">1</span> dmtsai dmtsai <span class="number">307200</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">52</span> servicesab</span><br><span class="line">-rw-rw-r--. <span class="number">1</span> dmtsai dmtsai  <span class="number">55893</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">52</span> servicesac</span><br><span class="line"><span class="comment"># 那个文件名可以随意取的啦！我们只要写上前导文字，小文件就会以</span></span><br><span class="line"><span class="comment"># xxxaa, xxxab, xxxac 等方式来创建小文件的！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：如何将上面的三个小文件合成一个文件，文件名为 servicesback</span></span><br><span class="line">cat services* &gt;&gt; servicesback</span><br><span class="line"><span class="comment"># 很简单吧？就用数据流重导向就好啦！简单！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：使用 ls -al / 输出的信息中，每十行记录成一个文件</span></span><br><span class="line">ls -al / | split <span class="operator">-l</span> <span class="number">10</span> - lsroot</span><br><span class="line">wc <span class="operator">-l</span> lsroot*</span><br><span class="line"></span><br><span class="line">  <span class="number">10</span> lsrootaa</span><br><span class="line">  <span class="number">10</span> lsrootab</span><br><span class="line">   <span class="number">4</span> lsrootac</span><br><span class="line">  <span class="number">24</span> total</span><br><span class="line"><span class="comment"># 重点在那个 - 啦！一般来说，如果需要 stdout/stdin 时，但偏偏又没有文件，</span></span><br><span class="line"><span class="comment"># 有的只是 - 时，那么那个 - 就会被当成 stdin 或 stdout ～</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>xargs 参数代换</p>
</blockquote>
<p>xargs 是在做什么的呢？就以字面上的意义来看， x 是加减乘除的乘号，args 则是 arguments （参数） 的意思，所以说，这个玩意儿就是在产生某个指令的参数的意思！ xargs 可以读入 stdin 的数据，并且以空白字符或断行字符作为分辨，将 stdin 的数据分隔成为 arguments 。 因为是以空白字符作为分隔，所以，如果有一些文件名或者是其他意义的名词内含有空白字符的时候， xargs 可能就会误判了</p>
<p><code>xargs [-0epn] command</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-0</code>：如果输入的 stdin 含有特殊字符，例如 `, \, 空白键等等字符时，这个 -0 参数可以将他还原成一般字符。这个参数可以用于特殊状态喔！</li>
<li><code>-e</code>：这个是 EOF （end of file） 的意思。后面可以接一个字串，当 xargs 分析到这个字串时，就会停止继续工作！</li>
<li><code>-p</code>：在执行每个指令的 argument 时，都会询问使用者的意思；</li>
<li><code>-n</code>：后面接次数，每次 command 指令执行时，要使用几个参数的意思。</li>
<li>当 xargs 后面没有接任何的指令时，默认是以 echo 来进行输出喔！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 /etc/passwd 内的第一栏取出，仅取三行，使用 id 这个指令将每个帐号内容秀出来</span></span><br><span class="line">id root</span><br><span class="line"></span><br><span class="line">uid=<span class="number">0</span>（root） gid=<span class="number">0</span>（root） groups=<span class="number">0</span>（root）   <span class="comment"># 这个 id 指令可以查询使用者的 UID/GID 等信息</span></span><br><span class="line"></span><br><span class="line">id $（cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span>）</span><br><span class="line"><span class="comment"># 虽然使用 $（cmd） 可以预先取得参数，但可惜的是， id 这个指令“仅”能接受一个参数而已！</span></span><br><span class="line"><span class="comment"># 所以上述的这个指令执行会出现错误！根本不会显示用户的 ID 啊！</span></span><br><span class="line"></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | id</span><br><span class="line"></span><br><span class="line">uid=<span class="number">1000</span>（dmtsai） gid=<span class="number">1000</span>（dmtsai） groups=<span class="number">1000</span>（dmtsai）,<span class="number">10</span>（wheel）   <span class="comment"># 我不是要查自己啊！</span></span><br><span class="line"><span class="comment"># 因为 id 并不是管线命令，因此在上面这个指令执行后，前面的东西通通不见！只会执行 id！</span></span><br><span class="line"></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | xargs id</span><br><span class="line"><span class="comment"># 依旧会出现错误！这是因为 xargs 一口气将全部的数据通通丢给 id 处理～但 id 就接受 1 个啊最多！</span></span><br><span class="line"></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | xargs -n <span class="number">1</span> id</span><br><span class="line"></span><br><span class="line">uid=<span class="number">0</span>（root） gid=<span class="number">0</span>（root） groups=<span class="number">0</span>（root）</span><br><span class="line">uid=<span class="number">1</span>（bin） gid=<span class="number">1</span>（bin） groups=<span class="number">1</span>（bin）</span><br><span class="line">uid=<span class="number">2</span>（daemon） gid=<span class="number">2</span>（daemon） groups=<span class="number">2</span>（daemon）</span><br><span class="line"><span class="comment"># 通过 -n 来处理，一次给予一个参数，因此上述的结果就 OK 正常的显示啰！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：同上，但是每次执行 id 时，都要询问使用者是否动作？</span></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | xargs -p -n <span class="number">1</span> id</span><br><span class="line"></span><br><span class="line">id root ?...y</span><br><span class="line">uid=<span class="number">0</span>（root） gid=<span class="number">0</span>（root） groups=<span class="number">0</span>（root）</span><br><span class="line">id bin ?...y</span><br><span class="line">.....（下面省略）.....</span><br><span class="line"><span class="comment"># 呵呵！这个 -p 的选项可以让使用者的使用过程中，被询问到每个指令是否执行！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：将所有的 /etc/passwd 内的帐号都以 id 查阅，但查到 sync 就结束指令串</span></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | xargs <span class="operator">-e</span><span class="string">'sync'</span> -n <span class="number">1</span> id</span><br><span class="line"><span class="comment"># 仔细与上面的案例做比较。也同时注意，那个 -e'sync' 是连在一起的，中间没有空白键</span></span><br><span class="line"><span class="comment"># 上个例子当中，第六个参数是 sync 啊，那么我们下达 -e'sync' 后，则分析到 sync 这个字串时，</span></span><br><span class="line"><span class="comment"># 后面的其他 stdin 的内容就会被 xargs 舍弃掉了！</span></span><br></pre></td></tr></table></figure>
<p>其实，在 man xargs 里面就有三四个小范例，您可以自行参考一下内容。 此外， xargs 真的是很好用的一个玩意儿！您真的需要好好的参详参详！会使用 xargs 的原因是， 很多指令其实并不支持管线命令，因此我们可以通过 xargs 来提供该指令引用 standard input 之用！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例四：找出 /usr/sbin 下面具有特殊权限的文件名，并使用 ls -l 列出详细属性</span></span><br><span class="line">find /usr/sbin -perm /<span class="number">7000</span> | xargs ls <span class="operator">-l</span></span><br><span class="line"></span><br><span class="line">-rwx-<span class="operator">-s</span>--x. <span class="number">1</span> root lock      <span class="number">11208</span> Jun <span class="number">10</span>  <span class="number">2014</span> /usr/sbin/lockdev</span><br><span class="line">-rwsr-xr-x. <span class="number">1</span> root root     <span class="number">113400</span> Mar  <span class="number">6</span> <span class="number">12</span>:<span class="number">17</span> /usr/sbin/mount.nfs</span><br><span class="line">-rwxr-sr-x. <span class="number">1</span> root root      <span class="number">11208</span> Mar  <span class="number">6</span> <span class="number">11</span>:<span class="number">05</span> /usr/sbin/netreport</span><br><span class="line">.....（下面省略）.....</span><br><span class="line"><span class="comment"># 聪明的读者应该会想到使用“ ls -l $（find /usr/sbin -perm /7000） ”来处理这个范例！</span></span><br><span class="line"><span class="comment"># 都 OK！能解决问题的方法，就是好方法！</span></span><br></pre></td></tr></table></figure>
<h2 id="u547D_u4EE4_3A_tr_2C_col_2C_join_2C_paste_2C_expand"><a href="#u547D_u4EE4_3A_tr_2C_col_2C_join_2C_paste_2C_expand" class="headerlink" title="命令: tr, col, join, paste, expand"></a>命令: tr, col, join, paste, expand</h2><blockquote>
<p>tr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换！</p>
</blockquote>
<p><code>tr [-ds] SET1 ...</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-d</code>：删除讯息当中的 SET1 这个字串；</li>
<li><code>-s</code>：取代掉重复的字符！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 last 输出的讯息中，所有的小写变成大写字符：</span></span><br><span class="line">last | tr <span class="string">'[a-z]'</span> <span class="string">'[A-Z]'</span></span><br><span class="line"><span class="comment"># 事实上，没有加上单引号也是可以执行的，如：last | tr [a-z] [A-Z]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：将 /etc/passwd 输出的讯息中，将冒号 （:） 删除</span></span><br><span class="line">cat /etc/passwd | tr <span class="operator">-d</span> <span class="string">':'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：将 /etc/passwd 转存成 dos 断行到 /root/passwd 中，再将 ^M 符号删除</span></span><br><span class="line">cp /etc/passwd ~/passwd &amp;&amp; unix2dos ~/passwd</span><br><span class="line">file /etc/passwd ~/passwd</span><br><span class="line"></span><br><span class="line">/etc/passwd:         ASCII text</span><br><span class="line">/home/dmtsai/passwd: ASCII text, with CRLF line terminators  &lt;==就是 DOS 断行</span><br><span class="line"></span><br><span class="line">cat ~/passwd | tr <span class="operator">-d</span> <span class="string">'\r'</span> &gt; ~/passwd.linux</span><br><span class="line"><span class="comment"># 那个 \r 指的是 DOS 的断行字符，关于更多的字符，请参考 man tr</span></span><br><span class="line">ll /etc/passwd ~/passwd*</span><br><span class="line">-rw-r--r--. <span class="number">1</span> root   root   <span class="number">2092</span> Jun <span class="number">17</span> <span class="number">00</span>:<span class="number">20</span> /etc/passwd</span><br><span class="line">-rw-r--r--. <span class="number">1</span> dmtsai dmtsai <span class="number">2133</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">13</span> /home/dmtsai/passwd</span><br><span class="line">-rw-rw-r--. <span class="number">1</span> dmtsai dmtsai <span class="number">2092</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">13</span> /home/dmtsai/passwd.linux</span><br><span class="line"><span class="comment"># 处理过后，发现文件大小与原本的 /etc/passwd 就一致了！</span></span><br></pre></td></tr></table></figure>
<p>其实这个指令也可以写在“正则表达式”里头！因为他也是由正则表达式的方式来取代数据的！ 以上面的例子来说，使用 [] 可以设置一串字呢！也常常用来取代文件中的怪异符号！ 例如上面第三个例子当中，可以去除 DOS 文件留下来的 <code>^M</code> 这个断行的符号！这东西相当的有用！相信处理 Linux &amp; Windows 系统中的人们最麻烦的一件事就是这个事情啦！亦即是 DOS 下面会自动的在每行行尾加入 <code>^M</code> 这个断行符号！这个时候除了以前讲过的 dos2unix 之外，我们也可以使用这个 tr 来将 <code>^M</code> 去除！ <code>^M</code> 可以使用 <code>\r</code> 来代替之！</p>
<blockquote>
<p>col</p>
</blockquote>
<p><code>col [-xb]</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-x</code>：将 tab 键转换成对等的空白键</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">范例一：利用 cat -A 显示出所有特殊按键，最后以 col 将 [tab] 转成空白</span><br><span class="line"> cat -A /etc/man_db.conf  &lt;==此时会看到很多 ^I 的符号，那就是 tab</span><br><span class="line"> cat /etc/man_db.conf | col -x | cat -A | more</span><br><span class="line"><span class="comment"># 嘿嘿！如此一来， [tab] 按键会被取代成为空白键，输出就美观多了！</span></span><br></pre></td></tr></table></figure>
<p>虽然 col 有他特殊的用途，不过，很多时候，他可以用来简单的处理将 [tab] 按键取代成为空白键！ 例如上面的例子当中，如果使用 cat -A 则 [tab] 会以 <code>^I</code> 来表示。 但经过 col -x 的处理，则会将 [tab] 取代成为对等的空白键！</p>
<blockquote>
<p>join 处理两个文件之间的数据</p>
</blockquote>
<p><code>join [-ti12] file1 file2</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-t</code>：join 默认以空白字符分隔数据，并且比对“第一个字段”的数据，如果两个文件相同，则将两笔数据联成一行，且第一个字段放在第一个</li>
<li><code>-i</code>：忽略大小写的差异；</li>
<li><code>-1</code>：这个是数字的 1 ，代表“第一个文件要用那个字段来分析”的意思；</li>
<li><code>-2</code>：代表“第二个文件要用那个字段来分析”的意思。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：用 root 的身份，将 /etc/passwd 与 /etc/shadow 相关数据整合成一栏</span></span><br><span class="line">head -n <span class="number">3</span> /etc/passwd /etc/shadow</span><br><span class="line">==&gt; /etc/passwd &lt;==</span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin</span><br><span class="line"></span><br><span class="line">==&gt; /etc/shadow &lt;==</span><br><span class="line">root:<span class="variable">$6</span><span class="variable">$wtbCCce</span>/PxMeE5wm<span class="variable">$KE2IfSJr</span>...:<span class="number">16559</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">bin:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">daemon:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line"><span class="comment"># 由输出的数据可以发现这两个文件的最左边字段都是相同帐号！且以 : 分隔</span></span><br><span class="line"></span><br><span class="line">join -t <span class="string">':'</span> /etc/passwd /etc/shadow | head -n <span class="number">3</span></span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash:<span class="variable">$6</span><span class="variable">$wtbCCce</span>/PxMeE5wm<span class="variable">$KE2IfSJr</span>...:<span class="number">16559</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line"><span class="comment"># 通过上面这个动作，我们可以将两个文件第一字段相同者整合成一列！</span></span><br><span class="line"><span class="comment"># 第二个文件的相同字段并不会显示（因为已经在最左边的字段出现了啊！）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：我们知道 /etc/passwd 第四个字段是 GID ，那个 GID 记录在 /etc/group 当中的第三个字段，请问如何将两个文件整合？</span></span><br><span class="line">head -n <span class="number">3</span> /etc/passwd /etc/group</span><br><span class="line">==&gt; /etc/passwd &lt;==</span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin</span><br><span class="line"></span><br><span class="line">==&gt; /etc/group &lt;==</span><br><span class="line">root:x:<span class="number">0</span>:</span><br><span class="line">bin:x:<span class="number">1</span>:</span><br><span class="line">daemon:x:<span class="number">2</span>:</span><br><span class="line"><span class="comment"># 从上面可以看到，确实有相同的部分喔！赶紧来整合一下！</span></span><br><span class="line"></span><br><span class="line">join -t <span class="string">':'</span> -<span class="number">1</span> <span class="number">4</span> /etc/passwd -<span class="number">2</span> <span class="number">3</span> /etc/group | head -n <span class="number">3</span></span><br><span class="line"><span class="number">0</span>:root:x:<span class="number">0</span>:root:/root:/bin/bash:root:x:</span><br><span class="line"><span class="number">1</span>:bin:x:<span class="number">1</span>:bin:/bin:/sbin/nologin:bin:x:</span><br><span class="line"><span class="number">2</span>:daemon:x:<span class="number">2</span>:daemon:/sbin:/sbin/nologin:daemon:x:</span><br><span class="line"><span class="comment"># 同样的，相同的字段部分被移动到最前面了！所以第二个文件的内容就没再显示。</span></span><br><span class="line"><span class="comment"># 请读者们配合上述显示两个文件的实际内容来比对！</span></span><br></pre></td></tr></table></figure>
<p>这个 join 在处理两个相关的数据文件时，就真的是很有帮助的啦！ 例如上面的案例当中，我的 /etc/passwd, /etc/shadow, /etc/group 都是有相关性的， 其中 /etc/passwd, /etc/shadow 以帐号为相关性，至于 /etc/passwd, /etc/group 则以所谓的 GID （帐号的数字定义） 来作为他的相关性。根据这个相关性， 我们可以将有关系的数据放置在一起！这在处理数据可是相当有帮助的！ 但是上面的例子有点难，希望您可以静下心好好的看一看原因喔！</p>
<p>此外，需要特别注意的是，在使用 join 之前，你所需要处理的文件应该要事先经过排序 （sort） 处理！ 否则有些比对的项目会被略过呢！特别注意了！</p>
<blockquote>
<p>paste 直接将两行贴在一起，且中间以 [tab] 键隔开</p>
</blockquote>
<p><code>paste [-d] file1 file2</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-d</code>：后面可以接分隔字符。默认是以 [tab] 来分隔的！</li>
<li><code>-</code>：如果 file 部分写成 - ，表示来自 standard input 的数据的意思。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：用 root 身份，将 /etc/passwd 与 /etc/shadow 同一行贴在一起</span></span><br><span class="line">paste /etc/passwd /etc/shadow</span><br><span class="line"></span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash root:<span class="variable">$6</span><span class="variable">$wtbCCce</span>/PxMeE5wm<span class="variable">$KE2IfSJr</span>...:<span class="number">16559</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin        bin:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin daemon:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line"><span class="comment"># 注意喔！同一行中间是以 [tab] 按键隔开的！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：先将 /etc/group 读出（用 cat），然后与范例一贴上一起！且仅取出前三行</span></span><br><span class="line">cat /etc/group|paste /etc/passwd /etc/shadow - | head -n <span class="number">3</span></span><br><span class="line"><span class="comment"># 这个例子的重点在那个 - 的使用！那玩意儿常常代表 stdin 喔！</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>expand 将 [tab] 按键转成空白键</p>
</blockquote>
<p><code>expand [-t] file</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-t</code>：后面可以接数字。一般来说，一个 tab 按键可以用 8 个空白键取代。我们也可以自行定义一个 [tab] 按键代表多少个字符呢！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 /etc/man_db.conf 内行首为 MANPATH 的字样就取出；仅取前三行；</span></span><br><span class="line">grep <span class="string">'^MANPATH'</span> /etc/man_db.conf | head -n <span class="number">3</span></span><br><span class="line"></span><br><span class="line">MANPATH_MAP     /bin                    /usr/share/man</span><br><span class="line">MANPATH_MAP     /usr/bin                /usr/share/man</span><br><span class="line">MANPATH_MAP     /sbin                   /usr/share/man</span><br><span class="line"><span class="comment"># 行首的代表标志为 ^ ，这个我们留待下节介绍！先有概念即可！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：承上，如果我想要将所有的符号都列出来？（用 cat）</span></span><br><span class="line">grep <span class="string">'^MANPATH'</span> /etc/man_db.conf | head -n <span class="number">3</span> |cat -A</span><br><span class="line"></span><br><span class="line">MANPATH_MAP^I/bin^I^I^I/usr/share/man$</span><br><span class="line">MANPATH_MAP^I/usr/bin^I^I/usr/share/man$</span><br><span class="line">MANPATH_MAP^I/sbin^I^I^I/usr/share/man$</span><br><span class="line"><span class="comment"># 发现差别了吗？没错～ [tab] 按键可以被 cat -A 显示成为 ^I </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：承上，我将 [tab] 按键设置成 6 个字符的话？</span></span><br><span class="line">grep <span class="string">'^MANPATH'</span> /etc/man_db.conf | head -n <span class="number">3</span> | expand -t <span class="number">6</span> - | cat -A</span><br><span class="line"></span><br><span class="line">MANPATH_MAP /bin              /usr/share/man$</span><br><span class="line">MANPATH_MAP /usr/bin          /usr/share/man$</span><br><span class="line">MANPATH_MAP /sbin             /usr/share/man$</span><br><span class="line"><span class="number">123456123456123456123456123456123456123456123456</span>...</span><br><span class="line"><span class="comment"># 仔细看一下上面的数字说明，因为我是以 6 个字符来代表一个 [tab] 的长度，所以，</span></span><br><span class="line"><span class="comment"># MAN... 到 /usr 之间会隔 12 （两个 [tab]） 个字符喔！如果 tab 改成 9 的话，</span></span><br><span class="line"><span class="comment"># 情况就又不同了！这里也不好理解～您可以多设置几个数字来查阅就晓得！</span></span><br></pre></td></tr></table></figure>
<h2 id="vi__u4E0E_vim"><a href="#vi__u4E0E_vim" class="headerlink" title="vi 与 vim"></a>vi 与 vim</h2><p>基本上 vi 共分为三种模式，分别是“一般指令模式”、“编辑模式”与“指令列命令模式”。 这三种模式的作用分别是：</p>
<ul>
<li>一般指令模式 （command mode）<ul>
<li>以 vi 打开一个文件就直接进入一般指令模式了（这是默认的模式，也简称为一般模式）。在这个模式中， 你可以使用“上下左右”按键来移动光标，你可以使用“删除字符”或“删除整列”来处理文件内容， 也可以使用“复制、贴上”来处理你的文件数据。</li>
</ul>
</li>
<li>编辑模式 （insert mode）<ul>
<li>在一般指令模式中可以进行删除、复制、贴上等等的动作，但是却无法编辑文件内容的！ 要等到你按下 <code>i, I, o, O, a, A, r, R</code> 等任何一个字母之后才会进入编辑模式。注意了！通常在 Linux 中，按下这些按键时，在画面的左下方会出现“ INSERT 或 REPLACE ”的字样，此时才可以进行编辑。而如果要回到一般指令模式时， 则必须要按下“Esc”这个按键即可退出编辑模式。</li>
</ul>
</li>
<li>指令列命令模式 （command-line mode）<ul>
<li>在一般模式当中，输入 <code>: / ?</code> 三个中的任何一个按钮，就可以将光标移动到最下面那一列。在这个模式当中， 可以提供你“搜寻数据”的动作，而读取、存盘、大量取代字符、离开 vi 、显示行号等等的动作则是在此模式中达成的！</li>
</ul>
</li>
</ul>
<p><img src="/images/14590796988736.jpg" alt=""></p>
<blockquote>
<p>一般指令模式可用的按钮说明</p>
</blockquote>
<ul>
<li>光标移动<ul>
<li><code>h 或 向左方向键（←）</code>：光标向左移动一个字符</li>
<li><code>j 或 向下方向键（↓）</code>：光标向下移动一个字符</li>
<li><code>k 或 向上方向键（↑）</code>：光标向上移动一个字符</li>
<li><code>l 或 向右方向键（→）</code>：光标向右移动一个字符</li>
<li>如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 列，可以使用 <code>30j</code> 或 <code>30↓</code> 的组合按键， 亦即加上想要进行的次数（数字）后，按下动作即可！</li>
<li><code>[Ctrl] + [f]</code>：屏幕“向下”移动一页，相当于 [Page Down]按键 （常用）</li>
<li><code>[Ctrl] + [b]</code>：屏幕“向上”移动一页，相当于 [Page Up] 按键 （常用）</li>
<li><code>[Ctrl] + [d]</code>：屏幕“向下”移动半页</li>
<li><code>[Ctrl] + [u]</code>：屏幕“向上”移动半页</li>
<li><code>+</code>：光标移动到非空白字符的下一列</li>
<li><code>-</code>：光标移动到非空白字符的上一列</li>
<li><code>n&lt;space&gt;</code>：那个 n 表示“数字”，例如 20 。按下数字后再按空白键，光标会向右移动这一列的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</space></li>
<li><code>0 或功能键[Home]</code>：这是数字“ 0 ”：移动到这一列的最前面字符处 （常用）</li>
<li><code>$ 或功能键[End]</code>：移动到这一列的最后面字符处（常用）</li>
<li><code>H</code>：光标移动到这个屏幕的最上方那一列的第一个字符</li>
<li><code>M</code>：光标移动到这个屏幕的中央那一列的第一个字符</li>
<li><code>L</code>：光标移动到这个屏幕的最下方那一列的第一个字符</li>
<li><code>G</code>：移动到这个文件的最后一列（常用）</li>
<li><code>nG</code>：n 为数字。移动到这个文件的第 n 列。例如 20G 则会移动到这个文件的第 20 列（可配合 <code>:set nu</code>）</li>
<li><code>gg</code>：移动到这个文件的第一列，相当于 1G 啊！ （常用）</li>
<li><code>n&lt;Enter&gt;</code>：n 为数字。光标向下移动 n 列（常用）</li>
</ul>
</li>
<li>复制粘贴<ul>
<li><code>x, X</code>：在一列字当中，x 为向后删除一个字符 （相当于 [del] 按键）， X 为向前删除一个字符（相当于 [backspace] 亦即是倒退键） （常用）</li>
<li><code>nx</code>：n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， “10x”</li>
<li><code>dd</code>：删除光标所在的那一整列（常用）</li>
<li><code>ndd</code>：n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列 （常用）</li>
<li><code>d1G</code>：删除光标所在到第一列的所有数据</li>
<li><code>dG</code>：删除光标所在到最后一列的所有数据</li>
<li><code>d$</code>：删除光标所在处，到该列的最后一个字符</li>
<li><code>d0</code>：那个是数字的 0 ，删除光标所在处，到该列的最前面一个字符</li>
<li><code>yy</code>：复制光标所在的那一列（常用）</li>
<li><code>nyy</code>：n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20 列（常用）</li>
<li><code>y1G</code>：复制光标所在列到第一列的所有数据</li>
<li><code>yG</code>：复制光标所在列到最后一列的所有数据</li>
<li><code>y0</code>：复制光标所在的那个字符到该列行首的所有数据</li>
<li><code>y$</code>：复制光标所在的那个字符到该列行尾的所有数据</li>
<li><code>p, P</code>：p 为将已复制的数据在光标下一列贴上，P 则为贴在光标上一列！ 举例来说，我目前光标在第 20 列，且已经复制了 10 列数据。则按下 p 后， 那 10 列数据会贴在原本的 20 列之后，亦即由 21 列开始贴。但如果是按下 P 呢？ 那么原本的第 20 列会被推到变成 30 列。 （常用）</li>
<li><code>J</code>：将光标所在列与下一列的数据结合成同一列</li>
<li><code>c</code>：重复删除多个数据，例如向下删除 10 列，[ 10cj ]</li>
<li><code>u</code>：复原前一个动作。（常用）</li>
<li><code>[Ctrl]+r</code>：重做上一个动作。（常用）这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</li>
<li><code>.</code>：不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点“.”就好了！ （常用）</li>
</ul>
</li>
<li>搜寻取代<ul>
<li><code>/word</code>：向光标之下寻找一个名称为 word 的字串。例如要在文件内搜寻 vbird 这个字串，就输入 <code>/vbird</code> 即可！ （常用）</li>
<li><code>?word</code>：向光标之上寻找一个字串名称为 word 的字串。</li>
<li><code>n</code>：这个 n 是英文按键。代表“重复前一个搜寻的动作”。举例来说， 如果刚刚我们执行 <code>/vbird</code> 去向下搜寻 vbird 这个字串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字串。如果是执行 <code>?vbird</code> 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字串！</li>
<li><code>N</code>：这个 N 是英文按键。与 n 刚好相反，为“反向”进行前一个搜寻动作。 例如 <code>/vbird</code> 后，按下 N 则表示“向上”搜寻 vbird 。</li>
<li>使用 <code>/word</code> 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键字！</li>
<li><code>:n1,n2s/word1/word2/g</code>：n1 与 n2 为数字。在第 n1 与 n2 列之间寻找 word1 这个字串，并将该字串取代为 word2 ！举例来说，在 100 到 200 列之间搜寻 vbird 并取代为 VBIRD 则：<code>:100,200s/vbird/VBIRD/g</code>（常用）</li>
<li><code>:1,$s/word1/word2/g</code>：从第一列到最后一列寻找 word1 字串，并将该字串取代为 word2 ！（常用）</li>
<li><code>:1,$s/word1/word2/gc</code>：从第一列到最后一列寻找 word1 字串，并将该字串取代为 word2 ！且在取代前显示提示字符给使用者确认 （confirm） 是否需要取代！（常用）</li>
</ul>
</li>
</ul>
<blockquote>
<p>进入插入或取代的编辑模式</p>
</blockquote>
<ul>
<li><code>i, I</code>：进入插入模式（Insert mode）<ul>
<li>i 为“从目前光标所在处插入”， I 为“在目前所在列的第一个非空白字符处开始插入”。 （常用）</li>
</ul>
</li>
<li><code>a, A</code>：进入插入模式（Insert mode）<ul>
<li>a 为“从目前光标所在的下一个字符处开始插入”， A 为“从光标所在列的最后一个字符处开始插入”。（常用）</li>
</ul>
</li>
<li><code>o, O</code>：进入插入模式（Insert mode）<ul>
<li>这是英文字母 o 的大小写。o 为“在目前光标所在的下一列处插入新的一列”； O 为在目前光标所在处的上一列插入新的一列！（常用）</li>
</ul>
</li>
<li><code>r, R</code>：进入取代模式（Replace mode）<ul>
<li>r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；（常用）</li>
</ul>
</li>
<li>上面这些按键中，在 vi 画面的左下角处会出现“–INSERT–”或“–REPLACE–”的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在文件里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</li>
<li><code>[Esc]</code>：退出编辑模式，回到一般指令模式中（常用）</li>
</ul>
<blockquote>
<p>一般指令模式切换到指令列模式的可用按钮说明</p>
</blockquote>
<ul>
<li>指令列模式的储存、离开等指令<ul>
<li><code>:w</code>：将编辑的数据写入硬盘文件中（常用）</li>
<li><code>:w!</code>：若文件属性为“只读”时，强制写入该文件。不过，到底能不能写入， 还是跟你对该文件的文件权限有关啊！</li>
<li><code>:q</code>：离开 vi （常用）</li>
<li><code>:q!</code>：若曾修改过文件，又不想储存，使用 ! 为强制离开不储存盘案。</li>
<li><code>:wq</code>：储存后离开，若为 <code>:wq!</code> 则为强制储存后离开 （常用）</li>
<li><code>ZZ</code>：这是大写的 Z 喔！若文件没有更动，则不储存离开，若文件已经被更动过，则储存后离开！</li>
<li><code>:w [filename]</code>：将编辑的数据储存成另一个文件（类似另存新文件）</li>
<li><code>:r [filename]</code>：在编辑的数据中，读入另一个文件的数据。亦即将 “filename” 这个文件内容加到光标所在列后面</li>
<li><code>:n1,n2 w [filename]</code>：将 n1 到 n2 的内容储存成 filename 这个文件。</li>
<li><code>:! command</code>：暂时离开 vi 到指令列模式下执行 command 的显示结果！例如 <code>:! ls /home</code> 即可在 vi 当中察看 /home 下面以 ls 输出的文件信息！</li>
</ul>
</li>
<li>vim 环境的变更<ul>
<li><code>:set nu</code>：显示行号，设置之后，会在每一列的字首显示该列的行号</li>
<li><code>:set nonu</code>：与 set nu 相反，为取消行号！</li>
</ul>
</li>
</ul>
<blockquote>
<p>区块选择（Visual Block）</p>
</blockquote>
<ul>
<li><code>v</code>：字符选择，会将光标经过的地方反白选择！</li>
<li><code>V</code>：列选择，会将光标经过的列反白选择！</li>
<li><code>[Ctrl]+v</code>：区块选择，可以用长方形的方式选择数据</li>
<li><code>y</code>：将反白的地方复制起来</li>
<li><code>d</code>：将反白的地方删除掉</li>
<li><code>p</code>：将刚刚复制的区块，在光标所在处贴上！</li>
</ul>
<blockquote>
<p>多文件编辑</p>
</blockquote>
<p>通过 <code>vim file1 file2</code> 指令来使用一个 vim 打开两个文件</p>
<ul>
<li><code>:n</code>：编辑下一个文件</li>
<li><code>:N</code>：编辑上一个文件</li>
<li><code>:files</code>：列出目前这个 vim 的打开的所有文件</li>
</ul>
<blockquote>
<p>多窗口功能</p>
</blockquote>
<p>如何分区窗口并放入文件呢？ 很简单啊！在指令列模式输入“:sp {filename}”即可！那个 filename 可有可无， 如果想要在新窗口启动另一个文件，就加入文件名，否则仅输入 :sp 时， 出现的则是同一个文件在两个窗口间！</p>
<ul>
<li><code>:sp [filename]</code>：打开一个新窗口，如果有加 filename， 表示在新窗口打开一个新文件，否则表示两个窗口为同一个文件内容（同步显示）。</li>
<li><code>[ctrl]+w+j</code> / <code>[ctrl]+w+↓</code> ：按键的按法是：先按下 [ctrl] 不放， 再按下 w 后放开所有的按键，然后再按下 j （或向下方向键），则光标可移动到下方的窗口。</li>
<li><code>[ctrl]+w+k</code> / <code>[ctrl]+w+↑</code>：同上，不过光标移动到上面的窗口。</li>
<li><code>[ctrl]+w+q</code>：其实就是 :q 结束离开啦！ 举例来说，如果我想要结束下方的窗口，那么利用 <code>[ctrl]+w+↓</code> 移动到下方窗口后，按下 <code>:q</code> 即可离开， 也可以按下 <code>[ctrl]+w+q</code> 啊！</li>
</ul>
<blockquote>
<p>vim 环境设置与记录</p>
</blockquote>
<p>主要是修改 <code>~/.vimrc</code> 和 <code>~/.viminfo</code></p>
<ul>
<li><code>:set nu</code> / <code>:set nonu</code>：就是设置与取消行号啊！</li>
<li><code>:set hlsearch</code> / <code>:set nohlsearch</code>：hlsearch 就是 high light search（高亮度搜寻）。 这个就是设置是否将搜寻的字串反白的设置值。默认值是 hlsearch</li>
<li><code>:set autoindent</code> / <code>:set noautoindent</code>：是否自动缩排？autoindent 就是自动缩排。</li>
<li><code>:set backup</code>：是否自动储存备份文件？一般是 nobackup 的， 如果设置 backup 的话，那么当你更动任何一个文件时，则原始文件会被另存成一个文件名为 filename~ 的文件。 举例来说，我们编辑 hosts ，设置 <code>:set backup</code>，那么当更动 hosts 时，在同目录下，就会产生 hosts~ 文件名的文件，记录原始的 hosts 文件内容</li>
<li><code>:set ruler</code>：还记得我们提到的右下角的一些状态列说明吗？ 这个 ruler 就是在显示或不显示该设置值的啦！</li>
<li><code>:set showmode</code>：这个则是，是否要显示 <code>--INSERT--</code> 之类的字眼在左下角的状态列。</li>
<li><code>:set backspace=（012）</code>：一般来说， 如果我们按下 i 进入编辑模式后，可以利用倒退键 （backspace） 来删除任意字符的。 但是，某些 distribution 则不许如此。此时，我们就可以通过 backspace 来设置啰～ 当 backspace 为 2 时，就是可以删除任意值；0 或 1 时，仅可删除刚刚输入的字符， 而无法删除原本就已经存在的文字了！</li>
<li><code>:set all</code>：显示目前所有的环境参数设置值。</li>
<li><code>:set</code>：显示与系统默认值不同的设置参数， 一般来说就是你有自行变动过的设置参数啦！</li>
<li><code>:syntax on</code> / <code>:syntax off</code>：是否依据程序相关语法显示不同颜色？ 举例来说，在编辑一个纯文本文件时，如果开头是以 # 开始，那么该列就会变成蓝色。 如果你懂得写程序，那么这个 <code>:syntax on</code> 还会主动的帮你除错呢！但是， 如果你仅是编写纯文本，要避免颜色对你的屏幕产生的干扰，则可以取消这个设置 。</li>
<li><code>:set bg=dark</code> / <code>:set bg=light</code>：可用以显示不同的颜色色调，默认是 light 。如果你常常发现注解的字体深蓝色实在很不容易看， 那么这里可以设置为 dark 喔！试看看，会有不同的样式呢！</li>
</ul>
<p>总之，这些设置值很有用处的啦！但是…我是否每次使用 vim 都要重新设置一次各个参数值？ 这不太合理吧？没错啊！所以，我们可以通过配置文件来直接规定我们习惯的 vim 操作环境呢！ 整体 vim 的设置值一般是放置在 <code>/etc/vimrc</code> 这个文件，不过，不建议你修改他！ 你可以修改 <code>~/.vimrc</code> 这个文件 （默认不存在，请你自行手动创建！），将你所希望的设置值写入！ 举例来说，可以是这样的一个文件：</p>
<p><img src="/images/14590898239987.jpg" alt=""></p>
<p>很多朋友常常哀嚎，说他们的 vim 里面怎么无法显示正常的中文啊？其实这很有可能是因为编码的问题！ 因为中文编码有 big5 与 utf8 两种，如果你的文件是使用 big5 编码制作的，但在 vim 的终端接口中你使用的是万国码（utf8）， 由于编码的不同，你的中文文件内容当然就是一堆乱码了！怎么办？这时你得要考虑许多东西啦！有这些：</p>
<ol>
<li>你的 Linux 系统默认支持的语系数据：这与 <code>/etc/locale.conf</code> 有关；</li>
<li>你的终端接口 （bash） 的语系： 这与 <code>LANG</code>, <code>LC_ALL</code> 这几个变量有关；</li>
<li>你的文件原本的编码；</li>
<li>打开终端机的软件，例如在 GNOME 下面的窗口接口。</li>
</ol>
<p>事实上最重要的是上头的第三与第四点，只要这两点的编码一致，你就能够正确的看到与编辑你的中文文件。 否则就会看到一堆乱码啦！</p>
<h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2><p>默认的指令记忆功能可以到达 1000 个！也就是说，你曾经下达过的指令几乎都被记录下来了。<br>这么多的指令记录在哪里呢？在你的主文件夹内的 <code>.bash_history</code> 啦！ 不过，需要留意的是，<code>~/.bash_history</code> 记录的是前一次登陆以前所执行过的指令， 而至于这一次登陆所执行的指令都被暂存在内存中，当你成功的登出系统后，该指令记忆才会记录到 <code>.bash_history</code> 当中！</p>
<p>bash 的配置文件主要分为 login shell 与 non-login shell。login shell 主要读取 <code>/etc/profile</code> 与 <code>~/.bash_profile</code>， non-login shell 则仅读取 <code>~/.bashrc</code></p>
<blockquote>
<p>命令别名设置功能 alias</p>
</blockquote>
<p>假如我需要知道这个目录下面的所有文件 （包含隐藏文件） 及所有的文件属性，那么我就必须要下达 <code>ls -al</code> 这样的指令串，唉！真麻烦，有没有更快的取代方式？呵呵！就使用命令别名呀！例如鸟哥最喜欢直接以 lm 这个自订的命令来取代上面的命令，也就是说， lm 会等于 <code>ls -al</code> 这样的一个功能，嘿！那么要如何作呢？就使用 alias 即可！你可以在指令列输入 alias 就可以知道目前的命令别名有哪些了！也可以直接下达命令来设置别名呦：<code>alias lm=&#39;ls -al&#39;</code></p>
<blockquote>
<p>查询指令是否为 Bash shell 的内置命令 type</p>
</blockquote>
<p><code>type [-tpa] name</code> 选项与参数：</p>
<ul>
<li>不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内置指令</li>
<li><code>-t</code>：当加入 -t 参数时，type 会将 name 以下面这些字眼显示出他的意义：<ul>
<li><code>file</code>：表示为外部指令；</li>
<li><code>alias</code>：表示该指令为命令别名所设置的名称；</li>
<li><code>builtin</code>：表示该指令为 bash 内置的指令功能；</li>
</ul>
</li>
<li><code>-p</code>：如果后面接的 name 为外部指令时，才会显示完整文件名；</li>
<li><code>-a</code>：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 alias</li>
</ul>
<blockquote>
<p>指令的下达与快速编辑按钮</p>
</blockquote>
<p>上面这个指令用途是将三个文件复制到 <code>/root</code> 这个目录下而已。不过，因为指令太长， 于是鸟哥就利用 <code>\[Enter]</code> 来将 [Enter] 这个按键“跳脱！”开来，让 [Enter] 按键不再具有“开始执行”的功能！好让指令可以继续在下一行输入。 需要特别留意， [Enter] 按键是紧接着反斜线 <code>\</code> 的，两者中间没有其他字符。 因为 <code>\</code> 仅跳脱“紧接着的下一个字符”而已！</p>
<p>另外，当你所需要下达的指令特别长，或者是你输入了一串错误的指令时，你想要快速的将这串指令整个删除掉，一般来说，我们都是按下删除键的。 有没有其他的快速组合键可以协助呢？是有的！常见的有下面这些：</p>
<ul>
<li><code>[ctrl]+u</code> / <code>[ctrl]+k</code><ul>
<li>分别是从光标处向前删除指令串 （[ctrl]+u） 及向后删除指令串 （[ctrl]+k）。</li>
</ul>
</li>
<li><code>[ctrl]+a</code> / <code>[ctrl]+e</code><ul>
<li>分别是让光标移动到整个指令串的最前面 （[ctrl]+a） 或最后面 （[ctrl]+e）。</li>
</ul>
</li>
</ul>
<p>Shell 相关的部分会另外进行学习，这里暂时略过</p>
<blockquote>
<p>万用字符</p>
</blockquote>
<ul>
<li><code>*</code>：代表“ 0 个到无穷多个”任意字符</li>
<li><code>?</code>：代表“一定有一个”任意字符</li>
<li><code>[ ]</code>：同样代表“一定有一个在括号内”的字符（非任意字符）。例如 [abcd] 代表“一定有一个字符， 可能是 a, b, c, d 这四个任何一个”</li>
<li><code>[ - ]</code>：若有减号在中括号内时，代表“在编码顺序内的所有字符”。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！</li>
<li><code>[^ ]</code>：若中括号内的第一个字符为指数符号（<code>^</code>），那表示“反向选择”，例如 <code>[^abc]</code> 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。</li>
</ul>
<blockquote>
<p>特殊符号</p>
</blockquote>
<ul>
<li><code>#</code> 注解符号：这个最常被使用在 script 当中，视为说明！在后的数据均不执行</li>
<li><code>\</code> 跳脱符号：将“特殊字符或万用字符”还原成一般字符</li>
<li><code>|</code> 管线 （pipe）：分隔两个管线命令的界定（后两节介绍）；</li>
<li><code>;</code> 连续指令下达分隔符号：连续性命令的界定 （注意！与管线命令并不相同）</li>
<li><code>~</code> 使用者的主文件夹</li>
<li><code>$</code> 取用变量前置字符：亦即是变量之前需要加的变量取代值</li>
<li><code>&amp;</code> 工作控制 （job control）：将指令变成背景下工作</li>
<li><code>!</code> 逻辑运算意义上的“非” not 的意思！</li>
<li><code>/</code> 目录符号：路径分隔的符号</li>
<li><code>&gt;</code>, <code>&gt;&gt;</code> 数据流重导向：输出导向，分别是“取代”与“累加”</li>
<li><code>&lt;</code>, <code>&lt;&lt;</code> 数据流重导向：输入导向 （这两个留待下节介绍）</li>
<li><code>&#39; &#39;</code> 单引号，不具有变量置换的功能（<code>$</code> 变为纯文本）</li>
<li><code>&quot; &quot;</code> 具有变量置换的功能！（<code>$</code> 可保留相关功能）</li>
<li>` ` 两个 ` 中间为可以先执行的指令，亦可使用 $（ ）</li>
<li><code>（ ）</code> 在中间为子 shell 的起始与结束</li>
<li><code>{ }</code> 在中间为命令区块的组合！</li>
</ul>
<blockquote>
<p>重定向</p>
</blockquote>
<p>简单的说，标准输出指的是“指令执行所回传的正确的讯息”，而标准错误输出可理解为“ 指令执行失败后，所回传的错误讯息”。举个简单例子来说，我们的系统默认有 <code>/etc/crontab</code> 但却无 <code>/etc/vbirdsay</code>， 此时若下达 <code>cat /etc/crontab /etc/vbirdsay</code> 这个指令时，cat 会进行：</p>
<ul>
<li>标准输出：读取 <code>/etc/crontab</code> 后，将该文件内容显示到屏幕上；</li>
<li>标准错误输出：因为无法找到 <code>/etc/vbirdsay</code>，因此在屏幕上显示错误讯息</li>
</ul>
<p>不管正确或错误的数据都是默认输出到屏幕上，所以屏幕当然是乱乱的！那能不能通过某些机制将这两股数据分开呢？ 当然可以啊！那就是数据流重导向的功能啊！数据流重导向可以将 standard output （简称 stdout） 与 standard error output （简称 stderr） 分别传送到其他的文件或设备去，而分别传送所用的特殊字符则如下所示：</p>
<ol>
<li>标准输入　　（stdin） ：代码为 0 ，使用 <code>&lt;</code> 或 <code>&lt;&lt;</code> ；</li>
<li>标准输出　　（stdout）：代码为 1 ，使用 <code>&gt;</code>（覆盖） 或 <code>&gt;&gt;</code>（累加） ；</li>
<li>标准错误输出（stderr）：代码为 2 ，使用 <code>2&gt;</code>（覆盖） 或 <code>2&gt;&gt;</code>（累加） ；</li>
</ol>
<p>想像一下，如果我知道错误讯息会发生，所以要将错误讯息忽略掉而不显示或储存呢？ 这个时候黑洞设备 /dev/null 就很重要了！这个 /dev/null 可以吃掉任何导向这个设备的信息喔！</p>
<p>如：<code>find /home -name .bashrc 2&gt; /dev/null</code></p>
<blockquote>
<p>命令执行的判断依据： <code>;</code> , <code>&amp;&amp;</code>, <code>||</code></p>
</blockquote>
<ul>
<li><code>cmd ; cmd</code> 不考虑指令相关性的连续指令下达</li>
<li><code>$? （指令回传值） 与 &amp;&amp; 或 ||</code></li>
</ul>
<blockquote>
<p>管线命令 pipe</p>
</blockquote>
<p>在每个管线后面接的第一个数据必定是“指令”喔！而且这个指令必须要能够接受 standard input 的数据才行，这样的指令才可以是为“管线命令”，例如 less, more, head, tail 等都是可以接受 standard input 的管线命令啦。至于例如 ls, cp, mv 等就不是管线命令了！因为 ls, cp, mv 并不会接受来自 stdin 的数据。 也就是说，管线命令主要有两个比较需要注意的地方：</p>
<ul>
<li>管线命令仅会处理 standard output，对于 standard error output 会予以忽略</li>
<li>管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行。</li>
</ul>
<blockquote>
<p>关于减号 - 的用途</p>
</blockquote>
<p>管线命令在 bash 的连续的处理程序中是相当重要的！另外，在 log file 的分析当中也是相当重要的一环， 所以请特别留意！另外，在管线命令当中，常常会使用到前一个指令的 stdout 作为这次的 stdin ， 某些指令需要用到文件名称 （例如 tar） 来进行处理时，该 stdin 与 stdout 可以利用减号 “-“ 来替代， 举例来说：</p>
<p>``bash<br>mkdir /tmp/homeback<br>tar -cvf - /home | tar -xvf - -C /tmp/homeback<br>```</p>
<p>上面这个例子是说：“我将 /home 里面的文件给他打包，但打包的数据不是纪录到文件，而是传送到 stdout； 经过管线后，将 <code>tar -cvf - /home</code> 传送给后面的 <code>tar -xvf -</code> ”。后面的这个 <code>-</code> 则是取用前一个指令的 <code>stdout</code>，因此，我们就不需要使用 filename 了！这是很常见的例子喔！注意注意！</p>
<h2 id="Linux__u76EE_u5F55_u7684_u542B_u4E49"><a href="#Linux__u76EE_u5F55_u7684_u542B_u4E49" class="headerlink" title="Linux 目录的含义"></a>Linux 目录的含义</h2><ul>
<li><code>bin</code><ul>
<li>系统有很多放置可执行文件的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin下面的指令可以被root与一般帐号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。</li>
</ul>
</li>
<li><code>/boot</code><ul>
<li>这个目录主要在放置开机会使用到的文件，包括Linux核心文件以及开机菜单与开机所需配置文件等等。 Linux kernel常用的文件名为：vmlinuz，如果使用的是grub2这个开机管理程序， 则还会存在/boot/grub2/这个目录喔！</li>
</ul>
</li>
<li><code>/dev</code><ul>
<li>在Linux系统上，任何设备与周边设备都是以文件的型态存在于这个目录当中的。 你只要通过存取这个目录下面的某个文件，就等于存取某个设备啰～ 比要重要的文件有 <code>/dev/null</code>, <code>/dev/zero</code>, <code>/dev/tty</code>, <code>/dev/loop*</code>, <code>/dev/sd*</code> 等等 </li>
</ul>
</li>
<li><code>/etc</code><ul>
<li>系统主要的配置文件几乎都放置在这个目录内，例如人员的帐号密码档、 各种服务的启始档等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的， 但是只有root有权力修改。FHS建议不要放置可可执行文件（binary）在这个目录中喔。比较重要的文件有： /etc/modprobe.d/, /etc/passwd, /etc/fstab, /etc/issue 等等。另外 FHS 还规范几个重要的目录最好要存在 /etc/ 目录下喔：</li>
<li>/etc/opt（必要）：这个目录在放置第三方协力软件 /opt 的相关配置文件</li>
<li>/etc/X11/（建议）：与 X Window 有关的各种配置文件都在这里，尤其是 xorg.conf 这个 X Server 的配置文件。</li>
<li>/etc/sgml/（建议）：与 SGML 格式有关的各项配置文件</li>
<li>/etc/xml/（建议）：与 XML 格式有关的各项配置文件</li>
</ul>
</li>
<li><code>/lib</code><ul>
<li>系统的函数库非常的多，而/lib放置的则是在开机时会用到的函数库， 以及在/bin或/sbin下面的指令会调用的函数库而已。 什么是函数库呢？你可以将他想成是“外挂”，某些指令必须要有这些“外挂”才能够顺利完成程序的执行之意。 另外 FSH 还要求下面的目录必须要存在：</li>
<li>/lib/modules/：这个目录主要放置可抽换式的核心相关模块（驱动程序）喔！</li>
</ul>
</li>
<li><code>/media</code><ul>
<li>media是“媒体”的英文，顾名思义，这个/media下面放置的就是可移除的设备啦！ 包括软盘、光盘、DVD等等设备都暂时挂载于此。常见的文件名有：/media/floppy，/media/cdrom等等。</li>
</ul>
</li>
<li><code>/mnt</code><ul>
<li>如果你想要暂时挂载某些额外的设备，一般建议你可以放置到这个目录中。 在古早时候，这个目录的用途与/media相同啦！只是有了/media之后，这个目录就用来暂时挂载用了。</li>
</ul>
</li>
<li><code>/opt</code><ul>
<li>这个是给第三方协力软件放置的目录。什么是第三方协力软件啊？ 举例来说，KDE这个桌面管理系统是一个独立的计划，不过他可以安装到Linux系统中，因此KDE的软件就建议放置到此目录下了。 另外，如果你想要自行安装额外的软件（非原本的distribution提供的），那么也能够将你的软件安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！ </li>
</ul>
</li>
<li><code>/run</code><ul>
<li>早期的 FHS 规定系统开机后所产生的各项信息应该要放置到 /var/run 目录下，新版的 FHS 则规范到 /run 下面。 由于 /run 可以使用内存来仿真，因此性能上会好很多！</li>
</ul>
</li>
<li><code>/sbin</code><ul>
<li>Linux有非常多指令是用来设置系统环境的，这些指令只有root才能够利用来“设置”系统，其他使用者最多只能用来“查询”而已。 放在/sbin下面的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序，一般则放置到/usr/sbin/当中。至于本机自行安装的软件所产生的系统可执行文件（system binary）， 则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, mkfs等等。</li>
</ul>
</li>
<li><code>/srv</code><ul>
<li>srv可以视为“service”的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如WWW, FTP等等。举例来说，WWW服务器需要的网页数据就可以放置在/srv/www/里面。 不过，系统的服务数据如果尚未要提供给网际网络任何人浏览的话，默认还是建议放置到 /var/lib 下面即可。 </li>
</ul>
</li>
<li><code>/tmp</code><ul>
<li>这是让一般使用者或者是正在执行的程序暂时放置文件的地方。 这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！ 因为FHS甚至建议在开机时，应该要将/tmp下的数据都删除唷！</li>
</ul>
</li>
<li><code>/usr</code><ul>
<li>第二层 FHS 设置，后续介绍</li>
</ul>
</li>
<li><code>/var</code><ul>
<li>第二层 FHS 设置，主要为放置变动性的数据，后续介绍</li>
</ul>
</li>
</ul>
<p>FHS 建议可以存在的目录</p>
<ul>
<li><code>/home</code><ul>
<li>这是系统默认的使用者主文件夹（home directory）。在你新增一个一般使用者帐号时， 默认的使用者主文件夹都会规范到这里来。比较重要的是，主文件夹有两种代号喔：</li>
<li><code>~</code>：代表目前这个使用者的主文件夹</li>
<li><code>~dmtsai</code>：则代表 dmtsai 的主文件夹！</li>
</ul>
</li>
<li><code>/lib&lt;qual&gt;</code><ul>
<li>用来存放与 /lib 不同的格式的二进制函数库，例如支持 64 位的 /lib64 函数库等</li>
</ul>
</li>
<li><code>/root</code><ul>
<li>系统管理员（root）的主文件夹。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有root的主文件夹，所以我们会希望root的主文件夹与根目录放置在同一个分区中。</li>
</ul>
</li>
</ul>
<p>事实上FHS针对根目录所定义的标准就仅有上面的咚咚，不过我们的Linux下面还有许多目录你也需要了解一下的。 下面是几个在Linux当中也是非常重要的目录喔</p>
<ul>
<li><code>/lost+found</code><ul>
<li>这个目录是使用标准的ext2/ext3/ext4文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。不过如果使用的是 xfs 文件系统的话，就不会存在这个目录了！</li>
</ul>
</li>
<li><code>/proc</code><ul>
<li>这个目录本身是一个“虚拟文件系统（virtual filesystem）”喔！他放置的数据都是在内存当中， 例如系统核心、行程信息（process）、周边设备的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的文件例如：<code>/proc/cpuinfo</code>, <code>/proc/dma</code>, <code>/proc/interrupts</code>, <code>/proc/ioports</code>, <code>/proc/net/*</code> 等等。</li>
</ul>
</li>
<li><code>/sys</code><ul>
<li>这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录核心与系统硬件信息较相关的信息。 包括目前已载入的核心模块与核心侦测到的硬件设备信息等等。这个目录同样不占硬盘容量喔！</li>
</ul>
</li>
</ul>
<p>早期 Linux 在设计的时候，若发生问题时，救援模式通常仅挂载根目录而已，因此有五个重要的目录被要求一定要与根目录放置在一起， 那就是 /etc, /bin, /dev, /lib, /sbin 这五个重要目录。现在许多的 Linux distributions 由于已经将许多非必要的文件移出 /usr 之外了， 所以 /usr 也是越来越精简，同时因为 /usr 被建议为“即使挂载成为只读，系统还是可以正常运行”的模样，所以救援模式也能同时挂载 /usr 喔！ </p>
<h3 id="/usr__u4ECB_u7ECD"><a href="#/usr__u4ECB_u7ECD" class="headerlink" title="/usr 介绍"></a>/usr 介绍</h3><p>依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的（shareable, static）。usr是Unix Software Resource的缩写， 也就是“Unix操作系统软件资源”所放置的目录，而不是使用者的数据啦！这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行创建该软件自己独立的目录。</p>
<p>一般来说，/usr的次目录建议有下面这些：</p>
<ul>
<li><code>/usr/bin/</code><ul>
<li>所有一般用户能够使用的指令都放在这里！目前新的 CentOS 7 已经将全部的使用者指令放置于此，而使用链接文件的方式将 /bin 链接至此！ 也就是说， /usr/bin 与 /bin 是一模一样了！另外，FHS 要求在此目录下不应该有子目录！</li>
</ul>
</li>
<li><code>/usr/lib/</code><ul>
<li>基本上，与 /lib 功能相同，所以 /lib 就是链接到此目录中的！</li>
</ul>
</li>
<li><code>/usr/local/</code><ul>
<li>系统管理员在本机自行安装自己下载的软件（非distribution默认提供者），建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦！ 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录喔！</li>
</ul>
</li>
<li><code>/usr/sbin/</code><ul>
<li>非系统正常运行所需要的系统指令。最常见的就是某些网络服务器软件的服务指令（daemon）啰！不过基本功能与 /sbin 也差不多， 因此目前 /sbin 就是链接到此目录中的。</li>
</ul>
</li>
<li><code>/usr/share/</code><ul>
<li>主要放置只读架构的数据文件，当然也包括共享文件。在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文字文件嘛！在此目录下常见的还有这些次目录：</li>
<li>/usr/share/man：线上说明文档</li>
<li>/usr/share/doc：软件杂项的文件说明</li>
<li>/usr/share/zoneinfo：与时区有关的时区文件</li>
</ul>
</li>
</ul>
<p>FHS 建议可以存在的目录</p>
<ul>
<li><code>/usr/games/</code><ul>
<li>与游戏比较相关的数据放置处</li>
</ul>
</li>
<li><code>/usr/include/</code><ul>
<li>c/c++等程序语言的文件开始（header）与包含档（include）放置处，当我们以tarball方式 （<code>*.tar.gz</code> 的方式安装软件）安装某些数据时，会使用到里头的许多包含档喔！</li>
</ul>
</li>
<li><code>/usr/libexec/</code><ul>
<li>某些不被一般使用者惯用的可执行文件或脚本（script）等等，都会放置在此目录中。例如大部分的 X 窗口下面的操作指令， 很多都是放在此目录下的。</li>
</ul>
</li>
<li><code>/usr/lib&lt;qual&gt;/</code><ul>
<li>与 <code>/lib&lt;qual&gt;/</code> 功能相同，因此目前 <code>/lib&lt;qual&gt;</code> 就是链接到此目录中 </li>
</ul>
</li>
<li><code>/usr/src/</code><ul>
<li>一般源代码建议放置到这里，src有source的意思。至于核心源代码则建议放置到/usr/src/linux/目录下。</li>
</ul>
</li>
</ul>
<h3 id="/var__u4ECB_u7ECD"><a href="#/var__u4ECB_u7ECD" class="headerlink" title="/var 介绍"></a>/var 介绍</h3><p>如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运行后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括高速缓存（cache）、登录文件（log file）以及某些软件运行所产生的文件， 包括程序文件（lock file, run file），或者例如MySQL数据库的文件等等。常见的次目录有：</p>
<ul>
<li><code>/var/cache/</code><ul>
<li>应用程序本身运行过程中会产生的一些暂存盘；</li>
</ul>
</li>
<li><code>/var/lib/</code><ul>
<li>程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去！</li>
</ul>
</li>
<li><code>/var/lock/</code><ul>
<li>某些设备或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该设备时， 就可能产生一些错误的状况，因此就得要将该设备上锁（lock），以确保该设备只会给单一软件所使用。 举例来说，烧录机正在烧录一块光盘，你想一下，会不会有两个人同时在使用一个烧录机烧片？ 如果两个人同时烧录，那片子写入的是谁的数据？所以当第一个人在烧录时该烧录机就会被上锁， 第二个人就得要该设备被解除锁定（就是前一个人用完了）才能够继续使用啰。目前此目录也已经挪到 /run/lock 中！</li>
</ul>
</li>
<li><code>/var/log/</code><ul>
<li>重要到不行！这是登录文件放置的目录！里面比较重要的文件如/var/log/messages, /var/log/wtmp（记录登陆者的信息）等。</li>
</ul>
</li>
<li><code>/var/mail/</code><ul>
<li>放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中！ 通常这两个目录是互为链接文件啦！</li>
</ul>
</li>
<li><code>/var/run/</code><ul>
<li>某些程序或者是服务启动后，会将他们的PID放置在这个目录下喔！至于PID的意义我们会在后续章节提到的。 与 /run 相同，这个目录链接到 /run 去了！</li>
</ul>
</li>
<li><code>/var/spool/</code><ul>
<li>这个目录通常放置一些伫列数据，所谓的“伫列”就是排队等待其他程序使用的数据啦！ 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作调度数据（crontab），就会被放置到/var/spool/cron/目录中！</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为之后更多会涉及后台开发的部分，所以系统学习一下 Linux 还是很有必要的，这里就用《鸟哥的 Linux 私房菜》作为主要的学习材料。不过因为我本身已经有一定基础了，所以这里主要会记录个人觉得比较生疏和重要的地方。</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://wdxtub.com/tags/Linux/"/>
    
      <category term="基础" scheme="http://wdxtub.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="服务器" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【启示录：打造用户喜爱的产品】读书笔记]]></title>
    <link href="http://wdxtub.com/2016/03/26/inspired-create-product/"/>
    <id>http://wdxtub.com/2016/03/26/inspired-create-product/</id>
    <published>2016-03-26T20:53:01.000Z</published>
    <updated>2016-03-26T20:56:23.000Z</updated>
    <content type="html"><![CDATA[<p>这本书基本上说清楚了打造好产品的方方面面，很值得一看。</p>
<a id="more"></a>
<hr>
<p>我们汲取了深刻教训：如果开发的产品没有市场价值，那么无论开发团队多么优秀也无济于事。不仅如此，我们认识到仅仅做出产品并不够，还要确认产品是有价值的、可用的、可行的。</p>
<p>从担任网景高级产品经理开始，我的日常工作明确分为三块：人员、流程、产品。</p>
<ul>
<li>人员是指负责定义和开发产品的团队成员的角色和职责。</li>
<li>流程是指探索、开发富有创意的产品时，反复应用的步骤和成功的实践经验。</li>
<li>产品是指富有创意的产品具有的鲜明特性。</li>
</ul>
<p>这三个部分是探索和开发用户喜爱的产品必不可少的。项目都是由人完成的，流程则保证大家持续开发出用户喜爱的产品。</p>
<hr>
<p>我从不认为富有创意的产品来自偶然。成功的产品都遵循一定的规律。以下是我总结的十条规律。</p>
<ol>
<li>产品经理的任务是探索产品的价值、可用性、可行性。</li>
<li>探索（定义）产品需要产品经理、交互设计师、软件架构师通力合作。</li>
<li>开发人员不擅长用户体验设计，因为开发人员脑子里想的是实现模型，而用户看重的是产品的概念模型。</li>
<li>用户体验设计就是交互设计、视觉设计（对硬件设备来说，则是工业设计）。</li>
<li>功能（产品需求）和用户体验设计密不可分。</li>
<li>产品创意必须尽早地、反复地接受目标用户的试用，以便获取有效的用户体验。</li>
<li>为了验证产品的价值和可用性，必须尽早地、反复地请目标用户测试产品创意。</li>
<li>采用高保真的产品原型是全体团队成员了解用户需求和用户体验最有效的途径。</li>
<li>产品经理的目标是在最短的时间内把握复杂的市场/用户需求，确定产品的基本要求——价值、可用性、可行性。</li>
<li>一旦认定产品符合以上基本要求，它就是一个完整的概念，去掉任何因素，都不可能达到预期的结果。</li>
</ol>
<h2 id="u5173_u952E_u89D2_u8272_u53CA_u5176_u804C_u8D23"><a href="#u5173_u952E_u89D2_u8272_u53CA_u5176_u804C_u8D23" class="headerlink" title="关键角色及其职责"></a>关键角色及其职责</h2><p>产品经理的主要职责分为两项：评估产品机会（product opportunity）；定义要开发的产品。</p>
<p>产品创意的来源很多，比如，公司高管的意见、用户的反馈、可用性测试的结果、产品团队和营销团队的点子、业内人士的分析等。应该有人严格审核这些创意，判断是否值得采纳。产品经理就是负责这项评估的人。许多公司借助市场需求文档（market requirements document，MRD）来完成这项工作。我更愿意使用一种简化的方法，我称之为机会评估（opportunity assessment）。</p>
<p>确定有价值且符合公司发展要求的产品机会后，还需要探索产品的解决方案，包括基本的产品特征和功能、产品的用户体验、产品的发布标准。这些也属于产品经理的工作范畴，而且是产品经理的核心职责。有些公司借助产品需求文档（product requirements document，PRD）来完成这项工作，也有人称其为产品说明文档或功能说明文档。同样，我主张采用简化的文档，围绕产品原型来展开这项工作。注意，文档应该清晰地描述产品的功能和属性，避免讨论产品的实现方法。</p>
<p>用户体验设计团队由多种角色组成，稍后我会详细说明。这里只谈谈最关键的角色——交互设计师（也称为信息架构师、用户界面设计师、用户体验架构师）。交互设计师负责深入理解目标用户，设计有价值的、可用的功能，以及用户导航和产品使用流程。交互设计师与产品经理密切合作，将功能与设计相结合，满足用户需求。目标是确保产品同时具有可用性和价值（可用性指的是用户明白如何使用产品，价值指的是用户对产品的渴求程度）。</p>
<p>产品经理完成产品定义后，开发团队承接项目，开始开发产品。项目管理的核心任务是制订计划和跟踪进度。项目管理工作常常由不同的角色承担，可能由专职的项目经理操刀，也可能由开发经理兼任（因为开发团队占有大部分项目资源），还可能由产品经理披挂上阵。这通常取决于公司文化和项目规模。规模较大的项目最好安排经验丰富的专职项目经理管理。</p>
<p>软件工程师也称为产品开发人员或软件开发人员，负责开发产品。开发团队在有些公司被称为IT（信息技术）团队。注意不要混淆这两个概念，区分的关键是看他们是为顾客开发软件，还是为公司内部（如人力资源部门）开发软件。IT团队通常指的是为内部员工提供技术支持的团队，而开发团队指的是为外部客户开发和维护产品的团队。</p>
<p>互联网服务产品通常运行在服务器上，用户通过web访问服务。运维团队负责保证服务正常运行。虽然有些公司将这项任务交给开发团队负责，但是运维工作需要一系列专业技能，很难由开发团队单独承担。</p>
<p>产品营销团队负责对外发布信息、宣传产品，为拓展市场销售渠道、组织重点营销活动（如在线营销）、促进产品销售提供支持。有些公司让一个人同时负责产品管理（产品定义）和产品营销。这两项工作内容相差很大，这样做实在不明智。</p>
<p>顺便提一下，微软把负责制定产品说明文档和管理项目进度的人称为项目经理（program manager）。由于这些“可怜”的人要同时应付多个项目，因此业界现在已经习惯用这个头衔称呼同时管理多个项目的管理人员。在微软，产品经理指的是那些负责产品营销的人。虽然我不喜欢微软对这两个头衔的用法，但我认为他们定义产品的工作做得非常棒。</p>
<h2 id="u4EA7_u54C1_u7BA1_u7406_u4E0E_u4EA7_u54C1_u8425_u9500"><a href="#u4EA7_u54C1_u7BA1_u7406_u4E0E_u4EA7_u54C1_u8425_u9500" class="headerlink" title="产品管理与产品营销"></a>产品管理与产品营销</h2><p>产品经理负责详细定义待开发的产品，让真实的用户测试产品。产品营销人员负责向外界宣传和推广产品，负责产品发布，为拓展市场销售渠道、组织重点营销活动（如在线营销）、促进产品销售提供支持。</p>
<h2 id="u4EA7_u54C1_u7BA1_u7406_u4E0E_u9879_u76EE_u7BA1_u7406"><a href="#u4EA7_u54C1_u7BA1_u7406_u4E0E_u9879_u76EE_u7BA1_u7406" class="headerlink" title="产品管理与项目管理"></a>产品管理与项目管理</h2><p>有些项目经理以为管理能力等同于使用微软Project软件的能力，他们没有领悟项目管理的真谛。以下是我从琳·丽迪这样优秀的项目经理身上总结出的七个特点。</p>
<p><strong>工作紧迫感</strong></p>
<p>只要琳走进房间，立刻就能传达给大家一种紧迫感。每次会议大约60秒闲话开场白后，马上转入正题。这种效果表面看来是因为她独特的身体语言和气质，但事实上，紧迫感和高效率是eBay企业文化的核心，而且已经升华为琳人格的一部分。</p>
<p><strong>善于捕捉问题</strong></p>
<p>有无数原因导致会议效率低下、毫无建设性，其中最主要的原因是会议目的不明确，不清楚要解决什么问题，也不知道难点在哪。优秀的项目经理能够迅速地、准确地指出问题及其要害，改善会议效果。</p>
<p><strong>思路清晰</strong></p>
<p>引发典型业务问题的原因多种多样，比如政治因素、日程安排有冲突、同事个性不合等，如果置之不理，稍作拖延就会导致整个项目一团糟。项目经理需要排除感情因素，放下思想包袱，拨云见日，把待解决的问题逐一独立分离出来，分配给每位同事，专注解决。</p>
<p><strong>用数据说话</strong></p>
<p>优秀的项目经理明白数据的重要性，懂得利用数据识别项目方向，确认项目进度。他们知道改善产品和开发流程必须从测量、收集数据开始。在时间紧迫的情况下，最容易仅凭直觉草率行事。为避免出现这种情况，项目经理务必坚持根据数据和事实制定决策。</p>
<p><strong>果断</strong></p>
<p>在多数公司里，产品团队成员不必向项目经理汇报工作，但项目经理必须驱动同事作出决策。项目经理必须向大家传达一种紧迫感，及时向团队收集数据和建议，适时向上级部门汇报情况，把问题理顺，用理性的思路和清晰的理由帮助大家，利用数据作出决策。</p>
<p><strong>判断力</strong></p>
<p>以上这些特点都基于良好的判断力。项目经理必须清楚何时催促进度，何时向上级汇报，何时需要收集更多信息，何时找个别成员私下交流。判断力很难言传身教，只能靠自己积累经验获得。</p>
<p><strong>态度</strong></p>
<p>如果产品不能按时交付，我们总能听到各种理由：可行性太差、资源不足、时间不够、资金匮乏等等。项目经理绝不能为自己找借口，必须克服所有障碍，解决所有问题，一往无前、愈挫愈勇，直到梦想成真。</p>
<h2 id="u4EA7_u54C1_u7BA1_u7406_u4E0E_u4EA7_u54C1_u8BBE_u8BA1"><a href="#u4EA7_u54C1_u7BA1_u7406_u4E0E_u4EA7_u54C1_u8BBE_u8BA1" class="headerlink" title="产品管理与产品设计"></a>产品管理与产品设计</h2><p>好产品必须提供舒适的用户体验。舒适的用户体验是产品管理和用户体验设计共同作用的结果。这是个很大的话题，我们先从了解设计包括哪些角色、分工开始。这里我给出与用户体验设计密切相关的分工。注意我描述的是工作角色而不是个人，因为有的人可能承担多项工作。</p>
<p><strong>用户研究</strong></p>
<p>专门研究、分析用户，评估产品或产品原型是否符合特定用户的使用习惯。其具体工作包括拟订恰当的测试项目，监督测试，评估测试结果，提出改进方案。</p>
<p><strong>交互设计</strong></p>
<p>在理解目标用户的基础上设计有价值的、可用的目标功能、用户导航和产品使用流程。交互设计师通常用线框绘制产品需求，然后交给视觉设计师。</p>
<p><strong>视觉设计</strong></p>
<p>根据线框设计可见的用户界面（页面），包括严格的布局、颜色和字体设置等。视觉设计能够传达并唤起产品蕴含的情感（其重要性常常被低估）。</p>
<p><strong>原型制作</strong></p>
<p>迅速制作融合了产品经理和设计师创意的产品原型，让用户试用，并根据反馈意见反复修正原型。</p>
<p>对大型产品（尤其是大众互联网服务）来说，这四种角色缺一不可。开发企业级应用软件的公司如果想从众多竞争对手中脱颖而出，最简单的办法是提供优秀的用户体验。用户体验是大部分企业级产品的弱项。对小型产品来说，可以让一位设计师身兼多职。例如，我最近与一家创业型公司合作，开发针对大众的Web 2.0服务。对方只有三个人：一位产品经理、一位交互设计师（同时负责用户研究）、一位视觉设计师（同时负责开发原型）。他们的工作非常出色，很快就拿出了可供目标用户测试的产品原型。</p>
<p>很多公司希望改善产品的用户体验，把用户体验设计外包给设计公司。这在一定程度上是可行的，但是有些工作不适合外包。例如，我认为交互设计不能外包，原因如下。</p>
<ol>
<li>深入理解用户需求非常费时间，需要多个项目的经验积累。设计公司没时间深入了解客户需求，就算他们做到了，这些经验也很难保存下来，用到下一个版本里。</li>
<li>交互设计师必须现场深度参与项目开发，从立项直到产品发布。开发和测试过程中会出现各种细节问题，必须有一名交互设计师迅速作出决定。</li>
<li>产品的用户体验是公司的核心竞争力，必须在内部完成。如果让我选择，质量检验更适合外包。 只要团队中有一位称职的交互设计师，视觉设计也可以外包，毕竟视觉设计公司很多，完全可以满足需求。此外，用户研究和可用性测试也可以外包，只是成本较高，对我这种重视测试反馈（参考第22章）的人来说更是如此，所以我建议让产品经理和交互设计师分担这项工作。</li>
</ol>
<h2 id="u4EA7_u54C1_u7BA1_u7406_u4E0E_u8F6F_u4EF6_u5F00_u53D1"><a href="#u4EA7_u54C1_u7BA1_u7406_u4E0E_u8F6F_u4EF6_u5F00_u53D1" class="headerlink" title="产品管理与软件开发"></a>产品管理与软件开发</h2><p>产品经理负责定义产品方案；开发团队最了解哪些产品构思是可行的，他们负责产品的开发与实现。作为产品经理，你很快能体会到，只有与开发团队融洽合作，才有可能开发出合格的产品；否则等待你的将是一段漫长、难挨的日子。形成合作关系的关键是双方承认彼此平等——任何一方不从属于另一方。产品经理负责定义正确的产品，开发团队负责正确地开发产品，双方相互依赖。你要求开发团队完成任务，必须先取得他们的认可，确信为了达到产品质量标准必须这么做；开发团队也要留给你足够的空间，设计有价值、可用的产品。</p>
<p>开发人员帮助产品经理完善产品定义的方式有如下三种。</p>
<ol>
<li>让开发人员直接面对用户或顾客，体会用户的困惑和疑虑，了解问题的严重性，这样好点子常常会随之而来，譬如，可以邀请一名开发人员参加产品原型测试。</li>
<li>向开发人员了解最新的技术发展动向，讨论哪些新技术可以用到产品里。开展头脑风暴，看看目前已实现的技术或即将实现的技术能不能解决手头的问题。</li>
<li>让开发人员在探索（定义）产品的初期阶段参与评估产品设计，协助策划方案。产品经理常犯一类错误，即完成产品定义后，便扔给开发团队，置之不理。这样做只会贻误协调需求与可行性的最佳时机，等到发现问题时，为时已晚。</li>
</ol>
<p>同样，产品经理也应该配合开发人员的工作，方式如下。</p>
<ol>
<li>产品经理只定义满足基本要求的产品。产品经理应该意识到，自己要定义的不是最终产品，而是满足基本要求的产品。只有这样，产品管理与软件开发之间才能形成良好的互动。</li>
<li>一旦产品进入开发阶段，要尽可能避免修改产品的需求和设计。虽然有些事情超出你的控制范围，导致项目波动是不可避免的（开发人员也能理解），但是千万不要在此时尝试突发奇想的点子。</li>
<li>产品开发阶段难免会产生诸多问题，比如，用例丢失，用例设计考虑不周全等，这很正常，最优秀的团队也避免不了。产品经理应该迅速采取行动，在维持产品基本功能、尽量避免修改的原则上，拿出解决方案。</li>
</ol>
<p>与开发团队合作应该遵循以下原则：在产品管理上为开发团队预留20%的自主时间，让他们自由支配。开发团队可以利用这些时间重写代码、完善架构、重构代码库中有缺陷的部分，或者更换数据库管理系统，提高系统性能，避免“需要停下来重写代码”的情形发生。</p>
<p>如果你的糟糕处境已经初现端倪，就应该拿出至少20%的资源进行调整。我担心有些团队连20%都不愿意拿出来。如果你已经身陷重写代码的困境，说明公司危在旦夕，这里给出一点建议供你参考。</p>
<p>第一，针对开发团队确定的产品修改目标制订切实可行的计划和时间表。通常，有经验的开发团队估计的开发时间八九不离十，但是重写代码是例外，因为多数团队没有重写代码的实际经验，估计往往过于乐观。你必须审时度势，仔细检查每处细节，确保计划切实可行。</p>
<p>第二，只要有可能，最好把重写目标分成几大块，实现递增修改，让用户感受到产品的改进，哪怕会因此把九个月的工作时间延长至两年，也一定要采用这种方式。重写代码时，保证让用户看到功能的改进——即使会占用少则25%，多则50%的开发资源——对保持产品（尤其是互联网产品）的市场占有率至关重要。</p>
<p>第三，由于开发用户可见功能的资源有限，必须谨慎选择正确的产品特性，确保产品定义的正确性。</p>
<h2 id="u62DB_u8058_u4EA7_u54C1_u7ECF_u7406"><a href="#u62DB_u8058_u4EA7_u54C1_u7ECF_u7406" class="headerlink" title="招聘产品经理"></a>招聘产品经理</h2><p><strong>个人素质和态度</strong></p>
<p>技术可以学习，素质却难以培养，有些素质是成功的产品经理必不可少的。</p>
<p><strong>对产品的热情</strong></p>
<p>有这样一群人，他们对产品有一种本能的热爱，把自己生活中的一切事物都看成产品，怀揣对优秀的产品的热爱和尊重。这份热情是产品经理必备的素质，是他们夜以继日克服困难、完善产品的动力。这份热情能感染团队成员，激励所有人。</p>
<p><strong>用户立场</strong></p>
<p>理想的产品经理不一定来自产品的目标市场（这种情况有利也有弊），但是他必须融入目标市场。这一特质对制造大众产品的高科技企业尤为难得。我们倾向于从自己的角度去理解用户和市场。事实上，目标用户的经验、喜好、价值观、知觉能力、忍受程度、技术理解很可能与我们的大相径庭。</p>
<p><strong>智力</strong></p>
<p>人的智力水平是无法替换的。产品管理需要洞察力和判断力，因此必须具备敏锐的头脑。勤奋当然是必需的，但从事这项工作光有勤奋还远远不够。</p>
<p><strong>职业操守</strong></p>
<p>每种团队角色承担的义务和付出的努力都不相同。产品经理肩负着产品的前途和命运，绝不适合贪图安逸的人担任。即便掌握了时间管理和产品管理的技巧，产品经理依然要为产品投入大量精力。成功的产品经理能拥有时间享受清闲的家庭生活吗？只要具备足够的经验，我相信可以做到。但是，如果你期望的是一周只工作四十个小时，下班后把工作抛诸脑后，那是不现实的。</p>
<p><strong>正直</strong></p>
<p>在所有产品团队成员里，产品经理最能体现公司和产品的价值观。通常产品经理不直接管理团队成员，不能要求别人执行命令，所以他必须通过行动影响、说服身边的同事。这种影响基于相互的信任和尊重，要求产品经理必须是个正直的人。</p>
<p><strong>信心</strong></p>
<p>很多人相信经验可以让人产生自信。如果仅凭经验可以建立信心，为什么许多工作多年的产品经理却毫无自信？相反，刚刚步入社会的大学毕业生却往往充满自信（虽然这种自信通常源自对自身状况的无知）。 自信是很重要的素质。公司高管、产品团队、销售团队都需要看到产品经理的信心，确信他们投入的时间、金钱、努力不会付之东流。自信的人更有说服力，更容易成为人们愿意追随的领导者。</p>
<p><strong>态度</strong></p>
<p>称职的产品经理把自己当成产品的CEO，愿意为产品的最终成败承担全部责任，绝不找借口。虽然他清楚产品按时成功上市要克服许多困难——开发难度大、开发时间长、成本过高、产品复杂等，但他明白预见和解决这些问题是他的责任。</p>
<p><strong>技能</strong></p>
<p>掌握一些重要的技能是打造成功产品的关键。我相信，只要具备优秀的个人素质，所有技能都可以习得。</p>
<p><strong>运用技术的能力</strong></p>
<p>很多成功的产品经理是工程师出身，因为策划产品在很大程度上取决于对新技术的理解，以及如何应用技术解决相关的问题。出色的产品经理并不需要自己发明或实现新技术，但必须有能力理解技术，发掘技术的应用潜力。</p>
<p><strong>注意力</strong></p>
<p>产品经理要优先解决重要问题。研发产品的过程中有很多干扰。能否集中注意力解决关键问题、克制不断增加功能的冲动、不受关键人物或重要客户的影响，取决于产品经理是否有足够强的自律性——不但要遵守公司制度，还要严格要求自己。</p>
<p><strong>时间管理</strong></p>
<p>电子邮件、即时消息和手机构成的世界充满了干扰。你可能一大早就来上班，拼命工作一整天，连吃饭喝水都顾不上，深夜回到家却发现到头来没完成一件重要工作。时间都用来“救火”和处理“紧急”事件了。熟练、迅速地区分重要任务和紧急任务，合理地规划和安排时间是产品经理必备的技能。如果产品经理无法集中精力完成真正重要的任务，那产品就难免命运多舛了。</p>
<p><strong>沟通技能</strong></p>
<p>虽然沟通技巧可以学习，但要做到出类拔萃需要经年累月的练习。沟通（包括口头表达和书面表达）能力是产品经理必备的技能，如前所述，产品经理只能以理服人，绝不能靠职位压制他人。口头表达能力可以在面试中测试，测试书面表达能力则需另寻他法。我常建议应聘者随身携带文字材料证明其书面表达能力，比如，不涉及专利的产品策划文档。</p>
<p><strong>商业技能</strong></p>
<p>作为产品团队的发言人，产品经理要协调团队与财务部门、营销部门、销售团队、公司高管之间的工作——必须使用这些人听得懂的概念和术语。 我认为产品经理应该具备双语技能。这并非指中文和英文，而是指产品经理既能与程序员讨论技术，又能与管理层和营销人员讨论成本结构、边际效应、市场份额、产品定位和品牌。</p>
<p>技术发展很快，所以产品经理必须善于快速学习新技术，解决新问题。我面试应聘者时，不关心他们已掌握的知识，只看重他们的学习思路。比如，让他们回忆研发产品之前，他们需要学习哪些知识，需要多长时间学习，如何利用这些知识。</p>
<h2 id="u5DF4_u987F_u5C06_u519B_u7684_u5FE0_u544A"><a href="#u5DF4_u987F_u5C06_u519B_u7684_u5FE0_u544A" class="headerlink" title="巴顿将军的忠告"></a>巴顿将军的忠告</h2><p>永远不要告诉别人怎么做。告诉他们做什么，他们自然会发挥天赋，给你惊喜。 ——乔治·史密斯·巴顿</p>
<p>优秀的用户体验设计师，特别是交互设计师可谓凤毛麟角。如果你发现了这样的人选，就一定要给予足够的创作空间，充分发挥其才能，使设计师成为产品团队的重要组成部分，让他们探索各种设计方案，倾听他们分析用户的行为和喜好。</p>
<p>总之，你留给用户体验设计师和开发人员的空间越大，他们就越有可能打造出用户喜爱的产品。</p>
<h2 id="u4EA7_u54C1_u526F_u7ECF_u7406"><a href="#u4EA7_u54C1_u526F_u7ECF_u7406" class="headerlink" title="产品副经理"></a>产品副经理</h2><p>我有一点工作体会，做产品要找公司最聪明的人合作。我发现每个公司都有几个聪明绝顶的人，这些人是公司的潜在资源，关键看你能不能发现他们。如果有幸能找到他们，就应该不拘一格地任用。我把这些人看做产品副经理，甚至公开授予他们头衔，把他们招进产品团队。</p>
<p>产品经理还可以向自己的领导借力，听取他们对产品的建议，虽然他们不太可能参与具体工作，但并不表示他们会袖手旁观。你需要的帮手可能隐身于公司各处——开发部门、销售部门、客户服务部门，甚至董事会。如何发现他们呢？</p>
<ol>
<li>打听！多问问同事，肯定会有收获。</li>
<li>采用走动式管理模式。这源于惠普的做法。管理者要走出自己的办公室和圈子，花时间与员工相处。</li>
<li>认真倾听与会者的对话与发言。</li>
<li>敞开办公室的门，让大家知道你随时欢迎他们向你提出产品建议。</li>
<li>坦率地把你的烦恼告诉同事，大家会热情地帮助你。</li>
<li>一起泡吧。工作之余，产品经理总是与产品经理一起消遣，高管总是与高管为伍，这是司空见惯的事。如果你能抽出时间与普通员工一起休息、娱乐，一定能发现“埋在沙里的金子”。</li>
</ol>
<h2 id="u7BA1_u7406_u4E0A_u53F8"><a href="#u7BA1_u7406_u4E0A_u53F8" class="headerlink" title="管理上司"></a>管理上司</h2><p>下面我介绍管理上司的十条经验。</p>
<ol>
<li>为项目波动做好准备 我用项目波动代指让你心烦意乱的各种返工、计划变更。不要企图消灭项目波动，但是可以尽量降低其负面影响。方法是提高警惕，记录工作进度，比如，记录每周、每月、每季度有多少时间项目在往前推进，掌握项目波动的规律，寻找对策。制订项目计划时，预留出时间应对变化和调整，做好“做无用功”的心理准备。这个方法不仅能缓解压力，提高计划的准确度，还有助于挖掘有待改善的细节。</li>
<li>注意沟通的方式与频率 千人千面，管理者也不例外的。有些管理者喜欢事无巨细亲力亲为；有些则希望尽量不被打扰。有些喜欢你用邮件介绍工作进展；有些则喜欢简短的口头汇报。弄清上司的喜好，对症下药。</li>
<li>会前沟通很多公司频繁开会。公司的高管、股东越多，汇报进度和评估工作的会议就越多。为了让大家了解进展，必须确保人人到场。组织好会议的诀窍是在正式会议召开前充分沟通，即在会前逐一会见与会的高管和股东，提出你的观点，征询他们的意见，确保会议召开前你们已经达成一致意见。如果会前沟通顺利，可以大大缩短正式会议的时间，结果也将毫无悬念。正式会议的作用只是让与会人员认识到大家取得了一致意见。</li>
<li>多提建议，少谈问题 管理者希望听到解决问题的方法，而不是听你报怨。最好根据问题的重要性列举出多种解决方案，并附上你的依据和建议。</li>
<li>向上司借力 许多员工不懂得向上司借力。假如你通过分析得出了解决方案，公司高管没有时间与你进行会前沟通，但你的上司能找到机会与他们交流，你可以把想法告诉上司，请他帮你转达建议。上司也想尽早结束会议，因而会乐于帮你。</li>
<li>充分准备 管理者通常聪明过人，能够立马发现你思路和计划上的漏洞。你最好准备充分，弄清问题所在，做到有备无患。</li>
<li>缩短邮件篇幅 产品经理喜欢写长篇的邮件向上司汇报工作，这是大忌。上司每天可能会收到上百封邮件，他更希望用简明扼要的方式进行交流。收件人的级别越高，邮件的篇幅就该越短。你可以添加附件，但不要让正文篇幅过长。</li>
<li>多用数据和事实说话 与上司（尤其是高管）打交道时，务必要提供数据和事实。网景公司前CEO吉姆·巴克斯德尔（Jim Barksdale）说过一句名言：如果我们依照个人看法来做决定，那就是臆断。多做准备工作，收集事实和数据，你的建议才有说服力。</li>
<li>内部宣传 向公司同事宣传产品，让大家认可你的工作，乐于帮助你。充分、有效的宣传，可以大大降低与其他部门合作的成本。</li>
<li>做让领导省心的员工 管理者的工作是保证团队高效运作，他们时间有限。不要劳烦你的上司做你的导师，但可以在你的直接管理层外另寻导师。思考如何节省上司的时间，你会获益匪浅。</li>
</ol>
<h2 id="u8BC4_u4F30_u4EA7_u54C1_u673A_u4F1A"><a href="#u8BC4_u4F30_u4EA7_u54C1_u673A_u4F1A" class="headerlink" title="评估产品机会"></a>评估产品机会</h2><p>市场给予新产品诸多机会，即使成熟的市场也不例外。因为市场环境充满变数：竞争对手不断被淘汰，新技术、新创意不断涌现……产品经理必须用他灵敏的“嗅觉”，从纷至沓来的机遇中迅速评估、挑选出有市场潜力、可行的创意，过滤那些没有价值或时机尚不成熟的点子。</p>
<p>为了评估产品机会，我要求产品经理回答如下十个问题。</p>
<ol>
<li>产品要解决什么问题？（产品价值）</li>
<li>为谁解决这个问题？（目标市场）</li>
<li>成功的机会有多大？（市场规模）</li>
<li>怎样判断产品成功与否？（度量指标或收益指标）</li>
<li>有哪些同类产品？（竞争格局）</li>
<li>为什么我们最适合做这个产品？（竞争优势）</li>
<li>时机合适吗？（市场时机）</li>
<li>如何把产品推向市场？（营销组合策略）</li>
<li>成功的必要条件是什么？（解决方案要满足的条件）</li>
<li>根据以上问题，给出评估结论。（继续或放弃）</li>
</ol>
<p>开发新产品能为老用户提供更多选择，还能吸纳新用户；改善原有产品能提高老用户的满意度，也能吸纳新用户。两者各有千秋。</p>
<h2 id="u4EA7_u54C1_u63A2_u7D22"><a href="#u4EA7_u54C1_u63A2_u7D22" class="headerlink" title="产品探索"></a>产品探索</h2><p>管理层坚持给产品探索设定期限，主要有如下原因。</p>
<ol>
<li>探索产品的过程不可预测。管理层担心花几个月研究解决方案，最后却做不出产品，而如果按计划进入开发阶段，至少有事可做。</li>
<li>开发人员是紧缺资源，开发团队无事可做会让管理层抓狂。问题是，这反而导致开发资源被浪费。 不管大家意识到没有，所有的公司都会执行探索产品的流程，只不过有些公司不是利用产品原型完成这项工作，而是孤注一掷，用实际产品搭上全部开发时间进行产品探索。他们开发的是一款非常昂贵的原型，让不知情的用户掏钱参与原型测试。这些公司需要一两年时间（发布几个版本）才能赢利。</li>
</ol>
<h2 id="u4EA7_u54C1_u539F_u5219"><a href="#u4EA7_u54C1_u539F_u5219" class="headerlink" title="产品原则"></a>产品原则</h2><p>产品原则是对团队信仰和价值观的总结，用来指导产品团队作出正确的决策和取舍。它体现了产品团队的目标和愿景，是产品战略的重要组成部分。从形式上看，它是一系列明确的、体现团队特色的产品价值准则。</p>
<p>每次加入新团队，我要做的第一件事就是制定产品原则。制定产品原则意味着决定什么重要、什么不重要，哪些原则是根本的、战略性的，哪些是临时的、战术性的。产品原则不是产品功能的清单，不依赖于任何单独的产品，它是整个产品线的战略指南，是公司的价值宣言。好的产品原则甚至可以激发设计产品的灵感。制定产品原则的过程也是学习的过程，我可以从中了解新公司的企业文化，以及公司创始人设立的企业目标。产品原则是一套价值判断的框架，帮助公司作出正确的决策。</p>
<p>制定产品原则时容易出现两类错误。第一类是原则过于空泛，失去了指导作用。第二类是把设计原则误当成产品原则，比如，为用户提供清晰的导航路径（方便用户完成下一步操作）属于常见的设计原则，不是产品原则。</p>
<p>不少产品经理向我抱怨说，他们受够了没完没了的会议（既无议程也无结果），以及会议中的那些争论、冲突。公司高管还时不时打断会议进程，扔下没头没脑的意见，然后拂袖而去，留下他们丈二和尚摸不着头脑。 这种情况在产品决策过程中经常发生，原因主要有以下几点：第一，每位同事对公司的产品都有自己的看法；第二，大家都非常在乎产品，明白公司营利得靠用户，只有产品才能吸引用户；第三，许多人以为自己比其他人了解目标用户，事实上并非如此。</p>
<p>务必认真分析产品目标的优先级（从最重要到最不重要逐项排序），让团队达成共识。切不可囫囵吞枣地把所有目标都贴上“关键”和“重要”的标签。一定要区分什么最重要，什么第二重要…… 我常被请去解决产品决策中出现的争议，我发现，多数团队跳过了这关键的一步。由于缺少基本评估标准，每个人对目标和优先级的理解都不同，大家往往情绪激动，在细枝末节上争执不下。</p>
<p>即使大家已经达成共识，也应该在讨论开始前再次予以强调，最好把目标按优先级顺序写在白板上，这样每位同事都可以看到评估方案和制定决策的确切依据。制定决策的过程和依据必须完全透明，不要让人觉得你只凭直觉判断。务必告诉大家决策的依据和理由，清楚地展示每一个决策环节。激烈的会议争论会影响大伙的斗志和工作效率。如果再出现这种情况，请先回顾产品目标和目标优先级，确保大家达成共识。</p>
<h2 id="u4EA7_u54C1_u8BC4_u5BA1_u56E2"><a href="#u4EA7_u54C1_u8BC4_u5BA1_u56E2" class="headerlink" title="产品评审团"></a>产品评审团</h2><p>产品评审团并不是设计和开发产品的团队，它的职责是监督产品研发流程，制定关键决策。 它根据研发产品的四个里程碑来评审产品，制定决策。</p>
<ol>
<li>评审产品战略和产品路线图，启动评估产品机会的工作，即选择值得投入精力的产品，请产品经理开始评估产品机会。</li>
<li>根据评估产品机会的结果，决定是否开始定义产品的解决方案。</li>
<li>评审产品原型、用户测试结果、成本估算明细，决定是否开始开发产品。</li>
<li>评审最终产品、产品品质、发布计划、社会效应，决定是否发布产品。</li>
</ol>
<h2 id="u7279_u7EA6_u7528_u6237"><a href="#u7279_u7EA6_u7528_u6237" class="headerlink" title="特约用户"></a>特约用户</h2><p>组织特约用户的注意事项</p>
<ol>
<li>不要向特约用户收取参与费用，否则合作关系将会变味。产品经理需要的是开发产品的伙伴，不要变成为特约用户开发产品。如果特约用户愿意，你尽可以等正式产品发布后再向他们收取费用。</li>
<li>由于可以免费试用产品，通常会有大量的申请者申请成为特约用户。公司的销售部门为了提高业绩，可能会要求产品经理招募更多的用户。这会消耗产品经理大量的精力，而且这些用户不一定符合要求。为了满足大批心急的用户，公司可以发布预览版产品。特约用户的人数绝不能超过十个，否则产品经理不可能有时间和精力与每位用户深入沟通。</li>
<li>如果在寻找特约用户时遇到困难，很可能是因为产品要解决的问题不像产品经理想象的那么重要，将来也很难销售出去。这可以初步验证产品创意是否有价值。出现这种情况，产品经理应该重新考虑产品计划。</li>
<li>产品经理需要确保特约用户是产品的潜在目标用户。我们很容易把产品尝鲜者（early adopter）误当成特约用户。产品尝鲜者常常能容忍产品的不足和缺陷，根据他们的建议研发的产品，很可能只适合他们自己，无法满足大众的需求（参见第35章）。</li>
<li>产品经理务必向特约用户说明，我们要开发的是面向大众的通用产品，不是为某家公司开发的定制产品。特约用户也不希望出现这种情况，因为小众产品的生命周期比较短，一旦产品被淘汰，售后服务也将被取消。产品经理应该向特约用户承诺产品不会昙花一现。</li>
<li>产品经理应该把特约用户当成开发伙伴对待，视他们为同事，互相帮助。许多特约用户和我结下了深厚持久的友谊。</li>
<li>产品经理与特约用户的合作贯穿产品研发的每个环节：向他们展示产品原型，请他们参加测试，向他们请教产品的细节问题，让他们帮你部署、测试待发布产品的备选版本。</li>
<li>正式产品发布之前，一定要先请特约用户试用，确保每个人都满意，一旦发布，他们会坚定不移地向大众推荐产品。</li>
<li>产品经理还要和产品营销团队紧密合作。一方面，营销团队可以帮助你物色特约用户；另一方面，他们可以协助你提高特约用户受关注的程度。</li>
<li>如果是平台产品，特约用户的作用就更突出了，只不过六个特约用户要换成六个应用。产品经理要与特约应用的开发者紧密合作，确保在平台上构建的应用让用户感到满意，最好鼓励应用开发者发展自<br>己的特约用户。</li>
</ol>
<h2 id="u5E02_u573A_u8C03_u7814"><a href="#u5E02_u573A_u8C03_u7814" class="headerlink" title="市场调研"></a>市场调研</h2><p><strong>用户调查</strong></p>
<p>网络降低了用户调查的难度，提高了调查的效率，以至于现在几乎所有产品都要求做用户调查。做用户调查要注意两点。第一，设计调查问卷需要技巧和经验，不是一件容易的事。要结合具体情景，仔细设置问题，如果调查问卷措辞不清、先入为主，其他部门的同事就会质疑调查结果。第二，调查结果为获得解决方案提供了一条途径，但不是解决方案本身。哪怕所有用户都回答喜欢X特性，我们还是可以通过提供Y特性更实际地解决他们的需求。</p>
<p><strong>产品使用分析</strong></p>
<p>如果你的产品是网站，有很多实用的工具可以分析用户访问网站的行为。这些工具正确安装和配置后即可使用，非常划算。越早使用分析工具越好，不断地观察学习，然后调整产品。如果你的产品不是网站，可以在产品中添加分析工具，记录用户使用产品的行为。应该明确告知用户分析工具的用途，声明只收集统计数据，不涉及用户隐私。这样做虽然麻烦，但很值得。</p>
<p><strong>数据挖掘</strong></p>
<p>收集数据的渠道很多，除了上面提到的产品使用分析，还有用户的账单和账户信息、产品数据等。新的数据分析工具的功能越来越强。想知道同时使用几项服务的用户性别比例？想知道特定人物角色的活跃程度和分布情况？新的数据分析工具可以轻松回答这类问题。</p>
<p><strong>拜访用户</strong></p>
<p>没有一种方法可以替代前往用户使用产品的场所（家、办公室）实地考察的作用。虽然拜访用户成本高、耗时长，但我每次都能收集到从其他途径无法了解的信息。拜访用户很有效，但出于对资金和时间成本的考虑，建议谨慎使用。</p>
<p><strong>人物角色</strong></p>
<p>我喜欢在定义和设计产品的过程中使用人物角色。市场调研也可以借助人物角色展开。请记住，你要面对的绝不是单一类型的用户，务必找出若干主要用户类型，深入了解他们，弄清哪些是当前的用户，哪些是潜在的用户。具体内容请参考第17章。</p>
<p><strong>可用性测试</strong></p>
<p>我主张尽早、反复地进行可用性测试（请参考第22章）。观察用户使用现有产品的反应，收集反馈意见，了解他们的真实想法。从用户的视角重新审视产品，不光阅读反馈信息，更要观察、记录用户的行为和反应（比如兴奋、沮丧）。现在还有工具带有远程功能，可以在异地进行可用性测试，记录、分析用户行为。</p>
<p><strong>同类产品分析</strong></p>
<p>产品团队常常低估了竞争对手。就我的经验而言，每款产品都有做得好的地方。有必要找出竞争对手的优势，学习对手的成功经验。</p>
<p>合理地利用市场调研工具和方法可以回答以下几个关键问题。</p>
<ol>
<li>谁是目标用户？</li>
<li>用户会怎样使用产品？</li>
<li>用户能想明白怎样使用产品吗？障碍在哪里？</li>
<li>用户为什么选用你的产品？</li>
<li>用户喜欢产品的哪些特点？</li>
<li>用户希望如何改进产品，增加哪些功能</li>
</ol>
<p>探索（定义）产品的过程则要回答如下问题。</p>
<ol>
<li>采用什么技术来更好地解决产品要解决的问题？</li>
<li>设计什么样的用户体验？</li>
</ol>
<h2 id="u4EA7_u54C1_u4EBA_u7269_u89D2_u8272"><a href="#u4EA7_u54C1_u4EBA_u7269_u89D2_u8272" class="headerlink" title="产品人物角色"></a>产品人物角色</h2><p>作为产品管理的工具，人物角色的主要用途如下。</p>
<ol>
<li>人物角色可以用来筛选重要的产品功能。假设目标用户是“玛丽”，就该添加对“玛丽”重要的功能；如果某项功能只是针对“山姆”的，就该被淘汰。人物角色既有助于决定谁是目标用户，也有助于决定谁不是目标用户，两者同样重要。面面倶到的产品往往一无是处，使用人物角色可以避免犯这种错误。</li>
<li>产品团队常常把自己的需求当成用户需求，我在别处讨论过这个问题，使用人物角色可以避免犯这类的错误。</li>
<li>许多产品的用户类型不止一种。如果只是简单地针对每种用户添加功能，结果会是一团乱麻。这主要是设计上的问题，使用人物角色有助于对用户类型的优先级进行排序，识别需要重点考虑用户体验的地方。</li>
<li>有了人物角色，可以方便地向团队描述产品的目标用户是谁，他们怎样使用产品，他们关心产品的哪些方面。</li>
<li>和产品原则一样，人物角色可以帮助团队成员达成共识。产品发布之前有数以千计的细节问题要解决，产品经理和设计师不可能事必躬亲。如果产品经理、设计师、文案创作人员、开发人员、测试人员在产品原则和人物角色上达成共识，解决问题的效率会更高。</li>
</ol>
<h2 id="u91CD_u65B0_u5B9A_u4E49_u4EA7_u54C1_u8BF4_u660E_u6587_u6863"><a href="#u91CD_u65B0_u5B9A_u4E49_u4EA7_u54C1_u8BF4_u660E_u6587_u6863" class="headerlink" title="重新定义产品说明文档"></a>重新定义产品说明文档</h2><p>我认为理想的产品说明文档应该满足以下要求。</p>
<ol>
<li>产品说明文档应该完整地描述用户体验——不只是用户需求，还包括交互设计和视觉设计。希望大家已经明白用户需求和用户体验是密不可分的。</li>
<li>产品说明文档必须准确地描述软件的行为。文字和图片的表达能力实在有限，不足以完成这项任务。</li>
<li>产品说明文档的受众较广——开发人员、测试人员、客服人员、市场营销人员、运维人员、销售人员、管理层等等。因此，产品说明文档必须以某种直观的方式把产品信息和产品行为告诉所有人。</li>
<li>产品说明文档应该可以修改。虽然进入开发阶段后，应该尽量避免修改产品说明文档，但总有意想不到的问题出现，需要修改产品说明文档以适应新情况。</li>
<li>撰写产品说明文档的过程中会出现许多衍生物，比如，按优先级排列的需求列表、线框图、实体模型，但应该有一个主体来代表产品，避免混淆不清，版本错乱。在我看来，只有一种形式的产品说明文档可以满足以上所有要求，那就是高保真产品原型。</li>
</ol>
<h2 id="u7528_u6237_u4F53_u9A8C_u8BBE_u8BA1_u4E0E_u5B9E_u73B0"><a href="#u7528_u6237_u4F53_u9A8C_u8BBE_u8BA1_u4E0E_u5B9E_u73B0" class="headerlink" title="用户体验设计与实现"></a>用户体验设计与实现</h2><p>许多团队把用户体验设计和软件开发放在一起进行，这是行不通的。原因如下。</p>
<ol>
<li>与软件开发团队合作的人要记住一点：一旦产品进入开发阶段，再修改设计思路是非常困难的，而且越往后修改的成本越高。因为开发团队必须根据确定的用户需求和产品定义设计软件架构，然后进行开发。前期架构决策极大地制约着后期的开发工作，事后修改软件架构，无异于推翻重来。另外，从心理上说，事后修改设计会打击开发人员的斗志，引发消极的心态。随着时间一分一秒过去，返工和波动会增加团队的压力。尽管敏捷方法提倡不断修改和完善，但并非所有的修改都受欢迎。</li>
<li>用户体验设计要保证产品同时具备可用性和价值，任务很重。为了拿出既可用又具有价值的设计，必须尽早、反复地验证设计思路。有些人觉得可以等到每个迭代周期结束再观察设计思路是否合适，甚至等到产品公开测试时再收集用户反馈，这样低效的验证方法肯定是行不通的。优秀的用户体验设<br>计师一两天内要尝试几十个点子，哪怕只是2～4周的迭代周期都会慢得让人无法忍受。</li>
<li>我认为验证设计思路必须使用高保真原型。有人说，迭代结果和公开测试的产品可以当做原型。抛开要等很长时间不谈，这些开发中的产品与产品原型有很大的区别，不能混用。为了验证各种设计思路，产品原型应该可以随意修改，完成其任务后应该被丢弃。而开发中的产品应该以固定的原型为基础。</li>
<li>尽管产品开发可以分成多次迭代（这样做可以降低风险，提高质量，便于产品集成），用户体验设计却不能拆分。设计师必须全面地、连贯地看待用户体验，考虑以往用户的使用习惯。让用户放弃不可用的软件很容易，要他们放弃使用习惯却很难。</li>
<li>用户体验设计不一定是最费时间的工作（像软件开发一样，所需时间取决于具体的方法、特定的产品需求，以及从业者的技能和经验），但至少需要一两周时间。</li>
</ol>
<p>只有在开发人员要开发大量后台基础软件的情况下，用户体验设计和软件开发才能并行展开。在这种情况下，开发团队可以利用设计师设计产品的时间完成这部分工作。虽然双方的工作会有一些依赖关系，但可以解决。多给设计师一些时间定义详细的待开发任务。</p>
<h2 id="u57FA_u672C_u4EA7_u54C1"><a href="#u57FA_u672C_u4EA7_u54C1" class="headerlink" title="基本产品"></a>基本产品</h2><p>我号召产品团队放弃老式的产品设计方式。比如，不再试图定义最终产品，转而定义只满足基本要求（价值、可用性、可行性）的产品，简称基本产品。一旦基本产品定义完成，通过了用户测试，它就是一个不可分割的整体，去掉任何元素，都不可能获得预期的效果。</p>
<h2 id="u4EA7_u54C1_u9A8C_u8BC1"><a href="#u4EA7_u54C1_u9A8C_u8BC1" class="headerlink" title="产品验证"></a>产品验证</h2><p><strong>可行性测试</strong></p>
<p>首先要明确在现有的技术条件下，能否成功开发出产品。邀请架构师和开发人员深度参与技术调研，寻找可行的方案。有些方案通向死胡同，但总有些是可行的。重点是让开发人员寻找产品设计里那些难以克服的障碍，现在发现远比损失了时间和资金后发现来得好。有些产品的技术风险较大，如果你的产品存在可行性风险，一定要提前解决这些问题。</p>
<p><strong>可用性测试</strong></p>
<p>交互设计师应该与产品经理密切合作，想方设法突出产品的功能特性，让不同类型的用户都能明白如何使用。可用性测试往往能发现没能成功实现的产品需求，如果测试得当的话，甚至能发现原本被忽略的产品需求。最好规划多次迭代测试，确保实现最佳的用户体验效果。一定要请真实的用户来试用可用性原型，从目标用户那里可以得到宝贵的反馈信息。虽然产品经理和设计师也能从设计和使用原型的过程中掌握大量信息，但这些都不能代替让真实用户体验原型的作用。</p>
<p>请注意，为了测试可用性，即使要模拟复杂的后台处理过程也是值得的，关键是要评估用户体验的实际效果。</p>
<p><strong>价值测试</strong></p>
<p>最后，仅仅知道产品能够开发出来、方便使用，这还不够。同样要紧的是知道用户是否觉得你的产品有用，是否愿意购买，有多喜欢产品的设计。价值测试可以和可用性测试同时进行，使用的原型也是一样的。只不过可用性测试重在观察用户如何设法完成必要的操作，而价值测试重在观察用户是否喜欢这些功能，是否满意功能的具体实现方式。</p>
<p>简单的产品也许在纸上画画原型就够了，但对于大多数采用复杂用户界面、运用新技术的产品来说，必须借助产品原型评估设计是否符合要求。不同的产品有不同的原型，比如，常见的原型是可点击的页面，当然，原型也可能是物理设备，或是软件与硬件的结合。无论哪种形式的原型都必须足够真实（高保真），可以提供给目标用户测试，并获取有效的用户反馈信息。</p>
<p>使用原型并非验证产品（尤其是互联网服务）的唯一方式，还有其他简单有效的方法，但它们都强调在正式开发软件前验证产品设计，因为设计总有考虑不周、出人意料的情况。越早发现问题越好，不要等到产品公开测试，甚至正式发布才醒悟。一旦进入开发阶段，修改产品设计的难度和成本会越来越高。</p>
<h2 id="u6539_u8FDB_u73B0_u6709_u4EA7_u54C1"><a href="#u6539_u8FDB_u73B0_u6709_u4EA7_u54C1" class="headerlink" title="改进现有产品"></a>改进现有产品</h2><p>产品经理应该时刻关注这些指标，与交互设计师、用户研究人员、主程序员密切合作，分析改善产品的可能性。想要进一步了解产品情况，还可以进行网站分析，请用户测试产品，向客服人员、销售人员了解情况，做盈亏分析，估算净推荐值。在互联网服务领域，可以获得几乎实时的数据反馈。通过分析这些数据改进产品，往往能收到事半功倍的效果。</p>
<p>记住，改进产品不是简单地满足个别用户的要求，也不能对用户调查的结果照单全收。能提高指标的功能才是你关注的重点。你应该找准方向，分析关键指标，有针对性地改进产品。</p>
<h2 id="u5E73_u6ED1_u90E8_u7F72"><a href="#u5E73_u6ED1_u90E8_u7F72" class="headerlink" title="平滑部署"></a>平滑部署</h2><p>毫无征兆地更新不必要的版本会令用户产生反感。有件事你可能觉得难以置信，但的确是事实：不是所有用户都喜欢新版本的产品。用户产生反感主要有以下几个原因。</p>
<ol>
<li>事前没有收到更新通知，用户觉得措手不及。</li>
<li>用户没时间学习、适应新版本，产品公司也没有提供旧版本方便用户在过渡阶段使用。</li>
<li>新版本无法正常运行。</li>
<li>新旧版本不兼容（比如新版本无法访问旧版本的数据）。</li>
<li>虽然新版本可以正常运行，但用户认为添加的功能和特性毫无必要。</li>
<li>应付接二连三的版本更新，用户感到疲惫不堪。</li>
<li>新版本修改了用户已经习惯的使用方式和操作流程，用户不得不重新调整适应。通常情况下，用户不喜欢变化。虽然他们也希望产品更完善，功能更丰富，但前提是不改变已有的使用习惯，大多数人不愿意花时间学习、适应新的使用方式。</li>
</ol>
<p>为了将版本更新带来的负面影响降到最低，可以采取以下几种措施。</p>
<ol>
<li>通过公告、群发邮件、在线教程等方式提前通知用户，但是很多人既没时间也没兴趣阅读这些内容，所以这个方法效果有限。</li>
<li>加倍做好测试工作，避免新版本存在影响正常使用的隐患，比如可靠性问题、扩展性问题、性能问题。确保将来不会陷入被迫返回旧版本的窘境，为用户增加不必要的麻烦。</li>
<li>如果更新版本会影响大规模的用户，应该采取并行部署或者增量部署的方式来降低风险。平滑部署的方式很多，比如发布两个并行的版本，邀请有兴趣、有时间的用户试用新版本。如果新版本运行正常，大部分用户习惯新版本后，再将新版本设为默认版本。同时将旧版本保留一段时间，公示为旧版本提供支持的最后期限，以便没来得及习惯新版本的用户在这段时间内能照常使用产品。</li>
</ol>
<p>对于用户数量庞大的服务和产品，这个过渡可能需要几个月的时间。产品经理还要准备好承担来自开发团队和运维团队的压力，毕竟支持并行版本不是件容易的事。另一种平滑部署的方式是区域性逐步部署，首先在某个区域内部署新版本，然后逐步扩大范围。还有一种方式是增量部署，将更新项分割成几个较小的部分逐步发布。无论采用哪种处理方式，关键要全面考虑更新可能带来的“副作用”，为用户提供便利，方便他们在空闲时适应变化，同时尽可能降低新版本带来的负面影响。</p>
<h2 id="u5FEB_u901F_u54CD_u5E94_u9636_u6BB5"><a href="#u5FEB_u901F_u54CD_u5E94_u9636_u6BB5" class="headerlink" title="快速响应阶段"></a>快速响应阶段</h2><p>我反复强调发布产品不等于大获全胜，交付产品后依然需要保持高度警惕。本章详细介绍产品交付后的收尾工作。产品发布后，多数公司会迅速撤走为研发产品和发布产品整合的资源，急于投入下一个项目，殊不知此时正是收集反馈信息、改进产品的最佳时机。急于“撤军”是项目管理和产品开发流程中的大忌，只要稍微延长项目周期，观察用户对产品的反应，效果就会有天壤之别。这样做投资之小、回报之高会令你瞠目结舌，绝非其他项目阶段可比。</p>
<p>我向来坚持产品发布后的几天至一周内，所有项目成员应该留出时间作为快速响应阶段。这个阶段的主要工作是快速响应、处理产品发布后的用户反馈意见。快速响应阶段最早是针对大众网络服务的，因为大众网络服务特别重视用户的反馈意见。我相信它同样适用于平台产品、基础设施类产品、企业级产品。</p>
<h2 id="u5408_u7406_u8FD0_u7528_u654F_u6377_u65B9_u6CD5"><a href="#u5408_u7406_u8FD0_u7528_u654F_u6377_u65B9_u6CD5" class="headerlink" title="合理运用敏捷方法"></a>合理运用敏捷方法</h2><p>注意这些诀窍只适用于产品软件团队，不适用于定制软件团队。</p>
<ol>
<li>产品经理即是产品负责人（product owner），他代表了客户的需求，因而需要与产品开发团队保持密切的联系，协助督促开发进程，及时解决出现的问题。有些产品经理以为敏捷方法可以让工作变得轻松，这是大错特错的。如果产品经理和产品负责人不是由一个人担任，通常会埋下隐患（参见第2章）。</li>
<li>使用敏捷方法绝不等于省略产品规划。产品经理仍然要明白产品的方向和目标，设定衡量产品成功与否的标准。只不过在敏捷环境里，规划周期应该适度缩短，反复迭代，采用轻量级的机会评估方法替代冗长的市场需求文档（参见第11章）。</li>
<li>产品经理和设计师的工作进度应该比开发团队领先一两个迭代周期，确保你们有足够的时间攻克难题。让交互设计师和视觉设计师提前设计产品，充分发挥他们主导设计的作用，不能一边设计一边开发（参见第19章）。另外，始终让开发人员参与评估产品设计和产品原型，及时反馈关于可行性、成本、解决方案的建议。</li>
<li>尽量把产品设计工作拆分成独立的部分，分而治之，但也不能拆得太细——好比设计建筑不能一次只设计一个房间。目标是设计出符合基本要求的产品（参见第20章）。值得注意的是，在敏捷环境里，设计师必须加快工作速度，采用迅速制作原型的方法更能适应敏捷环境。</li>
<li>产品经理的主要任务是定义有价值、可用的产品原型和用户故事（user story），作为开发的基础。用产品原型和用户故事替代厚厚的产品需求文档和功能说明文档有三个优势：①可以请用户测试；②强迫产品经理全面认真地思考问题；③向开发团队明确地描述每次迭代周期需要完成的任务。请用户测试原型，根据反馈意见反复迭代修改原型设计，确保交给开发团队的是有价值的结果，避免任何浪费，哪怕只是一个迭代周期。</li>
<li>让开发人员自主划分迭代周期。有的产品功能可以在一个迭代周期完成，有的却需要好几次迭代才能完成。好的原型可以提高估算工作量和开发时间的精度。别忘了，开发团队必须考虑产品的质量、性能、扩展性，应该让他们自行决定如何划分迭代周期。</li>
<li>产品经理和交互设计师必须出席每天的晨会。晨会是一天沟通过程的开始，而不是结束，关于产品的讨论会持续一整天。设计师向开发人员和测试人员展示产品功能；开发人员互相展示完成的代码，让测试人员测试，请设计师和产品经理过目；测试人员和开发人员在制作原型的阶段识别潜在的问题，协助产品经理制定更合理的决策，解决产品设计、开发的问题。</li>
<li>除非达到了产品经理的要求，否则不要轻易发布新版本。产品经理必须确保交给用户的产品能正常运行。过度频繁更新版本会让用户感到不安（参见第24章）。</li>
<li>在每次迭代完成后，产品经理应该向团队展示产品现状，以及下次迭代的产品原型，让大家看到工作成果，同时加深大家对产品的理解，增强团队对这种开发方式的信心。</li>
<li>在团队内展开敏捷培训。聘请敏捷顾问协助你们完成向敏捷团队转型的目标，但是要确保敏捷顾问有过类似的工作经验，理解产品软件与定制软件的差别。只有每位团队成员都真正理解敏捷方法，你才能把工作重心放在执行上，否则敏捷方法就只能停留在教条式的理论层面。</li>
</ol>
<h2 id="u5408_u7406_u8FD0_u7528_u7011_u5E03_u5F0F_u5F00_u53D1_u65B9_u6CD5"><a href="#u5408_u7406_u8FD0_u7528_u7011_u5E03_u5F0F_u5F00_u53D1_u65B9_u6CD5" class="headerlink" title="合理运用瀑布式开发方法"></a>合理运用瀑布式开发方法</h2><p>瀑布式开发方法的基本原则</p>
<p>传统瀑布式开发方法的理念很简单，主要有两点。</p>
<ol>
<li>采用阶段式开发 软件开发过程被事先分成固定的几个阶段：撰写书面的需求说明文档、设计高层软件架构、设计低层细节、编写代码、测试、部署。</li>
<li>采用阶段式评审 每个阶段结束后，对该阶段提交的成果进行评审，评审通过后才能进入下一阶段。</li>
</ol>
<h2 id="u5927_u516C_u53F8_u5982_u4F55_u521B_u65B0"><a href="#u5927_u516C_u53F8_u5982_u4F55_u521B_u65B0" class="headerlink" title="大公司如何创新"></a>大公司如何创新</h2><p>臭鼬工程是工程界的行话，原指秘密军事行动，现指在受限制的条件下，利用自己的时间，低调地进行创新研究。臭鼬工程拯救了很多大公司。在大公司里，普通员工很难凭空获得允许从事创新研究。如果你能拿出阶段性的成果来，获得许可会容易得多。在这种情况下，只要不耽误本职工作，管理层通常会支持你的做法。</p>
<p>有一点要提醒大家，有些公司规定员工在职期间研究出来的成果都归公司所有，所以不要随意拿研究成果自行创业。如果公司因为某些原因不愿意帮助你，你才能尝试谋求其他途径来实现自己的创意。了解硅谷历史的人知道，当年斯蒂夫·沃兹尼亚克（Steve Wozniak）因为惠普公司不愿意进入个人电脑市场，所以离职创业，才有了后来的苹果公司。</p>
<h2 id="u5728_u5927_u516C_u53F8_u65BD_u5C55_u62F3_u811A"><a href="#u5728_u5927_u516C_u53F8_u65BD_u5C55_u62F3_u811A" class="headerlink" title="在大公司施展拳脚"></a>在大公司施展拳脚</h2><p>理解这两点后，我再介绍在大公司施展拳脚的方法。</p>
<ol>
<li>了解公司制定决策的方式 每家公司的企业文化都不相同，制定决策的方式也千差万别。如果公司制定决策的方式不符合你的习惯，不要老想着改变大家来适应自己，要学着融入其中。有些公司虽然有明确的民主决策制度，但最终决策还是要请某位大人物拍板。你千万不要纠缠大家有没有没按照制度办事，与其抱怨，不如主动利用这一点。知道决策权在谁手里，你的工作目标就更明确了。了解他制定决策的方式，他是更看重原型演示、市场数据，还是客户的承诺和评价。如果你需要公司的支持，只需要说服他就行了。</li>
<li>建立人脉网络 在大公司工作必须与人合作，如果你喜欢单枪匹马工作，创业型公司更适合你。你需要同事的协助才能完成设计、开发、发布工作。主动与各个部门的同事结交朋友，聊聊工作的事，向大家介绍你手头的项目，不要等到有事才去找人家。主动帮助他人，积累人脉关系。</li>
<li>臭鼬工程 在大公司里，凭空申请创新资源很困难（参见第29章）。想靠几张画着产品构想的幻灯片说服老板是不切实际的。更可行的方法是找三五个志趣相投的同事在工作之余做出产品原型来。产品原型具有超出想象的说服效果。比起枯燥的陈述，生动形象的演示更有吸引力。数不清的优秀产品是这样诞生的。</li>
<li>自己顶上 说出来你也许不信，大公司里虽然员工众多，但真正需要帮手的时候，却总找不到人。即使是公司高管重视的项目，也难免资源不齐。遇到这种情况，你就得自己想办法了，比如，打电话找人帮忙，甚至自己顶上。在凡事都需要提交材料，有严格流程要求的大公司，与其对抗流程，不如自己主动填写、提交需要的材料。很多时候产品经理还要协助编写技术文档，组织销售培训，提供客户服务。一切为了推出产品，不要计较个人得失。</li>
<li>有选择地据理力争 在大公司工作，多一个敌人不如多一个朋友。如果你不满意同事的工作，或者与他人意见不同，不要随便发脾气，除非这件事对你确实重要，值得你据理力争，撕破脸也在所不惜。与人辩论，要小心措辞，做到对事不对人，不要把对方逼到死角。你的目标是完成产品，别为了一场战役输掉整场战争。</li>
<li>会前沟通，形成默契 在重要的决策会议上，如果有人公开反对你的提议，你会变得非常被动。在这种公开场合下发表的意见，反对者很难改口，你想再挽回就很难了。与其临渴掘井，不如未雨绸缪，设法在会前达成一致意见。会议的主要作用是让与会者认识到大家取得了一致意见。所以会前应该逐一找与会者聊聊，了解每个人的立场，如果有不同的意见，对症下药及时化解，确保他们会投赞成票。</li>
<li>合理分配时间 大公司频繁开会，有些人每天忙于参加大大小小的会议，深夜回家还要回复邮件，忙得不可开交，产品却毫无起色。产品经理应该重新检查会议日程，划掉无关紧要的会议；学会充分信任同事，让他们自己拿主意。产品经理应该留下时间完成自己的本职工作：制定产品战略，构思产品路线图，研究产品原型，分析竞争对手。</li>
<li>分享信息 不管在哪种组织里，沟通都是难题，大公司尤其如此——信息俨然变成了某种货币，大家只想获取，不愿支出。许多人把它看成私有财产，藏起来不愿与人分享。其实有舍才有得，分享信息会让你获得更多的朋友和资源，作为交换，别人也会毫无保留地分享信息给你。充分共享信息对你自己和公司都有好处，这叫共赢。</li>
<li>向上司借力 学会利用上司的关系，可以更好地开展工作。如果你的上司在公司里威望很高，你应该学会向他借力，利用他的人脉关系，传播你的理念，多向他请教，了解公司文化和组织结构。如果需要上司出面说服公司高管，你一定要事前做好充分的准备，为他提供翔实可靠的资料和信息，用实力取得他的信任，让他放心地当你的说客。</li>
<li>传播你的产品理念 多向同事传播你的产品理念，向大家描绘产品愿景，介绍产品策略，演示产品原型，分享用户反馈信息。不要低估了内部宣传潜移黙化的作用。让大家（包括没有直接业务联系的部门同事）不遗余力地支持你。</li>
</ol>
<h2 id="u82F9_u679C_u516C_u53F8_u7ED9_u6211_u7684_u542F_u793A"><a href="#u82F9_u679C_u516C_u53F8_u7ED9_u6211_u7684_u542F_u793A" class="headerlink" title="苹果公司给我的启示"></a>苹果公司给我的启示</h2><ol>
<li>硬件为软件服务 与其他硬件公司不同，苹果公司明白硬件必须为软件服务，这种关系不能颠倒。软件直接服务用户，满足用户需求。采用多点触控显示屏、重力加速器、距离传感器这些硬件技术是为了配合软件满足用户需求，而不是花哨的噱头。苹果公司明白，仅凭华丽的硬件技术和软件效果无法真正吸引用户，一旦消费者过了尝鲜的阶段，就会对产品失去兴趣。要抓住消费者的心，需要更深层的东西。</li>
<li>软件为用户体验服务 所有公司都把用户体验挂在嘴边，只有苹果公司把它放在心里。苹果公司的所有工作都围绕着产品的可用性、交互设计、视觉设计、工业设计展开。研发一款iPhone手机要两年半时间，设计用户体验几乎占了大部分时间。设计团队明白用户体验的重要性，即使阻力重重，也不轻言放弃。公司各个部门不遗余力地支持用户体验设计。相比之下，微软就差得远了，改善Vista用户体验的工作不但效果差，而且进展缓慢。苹果公司明白用户体验是产品立足之本。</li>
<li>用户体验为情感服务 如果非要举出苹果公司成功的秘诀，我相信是这一点：他们比谁都清楚是什么让消费者为产品疯狂，他们知道怎样抓住用户的情感需求。人人都想拥有一台iPhone手机，哪怕是四百美元的天价也心甘情愿！没人把iPhone和RAZR、Treo做比较，它们完全不是一个“重量级”的。我在机场候机时，常常暗中比较人们对待苹果电脑和其他品牌电脑的态度——前者像是宝马，后者像是租来的二手车。如果你胆敢从街头少年手里抢他的iPod，那一定是吃了熊心豹子胆。</li>
<li>产品为真正的需求服务 手机并非苹果公司首创，但他们挖掘出尚未被满足的用户需求。市面上的手机品种成百上千，却没几款让人爱不释手。十几年不变的语音邮件系统、不兼容的地址簿、蹩脚的网页浏览器和电子邮箱，只会让用户抓狂。苹果公司逐一完善这些功能，成功的产品应运而生。在数码音乐播放器领域，他们做得一样出色。很少公司像苹果公司那样理解和运用以上四点。竞相模仿其产品的大有人在，这些公司不过是在照猫画虎，形似神非。</li>
</ol>
<h2 id="u65B0_u74F6_u88C5_u8001_u9152"><a href="#u65B0_u74F6_u88C5_u8001_u9152" class="headerlink" title="新瓶装老酒"></a>新瓶装老酒</h2><p>成功的产品往往不是什么新鲜事物，只是新瓶装老酒，之所以成功，是因为这个“新瓶”做得更好、更方便、更便宜，改变了消费者对“老酒”的印象。</p>
<p>想在成熟的市场抢占一席之地，精明的公司至少要手握两件“法宝”。</p>
<p>第一，对目标市场了如指掌，对现有产品的缺陷洞若观火。我喜欢通过产品可用性测试掌握产品情况（包括自己的产品和竞争对手的产品）。</p>
<p>第二，跟踪最新的技术趋势。新技术层出不穷，让之前无法实现的方案变得可能。虽然谁都没有把握永远走在技术的前列，把最新的技术融入产品设计中，但是只要做到一次，你的产品将所向披靡。</p>
<h2 id="u6050_u60E7_u3001_u8D2A_u5A6A_u3001_u6B32_u671B"><a href="#u6050_u60E7_u3001_u8D2A_u5A6A_u3001_u6B32_u671B" class="headerlink" title="恐惧、贪婪、欲望"></a>恐惧、贪婪、欲望</h2><p>多数软件产品行业的从业者都是理工科或经济学背景，我们每天的工作却和研究人类情感的心理学有关。虽然很少有人意识到这一点，但事实如此。消费者购买产品大多源于情感需求。优秀的产品经理和销售人员明白其中的道理，懂得产品应该满足用户的情感需求。</p>
<p>企业级消费者出于恐惧和贪婪购买产品：如果不买这款产品，竞争对手会超过我，黑客会攻破我的防火墙、客户将弃我而去；如果买了，我会赚得更多、省得更多</p>
<h2 id="u60C5_u611F_u63A5_u7EB3_u66F2_u7EBF"><a href="#u60C5_u611F_u63A5_u7EB3_u66F2_u7EBF" class="headerlink" title="情感接纳曲线"></a>情感接纳曲线</h2><p>杰弗里·摩尔（Geoffrey Moore）在他的作品《跨越鸿沟》中提出了一个颇具影响力的概念——技术接纳曲线，这条曲线涉及了技术创新者、尝鲜者、早期消费大众、后期消费大众和跟随者。这本书尝试解释为什么很少有产品能越过鸿沟——获得尝鲜者以外消费者的青睐。</p>
<p>不要一味从技术角度看待产品，多从用户的角度考虑问题。是什么问题让他们头痛？是什么让他们垂头丧气、愁眉苦脸？比如，如今大家都讨厌旅行——旅行的过程变得毫无乐趣可言；又比如，人人都讨厌电话公司——复杂的话费清单几乎没人能看懂。电话公司仿佛存心为难消费者，每个月月底大家都得提高警惕，免得被忽悠。</p>
<h2 id="u5927_u4F17_u7F51_u7EDC_u670D_u52A1_u4EA7_u54C1"><a href="#u5927_u4F17_u7F51_u7EDC_u670D_u52A1_u4EA7_u54C1" class="headerlink" title="大众网络服务产品"></a>大众网络服务产品</h2><ol>
<li>可用性 在我看来，多数公司不够重视产品的可用性，尤其是开发企业级软件的公司。大众网络服务产品必须具备良好的用户体验。如果用户不清楚怎样使用产品，也不知道产品的优势何在，你就等着关门歇业吧。另外，别忘了产品性能是最重要的一条可用性指标，页面加载缓慢让用户无法忍受，也是糟糕的用户体验。</li>
<li>人物角色 网站用户数量过百万后，产品经理不可能再逐个研究每位用户，只能按典型特征将用户分类，抽象出有代表性的用户类型（人物角色），加以分析。产品每增加一项新功能，都要请典型用户参与测试，根据反馈信息加以完善（参见第17章）。</li>
<li>扩展性 激增的用户数量会带来莫明其妙的问题：数据库崩溃、系统出现性能瓶颈、用户界面罢工。网站上线前进行压力测试虽然可以发现部分问题，但正式使用时总有意想不到的情况出现。实现扩展性需要产品经理、设计人员、开发人员、运维人员的通力协作，最好利用部分开发资源和运维资源（我建议分配20%的资源）专门为系统扩展做好准备。不要到系统承受不了压力，即将崩溃才追悔莫及。从设计系统的第一天开始，就应该不间断地考虑扩展性问题，永远留有余地，不到万不得已不要满负载运行（参见第5章）。</li>
<li>持续可用性 大众网络服务要求一刻也不能停歇，但迄今为止我还没见过哪家网站能做到24×7小时无故障运行。系统中止服务是件痛苦的事，对那些负责解决系统故障的人来说更是如此，不是所有人都适合干这一行。系统出故障的时间没个准，工作日、节假日、周末、深夜，随时可能发生，从业者的压力相当大。在系统设计上保证持续可用性与规划扩展性一样重要。</li>
<li>客户服务 另一件让大众网络服务公司头痛的事是客户服务。传统的客户服务完全无法应付数量庞大的网络用户，收费的网络服务情况更严重。要想降低客服压力，除了尽量减少系统故障和缺陷外别无他法。在这个问题上，节省开支只是一方面，更重要的是维持良好的用户体验。</li>
<li>保护用户隐私 大众网络服务公司容易因侵犯或泄露用户隐私被迫停业。虽然你收集用户资料的初衷可能是好的，比如提供个性化用户体验，但如今电子邮件信息、信用卡卡号等用户数据都是敏感资料，一旦不小心泄露出去，后果不堪设想——接踵而来的负面报道、法律制裁，还有用户的满腔怒火。应尽早树立保护用户隐私的意识，设置用户资料保护机制，千万不能辜负用户对你的信任。最近美国在线的案件给我们敲响了警钟，我们需要警惕，提防自己的员工泄露用户资料。</li>
<li>口碑营销 用户如果喜欢产品，就会主动向家人、朋友、同事推荐。这是宣传产品的最佳方式。令我费解的是，很少有公司充分利用这种营销手段。我建议为用户提供便利，方便他们（通过邮件、短信、社交网络等）向熟人推荐产品。许多公司愿意为吸引新用户支付报酬，不妨向踊跃推荐产品的用户发放奖金。当然奖金激励还是次要的，最重要的是让用户易于向家人、朋友、同事、网友推荐产品。</li>
<li>全球化 优秀的互联网产品很快会被其他国家、地区的用户接受，迅速在互联网覆盖的范围内传播开。易于本地化的产品设计可以大大节省开发成本和开发时间，避免为了语言、货币、文化差异大量改写程序。这样随着产品业务的拓展，你可以迅速适应当地用户的需求。</li>
<li>平滑部署 网站用户数量过百万后，任何小小的变化都会影响大面积的用户，要三思而行。我详细讲述过平滑部署的要点（参见第24章），请大家务必谨慎小心。部署前要仔细测试，逐步过渡，步幅不可过大，为用户留出足够的时间来适应变化。有些公司让新老版本同时运行一段时间，让用户适应过渡，这是个好办法。最后，尽量减少不必要的更新，用户消化、吸收新事物不是件容易的事。</li>
<li>用户社区管理 所有的商业公司都依靠用户生存，这一点对大众网络服务公司来说显得尤为突出，水能载舟亦能覆舟。如果用户认可你的产品，他们会很乐意成为用户社区的一员，同时希望得到重视和认可。与用户交流的方法有很多，多和他们接触，了解他们希望如何改进产品。多用类似于“回馈用户”的活动表达对他们的重视。让公司上下认识到用户的重要性，真正从行动上把用户当做“上帝”。</li>
</ol>
<h2 id="u6253_u9020_u5E73_u53F0_u4EA7_u54C1_u7684_u7ECF_u9A8C"><a href="#u6253_u9020_u5E73_u53F0_u4EA7_u54C1_u7684_u7ECF_u9A8C" class="headerlink" title="打造平台产品的经验"></a>打造平台产品的经验</h2><p>产品管理中难度最大，也最能体现产品经理实力的是定义成功的平台产品。所谓平台产品，是指一类基础软件，应用开发者能在其基础上开发应用程序。平台有很多种，例如，操作系统（如Window操作系统、Mac操作系统、Palm智能手机操作系统）、运行环境（如Java、Flash）、web服务（如亚马逊和eBay的集成应用程序接口）、游戏开发平台（如XNA），以及应用平台（如Facebook和Salesforce.com）。</p>
<h2 id="u6700_u4F73_u5B9E_u8DF5_u7ECF_u9A8C"><a href="#u6700_u4F73_u5B9E_u8DF5_u7ECF_u9A8C" class="headerlink" title="最佳实践经验"></a>最佳实践经验</h2><p>从业二十多年来，我一直在总结打造富有创意产品的方法。这里分享我认为最重要的十个要点。每个要点在书中都有详细描述，希望这里的汇总能加深读者的印象，建议大家结合实际工作来体会。</p>
<ol>
<li>产品管理的职责 许多产品经理将大把的时间浪费在与产品管理无关的工作上，比如，营销管理和项目管理，这些都不是产品经理应该干的活。</li>
<li>用户体验 对于大多数软件产品来说，用户体验就是产品的生命。产品经理应该与交互设计师、开发人员密切合作，设计良好的用户体验，打造有实用价值的产品。</li>
<li>机会评估 用方便快捷的机会评估方法取代过时的市场需求文档。动手设计产品前，先明确产品要解决什么问题，为谁解决问题，以及评估产品的标准。</li>
<li>特约用户 有些产品团队企图绕过用户，直接设计、开发产品，这种想法可笑至极。打造优秀的产品没有任何捷径，只能请用户反复试用产品，不断改进。</li>
<li>产品原则 产品管理工作的主要内容是制定决策。明确的产品原则可以帮助产品经理和产品团队树立清晰的价值标准，作出果断的决策。</li>
<li>人物角色 人物角色是协助产品经理制定决策的另一项工具。把目标用户按特征分类，逐一分析、理解其情感和行为，以此作为决策的依据。</li>
<li>探索（定义）产品 产品经理的主要职责是探索（定义）有价值的、可用的、可行的产品。除非产品经理确定这三点，否则同事的努力都将付之东流。</li>
<li>使用原型 使用高保真原型是探索（定义）产品的关键步骤。原因如下：第一，迫使产品经理深入定义解决方案；第二，可以让真实的用户参与测试、验证产品创意；第三，可以直观地向团队展示产品的设计思路。</li>
<li>用户参与原型测试 有了产品原型，产品经理可以方便地请用户验证产品创意。原型测试是所有产品经理和产品设计师都必须掌握的工作技能。获取有效的用户反馈是产品经理最重要的工作。</li>
<li>根据数据改进产品 成功的产品经理懂得利用数据来改进现有产品。改进产品不是根据客户要求一味增加新功能，而是根据产品的实际应用情况，不断地提升产品的各项指标，逐步完善产品。</li>
</ol>
<h2 id="u4EA7_u54C1_u7ECF_u7406_u7684_u53CD_u7701_u6E05_u5355"><a href="#u4EA7_u54C1_u7ECF_u7406_u7684_u53CD_u7701_u6E05_u5355" class="headerlink" title="产品经理的反省清单"></a>产品经理的反省清单</h2><p>出色的产品经理会时刻关注产品的现状与未来。以下是产品经理无时无刻不在思考的问题。</p>
<ol>
<li>产品能吸引目标消费者的关注吗？</li>
<li>产品的设计是否人性化，是否易于操作？</li>
<li>产品能在竞争中取胜吗？即使是面对未来风云变化的市场，依旧有取胜的把握吗？</li>
<li>我了解目标用户吗？产品（不是理想的产品，而是实际开发出来的产品）是否能得到他们的认可？</li>
<li>产品是否有别于市面上的其他产品？我能在两分钟内向公司高管清楚地阐明这些差别吗？能在一分钟内向客户解释清楚吗？能在半分钟内向经验丰富的行业分析师解释清楚吗？</li>
<li>产品能正常运行吗？</li>
<li>产品是否完整？用户对产品的印象如何？销售业绩如何？销售任务能否顺利完成？</li>
<li>产品的特色是否与目标用户的需求一致？产品特色是否鲜明？</li>
<li>产品值钱吗？值多少钱？为什么值这么多钱？用户会选择更便宜的产品吗？</li>
<li>我了解其他团队成员对产品的看法吗？他们觉得产品好在哪里？他们的看法是否与我的观点一致？为什么每天的思考时间如此重要，为什么产品经理的工作如此费时？原因就在于这十个问题等着他不断地去琢磨。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>这本书基本上说清楚了打造好产品的方方面面，很值得一看。</p>]]>
    
    </summary>
    
      <category term="产品" scheme="http://wdxtub.com/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="方法" scheme="http://wdxtub.com/tags/%E6%96%B9%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【编程珠玑】读书笔记]]></title>
    <link href="http://wdxtub.com/2016/03/26/programming-pearls/"/>
    <id>http://wdxtub.com/2016/03/26/programming-pearls/</id>
    <published>2016-03-26T20:35:57.000Z</published>
    <updated>2016-03-26T20:41:16.000Z</updated>
    <content type="html"><![CDATA[<p>编程珠玑算是比较有年头的一套程序员进阶的书籍，这里是我的读书笔记。</p>
<a id="more"></a>
<hr>
<h2 id="u5F00_u7BC7"><a href="#u5F00_u7BC7" class="headerlink" title="开篇"></a>开篇</h2><p>一开头就拿出了这么一个例子，给10000000个7位整数排序（无重复的整数），但是你可能只有1MB的主存，怎么办又快又好呢？通常的想法是归并，多几次就可以了。但是其实还有更好的方法，就是利用位图的位向量。例如如果集合是{1，2，3，5，8，13}，那么可以存储在下面这个字符串中：</p>
<pre><code>0 1 1 1 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0
</code></pre><p>集合中代表数字的各个位设置为1，而其他的位全部都设置为0。这时候如果要个这10000000个整数排序，就可以分成这三步：1）初始化一个大数组。2）遍历一遍这10000000个数，出现过的就在数组中标注为1。3）最后再遍历一遍这个数组，把出现1的对应位置的数字输出一遍即可。</p>
<p>瞬间什么排序都不用了，而且只需要两次遍历，豁然开朗，柳暗花明之感。从这个例子可以总结出一些值得以后借鉴的经验：</p>
<p><strong>正确的问题</strong>。明确了问题，就更能找到最佳的解答。</p>
<p><strong>位图数据结构</strong>。该数据结构描述了一个有限定义域内的稠密集合，其中的每一个元素最多出现一次并且没有任何其他数据与该元素相关联。即使这些条件没有完全满足(例如，存在重复元素或额外的数据)，也可以用有限定义域内的键作为一个表项更复杂的表格的索引。</p>
<p><strong>多趟算法</strong>。多趟读入其输入数据，每次完成一步。</p>
<p><strong>时间-空间折中与双赢</strong>。只有在原始的设计远非最佳方案时，才有可能时空双赢。</p>
<p><strong>简单的设计</strong>。设计者确定其设计已经达到了完美的标准不是不能再增加任何东西，而是不能再减少任何东西。</p>
<blockquote>
<p>1.如果不缺内存，如何使用一个具有库的语言来实现一种排序算法以表示和排序集合？</p>
</blockquote>
<p>python 的 list 的 sort 方法就挺好，简单粗暴</p>
<pre><code>list = [1,2,3,4,5]
list.sort()
</code></pre><blockquote>
<p>2.如何使用位逻辑运算(与，或，移位)来实现位向量？</p>
</blockquote>
<p>位向量的实现就是用比特位0,1来表示一些特定信息，通常是用数组，每个int中包含32个bits，当我们定位某个位置时，先确定索引是在哪个int中，然后再确定int中的那个位对应索引。</p>
<p>c++中有现成的 bitset，原理应该差不多</p>
<blockquote>
<p>3.实现位图排序并度量运行时间</p>
</blockquote>
<p>位图的实现我用了三种，一个是c语言的（简称cvec），一个是c++的（简称cppvec），还有时c++现成的bitset（简称bitset）。系统排序用的是sort命令，加上-n选项。排序用了c的qsort，c++的sort和c++的set。</p>
<pre><code>cvec  1.737 1.001
cppvec 1.769 1.033
bitset 2.644 1.908
系统sort命令 5.290 4.554
qsort 2.081 1.345
sort 2.802 2.066
set 5.921 5.185
</code></pre><p>输入输出的时间是0.736s。左右分别为带输入输出和不带的。</p>
<p>可以看出两种语言位图的实现都是效率最高的，c++中的bitset，set，sort虽然效率上差了点，但是实现上非常方便，而且能保证一定的正确性。系统的排序实在方便，一句命令就可以搞定(<code>sort -n &lt; in -o out</code>).</p>
<blockquote>
<p>4.如何生成小于 n 且没有重复的 k 个整数？</p>
</blockquote>
<p>如果要想生成这样一个数组，可以直接从头到尾循环，每个数随机位置交换值就可以。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N = 10000000;
const int K = 10000000;
int randint( int l, int r ){
    return rand() % ( r-l ) + l;
}
int a[ N ];
int main(void){
    for( int i = 0; i &lt; N; i++ )
        a[i] = i;
    for( int i = 0; i &lt; K; i++ ){
        swap( a[i], a[ randint(i,N) ] );
        printf(&quot;%d\n&quot;,a[i]);
    }
    return 0;
}
</code></pre><blockquote>
<p>5.如果存储[0,10000000]大概需要1.25MB，但内存限定为1MB，要如何处理呢？</p>
</blockquote>
<p>可以将输入文件分成两分，第一份保存[0,5000000)的数，第二个文件保存[5000000,10000000)的数字，然后分别进行排序，所用内存就可以降到1MB以内。如果我们把文件分成k份（每份都存一定区间的数），那么就可以在n的时间，n/k的空间内完成排序。</p>
<blockquote>
<p>6.如果每个整数不只是出现一次而是最多可能出现十次，那么要如何修改算法呢？</p>
</blockquote>
<p>每个整数最多出现10次，那么保存每个数字信息的空间不再是1bit了，可以用4bits来保存，可以类比第五题，可以分成4份，在n/4的空间内完成。同样，当保存数字信息的量变化时，分成更多份，就可以在更小的空间内完成。</p>
<blockquote>
<p>7.程序还需要进行哪些错误检测，如何处理？</p>
</blockquote>
<p><strong>数出现超过一次</strong>。当第二次更新的时候，相应位已经是1了，这个时候提示错误。</p>
<p><strong>当输入小于0或者大于等于n</strong>。当输入数字时候对其进行范围判断，忽略或者提示错误。</p>
<p><strong>不是数值</strong>。忽略，给出提示</p>
<blockquote>
<p>8.之前的电话数据区号都是800，现在免费电话的区号还包括877和888并且可能还会增多，那么如何排序呢？如何将免费电话存储在一个集合中，要求可以实现非常快速的查找来判定是否已经存在？</p>
</blockquote>
<p>一个想法是把区号作为前缀加入到每个号码后面，然后利用bitmap进行存储，又或者维护另一个区号的映射表，这样可以减少编码的长度。检索的时候就看对应值是不是为1就行。</p>
<blockquote>
<p>!!9.使用更多的空间来换取更少的运行时间存在一个问题：初始化空间本身需要消耗大量的时间。如果数据很稀疏，那么要如何存储？</p>
</blockquote>
<p>初始化空间需要大量时间，不过我们的应用只需要其中一点点空间，比如1000000的位图，我们只用到其中的10位，怎样节省时间？题目中提示，可以用额外的正比于向量大小的空间。</p>
<p>解决方法使用了两个额外的向量，<code>from</code>和<code>to</code>，变量<code>top</code>。如果对i位置进行初始化，进行以下步骤：</p>
<pre><code>from[i] = top;
to[top] = i;
data[i] = 0;
top++;
</code></pre><p><code>from[i]=top</code>的目的是将<code>i</code>在<code>to</code>中的索引放入<code>to</code>中，<code>to[top]=i</code>的意思是，这个<code>top</code>位置对应的是<code>i</code>，这时data就可以做相应的操作，然后top右移。</p>
<p>判断一个位置是否初始化过的条件是<code>from[i] &lt; top &amp;&amp; to[from[i]] == i</code>,<code>from[i]&lt;top</code>的意思是<code>from[i]</code>对应的<code>to</code>中的位置已经被处理过了，但是<code>from[i]</code>可能是随机值，也只能会小于<code>top</code>，那么这时就需要第二个条件了，<code>to[from[i]] == i</code>的意思是，<code>to[from[i]]</code> 所指向的位置就是<code>i</code>，这种双向的指向性的内容确保了能确定<code>i</code>位置是否被初始化过。</p>
<blockquote>
<p>10.如何组织电话号码以允许高效的插入和检索操作？</p>
</blockquote>
<p>类似于取快递，根据电话号码的最后一位或者最后两位进行分类，类似于哈希的思想，用顺序遍历来处理碰撞。不能用开头的原因是很多电话号码的前面都是一样的，比如手机号码都是以1开头的。而且最后一位的分布比较随机、均匀。</p>
<blockquote>
<p>11.汽车每天运送图纸需要一个小时，有什么办法可以减少时间或者费用？</p>
</blockquote>
<p>飞鸽传书，答案也是醉</p>
<blockquote>
<p>12.外太空写字的笔</p>
</blockquote>
<p>铅笔</p>
<blockquote>
<p>深入阅读</p>
</blockquote>
<p>Michael Jackson \<software requirements="" &="" specifications\=""></software></p>
<p>程序员的主要问题与其说是技术问题，还不如说是心理问题。很多时候没有办法解决问题是因为想要解决错误的问题。问题的最终解决，是通过打破概念壁垒，进而去解决一个较简单的问题而实现的。</p>
<p>James L. Adams <conceptual blockbusting=""></conceptual></p>
<h2 id="u554A_u54C8_uFF01_u7B97_u6CD5"><a href="#u554A_u54C8_uFF01_u7B97_u6CD5" class="headerlink" title="啊哈！算法"></a>啊哈！算法</h2><p>看起来很困难的问题解决起来可能很简单，并且还很可能出人意料之外。只有经过广泛的研究之后才能对算法具备那种出神入化的理解力。任何愿意在编码前、编码期间以及编码后任职思考的程序员都可具备这种能力。</p>
<p>算法与其他哪些深奥的思想一样重要，但在更一般的编程层面上具有更重要的影响</p>
<blockquote>
<p>三个问题</p>
</blockquote>
<ol>
<li>给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中的32位整数。在具有足够内存的情况下，如何解决？如果有几个外部的临时文件可用，但是只有几百字节的内存，又该如何解决？</li>
<li>将一个 n 元一维向量向左旋转 i 个位置。简单的代码使用一个 n 元的中间向量在 n 步内完成工作。你能否仅适用数十个额外字节的存储空间，在正比于 n 的时间内完成向量的旋转？</li>
<li>给定一个英语词典，找出其中的所有变位词集合，例如<code>pots</code>,<code>stop</code>,<code>tops</code>互为变位词。</li>
</ol>
<blockquote>
<p>问题 1</p>
</blockquote>
<p>采用已知包含至少一个缺失元素的一系列整数作为范围，并使用包含所有这些整数在内的文件表示这个范围，通过统计中间点之上和之下的元素来探测范围：或者上面或者下面的范围具有至多全部范围的一半元素。由于整个范围中有一个缺失元素，因此我们所需的那一半范围中必然也包含缺失的元素</p>
<p>问题是这样的，给定一个包含32位整数的顺序文件，它至多只能包含40亿个这样的整数，并且整数的次序是随机的。请查找一个此文件中不存在的32位整数。</p>
<p>这个时候二分查找法就非常有用，首先遍历一遍这40亿个数字，并分为两组，一组是左边第一位为1的，一组是左边第一位为0的，正常来说，上下应该各占据一半，但因为总范围内有遗漏元素（假设只有一个），那么比较小的那一组必包含此遗漏元素。继续在比较小的那一组使用1与0的分组，很快就可以找到这个遗漏的整数。</p>
<blockquote>
<p>问题 2</p>
</blockquote>
<p>简单的方法就不说了，另一个想法是给出了旋转的位数其实每个字母的最终位置是确定的，只需要一个临时变量，把对应的放过去即可。但是这种方法比较容易出错，不容易维护。</p>
<p>另一个方法是把问题看做数组 ab 转换成 ba。</p>
<p>ab - a’b - a’b’ - (a’b’)’ - ba</p>
<pre><code>假设原来是 abcdefgh，向左旋转 3 位
reverse(0, i-1) // cbadefgh
reverse(i, n-1) // cbahgfed
reverse(0, n-1) // defghabc
</code></pre><p>这种方法高效且简短</p>
<blockquote>
<p>问题 3</p>
</blockquote>
<p>直接处理的话，问题非常复杂，需要大量的计算。因为我们只是需要找到同位词，那其实只要把拥有同样字母的单词贴上同样的标志即可。比如说，把每个单词里的字母按照字典序排序，而在具体的标志过程其实也有一些技巧，比如说good可以简化为go2d，这种标识法在长单词多重复时可以减少编码的长度。</p>
<p>具体的映射方式很多，这里不一一赘述</p>
<blockquote>
<p>1.考虑查找给定输入单词的所有变位词的问题。仅给定单词和字典的情况下，如何解决该问题？如果有一些时间和空间可以在响应任何查询之前预先处理字典，又会如何？</p>
</blockquote>
<p>在给定单词和字典的情况下，遍历字典，计算每个的标签，然后与给定的单词的标签比较。可以预处理的话就好说了，将所有单词按照标签排序，然后可以用equal_range求出区间，O(logN)。</p>
<blockquote>
<p>2.给定包含 4300000000 个 32 位整数的顺序文件，如何找出一个出现至少两次的整数？</p>
</blockquote>
<p>可以类比如何找出没有出现的整数。4300000000 大于int的表示范围。可以先扫描一遍，把第一位为0的和第一位为1的放到两个不同的文件中，看哪个文件里面的数多，就开始处理这个文件，把第二位的0和1的数字放到两个文件中，看哪个的数字多，依此类推，最后肯定得到一个数，他出现了不止一次。</p>
<blockquote>
<p>3.前面涉及了两个需要精确代码来实现的旋转算法，写出代码。在每个程序中，i 和 n 的最大公约数如何出现</p>
</blockquote>
<p>gao函数是那个杂技算法，gaogao是块交换算法。经过简单的测试还没有发现什么问题。n和len的最大公约数就是置换的次数。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
int gcd( int a, int b ){
    return b==0?a:gcd(b, a%b);
}
int gao( int *start, int *end, int n ){
    int len = end - start;
    int d = gcd( n, len );
    for( int i = 0; i &lt; d; i++ ){
        int t = *(start+i);
        int next = i;
        while( (next+n)%len != i ){
            *(start+next) = *(start+(next+n)%len);
            next = (next+n)%len;
        }
        *(start+next) = t;
    }
}
</code></pre><p>gaogao函数用到了一个辅助函数，rangeswap，就是将[start1,start1+n)和[start2,start2+n)的值进行交换。</p>
<pre><code>void rangeswap( int *start1, int *start2, int n ){
    for( int i = 0; i &lt; n; i++ )
        swap( *(start1+i), *(start2+i) );
}

void gaogao( int *start, int *end, int shift ){
    int len = end - start;
    shift = ( shift%len + shift )%len;
    if( len &lt;= 1 ) return;
    if( shift &lt;= len / 2 ){
        rangeswap( start, end - shift, shift );
        gaogao( start, end - shift, shift );
    }
    else{
        rangeswap( start, start+shift, len - shift );
        gaogao( end - shift, end, shift - len );
    }
}

const int n = 1000000;
int main(void){
    int a[n];
    for( int i = 0; i &lt; n; i++ )
        a[i] = i;
    gao( a, a+n, 6);
    for( int i = 0; i &lt; n; i++ )
        cout &lt;&lt; a[i] &lt;&lt; &apos; &apos;;
    cout &lt;&lt; endl;
    return 0;
}
</code></pre><p>STL中还有一种更bt的实现方法，algorithm中有个rotate，他用及其简单的代码就实现了循环位移。代码如下：</p>
<pre><code>template &lt;class ForwardIterator&gt;
void rotate ( ForwardIterator first, ForwardIterator middle, ForwardIterator last )
{
  ForwardIterator next = middle;
  while (first!=next)
  {
    swap (first++,next++);
    if (next==last) next=middle;
    else if (first == middle) middle=next;
  }
}
</code></pre><p>除了Orz我已经无话可说了。。</p>
<blockquote>
<p>4.比较三种不同的旋转算法</p>
</blockquote>
<p>暂略</p>
<blockquote>
<p>5.向量旋转函数将向量 ab 变为 ba，如何将 abc 变为 cba？</p>
</blockquote>
<p>对每一块儿进行翻转，然后对整体进行翻转即可。</p>
<blockquote>
<p>6.如何实现以一个名字的按键编码为参数，并返回所有可能的匹配名字的函数？</p>
</blockquote>
<p>计算出所有人名的按键信息（标识），然后按照标识进行排序，查询的时候二分即可。答案中提示更多使用的是hash和数据库。</p>
<blockquote>
<p>7.如何快速转置一个存储在磁带上的 4000x4000 的矩阵，从原来的50个小时缩减到半小时？</p>
</blockquote>
<p>可能是因为磁带的读写问题所导致的，具体不清楚</p>
<blockquote>
<p>8.给定一个 n 元实数集合、一个实数 t 和一个整数 k，如何快速确定是否存在一个 k 元子集，其元素之和不超过 t？</p>
</blockquote>
<p>第一感觉想到的是排序，然后看前k个数的和是否不超过t，不超过的话肯定存在。更优的方法用O(N)的选择算法求出第k大的数，然后把数组扫描一遍，求出小于第k大数的数的和sum，加上第k大。这样看似没有什么错误，但是仔细想想，如果第k-1大，第k大，第k+1大的数一样，肿么办？easy~扫描的时候顺便统计小于第k大数的数的个数a，和第k大的数的个数b，嗯，然后如果<code>a&lt;k-1</code>,就从b中取出m个，直到<code>a+m == k-1</code>。</p>
<blockquote>
<p>9.顺序搜索和二分搜索代表了搜索时间和预处理时间之间的折中。处理一个 n 元表格时，需要执行多少次二分搜索才能弥补对表进行排序所消耗的预处理时间？</p>
</blockquote>
<p>这个，具体让我来算一算</p>
<blockquote>
<p>10.爱迪生的故事</p>
</blockquote>
<p>用水来测体积</p>
<h2 id="u6570_u636E_u51B3_u5B9A_u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u51B3_u5B9A_u6570_u636E_u7ED3_u6784" class="headerlink" title="数据决定数据结构"></a>数据决定数据结构</h2><p>合适的数据结构确实构造了程序。本章描述了各种不同的程序，通过重构它们的内部数据，使其变得更加简短（而且更好）。数据结构本该短小、干净、漂亮，而不是巨大、混乱、丑陋不堪的。</p>
<p>能用小程序实现，就不要编写大程序。</p>
<p>程序员在节省空间方面无计可施时，将自己从代码中解脱出来，退回起点并集中心力研究数据，常常能有奇效，(数据的)表示形式是程序设计的根本。</p>
<p>下面是退回起点进行思考时的几条原则：</p>
<ul>
<li><strong>使用数组重新编写重复代码</strong>。冗长的相似代码常常可以使用最简单的数据结构——数组来更好地表述。</li>
<li><strong>封装复杂结构</strong>。当需要非常复杂的数据结构时，使用抽象术语进行定义，并将操作表示为类。</li>
<li><strong>尽可能使用高级工具</strong>。超文本、名字-值对、电子表格、数据库、编程语言等都是特定问题领域中的强大的工具。</li>
<li><strong>从数据得出程序的结构</strong>。彻底理解输入、输出和中间数据结构，并围绕这些结构创建程序。</li>
</ul>
<blockquote>
<p>1.税收分段计费</p>
</blockquote>
<p>使用数组来简化循环。数组中每个点表明一个阶段，用level[i]表示阶段i的起始点，tax[i]表示阶段i的税率，用have [i]表示这个阶段已经有的税收，然后得到收入后二分到相应的阶段，计算税收。</p>
<blockquote>
<p>2.k 阶常系数线性递归</p>
</blockquote>
<p>真心没看懂题目，也是醉</p>
<blockquote>
<p>3.编写一个“banner”函数，该函数的输入为大写字母，输出为一个字符数组，该数组以图形化的方式表示该字母</p>
</blockquote>
<p>这个就是用数组画图呗，三维数组即可。</p>
<p>原来要求的就是对三维数组进行信息压缩，自定一种格式显示即可。</p>
<blockquote>
<p>4.编写处理如下日期问题的函数：给定两个日期，计算两者之间的天数；给定一个日期，返回值为周几；给定月和年，使用字符数组生成该月的日历</p>
</blockquote>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;
int month[13] = {
0,  31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
//  1   2   3   4   5   6   7   8   9   10  11  12
};

class D{
public:
    int year,mon,day;// 1900 &lt;= year, 1 &lt;= mon &lt;= 12,
                    // 1 &lt;= day &lt;= 31
    D(){}
    D(int y, int m, int d):
        year(y),mon(m),day(d){}

    int yearday(void){//返回这一天是这一年的第几天
        int sum = day;
        for( int i = 1; i &lt; mon; i++ )
            sum += month[i];
        if( isrun() &amp;&amp; mon &gt; 2 )
            sum ++;
        return sum;
    }
    bool isrun( void ){//是否是闰年
        return (year%4==0&amp;&amp;year%100!=0)||(year%400==0);
    }
};

int dist( D d1, D d2 ){//两个日期相差的天数
    int sum = -(d1.yearday());
    for( ; d1.year &lt; d2.year ; d1.year++ )
        sum += d1.isrun()?366:365;
    return sum + d2.yearday();
}

int xingqiji( D d ){//某一天是星期几
    D temp(1900,1,1);
    return dist( temp, d )%7+1;
}

int print(int year, int mon ){//输出某月日历
    D d(year, mon, 1 );
    int week = xingqiji(d);
    int sum = month[ mon ];
    for( int i = 1; i &lt; week; i++ )
        cout &lt;&lt; &quot;   &quot;;
    for( int i = 1; i &lt;= sum; i++){
        cout &lt;&lt; i &lt;&lt; &quot;  &quot;;
        if( week == 7 ){
            week = 1;
            cout &lt;&lt; endl;
        }
        else week++;
    }
    cout &lt;&lt; endl;
}

int main(void){
    D a(2012,6,3);
    cout &lt;&lt; xingqiji(a) &lt;&lt; endl;
    print(1990,2);
    return 0;
</code></pre><blockquote>
<p>5.处理英语中的一小部分连字符问题。</p>
</blockquote>
<p>从前到后进行比较，符合一个输出就行。</p>
<blockquote>
<p>6.题目略</p>
</blockquote>
<p>回答略</p>
<blockquote>
<p>7.其实我没有看懂题目的意思</p>
</blockquote>
<p>所以我也没办法回答</p>
<blockquote>
<p>8.编写一个使用 5 个七段显示数字来显示十六位正整数的程序。输出为一个 5 字节的数组，当且仅当数字 j 中的第 i 段点亮时，字节 j 中的位 i 置 1。</p>
</blockquote>
<p>转化为一道题目，是zoj1146</p>
<blockquote>
<p>深入阅读</p>
</blockquote>
<p>数据可以结构化程序，但是只有聪明的程序员才能结构化大型软件系统。</p>
<h2 id="u7F16_u5199_u6B63_u786E_u7684_u7A0B_u5E8F"><a href="#u7F16_u5199_u6B63_u786E_u7684_u7A0B_u5E8F" class="headerlink" title="编写正确的程序"></a>编写正确的程序</h2><p>二分查找并不像想象中简单。</p>
<p>二分搜索的关键思想是如果 t 在 x[0…n-1] 中，那么它就一定存在于 x 的某个特定范围之内。这里使用 mustbe(range) 来表示。逻辑函数 mustbe(l, u) 是说：如果 t 在数组中，t 就一定在(闭区间)范围 x[l…u] 内。</p>
<p>最终的函数为</p>
<pre><code>l = 0; u = n - 1
loop
    { mustbe(l, u) }
    if l &gt; u
        p = -1; break;
    m = (l + u) / 2
    case
        x[m] &lt; t: l = m+1
        x[m] == t: P = m; break
        x[m] &gt; t: u = m-1
</code></pre><blockquote>
<p>1.如何证明二分搜索没有运行时错误(例如除数为0、数值溢出、变量值超出声明范围或者数组下标越界)？</p>
</blockquote>
<p>为了保证范围不超过范围，我们需要在初始化的时候，让变量不超出范围。这样每次循环得到的新的范围是慢慢缩小的，不会越界。</p>
<blockquote>
<p>!!2.把 t 在数组 x 中地一次出现的位置返回给 p(如果存在多个的话，原始的算法会任意返回其中的一个)。要求代码对数组元素进行对数次比较(在log~2 n 次比较内完成)</p>
</blockquote>
<pre><code>int bs( int *a, int l, int r, int v ){
    while( l &lt;= r ){
        if( a[l] == v ) return l;
        int mid = (l+r)/2;
        if( a[mid] &lt; v ) l = mid+1;
        if( a[mid] == v )r = mid;
        if( a[mid] &gt; v ) r = mid-1;
    }
    return -1;
}
</code></pre><p>这个二分可以返回所需要查询的元素第一次出现的位置，如果不存在，则返回-1.在每个循环内，我们假定元素第一次出现的范围是闭区间[l，r]内，当循环体内语句执行完之后，我们得到了一个新的区间。新的区间的范围是一直在收敛的（不会存在r，l执行完循环之后大小没有变化。），所以程序可以终止，得到正确结果。</p>
<blockquote>
<p>3.编写一个递归的二分搜索程序</p>
</blockquote>
<pre><code>int bss( int *a, int l, int r, int v ){
    if( l &gt; r ) return -1;
    if( a[l] == v ) return l;
    int mid = (l+r)/2;
    if( a[mid] &lt; v ) return bss( a, mid+1, r, v );
    if( a[mid] == v )return bss( a, l, mid, v );
    if( a[mid] &gt; v ) return bss( a, l, mid-1, v );
}
</code></pre><p>递归每加深一层，[l,r]的范围就减小。本层的后置条件要和下一层的前置条件吻合。</p>
<blockquote>
<p>4.验证运行时间是对数的</p>
</blockquote>
<p>略</p>
<blockquote>
<p>5.证明下面的程序在输入 x 为正整数时能够终止</p>
</blockquote>
<pre><code>while x != 1 do
    if even(x)
        x = x/2
    else
        x = 3 * x + 1
</code></pre><p>找一下规律</p>
<p>从 2 开始: 2 1 4 2 1 4….无法终止<br>从 3 开始: 3 10 5 16 8 4 2 1 4 2 1 4…无法终止</p>
<p>最终都会归于 214 循环</p>
<blockquote>
<p>6.咖啡罐问题：给定一个装有一些黑豆子和一些白豆子的咖啡罐以及一大堆额外的黑豆子，重复下面过程直到罐中只剩一颗豆子为止——从罐中选取两个豆子，如果颜色相同，就都扔掉并放入一个额外的黑色豆子，如果颜色不同，将白色的留下，黑色的扔掉。证明该过程会停止，最后留在罐中的豆子颜色与最初白豆子和黑豆子的数量有何函数关系？</p>
</blockquote>
<p>每次执行一次，罐子中的豆子数量就减去1,所以此过程可以终止。</p>
<p>化简到最后的阶段</p>
<pre><code>1 白 1 黑 -&gt; 白
2 白 -&gt; 黑
2 黑 -&gt; 白
可得出以下结论：
</code></pre><p>如果最后留下的是白色的，那么开始时候白色的个数为奇数，否则为偶数。</p>
<blockquote>
<p>7.确定点与线段的位置关系</p>
</blockquote>
<p>先是给一个线段的范围。然后选取中间的线，看点在他上面还是下面，然后可以缩小一半的查找范围。类似于二分查找</p>
<blockquote>
<p>8.如何在不改变二次比较次数的前提下让代码运行得更快？</p>
</blockquote>
<p>暂时没有想到什么</p>
<blockquote>
<p>9.证明程序有效性的题目</p>
</blockquote>
<p>两个n维的向量相加。初开始时：i=0表示前i个维度的都已经计算好了。在循环之中，计算一个维度，然后i加一，计算下一个维度，每个循环结束表明前i个维度已经计算完毕。i一直在增大，证明这个过程是可以终止的。当最后一个循环执行完毕的时候，i的值是n，表明前n个维度已经计算好了。所以其代码是正确的。</p>
<p>求x数组的最大值。初开始时候，max=x[0]表示最大值是第一个数，i=1表示前i个数的最大值已经求出。每次循环时候，如果有比max大的数，就替换，当循环结束时候，前i个数的最大值就知道了。当整个过程结束时，i==n，所以前n个数的最大值可以求出。</p>
<p>当循环找个一个t的时候，就停止循环，或者当i超出范围的时候停止。i在每一次循环的时候值都增加，所以这个算法是可以结束的。当超出范围的时候，返回-1，否则返回的就是第一次出现的位置，因为i的值是从小到大递增的。</p>
<p>每次递归，问题的规模都是缩小的，所以问题可以在有限步骤内结束。每次递归完成一次，就可以得到上次层想要的运算结果，接着向上传递。</p>
<h2 id="u7F16_u7A0B_u5C0F_u4E8B"><a href="#u7F16_u7A0B_u5C0F_u4E8B" class="headerlink" title="编程小事"></a>编程小事</h2><p><strong>脚手架</strong>。最好的脚手架通常是最容易构建的脚手架。</p>
<p><strong>编码</strong>。对于比较难写的函数，我发现最容易的方法是使用方便的高级伪代码来构建程序框架，然后将伪代码翻译成要实现的语言。</p>
<p><strong>测试</strong>。在脚手架中对组件进行测试要比在大系统中更容易、更彻底。</p>
<p><strong>调试</strong>。对隔离在其脚手架中的程序进行调试是很困难的，但是若将其嵌入真实运行环境中，调试工作会更困难。</p>
<p><strong>计时</strong>。用以测试达到预期的性能</p>
<h2 id="u7A0B_u5E8F_u6027_u80FD_u5206_u6790"><a href="#u7A0B_u5E8F_u6027_u80FD_u5206_u6790" class="headerlink" title="程序性能分析"></a>程序性能分析</h2><p>可以通过以下几个不同层次的改进，来获得巨大的加速：</p>
<ul>
<li><strong>算法和数据结构</strong>。改进访问的效率，分治法</li>
<li><strong>算法调优</strong>。配合数据结构进行优化</li>
<li><strong>数据结构重组</strong></li>
<li><strong>代码调优</strong>。对于不需要特别高精度的计算，可以用精度较低的类型代替</li>
<li><strong>硬件</strong>。升级性能我会乱说</li>
</ul>
<blockquote>
<p>原理</p>
</blockquote>
<ul>
<li>计算机系统中最廉价、最快速且可靠的元件是根本不存在的</li>
<li>如果仅需要较小的加速，就对效果最佳的层面做改进</li>
<li>如果需要较大的加速，就对多个层面做改进</li>
</ul>
<h2 id="u7C97_u7565_u4F30_u7B97"><a href="#u7C97_u7565_u4F30_u7B97" class="headerlink" title="粗略估算"></a>粗略估算</h2><blockquote>
<p>基本技巧</p>
</blockquote>
<ul>
<li><strong>两个答案比一个答案好</strong>。如果两种方法得到的估算结果比较接近，那么很可能答案是靠谱的。</li>
<li><strong>快速检验</strong>。量纲检验</li>
<li><strong>经验法则</strong>。比如说，假设以年利率 r% 投资一笔钱 y 年，如果 r x y = 72，那么你的投资差不多会翻倍。</li>
</ul>
<p>计算的输入决定了其输出的质量。基于良好的数据，简单的计算也可以得到精确的计算结果。</p>
<p>Brooklyn Bridge的设计者John Reobling是一个很有趣的人，在1940年左右，有许多桥因为暴风雨断裂了，那时候因为科学的限制并没有办法具体算出气动上升现象究竟需要多少的承载力。但是John Roebling充分意识到他不知道某些东西，所以在他意识到气动上升现象时，知道自己不足以对其建模，于是将Brooklyn Bridge桥上的铁索强度设计成基于已知的静态和动态负载的常规计算所要求强度的六倍。</p>
<p>Roebling是一名优秀的工程师，他使用一个巨大的安全系数来补偿他对某些方面的无知，从而使得Brooklyn Bridge成为当时所建现在唯一没有垮掉的桥。所以在对软件系统进行性能计算时，最好按照2、4或6的系数降低性能，以补偿我们的无知。</p>
<p><strong>Little 定律</strong>：队列中物体的平均数量为进入速率与平均停留时间的乘积。</p>
<p>下面举三个例子来说明利特尔法则：</p>
<p>有一个非常火爆的夜总会，你现在在排队，前面有20个人，你知道这个地方可以容纳60个人，平均来说每个人进去待3个小时，所以进入率就是每小时20个人，你大概就知道你大约需要等待1个小时。（同样可以推广到在游乐场等待游戏设施，不过最好别算，算了总是让人伤心）</p>
<p>假如我在地下室中存有150个酒瓶，我每年会喝掉25瓶并买回新的25瓶酒，那么每个容器我要保存多少年。应用利特尔法则，150除以25，得到每个容器保存六年。</p>
<p>假设平均思考时间为z的n个用户连接到了一个任意的系统中，其响应时间为r。每个用户都在思考和等待响应之间循环，所以总计作业数都是n。如果切断系统输出到用户之间的路径，你就能看到一个元系统，其平均负载为n，平均响应时间为z+r，吞吐量x=n/(r+z)</p>
<p><strong>任何事都应尽量简单，但不宜过于简单。</strong></p>
<blockquote>
<p>1.贝尔实验室距离狂野的密西西比河大约有1000英里，而我们距离平时比较温和的帕塞伊克河只有几英里。在一个星期的倾盆大雨后，报纸说“帕塞伊克河的流速为200英里每小时，大约是平时的五倍”，你有何评论？</p>
</blockquote>
<p>什么叫温和，我觉得可能是流速大约在跑步与汽车低速之间，假设是20英里每小时好了。一条河的流速的影响因素很多，比方说总流量，宽度，还有水量。经过综合考虑，我觉得报道上的流速太夸张了，200英里，吓死人。</p>
<p>常见流速其实是每小时2英里。也许200英里是一天的流速，是常见的一天40英里的五倍</p>
<blockquote>
<p>2.在什么距离下骑自行车的送信人使用移动存储介质传递信息的速度高于高速数据线的传输速度？</p>
</blockquote>
<p>假设这个移动存储介质的容量是无限的，要传递的信息的大小是 N mb，然后高速数据线的传输速率是 V mb/h，骑车的速度是 S km/h</p>
<p>可以转化为 N / V x S = 临界距离，具体找几个可能的数值代入进去算，考虑一些额外消耗即可。</p>
<blockquote>
<p>3.手动录入文字来填满一张软盘需要多长时间？</p>
</blockquote>
<p>考虑到软盘几近灭绝，我们就拿填满 1MB 为例子吧。</p>
<p>一个汉字占两个字节，我的打字速度大概是一分钟80个字，也就是一分钟可以填充160个字节，那么 1 MB = 1024 KB = 1024 x 1024 B</p>
<p>1024 x 1024 / 160 = 6553 min = 109 hour</p>
<blockquote>
<p>4.假设整个世界变慢为原来的百万分之一。你的计算机执行一条指令需要多长时间？你的磁盘旋转一周需要多长时间？磁盘臂在磁盘上搜索需要多长时间？键入自己的名字又需要多长时间？</p>
</blockquote>
<p>CPU的时钟频率为5MHz，即一个时钟周期为0.2μs，那么一条指令大约需要6-20个周期。现在的硬盘大约是7200转或者5400转，后面的类推即可</p>
<blockquote>
<p>5.如何进一步检验 72 法则？</p>
</blockquote>
<p>增长速率介于 5% 和 10% 之间，72法则估算的误差在1%以内。</p>
<blockquote>
<p>6.联合国估算1998年的世界人口为59亿，年增长率为1.33%。如果按照这个速率，到2050年世界人口会是多少？</p>
</blockquote>
<p>2050-1998=52； 52*1.33≈70</p>
<p>因此根据72法则，2050年人口约为59*2=118亿。</p>
<blockquote>
<p>10.请估计一下你所在城市的死亡率，用每年的总人口百分比来度量</p>
</blockquote>
<p>通过报纸上的死亡通告并估算本地人口来估算死亡率。或者是利用 Little 定律以及对平均寿命的估算。例如，如果平均寿命为70年，那么每年有1/70或1.4%的人口死亡</p>
<blockquote>
<p>11.给出 Little 定律的概要证明</p>
</blockquote>
<p>具体看官方解答吧</p>
<blockquote>
<p>12.一些报纸称，25美分硬币的平均寿命是30年，该如何检验真伪呢？</p>
</blockquote>
<p>抽样统计，平均数的两倍大约为寿命</p>
<h2 id="u7B97_u6CD5_u8BBE_u8BA1_u6280_u672F"><a href="#u7B97_u6CD5_u8BBE_u8BA1_u6280_u672F" class="headerlink" title="算法设计技术"></a>算法设计技术</h2><p>算法领悟可以使程序更加简单。复杂算法有时可以极大地提高性能。</p>
<blockquote>
<p>问题的提出</p>
</blockquote>
<p>一个具有n个浮点数字的数组x，目标是要找到之中连在一起的数组元素中找到最大和。例如如果输入的数组是以下这十个元素：</p>
<pre><code>31  -41  59  26  -53  58  97  -93  -23  84
</code></pre><p>那么程序应该返回从59到97的综合，也就是187。第一个算法迭代了所有满足 0 ≤ i ≤ j ＜ n 的 i 和 j 整数对，分别计算总和，最终找到综合最大的组合。</p>
<blockquote>
<p>最初的算法（算法1）</p>
</blockquote>
<pre><code>maxsofar = 0
for i = [0, n)
    for j = [i, n)
        sum = 0
        for k = [i, j]
            sum += x[k]
            maxsofar = max(maxsofar, sum)
</code></pre><p>这段代码比较简短、直观并且易于理解，唯一遗憾的就是——慢。基本上来说可以判断这个算法的大O是n的三次方。</p>
<blockquote>
<p>二次算法（算法2）</p>
</blockquote>
<p>第一个二次算法注意到 x[i..j]中的总和与前面已计算的 x[i..j-1] 的总和密切相关，从而减少了计算量。</p>
<pre><code>maxsofar = 0
for i = [0, n)
    sum = 0
    for j = [i, n)
        sum += x[j]
        maxsofar = max(maxsofar, sum)
</code></pre><p>外循环和内循环都要执行n次，所以大O是n的平方。但是如果这样我们依然觉得不够，因为检测所有值肯定需要花费二次方时间，如何可以避开这个问题？</p>
<blockquote>
<p>分治算法（算法3）</p>
</blockquote>
<p>分治法的思想是这样的：要解决规模为 n 的问题，可递归解决两个规模近似为 n/2 的子问题，然后将它们的答案进行合并以得到整个问题的答案。</p>
<p>具体到这个问题上，可以把整个数组分为两个大约相等的部分，就叫 a 和 b。然后递归找出 a 和 b 中元素和最大的子数组，称为 ma 与 mb。然后再找到 ma 与 mb 之间的最大子数组称为 mc。最后找到最大的一个即可。代码如下：</p>
<pre><code>float maxsum3(l, u)
    if (l &gt; u)    return 0
    if (l == u )    return max(0, x[l])
    m = (l + u) / 2
    lmax = sum = 0
    for (i = m; i &gt;= l; i--)
         sum += x[i]
         lmax = max (lmax, sum)
    rmax = sum = 0

    for i = (m, u]
         sum += x[i]
         rmax = max (rmax, sum)

    return max(lmax+rmax, maxsum(l, m), maxsum3(m+1, u))
</code></pre><p>代码非常微妙，也就意味着非常容易出错，但是复杂度是O(n log n)。</p>
<blockquote>
<p>扫描算法（算法4）</p>
</blockquote>
<p>从最左端（元素 x[0]）开始，一直扫描到最右端（元素 x[n-1]），记下所碰到过的最大总和子数组。最大值初始为0.假设我们已经解决了针对 x[0..i-1] 的问题，现在需要拓展到 x[i] 中。可以使用类似分治法中的道理，前 i 个元素中，最大总和子数组要么在 i-1 个元素中（存储在 maxsofar 中），要么截止到位置 i（存储在 maxendinghere中）。下面就是扫描算法：</p>
<pre><code>maxsofar = 0
maxendinghere = 0

for i = [0, n)
    maxendinghere = max(maxendinghere + x[i], 0)
    maxsofar = max(maxsofar, maxendinghere)
</code></pre><p>这个算法代码更加简短，但是运行起来是最快的，运行时间是O(n)，已经是线性算法，不可能再快了。</p>
<blockquote>
<p>原则</p>
</blockquote>
<p>这个问题的原型其实是Grenander面对的模式匹配问题（在最大子数组问题中，给定 n x n 的实数数组，如何找出任意具有最大总和的举行子数组）。为了简便，所以化为一维，并且经过不同人的努力，得到了最后的扫描算法。总这里我们就可以看出来几个重要的算法设计技术。</p>
<ul>
<li><strong>保存状态，避免重新计算</strong>。算法2和4使用了简单的动态编程形式。</li>
<li><strong>将信息预处理到数据结构中</strong></li>
<li><strong>分治算法</strong></li>
<li><strong>扫描算法</strong></li>
<li><strong>累积</strong></li>
<li><strong>下限</strong></li>
</ul>
<p>只有经过广泛地研究和实践，才能熟练地使用算法设计技术</p>
<h2 id="u4EE3_u7801_u8C03_u4F18"><a href="#u4EE3_u7801_u8C03_u4F18" class="headerlink" title="代码调优"></a>代码调优</h2><p>优秀的程序员会保持代码效率：效率在软件中只是众多问题中的一个，但有时也是极其重要的一个。代码优化确定现有程序中的开销昂贵的部分并提高其速度，虽然并不总是适当的方法，并且很少能吸引人，但是有时确实可以使程序的性能大不一样。</p>
<blockquote>
<p>问题1：整数取模</p>
</blockquote>
<p>原来的代码</p>
<pre><code>k = (j + rotdist) % n;
</code></pre><p>但在C语言中取模(其实大部分语言都是)的开销很大，使用下面代码可以减少时间</p>
<pre><code>k = j + rotdist;
if (k &gt;= n)
    k -= n;
</code></pre><p>如果程序的运行时间主要消耗在输入输出上，那么对程序中的计算进行加速是毫无意义的。</p>
<blockquote>
<p>问题2：函数、宏和内联代码</p>
</blockquote>
<p>因为现代编译器的优化，小心出现很难发现的错误</p>
<blockquote>
<p>问题3：顺序搜索</p>
</blockquote>
<p>原来的代码是这样的</p>
<pre><code>int ssearch1(t)
    for i = [0,n)
        if x[i] == t
            return i
    return -1
</code></pre><p>可以使用 loop unrooling 技术减少分支判断提高速度</p>
<blockquote>
<p>问题4：计算球面距离</p>
</blockquote>
<p>这个问题就是地理或集合数据处理方面的典型应用场合。先输入一个由球面上5000个点组成的S集，每个点都由经度和纬度表示。然后读入20000个点组成的序列，每个点都由经度和纬度表示。对于该序列中的每个点，程序需要指出S集中哪个点最接近它，其中的距离是以球体中心到两个点的连线之间的角度来度量的。</p>
<p>如果想要利用别出心裁的算法（很可能需要好几百行代码），那么可能付出很大的代价。为什么不是用简单的数据结构？于是更换成三维坐标系而不是精度纬度。这样只需要几十行的代码优化，运行时间从几个小时降低为半分钟。</p>
<blockquote>
<p>问题5：二分查找</p>
</blockquote>
<p>代码优化在二分查找中通常不是必需的，因为二分查找算法的效率已经较高了。但是对于特定问题其实仍有优化的空间，比如如果一个序列中同一数字出现多次的情况，这里就不细说。</p>
<blockquote>
<p>原则</p>
</blockquote>
<p>有关代码优化最重要的原则就是尽量少用代码优化。总的来说可以概括为以下几点：</p>
<ul>
<li><strong>效率的角色</strong>。软件的许多其他属性和效率一样重要，甚至更重要。不成熟的优化是大量编程灾害的根源。</li>
<li><strong>度量工具</strong>。当效率变得重要时，第一步就是对系统进行配置，找出花费时间的位置。对程序进行剖析将指出关键的区域；对于其他区域，“没有坏的话就不要修复它”。</li>
<li><strong>设计层次</strong>。在优化代码以前，我们应该确保其他方法不会提供更加有效的解决方案。</li>
<li><strong>双刃剑</strong>。有时候使用if语句替换%求余运算符可以得到两倍的加速，而有时候则没有什么差别。“咬人的人也应该提防被咬”。</li>
</ul>
<h2 id="u8282_u7701_u7A7A_u95F4"><a href="#u8282_u7701_u7A7A_u95F4" class="headerlink" title="节省空间"></a>节省空间</h2><p>时常努力考虑压缩程序是很有利的。有时这种思考会带来新的启示，使程序变得更加简单。减少空间通常带来运行时间上合理的副作用：程序越小，加载的时候也越快，也越容易填充到高速缓存中；需要操作的数据越少，操作时所花的时间通常也就越少。</p>
<blockquote>
<p>关键在于简单性</p>
</blockquote>
<p>简单性可以产生功能性、健壮性以及速度和空间。简单性也可以减少代码的空间。</p>
<p>例如遇到稀疏数组，就有多种方法可以进行空间的压缩，一种就是把一个二维数组转化为一个一维数组+链表的组合。</p>
<blockquote>
<p>数据空间技术</p>
</blockquote>
<p><strong>不存储，重新计算</strong>。如果我们在需要某一给定对象的任何时候，都对其进行重新计算而不保存，那么所需空间就可以急剧减少。</p>
<p><strong>稀疏数据结构</strong>。使用指针来共享大型对象可以消除存储同一对象的众多副本所需的开销。</p>
<p><strong>数据压缩</strong></p>
<p><strong>分配策略</strong>。动态分配</p>
<p><strong>垃圾回收</strong></p>
<h2 id="u6392_u5E8F"><a href="#u6392_u5E8F" class="headerlink" title="排序"></a>排序</h2><p>使用库排序函数并不总是有效的，有时使用起来会非常麻烦，这种时候，手动编写排序函数就成为了唯一的选择。</p>
<blockquote>
<p>插入排序</p>
</blockquote>
<p>伪代码</p>
<pre><code>for i = [1,n)
    for (j=i; j&gt;0 &amp;&amp; x[j-1] &gt; x[j]; j--)
        swap(j-1, j)
</code></pre><p>swap 函数调用会带来很大的额外开销，内联之后还可以进一步优化</p>
<pre><code>for i = [1, n)
    t = x[i]
    for (j=i; j&gt;0 &amp;&amp; x[j-1] &gt; t; j--)
        x[j] = x[j-1]
    x[j] = t
</code></pre><blockquote>
<p>一种简单的快速排序</p>
</blockquote>
<p>排序数组时，将数组分成两个小部分，然后对它们递归排序。</p>
<pre><code>void qsort(l, u)
    if l &gt;= u then
        /* at most one element, do nothing */
        return
    /* goal:partition array around a particular value,
       which is eventually placed in its correct position p
    */
    qsort(l, p-1)
    qsort(p+1, u)
</code></pre><p>更详细一点的代码是 qsort1，可以通过调用 qsort1(0, n-1) 来排序数组 x[n]</p>
<pre><code>void qsort2(l, u)
    if (l &gt;= u)
        return
    m = l
    for i = [l+1, u]
        /* invariant: x[l+1..m] &lt; x[l] &amp;&amp; x[m+1..i-1] &gt;= x[l] */
        if (x[i] &lt; x[l])
            swap(++m, i)
    swap(l, m)
    /* x[1..m-1] &lt; x[m] &lt;= x[m+1..u] */
    qsort2(l, m-1)
    qsort2(m+1, u)
</code></pre><p>当输入数组是不同元素的随机排列时，该快速排序平均需要 O(n log n) 的时间和 O(log n) 的栈空间。</p>
<blockquote>
<p>更好的几种快速排序</p>
</blockquote>
<p>考虑一种极端的情况：n 个相同元素组成的数组，对于这种输入，qsort1 的性能非常糟糕，总的性能为O(n^2)</p>
<p>使用双向划分可以避免这个问题，下标 i 和 j 初始化为待划分数组的两端。主循环内有两个内循环，第一个内循环将 i 向右移过小元素，遇到大元素时停止；第二个内循环将 j 向左移过大元素，遇到小元素时停止。然后主循环测试这两个下标是否交叉并交换它们的值。</p>
<p>遇到相同的元素时停止扫描，并交换 i 和 j 的值。虽然这样做使交换的次数增加了，但却将所有元素都相同的最坏情况变成了比较好的情况</p>
<pre><code>void qsort3(l, u)
    if l &gt;= u
        return
    t = x[l]; i = 1; j = u+1
    loop
        do i++ while i &lt;= u &amp;&amp; x[i] &lt; t
        do j-- while x[j] &gt; t
        if i &gt; j
            break
        swap(i, j)
    swap(l, j)
    qsort3(l, j-1)
    qsort3(j+1, u)
</code></pre><p>我们的快盘程序花费了大量的时间来排序很小的子数组。如果用插入排序之类的简单方法来排序这些很小的数组，程序的速度会更快。</p>
<pre><code>void qsort4(l, u)
    if u-l &lt; cutoff
        return
    swap(l, randint(l, u))
    t = x[l]; i = 1; j = u+1
    loop
        do i++ while i &lt;= u &amp;&amp; x[i] &lt; t
        do j-- while x[j] &gt; t
        if i &gt; j
            break
        temp = x[i]; x[i] = x[j]; x[j] = temp
    swap(l, j)
    qsort4(l, j-1)
    qsort4(j+1, u)

qsort4(0, n-1)
isort3() // 再用插入排序
</code></pre><blockquote>
<p>3.在特定的系统上如何求出最佳的 cutoff 值？</p>
</blockquote>
<p>做测试，都跑一次，然后找到最佳性能的点</p>
<blockquote>
<p>4.虽然快速排序平均只需要 O(log n) 的栈空间，但是在最坏情况下需要线性空间，请解释原因。修改程序，使得最坏情况下仅使用对数空间。</p>
</blockquote>
<p>参考算法书</p>
<blockquote>
<p>5.编写程序，在O(n)时间内从数组 x[0..n-1] 中找出第 k 个最小的元素。算法可以对 x 中的元素进行排序</p>
</blockquote>
<p>这个参考July的博客</p>
<h2 id="u53D6_u6837_u95EE_u9898"><a href="#u53D6_u6837_u95EE_u9898" class="headerlink" title="取样问题"></a>取样问题</h2><p>编写程序从 0 到 n-1 中随机输出 m 个有序整数</p>
<pre><code>void gensets(int m, int n){
    set&lt;int&gt; S;
    while(S.size() &lt; m)
        S.inseart(bigrand() % n);
    set&lt;int&gt;iterator i;
    for (i = S.begin(); i != S.end(); ++i)
        cout &lt;&lt; *i &lt;&lt; &quot;\n&quot;;
}
</code></pre><p>但是用 set 的话，时间开销比较大。</p>
<p>另一种方法是把包含 0 到 n-1 的数组顺序打乱，然后把前 m 个元素排序输出</p>
<pre><code>for i = [0, n)
    swap(i, randint(i, n-1))
</code></pre><p>其实只需要打乱前 m 个元素即可</p>
<pre><code>void genshuf(int m, int n){
    int i, j;
    int *x = new int[n];
    for (i = 0; i &lt; n; i++)
        x[i] = i;
    for (i = 0; i &lt; m; i++){
        j = randint(i, n-1)
        int t = x[i]; x[i] = x[j]; x[j] = t;
    }
    sort(x, x+m);
    for (i = 0; i &lt; m; i++)
        cout &lt;&lt; x[i] &lt;&lt; &quot;\n&quot;;
}
</code></pre><blockquote>
<p>原理</p>
</blockquote>
<p><strong>正确理解所遇到的问题</strong>。与用户讨论问题产生的北京。问题的陈述通常就包含了与解决方案有关的想法。</p>
<p><strong>提炼出抽象问题</strong>。简洁、明确的问题陈述不仅可以帮助我们解决当前遇到的问题，还有助于我们把解决方案应用到其他问题中。</p>
<p><strong>考虑尽可能多的解法</strong></p>
<p><strong>实现一种解决方案</strong></p>
<blockquote>
<p>1.C库函数 rand() 通常返回约15个随机位。使用该函数实现函数 bigrand() 和 randint(l,u)，要求前者至少返回30个随机位，后者返回[l,u]范围内的一个随机整数</p>
</blockquote>
<pre><code>int bigrand(){
    return RAND_MAX*rand() + rand();
}

int randint(int l, int u){
    return l + bigrand() % (u-l+1);
}
</code></pre><blockquote>
<p>8.如何从 0 到 n-1 中随机选择 m 个整数，使得最终的输出顺序是随机的？如果有序列表中允许有重复整数，如何生成该列表？如果既允许重复，又要求按随机顺序输出，情况又如何？</p>
</blockquote>
<p>第一次生成整数时就输出</p>
<blockquote>
<p>9.[R. W. Floyd] 当 m 接近于 n 时，基于集合的算法生成的很多随机数都要丢掉，因为它们之前已经存在于集合中了。能否给出一个算法，使得即使在最坏情况下也只使用 m 个随机数？</p>
</blockquote>
<pre><code>void genfloyd(int m, int n){
    set&lt;int&gt; S;
    set&lt;int&gt;::iterator i;
    for (int j = n - m; j &lt; n; j++){
        int t = bigrand() % (j+1);
        if (S.find(t) == S.end())
            S.insert(t); // t is not in S
        else
            S.insert(j); // t is in S
    }
    for(i = S.begin(); i != S.end(); ++i)
        cout &lt;&lt; *i &lt;&lt; &quot;\n&quot;;
}
</code></pre><blockquote>
<p>10.如何从 n 个对象(可以依次看到这 n 个对象，但事先不知道 n 的值)中随机选择一个？具体说来，如何在事先不知道文本文件行数的情况下读取该文件，从中随机选择并输出一行？</p>
</blockquote>
<p>总选择第一行，然后以1/2的概率选择第2行，然后1/3几率选择第三行。在这一过程是，每一行选中的概率都是相等的</p>
<pre><code>i = 0
while more input lines
    with probability 1.0/++i
        choice = this input line
print choise
</code></pre><h2 id="u641C_u7D22"><a href="#u641C_u7D22" class="headerlink" title="搜索"></a>搜索</h2><p><strong>空间的重要性</strong>。调优得很好的链表虽然完成的工作只有数组的一半，但却需要两倍于数组的时间。因为数组中每个元素所占的内存只有链表的一半，而且数组是顺序访问内存的。</p>
<p><strong>代码调优方法</strong>。最显著的改进就是用只分配一个较大的内存块的方案来替换通用内存分配。这样就消除了很多开销较大的调用，而且也使空间的利用更加有效。对大多数结构来说，引入哨兵可以获得清晰、简单的代码，并缩短运行时间。</p>
<blockquote>
<p>10.在完成类似于生成随机数的任务时，可以使用其他哪些数据结构来表示整数集合？</p>
</blockquote>
<p>混合并匹配多种数据结构来表示随机集合</p>
<h2 id="u7B2C_14__u7AE0_uFF1A"><a href="#u7B2C_14__u7AE0_uFF1A" class="headerlink" title="第 14 章："></a>第 14 章：</h2><p>解决两个重要问题：<strong>排序</strong>和<strong>优先级队列</strong></p>
<h2 id="u5B57_u7B26_u4E32"><a href="#u5B57_u7B26_u4E32" class="headerlink" title="字符串"></a>字符串</h2><p><strong>散列</strong>。这一结构的平均速度很快，且易于实现</p>
<p><strong>平衡树</strong>。这些结构在最坏情况下也有较好的性能</p>
<p><strong>后缀数组</strong></p>
<blockquote>
<p>!!9.给定两个输入文本，找出它们的共有的最长字符串</p>
</blockquote>
<p>把第一个字符串读入数组c，记录器结束的位置并在其最后填入空字符；然后读入第二个字符串并进行同样的处理。跟以前一样进行排序。扫描数组时，使用异或来确保恰有一个字符串是从过渡点前面开始的。</p>
<h2 id="u7B97_u6CD5_u5206_u7C7B"><a href="#u7B97_u6CD5_u5206_u7C7B" class="headerlink" title="算法分类"></a>算法分类</h2><blockquote>
<p>排序</p>
</blockquote>
<p>通用函数</p>
<ul>
<li>插入排序。稳定排序算法</li>
<li>快速排序。递归</li>
<li>堆排序。非递归，仅适用固定大小额外空间</li>
</ul>
<p>专用函数</p>
<ul>
<li>基数排序。对字符串排序</li>
<li>位图排序。待排序整数通常在小范围内，无重复也没有多余数据</li>
</ul>
<blockquote>
<p>搜索</p>
</blockquote>
<p>通用函数</p>
<ul>
<li>顺序搜索</li>
<li>二分搜索</li>
<li>散列</li>
<li>二分搜索树</li>
</ul>
<p>专用函数</p>
<ul>
<li>关键字索引</li>
</ul>
<blockquote>
<p>其他集合算法</p>
</blockquote>
<ul>
<li>优先级队列</li>
<li>选择</li>
</ul>
<blockquote>
<p>字符串算法</p>
</blockquote>
<ul>
<li>变位词</li>
<li>最长重复子串</li>
<li>生成随机文本</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>编程珠玑算是比较有年头的一套程序员进阶的书籍，这里是我的读书笔记。</p>]]>
    
    </summary>
    
      <category term="技巧" scheme="http://wdxtub.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【深入理解计算机系统】读书笔记]]></title>
    <link href="http://wdxtub.com/2016/03/26/csapp-book-note/"/>
    <id>http://wdxtub.com/2016/03/26/csapp-book-note/</id>
    <published>2016-03-26T19:55:57.000Z</published>
    <updated>2016-03-26T20:32:15.000Z</updated>
    <content type="html"><![CDATA[<p>这是我之前自学时的笔记，本文的内容为第二版，现在最新是第三版。</p>
<p><em>Notes from Da Wang, Feb.2 2015</em></p>
<a id="more"></a>
<hr>
<p>从程序员的角度来学习计算机系统是如何工作的会非常有趣，主要是因为你可以主动地来做这件事情。无论何时你学到一些新的东西，都可以马上试验并且直接看到运行结果。事实上，我们相信学习系统的唯一方法就是做(do)系统，即再真正的系统上解决具体的问题，或是编写和运行程序。</p>
<p>本书起源于1998年秋季，作者在 CMU 开设的编号为15-213的介绍性课程：计算机系统导论(Introduction to Computer Systems, ICS)，是大多数高级系统课程的先行必修课。宗旨是用一种不同的方式向学生介绍计算机，只讨论那些影响用户级 C 语言程序的性能、正确性或实用性的主题。</p>
<h1 id="u8BA1_u7B97_u673A_u7CFB_u7EDF_u6F2B_u6E38"><a href="#u8BA1_u7B97_u673A_u7CFB_u7EDF_u6F2B_u6E38" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h1><p>我们通过跟踪 helloworld 程序的生命周期来开始对系统的学习——从它被程序员创建，到在系统上运行，输出简单的消息，然后终止。</p>
<h2 id="u4FE1_u606F_u5C31_u662F_u4F4D_+__u4E0A_u4E0B_u6587"><a href="#u4FE1_u606F_u5C31_u662F_u4F4D_+__u4E0A_u4E0B_u6587" class="headerlink" title="信息就是位 + 上下文"></a>信息就是位 + 上下文</h2><p><img src="/images/csapp1.1.jpg" alt="csapp1.1"></p>
<p>hello.c 程序以字节序列的方式存储在文件中。每个字节都有一个整数值，而该整数值对应于某个字符。</p>
<p><img src="/images/csapp1.2.jpg" alt="csapp1.2"></p>
<p>hello.c 的表示方法说明了一个基本的思想：系统中所有的信息——包括磁盘文件、存储器中的程序、存储器中存放的用户数据以及网络上传送的数据，都是由一串位表示的。区分不同数据对象的唯一方式是我们读到这些数据对象时的上下文。</p>
<p><strong>C 编程语言的起源</strong></p>
<ul>
<li>贝尔实验室的 Dennis Ritchie 于 1969-1973 年创建</li>
<li>C 语言与 Unix 操作系统关系密切</li>
<li>C 语言小而简单</li>
<li>C 语言是为实践目的而设计的</li>
<li>C 语言是系统级编程的首选，同时它也非常适用于应用级程序的编写。然而，它也并非适用于所有的程序员和所有的情况。C 语言的指针是造成困惑和程序错误的一个常见原因。同时，C 语言还缺乏对非常有用的抽象（类、对象和异常）的显式支持。</li>
</ul>
<h2 id="u7A0B_u5E8F_u88AB_u5176_u4ED6_u7A0B_u5E8F_u7FFB_u8BD1_u6210_u4E0D_u540C_u7684_u683C_u5F0F"><a href="#u7A0B_u5E8F_u88AB_u5176_u4ED6_u7A0B_u5E8F_u7FFB_u8BD1_u6210_u4E0D_u540C_u7684_u683C_u5F0F" class="headerlink" title="程序被其他程序翻译成不同的格式"></a>程序被其他程序翻译成不同的格式</h2><p>hello 程序的生命周期是从一个高级 C 语言程序开始的，因为这种形式能够被人读懂。为了在系统上运行，每条 C 语句都必须被其他程序转化为一系列的低级<strong>机器语言</strong>指令。然后这些指令按照一种称为<strong>可执行目标程序</strong>的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为<strong>可执行目标文件</strong>。</p>
<p>在 Unix 系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：</p>
<pre><code>unix&gt; gcc -o hello hello.c
</code></pre><p>这个翻译过程可分为四个阶段。这行这四个阶段的程序（预处理器cpp、编译器ccl、汇编器as和链接器ld）一起构成了编译系统（compilation system）。</p>
<p><img src="/images/csapp1.3.jpg" alt="csapp1.3"></p>
<p><strong>GNU 项目</strong></p>
<p>GCC 是 GNU(GNU’s Not Unix) 项目开发出来的众多有用工具之一。GNU 项目已经开发出了一个包含 Unix 操作系统的所有主要部件的环境，但内核除外，内核是由 Linux 项目独立发展而来的。GNU 环境包括 EMACS 编辑器、GCC 编译器、GDB 调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件。</p>
<h2 id="u4E86_u89E3_u7F16_u8BD1_u7CFB_u7EDF_u5982_u4F55_u5DE5_u4F5C_u662F_u5927_u6709_u76CA_u5904_u7684"><a href="#u4E86_u89E3_u7F16_u8BD1_u7CFB_u7EDF_u5982_u4F55_u5DE5_u4F5C_u662F_u5927_u6709_u76CA_u5904_u7684" class="headerlink" title="了解编译系统如何工作是大有益处的"></a>了解编译系统如何工作是大有益处的</h2><p>知道编译系统是如何工作非常重要，原因如下：</p>
<ul>
<li><strong>优化程序性能</strong>。了解一些机器代码以及编译器将不同的 C 语句转换为机器代码的方式。<ul>
<li>一个 <code>switch</code> 语句是否总是比一系列 <code>if-else</code> 语句高效得多？</li>
<li>一个函数调用的开销有多大？</li>
<li><code>while</code> 循环比 <code>for</code> 循环更有效吗？</li>
<li>指针引用比数组索引更有效吗？</li>
</ul>
</li>
<li><strong>理解链接时出现的错误</strong>。一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。<ul>
<li>无法解析一个引用是什么意思？</li>
<li>静态变量和全局变量的区别是什么？</li>
<li>在不同 C 文件中定义的名字相同的两个全局变量会发生什么？</li>
<li>静态库和动态库的区别是什么？</li>
<li>我们在命令行上排列库的顺序有什么影响？</li>
</ul>
</li>
<li><strong>避免安全漏洞</strong>。学习安全变成的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。</li>
</ul>
<h2 id="u5904_u7406_u5668_u8BFB_u5E76_u89E3_u91CA_u5B58_u50A8_u5728_u5B58_u50A8_u5668_u4E2D_u7684_u6307_u4EE4"><a href="#u5904_u7406_u5668_u8BFB_u5E76_u89E3_u91CA_u5B58_u50A8_u5728_u5B58_u50A8_u5668_u4E2D_u7684_u6307_u4EE4" class="headerlink" title="处理器读并解释存储在存储器中的指令"></a>处理器读并解释存储在存储器中的指令</h2><p>要想在 Unix 系统上运行可执行目标文件 hello，将文件名输入到 shell 中：</p>
<pre><code>unix&gt; ./hello
hello, world
unix&gt;
</code></pre><p>shell 是一个命令行解释器，它输出一个提示符，等待你输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的 shell 命令，那么 shell 就会假设这是一个可执行文件的名字，它将加载并运行这个文件。</p>
<blockquote>
<p>系统的硬件组成</p>
</blockquote>
<p>下图是 Intel Pentium 系统产品系列的模型：</p>
<p><img src="/images/csapp1.4.jpg" alt="csapp1.4"></p>
<ol>
<li><strong>总线</strong>：贯穿整个系统的电子管道，携带信息字节并负责在各个部件间传递。通常总线呗设计成传送定长的字节块，也就是字(word)。假设字长为 4 个字节，并且总线每次只传送 1 个字。</li>
<li><strong>I/O 设备</strong>：系统与外部世界的联系通道。每个 I/O 设备都通过一个<strong>控制器</strong>或<strong>适配器</strong>与 I/O 总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是置于 I/O 设备本身的或者系统的主板上的芯片组，而适配器则是一块插在主板插槽上的卡。</li>
<li><strong>主存</strong>：临时存储设备，由一组动态随机存取存储器(DRAM)芯片组成。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一地址。</li>
<li><strong>处理器</strong>：解释(或执行)存储在主存中指令的引擎。核心是一个字长的存储设备(或寄存器)，称为程序计数器(PC)。在任何时刻，PC 都指向主存中的某条机器语言指令。从系统痛点开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，在更新程序计数器，使其指向下一条指令。</li>
</ol>
<blockquote>
<p>运行 hello 程序</p>
</blockquote>
<p>当我们输入“./hello”后，shell 程序将字符逐一读入寄存器，再把它存放到存储器中，如下图所示：</p>
<p><img src="/images/csapp1.5.jpg" alt="csapp1.5"></p>
<p>利用直接存储器存取(DMA)技术，数据可以不通过处理器而直接从磁盘到达主存</p>
<p><img src="/images/csapp1.6.jpg" alt="csapp1.6"></p>
<p>一旦目标文件中的代码和数据被加载到主存，处理器就开始执行 hello 程序的 main 程序中的机器语言指令。这些指令将“hello, world\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。</p>
<p><img src="/images/csapp1.7.jpg" alt="csapp1.7"></p>
<h2 id="u9AD8_u901F_u7F13_u5B58_u81F3_u5173_u91CD_u8981"><a href="#u9AD8_u901F_u7F13_u5B58_u81F3_u5173_u91CD_u8981" class="headerlink" title="高速缓存至关重要"></a>高速缓存至关重要</h2><p>这个简单的例子揭示了一个重要的问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。因此，系统设计者的一个主要目的就是使这些复制操作尽可能快地完成。</p>
<p><img src="/images/csapp1.8.jpg" alt="csapp1.8"></p>
<p>较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。针对这种差异，系统设计者采用了更小、更快的存储设备，即<strong>高速缓存存储器</strong>，作为暂时的集结区域，用一种叫<strong>做静态随机访问存储器(SRAM)</strong>的硬件技术实现。</p>
<h2 id="u5B58_u50A8_u8BBE_u5907_u5F62_u6210_u5C42_u6B21_u7ED3_u6784"><a href="#u5B58_u50A8_u8BBE_u5907_u5F62_u6210_u5C42_u6B21_u7ED3_u6784" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h2><p>从上至下，设备的访问速度越来越慢、容量越来越大，每字节的造价也越来越便宜。</p>
<p><img src="/images/csapp1.9.jpg" alt="csapp1.9"></p>
<h2 id="u64CD_u4F5C_u7CFB_u7EDF_u7BA1_u7406_u786C_u4EF6"><a href="#u64CD_u4F5C_u7CFB_u7EDF_u7BA1_u7406_u786C_u4EF6" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h2><p>我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。操作系统有两个基本功能：</p>
<ol>
<li>防止硬件被失控的应用程序滥用。</li>
<li>向应用程序提供简单一致的机制来控制复杂而又通常大相径庭的低级硬件设备。</li>
</ol>
<p><img src="/images/csapp1.10.jpg" alt="csapp1.10"></p>
<p>操作系统通过几个基本的抽象概念(进程、虚拟存储器和文件)来实现这两个功能。</p>
<p><strong>Unix 和 Posix</strong></p>
<p>20 世纪 60 年代是大型、复杂操作系统盛行的年代，如 IBM 的 OS/360 和 Honeywell 的 Multics 系统。贝尔实验室曾经是 Multics 项目的最初参与者，但是因为项目复杂和缺乏进展于 1969 年退出。这之后一组贝尔实验室的研究人员(Ken Thompson, Dennis Ritchie, Doug Mcllroy &amp; Joe Ossanna)从1969年开始在 DEC PDP-7 计算机上完全用机器语言编写了一个简单得多的系统，1970 年 Brian Kernighan 命名为“Unix”。1973 年用 C 语言重新编写内核，1974年开始对外发布。</p>
<p>发布之后不同的 Unix 厂商加入新的、往往不兼容的特性来使它们的程序与众不同，也带来很多麻烦，为了阻止这种趋势，IEEE 开始努力标准化 Unix 的开发，后来由 Richard Stallman 命名为“Posix”，称为 Posix 标准。</p>
<blockquote>
<p>进程</p>
</blockquote>
<p><strong>进程</strong>是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。无论是在单核还是多核系统中，一个 CPU 看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的，这种交错执行的机制称为<strong>上下文切换</strong>。</p>
<p>操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是<strong>上下文</strong>，它包括许多信息，例如 PC 和寄存器文件的当前值，以及主存的内容。</p>
<p><img src="/images/csapp1.12.jpg" alt="csapp1.12"></p>
<blockquote>
<p>线程</p>
</blockquote>
<p>一个进程实际上可以由多个称为<strong>线程</strong>的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器对并行处理的需求，线程称为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，一般来说也更高效。</p>
<blockquote>
<p>虚拟存储器</p>
</blockquote>
<p><strong>虚拟存储器</strong>是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的是一致的存储器，称为<strong>虚拟地址空间</strong>。</p>
<p>在 Linux 中，地址空间最上面的区域是为操作系统中的代码和数据保留的，这对所有进程来说都是一样的。地址空间的底部区域存放用户进程定义的代码和数据，请注意，图中的地址是从下往上增大的。</p>
<p><img src="/images/csapp1.13.jpg" alt="csapp1.13"></p>
<p>从最低的地址开始，逐步向上介绍：</p>
<ul>
<li><strong>程序代码和数据</strong>。对于所有的进程来说，代码是从同一固定地址开始，紧接着是和 C 全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。</li>
<li><strong>堆</strong>。代码和数据区后紧随着的是运行时堆。代码和数据区是在进程一开始运行就被规定了大小，与此不同，当调用如 <code>malloc</code> 和 <code>free</code> 这样的 C 标准库函数时，对可以在运行时动态地扩展和收缩。</li>
<li><strong>共享库</strong>。大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。</li>
<li><strong>栈</strong>。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。</li>
<li><strong>内核虚拟存储器</strong>。内核总是主流在内存中，是操作系统的一部分。地址空间顶部的区域是为内核保留的，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。</li>
</ul>
<blockquote>
<p>文件</p>
</blockquote>
<p><strong>文件</strong>就是字节序列，仅此而已。这个简单而精致的概念拥有极其丰富的内涵，它向应用程序提供了一个统一的视角，来看待系统中可能含有的所有 I/O 设备。</p>
<h2 id="u7CFB_u7EDF_u4E4B_u95F4_u5229_u7528_u7F51_u7EDC_u901A_u4FE1"><a href="#u7CFB_u7EDF_u4E4B_u95F4_u5229_u7528_u7F51_u7EDC_u901A_u4FE1" class="headerlink" title="系统之间利用网络通信"></a>系统之间利用网络通信</h2><p>从一个单独的系统来看，网络可视为一个 I/O 设备。当系统从主存将一串字节复制到网络适配器时，数据流经过网络到达另一台机器，而不是其他地方。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。</p>
<p><img src="/images/csapp1.14.jpg" alt="csapp1.14"></p>
<h2 id="u91CD_u8981_u4E3B_u9898"><a href="#u91CD_u8981_u4E3B_u9898" class="headerlink" title="重要主题"></a>重要主题</h2><p>系统不仅仅只是硬件，而是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序的最终目的。下面是几个贯穿计算机系统所有方面的重要概念：</p>
<blockquote>
<p>并发和并行</p>
</blockquote>
<p><strong>并发(concurrency)</strong>是一个通用的概念，指一个同时具有多个活动的系统；<strong>并行(parallelism)</strong>指的是用并发使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。</p>
<p><strong>1.线程级并发</strong></p>
<p>传统意义上，这种并发执行只是模拟出来的，是通过正在执行的进程间快速切换的方式实现的，这种配置称为<strong>单处理器系统</strong>。</p>
<p><img src="/images/csapp1.16.jpg" alt="csapp1.16"></p>
<p>当构建一个由单操作系统内核控制的多处理器组成的系统时，就得到了一个<strong>多处理器系统</strong>。超线程，有时称为<strong>同时多线程(simultaneous multi-threading)</strong>，是一项允许一个 CPU 执行多个控制流的技术。</p>
<p><img src="/images/csapp1.17.jpg" alt="csapp1.17"></p>
<p>多处理器的使用可以从两个方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。其次，它可以使应用程序运行得更快。</p>
<p><strong>2.指令级并行</strong></p>
<p>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为<strong>指令级并行</strong>。流水线(pipelining)的引入使得指令并行成为可能。如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为<strong>超标量(superscalar)</strong>处理器。</p>
<p><strong>3.单指令、多数据并行</strong></p>
<p>在最低层次上，许多处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，即 SIMD 并行。</p>
<blockquote>
<p>计算机系统中抽象的重要性</p>
</blockquote>
<p><strong>抽象</strong>的使用是计算机科学中最为重要的概念之一。</p>
<p><img src="/images/csapp1.18.jpg" alt="csapp1.18"></p>
<p>在处理器里，<strong>指令集结构</strong>提供了对实际处理器硬件的抽象。在操作系统中：<strong>文件</strong>是对 I/O 的抽象，<strong>虚拟存储器</strong>是对程序存储器的抽象，而<strong>进程</strong>是对一个正在运行的程序的抽象。虚拟机则是对整个计算机(包括操作系统、处理器和程序)的抽象。</p>
<hr>
<p><strong>第一部分：程序结构和执行</strong></p>
<p>计算机由处理器和存储器子系统组成。在核心部分，我们需要方法来表示基本数据类型，比如整数和实数运算的近似值。然后，我们考虑机器级指令如何操作这样的数据，以及编译器如何将 C 程序翻译成这样的指令。这一部分将帮助你深入了解如何表示和执行应用程序。</p>
<h1 id="u4FE1_u606F_u7684_u8868_u793A_u548C_u5904_u7406"><a href="#u4FE1_u606F_u7684_u8868_u793A_u548C_u5904_u7406" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h1><p>单个 bit 不是非常有用，然而，当把 bit 组合在一起，再加上某种解释(interpretation)，即给不同的可能位模式赋予含义，就能够表示任何有限集合的元素。计算机的表示法适用有限数量的 bit 来对一个数字编码，因此，当结果太大以至于不能表示时，某些运算就会<strong>溢出(overflow)</strong>。</p>
<p>浮点运算有完全不同的数学属性，由于精度有限，浮点运算是不可结合的。整数的表示虽然只能编码一个相对较小的数值范围，但这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但这种表示只是近似的。</p>
<p><strong>C 编程语言的演变</strong></p>
<p>C -> ANSI C -> ISO C90 -> ISO C99</p>
<p>GNU 编译器套装(GNU Compiler Collection, GCC)可以基于不同的命令行选项，依照多个不同版本的 C 语言规则来编译程序。</p>
<p><img src="/images/csapp2.1.jpg" alt="csapp2.1"></p>
<h2 id="u4FE1_u606F_u5B58_u50A8"><a href="#u4FE1_u606F_u5B58_u50A8" class="headerlink" title="信息存储"></a>信息存储</h2><p>大多数计算机使用8位的块，或者 byte 作为最小的可寻址的存储器单位，而不是在存储器中访问单独的 bit。机器级程序将存储器视为一个非常大的字节数组，称为<strong>虚拟存储器(virtual memory)</strong>。存储器的每个字节都由一个唯一的数字来标识，称为它的<strong>地址(address)</strong>，所有可能的地址集合称为<strong>虚拟地址空间(virtual address space)</strong>。</p>
<blockquote>
<p>十六进制表示法</p>
</blockquote>
<p>一个 byte 由 8 个 bit 组成。在二进制表示法中，它的值域是 00000000(2) ~ 11111111(2)；如果用十进制整数表示，它的值域就是 0 ~ 255。用十六进制书写，一个字节的值域为 00(16) ~ FF(16)。</p>
<p><img src="/images/csapp2.2.jpg" alt="csapp2.2"></p>
<blockquote>
<p>字</p>
</blockquote>
<p>每台计算机都有一个<strong>字长(word size)</strong>，指明整数和指针数据的<strong>标称大小(nominal size)</strong>。因为虚拟地址是以这样一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长尾 w 位的机器而言，虚拟地址的范围为 0 ~ 2^(w-1)，程序最多访问 2^w 个字节。现在的 32 位机器指的就是字长是 32 位，就限定了虚拟地址空间为 4GB。</p>
<blockquote>
<p>数据大小</p>
</blockquote>
<p>计算机和编译器支持多种不同方式编码的数字格式，如整数和浮点数，以及其他长度的数字。</p>
<p><img src="/images/csapp2.3.jpg" alt="csapp2.3"></p>
<p>程序员应该力图使他们的程序在不同的机器和编译器上是可移植的。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。</p>
<blockquote>
<p>寻址和字节顺序</p>
</blockquote>
<p>对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在存储器中如何排列这些字节。</p>
<p>某些机器选择在存储器中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则——最低有效字节在最前面的方式，称为<strong>小端法(little endian)</strong>。后一种规则——最高有效字节在最前面的方式，称为<strong>大端法(big endian)</strong>。许多比较新的微处理器使用<strong>双端法(bi-edian)</strong>，也就是说可以把它们配置成作为大端或者小端的机器运行。</p>
<p>几种机器所使用的字节顺序会成为问题的情况：</p>
<ol>
<li>在不同类型的机器之间通过网络传送二进制数据。</li>
<li>当阅读表示整数数据的字节序列时，字节顺序也很重要。</li>
<li>当编写规避正常的类型的系统时。</li>
</ol>
<p><strong>使用 typedef 命名数据类型</strong></p>
<p>C 语言中的 typedef 声明提供了一种给数据类型命名的方式。这能够极大地改善代码的可读性，因为深度嵌套的类型声明很难读懂。typedef 的语法与声明变量的语法十分相似，除了它使用的是类型名，而不是变量名。</p>
<blockquote>
<p>表示字符串</p>
</blockquote>
<p>C 语言中字符串被编码为一个以 null(其值为 0)字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是 ASCII 字符码。在使用 ASCII 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关，因此文本数据比二进制数据具有更强的平台独立性。</p>
<p><img src="/images/csapp0.2.jpg" alt="csapp0.2"></p>
<blockquote>
<p>表示代码</p>
</blockquote>
<p>考虑下面的 C 函数：</p>
<pre><code>int sum(int x, int y) {
    return x + y;
}
</code></pre><p>当我们在示例机器上编译时，生成如下字节表示的机器代码：</p>
<p><img src="/images/csapp0.3.jpg" alt="csapp0.3"></p>
<p>可以看到指令编码是不同的。不同的机器类型使用不同的且不兼容的指令和编码方式。因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。</p>
<blockquote>
<p>布尔代数简介</p>
</blockquote>
<p>二进制是计算机编码、存储和操作信息的核心，所以围绕 0 和 1 的研究演化出了丰富的数学知识体系。</p>
<p><img src="/images/csapp2.7.jpg" alt="csapp2.7"></p>
<blockquote>
<p>C 语言中的位级运算</p>
</blockquote>
<p>C 语言支持按位布尔运算，确定一个位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制并执行二进制运算，然后转换回十六进制。</p>
<p>位级运算的一个常见用法就是实现<strong>掩码</strong>运算，这里的掩码是一个位模式，表示从一个字中选出的位的集合。</p>
<blockquote>
<p>C 语言中的逻辑运算</p>
</blockquote>
<p>C 语言还提供了一组逻辑运算符 ||、&amp;&amp; 和 !，分别对应于命题逻辑中的 OR、AND 和 NOT 运算。</p>
<blockquote>
<p>C 语言中的移位运算</p>
</blockquote>
<p>C 语言还提供了一组移位运算，以便向左或者向右移动位模式：\&lt;\&lt;、>>。</p>
<p>x \&lt;\&lt; k 会生成一个值，x 向左移动 k 位，丢弃最高的 k 位，并在右端补 k 个 0。</p>
<p>右移 x >> k 比较微妙，一般而言，机器支持两种形式的右移：逻辑右移(补 0)和算术右移(补 1)。对于无符号数据，右移必须是逻辑的。对于有符号数据，几乎所有的编译器 / 机器组合都使用算术右移。</p>
<h2 id="u6574_u6570_u8868_u793A"><a href="#u6574_u6570_u8868_u793A" class="headerlink" title="整数表示"></a>整数表示</h2><blockquote>
<p>整型数据类型</p>
</blockquote>
<p>C 语言支持多种整型数据类型——表示有限范围的整数。C 语言标准定义了每种数据类型必须能够表示的最小的取值范围。</p>
<p><img src="/images/csapp2.8.jpg" alt="csapp2.8"></p>
<p><img src="/images/csapp2.9.jpg" alt="csapp2.9"></p>
<p><img src="/images/csapp2.10.jpg" alt="csapp2.10"></p>
<blockquote>
<p>无符号数的编码</p>
</blockquote>
<p>假设一共有 w 位，每个介于 0 ~ 2^w -1 之间的数都有唯一一个 w 位的值编码，即这个函数映射是一个双射。</p>
<blockquote>
<p>补码(two’s-complement)编码</p>
</blockquote>
<p>字的最高有效位解释为负权(negative weight)。</p>
<p><img src="/images/csapp2.13.jpg" alt="csapp2.13"></p>
<p>C 语言标准并没有要求用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。</p>
<p>其他的表示方法有<strong>反码(ones’ complement)</strong>和<strong>原码(sign-magnitude)</strong>，这两种表示方法都有一个奇怪的属性，就是对于数字 0 有两种不同的编码方式。</p>
<blockquote>
<p>有符号数和无符号数之间的转换</p>
</blockquote>
<p><img src="/images/csapp2.17.jpg" alt="csapp2.17"></p>
<blockquote>
<p>C 语言中的有符号数与无符号数</p>
</blockquote>
<p>C 语言允许无符号数和有符号数之间的转换。转换的原则是底层的位表示保持不变。</p>
<p><img src="/images/csapp2.18.jpg" alt="csapp2.18"></p>
<blockquote>
<p>扩展一个数字的位表示</p>
</blockquote>
<p>将一个无符号数转换为一个更大的数据类型，我们只需要简单地在表示的开头添加 0，这种运算称为<strong>零扩展(zero extension)</strong>。将一个补码数字转换为一个更大的数据类型可以执行<strong>符号扩展(sign extension)</strong>，规则是在表示中添加最高有效位的值的副本。</p>
<blockquote>
<p>截断数字</p>
</blockquote>
<p>截断一个数字可能会改变它的值——溢出的一种形式。</p>
<blockquote>
<p>关于有符号树与无符号数的建议</p>
</blockquote>
<p>有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换细微差别的错误很难被发现。因为这种强制类型转换是在代码中没有明确指示的情况下发生的，程序员经常忽视了它的影响。</p>
<p>避免这类错误的一种方法就是绝不使用无符号数。实际上，除了 C 以外，很少有语言支持无符号整数。</p>
<h2 id="u6574_u6570_u8FD0_u7B97"><a href="#u6574_u6570_u8FD0_u7B97" class="headerlink" title="整数运算"></a>整数运算</h2><p>理解计算机运算的细微之处能够帮助程序员编写更可靠的代码。</p>
<blockquote>
<p>无符号加法</p>
</blockquote>
<p>考虑两个非负整数 x 和 y，满足 $0 ≤ x, y ≤ 2^w - 1$。每个数都能表示为 w 位无符号数字。如果计算它们的和，我们就有一个可能的范围 $0 ≤ x + y ≤ 2^(w+1) - 2$，表示这个和可能需要 w + 1位。无符号运算可以被视为一种模运算形式。</p>
<blockquote>
<p>补码加法</p>
</blockquote>
<p>必须确定当结果太大(为正)或者太小(为负)时，应该做些什么。</p>
<p><img src="/images/csapp2.24.jpg" alt="csapp2.24"></p>
<blockquote>
<p>补码乘法</p>
</blockquote>
<p><img src="/images/csapp2.26.jpg" alt="csapp2.26"></p>
<blockquote>
<p>乘以常数</p>
</blockquote>
<p>在大多数机器上，整数乘法指令相当慢，需要 10 个或者更多的时钟周期，然而其他整数运算(例如加法、减法、位级运算和移位)只需要 1 个时钟周期。因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。</p>
<p>例如，假设一个程序包含表达式 x * 14。利用等式 $14 = 2^3 + 2^2 + 2^1$，编译器会将乘法重写为 (x \&lt;\&lt; 3) + (x \&lt;\&lt; 2) + (x \&lt;\&lt; 1)，实现了将一个乘法替换为三个移位和两个加法。更好的方法是 $14 = 2^4 - 2^1$，将乘法重写为(x \&lt;\&lt; 4) - (x \&lt;\&lt; 1)，这时只需要两个移位和一个减法。</p>
<blockquote>
<p>除以 2 的幂</p>
</blockquote>
<p>在大多数机器上，整数除法要比整数乘法更慢——需要 30 个或者更多的周期。除以 2 的幂也可以用移位运算右移来实现，无符号和补码数分别使用逻辑移位和算术移位来达到目的。</p>
<blockquote>
<p>关于整数运算的最后思考</p>
</blockquote>
<p>计算机执行“整数”运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。补码表示提供了一种既能表示负数也能表示正数的灵活方法，同时使用了与执行无符号算术相同的位级实现。</p>
<h2 id="u6D6E_u70B9_u6570"><a href="#u6D6E_u70B9_u6570" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点表示对形如 V = x * 2^y 的有理数进行编码，IEEE 标准 754 规定了如何表示浮点数及其运算。</p>
<blockquote>
<p>二进制小数</p>
</blockquote>
<p><img src="/images/csapp2.30.jpg" alt="csapp2.30"></p>
<p>增加二进制表示的长度可以提高表示的精度。</p>
<blockquote>
<p>IEEE 浮点表示</p>
</blockquote>
<p>用 V = (-1)^s * M * 2^E 的形式来表示一个数：</p>
<ul>
<li>符号(sign) s决定这个数是负数(s=1)还是正数(s=0)，对于数值 0 的符号位解释作为特殊情况处理。</li>
<li>尾数(significand) M 是一个二进制小数，它的范围是 1 ~ 2 - ε，或者是 0 ~ 1 - ε。</li>
<li>阶码(exponent) E 的作用是对浮点数加权，这个权重是 2 的 E 次幂(可能是负数)</li>
</ul>
<p>将浮点数的位表示划分为三个字段，分别对这些值进行编码：</p>
<ul>
<li>一个单独的符号位 s 直接编码符号 s。</li>
<li>k 位的阶码字段 exp = e(k-1)…e(1)e(0) 编码阶码 E。</li>
<li>n 位小数字段 frac = f(n-1)…f(1)f(0) 编码尾数 M，但是编码出来的值也依赖于阶码字段的值是否等于 0。</li>
</ul>
<p><img src="/images/csapp2.31.jpg" alt="csapp2.31"></p>
<p><img src="/images/csapp2.32.jpg" alt="csapp2.32"></p>
<blockquote>
<p>2.4.3 数字示例</p>
</blockquote>
<p><img src="/images/csapp2.33.jpg" alt="csapp2.33"></p>
<p><img src="/images/csapp2.34.jpg" alt="csapp2.34"></p>
<blockquote>
<p>2.4.4 舍入(rounding)</p>
</blockquote>
<p>因为表示方法限制类浮点数的范围和精度，浮点运算只能近似地表示实数运算。因此，对于值 x，我们一般想用一种系统的方法，能够找到“最接近的”匹配值，这就是舍入运算的任务。</p>
<blockquote>
<p>2.4.5 浮点运算</p>
</blockquote>
<p>浮点加法不具有结合性。浮点乘法在加法上不具备分配性。对于科学计算程序员和编译器编写者来说，这是很严重的问题，即使为了在三维空间中确定两条线是否交叉而写代码这样看上去很简单的任务，也可能成为一个很大的挑战。</p>
<blockquote>
<p>2.4.6 C 语言中的浮点数</p>
</blockquote>
<p>float 和 double。在 int、float 和 double 格式之间进行强制类型转换时，程序改变数值和位模式的原则如下(假设 int 是 32 位的)：</p>
<ul>
<li>从 int 转换成 float，不会溢出，可能被舍入。</li>
<li>从 int 或 float 转换成 double，能够保留精确的数值。</li>
<li>从 double 转换成 float，可能溢出成为正无穷或负无穷，也可能被舍入。</li>
<li>从 float 或者 double 转换成 int，值会向零舍入。例如 1.999 将被转换成 1。</li>
</ul>
<h2 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h2><p>计算机将信息按位编码，通常组织成字节序列。用不同的编码方式表示整数、实数和字符串。不同的计算机模型在编码数字和多字节数据中的字节排序时使用不同的约定。</p>
<p>由于编码的长度有限，与传统整数和实数运算想必，计算机运算具有完全不同的属性。当超出表示范围时，有限长度能够引起数值溢出。当浮点数非常接近于 0.0，从而转换成零时，也会瞎溢。</p>
<p>必须非常小心地使用浮点运算，因为浮点运算只有有限的范围和精度，而且不遵守普遍的算术属性，比如结合性。</p>
<h1 id="u7A0B_u5E8F_u7684_u673A_u5668_u7EA7_u8868_u793A"><a href="#u7A0B_u5E8F_u7684_u673A_u5668_u7EA7_u8868_u793A" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h1><p>计算机执行<strong>机器代码</strong>，用字节序列编码低级的操作，包括处理数据、管理存储器、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的原则、目标机器的指令集和操作系统遵循的规则，经过一系列的阶段产生机器代码。GCC C 语言汇编器以<strong>汇编代码</strong>的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后 GCC 调用<strong>汇编器</strong>和<strong>链接器</strong>，从而根据汇编代码生成可执行的机器代码。</p>
<h2 id="u5386_u53F2_u89C2_u70B9"><a href="#u5386_u53F2_u89C2_u70B9" class="headerlink" title="历史观点"></a>历史观点</h2><p>Intel 处理器系列俗称 x86，经历了一个长期的、不断进化的发展过程。</p>
<h2 id="u7A0B_u5E8F_u7F16_u7801"><a href="#u7A0B_u5E8F_u7F16_u7801" class="headerlink" title="程序编码"></a>程序编码</h2><p>假设一个 C 程序，有两个文件 p1.c 和 p2.c。我们在一台 IA32 机器上，用 Unix 命令行编译这些代码如下：</p>
<pre><code>unix&gt; gcc -O1 -o p p1.c p2.c
</code></pre><p>编译选项 -O1 告诉编译器使用第一级优化。使用更高级别的优化产生的代码会严重改变形式，以至于产生的机器代码和初始源代码之间的关系非常难以理解。实际中，从得到的程序性能方面考虑，第二级优化(-O2)被认为是较好的选择。</p>
<p>实际上 gcc 命令调用了一系列程序，将源代码转化成可执行代码。首先，<strong>C 预处理器</strong>扩展源代码，插入所有用 #include 命令指定的文件，并扩展所有用 #define 声明指定的宏。然后，<strong>编译器</strong>产生两个源代码的汇编代码，名字分别为 p1.s 和 p2.s。接下来，<strong>汇编器</strong>将汇编代码转化成二进制目标代码，文件名为 p1.o 和 p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入地址的全局值。最后，<strong>链接器</strong>将两个目标代码文件与实现库函数(例如 printf )的代码合并，并产生最终的可执行代码文件 p。</p>
<blockquote>
<p>机器级代码</p>
</blockquote>
<p>对于机器级变成来说，有两种抽象非常重要。第一种是机器级程序的格式和行为，定义为指<strong>令集体系结构(Instruction set architecture, ISA)</strong>，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。第二种抽象是，机器级程序使用的存储器地址是虚拟地址，提供的存储器模型看上去是一个非常大的字节数组。</p>
<p>在整个编译过程中，编译器会完成大部分的工作，将把用 C 语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。汇编代码非常接近于机器代码，与机器代码的二进制格式相比，汇编代码有一个主要特点，即它用可读性更好的文本格式来表示。能够理解汇编代码和它与原始的 C 代码的联系，是理解计算机如何执行程序的关键一步。</p>
<p>IA32 机器代码和原始的 C 代码差别非常大。一些通常对 C 语言程序员隐藏的处理器状态是可见的：</p>
<ul>
<li><strong>程序计数器</strong>(PC，用 %eip 表示)指示将要执行的下一条指令在存储器中的地址。</li>
<li>整数<strong>寄存器</strong>文件包含 8 个命名的位置，分别存储 32 位的值。这些寄存器可以存储地址(对应于 C 语言的指针)或证书数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器则用来保存临时数据。</li>
<li>条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化。</li>
<li>一组浮点寄存器存放浮点数据。</li>
</ul>
<p>汇编代码不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分指针和整数。</p>
<p>程序存储器(program memory)包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的存储器块。</p>
<p>一条指令只执行一个非常基本的操作。例如，将存放在寄存器中的两个数字相加，在存储器和寄存器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从而实现(像算术表达式求值、循环或过程调用和返回这样的)程序结构。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>假设我们写了一个 C 语言代码文件 code.c，内容如下：</p>
<pre><code>int accum = 0;

int sum(int x, int y){
    int t = x + y;
    accum += t;
    return t;
}
</code></pre><p>在命令行上使用 <code>-S</code> 选项，就能得到 C 语言编译器产生的汇编代码：</p>
<pre><code>unix&gt; gcc -O1 -S code.c
</code></pre><p>GCC 会运行编译器，产生一个汇编文件 code.s，但是不做其他进一步的工作。如果我们使用 <code>-c</code> 命令行选项，GCC 会编译并汇编该代码：</p>
<pre><code>unix&gt; gcc -O1 -c code.c
</code></pre><p>这就会产生目标代码文件 code.o，它是二进制格式，无法直接查看。机器实际执行的程序只是对一系列指令进行编码的字节序列。及其对产生这些指令的源代码几乎一无所知。</p>
<blockquote>
<p>关于格式的注释</p>
</blockquote>
<p>所有以 <code>.</code> 开头的行都是指导汇编器和链接器的命令，我们通常可以忽略这些行。</p>
<blockquote>
<p>数据格式</p>
</blockquote>
<p>由于是从 16 位体系结构扩展成 32 位的，Intel 用术语 word 表示 16 位数据类型。因此，称 32 位数为 double words，称 64 位数为 quad words。后面遇到的大多数指令都是对 word 或者 double words 操作的。</p>
<p><img src="/images/csapp3.1.jpg" alt="csapp3.1"></p>
<h2 id="u8BBF_u95EE_u4FE1_u606F"><a href="#u8BBF_u95EE_u4FE1_u606F" class="headerlink" title="访问信息"></a>访问信息</h2><p>一个 IA32 CPU 包含一组 8 个存储 32 位值的寄存器。这些寄存器用来存储整数数据和指针。它们的名字都以 %e 开头，不过它们都另有特殊的名字。</p>
<p><img src="/images/csapp3.2.jpg" alt="csapp3.2"></p>
<p>对前三个寄存器(%eax, %ecx, %edx)的保存和恢复惯例不同于接下来的三个寄存器(%ebx, %edi, %esi)。最后两个寄存器(%ebp, %esp)保存着指向程序栈中重要位置的指针。只有根据栈管理的标准惯例才能修改这两个寄存器中的值。</p>
<p>字节操作指令可以独立地读写前 4 个寄存器的 2 个低位字节。8086 中提供这样的特性是为了兼容 8008 和 8080。当一条字节指令更新这些单字节“寄存器元素”中的一个时，余下的 3 个字节不会改变。</p>
<blockquote>
<p>操作数指示符</p>
</blockquote>
<p>大多数指令有一个或多个<strong>操作数(operand)</strong>，指示出执行一个操作中要引用的源数据值，以及放置结果的目标位置。操作数可能被分为三种类型：</p>
<ol>
<li>立即数(immediate)，也就是常数值</li>
<li>寄存器(register)，表示某个寄存器的内容</li>
<li>存储器(memory)引用，它会根据计算出来的地址访问某个存储器位置</li>
</ol>
<p><img src="/images/csapp3.3.jpg" alt="csapp3.3"></p>
<blockquote>
<p>数据传送指令</p>
</blockquote>
<p>将数据从一个位置复制到另一个位置的指令是最频繁使用的指令。操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条指令才能完成的功能。</p>
<p><img src="/images/csapp3.4.jpg" alt="csapp3.4"></p>
<h2 id="u7B97_u672F_u548C_u903B_u8F91_u64CD_u4F5C"><a href="#u7B97_u672F_u548C_u903B_u8F91_u64CD_u4F5C" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h2><p>给出的每个指令类都有对字节、字和双字数据进行操作的指令。这些操作被分为四组：加载有效地址、亿元操作、二元操作和移位。</p>
<blockquote>
<p>加载有效地址</p>
</blockquote>
<p>加载有效地址(load effective address)指令 leal 实际上是 movl 指令的变形。它的指令形式是从存储器读数据到寄存器，但实际上它根本就没有引用存储器。它的第一个操作数看上去是一个存储器引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。</p>
<p><img src="/images/csapp3.7.jpg" alt="csapp3.7"></p>
<blockquote>
<p>一元操作和二元操作</p>
</blockquote>
<p>一元操作：一个操作数既是源又是目的</p>
<p>二元操作：第二个操作数既是源又是目的</p>
<blockquote>
<p>移位操作</p>
</blockquote>
<p>先给出移位量，第二项给出的是要移位的位数，可以进行算术和逻辑右移。</p>
<blockquote>
<p>讨论</p>
</blockquote>
<p><img src="/images/csapp3.8.jpg" alt="csapp3.8"></p>
<blockquote>
<p>特殊的算术操作</p>
</blockquote>
<p><img src="/images/csapp3.9.jpg" alt="csapp3.9"></p>
<h2 id="u63A7_u5236"><a href="#u63A7_u5236" class="headerlink" title="控制"></a>控制</h2><p>机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。</p>
<blockquote>
<p>条件码</p>
</blockquote>
<p>除了整数寄存器，CPU 还维护着一组单个 bit 的<strong>条件码(condition code)</strong> 寄存器，他们描述了最近的算术或逻辑操作的属性。</p>
<p><img src="/images/csapp0.4.jpg" alt="csapp0.4"></p>
<p><img src="/images/csapp3.10.jpg" alt="csapp3.10"></p>
<blockquote>
<p>访问条件码</p>
</blockquote>
<p>条件码通常不会直接读取，常用的使用方法有三种：</p>
<ol>
<li>可以根据条件码的某个组合，将一个字节设置为 0 或者 1</li>
<li>可以条件跳转到程序的某个其他的部分</li>
<li>可以有条件地传送数据</li>
</ol>
<p><img src="/images/csapp3.11.jpg" alt="csapp3.11"></p>
<blockquote>
<p>跳转指令及其编码</p>
</blockquote>
<p>跳转(jump)指令会导致执行切换到程序中的一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号(label)指明。</p>
<p><img src="/images/csapp3.12.jpg" alt="csapp3.12"></p>
<blockquote>
<p>翻译条件分支</p>
</blockquote>
<p>将条件表达式和语句从 C 语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转</p>
<p><img src="/images/csapp3.13.jpg" alt="csapp3.13"></p>
<blockquote>
<p>循环</p>
</blockquote>
<p>汇编中没有循环结构的指令存在，可以用条件测试和跳转组合起来实现循环的效果。大多数汇编器根据一个循环的 do-while形式来产生循环代码，即使在实际程序中这种形式用得相对较少。</p>
<p><img src="/images/csapp3.14.jpg" alt="csapp3.14"></p>
<p><img src="/images/csapp3.15.jpg" alt="csapp3.15"></p>
<blockquote>
<p>条件传送指令</p>
</blockquote>
<p>实现条件操作的传统方法是利用控制的条件转移。当条件满足时，程序沿着一条执行路径进行，反之走另一条路径。这种机制简单而通用，但是在现代处理器上，它可能会非常低效率。</p>
<p>数据的条件转移是一种替代的策略。这种方法先计算一个条件操作的两种结果，然后再根据条件是否满足从而选取一个。只有在一些受限制的情况下，这种策略才可行，但是如果可行，就可以用一条简单的条件传送指令来实现它。条件传送指令更好地匹配了现代处理器的性能特征。</p>
<p><img src="/images/csapp3.16.jpg" alt="csapp3.16"></p>
<p>这个机制和分支预测紧密相关。</p>
<p><img src="/images/csapp3.17.jpg" alt="csapp3.17"></p>
<blockquote>
<p>switch 语句</p>
</blockquote>
<p>switch 语句可以根据一个整数索引值进行多重分支(multi-way branching)。不仅提高了 C 代码的可读性，而且通过使用<strong>跳转表(jump table)</strong>和使用一组很长的 if-else 语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。GCC 根据开关情况的数量和开关情况值的 sprsity 来翻译开关语句。</p>
<p><img src="/images/csapp3.18.jpg" alt="csapp3.18"></p>
<h2 id="u8FC7_u7A0B"><a href="#u8FC7_u7A0B" class="headerlink" title="过程"></a>过程</h2><p>一个过程调用包括将数据和控制从代码的一部分传递到另一部分。另外，它还必须在进入时为过程的局部变量分配空间，并在退出时释放这些空间。大多数机器，包括 IA32，只提供转移控制到过程和从过程转移出控制这种简单的指令。数据传递、局部变量的分配和释放通过操纵程序栈来实现。</p>
<blockquote>
<p>栈帧结构</p>
</blockquote>
<p>IA32 程序用程序栈来支持过程调用。机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后回复，以及本地存储。为单个过程分配的那部分栈称为<strong>栈帧(stack frame)</strong>。</p>
<p><img src="/images/csapp3.21.jpg" alt="csapp3.21"></p>
<p>假设过程 P(调用者)调用过程 Q(被调用者)，则 Q 的参数放在 P 的栈帧中。另外，当 P 调用 Q 时，P 中的<strong>返回地址</strong>被压入栈中，形成 P 的栈帧的末尾。返回地址就是当程序从 Q 返回时应该继续执行的地方。</p>
<blockquote>
<p>转移控制</p>
</blockquote>
<p><img src="/images/csapp3.22.jpg" alt="csapp3.22"></p>
<blockquote>
<p>寄存器使用惯例</p>
</blockquote>
<p>程序寄存器组是唯一能够被所有过程共享的资源。虽然在给定时刻只能有一个过程是活动的，但是我们必须保证当一个过程调用另一个过程时，被调用者不会覆盖某个调用者稍后会使用的寄存器的值。</p>
<p>根据惯例，寄存器 %eax、%edx、%ecx 被划分为<strong>调用者保存</strong>寄存器。当过程 P 调用 Q 时，Q 可以覆盖这些寄存器，而不会破坏任何 P 所需要的数据。另一方面， 寄存器 %ebx、%esi、%edi 被划分为<strong>被调用者保存</strong>寄存器。</p>
<blockquote>
<p>过程示例</p>
</blockquote>
<p><img src="/images/csapp3.24.jpg" alt="csapp3.24"></p>
<blockquote>
<p>递归过程</p>
</blockquote>
<p><img src="/images/csapp3.25.jpg" alt="csapp3.25"></p>
<p><img src="/images/csapp3.27.jpg" alt="csapp3.27"></p>
<h2 id="u6570_u7EC4_u5206_u914D_u548C_u8BBF_u95EE"><a href="#u6570_u7EC4_u5206_u914D_u548C_u8BBF_u95EE" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h2><p>C 语言实现数组的方式非常简单，因此很容易翻译成机器代码。C 语言一个不同寻常的特点是可以产生指向数组中元素的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译成地址计算。</p>
<p>优化编译器非常善于简化数组索引所使用的地址计算。不过这使得 C 代码和它机器代码的翻译之间的对应关系有些难以理解。</p>
<blockquote>
<p>基本原则</p>
</blockquote>
<p>对于数据类型 T 和整型常数 N，声明如下：</p>
<pre><code>T A[N];
</code></pre><p>它有两个效果。首先，它在存储器中分配一个 L*N 字节的连续区域；这里 L 是数据类型 T 的大小(单位为字节)。可以用从 0 到 N-1 之间的整数索引来访问数组元素。数组元素 i 会被存放在地址为 xa + L * i 的地方(xa 为指向数组开头的指针)</p>
<p><img src="/images/csapp0.5.jpg" alt="csapp0.5"></p>
<blockquote>
<p>指针运算</p>
</blockquote>
<p>C 语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。也就是说，如果 p 是一个指向类型为 T 的数据的指针，p 的值为 xp，那么表达式 p+i 的值为 xp+L*i，这里 L 是数据类型 T 的大小。</p>
<p><img src="/images/csapp0.6.jpg" alt="csapp0.6"></p>
<blockquote>
<p>嵌套的数组</p>
</blockquote>
<pre><code>int A[5][3];
</code></pre><p>等价于下面的声明</p>
<pre><code>typedef int row3_t[3];
row3_t A[5];
</code></pre><p>数据类型<code>row3_t</code>被定义为一个 3 个整数的数组。数组 A 包含 5 个这样的元素，每个元素需要 12 个字节来存储 3 个整数。整个数组的大小就是 4x5x3=60 字节。</p>
<p><img src="/images/csapp0.7.jpg" alt="csapp0.7"></p>
<blockquote>
<p>定长数组</p>
</blockquote>
<p>C 语言编译器能够优化定长多维数组上的操作代码。</p>
<p><img src="/images/csapp3.28.jpg" alt="csapp3.28"></p>
<blockquote>
<p>变长数组</p>
</blockquote>
<p><img src="/images/csapp3.29.jpg" alt="csapp3.29"></p>
<h2 id="u5F02_u8D28_u7684_u6570_u636E_u7ED3_u6784"><a href="#u5F02_u8D28_u7684_u6570_u636E_u7ED3_u6784" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h2><p>C 语言提供了两种结合不同类型的对象来创建数据类型的机制：<strong>结构(structure)</strong>，用关键字<code>struct</code>声明，将多个对象集合到一个单位中；<strong>联合(union)</strong>，用关键字<code>union</code>声明，允许用几种不同的类型来引用一个对象。</p>
<blockquote>
<p>结构</p>
</blockquote>
<p>创建一个数据类型，将可能不同类型的对象聚合到一个对象中。结构的各个组成部分用名字来引用。类似于数组的实现，结构的所有组成部分都存放在存储器中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段(field)的字节偏移。它以这些偏移作为存储器引用指令中的位移，从而产生对结构元素的引用。</p>
<blockquote>
<p>联合</p>
</blockquote>
<p>提供了一种方式，能够规避 C 语言的类型系统，允许以多种类型来引用一个对象。联合声明的语法与结构的语法一样，只不过语义相差比较大。它们是用不同的字段来引用相同的存储器块。</p>
<blockquote>
<p>数据对齐</p>
</blockquote>
<p>许多计算机系统对基本数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是某个值 K(通常是 2、4、8)。这种对齐限制简化了形成处理器和存储器系统之间接口的硬件设计</p>
<p><strong>强制对齐的情况</strong></p>
<p>对于大多数 IA32 指令来说，保持数据对齐能够提高效率，但是它不会影响程序的行为。另一方面，如果数据未对齐，有些实现多媒体操作的 SSE 指令就无法正确工作。</p>
<h2 id="u7EFC_u5408_uFF1A_u7406_u89E3_u6307_u9488"><a href="#u7EFC_u5408_uFF1A_u7406_u89E3_u6307_u9488" class="headerlink" title="综合：理解指针"></a>综合：理解指针</h2><p>指针是 C 语言的一个重要特征。它们以一种统一方式，对不同数据结构中的元素产生引用。这里介绍一些指针和它们映射到机器代码的关键原则。</p>
<ul>
<li><strong>每个指针都对应一个类型。</strong>这个类型表明指针指向哪一类对象。</li>
<li><strong>每个指针都有一个值。</strong>这个值是某个指定类型对象的地址。特殊的 NULL(0) 值表示该指针没有指向任何地方</li>
<li><strong>指针用 &amp; 运算符创建。</strong>这个运算符可以应用到任何 lvalue 类的 C 表达式上。</li>
<li><strong>操作符用于指针的间接引用。</strong>其结果是一个值，它的类型与该指针的类型相关。间接引用是通过存储器引用来实现的，要么是存储到一个指定的地址，要么是从指定的地址读取。</li>
<li><strong>数组与指针紧密联系。</strong>一个数组的名字可以像一个指针变量一样引用(但是不能修改)。数组引用与指针运算和间接引用有一样的效果。数组引用和指针运算都需要用对象大小对偏移量进行伸缩。</li>
<li><strong>将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。</strong>强制类型转换的一个效果是改变指针运算的伸缩。来看一个例子，如果 p 是一个 char* 类型的指针，那么表达式(int<em>)p+7 计算为 p+28, 而(int</em>)(p+7)计算为 p+7。</li>
<li>指针也可以指向函数。这提供了一个很强大的存储和向代码传递引用的功能，这些引用可以被程序的某个其他部分调用。</li>
</ul>
<p><strong>函数指针</strong></p>
<p>假如我们有一个函数<code>int fun(int x, int *p)</code>，然后我们可以声明一个指针<code>fp</code>，将它赋值为这个函数：</p>
<pre><code>(int)(*fp)(int, int *);
fp = fun;
</code></pre><p>然后用以下真真来调用这个函数</p>
<pre><code>int y = 1;
int result = fp(3, &amp;y);
</code></pre><h2 id="u5E94_u7528_uFF1A_u4F7F_u7528_GDB__u8C03_u8BD5_u5668"><a href="#u5E94_u7528_uFF1A_u4F7F_u7528_GDB__u8C03_u8BD5_u5668" class="headerlink" title="应用：使用 GDB 调试器"></a>应用：使用 GDB 调试器</h2><p>启动 GDB:</p>
<pre><code>unix&gt; gdb prog
</code></pre><h2 id="u5B58_u50A8_u5668_u7684_u8D8A_u754C_u5F15_u7528_u548C_u7F13_u51B2_u533A_u6EA2_u51FA"><a href="#u5B58_u50A8_u5668_u7684_u8D8A_u754C_u5F15_u7528_u548C_u7F13_u51B2_u533A_u6EA2_u51FA" class="headerlink" title="存储器的越界引用和缓冲区溢出"></a>存储器的越界引用和缓冲区溢出</h2><p>C 对于数组引用不进行任何边界检查，而局部变量和状态信息，都存放在栈中。这两种情况结合到一起就可能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行 ret 指令时，就会出现很严重的错误。</p>
<p>缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击系统安全的方法。通常，输入和程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为**攻击代码(exploit code)，另外还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么执行 ret 指令的效果就是跳转到攻击代码。</p>
<p>一种攻击形式，攻击代码会使用系统调用启动一个外壳程序，给攻击者提供一组操作系统函数。另一种攻击形式是，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行 ret 指令，(表面上)正常返回给调用者。</p>
<p><strong>对抗缓冲区溢出攻击</strong></p>
<p>1.<strong>栈随机化</strong></p>
<p>为了在系统中插入攻击代码，攻击者不但要插入代码，还需要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。在过去，程序的栈地址非常容易预测。对于所有运行同样程序和操作系统版本的系统来说，在不同的机器之间，栈的位置是相当固定的。用传染病来打比方，许多系统都容易受到同一种病毒的攻击，这种现象常称作<strong>安全单一化(security monoculture)</strong>。</p>
<p><strong>栈随机化</strong>的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。实现的方式是：程序开始时，在栈上分配一段 0-n 字节之间的随机大小的空间。</p>
<p>在 Linux 系统中，栈随机化已经变成了标准行为。它是更大一类技术中的一种，这类技术称为**地址空间布局随机化(Address-Space Layout Randomization)，或者简称 ASLR。</p>
<p>然而一个执着的攻击者总是能够用蛮力克服随机化，他可以反复地用不同的地址进行攻击。一种常见的把戏就是在实际的攻击代码前插入很长一段的 nop 指令。执行这种指令除了对程序计数器加一，使指针指向下一条指令之外，没有任何的效果。只要攻击者能够猜中这段序列中的某个地址，程序就会经过这个序列，到达攻击代码。这个序列常用的术语是“空操作雪橇”(nop sled)。</p>
<p>2.<strong>栈破坏检测</strong></p>
<p><strong>栈保护者(stack protector)</strong>机制，用来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的<strong>金丝雀(canary)</strong>值，也称为<strong>哨兵值(guard value)</strong>，如下图所示。这个值是在程序每次运行时随机产生的，因此，攻击者没有简单的办法能够知道它是什么。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个函数的某个操作改变了。如果是，那么程序异常终止。</p>
<p>3.限制可执行代码区域</p>
<p>消除攻击者向系统中插入可执行代码的能力，只有保存编译器产生的代码的那部分妇女初期才是可执行的，其他部分可以被限制为只允许读和写</p>
<p><img src="/images/csapp3.33.jpg" alt="csapp3.33"></p>
<h2 id="x86-64_3A__u5C06_IA32__u6269_u5C55_u5230_64__u4F4D"><a href="#x86-64_3A__u5C06_IA32__u6269_u5C55_u5230_64__u4F4D" class="headerlink" title="x86-64: 将 IA32 扩展到 64 位"></a>x86-64: 将 IA32 扩展到 64 位</h2><p>IA32 的 32 位字长已经成为限制微处理器能力不断增长的主要因素。最重要的是，机器的字长定义了程序能够使用的虚拟地址范围，32 位字长就是 4GB 虚拟地址空间。现在机器很容易就可以配置 4G 以上 RAM，但是系统却不能有效利用它。</p>
<p>Intel 和 AMD 提供的新硬件和以这些为目标的 GCC 新版本的组合，使得 x86-64 代码与为 IA32 机器生成的代码有极大的不同。主要特性如下：</p>
<ul>
<li>指针和长整数是 64 位长。整数运算支持 8/16/32/64 位数据类型</li>
<li>通用目的寄存器组从 8 个扩展到 16 个</li>
<li>许多程序状态都保存在寄存器中，而不是栈上</li>
<li>如果可能，条件操作用条件传送指令实现，会得到比传统分支代码更好的性能</li>
<li>浮点操作用面向寄存器的指令集来实现</li>
</ul>
<p><img src="/images/csapp3.34.jpg" alt="csapp3.34"></p>
<h2 id="u6D6E_u70B9_u7A0B_u5E8F_u7684_u673A_u5668_u7EA7_u8868_u793A"><a href="#u6D6E_u70B9_u7A0B_u5E8F_u7684_u673A_u5668_u7EA7_u8868_u793A" class="headerlink" title="浮点程序的机器级表示"></a>浮点程序的机器级表示</h2><p>我们把存储模型、指令和传递规则的组合称为机器的<strong>浮点体系结构</strong>。由于 x86 处理器有很长的发展演变历史，它提供了多种浮点体系结构，目前有两种还在使用：x87 和 SSE</p>
<h2 id="u5C0F_u7ED3-1"><a href="#u5C0F_u7ED3-1" class="headerlink" title="小结"></a>小结</h2><p>机器级程序和它们的汇编代码表示，与 C 程序的差别很大。在汇编语言程序中，各种数据类型之间的差别很小。程序是以指令序列来表示的，每条指令都完成一个单独的操作。部分程序状态，如寄存器和运行时栈，对程序员来说是直接可见的。</p>
<p>C 语言中缺乏边界检查，使得许多程序容易出现缓冲区溢出。虽然最近的运行时系统提供了安全保护，而且编译器帮助使得程序更加安全，但是这已经使许多系统容易收到入侵者的恶意攻击。</p>
<h1 id="u5904_u7406_u5668_u4F53_u7CFB_u7ED3_u6784"><a href="#u5904_u7406_u5668_u4F53_u7CFB_u7ED3_u6784" class="headerlink" title="处理器体系结构"></a>处理器体系结构</h1><p>现代微处理器可以称得上时人类创造的最复杂的系统之一。一个处理器支持的指令和指令的字节级编码称为它的<strong>指令集体系结构(Instruction-Set Architecture, ISA)</strong>。不同的处理器家族，有不同的 ISA。一个程序编译成在一种机器上运行。</p>
<p>注：这一章偏硬件实现部分将较为简略，具体参看原书。</p>
<h2 id="Y86__u6307_u4EE4_u96C6_u4F53_u7CFB_u7ED3_u6784"><a href="#Y86__u6307_u4EE4_u96C6_u4F53_u7CFB_u7ED3_u6784" class="headerlink" title="Y86 指令集体系结构"></a>Y86 指令集体系结构</h2><p>定义一个指令集体系结构，包括定义各种状态元素、指令集和它们的编码、一组编程规范和异常事件处理。</p>
<blockquote>
<p>程序员可见的状态</p>
</blockquote>
<p>如下图所示，Y86 程序中的每条指令都会读取或修改处理器状态的某些部分，这称为<strong>程序员可见状态</strong>。在处理器视线中，只要我们保证机器级程序能够访问程序员可见状态，就不需要完全按照 ISA 隐含的方式来表示和组织这个处理器状态。</p>
<p><img src="/images/csapp4.1.jpg" alt="csapp4.1"></p>
<p>Y86 处理器有 8 个程序寄存器(每个存储一个字，%esp 被入栈、出栈、调用和返回指令作为栈指针)，3 个一位的条件码(保存最近的算术或逻辑指令所造成影响的有关信息)，程序计数器 PC 存放当前正在执行指令的地址。</p>
<p>存储器，从概念上说就是一个很大的数组，保存这程序和数据。 Y86 程序使用<strong>虚拟地址</strong>来引用存储器位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或<strong>物理地址</strong>，指明数据实际保存在存储器中的哪个地方。</p>
<p>状态码 Stat 表明程序执行的总体状态，它会指示是正常运行，还是出现了某种异常。</p>
<blockquote>
<p>Y86 指令</p>
</blockquote>
<p><img src="/images/csapp4.2.jpg" alt="csapp4.2"></p>
<p>具体说明</p>
<ul>
<li>4 个 movl 相关指令，显式指明源和目的的格式。源可以是立即数(i)、寄存器(r)或存储器(m)。指令名字的第一个字母表明了源的类型，第二个字母指明了目的类型</li>
<li>4 个整数操作指令，即上图的 OPl，它们是 addl、subl、andl 和 xorl。它们只对寄存器数据进行操作，并设置 3 个条件码 ZF、SF 和 OF(零、符号和一处)</li>
<li>7 个跳转指令，即上图的 jXX，它们是 jmp、jle、jl、je、jne、jge 和 jg。根据分支指令的类型和条件码的设置来选择分支</li>
<li>6 个条件传送指令，即上图的 cmovXX：cmovle、cmovl、cmove、cmovne、cmovge 和 cmovg，只有当条件码满足所需要的约束时，才会更新目的寄存器的值</li>
<li>call 指令将返回地址入栈，然后跳到目的地址。ret 指令从这样的过程调用中返回</li>
<li>pushl 和 popl 指令实现了入栈和出栈</li>
<li>halt 指令停止指令的执行</li>
</ul>
<blockquote>
<p>指令编码</p>
</blockquote>
<p>每条指令需要 1~6 个字节不等，每条指令的第一个字节表明指令的类型。这个字节分为两个部分，每部分 4 位：高 4 位是<strong>代码(code)</strong>部分，低 4 位是<strong>功能(function)部分</strong>。</p>
<p><img src="/images/csapp4.3.jpg" alt="csapp4.3"></p>
<p>CISC vs RISC</p>
<p><img src="/images/csapp0.8.jpg" alt="csapp0.8"></p>
<h2 id="u903B_u8F91_u8BBE_u8BA1_u548C_u786C_u4EF6_u63A7_u5236_u8BED_u8A00_HCL"><a href="#u903B_u8F91_u8BBE_u8BA1_u548C_u786C_u4EF6_u63A7_u5236_u8BED_u8A00_HCL" class="headerlink" title="逻辑设计和硬件控制语言 HCL"></a>逻辑设计和硬件控制语言 HCL</h2><p>在硬件设计中，用电子电路来计算来计算对位进行运算的函数，以及在各种存储器元素中存储位。大多数现代电路技术都用信号线上的高电压或低电压来表示不同的位值。</p>
<blockquote>
<p>逻辑门</p>
</blockquote>
<p>逻辑门是数字电路的基本计算元素。它们产生的输出，等于它们输入位值的某个布尔函数。</p>
<blockquote>
<p>组合电路和 HCL 布尔表达式</p>
</blockquote>
<p>将很多的逻辑门组合成一个网，就能构建计算块(computational block)，称为<strong>组合电路(combinational circuits)</strong>。构建这些网有两条限制：</p>
<ul>
<li>两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障</li>
<li>这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的回路会导致该网络计算的函数有歧义。</li>
</ul>
<blockquote>
<p>字级的组合电路和 HCL 整数表达式</p>
</blockquote>
<p>通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。</p>
<h2 id="Y86__u7684_u987A_u5E8F_u5B9E_u73B0"><a href="#Y86__u7684_u987A_u5E8F_u5B9E_u73B0" class="headerlink" title="Y86 的顺序实现"></a>Y86 的顺序实现</h2><p>将处理组织成阶段</p>
<p>取指(fetch)、译码(decode)、执行(execute)、访存(memory)、写回(write back)、更新 PC(PC update)</p>
<h2 id="u6D41_u6C34_u7EBF_u7684_u901A_u7528_u539F_u7406"><a href="#u6D41_u6C34_u7EBF_u7684_u901A_u7528_u539F_u7406" class="headerlink" title="流水线的通用原理"></a>流水线的通用原理</h2><p>参考 Foundation of Computer Architecture，此略</p>
<h2 id="u5C0F_u7ED3-2"><a href="#u5C0F_u7ED3-2" class="headerlink" title="小结"></a>小结</h2><p>有关处理器设计的几个重要经验：</p>
<ul>
<li>管理复杂性是首要问题。想要优化使用硬件资源，在最小的成本下获得最大的性能</li>
<li>我们不需要直接实现 ISA</li>
<li>硬件设计人员必须非常谨慎小心</li>
</ul>
<h1 id="u4F18_u5316_u7A0B_u5E8F_u6027_u80FD"><a href="#u4F18_u5316_u7A0B_u5E8F_u6027_u80FD" class="headerlink" title="优化程序性能"></a>优化程序性能</h1><blockquote>
<p>你能获得的对程序最大的加速比就是当你第一次让它工作起来的时候。 —— John K.Ousterhout</p>
</blockquote>
<p>写程序最主要的目标就是使它在所有可能的情况下都正确工作。程序员必须写出清晰简洁的代码，这样做不仅是为了程序员能够看懂代码，也是为了在检查代码和今后需要修改代码时，其他人能够读懂和理解代码。</p>
<p>编写高效程序需要几类活动：第一，我们必须选择一组合适的算法和数据结构。第二，我们必须编写出编译器能够有效优化以转换成搞笑可执行代码的源代码。对于第二点，理解优化编译器的能力和局限性是很重要的。</p>
<p>在程序开发和优化的过程中，我们必须考虑代码使用的方式，以及影响它的关键因素。通常，程序员必须在实现和维护程序的简单性与它的运行速度之间做出权衡。</p>
<p>程序优化的第一步就是消除不必要的内容，让代码尽可能有效地执行它期望的工作。这包括消除不必要的函数调用、条件测试和存储器引用。这些优化不依赖于目标机器的任何具体属性。</p>
<p>研究程序的汇编代码表示，是理解编译器，以及产生的代码如何运行的最有效的手段之一。仔细研究内循环的代码是一个很好的开端。</p>
<h2 id="u4F18_u5316_u7F16_u8BD1_u5668_u7684_u80FD_u529B_u548C_u5C40_u9650_u6027"><a href="#u4F18_u5316_u7F16_u8BD1_u5668_u7684_u80FD_u529B_u548C_u5C40_u9650_u6027" class="headerlink" title="优化编译器的能力和局限性"></a>优化编译器的能力和局限性</h2><p>现代编译器运用复杂精细的算法来确定一个程序中计算的是什么值，以及它们是被如何使用的。然后它们会利用一些机会来简化表达式，在几个不同的地方使用同一个计算，以及降低一个给定的计算必须被执行的次数。</p>
<p>限制编译器只进行安全的优化，消除了一些造成不希望的运行时行为的可能原因，但这也意味着程序员必须花费更大的力气写出程序使编译器能够将之转换成有效机器代码。请看下面这个例子</p>
<pre><code>void twiddle1(int *xp, int *yp){
    *xp += *yp;
    *xp += *yp;
}

void twiddle2(int *xp, int *yp){
    *xp += 2* *yp
}
</code></pre><p>初看这两个函数似乎有相同的行为，都是将存储在由指针 yp 指示的位置除的值两次加到指针 xp 指示的位置处的值。另一方面，函数 twiddle2 的效率更高一些，它只要求 3 次存储器引用(读 <code>*xp</code>，读 <code>*yp</code>，写 <code>*xp</code>)，而 twiddle1 需要 6 次。不过，当 xp 等于 yp 时，这两个函数的执行结果则会不一致，twiddle1 使 xp 的值增加 4 倍，而 twiddle2 则是 3 倍，因此，编译器不能产生 twiddle2 风格的代码作为 twiddle1 的优化版本。</p>
<p>这种两个指针可能指向同一个存储器位置的情况称为<strong>存储器别名使用(memory aliasing)</strong>。在只执行安全的优化中，编译器必须假设不同的指针可能会指向存储器中同一个位置。</p>
<p>第二个妨碍优化的因素是函数调用，例如：</p>
<pre><code>int f();

int func1(){
    return f() + f() + f() + f();
}

int func2(){
    return 4*f();
}
</code></pre><p>最初看上去两个过程计算都是相同的结果，但是 func2 只调用 f1 一次，比 func2 的四次要好。不过，考虑下面 f 的代码：</p>
<pre><code>int counter = 0;

int f(){
    return counter++;
}
</code></pre><p>这个函数有个副作用——它修改了全局程序状态的一部分。改变调用它的次数会改变程序的行为。所以，编译器会假设最早的情况，并保持所有函数调用不变。</p>
<h2 id="u8868_u793A_u7A0B_u5E8F_u6027_u80FD"><a href="#u8868_u793A_u7A0B_u5E8F_u6027_u80FD" class="headerlink" title="表示程序性能"></a>表示程序性能</h2><p>我们引入度量标准<strong>每元素的周期数(Cycles Per Element, CPE)</strong>作为一种表示性能并指导我们改进代码的方法。处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用<strong>千兆赫兹(GHz)</strong>，即十亿周期每秒来表示。CPE 越小越好。</p>
<p>许多过程含有在一组元素上迭代的循环。如下图中的函数 psum1 和 psum2 计算都是一个长度为 n 的向量的前置和(prefix sum)，对于向量 a={a0,a1,…,an-1}，前置和 p={p0,p1,…pn-1}定义为</p>
<pre><code>p0 = a0
pi = pi-1 + ai, 1&lt;= i &lt; n
</code></pre><p>函数 psum1 每次迭代计算结果向量的一个元素，第二个函数使用<strong>循环展开(loop unrolling)</strong>的技术，每次迭代计算两个元素。</p>
<p><img src="/images/csapp5.1.jpg" alt="csapp5.1"></p>
<p>我们发现，psum1 和 psum2 的运行时间(以时钟周期为单位)分辨近似于等式 496+10.0n 和 500+6.5n。</p>
<p><img src="/images/csapp5.2.jpg" alt="csapp5.2"></p>
<h2 id="u7A0B_u5E8F_u793A_u4F8B"><a href="#u7A0B_u5E8F_u793A_u4F8B" class="headerlink" title="程序示例"></a>程序示例</h2><p>考虑如下图所示的简单向量数据结构，由两个存储器块表示：头部和数据数组。头部是一个声明如下的结构</p>
<p><img src="/images/csapp5.3.jpg" alt="csapp5.3"></p>
<p>这个声明用数据类型 data_t 作为基本元素的数据类型。例如 <code>typedef int data_t</code>。</p>
<p><img src="/images/csapp5.4.jpg" alt="csapp5.4"></p>
<p>对向量元素求和</p>
<pre><code>#define IDENT 0
#define OP +
</code></pre><p>对向量元素求积</p>
<pre><code>#define IDENT 1
#define OP *
</code></pre><p><img src="/images/csapp5.5.jpg" alt="csapp5.5"></p>
<p>我们会进行一组变换，发现有很多智能带来很小的性能提高，而其他的能带来更巨大的效果。确定该使用哪些变换的组合确实是编写快速代码的魔术(black art)。</p>
<p>未经优化的代码是从 C 语言代码到机器代码的直接翻译，通常有明显的低效率。简单地使用命令行选项 <code>-O1</code>，就会进行一些基本的优化，可以显著提高性能。</p>
<h2 id="u6D88_u9664_u5FAA_u73AF_u7684_u4F4E_u6548_u7387"><a href="#u6D88_u9664_u5FAA_u73AF_u7684_u4F4E_u6548_u7387" class="headerlink" title="消除循环的低效率"></a>消除循环的低效率</h2><p>可以观察到，过程 combine1 调用函数 <code>vec_length</code> 作为 for 循环的测试条件。我们其实可以只计算一次向量的长度，然后在我们的测试条件中都使用这个值。如下图所示：</p>
<p><img src="/images/csapp5.6.jpg" alt="csapp5.6"></p>
<p>这个优化是一类常见的优化的一个例子，称为<strong>代码移动(code motion)</strong>。这类优化包括识别要执行多次(例如在循环里)但是计算结果不会改变的计算。因而可以将计算移动到代码前面不会被多次求值的部分。</p>
<p>编程时一个常见的问题就是一个看上去无足轻重的代码片段有隐藏的渐进低效率(asymptotic inefficiency)</p>
<h2 id="u51CF_u5C11_u8FC7_u7A0B_u8C03_u7528"><a href="#u51CF_u5C11_u8FC7_u7A0B_u8C03_u7528" class="headerlink" title="减少过程调用"></a>减少过程调用</h2><p>过程调用会代码相当大的开销，而且妨碍大多数形式的程序优化。从上图可以看出，每次循环迭代都会调用 <code>get_vec_element</code> 来获取下一个向量元素。我们可以直接访问数组，而不是利用函数调用并加上边界检查：</p>
<p><img src="/images/csapp5.9.jpg" alt="csapp5.9"></p>
<h2 id="u6D88_u9664_u4E0D_u5FC5_u8981_u7684_u5B58_u50A8_u5668_u5F15_u7528"><a href="#u6D88_u9664_u4E0D_u5FC5_u8981_u7684_u5B58_u50A8_u5668_u5F15_u7528" class="headerlink" title="消除不必要的存储器引用"></a>消除不必要的存储器引用</h2><p>累加过程中其实没有必要每次都把结果写入到 dest 中，可以使用一个临时变量，消除不必要的存储器引用：</p>
<p><img src="/images/csapp5.10.jpg" alt="csapp5.10"></p>
<h2 id="u7406_u89E3_u73B0_u4EE3_u5904_u7406_u5668"><a href="#u7406_u89E3_u73B0_u4EE3_u5904_u7406_u5668" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h2><p>要想获得充分提高的性能，需要仔细地分析程序，同时代码的生成也要针对目标处理器进行调整。由于可以将大量的晶体管继承到一块新品啊上，现代微处理器采用了复杂的硬件，试图使程序性能最大化。带来的一个后果就是处理器的实际操作与观察机器级程序锁察觉到的大相径庭。在代码级上，看上去似乎是一次执行一条指令，每条指令都包括从寄存器或存储器取值，执行一个操作，并把结果存回到一个寄存器或存储器位置。在实际的处理器中，是同时对多条指令求值，这个现象称为<strong>指令级并行</strong>。现代微处理器取得的了不起的功绩之一是：它们采用复杂而奇异的微处理器结构，其中，多条指令可以并行地执行，同时又呈现一种简单地顺序执行指令的表象。</p>
<p>两种下界描述了程序的最大性能。当一系列操作必须按照严格顺序执行时，就会遇到<strong>延迟界限(latency bound)</strong>，因为在下一条指令开始之前，这条指令必须结束。当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限定程序性能。<strong>吞吐量界限(throughput bound)</strong>刻画了处理器功能单元的原始计算能力。这个界限是程序性能的终极限制。</p>
<blockquote>
<p>整体操作</p>
</blockquote>
<p>Nehalem 微体系结构是 20 世纪 90 年代以来，许多制造商生产的典型的高端处理器。在工业界称为超标量(superscalar)，意思是可以在每个时钟周期执行多个操作，而且是乱序的(out-of-order)，意思就是指令执行的顺序不一定要与它们在机器级程序中的顺序一致。整个设计有两个主要部分：指令控制单元(Instruction Control Unit, ICU)和执行单元(Execution Unit, EU)。前者负责从存储器中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作；而后执行这些操作。</p>
<p>ICU 从指令高速缓存(instruction cache)中读取指令。指令高速缓存是一个特殊的高速缓存存储器，它包含最近访问的指令。通常，ICU 会在当前正在的指令很早之前取指，这样它才有足够的时间对指令译码，并把操作发送到 EU。不过，一个问题是党程序遇到分支时，程序有两个可能的前进方向。一种可能会选择分支，控制被传递到分支目标。另一种可能是，不选择分支，控制被传递到指令序列的下一条指令。现代处理器采用了一种称为<strong>分支预测(branch prediction)</strong>的技术<strong>，处理区会猜测是否会选择分支，同时还预测分支的目标地址。使用</strong>投机执行(speculative execution)**的技术，处理器会开始取出位于它预测的分支会跳到的地方的指令，并对指令译码，甚至在它确定分支预测是否正确之前就开始执行这些操作。如果过后确定分支预测错误，会将状态重新设置到分支点的状态，并开始取出和执行另一个方向上的指令。</p>
<blockquote>
<p>功能单元的特性</p>
</blockquote>
<p>每个运算都是由两个周期计数值来刻画的：一个是延迟(latency)，它表示完成运算所需要的总时间；另一个是发射时间(issue time)，它表示两个连续的同类型运算之间需要的最小时钟周期数。随着字长的增加，对于更复杂的数据类型，对于更复杂的运算，延迟也会增加。</p>
<blockquote>
<p>处理器操作的抽象模型</p>
</blockquote>
<p>我们会使用程序的数据流(data-flow)表示，作为分析在现代处理器上执行的机器级程序性能的一个工具，这是一种图形化的表示方法，展现了不同操作之间的数据相关是如何限制它们的执行顺序的。这种限制形成了图中的<strong>关键路径(critical path)</strong>，这是执行一组机器指令所需时钟周期数的一个下界。</p>
<h2 id="u5FAA_u73AF_u5C55_u5F00"><a href="#u5FAA_u73AF_u5C55_u5F00" class="headerlink" title="循环展开"></a>循环展开</h2><p>循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。循环展开能够从两个方面改善程序的性能。首先，它减少了不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支。其次，它提供了一些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。</p>
<h2 id="u63D0_u9AD8_u5E76_u884C_u6027"><a href="#u63D0_u9AD8_u5E76_u884C_u6027" class="headerlink" title="提高并行性"></a>提高并行性</h2><p>对于一个可结合和可交互的合并运算来说，比如说整数加法或乘法，我们可以通过将一组合并运算分割成两个或更多的部分，并在最后合并结果来提高性能。</p>
<h2 id="u4E00_u4E9B_u9650_u5236_u56E0_u7D20"><a href="#u4E00_u4E9B_u9650_u5236_u56E0_u7D20" class="headerlink" title="一些限制因素"></a>一些限制因素</h2><ul>
<li>寄存器溢出</li>
<li>分支预测和预测错误处罚</li>
</ul>
<p>通用原则：</p>
<ul>
<li>不要过分关心可预测的分支</li>
<li>书写适合用条件传送实现的代码</li>
</ul>
<p><img src="/images/csapp0.9.jpg" alt="csapp0.9"></p>
<h2 id="u7406_u89E3_u5B58_u50A8_u5668_u6027_u80FD"><a href="#u7406_u89E3_u5B58_u50A8_u5668_u6027_u80FD" class="headerlink" title="理解存储器性能"></a>理解存储器性能</h2><p>现代处理器有专门的功能单元来执行加载和存储操作，这些单元有内部的缓冲区来保存未完成的存储器操作请求集合。</p>
<blockquote>
<p>加载的性能</p>
</blockquote>
<p>一个包含加载操作的程序的性能既依赖于流水线的能力，也依赖于加载单元的延迟</p>
<blockquote>
<p>存储的性能</p>
</blockquote>
<p>存储操作将一个寄存器值写到存储器。</p>
<h2 id="u5E94_u7528_uFF1A_u6027_u80FD_u63D0_u9AD8_u6280_u672F"><a href="#u5E94_u7528_uFF1A_u6027_u80FD_u63D0_u9AD8_u6280_u672F" class="headerlink" title="应用：性能提高技术"></a>应用：性能提高技术</h2><ol>
<li>高级设计。为遇到的问题选择适当的算法和数据结构。要特别警觉，避免使用那些会渐进地产生糟糕性能的算法或编码技术。</li>
<li>基本编码原则。避免限制优化的因素，这样编译器就能产生高效的代码。<ul>
<li>消除连续的函数调用。在可能时，将计算移到循环外。考虑有选择地拖鞋程序的模块性以获得更大的效率</li>
<li>消除不必要的存储器引用。引入临时变量来保存中间结果。只有在最后的值计算出来时，才将结果存放到数组或全局变量中</li>
</ul>
</li>
<li>低级优化<ul>
<li>展开循环，降低开销，并且使得进一步的优化成为可能</li>
<li>通过使用多个累积变量和重新结合等技术，找到方法提高指令级并行</li>
<li>用功能的风格重写条件操作，使得编译采用条件数据传送</li>
</ul>
</li>
</ol>
<h2 id="u786E_u5B9A_u548C_u6D88_u9664_u6027_u80FD_u74F6_u9888"><a href="#u786E_u5B9A_u548C_u6D88_u9664_u6027_u80FD_u74F6_u9888" class="headerlink" title="确定和消除性能瓶颈"></a>确定和消除性能瓶颈</h2><p>系统优化的通用原则：Amdahl’s law</p>
<p>Unix 的程序剖析(profiling)工具 GPROF。这个程序产生两种形式的信息。首先，它确定程序中每个函数花费了多少 CPU 时间。其次，它计算每个函数被调用的次数，以执行调用的函数来分类。</p>
<p>运行时需要三个步骤</p>
<ol>
<li>程序必须为剖析而编译和链接，加上 <code>-pg</code>: <code>unix&gt; gcc -O1 -pg prog.c -o prog</code></li>
<li>然后像往常一样执行：<code>unix&gt; ./prog file.txt</code>，会产生额外的文件 <code>gmon.out</code></li>
<li>调用 GPROF 来分析 <code>gmon.out</code> 中的数据：<code>unix&gt; gprof prog</code></li>
</ol>
<p>具体的用法请参考书本或者网上的例子，此略</p>
<h2 id="u5C0F_u7ED3-3"><a href="#u5C0F_u7ED3-3" class="headerlink" title="小结"></a>小结</h2><p>没有任何编译器能用一个好的算法或数据结构代替低效率的算法或数据结构，因此程序设计时的这些方面仍然应该是程序员主要关心的。</p>
<h1 id="u5B58_u50A8_u5668_u5C42_u6B21_u7ED3_u6784"><a href="#u5B58_u50A8_u5668_u5C42_u6B21_u7ED3_u6784" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><p>存储器系统(memory system)是一个具有不同容量、成本和访问时间的存储设备的层次结构。CPU 寄存器保存着最常用的数据。靠近 CPU 的晓得、快速的<strong>高速缓存存储器(cache memory)</strong>作为一部分存储在相对慢速的主存储器(main memory)中的数据和指令的缓冲区域。主存暂时存放在容量较大的、慢速磁盘上的数据，而这些磁盘常常又作为存储在通过网络连接的其他机器的磁盘或磁带上的区域的缓冲区域。</p>
<p>如果你理解了系统是如何将数据在存储器层次结构中上上下下移动的，那么你就可以编写你的应用程序，使得它们的数据项存储在层次结构中较高的地方，在那里 CPU 能更快地访问到它们。</p>
<p>这个思想围绕着计算机程序的一个称为<strong>局部性(locality)</strong>的基本属性。具有良好局部性的程序倾向于一次又一次地访问相同的数据项集合，或是倾向于访问临近的数据项集合。</p>
<h2 id="u5B58_u50A8_u6280_u672F"><a href="#u5B58_u50A8_u6280_u672F" class="headerlink" title="存储技术"></a>存储技术</h2><p>计算机技术的成功很大程度上源自于存储技术的巨大进步。</p>
<blockquote>
<p>随机访问存储器</p>
</blockquote>
<p>随机访问存储器   (Random-Access Memory, RAM)分为两类：静态的和懂啊提的。SRAM 比 DRAM 更快，但也贵得多。SRAM 用来作为高速缓存存储器，既可以在 CPU 芯片上，也可以在片下。DRAM 用来作为主存以及图形系统的帧缓冲区。</p>
<blockquote>
<p>固态硬盘</p>
</blockquote>
<p>固态硬盘(Solid State Disk, SSD)是一种基于闪存的存储技术。一个 SSD 包由一个或多个闪存芯片和闪存翻译层(flash translation layer)组成，闪存芯片代替传统旋转磁盘中的机械驱动器，而闪存翻译层是一个硬件/固件设备，扮演与磁盘控制器相同的角色，将对逻辑块的清酒翻译成对底层物理设备的访问。</p>
<p><img src="/images/csapp6.16.jpg" alt="csapp6.16"></p>
<p>SSD 有着与旋转磁盘不同的性能特征。顺序读和写性能相当，不过，当按照随机顺序访问逻辑块时，写比读慢一个数量级。随机读和写的性能差别是由底层闪存基本属性决定的。如上图所示，一个闪存由 B 个块的序列组成，每个块由 P 页组成。通常，页的大小是 512~4KB，块是由 32~128 页组成的，块的大小为 16~512 KB。数据是以页为单位读写的。只有在一页所属的块整个被擦除之后，才能写这一页。不过，一旦一个块被擦除了，块中的每一个页都可以不需要再进行擦除就写一次。在大约进行 100000 次重复写之后，块就会磨损坏。</p>
<blockquote>
<p>存储技术趋势</p>
</blockquote>
<ul>
<li>不同的存储技术有不同的价格和性能折中</li>
<li>不同的存储技术的价格和性能属性一截然不同的速率变化着</li>
<li>DRAM 和磁盘的性能滞后于 CPU 的性能</li>
</ul>
<h2 id="u5C40_u90E8_u6027"><a href="#u5C40_u90E8_u6027" class="headerlink" title="局部性"></a>局部性</h2><p>一个编写良好的计算机程序常常具有良好的局部性(locality)。也就是说，它们倾向于引用临近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性，被称为<strong>局部性原理(principle of locality)</strong>，是一个持久的概念，对硬件和软件系统的设计和性能都有着极大的影响。</p>
<p>局部性通常有两种不同的形式：<strong>时间局部性(temporal locality)</strong>和<strong>空间局部性(spatial locality)</strong>。有良好局部性的程序比局部性差的程序运行得更快。</p>
<ul>
<li>重复引用同一个变量的程序有良好的时间局部性</li>
<li>对于具有步长为 k 的引用模式的程序，步长越小，空间局部性越好</li>
<li>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好</li>
</ul>
<h2 id="u5B58_u50A8_u5668_u5C42_u6B21_u7ED3_u6784-1"><a href="#u5B58_u50A8_u5668_u5C42_u6B21_u7ED3_u6784-1" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h2><p>存储器层次结构(memory hierarchy)如下图所示</p>
<p><img src="/images/csapp6.23.jpg" alt="csapp6.23"></p>
<blockquote>
<p>存储器层次结构中的缓存</p>
</blockquote>
<p>一般而言，高速缓存(cache)是一个小而快速的存储设备。使用高速缓存的过程称为缓存(caching)。</p>
<p>存储器层次结构的中心思想是，对于每个 k，位于 k 层的更快更小的存储设备作为位于 k+1 层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一次都缓存来自较低一层的数据对象。</p>
<p>数据总是以块大小为<strong>传送单元(transfer unit)</strong>在第 k 层和第 k+1 层之间来回拷贝的。虽然在层次结构中任何一对相邻的层次之间块大小是固定的，但是其他的层次对之间可以用不同的块大小。一般而言，层次结构较低的层(离 CPU 较远)的设备访问时间较长，因此为了补偿这些较长的访问时间，倾向于使用较大的块。</p>
<p><img src="/images/csapp6.24.jpg" alt="csapp6.24"></p>
<p><strong>缓存命中</strong></p>
<p>当程序需要第 k+1 层的某个数据对象 d 时，它首先在当前存储的第 k 层的一个块中查找 d。如果 d 刚好缓存在第 k 层中，那么就是<strong>缓存命中(cache hit)</strong>。</p>
<p><strong>缓存不命中</strong></p>
<p>如果第 k 层中没有缓存数据对象 d，那么就是<strong>缓存不命中(cache miss)</strong>。当发生 cache miss 时，会从下一次取出包含 d 的那个块，如果第 k 层的缓存已经满了的话，可能就会覆盖现存的一个块。</p>
<p>覆盖一个现存的块的过程称为<strong>替换(replacing)</strong>或<strong>驱逐(evicting)</strong>。被驱逐的看这个块有时也称为<strong>牺牲块(victim block)</strong>。决定该替换那个块是由缓存的<strong>替换策略(replacement policy)</strong>来控制的。(LRU, LFU 等等替换策略在这里可以使用)</p>
<p><strong>缓存不命中的种类</strong></p>
<p>一个空的缓存有时称为<strong>冷缓存(cold cache)</strong>，此类不命中称为<strong>compulsory miss</strong> 或 <strong>cold miss</strong>。</p>
<p>只要发生了 cache miss，第 k 层的缓存就必须执行某个<strong>放置策略(placement policy)</strong>，确定把它从第 k+1 层中取出的块放在哪里。一般来说是用映射来确定放在哪里，如果两个不同的块映射到同一个位置，就引起了 conflict miss。当工作集的大小超过缓存的大小时，就会有 capacity miss。</p>
<p><img src="/images/csapp6.25.jpg" alt="csapp6.25"></p>
<h2 id="u9AD8_u901F_u7F13_u5B58_u5B58_u50A8_u5668"><a href="#u9AD8_u901F_u7F13_u5B58_u5B58_u50A8_u5668" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h2><p>早期计算机系统的存储器结构只有三层：CPU 寄存器、DRAM 主存储器和磁盘存储。不过，由于 CPU 和主存之间逐渐增大的差距，系统设计者被迫在 CPU 寄存器文件和主存之间插入了一个小的 SRAM 高速缓存存储器，称为 L1 高速缓存。之后又插入了一个更大的高速缓存，称为 L2 高速缓存，之后还有 L3 高速缓存。周期数：L1(2~4), L2(~10), L3(~30~40)</p>
<h2 id="u7F16_u5199_u9AD8_u901F_u7F13_u5B58_u53CB_u597D_u7684_u4EE3_u7801"><a href="#u7F16_u5199_u9AD8_u901F_u7F13_u5B58_u53CB_u597D_u7684_u4EE3_u7801" class="headerlink" title="编写高速缓存友好的代码"></a>编写高速缓存友好的代码</h2><ul>
<li>让最常见的情况运行得快</li>
<li>在每个循环内部缓存不命中数量最小</li>
</ul>
<h2 id="u7EFC_u5408_uFF1A_u9AD8_u901F_u7F13_u5B58_u5BF9_u7A0B_u5E8F_u6027_u80FD_u7684_u5F71_u54CD"><a href="#u7EFC_u5408_uFF1A_u9AD8_u901F_u7F13_u5B58_u5BF9_u7A0B_u5E8F_u6027_u80FD_u7684_u5F71_u54CD" class="headerlink" title="综合：高速缓存对程序性能的影响"></a>综合：高速缓存对程序性能的影响</h2><blockquote>
<p>存储器山</p>
</blockquote>
<p>一个程序从存储系统中读数据的速率称为<strong>度吞吐量(read throughput)</strong>，或者有时称为<strong>读带宽(read bandwidth)</strong>。</p>
<p><img src="/images/csapp6.43.jpg" alt="csapp6.43"></p>
<blockquote>
<p>重新排列循环以提高空间局部性</p>
</blockquote>
<p>矩阵的循环优化，略</p>
<blockquote>
<p>在程序中利用局部性</p>
</blockquote>
<ul>
<li>将你的注意力集中在内循环上，大部分计算和存储器访问都发生在这里</li>
<li>通过按照数据对象存储在存储器中的顺序、以步长为 1 的来读数据，从而使得程序中的空间局部性最大</li>
<li>一旦从存储器中读入了一个数据对象，就尽可能多地使用它，从而使得程序中的时间局部性最大</li>
</ul>
<h2 id="u5C0F_u7ED3-4"><a href="#u5C0F_u7ED3-4" class="headerlink" title="小结"></a>小结</h2><p>程序员可以通过编写有良好空间和时间局部性的程序来显著地改进程序的运行时间。利用基于 SRAM 的高速缓存存储器特别重要。</p>
<h1 id="u94FE_u63A5"><a href="#u94FE_u63A5" class="headerlink" title="链接"></a>链接</h1><p>链接(linking)是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载到存储器并执行。链接可以执行于编译时(compile time)，也可以执行于加载时(load time)，甚至执行于运行时(run time)。</p>
<p>链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译(separate compilation)成为可能。</p>
<h2 id="u7F16_u8BD1_u5668_u9A71_u52A8_u7A0B_u5E8F"><a href="#u7F16_u8BD1_u5668_u9A71_u52A8_u7A0B_u5E8F" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h2><p>大多数编译系统提供<strong>编译驱动程序(compiler driver)</strong>，它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。</p>
<h2 id="u9759_u6001_u8FDE_u63A5"><a href="#u9759_u6001_u8FDE_u63A5" class="headerlink" title="静态连接"></a>静态连接</h2><p>静态链接器(static linker)以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节(section)组成。指令在一个 section 中，初始化的全局变量在另一个 section 中，而未初始化的变量又在另一个 section 中。</p>
<p><img src="/images/csapp7.2.jpg" alt="csapp7.2"></p>
<p>为了构造可执行文件，链接器必须完成两个主要任务：</p>
<ul>
<li>符号解析(symbol resolution)。目标文件定义和引用符号。符号解析的目的是将每个符号引用刚好和一个符号定义联系起来。</li>
<li>重定位(relocation)。编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义域一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定位这些节。</li>
</ul>
<p>关于链接器的一些基本事实：目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包含指导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。</p>
<h2 id="u76EE_u6807_u6587_u4EF6"><a href="#u76EE_u6807_u6587_u4EF6" class="headerlink" title="目标文件"></a>目标文件</h2><p>目标文件有三种形式：</p>
<ul>
<li>可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li>
<li>可执行目标文件。包含二进制代码和数据，其形式可以被直接拷贝到存储器并执行。</li>
<li>共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载到存储器并链接。</li>
</ul>
<h2 id="u53EF_u91CD_u5B9A_u4F4D_u76EE_u6807_u6587_u4EF6"><a href="#u53EF_u91CD_u5B9A_u4F4D_u76EE_u6807_u6587_u4EF6" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h2><p>下图是一个典型的 ELF 可重定位目标文件的格式。ELF 头(ELF header)以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。</p>
<p><img src="/images/csapp7.3.jpg" alt="csapp7.3"></p>
<h2 id="u7B26_u53F7_u548C_u7B26_u53F7_u8868"><a href="#u7B26_u53F7_u548C_u7B26_u53F7_u8868" class="headerlink" title="符号和符号表"></a>符号和符号表</h2><p>每个可重定位目标模块 m 都有一个符号表，它包含 m 所定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：</p>
<ul>
<li>由 m 定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的 C 函数以及被定义为不带 C static 属性的全局变量</li>
<li>由其他模块定义的并被模块 m 引用的全局符号。这些符号称为外部符号(external)，对应于定义在其他模块中的 C 函数和变量。</li>
<li>只被模块 m 定义和引用的本地符号。有的本地链接器符号对应于带 static 属性的 C 函数和全局变量。</li>
</ul>
<p>C 程序员使用 static 属性在模块内部隐藏变量和函数声明。</p>
<h2 id="u7B26_u53F7_u89E3_u6790"><a href="#u7B26_u53F7_u89E3_u6790" class="headerlink" title="符号解析"></a>符号解析</h2><p>链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义联系起来。对那些和引用定义在相同模块中的本地符号的引用，符号解析是非常简单明了的。编译器只允许每个模块中每个本地符号只有一个定义。编译器还确保静态本地变量，它们也会有本地链接器符号，拥有唯一的名字。</p>
<h2 id="u91CD_u5B9A_u4F4D"><a href="#u91CD_u5B9A_u4F4D" class="headerlink" title="重定位"></a>重定位</h2><p>一旦链接器完成了符号解析这一步，它就把代码中的每个符号引用和确定的一个符号定义联系起来。在此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。重定位由两步组成：</p>
<ul>
<li>重定位节和符号定义</li>
<li>重定位节中的符号引用</li>
</ul>
<h2 id="u53EF_u6267_u884C_u76EE_u6807_u6587_u4EF6"><a href="#u53EF_u6267_u884C_u76EE_u6807_u6587_u4EF6" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h2><p>可执行目标文件的格式类似于可重定位目标文件的格式，如下图所示。ELF 头部描述文件的总体格式。它还包括程序的入口点(entry point)，也就是当程序要执行的第一条指令的地址。</p>
<p><img src="/images/csapp7.11.jpg" alt="csapp7.11"></p>
<h2 id="u52A0_u8F7D_u53EF_u6267_u884C_u76EE_u6807_u6587_u4EF6"><a href="#u52A0_u8F7D_u53EF_u6267_u884C_u76EE_u6807_u6587_u4EF6" class="headerlink" title="加载可执行目标文件"></a>加载可执行目标文件</h2><p>要允许可执行目标文件 p，可以在 Unix 外壳的命令行中输入它的名字</p>
<pre><code>unix&gt; ./p
</code></pre><p>因为 p 不是一个内置的外壳命令，所以外壳会认为 p 是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器(loader)的操作系统代码来运行它。任何 Unix 程序都可以通过调用 execve 函数来调用加载器。加载器将可执行目标文件中的代码和数据从磁盘拷贝到存储器，然后通过跳转到程序的第一条指令或入口点(entry point)来运行该程序。这个将程序拷贝到存储器并运行的过程叫做加载(loading)。</p>
<p><img src="/images/csapp7.13.jpg" alt="csapp7.13"></p>
<p>每个 Unix 程序都有一个运行时存储器映像，如上图所示。在 32 位 Linux 系统中，代码段总是从地址 0x08048000 处开始。数据段是在接下来的下一个 4KB 对齐的地址处。运行时<strong>堆</strong>再读/写段之后接下来的第一个 4KB 对齐的地址处，并通过调用 malloc 库往上增长。还有一个段是为共享库保留的。用户栈总是从最大的合法用户地址开始，向下增长的(向低存储器地址方向增长)。从栈的上部开始的段是为操作系统主流存储器的部分(也就是内核)的代码和数据保留的。</p>
<h2 id="u52A8_u6001_u94FE_u63A5_u5171_u4EAB_u5E93"><a href="#u52A8_u6001_u94FE_u63A5_u5171_u4EAB_u5E93" class="headerlink" title="动态链接共享库"></a>动态链接共享库</h2><p>共享库(shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行时，可以加载到任意的存储器地址，并和一个在存储器中的程序链接起来。这个过程称为<strong>动态链接(dynamic linking)</strong>，是由一个叫做<strong>动态链接器</strong>的程序来执行的。</p>
<p>共享库也称为<strong>共享目标(shared object)</strong>，在 Unix 系统中通常用 .so 后缀来表示。微软的操作系统大量地利用了共享库，它们称为 DLL。</p>
<p><img src="/images/csapp7.15.jpg" alt="csapp7.15"></p>
<p>共享库是以两种不同方式来“共享”的。首先，在任何给定的文件系统中，对于一个库只有一个 .so 文件。所有引用该库的可执行目标文件共享这个 .so 文件中的代码和数据，而不是像静态库的内容那样被拷贝和嵌入到引用它们的可执行的文件中。</p>
<h2 id="u4E0E_u4F4D_u7F6E_u65E0_u5173_u7684_u4EE3_u7801_28PIC_29"><a href="#u4E0E_u4F4D_u7F6E_u65E0_u5173_u7684_u4EE3_u7801_28PIC_29" class="headerlink" title="与位置无关的代码(PIC)"></a>与位置无关的代码(PIC)</h2><p>PIC 数据引用；PIC 函数调用</p>
<h2 id="u5904_u7406_u76EE_u6807_u6587_u4EF6_u7684_u5DE5_u5177"><a href="#u5904_u7406_u76EE_u6807_u6587_u4EF6_u7684_u5DE5_u5177" class="headerlink" title="处理目标文件的工具"></a>处理目标文件的工具</h2><p>在 Unix 系统中有大量可用的工具可以帮助你理解和处理目标文件。特别的，GNU binutils 包尤其有帮助，而且可以运行在每个 Unix 平台上。</p>
<ul>
<li>AR: 创建静态库，插入、删除、列出和提取成员</li>
<li>STRINGS: 列出一个目标文件中所有可打印的字符串</li>
<li>STRIP: 从目标文件中删除符号表信息</li>
<li>NM: 列出一个目标文件的符号表中定义的符号</li>
<li>SIZE: 列出目标文件中节的名字和大小</li>
<li>READELF: 显示一个目标文件的完整结构，包括 ELF 头中编码的所有信息。包含 SIZE 和 NM 的功能</li>
<li>OBJDUMP: 二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编 .text 节中的二进制命令</li>
<li>LDD: 列出一个可执行文件在运行时所需要的共享库</li>
</ul>
<h2 id="u5C0F_u7ED3-5"><a href="#u5C0F_u7ED3-5" class="headerlink" title="小结"></a>小结</h2><p>链接可以在编译时由静态编译器来完成，也可以在加载时和运行时由动态链接器来完成。链接器处理称为目标文件的二进制文件，它又三种不同的形式：可重定位的、可执行的和共享的。可重定位的目标文件由静态链接器合并成一个可执行的目标文件，它可以加载到存储器中并执行。共享目标文件(共享库)是在运行时由动态链接器链接和加载的，或者隐含地在调用程序被加载和开始执行时，或者根据需要在程序调用 dlopen 库的函数时。</p>
<p>链接器的两个主要任务是符号解析和重定位，符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义，而重定位确定每个符号的最终存储器地址，并修改对那些目标的引用。</p>
<p>静态链接器是由像 GCC 这样的编译驱动器调用的。它们将多个可重定位目标文件合并成一个单独的可执行目标文件。多个目标文件可以定义相同的符号，而链接器用来悄悄地解析这些多重定义的规则可能在用户程序中引入的微妙错误。</p>
<p>多个目标文件可以被连接到一个单独的静态库中。链接器用库来解析其他目标模块中的符号引用。许多链接器通过从左到右的顺序扫描来解析符号引用，这是另一个引起迷惑的链接时错误来源。</p>
<p>加载器将可执行文件的内容映射到存储器，并运行这个程序。链接器还可能生成部分链接的可执行目标文件，这样的文件中有对定义在共享库中的程序和数据的未解析的引用。在加载时，加载器将部分链接的可执行文件映射到存储器，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链接任务。</p>
<p>被编译为位置无关代码的共享库可以加载到任何地方，也可以在运行时被多个进程共享。为了加载、链接和访问共享库的函数和数据，应用程序还可以在运行时使用动态链接器。</p>
<h1 id="u5F02_u5E38_u63A7_u5236_u6D41"><a href="#u5F02_u5E38_u63A7_u5236_u6D41" class="headerlink" title="异常控制流"></a>异常控制流</h1><p>系统必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。当子进程终止时，创造这些子进程的父进程必须得到通知。</p>
<p>线代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为<strong>异常控制流(Exceptional Control Flow, ECF)</strong>。异常控制流发生在计算机系统的各个层次。比如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文转换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送<strong>信号</strong>到另一个进程，而接受者会将控制突然转移到它的一个信号处理程序。一个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。</p>
<h2 id="u5F02_u5E38"><a href="#u5F02_u5E38" class="headerlink" title="异常"></a>异常</h2><p>异常是异常控制流的一种形式，它一部分是由硬件实现的，一部分是由操作系统实现的。因为它们有一部分是由硬件实现的，所以具体细节将随系统的不同而有所不同。然而，对于每个系统而言，基本的思想都是相同的。</p>
<p>异常(exception)就是控制流中的突变，用来响应处理器状态中的某些变化。如下图所示：</p>
<p><img src="/images/csapp8.1.jpg" alt="csapp8.1"></p>
<p>在图中，当处理器状态中发生一个重要的变化时，处理器正在执行某个当前指令。在处理器中，状态被编码为不同的位和信号。状态变化称为<strong>事件(event)</strong>。事件可能和当前指令的执行直接相关。比如，发生虚拟存储器缺页、算术溢出，或者一条指令试图除以零。另一方面，事件也可能和当前指令的执行没有关系。比如，一个系统定时器产生信号或者一个 I/O 请求完成。</p>
<p>在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做<strong>异常表(exception table)</strong>的跳转表，进行一个间接过程调用(异常)，到一個专门设计用来处理这类事件的操作系统子程序(异常处理程序, exception handler)</p>
<p>当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下三种情况中的一种：</p>
<ol>
<li>处理程序将控制返回给当前指令 I(curr)，即当事件发生时正在执行的指令。</li>
<li>处理程序将控制返回给 I(next)，即如果没有发生异常将会执行的下一条指令。</li>
<li>处理程序被中断的程序</li>
</ol>
<blockquote>
<p>异常处理</p>
</blockquote>
<p>系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号(exception number)。其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核的设计者分配的。前者的示例包括被零除、缺页、存储器访问违例以及算术溢出。后者的示例包括系统调用和来自外部 I/O 设备的信号。</p>
<p>在系统启动时，操作系统分配和初始化一张称为<strong>异常表</strong>的跳转表，使得条目 k 包含异常 k 的处理程序的地址。如下图所示</p>
<p><img src="/images/csapp8.2.jpg" alt="csapp8.2"></p>
<p>在运行时，处理器检测到发生了一个事件，并且确定了相应的异常号 k。随后，处理器触发异常，方法是执行间接过程调用，通过异常表的条目 k 转到相应的处理程序。下图展示了处理器如何使用异常表来形成适当的异常处理程序的地址。异常号是到异常表中的索引，异常表的起始地址放在一个叫做<strong>异常表基址寄存器(exception table base register)</strong>的特殊 CPU 寄存器里。</p>
<p><img src="/images/csapp8.3.jpg" alt="csapp8.3"></p>
<blockquote>
<p>异常的类别</p>
</blockquote>
<p>异常可以分为四类：中断(interrupt)、陷阱(trap)、故障(fault)和终止(abort)。下图是一些总结</p>
<p><img src="/images/csapp8.4.jpg" alt="csapp8.4"></p>
<p><strong>中断</strong></p>
<p>中断是异步发生的，是来自处理器外部的 I/O 设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序通常称为中断处理程序(interrupt handler)</p>
<p><img src="/images/csapp8.5.jpg" alt="csapp8.5"></p>
<p>剩下的异常类型(陷阱、故障和终止)是同步发生的，是执行当前指令的结果。我们把这类指令叫做故障指令(faulting instruction)。</p>
<p>陷阱和系统调用</p>
<p>陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做<strong>系统调用</strong>。</p>
<p>用户程序经常需要向内核请求服务，比如读一个文件(read)、创建一个新的进程(fork)、记在一个新的程序(execve)，或者终止当前进程(exit)。为了允许对这些内核服务的受控范文，处理器提供一条特殊的 <code>syscall n</code> 指令，当用户程序想要请求服务 n 时，可以执行这条指令。执行 <code>syscall</code> 指令会导致一个到异常处理程序的陷阱，这个处理程序对参数解码，并调用适当的内核程序。</p>
<p><img src="/images/csapp8.6.jpg" alt="csapp8.6"></p>
<p><strong>故障</strong></p>
<p>故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort 例程，abort 例程会终止引起故障的应用程序，如下图所示：</p>
<p><img src="/images/csapp8.7.jpg" alt="csapp8.7"></p>
<p>一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在存储器中，因此必须从磁盘中取出时，就会发生故障。就像我们将在第 9 章中看到的那样，一个页面就是虚拟存储器的一个连续的块。缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在存储器中了，指令就可以没有故障地运行完成了。</p>
<p><strong>终止</strong></p>
<p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者 SRAM 位被损坏时发生的奇偶错误。终止程序从不将控制返回给应用程序。如下图所示</p>
<p><img src="/images/csapp8.8.jpg" alt="csapp8.8"></p>
<blockquote>
<p>Linux/IA32 系统中的异常</p>
</blockquote>
<p>IA32 系统有高达256种不同的异常类型。0-31的号码对应的是由 Intel 架构师定义的异常，因此对任何 IA32 系统都是一样的。32-255的号码对应的是操作系统定义的终端和陷阱，如下图所示</p>
<p><img src="/images/csapp8.9.jpg" alt="csapp8.9"></p>
<p><strong>Linux/IA32 故障和终止</strong></p>
<ul>
<li>除法错误。当应用试图除以零时，或者当一个除法指令的结果对于目标操作数来说太大的时候，就会发生除法错误(异常0)。Unix 不会试图从除法错误中恢复，而是选择终止程序。Linux shell 通常会把除法错误报告为浮点异常(Floating exception)。</li>
<li>一般保护故障。许多原因都会导致不为人知的一般保护故障(异常13)，通常是因为一个程序引用了一个未定义的虚拟存储器区域，或者因为程序视图写一个只读的文本段。Linux 不会尝试恢复这类故障。Linux shell 通常会把这种一般保护故障报告为段故障(Segmentation fault)。</li>
<li>缺页(异常14)是会重新执行产生故障的指令的一个异常示例。</li>
<li>机器检查(异常18)是在导致故障的指令中检测到致命的硬件错误时发生的。机器检查处理程序从不返回控制给应用程序</li>
</ul>
<p><strong>Linux/IA32 系统调用</strong></p>
<p>每个系统调用都有一个唯一的整数号，对应于一个到内核中跳转表的偏移量。</p>
<p><img src="/images/csapp8.10.jpg" alt="csapp8.10"></p>
<h2 id="u8FDB_u7A0B"><a href="#u8FDB_u7A0B" class="headerlink" title="进程"></a>进程</h2><p>异常是允许操作系统提供<strong>进程(process)</strong>的概念所需要的基本构造块，进程是计算机可续重最深刻最成功的概念之一。当我们在一个现代系统上运行一个程序时，会得到一个假象，就好像我们的程序是系统中当前运行着的唯一的程序。</p>
<p>进程的经典定义就是一个<strong>执行中的程序的实例</strong>。系统中的每个程序都是运行在某个进程的<strong>上下文(context)</strong>中的。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在存储器中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p>
<p>每次用户通过向外壳输入一个可执行目标文件的名字，并运行一个程序时，shell 就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，且在这个新进程的上下文中运行它们自己的代码或其他应用程序。</p>
<blockquote>
<p>逻辑控制流</p>
</blockquote>
<p>即使在系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，好像它在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器(PC)的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或者是包含在运行时动态链接到程序的共享对象的指令。这个 PC 值的序列叫做<strong>逻辑控制流</strong>，或者简称<strong>逻辑流</strong>。</p>
<p><img src="/images/csapp8.12.jpg" alt="csapp8.12"></p>
<p>每个进程执行它的流的一部分，然后被<strong>抢占(preempted，暂时挂起)</strong>，然后轮到其他进程。</p>
<blockquote>
<p>并发流</p>
</blockquote>
<p>一个逻辑流的执行在时间上与另一个流重叠，称为<strong>并发流(concurrent flow)</strong>，这两个流被称为并发地运行。更准确地说，流 X 和 Y 互相并发，当且仅当 X 在 Y 开始之后和 Y 结束之前开始，或者 Y 在 X 开始之后和 X 结束之前开始。</p>
<p>多个流并发地执行的一般现象称为<strong>并发(concurrency)</strong>。一个进程和其他进程轮流运行的概念称为<strong>多任务(multitasking)</strong>。一个进程执行它的控制流的一部分的每一时间段叫做<strong>时间片(time slice)</strong>。因此，多任务也叫做<strong>时间分片(time slicing)</strong></p>
<p>注意，并发的思想与流运行的处理器核数或者计算机无关。如果两个流再时间上重叠，那么它们就是并发的，即使它们是运行在同一个处理器上的。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为<strong>并行流(parallel flow)</strong>。</p>
<blockquote>
<p>私有地址空间</p>
</blockquote>
<p>进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。尽管和每个私有地址空间相关联的存储器的内容一般是不同的，但是每个这样的空间都有相同的通用结构，如下图所示。</p>
<p><img src="/images/csapp8.13.jpg" alt="csapp8.13"></p>
<blockquote>
<p>用户模式和内核模式</p>
</blockquote>
<p>为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。</p>
<p>处理器通常是用某个控制寄存器中的一个<strong>模式位(mode bit)</strong>来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位，进程就运行在<strong>内核模式(超级用户模式)</strong>。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中任何存储器位置。</p>
<p>没有设置模式位时，进程就运行在<strong>用户模式</strong>中。用户模式中的进程不允许执行<strong>特权指令(priviledged instruction)</strong>，比如停止处理器、改变位模式，或者发起一个 I/O 操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。</p>
<p>Linux 提供了一种聪明的机制，叫做 /proc 文件系统，它允许用户模式进程访问内核数据结构的内容。/proc文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构。</p>
<blockquote>
<p>上下文切换</p>
</blockquote>
<p>操作系统内核使用一种称为<strong>上下文切换(context switch)</strong>的较高层形式的异常控制流来实现多任务。上下文切换机制是建立在8.1节中那些较低层异常机制之上的。</p>
<p>内核为每个进程维持一个<strong>上下文(context)</strong>。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描绘地址空间的页表、包含有关当前进程信息的<strong>进程表</strong>，以及包含进程已打开文件的信息的<strong>文件表</strong>。</p>
<p>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程。这种决定就叫做<strong>调度(schedule)</strong>，是由内核中称为<strong>调度器(scheduler)</strong>的代码处理的。当内核选择一个新的进程运行时，我们就说内核调度了这个进程。</p>
<p><img src="/images/csapp8.14.jpg" alt="csapp8.14"></p>
<h2 id="u7CFB_u7EDF_u8C03_u7528_u9519_u8BEF_u5904_u7406"><a href="#u7CFB_u7EDF_u8C03_u7528_u9519_u8BEF_u5904_u7406" class="headerlink" title="系统调用错误处理"></a>系统调用错误处理</h2><p>当 Unix 系统级函数遇到错误时，它们典型地会返回 -1，并设置全局帧数变量 errno 来表示什么出错了。通过使用<strong>错误处理包装(error-handling wrapper)</strong>函数，可以简化错误处理代码。</p>
<h2 id="u8FDB_u7A0B_u63A7_u5236"><a href="#u8FDB_u7A0B_u63A7_u5236" class="headerlink" title="进程控制"></a>进程控制</h2><p>Unix 提供了大量从 C 程序中操作进程的系统调用。</p>
<blockquote>
<p>获取进程 ID</p>
</blockquote>
<p>每个进程都有一个唯一的正数进程 ID(PID)。<code>getpid</code> 函数返回调用进程的 PID。<code>getppid</code> 函数返回它的父进程的 PID。</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t getpid(void);
pit_t getppid(void);
</code></pre><blockquote>
<p>创建和终止进程</p>
</blockquote>
<p>从程序员的角度，我们可以认为进程总是处于下面三种状态之一：</p>
<ul>
<li>运行。进程要么在 CPU 上执行，要么在等待被执行且最终会被内核调度。</li>
<li>停止。进程的执行被<strong>挂起(suspend)</strong>，且不会被调度。当收到 <code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIDTTIN</code> 或者 <code>SIGTTOU</code> 信号时，进程就停止，并且保持停止直到它收到一个 <code>SIGCONT</code> 信号，在这个时刻，进程再次开始运行。</li>
<li>终止。进程永远地停止了。进程会因为三种原因终止：1）收到一个默认行为是终止进程的信号，2）从主程序返回，3）调用 exit 函数</li>
</ul>
<p>该程序无返回值，<code>exit</code> 函数以 status 退出来终止进程。</p>
<pre><code>#include &lt;stdlib.h&gt;

void exit(int status);
</code></pre><p>父进程通过调用 <code>fork</code> 函数创建一个新的运行子进程，子进程返回0，父进程返回子进程的 PID，如果出错则为 -1。</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t fork(void);
</code></pre><p>新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份拷贝，包括文本、数据和 bss 段、以及用户栈。子进程还获得与父进程任何打开文件描述符相同的拷贝。父进程和新创建的子进程最大的区别在于他们有不同的 PID。</p>
<p><code>fork</code> 函数只被调用一次，却会返回两次(父进程与子进程)。因为子进程的 PID 总是非零的，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。</p>
<p><img src="/images/csapp8.15.jpg" alt="csapp8.15"></p>
<ul>
<li>调用一次，返回两次</li>
<li>并发执行。顺序不能保证</li>
<li>相同但是独立的地址空间，所以变量是分别独立的</li>
<li>共享文件，输出是指向同一个地方</li>
</ul>
<p><img src="/images/csapp8.16.jpg" alt="csapp8.16"></p>
<blockquote>
<p>回收子进程</p>
</blockquote>
<p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一中已终止的状态中，直到被它的父进程<strong>回收(reap)</strong>。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个终止了但还未被回收的进程称为<strong>僵死进程(zombie)</strong>。</p>
<p>如果父进程没有回收它的僵死子进程就终止了，那么内核就会安排 init 进程来回收它们。init 进程的 PID 为 1，并且是在系统初始化时由内核创建的。长时间运行的程序，比如 shell 或者服务器，总是应该回收它们的僵死子进程。即使僵死子进程没有运行，它们仍然小号系统的存储器资源。</p>
<p>一个进程可以通过调用 <code>waitpid</code> 函数来等待它的子进程终止或者停止。如果成功，则返回子进程的 PID，如果 WHOHANG ，则为 0，如果其他错误，则为 -1。</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

pit_t waitpid(pid_t pid, int *status, int options);
</code></pre><p>具体用法略</p>
<blockquote>
<p>让进程休眠</p>
</blockquote>
<p><code>sleep</code> 函数让一个进程挂起一段指定的时间。返回还要休眠的秒数。</p>
<pre><code>#include &lt;unistd.h&gt;
unsigned int sleep(unsigned int secs);
</code></pre><p>如果请求的时间量已经到了，<code>sleep</code>返回 0，否则返回还剩下要休眠的秒数。我们会发现很有用的另一个函数是 <code>pause</code> 函数，该函数让调用函数休眠，直到该进程收到一个信号。总是返回 -1。</p>
<pre><code>#include &lt;unistd.h&gt;
int pause(void);
</code></pre><blockquote>
<p>加载并运行程序</p>
</blockquote>
<p><code>execve</code> 函数子啊当前进程的上下文中加载并运行一个新程序。如果成功则不返回，如果错误，则返回 -1。</p>
<pre><code>#include &lt;unistd.h&gt;

int execve(const char *filename, const char *argv[], const char *envp[]);
</code></pre><p><code>execve</code> 函数加载并运行可执行目标文件 filename，且带参数列表 argv 和环境变量列表 envp。只有当出现错误时，<code>execve</code> 才会返回到调用程序。<code>execve</code> 调用一次并从不返回。</p>
<p><img src="/images/csapp8.19.jpg" alt="csapp8.19"></p>
<p>当 <code>main</code> 开始在一个 32 位 Linux 进程中执行时，用户栈有如下图所示的组织结构。</p>
<p><img src="/images/csapp8.21.jpg" alt="csapp8.21"></p>
<p><strong>程序与进程</strong></p>
<p>程序是一堆代码和数据；程序可以作为目标模块存在于磁盘上，或者作为段存在于地址空间中。进程执行中程序的一个具体的实例；程序总是运行在某个进程的上下文中。<code>fork</code>函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品。<code>execve</code> 函数在当前进程的上下文中加载并运行一个新的程序，会覆盖当前进程的地址空间，但并没有创建一个新进程。新的程序仍然拥有相同的 PID，并且继承了调用 <code>execve</code> 函数时已打开的所有文件描述符。</p>
<blockquote>
<p>利用 fork 和 execve 运行程序</p>
</blockquote>
<p>Shell 是一个交互型的应用级程序，它代表用户运行其他程序。最早的 shell 是 sh 程序，后面出现了一些变种，比如 csh, tcsh, ksh 和 bash。Shell 执行一系列的<strong>读/求值(read/evaluate)</strong>步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并代表用户运行程序。</p>
<h2 id="u4FE1_u53F7"><a href="#u4FE1_u53F7" class="headerlink" title="信号"></a>信号</h2><p>一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。下图是 Linux 系统支持的 30 种不同类型的信号。在 shell 中输入 <code>man 7 signal</code> 就能得到这个列表。</p>
<p><img src="/images/csapp8.25.jpg" alt="csapp8.25"></p>
<p>每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。比如，如果一个进程试图除以 0，那么内核就发送给他一个 <code>SIGFPE</code> 信号(8)。其他信号对应于内核或者其他用户进程中较高层的软件事件。比如，如果当进程在前台运行时，按下 ctrl-c，那么内核就会发送一个 <code>SIGINT</code> 信号(2)给这个前台进程。</p>
<blockquote>
<p>信号术语</p>
</blockquote>
<p>传送一个信号到目的进程是由两个不同步骤组成的：</p>
<ul>
<li><strong>发送信号</strong>。内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。发送信号可以用如下两个原因：1）内核检测到一个系统事件，比如被零除错误或者子进程终止。2）一个进程调用 kill 函数，显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。</li>
<li><strong>接收信号</strong>。当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为<strong>信号处理程序(signal handler)</strong>的用户层函数捕获这个信号。如下图所示</li>
</ul>
<p><img src="/images/csapp8.26.jpg" alt="csapp8.26"></p>
<p>一个只发出而没有被接收的信号叫做<strong>待处理信号(pending signal)</strong>。在任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为 k 的待处理信号，那么任何接下来发送到这个进程的类型为 k 的信号都不会排队等待，它们只是被简单地丢弃。一个进程可以有选择地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。</p>
<p>一个待处理信号最多只能被接收一次。内核为每个进程在 pending 位向量中维护着待处理信号的集合，而在 blocked 位向量中维护着被阻塞的信号集合。只要传送了一个类型为 k 的信号，内核就会设置 pending 中的第 k 位，而只要接收了一个类型为 k 的信号，内核就会清除 pending 中的第 k 位。</p>
<blockquote>
<p>发送信号</p>
</blockquote>
<p>Unix 系统提供了大量向进程发送信号的机制。所有这些机制都是基于<strong>进程组(process group)</strong>这个概念的。</p>
<p><strong>进程组</strong></p>
<p>每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的。<code>getpgrp</code> 函数返回当前进程的进程组 ID。</p>
<pre><code>#include &lt;unistd.h&gt;

pid_t getpgrp(void);
</code></pre><p>默认的，一个子进程和它的父进程同属一个进程组。一个进程可以通过使用 <code>setpgid</code> 函数来改变自己或者其他进程的进程组，成功则返回 0，否则返回 -1。</p>
<pre><code>#include &lt;unistd.h&gt;

int setpgid(pid_t pid, pid_t pgid);
</code></pre><p><strong>用 /bin/kill 程序发送信号</strong></p>
<p><code>/bin/kill</code> 程序可以向另外的进程发送任意的信号。比如</p>
<pre><code>unix&gt; /bin/kill -9 15213
</code></pre><p>发送信号9(SIGKILL)给进程 15213。</p>
<p><strong>从键盘发送信号</strong></p>
<p>Unix shell 使用<strong>作业(job)</strong>这个抽象概念来表示为对一个命令行求值而创建的进程。在任何时刻，至多只有一个前台作业和 0 个或多个后台作业。比如：</p>
<pre><code>unix&gt; ls | sort
</code></pre><p>创建一个由两个进程组成的前台作业，这两个进程是通过 Unix 管道连接起来的：一个进程运行 ls 程序，另一个运行 sort 程序。Shell 为每个作业创建一个独立的进程组。</p>
<p><strong>用 kill 函数发送信号</strong></p>
<p>进程通过调用 <code>kill</code> 函数发送信号给其他进程(包括它们自己)。如果 pid 大于零，那么 <code>kill</code> 函数发送信号 sig 给进程 pid。如果 pid 小于零，那么 kill 发送信号 sig 给进程组 abs(pid) 中的每个进程。</p>
<p><img src="/images/csapp8.28.jpg" alt="csapp8.28"></p>
<p><strong>用 alarm 函数发送信号</strong></p>
<p>进程可以通过调用 <code>alarm</code> 函数向它自己发送 SIGALRM 信号。返回前一次闹钟剩余的秒数，若以前没有设定闹钟，则为 0。</p>
<pre><code>#include &lt;unistd.h&gt;

unsigned int alarm(unsigned int secs);
</code></pre><blockquote>
<p>接收信号</p>
</blockquote>
<p>当内核从一个异常处理程序返回，准备将控制传递给进程 p 时，它会检查进程 p 的未被阻塞的待处理信号的集合(pending&amp;~blocked)。如果这个集合为空(通常情况下)，那么内核将控制传递到 p 的逻辑控制流中的下一条指令。</p>
<blockquote>
<p>信号处理问题</p>
</blockquote>
<p>当一个程序要补货多个信号时，一些细微的问题就产生了：</p>
<ul>
<li>待处理信号被阻塞</li>
<li>待处理信号不会排队等待</li>
<li>系统调用可以被中断</li>
</ul>
<p>不可以用信号来对其他进程中发生的事件计数。</p>
<blockquote>
<p>可移植的信号处理</p>
</blockquote>
<p>不同系统之间，信号处理语义的差异是 Unix 信号处理的一个缺陷。为了处理这个问题，Posix 标准定义了 <code>sigaction</code> 函数，它允许用户明确指定他们想要的信号处理语义。</p>
<blockquote>
<p>显式地阻塞和取消阻塞信号</p>
</blockquote>
<p>使用 <code>sigprocmask</code> 函数</p>
<blockquote>
<p>同步流以避免讨厌的并发错误</p>
</blockquote>
<p><strong>竞争(race)</strong>，经典同步错误</p>
<h2 id="u975E_u672C_u5730_u8DF3_u8F6C"><a href="#u975E_u672C_u5730_u8DF3_u8F6C" class="headerlink" title="非本地跳转"></a>非本地跳转</h2><p>C 语言提供了一种用户级一场控制流形式，称为<strong>非本地跳转(nonlocal jump)</strong>，它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用——返回序列，通过 <code>setjmp</code> 和 <code>longjmp</code> 函数来提供的。</p>
<pre><code>#include &lt;setjmp.h&gt;

int setjmp(jmp_buf env);
int sigsetjmp(sigjmp_buf env, int savesigs);
</code></pre><p><code>setjmp</code> 函数在 env 缓冲区中保存当前调用环境，以供后面 <code>longjmp</code> 使用，并返回 0。调用环境包括程序计数器、栈指针和通用目的寄存器。</p>
<pre><code>#include &lt;setjmp.h&gt;

void longjmp(jmp_buf env, int retval);
void siglongjmp(sigjmp_buf env, int retval);
</code></pre><p><code>longjmp</code> 函数从 env 缓冲区中恢复调用环境，然后触发一个从最近一次初始化 env 的 <code>setjmp</code> 调用的返回。然后 <code>setjmp</code> 返回，并带有非零的返回值 retval。</p>
<p><code>setjmp</code> 函数只被调用一次，但是返回<strong>多次</strong>：一次是当第一次调用 <code>setjmp</code>，而调用环境保存在缓冲区 env 时；一次是为每个相应的 <code>longjmp</code> 调用。另一方面，<code>longjmp</code> 函数被调用一次，但从不返回。</p>
<p>非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。如果在一个深层嵌套的函数调用中发现了一个错误，我们可以使用非本地跳转直接返回到一个普通的本地化的错误处理程序，而不是费力地解开调用栈。</p>
<p>非本地跳转的另一个重要应用是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。</p>
<p><img src="/images/csapp8.39.jpg" alt="csapp8.39"></p>
<h2 id="u64CD_u4F5C_u8FDB_u7A0B_u7684_u5DE5_u5177"><a href="#u64CD_u4F5C_u8FDB_u7A0B_u7684_u5DE5_u5177" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h2><p>Linux 系统提供了大量的监控和操作进程的有用工具：</p>
<ul>
<li>STRACE：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。用 <code>-static</code> 编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的 trace</li>
<li>PS：列出当前系统中的进程(包括僵死进程)</li>
<li>TOP：打印出关于当前进程资源使用的信息</li>
<li>PMAP：显示进程的存储器映射</li>
<li>/proc：一个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容，用户可以读取这些内容</li>
</ul>
<h2 id="u5C0F_u7ED3-6"><a href="#u5C0F_u7ED3-6" class="headerlink" title="小结"></a>小结</h2><p>异常控制流(ECF)发生在计算机系统的各个层次，是计算机系统中提供并发的基本机制。</p>
<p>在硬件层，异常是由处理器中的事件触发的控制流中的突变。控制流传递给一个软件处理程序，该处理程序进行一些处理，然后返回控制给被中断的控制流。</p>
<p>有四种不同类型的异常：中断、故障、终止和陷阱。</p>
<p>在操作系统层，内核用 ECF 提供进程的基本概念。进程提供给应用两个重要的抽象：1）逻辑控制流，它提供给每个程序一个假象，好像它是在独占地使用处理器，2）私有地址空间，它提供给每个程序一个假象，好像它是在独占地使用主存。</p>
<p>在操作系统和应用程序之间的接口处，应用程序可以创建子进程，等待它们的子进程停止或者终止，运行新的程序，以及不活来自其他进程的信号。信号处理的语义是微妙的，并且随着系统不同而不同。然而，在与 Posix 兼容的系统上存在着一些机制，允许程序清楚地指定期望的信号处理语义。</p>
<h1 id="u865A_u62DF_u5B58_u50A8_u5668"><a href="#u865A_u62DF_u5B58_u50A8_u5668" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><p>一个系统中的进程是与其他进程共享 CPU 和主存资源的。然而，共享主存会形成一些特殊的挑战。随着对 CPU 需求的增长，进程以某种合理的平滑方式慢了下来。但是如果太多的进程需要太多的存储器，那么它们中的一些就根本无法运行。当一个程序没有空间可用时，那就是它运气不好了。存储器还很容易被破坏。如果某个进程不小心写了另一个进程使用的存储器，它就可能以某种完全和程序逻辑无关的令人迷惑的方式失败。</p>
<p>为了更加有效地管理存储器并且少出错，现代系统提供了一种对主存的抽象概念，叫做<strong>虚拟存储器(VM)</strong>。虚拟存储器是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟存储器提供了三个重要的能力：1）它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。2）它为每个进程提供了一致的地址空间，从而简化了存储器管理。3）它保护了每个进程的地址空间不被其他进程破坏。</p>
<p>虚拟存储器是计算机系统最重要的概念之一。它成功的一个主要原因就是因为它是沉默地、自动地工作的，不需要应用程序员的任何干涉。</p>
<h2 id="u7269_u7406_u548C_u865A_u62DF_u5BFB_u5740"><a href="#u7269_u7406_u548C_u865A_u62DF_u5BFB_u5740" class="headerlink" title="物理和虚拟寻址"></a>物理和虚拟寻址</h2><p>计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的<strong>物理地址(Physical Address, PA)</strong>。第一个字节的地址为 0，接下来的字节地址为 1，再下一个为 2，以此类推。给定这种简单的结构，CPU 访问存储器的最自然的方式就是使用物理地址。我们把这种方式称为<strong>物理寻址(physical addressing)</strong>。如下图所示</p>
<p><img src="/images/csapp9.1.jpg" alt="csapp9.1"></p>
<p>当 CPU 执行这条加载指令时，它会生成一个有效物理地址，通过存储器总线，把它传递给主存。主存取出从物理地址 4 处开始的 4 字节的字，并将它返回给 CPU，CPU 会将它存放在一个寄存器里。</p>
<p>早起的 PC 使用 物理寻址，现代处理器使用的是一种称为<strong>虚拟寻址(virtual addressing)</strong>的寻址形式，如下图所示：</p>
<p><img src="/images/csapp9.2.jpg" alt="csapp9.2"></p>
<p>使用虚拟寻址时，CPU 通过生成一个<strong>虚拟地址(Virtual Address, VA)</strong>来访问主存，这个虚拟地址在被送到存储器之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做<strong>地址翻译(address translation)</strong>。就像异常处理一样，地址翻译需要 CPU 硬件和操作系统之间的紧密合作。CPU 芯片上叫做<strong>存储器管理单元(Memory Management Unit, MMU)</strong>的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容是由操作系统管理的。</p>
<h2 id="u5730_u5740_u7A7A_u95F4"><a href="#u5730_u5740_u7A7A_u95F4" class="headerlink" title="地址空间"></a>地址空间</h2><p><strong>地址空间(address space)</strong>是一个非负整数地址的有序集合：{0, 1, 2, …}。如果地址空间中的整数是连续的，那么我们说它是一个<strong>线性地址空间(linear address space)</strong>。</p>
<p>地址空间的概念是很重要的，因为它清楚地区分了数据对象(字节)和它们的属性(地址)。</p>
<h2 id="u865A_u62DF_u5B58_u50A8_u5668_u4F5C_u4E3A_u7F13_u5B58_u7684_u5DE5_u5177"><a href="#u865A_u62DF_u5B58_u50A8_u5668_u4F5C_u4E3A_u7F13_u5B58_u7684_u5DE5_u5177" class="headerlink" title="虚拟存储器作为缓存的工具"></a>虚拟存储器作为缓存的工具</h2><p>概念上而言，虚拟存储器(VM)被组织为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，这个唯一的虚拟地址是作为到数组的索引的。VM 系统通过将虚拟存储器分割为<strong>虚拟页(Virtual Page, VP)</strong>的大小固定的块来处理这个问题。每个虚拟页的大小为 P=2^p 字节。类似地，物理存储器被分割为<strong>物理页(Physical Page, PP)</strong>，大小也为 P 字节(物理页也称为<strong>页帧(page frame)</strong>)。</p>
<p>在任意时刻，虚拟页面的集合部分都分为三个不相交的子集：</p>
<ul>
<li>未分配的：VM 系统还未分配(或者创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。</li>
<li>缓存的：当前缓存在物理存储器中的已分配页。</li>
<li>未缓存的：没有缓存在物理存储器中的已分配页。</li>
</ul>
<p><img src="/images/csapp9.3.jpg" alt="csapp9.3"></p>
<blockquote>
<p>DRAM 缓存的组织结构</p>
</blockquote>
<p>这里用<strong>SRAM 缓存</strong>来表示位于 CPU 和主存之间的 L1, L2 和 L3 高速缓存，并且用<strong>DRAM 缓存</strong>来表示虚拟存储器系统的缓存，它在主存中缓存虚拟页。</p>
<p>DRAM 缓存的组织结构完全是由巨大的不命中开销驱动的。因为大的不命中处罚和访问第一字节的开销，虚拟页往往很大，典型地是<br>4KB-2MB。由于大的不命中处罚，DRAM 缓存是全相连的，也就是说，任何虚拟页都可以放置在任何的物理页中。不命中时的替换策略也很重要，因为替换错了虚拟页的出发也非常高。因此，与硬件对 SRAM 缓存相比，操作系统对 DRAM 缓存使用了更复杂精密的替换算法。最后，因为对磁盘的访问时间很长，DRAM 缓存总是使用写回(write back)，而不是直写。</p>
<blockquote>
<p>页表</p>
</blockquote>
<p>同任何缓存一样，虚拟存储器系统必须有某种方法来判定一个虚拟页是否存放在 DRAM 中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理存储器中选择一个牺牲页，并将虚拟页从磁盘拷贝到 DRAM 中，替换这个牺牲页。</p>
<p>这些功能是由许多软硬件联合提供的，包括操作系统软、MMU(存储器管理单元)中的地址翻译硬件和一个存放在物理存储器中叫做<strong>页表(page table)</strong>的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。</p>
<p>下图展示了一个页表的基本组织结构。页表就是一个<strong>页表条目(Page Table Entry, PTE)</strong>的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。</p>
<p><img src="/images/csapp9.4.jpg" alt="csapp9.4"></p>
<blockquote>
<p>页命中</p>
</blockquote>
<p><img src="/images/csapp9.5.jpg" alt="csapp9.5"></p>
<blockquote>
<p>缺页</p>
</blockquote>
<p>DRAM 缓存不命中称为<strong>缺页(page fault)</strong>。在虚拟存储器的习惯说法中，块被称为页。在磁盘和存储器之间传送页的活动叫做<strong>交换(swapping)</strong>或者<strong>页面调度(paging)</strong>。</p>
<p><img src="/images/csapp9.6.jpg" alt="csapp9.6"></p>
<p><img src="/images/csapp9.7.jpg" alt="csapp9.7"></p>
<blockquote>
<p>分配页面</p>
</blockquote>
<p><img src="/images/csapp9.8.jpg" alt="csapp9.8"></p>
<blockquote>
<p>又是局部性救了我们</p>
</blockquote>
<p>尽管在整个运行过程中程序引用的不同页面的总数可能超出物理存储器总的大小，但是局部性原则保证了在任意时刻，程序往往在一个较小的<strong>活动页面(active page)</strong>集合上工作，这个集合叫做<strong>工作集(working set)</strong>或者<strong>常驻集(resident set)</strong>。</p>
<h2 id="u865A_u62DF_u5B58_u50A8_u5668_u4F5C_u4E3A_u5B58_u50A8_u5668_u7BA1_u7406_u7684_u5DE5_u5177"><a href="#u865A_u62DF_u5B58_u50A8_u5668_u4F5C_u4E3A_u5B58_u50A8_u5668_u7BA1_u7406_u7684_u5DE5_u5177" class="headerlink" title="虚拟存储器作为存储器管理的工具"></a>虚拟存储器作为存储器管理的工具</h2><p>操作系统为每个进程提供了一个独立的页表，因为也就是一个独立的虚拟地址空间。如下图所示：</p>
<p><img src="/images/csapp9.9.jpg" alt="csapp9.9"></p>
<h2 id="u865A_u62DF_u5B58_u50A8_u5668_u4F5C_u4E3A_u5B58_u50A8_u5668_u4FDD_u62A4_u7684_u5DE5_u5177"><a href="#u865A_u62DF_u5B58_u50A8_u5668_u4F5C_u4E3A_u5B58_u50A8_u5668_u4FDD_u62A4_u7684_u5DE5_u5177" class="headerlink" title="虚拟存储器作为存储器保护的工具"></a>虚拟存储器作为存储器保护的工具</h2><p>如果一条指令违反了许可操作，那么 CPU 就出发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Unix shell 一般将这种异常报告为<strong>段错误(sgmentation fault)</strong>。</p>
<p><img src="/images/csapp9.10.jpg" alt="csapp9.10"></p>
<h2 id="u5730_u5740_u7FFB_u8BD1"><a href="#u5730_u5740_u7FFB_u8BD1" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>地址翻译的基础知识。</p>
<p><img src="/images/csapp9.11.jpg" alt="csapp9.11"></p>
<p><img src="/images/csapp9.12.jpg" alt="csapp9.12"></p>
<p>后面的暂略，几乎很少接触</p>
<h1 id="u7CFB_u7EDF_u7EA7_I/O"><a href="#u7CFB_u7EDF_u7EA7_I/O" class="headerlink" title="系统级 I/O"></a>系统级 I/O</h1><p>输入/输出是在主存和外部设备之间拷贝数据的过程。所有语言的运行时系统都提供执行 I/O 的较高级别的工具。</p>
<h2 id="Unix_I/O"><a href="#Unix_I/O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p>一个 Unix 文件就是一个 m 字节的序列。所有的 I/O 设备，如网络、磁盘和终端，都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许 Unix 内核引出一个简单、低级的应用接口，称为 Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行：</p>
<ul>
<li>打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O 设备。内核返回一个小的非负整数，叫做<strong>描述符</strong>，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。</li>
<li>改变当前的文件位置。</li>
<li>读写文件</li>
<li>关闭文件</li>
</ul>
<h2 id="u6253_u5F00_u548C_u5173_u95ED_u6587_u4EF6"><a href="#u6253_u5F00_u548C_u5173_u95ED_u6587_u4EF6" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h2><p>进程是通过调用 <code>open</code> 函数来打开一个已存在的文件或者创建一个新文件的。若成功则返回新文件描述符，否为返回 -1。</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int open(char *filename, int flags, mode_t mode);
</code></pre><p>进程通过调用 <code>close</code> 函数关闭一个打开的文件。若成功则返回 0，否则 -1。</p>
<pre><code>#include &lt;unistd.h&gt;

int close(int fd);
</code></pre><h2 id="u8BFB_u548C_u5199_u6587_u4EF6"><a href="#u8BFB_u548C_u5199_u6587_u4EF6" class="headerlink" title="读和写文件"></a>读和写文件</h2><p>应用程序是通过分别调用 <code>read</code> 和 <code>write</code> 函数来执行输入和输出的。</p>
<pre><code>#include &lt;unistd.h&gt;

ssize_t read(int fd, void *buf, size_t n);
ssize_t write(int fd, const void *buf, size_t n);
</code></pre><h2 id="u7528_RIO__u5305_u5065_u58EE_u5730_u8BFB_u5199"><a href="#u7528_RIO__u5305_u5065_u58EE_u5730_u8BFB_u5199" class="headerlink" title="用 RIO 包健壮地读写"></a>用 RIO 包健壮地读写</h2><p>提供两类不同的函数：无缓冲的输入输出函数与带缓冲的输入函数。</p>
<h2 id="u8BFB_u53D6_u6587_u4EF6_u5143_u6570_u636E"><a href="#u8BFB_u53D6_u6587_u4EF6_u5143_u6570_u636E" class="headerlink" title="读取文件元数据"></a>读取文件元数据</h2><p>应用程序能够通过调用 <code>stat</code> 和 <code>fstat</code> 函数，检索到关于文件的信息，有时也称为文件的<strong>元数据(metadata)</strong>。</p>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;

int stat(const char *filename, struct stat *buf);
int fstat(int fd, struct stat *buf);
</code></pre><p><img src="/images/csapp10.8.jpg" alt="csapp10.8"></p>
<h2 id="u5171_u4EAB_u6587_u4EF6"><a href="#u5171_u4EAB_u6587_u4EF6" class="headerlink" title="共享文件"></a>共享文件</h2><p>可以用许多不同的方式来共享 Unix 文件。内核用三个相关的数据结构来表示打开的文件：</p>
<ul>
<li>描述符表(descriptor table)。每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表指向<strong>文件表</strong>中的一个表项。</li>
<li>文件表(file table)。打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项包括当前的文件位置、**引用计数(reference count)，以及一个指向 <code>v-node 表</code>中对应表项的指针。</li>
<li>v-node 表(v-node table)。同文件表一样，所有的进程共享这张表。每个表项包含 stat 结构中的大多数信息。</li>
</ul>
<p><img src="/images/csapp10.11.jpg" alt="csapp10.11"></p>
<p><img src="/images/csapp10.12.jpg" alt="csapp10.12"></p>
<p><img src="/images/csapp10.13.jpg" alt="csapp10.13"></p>
<h2 id="I/O__u91CD_u5B9A_u5411"><a href="#I/O__u91CD_u5B9A_u5411" class="headerlink" title="I/O 重定向"></a>I/O 重定向</h2><p>Unix shell 提供了 I/O 重定向操作符，允许用户将磁盘文件和标准输入输出联系起来，例如</p>
<pre><code>unix&gt; ls &gt; foo.txt
</code></pre><p><img src="/images/csapp10.14.jpg" alt="csapp10.14"></p>
<h2 id="u6807_u51C6_I/O"><a href="#u6807_u51C6_I/O" class="headerlink" title="标准 I/O"></a>标准 I/O</h2><p>ANSI C 定义了一组高级输入输出函数，称为<strong>标准 I/O 库</strong>，为程序员提供了 Unix I/O 的较高级别的替代。这个库(libc)提供了打开和关闭文件的函数(<code>fopen</code>和<code>fclose</code>)，读和写字节的函数(<code>fread</code>和<code>fwrite</code>)，读和写字符串的函数(<code>fgets</code>和<code>fputs</code>)，以及复杂的格式化的 I/O 函数(<code>scanf</code>和<code>printf</code>)。</p>
<p>标准 I/O 库将一个打开的文件模型化为一个<strong>流</strong>。对于程序员而言，一个流就是一个指向 FILE 类型的结构的指针。</p>
<h2 id="u7EFC_u5408_uFF1A_u8BE5_u4F7F_u7528_u54EA_u4E9B_I/O__u51FD_u6570"><a href="#u7EFC_u5408_uFF1A_u8BE5_u4F7F_u7528_u54EA_u4E9B_I/O__u51FD_u6570" class="headerlink" title="综合：该使用哪些 I/O 函数"></a>综合：该使用哪些 I/O 函数</h2><p><img src="/images/csapp10.15.jpg" alt="csapp10.15"></p>
<p>标准 I/O 流，从某种意义上而言是<strong>全双工</strong>的，因为程序能够在同一个流上执行输入和输出。然而，对流的限制和对套接字的限制，有时候会互相冲突：</p>
<ul>
<li>限制一：跟在输出函数之后的输入函数。如果中间没有插入对 <code>fflush</code>, <code>fseek</code>, <code>fsetpos</code> 或者 <code>rewind</code> 的调用，一个输入函数不能跟随在一个输出函数之后。<code>fflush</code> 函数清空与流相关的缓冲区。后三个函数使用 Unix I/O <code>lseek</code> 函数来重置当前的文件位置。</li>
<li>限制二：跟在输入函数之后的输出函数。如果中间没有插入对 <code>fseek</code>, <code>fsetpos</code> 或者 <code>rewind</code> 的调用，一个输出函数不能跟随在一个输入函数之后，除非该输入函数遇到了一个 EOF。</li>
</ul>
<p>这些限制给网络应用带来了一个问题，因为对套接字使用 <code>lseek</code> 函数是非法的，所以在网络套接字上不要使用标准 I/O 进行输入和输出，而要使用健壮的 <code>RIO</code> 函数。</p>
<h2 id="u5C0F_u7ED3-7"><a href="#u5C0F_u7ED3-7" class="headerlink" title="小结"></a>小结</h2><p>Unix 提供了少量的系统级函数，它们允许应用程序打开、关闭、读和写文件，提取文件的元数据，以及执行 I/O 重定向。 Unix 的读和写操作会出现不足值，应用程序必须能正确地预计和处理这种情况。应用程序不应直接调用 Unix I/O 函数，而应该使用 RIO 包，RIO 包通过反复执行读写操作，直到传送完所有的请求数据，自动处理不足值。</p>
<p>Unix 内核使用三个相关的数据结构来表示打开的文件。描述符表中的表项指向打开文件表中的表项，而打开文件表中的表项又指向 v-node 表中的表项。</p>
<p>标准 I/O 库是基于 Unix I/O 实现的，并提供了一组强大的高级 I/O 例程。对于大多数应用程序而言，标准 I/O 更简单，是优于 Unix I/O 的选择。然而，因为对标准 I/O 和网络文件的一些相互不兼容的限制，Unix I/O 比标准 I/O 更适用于网络应用程序。</p>
<h1 id="u7F51_u7EDC_u7F16_u7A0B"><a href="#u7F51_u7EDC_u7F16_u7A0B" class="headerlink" title="网络编程"></a>网络编程</h1><p>网络应用随处可见。有趣的是，所有的网络应用都是基于相同的基本编程模型，有着相似的整体逻辑结构，并且一来相同的编程接口。</p>
<p>网络应用依赖于很多在系统研究正已经学习过的概念，例如，进程、信号、字节顺序、存储器映射以及动态存储分配，都扮演着重要的角色。</p>
<h2 id="u5BA2_u6237_u7AEF-_u670D_u52A1_u5668_u7F16_u7A0B_u6A21_u578B"><a href="#u5BA2_u6237_u7AEF-_u670D_u52A1_u5668_u7F16_u7A0B_u6A21_u578B" class="headerlink" title="客户端-服务器编程模型"></a>客户端-服务器编程模型</h2><p>每个网络应用都是基于<strong>客户端-服务器模型</strong>模型的。采用这个模型，一个应用是由一个<strong>服务器</strong>进程和一个或者多个<strong>客户端</strong>进程组成。服务器管理某种<strong>资源</strong>，并且通过操作这种资源来为它的客户端提供某种<strong>服务</strong>。</p>
<p>客户端-服务器模型中的基本操作是<strong>事务(transaction)</strong>，由四步组成，如下图所示：</p>
<p><img src="/images/csapp11.1.jpg" alt="csapp11.1"></p>
<h2 id="u7F51_u7EDC"><a href="#u7F51_u7EDC" class="headerlink" title="网络"></a>网络</h2><p>客户端和服务器通常运行在不同的主机上，并且通过<strong>计算机网络</strong>的硬件和软件资源来通信。对于一台主机而言，网络只是又一种 I/O 设备，作为数据源和数据接收方，如下图所示。</p>
<p><img src="/images/csapp11.2.jpg" alt="csapp11.2"></p>
<p>物理上而言，网络是一个按照地理远近组成的层次系统。最底层是 LAN(Local Area Network, 局域网)，在一个建筑或者校园范围内。迄今为止，最流行的局域网技术是<strong>以太网(Ethernet)</strong>。</p>
<p>每个以太网适配器都有一个全球唯一的 48 位地址，一台主机可以发送一段位，称为<strong>帧(frame)</strong>，到这个网段内的其他任何主机。每个帧包括一些固定数量的<strong>头部(header)</strong>位，用来标识此帧的源和目的地址以及此帧的长度，伺候紧随的就是数据位的<strong>有效载荷</strong>。每个主机适配器都能看到这个帧，但是只有目的主机实际读取它。</p>
<p>使用一些电缆和叫做网桥(bridge)的小盒子，多个以太网段可以连接成较大的局域网，称为**桥接以太网(bridged Ethernet)，如下图所示：</p>
<p><img src="/images/csapp11.4.jpg" alt="csapp11.4"></p>
<p>在层次更高的级别中，多个不兼容的局域网可以通过叫做<strong>路由器(router)</strong>的忒书计算机连接起来，组成一个<strong>internet(互联网络)</strong>。</p>
<p><img src="/images/csapp11.6.jpg" alt="csapp11.6"></p>
<p>协议软件消除了不同网络之间的差异，必须具备两种基本能力：命名机制和传送机制。</p>
<p>每台因特网主机都运行实现 <strong>TCP/IP 协议(Transmission Control Protocol/Internet Protocol)</strong>的软件，几乎每个现代计算机系统都支持这个协议。</p>
<p><img src="/images/csapp11.8.jpg" alt="csapp11.8"></p>
<p>TCP/IP 实际上是一个协议族，其中每一个都提供不同的功能。从程序员角度，我们可以把因特网看做一个世界范围的主机集合，满足以下特性：</p>
<ul>
<li>主机集合被映射为一组 32 位的 IP 地址</li>
<li>这组 IP 地址被映射为一组称为<strong>因特网域名(Internet domain name)</strong>的标识符</li>
<li>因特网主机上的进程能够通过<strong>连接(connection)</strong>和任何其他因特网主机上的进程通信</li>
</ul>
<blockquote>
<p>IP 地址</p>
</blockquote>
<p>一个 IP 地址就是一个 32 位无符号整数。IP 地址通常是以一种称为<strong>点分十进制表示法</strong>来表示的，这里，每个字节由它的十进制值表示，并且用句点和其他字节间分开。</p>
<p>因特网程序使用 <code>inet_aton</code> 和 <code>inet_ntoa</code> 函数来实现 IP 地址和点分十进制串之间的转换</p>
<pre><code>#include &lt;arpa/inet.h&gt;

int inet_aton(const char *cp, struct in_addr *inp);
char *inet_ntoa(struct in_addr in);
</code></pre><p>n 表示网络(network)，a 表示应用(application)。</p>
<blockquote>
<p>因特网域名</p>
</blockquote>
<p>域名集合形成了一个层次结构，每个域名编码了它在这个层次中的位置。</p>
<p><img src="/images/csapp11.10.jpg" alt="csapp11.10"></p>
<blockquote>
<p>因特网连接</p>
</blockquote>
<p>因特网客户端和服务器通过在<strong>连接</strong>上发送和接收字节流来通信。从连接一对进程的意义上而言，连接是点对点的。从数据可以同时双向流动的角度来说，它是<strong>全双工</strong>的。并且由源进程发出的字节流最终被目的进程以它发出的顺序收到它的角度来说，它是可靠的。</p>
<p>一个<strong>套接字</strong>是连接的一个端点。每个套接字都有相应的<strong>套接字地址</strong>，是由一个因特网地址和一个 16 位的整数<strong>端口</strong>组成的，用<code>地址:端口</code>来表示。当客户端发起一个连接请求时，客户端套接字地址中的端口是由内核自动分配的，称为<strong>临时端口(ephemeral port)</strong>。然而，服务器套接字地址中的端口通常是某个<strong>知名的端口</strong>，是和这个服务相对应的。例如，Web 服务器通常使用端口 80，而电子邮件服务器使用端口 25。在 Unix 机器上，文件 <code>/etc/services</code> 包含一张这台机器提供的服务以及它们的知名端口号的综合列表。</p>
<p>一个连接由它两端的套接字地址唯一确定。这对套接字地址叫做<strong>套接字对(socket pair)</strong>，由下列元组来表示：</p>
<pre><code>(cliaddr:cliport, servaddr:servport)
</code></pre><p><img src="/images/csapp11.13.jpg" alt="csapp11.13"></p>
<h2 id="u5957_u63A5_u5B57_u63A5_u53E3"><a href="#u5957_u63A5_u5B57_u63A5_u53E3" class="headerlink" title="套接字接口"></a>套接字接口</h2><p><strong>套接字接口(socket interface)</strong>是一组函数，它们和 Unix I/O 函数结合起来，用以创建网络应用。</p>
<p><img src="/images/csapp11.14.jpg" alt="csapp11.14"></p>
<blockquote>
<p>套接字地址结构</p>
</blockquote>
<p>从 Unix 内核的角度来看，一个套接字就是通信的一个端点。从 Unix 程序的角度来看，套接字就是一个有相应描述符的打开文件。</p>
<blockquote>
<p>socket 函数</p>
</blockquote>
<p>客户端和服务器使用 <code>socket</code> 函数来创建一个<strong>套接字描述符(socket descriptor)</strong></p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol);
</code></pre><blockquote>
<p>connect 函数</p>
</blockquote>
<p>客户端通过调用 <code>connect</code> 函数来建立和服务器的连接。</p>
<pre><code>#include &lt;sys/socket.h&gt;

int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);
</code></pre><p>剩下还有<code>bind</code>, <code>listen</code>, <code>accept</code> 等函数，略</p>
<h2 id="Web__u670D_u52A1_u5668"><a href="#Web__u670D_u52A1_u5668" class="headerlink" title="Web 服务器"></a>Web 服务器</h2><blockquote>
<p>Web 基础</p>
</blockquote>
<p>Web 客户端和服务器之间的交互用的是一个基于文本的应用级协议，叫做 HTTP(Hypertext Transfer Protocol)。HTTP 是一个简单的协议。一个 Web客户端打开一个到服务器的因特网连接，并且请求某些内容。服务器响应所请求的内容，然后关闭连接。浏览器读取这些内容，并把它显示在屏幕上。</p>
<blockquote>
<p>Web 内容</p>
</blockquote>
<p>对于 Web 客户端和服务器而言，内容是一个与 MIME(Multipurpose Internet Mail Extensions)类型相关的字节序列。</p>
<p><img src="/images/csapp11.22.jpg" alt="csapp11.22"></p>
<p>Web 服务器以两种不同的方式向客户端提供内容：</p>
<ul>
<li>取一个磁盘文件，并将它的内容返回给客户端。磁盘文件称为<strong>静态内容(static content)</strong>，而返回文件给客户端的过程称为<strong>服务静态内容(serving static content)</strong>。</li>
<li>运行一个可执行文件，并将它的输出返回给客户端。运行时可执行文件产生的输出称为<strong>动态内容(dynamic content)</strong>，而运行程序并返回它的输出到客户端的过程称为<strong>服务动态内容(serving dynamic content)</strong>。</li>
</ul>
<p>每条由 Web 服务器返回的内容都是和它管理的某个文件相关联的。这些文件中的每一个都有一个唯一的名字，叫做 URL(Universal Resource Locator)。</p>
<p>关于服务器如何解释一个 URL 的后缀，以下几点需要理解：</p>
<ul>
<li>确定一个 URL 指向的是静态内容还是动态内容没有标准的规则。每个服务器对它所管理的文件都有自己的规则。一种常见方法是，确定一组目录，例如 cgi-bin，所有的可执行文件都必须存放这些目录中。</li>
<li>后缀中的最开始的那个 <code>/</code> 不表示 Unix 的根目录。相反，它表示的是被请求内容类型的主目录。例如，可以将一个服务器配置成这样：所有的静态内容存放在目录 <code>/usr/httpd/html</code> 下。</li>
<li>最小的 URL 后缀是 <code>/</code> 字符，所有服务器将其扩展为某个默认的主页，例如 <code>/index.html</code>。这解释了为什么在浏览器中键入一个域名就可以取出一个网站的主页。浏览器在 URL 后添加缺失的 <code>/</code>，之后服务器把 <code>/</code> 扩展到某个默认的文件名。</li>
</ul>
<blockquote>
<p>HTTP 事务</p>
</blockquote>
<p>因为 HTTP 是基于在因特网连接上传送的文本行的，我们可以使用 Unix 的 TELNET 程序来和因特网上的任何 Web 服务器执行事务。</p>
<p><img src="/images/csapp11.23.jpg" alt="csapp11.23"></p>
<p><strong>HTTP 请求</strong></p>
<p>一个 HTTP 请求的组成是这样的：一个<strong>请求行(request line)</strong>(line 5)，后面跟随零个或更多个<strong>请求报头(request header)</strong>(line 6)，在跟随一个空的文本行来终止报头列表(line 7)。一个请求行的形式是</p>
<pre><code>&lt;method&gt; &lt;url&gt; &lt;version&gt;
</code></pre><p>HTTP 支持不同的方法，包括 GET, POST, OPTIONS, HEAD, PUT, DELETE 和 TRACE。主要应用的是 GET 方法。</p>
<p><strong>HTTP 响应</strong></p>
<p>HTTP 响应和 HTTP 请求是相似的。一个 HTTP 响应的组成是这样的：一个<strong>响应行(response line)</strong>(line 8)后面跟随着零个或者更多的<strong>响应报头(response header)</strong>(line 9-13)，再跟随一个终止报头的空行(line 14)，在跟随一个<strong>响应主体(response body)</strong>(line 15-17)。一个响应行的格式是</p>
<pre><code>&lt;version&gt; &lt;status code&gt; &lt;status message&gt;
</code></pre><p>版本字段描述的是响应所遵循的 HTTP 版本。<strong>状态码(status code)</strong>是一个三位数的正整数，指明对请求的处理。<strong>状态消息(status message)</strong>给出与错误代码等价的英文描述。第9-13行的响应报头提供了关于响应的附加信息。针对我们的目的，两个最重要的报头是 <code>Content-Type</code>(line 12)，它告诉客户端响应主体中内容 MIME 类型；以及 <code>Content-Length</code>(line 13)，用来指示响应主体的字节大小。</p>
<p><img src="/images/csapp11.24.jpg" alt="csapp11.24"></p>
<h2 id="u5C0F_u7ED3-8"><a href="#u5C0F_u7ED3-8" class="headerlink" title="小结"></a>小结</h2><p>Web 服务器使用 HTTP 协议和它们的客户端彼此通信。浏览器向服务器请求静态或者动态内容。CGI 标准提供了一组规则，来管理客户端如何将程序参数传递给服务器，服务器如何将这些参数以及其他信息传递给子进程，以及子进程如何将它的输出发送会客户端。</p>
<h1 id="u5E76_u53D1_u7F16_u7A0B"><a href="#u5E76_u53D1_u7F16_u7A0B" class="headerlink" title="并发编程"></a>并发编程</h1><p>应用级并发在以下情况下很有用：</p>
<ul>
<li>访问慢速 I/O 设备</li>
<li>与人交互</li>
<li>通过推迟工作以降低延迟</li>
<li>服务多个网络客户端</li>
<li>在多核机器上进行并行计算</li>
</ul>
<p>使用应用级并发的应用程序称为<strong>并发程序(concurrent program)</strong>。现代操作系统提供了三种基本的构造并发程序的方法：</p>
<ul>
<li>进程。用这种方法，每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显式的**进程间通信(interprocess communication, IPC)机制。</li>
<li>I/O 多路复用。在这种形式的并发编程中，应用程序在一个进程的上下文中显式地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态。因为程序是一个单独的进程，所以所有的流都共享同一个地址空间。</li>
<li>线程。线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。你可以把线程看成是其他两种方式的混合体，像进程流一样由内核进行调度，而像 I/O 多路复用一样共享同一个虚拟地址空间。</li>
</ul>
<h2 id="u57FA_u4E8E_u8FDB_u7A0B_u7684_u5E76_u53D1_u7F16_u7A0B"><a href="#u57FA_u4E8E_u8FDB_u7A0B_u7684_u5E76_u53D1_u7F16_u7A0B" class="headerlink" title="基于进程的并发编程"></a>基于进程的并发编程</h2><p>构造并发程序最简单的方法就是用进程，使用那些大家都很熟悉的函数，像 <code>fork</code>, <code>exec</code> 和 <code>waitpid</code>。</p>
<p><img src="/images/csapp12.1.jpg" alt="csapp12.1"></p>
<p><img src="/images/csapp12.2.jpg" alt="csapp12.2"></p>
<p><img src="/images/csapp12.3.jpg" alt="csapp12.3"></p>
<p><img src="/images/csapp12.4.jpg" alt="csapp12.4"></p>
<p>对于在父、子进程间共享状态信息，进程有一个非常清晰的模型：共享文件表，但是不共享用户地址空间。进程有独立的地址空间既是优点也是缺点。这样一来，一个进程不可能不小心覆盖另一个进程的虚拟存储器，这就消除了许多令人迷惑的错误。</p>
<p>另一方面，独立的地址空间使得进程共享状态信息变得更加困难。为了共享信息，它们必须使用显式的 IPC 机制。基于进程的设计的另一个缺点是，它们往往比较慢，因为进程控制和 IPC 的开销很高。</p>
<h2 id="u57FA_u4E8E_I/O__u591A_u8DEF_u590D_u7528_u7684_u5E76_u53D1_u7F16_u7A0B"><a href="#u57FA_u4E8E_I/O__u591A_u8DEF_u590D_u7528_u7684_u5E76_u53D1_u7F16_u7A0B" class="headerlink" title="基于 I/O 多路复用的并发编程"></a>基于 I/O 多路复用的并发编程</h2><p>I/O 多路复用可以用作并发<strong>事件驱动(event-driven)</strong>程序的基础，在事件驱动程序中，流是因为某种事件而前进的。一般概念是将逻辑流模型化为状态机。不严格地说，一个<strong>状态机(state machine)</strong>就是一组<strong>状态(state)</strong>、<strong>输入事件(input event)</strong>和<strong>转移(transition)</strong>，其中转移就是将状态和输入事件映射到状态。每个状态都将一个(输入状态，输入事件)对映射到一个输出状态。<strong>自循环(self-loop)</strong>是同一组输入和输出状态之间的转移。通常把状态机花城有向图，其中节点表示状态，有向弧表示转移，而弧上的标号表示输入事件。一个状态机从某种初始状态开始执行。每个输入事件都会引发一个从当前状态到下一状态的转移。</p>
<p>事件驱动设计的一个优点是，它比基于进程的设计给了程序员更多的对程序行为的控制。另一个优点是在流之间共享数据变得很容易，而且事件驱动设计常常比基于进程的设计要高效得多，因为它们不需要进程上下文切换来调度新的流。</p>
<p>事件驱动设计的一个明显的缺点就是编码复杂，另一重大缺点时它们不能充分利用多核处理器。</p>
<h2 id="u57FA_u4E8E_u7EBF_u7A0B_u7684_u5E76_u53D1_u7F16_u7A0B"><a href="#u57FA_u4E8E_u7EBF_u7A0B_u7684_u5E76_u53D1_u7F16_u7A0B" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h2><p><strong>线程(thread)</strong>就是运行在进程上下文中的逻辑流，由内核自动调度。每个线程都有它自己的<strong>线程上下文(thread context)</strong>，包括一个唯一的整数<strong>线程ID(Thread ID, TID)</strong>、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。</p>
<p><img src="/images/csapp12.12.jpg" alt="csapp12.12"></p>
<h2 id="u591A_u7EBF_u7A0B_u7A0B_u5E8F_u4E2D_u7684_u5171_u4EAB_u53D8_u91CF"><a href="#u591A_u7EBF_u7A0B_u7A0B_u5E8F_u4E2D_u7684_u5171_u4EAB_u53D8_u91CF" class="headerlink" title="多线程程序中的共享变量"></a>多线程程序中的共享变量</h2><p>从一个程序员的角度来看，线程很有吸引力的一个方面就是多个线程很容易共享相同的程序变量。然而，这种共享也是很棘手的。</p>
<blockquote>
<p>线程存储器模型</p>
</blockquote>
<p>一组并发线程运行在一个进程的上下文中。每个线程都有它自己独立的<strong>线程上下文</strong>，包括线程 ID、栈、栈指针、程序计数器、条件码和通用目的寄存器。每个线程和其他线程一个共享进程上下文的剩余部分。这包括整个用户虚拟地址空间，它是由只读文本(代码)、读/写数据、堆以及所有的共享库代码和数据区域组成的。</p>
<p>从实际操作的角度来说，让一个线程去读写另一个线程的寄存器是不可能的。寄存器是从不共享的，而虚拟存储器总是共享的。</p>
<blockquote>
<p>将变量映射到存储器</p>
</blockquote>
<p>线程化的 C 程序中变量根据它们的存储类型被映射到虚拟存储器：</p>
<ul>
<li>全局变量：在运行时，虚拟存储器的读/写区域只包含每个全局变量的一个实例，任何线程都可以引用</li>
<li>本地自动变量：定义在函数内部但是没有 static 属性的变量。在运行时，每个线程的栈都包含它自己的所有本地自动变量的实例</li>
<li>本地静态变量：定义在函数内部并有 static 属性的变量，和全局变量一样</li>
</ul>
<h2 id="u7528_u4FE1_u53F7_u91CF_u540C_u6B65_u7EBF_u7A0B"><a href="#u7528_u4FE1_u53F7_u91CF_u540C_u6B65_u7EBF_u7A0B" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h2><p>共享变量是十分方便的，但是它们也引入了<strong>同步错误(synchronization error)</strong>的可能性。一般而言，你没有办法预测操作系统是否将为你的线程选择一个正确的顺序。</p>
<p>一些关键词：进度图，信号量，使用信号量来实现互斥，生产者-消费者问题，两类读者-写者问题</p>
<h2 id="u5176_u4ED6_u5E76_u53D1_u95EE_u9898"><a href="#u5176_u4ED6_u5E76_u53D1_u95EE_u9898" class="headerlink" title="其他并发问题"></a>其他并发问题</h2><p>这些典型问题是任何类型的并发流操作共享资源时都会出现的。</p>
<blockquote>
<p>线程安全</p>
</blockquote>
<p>四个(不相交的)线程不安全函数类：</p>
<ul>
<li>不保护共享变量的函数</li>
<li>保持跨越多个调用的状态的函数</li>
<li>返回指向静态变量的指针的函数</li>
<li>调用线程不安全函数的函数</li>
</ul>
<blockquote>
<p>可重入性</p>
</blockquote>
<p>其特点在于当被多个线程调用时，不会引入任何共享数据。</p>
<p><img src="/images/csapp12.37.jpg" alt="csapp12.37"></p>
<blockquote>
<p>在线程化的程序中使用已存在的库函数</p>
</blockquote>
<p>大多数 Unix 函数，包括定义在标准 C 库中的函数都是线程安全，只有一小部分是例外：</p>
<p><img src="/images/csapp12.39.jpg" alt="csapp12.39"></p>
<blockquote>
<p>竞争</p>
</blockquote>
<p>当一个程序的正确性依赖于一个线程要在另一个线程达到 y 点之前达到它的控制流中的 x 点时，就会发生<strong>竞争(race)</strong>。</p>
<blockquote>
<p>死锁</p>
</blockquote>
<p>指的是一组线程被阻塞了，等待一个永远也不会为真的条件。进度图对于理解死锁是一个无价的工具。</p>
<p><img src="/images/csapp12.42.jpg" alt="csapp12.42"></p>
<p><img src="/images/csapp12.43.jpg" alt="csapp12.43"></p>
<p>重叠的禁止区域引起了一组称为<strong>死锁区域(deadlock region)</strong>的状态。</p>
<h2 id="u5C0F_u7ED3-9"><a href="#u5C0F_u7ED3-9" class="headerlink" title="小结"></a>小结</h2><p>无论哪种并发机制，同步对于共享数据的并发访问都是一个困难的问题。提出对信号的 P 和 V 操作就是为了帮助解决这个问题。信号量操作可以用来提供对共享数据的互斥访问，也对诸如生产者-消费者程序中有限缓冲区和读者-写者系统中的共享对象这样的资源访问进行调度。</p>
<p>并发也引入了其他一些困难的问题。被线程调用的函数必须具有一种称为线程安全的属性。竞争和死锁是并发程序中出现的另一些困难的问题。当程序员错误地假设逻辑流该如何调度时，就会发生竞争。当一个流等待一个永远不会发生的事件时，就会产生死锁。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是我之前自学时的笔记，本文的内容为第二版，现在最新是第三版。</p>
<p><em>Notes from Da Wang, Feb.2 2015</em></p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="原理" scheme="http://wdxtub.com/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[烤箱指南]]></title>
    <link href="http://wdxtub.com/2016/03/26/oven-guide/"/>
    <id>http://wdxtub.com/2016/03/26/oven-guide/</id>
    <published>2016-03-26T19:23:14.000Z</published>
    <updated>2016-03-26T19:38:34.000Z</updated>
    <content type="html"><![CDATA[<p>在美国学会的技能之一就是用烤箱做懒人食品，但烤箱也是有门道的，尤其是各种香料，这里收集了一些基本知识和技巧，分享给大家。</p>
<a id="more"></a>
<hr>
<p>刀工和颠勺两样，前者关乎食材的准备，后者关乎火候，这两样学会了，大抵就错不了。再后来我发现，除了这两样之外，还需要两样东西，就是对食材的感觉，和对自己的信心。</p>
<p>每次看到一个菜谱后自己做时，我不会纠结我手头的材料和菜谱不是一模一样，我不会纠结具体的制作时间和放多少调料这些细节，因为我对自己有信心，因为我对自己对食材的感觉有信心。</p>
<p>食材好，做出来的东西一般不会有大问题，所以在战术上要重视食材，再好的技术，没有好食材也做不出美食来。</p>
<p>但是不能被食材所左右，真正在操作的是自己，美味的界限由自己来拓展，好食材只是工具，这就是在战略上藐视食材。</p>
<h2 id="u70E4_u8089_u5668_u5177"><a href="#u70E4_u8089_u5668_u5177" class="headerlink" title="烤肉器具"></a>烤肉器具</h2><p><strong>器材</strong></p>
<ul>
<li>一个大烤盘。这是你最基本的烤箱器材，用来烤大批东西用，而且在其它器材不足的情况下可以勉强代替使用</li>
<li>一个带烤架的深盘。有些东西烤的时候要考虑到各个方位均匀加热，用烤架架着隔空烤更加合适。而且这个深盘平常可以用来烤别的东西</li>
<li>一个中号的玻璃或者陶瓷烤皿。用来焗东西，或者用来烤小批的东西</li>
<li>几个小号的烤皿。用来做些快速方便的吃食，或者做开胃菜</li>
<li>一个可以进烤箱的铸铁煎锅/铁板。有些肉类需要先煎然后再进烤箱烤，这个时候如果能整个锅放进烤箱就方便好多</li>
<li>肉类温度计。烤大块肉的之后，要知道肉的内部有没有熟就要靠肉类温度计了，具体样子上面的图已经出现过了</li>
<li>其它小配件。比如烤串用的竹签，烤箱手套，锡纸，注射用的针管等等</li>
</ul>
<p><strong>调料</strong></p>
<ul>
<li>基本：盐，黑胡椒</li>
<li>香料：罗勒、迷迭香、百里香、孜然和王守义十三香（具体参见香料详解）</li>
<li>其它调料：蜂蜜（有时候烤肉时能刷），洋葱，蒜，烤肉酱，番茄酱</li>
</ul>
<h2 id="u7B80_u6613_u83DC_u8C31"><a href="#u7B80_u6613_u83DC_u8C31" class="headerlink" title="简易菜谱"></a>简易菜谱</h2><h3 id="u7ECF_u5178_u871C_u6C41_u9E21_u7FC5"><a href="#u7ECF_u5178_u871C_u6C41_u9E21_u7FC5" class="headerlink" title="经典蜜汁鸡翅"></a>经典蜜汁鸡翅</h3><ul>
<li>难度★★</li>
<li>腌一腌：鸡翅用味极鲜酱油、蚝油、五香粉腌一晚上。番茄酱什么的也可以随意放，反正怎么都好吃。</li>
<li>烤一烤：上烤架，为了防粘，烤架上面铺锡纸，用叉子戳洞，方便滴油。下面放烤盘接油。200℃ 10分钟，拿出来刷蜂蜜，继续10分钟。再拿出来翻面刷蜂蜜，10分钟。</li>
</ul>
<h3 id="u7EAF_u7237_u4EEC_u7F8A_u8089_u4E32"><a href="#u7EAF_u7237_u4EEC_u7F8A_u8089_u4E32" class="headerlink" title="纯爷们羊肉串"></a>纯爷们羊肉串</h3><ul>
<li>难度★★★★</li>
<li>切一切：无骨的净羊肉切大块。</li>
<li>腌一腌：用大量孜然粉、大量辣椒粉、一点盐抓匀，有的话还可以放一点蒜粉和葱粉。</li>
<li>串一串：就是串竹签。</li>
<li>烤一烤：烤架+烤盘接油，220℃ 10分钟，翻面再8分钟。</li>
</ul>
<h3 id="u778E_u70E4_u9E21_u8089_u4E32"><a href="#u778E_u70E4_u9E21_u8089_u4E32" class="headerlink" title="瞎烤鸡肉串"></a>瞎烤鸡肉串</h3><ul>
<li>难度★★★★</li>
<li>切一切：鸡腿肉切块。蔬菜（青红辣椒、洋葱、大蒜之类的，随意）等腌好鸡腿肉再切块。</li>
<li>腌一腌：切好的鸡腿肉用蒜末、味极鲜、蜂蜜腌半天。</li>
<li>串一串：就是串竹签。</li>
<li>烤一烤：220℃正反面各6分钟，中间刷点番茄酱、辣椒酱什么的。</li>
</ul>
<h3 id="u5965_u5C14_u826F_u70E4_u91CC_u810A_u8089"><a href="#u5965_u5C14_u826F_u70E4_u91CC_u810A_u8089" class="headerlink" title="奥尔良烤里脊肉"></a>奥尔良烤里脊肉</h3><ul>
<li>难度★★★★</li>
<li>切一切：里脊肉切片。</li>
<li>腌一腌：网上买奥尔良腌肉料，按照说明腌三小时以上。</li>
<li>串一串：就是串竹签。</li>
<li>烤一烤：200℃正反面各8分钟。</li>
</ul>
<h3 id="u9500_u9B42_u626D_u8170_u867E"><a href="#u9500_u9B42_u626D_u8170_u867E" class="headerlink" title="销魂扭腰虾"></a>销魂扭腰虾</h3><ul>
<li>难度★★★</li>
<li>切一切：大虾从背部切开，取出虾线，</li>
<li>腌一腌：橄榄油+蒜末+小米辣+鸡精做成酱汁，一只虾塞一小勺。</li>
<li>烤一烤：烤盘铺锡纸，200℃ 10分钟。虾壳脆扑扑也能吃。</li>
<li>如果不想要扭腰效果就用竹签串起来烤。</li>
</ul>
<h3 id="u70E4_u4E32"><a href="#u70E4_u4E32" class="headerlink" title="烤串"></a>烤串</h3><ol>
<li>猪肩肉</li>
<li>腌料，一个柠檬，柠檬皮刨丝，柠檬汁挤出来，按照柠檬汁橄榄油1:3的比例加橄榄油，放入海盐、现磨黑椒、蒜头碎、花椒、小茴香籽、孜然籽、罗勒、百里香和王守义十三香粉，一点老抽上色用。手边香料不全的话不要太过于纠结，少几味就少几味吧。</li>
<li>肉切成块，然后用竹签在肉上面戳几个洞，取几个台湾小香肠，也戳几个洞，把肉和香肠放到腌料里面拌匀，腌制半个小时。没香肠也行，不影响肉的味道。</li>
<li>各种颜色甜椒去籽切片，洋葱去皮切块</li>
<li>串起来</li>
<li>放进预热的烤箱里面（最好用烤架），200摄氏度，烤30-40分钟，熟了就能吃</li>
</ol>
<h3 id="u70E4_u7F8A_u817F"><a href="#u70E4_u7F8A_u817F" class="headerlink" title="烤羊腿"></a>烤羊腿</h3><p>零基础能做出来的大菜。</p>
<ol>
<li>买一块羊腿，前腿、后腿做法一样，你看着买</li>
<li>在脂肪比较厚的地方随便切几刀，这是为了方便入味</li>
<li>然后弄点干腌料。想吃羊肉原味的只用盐和黑胡椒就够了（我还用了干迷迭香、孜然和辣椒粉，其它料你看着加）</li>
<li>把混好的腌料均匀的抹在羊腿表面</li>
<li>拿个容器装起来，用保鲜膜包住。放冰箱里一晚上入味</li>
</ol>
<p>第二天</p>
<ol>
<li>搞定洋葱和蒜，表面洗干净就好了，然后洋葱切大块，蒜掰成瓣，不需要去皮</li>
<li>把羊腿从冰箱拿出来，表面抹一层油。不要怕油多不健康，最后这些油都会流到下面去的</li>
<li>用锡纸把烤盘包严实了。因为是低温慢烤，如果不包严实最后会烤干掉</li>
<li>然后烤箱里160摄氏度烤四个小时</li>
<li>把垫底的料和油留在烤盘里，羊腿装盘就能上桌吃了</li>
</ol>
<p>Q&amp;A</p>
<blockquote>
<p>问：为什么蒜不用剥皮</p>
</blockquote>
<p>答：因为这个蒜是为了调味，不是为了吃的，烤四个小时候剥不剥皮都一样</p>
<blockquote>
<p>问：为什么要烤四个小时，能不能烤短一点</p>
</blockquote>
<p>答：如果肉比较小的话可以适当缩短时间，但是低温长时间是用烤箱把肉烤烂的必要过程</p>
<blockquote>
<p>问：烤盘底部烤焦的油很难洗的样子啊</p>
</blockquote>
<p>答：烤盘倒满水，泡一个晚上，第二天早上一抹就抹掉了。</p>
<h2 id="u5982_u4F55_u7528_u70E4_u7BB1_u70E4_u51FA_u597D_u5403_u7684_u9C7C_u7C7B_uFF08_u6D77_u9C9C_uFF09_u6599_u7406"><a href="#u5982_u4F55_u7528_u70E4_u7BB1_u70E4_u51FA_u597D_u5403_u7684_u9C7C_u7C7B_uFF08_u6D77_u9C9C_uFF09_u6599_u7406" class="headerlink" title="如何用烤箱烤出好吃的鱼类（海鲜）料理"></a>如何用烤箱烤出好吃的鱼类（海鲜）料理</h2><p>西餐中，鱼肉的处理使用烤箱是非常常见的，因为鱼肉相比其它肉类来说比较脆弱，易碎，比较难处理，鱼肉也比较适合低温处理，不会一下控制不好火候，烤过头，进烤箱的话，对于那些比较薄的鱼肉、全鱼或是鱼排来说都是非常好处理方法，干燥的烤箱也起到很好的浓缩鱼肉和调料香气的作用。</p>
<p>用烤箱烤鱼基本有以下几种方法：</p>
<h3 id="u9AD8_u6E29_u70D8_u70E4"><a href="#u9AD8_u6E29_u70D8_u70E4" class="headerlink" title="高温烘烤"></a>高温烘烤</h3><p><strong>1.烤箱‘油炸’法</strong></p>
<p>为了防止鱼变老，这里我们需要给”鱼“穿上一层”外衣“再进烤箱，最简单的方法，我们可以裹上：蛋黄酱、黑胡椒、柠檬汁、洋葱粉、再撒满面包屑和一些黄油或橄榄油，大概220度，烤制20分钟</p>
<p><strong>2.先煎再烤</strong></p>
<p>这个方法很像中国人做鱼的方法，先煎炸再炖煮，西方人是先煎炸再进烤箱，这样可以使鱼肉的表皮能有很好的酥脆度还有焦香，我们可以用铁平底锅煎制，煎制的时候将带皮的面朝下。</p>
<p>大概5-6分钟后，鱼皮开始出现焦香，之后将其放入烤箱，烤个6-7分钟，有了解西餐料理的朋友们，应该对此做法不陌生，这种先煎再烤的方法可以运用在各种肉类的烹调里，比如大名鼎鼎的 Beef Wellington。</p>
<p>从烤箱拿出来后，我们将另一面再稍微煎制十几秒钟，烤好之后可以撒一些 Parsley</p>
<h3 id="u4F4E_u6E29_u70D8_u70E4"><a href="#u4F4E_u6E29_u70D8_u70E4" class="headerlink" title="低温烘烤"></a>低温烘烤</h3><p>烤箱温度基本在100度-120度，烤出的鱼肉整体都非常嫩滑，这种方式基本是通过烤制过程中的水分蒸发对流将鱼肉”蒸熟“</p>
<h3 id="u5305_u88F9_u70D8_u70E4"><a href="#u5305_u88F9_u70D8_u70E4" class="headerlink" title="包裹烘烤"></a>包裹烘烤</h3><p>我们可以用油纸、锡纸、或酥皮，东南亚喜欢用芭蕉叶等味道不影响主食材味道的材料。这种方法主要是不让鱼肉直接受热、这种方法可以使鱼肉受热均匀，这种做法最大程度的保留了所有食材的味道。这种方法类似于低温烘烤。</p>
<h2 id="u897F_u9910_u5E38_u7528_u9999_u6599"><a href="#u897F_u9910_u5E38_u7528_u9999_u6599" class="headerlink" title="西餐常用香料"></a>西餐常用香料</h2><p>植物香料太多，世界各地的加起来估计能有个上百种吧，光罗勒就有很多不同的分类，香味和味道都不一样。还有地域性分别，比如柠檬草，在东南亚菜肴中很常见，别的地方就不多。再有一些植物可做观赏可入菜，比如薰衣草、茉莉花之类。</p>
<p>香料的使用没有硬性规定，通常的建议是味道和香气淡的香料配白肉和鱼，味道辛辣、香味重的配红肉，不同香料混搭很多，可以自己多尝试。当然不按着常规用法来用问题也不大，自己怎么喜欢就怎么来，吃的开心最重要。</p>
<p>说几种西餐常见的吧，按照字母顺序来：</p>
<blockquote>
<p>多香果（All Spice）</p>
</blockquote>
<p>运用广泛，从腌鱼、烧烤酱、德国香肠、印度咖喱等等都有用。我自己有时候拿来卤肉吃，不是常见用法，但是效果普遍不错，比传统的中式红卤更添一层味道。</p>
<blockquote>
<p>罗勒(Basil)</p>
</blockquote>
<p>罗勒大概是各种香草里面最常见的了，干罗勒基本和各种肉都百搭。新鲜罗勒经常用来点缀菜肴和增加香气，用法和香菜类似。我的各种烤肉里面用颇多的罗勒，新鲜罗勒在上次做洛林糕的时候也有用到</p>
<blockquote>
<p>香叶（Bay Leaf）</p>
</blockquote>
<p>这个东西中餐西餐都有用，西餐里面香叶一般是不摆上桌的，也就是说上桌前会从锅里拿走。主要是在汤类和各种肉类食物准备和烹调过程中增加香味的。</p>
<blockquote>
<p>小葱（Chives）</p>
</blockquote>
<p>这个东西中餐西餐都用的很多，不同种类味道略有差别，但基本都是葱。西餐主要用来沙拉上，也常用来和海鲜、鱼肉调味，和各种芝士搭配也多。</p>
<blockquote>
<p>肉桂(Cinnamon)</p>
</blockquote>
<p>也是中西通用，也分很多不同的种类，和香叶一样一般不摆上桌。适合红肉类的烹调。</p>
<blockquote>
<p>丁香（Clove)</p>
</blockquote>
<p>欧洲菜不太用，一般也不摆上桌，适合红肉类的烹调，和其它红肉类香料比如肉桂、八角什么搭配很好。</p>
<blockquote>
<p>香菜(Coriander)</p>
</blockquote>
<p>西餐里面常用这个，和什么肉都很搭。我一般用来拌凉菜吃，沙拉也可以用。</p>
<blockquote>
<p>莳萝（Dill）</p>
</blockquote>
<p>味道淡，一般放很多才有味道，适合配鱼和白肉。我用来用来腌三文鱼，泡橄榄油，炒鸡胸肉吃。下面这个我腌的gravlax里面用到了上面提到多香果。</p>
<blockquote>
<p>蒜（Garlic）</p>
</blockquote>
<p>蒜整个烤、切丁炒、做成蒜泥烤都行，和各种肉类都很搭，主要看自己的口味，之前做牛排的时候也抹蒜来着</p>
<blockquote>
<p>姜（Ginger）</p>
</blockquote>
<p>各种肉去腥什么的，就不多说了</p>
<blockquote>
<p>墨角兰（Majoram）</p>
</blockquote>
<p>一般用来给汤和酱料调味</p>
<blockquote>
<p>薄荷（Mint）</p>
</blockquote>
<p>薄荷清凉味，一般配饮料，如Mojito之类，或者甜点。做菜可以配一些味道淡的肉、鱼、蔬菜</p>
<blockquote>
<p>肉豆蔻（Nutmeg）</p>
</blockquote>
<p>一般配蔬菜，比如土豆什么的</p>
<blockquote>
<p>洋葱（Onion）</p>
</blockquote>
<p>洋葱种类很多，单独炒菜、烤肉、熬汤都行，是西餐的基本食材和基本配料之一。我一般用黄葱</p>
<blockquote>
<p>牛至（Oregano）</p>
</blockquote>
<p>香中带微苦，意大利菜尤多。我一般不单独用，都是和别的香料混着用。</p>
<blockquote>
<p>欧芹（Parsley）</p>
</blockquote>
<p>这个东西主要就是点缀用，本身味道太淡了。</p>
<blockquote>
<p>迷迭香（Rosemary)</p>
</blockquote>
<p>香味浓郁，略带苦味，配鸡肉和羊肉最佳。</p>
<blockquote>
<p>番红花（Saffron)</p>
</blockquote>
<p>最常见的是西班牙海鲜饭，主要为了染色，可以用姜黄粉代替，效果差点。番红花种植难收成少，特别贵，都是按克卖。</p>
<blockquote>
<p>鼠尾草（Sage）</p>
</blockquote>
<p>法国菜常见，微辣，适合配猪肉</p>
<blockquote>
<p>龙蒿（Tarragon）</p>
</blockquote>
<p>法国菜常见，清香微甜，适合白肉和鱼。</p>
<blockquote>
<p>百里香（Thyme）</p>
</blockquote>
<p>法国菜常见，香味浓郁，配鸡肉、猪肉都合适。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在美国学会的技能之一就是用烤箱做懒人食品，但烤箱也是有门道的，尤其是各种香料，这里收集了一些基本知识和技巧，分享给大家。</p>]]>
    
    </summary>
    
      <category term="烤箱" scheme="http://wdxtub.com/tags/%E7%83%A4%E7%AE%B1/"/>
    
      <category term="美食" scheme="http://wdxtub.com/tags/%E7%BE%8E%E9%A3%9F/"/>
    
      <category term="菜谱" scheme="http://wdxtub.com/tags/%E8%8F%9C%E8%B0%B1/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[租房手册]]></title>
    <link href="http://wdxtub.com/2016/03/26/rent-room-guide/"/>
    <id>http://wdxtub.com/2016/03/26/rent-room-guide/</id>
    <published>2016-03-26T18:46:57.000Z</published>
    <updated>2016-03-26T19:17:23.000Z</updated>
    <content type="html"><![CDATA[<p>对于不在家乡工作的人来说，找房子算是相当麻烦的事情，这里是我收集的一些资料，希望给大家一些参考。</p>
<a id="more"></a>
<hr>
<h2 id="u623F_u5B50_u7C7B_u578B"><a href="#u623F_u5B50_u7C7B_u578B" class="headerlink" title="房子类型"></a>房子类型</h2><ul>
<li>地下室<ul>
<li>每个小区都有地下室，并且大都出租，自己去小区转转就能找到，因为房东大都会在地下室前面立个牌子写上出租。价位不等，租客鱼龙混杂，洗刷间男女共用。如果不是十分的困难不建议住，尤其是女生。不同小区价位不等，环境也有很大差别，冬天住还可以，夏天就十分热。还要注意冬天的时候有的没有暖气。对于大多数初到北京的北漂，大都住过，我住过，那种感觉怎么说呢，如果一个人住会有很孤独压抑的感觉，后来租了一个有窗户的，略微有光，还好一点。</li>
</ul>
</li>
<li>平房<ul>
<li>我把一、二层的放到一起来写吧，同区的价位也就比地下室贵个一到两百（不同地区不同），但是好歹在地上，环境也稍微好一些。</li>
</ul>
</li>
<li>群租房、床位<ul>
<li>群租房就是很多人一起租，本质也属于合租房，但是由于跟合租差别还是很大，所以跟合租房分开说。群租房分两种，一种是打了很多隔断的，这种一般是小中介代理的。一种是做成宿舍那种的床位，人很多，一般也是中介代理。</li>
</ul>
</li>
<li>合租房<ul>
<li>指没有打过隔断或者只在客厅打过一间隔断的房子。这种房子还是比较推荐大家来住的，因为确实人少并且住着也舒服。并且价位也不贵，适合收入尚可的学生和白领。后面会着重介绍。</li>
</ul>
</li>
<li>普通住房<ul>
<li>开间就是客厅和卧室在一起，即一室0厅一厨一卫。标准一居室就是一室一厅一厨一卫。室指卧室，厅指客厅，厨指厨房，卫指卫生间。</li>
<li>四居五居比较少有（不包括隔断），一般是豪宅会有，比如说山水文园、观湖国际等。</li>
<li>三居室以上要注意有的三居室是两卫，即在主卧室多出一个卫生间，有的没有。</li>
</ul>
</li>
<li>商住两用住房<ul>
<li>一般公司需要注册的，又不需要在底商的，会要租这种房子。童鞋们一般不用考虑这类住房，或者应该避开一些商住两用的，为什么？同环境同户型价位比一般住房要贵一到两千，而且水电要比普通的住房要贵。但是这类的装修都还不错，比较有代表性的是林达海渔广场。</li>
<li>有需要办公而租住这类房子的要注意要问这房子之前是否被注册过，如果注册过的话可以先去销一下。</li>
</ul>
</li>
<li>写字楼，底商<ul>
<li>写字楼是办公、这大家都知道。底商就是指那些底层的一楼商铺。这类房子报价通常是说几块钱，比如说3块钱，这里指的是3块钱/平/天。</li>
</ul>
</li>
</ul>
<h2 id="u627E_u623F_u6B65_u9AA4"><a href="#u627E_u623F_u6B65_u9AA4" class="headerlink" title="找房步骤"></a>找房步骤</h2><h3 id="u5468_u671F"><a href="#u5468_u671F" class="headerlink" title="周期"></a>周期</h3><p>至少提前一周，看房两次到三次，每次至少两套。</p>
<p>理想状态是半个月吧，但是记住这时间只是个参考，如果立刻遇到自己满意的房子要马上交订金，尤其是在3-4月和6-8月，因为这是租房高峰期，尤其是好房子，大家都在抢（因为房东一般都是多家中介报盘，客户比较多）。有时候只要耽搁半天好房子马上就没了~在租房高峰尤其常见。</p>
<p>此外有一个叫做租房低峰，大概就是指年前一个月左右。租房是其实没有低峰的，年前一个月客户少一点是确实但是绝对不是淡出鸟那种，因为精明的人都会在那个时候出来先看看房。</p>
<p>不要以为在临近过年大家都在退房房子很好租还会降价，北京的房价不曾降过的亲~你要是不傻绝对不要在过年的时候退房，因为回来之后马上就是返京高峰，知道前后的房子价格差多少吗？年后的第一个月两到三居室房价一般都会小涨100~500多。</p>
<p>我知道大家都想租便宜的，租金低的，位置好的，朝向户型优越，家具家电全齐，性价比高的房子~~~别想了，那种房子一般不存在。</p>
<p>豪宅除外，一般同个区域同个小区相同户型同等装修的房子差价不会超过200块钱~大家都不是傻子，能租到跟自己要求符合百分之七十的就差不多了，百分之百的很难找到，除非你找房的周期很长。</p>
<p>有时你会听到某人现在租的房租很便宜的，但人家一般那是租住了好多年的房子，北京房价涨的很快，现在确实很变态。</p>
<p>外环的房子要比内环的便宜的很多，京南的房子要比京北的房子便宜。所以沿着地铁找还是比较合适的。</p>
<p>北京的房子中介费大都是客户出的，但是也有业主出的情况，让中介帮你争取，在中介带你看房子的时候，中介一般都会跟你说业主不出，所以在中介说出这话之前，你要透漏给他你不想出的意思，这样可以诱导中介回去跟业主提这件事。否则一般中介都不会提。</p>
<p>在网上看房，有时看好的打电话问却被说是房子没了。有两个原因，一是你看的是钓鱼贴，中介用来钓客户的。二是这房子确实是被租了，中介还没来得及下架。第一个原因多一点。</p>
<p>跟中介看房子，除非是年后一个月的那段时间，尽量第一次不要定，尤其不要交钱。</p>
<h3 id="u9009_u5B9A_u533A_u57DF"><a href="#u9009_u5B9A_u533A_u57DF" class="headerlink" title="选定区域"></a>选定区域</h3><p>选小区两种方法：</p>
<ol>
<li>找中介</li>
<li>自己百度地图</li>
</ol>
<p>百度地图的三种方法：</p>
<ol>
<li>找工作地点近的小区。</li>
<li>工作地点一两到两站公交左右范围内的小区。</li>
<li>如果工作地点距离地铁近的话，沿着地铁站找。当然如果在北京的话个人还是建议第三条，虽然路上费点时间，但是省钱。</li>
</ol>
<p>了解价位的方法：</p>
<ol>
<li>问中介，不想去店里面的话可以在网络上留言，比如58、赶集等。</li>
<li>在网络上查，在北京的推荐链家在线，很权威，不过有些地区你要在此基础上减一到两百，百分之七八十还是很靠谱的</li>
</ol>
<p>选择哪个网站查询：</p>
<p>链家在线的原因：虽然有点做广告的嫌疑，但是这个确实很牛逼，链家花大价钱请IBM做的。</p>
<p>链家在线的数据与其经纪人用的内网se系统是对接的，se系统则全是当前公司全部房源的内部报价。相比其他的网站。比如58或者赶集安居客更准确——因为经纪人只会把好的房子往那些网站发，而不会发差的房子。此外现在这个网站上有很多房评，也有一些借鉴价值。</p>
<p>除了豪宅（上万的月租前后可谈价位空间大都在一到两千浮动）外，房子前后差价不会多于200。并且上面的房源百分之90多都是真的——个别可能业主通过其他中介租出去了没有销。所以看房价还是很靠谱的，尤其是买房。</p>
<h3 id="u67E5_u8BE2_u623F_u6E90"><a href="#u67E5_u8BE2_u623F_u6E90" class="headerlink" title="查询房源"></a>查询房源</h3><ol>
<li>公司如果给提供是最好不过了，遇到这种公司你就嫁了吧</li>
<li>如果人脉够宽广，最好是找熟人介绍，这种一般还是比较靠谱的，还能免去中介费神马的，最方便，并且租金还便宜。</li>
<li>找中介。</li>
<li>网络上慢慢翻业主自己发的贴</li>
<li>街边小广告，这是一种找房的方法，就是比较费时间，并且有些也不靠谱。</li>
<li>有些小区的物业也会做做，但是大部分还是做卖的房子的，比如御景园，但是费用照样收的。</li>
</ol>
<p>网站上大部分都是中介发的房子，所以挑个顺眼的公司顺眼的经纪人就行。</p>
<p>有一些有区别的是大一些的中介公司比如链家、丽姿行等房源是内部共享的，新老经纪人的差距就是讲价的能力，房源优势是一样的。</p>
<p>而有一些小公司他们的经纪人会藏房源，建议找个老经纪人，但是如果你涉世未深，也更容易被忽悠，摆脱不掉。</p>
<p>网上发的房源超过半个月的就不要给他打电话了。</p>
<p>链家在线（链家独有的），58同城，赶集，安居客，搜房网这些是租赁经纪人常用的网络端口，房源多且新。</p>
<p>新浪、焦点网、搜狐，这些是买房的人必看的几个，租赁房源不如前几个。</p>
<blockquote>
<p>什么样的房子是好房子？</p>
</blockquote>
<ol>
<li>精装修，家具家电全齐</li>
<li>朝向：即主卧室窗户的朝向，南北通透或者东南向、西南向、南向</li>
<li>主要建筑类型按照舒适度和人的密度排名：<ul>
<li>板楼：简单说就是分单元的长条楼，人均密度比较低，一般是6层（例如十里河周庄家园），不带电梯。当然也有带电梯的高板（小高层，参考十里河山水文园）。板楼的南北通透户型比较多。</li>
<li>塔楼：人均密度比较高吧，其他的也都还可以。（参考御景园）</li>
<li>板塔结合：一般是出现在小区四个角上的楼型（例如十里河美景东方拐角的四个楼）。</li>
</ul>
</li>
<li>集中供暖</li>
<li>不把边：一般是相对于板楼来说的，就是不靠楼的最边上的意思，听说冬天会有一些问题，不过我觉得还好吧。</li>
<li>地铁房：其实我觉得步行在十分钟左右的房子都可以算。</li>
<li>不临街：在小区中间的房子，不吵。</li>
<li>人车分流：一般高档小区才会这样，一般租房不需要考虑这个。代表十里河的山水文园。</li>
<li>1000米内没有六类嫌恶设施（这个很重要）：飞机场（1000米）、加油站50米、高压电站（15米，这个说明一下，主要是要看看窗外是否有，孕妇要远离这样的房子，有辐射）、垃圾处理场（500米）、工厂（200米）、墓地/殡仪馆</li>
</ol>
<h3 id="u8054_u7CFB_u4E2D_u4ECB"><a href="#u8054_u7CFB_u4E2D_u4ECB" class="headerlink" title="联系中介"></a>联系中介</h3><p>首先给各个中介公司按照好感度排下号</p>
<p>链家地产（北京最大的中介公司）、丽姿行（专做高端豪宅的，普通住宅业务不涉及，有想租豪宅的可以去）、麦田房产、中原、21世纪（一般是加盟店，其实人员素质也是参差不齐，一般也不要找）、顺驰……我爱我家。</p>
<p>我爱我家还是比较没好感的，因为同事出现过被枪单还被威胁的，这仇真记一辈子啊made。</p>
<p>前三家还是不错的，虽然是竞争对手但是觉得麦田和丽姿行还是不错的。但是链家和丽姿行中介费不打折（只有小部分情况下会略有小折扣。），其他的中介公司折扣就比较大，做私单的也比较多，比如我爱我家。</p>
<p>关于跟中介打交道几个事项</p>
<ol>
<li>中介电话都是24小时开机，随便什么时间打都行。不建议在在网页上聊天，因为北京中介们大部分时间不会守着电脑的。建议电话联系。</li>
<li>尽可能完善的把你的需求告诉中介，北京的中介行业相对成熟，服务也还不错（当然收费也高），他会给你筛选，以促进成交。</li>
<li>一定要守时。经纪人倒是无所谓，其实关键是给房东留下好印象。大家都很忙，有些房东很在意时间问题。</li>
<li>如果选定了某个小区，一般看两~三次房再定。因为一般中介带你看房子，会给你准备三套房一套最差，一套最好，一套居中的房子，这是中介最常用的ABC法则，一般看完第一次房子中介就会逼定，就是逼你交订金，一定要挺住。</li>
</ol>
<p>原因：第一次中介带你看房，其实也是在试探你的需求，所以如果开始对房子有什么需求，一定要跟经纪人说（当然不要当着业主的面说，因为会伤到业主。）</p>
<p>你第一次没定之后，他会根据你的需求信息再一次的筛选更优质的房源，而且有时候好房的房主不一定有时间。</p>
<p>另外中介第一次带你去看的房子一般都是有钥匙的房子，房源不一定优质，而第二次或者第三次则是更精心选的。</p>
<h3 id="u770B_u623F"><a href="#u770B_u623F" class="headerlink" title="看房"></a>看房</h3><p>一般一次两三套就行了，具体参考前面好房子的特点，但是这几个特别注意：</p>
<ul>
<li>房主是否是本人。</li>
<li>嫌恶设施。</li>
<li>中介费谁出。</li>
<li>水电燃气取暖费和物业费谁来出。</li>
<li>家具家电是否齐全（床、空调、冰箱、洗衣机，缺什么跟房东说好了。）</li>
<li>卫生间。</li>
<li>朝向，房间的朝向指的是主卧的朝向。</li>
<li>如果是塔楼，问问是否是管道层。</li>
</ul>
<p>普及知识：其实一般的中介会在报价的时候藏价，但是也有一些是真的给你谈下来的。主导价格的因素主要有两个：经纪人能力和客户形象</p>
<p>在客户挑房子的时候其实业主也在挑客户。业主都是很爱惜自己的房子的。特别注意以下几点：</p>
<ul>
<li>进房之前要穿鞋套，中介会为您准备的。</li>
<li>如果业主在，热情的跟业主打声招呼，离开后问好，给业主留下好印象。</li>
<li>跟业主简单交流时注意把以下几点“透露给业主”：工作稳定，住的人少，爱干净，爱惜房子等</li>
<li>进门后如果业主在，不要说房子破旧不好，乱挑毛病来自己压价。不要跟业主起冲突。</li>
<li>有什么不满或者要求等出门以后再说，把自己理想的价位跟经纪人说让他去谈</li>
</ul>
<h3 id="u7F34_u7EB3_u610F_u5411_u91D1_u6216_u8005_u8BA2_u91D1"><a href="#u7F34_u7EB3_u610F_u5411_u91D1_u6216_u8005_u8BA2_u91D1" class="headerlink" title="缴纳意向金或者订金"></a>缴纳意向金或者订金</h3><p>想说一个叫做意向金的，其他公司不知道，在链家这个意向金还是挺好用的（其他公司不太清楚），尤其是在租房高峰时。意向金不是订金，没有法律效益，可以收回，中介拿这个意向金有四个作用：</p>
<ol>
<li>拿着这个钱去跟业主谈价（对，一般的房子是可以谈价格的，浮动大概在200~300左右。浮动的原因大概有两个：1因为中介会藏一些价格。2中介没有藏价而是后期跟业主谈判砍下来的。），意向金代表你的诚意，如果中介砍价成功那么中介就会将意向金交给业主变成订金，就拥有法律效益，业主违约归还订金加违约金，你违约会没收订金。</li>
<li>禁止同公司的人竞争，先交意向金或者订金的人可以先谈房子。</li>
<li>把控客户。</li>
<li>还有一个小小的擦边作用就是利用2中所说的禁止竞争占房子，在高峰期时自己还不确定是否租这个房子时候用。</li>
</ol>
<p>注：如果房子不满意不要随便交钱，还有这些个金其实也没有一定规定要交多少，通常中介会说一个月房租，但其实500—1000的都可以，当然如果对房子真的有意向那建议交齐。还有要对经纪人说非常重要的一点：我让你交你才交。但是小公司不要随便交钱，会扣压。</p>
<p>交意向金后会有一个单据，要收好。</p>
<h3 id="u7B7E_u7EA6"><a href="#u7B7E_u7EA6" class="headerlink" title="签约"></a>签约</h3><blockquote>
<p>三方到场</p>
</blockquote>
<p>（中介公司代理房除外，避免吃差价），签约时长大概需要2-4个小时，合同期限一般是一年。</p>
<p>所需材料</p>
<ul>
<li>客户需要带的材料：<ul>
<li>本人身份证原件，</li>
<li>钱（中介费、房租和订金）</li>
</ul>
</li>
<li>如果你是替朋友租房或者签合同，那么需要带上：<ul>
<li>你自己的身份证原件</li>
<li>你朋友的身份证原件或者复印件</li>
<li>你朋友手写的授权委托书（如果是打印的需要有签字和手印）</li>
</ul>
</li>
<li>业主需要的资料（客户最好仔细看一下）：<ul>
<li>业主身份证原件</li>
<li>房本，没有房本的需要购房合同</li>
</ul>
</li>
<li>如果签约人非房主本人：<ul>
<li>签约人身份证原件</li>
<li>房主的身份证原件或者复印件</li>
<li>房主手写或者打印的委托书，</li>
<li>房本,无房本的需要购房合同</li>
<li>如果房主为两个人，一位没有到场的话需要他的同意出租证明。</li>
</ul>
</li>
</ul>
<p><strong>起租期：</strong>这个要注意，就是开始计算房租的日期，一般是签约的第二天。但是呢，如果你房子还没到期，可以协商把起租期定的晚一点。你就说给个搬家的时间，房东一般都会同意。一般可以争取到三天到一个周（所以周天看房，最好周一二晚上签合同，拿钥匙做物业交割然后白住一个周，哈哈），按照北京的房价，可以省下好几百。</p>
<blockquote>
<p>付款方式</p>
</blockquote>
<p>押金+支付的月租金。押金和租金全部交给业主，押金在房子到期后返还。</p>
<p>一般分为：押一付一（即押一个月租金付一个月的租金），押一付三（也就是季付），押一付六（半年付），年付。当然个别情况还有押金交两个月的。</p>
<p>大多数情况都是季付，当然付款方式越好，越有利于中介砍价，押两个月的租金和半年付、年付都属于比较好的付款方式，这样一般的业主也都乐于把价格再低个100—200。</p>
<blockquote>
<p>一般中介费标准</p>
</blockquote>
<p>一般是一个月房租，不同公司会有不同，具体询问。</p>
<blockquote>
<p>押金问题</p>
</blockquote>
<p>代理房押金是交给中介的，如果不是代理房那么押金是交给业主的，注意区分，给业主的一般都会退，交给中介的不一定。可能会克扣。</p>
<blockquote>
<p>续租缴费</p>
</blockquote>
<p>中介的代理房，看情况。跟业主签约的房子不需要再给中介缴纳中介费，中介费一次性付清。</p>
<blockquote>
<p>发票问题</p>
</blockquote>
<p>好多人提到发票问题，说不给开，倒不是想要偷税漏税或者很难开什么的，在这里给大家略为科普一下：</p>
<p>租房用到的发票有两个：服务费发票和房租发票。</p>
<p>服务费发票：即中介费发票，中介可以给你开服务费发票，时间一般是半个月到一个月的时间。</p>
<p>房租发票：中介不给提供。原因是无权提供。在北京在租房需要到当地街道办事处登记，是需要缴5%的税，所以大部分业主不想登记。</p>
<p>现在一般是客户拿着公司的证明文件（这个应该还分个人租房和企业用房，具体的文件问经纪人）自己到当地街道办事处开取，自己付税费。</p>
<p>负责的经纪人会代你去开取。所以这些问题都应该提前说明白，否则有些经纪人在收了钱后根本不鸟你，因为开这个发票也要一些时间。</p>
<blockquote>
<p>优先购买权</p>
</blockquote>
<p>你住的房子如果要卖，现租客享有优先购买权。</p>
<blockquote>
<p>物业交割</p>
</blockquote>
<p>仔细仔细再仔细</p>
<ol>
<li>检查各种电器，看看是否能用，不能用的要换。</li>
<li>要把水电燃气的表数抄在合同上。</li>
<li>墙体，水管等地方。</li>
<li>业主的家具以及贵重物品等级，要细化到牌子型号。 </li>
</ol>
<h2 id="u6311_u9009_u81EA_u4F4F_u623F_u768416_u5927_u5173_u952E_u8BCD"><a href="#u6311_u9009_u81EA_u4F4F_u623F_u768416_u5927_u5173_u952E_u8BCD" class="headerlink" title="挑选自住房的16大关键词"></a>挑选自住房的16大关键词</h2><blockquote>
<p>地段</p>
</blockquote>
<p>这个已经在『只谈房事』第一期用整个专栏的时间说过了，对于地段的选择，无论是自住型还是投资型，都是同样重要的。</p>
<blockquote>
<p>小环境</p>
</blockquote>
<p>就是指小区周边和小区内的环境，有点楼盘地段很好，但是小环境不敢恭维，一定要注意周边是否有高压电线，工厂，发电站等污染源，另外周边紧靠城中村的楼盘也要打折扣。</p>
<blockquote>
<p>容积率</p>
</blockquote>
<p>如果你去售楼处看盘的时候，很随口地问一句，这楼盘的容积率是多少，实用率是多少，售楼小姐肯定不敢忽悠你，因为一听就知道你是个行家。其实这个概念很简单，容积率是建筑总面积与建筑用地面积的比。容积率是越小越好，根据经验，豪宅的容积率通常都会在1.5以下。</p>
<blockquote>
<p>实用率</p>
</blockquote>
<p>上面说到这也是个专有名词，意思就是你实际的使用面积和建筑面积之比，通常不带电梯的多层的实用率会高达92%以上，带电梯的小高层在85%以上，超过15层的高层在80%以上都属于正常。有些楼盘的实用率会低的离谱，例如“信和自由广场”的房子的实用率只有70%多点，实在让人想不通面积都分摊到哪里去了。因为买房是根据建筑面积来算价的，所以买这样的房子是很不划算的。买商铺的更要注意这个，有的商铺的实用率能高达100%，“海印长城”下面的商铺，实用率才只有40%。所以买房算价格不仅仅是看单价那么简单，里面的猫腻还是很多的。</p>
<blockquote>
<p>建筑质量</p>
</blockquote>
<p>这个需要在楼盘在建的阶段就去工地实地考察，而且具有一定的专业性才能看出来。如果楼盘已经封顶了，或者买二手楼，如何判断呢？很久很久以前有个叫半球的房事达人，对每个楼盘都会亲自考察，并写一篇详细的调查报告，不过半球先生早已蜕变成职业写软文的托了。浑浑的水还有一个绝招，在每个新楼盘在销售的时候，都会在知名房产网站（如搜房网，房地产信息网）建立一个业主联系论坛，去翻一下论坛的历史内容，就能对楼盘的缺点有个最直观的了解。你能想象“学林雅院”居然没有打地基吗？你能想象“名家富居”居然没有设计排烟管吗？我也不能想象，但是我能从业主论坛了解这些信息。</p>
<blockquote>
<p>噪音</p>
</blockquote>
<p>这是浑浑的水特别重视的一个因素，这可能严重影响到睡眠的质量。不要听经纪说这个房子装了真空隔音玻璃，关上窗就特别安静这样的鬼话，不开窗的房子是没法住的。要特别注意，靠近高速路，立交桥的楼盘，是无论如何都不会安静的，即使你买的是背靠噪音源的方向也不行，不信可以去问问住“滨海之窗”，或者“创世纪滨海花园”的业主。</p>
<blockquote>
<p>楼层</p>
</blockquote>
<p>一楼通常会很潮湿，因为出入方便，安全性也差一点，有架空层的会好一些。一般楼层越高，采光和通风越好，如果旁边是马路的话，因为声波衍射的关系噪音高层的反而会比低层的要大一些。对于有电梯的高层来说，楼层越高，价格越贵，对于无电梯的多层只要记得“金三银四”就可以了。</p>
<blockquote>
<p>朝向</p>
</blockquote>
<p>这也是浑浑的水很在意的一个因素。在深圳，最好的朝向是南北通，卧室和客厅都朝南。其次依次是朝正南，东南，西南，东西通，朝东，朝西，东北，西北，正北。朝南还是朝北，对于居住的感受差异非常大。朝北的房子夏天会暴晒，冬天一点都晒不到太阳，夏天没有风，冬天的北风那个吹啊。西晒的房子一般都比较热，会让你花更多的空调费。</p>
<blockquote>
<p>通风</p>
</blockquote>
<p>通风跟设计有关，通风必须要对流，只有单面朝向开窗的房子是不可能通风的。有一些的楼盘对通风的设计很有问题，完全不通风，这样的房子对健康很不好，要慎重考虑。</p>
<blockquote>
<p>采光</p>
</blockquote>
<p>假如生活缺少了阳光，你自己衡量吧，浑浑的水觉得比较重要。</p>
<blockquote>
<p>住宅性质</p>
</blockquote>
<p>住宅性质分住宅和商住楼，房产证上面就有写。通常，商住楼里是可以作为注册地开公司的，而住宅不允许，所以一般商住楼里都有几家是开公司的，例如“青春家园”里有美容院，“金钟大厦”有家政公司等等，而“海王大厦”里基本很少住家了，大部分都是开公司的。住在这样的楼盘，来来往往的人员会很杂，所以要综合考虑。如何辨别住宅性质，最直接的是看房产证，或者还有个简单的办法，通常裙楼是商铺的住宅，性质都是商住楼。还有一个问题要特别注意，就是商住楼商铺的营业性质，如果是餐饮业的话是最糟糕的，小心可能会被油烟污染，最好能避开。</p>
<blockquote>
<p>学位</p>
</blockquote>
<p>浑浑的水特别提出学位的重要性，每个房子都有划分的小学和中学，如果划分的学校好，那么是一定会有溢价的，这个很容易理解，家长对子女的教育，都是愿意花费血本的！。例如深圳的老片区“园岭小区”，从1栋到75栋的是划分到园岭小学第一分部，75栋以上划分到第二分部，仅因为第一分部的房子就会比第二分部的房子每平方贵1000元以上。</p>
<blockquote>
<p>批地时间</p>
</blockquote>
<p>也就是地皮被批准可以建房子的时间，这个影响到房子的使用年限。目前住宅的使用年限都是70年，从批地时间开始计算。有些楼盘虽然是新楼盘，但是批地很早，使用年限是要打折扣的，例如“半岛城邦”的批地时间是1996年，入伙是2007年，这里就少了11年的使用年限。不过这个因素也不用太在意，根据新的物权法，对于这个年限到期后怎么办，根据浑浑的水的理解，只要该地皮不另作其他用途，则会自动续期，业主需要补交土地使用费，就可以继续拥有房产。</p>
<blockquote>
<p>户型</p>
</blockquote>
<p>户型的要点就是两个字“方正”。浑浑的水有个朋友精通风水，他跟我说过一句话，如果不找人看风水的话，那么就记住选择户型方正的房子，房子只要是方方正正的，风水问题都不会很大。另外就是要看浪费的空间多不多，有些房子的走廊啊，拐角都会占用过多的面积。</p>
<blockquote>
<p>开发商和建筑商</p>
</blockquote>
<p>如果在了解上面的因素后还有精力，可以再去查一下楼盘的开发商和建筑商的资历，和过往开发过的楼盘的业主论坛。像招商地产，华侨城地产这样的开发商的楼盘，通常都是有质量保证的。</p>
<blockquote>
<p>价格</p>
</blockquote>
<p>没错，浑浑的水故意把价格放在最后来讲。这里先讲一个故事，去年某天浑浑的水跟朋友聊一款车，这款车带天窗的要加2万块，他很喜欢天窗，但是觉得这个价格太不划算了，后来知道他还是买了带天窗的版本，问他为什么，他说了一句很经典的话，“我后来想通了，如果买带天窗的，我最多只心疼这2万块，如果买了不带天窗的，我会心疼整台车的价钱。”对自住房最大的感触就是，对于自己很在乎的因素，一定不要太在意价格，最关键的还是看你和这个房子的缘分。而且因为贷款的关系，其实首付价格的差别并没有你想象的大。</p>
<h2 id="u4E2D_u4ECB_u9632_u5751"><a href="#u4E2D_u4ECB_u9632_u5751" class="headerlink" title="中介防坑"></a>中介防坑</h2><p>话入正题，今天我们来聊一下和房地产中介打交道的实战技巧。其实浑浑的水并不是像你们想象的那样对中介恨之入骨，只是跟他们浑久了，对中介的黑比一般人有更深一层的了解而已。事实上，浑浑的水有一些朋友不巧就是在地产中介上班的，黑只是他们工作必须的态度而已，而并非都是他们的本性。说白了，房客和中介的关系，不过是相互利用的关系而已，尔虞我诈是不可避免的。在国内由于相关的规范和法律很不健全，所以中介基本上全部是没有诚信的。这个跟劣币驱逐良币的原理一样，当大部分地产公司都足够黑的时候，不够黑的地产公司是一定会最先倒闭的。</p>
<p>当中介带你看房的时候，会让你签一份看楼书，假如将来你买下了这套房而没通过这个中介的时候，麻烦就来了，你将会受到最恶毒的骚扰，还会威胁跟你打官司，直到你受不了给他们一些钱为止，这绝不是浑浑的水在恐吓你，这种事情非常多见。可能的话，我会尽量不一个人去，而带一个不真正参与交易的朋友或家人去签这份看楼书，就算自己签，也会用个假的名字和电话号码。这样的好处是，你可以委托多家中介帮你谈价格，假如你能直接跟业主达成协议，完全可以随便找一家中介帮你办手续，通常给2，3千块手续费就够了，否则就要支付高达房价3%的佣金，当然，这样做也要考验你做人的道德标准，浑浑的水认为对待本来就不讲道德的地产公司，根本不需要有道德的顾虑。</p>
<p>当你表示对一套房子感兴趣的时候，中介通常会用各种手段让你交一笔定金，说明谈到什么价格之后就必须签约，如果到时你想不买，定金是不退的，即使这单谈不拢，有些黑地产公司也一样不肯乖乖退款，他们会让你继续看其他的房子，直到成交为止。特别注意的是，这个价格不单单只约定单价的价格，还必须约定各种手续费，中介费，赎楼费，税费等由哪一方支付，中介通常会故意不告诉你这些，然后用最不利于你的价格来判断这个约定是否成立。浑浑的水在签约之前，是从来不交任何费用的，因为即使你不交，中介为了促成这单，也一样会去跟卖家谈价格，如果交了定金，只会让你更被动，如果中介实在不配合，完全可以换一家地产公司继续谈。记住，在交钱之前，你还是爷们，一旦交了第一笔定金，你就变成孙子了。在交钱之前，一定一定要考虑的非常清楚，真正抢手的笋盘不是那么容易碰到的，不要担心今天不签明天就被别人签了，中介通常会虚构其他的买家来促使你尽快交定金，当然这招我在卖房的时候也经常用，而且通常都很管用。</p>
<p>在和中介交谈的时候，对他说的话一定不要太相信，一切都以眼见为实。例如看房的时候说一套房子有100平方，而看到房产证的时候通常就只有90多平方，只要相差不太多，很多买家也就认了。还有很多例如是他亲戚的房子啊，独家代理啊之类的话，绝对是假话。除了假话，中介对迫使你签约都是很有一套的，所以跟中介交往一定要脸皮够厚，不好意思的人往往就直接签约交钱了，这种买家还是不少的，如果你实在脸皮很薄，强烈建议你带一个买衣服砍价很厉害的朋友来帮忙。</p>
<p>签合同之后，定金是必须支付给卖家的，假如中介代收的话，也一定要开具定金收据给你。而首付款，你一定要委托银行做资金托管，不要怕麻烦交给地产公司，这里有很大的风险，中天置业事件和创辉事件就是实例。大的地产公司通常会正规一些，而很多小地产公司会千方百计的让你把首付款打入他公司的账户甚至是个人的账户中，遇到这种公司要学会拒绝。签合同的时候一定要买方，卖方和中介三方同时在场，如果卖家跟中介交易进行了委托公证的话，一定要核实清楚委托人是否跟房产证的业主是同一人，否则你很可能被骗或者被吃差价了。</p>
<p>最后谈一个关于打印房地产交易合同的事情。为了保证交易合同的合法性，市政府管理部门拟定了一份标准的合同，这份合同可以在任何一家地产公司打印，也可以在房地产交易中心打印，是免费的。但是后来房协管理之后，取消了在房地产交易中心的打印，这样就必须要在地产公司打印合同。这样地产公司之间就建立了一条潜规则，打印合同必须交纳高达上千元的打印费，前段时间在深圳台第一现场也报道了这个黑幕。浑浑的水教你一招，遇到这种情况，不要轻易交费，直接跟中介声明要打电话到房协投诉，投诉电话是83785630，83785851，这招通常都能搞定。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于不在家乡工作的人来说，找房子算是相当麻烦的事情，这里是我收集的一些资料，希望给大家一些参考。</p>]]>
    
    </summary>
    
      <category term="找房" scheme="http://wdxtub.com/tags/%E6%89%BE%E6%88%BF/"/>
    
      <category term="租房" scheme="http://wdxtub.com/tags/%E7%A7%9F%E6%88%BF/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[买车养车开车指南]]></title>
    <link href="http://wdxtub.com/2016/03/26/car-guide/"/>
    <id>http://wdxtub.com/2016/03/26/car-guide/</id>
    <published>2016-03-26T18:46:43.000Z</published>
    <updated>2016-03-26T19:00:06.000Z</updated>
    <content type="html"><![CDATA[<p>估计以后工作了，在所难免需要买车，这里是平时收集的一些经验技巧。最重要的，安全第一。</p>
<a id="more"></a>
<hr>
<h2 id="u9009_u8F66"><a href="#u9009_u8F66" class="headerlink" title="选车"></a>选车</h2><h3 id="u4E00_u3001_u9884_u7B97_u8303_u56F4"><a href="#u4E00_u3001_u9884_u7B97_u8303_u56F4" class="headerlink" title="一、预算范围"></a>一、预算范围</h3><p>划分选车范围最简单也是最直接的条件就是钱。一般的预算分为两种，一种叫做落地预算，一种叫做裸车预算。</p>
<p>落地预算你可以理解为这一辆车从购买到能够正式上路行驶所需要的总共花费的预算，包括了买车之后所需要交纳的各种税费保险等费用：</p>
<p>裸车预算你可以理解为单独对车辆的售价所做的预算，不包括买车之后所需要交纳的各种税费保险等费用。</p>
<p>相信大部分人的购车预算都是前者，但是用这个预算来选车则很容易出现实际预算超标的情况，因为 20 万预算实际上是不够买下一辆 18 万出头的车的，在天朝各种税费再加上保险成本还是非常高的。因此我建议大家都把自己的购车预算折合为裸车预算，同时提供一个经验化的、粗略的换算公式：</p>
<pre><code>裸车预算 ≈ 购车预算 * 0.85
</code></pre><p>实际上如果完全最佳按流程来，真实的裸预算车会比这个数值高一些，但是考虑到有些 4s 还有绑定条款如必须在店内买一年保险等，再考虑到很多车主会去选择做一些全车坐垫脚垫、贴膜这样汽车装潢，适当的留下一点机动空间是有必要的。</p>
<p>这么一来，我们候选车辆范围就从和太平洋一样大的一千多个车系缩减成了一般不超过 300 款了——不过还是有北冰洋那么大。</p>
<h3 id="u4E8C_u3001_u8F66_u578B_u9009_u62E9"><a href="#u4E8C_u3001_u8F66_u578B_u9009_u62E9" class="headerlink" title="二、车型选择"></a>二、车型选择</h3><p>这里的车型指的是：三厢轿车（包括掀背车）/ 两厢轿车 / SUV / MPV / 旅行车 / 跑车 /（后面还有皮卡货车啊客车专业车辆啊之类的等等等等）。对于大部分的普通消费者而言，都是在前面的 5 种车型 （三厢轿车 / 两厢轿车 / SUV / MPV / 旅行车）中进行选择，后面的由于比较小众同时购车群体一般目的性比较明确，就不作为重点来描述了。</p>
<p>那么我们的这一步的任务就是，在这 4-5 种车中选出一种（至多两种——由衷希望你没看见这个括号里面的内容）车型作为自己的目标。那么下面就按照一个一个问题的顺序，来做车型的排除法。</p>
<h4 id="u7B2C_u4E00_u4E2A_u95EE_u9898_uFF1A_u8FD9_u8F66_u6B63_u5E38_u60C5_u51B5_u4E0B_u6700_u591A_u8981_u5750_u51E0_u4E2A_u4EBA_uFF1F"><a href="#u7B2C_u4E00_u4E2A_u95EE_u9898_uFF1A_u8FD9_u8F66_u6B63_u5E38_u60C5_u51B5_u4E0B_u6700_u591A_u8981_u5750_u51E0_u4E2A_u4EBA_uFF1F" class="headerlink" title="第一个问题：这车正常情况下最多要坐几个人？"></a>第一个问题：这车正常情况下最多要坐几个人？</h4><p>如果不会超过 4 人的话 MPV 就可以划掉了，如果正常情况下需要带上的人数达到了 6-7 人，那么你只需要保留下来 MPV 和 SUV 这两种车型，当然，我是把杰德这样的“另类”直接当做 MPV 来看的，只不过这是只能坐 6 个人的 MPV。（至于超过 7 人的情况，本人对所有 C<br>照不能驾驶的车都无法提供任何有用的选车帮助）。</p>
<p>在此我只强调一点： 假如你的车长时间需要乘坐 5 个人（如夫妻父母加上一个孩子），并且这五个人块头都不小的话，那么我建议你多考虑一下六座七座车型，因为目前大部分的 A/B 级轿车在后排坐三个人的时候，长时间的乘坐体验都是非常差的 。</p>
<h4 id="u7B2C_u4E8C_u4E2A_u95EE_u9898_uFF1A_u4F60_u9700_u8981_u8D70_u4EC0_u4E48_u6837_u7684_u8DEF_uFF1F"><a href="#u7B2C_u4E8C_u4E2A_u95EE_u9898_uFF1A_u4F60_u9700_u8981_u8D70_u4EC0_u4E48_u6837_u7684_u8DEF_uFF1F" class="headerlink" title="第二个问题：你需要走什么样的路？"></a>第二个问题：你需要走什么样的路？</h4><p>也就是你对于通过性的需要。为了方便分类先定义了一个通过等级。以下的定义无法做到准确分类，但是具有宏观上的参考价值。</p>
<ul>
<li>零级通过性 ：纯正跑车；</li>
<li>一级通过性 ：普通的轿车（两厢三厢和轿跑均包括在内）；</li>
<li>二级通过性 ：城市 SUV；</li>
<li>三级通过性 ：越野 SUV（也可以理解为“真正的越野车”）。</li>
</ul>
<p>同理，我也对不同的道路路况等级进行了一个定义（路况等级具有向上兼容的特性，即高等级的路况包含了低等级路况的全部内容）：</p>
<ul>
<li>零级路况 ：高速公路，较好的城市道路；</li>
<li>一级路况 ：高速公路，所有的城市道路，大部分的乡村道路，部分有道路的山路，部分工地道路；</li>
<li>二级路况 ：高速公路，所有的城市道路，所有的乡村道路，大部分有道路的山路，大部分的工地道路，极少量没有道路的复杂路况；</li>
<li>三级路况 ：高速公路，所有的城市道路，所有的乡村道路，所有的有道路的山路，有的工地道路，较多的没有道路的复杂路况。</li>
</ul>
<p>基本上而言，几级的通过性就代表了能应付的几级路况，并且通过性高的车辆都向上兼容各种低级路况。比如一般而言通过性为零级的各种法拉利兰博基尼是根本无法到二级路况中的山路去撒欢的，但是你开个牧马人在跑跑高速则是一点儿问题也没有。</p>
<p>那么是不是通过性越高的车型就一定越好呢？——当然不是！如果那样的话，我还是推荐大家都去买 jeep 牧马人——因为一般而言越高的通过性往往意味着相同类似的空间、动力级别下更差的操控性、更贵的价格、更高的油耗（当然价格和油耗这两条对零级的超跑到一级的轿车的过渡时不成立，物极必反嘛！）。做个比喻，类似空间和动力系统（强调一下：仅仅是宏观上的类似）的高尔夫 GTI 和途观 2.0T，前者属于典型的一级通过性，后者则属于典型的二级通过性。GTI的动力能力、操控水平远远超过途观 2.0T，而途观 2.0T 则更贵、油耗更高。</p>
<p>因此我给大家的建议是： 尽量根据自己所面对的道路等级去挑选对应级别通过性的车型，假如因为自己的喜好的原因希望扩大范围，那么也请务必将误差幅度控制在一级之内。</p>
<p>此外，原则上不建议所选择的车辆通过性等级低于自己的所需求的等级——除非是预算真的有限 。</p>
<p>举个例子，如果你就是城市道路通勤偶尔自驾，我建议你去购买轿车，可是如果你真的很喜欢坐得高高的感觉，那么选个城市 SUV 也可以，但是你如果你非得去买什么帕杰罗、普拉多之类的——我真的觉得有必要拉住你。反过来，如果你是一个越野爱好者，我觉得买一辆 A4L 绝对不是一个正确的选择——哪怕销售一再和你鼓吹这是一辆四驱的 A4L。</p>
<h4 id="u7B2C_u4E09_u4E2A_u95EE_u9898_uFF1A_u8FD9_u8F66_u4F60_u662F_u5F00_u6765_u505A_u4EC0_u4E48_u7684_uFF1F"><a href="#u7B2C_u4E09_u4E2A_u95EE_u9898_uFF1A_u8FD9_u8F66_u4F60_u662F_u5F00_u6765_u505A_u4EC0_u4E48_u7684_uFF1F" class="headerlink" title="第三个问题：这车你是开来做什么的？"></a>第三个问题：这车你是开来做什么的？</h4><p>这一点很好理解。如果你是做生意的或者是一家三四口家用的，那么三厢轿车绝对是你两厢轿车来得实用。可是如果你是小年轻一个人自己用的，那么两厢车的灵活和时尚则成为了加分项。喜欢旅游？SUV 和旅行车呀！</p>
<p>总之， 每一种车型的存在都是有其设计的出发点的，尽量让其的特色有用。不要让你的旅行车的超大后备箱始终只是一个孤零零的摆设，或者是让你的两厢车后备箱装不下的行李长期只能放在后排乘客的腿上。当作商务使用的时候我也真的不觉得一辆A3 DS5 之类的车会比一辆老老实实的帕萨特雅阁好——哪怕其实你对后备箱实际上是没什么需求的。</p>
<p>好的，三个问题结束，相信大家都已经有了自己的答案了。当然，可能有的同学就要问了：我这三个问题的答案有些是冲突的怎么办？比如我需要坐六七个人需要一辆七座的MPV 或者是 SUV，可又是做生意的，按说可能三厢车更合适，咋办？</p>
<p>请注意：以上三个问题是有排序的，当前后的问题答案出现冲突之时，以前面问题的答案为准。因为这三个问题的刚需程度是依次下降的。</p>
<p>希望此事已经确定了一种（至多两种——好吧，再次由衷希望你没看见这个括号里面的内容）车型作为自己的目标。那么再把这个也填写到你的选车条件里面去吧。</p>
<p>说明：在很多选车工具中，轿车的分类是微型车(A00 级，代表如 Smart)、小型车 (A0 级，代表如 POLO)、紧凑型车 (A 级，代表如速腾)、中型车 (B 级，代表如帕萨特)、中大型车 (C 级，代表如奥迪 A6L)、豪华车（D 级，代表如宝马 7 系），选车目标是两厢轿车 / 三厢轿车 / 旅行车可以按照你自己预算和空间要求选择 1-2 个作为大小范围。两厢车和三厢车是在【结构】一栏中进行选择的。不建议通过”座位数“进行选车，因为大部分的网站数据都有一些问题。</p>
<p>我们的选车范围总算从三位数降低到了两位数，一般情况下这里还剩下不到 50 款的候选车型，再也不像是大洋一样大了——不过依然多得让人没欲望一个一个看。</p>
<h3 id="u4E09_u3001_u52A8_u529B_u9009_u62E9"><a href="#u4E09_u3001_u52A8_u529B_u9009_u62E9" class="headerlink" title="三、动力选择"></a>三、动力选择</h3><p>其实想单纯的从账面的动力系统去看一个车的动力都是非常难的。因为每款发动机的标示参数不一样，每个厂商标示的真实性不一样，不同发动机动力输出区间不一样，匹配的变速箱型号不一样，相同型号不同车型变速箱的调教不一样。因此如果我们想从一个非常科学研究的角度来研究这个问题，会显得非常力不从心。但是如果我们跳开这些微观上的细节，本着正态分布 2σ的偏差来看，也就是 95.4%的可靠度来看——一般而言，一款车的排量大小基本上可以反映出来这辆车的性能水平。</p>
<p>我定义三种人：</p>
<pre><code>第①类：对动力基本没啥需求的，够用就行；
第②类：在够用的基础上希望动力别太肉，可以偶尔撒撒欢，想超车时无压力；
第③类：对动力要求较高，希望可以跑赢大部分的车，动力储备充足甚至过剩
</code></pre><p>对于这些人所需要的排量，按照 6 类进行分类讨论，以下①代表第①类人，以此类推，自吸代表自然吸气，增压代表涡轮 / 机械增压.</p>
<p>A 级车：</p>
<p>①自吸≤1.8L，增压≤1.6T；②自吸 1.6-2.0，增压 1.4T-1.8T；③自吸≥1.8，增压≥1.6T</p>
<p>B 级车 / 大部分家用 MPV/ 旅行车：</p>
<p>①自吸≤2.0L，增压≤1.8T；②自吸 2.0-2.4，增压 1.6T-2.0T；③自吸≥2.4，增压≥2.0T</p>
<p>C 级车及以上 / 大型 MPV：</p>
<p>①自吸≤3.0L，增压≤2.0T；②自吸 2.5-3.7，增压 2.0T-3.0T；③自吸≥3.5，增压≥3.0T</p>
<p>紧凑型 / 小型城市 SUV：</p>
<p>①自吸≤2.0L，增压≤1.8T；②自吸 1.8-2.5，增压 1.4T-2.0T；③自吸≥2.4，增压≥2.0T</p>
<p>中型城市 SUV：</p>
<p>①自吸≤2.4L，增压≤2.0T；②自吸 2.4-3.7，增压 2.0T-3.0T；③自吸≥3.0，增压≥2.5T</p>
<p>中型以上 SUV 级越野 SUV：</p>
<p>①自吸≤3.0L，增压≤2.5T；②自吸 3.0-4.0，增压 2.0T-3.0T；③自吸≥3.5，增压≥3.0T</p>
<p>以上的动力配置基本上都是比较靠谱，且范围算是比较大的，避免了大部分的误杀情况。当然，因为一些妖孽一样的发动机的存在（如上面提到的雷克萨斯 CT200 的那台 1.8L，还有反过来的例子如全新一代沃尔沃 XC90T6 上的那台 320 马力的 2.0T 以及高尔夫 R400 上面的那台 400 马力的 2.0T），所以在不远的未来难免会有一些极端情况的出现。不过对于大部分的位于中间部分的普通消费者而言，这些变化对于他们的影响并不大。</p>
<p>一般而言更强的动力系统也意味着更高的价格和更大的油耗（注：混合动力、油电混合算是价格上的例外，不过换来的一般都是更低油耗；除此之外小马拉大车和更高科技的发动机也可能导致动力更高的实际油耗更低，不过一般还会带来更贵的价格）。并且绝大部分驾驶员都不太可能完全发挥一辆车的动力潜能——也就是俗话说的没有肉车只有肉人。因此除非不差钱，否则我不建议动力配置过剩，适合自己的才最重要 。</p>
<h3 id="u56DB_u3001_u4E2A_u4EBA_u559C_u597D_u9009_u62E9"><a href="#u56DB_u3001_u4E2A_u4EBA_u559C_u597D_u9009_u62E9" class="headerlink" title="四、个人喜好选择"></a>四、个人喜好选择</h3><p>这里，大家总算是可以开始轻松愉快地完全按照自己的对于汽车喜好进行一些筛选了。在很多人的选车过程中往往都把这个放到了第一步第二步，而我则放到了第四步——没错，我的选车范围的划分顺序也是按照需求的重要性来排列的，当一个人还不够足够地了解车的时候（如果一个人可以已经“足够地了解车”，无论是真懂是假懂，他应该都不会再需要什么“购车推荐”了吧？），我个人认为其的很多“个人喜好”的优先级的重要性应该是低于价格、实用性的，甚至应该是低于动力配置的选择的。</p>
<p>在这个环节，大家所需要做的就是开始完善选车工具中的各个选项。比如手动还是自动，汽油还是混动亦或是干脆电动（补充说明一下，本人暂时不建议大家购家用型柴油车），国产品牌、合资品牌还是进口车，当然还可以选择一下哪个国家哪个品牌的车要哪个国家哪个品牌的车不要（嗯，派系粉们在这里总算可以把自己所痛恶的东西干掉了）。</p>
<p>此外在可以选择配置的地方，大家也可以把自己非常在意的一些配置选上去，如有些人无天窗不买，有些人没倒车雷达不考虑，有些人没有定速巡航不考虑，诸如此类的。我仅仅给大家提出一个建议： 在预算超过 10 万元的情况下，请记得选上 ESP 。在此顺带强烈鄙视一些无良厂家在 ESP 这样的基础安全配置上面偷工减料。</p>
<p>这里强调一点，请务必确定被自己拉黑的选项是自己绝对不考虑的，否则建议大家还是尽量少的在这一步做过多的选择，因为这里不是在列优先级、列权重，而是在做一票否决权，请慎用你的否决权，尤其是对某个车系的拉黑——虽然我依然会尊重你的选择，但是毕竟这样是很狭隘的！</p>
<p>没错，在这个什么都要看脸（和身材）的社会，车和对象一样，虽然实用性很重要，但是长得自己满意（起码不恶心）也是非常重要的。大家得辛苦一下，把所有候选车辆逐一打开，看看它的前脸，腰线，车位，中控。然后把自己 完全不能接受的 默默从名单中划掉。温柔的阿姨们总算可以把各种蒙迪欧阿特兹 CC 去掉了，年轻小伙也总算可以把各种君越天籁凯美瑞给去掉了。据说外形和内饰丑哭了一片人的斯巴鲁和长得个性得没朋友的欧宝雷诺在这一环节被大量评委直接淘汰——反正这一环节你的审美（或者说是眼缘）是唯一的标准。</p>
<p>如果在上面一个环节时你比较“博爱”剩余的车型比较多，那么我建议你在“看脸”这个环节的时候稍微严格一点儿，好好得做一些删减。而如果你在上一个环节已经把目标锁定到了三五辆车，那么我觉得你还是别苛求太多了，毕竟选着选着选没了可不好。</p>
<h2 id="u4E70_u8F66"><a href="#u4E70_u8F66" class="headerlink" title="买车"></a>买车</h2><p>如果车子只是随意挑选或是临时被销售人员说服但还想退、改的，写订金；</p>
<ul>
<li>如果车子是自己很喜欢确定了的型号或确定了的颜色非要不可的，写定金。</li>
<li>车辆是期货，一定写双方都能达成的交付时间并留有余地，这一点和销售人员协商并确认。</li>
<li>车辆有现货，交付期写今天或者自定的黄道吉日皆可；无论如何，一定要写。</li>
<li>逛车行，经常都能在经销店看到某某经典版，某某科技版等在厂家型录之外的型号，从杀价角度，不要参考这些加装的车型，要看厂家指导价。</li>
<li>如果你不在北上广，那北上广的价格对你基本没有参考作用，就算你在北上广，你在网上看到的北上广的价格对你也还是没有参考作用。</li>
<li>询价最好、最简单的办法，同城同品牌不同店询价，店不多的话，那就找同价位但更便宜一些的竞品车型做幌子。议价是情报战和心理战，娴熟的销售顾问能够了解到竞争店的库存和优惠，所以扯幌子尺度大了，比如要价过高，人家很可能认为你没真实购买意向没诚意；不了解库存，你说的车型只有他店有的话，他就吃定你了。</li>
<li>议价一定要快，不能被销售人员认为是意向级别不高的，要不人家电话都懒得给你打，得自己觉着这几天就下单了，言语间那种焦急和迫切的心态，一两天内几家内反复询价，坐在一家经销店给另一家店里销售打电话的紧迫感，一般的销售顾问都受不了就把底价报出去了。</li>
<li>车型选择上，一般的车款最低配都是拉低售价区间，配置惨不忍睹，最高配都是起营销作用，配置华而不实，中配的才是实在款。让利最多的型号很多时候不一定是最高配，而是库存压力最大的配置，什么型号库存压力最大？销售人员会主动推荐的，通常这也是卖得最好的配置（厂家压货），库存压力大的车型，通常比其他型号再便宜一些经销店都愿意（红蓝绿黄冷门颜色招手ing）。</li>
<li>前装车一般都是在车辆运输过程中局部部件损坏，按道理说这种车就不是新车了，而是事故车了，应该要返厂的，但是这其中的运输费用就摊在了4S店上，为了避免这种损失，聪明的领导们发明了「前装车」，用一些局部零件的更换来遮掩以前的损伤，通常前装车都是补过漆的，如果你购买的话相当于新车的价格买了个二手车。</li>
<li>每次你走进4S店销售顾问，都会热情地向你介绍车型，他们一般都优先介绍高配车，因为高配车的利润高，从而销售人员的提成也高，所以对于他们说自己的原装导航/真皮座椅/BOSE音箱/多功能方向盘等全部屏蔽之，你要看的是车不是附属电子，原车上面的配置所多出来的钱，你用一半就可以在汽配城买到，低配车永远是最高性价比，然后怎么砍价，很简单，去看车，然后试驾，满意了直接问销售顾问价格，此时他会让你留电话，你一定要装出一副不情愿的样子说「我觉得XX（竞争对手）也挺好的」然后给他留个电话，第二天他绝逼会给你打电话回访，你就说你现在正往XX（竞争对手）公司去准备去试驾，好的话就买了。</li>
<li>接下来的两个小时你会接到他无数个电话，压了给发个短信，直接报一个他们想都不敢想的低价，比如「二十万的车你说十六万能拿我就考虑去你们那里」，然后他们会给你报一个价格，但是现在价格还没有到底，去他们店里，然后找销售总监，就说这个价格可以，但是你还得送我一个全车镀膜／底盘装甲／原装脚垫什么的，他肯定会表现得特别为难，说「我们底盘装甲闹下来要三千多，全车镀膜六千多，原车脚垫两千多……」什么什么的，他说的这个价格除以十就是市场上的价格，他答应你一个就说明价格还有这么大的余地，话锋一转说算了，这个东西我不要了，你再给我便宜（他说那个配置的价格除以十）元吧，嗯……你成功地把销售总监闹潮了，他现在会表现得超级不耐烦，然后现在这个价格就是全市最低价了……想买车砍价还是蛮费工夫的，祝你们幸福。</li>
</ul>
<h2 id="u517B_u8F66"><a href="#u517B_u8F66" class="headerlink" title="养车"></a>养车</h2><ol>
<li>车子和人一样是要保养的，请根据说明书的指示定期或定里程进行保养和检查。4S当然可以保养保修，但是出保后如果能找到一家信得过的汽修厂更好，省钱也放心。</li>
<li>给轮胎打气的时候，别忘了车里还有个备胎，要定期检查备胎气压是否在正常范围内。</li>
<li>轮胎的厂家推荐气压一般都标在油箱盖或驾驶侧车门上，满载与空载情况下需要打的气都是不一样的。走高速胎压宜高不宜低，因为偏低的胎压反而会增加高速爆胎的危险，胎压稍微高一些还可以省些油。爆胎这件事可大可小，或许车子不至于失控，但是我相信你也不想在大热天搬动十多公斤的备胎吧？</li>
<li>机械式胎压表误差在0.1左右，实际使用的时候影响并不大。标准胎压是厂家经过测试后平衡了性能及经济性的一个参数，适当高一点的确偏离了这个平衡。但轮胎在高胎压状况下，温度和压力上升都比低胎压时要慢。新手可能疏于检查胎压，适当的高我认为会更稳妥一些。现在轿车轮胎都是低压胎，不是货车使用的高压胎。低压胎大部分情况是因为缺气而胎壁变形被碾坏，而很难因为胎压过高而炸开。每条轮胎都会在胎壁上标示出允许的最高压力，一般轿车轮胎是常温态3.0左右。只要胎压不远超这个数值，是不会因为压力过大爆开的。</li>
<li>轮胎尽量换好些的，不管是夏利、吉利还是宾利，汽车动力再大也得通过四个脚才能发挥出来，用好些的轮胎能减少安全隐患。平时勤检测，磨损到警戒线就该买新的了</li>
<li>汽油标号按照说明书的指示就好，加高标号的汽油对发动机没有坏处，而且油耗会稍微低一点点，省油不省钱。</li>
<li>更高辛烷值的汽油不代表油品更好，国内有些油站的97号汽油是通过添加剂来帮助达到标准的，油品甚至没有正规油站的93号汽油好。</li>
<li>按照压缩比选择燃油是以往化油器车的经验，如今的发动机都是电喷的，会根据燃烧状况进行相应调节，只要燃油标号不低于推荐值就不会出问题。</li>
<li>加油尽量去大公司的直营油站，不要去小油站或者大公司的挂靠民营油站。如果当地有外资的加油站也比较放心。</li>
<li>机油大致分三种：矿物油、半合成和全合成。4S店保养通常用的矿物油或者半合成油，同等使用状况下用全合成或半合成机油可以延长机油寿命，可以通过机油试纸来判断机油衰减情况。</li>
</ol>
<p>另外：</p>
<ol>
<li>会换轮胎。我以前的状态是在有起落架的情况下30秒一只轮胎，一般来说后备厢应该常备一个千斤顶和套筒，在需要的时候能独立拆卸和安装轮胎，免得出现有设备没本事搞的尴尬状态，好比我表哥上礼拜轮胎没气还开了好远，最后车胎爆了，然后一个电话害我老爸开了50多公里去帮他换轮胎（感觉好弱！），另外实习生刚进去最先开始做的就是给轮胎打气，按照我小半个月的经验来说，轮胎气打到轮胎硬，踢上去能有轻微凹痕为宜，太满的话开高速容易爆胎！</li>
<li>知道机油汽油制动油和防冻液的使用。没事机油尺拉出来瞧瞧，看看油线的位置和油的颜色，随时补充机油，如果颜色实在太黑记得去维修点更换机油，油箱尽量不要出现空油状态，制动油的颜色和刻度线位置要熟知，如果缺少太多记得及时补充，防冻液不仅起着防冻作用，也起着防止爆沸的作用，因此平时要保持水箱中防冻液和水的补充，别到了大冬天才想着加，大热天也是很需要的，如果你只用水的话100摄氏度就开始沸腾了！你的车开在路上会冒烟的哈哈哈！</li>
<li>刹车和油门的问题。可能有人会觉得我小题大做，我前东家是上海一家著名的上牌点（以按排量分别收取服务费用而出名），最让我无力吐槽的是当时有个老板带着司机来上牌，是辆百万的雷克萨斯，上完牌后老板很开心，要求自己开车回去，然后出了咱们店门，左转，加速，撞墙，四个气囊全部弹出来……好吧，你牛B你有钱，NO ZUO NO DIE的最好体现……然后老生常谈一句：开车时右脚平时放在刹车上，要加速再轰油门，轰完油门请高抬贵脚放回刹车上，谢谢！！另外如果刹车和油门感觉有黏滞的话请马上前去维修，制动系的问题都是大问题，一定要重视！</li>
<li>如果想要学习的话，最简单的就是跑4S店的维修区域找那些维修师傅去唠唠，切记不要跑到维修接待（汽车售后维护顾问）那里去，说真的这些维修接待除非有维修经验，否则基本都是些没学历没水平的。不是我个人吐槽或者鄙视啥，在4S店里除了老师傅，新进的维修工基本都有大专或本科学历且为相关专业有相关证书，这些都是硬指标；而负责维修接待的那些人反而只有中专职校级别，这工作不需要特定证书和技能，只要你会忽悠！比如打方向盘有异响是明显的转向轴问题，他们的报修单上竟然会写：左转右转方向盘会发出嘎吱嘎吱的声音，我们这些搞维修的除了orz真是无力了……但是不得不说，他们装得会比较专业，所以有问题找维修师傅问会比较靠谱，而你问维修接待多半会让先让你进保，这是本质上的区别。这里我插两句，你可以试试问这些维修接待：1.车辆保养要做的轮胎动平衡，具体是为了什么目的才做的，怎么做？指标是什么？2.刚才楼上说的所谓的燃油添加剂，添加燃油添加剂主要目的是什么？润滑？去积碳？那么积碳主要的成因是什么？为什么现在的车辆会有积碳？难道仅仅是因为油品不好？</li>
</ol>
<p>首先，对于车辆的日常保养请务必用心</p>
<ol>
<li>每两周校准车胎压，高端车型记得给胎压做初始化。这要求你记得胎压值，或者能识别左前门上的胎压值标签。胎压不准确的后果，直观地说有两个：其一，容易使车辆跑偏。一腿长，一腿短，这个应该比较容易理解。其二，会吃胎。胎压过高吃中间，胎压过低吃两边。再往大了说，操控性、油耗、胎噪都会影响到。</li>
<li>定期打开车辆的前盖，看看里面有没有小喵、小汪、小吱（老鼠）的脚印。猫猫狗狗最多在里面取暖，小吱可就没有那么客气啦，它们会咬线哦！会嘘嘘哦！会在里面修房子哦！运气好的话，你还能看见它们的宝宝哦！如果有脚印了怎么办？请先反思一下你的停车位，是不是在老鼠王国——地下停车场？还是在垃圾桶的旁边？你从来没有打开过发动机的下护板，所以你不知道里面会有煎鸡蛋水果核编织袋鼠便便……</li>
<li>如果是高端车，建议使用燃油添加剂。它是发动机的保养品，就像女孩子的面霜一样，不一定能让你返老还童，至少让你衰老得慢一点。国内的油品质检我不做评价，我是见过很多加完汽油后发动机故障灯亮的汽车。那什么，您都打算买了，就还是买4S店里的吧，有点贵，但是你的发动机会更喜欢一点。加油站的……我没用过，不做推荐。</li>
<li>洗车时请注意保护你的雷达、摄像头：它们有点娇弱，不耐高压水枪的折磨。还有你的软顶敞篷也是哟～</li>
<li>你再洗车时，要记得清洁雨刮片和前挡玻璃。玻璃上团状的水痕主要是油渍引起的，汽车尾气里的油液、路边烧烤摊的油液都会附着在玻璃上，所以清洁玻璃不光是去砂石，还有去油渍哦！</li>
</ol>
<p>在雨刮条和玻璃之间，会藏着很多细小的沙石。如果你不清理掉它们，它们就一直躲在那里，你一动雨刮，玻璃和雨刮都会受到磨损。还有雨刮是橡胶制品，不耐晒，老化以后刮动会有声音，会抖动，所以请给它防晒！宝马给出的建议是每六个月更换一次雨刮片，仅供参考啦！雨刮片是安全件，它们还是很重要的啦！</p>
<p>雨刮水壶的位置一般位于叶子板的位置，所以它的盖盖也比较边缘化，统一的标识是一个蓝色的盖子，就像这样（手机传不上图片，请原谅T_T，大家打开前盖自己找找吧）保养它的时候，请你：</p>
<ol>
<li>使用专用的雨刮水。不要用洗衣粉、洗洁精……</li>
<li>定期加水。有些质量不过关的雨刮水在缺水情况下会变成果冻，然后它们会堵在管道和喷头处，然后就堵上了，堵、上、了……</li>
<li>加水请加干净的水。理由同上，避免堵塞。</li>
<li>请阅读车辆的使用说明，知道雨刮液位低的报警标志。（我一定不会告诉你，有客人给我打电话说是花盆里面冒出烟花的那个灯……）</li>
<li>没有水的时候强迫雨刮喷水，驱动马达会烧掉的！</li>
</ol>
<p>然后我们来说说冷却液（先说重点的）</p>
<ol>
<li>发动机的整个冷却系统都是带压的！！！我们可以把它理解为：热车状态下的冷却液，就像是被狠狠摇过的可乐——一旦被打开就会成喷射状往外冒（请脑补……脑补不来请实验）。而且它的温度很高哟，看看你的水温表，它指几度水就几度。</li>
<li>冷却液是有颜色的，或者红色，或者蓝色。如果有天你看见车子下面有水，先分辨它是油还是水，如果是水，看看它有没有颜色。没颜色的是空调水，有颜色的是冷却液。确定是冷却液泄露以后，直接叫拖车，不要启动发动机！因为你是新手司机，你能做的只有求助场外观众。</li>
<li>如果冷却液没有明显泄露，只是有一点点减少（你目测它少了），可能只是冷却系统压力比较大，把它压瘦了一点，释放掉压力后液位会回升。</li>
<li>冷却液的液位一般在Min和Max之间就可以了，不要像处女座那样较真╮(╯▽╰)╭</li>
<li>如果非要添加冷却液，请只！加！一！种！在4S店里买一瓶，备用就可以了，不要红的蓝的绿的看着是冷却液通通往里加。</li>
<li>如果你决定加水，请加纯！净！水！不要认真地说：我特地给它加了农夫山泉……发动机不缺钙铁锌硒维生素，它要的是液体良好的循环性，且不容易产生水垢，所以各大品牌矿泉水可以留着您自己喝哈~</li>
</ol>
<h2 id="u5F00_u8F66"><a href="#u5F00_u8F66" class="headerlink" title="开车"></a>开车</h2><ol>
<li>汽车能开多快，它对人造成的伤害就能有多大。无论如何人的血肉之躯是无法与具有钢铁车身的汽车抗衡的。ABS、ESP等只能辅助你避险，而汽车往哪里开、开多快最终是由驾驶者决定的。所以需要永远把安全放在第一位，时刻注意安全，自己不要去撞其他的人和车，也尽量避免其他车或人撞到自己。商业保险当然也是必需的，特别是强制的第三者责任险，最好能买50万以上额度的，国内一线城市请尽量买一百万以上的。</li>
<li>车子是一件工业产品，所以使用它之前，请认真阅读它的使用说明书。不仅要了解车子有什么功能，还要把这些功能发挥到极致，这才是一个好的使用者。况且你为这些功能付了钱却不用也是一种浪费。</li>
<li>不要把东西放在阻碍视线的地方，例如前挡风玻璃下面或者后尾厢的搁板上面。汽车工程师为了改善驾驶者的视野下了很大的工夫，不要让他们的心血因为车内花花绿绿的挂饰而白费。而且视线被遮挡会造成行车安全问题，这是最致命的，也是你最不希望看到的。</li>
<li>车子的行驶证是需要随车携带的，所以最好在车上找个隐蔽的地方把它藏起来，保险等车辆相关证件也是如此。但驾驶证是身份证件，需要随身携带，不要放在车上。</li>
<li>在车子的储物格里面放一些现金、手电筒、创可贴和胶带等备用物品，以备不时之需。</li>
<li>「对于借车这种事情需要慎重考虑，因为发生重大交通事故的话车主要承担连带责任，所以车子轻易不外借，要借也得给那些你愿意为他们承担责任的人。」简单来说，从《侵权责任法》颁布以来，就没有机动车所有人承担连带责任这一说了。</li>
<li>认得路上的常见车型，这样你就可以在发生交通事故的时候准确地向警察描述车辆特征，比如「一辆银色奥德赛与一辆浅蓝色马自达5在滨河大道西行方向赤尾人行天桥附近发生擦碰逃逸」。另外一个办法就是使用手机拍照或者在车内安装行车记录仪，这些措施都有助于事故的处理，同时还能防碰瓷。</li>
<li>一定会为新车的第一道划痕、第一次擦碰而懊恼。但车只是个工具，人身安全才是最重要的。小划痕不要太着急处理，注意一年内的出保次数，尽量不要超过三次，以免因此影响下年的保费。</li>
</ol>
<h3 id="u9A7E_u9A76_u7BC7"><a href="#u9A7E_u9A76_u7BC7" class="headerlink" title="驾驶篇"></a>驾驶篇</h3><ol>
<li>上车前，注意观察车子的外观和车轮状况，留意车周围有没有小孩或者宠物狗在玩耍，车轮气压是否在正常范围内。</li>
<li>开车前调整好座椅位置和后视镜的位置。一脚把刹车和离合器踩到底时膝盖还能适当弯曲的坐姿是比较合理的，方向盘应调至双手手腕能自然落在其顶端的位置。</li>
<li>挂P挡或从P挡挂到其他挡位的顿挫感是因为变速箱的P挡卡锁的锁紧或释放，挂到D挡的顿挫可能是因为冷车时的转速差异，N挡转D挡的顿挫也有可能是变速箱的匹配没有做得很好。</li>
<li>挂挡时从P挡挂到D挡，快速通过R挡时是不会执行换挡动作的。因为现在的变速箱都是电子信号控制的，短时间通过R挡并不会触发换挡动作。</li>
<li>高跟鞋不是用来开车的，女性驾驶员可以在车上备一双平底鞋。</li>
<li>让车上的每一个人都系上安全带，包括第二排和第三排的乘客，12岁以下的儿童乘车要正确使用安全座椅。安全气囊、车身结构和吸能区在乘客没有系好安全带的时候都是没有用的。</li>
<li>方向打死之后要记得回一点，长期打死方向会导致液压助力转向系统处于最大输出功率，容易减少助力转向系统寿命。电动助力转向系统不存在这个问题。</li>
<li>车子启动以后要经常注意刹车是否正常，车辆满载时要比平时提早刹车。</li>
<li>有机会的时候试试大力刹车，体验一下ABS顶脚的感觉。知道自己的车子在极限情况下的动态表现，大力刹车是每一个驾驶者都需要懂的技巧。当然大力刹车的时候要通过后视镜注意后车动态，最好在急刹车的同时开启双闪灯提醒后车注意，以免被追尾，如果后面跟着大货车还是别急刹了，保证安全的情况下赶紧换个车道保命要紧。</li>
<li>驾驶的过程中经常注意看左中右三块后视镜，变线的时候更要多注意后视镜。</li>
<li>变线前记得打转向灯，提醒他人自己要变线了。</li>
<li>变道时要通过第二块侧窗观察自己的侧后方，看看盲区里有没有车辆。自己行车时也尽量避免在其他车的盲区范围内长时间行驶。</li>
<li>变线的时候尽量比别人快，让后车踩刹车的变线不是安全的变线，如果变线条件不足应该放弃变线。</li>
<li>从匝道转入主道时一定要注意主道的车子，必要时减速让行。并入主线时一定要尽快加速到车流均速，成功并线的标准就是不让主道的车子刹车减速。我觉得欧洲一部分国家的做法很好：每次主道的车辆路过匝道时都会变线到快车道，给右边车辆充足的空间并入主道。</li>
<li>每一次上路其实是一次占用道路资源的行为，在不超速的情况下请尽量把车开快些，这样交通会畅顺很多。不要在城市快速道上慢行，路上最危险的不是绝对速度，而是相对速度。车流速度80，自己只开40也是一种非常危险的情况。</li>
<li>学会防御性驾驶，眼光放远一些，预判路上可能会出现的各种突发情况，同时心中要及时想到合理、有效的对应方案。</li>
<li>在路上尽量远离大货车与大客车，尾随大货车的话有可能会被货斗内掉落的石头砸坏挡风玻璃，大货车后轮卷起的碎石也能把前挡风玻璃刮花。被大车尾随也是很危险的，国内的大车安全标准不够高，超载严重，紧急刹车的时候距离要比小车多不少，容易引起追尾。</li>
<li>行车的时候不要与其他车辆并排，这样会使得你的注意力分散到两侧，忽视前方的状况，也会阻碍后面的车辆超车，没有公德。</li>
<li>车灯不光能照亮道路，也能让别人看到你的车子，所以天色灰暗，看不清其他车辆的时候就应该打开前车灯了。深色车辆尤其要注意。</li>
<li>市区夜晚会车时不要开远光灯，前面有车的时候也不要开远光灯，变线提前打灯。雨雾天能见度差的时候打开前后雾灯，紧急情况下开双闪灯。夜晚超车时，如果前车没有注意到你偏离了车道，可以适当闪动远/近光灯并鸣喇叭。</li>
<li>如果有人在你正后方闪动远光灯的话那应该是你开得太慢了，有条件的话可以变道让行；有人在你侧后方闪动远光灯的话那就是要超车了，这个时候要保持行车路线，不要变线。</li>
<li>通过任何路口的时候，脚永远要放在刹车上而不是油门上，毕竟你不知道路口会冲出来什么，非机动车和不守规矩的车辆随时都有可能出现。</li>
<li>等红灯的时候如果时间较短建议踩住刹车踏板，如果时间较长的话可以挂空挡拉手刹，自己可以放松一下右脚，后面的司机也不会被明亮的刹车灯晃到眼睛。</li>
<li>绿灯起步排在第一位的时候，如果周围视野良好，没有行人冲出来的话，请不要吝啬那一点汽油，果断大脚油门起步，这样一个信号周期可以多过几辆车，后面的人会感激你的。但如果车子两边都是大巴或者视线不好的话那起步就要小心，因为你不知道大巴车头会不会突然出现一个闯红灯的冒失鬼。</li>
<li>作为司机要照顾好车上的每一位乘客，告诉不熟悉车内设备的他们哪些开关是干什么用的，行车时要锁住全车车门，有儿童的时候记得锁上儿童锁。下车的时候，乘客必须听从司机指挥，不要自行打开车门，司机要通过后视镜确认后方安全后才能让乘客下车。</li>
<li>开在小路上也要留意路边停着的汽车，它们随时都有可能打开车门，所以有条件的话尽量和它们保持一定距离。如果避让不开则尽快减速。另外注意它们的车头，面对突然冲出来的行人或者自行车要有心理准备。</li>
<li>下雨天为了确保安全，可以打开后视镜电加热开关蒸干后视镜上的小水珠。下小雨的情况下如果侧窗玻璃有些模糊，可以通过升降玻璃这个动作来刮掉玻璃上的积水。</li>
<li>雨天开高速要遵守雨天建议限速，避免急刹车与急打方向。上次我在深汕高速亲眼看到一辆还没上牌的凯美瑞在暴雨中因为急打方向失控撞护栏。在市区压过路边积水的时候尽量慢点开，避免溅到路人。若看见前方有深的水坑尽量绕开。涉水时最好换到手动换挡模式，保持油门使得水不会通过排气管倒灌进去。如果发动机进水熄火则不应再次尝试启动，否则发动机需要拆开大修，这个修复费用可就贵了。</li>
<li>不幸在路上抛锚的时候，一定要在车子后方足够远的地方立起警示牌。所有人应尽快离开车辆，在公路护栏后相对安全的地方等候道路救援服务。</li>
<li>对路况不熟悉的时候不要随意掉头、变道或者倒车，很多事故发生就是因为司机不认路的时候鲁莽处理，后车躲避不及撞上。去陌生的地方事先查看地图，在路上使用导航，力求做到心中有数。错过路口时千万不要紧急停车，应该直接往前走，在前面路口掉头或者下了出口重新上反方向的高速。</li>
</ol>
<h3 id="u505C_u8F66_u7BC7"><a href="#u505C_u8F66_u7BC7" class="headerlink" title="停车篇"></a>停车篇</h3><ol>
<li>停车前可以把后视镜往下翻15度，方便观察地面标线及路沿。现在很多车也自带这个功能，非常实用。</li>
<li>停好车注意观察一下车子有没有停正，有没有占用多个车位，有没有给旁边的车子留下开车门的空间。不注意这些容易被别人刮碰，给别人方便也是给自己方便。</li>
<li>如果可能的话在车辆左边留多一些空间，副驾驶一般没有司机细心，猛一下开门容易碰到旁车。</li>
<li>车驶入地下室请开启近光灯，不要因为地下室灯光够亮就偷懒，开灯是为了让别人注意你。倒车的时候要把音响关掉，车窗打开，不然音乐会分散注意力，甚至让你错过倒车雷达的警示声音。</li>
<li>倒车时可以利用刹车灯和前后灯光进行距离估算，有的时候比倒车雷达还好用。</li>
<li>MPV和旅行车的尾厢门开启角度非常大，尾厢门会升得很高，在地下室打开尾厢的时候要防止尾厢门碰撞到地下室的通风管道。</li>
<li>下车的时候，记得确认所有门窗都关闭了，尤其是天窗，不然下起雨来就惨了；同时还要确认所有电器、灯光是否关闭，否则电池会很快没电，就会打不着火。停车时车内不要放显眼的财物。</li>
</ol>
<p>写了这么多，概括起来就是开车给人方便，别人就会给己方便。处处为人着想就会少很多不必要的麻烦。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>估计以后工作了，在所难免需要买车，这里是平时收集的一些经验技巧。最重要的，安全第一。</p>]]>
    
    </summary>
    
      <category term="安全" scheme="http://wdxtub.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="车" scheme="http://wdxtub.com/tags/%E8%BD%A6/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[北美二手车购买指南]]></title>
    <link href="http://wdxtub.com/2016/03/26/na-second-hand-car/"/>
    <id>http://wdxtub.com/2016/03/26/na-second-hand-car/</id>
    <published>2016-03-26T18:46:27.000Z</published>
    <updated>2016-03-26T18:52:15.000Z</updated>
    <content type="html"><![CDATA[<p>这里是之前收集的一些在美国买二手车的注意事项和相关技巧，分享给大家。</p>
<a id="more"></a>
<hr>
<h2 id="u6982_u8981"><a href="#u6982_u8981" class="headerlink" title="概要"></a>概要</h2><h3 id="u7B80_u5199_u540D_u8BCD_u6CE8_u91CA"><a href="#u7B80_u5199_u540D_u8BCD_u6CE8_u91CA" class="headerlink" title="简写名词注释"></a>简写名词注释</h3><ol>
<li>Kbb，指著名的二手车估计网站 www.kbb.com 。其中给出了具体年份里程车的参考价格。</li>
<li>Craigslist，简称 CL，著名的二手物品交易网站，美国的 58 同城。</li>
<li>Sedan，SUV，coupe 等等都是指车的类型，或者车的结构是怎么样的。比如 coupe 是特指两门或者三门的 跑车/运动型轿车  类型。具体细分，还有 full size，medium size，compact sedan。</li>
<li>MPG，miles per gallon，借代指车子的经济性价比，即省不省 gas。</li>
<li>Make/model，make 是指车的生产厂商，比如 本田/丰田/宝马/奔驰/奥迪/…，model 是指具体车的型号，比如 野马/3 series/A6/CTS 等等。结合起来，就是 Audi A6，Ford 等等。</li>
<li>DFBB，指北美四大神车，分别 Toyota Camry，Toyota Corolla，Honda Civic，Honda Accord，排名不分先后。在2000 年左右在北美华人论坛上很火，一直到现在。这四种车以保值性高，可靠性强，誉为神车。</li>
<li>Vin，是每辆车独有的号码，独一无二，相当于车的身份证号码。查车的历史就是通过 Vin 来查的，只有两个公司提供的报告可靠，一是 Carfax，另一个是 Autocheck。</li>
<li>DMV，即美国的车管所。车辆注册买卖，驾照什么的都在这里办。</li>
<li>Title，即车子的归属权。一般有 clean/clear title，salvage title，duplicate title 等等。其中，salvage title 是属于出过重大事故，车子被total了，即维修的估算超过了车的价值。出过事故的车也可能有 clean/clear title。有一种 title 是属于没有还清贷款的 title，忘了叫啥。总之，买车只买 clean/clear title 的车，尤其当你是车盲的时候。</li>
<li>Registration，指车辆的注册，在车牌会有一个小贴纸，写明了过期的年份月份，比如 08/15。如果过期需要去 DMV renew，过期不算犯法，但上路会被警察 pull over。如果你要买的车的 registration 过期了，去 renew 就可以了，不要紧的。</li>
<li>Smog check/emission test，指年检，没通过就不能  renew registration。各州法律不同，一般十年以上车龄的车需要做。在加州，如果卖家没有做好 smog check 就卖车，是违法的。</li>
</ol>
<h3 id="u4E70_u4E8C_u624B_u8F66_u7684_u539F_u5219"><a href="#u4E70_u4E8C_u624B_u8F66_u7684_u539F_u5219" class="headerlink" title="买二手车的原则"></a>买二手车的原则</h3><ol>
<li>车子必须CleanTitle。CleanTitle 说明不仅车子不是报废车，还说明车子的所有产权都是title上面的主人。没有欠银行贷款。</li>
<li>车子可以容忍大修的历史，撞过的历史，或者租过的历史。当然没有最好。</li>
<li>一手交钱一手交title，title需要车主的signature。</li>
<li>朋友/熟人/师生/情侣之间不做买卖，道理你懂的。</li>
</ol>
<h3 id="u4E70_u4E8C_u624B_u8F66_u7684_u57FA_u672C_u8FC7_u7A0B"><a href="#u4E70_u4E8C_u624B_u8F66_u7684_u57FA_u672C_u8FC7_u7A0B" class="headerlink" title="买二手车的基本过程"></a>买二手车的基本过程</h3><p>(在这里只谈CL即Craigslist的途径，其他情况可借鉴)</p>
<ol>
<li>找个一个合适的Post，打电话联系卖家。</li>
<li>要VIN#，利用Carfax或者AutoCheck的账户查车的历史。</li>
<li>确定见面看车时间地点，试车。</li>
<li>去一个修车厂找个mechanic做个inspection。</li>
<li>一手交钱一手交title。</li>
<li>去DMV办手续，也可以让AutoRegistration Company 代办，手续费大概40刀。</li>
<li>一番折腾后，终于拿到了带有你的名字的title。你落泪情绪飘零，来地里发经验求大米。</li>
</ol>
<h3 id="u9664_u53BB_u8F66_u4EF7_u5916_uFF0C_u517B_u8F66_u7684_u82B1_u9500"><a href="#u9664_u53BB_u8F66_u4EF7_u5916_uFF0C_u517B_u8F66_u7684_u82B1_u9500" class="headerlink" title="除去车价外，养车的花销"></a>除去车价外，养车的花销</h3><ol>
<li>去 DMV 注册的费用以及交易税。这部分费用一般不能减免，另外最好不要把交易的价格填得很低，这样虽然能省一点税，但对你不利。当然，各州情况不同，我这里是 CA 的情况，在 AZ 买车是没有交易税的。至于多少，一般 registration 的费用大概 100 刀左右，交易税是 8% 左右吧，不好估计。</li>
<li>保险。保险有得是按月份，有的是按年。我在大农村的地方，用的最低保险，300 刀管半年。保险这个因人而异。</li>
<li>油费。这个可以自己计算。利用车子的 MPG 和自己平时走的路程。保守点算。</li>
<li>维修与保养。其实很多活自己可以 DIY 做的，我也写了一些帖子介绍。比如换 brake pads，前后八片用中上档次的牌子，自己换的话一共用不了 80 刀。看到版上有人1000多刀换了这些，感到心痛。可见 dealer 有多黑，放血是往死里放。咳咳。</li>
<li>停车费用，自己看看学校 parking lot 的收费标准。</li>
<li>罚单。我平均6个月会收到一次停车的罚单，最近一次是在 Downtown LA 停车的时候，没有把咪表给的回执放到车窗前面。两个月后罚单寄到家里了。童鞋们要吸取教训，以后有在咪表的地方停车，需要把缴费的小单放到前窗显眼的位置。</li>
</ol>
<h2 id="u660E_u786E_u4E70_u8F66_u7684_u76EE_u7684_28WHY_29"><a href="#u660E_u786E_u4E70_u8F66_u7684_u76EE_u7684_28WHY_29" class="headerlink" title="明确买车的目的(WHY)"></a>明确买车的目的(WHY)</h2><p>主要是这两个方面</p>
<h3 id="u901A_u52E4"><a href="#u901A_u52E4" class="headerlink" title="通勤"></a>通勤</h3><p>包括上下学上下班什么的，每天至少10mile的来回。</p>
<p>主要特征：每天必须用车，车如果坏了的话基本生活大受影响(&gt;80%)。一年的里程数应该能到5000 miles。其实一年5000 miles 不算多了，如果在LA 这种大地方通勤，一年20000 miles也很正常。全美国汽车的平均年里程是10000 miles左右。如果你买车是来通勤，就可以稍微算算到时候卖车的里程数，看看值不值当。</p>
<p>评价：车子如同是鞋子，天天要用，reliability非常重要。另外如果往返距离比较长(超过30mile)，需要考虑一下车子的MPG (Mileage Per Gallon)。</p>
<h3 id="u8212_u9002"><a href="#u8212_u9002" class="headerlink" title="舒适"></a>舒适</h3><p>包括方便买菜、方便出去玩、住得不远(5mile来回或者有公交站)但有车方便。</p>
<p>主要特征：一周用2-3次，不是天天开，车如果坏了生活略受影响(&lt;30%)。一年的里程数有3000 miles就不错了，可能主要是去华人超市或者小长途(往返500miles)。这时候，比较高里程但年份新的车子就比较适合你了。等到resale的时候，虽然你的车买来时里程比较高，但由于你没怎么开，自然就和年份平衡了。</p>
<p>评价：车是提高生活质量的东西，所以没有必要上cheap used car。这时候可以重点考虑resale 的情况。</p>
<h2 id="u786E_u5B9A_u9884_u7B97"><a href="#u786E_u5B9A_u9884_u7B97" class="headerlink" title="确定预算"></a>确定预算</h2><p>根据你买车的目的，确定自己的预算。或者，由你的预算，确定你买什么车。(以下都是USD不是人刀)</p>
<ol>
<li>Tier 1。10k以上</li>
<li>Tier 2。8k- 10k</li>
<li>Tier 3。6k- 8k</li>
<li>Tier 4。4k- 6k</li>
<li>Tier 5。4k以下</li>
</ol>
<p>这里有一个很重要的前提，就是你的预算决定了你和什么人打交道。永远记住：如果车主不是个好人，那么他要卖给你的车肯定不值得买。社会有三教九流，而不同社会地位的人由于收入不一致，开的车档次当然不一致。这里粗略分了五个档次，大概说说：(四大神车不在讨论范围之内，DFBB)</p>
<ol>
<li>最顶层的人，卖的车子都在10k以上。一般来说，这样的人不太会缺钱，所以砍价比较好砍。另外，这些人也是有着好的收入，不会为了自己的二手车而浪费太多精力。所以，绝大部分这样的车都是trade-in给dealer了，能留到CL上面的这部分车不多。一般车主都是白富美或者高富帅学生，上完大学4年以后新车变老车便卖掉走人。值得注意的是，这类车由于价格高，其实在CL上面买家没有多少的，所以很多车主也就trade-in了。买这一类车，只要你的offer高于dealer给车主的trade-in价格2k以上，估计就十拿九稳了。</li>
<li>最下面的人，卖的车子都不超过4k。这部分人，相当的鱼龙混杂。相当大的几率你会遇上curbdealer，属于自己做car business 靠坑蒙拐骗赚黑心钱，这类人一般心狠手辣，专骗不会开车看车的新手。有前辈指出怎么分辨curb dealer，最简单就是直接问车况，不说 make 和 model。如果对方说 which one?，那么99%是curb dealer。其次，如果是 title 不是卖家的名字，但是却签好名了，那么也90%是curb dealer。剩下的基本都是收入低下的红脖、尼哥、莫莫或者是穷学生。对于要买这一类车的人，必须要有强大的汽修知识，开车熟练，方能在剩下的这一部分卖家的破烂里面找到适合自己的车。当然这里面也有好车的，可是买这一类车难度很大，跟赌博一样，如果你连车都开不稳，又没有预算，那就算了吧。</li>
<li>其余档次的人。这里的就是普通人了，无非是中产阶级家里长大的伪白富美或者小红脖。没有什么特别注意的地方，不过卖家一般都不会轻易松价，得一口口吃，别妄想一下砍1k以上。</li>
</ol>
<h2 id="u9009_u62E9_u5408_u9002_u7684_u6E20_u9053_28HOW_29"><a href="#u9009_u62E9_u5408_u9002_u7684_u6E20_u9053_28HOW_29" class="headerlink" title="选择合适的渠道(HOW)"></a>选择合适的渠道(HOW)</h2><ol>
<li>二手车行，即 dealer。车行的车比较全，而且买来方便，也会有 Warranty。在车行买车是可以讲价的，但别期望能讲得很低。Sales 们都是人精，会使用各种手脚胁迫你买车，一般人不好对付他们。所以，如果在车行买车，那么你肯定是不差钱的了。</li>
<li>租车公司，如 enterprise，hertz 等等。租车公司的车特点是新，一般是 2012年，2013年的车，迈数都很大，每年迈数在 30k 左右。二手车的价格是固定的，不能讲价。讲价的特例也就是除去运输费。比如说你想在 LA买一辆红色的 Camry，但不幸全洛杉矶都没有，只有 San Diego 有这样一辆车。而租车公司运车过来就要收运输费。这里的运输费可以讲下去，但是例子很少。Hertz 卖的车有三天的试驾时间，就是说如果你三天内想退车，可以退而且只会收你三天的租车费用。值得注意的是，租车公司是资本家，具有吸血的自带天赋，能 15000.01 刀卖你的车绝对不会 15000 就卖你，所以也算是一分钱一分货，价格比 Kbb 的 good 略微低一点点。</li>
<li>特殊的组织卖二手车，比如说学校、教会等等。比如说，campus police department 有一批退役的警车，就会定价在学校或者社会公开卖。可能价格是 fixed，也可能是拍卖的形式或者 best offer 的形式，因学校而异。而教会呢，这些二手车的来源可能是 donation，而且教会为了省事，会订出比较低的价格卖这些车变现。这种买车机会可遇不可求，一般情况下是遇不到的。</li>
<li>拍卖会，即 auction。拍卖，是获取大量二手车的主要途径。在拍卖行里面有很多的私人 dealer 或者是本地非著名的中型 dealer，很少私人买家。</li>
<li>在北美省钱快报上面买其他小留的二手车。这是个买二手车的新途径，而且很多车都是豪车或者是特别新的车。不过最近有华人 dealer 冒充卖家卖车，需要提高警惕性。缺点就是地理位置限制，另外数量也不多。</li>
<li>在二手网站 craigslist 上面买二手车。这种方法是本文提倡的，也是重点讲解的。</li>
</ol>
<p>总结一下，如果你想买豪车或者是很新的二手车，那么可以去车行、租车公司或者北美省钱快报，其他途径90%的情况下都没有你想要的车，你也没必要看这篇文章了；其他情况建议去craigslist。</p>
<h2 id="u9009_u62E9_u5408_u9002_u81EA_u5DF1_u7684_u4E8C_u624B_u8F66_28WHICH_ONE_29"><a href="#u9009_u62E9_u5408_u9002_u81EA_u5DF1_u7684_u4E8C_u624B_u8F66_28WHICH_ONE_29" class="headerlink" title="选择合适自己的二手车(WHICH ONE)"></a>选择合适自己的二手车(WHICH ONE)</h2><p>这节内容是假设你已经决定在craigslist上买车了，其内容也同样适用于其他买车途径。这里介绍我选车的方法，如果按照这种方法选车，相信最后在你面前出现的是好车的几率会大幅上升。做任何事情都有相对合适的方法，而如果方法得当，那么最后完成事情的成功率会比方法不正确的完成要高。我一直认为其实买二手车是很需要方法的，具体的技巧甚至是车型都是其次的。他们的区别在于，方法是战略，而mechanics或者make/model都是战术，在战略面前显得太过不重要了。不禁想起了当年校长的“以空间换时间”的战略，即便国家贫瘠，战斗力低下，但只要战略正确，还是可以有相对高的成功率的。废话有点多，还请见谅。Let’s do this, yo！参考在第一节里的“买二手车的基本过程”，下面参照其基本过程给出详细操作步骤。只有两大步，选车和见面。</p>
<h3 id="1-_u5728_CL__u7684_u521D_u6B65_u9009_u8F66/_u5E7F_u544A"><a href="#1-_u5728_CL__u7684_u521D_u6B65_u9009_u8F66/_u5E7F_u544A" class="headerlink" title="1.在 CL 的初步选车/广告"></a>1.在 CL 的初步选车/广告</h3><p>在 CL 上面选车是件长期的事情，要做好艰苦抗战的准备。一般没有30天每天1小时的间隔地刷，是找不到自己想到的车的，所以不要着急。另外，有些看似是Deal 的Post 会被卖家delete掉，也就是卖掉了，也没必要伤感。因为买二手车并不是抢Deal这么简单，它是要陪伴你好几年的坐骑咳，着急不得。邪恶一下，说不定这种Deal有个什么隐形的毛病，一时半会看不出来。比如高速堵车时水温容易过高的毛病，就需要高速20分钟以上同时堵车才能出现，所以说是隐形的。抢了车的人很可能事后后悔不已呢，咳咳。</p>
<p>如何有效地浏览各种 Post</p>
<p>打开 CL 你所在的城市，比如 Phoenix。如果你住的地方比较大，比如 Los Angeles，那么还可以选 Long Beach/Santa Monica 等等的各种郡。当然如果觉得太远的话就可以只看离自己地点近的地方，因人而异。点击 Cars/Trucks for Sale by Owners，进入各种 Post 的页面。然后选择 gallery 的方式， newest first 的排序，选必须有 pic。选好之后，再去 research 栏里面填期望的价格。注意一定要填一个最低价，以筛选掉很多陷阱或者垃圾。比如你预算是 6000 USD，那么价格可以填 min:4000，max:7000。之所以 max 比自己的预算高，那是因为最后的成交价一般会比卖家 Post  的低。好了，这样一来，很多无效的 Post 都已经被过滤掉了，下面进入第二步。</p>
<p>点开 Post 后的再次筛选</p>
<p>a. 首先看 Post 的日期，指第一次 Post 的日期。如果这个 Post 之前 Post 过，那么你应该有印象是好是坏，可以凭感觉甚至图片关掉。本着群众的眼睛是雪亮的道理，好 deal 是轮不到你猥琐男的，一出来就会被抢掉的。所以呢，剩下来的车一般都不是性价比最好的，好车况的车需要降降价。超过3天的 Post 一律不要看了，除非是由于卖家主动降价导致的 Repost，不然都不要看了。</p>
<p>b. 其次看车是不是 Auto Transmission 自动挡，手动车就直接略过 ctrl+W 吧，当然如果你会开或者不介意那没关系。没写的话默认它是自动挡。</p>
<p>c. 接着看 Year/Make/Model 和 Odometer。这里争议比较大，一般年份10年左右的也可以接受了，但是 Odometer 最好不要超过 130k。在这里还是要俗套地说一下：我觉得如果是德国车，超过 100k 的话就不要了吧；美国车，超过110k 就不要了吧；日本车，超过 120k 就不要了吧。当然只是大概，楼主我可能会被喷，不过各位看官权当看看，了解个大概就好了。<br>d. 然后看卖家写的介绍。几个关键词：clean/clear title(必须有，如果是 salvage title 那么最好不要)，1st owner(有最好，没有也行)，有没有电话(没有电话的一律假设是骗纸)，有没有 leaks，换过什么东西(验车的时候要重点查除了这几个之外的大件)。</p>
<p>e. 最后结合所有情况，决定要不要给卖家打电话。</p>
<p>打电话干什么</p>
<p>打电话问广告里面没有的内容，特别是没有给出的特别重要的信息。一般来说，没有给出关键信息说明卖家对这个信息持消极态度。也就是说，这个关键信息对车价的影响是不良/负面的。比如，如果原文没有给出 VIN，那么需要索要 VIN#，查一下看看有没有不良的记录。又例如，没有给出里程数，那么基本可以确定车的里程特别的高，因为里程数是很明显不可能 miss 的关键信息。然后根据纸面车况和历史，把价格初步砍一砍。最后如果不错，那么就约个时间见面试车吧！哎？等等，怎么个见面，也是有学问的！</p>
<p>见面的时间地点选择</p>
<p>时间选择，最好是工作日工作时间，比如3p mon Monday。原因很简单，一是如果要去做inspection，那么得在车行工作时间可以做。可以提前预约，也可以不预约排队。二是如果要交易，写check银行能马上出钱，同时银行有人可以开证明。当然，当天办title这个不是必须。如果你当天因为这些原因不能验车或者交易，那卖家第二天把车卖给别人了就很可惜了。地点选择，最好在餐厅，比如麦当劳之类的地方。一是有wifi，如果卖家没给你VIN，你可以过去后抄下来当场查；二是公共场合，能保证安全。三是麦当劳一般靠近所在地的主要干道，附近的公交车站密集，方便你回家。</p>
<h3 id="2-_u89C1_u9762_u51B3_u5B9A_u662F_u5426_u4EA4_u6613"><a href="#2-_u89C1_u9762_u51B3_u5B9A_u662F_u5426_u4EA4_u6613" class="headerlink" title="2.见面决定是否交易"></a>2.见面决定是否交易</h3><p>a. 根据卖家的表现，确定他|她卖车的真实目的。<br>凡事都有个因果。卖家之所以卖车，也无非是有原因的：</p>
<ol>
<li>修好破车或者倒卖车辆赚钱</li>
<li>避免trade-in给dealer或者贱卖junkyard 损失更多钱</li>
<li>甩掉包袱，破车修不好了，投入的钱太多了</li>
<li>升官发财后，猛将配好马，屌丝逆袭换车了</li>
<li>其他</li>
</ol>
<p>这里的1.&amp; 4. 是主动性卖车，2.&amp;3.　是被动性卖车。所谓主动，是车主并不着急，主动权在他|她手上；所谓被动，是车主不得不卖车，有他|她自己的个人小原因，可能是搬家横跨美国了，可能是老车毛病太多，不值得修了。如何得知卖家的真实意图呢？直接问就可以了。从卖家的言语神态还是可以捕捉到蛛丝马迹的，这里就看你的察言观色能力了。结合卖家的回答，再利用下面介绍的一些trick，揣摩卖家的真实意图。</p>
<p>Tips</p>
<ol>
<li>Why do you want to sell your vehicle?如果回答是说换车了，接2；如果回答是说搬家要卖车，接3；如果是其他回答，那么卖家基本说的实话，因为所有原因里面只有前两个最好，或者说最合理最有逻辑。</li>
<li>Cool, bro. Got a new car? Can I have a look at it?如果确实看到新车了，车主还打开车门让你看看的话，基本原因就属实。啰嗦几句，如果说是因为有孩儿换了大车(SUV，minivan)，那么看看有没有专门的儿童座椅，如果有的话，这肯定是实话了。又或者是老婆怀孕，那看她肚子就行了..</li>
<li>Move to where? What time will you leave? 如果你是在他|她house或者Apartment里面，随便问问有没有其他|她不需要的或者搬不走的东西，说不定还有好deal呢。应该能观察到房间里打包的行李什么的，而且如果卖家说什么家具都不卖，从而推测出卖家是否在说谎。当然，如果地点支支吾吾的最后说了个近的，比如住在LA说要搬去LasVegas 或者Phoenix，那么可疑了，这么短的距离为何不开车去呢？如果说要回国了，那么无解了。不过说回国的，那也出现一个优势，就是砍价的时候可以尽情往下去，直到比dealer给的trade-in价格高些就行了。因为如果回国，车子肯定要卖，卖谁都一样，给bestoffer 就会卖的。而且这种回国的人，随着时间的拖延，卖车欲望会指数增长。也就是说，如果你看到之前这个回国的卖家隔了几天又把车post出来了，那么就是急了。把价格稍微压一压就可以拿下了。</li>
</ol>
<p>下面分析，针对各种真实卖车原因：</p>
<ol>
<li>赚钱赚钱赚钱！这一条卖家卖车就只是为了赚钱。无论是修好的破车还是倒卖的车辆也好，如果卖家卖车是为了赚钱，那么这动机不纯洁，什么伤天害理的事情都会发生的。车子坚决不要！靠卖车赚钱的人通常车的title都会有问题，这是很明显的证据。比如说，title上面不是他的名字，但却签好字了，说明卖家在倒卖车；title的日期很近，比如说一个月之前卖家买了这辆车，这样就很不正常。</li>
<li>避免损失更多钱，指的是卖家不希望只得到dealer的lowball offer，想卖多一点钱，这时候车子的情况可能还是不错的，就是价格可能坚挺，毕竟主动权在卖家手上。</li>
<li>修不好的破车，无论到谁手上都是烫手的山芋。一般这样的车，有明显的缺陷。比如CheckEngine Light 亮着，或者是出了车祸前bumper破烂不堪Coolant洒了满地的。车况劣等。</li>
<li>发财换车，是件好事。一来卖家手上宽裕，买了新车心里高兴，砍价好些；二来旧车不是由于机械故障才出售的，所以车况一般不错。值得注意的是，由于一般买新车dealer都会主动要求trade-in客户的旧车，所以可以说这卖家是当时拒绝了dealer的lowball offer 的。当然也可能有其他原因，比如生了小BB，家里需要SUV而不是Sedan了。</li>
<li>情况比较复杂。这里不展开。</li>
</ol>
<p>b. 验车<br>验车可以分成两个部分：一是自己试开车或者朋友试开，一是去mechanicshop 做inspection。下面展开来说：</p>
<p>试开车。<br>以后自己的坐骑，如果试开就不爽，那以后可能天天不爽。试开呢，是很重要的，你需要了解这辆二手车。试开，可以查查下面几个部分：</p>
<ol>
<li>方向盘的轻重。如果非 pickup/truck 而方向盘很重的话，可能转向液 (power steering fluid) 寿命已过，车主没有及时保养。</li>
<li>刹车性能。如果刹车有尖锐的叫声从 rim 传来，说明刹车差不多磨没了，需要更换。</li>
<li>轮胎寿命。拿个5美分的硬币塞入轮胎的缝隙中，如果林肯的头能埋进去，说明寿命还够；如果没有，说明需要换轮胎了。</li>
<li>避震器。把车子的四个角往下使劲摁，如果几下恢复原状说明性能不错。</li>
<li>加速时有没有变速箱的 slipping。就是说，加速提档位的时候，有没有一种一格一格的感觉。老车自然会有一点这种 slipping，但如果很严重，变速箱液(ATF) 颜色味道又很烂，说明其寿命不长了。</li>
<li>开完车后，趴在车底下看看有没有什么液体漏在地上了。</li>
<li>如果在冬天验车，最好在车还没热起来的时候去点火。有些车冬天点火很不容易着，但如果提前热过车后，会很容易点火。</li>
<li>试试空调和收音机喇叭什么的是不是好的。</li>
<li>各种灯，大灯远光灯转向灯日行灯倒车灯刹车灯等等..</li>
<li>还会继续补充..</li>
</ol>
<p>去mechanicshop 做inspection。</p>
<p>原则上来说，不能去任何与卖家有瓜葛的店里做检查。可以选择些著名的黑店，比如说firestone..之所以选黑店，是因为黑店对很多车的小毛病都不放过，想骗你去修。而我们做inspection就是尽可能地找出这些毛病，用来砍价。所以，你懂的。当然，如果有什么很重大的毛病，车行说要很多钱修的话，你既可以于卖家商量把价格压低，也可以不买这辆车了。</p>
<p>交易</p>
<p>记得一手交钱，一手拿带有卖家签名的title。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里是之前收集的一些在美国买二手车的注意事项和相关技巧，分享给大家。</p>]]>
    
    </summary>
    
      <category term="二手车" scheme="http://wdxtub.com/tags/%E4%BA%8C%E6%89%8B%E8%BD%A6/"/>
    
      <category term="北美" scheme="http://wdxtub.com/tags/%E5%8C%97%E7%BE%8E/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Latex 常用符号表]]></title>
    <link href="http://wdxtub.com/2016/03/26/latex-notation-table/"/>
    <id>http://wdxtub.com/2016/03/26/latex-notation-table/</id>
    <published>2016-03-26T16:37:43.000Z</published>
    <updated>2016-03-26T16:44:18.000Z</updated>
    <content type="html"><![CDATA[<p>这里记录了常用的 Latex 符号及用法</p>
<a id="more"></a>
<hr>
<h2 id="u5B57_u4F53"><a href="#u5B57_u4F53" class="headerlink" title="字体"></a>字体</h2><ul>
<li><code>\mathrm{}</code>，正常字体</li>
<li><code>\mathit{}</code>，斜体</li>
<li><code>\mathbf{}</code>，粗体符号boldfont</li>
<li><code>\mathbb{}</code>，空心粗体blackboard</li>
<li><code>\mathnormal{}</code>，正常字体</li>
</ul>
<h2 id="u6570_u5B66_u516C_u5F0F"><a href="#u6570_u5B66_u516C_u5F0F" class="headerlink" title="数学公式"></a>数学公式</h2><p><img src="/images/14590103911299.jpg" alt=""></p>
<h2 id="u6392_u7248"><a href="#u6392_u7248" class="headerlink" title="排版"></a>排版</h2><ul>
<li><code>\quad</code> 生成一个空格（相当于大写’M’的宽度）</li>
<li><code>\qquad</code> 生成一个大空格</li>
<li><code>\,</code> 相当于3/18个\quad</li>
<li><code>:</code> 相当于4/18个\quad</li>
<li><code>\;</code> 相当于5/18个\quad</li>
<li><code>!</code> 生成一个负空格-3/18个\quad</li>
<li>将 <code>\left</code> 放在分隔符前，tex会自动调整分隔符的大小</li>
<li>但是每个 <code>\left</code> 必须要用一个<code>\right</code>关闭</li>
<li>如果分隔符仅有左括号则用<code>\right.</code>关闭</li>
</ul>
<p>$$\left{ x^2 \right}$$</p>
<h2 id="u7B26_u53F7_u8868"><a href="#u7B26_u53F7_u8868" class="headerlink" title="符号表"></a>符号表</h2><p><img src="/images/14590105384037.jpg" alt=""></p>
<p><img src="/images/14590105424692.jpg" alt=""></p>
<p><img src="/images/14590105464309.jpg" alt=""></p>
<p><img src="/images/14590105502032.jpg" alt=""></p>
<p><img src="/images/14590105541907.jpg" alt=""></p>
<p><img src="/images/14590105592350.jpg" alt=""></p>
<p><img src="/images/14590105659095.jpg" alt=""></p>
<p><img src="/images/14590105709311.jpg" alt=""></p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://hustlei.tk/2014/08/latex-math-equation.html" target="_blank" rel="external">latex数学公式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里记录了常用的 Latex 符号及用法</p>]]>
    
    </summary>
    
      <category term="Latex" scheme="http://wdxtub.com/tags/Latex/"/>
    
      <category term="符号" scheme="http://wdxtub.com/tags/%E7%AC%A6%E5%8F%B7/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google 搜索技巧]]></title>
    <link href="http://wdxtub.com/2016/03/26/google-tip/"/>
    <id>http://wdxtub.com/2016/03/26/google-tip/</id>
    <published>2016-03-26T16:15:16.000Z</published>
    <updated>2016-03-26T16:16:19.000Z</updated>
    <content type="html"><![CDATA[<p>这里记录一些非常有用的搜索技巧，熟练运用后可以有效提升自己的效率。</p>
<a id="more"></a>
<hr>
<h2 id="u64CD_u4F5C_u7B26"><a href="#u64CD_u4F5C_u7B26" class="headerlink" title="操作符"></a>操作符</h2><p><code>+</code> 强制搜索</p>
<p>由于Google会忽略和过滤一些常用词（称为stop words / common words），如and、how等。使用+可以让搜索引擎强制包括这些词。使用+还可以强制过滤关键词变体形式（不让搜索结果出现关键词的其它形式），如单复数、动词时态、ing形式等等。</p>
<p><code>-</code>  逻辑非</p>
<p>用于过滤-号后面的关键词。如：MP3 -MP4，表示只搜索MP3而不要MP4的搜索结果。 -号后面没有空格。</p>
<p><code>~</code> 同义词</p>
<p>关键词前加波浪线。如：~table 。</p>
<p><code>*</code> 通配符</p>
<p>如：Google was founded in * 。</p>
<p><code>**</code> 指数</p>
<p>作用同  ^ ，如：2**10 。</p>
<p><code>&quot; &quot;</code> 引号</p>
<p>用引号精确搜索，有时可只用左侧引号。如：”Google hacking” = “Google hacking 。</p>
<p><code>|</code> 逻辑或</p>
<p>作用同 OR ，如：Google hacking | hacks 。</p>
<p><code>..</code> 数字范围</p>
<p>用于限定数值范围，如：spring festival logo 2002..2009 。</p>
<p><code>^</code> 指数</p>
<p>作用同  ** ，如：2^10 。</p>
<h2 id="u64CD_u4F5C_u547D_u4EE4"><a href="#u64CD_u4F5C_u547D_u4EE4" class="headerlink" title="操作命令"></a>操作命令</h2><p><code>OR</code>  逻辑或</p>
<p>作用同 | ，如：Google hacking OR hacks 。</p>
<p><code>define:</code>  关键词定义</p>
<p>查询关键词的网络释义。如： define:google 。</p>
<p><code>ext:</code>  限定搜索指定文件类型</p>
<p>作用同 filetype:</p>
<p><code>filetype:</code>  限定搜索指定文件类型<br>    作用同 ext: 如：filetype:pdf = ext:pdf 。目前文件类型支持如下格式：<br>    Adobe Acrobat PDF (.pdf)<br>    Adobe Postscript (.ps)<br>    Autodesk DWF (.dwf)<br>    Google地球 KML (.kml)<br>    Google地球 KMZ (.kmz)<br>    Lotus 1-2-3（wk1、wk2、wk3、wk4、wk5、wki、wks、wku）<br>    Lotus WordPro (.lwp)<br>    MacWrite (.mw)<br>    Microsoft Excel (.xls)<br>    Microsoft Powerpoint (.ppt)<br>    Microsoft Word (.doc)<br>    Microsoft Works（wks、wps、wdb）<br>    Microsoft Write (.wri)<br>    Rich Text Format富文本格式 (.rtf)<br>    Shockwave Flash (.swf)<br>    纯文本（ans、txt）</p>
<p><code>intitle:</code>  限定搜索标题中含指定关键词的网页</p>
<p>如： intitle:google search guide 。限定多个关键词用 allintitle:</p>
<p><code>inurl:</code>  限定搜索url中含指定关键词的网页</p>
<p>如： inurl:google search guide 。通过inurl:view.shtml 你可以找到在线的网络摄像头。 限定多个关键词用 allinurl:</p>
<p><code>inanchor:</code>  限定搜索页面链接锚文本中含指定关键词的网页</p>
<p>如： inanchor:google search guide 。限定多个关键词用 allinanchor:</p>
<p><code>intext:</code>  限定搜索正文文本（不含标题和链接）中含指定关键词的网页</p>
<p>如： intext:google vs mircosoft。</p>
<h2 id="u7F51_u7AD9_u7F51_u9875_u547D_u4EE4"><a href="#u7F51_u7AD9_u7F51_u9875_u547D_u4EE4" class="headerlink" title="网站网页命令"></a>网站网页命令</h2><p><code>site:</code>  限定搜索某网站的网页</p>
<p>如： site:www.google.com 。</p>
<p><code>link:</code>  搜索链向某网站/网址的网页</p>
<p>如： link:www.google.com 。</p>
<p><code>related:</code>  搜索与某网页相似或相关的页面</p>
<p>如： related:www.google.com 。</p>
<p><code>cache:</code>  搜索某网页在Google缓存（网页快照）中的旧版本</p>
<p>如： cache:www.google.com 。</p>
<p><code>info:</code>  综合查询某网页的信息，即列出上述四个命令</p>
<p>如： info:www.google.com 。作用同 id:</p>
<h2 id="u56FE_u7247_u641C_u7D22_u4E0E_u5F71_u89C6_u641C_u7D22"><a href="#u56FE_u7247_u641C_u7D22_u4E0E_u5F71_u89C6_u641C_u7D22" class="headerlink" title="图片搜索与影视搜索"></a>图片搜索与影视搜索</h2><p>filetype: 限定搜索指定文件类型的图片，支持如下格式：</p>
<ul>
<li>filetype:jpg</li>
<li>filetype:gif</li>
<li>filetype:png</li>
<li>filetype:bmp</li>
</ul>
<p>imagesize: 限定搜索指定尺寸的图片，如: imagesize:800x600</p>
<p>URL 参数：加在图片搜索网页的 URL 后面，可以实现更精细的搜索</p>
<ul>
<li>&amp;imgtype=news 资讯</li>
<li>&amp;imgtype=face 脸部特写</li>
<li>&amp;imgtype=clipart 剪贴画</li>
<li>&amp;imgtype=lineart 素描</li>
<li>&amp;imgtype=photo 照片</li>
<li>&amp;imgc=gray 黑白图片</li>
<li>&amp;imgc=mono 灰阶图片</li>
<li>&amp;imgc=color 全彩图片</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里记录一些非常有用的搜索技巧，熟练运用后可以有效提升自己的效率。</p>]]>
    
    </summary>
    
      <category term="Google" scheme="http://wdxtub.com/tags/Google/"/>
    
      <category term="搜索" scheme="http://wdxtub.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux 的概念与体系]]></title>
    <link href="http://wdxtub.com/2016/03/26/linux-basic/"/>
    <id>http://wdxtub.com/2016/03/26/linux-basic/</id>
    <published>2016-03-26T15:17:06.000Z</published>
    <updated>2016-03-26T15:38:33.000Z</updated>
    <content type="html"><![CDATA[<p>这篇日志来自 <a href="http://www.cnblogs.com/vamei" target="_blank" rel="external">Vamei 博客</a> 中的系列文章，把一些基本的内容做了整合，方便查阅。</p>
<a id="more"></a>
<hr>
<h2 id="Linux_u7B80_u4ECB_u4E0E_u5382_u5546_u7248_u672C"><a href="#Linux_u7B80_u4ECB_u4E0E_u5382_u5546_u7248_u672C" class="headerlink" title="Linux简介与厂商版本"></a>Linux简介与厂商版本</h2><p><strong>Linux简介</strong></p>
<p>Linux可以有狭义和广义两种定义。狭义来说，Linux实际上指Linux kernel (内核)。内核负责管理硬件，并为上层应用提供接口。而广义来说，是指以Linux kernel为基础的，包括OS和各种应用在内的各个Linux版本(distribution)。尽管看起来版本眼花缭乱，但实际上，各个版本之间也只是大同小异，其差别往往体现在客户群、升级维护和界面等方面。</p>
<p>Linus Torvalds是Linux之父。他根据Minix系统的代码，参照UNIX系统的设计，写出了第一给Linux内核。Linus的创举在于将Linux内核的代码开源。后来，Linux内核和一套开源的应用软件GNU结合，共同采取开源协议，并迅速发展成熟。我们可以随意地使用和修改开源代码，但以此为基础开发的程序也要根据开源协议公开。Linux和GNU的开源性吸引了大批优秀的程序员参与到Linux相关的开发中。</p>
<p>从哲学和设计理念上，Linux与其他的UNIX版本相类似，并使用类似的接口。我们可以通过学习Linux的基本概念和机制来了解其它UNIX系统，比如Solaris, FreeBSD，还有基于FreeBSD的苹果公司的Mac OS。曾经Windows的兴起曾经让许多人认为UNIX将最终被Windows取代，但如今看到Linux和苹果产品的兴盛，我很感慨于UNIX体系的力量。</p>
<p>Linux的有如下比较重要的机制: 用于储存数据以及管理权限的文件系统，用于IO的文本操作API，用于管理操作的进程，用于实现多任务运行的多线程，以及进程间通信(我将信号和网络也都归入这一类中)。</p>
<p>特别推荐下面的一些文章，以便你对Linux有一个概观：</p>
<p><a href="http://www.catb.org/~esr/writings/cathedral-bazaar/introduction/" target="_blank" rel="external">大教堂和市集（The Cathedral and the Bazaar）</a>，作者Eric Raymond</p>
<p>可以说是为Linux正名的一篇文章，深入分析Linux成功的原因。你也可以通过名字来搜索中文翻译版本。</p>
<p>该作者的<a href="http://www.catb.org/~esr/writings/" target="_blank" rel="external">其他文章</a>也非常值得一读。</p>
<p>UNIX传奇，来自酷壳，作者陈皓</p>
<ul>
<li>上篇：<a href="http://coolshell.cn/articles/2322.html" target="_blank" rel="external">http://coolshell.cn/articles/2322.html</a></li>
<li>下篇：<a href="http://coolshell.cn/articles/2324.html" target="_blank" rel="external">http://coolshell.cn/articles/2324.html</a></li>
</ul>
<p>(作者博客内容丰富，又容易读，非常值得订阅。)</p>
<p><strong>Linux的厂商版本</strong></p>
<p>在Linux内核基础上，我们还有许多厂商版本。即使有了内核和GNU软件，Linux的安装和编译并不是简单的工作，Linux厂商就是瞄准了这个市场。这些厂商会在Linux内核的基础上，结合自己开发的软件，帮助用户安装和使用Linux，并提供技术支持。由于在服务器领域，Linux操作系统远远领先于Windows系统，而这些被政府部门、银行或者大学拥有的服务器往往承担很重要的信息处理和IO (input/outpt) 工作，所以尽管Linux开源，厂商还是可以根据其提供的商用软件和技术支持获得丰厚的利润。</p>
<p>(IBM是Linux设备最大的供应商，同时它的咨询业务很大一部份也来源于提供Linux相关的支持。我们所熟知的Android操作系统，也算是Google提供的一个厂商版本。)</p>
<p>我们这里主要介绍在PC上比较流行的Linux厂商版本:</p>
<p><strong>红帽系列</strong></p>
<ul>
<li>Red Hat linux: 大名鼎鼎的红帽，现在已经完结。以此为基础有以下分支:</li>
<li>Red Hat Enterprise: (www.redhat.com) 这个是企业级的linux，主要面向服务器。作为商业版，有比较好的配套软件和技术支持。RH的教材也堪称经典。</li>
<li>Fedora: (<a href="http://fedoraproject.org" target="_blank" rel="external">http://fedoraproject.org</a>) 由社区维护，去除了一些商业软件。红帽实际上赞助了这个项目，以便以此作为技术测试平台。</li>
<li>CentOS: (www.centos.org) 这个版本不来自红帽的公司，是收集红帽公开的源码组成的免费版本，由社区维护，和红帽完全兼容。版本号升级较慢，但有持续的技术支持，所以适合于不愿意频繁升级的情形，鸟哥中就推荐以CentOS来建站。</li>
</ul>
<p><strong>SUSE系列</strong></p>
<ul>
<li>SUSE Linux Enterprise: (www.suse.com) 和红帽商业版类似，是德国公司制作的，据说在欧洲比较流行，但我欧洲的朋友表示没怎么听说过。SUSE系列比较有特色的是YAST2，就是用来设置Linux的界面，对初级管理员比较方便。</li>
<li>openSUSE: (www.opensuse.org) SUSE的免费版本。以前SUSE不是很推这个免费版本，支持不好。现在似乎态度大大转变。就我个人的使用体验来说，还是觉得社区支持不足。</li>
</ul>
<p><strong>Debian系列</strong></p>
<ul>
<li>Debian: (www.debian.org) 完全免费，社区维护的Linux版本，有很大的用户群，所以遇到问题，基本都可以找到社区用户的支持。</li>
<li>Ubuntu: (www.ubuntu.com) 由一个基金提供支持的免费Linux版本。 继承自Debian。界面很友好。发邮件过去，还会送你免费安装CD (不知道现在还有没有)。现在的版本加载的东西有些多，速度有些慢。写《大教堂和市集》的Eric Raymond说它是最好的Linux。</li>
<li>Mint (<a href="http://www.linuxmint.com" target="_blank" rel="external">http://www.linuxmint.com</a>), 基于ubuntu。它提供了更加丰富的预装应用，以减少用户搜索并安装应用的麻烦。其使用的应用版本比较新，可能不是很稳定。</li>
</ul>
<p>此外，还有如下一些版本：</p>
<ul>
<li>Gentoo (www.gentoo.org) 基于源码的版本，提供给用户很大的自由度。为用户提供大量应用程序的源码，可以在用户的系统上重新编译建造。需要一定的系统配置的知识。</li>
<li>ArchLinux (www.archlinux.org)，推崇简洁，避免不必要和复杂的修改，是一个轻便灵活的版本。其配置文件有良好注释。</li>
<li>Mandriva (www.mandriva.com) 一个很方便用户使用的版本，其目标是使得新用户更容易使用linux。</li>
<li>Slackware (www.slackware.com) 稳定，基本。它的只包含稳定版本的应用程序。对于初级用户不是很友好。</li>
<li>TurboLinux (www.turbolinux.com) 在亚洲比较流行。商业版本，提供技术支持和咨询服务。</li>
</ul>
<h2 id="Linux_u5F00_u673A_u542F_u52A8"><a href="#Linux_u5F00_u673A_u542F_u52A8" class="headerlink" title="Linux开机启动"></a>Linux开机启动</h2><p>计算机开机是一个神秘的过程。我们只是按了开机键，就看到屏幕上的进度条或者一行行的输出，直到我们到达登录界面。然而，计算机开机又是个异常脆弱的过程，我们满心期望的登录界面可能并不会出现，而是一个命令行或者错误信息。了解计算机开机过程有助于我们修复开机可能出现的问题。</p>
<p><strong>最初始阶段</strong></p>
<p>当我们打开计算机电源，计算机会自动从主板的BIOS(Basic Input/Output System)读取其中所存储的程序。这一程序通常知道一些直接连接在主板上的硬件(硬盘，网络接口，键盘，串口，并口)。现在大部分的BIOS允许你从软盘、光盘或者硬盘中选择一个来启动计算机。</p>
<p>下一步，计算机将从你所选择的存储设备中读取起始的512 bytes(比如光盘一开是的512 bytes，如果我们从光盘启动的话)。这512 bytes叫做主引导记录MBR (master boot record)。MBR会告诉电脑从该设备的某一个分区(partition)来装载引导加载程序(boot loader)。Boot loader储存有操作系统(OS)的相关信息，比如操作系统名称，操作系统内核 (kernel)所在位置等。常用的boot loader有GRUB和LILO。</p>
<p>随后，boot loader会帮助我们加载kernel。kernel实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过kernel传达给硬件。Windows和Linux各自有自己kernel。狭义的操作系统就是指kernel，广义的操作系统包括kernel以及kernel之上的各种应用。</p>
<p>（Linus Torvalds与其说是Linux之父，不如说是Linux kernel之父。他依然负责Linux kernel的开发和维护。至于Ubuntu, Red Hat, 它们都是基于相同的kernel之上，囊括了不同的应用和界面构成的一个更加完整的操作系统版本。)</p>
<p>实际上，我们可以在多个分区安装boot loader，每个boot loader对应不同的操作系统，在读取MBR的时候选择我们想要启动的boot loader。这就是多操作系统的原理。</p>
<p>小结：BIOS -&gt; MBR -&gt; boot loader -&gt; kernel</p>
<p><strong>kernel</strong></p>
<p>如果我们加载的是Linux kernel，Linux kernel开始工作。kernel会首先预留自己运行所需的内存空间，然后通过驱动程序(driver)检测计算机硬件。这样，操作系统就可以知道自己有哪些硬件可用。随后，kernel会启动一个init进程。它是Linux系统中的1号进程(Linux系统没有0号进程)。到此，kernel就完成了在计算机启动阶段的工作，交接给init来管理。</p>
<p>小结: kernel -&gt; init process</p>
<p><strong>init process</strong></p>
<p>(根据boot loader的选项，Linux此时可以进入单用户模式(single user mode)。在此模式下，初始脚本还没有开始执行，我们可以检测并修复计算机可能存在的错误)</p>
<p>随后，init会运行一系列的初始脚本(startup scripts)，这些脚本是Linux中常见的shell scripts。这些脚本执行如下功能：</p>
<p>设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络……</p>
<p>当这些初始脚本，操作系统已经完全准备好了，只是，还没有人可以登录！！！init会给出登录(login)对话框，或者是图形化的登录界面。</p>
<p>输入用户名(比如说vamei)和密码，DONE！</p>
<p>在此后的过程中，你将以用户(user)vamei的身份操作电脑。此外，根据你创建用户时的设定，Linux还会将你归到某个组(group)中，比如可以是stupid组，或者是vamei组。</p>
<p>所以你将是用户vamei， 同时是vamei组的组员。(注意，组vamei和用户vamei只是重名而已，就好想你可以叫Dell, 同时还是Dell公司的老板一样。你完全也可以是用户vamei，同时为stupid组的组员)</p>
<p><strong>总结</strong></p>
<p>BIOS -&gt; MBR -&gt; boot loader -&gt; kernel -&gt; init process -&gt; login</p>
<p>用户，组。</p>
<h2 id="Linux_u6587_u4EF6_u7BA1_u7406"><a href="#Linux_u6587_u4EF6_u7BA1_u7406" class="headerlink" title="Linux文件管理"></a>Linux文件管理</h2><p>对于计算机来说，所谓的数据就是0和1的序列。这样的一个序列可以存储在内存中，但内存中的数据会随着关机而消失。为了将数据长久保存，我们把数据存储在光盘或者硬盘中。根据我们的需要，我们通常会将数据分开保存到文件这样一个个的小单位中(所谓的小，是相对于所有的数据而言)。但如果数据只能组织为文件的话，而不能分类的话，文件还是会杂乱无章。每次我们搜索某一个文件，就要一个文件又一个文件地检查，太过麻烦。文件系统(file system)是就是文件在逻辑上组织形式，它以一种更加清晰的方式来存放各个文件。</p>
<p><strong>路径与文件简介</strong></p>
<p>文件被组织到文件系统(file system)中，通常会成为一个树状(tree)结构。Linux有一个根目录/, 也就是树状结构的最顶端。这个树的分叉的最末端都代表一个文件，而这个树的分叉处则是一个目录(directory, 相当于我们在windows界面中看到的文件夹)。在图1中看到的是整个的一个文件树。如果我们从该树中截取一部分，比如说从目录vamei开始往下，实际上也构成一个文件系统。</p>
<p>要找到一个文件，除了要知道该文件的文件名，还需要知道从树根到该文件的所有目录名。从根目录开始的所有途径的目录名和文件名构成一个路径(path)。比如说，我们在Linux中寻找一个文件file.txt，不仅要知道文件名(file.txt)，还要知道完整路径，也就是绝对路径(/home/vamei/doc/file.txt)。从根目录录/, 也就是树状结构的最顶端出发，经过目录home, vamei, doc，最终才看到文件file.txt。整个文件系统层层分级(hierarchy)，vamei是home的子目录，而home是vamei的父目录。</p>
<p>在Linux中，我们用ls命令来显示目录下的所有文件，比如 $ls /home/vamei/doc</p>
<p><strong>目录</strong></p>
<p>在Linux系统中，目录也是一种文件。所以/home/vamei是指向目录文件vamei的绝对路径。</p>
<p>这个文件中至少包含有以下条目:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">.       </span>指向当前目录</span><br><span class="line"><span class="bullet">..      </span>指向父目录</span><br></pre></td></tr></table></figure>
<p>除此之外，目录文件中还包含有属于该目录的文件的文件名，比如vamei中就还要有如下条目，指向属于该目录的文件:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">doc</span></span><br><span class="line"><span class="keyword">movie</span><br><span class="line"></span><span class="label">photo</span></span><br></pre></td></tr></table></figure>
<p>Linux解释一个绝对路径的方式如下：先找到根目录文件，从该目录文件中读取home目录文件的位置，然后从home文件中读取vamei的位置……直到找到目录doc中的file.txt的位置。</p>
<p>由于目录文件中都有.和..的条目，我们可以在路径中加入.或者..来表示当前目录或者父目录，比如/home/vamei/doc/..与/home/vamei等同。</p>
<p>此外，Linux会在进程中，维护一个工作目录(present working directory)的变量。在shell中，你可以随时查询到到工作目录(在命令行输入<code>$pwd</code>)。这是为了省去每次都输入很长的绝对路径的麻烦。比如说我们将工作目录更改为/home/vamei (<code>$cd /home/vamei</code>)，那么此时我们再去找file.txt就可以省去/home/vamei/ (<code>$ls doc/file.txt</code>)，这样得到的路径叫相对路径(relative path)，上面的doc/file.txt就是这样一个相对路径。</p>
<p>当文件出现在一个目录文件中时，我们就把文件接入到文件系统中，我们称建立一个到文件的硬链接(hard link)。一个文件允许出现在多个目录中，这样，它就有多个硬链接。当硬链接的数目(link count)降为0时，文件会被Linux删除。所以很多时候，unlink与remove在Linux操作系统中是一个意思。由于软链接(soft link)的广泛使用(soft link不会影响link count，而且可以跨越文件系统)，现在较少手动建立硬连接。</p>
<p><strong>文件操作</strong></p>
<p>对于文件，我们可以读取(read)，写入(write)和运行(execute)。读取是从已经存在的文件中获得数据。写入是向新的文件或者旧的文件写入数据。如果文件储存的是可执行的二进制码，那么它可以被载入内存，作为一个程序运行。在Linux的文件系统中，如果某个用户想对某个文件执行某一种操作，那么该用户必须拥有对该文件进行这一操作的权限。文件权限的信息保存在文件信息(metadata)中, 见下一节。</p>
<p><strong>文件附加信息 (metadata)</strong></p>
<p>文件自身包含的只有数据。文件名实际上储存在目录文件。除了这些之外，还有操作系统维护的文件附加信息，比如文件类型，文件尺寸，文件权限，文件修改时间，文件读取时间等。可以用ls命令查询文件信息($ls -l file.txt)，得到如下结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- <span class="number">1</span> vamei vamei <span class="number">8445</span> Sep  <span class="number">8</span> <span class="number">07</span>:<span class="number">33</span> file1.txt</span><br></pre></td></tr></table></figure>
<p>各个部分的含义如下：</p>
<ul>
<li>我们先介绍最开始的-，它表示文件类型，说明file1.txt是常规文件(如果是目录文件，则应显示d)。</li>
<li>随后有九个字符，为rw-r–r–，它们用于表示文件权限。这九个字符分为三组，rw-, r–, r–，分别对应拥有者(owner)，拥有组(owner group)和所有其他人(other)。回顾Linux开机启动，登录后，我会有一个用户身份和一个组身份, 相当于我的名片。第一组表示，如果我的名片上的用户身份证明我是该文件的拥有者，那么我就可以对该文件有读取(r)，写入(w)该文件的权限，但不拥有执行(-，如果拥有执行权限，则为x)该文件的权限。第二组表示，如果我的名片上的组身份证明我所在的组是该文件的拥有组的一员，那么我有从该文件读入的权限。第三组表示，如果我的名片显示我既不是拥有者，也不是拥有组的一员，那么我只有读入的权限。当我想要进行一个读取操作时，Linux会先看我是否是拥有者下文会进一步解释拥有者和拥有组。</li>
<li>后面的1是硬连接(hard link)数目(link count)。</li>
<li>之后的vamei表示用户vamei是文件的拥有者(owner)，文件的拥有者有权更改文件权限(比如改为rwxrwxrwx)。而后面的vamei文件的拥有组是组vamei。文件的拥有者和拥有组在文件创建时就附加在文件上(相当于给文件上锁，只有有合适名片的用户才能打开操作)。要注意，Linux有一个超级用户root (也叫做根用户)，该用户拥有所有的文件。</li>
<li>随后的8445表示文件大小，单位为字节(byte)。</li>
<li>Sep 8 07:33表示文件的上一次写入的时间(modification time)。实际上在文件附加信息中还包含有文件的上一次读取时间(access time)，没有显示出来。</li>
</ul>
<p><strong>软链接 (soft link, or symbolic link)</strong></p>
<p>如上讨论硬链接时说到的，软链接不会影响文件的link count。如果还记得windows系统的快捷方式的话，Linux的软链接(soft link，也叫做symbolic link)就是linux的快捷方式。软链接本质上是一个文件，它的文件类型是symbolic link。在这个文件中，包含有链接指向的文件的绝对路径。当你从这个文件读取数据时，linux会把你导向所指向的文件，然后从那个文件中读取（就好像你双击快捷方式的效果一样）。软链接可以方便的在任何地方建立，并指向任何一个绝对路径。</p>
<p>软链接本身也是一个文件，也可以执行文件所可以进行的操作。当我们对软链接操作时，要注意我们是对软链接本身操作，还是对软链接指向的目标操作。如果是后者，我们就说该操作跟随链接指引(follow the link)。</p>
<p>umask</p>
<p>当我们创建文件的时候，比如使用touch，它会尝试将新建文件创建为权限666，也就是rw-rw-rw-。但操作系统要参照权限mask来看是否真正将文件创建为666。权限mask表示操作系统不允许设置的权限位，比如说037(—-wxrwx)的权限mask意味着不允许设置设置group的wx位和other的rwx位。如果是这个权限mask的话，最终的文件权限是rw-r—– (group的w位和other的rw位被mask)。</p>
<p>我们可以通过</p>
<pre><code>$umask 022
</code></pre><p>的方式改变权限mask。</p>
<p><strong>总结</strong></p>
<p>计算机本质上是对数据进行处理的工具，而文件是数据储存的逻辑载体，所以了解Linux文件系统很重要。对于文件系统的了解要结合Linux的其他方面(比如用户管理)进行有机的学习。</p>
<p>文件权限，拥有者，拥有组，超级用户root</p>
<p>硬链接，软链接，follow the link</p>
<h2 id="Linux_u7684_u67B6_u6784"><a href="#Linux_u7684_u67B6_u6784" class="headerlink" title="Linux的架构"></a>Linux的架构</h2><p>我以下图为基础，说明Linux的架构(architecture)。(该图参考《Advanced Programming in Unix Environment》)</p>
<p><img src="/images/14590055441877.jpg" alt=""></p>
<p>最内层是硬件，最外层是用户常用的应用，比如说firefox浏览器，evolution查看邮件，一个计算流体模型等等。硬件是物质基础，而应用提供服务。但在两者之间，还要经过一番周折。</p>
<p>还记得Linux启动。Linux首先启动内核 (kernel)，内核是一段计算机程序，这个程序直接管理管理硬件，包括CPU、内存空间、硬盘接口、网络接口等等。所有的计算机操作都要通过内核传递给硬件。</p>
<p>为了方便调用内核，Linux将内核的功能接口制作成系统调用(system call)。系统调用看起来就像C语言的函数。你可以在程序中直接调用。Linux系统有两百多个这样的系统调用。用户不需要了解内核的复杂结构，就可以使用内核。系统调用是操作系统的最小功能单位。一个操作系统，以及基于操作系统的应用，都不可能实现超越系统调用的功能。一个系统调用函数就像是汉字的一个笔画。任何一个汉字都要由基本的笔画（点、横、撇等等）构成。我不能臆造笔画。</p>
<p>在命令行中输入<code>$man 2 syscalls</code>可以查看所有的系统调用。你也可以通过<code>$man 2 read</code>来查看系统调用read()的说明。在这两个命令中的2都表示我们要在2类(系统调用类)中查询 (具体各个类是什么可以通过<code>$man man</code>看到)。</p>
<p>系统调用提供的功能非常基础，所以使用起来很麻烦。一个简单的给变量分配内存空间的操作，就需要动用多个系统调用。Linux定义一些库函数(library routine)来将系统调用组合成某些常用的功能。上面的分配内存的操作，可以定义成一个库函数(像malloc()这样的函数)。再比如说，在读取文件的时候，系统调用要求我们设置好所需要的缓冲。我可以使用Standard IO库中的读取函数。这个读取函数既负责设置缓冲，又负责使用读取的系统调用函数。使用库函数对于机器来说并没有效率上的优势，但可以把程序员从细节中解救出来。库函数就像是汉字的偏旁部首，它由笔画组成，但使用偏旁部首更容易组成字，比如”铁”。当然，你也完全可以不使用库函数，而直接调用系统函数，就像“人”字一样，不用偏旁部首。</p>
<p>(实际上，一个操作系统要称得上是UNIX系统，必须要拥有一些库函数，比如ISO C标准库，POSIX标准等。)</p>
<p>shell是一个特殊的应用。很多用户将它称为命令行。shell是一个命令解释器(interpreter)，当我们输入“ls -l”的时候，它将此字符串解释为</p>
<ol>
<li>在默认路径找到该文件(/bin/ls)，</li>
<li>执行该文件，并附带参数”-l”。</li>
</ol>
<p>我之前用&gt;表示重新定向，用|表示管道，也是通过shell解释&amp;或者|的含义。Shell接着通过系统调，用指挥内核，实现具体的重定向或者管道。在没有图形界面之前，shell充当了用户的界面，当用户要运行某些应用时，通过shell输入命令，来运行程序。shell是可编程的，它可以执行符合shell语法的文本。这样的文本叫做shell脚本(script)。可以在架构图中看到，shell下通系统调用，上通各种应用，同时还有许多自身的小工具可以使用。Shell脚本可以在寥寥数行中，实现复杂的功能。</p>
<p>UNIX的一条哲学是让每个程序尽量独立的做好一个小的功能。而shell充当了这些小功能之间的”胶水”，让不同程序能够以一个清晰的接口(文本流)协同工作，从而增强各个程序的功能。这也是Linux老鸟鼓励新手多用shell，少用图形化界面的原因之一。</p>
<p>(shell也有很多种，最常见的是bash, 另外还有sh, csh, tcsh, ksh。它们出现的年代不同，所支持的功能也有差异。)</p>
<p>一个shell对应一个终端 (terminal)。曾经来说，终端是一个硬件设备，用来输入并显示输出。如今，由于图形化界面的普及，终端往往就像上图一样，是一个图形化的窗口。你可以通过这个窗口输入或者输出文本。这个文本直接传递给shell进行分析解释，然后执行。</p>
<p>最后，我们进入一般的应用。应用是一个程序，它可以</p>
<ol>
<li>直接调用系统函数</li>
<li>调用库函数</li>
<li>运行shell脚本</li>
</ol>
<p>这些应用可以由多种语言开发。最常见的是C语言。</p>
<p><strong>总结</strong></p>
<p>Linux利用内核实现软硬件的对话。</p>
<p>通过系统调用的这个接口，Linux将上层的应用与下层的内核分离，隐藏了底层的复杂性，也提高了上层应用的可移植性。</p>
<p>库函数利用系统调用创造出模块化的功能，</p>
<p>Shell则提供了一个用户界面，并让我们可以利用shell的语法编写脚本，以整合程序。</p>
<h2 id="Linux_u547D_u4EE4_u884C_u4E0E_u547D_u4EE4"><a href="#Linux_u547D_u4EE4_u884C_u4E0E_u547D_u4EE4" class="headerlink" title="Linux命令行与命令"></a>Linux命令行与命令</h2><p>Linux的命令是很重要的工具，也往往是初学者最大的瓶颈。有朋友用了很长时间的Linux图形界面，基本不使用命令行输入命令执行，所以装的Linux最终成了摆设。这里总结一些命令行下常使用的命令，希望能有用。</p>
<p><strong>什么是命令</strong></p>
<p>我们通常所说的Linux命令行是运行在终端(terminal)的shell (阅读Linux架构以了解什么是shell以及它在Linux系统中的位置)</p>
<p>所谓的命令，是我们在命令行输入的一串字符。shell负责理解并执行这些字符串。shell命令可以分为如下几类 1）可执行文件(executable file) 2）shell内建函数(built-in function) 3) 别名(alias)。可执行文件为经过编译的程序文件，我们输入这些文件的路径来让shell运行，比如<code>$/bin/ls</code>。有些可执行文件被放在特殊的目录(默认路径)下面，从而使得操作系统可以通过文件名找到，而不用总是输入该文件的绝对路径(absolute path)。比如说<code>$ls</code>(实际上，shell自动帮我们补齐ls的路径)。随后，这些可执行文件中包含的程序运行，并成为进程。shell的内建函数与上面类似，只是其对应的程序被保存在shell的内部。别名是指我们给以上两种命令起一个简称，以便减少输入的工作量。</p>
<p>我们可以通过type命令来了解命令的类型：</p>
<ul>
<li><code>$type ls</code></li>
<li><code>$type cd</code></li>
</ul>
<p>命令的构成</p>
<p>当我们在命令行输入命令的时候，往往由以下方式构成:</p>
<pre><code>$ls -l /home
</code></pre><p>整个一行命令由空格分为三个部分（注意, $是自动出现的提示符，有时还会在此之前出现计算机名）。第一个为命令的名字ls，这个命令ls的功能是列出目录中所有文件，第二个-l是关键字，它告诉ls要列出每个文件的详细信息，第三个/home为参数，表示我所要列出的目录是/home。实际上关键字是一种特殊的参数，大部分情况下用来开关程序的某些特殊功能 （用来选择做出的是拿铁咖啡还是黑咖啡）。而参数是用来传递给程序的一般的变量。ls经过处理之后，将在终端输出/home下面包含的各个文件名 (该文件系统见:<a href="http://www.cnblogs.com/vamei/archive/2012/09/09/2676792.html)：" target="_blank" rel="external">http://www.cnblogs.com/vamei/archive/2012/09/09/2676792.html)：</a></p>
<pre><code>vamei another
</code></pre><p>关键字和参数可以不止有一个，比如:</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ls</span> -l -a /home /bin</span><br><span class="line"><span class="variable">$ls</span> -la /home /bin</span><br><span class="line">(上面两个命令等价)</span><br></pre></td></tr></table></figure>
<p>列出/home和/bin目录下的文件，-a表示列出全部文件(即使是隐藏文件也要列出)， -l表示列出每个文件的详细信息。</p>
<p>(如果命令没有被放在默认路径中，你也可以输入绝对路径来执行)</p>
<p>回忆Linux文件管理背景知识，我们知道，每个文件能否被执行要根据用户所拥有的权限。命令实际上是可执行文件，也是如此。系统相关的命令，或者某个命令中的定义的操作，往往会要求超级用户root的身份才能使用。如果你是用户vamei，那么你就无法使用这些命令。但以root的身份登录是个糟糕的想法。为了解决这一矛盾，你可以以vamei的身份登录，但在执行命令之前加上sudo， 以便临时以root的身份执行某条命令。比如<code>$sudo ls .</code></p>
<p>对于大多数的shell来说，都有命令补齐的功能。当你在<code>$</code>的后面输入命令的一部分时，比如rmdir的rmd的时候，按Tab键，Linux会帮你打剩下的字符，补充成为rmdir。不止是命令，如果你输入的是文件名，Linux也可以帮你补齐。比如说, <code>$ls a.txt</code>。当你输入到<code>$ls a.t</code>的时候，按Tab键，Linux会帮你补齐该文件名，成为<code>$ls a.txt</code>。当然，这样做的前提是你输入到rmd的时候，默认路径下能和它相符的命令只有一个rmdir了。如果有多个相符的命令，连按两下Tab，Linux会显示所有的相符的命令。</p>
<p><strong>多使用命令的好处</strong></p>
<p>实际上，许多命令的功能都可以通过图形化界面来实现，学习这些命令的意义在哪里呢？</p>
<p>在UNIX发育的大部分历史上，用户都是通过shell来工作的。大部分命令都已经经过了几十年的发展和改良，功能强大，性能稳定。Linux继承自UNIX，自然也是如此。此外Linux的图形化界面并不好，并不是所有的命令都有对应的图形按钮。更别说在图形化界面崩溃的情况下，你就要靠shell输入命令来恢复计算机了。</p>
<p>命令本身是一个函数 (function)，是一个小的功能模块。当我们想要让计算机做很复杂的事情 (比如说: 在晚上12:00下载某个页面的所有链接，然后复制到移动硬盘)的时候，不断地去按各个图形化按钮并不是个很聪明的事情 (1. 要点很多下，2. 必须等到12:00)。我们通常是通过shell编程来实现这样一些复杂任务，这时，就可以把命令作为函数，嵌入到我们的shell程序中, 从而让不同命令协同工作 (比如使用date来查询时间，再根据时间来使用wget下载等等)。</p>
<p><strong>如何了解一个陌生的命令</strong>？</p>
<p>有一些命令可以用来了解某个命令本身的情况，比如这个命令的绝对路径。</p>
<pre><code>$which ls
</code></pre><p>which 在默认路径中搜索命令，返回该命令的绝对路径。</p>
<pre><code>$whereis ls
</code></pre><p>whereis 在相对比较大的范围搜索命令，返回该命令的绝对路径。</p>
<pre><code>$whatis ls
</code></pre><p>whatis 用很简短的一句话来介绍命令。</p>
<pre><code>$man ls
</code></pre><p>man 查询简明的帮助手册。对于大部分的Linux自带的命令来说，当作者编写它的时候，都会带有一个帮助文档，告诉用户怎么使用这个命令。</p>
<p>(man可以说是我们了解Linux最好的百科全书，它不但可以告诉你Linux自带的命令的功能，还可以查询Linux的系统文件和系统调用。如果想要深入学习Linux，就必须要懂得如何用man来查询相关文档。)</p>
<pre><code>$info ls
</code></pre><p>info 查询更详细的帮助信息</p>
<p>此外，在shell中，你还可以用向上箭头来查看之前输入运行的命令。</p>
<p>你也可以用</p>
<pre><code>$history
</code></pre><p>来查询之前在命令行的操作。</p>
<p>当一个命令运行时，你中途想要停止它时，可以用Ctrl + c。如果你只是想暂时停止，使用Ctrl + z。具体机制与信号(signal)有关，我们将在以后介绍</p>
<p><strong>总结</strong></p>
<p>命令行: 使用shell解释输入的字符串，以运行程序</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span></span><br><span class="line">sudo</span><br><span class="line"><span class="keyword">which</span>, whereis, whatis, <span class="keyword">man</span>, info</span><br></pre></td></tr></table></figure>
<p>使用Tab自动补齐，向上箭头查询历史，history</p>
<pre><code>Ctrl + c, Ctrl + z
</code></pre><h2 id="Linux_u6587_u4EF6_u7BA1_u7406_u76F8_u5173_u547D_u4EE4"><a href="#Linux_u6587_u4EF6_u7BA1_u7406_u76F8_u5173_u547D_u4EE4" class="headerlink" title="Linux文件管理相关命令"></a>Linux文件管理相关命令</h2><p>在了解了Linux文件管理背景知识之后， 我们可以学习一些命令来管理我们的文件。</p>
<p><strong>文件操作相关</strong></p>
<p>有一些命令可以帮助我们”修剪”之前看到的文件树。</p>
<pre><code>$touch a.txt
</code></pre><p>如果a.txt不存在，生成一个新的空文档a.txt。如果a.txt存在，那么只更改该文档的时间信息。(这个命令实际上用得并不广泛，但可以帮我们创建一个空文件来实验下面操作)</p>
<pre><code>$ls .
</code></pre><p>是list的简写，列出当前目录下的所有文件名</p>
<pre><code>$ls -l a.txt
</code></pre><p>列出文件的详细信息</p>
<pre><code>$cp a.txt b.txt 
</code></pre><p>cp是copy的简写，用来复制文件。在工作目录下，将a.txt复制到文件b.txt</p>
<pre><code>$cp a.txt ..
</code></pre><p>将a.txt复制到父目录的a.txt</p>
<pre><code>$mv a.txt c.txt
</code></pre><p>mv是move的简写，用来移动文件。将a.txt移动成为c.txt (相当于重命名rename)</p>
<pre><code>$mv c.txt /home/vamei
</code></pre><p>将c.txt移动到/home/vamei目录</p>
<pre><code>$rm a.txt
</code></pre><p>rm是remove的缩写，用于删除文件。删除a.txt</p>
<pre><code>$rm -r /home/vamei 
</code></pre><p>删除从/home/vamei向下的整个子文件系统。-r表示recursive， 是指重复删除的操作，/home/vamei文件夹为空，然后删除/home/vamei文件夹本身。</p>
<p>(程序员总是对这个命令很感兴趣,   <code>$rm -rf /</code>   它会删除整个文件树。f的目的是告诉rm放心干，不用再确认了…… 一般情况下，应该没有人会用这个命令。)</p>
<pre><code>$mkdir /home/vamei/good
</code></pre><p>创建一个新的目录</p>
<pre><code>$rmdir /home/vamei/good
</code></pre><p>删除一个空的目录</p>
<p><strong>文件权限相关</strong></p>
<pre><code>$chmod 755 a.txt
</code></pre><p>(你必须是文件a.txt的拥有者才能运行此命令。或者以$sudo chmod 755 a.txt的方式，以超级用户的身份运行该命令。)</p>
<p>change mode 改变a.txt的读、写以及执行权限。还记得每个文件都有九位的读写执行权限(参看 Linux文件管理背景知识)，分为三组，分别对应拥有者(owner)，拥有组(owner group)中的用户和所有其他用户(other)。在这里，我们也有三个数字，755，对应三个组。7被分配给拥有者，5被分配给拥有组，最后一个5分配给其它用户。Linux规定: 4为有读取的权利，2为有写入的权利，1为有执行的权利。我们看到的7实际上是4 + 2 + 1，表示拥有者有读、写、执行三项权利。(想想5 意味着什么)</p>
<p>这时，运行<code>$ls -l a.txt</code>, 你应该看到九位的权限变成了rwxr-xr-x。根据自己的需要，你可以用比如444, 744代替755，来让文件有不同的权限。</p>
<pre><code>$sudo chown root a.txt
</code></pre><p>change owner 改变文件的拥有者为root用户。这个命令需要有超级用户权限才能执行，所以我们在命令之前加上sudo。</p>
<pre><code>$sudo chgrp root a.txt
</code></pre><p>change group 改变文件的拥有组为root组</p>
<p><strong>Linux文件名通配表达式</strong></p>
<p>(wild card, 也叫filename pattern matching)</p>
<p>之前所讲的命令，比如ls, mv, cp都可以接收多个参数，比如:</p>
<pre><code>$ls -l a.txt b.txt c.txt
</code></pre><p>就可以列出这三个文件的所有信息。</p>
<p>有时候，我们想列出工作目录下所有的以.txt结尾的文件的信息，可以用下面的方式:</p>
<pre><code>$ls -l *.txt
</code></pre><p><code>*.txt</code>的写法就运用了Linux通配表达式。它与正则表达式相类似，但语法有所不同。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Filename Pattern Matching</th>
<th style="text-align:center">对应含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">任意多个任意字符</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">任意一个字符</td>
</tr>
<tr>
<td style="text-align:center">[kl]</td>
<td style="text-align:center">字符k或者字符l</td>
</tr>
<tr>
<td style="text-align:center">[0-4]</td>
<td style="text-align:center">数字0到4字符中的一个</td>
</tr>
<tr>
<td style="text-align:center">[b-e]</td>
<td style="text-align:center">b到e字符中的一个</td>
</tr>
<tr>
<td style="text-align:center">[^mnp]</td>
<td style="text-align:center">一个字符，这个字符不是m,n,p</td>
</tr>
</tbody>
</table>
<p>Linux会找到符合表达式的文件名，然后用这些文件名作为参数传递给命令。注意，当使用rm的时候，要格外小心。下面两个命令，只相差一个空格，但效果大为不同:</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$rm</span> * .txt</span><br><span class="line"><span class="variable">$rm</span> *.txt</span><br></pre></td></tr></table></figure>
<p>第一个命令会删除当前目录下所有文件！</p>
<p><strong>总结</strong></p>
<p>touch, ls, mv, cp, rm, mkdir, rmdir</p>
<p>chmod, chown, chgrp</p>
<p>wild card</p>
<h2 id="Linux_u6587_u672C_u6D41"><a href="#Linux_u6587_u672C_u6D41" class="headerlink" title="Linux文本流"></a>Linux文本流</h2><p><strong>文本流</strong></p>
<p>文件用于数据的存储，相当于一个个存储数据的房子。我们之前说，所谓的数据是0或者1的序列，但严格来说，Linux以字节(byte)来作为数据的单位，也就是说这个序列每八位(bit)为一个单位(八位二进制对应的十进制范围为0到255)。使用ASCII编码，可以将这样一个字节转换成为字符。所以，在Linux中，我们所说的数据，完全可以用字符表达出来，也就是说文本(text)的形式。</p>
<p>实际上，如果以bit为单位处理字符的话，机器会更容易读懂和传输，效率会更高。但为什么Linux依然以字节为单位进行处理呢？原因在于，相对于以bit为单位处理数据，以byte为单位可以更容易将数据转化为字符。相对于枯燥的0和1，字符更容易被人读懂 (human readable)。然而，并不是所有的数据都是设计来让人读懂的，比如可执行文件包含的各种字符对于人来说并没有什么意义 (因为可执行文件是为了让机器读懂的)。但Linux依然以字节为单位处理所有文件，这是为了让所有文件能够共用一套接口 (virtual file system)，从而减少Linux设计的复杂度。</p>
<p>(“everything is a file”是通常所流传的UNIX设计的哲学之一，但Linus对此作出纠正，改为”everything is a stream of bytes”。)</p>
<p>然而，数据不是在找到了自己的房子(file)之后就永远的定居下来。它往往要被读入到内存 (就像是到办公室上班)，或者被传送到外部设备(好像去酒店休假)，或者搬到别的房子中。在这样的搬迁过程中，数据像是一个个排着队走路的人流，我们叫它文本流(text stream，或者byte stream)。然而，计算机不同设备之间的连接方法差异很大，从内存到文件的连接像是爬山，从内存到外设像是游过一条河。为此，Linux还定义了流 (stream)，以此作为修建连接各处的公路的标准。Stream的好处在于，无论你是从内存到外设，还是从内存到文件，所有的公路都是相同的 (至于公路下面是石头还是土地，都可以不用操心)。</p>
<p>我们再回味一下“everything is a stream of bytes”这句话。信息包含在文本流中，不断在计算机的各个组件之间流动，不断地接受计算机的加工，最终成为用户所需要的某种服务。</p>
<p>标准输入，标准输出，标准错误与重新定向</p>
<p>当Linux执行一个程序的时候，会自动打开三个流，标准输入(standard input)，标准输出(standard output)，标准错误(standard error)。比如说你打开命令行的时候，默认情况下，命令行的标准输入连接到键盘，标准输出和标准错误都连接到屏幕。对于一个程序来说，尽管它总会打开这三个流，但它会根据需要使用，并不是一定要使用。</p>
<p>想象一下敲击一个</p>
<pre><code>$ls
</code></pre><p>键盘敲击的文本流(“ls\n”，\n是回车时输入的字符，表示换行)命令行 (命令行实际上也是一个程序)。命令行随后调用/bin/ls得到结果(“a.txt”)，最后这个输出的文本流(“a.txt”)流到屏幕，显示出来，比如说：</p>
<pre><code>a.txt
</code></pre><p>假设说我们不想让文本流流到屏幕，而是流到另一个文件，我们可以采用重新定向(redirect)的机制。</p>
<pre><code>$ls &gt; a.txt
</code></pre><p>重新定向标准输出。这里的&gt;就是提醒命令行，让它知道我现在想变换文本流的方向了，我们不让标准输出输出到屏幕，而是要到a.txt这个文件 (好像火车轨道换轨)。此时，计算机会新建一个a.txt的文件，并将命令行的标准输出指向这个文件。</p>
<p>有另一个符号:</p>
<pre><code>$ls &gt;&gt; a.txt
</code></pre><p>这里&gt;&gt;的作用也是重新定向标准输出。如果a.txt已经存在的话，ls产生的文本流会附加在a.txt的结尾，而不会像&gt;那样每次都新建a.txt。</p>
<p>我们下面介绍命令echo：</p>
<pre><code>$echo IamVamei
</code></pre><p>echo的作用是将文本流导向标准输出。在这里，echo的作用就是将IamVamei输出到屏幕上。如果是</p>
<pre><code>$echo IamVamei &gt; a.txt
</code></pre><p>a.txt中就会有IamVamei这个文本。</p>
<p>我们也可以用&lt;符号来改变标准输入。比如cat命令，它可以从标准输入读入文本流，并输出到标准输出:</p>
<pre><code>$cat &lt; a.txt
</code></pre><p>我们将cat标准输入指向a.txt，文本会从文件流到cat，然后再输出到屏幕上。当然，我们还可以同时重新定向标准输出:</p>
<pre><code>$cat &lt; a.txt &gt; b.txt
</code></pre><p>这样，a.txt的内容就复制到了b.txt中。</p>
<p>我们还可以使用&gt;&amp;来同时重新定向标准输出和标准错误。假设我们并没有一个目录void。那么</p>
<pre><code>$cd void &gt; a.txt
</code></pre><p>会在屏幕上返回错误信息。因为此时标准错误依然指向屏幕。当我们使用:</p>
<pre><code>$cd void &gt;&amp; a.txt
</code></pre><p>错误信息被导向a.txt。</p>
<p>如果只想重新定向标准错误，可以使用2&gt;:</p>
<pre><code>$cd void 2&gt; a.txt &gt; b.txt
</code></pre><p>标准错误对应的总是2号，所以有以上写法。标准错误输出到a.txt，标准输出输出到b.txt。</p>
<p><strong>管道 (pipe)</strong></p>
<p>理解了以上的内容之后，管道的概念就易如反掌。管道可以将一个命令的输出导向另一个命令的输入，从而让两个(或者更多命令)像流水线一样连续工作，不断地处理文本流。在命令行中，我们用|表示管道：</p>
<pre><code>$cat &lt; a.txt | wc 
</code></pre><p>wc命令代表word count，用于统计文本中的行、词以及字符的总数。a.txt中的文本先流到cat，然后从cat的标准输出流到wc的标准输入，从而让wc知道自己要处理的是a.txt这个字符串。</p>
<p>Linux的各个命令实际上高度专业化，并尽量相互独立。每一个都只专注于一个小的功能。但通过pipe，我们可以将这些功能合在一起，实现一些复杂的目的。</p>
<p><strong>总结</strong></p>
<p>文本流，标准输入，标准输出，标准错误</p>
<p>cat, echo, wc</p>
<p><code>&gt;, &gt;&gt;, &lt;, |</code></p>
<h2 id="Linux_u8FDB_u7A0B_u57FA_u7840"><a href="#Linux_u8FDB_u7A0B_u57FA_u7840" class="headerlink" title="Linux进程基础"></a>Linux进程基础</h2><p>计算机实际上可以做的事情实质上非常简单，比如计算两个数的和，再比如在内存中寻找到某个地址等等。这些最基础的计算机动作被称为指令 (instruction)。所谓的程序(program)，就是这样一系列指令的所构成的集合。通过程序，我们可以让计算机完成复杂的操作。程序大多数时候被存储为可执行的文件。这样一个可执行文件就像是一个菜谱，计算机可以按照菜谱作出可口的饭菜。</p>
<p>那么，程序和进程(process)的区别又是什么呢?</p>
<p>进程是程序的一个具体实现。只有食谱没什么用，我们总要按照食谱的指点真正一步步实行，才能做出菜肴。进程是执行程序的过程，类似于按照食谱，真正去做菜的过程。同一个程序可以执行多次，每次都可以在内存中开辟独立的空间来装载，从而产生多个进程。不同的进程还可以拥有各自独立的IO接口。</p>
<p>操作系统的一个重要功能就是为进程提供方便，比如说为进程分配内存空间，管理进程的相关信息等等，就好像是为我们准备好了一个精美的厨房。</p>
<p><strong>看一眼进程</strong></p>
<p>首先，我们可以使用<code>$ps</code>命令来查询正在运行的进程，比如<code>$ps -eo pid,comm,cmd</code>，下图为执行结果:</p>
<p>(-e表示列出全部进程，-o pid,comm,cmd表示我们需要PID，COMMAND，CMD信息)</p>
<p><img src="/images/14590055629919.jpg" alt=""></p>
<p>每一行代表了一个进程。每一行又分为三列。第一列PID(process IDentity)是一个整数，每一个进程都有一个唯一的PID来代表自己的身份，进程也可以根据PID来识别其他的进程。第二列COMMAND是这个进程的简称。第三列CMD是进程所对应的程序以及运行时所带的参数。</p>
<p>(第三列有一些由中括号[]括起来的。它们是kernel的一部分功能，被打扮成进程的样子以方便操作系统管理。我们不必考虑它们。)</p>
<p>我们看第一行，PID为1，名字为init。这个进程是执行/bin/init这一文件(程序)生成的。当Linux启动的时候，init是系统创建的第一个进程，这一进程会一直存在，直到我们关闭计算机。这一进程有特殊的重要性，我们会不断提到它。</p>
<p><strong>如何创建一个进程</strong></p>
<p>实际上，当计算机开机的时候，内核(kernel)只建立了一个init进程。Linux kernel并不提供直接建立新进程的系统调用。剩下的所有进程都是init进程通过fork机制建立的。新的进程要通过老的进程复制自身得到，这就是fork。fork是一个系统调用。进程存活于内存中。每个进程都在内存中分配有属于自己的一片空间 (address space)。当进程fork的时候，Linux在内存中开辟出一片新的内存空间给新的进程，并将老的进程空间中的内容复制到新的空间中，此后两个进程同时运行。</p>
<p>老进程成为新进程的父进程(parent process)，而相应的，新进程就是老的进程的子进程(child process)。一个进程除了有一个PID之外，还会有一个PPID(parent PID)来存储的父进程PID。如果我们循着PPID不断向上追溯的话，总会发现其源头是init进程。所以说，所有的进程也构成一个以init为根的树状结构。</p>
<p>如下，我们查询当前shell下的进程：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@vamei:~# ps -o pid,ppid,cmd&#10;  PID  PPID CMD&#10;16935  3101 sudo -i&#10;16939 16935 -bash&#10;23774 16939 ps -o pid,ppid,cmd</span><br></pre></td></tr></table></figure>
<p>我们可以看到，第二个进程bash是第一个进程sudo的子进程，而第三个进程ps是第二个进程的子进程。</p>
<p>还可以用$pstree命令来显示整个进程树：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init&#9472;&#9516;&#9472;NetworkManager&#9472;&#9516;&#9472;dhclient&#10;     &#9474;                &#9492;&#9472;2*[&#123;NetworkManager&#125;]&#10;     &#9500;&#9472;accounts-daemon&#9472;&#9472;&#9472;&#123;accounts-daemon&#125;&#10;     &#9500;&#9472;acpid&#10;     &#9500;&#9472;apache2&#9472;&#9516;&#9472;apache2&#10;     &#9474;         &#9492;&#9472;2*[apache2&#9472;&#9472;&#9472;26*[&#123;apache2&#125;]]&#10;     &#9500;&#9472;at-spi-bus-laun&#9472;&#9472;&#9472;2*[&#123;at-spi-bus-laun&#125;]&#10;     &#9500;&#9472;atd&#10;     &#9500;&#9472;avahi-daemon&#9472;&#9472;&#9472;avahi-daemon&#10;     &#9500;&#9472;bluetoothd&#10;     &#9500;&#9472;colord&#9472;&#9472;&#9472;2*[&#123;colord&#125;]&#10;     &#9500;&#9472;console-kit-dae&#9472;&#9472;&#9472;64*[&#123;console-kit-dae&#125;]&#10;     &#9500;&#9472;cron&#10;     &#9500;&#9472;cupsd&#9472;&#9472;&#9472;2*[dbus]&#10;     &#9500;&#9472;2*[dbus-daemon]&#10;     &#9500;&#9472;dbus-launch&#10;     &#9500;&#9472;dconf-service&#9472;&#9472;&#9472;2*[&#123;dconf-service&#125;]&#10;     &#9500;&#9472;dropbox&#9472;&#9472;&#9472;15*[&#123;dropbox&#125;]&#10;     &#9500;&#9472;firefox&#9472;&#9472;&#9472;27*[&#123;firefox&#125;]&#10;     &#9500;&#9472;gconfd-2&#10;     &#9500;&#9472;geoclue-master&#10;     &#9500;&#9472;6*[getty]&#10;     &#9500;&#9472;gnome-keyring-d&#9472;&#9472;&#9472;7*[&#123;gnome-keyring-d&#125;]&#10;     &#9500;&#9472;gnome-terminal&#9472;&#9516;&#9472;bash&#10;     &#9474;                &#9500;&#9472;bash&#9472;&#9472;&#9472;pstree&#10;     &#9474;                &#9500;&#9472;gnome-pty-helpe&#10;     &#9474;                &#9500;&#9472;sh&#9472;&#9472;&#9472;R&#9472;&#9472;&#9472;&#123;R&#125;&#10;     &#9474;                &#9492;&#9472;3*[&#123;gnome-terminal&#125;]</span><br></pre></td></tr></table></figure>
<p>fork通常作为一个函数被调用。这个函数会有两次返回，将子进程的PID返回给父进程，0返回给子进程。实际上，子进程总可以查询自己的PPID来知道自己的父进程是谁，这样，一对父进程和子进程就可以随时查询对方。</p>
<p>通常在调用fork函数之后，程序会设计一个if选择结构。当PID等于0时，说明该进程为子进程，那么让它执行某些指令,比如说使用exec库函数(library function)读取另一个程序文件，并在当前的进程空间执行 (这实际上是我们使用fork的一大目的: 为某一程序创建进程)；而当PID为一个正整数时，说明为父进程，则执行另外一些指令。由此，就可以在子进程建立之后，让它执行与父进程不同的功能。</p>
<p><strong>子进程的终结(termination)</strong></p>
<p>当子进程终结时，它会通知父进程，并清空自己所占据的内存，并在kernel里留下自己的退出信息(exit code，如果顺利运行，为0；如果有错误或异常状况，为&gt;0的整数)。在这个信息里，会解释该进程为什么退出。父进程在得知子进程终结时，有责任对该子进程使用wait系统调用。这个wait函数能从kernel中取出子进程的退出信息，并清空该信息在kernel中所占据的空间。但是，如果父进程早于子进程终结，子进程就会成为一个孤儿(orphand)进程。孤儿进程会被过继给init进程，init进程也就成了该进程的父进程。init进程负责该子进程终结时调用wait函数。</p>
<p>当然，一个糟糕的程序也完全可能造成子进程的退出信息滞留在kernel中的状况（父进程不对子进程调用wait函数），这样的情况下，子进程成为僵尸（zombie）进程。当大量僵尸进程积累时，内存空间会被挤占。</p>
<p><strong>进程与线程(thread)</strong></p>
<p>尽管在UNIX中，进程与线程是有联系但不同的两个东西，但在Linux中，线程只是一种特殊的进程。多个线程之间可以共享内存空间和IO接口。所以，进程是Linux程序的唯一的实现方式。</p>
<p><strong>总结</strong></p>
<p>程序，进程，PID，内存空间</p>
<p>子进程，父进程，PPID，fork， wait</p>
<h2 id="Linux_u4FE1_u53F7_u57FA_u7840"><a href="#Linux_u4FE1_u53F7_u57FA_u7840" class="headerlink" title="Linux信号基础"></a>Linux信号基础</h2><p>Linux进程基础一文中已经提到，Linux以进程为单位来执行程序。我们可以将计算机看作一个大楼，内核(kernel)是大楼的管理员，进程是大楼的房客。每个进程拥有一个独立的房间(属于进程的内存空间)，而每个房间都是不允许该进程之外的人进入。这样，每个进程都只专注于自己干的事情，而不考虑其他进程，同时也不让别的进程看到自己的房间内部。这对于每个进程来说是一种保护机制。(想像一下几百个进程总是要干涉对方，那会有多么混乱，或者几百个进程相互偷窥……)</p>
<p>然而，在一些情况，我们需要打破封闭的房间，以便和进程交流信息。比如说，内核发现有一个进程在砸墙(硬件错误)，需要让进程意识到这样继续下去会毁了整个大楼。再比如说，我们想让多个进程之间合作。这样，我们就需要一定的通信方式。信号(signal)就是一种向进程传递信息的方式。我们可以将信号想象成大楼的管理员往房间的信箱里塞小纸条。随后进程取出小纸条，会根据纸条上的内容来采取一定的行动，比如灯坏了，提醒进程使用手电。(当然，也可以完全无视这张纸条，然而在失火这样紧急的状况下，无视信号不是个好的选择)。相对于其他的进程间通信方式(interprocess communication， 比如说pipe, shared memory)来说，信号所能传递的信息比较粗糙，只是一个整数。但正是由于传递的信息量少，信号也便于管理和使用。信号因此被经常地用于系统管理相关的任务，比如通知进程终结、中止或者恢复等等。</p>
<p>信号是由内核(kernel)管理的。信号的产生方式多种多样，它可以是内核自身产生的，比如出现硬件错误(比如出现分母为0的除法运算，或者出现segmentation fault)，内核需要通知某一进程；也可以是其它进程产生的，发送给内核，再由内核传递给目标进程。内核中针对每一个进程都有一个表存储相关信息(房间的信箱)。当内核需要将信号传递给某个进程时，就在该进程相对应的表中的适当位置写入信号(塞入纸条)，这样，就生成(generate)了信号。当该进程执行系统调用时，在系统调用完成后退出内核时，都会顺便查看信箱里的信息。如果有信号，进程会执行对应该信号的操作(signal action, 也叫做信号处理signal disposition)，此时叫做执行(deliver)信号。从信号的生成到信号的传递的时间，信号处于等待(pending)状态(纸条还没有被查看)。我们同样可以设计程序，让其生成的进程阻塞(block)某些信号，也就是让这些信号始终处于等待的状态，直到进程取消阻塞(unblock)或者无视信号。</p>
<p><strong>常见信号</strong></p>
<p>信号所传递的每一个整数都被赋予了特殊的意义，并有一个信号名对应该整数。常见的信号有SIGINT, SIGQUIT, SIGCONT, SIGTSTP, SIGALRM等。这些都是信号的名字。你可以通过</p>
<pre><code>$man 7 signal
</code></pre><p>来查阅更多的信号。</p>
<p>上面几个信号中，</p>
<ul>
<li><code>SIGINT</code>   当键盘按下CTRL+C从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是中断 (INTERRUPT) 该进程。</li>
<li><code>SIGQUIT</code>  当键盘按下CTRL+\从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是退出 (QUIT) 该进程。</li>
<li><code>SIGTSTP</code>  当键盘按下CTRL+Z从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是暂停 (STOP) 该进程。</li>
<li><code>SIGCONT</code>  用于通知暂停的进程继续。</li>
<li><code>SIGALRM</code>  起到定时器的作用，通常是程序在一定的时间之后才生成该信号。</li>
</ul>
<p><strong>在shell中使用信号</strong></p>
<p>下面我们实际应用一下信号。我们在shell中运行ping：</p>
<pre><code>$ping localhost
</code></pre><p>此时我们可以通过CTRL+Z来将SIGTSTP传递给该进程。shell中显示：</p>
<pre><code>[1]+  Stopped                 ping localhost
</code></pre><p>我们使用<code>$ps</code>来查询ping进程的PID (PID是ping进程的房间号), 在我的机器中为27397</p>
<p>我们可以在shell中通过$kill命令来向某个进程发出信号:</p>
<pre><code>$kill -SIGCONT  27397
</code></pre><p>来传递SIGCONT信号给ping进程。</p>
<p><strong>信号处理 (signal disposition)</strong></p>
<p>在上面的例子中，所有的信号都采取了对应信号的默认操作。但这并不绝对。当进程决定执行信号的时候，有下面几种可能：</p>
<ol>
<li>无视(ignore)信号，信号被清除，进程本身不采取任何特殊的操作</li>
<li>默认(default)操作。每个信号对应有一定的默认操作。比如上面SIGCONT用于继续进程。</li>
<li>自定义操作。也叫做获取 (catch) 信号。执行进程中预设的对应于该信号的操作。</li>
</ol>
<p>进程会采取哪种操作，要根据该进程的程序设计。特别是获取信号的情况，程序往往会设置一些比较长而复杂的操作(通常将这些操作放到一个函数中)。</p>
<p>信号常常被用于系统管理，所以它的内容相当庞杂。深入了解信号，需要一定的Linux环境编程知识。</p>
<p><strong>总结</strong></p>
<p>信号机制; generate, deliver, pending, blocking</p>
<p>signal action/dispositon; ignore, default action, catch signal</p>
<p><code>$kill</code></p>
<h2 id="Linux_u8FDB_u7A0B_u5173_u7CFB"><a href="#Linux_u8FDB_u7A0B_u5173_u7CFB" class="headerlink" title="Linux进程关系"></a>Linux进程关系</h2><p>Linux的进程相互之间有一定的关系。比如说，在Linux进程基础中，我们看到，每个进程都有父进程，而所有的进程以init进程为根，形成一个树状结构。我们在这里讲解进程组和会话，以便以更加丰富的方式了管理进程。</p>
<p><strong>进程组 (process group)</strong></p>
<p>每个进程都会属于一个进程组(process group)，每个进程组中可以包含多个进程。进程组会有一个进程组领导进程 (process group leader)，领导进程的PID (PID见Linux进程基础)成为进程组的ID (process group ID, PGID)，以识别进程组。</p>
<pre><code>$ps -o pid,pgid,ppid,comm | cat
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  PID  PGID  PPID COMMAND</span><br><span class="line"><span class="number">17763</span> <span class="number">17763</span> <span class="number">17751</span> bash</span><br><span class="line"><span class="number">18534</span> <span class="number">18534</span> <span class="number">17763</span> ps</span><br><span class="line"><span class="number">18535</span> <span class="number">18534</span> <span class="number">17763</span> cat</span><br></pre></td></tr></table></figure>
<p>PID为进程自身的ID，PGID为进程所在的进程组的ID， PPID为进程的父进程ID。从上面的结果，我们可以推测出如下关系：</p>
<p><img src="/images/14590055773563.jpg" alt=""></p>
<p>图中箭头表示父进程通过fork和exec机制产生子进程。ps和cat都是bash的子进程。进程组的领导进程的PID成为进程组ID。领导进程可以先终结。此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。</p>
<p>我们将一些进程归为进程组的一个重要原因是我们可以将信号发送给一个进程组。进程组中的所有进程都会收到该信号。我们会在下一部分深入讨论这一点。</p>
<p><strong>会话 (session)</strong></p>
<p>更进一步，在shell支持工作控制(job control)的前提下，多个进程组还可以构成一个会话 (session)。bash(Bourne-Again shell)支持工作控制，而sh(Bourne shell)并不支持。</p>
<p>会话是由其中的进程建立的，该进程叫做会话的领导进程(session leader)。会话领导进程的PID成为识别会话的SID(session ID)。会话中的每个进程组称为一个工作(job)。会话可以有一个进程组成为会话的前台工作(foreground)，而其他的进程组是后台工作(background)。每个会话可以连接一个控制终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。由终端产生的信号，比如CTRL+Z， CTRL+\，会传递到前台进程组。</p>
<p>会话的意义在于将多个工作囊括在一个终端，并取其中的一个工作作为前台，来直接接收该终端的输入输出以及终端信号。 其他工作在后台运行。</p>
<p>一个命令可以通过在末尾加上&amp;方式让它在后台运行:</p>
<pre><code>$ping localhost &gt; log &amp;
</code></pre><p>此时终端显示:</p>
<pre><code>[1] 10141
</code></pre><p>括号中的1表示工作号，而10141为PGID</p>
<p>我们通过如下方式查询更加详细的信息:</p>
<pre><code>$ps -o pid,pgid,ppid,sid,tty,comm
(tty表示控制终端）
</code></pre><p>信号可以通过kill</p>
<pre><code>$kill -SIGTERM -10141
</code></pre><p>或者</p>
<pre><code>$kill -SIGTERM %1
</code></pre><p>的方式来发送给工作组。上面的两个命令，一个是发送给PGID(通过在PGID前面加-来表示是一个PGID而不是PID)，一个是发送给工作1(%1)，两者等价。</p>
<p>一个工作可以通过$fg从后台工作变为前台工作:</p>
<pre><code>$cat &gt; log &amp;
$fg %1
</code></pre><p>当我们运行第一个命令后，由于工作在后台，我们无法对命令进行输入，直到我们将工作带入前台，才能向cat命令输入。在输入完成后，按下CTRL+D来通知shell输入结束。</p>
<p>进程组(工作)的概念较为简单易懂。而会话主要是针对一个终端建立的。当我们打开多个终端窗口时，实际上就创建了多个终端会话。每个会话都会有自己的前台工作和后台工作。这样，我们就为进程增加了管理和运行的层次。在没有图形化界面的时代，会话允许用户通过shell进行多层次的进程发起和管理。比如说，我可以通过shell发起多个后台工作，而此时标准输入输出并不被占据，我依然可以继续其它的工作。如今，图形化界面可以帮助我们解决这一需求，但工作组和会话机制依然在Linux的许多地方应用。</p>
<p><strong>总结</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process group, pgid</span><br><span class="line">session, sid, job, forground, background</span><br><span class="line"><span class="built_in">fg</span>, <span class="built_in">kill</span> -pid, &amp;, %</span><br></pre></td></tr></table></figure>
<h2 id="Linux_u7528_u6237"><a href="#Linux_u7528_u6237" class="headerlink" title="Linux用户"></a>Linux用户</h2><p>Linux的用户在登录(login)之后，就带有一个用户身份(user ID, UID)和一个组身份(group ID, GID)。在Linux文件管理背景知识中，我们又看到，每个文件又有九位的权限说明，用来指明该文件允许哪些用户执行哪些操作(读、写或者执行)。</p>
<p><strong>进程权限</strong></p>
<p>但是，在Linux中，用户的指令是在进程的范围内进行的。当我们向对某个文件进行操作的时候，我们需要在进程中运行一个程序，在进程中对文件打开，并进行读、写或者执行的操作。因此，我们需要将用户的权限传递给进程，以便进程真正去执行操作。例如我们有一个文件a.txt, 文件中为一个字符串:</p>
<pre><code>Hello world!
</code></pre><p>我以用户Vamei的身份登录，并在shell中运行如下命令：</p>
<pre><code>$cat a.txt
</code></pre><p>整个运行过程以及文件读取如下:</p>
<p><img src="/images/14590055890788.jpg" alt=""></p>
<p>我们可以看到，整个过程中我们会有两个进程，一个是shell本身(2256)，一个是shell复制自身，再运行/bin/cat (9913)。图中的fork, exec, PID可参看Linux进程基础。第二个进程总共对文件系统进行了两次操作，一次是执行(x)文件/bin/cat，另外一次是读取(r)文件a.txt。使用<code>$ls -l</code> 查看这两个文件的权限:</p>
<pre><code>$ls -l /bin/cat
-rwxr-xr-x 1 root root 46764 Apr  1  2012 /bin/cat

$ls -l a.txt
-rw-rw-r-- 1 Vamei Vamei 14 Oct  7 09:14 a.txt
</code></pre><p>从上面可以看到(参考Linux文件管理背景知识)，/bin/cat让所有用户都享有执行的权利，而Vamei作为a.txt的拥有者，对a.txt享有读取的权利。</p>
<p>让我们进入更多的细节 (The devil is in the details)。在进行这两次操作的时候，尽管用户Vamei拥有相应的权限，但我们发现，真正做工作的是进程9913。我们要让这个进程得到相应的权限。实际上，每个进程会维护有如下6个ID：</p>
<p>真实身份: real UID,       real GID</p>
<p>有效身份: effective UID,  effective GID</p>
<p>存储身份: saved UID,      saved GID</p>
<p>其中，真实身份是我们登录使用的身份，有效身份是当该进程真正去操作文件时所检查的身份，存储身份较为特殊，我们等一下再深入。当进程fork的时候，真实身份和有效身份都会复制给子进程。大部分情况下，真实身份和有效身份都相同。当Linux完成开机启动之后，init进程会执行一个login的子进程。我们将用户名和密码传递给login子进程。login在查询了/etc/passwd和/etc/shadow，并确定了其合法性之后，运行(利用exec)一个shell进程，shell进程真实身份被设置成为该用户的身份。由于此后fork此shell进程的子进程都会继承真实身份，所以该真实身份会持续下去，直到我们登出并以其他身份再次登录(当我们使用su成为root的时候，实际上就是以root身份再次登录，此后真实身份成为root)。</p>
<p><strong>最小权限原则</strong></p>
<p>每个进程为什么不简单地只维护真实身份，却选择费尽麻烦地去维护有效身份和存储身份呢？这牵涉到Linux的“最小特权”(least priviledge)的原则。Linux通常希望进程只拥有足够完成其工作的特权，而不希望赋予更多的特权给它。从设计上来说，最简单的是赋予每个进程以super user的特权，这样进程就可以想做什么做什么。然而，这对于系统来说是一个巨大的安全漏洞，特别是在多用户环境下，如果每个用户都享有无限制的特权，就很容易破坏其他用户的文件或者系统本身。“最小特权”就是收缩进程所享有的特权，以防进程滥用特权。</p>
<p>然而，进程的不同阶段可能需要不同的特权。比如一个进程最开始的有效身份是真实身份，但运行到中间的时候，需要以其他的用户身份读入某些配置文件，然后再进行其他的操作。为了防止其他的用户身份被滥用，我们需要在操作之前，让进程的有效身份变更回来成为真实身份。这样，进程需要在两个身份之间变化。</p>
<p>存储身份就是真实身份之外的另一个身份。当我们将一个程序文件执行成为进程的时候，该程序文件的拥有者(owner)和拥有组(owner group)可以被，存储成为进程的存储身份。在随后进程的运行过程中，进程就将可以选择将真实身份或者存储身份复制到有效身份，以拥有真实身份或者存储身份的权限。并不是所有的程序文件在执行的过程都设置存储身份的。需要这么做的程序文件会在其九位(bit)权限的执行位的x改为s。这时，这一位(bit)叫做set UID bit或者set GID bit。</p>
<pre><code>$ls -l /usr/bin/uuidd
-rwsr-sr-x 1 libuuid libuuid 17976 Mar 30  2012 /usr/sbin/uuidd
</code></pre><p>当我以root(UID), root(GID)的真实身份运行这个程序的时候，由于拥有者(owner)有s位的设定，所以saved UID被设置成为libuuid，saved GID被设置成为libuuid。这样，uuidd的进程就可以在两个身份之间切换。</p>
<p>我们通常使用chmod来修改set-UID bit和set-GID bit:</p>
<pre><code>$chmod 4700 file
</code></pre><p>我们看到，这里的chmod后面不再只是三位的数字。最前面一位用于处理set-UID bit/set-GID bit，它可以被设置成为4/2/1以及或者上面数字的和。4表示为set UID bit, 2表示为set GID bit，1表示为sticky bit (暂时不介绍)。必须要先有x位的基础上，才能设置s位。</p>
<p>作为一个Linux用户来说，我们并不需要特别关心上面的机制。但是，当我们去编写一个Linux应用程序的时候，就要注意在程序中实现以上切换(有必要的前提下)，以便让我们的程序符合”最小权限”的原则，不给系统留下可能的安全隐患</p>
<h2 id="Linux_u4ECE_u7A0B_u5E8F_u5230_u8FDB_u7A0B"><a href="#Linux_u4ECE_u7A0B_u5E8F_u5230_u8FDB_u7A0B" class="headerlink" title="Linux从程序到进程"></a>Linux从程序到进程</h2><p>计算机如何执行进程呢？这是计算机运行的核心问题。即使已经编写好程序，但程序是死的。只有活的进程才能产出。我们已经从Linux进程基础中了解了进程。现在我们看一下从程序到进程的漫漫征程。</p>
<p><strong>一段程序</strong></p>
<p>下面是一个简单的C程序，假设该程序已经编译好</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> glob=<span class="number">0</span>;                                             <span class="comment">/*global variable*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> main1=<span class="number">5</span>;                                          <span class="comment">/*local variable of main()*/</span></span><br><span class="line">  <span class="keyword">int</span> main2;                                            <span class="comment">/*local variable of main()*/</span></span><br><span class="line">  main2 = inner(main1);                                 <span class="comment">/* call inner() function */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"From Main: glob: %d \n"</span>, glob);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"From Main: main2: %d \n"</span>, main2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inner</span><span class="params">(<span class="keyword">int</span> inner1)</span> </span>&#123;                                 <span class="comment">/*inner1 is an argument, also local to inner()*/</span></span><br><span class="line">  <span class="keyword">int</span> inner2=<span class="number">10</span>;                                        <span class="comment">/*local variable of inner()*/</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"From inner: glob: %d \n"</span>, glob);</span><br><span class="line">  <span class="keyword">return</span>(inner1+inner2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(选取哪一个语言或者具体的语法并不是关键，大部分语言都可以写出类似上面的程序。在看Python教程的读者也可以利用Python的函数结构和print写一个类似的python程序。当然，还可以是C++，Java，Objective-C等等。选用C语言的原因是：它是为UNIX而生的语言。)</p>
<p>main()函数中调用了inner()函数。inner()中调用一次printf()以输出。最后，在main()中进行了两次printf()。</p>
<p>注意变量的作用范围。简单地说，变量可以分为全局变量和局部变量。在所有函数之外声明的变量为全局变量，比如glob，在任何时候都可以使用。在函数内定义的变量为局部变量，只能在该函数的作用域(range)内使用，比如说我们在inner()工作的时候不能使用main()函数中声明的main1变量，而在main()中我们无法使用inner()函数中声明的inner2变量。</p>
<p>不用太过在意这个程序的具体功能。要点是这个程序的运行过程。下图为该程序的运行过程，以及各个变量的作用范围：</p>
<p><img src="/images/14590056061703.jpg" alt=""></p>
<p><strong>进程空间</strong></p>
<p>为了进一步了解上面程序的运行，我们还需要知道，进程如何使用内存。当程序文件运行为进程时，进程在内存中获得空间。这个空间是进程自己的小屋子。</p>
<p>每个进程空间按照如下方式分为不同区域:</p>
<p><img src="/images/14590056162054.jpg" alt=""></p>
<p>Text区域用来储存指令(instruction)，说明每一步的操作。Global Data用于存放全局变量，栈(Stack)用于存放局部变量，堆(heap)用于存放动态变量 (dynamic variable. 程序利用malloc系统调用，直接从内存中为dynamic variable开辟空间)。Text和Global data在进程一开始的时候就确定了，并在整个进程中保持固定大小。</p>
<p>栈(Stack)以帧(stack frame)为单位。当程序调用函数的时候，比如main()函数中调用inner()函数，stack会向下增长一帧。帧中存储该函数的参数和局部变量，以及该函数的返回地址(return address)。此时，计算机将控制权从main()转移到inner()，inner()函数处于激活(active)状态。位于栈最下方的帧，和全局变量一起，构成了当前的环境(context)。激活函数可以从环境中调用需要的变量。典型的编程语言都只允许你使用位于stack最下方的帧 ，而不允许你调用其它的帧 (这也符合stack结构“先进后出”的特征。但也有一些语言允许你调用栈的其它部分，相当于允许你在运行inner()函数的时候调用main()中声明的局部变量，比如Pascal)。当函数又进一步调用另一个函数的时候，一个新的帧会继续增加到栈的下方，控制权转移到新的函数中。当激活函数返回的时候，会从栈中弹出(pop，读取并从栈中删除)该帧，并根据帧中记录的返回地址，将控制权交给返回地址所指向的指令(比如从inner()函数中返回，继续执行main()中赋值给main2的操作)。</p>
<p>下图是栈在运行过程中的变化。箭头表示栈的增长方向。每个方块代表一帧。开始的时候我们有一个为main()服务的帧，随着调用inner()，我们为inner()增加一个帧。在inner()返回时，我们再次只有main()的帧，直到最后main()返回，其返回地址为空，所以进程结束。</p>
<p><img src="/images/14590056276526.jpg" alt=""></p>
<p>在进程运行的过程中，通过调用和返回函数，控制权不断在函数间转移。进程可以在调用函数的时候，原函数的帧中保存有在我们离开时的状态，并为新的函数开辟所需的帧空间。在调用函数返回时，该函数的帧所占据的空间随着帧的弹出而清空。进程再次回到原函数的帧中保存的状态，并根据返回地址所指向的指令继续执行。上面过程不断继续，栈不断增长或减小，直到main()返回的时候，栈完全清空，进程结束。</p>
<p>当程序中使用malloc的时候，堆(heap)会向上增长，其增长的部分就成为malloc从内存中分配的空间。malloc开辟的空间会一直存在，直到我们用free系统调用来释放，或者进程结束。一个经典的错误是内存泄漏(memory leakage), 就是指我们没有释放不再使用的堆空间，导致堆不断增长，而内存可用空间不断减少。</p>
<p>栈和堆的大小则会随着进程的运行增大或者变小。当栈和堆增长到两者相遇时候，也就是内存空间图中的蓝色区域(unused area)完全消失的时候，再无可用内存。进程会出现栈溢出(stack overflow)的错误，导致进程终止。在现代计算机中，内核一般会为进程分配足够多的蓝色区域，如果清理及时，栈溢出很容易避免。即便如此，内存负荷过大，依然可能出现栈溢出的情况。我们就需要增加物理内存了。</p>
<p>Stack overflow可以说是最出名的计算机错误了，所以才有IT网站(stackoverflow.com)以此为名。</p>
<p><strong>进程附加信息</strong></p>
<p>除了上面的信息之外，每个进程还要包括一些进程附加信息，包括PID，PPID，PGID(参考Linux进程基础以及Linux进程关系)等，用来说明进程的身份、进程关系以及其它统计信息。这些信息并不保存在进程的内存空间中。内核会为每个进程在内核自己的空间中分配一个变量(task_struct结构体)以保存上述信息。内核可以通过查看自己空间中的各个进程的附加信息就能知道进程的概况，而不用进入到进程自身的空间 (就好像我们可以通过门牌就可以知道房间的主人是谁一样，而不用打开房门)。每个进程的附加信息中有位置专门用于保存接收到的信号(正如我们在Linux信号基础中所说的“信箱”)。</p>
<p><strong>fork &amp; exec</strong></p>
<p>现在，我们可以更加深入地了解fork和exec(参考Linux进程基础)的机制了。当一个程序调用fork的时候，实际上就是将上面的内存空间，包括text, global data, heap和stack，又复制出来一个，构成一个新的进程，并在内核中为改进程创建新的附加信息 (比如新的PID，而PPID为原进程的PID)。此后，两个进程分别地继续运行下去。新的进程和原有进程有相同的运行状态(相同的变量值，相同的instructions…)。我们只能通过进程的附加信息来区分两者。</p>
<p>程序调用exec的时候，进程清空自身内存空间的text, global data, heap和stack，并根据新的程序文件重建text, global data, heap和stack (此时heap和stack大小都为0)，并开始运行。</p>
<p>(现代操作系统为了更有效率，改进了管理fork和exec的具体机制，但从逻辑上来说并没有差别。具体机制请参看Linux内核相关书籍)</p>
<p>这一篇写了整合了许多东西，所以有些长。这篇文章主要是概念性的，许多细节会根据语言和平台乃至于编译器的不同而有所变化，但大体上，以上的概念适用于所有的计算机进程(无论是Windows还是UNIX)。更加深入的内容，包括线程(thread)、进程间通信(IPC)等，都依赖于这里介绍的内容。</p>
<p><strong>总结</strong></p>
<p>函数，变量的作用范围，global/local/dynamic variables</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">global data, text,</span><br><span class="line"><span class="built_in">stack</span>, <span class="built_in">stack</span> frame, <span class="keyword">return</span> address, <span class="built_in">stack</span> overflow</span><br><span class="line">heap, <span class="built_in">malloc</span>, <span class="built_in">free</span>, memory leakage</span><br><span class="line">进程附加信息, task_struct</span><br><span class="line">fork &amp; exec</span><br></pre></td></tr></table></figure>
<h2 id="Linux_u591A_u7EBF_u7A0B_u4E0E_u540C_u6B65"><a href="#Linux_u591A_u7EBF_u7A0B_u4E0E_u540C_u6B65" class="headerlink" title="Linux多线程与同步"></a>Linux多线程与同步</h2><p>典型的UNIX系统都支持一个进程创建多个线程(thread)。在Linux进程基础中提到，Linux以进程为单位组织操作，Linux中的线程也都基于进程。尽管实现方式有异于其它的UNIX系统，但Linux的多线程在逻辑和使用上与真正的多线程并没有差别。</p>
<p><strong>多线程</strong></p>
<p>我们先来看一下什么是多线程。在Linux从程序到进程中，我们看到了一个程序在内存中的表示。这个程序的整个运行过程中，只有一个控制权的存在。当函数被调用的时候，该函数获得控制权，成为激活(active)函数，然后运行该函数中的指令。与此同时，其它的函数处于离场状态，并不运行。如下图所示:</p>
<p><img src="/images/14590056454901.jpg" alt=""></p>
<p>我们看到，各个方块之间由箭头连接。各个函数就像是连在一根线上一样，计算机像一条流水线一样执行各个函数中定义的操作。这样的一个程序叫做单线程程序。</p>
<p>多线程就是允许一个进程内存在多个控制权，以便让多个函数同时处于激活状态，从而让多个函数的操作同时运行。即使是单CPU的计算机，也可以通过不停地在不同线程的指令间切换，从而造成多线程同时运行的效果。如下图所示，就是一个多线程的流程:</p>
<p><img src="/images/14590056551293.jpg" alt=""></p>
<p>main()到func3()再到main()构成一个线程，此外func1()和func2()构成另外两个线程。操作系统一般都有一些系统调用来让你将一个函数运行成为一个新的线程。</p>
<p>回忆我们在Linux从程序到进程中提到的栈的功能和用途。一个栈，只有最下方的帧可被读写。相应的，也只有该帧对应的那个函数被激活，处于工作状态。为了实现多线程，我们必须绕开栈的限制。为此，创建一个新的线程时，我们为这个线程建一个新的栈。每个栈对应一个线程。当某个栈执行到全部弹出时，对应线程完成任务，并收工。所以，多线程的进程在内存中有多个栈。多个栈之间以一定的空白区域隔开，以备栈的增长。每个线程可调用自己栈最下方的帧中的参数和变量，并与其它线程共享内存中的Text，heap和global data区域。对应上面的例子，我们的进程空间中需要有3个栈。</p>
<p>(要注意的是，对于多线程来说，由于同一个进程空间中存在多个栈，任何一个空白区域被填满都会导致stack overflow的问题。)</p>
<p><strong>并发</strong></p>
<p>多线程相当于一个并发(concunrrency)系统。并发系统一般同时执行多个任务。如果多个任务可以共享资源，特别是同时写入某个变量的时候，就需要解决同步的问题。比如说，我们有一个多线程火车售票系统，用全局变量i存储剩余的票数。多个线程不断地卖票(i = i - 1)，直到剩余票数为0。所以每个都需要执行如下操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*mu is a global mutex*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;                        <span class="comment">/*infinite loop*/</span></span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) i = i -<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"no more tickets"</span>);</span><br><span class="line">      <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只有一个线程执行上面的程序的时候(相当于一个窗口售票)，则没有问题。但如果多个线程都执行上面的程序(相当于多个窗口售票), 我们就会出现问题。我们会看到，其根本原因在于同时发生的各个线程都可以对i读取和写入。</p>
<p>我们这里的if结构会给CPU两个指令, 一个是判断是否有剩余的票(i != 0), 一个是卖票 (i = i -1)。某个线程会先判断是否有票(比如说此时i为1)，但两个指令之间存在一个时间窗口，其它线程可能在此时间窗口内执行卖票操作(i = i -1)，导致该线程卖票的条件不再成立。但该线程由于已经执行过了判断指令，所以无从知道i发生了变化，所以继续执行卖票指令，以至于卖出不存在的票 (i成为负数)。对于一个真实的售票系统来说，这将成为一个严重的错误 (售出了过多的票，火车爆满)。</p>
<p>在并发情况下，指令执行的先后顺序由内核决定。同一个线程内部，指令按照先后顺序执行，但不同线程之间的指令很难说清除哪一个会先执行。如果运行的结果依赖于不同线程执行的先后的话，那么就会造成竞争条件(race condition)，在这样的状况下，计算机的结果很难预知。我们应该尽量避免竞争条件的形成。最常见的解决竞争条件的方法是将原先分离的两个指令构成不可分隔的一个原子操作(atomic operation)，而其它任务不能插入到原子操作中。</p>
<p><strong>多线程同步</strong></p>
<p>对于多线程程序来说，同步(synchronization)是指在一定的时间内只允许某一个线程访问某个资源 。而在此时间内，不允许其它的线程访问该资源。我们可以通过互斥锁(mutex)，条件变量(condition variable)和读写锁(reader-writer lock)来同步资源。</p>
<p><strong>1) 互斥锁</strong></p>
<p>互斥锁是一个特殊的变量，它有锁上(lock)和打开(unlock)两个状态。互斥锁一般被设置成全局变量。打开的互斥锁可以由某个线程获得。一旦获得，这个互斥锁会锁上，此后只有该线程有权打开。其它想要获得互斥锁的线程，会等待直到互斥锁再次打开的时候。我们可以将互斥锁想像成为一个只能容纳一个人的洗手间，当某个人进入洗手间的时候，可以从里面将洗手间锁上。其它人只能在互斥锁外面等待那个人出来，才能进去。在外面等候的人并没有排队，谁先看到洗手间空了，就可以首先冲进去。</p>
<p>上面的问题很容易使用互斥锁的问题解决，每个线程的程序可以改为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*mu is a global mutex*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;                <span class="comment">/*infinite loop*/</span></span><br><span class="line">  mutex_lock(mu);           <span class="comment">/*aquire mutex and lock it, if cannot, wait until mutex is unblocked*/</span></span><br><span class="line">  <span class="keyword">if</span> (i != <span class="number">0</span>) i = i - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"no more tickets"</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_unlock(mu);         <span class="comment">/*release mutex, make it unblocked*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个执行mutex_lock()的线程会先获得mu。其它想要获得mu的线程必须等待，直到第一个线程执行到mutex_unlock()释放mu，才可以获得mu，并继续执行线程。所以线程在mutex_lock()和mutex_unlock()之间的操作时，不会被其它线程影响，就构成了一个原子操作。</p>
<p>需要注意的时候，如果存在某个线程依然使用原先的程序 (即不尝试获得mu，而直接修改i)，互斥锁不能阻止该程序修改i，互斥锁就失去了保护资源的意义。所以，互斥锁机制需要程序员自己来写出完善的程序来实现互斥锁的功能。我们下面讲的其它机制也是如此。</p>
<p><strong>2) 条件变量</strong></p>
<p>条件变量是另一种常用的变量。它也常常被保存为全局变量，并和互斥锁合作。</p>
<p>假设这样一个状况: 有100个工人，每人负责装修一个房间。当有10个房间装修完成的时候，老板就通知相应的十个工人一起去喝啤酒。</p>
<p>我们如何实现呢？老板让工人在装修好房间之后，去检查已经装修好的房间数。但多线程条件下，会有竞争条件的危险。也就是说，其他工人有可能会在该工人装修好房子和检查之间完成工作。采用下面方式解决：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*mu: global mutex, cond: global codition variable, num: global int*/</span></span><br><span class="line">mutex_lock(mu)</span><br><span class="line"></span><br><span class="line">num = num + <span class="number">1</span>;                      <span class="comment">/*worker build the room*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num &lt;= <span class="number">10</span>) &#123;                     <span class="comment">/*worker is within the first 10 to finish*/</span></span><br><span class="line">    cond_wait(mu, cond);            <span class="comment">/*wait*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"drink beer"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num = <span class="number">11</span>) &#123;                <span class="comment">/*workder is the 11th to finish*/</span></span><br><span class="line">  cond_broadcast(mu, cond);         <span class="comment">/*inform the other 9 to wake up*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutex_unlock(mu);</span><br></pre></td></tr></table></figure>
<p>上面使用了条件变量。条件变量除了要和互斥锁配合之外，还需要和另一个全局变量配合(这里的num, 也就是装修好的房间数)。这个全局变量用来构成各个条件。</p>
<p>具体思路如下。我们让工人在装修好房间(num = num + 1)之后，去检查已经装修好的房间数( num &lt; 10 )。由于mu被锁上，所以不会有其他工人在此期间装修房间(改变num的值)。如果该工人是前十个完成的人，那么我们就调用cond_wait()函数。<br>cond_wait()做两件事情，一个是释放mu，从而让别的工人可以建房。另一个是等待，直到cond的通知。这样的话，符合条件的线程就开始等待。</p>
<p>当有通知(第十个房间已经修建好)到达的时候，condwait()会再次锁上mu。线程的恢复运行，执行下一句prinft(“drink beer”) (喝啤酒！)。从这里开始，直到mutex_unlock()，就构成了另一个互斥锁结构。</p>
<p>那么，前面十个调用cond_wait()的线程如何得到的通知呢？我们注意到elif if，即修建好第11个房间的人，负责调用cond_broadcast()。这个函数会给所有调用cond_wait()的线程放送通知，以便让那些线程恢复运行。</p>
<p>条件变量特别适用于多个线程等待某个条件的发生。如果不使用条件变量，那么每个线程就需要不断尝试获得互斥锁并检查条件是否发生，这样大大浪费了系统的资源。</p>
<p><strong>3) 读写锁</strong></p>
<p>读写锁与互斥锁非常相似。r、RW lock有三种状态: 共享读取锁(shared-read), 互斥写入锁(exclusive-write lock), 打开(unlock)。后两种状态与之前的互斥锁两种状态完全相同。</p>
<p>一个unlock的RW lock可以被某个线程获取R锁或者W锁。</p>
<p>如果被一个线程获得R锁，RW lock可以被其它线程继续获得R锁，而不必等待该线程释放R锁。但是，如果此时有其它线程想要获得W锁，它必须等到所有持有共享读取锁的线程释放掉各自的R锁。</p>
<p>如果一个锁被一个线程获得W锁，那么其它线程，无论是想要获取R锁还是W锁，都必须等待该线程释放W锁。</p>
<p>这样，多个线程就可以同时读取共享资源。而具有危险性的写入操作则得到了互斥锁的保护。</p>
<p>我们需要同步并发系统，这为程序员编程带来了难度。但是多线程系统可以很好的解决许多IO瓶颈的问题。比如我们监听网络端口。如果我们只有一个线程，那么我们必须监听，接收请求，处理，回复，再监听。如果我们使用多线程系统，则可以让多个线程监听。当我们的某个线程进行处理的时候，我们还可以有其他的线程继续监听，这样，就大大提高了系统的利用率。在数据越来越大，服务器读写操作越来越多的今天，这具有相当的意义。多线程还可以更有效地利用多CPU的环境。</p>
<p>(就像做饭一样，不断切换去处理不同的菜。)</p>
<p>本文中的程序采用伪C的写法。不同的语言有不同的函数名(比如mutex_lock)。这里关注的是逻辑上的概念，而不是具体的实现和语言规范。</p>
<p><strong>总结</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">multiple </span>threads, <span class="keyword">multiple </span>stacks</span><br><span class="line"><span class="label">race</span> condition</span><br><span class="line"><span class="label">mutex</span>, condition variable, RW lock</span><br></pre></td></tr></table></figure>
<h2 id="Linux_u8FDB_u7A0B_u95F4_u901A_u4FE1"><a href="#Linux_u8FDB_u7A0B_u95F4_u901A_u4FE1" class="headerlink" title="Linux进程间通信"></a>Linux进程间通信</h2><p>我们在Linux信号基础中已经说明，信号可以看作一种粗糙的进程间通信(IPC, interprocess communication)的方式，用以向进程封闭的内存空间传递信息。为了让进程间传递更多的信息量，我们需要其他的进程间通信方式。这些进程间通信方式可以分为两种:</p>
<ul>
<li>管道(PIPE)机制。在Linux文本流中，我们提到可以使用管道将一个进程的输出和另一个进程的输入连接起来，从而利用文件操作API来管理进程间通信。在shell中，我们经常利用管道将多个进程连接在一起，从而让各个进程协作，实现复杂的功能。</li>
<li>传统IPC (interprocess communication)。我们主要是指消息队列(message queue)，信号量(semaphore)，共享内存(shared memory)。这些IPC的特点是允许多进程之间共享资源，这与多线程共享heap和global data相类似。由于多进程任务具有并发性 (每个进程包含一个进程，多个进程的话就有多个线程)，所以在共享资源的时候也必须解决同步的问题 (参考Linux多线程与同步)。</li>
</ul>
<p><strong>管道与FIFO文件</strong></p>
<p>一个原始的IPC方式是所有的进程通过一个文件交流。比如我在纸(文件)上写下我的名字和年纪。另一个人读这张纸，会知道我的名字和年纪。他也可以在同一张纸上写下他的信息，而当我读这张纸的话，同样也可以知道别人的信息。但是，由于硬盘读写比较慢，所以这个方式效率很低。那么，我们是否可以将这张纸放入内存中以提高读写速度呢？</p>
<p>在Linux文本流中，我们已经讲解了如何在shell中使用管道连接多个进程。同样，许多编程语言中，也有一些命令用以实现类似的机制，比如在Python子进程中使用Popen和PIPE，在C语言中也有popen库函数来实现管道 (shell中的管道就是根据此编写的)。管道是由内核管理的一个缓冲区(buffer)，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。</p>
<p><img src="/images/14590056730715.jpg" alt=""></p>
<p>从原理上，管道利用fork机制建立(参考Linux进程基础和Linux从程序到进程），从而让两个进程可以连接到同一个PIPE上。最开始的时候，上面的两个箭头都连接在同一个进程Process 1上(连接在Process 1上的两个箭头)。当fork复制进程的时候，会将这两个连接也复制到新的进程(Process 2)。随后，每个进程关闭自己不需要的一个连接 (两个黑色的箭头被关闭; Process 1关闭从PIPE来的输入连接，Process 2关闭输出到PIPE的连接)，这样，剩下的红色连接就构成了如上图的PIPE。</p>
<p><img src="/images/14590056811596.jpg" alt=""></p>
<p><strong>传统IPC</strong></p>
<p>这几种传统IPC实际上有很悠久的历史，所以其实现方式也并不完善 (比如说我们需要某个进程负责删除建立的IPC)。一个共同的特征是它们并不使用文件操作的API。对于任何一种IPC来说，你都可以建立多个连接，并使用键值(key)作为识别的方式。我们可以在一个进程中中通过键值来使用的想要那一个连接 (比如多个消息队列，而我们选择使用其中的一个)。键值可以通过某种IPC方式在进程间传递(比如说我们上面说的PIPE，FIFO或者写入文件)，也可以在编程的时候内置于程序中。</p>
<p>在几个进程共享键值的情况下，这些传统IPC非常类似于多线程共享资源的方式(参看Linux多线程与同步):</p>
<ul>
<li>semaphore与mutex类似，用于处理同步问题。我们说mutex像是一个只能容纳一个人的洗手间，那么semaphore就像是一个能容纳N个人的洗手间。其实从意义上来说，semaphore就是一个计数锁(我觉得将semaphore翻译成为信号量非常容易让人混淆semaphore与signal)，它允许被N个进程获得。当有更多的进程尝试获得semaphore的时候，就必须等待有前面的进程释放锁。当N等于1的时候，semaphore与mutex实现的功能就完全相同。许多编程语言也使用semaphore处理多线程同步的问题。一个semaphore会一直存在在内核中，直到某个进程删除它。</li>
<li>共享内存与多线程共享global data和heap类似。一个进程可以将自己内存空间中的一部分拿出来，允许其它进程读写。当使用共享内存的时候，我们要注意同步的问题。我们可以使用semaphore同步，也可以在共享内存中建立mutex或其它的线程同步变量来同步。由于共享内存允许多个进程直接对同一个内存区域直接操作，所以它是效率最高的IPC方式。</li>
</ul>
<p>消息队列(message queue)与PIPE相类似。它也是建立一个队列，先放入队列的消息被最先取出。不同的是，消息队列允许多个进程放入消息，也允许多个进程取出消息。每个消息可以带有一个整数识别符(message_type)。你可以通过识别符对消息分类 (极端的情况是将每个消息设置一个不同的识别符)。某个进程从队列中取出消息的时候，可以按照先进先出的顺序取出，也可以只取出符合某个识别符的消息(有多个这样的消息时，同样按照先进先出的顺序取出)。消息队列与PIPE的另一个不同在于它并不使用文件API。最后，一个队列不会自动消失，它会一直存在于内核中，直到某个进程删除该队列。</p>
<p>多进程协作可以帮助我们充分利用多核和网络时代带来的优势。多进程可以有效解决计算瓶颈的问题。互联网通信实际上也是一个进程间通信的问题，只不过这多个进程分布于不同的电脑上。网络连接是通过socket实现的。由于socket内容庞大，所以我们不在这里深入。一个小小的注解是，socket也可以用于计算机内部进程间的通信。</p>
<p><strong>总结</strong></p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PIPE, FIFO</span><br><span class="line">semaphore, message queue, <span class="keyword">shared</span> memory; <span class="keyword">key</span></span><br></pre></td></tr></table></figure>
<h2 id="Linux_u6587_u4EF6_u7CFB_u7EDF_u7684_u5B9E_u73B0"><a href="#Linux_u6587_u4EF6_u7CFB_u7EDF_u7684_u5B9E_u73B0" class="headerlink" title="Linux文件系统的实现"></a>Linux文件系统的实现</h2><p>Linux文件管理从用户的层面介绍了Linux管理文件的方式。Linux有一个树状结构来组织文件。树的顶端为根目录(/)，节点为目录，而末端的叶子为包含数据的文件。当我们给出一个文件的完整路径时，我们从根目录出发，经过沿途各个目录，最终到达文件。</p>
<p>我们可以对文件进行许多操作，比如打开和读写。在Linux文件管理相关命令中，我们看到许多对文件进行操作的命令。它们大都基于对文件的打开和读写操作。比如cat可以打开文件，读取数据，最后在终端显示：</p>
<pre><code>$cat test.txt
</code></pre><p>对于Linux下的程序员来说，了解文件系统的底层组织方式，是深入进行系统编程所必备的。即使是普通的Linux用户，也可以根据相关的内容，设计出更好的系统维护方案。</p>
<p><strong>存储设备分区</strong></p>
<p>文件系统的最终目的是把大量数据有组织的放入持久性(persistant)的存储设备中，比如硬盘和磁盘。这些存储设备与内存不同。它们的存储能力具有持久性，不会因为断电而消失；存储量大，但读取速度慢。</p>
<p>观察常见存储设备。最开始的区域是MBR，用于Linux开机启动(参考Linux开机启动)。剩余的空间可能分成数个分区(partition)。每个分区有一个相关的分区表(Partition table)，记录分区的相关信息。这个分区表是储存在分区之外的。分区表说明了对应分区的起始位置和分区的大小。</p>
<p><img src="/images/14590056923433.jpg" alt=""></p>
<p>我们在Windows系统常常看到C分区、D分区等。Linux系统下也可以有多个分区，但都被挂载在同一个文件系统树上。</p>
<p>数据被存入到某个分区中。一个典型的Linux分区(partition)包含有下面各个部分:</p>
<p><img src="/images/14590056997684.jpg" alt=""></p>
<p>分区的第一个部分是启动区(Boot block)，它主要是为计算机开机服务的。Linux开机启动后，会首先载入MBR，随后MBR从某个硬盘的启动区加载程序。该程序负责进一步的操作系统的加载和启动。为了方便管理，即使某个分区中没有安装操作系统，Linux也会在该分区预留启动区。</p>
<p>启动区之后的是超级区(Super block)。它存储有文件系统的相关信息，包括文件系统的类型，inode的数目，数据块的数目。</p>
<p>随后是多个inodes，它们是实现文件存储的关键。在Linux系统中，一个文件可以分成几个数据块存储，就好像是分散在各地的龙珠一样。为了顺利的收集齐龙珠，我们需要一个“雷达”的指引：该文件对应的inode。每个文件对应一个inode。这个inode中包含多个指针，指向属于该文件各个数据块。当操作系统需要读取文件时，只需要对应inode的”地图”，收集起分散的数据块，就可以收获我们的文件了。</p>
<p>最后一部分，就是真正储存数据的数据块们(data blocks)了。</p>
<p><strong>inode简介</strong></p>
<p>上面我们看到了存储设备的宏观结构。我们要深入到分区的结构，特别是文件在分区中的存储方式。</p>
<p>文件是文件系统对数据的分割单元。文件系统用目录来组织文件，赋予文件以上下分级的结构。在硬盘上实现这一分级结构的关键，是使用inode来虚拟普通文件和目录文件对象。</p>
<p>在Linux文件管理中，我们知道，一个文件除了自身的数据之外，还有一个附属信息，即文件的元数据(metadata)。这个元数据用于记录文件的许多信息，比如文件大小，拥有人，所属的组，修改日期等等。元数据并不包含在文件的数据中，而是由操作系统维护的。事实上，这个所谓的元数据就包含在inode中。我们可以用$ls -l filename来查看这些元数据。正如我们上面看到的，inode所占据的区域与数据块的区域不同。每个inode有一个唯一的整数编号(inode number)表示。</p>
<p>在保存元数据，inode是“文件”从抽象到具体的关键。正如上一节中提到的，inode储存由一些指针，这些指针指向存储设备中的一些数据块，文件的内容就储存在这些数据块中。当Linux想要打开一个文件时，只需要找到文件对应的inode，然后沿着指针，将所有的数据块收集起来，就可以在内存中组成一个文件的数据了。</p>
<p><img src="/images/14590057101211.jpg" alt=""></p>
<p>inode并不是组织文件的唯一方式。最简单的组织文件的方法，是把文件依次顺序的放入存储设备，DVD就采取了类似的方式。但如果有删除操作，删除造成的空余空间夹杂在正常文件之间，很难利用和管理。</p>
<p>复杂的方式可以使用链表，每个数据块都有一个指针，指向属于同一文件的下一个数据块。这样的好处是可以利用零散的空余空间，坏处是对文件的操作必须按照线性方式进行。如果想随机存取，那么必须遍历链表，直到目标位置。由于这一遍历不是在内存进行，所以速度很慢。</p>
<p>FAT系统是将上面链表的指针取出，放入到内存的一个数组中。这样，FAT可以根据内存的索引，迅速的找到一个文件。这样做的主要问题是，索引数组的大小与数据块的总数相同。因此，存储设备很大的话，这个索引数组会比较大。</p>
<p>inode既可以充分利用空间，在内存占据空间不与存储设备相关，解决了上面的问题。但inode也有自己的问题。每个inode能够存储的数据块指针总数是固定的。如果一个文件需要的数据块超过这一总数，inode需要额外的空间来存储多出来的指针。</p>
<p><strong>inode示例</strong></p>
<p>在Linux中，我们通过解析路径，根据沿途的目录文件来找到某个文件。目录中的条目除了所包含的文件名，还有对应的inode编号。当我们输入$cat /var/test.txt时，Linux将在根目录文件中找到var这个目录文件的inode编号，然后根据inode合成var的数据。随后，根据var中的记录，找到text.txt的inode编号，沿着inode中的指针，收集数据块，合成text.txt的数据。整个过程中，我们参考了三个inode：根目录文件，var目录文件，text.txt文件的inodes。</p>
<p>在Linux下，可以使用$stat filename，来查询某个文件对应的inode编号。</p>
<p><img src="/images/14590057224870.jpg" alt=""></p>
<p>在存储设备中实际上存储为：</p>
<p><img src="/images/14590057295211.jpg" alt=""></p>
<p>当我们读取一个文件时，实际上是在目录中找到了这个文件的inode编号，然后根据inode的指针，把数据块组合起来，放入内存供进一步的处理。当我们写入一个文件时，是分配一个空白inode给该文件，将其inode编号记入该文件所属的目录，然后选取空白的数据块，让inode的指针指像这些数据块，并放入内存中的数据。</p>
<p><strong>文件共享</strong></p>
<p>在Linux的进程中，当我们打开一个文件时，返回的是一个文件描述符。这个文件描述符是一个数组的下标，对应数组元素为一个指针。有趣的是，这个指针并没有直接指向文件的inode，而是指向了一个文件表格，再通过该表格，指向加载到内存中的目标文件的inode。如下图，一个进程打开了两个文件。</p>
<p><img src="/images/14590057435416.jpg" alt=""></p>
<p>可以看到，每个文件表格中记录了文件打开的状态(status flags)，比如只读，写入等，还记录了每个文件的当前读写位置(offset)。当有两个进程打开同一个文件时，可以有两个文件表格，每个文件表格对应的打开状态和当前位置不同，从而支持一些文件共享的操作，比如同时读取。</p>
<p>要注意的是进程fork之后的情况，子进程将只复制文件描述符的数组，而和父进程共享内核维护的文件表格和inode。此时要特别小心程序的编写。</p>
<p><strong>总结</strong></p>
<p>这里概括性的总结了Linux的文件系统。Linux以inode的方式，让数据形成文件。</p>
<p>了解Linux的文件系统，是深入了解操作系Linux原理的重要一步。</p>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/03/03/2871198.html" target="_blank" rel="external">Linux 常用命令</a></li>
<li><a href="http://www.cnblogs.com/peida/archive/2012/12/05/2803591.html" target="_blank" rel="external">每天一个linux命令目录</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇日志来自 <a href="http://www.cnblogs.com/vamei">Vamei 博客</a> 中的系列文章，把一些基本的内容做了整合，方便查阅。</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://wdxtub.com/tags/Linux/"/>
    
      <category term="Vamei" scheme="http://wdxtub.com/tags/Vamei/"/>
    
      <category term="概念" scheme="http://wdxtub.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
