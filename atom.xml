<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-04-08T21:40:27.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 27 课 总结]]></title>
    <link href="http://wdxtub.com/2016/04/08/csapp-27/"/>
    <id>http://wdxtub.com/2016/04/08/csapp-27/</id>
    <published>2016-04-08T21:38:47.000Z</published>
    <updated>2016-04-08T21:40:27.000Z</updated>
    <content type="html"><![CDATA[<p>为什么 15213 在 CMU 是当之无愧的第一神课？我们需要怎么样的教育？这门课都给了我太多启发。</p>
<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<p>为什么 15213 在 CMU 是当之无愧的第一神课？我们需要怎么样的教育？这门课都给了我太多启发。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="总结" scheme="http://wdxtub.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 26 课 Future of Computing]]></title>
    <link href="http://wdxtub.com/2016/04/08/csapp-26/"/>
    <id>http://wdxtub.com/2016/04/08/csapp-26/</id>
    <published>2016-04-08T18:40:49.000Z</published>
    <updated>2016-04-08T21:37:28.000Z</updated>
    <content type="html"><![CDATA[<p>从 1965 年看 2015 年，和从 2015 年想象 2065 年，究竟哪个会更让我们惊喜？</p>
<a id="more"></a>
<hr>
<p>提到计算机的发展，有一个词一定绕不开，就是『摩尔定律』，毕竟五十年来，基本都是符合这个定律的，如下图所示：</p>
<p><img src="/images/14601480690552.jpg" alt="Moore&#39;s Law: 50 Years"></p>
<p>摩尔定律的发展意味着实实在在的改变：</p>
<p><img src="/images/14601504905788.jpg" alt=""></p>
<p>再来看看从 1965 年到 2015 年发生的巨大变化：</p>
<p><img src="/images/14601505812629.jpg" alt=""></p>
<p>不妨猜想一下，2065 年的消费者产品是什么？虽然不知道具体的产品形态，但是有几个趋势是一定的：</p>
<ul>
<li>更编写，能效比更高</li>
<li>单位造价更便宜</li>
<li>不一定是基于晶体管的</li>
</ul>
<p>最后是几个关于未来集成系统的问题</p>
<ul>
<li>Can we build them?</li>
<li>What will be the techonology?</li>
<li>Are they commercially viable?</li>
<li>Can we keep power consumption low?</li>
<li>What will we do with them?</li>
<li>How will we program / customize them?</li>
</ul>
<hr>
<p>最后的两节课，内容比较简单。虽然看起来对考试没啥帮助，但是如果想在这个行业里混出一点名堂，一定要从长远的角度来考虑的。</p>
<p>这其实也是我特别想跟身边朋友说的，作为学生来说，看待问题的尺度可能是学期，考试结束一切也就盖棺定论了。但是走入社会之后，一切都是连续动态的，一言一行都可能会有比自己想得深远得多的影响，好好决定自己的每一天，认真做好每件事情，广结善缘，扩大影响力，这些都是比内斗内耗有意义得多的事情。</p>
<p>共勉。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从 1965 年看 2015 年，和从 2015 年想象 2065 年，究竟哪个会更让我们惊喜？</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="未来" scheme="http://wdxtub.com/tags/%E6%9C%AA%E6%9D%A5/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 25 课 Thread-Level Parallelism]]></title>
    <link href="http://wdxtub.com/2016/04/08/csapp-25/"/>
    <id>http://wdxtub.com/2016/04/08/csapp-25/</id>
    <published>2016-04-08T13:52:18.000Z</published>
    <updated>2016-04-08T21:23:46.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们从硬件讲起，然后介绍线程级并行，最后说一下一致性模型。这部分内容在我当助教的 18645 How to Write Fast Code 也有涉及。</p>
<a id="more"></a>
<hr>
<p>回想一下，我们之前是如何处理 I/O 的延迟的呢？一个办法是每个客户端都由一个线程来处理，这样就不需要互相等待。现在的多核/超线程处理器提供了另外一种可能。我们不但可以并行执行多个线程，更好的是这些都是自动进行的，当然，我们也可以通过把大任务分成小任务来加速运算。</p>
<p><img src="/images/14601449201982.jpg" alt="Typical Multicore Processor"></p>
<p>上图是典型的多核处理器架构，这里需要注意的是 L3 缓存和主内存都是共享的。而具体的执行计算的架构，基本的乱序执行处理器的架构为：</p>
<p><img src="/images/14601450728106.jpg" alt="Out-of-Order Processor Structure"></p>
<p>指令控制器会动态把程序转换成操作流，操作会被映射到 Functional Unit 上进行并行处理。这种情况下，一个核心处理一个线程。而在超线程的设计中，一个核心可以处理若干个线程，秘诀在于多出来了若干套指令控制流，如下图：</p>
<p><img src="/images/14601452084625.jpg" alt="Hyperthreading Implementation"></p>
<p>如果我们想要了解机器的相关信息，可以访问 <code>/proc/cpuinfo</code></p>
<p><img src="/images/14601453998378.jpg" alt=""></p>
<p>随后老师提及了两个例子，一个是并行求和，一个是并行快排，这里不赘述，如果感兴趣的话，可以自己思考一下。</p>
<p>另外一些关键字是</p>
<ul>
<li>Amdahl’s Law</li>
<li>Parallel Program Performance: Speedup &amp; Efficiency</li>
</ul>
<p>总结来看，并行编程需要注意的是：</p>
<ul>
<li>要有并行策略，可以把一个大任务分成若干个独立的子任务，或者用分而治之的方式来解决</li>
<li>内循环最好不要有任何同步机制</li>
<li>注意 Amdahl’s Law</li>
</ul>
<p>最后说一下内存一致性的问题，下面的程序会输出什么呢？</p>
<p><img src="/images/14601474171500.jpg" alt="Memory Consistency"></p>
<p>具体输出的内容，取决于内存的一致性模型</p>
<p><img src="/images/14601475352960.jpg" alt="Sequential Consistency Example"></p>
<p>如果使用 Write-back 的话，不同的缓存间不沟通，那么结果如下：</p>
<p><img src="/images/14601476490089.jpg" alt=""></p>
<p>而更多的会用 tag 来标记不同的状态，由内存和缓存完成具体的协调工作：</p>
<p><img src="/images/14601477220538.jpg" alt=""></p>
<p><img src="/images/14601477302068.jpg" alt="Before"></p>
<p><img src="/images/14601477449024.jpg" alt="After"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们从硬件讲起，然后介绍线程级并行，最后说一下一致性模型。这部分内容在我当助教的 18645 How to Write Fast Code 也有涉及。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="并行" scheme="http://wdxtub.com/tags/%E5%B9%B6%E8%A1%8C/"/>
    
      <category term="线程" scheme="http://wdxtub.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 习题课 7 Proxylab]]></title>
    <link href="http://wdxtub.com/2016/04/07/csapp-lab7/"/>
    <id>http://wdxtub.com/2016/04/07/csapp-lab7/</id>
    <published>2016-04-08T01:52:23.000Z</published>
    <updated>2016-04-08T13:47:33.000Z</updated>
    <content type="html"><![CDATA[<p>这次，我们来自己实现一个多线程带缓存的代理服务器！</p>
<a id="more"></a>
<hr>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>这次的作业主要分三个部分：</p>
<ol>
<li>Sequential Proxy: 接收客户端发送的 HTTP 请求，解析之后向目标服务器转发，获得响应之后再转发回客户端</li>
<li>Concurrent Proxy: 在第一步的基础上，支持多线程</li>
<li>Cache Web Objects: 使用 LRU 缓存单独的对象，而不是整个页面</li>
</ol>
<p>老套路</p>
<ul>
<li>上传文件 <code>scp proxylab-handout.tar dawang@shark.ics.cs.cmu.edu:~/513</code></li>
<li>登录 <code>ssh -X dawang@shark.ics.cs.cmu.edu</code></li>
<li>解压 <code>tar xvf proxylab-handhout.tar</code></li>
</ul>
<p>因为我比较习惯在本地写代码，所以把文件复制回来：</p>
<ul>
<li>服务器至本地 <code>scp dawang@shark.ics.cs.cmu.edu:~/513/proxylab-handout/proxy.c ./</code></li>
<li>本地至服务器 <code>scp ./proxy.c dawang@shark.ics.cs.cmu.edu:~/513/proxylab-handout/</code></li>
</ul>
<blockquote>
<p>评分标准</p>
</blockquote>
<p>使用 <code>./driver.sh</code> 来进行测试</p>
<ul>
<li>[40] 基本正确性（自动评分）</li>
<li>[15] 并行（自动评分）</li>
<li>[15] 缓存（自动评分）</li>
<li>[20] 实际页面测试<ul>
<li><a href="http://www.cs.cmu.edu/~213" target="_blank" rel="external">http://www.cs.cmu.edu/~213</a></li>
<li><a href="http://csapp.cs.cmu.edu" target="_blank" rel="external">http://csapp.cs.cmu.edu</a></li>
<li><a href="http://www.cs.cmu.edu" target="_blank" rel="external">http://www.cs.cmu.edu</a></li>
<li><a href="http://chalkdinosaur.bandcamp.com" target="_blank" rel="external">http://chalkdinosaur.bandcamp.com</a></li>
</ul>
</li>
<li>[10] 代码风格</li>
</ul>
<p>在工作文件夹中使用 <code>make handin</code> 来生成提交文件，然后交到 autolab 即可。</p>
<h2 id="Sequential_Web_Proxy"><a href="#Sequential_Web_Proxy" class="headerlink" title="Sequential Web Proxy"></a>Sequential Web Proxy</h2><p>第一步是实现一个简单的代理服务器，只处理 <code>HTTP/1.0 GET</code> 请求。具体步骤为</p>
<ul>
<li>端口号在命令行指令中指定<ul>
<li>申请自己的端口 <code>$ ./port-for-user.pl dawang</code>，这里申请的总是偶数，所以如果需要一个额外的端口，直接在端口号 +1 即可</li>
<li>不要随便指定端口，不然很可能干扰到别人</li>
<li><code>$ ./proxy 12345</code></li>
</ul>
</li>
<li>监听从该端口进入的所有请求</li>
<li>解析请求，并转发合法的 HTTP 请求<ul>
<li>假设请求为 <code>GET http://www.cmu.edu/hub/index.html HTTP/1.1</code></li>
<li>则主机名 <code>www.cmu.edu</code></li>
<li>请求的页面 <code>/hub/index.html</code></li>
<li>HTTP 请求每行以 <code>\r\n</code> 结束，以一个空行 <code>\r\n</code> 结尾</li>
<li>需要判断地址里有没有带端口</li>
</ul>
</li>
<li>把从服务器获取到的响应返回给客户端</li>
</ul>
<p>请求的 header 也很重要，一定要有的内容是：</p>
<ul>
<li><code>Host</code>: 如 <code>Host: www.cmu.edu</code></li>
<li><code>User-Agent</code>: 如 <code>User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3</code></li>
<li><code>Connection</code>: 必须发送 <code>Connection: close</code></li>
<li><code>Proxy-Connection</code>: 必须发送 <code>Proxy-Connection: close</code></li>
</ul>
<h2 id="Multiple_Concurrent_Requests"><a href="#Multiple_Concurrent_Requests" class="headerlink" title="Multiple Concurrent Requests"></a>Multiple Concurrent Requests</h2><p>使用 POSIX 线程，最好在线程一开始执行 <code>pthread_detach(pthread_self());</code> 这样就不用自己负责清理线程了。</p>
<p>注意竞争条件，尽量减少共享资源，访问共享资源的时候需要同步。</p>
<p><code>open_clientfd</code> 和 <code>open_listenfd</code> 函数是线程安全的</p>
<h2 id="Caching_Web_Objects"><a href="#Caching_Web_Objects" class="headerlink" title="Caching Web Objects"></a>Caching Web Objects</h2><p>具体缓存的机制是 LRU，一些具体的参数是：</p>
<ul>
<li>缓存大小限制 <code>MAX_CACHE_SIZE = 1 MiB</code>，注意只缓存 web 对象，其他诸如 metadata 应该忽略</li>
<li>单个文件大小限制 <code>MAX_OBJECT_SIZE = 100 KiB</code></li>
<li>如果有 T 个连接，那么最大的空间为 <code>MAX_CACHE_SIZE + T * MAX_OBJECT_SIZE</code></li>
</ul>
<p>同步问题可以参考『读者-写者问题』</p>
<h2 id="u8C03_u8BD5_u5DE5_u5177"><a href="#u8C03_u8BD5_u5DE5_u5177" class="headerlink" title="调试工具"></a>调试工具</h2><ul>
<li>Telnet: 不安全的 ssh，需要手动构造 HTTP 请求，如果想要测试非法的 header，这个功能就很有用<ul>
<li><code>man telnet</code></li>
<li><code>telnet www.wdxtub.com</code></li>
<li><code>GET http://www.wdxtub.com HTTP/1.0</code> </li>
</ul>
</li>
<li>cURL: 会自动构建 HTTP 请求<ul>
<li><code>curl http://www.wdxtub.com</code></li>
<li>代理模式 <code>curl --proxy lemonshar.ics.cs.cmu.edu:3092 http://www.wdxtub.com</code> </li>
</ul>
</li>
<li><code>netcat</code>: 多用途网络工具，用法与 <code>telnet</code> 类似<ul>
<li><code>nc catshark.ics.cs.cmu.edu 12345</code></li>
<li><code>GET http://www.cmu.edu/hub/index.html HTTP/1.0</code></li>
</ul>
</li>
</ul>
<h2 id="u6CE8_u610F_u4E8B_u9879"><a href="#u6CE8_u610F_u4E8B_u9879" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>大端小端</li>
<li>能够处理各种 URL（合法或非法）</li>
<li>不是所有的内容都是 ASCII 码，注意选择对应的函数来处理二进制文件（图像和视频）</li>
<li>所有的请求都用 <code>HTTP/1.0</code> 来转发</li>
<li>需要处理 <code>SIGPIPE</code> 信号，默认的操作是关闭进程，这里应该屏蔽这个信号</li>
<li>使用 Robust I/O package 的 <code>read</code>, <code>write</code>, <code>fread</code>, <code>fwrite</code> 来增加健壮性</li>
<li>如果调用 <code>read</code> 来获取已经被关闭的 socket，会返回 -1，并给出 <code>ECONNRESET</code> 错误，不应该因为这个错误而导致进程终结</li>
<li>如果调用 <code>write</code> 来获取已经被关闭的 socket，会返回 -1，并给出 <code>EPIPE</code> 错误，不应该因为这个错误而导致进程终结</li>
<li>代码注意模块化</li>
<li>因为可以写单独的文件，需要对应更新 Makefile</li>
</ul>
<p><img src="/images/14600850252282.jpg" alt="最终效果"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这次，我们来自己实现一个多线程带缓存的代理服务器！</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Proxy" scheme="http://wdxtub.com/tags/Proxy/"/>
    
      <category term="习题课" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98%E8%AF%BE/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 24 课 Synchronization - Advanced]]></title>
    <link href="http://wdxtub.com/2016/04/07/csapp-24/"/>
    <id>http://wdxtub.com/2016/04/07/csapp-24/</id>
    <published>2016-04-07T15:30:39.000Z</published>
    <updated>2016-04-08T01:05:30.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们通过『生产者-消费者问题』以及『读者-写者问题』来更深入理解同步机制。</p>
<a id="more"></a>
<hr>
<p>Semaphores 实际上可以认为是线程之间最简单的通知机制，用来控制共享资源的访问。这之中有两个非常经典的问题：</p>
<ul>
<li>The Producer-Consumer Problem</li>
<li>The Readers-Writers Problem</li>
</ul>
<h2 id="u751F_u4EA7_u8005-_u6D88_u8D39_u8005_u95EE_u9898"><a href="#u751F_u4EA7_u8005-_u6D88_u8D39_u8005_u95EE_u9898" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p><img src="/images/14600704484721.jpg" alt="Producer-Consumer Problem"></p>
<p>具体的同步模型为：</p>
<ul>
<li>生产者等待空的 slot，把 item 存储到 buffer，并通知消费者</li>
<li>消费整等待 item，从 buffer 中移除 item，并通知生产者</li>
</ul>
<p>主要用于</p>
<ul>
<li>多媒体处理<ul>
<li>生产者生成 MPEG 视频帧，消费者进行渲染</li>
</ul>
</li>
<li>事件驱动的图形用户界面<ul>
<li>生产者检测到鼠标点击、移动和键盘输入，并把对应的事件插入到 buffer 中</li>
<li>消费者从 buffer 中获取事件，并绘制到到屏幕上</li>
</ul>
</li>
</ul>
<p>接下来我们实现一个有 n 个元素 buffer，为此，我们需要一个 mutex 和两个用来计数的 semaphore：</p>
<ul>
<li><code>mutex</code>: 用来保证对 buffer 的互斥访问</li>
<li><code>slots</code>: 统计 buffer 中可用的 slot 数目</li>
<li><code>items</code>: 统计 buffer 中可用的 item 数目</li>
</ul>
<p>我们直接来看代码，就比较清晰了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 sbuf.h</span></span><br><span class="line"><span class="comment">// 包括几个基本操作</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> *buf;    <span class="comment">// Buffer array</span></span><br><span class="line">    <span class="keyword">int</span> n;       <span class="comment">// Maximum number of slots</span></span><br><span class="line">    <span class="keyword">int</span> front;   <span class="comment">// buf[(front+1)%n] is first item</span></span><br><span class="line">    <span class="keyword">int</span> rear;    <span class="comment">// buf[rear%n] is the last item</span></span><br><span class="line">    <span class="keyword">sem_t</span> mutex; <span class="comment">// Protects accesses to buf</span></span><br><span class="line">    <span class="keyword">sem_t</span> slots; <span class="comment">// Counts available slots</span></span><br><span class="line">    <span class="keyword">sem_t</span> items; <span class="comment">// Counts available items</span></span><br><span class="line">&#125; <span class="keyword">sbuf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_init</span><span class="params">(sbuf_t *sp, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_deinit</span><span class="params">(sbuf_t *sp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(sbuf_t *sp, <span class="keyword">int</span> item)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbuf_remove</span><span class="params">(sbuf_t *sp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>然后是具体的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sbuf.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an empty, bounded, shared FIFO buffer with n slots</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_init</span><span class="params">(sbuf_t *sp, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    sp-&gt;buf = Calloc(n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    sp-&gt;n = n;                  <span class="comment">// Buffer holds max of n items</span></span><br><span class="line">    sp-&gt;front = sp-&gt;rear = <span class="number">0</span>;   <span class="comment">// Empty buffer iff front == rear</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// Binary semaphore for locking</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;slots, <span class="number">0</span>, n); <span class="comment">// Initially, buf has n empty slots</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;items, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// Initially, buf has 0 items</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clean up buffer sp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_deinit</span><span class="params">(sbuf_t *sp)</span></span>&#123;</span><br><span class="line">    Free(sp-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert item onto the rear of shared buffer sp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(sbuf_t *sp, <span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">    P(&amp;sp-&gt;slots);                        <span class="comment">// Wait for available slot</span></span><br><span class="line">    P(&amp;sp-&gt;mutext);                       <span class="comment">// Lock the buffer</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear)%(sp-&gt;n)] = item; <span class="comment">// Insert the item</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);                        <span class="comment">// Unlock the buffer</span></span><br><span class="line">    V(&amp;sp-&gt;items);                        <span class="comment">// Announce available item</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove and return the first tiem from the buffer sp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbuf_remove</span><span class="params">(sbuf_f *sp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    P(&amp;sp-&gt;items);                         <span class="comment">// Wait for available item</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);                         <span class="comment">// Lock the buffer</span></span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front)%(sp-&gt;n)]; <span class="comment">// Remove the item</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);                         <span class="comment">// Unlock the buffer</span></span><br><span class="line">    V(&amp;sp-&gt;slots);                         <span class="comment">// Announce available slot</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u8BFB_u8005-_u5199_u8005_u95EE_u9898"><a href="#u8BFB_u8005-_u5199_u8005_u95EE_u9898" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>是互斥问题的通用描述，具体为：</p>
<ul>
<li>读者线程只读取对象</li>
<li>写者线程修改对象</li>
<li>写者对于对象的访问是互斥的</li>
<li>多个读者可以同时读取对象</li>
</ul>
<p>常见的应用场景是：</p>
<ul>
<li>在线订票系统</li>
<li>多线程缓存 web 代理</li>
</ul>
<p>根据不同的读写策略，又两类读者写者问题，需要注意的是，这两种情况都可能出现 starvation。</p>
<blockquote>
<p>第一类读者写者问题（读者优先）</p>
</blockquote>
<ul>
<li>如果写者没有获取到使用对象的权限，不应该让读者等待</li>
<li>在等待的写者之后到来的读者应该在写者之前处理</li>
<li>也就是说，只有没有读者的情况下，写者才能工作</li>
</ul>
<blockquote>
<p>第二类读者写者问题（写者优先）</p>
</blockquote>
<ul>
<li>一旦写者可以处理的时候，就不应该进行等待</li>
<li>在等待的写者之后到来的读者应该在写者之后处理</li>
</ul>
<p>把前面这些拼到一起，就有了完整的 Server </p>
<p><img src="/images/14600747953883.jpg" alt="Prethreaded Concurrent Server"></p>
<p>具体的代码为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sbuf_t</span> sbuf; <span class="comment">// Shared buffer of connected descriptors</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> byte_cnt;  <span class="comment">// Byte counter</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">sem_t</span> mutex;   <span class="comment">// and the mutex that protects it</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo_cnt</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_once_t</span> once = PTHREAD_ONCE_INIT;</span><br><span class="line">    </span><br><span class="line">    Pthread_once(&amp;once, init_echo_cnt);</span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        byte_cnt += n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread %d received %d (%d total) bytes on fd %d\n"</span>,</span><br><span class="line">                    (<span class="keyword">int</span>) pthread_self(), n, byte_cnt, connfd);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_echo_cnt</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    Sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    byte_cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>&#123;</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> connfd = sbuf_remove(&amp;sbuf); <span class="comment">// Remove connfd from buf</span></span><br><span class="line">        echo_cnt(connfd);                <span class="comment">// Service client</span></span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, listenfd, connfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_storage clientaddr;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    </span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    sbuf_init(&amp;sbuf, SBUFSIZE);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHREADS; i++) <span class="comment">// Create worker threads</span></span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        sbuf_insert(&amp;sbuf, connfd); <span class="comment">// Insert connfd in buffer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7EBF_u7A0B_u5B89_u5168"><a href="#u7EBF_u7A0B_u5B89_u5168" class="headerlink" title="线程安全"></a>线程安全</h2><p>在线程中调用的函数必须是线程安全的，定义为：</p>
<blockquote>
<p>A function is thread-safe iff it will always produce correct results when called repeatedly from multiple concurrent threads</p>
</blockquote>
<p>主要有 4 类线程不安全的函数</p>
<ol>
<li>Functions that do not protect shared variables<ul>
<li>解决办法：使用 P 和 V semaphore 操作</li>
<li>问题：同步操作会影响性能</li>
</ul>
</li>
<li>Functions that keep state across multiple invocations<ul>
<li>Fix: Pass state as part of argument </li>
</ul>
</li>
<li>Functions that return a pointer to a static variable<ul>
<li>Fix 1: Rewrite function so caller passes address of variable to store result</li>
<li>Fix 2: Lock-and-copy</li>
</ul>
</li>
<li>Functions that call thread-unsage functions<ul>
<li>解决办法：只调用线程安全的函数</li>
</ul>
</li>
</ol>
<p>另一个重要的概念是 Reentrant Function，定义为：</p>
<blockquote>
<p>A function is <strong>reentrant</strong> iff it accesses no shared variables when called by multiple threads</p>
</blockquote>
<p><img src="/images/14600771838118.jpg" alt=""></p>
<p>Reentrant Functions 是线程安全函数非常重要的子集，不需要同步操作，对于第二类的函数来说（上面提到的），唯一的办法就是把他们修改成 reentrant 的。</p>
<p>标准 C 库中的函数都是线程安全的（如 <code>malloc</code>, <code>free</code>, <code>printf</code>, <code>scanf</code>），大多数 Unix 的系统调用也都是线程安全的，除了下面这些例外：</p>
<p><img src="/images/14600772808229.jpg" alt=""></p>
<p>最后要提的两点是『竞争条件』和『死锁』，对于前者来说，要避免状态的共享，对于后者来说，要保证共享资源按照顺序进行请求。举个例子：</p>
<p><img src="/images/14600774132333.jpg" alt="Deadlocking With Semaphores"></p>
<p> 留意两个函数中 P 操作的顺序，用 Progress Graph 来表示就是：</p>
<p><img src="/images/14600774554184.jpg" alt="Deadlock Visualized in Progress Graph"></p>
<p>但是如果我们调整顺序：</p>
<p><img src="/images/14600774851875.jpg" alt="Acquire shared resources in same order"></p>
<p>情况就会变成这样</p>
<p><img src="/images/14600775118044.jpg" alt="Avoided Deadlock in Progress Graph"></p>
<p>也就解决了死锁的问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们通过『生产者-消费者问题』以及『读者-写者问题』来更深入理解同步机制。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="同步" scheme="http://wdxtub.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 23 课 Synchronization - Basics]]></title>
    <link href="http://wdxtub.com/2016/04/07/csapp-23/"/>
    <id>http://wdxtub.com/2016/04/07/csapp-23/</id>
    <published>2016-04-07T15:30:32.000Z</published>
    <updated>2016-04-07T20:19:11.000Z</updated>
    <content type="html"><![CDATA[<p>并行编程中最重要的问题就是同步，这节课我们来了解同步相关的基础知识</p>
<a id="more"></a>
<hr>
<h2 id="u5171_u4EAB_u53D8_u91CF"><a href="#u5171_u4EAB_u53D8_u91CF" class="headerlink" title="共享变量"></a>共享变量</h2><p>在介绍同步之前，我们需要弄清楚一个定义，什么是 Shared variable（共享变量）？</p>
<blockquote>
<p>A variable <code>x</code> is <em>shared</em> if and only if multiple threads reference some instance of <code>x</code></p>
</blockquote>
<p>另外一个需要注意的是线程的内存模型，因为概念上的模型和实际的模型有一些差异，非常容易导致错误。</p>
<p>在概念上的模型中：</p>
<ul>
<li>多个线程在一个单独进程的上下文中运行</li>
<li>每个线程有单独的线程上下文（线程 ID，栈，栈指针，PC，条件码，GP 寄存器）</li>
<li>所有的线程共享剩下的进程上下文<ul>
<li>Code, data, heap, and shared library segments of the process virtual address space</li>
<li>Open files and installed handlers</li>
</ul>
</li>
</ul>
<p>在实际的模型中，寄存器的值虽然是隔离且被保护的，但是在栈中的值并不是这样的（其他线程也可以访问）。</p>
<p>我们来看一个简单的例子：</p>
<p><img src="/images/14600480676890.jpg" alt="Example Program to Illustrate Sharing"></p>
<p>这里有几个不同类型的变量，我们一一来看一下：</p>
<ul>
<li>全局变量：在函数外声明的变量<ul>
<li>虚拟内存中有全局唯一的一份实例</li>
</ul>
</li>
<li>局部变量：在函数内声明，且没有用 static 关键字<ul>
<li>每个线程的栈中都保存着对应线程的局部变量</li>
</ul>
</li>
<li>局部静态变量：在函数内用 static 关键字声明的变量<ul>
<li>虚拟内存中有全局唯一的一份实例</li>
</ul>
</li>
</ul>
<p>具体分析下上面例子中的变量，有：</p>
<p><img src="/images/14600483444019.jpg" alt="Mapping Variable Instances to Memory"></p>
<p>具体来分析下，一个变量只有在被多个线程引用的时候才算是共享，在这个例子中，共享变量有 <code>ptr</code>, <code>cnt</code> 和 <code>msgs</code>；非共享变量有 <code>i</code> 和 <code>myid</code>。</p>
<p><img src="/images/14600486014966.jpg" alt="Shared Vairable Analysis"></p>
<p>共享变量看起来不难，但是会导致一个并行编程中最重要的问题——同步问题。</p>
<h2 id="Critical_Section"><a href="#Critical_Section" class="headerlink" title="Critical Section"></a>Critical Section</h2><p>我们直接来看例子</p>
<p><img src="/images/14600488439280.jpg" alt="Improper Synchronization"></p>
<p>为什么运行的时候，会出现不一样的结果呢？我们把操作 <code>cnt</code> 的部分抽出来单独看一看：</p>
<p><img src="/images/14600574108297.jpg" alt="Assembly Code for Counter Loop"></p>
<p>这里有一点需要注意，<code>cnt</code> 使用了 <code>volatile</code> 关键字声明，意思是不要在寄存器中保存值，无论是读取还是写入，都要对内存操作（还记得 write-through 吗？）。这里把具体的步骤分成 5 步：HLUST，尤其要注意的 LUS 这三个操作，后面会继续说。</p>
<p>我们先来看看没有问题的情况：</p>
<p><img src="/images/14600579848706.jpg" alt=""></p>
<p>这里我们可以看到，有颜色的指令连在一起，所以没有问题。但是一旦交叉，就有问题了，如：</p>
<p><img src="/images/14600580383523.jpg" alt=""></p>
<h2 id="Progress_Graph__26amp_3B_Trajectory"><a href="#Progress_Graph__26amp_3B_Trajectory" class="headerlink" title="Progress Graph &amp; Trajectory"></a>Progress Graph &amp; Trajectory</h2><p>为了描述上面这种情况，我们可以用 Progress Graph 来辅助，比如：</p>
<p><img src="/images/14600581230106.jpg" alt="Progress Graph"></p>
<p>不同的轴代表在某线程中的指令执行顺序，每个点对应一个可能的执行状态，比如说图中的红点，表示线程 1 执行完了 L1，而线程 2 执行完了 S2。</p>
<p>Trajectory 的概念也很好理解，即可行的执行顺序，如下图：</p>
<p><img src="/images/14600582550787.jpg" alt="Trajectory"></p>
<p>我们把 critical section 的边界画出来，就可以判断不同的 trajectory 是否是安全的了：</p>
<p><img src="/images/14600583380649.jpg" alt=""></p>
<p>怎么样保证我们的执行不会走到不安全的区域里呢？有几种方法，这里我们只介绍 Semaphores。下面是比较常用的：</p>
<ul>
<li>Semaphores - Edsger Dijkstra</li>
<li>Mutex &amp; condition variables - Pthreads</li>
<li>Monitors - Java</li>
</ul>
<h2 id="Semaphores"><a href="#Semaphores" class="headerlink" title="Semaphores"></a>Semaphores</h2><p>先看定义</p>
<blockquote>
<p>Semaphore: non-negative global integer synchronization vairable. Manipulated by P and V operations.</p>
</blockquote>
<p>具体的操作为：</p>
<p><img src="/images/14600591923220.jpg" alt=""></p>
<p>根据这样的设计，我们可以知道作为 Semaphore 变量其值一定是非负的。另外样例代码中已经封装了 Pthreads 的函数，如下：</p>
<p><img src="/images/14600599945369.jpg" alt="C Semaphore Operations"></p>
<p>用法也很简单，在进入 critical section 之前，用 P 操作锁住，操作完成之后，用 V 才做释放。一些术语为：</p>
<p><img src="/images/14600600984591.jpg" alt="Terminology"></p>
<p>就可以用 Semaphore 来保证前面的程序不会算错数了，但是因为要同步的缘故，速度会慢</p>
<p><img src="/images/14600602184868.jpg" alt="Proper Synchronization"></p>
<p>具体的机制就是给不安全的区域上了个『锁』：</p>
<p><img src="/images/14600602784245.jpg" alt="Why Mutexes Work"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>总结一下，在使用线程时，程序员脑中需要又一个清晰的分享变量的概念，共享变量需要互斥访问，而 Semaphores 是一个基础的机制。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>并行编程中最重要的问题就是同步，这节课我们来了解同步相关的基础知识</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="同步" scheme="http://wdxtub.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 22 课 Concurrent Programming]]></title>
    <link href="http://wdxtub.com/2016/04/06/csapp-22/"/>
    <id>http://wdxtub.com/2016/04/06/csapp-22/</id>
    <published>2016-04-07T02:16:36.000Z</published>
    <updated>2016-04-07T13:12:00.000Z</updated>
    <content type="html"><![CDATA[<p>如果想要充分利用硬件资源，就要尽可能让计算机同时处理多项事务，具体是怎么实现的？又哪些基本的策略？这节课会一一解答。</p>
<a id="more"></a>
<hr>
<p>首先一定要清楚地意识到：『并行编程不简单』！最主要的原因恐怕就是我们自己的大脑，人脑实际上是一个非常精妙的系统，所采取的并行策略是一明一暗两条线，但是对于明线来说，是线性的，于是就和计算机中并行的概念冲突了。另外时间这个概念也是线性的，这就导致了想要处理好并行程序可能出现的各种问题几乎是不可能的（或者常常要出错）。</p>
<p>常见的错误有仨：竞争条件、死锁和活锁，具体如下：</p>
<p><img src="/images/14599962597558.jpg" alt="Classical problem classes"></p>
<h2 id="u670D_u52A1_u5668_u7684_u4F8B_u5B50"><a href="#u670D_u52A1_u5668_u7684_u4F8B_u5B50" class="headerlink" title="服务器的例子"></a>服务器的例子</h2><p>我们前面实现的服务器，一次只能处理一个请求，只有当前的请求处理完了，才能继续处理下一个。</p>
<p><img src="/images/14599976220466.jpg" alt=""></p>
<p>这里具体讲解一下：Client 1 向 Server 发送连接请求(connect)，Server 接受(accept)之后开始等待 Client 1 发送请求（也就是开始 read），这之后 Client 1 发送具体的内容(write)后转为等待响应(call read)，Server 的 read 接收到了内容之后，发送响应(write) 后仅需进入等待(read)，而 Client 1 接收到了响应(ret read)，最后根据用户指令退出(close)。</p>
<p>而只有当 Client 1 断开之后，Server 才会处理 Client 2 的请求，从图中也可以看到这一点。具体是在哪里等待呢？因为 TCP 会缓存，所以实际上 Client 2 在 <code>ret read</code> 之前进行等待，如：</p>
<p><img src="/images/14599992829071.jpg" alt="Where Does Second Client Block"></p>
<p>为了解决这个问题，我们可以使用并行的策略，同时处理不同客户端发来的请求。</p>
<h2 id="u5E76_u884C_u65B9_u6CD5"><a href="#u5E76_u884C_u65B9_u6CD5" class="headerlink" title="并行方法"></a>并行方法</h2><p>总体来说，根据系统机制的层级和实现方式，有下面三大类方法：</p>
<ol>
<li>基于进程<ul>
<li>内核自动管理多个逻辑流</li>
<li>每个进程有其私有的地址空间（也就是说进程切换的时候需要保存和载入数据）</li>
</ul>
</li>
<li>基于事件<ul>
<li>由程序员手动控制多个逻辑流</li>
<li>所有的逻辑流共享同一个地址空间</li>
<li>这个技术称为 I/O multiplexing</li>
</ul>
</li>
<li>基于线程<ul>
<li>内核自动管理多个逻辑流</li>
<li>每个线程共享地址空间</li>
<li>属于基于进程和基于事件的混合体</li>
</ul>
</li>
</ol>
<h3 id="u57FA_u4E8E_u8FDB_u7A0B"><a href="#u57FA_u4E8E_u8FDB_u7A0B" class="headerlink" title="基于进程"></a>基于进程</h3><p>为每个客户端分离出一个单独的进程，是建立了连接之后才开始并行，连接的建立还是串行的。</p>
<p><img src="/images/14600273587521.jpg" alt="Spawn separate process for each client"></p>
<p>具体的代码为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(-<span class="number">1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// Reap all zombie children</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_storage clientaddr;</span><br><span class="line">    </span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            Close(listenfd); <span class="comment">// Child closes its listening socket</span></span><br><span class="line">            echo(connfd); <span class="comment">// Child services client</span></span><br><span class="line">            Close(connfd); <span class="comment">// Child closes connection with client</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// Child exits</span></span><br><span class="line">        &#125;</span><br><span class="line">        Close(connfd); <span class="comment">// Parent closes connected socket (important!)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键步骤(accept)的描述为</p>
<p><img src="/images/14600278440053.jpg" alt="Concurrent Server: `accept` Illustrated"></p>
<p>执行模型为</p>
<p><img src="/images/14600278862489.jpg" alt="Process-based Server Execution Model"></p>
<ul>
<li>每个客户端由独立子进程处理<ul>
<li>必须回收僵尸进程，来避免严重的内存泄露</li>
</ul>
</li>
<li>不同进程之间不共享数据</li>
<li>父进程和子进程都有 <code>listenfd</code> 和 <code>connfd</code>，所以在父进程中需要关闭 <code>connfd</code>，在子进程中需要关闭 <code>listenfd</code><ul>
<li>内核会保存每个 socket 的引用计数，在 fork 之后 <code>refcnt(connfd) = 2</code>，所以在父进程需要关闭 connfd，这样在子进程结束后引用计数才会为零</li>
</ul>
</li>
</ul>
<blockquote>
<p>优劣</p>
</blockquote>
<p><img src="/images/14600282200028.jpg" alt="Pros and Cons of Process-based Servers"></p>
<h3 id="u57FA_u4E8E_u4E8B_u4EF6"><a href="#u57FA_u4E8E_u4E8B_u4EF6" class="headerlink" title="基于事件"></a>基于事件</h3><p>服务器会维护一个 connection 数组，包含若干 <code>connfd</code>，具体的过程为：</p>
<p><img src="/images/14600283355967.jpg" alt=""></p>
<p>这里一个很重要的技术是 I/O Multiplexing，感兴趣的同学可以查阅书中对应章节（具体内容会在习题课中介绍）。</p>
<blockquote>
<p>优劣</p>
</blockquote>
<p><img src="/images/14600283984253.jpg" alt="Pros and Cons of Event-based Servers"></p>
<h3 id="u57FA_u4E8E_u7EBF_u7A0B"><a href="#u57FA_u4E8E_u7EBF_u7A0B" class="headerlink" title="基于线程"></a>基于线程</h3><p>和基于进程的方法非常相似，唯一的区别是这里用线程。进程其实是比较『重』的，一个进程包括：</p>
<p><img src="/images/14600286544772.jpg" alt="Traditional View of a Process"></p>
<p>当然，我们也可以从线程的角度来描述进程：</p>
<p><img src="/images/14600286291425.jpg" alt="Alternate View of a Process"></p>
<p>这两个角度的区别在于，通过线程视角观察，把单独的可执行部分抽离出来了，于是当一个进程有多个线程的时候，看起来像这样：</p>
<p><img src="/images/14600287485774.jpg" alt="A Process With Multiple Threads"></p>
<p>每个线程有自己的线程 id，有自己的逻辑控制流，也有自己的用来保存局部变量的栈（其他线程可以修改）但是会共享所有的代码、数据以及内核上下文。</p>
<p>和进程不同的是，线程没有一个明确的树状结构（使用 <code>fork</code> 是有明确父进程子进程区分的），看起来就像下面这样：</p>
<p><img src="/images/14600293169627.jpg" alt="Logical View of Threads"></p>
<p>和进程中『并行』的概念一样，如果两个线程的控制流在时间上有『重叠』（或者说有交叉），那么就是并行的，例如：</p>
<p><img src="/images/14600295257230.jpg" alt="Concurrent Threads"></p>
<p>单核与多核处理器也有一点点不同：</p>
<p><img src="/images/14600297006546.jpg" alt="Concurrent Thread Execution"></p>
<p>进程和线程的差别已经被说了太多次，这里简单提一下。相同点在于，它们都有自己的逻辑控制流，可以并行，都需要进行上下文切换。不同点在于，线程共享代码和数据（进程通常不会），线程开销比较小（创建和回收）</p>
<h2 id="Posix_Threads__28Pthreads_29_Interface"><a href="#Posix_Threads__28Pthreads_29_Interface" class="headerlink" title="Posix Threads (Pthreads) Interface"></a>Posix Threads (Pthreads) Interface</h2><p>Pthreads 是一个线程库，基本上只要是 C 程序能跑的平台，都会支持这个标准，具体如下；</p>
<p><img src="/images/14600332547386.jpg" alt=""></p>
<p>一个例子</p>
<p><img src="/images/14600332776267.jpg" alt="The Pthreads &quot;hello, world&quot; Program"></p>
<p>这个程序的流程描述为</p>
<p><img src="/images/14600338560676.jpg" alt="Execution of Thread &quot;hello, world&quot;"></p>
<p>我们用线程的方式重写一次之前的 Echo Server</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread routine</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connf = *((<span class="keyword">int</span> *)vargp);</span><br><span class="line">    <span class="comment">// detach 之后不用显式 join，会在执行完毕后自动回收</span></span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    Free(vargp);</span><br><span class="line">    echo(connfd);</span><br><span class="line">    <span class="comment">// 一定要记得关闭！</span></span><br><span class="line">    Close(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, *connfdp;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_storage clientaddr;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    </span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        <span class="comment">// 这里使用新分配的 connected descriptor 来避免竞争条件</span></span><br><span class="line">        connfdp = Malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        *connfdp = Accept(listenfd, (SA *) &amp; clientaddr, &amp;clientlen);</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, connfdp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的执行模型为：</p>
<p><img src="/images/14600343334886.jpg" alt="Thread-based Server Execution Model"></p>
<p>在这个模型中，每个客户端由单独的线程进行处理，这些线程除了线程 id 之外，共享所有的进程状态（但是每个线程有自己的局部变量栈）。需要注意的有：</p>
<p><img src="/images/14600346185454.jpg" alt="Issues With Thread-Based Servers"></p>
<p>说了这么多，其实就是同步问题（后面两节课会专门介绍）</p>
<blockquote>
<p>优劣</p>
</blockquote>
<p><img src="/images/14600346688214.jpg" alt=""></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这里我们了解了三大类方法的特点，具体的会在习题课结合例子说明，这里是一个简单的总结</p>
<p><img src="/images/14600347193577.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果想要充分利用硬件资源，就要尽可能让计算机同时处理多项事务，具体是怎么实现的？又哪些基本的策略？这节课会一一解答。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="并行" scheme="http://wdxtub.com/tags/%E5%B9%B6%E8%A1%8C/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 21 课 Network Programming II]]></title>
    <link href="http://wdxtub.com/2016/04/06/csapp-21/"/>
    <id>http://wdxtub.com/2016/04/06/csapp-21/</id>
    <published>2016-04-06T11:34:02.000Z</published>
    <updated>2016-04-07T00:44:41.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们来学习如何编写 web 服务器！</p>
<a id="more"></a>
<hr>
<h2 id="u67B6_u6784_u603B_u89C8"><a href="#u67B6_u6784_u603B_u89C8" class="headerlink" title="架构总览"></a>架构总览</h2><p>写服务器，最重要的就是理清思路，上节课我们介绍了诸多概念，尤其是最后提到的 <code>getaddrinfo</code> 和 <code>getnameinfo</code>，都是我们在搭建过程中必不可少的工具。这里先借下图来介绍具体的实现思路：</p>
<p><img src="/images/14599728555354.jpg" alt=""></p>
<p>整个的工作流程有 5 步：</p>
<ol>
<li>开启服务器（<code>open_listenfd</code> 函数，做好接收请求的准备）<ul>
<li><code>getaddrinfo</code>: 设置服务器的相关信息，具体可以参见 图1&amp;2</li>
<li><code>socket</code>: 创建 socket descriptor，也就是之后用来读写的 file descriptor<ul>
<li><code>int socket(int domain, int type, int protocol)</code></li>
<li>例如 <code>int clientfd = socket(AF_INET, SOCK_STREAM, 0);</code></li>
<li><code>AF_INET</code> 表示在使用 32 位 IPv4 地址</li>
<li><code>SOCK_STREAM</code> 表示这个 socket 将是 connection 的 endpoint</li>
<li>前面这种写法是协议相关的，建议使用 <code>getaddrinfo</code> 生成的参数来进行配置，这样就是协议无关的了</li>
</ul>
</li>
<li><code>bind</code>: 请求 kernel 把 socket address 和 socket descriptor 绑定<ul>
<li><code>int bind(int sockfd, SA *addr, socklen_t addrlen);</code></li>
<li>The process can read bytes that arrive on the connection whose endpoint is <code>addr</code> by reading from descriptor <code>sockfd</code></li>
<li>Similarly, writes to <code>sockfd</code> are transferred along connection whose endpoint is <code>addr</code></li>
<li>最好是用 <code>getaddrinfo</code> 生成的参数作为 <code>addr</code> 和 <code>addrlen</code> </li>
</ul>
</li>
<li><code>listen</code>: 默认来说，我们从 <code>socket</code> 函数中得到的 descriptor 默认是 active socket（也就是客户端的连接），调用 <code>listen</code> 函数告诉 kernel 这个 socket 是被服务器使用的<ul>
<li><code>int listen(int sockfd, int backlog);</code></li>
<li>把 <code>sockfd</code> 从 active socket 转换成 listening socket，用来接收客户端的请求</li>
<li><code>backlog</code> 的数值表示 kernel 在接收多少个请求之后（队列缓存起来）开始拒绝请求</li>
</ul>
</li>
<li>[*]<code>accept</code>: 调用 <code>accept</code> 函数，开始等待客户端请求<ul>
<li><code>int accept(int listenfd, SA *addr, int *addrlen);</code></li>
<li>等待绑定到 <code>listenfd</code> 的连接接收到请求，然后把客户端的 socket address 写入到 <code>addr</code>，大小写入到 <code>addrlen</code></li>
<li>返回一个 connected descriptor 用来进行信息传输（类似 Unix I/O）</li>
<li>具体的过程可以参考 图3</li>
</ul>
</li>
</ul>
</li>
<li>开启客户端（<code>open_clientfd</code> 函数，设定访问地址，尝试连接）<ul>
<li><code>getaddrinfo</code>: 设置客户端的相关信息，具体可以参见 图1&amp;2</li>
<li><code>socket</code>: 创建 socket descriptor，也就是之后用来读写的 file descriptor</li>
<li><code>connect</code>: 客户端调用 <code>connect</code> 来建立和服务器的连接<ul>
<li><code>int connect(int clientfd, SA *addr, socklen_t addrlen);</code></li>
<li>尝试与在 socker address <code>addr</code> 的服务器建立连接</li>
<li>如果成功 <code>clientfd</code> 可以进行读写</li>
<li>connection 由 socket 对描述 <code>(x:y, addr.sin_addr:addr.sin_port)</code></li>
<li><code>x</code> 是客户端地址，<code>y</code> 是客户端临时端口，后面的两个是服务器的地址和端口</li>
<li>最好是用 <code>getaddrinfo</code> 生成的参数作为 <code>addr</code> 和 <code>addrlen</code> </li>
</ul>
</li>
</ul>
</li>
<li>交换数据（主要是一个流程循环，客户端向服务器写入，就是发送请求；服务器向客户端写入，就是发送响应）<ul>
<li>[Client]<code>rio_writen</code>: </li>
<li>[Client]<code>rio_readlineb</code>: </li>
<li>[Server]<code>rio_readlineb</code>:</li>
<li>[Server]<code>rio_writen</code>: </li>
</ul>
</li>
<li>关闭客户端（主要是 <code>close</code>）<ul>
<li>[Client]<code>close</code>:</li>
</ul>
</li>
<li>断开客户端（服务接收到客户端发来的 EOF 消息之后，断开已有的和客户端的连接）<ul>
<li>[Server]<code>rio_readlineb</code>:</li>
<li>[Server]<code>close</code>: </li>
</ul>
</li>
</ol>
<p><img src="/images/14599747281009.jpg" alt="图 1 Generic socket address"></p>
<p><img src="/images/14599747501489.jpg" alt="图 2 Socket Address Structures"></p>
<p><img src="/images/14599774536738.jpg" alt="图3 `accept` Illustrated"></p>
<blockquote>
<p>[Client]Connected Descriptor vs. [Server]Listening Descriptors</p>
</blockquote>
<p> 这两个的差别还是需要注意一下：</p>
<p> <img src="/images/14599776259093.jpg" alt=""></p>
<p>之所以要有这样的差别，是因为这样服务器可以同时处理多个请求（只要 fork 即可）</p>
<h2 id="u4EE3_u7801_u8BB2_u89E3"><a href="#u4EE3_u7801_u8BB2_u89E3" class="headerlink" title="代码讲解"></a>代码讲解</h2><blockquote>
<p>[Client] <code>open_clientfd</code></p>
</blockquote>
<p>用来建立和服务器的连接，协议无关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_clientfd</span><span class="params">(<span class="keyword">char</span> *hostname, <span class="keyword">char</span> *port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clientfd;</span><br><span class="line">    <span class="keyword">struct</span> addrinfo hints, *listp, *p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Get a list of potential server address</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">// Open a connection</span></span><br><span class="line">    hints.ai_flags = AI_NUMERICSERV; <span class="comment">// using numeric port arguments</span></span><br><span class="line">    hints.ai_flags |= AI_ADDRCONFIG; <span class="comment">// Recommended for connections</span></span><br><span class="line">    getaddrinfo(hostname, port, &amp;hints, &amp;listp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Walk the list for one that we can successfully connect to</span></span><br><span class="line">    <span class="comment">// 如果全部都失败，才最终返回失败（可能有多个地址）</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">// Create a socket descriptor</span></span><br><span class="line">        <span class="comment">// 这里使用从 getaddrinfo 中得到的参数，实现协议无关</span></span><br><span class="line">        <span class="keyword">if</span> ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</span><br><span class="line">                               p-&gt;ai_protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// Socket failed, try the next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Connect to the server</span></span><br><span class="line">        <span class="comment">// 这里使用从 getaddrinfo 中得到的参数，实现协议无关</span></span><br><span class="line">        <span class="keyword">if</span> (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Success</span></span><br><span class="line">        </span><br><span class="line">        close(clientfd); <span class="comment">// Connect failed, try another</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">// All connections failed</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// The last connect succeeded</span></span><br><span class="line">        <span class="keyword">return</span> clientfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[Server] <code>open_listenfd</code></p>
</blockquote>
<p>创建 listening descriptor，用来接收来自客户端的请求，协议无关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_listenfd</span><span class="params">(<span class="keyword">char</span> *port)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> addrinfo hints, *listp, *p;</span><br><span class="line">    <span class="keyword">int</span> listenfd, optval=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Get a list of potential server addresses</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">// Accept connection</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; <span class="comment">// on any IP address</span></span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV; <span class="comment">// using port number</span></span><br><span class="line">    <span class="comment">// 因为服务器不需要连接，所以原来填写地址的地方直接是 NULL</span></span><br><span class="line">    getaddrinfo(<span class="literal">NULL</span>, port, &amp;hints, &amp;listp); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Walk the list for one that we can successfully connect to</span></span><br><span class="line">    <span class="comment">// 如果全部都失败，才最终返回失败（可能有多个地址）</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">// Create a socket descriptor</span></span><br><span class="line">        <span class="comment">// 这里使用从 getaddrinfo 中得到的参数，实现协议无关</span></span><br><span class="line">        <span class="keyword">if</span> ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</span><br><span class="line">                               p-&gt;ai_protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// Socket failed, try the next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Eliminates "Address already in use" error from bind</span></span><br><span class="line">        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR), </span><br><span class="line">                    (<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;optval, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Bind the descriptor to the address</span></span><br><span class="line">        <span class="keyword">if</span> (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Success</span></span><br><span class="line">        </span><br><span class="line">        close(listenfd); <span class="comment">// Bind failed, try another</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">// No address worked</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Make it a listening socket ready to accept connection requests</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, LISTENQ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(listenfd);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一个简单的 socket 服务器实例</p>
<blockquote>
<p>Echo Client: Main Routine</p>
</blockquote>
<p>这个客户端做得事情很简单，就是把一段用户输入的文字发送到服务器，然后再把从服务器接收到的内容显示到输出中，具体可以参见注释</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// echoclient.c</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clientfd;</span><br><span class="line">    <span class="keyword">char</span> *host, *port, buf[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line">    </span><br><span class="line">    host = argv[<span class="number">1</span>];</span><br><span class="line">    port = argv[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建立连接（前面已经详细介绍）</span></span><br><span class="line">    clientfd = Open_clientfd(host, port);</span><br><span class="line">    Rio_readinitb(&amp;rio, clientfd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (Fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 写入，也就是向服务器发送信息</span></span><br><span class="line">        Rio_writen(clientfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="comment">// 读取，也就是从服务器接收信息</span></span><br><span class="line">        Rio_readlineb(&amp;rio, buf, MAXLINE);</span><br><span class="line">        <span class="comment">// 把从服务器接收的信息显示在输出中</span></span><br><span class="line">        Fputs(buf, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(clientfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative Echo Server: Main Rountine</p>
</blockquote>
<p>服务器做得工作也很简单，接收到从客户端发送的信息，然后返回一个一模一样的。具体参加注释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// echoserveri.c</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_storage clientaddr; <span class="comment">// Enough room for any addr</span></span><br><span class="line">    <span class="keyword">char</span> client_hostname[MAXLINE], client_port[MAXLINE];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启监听端口，注意只开这么一次</span></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要具体的大小</span></span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage); <span class="comment">// Important!</span></span><br><span class="line">        <span class="comment">// 等待连接</span></span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="comment">// 获取客户端相关信息</span></span><br><span class="line">        Getnameinfo((SA *) &amp;clientaddr, clientlen, client_hostname,</span><br><span class="line">                     MAXLINE, client_port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Connected to (%s, %s)\n"</span>, client_hostname, client_port);</span><br><span class="line">        <span class="comment">// 服务器具体完成的工作</span></span><br><span class="line">        echo(coonfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取从客户端传输过来的数据</span></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span>((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server received %d bytes\n"</span>, (<span class="keyword">int</span>)n);</span><br><span class="line">        <span class="comment">// 把从 client 接收到的信息再写回去</span></span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6D4B_u8BD5_u5DE5_u5177"><a href="#u6D4B_u8BD5_u5DE5_u5177" class="headerlink" title="测试工具"></a>测试工具</h2><p>测试的时候，我们可以使用 <code>telnet</code> 应用来测试服务器（只传输 ASCII 字符串的话，命令行工具无法显示图片），例如：</p>
<p>使用方法 <code>$ telnet &lt;host&gt; &lt;portnumber&gt;</code>，例如</p>
<p><img src="/images/14599877200828.jpg" alt="Testing Echo Server with `telnet`"></p>
<h2 id="Web__u670D_u52A1_u5668"><a href="#Web__u670D_u52A1_u5668" class="headerlink" title="Web 服务器"></a>Web 服务器</h2><p>客户端和服务器通过 HyperText Transfer Protocol(HTTP) 协议进行传输，具体的步骤是</p>
<ul>
<li>客户端和服务器建立 TCP 连接</li>
<li>客户端请求内容</li>
<li>服务器响应所请求的内容<ul>
<li>content: a sequence of bytes with an associated MIME (Multipurporse Internet Mail Extensions) types</li>
</ul>
</li>
<li>（最终）客户端和服务器关闭连接</li>
</ul>
<p><img src="/images/14599884494825.jpg" alt="Web Server Basics"></p>
<p>目前的版本是 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html" target="_blank" rel="external">HTTP/1.1 RFC 2616, June, 1999</a></p>
<p>一些 MIME 类型，更详细可见<a href="http://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank" rel="external">这里</a></p>
<ul>
<li><code>text/html</code> HTML document</li>
<li><code>text/plain</code> Unformatted text</li>
<li><code>image/gif</code> Binary image encoded in GIF format</li>
<li><code>image/png</code> Binary image encoded in PNG format</li>
<li><code>imgae/jpeg</code> Binary image encoded in JPEG format</li>
</ul>
<blockquote>
<p>静态内容与动态内容</p>
</blockquote>
<p>这部分比较简单，直接上图</p>
<p><img src="/images/14599890887501.jpg" alt=""></p>
<blockquote>
<p>URL 相关</p>
</blockquote>
<p>这部分比较简单，直接上图</p>
<p><img src="/images/14599891181741.jpg" alt=""></p>
<blockquote>
<p>HTTP Request</p>
</blockquote>
<p>这部分比较简单，直接上图</p>
<p><img src="/images/14599892040565.jpg" alt=""></p>
<blockquote>
<p>HTTP Responses</p>
</blockquote>
<p>这部分比较简单，直接上图</p>
<p><img src="/images/14599892360582.jpg" alt=""></p>
<blockquote>
<p>Example HTTP Transaction</p>
</blockquote>
<p><img src="/images/14599895910357.jpg" alt=""></p>
<p>剩下的概念主要是 CGI 应用，地址中 GET 表达形式，具体会在之后的习题课结合例子进行讲解，这里就不赘述了。不过还是要提一个重要概念：代理</p>
<blockquote>
<p>Proxies</p>
</blockquote>
<p><img src="/images/14599898580384.jpg" alt=""></p>
<p><img src="/images/14599898773522.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们来学习如何编写 web 服务器！</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="网络" scheme="http://wdxtub.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 20 课 Network Programming I]]></title>
    <link href="http://wdxtub.com/2016/04/06/csapp-20/"/>
    <id>http://wdxtub.com/2016/04/06/csapp-20/</id>
    <published>2016-04-06T11:33:58.000Z</published>
    <updated>2016-04-06T15:53:03.000Z</updated>
    <content type="html"><![CDATA[<p>网络已经成为了我们『智能』生活中最重要的一部分，这两节课我们会通过 C API 来了解具体的网络相关编程（用更高层次的封装只会更轻松！）</p>
<a id="more"></a>
<hr>
<h2 id="u7F51_u7EDC_u67B6_u6784"><a href="#u7F51_u7EDC_u67B6_u6784" class="headerlink" title="网络架构"></a>网络架构</h2><p>计算机网络的知识可谓是非常『保值』的，因为这么多基础设备还在运行着，基本机制在短时间内很难改变，关于网络的另一个版本的讲解在<a href="/./2016/02/10/internet-protocol/">这里</a>，我觉得也非常不错，大家感兴趣可以看看。</p>
<p>客户端-服务器模型是网络应用最广泛使用的模型，作为耳熟能详的概念，这里不多提，相信通过下图就能大致明白：</p>
<p><img src="/images/14599482011858.jpg" alt=""></p>
<p>网络相关的处理，都是通过网络适配器来完成的，具体在硬件上为：</p>
<p><img src="/images/14599482515878.jpg" alt="Hardware Organization of a Network Host"></p>
<p>根据应用范围和架构层级，可以分成三个部分：</p>
<ul>
<li>SAN - System Area Network<ul>
<li>Switched Ethernet, Quadrics QSW, …</li>
</ul>
</li>
<li>LAN - Local Area Network<ul>
<li>Ethernet, ..</li>
</ul>
</li>
<li>WAN - Wide Area Network<ul>
<li>High speed point-to-point phone lines</li>
</ul>
</li>
</ul>
<blockquote>
<p>最底层 - Ethernet Segment</p>
</blockquote>
<p>Ethernet segment consists of a collection of <strong>hosts</strong> connected by wires (twisted pairs) to a <strong>hub</strong>.</p>
<p>通常范围是房间或一层楼</p>
<p><img src="/images/14599485111822.jpg" alt="Ethernet Segment"></p>
<ul>
<li>每个 Ethernet 适配器有一个唯一的 48 位的地址（也就是 MAC 地址），例如 <code>00:16:ea:e3:54:e6</code></li>
<li>不同主机间发送的数据称为帧(frame)</li>
<li>Hub 会把每个端口发来的所有数据复制到其他的端口<ul>
<li>所有的主机都可以看到所有的数据（注意安全问题）</li>
</ul>
</li>
</ul>
<blockquote>
<p>下一层 - Bridged Ethernet Segment</p>
</blockquote>
<p><img src="/images/14599487658645.jpg" alt="Bridged Ethernet Segment"></p>
<p>通常范围是一层楼，通过不同的 bridge 来连接不同的 ethernet segment。Bridge 知道从某端口出发可达的主机，并有选择的在端口间复制数据。</p>
<p>为了从概念上简化，我们可以认为，所有的 hub, bridge 可以抽象为一条线，如下图所示：</p>
<p><img src="/images/14599488669806.jpg" alt="Conceptual View of LANs"></p>
<blockquote>
<p>下一层 - internets</p>
</blockquote>
<p>不同的（也许不兼容）的 LAN 可以通过 router 来进行物理上的连接，这样连接起来的网络称为 internet（注意是小写，大写的 Internet 可以认为是最著名的 internet）</p>
<p><img src="/images/14599491906184.jpg" alt="internets"></p>
<blockquote>
<p>internet 的逻辑结构</p>
</blockquote>
<p><img src="/images/14599492763163.jpg" alt="Logical Structure of an internet"></p>
<ul>
<li>Ad hoc interconnection of networks<ul>
<li>没有特定的拓扑结构</li>
<li>不同的 router 和 link 差异可能很大</li>
</ul>
</li>
<li>通过在不同的网络间跳转来传递 packet<ul>
<li>Router 是不同网络间的连接</li>
<li>不同的 packet 可能会走不同的路线</li>
</ul>
</li>
</ul>
<h2 id="u7F51_u7EDC_u534F_u8BAE"><a href="#u7F51_u7EDC_u534F_u8BAE" class="headerlink" title="网络协议"></a>网络协议</h2><p>在不同的 LAN 和 WAN 中传输数据，就要守规矩，这个规矩就是协议。协议负责做的事情有：</p>
<ul>
<li>提供 naming scheme<ul>
<li>定义 host address 格式</li>
<li>每个主机和路由器都至少有一个独立的 internet 地址</li>
</ul>
</li>
<li>提供 delivery mechanism<ul>
<li>定义了标准的传输单元 - packet</li>
<li>Packet 包含 header 和 payload<ul>
<li>header 包括 packet size, source 和 destination address</li>
<li>payload 包括需要传输的数据  </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在这样的协议下，具体的数据传输是：</p>
<p><img src="/images/14599502534733.jpg" alt="Transferring internet Data Via Encapsulation"></p>
<p>PH = Internet packet header, FH = LAN frame header</p>
<blockquote>
<p>Globle IP Internet(upper case)</p>
</blockquote>
<p>Internet 是 internet 最为著名的例子。主要基于 TCP/IP 协议族：</p>
<ul>
<li>IP (Internet Protocal)<ul>
<li>Provides <strong>basic naming scheme</strong> and unreliable <strong>delivery capability</strong> of packets (datagrams) from <strong>host-to-host</strong></li>
</ul>
</li>
<li>UDP (Unreliable Datagram Protocol)<ul>
<li>Uses IP to provide <strong>unreliable</strong> datagram delivery from <strong>process-to-process</strong></li>
</ul>
</li>
<li>TCP (Transmission Control Protocol)<ul>
<li>Uses IP to provide <strong>reliable</strong> byte streams from <strong>process-to-process</strong> over <strong>connections</strong></li>
</ul>
</li>
</ul>
<p>Accessed via a mix of Unix file I/O and functions from <strong>sockets interface</strong>.（很多东西不是很好翻译，用原文比较准确）</p>
<p><img src="/images/14599506938536.jpg" alt="Hardware and Software Organization of an Internet Application"></p>
<h2 id="Internet__u7684_u7A0B_u5E8F_u5458_u89C6_u89D2"><a href="#Internet__u7684_u7A0B_u5E8F_u5458_u89C6_u89D2" class="headerlink" title="Internet 的程序员视角"></a>Internet 的程序员视角</h2><ul>
<li>主机有 32 位的 IP 地址 - 23.235.46.133<ul>
<li>IPv4 - 32 位地址，IPv6 - 128 位地址</li>
</ul>
</li>
<li>IP 地址被映射到域名 - 23.235.46.133 映射到 www.wdxtub.com</li>
<li>不同主机之间的进程，可以通过 connection 来交换数据</li>
</ul>
<blockquote>
<p>IP 地址</p>
</blockquote>
<p>我们会用一个叫做 IP address stuct 的东西来存储，并且 IP 地址是以 network byte order（也就是大端）来进行存储的</p>
<p><img src="/images/14599515895838.jpg" alt="IP Address"></p>
<p>为了方便读，一般用下图的形式来进行表示：</p>
<p><img src="/images/14599516332783.jpg" alt=""></p>
<p>具体的转换可以使用 <code>getaddrinfo</code> 和 <code>getnameinfo</code> 函数</p>
<blockquote>
<p>Internet 域名</p>
</blockquote>
<p><img src="/images/14599516793840.jpg" alt="Internet Domain Names"></p>
<p>这里主要需要了解的就是 Domain Naming System(DNS) 的概念，用来做 IP 地址到域名的映射。具体可以用 <code>nslookup</code> 命令来查看，下面是一些例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">wdxtub.local</span><br><span class="line"></span><br><span class="line">$ nslookup www.wdxtub.com</span><br><span class="line">Server:		<span class="number">8.8</span>.<span class="number">8.8</span></span><br><span class="line">Address:	<span class="number">8.8</span>.<span class="number">8.8</span><span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.wdxtub.com	canonical name = wdxtub.github.io.</span><br><span class="line">wdxtub.github.io	canonical name = github.map.fastly.net.</span><br><span class="line">Name:	github.map.fastly.net</span><br><span class="line">Address: <span class="number">23.235</span>.<span class="number">39.133</span></span><br><span class="line"></span><br><span class="line">$ nslookup www.twitter.com</span><br><span class="line">Server:		<span class="number">8.8</span>.<span class="number">8.8</span></span><br><span class="line">Address:	<span class="number">8.8</span>.<span class="number">8.8</span><span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.twitter.com	canonical name = twitter.com.</span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: <span class="number">199.16</span>.<span class="number">156.6</span></span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: <span class="number">199.16</span>.<span class="number">156.198</span></span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: <span class="number">199.16</span>.<span class="number">156.230</span></span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: <span class="number">199.16</span>.<span class="number">156.70</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Internet Connections</p>
</blockquote>
<p>客户端和服务器通过 connection 来发送字节流，特点是：</p>
<ul>
<li>Point-to-point: 连接一对进程</li>
<li>Full-duplex: 数据同时可以在两个方向流动</li>
<li>Reliable: 字节的发送的顺序和收到的一致</li>
</ul>
<p>Socket 则可以认为是 connection 的 endpoint，socket 地址是一个 <code>IPaddress:port</code> 对。</p>
<p>Port（端口）是一个 16 位的整数，用来标识不同的进程：</p>
<ul>
<li>Ephemeral port: Assigned automatically by client kernel when client makes a connection request</li>
<li>Well-known port: Associated with some <strong>service</strong> provided by a server（在 linux 系统上可以在 <code>/etc/services</code> 中查看具体的信息）<ul>
<li>echo server: 7/echo</li>
<li>ssh server: 22/ssh</li>
<li>email server: 25/smtp</li>
<li>web servers: 80/http</li>
</ul>
</li>
</ul>
<blockquote>
<p>Connection 详解</p>
</blockquote>
<p>A connection is uniquely identified by the socket addresses of its endpoints(socket pair - cliaddr:cliport, servaddr: servport)</p>
<p><img src="/images/14599531325600.jpg" alt="Anatomy of a Connection"></p>
<p>利用不同的端口来连接不同的服务：</p>
<p><img src="/images/14599534610996.jpg" alt="Using Ports to Identify Services"></p>
<blockquote>
<p>Socket Interface</p>
</blockquote>
<p>一系列系统级的函数，和 Unix I/O 配合构造网络应用（在所有的现代操作系统上都可用）。</p>
<p>对于 kernel 来说，socket 是 endpoint of communication；对于应用程序来说，socket 是 file descriptor，用来读写（回忆一下，STDIN 和 STDOUT 也是 file descriptor）。客户端和服务器通过读写对应的 socket descriptor 来进行。</p>
<p><img src="/images/14599559864957.jpg" alt=""></p>
<p>The main distinction between regular file I/O and socket I/O is how the application “opens” the socket descriptors.</p>
<blockquote>
<p>Generic socket address</p>
</blockquote>
<p><img src="/images/14599561357752.jpg" alt=""></p>
<blockquote>
<p>Internet-specific socket address</p>
</blockquote>
<p>实际上占用同样的空间，但是有更详细的信息</p>
<p><img src="/images/14599561803255.jpg" alt=""></p>
<p>总体的流程为：</p>
<p><img src="/images/14599565974716.jpg" alt=""></p>
<h2 id="u5E38_u7528_u51FD_u6570"><a href="#u5E38_u7528_u51FD_u6570" class="headerlink" title="常用函数"></a>常用函数</h2><p>接下来直接用 PPT 介绍两个重要函数 <code>getaddrinfo</code> 和 <code>getnameinfo</code></p>
<blockquote>
<p>getaddrinfo</p>
</blockquote>
<p>用来把 hostname, host address, port, service name 的字符串表示转换成 socket address 结构。</p>
<p><img src="/images/14599569037369.jpg" alt=""></p>
<p>函数原型为：</p>
<p><img src="/images/14599569254580.jpg" alt=""></p>
<p>这里具体说一下 <code>result</code> 这个链表：</p>
<p><img src="/images/14599569748746.jpg" alt="Linked List Returned by `getaddrinfo`"></p>
<p> 客户端需要遍历这个列表，按顺序访问每个 socket address，直到 <code>socket</code> 和 <code>connect</code> 函数调用成功。</p>
<p> 服务器需要遍历这个列表，直到 <code>socket</code> 和  <code>bind</code> 函数调用成功</p>
<p>每个 <code>addrinfo</code> 结构体为</p>
<p><img src="/images/14599573080061.jpg" alt="addrinfo Struct"></p>
<blockquote>
<p>getnameinfo</p>
</blockquote>
<p>刚好和 <code>getaddrinfo</code> 相反，把 socket address 转换成对应的字符串信息，函数原型为</p>
<p><img src="/images/14599575876044.jpg" alt=""></p>
<p>举个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hostinfo.c</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> addrinfo *p, *listp, hints;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> rc, flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Get a list of addrinfo records</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_family = AF_INET; <span class="comment">// IPv4 only</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">// Connections only</span></span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(argv[<span class="number">1</span>], <span class="literal">NULL</span>, &amp;hints, &amp;listp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"getaddrinfo error: %s\n"</span>, gai_strerror(rc));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Walk the list and display each IP address</span></span><br><span class="line">    flags = NI_NUMERICHOST; <span class="comment">// Display address instead of name</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        getnameinfo(p-&gt;ai_addr, p-&gt;ai_addrlen, buf, MAXLINE, <span class="literal">NULL</span>, <span class="number">0</span>, flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>网络已经成为了我们『智能』生活中最重要的一部分，这两节课我们会通过 C API 来了解具体的网络相关编程（用更高层次的封装只会更轻松！）</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="网络" scheme="http://wdxtub.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker 碎碎念]]></title>
    <link href="http://wdxtub.com/2016/04/03/docker-gossip/"/>
    <id>http://wdxtub.com/2016/04/03/docker-gossip/</id>
    <published>2016-04-03T19:14:10.000Z</published>
    <updated>2016-04-03T22:35:01.000Z</updated>
    <content type="html"><![CDATA[<p>这篇日志主要来自 Docker 的应用及部署实践，算是从感性的角度来了解 Docker。</p>
<a id="more"></a>
<hr>
<p>以 Docker 为代表的容器技术模糊了 IaaS 与 PaaS 之间的界限，为云计算的服务形式带来了一个开放的未来。</p>
<p>一些言论：</p>
<ul>
<li>对 Docker 大规模应用到生产环境需要谨慎，但是仅考虑测试和开发，是可以真正解决环境部署问题的好办法</li>
<li>将所有服务放在一个容器叫做 Fat Container</li>
<li>Docker 天然适合一个容器只运行一种服务（官方更推荐）<ul>
<li>为每个服务创建单独文件夹，并在每个文件夹下放一个 Dockerfile</li>
</ul>
</li>
<li>每个容器只运行单一服务，容器间的互相通信有两种办法：<ul>
<li>将容器端口绑定到一个本地端口，通过端口通讯</li>
<li>通过 Docker 提供的 Linking 功能，推荐使用 Docker-Compose</li>
</ul>
</li>
<li>当前容器技术面临的最大阻力是安全问题和管理工具</li>
<li>学习 Docker 的三个阶段<ul>
<li>Docker 本身功能的使用</li>
<li>驾驭 Docker 集群（使用 Kubernetes, Shipyard, Machine+Swarm+Compose）</li>
<li>为场景和业务深度定制</li>
</ul>
</li>
<li>Docker 面临的最大阻碍 <ul>
<li>Docker 所属公司本身的强势，想做一揽子事情的态度，这使得 Docker 现在非常臃肿</li>
<li>不要把眼光局限在 Docker 上面，让 Docker 只做容器的事情</li>
</ul>
</li>
</ul>
<blockquote>
<p>除非你不想做，不想做就算了，想做好的话就不可能不劳而获</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">差劲的叛逆者</th>
<th style="text-align:center">优秀的叛逆者</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">抱怨</td>
<td style="text-align:center">创造</td>
</tr>
<tr>
<td style="text-align:center">断言</td>
<td style="text-align:center">质疑</td>
</tr>
<tr>
<td style="text-align:center">关注个人</td>
<td style="text-align:center">关注任务</td>
</tr>
<tr>
<td style="text-align:center">悲观</td>
<td style="text-align:center">乐观</td>
</tr>
<tr>
<td style="text-align:center">愤怒</td>
<td style="text-align:center">热情</td>
</tr>
<tr>
<td style="text-align:center">耗费能量</td>
<td style="text-align:center">生成能量</td>
</tr>
<tr>
<td style="text-align:center">疏离</td>
<td style="text-align:center">吸引</td>
</tr>
<tr>
<td style="text-align:center">问题</td>
<td style="text-align:center">可能性</td>
</tr>
<tr>
<td style="text-align:center">抱怨问题</td>
<td style="text-align:center">寻找机会</td>
</tr>
<tr>
<td style="text-align:center">担心</td>
<td style="text-align:center">希冀</td>
</tr>
<tr>
<td style="text-align:center">指责他人</td>
<td style="text-align:center">指出原因</td>
</tr>
<tr>
<td style="text-align:center">困扰</td>
<td style="text-align:center">反抗</td>
</tr>
<tr>
<td style="text-align:center">说教</td>
<td style="text-align:center">倾听</td>
</tr>
</tbody>
</table>
<p>成功叛逆者的秘密</p>
<table>
<thead>
<tr>
<th style="text-align:left">策略：实现特定目标的行动</th>
<th style="text-align:left">行为：你的行为举止，特别是对他人时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">利用他人的才华，明白没人能独自完成意义重大的改变</td>
<td style="text-align:left">保持乐观，鼓舞他人加入解决问题的行列</td>
</tr>
<tr>
<td style="text-align:left">将自己的想法和组织的目标统一起来</td>
<td style="text-align:left">评论想法，不评论人；讨论想法和想法的价值</td>
</tr>
<tr>
<td style="text-align:left">展现改变带来的好处与代价相称</td>
<td style="text-align:left">从愤怒中学习：思考是什么引发了愤怒，避免陷入情绪闹剧</td>
</tr>
<tr>
<td style="text-align:left">有效利用冲突：探究分歧和冲突，学习如何完善和推进一个想法</td>
<td style="text-align:left">尊重他人并考虑不同的观点</td>
</tr>
<tr>
<td style="text-align:left">不操之过急：给他人实践来接受新想法并思考它的影响</td>
<td style="text-align:left">知道何时该放弃坚持，懂得权衡想法的重要性和固执的代价</td>
</tr>
</tbody>
</table>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.wolonge.com/zhuanlan/detail/117441" target="_blank" rel="external">Docker在PHP项目开发环境中的应用</a></li>
<li><a href="http://news.oneapm.com/mesos-docker-go/" target="_blank" rel="external">通过 Mesos、Docker 和 Go，使用 300 行代码创建一个分布式系统</a></li>
<li>《Docker 开发实践》</li>
<li>《Docker——容器与容器云》</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇日志主要来自 Docker 的应用及部署实践，算是从感性的角度来了解 Docker。</p>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://wdxtub.com/tags/Docker/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="平台" scheme="http://wdxtub.com/tags/%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker 基本概念]]></title>
    <link href="http://wdxtub.com/2016/04/03/docker-basic-concept/"/>
    <id>http://wdxtub.com/2016/04/03/docker-basic-concept/</id>
    <published>2016-04-03T10:03:09.000Z</published>
    <updated>2016-04-03T17:56:32.000Z</updated>
    <content type="html"><![CDATA[<p>在 <a href="/./2016/04/02/docker-first-step/">Docker 快速入门及试验环境配置</a>中我们通过一个例子简单了解了 docker 的使用。这篇文章会从基本概念出发，用实际操作去更加深入理解 docker。</p>
<a id="more"></a>
<hr>
<p>具体的安装部分这里不赘述，可以在 <a href="/./2016/04/02/docker-first-step/">Docker 快速入门及试验环境配置</a> 的『安装』部分找到。</p>
<p>先大概复习一下基本概念：</p>
<p>主要是三个：</p>
<ul>
<li>镜像(Image)<ul>
<li>一个只读的模板，镜像可以用来创建 Docker 容器</li>
<li>可以简单创建或更新现有镜像，或者直接下载使用其他人的</li>
</ul>
</li>
<li>容器(Container)<ul>
<li>容器是从镜像创建的运行实例，在启动的时候创建一层可写层作为最上层（因为镜像是只读的）</li>
<li>可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台</li>
<li>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序</li>
</ul>
</li>
<li>仓库(Repository)<ul>
<li>集中存放镜像文件的场所</li>
<li>最大的公开仓库是 <a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a></li>
<li>国内的公开仓库包括 <a href="http://www.dockerpool.com/" target="_blank" rel="external">Docker Pool</a> 等</li>
<li>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了</li>
<li>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务</li>
</ul>
</li>
</ul>
<h2 id="u955C_u50CF"><a href="#u955C_u50CF" class="headerlink" title="镜像"></a>镜像</h2><p>我们可以使用 <code>docker pull</code> 命令从仓库中获取所需要的镜像。比如说 <code>sudo docker pull ubuntu:12.04</code>，相当于 <code>sudo docker pull registry.hub.docker.com/ubuntu:12.04</code>，即从注册服务器 <code>registry.hub.docker.com</code> 中的 <code>ubuntu</code> 仓库来下载标记为<code>12.04</code> 的镜像。</p>
<p>如果想从其他仓库注册服务器下载，需要输入完成的地址，例如：<code>sudo docker pull dl.dockerpool.com:5000/ubuntu:12.04</code></p>
<p>下载完成之后就可以使用该镜像了，比如下面的语句就会创建容器，其中运行 <code>bash</code>：<code>sudo docker run -t -i ubuntu:12.04 /bin/bash</code></p>
<p>可以使用 <code>dokcer images</code> 来显示本地已有的镜像，如下</p>
<p><img src="/images/14596963929829.jpg" alt="docker images"></p>
<p>具体字段的意思一目了然，这里不再赘述。然后我们来运行官方例子 <code>whalesay</code> 镜像。</p>
<h3 id="u8FD0_u884C_u955C_u50CF"><a href="#u8FD0_u884C_u955C_u50CF" class="headerlink" title="运行镜像"></a>运行镜像</h3><p>打开浏览器，进入 <a href="https://hub.docker.com/?utm_source=getting_started_guide&amp;utm_medium=embedded_Linux&amp;utm_campaign=find_whalesay" target="_blank" rel="external">Docker Hub</a></p>
<p><img src="/images/14596967621449.jpg" alt="Docker Hub"></p>
<p>搜索 <code>whalesay</code> 这个镜像，就可以看到结果，点进去可以看到详细内容（基于 Ubuntu）</p>
<p><img src="/images/14596968187418.jpg" alt="whalesay image"></p>
<p>然后我们来运行一下，使用命令 <code>docker run docker/whalesay cowsay boo</code>，其中 <code>cowsay</code> 是要运行的命令，后面的 <code>boo</code> 是参数。</p>
<p>Docker 会先在本地查找有没有镜像，如果没有就从仓库中下载，具体的运行结果是：</p>
<p><img src="/images/14596971019958.jpg" alt="cowsay boo"></p>
<p>也可以让鲸鱼说不同的话，比如：</p>
<p><img src="/images/14596971443647.jpg" alt=""></p>
<h3 id="u5236_u4F5C_u955C_u50CF"><a href="#u5236_u4F5C_u955C_u50CF" class="headerlink" title="制作镜像"></a>制作镜像</h3><p>如果想要制作自己的镜像，需要自己写 Dockerfile。具体步骤如下</p>
<ol>
<li>创建一个文件夹 <code>mkdir wdxtub; cd wdxtub</code>，构造镜像所需的所有东西都会放在这个文件夹中</li>
<li>创建一个名为 <code>Dockerfile</code> 的文件 <code>gedit Dockerfile</code></li>
<li>添加第一句话 <code>FROM docker/whalesay:latest</code>，表示我们的镜像以 <code>whalesay</code> 为基础</li>
<li>添加需要运行的命令，如 <code>RUN apt-get -y update &amp;&amp; apt-get install -y fortunes</code>（<code>fortunes</code> 这个程序会输出名言警句）</li>
<li>通过 <code>CMD</code> 指定镜像载入之后需要执行的命令，如 <code>CMD /usr/games/fortune -a | cowsay</code></li>
<li>保存并关闭 Dockerfile</li>
<li>使用 <code>sudo docker build -t wdx-whale .</code> 来构造镜像，简单来说就是用 Dockerfile 中的内容按步骤构造</li>
<li>使用 <code>docker images</code> 应该就可以看到我们新创建的镜像</li>
</ol>
<p><img src="/images/14596980285832.jpg" alt="wdx-whale image"></p>
<p>然后我们就可以运行一下看看 <code>docker run wdx-whale</code></p>
<p><img src="/images/14596980932968.jpg" alt="搞笑句"></p>
<p>还有更贱的（感觉可以玩一天）</p>
<p><img src="/images/14596987783177.jpg" alt=""></p>
<p>如果想要把自己的镜像上传到网上，就需要注册一个 Docker Hub 帐号，然后点击 Create Repository，这里我创建了一个名为 <code>wdxtub/demo</code> 的公用仓库。</p>
<p>接下来我们需要打上 tag，目前 <code>docker images</code> 的情况是：</p>
<p><img src="/images/14596980285832.jpg" alt="wdx-whale image"></p>
<p>记住我们的 IMAGE ID 26ac9649d7da。用以下命令打 tag <code>docker tag 26ac9649d7da wdxtub/wdx-whale:latest</code>，然后再 <code>docker images</code> 一次：</p>
<p><img src="/images/14596998719751.jpg" alt=""></p>
<p>然后用这个命令登录 <code>docker login --username=yourhubusername --email=youremail@company.com</code>，对于我来说就是 <code>docker login --username=wdxtub --email=dacrocodilee@gmail.com</code></p>
<p>成功之后大概是这样：</p>
<p><img src="/images/14596999803535.jpg" alt="登录成功"></p>
<p>然后就可以 push 上去了 <code>docker push wdxtub/wdx-whale</code>，像下面这样</p>
<p><img src="/images/14597002872580.jpg" alt="push"></p>
<p>为了测试 pull 自己的镜像，我们先把本地上的 whale 镜像删掉：<code>docker rmi -f wdxtub/wdx-whale; docker rmi -f wdx-whale</code>（如果有其他的用不着的也都删掉），最后剩下（上课要用的镜像）：</p>
<p><img src="/images/14597004851281.jpg" alt=""></p>
<p>接着来运行一下 <code>docker run wdxtub/wdx-whale</code></p>
<h3 id="u7BA1_u7406_u955C_u50CF"><a href="#u7BA1_u7406_u955C_u50CF" class="headerlink" title="管理镜像"></a>管理镜像</h3><p>我们可以把镜像导出到本地文件，使用 <code>docker save</code> 命令即可，比如针对我现在有的镜像 <code>wdxtub/wdx-whale(id:26ac9649d7da)</code>，可以这样：<code>docker save -o wdx-local-whale.tar wdxtub/wdx-whale</code>。如果要载入的话，使用下面的命令即可（会载入相关的元数据信息）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker load --input wdx-local-whale.tar</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker load &lt; wdx-local-whale.tar</span><br></pre></td></tr></table></figure>
<p>在删除镜像之前要先用 <code>docker rm</code> 删掉依赖于这个镜像的所有容器.</p>
<p><code>sudo docker rmi $(docker images -q -f &quot;dangling=true&quot;)</code></p>
<blockquote>
<p>镜像的实现原理</p>
</blockquote>
<p>Docker 镜像是怎么实现增量的修改和维护的？ 每个镜像都由很多层次构成，Docker 使用 <a href="http://en.wikipedia.org/wiki/UnionFS" target="_blank" rel="external">Union FS</a> 将这些不同的层结合到一个镜像中去。</p>
<p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。 Docker 在 AUFS 上构建的容器也是利用了类似的原理。</p>
<h2 id="u5BB9_u5668"><a href="#u5BB9_u5668" class="headerlink" title="容器"></a>容器</h2><p>容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>
<p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器（对于初级应用来说后者更方便）。</p>
<p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<p>可以利用 <code>docker start</code> 命令，直接将一个已经终止的容器启动运行。<br>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p>
<h3 id="u542F_u52A8"><a href="#u542F_u52A8" class="headerlink" title="启动"></a>启动</h3><p>举个例子，我们来创建一个 ubuntu:14.04 的容器 <code>docker run ubuntu:14.04 /bin/echo &#39;Hello wdx!&#39;</code></p>
<p><img src="/images/14597044909422.jpg" alt=""></p>
<p>用 <code>docker run -t -i ubuntu:14.04 /bin/bash</code> 可以启动一个 bash 终端用来交互。其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。我们可以输入一些命令来测试</p>
<p><img src="/images/14597046071804.jpg" alt=""></p>
<p>我们用 <code>ps</code> 或 <code>top</code> 在伪终端中查看进程信息，可以看到：</p>
<p><img src="/images/14597046832387.jpg" alt=""></p>
<p>输入 <code>exit</code> 可以退出 docker</p>
<p>容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p>
<h3 id="u540E_u53F0_u8FD0_u884C"><a href="#u540E_u53F0_u8FD0_u884C" class="headerlink" title="后台运行"></a>后台运行</h3><p>更多的时候，需要让 Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。</p>
<p>下面举两个例子来说明一下。</p>
<p>如果不使用 -d 参数运行容器 <code>docker run ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code> 容器会把输出的结果(STDOUT)打印到宿主机上面</p>
<p><img src="/images/14597048507796.jpg" alt=""></p>
<p>如果使用了 -d 参数运行容器 <code>docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code>，则显示是这样：</p>
<p><img src="/images/14597049156842.jpg" alt=""></p>
<p>使用 <code>docker logs containerid</code> 可以查看输出，如：</p>
<p><img src="/images/14597049744299.jpg" alt=""></p>
<p>使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker ps 命令来查看容器信息。容器是否会长久运行，是和docker run指定的命令有关，和 -d 参数无关</p>
<p>在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作，有很多种方法，包括使用 docker attach 命令或 nsenter 工具等。具体参考<a href="https://yeasy.gitbooks.io/docker_practice/content/container/enter.html" target="_blank" rel="external">这里</a></p>
<h3 id="u7EC8_u6B62_u4E0E_u91CD_u65B0_u542F_u52A8"><a href="#u7EC8_u6B62_u4E0E_u91CD_u65B0_u542F_u52A8" class="headerlink" title="终止与重新启动"></a>终止与重新启动</h3><p>使用 <code>docker stop containerid</code> 来终止容器。终止状态的容器可以用 <code>docker ps -a</code> 命令看到。</p>
<p>另外，<code>docker restart containerid</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h3 id="u5BFC_u5165_u5BFC_u51FA_u4E0E_u5220_u9664"><a href="#u5BFC_u5165_u5BFC_u51FA_u4E0E_u5220_u9664" class="headerlink" title="导入导出与删除"></a>导入导出与删除</h3><p>如果要导出本地某个容器，可以使用 <code>docker export containerid</code> 命令。</p>
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat ubuntu.tar | sudo docker import - <span class="built_in">test</span>/ubuntu:v1.<span class="number">0</span></span><br><span class="line"><span class="comment"># 也可以通过指定 URL 或者某个目录来导入，例如</span></span><br><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>
<p>用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<p>可以使用 <code>docker rm</code> 来删除一个处于终止状态的容器。如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</p>
<p>用 <code>docker ps -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用 <code>docker rm $(docker ps -a -q)</code> 可以全部清理掉。</p>
<p>注意：这个命令其实会试图删除所有的包括还在运行中的容器，不过就像上面提过的<code>docker rm</code> 默认并不会删除运行中的容器。</p>
<h2 id="u4ED3_u5E93"><a href="#u4ED3_u5E93" class="headerlink" title="仓库"></a>仓库</h2><p>仓库（Repository）是集中存放镜像的地方。</p>
<p>一个容易混淆的概念是注册服务器（Registry）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址dl.dockerpool.com/ubuntu 来说，dl.dockerpool.com 是注册服务器地址，ubuntu是仓库名。</p>
<p>大部分时候，并不需要严格区分这两者的概念。相信信息可以直接看教程，这里不赘述了。</p>
<ul>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/dockerhub.html" target="_blank" rel="external">Docker Hub 指南</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/local_repo.html" target="_blank" rel="external">私有仓库指南</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/config.html" target="_blank" rel="external">配置文件指南</a></li>
</ul>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="/Find and run the whalesay image">Find and run the whalesay image</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/image/create.html" target="_blank" rel="external">创建镜像</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/container/enter.html" target="_blank" rel="external">进入容器</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 <a href="/./2016/04/02/docker-first-step/">Docker 快速入门及试验环境配置</a>中我们通过一个例子简单了解了 docker 的使用。这篇文章会从基本概念出发，用实际操作去更加深入理解 docker。</p>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://wdxtub.com/tags/Docker/"/>
    
      <category term="概念" scheme="http://wdxtub.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker 快速入门及试验环境配置]]></title>
    <link href="http://wdxtub.com/2016/04/02/docker-first-step/"/>
    <id>http://wdxtub.com/2016/04/02/docker-first-step/</id>
    <published>2016-04-03T00:11:29.000Z</published>
    <updated>2016-04-04T00:48:18.000Z</updated>
    <content type="html"><![CDATA[<p>借着课程的机会来了解一下 Docker，大部分内容来自官方文档以及课程指引。</p>
<a id="more"></a>
<hr>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Docker 最初 dotCloud 公司内部的一个业余项目</li>
<li>Docker 基于 Go 语言</li>
<li>Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案</li>
<li>Docker 的基础是 Linux 容器（LXC）等技术</li>
<li>Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多</li>
<li>Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器</li>
</ul>
<p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</p>
<p><img src="/images/14596424862659.png" alt=""></p>
<p><img src="/images/14596424920098.png" alt=""></p>
<p>容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。</p>
<p>主要优势为：</p>
<ul>
<li>更快速的交付和部署 - 容器成为了最小单位</li>
<li>更高效的虚拟化 - 内核级虚拟化</li>
<li>更轻松的迁移和拓展</li>
<li>更简单的管理</li>
</ul>
<h2 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h2><p>主要是三个：</p>
<ul>
<li>镜像(Image)<ul>
<li>一个只读的模板，镜像可以用来创建 Docker 容器</li>
<li>可以简单创建或更新现有镜像，或者直接下载使用其他人的</li>
</ul>
</li>
<li>容器(Container)<ul>
<li>容器是从镜像创建的运行实例，在启动的时候创建一层可写层作为最上层（因为镜像是只读的）</li>
<li>可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台</li>
<li>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序</li>
</ul>
</li>
<li>仓库(Repository)<ul>
<li>集中存放镜像文件的场所</li>
<li>最大的公开仓库是 <a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a></li>
<li>国内的公开仓库包括 <a href="http://www.dockerpool.com/" target="_blank" rel="external">Docker Pool</a> 等</li>
<li>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了</li>
<li>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务</li>
</ul>
</li>
</ul>
<h2 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h2><p>官方网站提供了 <a href="https://docs.docker.com/mac/" target="_blank" rel="external">Mac</a>, <a href="https://docs.docker.com/linux/" target="_blank" rel="external">Linux</a> 和 <a href="https://docs.docker.com/windows/" target="_blank" rel="external">Windows</a> 版本的安装教程。因为我打算使用虚拟机进行安装测试，所以这里主要走 Linux 的安装教程，不过其他的应该大同小异。我的 ubuntu 版本是 14.04 LTS, trusty</p>
<p>Docker 目前只能安装在 64 位平台上，并且要求内核版本不低于 3.10，实际上内核越新越好，过低的内核版本容易造成功能的不稳定。可以通过下面的命令来检查内核版本（两个方式，都可以）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parallels@ubuntu:~$ uname <span class="operator">-a</span>Linux ubuntu <span class="number">3.13</span>.<span class="number">0</span>-<span class="number">83</span>-generic <span class="comment">#127-Ubuntu SMP Fri Mar 11 00:25:37 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line">parallels@ubuntu:~$ cat /proc/versionLinux version <span class="number">3.13</span>.<span class="number">0</span>-<span class="number">83</span>-generic (buildd@lgw01-<span class="number">55</span>) (gcc version <span class="number">4.8</span>.<span class="number">2</span> (Ubuntu <span class="number">4.8</span>.<span class="number">2</span>-<span class="number">19</span>ubuntu1) ) <span class="comment">#127-Ubuntu SMP Fri Mar 11 00:25:37 UTC 2016</span></span><br></pre></td></tr></table></figure>
<p>这里我们按照官网的教程，不使用 <code>apt-get</code> 而是使用 <code>curl</code> 来进行安装。</p>
<ol>
<li>如果没有安装 <code>curl</code>，使用 <code>sudo apt-get update; sudo apt-get install curl</code> 来进行安装</li>
<li>下载最新的 Docker 包 <code>curl -fsSL https://get.docker.com/ | sh</code><ul>
<li>如果想要以 non-root 用户的角色来使用，请使用 <code>sudo usermod -aG docker parallels</code>（这里 <code>parallels</code> 是用户名），注意需要注销并重新登录以应用改动</li>
</ul>
</li>
<li>验证安装<ul>
<li>需要先启用 docker <code>sudo service docker start</code></li>
<li>然后可以用 <code>docker version</code> 来查看版本</li>
<li>最后使用 <code>docker run hello-world</code> 来测试</li>
</ul>
</li>
</ol>
<p>版本信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parallels@ubuntu:~$ docker versionClient: Version:      <span class="number">1.10</span><span class="number">.3</span> API version:  <span class="number">1.22</span> Go version:   go1<span class="number">.5</span><span class="number">.3</span> Git commit:   <span class="number">20f</span>81dd Built:        Thu Mar <span class="number">10</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">52</span> <span class="number">2016</span> OS/Arch:      linux/amd64Server: Version:      <span class="number">1.10</span><span class="number">.3</span> API version:  <span class="number">1.22</span> Go version:   go1<span class="number">.5</span><span class="number">.3</span> Git commit:   <span class="number">20f</span>81dd Built:        Thu Mar <span class="number">10</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">52</span> <span class="number">2016</span> OS/Arch:      linux/amd64</span><br></pre></td></tr></table></figure>
<p>成功运行 hello world 的结果</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parallels@ubuntu:~$ docker run hello-worldHello <span class="built_in">from</span> Docker.This message shows that your installation appears <span class="built_in">to</span> be working correctly.To generate this message, Docker took <span class="operator">the</span> following steps: <span class="number">1.</span> The Docker client contacted <span class="operator">the</span> Docker daemon. <span class="number">2.</span> The Docker daemon pulled <span class="operator">the</span> <span class="string">"hello-world"</span> image <span class="built_in">from</span> <span class="operator">the</span> Docker Hub. <span class="number">3.</span> The Docker daemon created <span class="operator">a</span> <span class="built_in">new</span> container <span class="built_in">from</span> that image which runs <span class="operator">the</span>    executable that produces <span class="operator">the</span> output you are currently reading. <span class="number">4.</span> The Docker daemon streamed that output <span class="built_in">to</span> <span class="operator">the</span> Docker client, which sent <span class="keyword">it</span>    <span class="built_in">to</span> your terminal.To <span class="keyword">try</span> something more ambitious, you can run <span class="operator">an</span> Ubuntu container <span class="operator">with</span>: $ docker run -<span class="keyword">it</span> ubuntu bashShare images, automate workflows, <span class="operator">and</span> more <span class="operator">with</span> <span class="operator">a</span> free Docker Hub account: <span class="keyword">https</span>://hub.docker.comFor more examples <span class="operator">and</span> ideas, visit: <span class="keyword">https</span>://docs.docker.com/userguide/</span><br></pre></td></tr></table></figure>
<p>这之后的部分是课程需求。</p>
<p>我们需要安装 docker machine 和 virtual box，具体步骤为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取权限</span></span><br><span class="line">$ sudo su</span><br><span class="line"><span class="comment"># 下载 Docker Machine 的二进制文件 </span></span><br><span class="line">$ curl -L https://github.com/docker/machine/releases/download/v0.<span class="number">6.0</span>/docker-machine-`uname <span class="operator">-s</span>`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-machine &amp;&amp; chmod +x /usr/<span class="built_in">local</span>/bin/docker-machine</span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">$ docker-machine version</span><br><span class="line">docker-machine version <span class="number">0.6</span>.<span class="number">0</span>, build e27fb87</span><br></pre></td></tr></table></figure>
<ul>
<li>添加源<ul>
<li>把这行添加到 <code>/etc/apt/sources.list</code> 文件中 <code>deb http://download.virtualbox.org/virtualbox/debian trusty contrib</code> </li>
<li><code>wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add -</code></li>
</ul>
</li>
<li>更新并安装 <code>sudo apt-get update; sudo apt-get install virtualbox-5.0</code></li>
</ul>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2><p>然后是一些配置，先重设默认的虚拟机 </p>
<ul>
<li>删除原来的默认（如果有的话）<code>docker-machine rm default</code></li>
<li>创建新的默认虚拟机 <code>docker-machine create --driver virtualbox default</code>（这一步可能需要等一下，我用的是 Parallel Desktop 11，还需要在虚拟机设置中开启 CPU 虚拟化，主要是支持 vt-x）</li>
</ul>
<p>然后如果直接在菜单中选择 Virtual Box 的话，就会发现什么都没有，技巧是要在刚才的命令行中输入 <code>virtualbox</code>，然后就可以看到下面的界面：</p>
<p><img src="/images/14596481872848.jpg" alt="default 就是我们刚才创建的虚拟机"></p>
<p>在 Settings - Network 中选择 Port Forwarding，然后按照如图所示添加记录</p>
<p><img src="/images/14596485001418.jpg" alt=""></p>
<p>这里的 Host Port: 9234 记为 A，Guest Port: 9001 记为 B。然后就可以启动 docker 中老师提供的镜像了：</p>
<p>命令为 <code>docker run -it -p 9001:9000 cmusvsc/apachecmda:1.1</code>（需要下载一段时间，然后再解压一段时间），这里 9001 记为 C，9000 记为 D。</p>
<p>接着就会直接连接到 docker 中的虚拟机，从之后的图中可以看到命令行前面的内容也变化了。然后我们输入命令开启前端 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/Spring2016/ApacheCMDA-Frontend</span><br><span class="line">./activator run <span class="comment"># 相当于在 9000 端口开启</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/14596510005751.jpg" alt="开启前端"></p>
<p>不要关现在的终端，开启一个新的终端。仍然 <code>docker run -it -p 9001:9000 cmusvsc/apachecmda:1.1</code></p>
<p>等待一段时间后，继续走以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/Spring2016/ApacheCMDA-Backend</span><br><span class="line">./activator <span class="string">"run 9034"</span></span><br></pre></td></tr></table></figure>
<p>然后可以见到 </p>
<p><img src="/images/14596503095705.jpg" alt="开启后端"></p>
<p>然后等待一段时间（第一运行需要编译），就可以见到主页面了：</p>
<p><img src="/images/14596510450895.jpg" alt="主界面"></p>
<p>还记得前面的端口转发吗？这里解释一下：</p>
<ul>
<li>A，也就是 9234，是用户访问的端口号</li>
<li>B，也就是 9001，我们通过虚拟机的端口转发从 9234 转到了 9001</li>
<li>C，也就是 9001（这个命令中的 <code>docker run -it -p 9001:9000 cmusvsc/apachecmda:1.1</code>），是虚拟机继续转发的端口</li>
<li>D，也就是 9000（这个命令中的 <code>docker run -it -p 9001:9000 cmusvsc/apachecmda:1.1</code>），是 Docker 容器中接收请求的端口。</li>
</ul>
<p>也就是说，B 和 C 一定要一样，A 和 D 可以在命令中设置。至于为什么后端需要运行在 9034 端口，是因为前端和后端通过这个端口通讯（应该是写死在代码里的）</p>
<p>挂载主机数据卷到容器内，可以通过如下命令进行文件夹映射</p>
<p><code>docker run -it -p 9999:9999 -p 9001:9000 -v ~/localFolder:/sharedFolder cmusvsc/apachecmda:1.1</code></p>
<p>从容器内拷贝文件到主机上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出 container</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 复制 这个不知道为啥不行</span></span><br><span class="line">docker cp &lt;containerId&gt;:/file/path/within/container /host/path/target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载映射</span></span><br><span class="line">docker run -it -v /home/parallels/Documents/code:/home/code cmusvsc/apachecmda:<span class="number">1.1</span></span><br><span class="line"><span class="comment"># 复制</span></span><br><span class="line">cp -r Spring2016/* ./code/</span><br></pre></td></tr></table></figure>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/docker/docker" target="_blank" rel="external">开源代码</a></li>
<li><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a></li>
<li><a href="https://docs.docker.com/machine/install-machine/" target="_blank" rel="external">Install Docker Machine</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>借着课程的机会来了解一下 Docker，大部分内容来自官方文档以及课程指引。</p>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://wdxtub.com/tags/Docker/"/>
    
      <category term="容器" scheme="http://wdxtub.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第十二周 - 正趣果上果]]></title>
    <link href="http://wdxtub.com/2016/04/02/the-fun/"/>
    <id>http://wdxtub.com/2016/04/02/the-fun/</id>
    <published>2016-04-02T12:58:28.000Z</published>
    <updated>2016-04-02T14:44:39.000Z</updated>
    <content type="html"><![CDATA[<p>人生在世三万天，趣果有间孤独无解，苦练含笑半步颠。心怀啮雪大志愿，被人称作小可怜。本欲歃血定风月，乌飞兔走光阴只负尾生约。</p>
<a id="more"></a>
<hr>
<p>习惯了没有四季的广州，在四季分明的匹兹堡，真的能感受到生机勃勃的味道。不过这都是用六个月的寒冬换来的，如果可以选的话，我宁愿放弃四季。虽然温差依然可以二十多度，好歹下午是可以开开心心去跑跑步了。离开之前，多看几眼。</p>
<p>对一个地方的感情，其实和在这个地方交到的朋友和自己的改变程度有关。在执信我既经历了自我的重大转变，也交到了许多挚友，理所当然是我感情密度最高的地方。</p>
<p>相对来说，在匹兹堡的这段时间，以另外的方式认识了很多朋友，也真正完成了一直以来想要完成的转身。华丽不华丽不知道，虽然还有这样那样的小问题，总体来说我是满意的。</p>
<p>陆陆续续在收拾行李，发现其实也没有多少要带回去的东西，因为一直都是以『游子』的心态在过日子，大件的东西不买，可能用到=不用，带不走的直接送人，轻轻来轻轻走。年年毕业季，年年卖闲置，我觉得为了几块钱几十块钱劳神费力真不值得，还不如以交朋友的心态直接送给有缘人。</p>
<p>慢慢熟悉了英文歌的套路之后，现在又开始听中文歌了，但是口味变了不少。从陈粒 Jam 程璧常石磊到屠洪刚韩磊刘欢，除了旋律之外，越来越在意歌词讲不讲究。除了标题是陈粒的『正趣果上果』外，我还想安利几首：</p>
<blockquote>
<p>给少年的歌 程璧</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">月亮悄悄蒙上一层纱 夜云悄悄隆起崖</span><br><span class="line">曾经年少的我啊 曾经痴心这么想</span><br><span class="line">如果有一天 如果有一个人</span><br><span class="line">陪我一起看花开 陪我一起看流霞</span><br><span class="line">我就想为谁 为谁唱起这首歌</span><br><span class="line">一首少年的歌 一首为你写的歌</span><br></pre></td></tr></table></figure>
<blockquote>
<p>晴日共剪窗 程璧</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">庭前花木满 院外小径芳</span><br><span class="line">四时常相往 晴日共剪窗</span><br></pre></td></tr></table></figure>
<blockquote>
<p>七月上 Jam</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我想你就站在，站在大漠边疆</span><br><span class="line">我想你就站在，站在七月上</span><br><span class="line">我化尘埃飞扬，追寻赤裸逆翔</span><br><span class="line">奔去七月刑场，时间烧灼滚烫</span><br><span class="line">回忆撕毁臆想，路上行走匆忙</span><br><span class="line">难能可贵世上，散播留香磁场</span><br></pre></td></tr></table></figure>
<blockquote>
<p>老爸 常石磊</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我在牵挂 你也在牵挂 是你引我走天涯</span><br><span class="line">你慢慢老 我渐渐长大 是你让我别想家</span><br><span class="line">你在牵挂 我也在牵挂 是你教我志在四方 什么都别怕 </span><br><span class="line">我不在家 你好好保重吧</span><br></pre></td></tr></table></figure>
<p>未来的选择，和选择的未来，更多是计划之后的顺其自然。</p>
<p>正趣果上果，归依天中天，一道长死生，有无离二边。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>人生在世三万天，趣果有间孤独无解，苦练含笑半步颠。心怀啮雪大志愿，被人称作小可怜。本欲歃血定风月，乌飞兔走光阴只负尾生约。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="反思" scheme="http://wdxtub.com/tags/%E5%8F%8D%E6%80%9D/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="选择" scheme="http://wdxtub.com/tags/%E9%80%89%E6%8B%A9/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Prolog 快速入门]]></title>
    <link href="http://wdxtub.com/2016/04/01/prolog-first-step/"/>
    <id>http://wdxtub.com/2016/04/01/prolog-first-step/</id>
    <published>2016-04-02T01:02:45.000Z</published>
    <updated>2016-04-02T15:45:43.000Z</updated>
    <content type="html"><![CDATA[<p>Prolog 是一门声明式编程语言，也是最早成功的逻辑编程语言之一。只需提供 fact 和 inference，程序会替我们进行推断。甚至不需要知道怎么做，只要告诉计算机要做什么即可。比方说，用不到 20 行代码解决数独问题。</p>
<a id="more"></a>
<hr>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><ul>
<li>1972 年由 Alain Colmerauer 和 Phillipe Roussel 开发完成</li>
<li>基于数据库，数据由逻辑规则和关系组成</li>
<li>包含两个部分：一部分用于描述数据，另一部分用于查询数据</li>
</ul>
<p>在 Prolog 中，数据以逻辑规则的形式存在，下面是基本构建单元：</p>
<ul>
<li>事实：关于真实世界的基本断言（Babe 是一头猪，猪喜欢泥巴）</li>
<li>规则：关于真实世界中的一些事实的推论（如果一个动物是猪，那么它喜欢泥巴）</li>
<li>查询：关于真实世界的一个问题（Babe 喜欢泥巴吗）</li>
</ul>
<p>事实和规则被放入一个知识库(knowledge base)。Prolog 编译器将这个知识库编译成一种适于高效查询的形式。</p>
<p>这里我们在 ubuntu 下做实验，直接 <code>sudo apt-get install gprolog</code> 即可</p>
<h2 id="u7F16_u7A0B_u6A21_u578B"><a href="#u7F16_u7A0B_u6A21_u578B" class="headerlink" title="编程模型"></a>编程模型</h2><p>Prolog 中，一个词以小写字母开头，就是一个原子(atom)——类似于 Ruby 中的符号(symbol)的固定值，如果一个词以大写字母或下划线开头，那么它就是一个变量。变量的值可以改变，原则则不能。</p>
<p>下面是一个简单的例子，先创建一个文件（比如 <code>friends.pl</code>），输入以下内容</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">likes</span>(<span class="atom">wallace</span>, <span class="atom">cheese</span>).</span><br><span class="line"><span class="atom">likes</span>(<span class="atom">grommit</span>, <span class="atom">cheese</span>).</span><br><span class="line"><span class="atom">likes</span>(<span class="atom">wendolene</span>, <span class="atom">sheep</span>).</span><br><span class="line"></span><br><span class="line"><span class="atom">friend</span>(<span class="name">X</span>, <span class="name">Y</span>) :- \+(<span class="name">X</span> = <span class="name">Y</span>), <span class="atom">likes</span>(<span class="name">X</span>, <span class="name">Z</span>), <span class="atom">likes</span>(<span class="name">Y</span>, <span class="name">Z</span>).</span><br></pre></td></tr></table></figure>
<p>上面这个文件就是由事实和规则组成的知识库。前三条语句是事实，最后一条语句是一个规则。<code>wallace</code>, <code>grommit</code> 和 <code>wendolene</code> 都是原子，翻译过来就是</p>
<ul>
<li><code>wallace</code> 喜欢 <code>cheese</code></li>
<li><code>grommit</code> 喜欢 <code>cheese</code></li>
<li><code>wendolene</code> 喜欢 <code>sheep</code></li>
</ul>
<p>具体执行时，先输入 <code>gprolog</code>，然后输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- [<span class="string">'friends.pl'</span>].compiling /home/parallels/Documents/friends.pl <span class="keyword">for</span> byte code.../home/parallels/Documents/friends.pl compiled, <span class="number">5</span> lines <span class="built_in">read</span> - <span class="number">976</span> bytes written, <span class="number">6</span> ms(<span class="number">1</span> ms) yes</span><br></pre></td></tr></table></figure>
<p>除非 Prolog 在等待一个中间结果，否则都会用 <code>yes</code> 或者 <code>no</code> 来回应，这一句里文件加载成功，所以返回 <code>yes</code>。而 <code>| ?-</code> 是命令前面的提示符，类似于命令行前的 <code>$</code>，不过这么有个性的，我还是第一次见</p>
<p>然后我们就可以让计算机自己进行逻辑推断了，比如：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- <span class="atom">likes</span>(<span class="atom">wallace</span>, <span class="atom">sheep</span>).<span class="atom">no</span></span><br></pre></td></tr></table></figure>
<p>通过前面的条件我们知道，并不能推断出 wallace 喜欢 sheep，所以返回 no。</p>
<blockquote>
<p>基本推论和变量</p>
</blockquote>
<p>来测试以下前面的 <code>friend</code> 规则：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| ?- <span class="atom">friend</span>(<span class="atom">wallace</span>, <span class="atom">wallace</span>).<span class="atom">no</span></span><br><span class="line">| ?- <span class="atom">friend</span>(<span class="atom">grommit</span>, <span class="atom">wallace</span>).<span class="atom">yes</span>| ?- <span class="atom">friend</span>(<span class="atom">wallace</span>, <span class="atom">grommit</span>).<span class="atom">yes</span></span><br></pre></td></tr></table></figure>
<p>我们来用自然语言翻译一下 <code>friend</code> 规则</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">friend</span>(<span class="name">X</span>, <span class="name">Y</span>) :- \+(<span class="name">X</span> = <span class="name">Y</span>), <span class="atom">likes</span>(<span class="name">X</span>, <span class="name">Z</span>), <span class="atom">likes</span>(<span class="name">Y</span>, <span class="name">Z</span>).</span><br></pre></td></tr></table></figure>
<p>如果 <code>X</code> 和 <code>Y</code> 是朋友，那么 X 就不能与 Y 相同。<code>:-</code> 右边的称为子目标(subgoal)。<code>\+</code> 是逻辑取反操作，所以第一个子目标 <code>\+(X=Y)</code> 的意思是 <code>X</code> 不等于 <code>Y</code>。后面的 <code>likes</code> 语句表示如果 <code>X</code> 喜欢 <code>Z</code>，并且 <code>Y</code> 也喜欢 <code>Z</code>，所以后面的子目标就是在 <code>X</code> 不等于 <code>Y</code> 的情况下，他们还喜欢同一个 <code>Z</code>。我们可以试验以下其他的组合，来看看 prolog 的工作机制。</p>
<p>上面的代码是一个具有三个变量 <code>X</code>, <code>Y</code> 和 <code>Z</code> 的 Prolog 规则，称为 <code>friend/2</code> 表示参数有 2 个，这个规则有三个子目标（条件）。只有都满足的时候，规则才为真。</p>
<blockquote>
<p>填空</p>
</blockquote>
<p>我们还可以利用 prolog 查询出所有可能的匹配，这时候我们就需要一个变量，打开一个新的文件 <code>food.pl</code>，并填入下面的代码：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">food_type</span>(<span class="atom">velveeta</span>, <span class="atom">cheese</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">ritz</span>, <span class="atom">cracker</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">spam</span>, <span class="atom">meat</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">sausage</span>, <span class="atom">meat</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">jolt</span>, <span class="atom">soda</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">twinkie</span>, <span class="atom">dessert</span>).</span><br><span class="line"></span><br><span class="line"><span class="atom">flavor</span>(<span class="atom">sweet</span>, <span class="atom">dessert</span>).</span><br><span class="line"><span class="atom">flavor</span>(<span class="atom">savory</span>, <span class="atom">meat</span>).</span><br><span class="line"><span class="atom">flavor</span>(<span class="atom">savory</span>, <span class="atom">cheese</span>).</span><br><span class="line"><span class="atom">flavor</span>(<span class="atom">sweet</span>, <span class="atom">soda</span>).</span><br><span class="line"></span><br><span class="line"><span class="atom">food_flavor</span>(<span class="name">X</span>, <span class="name">Y</span>) :- <span class="atom">food_type</span>(<span class="name">X</span>, <span class="name">Z</span>), <span class="atom">flavor</span>(<span class="name">Y</span>, <span class="name">Z</span>).</span><br></pre></td></tr></table></figure>
<p>其中 <code>food_type(velveeta, cheese)</code> 意思是 <code>velveeta</code> 属于 <code>cheese</code> 类食物；而 <code>flavor(sweet, dessert)</code> 则表示 <code>sweet</code> 是 <code>dessert</code> 的味道。最后的规则的意思是如果食物 <code>X</code> 属于类别 <code>Z</code> 并且 <code>Z</code> 的味道是 <code>Y</code>，那么食物 <code>X</code> 具有 <code>food_flavor</code> <code>Y</code>。编译一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- [<span class="string">'food.pl'</span>].compiling /home/parallels/Documents/food.pl <span class="keyword">for</span> byte code.../home/parallels/Documents/food.pl compiled, <span class="number">13</span> lines <span class="built_in">read</span> - <span class="number">1536</span> bytes written, <span class="number">5</span> msyes</span><br></pre></td></tr></table></figure>
<p>然后我们来问几个问题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- food_<span class="built_in">type</span>(What, meat).What = spam ? ;What = sausage ? ;no</span><br></pre></td></tr></table></figure>
<p>这里 prolog 会先找到 <code>spam</code>，然后输入 <code>;</code>，prolog 就会继续寻找下一个，也就是返回 <code>sausage</code>，继续输入 <code>;</code>，会发现返回了 <code>no</code>，这表示在未经更多计算的情况下不能判断是否还有更多选项。</p>
<p>另一个问题可以是 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- food_flavor(What, savory).What = velveeta ? ;What = spam ? ;What = sausage ? ;no</span><br></pre></td></tr></table></figure>
<p>这里要注意 <code>food_flavor(X,Y)</code> 是一个规则，而不是事实，逻辑引擎会遍历所有使目标为真的可能组合。</p>
<h2 id="u4E60_u9898"><a href="#u4E60_u9898" class="headerlink" title="习题"></a>习题</h2><h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://fengdidi.github.io/blog/2011/11/15/di-1zhang-pei-zhi-kai-fa-huan-jing/" target="_blank" rel="external">笨办法学Prolog</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Prolog 是一门声明式编程语言，也是最早成功的逻辑编程语言之一。只需提供 fact 和 inference，程序会替我们进行推断。甚至不需要知道怎么做，只要告诉计算机要做什么即可。比方说，用不到 20 行代码解决数独问题。</p>]]>
    
    </summary>
    
      <category term="Prolog" scheme="http://wdxtub.com/tags/Prolog/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="语言" scheme="http://wdxtub.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Io 快速入门]]></title>
    <link href="http://wdxtub.com/2016/04/01/io-first-step/"/>
    <id>http://wdxtub.com/2016/04/01/io-first-step/</id>
    <published>2016-04-01T15:33:13.000Z</published>
    <updated>2016-04-02T01:02:26.000Z</updated>
    <content type="html"><![CDATA[<p>原型语言我接触得其实非常少，Io 和 JavaScript/Lua 一样，每个对象都是另一个对象的复制品。这部分暂时我的兴趣不是特别大，所以简要记录一下，以后有兴趣再学。</p>
<a id="more"></a>
<hr>
<ul>
<li>Io 语言于 2002 年由 Steve Dekorte 发明</li>
<li>基于原型的语言，每个对象都不是类的复制品</li>
<li>带有微型虚拟机和丰富并发特性的可嵌入语言来推广</li>
<li>拥有大量可定制语法和函数，以及强有力的并发模型</li>
<li>万事万物皆为消息，且每条消息都会返回另一接收消息的对象</li>
<li>没有关键字，只有少量在行为上接近于关键字的字符</li>
</ul>
<h2 id="u7F16_u7A0B_u6A21_u578B"><a href="#u7F16_u7A0B_u6A21_u578B" class="headerlink" title="编程模型"></a>编程模型</h2><blockquote>
<p>优势</p>
</blockquote>
<ul>
<li>灵活，可以快速创建出想要的语法</li>
<li>强大的、现代的并发库</li>
<li>占用空间小，但功能强大且灵活，应用在嵌入式领域</li>
<li>语法简洁，灵活</li>
</ul>
<blockquote>
<p>劣势</p>
</blockquote>
<ul>
<li>社区规模小</li>
<li>单线程性能较差</li>
</ul>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://iolanguage.org/" target="_blank" rel="external">官方网站</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>原型语言我接触得其实非常少，Io 和 JavaScript/Lua 一样，每个对象都是另一个对象的复制品。这部分暂时我的兴趣不是特别大，所以简要记录一下，以后有兴趣再学。</p>]]>
    
    </summary>
    
      <category term="Io" scheme="http://wdxtub.com/tags/Io/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="语言" scheme="http://wdxtub.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聪明人的枷锁]]></title>
    <link href="http://wdxtub.com/2016/03/31/smart-lock/"/>
    <id>http://wdxtub.com/2016/03/31/smart-lock/</id>
    <published>2016-03-31T18:31:02.000Z</published>
    <updated>2016-04-01T04:23:31.000Z</updated>
    <content type="html"><![CDATA[<p>小聪明到大智慧之间，有一条看不见的横沟，只能用天赋、坚持和勤奋来填。如果硬要说有技巧，恐怕就是『元学习』、『元思考』、『元实践』和『元创造』。</p>
<a id="more"></a>
<hr>
<h2 id="u806A_u660E_u4E86_u5417_uFF1F"><a href="#u806A_u660E_u4E86_u5417_uFF1F" class="headerlink" title="聪明了吗？"></a>聪明了吗？</h2><p>聪明固然是一件好事，但是一旦被别人被自己贴上了『聪明人』的标签，也就戴上了枷锁。外在的枷锁随着时间的推移逐渐会被移去，但是内在的枷锁，想要解开，就没那么容易了。</p>
<p>内在的枷锁主要体现在以下两个方面：</p>
<ol>
<li>做事情凭借直觉，大多数情况下都能完成得不错。可是直觉也有范围，一旦超出，因为平时没有培养正确做事的能力，往往不尽如人意。</li>
<li>做事情依赖个人，在学生时代作业考试甚至是小组项目都可以自己扛，可是个人能力再大也有范围，一旦超出，因为平时没有培养合作的能力，常常功亏一篑。</li>
</ol>
<p>直觉是可以培养的，合作是可以学习的。小聪明若是想要转变为大智慧，得利用自己的聪明，用不依赖聪明的方法，在正确做事的前提下，扩大自己的直觉范围，优化自己的合作机制。</p>
<p>遗憾的是，市面上大部分的书，到这里就结束了，剩下的不是猛灌鸡汤，就是列举一堆『看起来有用但是实际没用』的技巧，基本属于作者自己都没想明白就出来忽悠。</p>
<p>这篇文章想说的就是各类畅销书没说清楚的东西：</p>
<ol>
<li>正确学习的方法</li>
<li>正确思考的方法</li>
<li>正确实践的方法</li>
<li>正确创造的方法</li>
</ol>
<p>就像大贤得出世再入世一样，想要成为『大智慧』，首先得有点『小聪明』。注意，这里的『小聪明』和大家通常理解的不一样，指的是相对于『大』智慧的『小』聪明，而不是原来略带贬义的意思。成为『小聪明』的第一步，就是认清自己的思维模式，要想以聪明的方式思考问题，就得善用自己的长处，认识并完善自己的弱点。</p>
<p>另外正如《穷查理宝典》中所说的那样：『我们必须掌握许多知识，让它们在头脑中形成一个思维框架，在随后的日子里能自动地运用它们。与之相反，如果不努力去实践这种跨科学的方法，许多最聪明的人只会取得中等成就，甚至生活在阴影中』。</p>
<h2 id="u6B63_u786E_u5B66_u4E60"><a href="#u6B63_u786E_u5B66_u4E60" class="headerlink" title="正确学习"></a>正确学习</h2><blockquote>
<p>Data is not information. Information is not knowledge. Knowledge is not expertise. Expertise is not execution.</p>
</blockquote>
<p>广义来说，所有的学习都是自学，毕竟没有任何一种科技可以直接把知识『灌输』到我们脑中，即使有老师，我们仍然需要自己去学习。当我仔细审视『自学能力』的时候，发现有以下几个重要的组成部分：</p>
<ul>
<li>阅读能力 - 基础技能 <ul>
<li>广泛阅读，略读结合精读</li>
</ul>
</li>
<li>理解能力 - 在阅读能力基础上的初级技能<ul>
<li>提取核心思想，按照章节逻辑堆阅读进行总结</li>
</ul>
</li>
<li>检索能力 - 在理解能力基础上的中级技能<ul>
<li>围绕核心思想，寻找相关材料，从多方面看问题</li>
</ul>
</li>
<li>写作能力 - 由输入到输出的重要技能<ul>
<li>写作实际上是一个思考的过程。把思维中的想法用文字写下来，本身就是一个整理、分类的过程</li>
</ul>
</li>
<li>思考能力 - 在写作能力基础上的高级技能<ul>
<li>勤于琢磨思考该事情的目标、实质、意义，而后再据此去思考做好这件事情的方法，并挖掘出更深层次的意义</li>
</ul>
</li>
<li>实践能力 - 把学习转化为价值的核心技能<ul>
<li>能够举一反三，能把所学应用于实践，并根据实际情况调整前进的方向</li>
</ul>
</li>
</ul>
<p>一定要脱离『学霸/学渣』的思维定式。学校的教育体系本来就是有缺陷的，我们需要做的就是通过自学能力，去弥补那些自己感兴趣但学校从未教授的东西。这样看来，我们应该成为『沙盒游戏』中的『自由探索者』，不要限定自己的角色，也不要被学校、专业所限制。多学科视角的思考方法能产生某种「共奏效应」，发现原本无法发现的深度见解。</p>
<p>学习关于学习本身的知识，就是元学习。</p>
<h2 id="u6B63_u786E_u601D_u8003"><a href="#u6B63_u786E_u601D_u8003" class="headerlink" title="正确思考"></a>正确思考</h2><blockquote>
<p>So avoid the temptation to master all the skills you need before taking on a challenge. </p>
</blockquote>
<p>应试教育，或者说以考试制度为核心的教育体系中，学生会自然而然被灌输『标准答案』的概念，写对有分写错没分，每个问题对应一个标准答案就被植入到我们的脑中。小聪明可能可以每次都填上标准答案，但大智慧会以标准答案为起点，开始探索的旅程。</p>
<p>差异在哪里？在于『思考无固定答案』的习惯。把纸上的问题映射到现实问题中，培养独立思考的能力，得到自己的答案。这里有一点需要强调，就是『独立』。思考时不要依靠网络，毕竟思考是思考，搜索是搜索。如果总是依赖网络，一旦遇到搜不出来的情况，就很难找到解决办法了。</p>
<p>当然，在有了自己的思考之后，还是需要借助搜索的力量，更加全面地看待问题。这个过程中千万不能『囫囵吞枣』，信息需要经过考虑、推敲后才能转化为想法。不同人看待同样的信息角度不同，得出的结论也不同，相信自己的判断，确认信息，独立思考，不能偷懒。我们还需要时刻拥抱不确定性，越是不习惯，越是要让自己站在正反两面去思考分析问题。</p>
<p>思考的时候一定要有的放矢，意识流看起来很美，但是不利于交流，思考的输出应当是他人容易重视、记住和接受的，也就是要有：</p>
<ul>
<li>逻辑推理能力 - 论点分解或总结</li>
<li>时间管理能力 - 区分优先性</li>
<li>交流能力 - 加强说服力</li>
</ul>
<p>至于思考的结果是对是错，反而不是重要的。一旦出现错误时，要学会追踪当初的思维轨迹，找到哪里出了差错，经验——错误的归纳模式是人类最根本也最可靠的学习方法。</p>
<p>思考关于思考本身的东西，就是元思考。</p>
<h2 id="u6B63_u786E_u5B9E_u8DF5"><a href="#u6B63_u786E_u5B9E_u8DF5" class="headerlink" title="正确实践"></a>正确实践</h2><blockquote>
<p>Whenever you can, as long as the water’s not too far over your head, just jump in, and figure it out as you go.</p>
</blockquote>
<p>知行合一，可能是正确实践的终极奥义。在实践的过程中，一定要时不时问自己下面几个问题：</p>
<ul>
<li>正在解决的问题是我需要解决的问题吗？<ul>
<li>沿着正确的方向前行通常并不会花很多时间，方向不清的情况下走冤枉路却是白费工夫</li>
</ul>
</li>
<li>为什么要这样做，这是最好的方式吗？<ul>
<li>实践过程中会出各种小差错，要从这些差错中学习并提高实践能力</li>
</ul>
</li>
<li>能不能利用前辈的经验减少重复劳动？<ul>
<li>太阳底下没有新鲜事，很多经验是共同的</li>
</ul>
</li>
<li>可能会遇到什么困难，对应的尝试思路是什么？<ul>
<li>遇到困难的时候已经有了准备，就不会慌乱</li>
</ul>
</li>
<li>信息流动顺畅吗？是不是团队的每个成员都真正参与了进来？<ul>
<li>让每个人都清楚明白，就是流程的『可视化』，能让工作更简洁、更有效率</li>
</ul>
</li>
</ul>
<p>实践是学习和思考的演戏场，前面提到的各种能力和技巧，都可以运用到实践中来。当我们遇到问题时，最高效的做法是：</p>
<ol>
<li>认识问题。思考问题背后的东西，背景、事物、条件、关系。通过重新定义问题本身来探索问题的本质。</li>
<li>独立思考。先不借助书本和网络，大胆假设，小心求证。试错的目的就是从中得到意外的收获。现实不比理论，遇到的问题往往具体而特殊，几乎没有什么现成的经验，还是那句话：主动思考大胆假设小心求证。书本和网络的资料可能会给人启发，但是也是枷锁，框住想象力。</li>
<li>全面观测。这个时候可以在书本或网络中找寻相关内容，可能的话尽量与他人交换想法。认知本身就是主观的，横看成岭侧成峰，要全面观测，才能得到更接近『真实』的认知。也就是主观的客观化。</li>
<li>形成框架。简单来说，就是要有自己的『套路』，不同类型的问题有不同的解法，通过具体的实践不断迭代优化自己的理论与套路。</li>
<li>魔鬼细节。仰望星空同时也要脚踏实地，实践难免把手弄脏，但也只有把手弄脏才能得到完备的解决方案，继而解决复杂的现实问题。</li>
<li>每次处理问题请重复上述步骤</li>
</ol>
<p>实践是问题导向的，不能为了做而做，面对动态世界的复杂系统，只有以未知作为起点进行思考，才可能拨开迷雾找到答案。</p>
<p>实践关于实践本身的东西，就是元实践。</p>
<h2 id="u6B63_u786E_u521B_u9020"><a href="#u6B63_u786E_u521B_u9020" class="headerlink" title="正确创造"></a>正确创造</h2><blockquote>
<p>The purpose of education is to provide you the toolsets that enable you take the data around you, make sense out of it and find out a way to create something productive out of that. As the amount of data around us explode, the necessity for education grows.</p>
</blockquote>
<p>创造性这个东西，说流淌在血液中一点也不为过。我们骨子里传下来的智慧、毅力、勤勉、奋发当然不能丢，但是更应该再来点浪漫主义，从超越功利的角度找回精神自主性，每个人都要是特立独行的个体，而不是流水线生产出来的千人一面脸谱化。</p>
<p>多元化的生活态度与人生哲学，对生活本身的富于诗情的理解，才能真正让自己『立体』，有广度也有深度，才能创造出更多新东西，而不是循规蹈矩墨守成规。</p>
<p>『当幸福来敲门』这个翻译我觉得特别好，很多东西不是去找就能找得到的，而是把该做好的都做好，然后静静等待那个时刻的到来。创造就是如此，尤其是下面提到的『酝酿』阶段，就是『当创意来敲门』。但是需要注意的是，不同阶段有不同的侧重点：</p>
<ul>
<li>准备阶段。搜集相关信息，缩小问题范围，直到看到障碍</li>
<li>酝酿阶段。将自己完全浸在问题里，运用潜意识思考，不要有寻找解决方案的压力</li>
<li>启发阶段。用直觉或有意识的思考处理问题，用直觉或洞察力来形成可能的解决方案</li>
<li>验证阶段。对可能的解决方案进行合理性检验，验证方案的正确性，并最终打磨完整</li>
</ul>
<p>创造关于创造本身的东西，就是元创造。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>Heroes inspire us for many reasons: they make tough decisions, they keep going and they get done what matters. But there’s another reason we love our heroes. Inside us all, we know we have the power to become one ourselves.</p>
</blockquote>
<p>英雄人物之所以能激励我们，是因为他们能够作出艰难的抉择，他们永不言弃，他们总能做出惊天动地的事情。但我们之所以崇拜英雄还有另一个原因。在内心深处，我们都相信自己有能力成为他们。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>小聪明到大智慧之间，有一条看不见的横沟，只能用天赋、坚持和勤奋来填。如果硬要说有技巧，恐怕就是『元学习』、『元思考』、『元实践』和『元创造』。</p>]]>
    
    </summary>
    
      <category term="创造" scheme="http://wdxtub.com/tags/%E5%88%9B%E9%80%A0/"/>
    
      <category term="感觉" scheme="http://wdxtub.com/tags/%E6%84%9F%E8%A7%89/"/>
    
      <category term="方法" scheme="http://wdxtub.com/tags/%E6%96%B9%E6%B3%95/"/>
    
      <category term="聪明" scheme="http://wdxtub.com/tags/%E8%81%AA%E6%98%8E/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 反思课 5 实时服务测试的策略与思考]]></title>
    <link href="http://wdxtub.com/2016/03/31/cc-rethink-5/"/>
    <id>http://wdxtub.com/2016/03/31/cc-rethink-5/</id>
    <published>2016-03-31T10:02:04.000Z</published>
    <updated>2016-03-31T11:19:15.000Z</updated>
    <content type="html"><![CDATA[<p>昨天我们的 Twitter Analysis Service 采用了新的测试方式，在大约两个半小时的时间内进行各类请求的压力测试，以确保系统能够应对复杂请求。虽然我做的部分表现非常糟糕，但是从中学到了很多东西，知耻而后勇。</p>
<a id="more"></a>
<hr>
<p>总得来说，因为有靠谱的队友（手动重启服务器几十次），整个测试不至于滑铁卢，但是这也暴露了我们在前后端设计处理的各种问题，接下来逐条分析。</p>
<blockquote>
<p>架构设计</p>
</blockquote>
<p>因为整套系统目前有 6 台机器，之前测试的时候使用 1 台前端 + 4 台后端是行得通的。但是因为之前并没有过多留意前后端机器的硬件利用情况（基本凭感觉），所以想当然得觉得后端是瓶颈（对 HBase 的特性不大了解，估计错误）。事实狠狠打了我的脸，前端的 CPU 利用率居高不下（接近满负荷运载）而后端的利用率分布不均（有的节点 60% 的 CPU 使用率，有的节点甚至只有 20%）。</p>
<p>当我意识到这个问题的时候，只能眼睁睁看着唯一的一台前端苦苦支撑，爆内存，和 HBase 的连接断开，每次都只能手动重启服务器（但是因为 CPU 占用满了，重启也需要几分钟）。这极大影响了正确率和吞吐量，最终得到的分数自然少得可怜。</p>
<p>参考其他组的先进经验，前端使用 ELB(负载均衡) + 2 台机器，后端使用 1(master) + 3(slave) 的模式可能是最科学的，这样可以尽可能得减轻前端单机压力。</p>
<blockquote>
<p>硬件监控</p>
</blockquote>
<p>好消息是，在同学的帮助之下，终于意识到了『监控』的重要性。虽然不难（每台机器开着 <code>top</code> 查看使用率即可），但是有没有这个意识就有天壤之别。简单粗暴来说，哪怕只通过 CPU 利用率一个指标，就能大概估计目前的硬件使用情况，可是我之前竟然拍脑袋想当然总觉得硬件不是问题。</p>
<p>这是很好的教训，我要吸取经验。</p>
<p>痛定思痛，至少可以从其他多个角度来利用监控数据：</p>
<ul>
<li>了解不同的监控命令，深入理解不同监控参数的意义，编写脚本抓取重点关注的数据</li>
<li>结合 CPU 利用率 + 内存利用率来优化代码，力求达到充分利用 CPU 以及内存</li>
<li>观察 CPU / 内存 / 网络的相关数据，来确定具体的瓶颈所在，然后对症下药，寻找可能的解决方案</li>
<li>在监控脚本的基础上，可以设定一些阈值，自动化提醒和记录日志（不用自己时刻盯着屏幕了）</li>
<li>提醒内容：CPU / 内存 / 网络满载警报，或者不均衡使用警报等</li>
<li>日志内容：在出现警报的时候，需要记录相关请求，查看日志的时候能够快速掌握上下文</li>
</ul>
<blockquote>
<p>数据统计</p>
</blockquote>
<p>一般来说，不同的 web 服务，用户的请求模式总体来说是有一定规律的。对于 Twitter 数据的分析，就有热门/冷门的用户/hashtag/单词/时间段（比方说有重大事件发生的日子，tweet 的数量可能会更多）</p>
<p>我们应该根据具体的需求，通过统计大致了解数据分布。比方说其中一个请求是返回某用户包含某 hashtag 的 tweet，那么我们最好需要了解哪些用户热门，哪些 hashtag 热门，然后根据这些特点来进行数据库 schema 的设计（就是 rowkey 和 value）以及数据库中不同 region 在不同 regionserver 的平衡。之前的设计方式会导致有些 region 访问次数非常多，有些却非常少，这样就没有充分利用 HBase 的能力。</p>
<p>这部分具体怎么实现还需要通过不断实践来摸索，但是想要获得更好的性能，总是逃不开这步的。</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>这一部分就是压力测试下暴露的代码问题了，主要是以下几点：</p>
<ul>
<li>请求的参数要进行检查，很可能为空。但是写起来的语法很麻烦，这个时候就开始怀念 Swift 中的语法糖了</li>
<li>对于 HBase 1.0 来说，连接池几乎没用，因为共用 HConnection 的 HTableInterface 并不会并行</li>
<li>线程池也不大需要，undertow 框架基本能够处理好，就不要画蛇添足（容易爆内存）</li>
</ul>
<p>最后写三句，从错误中学习比实现 web 服务本身更有意义，这是第二句，第三句也写完了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天我们的 Twitter Analysis Service 采用了新的测试方式，在大约两个半小时的时间内进行各类请求的压力测试，以确保系统能够应对复杂请求。虽然我做的部分表现非常糟糕，但是从中学到了很多东西，知耻而后勇。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="优化" scheme="http://wdxtub.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[tmux 指南]]></title>
    <link href="http://wdxtub.com/2016/03/30/tmux-guide/"/>
    <id>http://wdxtub.com/2016/03/30/tmux-guide/</id>
    <published>2016-03-30T22:55:27.000Z</published>
    <updated>2016-03-31T04:01:21.000Z</updated>
    <content type="html"><![CDATA[<p>今天试用了一下 tmux，发现简直是神器！以前还傻傻不停开窗口，现在一个窗口就可以都搞定啦！</p>
<a id="more"></a>
<hr>
<p>Tmux 简单来说就是终端里的『窗口管理器』，如果我使用终端登录到远程主机并运行前台程序，那么这个窗口等于就被占用了，想要看一下 CPU 的使用率，就得再连接一次。但是如果在远程主机上运行 tmux，那么就可以开启多个控制台（类似于窗口），相当高效，比方说可以像下面这样：</p>
<p><img src="/images/14593788571503.jpg" alt="一个面板监视服务器，一个面板查看硬件状况"></p>
<p>需要注意的是，这里是在我本地使用 tmux，最好在远程主机也安装 tmux，这样就只需要连接一次。</p>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>前面提到的窗口管理只是 tmux 功能的一小部分，另一个很有用的功能就是，连接到远程主机之后，一旦断开，那么当前账户登录的任务就被取消了，但是使用 tmux 可以在断开之后继续工作，下次登录可以查看。其他的功能还有：</p>
<ol>
<li>窗口切换，每个窗口里还可以分割面板</li>
<li>配置方便，可以使用脚本</li>
<li>类似 vim 的双层操作逻辑</li>
<li>复制粘贴缓冲区</li>
</ol>
<p>安装的话也很简单，在 mac 下直接 <code>brew install tmux</code>（前提需要安装 homebrew），ubuntu 下则直接 <code>sudo apt-get install tmux</code></p>
<p>在终端中输入 <code>tmux</code> 就可以打开一个新的 tmux session，tmux 的所有操作必须先使用一个前缀键（默认是 <code>ctrl + b</code>）进入命令模式，或者说进入控制台，就像 vim 中的 esc。</p>
<h2 id="u57FA_u672C_u64CD_u4F5C"><a href="#u57FA_u672C_u64CD_u4F5C" class="headerlink" title="基本操作"></a>基本操作</h2><blockquote>
<p>信息查询</p>
</blockquote>
<ul>
<li><code>tmux list-keys</code> 列出所有可以的快捷键和其运行的 tmux 命令</li>
<li><code>tmux list-commands</code> 列出所有的 tmux 命令及其参数</li>
<li><code>tmux info</code> 流出所有的 session, window, pane, 运行的进程号，等。</li>
</ul>
<blockquote>
<p>窗口控制</p>
</blockquote>
<p>先来看看在 tmux 之外如何进行控制</p>
<ul>
<li>session 会话：session是一个特定的终端组合。输入tmux就可以打开一个新的session<ul>
<li><code>tmux new -s session_name</code> 创建一个叫做 <code>session_name</code> 的 tmux session</li>
<li><code>tmux attach -t session_name</code> 重新开启叫做 <code>session_name</code> 的 tmux session</li>
<li><code>tmux switch -t session_name</code> 转换到叫做 <code>session_name</code> 的 tmux session</li>
<li><code>tmux list-sessions</code> / <code>tmux ls</code> 列出现有的所有 session</li>
<li><code>tmux detach</code> 离开当前开启的 session</li>
</ul>
</li>
<li>window 窗口：session 中可以有不同的 window（但是同时只能看到一个 window）<ul>
<li><code>tmux new-window</code> 创建一个新的 window</li>
<li><code>tmux list-windows</code> </li>
<li><code>tmux select-window -t :0-9</code> 根据索引转到该 window</li>
<li><code>tmux rename-window</code> 重命名当前 window</li>
</ul>
</li>
<li>pane 面板：window 中可以有不同的 pane（可以把 window 分成不同的部分）<ul>
<li><code>tmux split-window</code> 将 window 垂直划分为两个 pane</li>
<li><code>tmux split-window -h</code> 将 window 水平划分为两个 pane</li>
<li><code>tmux swap-pane -[UDLR]</code> 在指定的方向交换 pane</li>
<li><code>tmux select-pane -[UDLR]</code> 在指定的方向选择下一个 pane</li>
</ul>
</li>
</ul>
<p>更常用的是在 tmux 中直接通过默认前缀 <code>ctrl + b</code> 之后输入对应命令来操作，具体如下（这里只列出输入默认前缀之后需要输入的操作）：</p>
<blockquote>
<p>基本操作</p>
</blockquote>
<ul>
<li><code>?</code> 列出所有快捷键；按q返回</li>
<li><code>d</code> 脱离当前会话,可暂时返回Shell界面</li>
<li><code>s</code> 选择并切换会话；在同时开启了多个会话时使用</li>
<li><code>D</code> 选择要脱离的会话；在同时开启了多个会话时使用</li>
<li><code>:</code> 进入命令行模式；此时可输入支持的命令，例如 <code>kill-server</code> 关闭所有tmux会话</li>
<li><code>[</code> 复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q/Esc退出</li>
<li><code>]</code> 进入粘贴模式，粘贴之前复制的内容，按q/Esc退出</li>
<li><code>~</code> 列出提示信息缓存；其中包含了之前tmux返回的各种提示信息</li>
<li><code>t</code> 显示当前的时间</li>
<li><code>ctrl + z</code> 挂起当前会话</li>
</ul>
<blockquote>
<p>窗口操作</p>
</blockquote>
<ul>
<li><code>c</code> 创建新窗口</li>
<li><code>&amp;</code> 关闭当前窗口</li>
<li><code>[0-9]</code> 数字键切换到指定窗口</li>
<li><code>p</code> 切换至上一窗口</li>
<li><code>n</code> 切换至下一窗口</li>
<li><code>l</code> 前后窗口间互相切换</li>
<li><code>w</code> 通过窗口列表切换窗口</li>
<li><code>,</code> 重命名当前窗口，便于识别</li>
<li><code>.</code> 修改当前窗口编号，相当于重新排序</li>
<li><code>f</code> 在所有窗口中查找关键词，便于窗口多了切换</li>
</ul>
<blockquote>
<p>面板操作</p>
</blockquote>
<ul>
<li><code>&quot;</code> 将当前面板上下分屏（我自己改成了 <code>|</code>）</li>
<li><code>%</code> 将当前面板左右分屏（我自己改成了 <code>-</code>）</li>
<li><code>x</code> 关闭当前分屏</li>
<li><code>!</code> 将当前面板置于新窗口,即新建一个窗口,其中仅包含当前面板</li>
<li><code>ctrl+方向键</code> 以1个单元格为单位移动边缘以调整当前面板大小</li>
<li><code>alt+方向键</code> 以5个单元格为单位移动边缘以调整当前面板大小</li>
<li><code>q</code> 显示面板编号</li>
<li><code>o</code> 选择当前窗口中下一个面板</li>
<li><code>方向键</code> 移动光标选择对应面板</li>
<li><code>{</code> 向前置换当前面板</li>
<li><code>}</code> 向后置换当前面板</li>
<li><code>alt+o</code> 逆时针旋转当前窗口的面板</li>
<li><code>ctrl+o</code> 顺时针旋转当前窗口的面板</li>
<li><code>z</code> 最大化当前所在面板</li>
<li><code>page up</code> 向上滚动屏幕，q 退出</li>
<li><code>page down</code> 向下滚动屏幕，q 退出</li>
</ul>
<p>因为 iTerm2 的支持，很多切换的操作可以直接用鼠标进行，非常方便。具体大家可以自己尝试一下。</p>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2><p>我们可以先进行一些简单的配置，修改 <code>~/.tmux.conf</code> 即可，让整个使用更方便。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#<span class="comment">-- base --#</span></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">default</span>-terminal <span class="string">"screen-256color"</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> display-<span class="keyword">time</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> history-<span class="keyword">limit</span> <span class="number">10000</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> base-<span class="keyword">index</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> pane-base-<span class="keyword">index</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> -s escape-<span class="keyword">time</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> mouse <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line">#<span class="comment">-- bindkeys --#</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">split</span> windows <span class="keyword">like</span> vim.  - Note: vim<span class="string">'s definition of a horizontal/vertical split is reversed from tmux'</span>s</span><br><span class="line"></span><br><span class="line">unbind s</span><br><span class="line">bind s <span class="keyword">split</span>-window -v</span><br><span class="line">bind S <span class="keyword">split</span>-window -v -<span class="keyword">l</span> <span class="number">40</span></span><br><span class="line">bind v <span class="keyword">split</span>-window -h</span><br><span class="line">bind V <span class="keyword">split</span>-window -h -<span class="keyword">l</span> <span class="number">120</span></span><br><span class="line"></span><br><span class="line"># navigate panes <span class="keyword">with</span> hjkl</span><br><span class="line">bind h <span class="keyword">select</span>-pane -<span class="keyword">L</span></span><br><span class="line">bind j <span class="keyword">select</span>-pane -<span class="keyword">D</span></span><br><span class="line">bind <span class="keyword">k</span> <span class="keyword">select</span>-pane -U</span><br><span class="line">bind <span class="keyword">l</span> <span class="keyword">select</span>-pane -R</span><br><span class="line"></span><br><span class="line"># <span class="keyword">key</span> bindings <span class="keyword">for</span> horizontal <span class="keyword">and</span> vertical panes</span><br><span class="line">unbind %</span><br><span class="line">bind | <span class="keyword">split</span>-window -h      # 使用|竖屏，方便分屏</span><br><span class="line">unbind <span class="string">'"'</span></span><br><span class="line">bind - <span class="keyword">split</span>-window -v      # 使用-横屏，方便分屏</span><br><span class="line"></span><br><span class="line"># swap panes</span><br><span class="line">bind ^u swapp -U</span><br><span class="line">bind ^<span class="keyword">d</span> swapp -<span class="keyword">D</span></span><br><span class="line"></span><br><span class="line">bind q killp</span><br><span class="line">bind ^<span class="keyword">e</span> <span class="keyword">last</span></span><br><span class="line"></span><br><span class="line">unbind r</span><br><span class="line">bind r <span class="keyword">source</span>-<span class="keyword">file</span> ~/.tmux.conf \;</span> display "Configuration Reloaded!"</span><br><span class="line"></span><br><span class="line">#<span class="comment">-- statusbar --#</span></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-justify centre</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">left</span> <span class="string">"#[fg=red]s#S:w#I.p#P#[default]"</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">right</span> <span class="string">'[#(whoami)#(date +" %m-%d %H:%M ")]'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">left</span>-<span class="keyword">attr</span> bright</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">left</span>-<span class="keyword">length</span> <span class="number">120</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">right</span>-<span class="keyword">length</span> <span class="number">120</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-utf8 <span class="keyword">on</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="built_in">interval</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> visual-activity <span class="keyword">on</span></span><br><span class="line">setw -<span class="keyword">g</span> monitor-activity <span class="keyword">on</span></span><br><span class="line">setw -<span class="keyword">g</span> <span class="keyword">automatic</span>-<span class="keyword">rename</span> <span class="keyword">off</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">default</span> statusbar colors</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-bg colour235 #base02</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-fg colour136 #yellow</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">attr</span> <span class="keyword">default</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">default</span> window title colors</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-fg colour244</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-bg <span class="keyword">default</span></span><br><span class="line">#setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">attr</span> dim</span><br><span class="line"></span><br><span class="line"># active window title colors</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-fg colour166 #orange</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-bg <span class="keyword">default</span></span><br><span class="line">#setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-<span class="keyword">attr</span> bright</span><br><span class="line"></span><br><span class="line"># window title <span class="keyword">string</span> (uses statusbar <span class="keyword">variables</span>)</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">set</span>-titles-<span class="keyword">string</span> <span class="string">'#T'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-justify <span class="string">"centre"</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">format</span> <span class="string">'#I #W'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-<span class="keyword">format</span> <span class="string">' #I #W '</span></span><br><span class="line"></span><br><span class="line"># pane border</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> pane-active-border-fg <span class="string">'#55ff55'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> pane-border-fg <span class="string">'#555555'</span></span><br><span class="line"></span><br><span class="line"># message <span class="built_in">text</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> message-bg colour235 #base02</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> message-fg colour166 #orange</span><br><span class="line"></span><br><span class="line"># pane <span class="built_in">number</span> display</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> display-panes-active-colour colour33 #blue</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> display-panes-colour colour166 #orange</span><br><span class="line"></span><br><span class="line"># clock</span><br><span class="line">setw -<span class="keyword">g</span> clock-<span class="keyword">mode</span>-colour colour64 #green</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 修改进入命令模式按键</span><br><span class="line"># remap prefix <span class="keyword">to</span> Control + a</span><br><span class="line"># <span class="keyword">set</span> -<span class="keyword">g</span> prefix <span class="keyword">C</span>-a</span><br><span class="line"># unbind <span class="keyword">C</span>-b</span><br><span class="line"># bind <span class="keyword">C</span>-a send-prefix</span></span><br></pre></td></tr></table></figure>
<p>最终的效果是</p>
<p><img src="/images/14593965566247.jpg" alt=""></p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://foocoder.com/blog/zhong-duan-huan-jing-zhi-tmux.html/" target="_blank" rel="external">终端环境之tmux</a></li>
<li><a href="http://blog.jeswang.org/blog/2013/06/24/tmux-kuai-su-jiao-cheng/" target="_blank" rel="external">Tmux 快速教程</a></li>
<li><a href="http://kumu-linux.github.io/blog/2013/08/06/tmux/" target="_blank" rel="external">Linux下终端利器tmux</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天试用了一下 tmux，发现简直是神器！以前还傻傻不停开窗口，现在一个窗口就可以都搞定啦！</p>]]>
    
    </summary>
    
      <category term="命令行" scheme="http://wdxtub.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="效率" scheme="http://wdxtub.com/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="窗口" scheme="http://wdxtub.com/tags/%E7%AA%97%E5%8F%A3/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ruby 快速入门]]></title>
    <link href="http://wdxtub.com/2016/03/30/ruby-first-step/"/>
    <id>http://wdxtub.com/2016/03/30/ruby-first-step/</id>
    <published>2016-03-30T13:14:28.000Z</published>
    <updated>2016-04-01T15:07:09.000Z</updated>
    <content type="html"><![CDATA[<p>学编程就好比学有用，再好的理论也不如一头扎下水，扑腾着呼吸新鲜空气管用。这个系列的目的，就是帮助自己跳入水中，这一次我们来学 Ruby。</p>
<a id="more"></a>
<hr>
<p>获得任何新技能的第一步，是先别想着独立解决什么，而是重复一边前人已竟之事，这是最快的方法。每门语言都有自己的一套惯用方法，各有所长，各有所短。通过学习不同的编程语言，你会明白，哪门语言最适宜解决自己当下关注的问题。</p>
<p>精于禅宗的大师会告诉你，拉丁语学得越好，数学也就越好。编程也同样如此。通过研究逻辑式编程或函数式编程，你能领悟到面向对象编程的精华；通过学习汇编语言，你能更透彻地理解函数式编程。</p>
<p>学习新语言的时候，一定要弄清楚以下几个问题：</p>
<ul>
<li>语言的类型模型是什么？<ul>
<li>强类型/弱类型，静态类型/动态类型</li>
<li>类型模型会改变问题的处理方式，控制语言的运行方式</li>
</ul>
</li>
<li>语言的编程范型是什么？<ul>
<li>面向对象、函数式、过程式等等</li>
</ul>
</li>
<li>怎样和语言交互？<ul>
<li>编译、解释</li>
</ul>
</li>
<li>语言的判断结构(decision construct)和核心数据结构是什么？</li>
<li>哪些核心特性让这门语言与众不同？</li>
</ul>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><ul>
<li>由松本行弘(Yukihiro Matsumoto)大约在 1993 年发明</li>
<li>脚本语言、解释型、面向对象、动态类型</li>
</ul>
<p>现在我的机器上安装的 ruby 版本是 2.1，可以使用下面的命令来查询：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -v</span><br><span class="line">ruby <span class="number">2.1</span>.<span class="number">4</span>p265 (<span class="number">2014</span>-<span class="number">10</span>-<span class="number">27</span> revision <span class="number">48166</span>) [x86_64-darwin14.<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>具体的安装不做太多介绍，在<a href="https://www.ruby-lang.org/zh_cn/" target="_blank" rel="external">官方网站</a>查阅不同平台的相关资料即可，下面是一个简单的例子</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> properties = [<span class="string">'good'</span>, <span class="string">'bad'</span>, <span class="string">'clever'</span>, <span class="string">'stupid'</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"good"</span>, <span class="string">"bad"</span>, <span class="string">"clever"</span>, <span class="string">"stupid"</span>]</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> properties.each &#123;|property| puts <span class="string">"I am <span class="subst">#&#123;property&#125;</span>."</span>&#125;</span><br><span class="line"><span class="constant">I</span> am good.</span><br><span class="line"><span class="constant">I</span> am bad.</span><br><span class="line"><span class="constant">I</span> am clever.</span><br><span class="line"><span class="constant">I</span> am stupid.</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"good"</span>, <span class="string">"bad"</span>, <span class="string">"clever"</span>, <span class="string">"stupid"</span>]</span><br></pre></td></tr></table></figure>
<p>留意一下 ruby 是如何进行遍历及值替换的，之后我们也会深入了解。需要注意的是，这种写起来方便的语言，一般来说效率都不会太高。但是开发效率与执行效率常常是鱼与熊掌，很多时候不得不进行选择。</p>
<p>我们再来看一个长一点的例子：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> puts <span class="string">'hello, wdx'</span></span><br><span class="line">hello, wdx</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> friend = <span class="string">'Snake'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Snake"</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> puts <span class="string">"hello, <span class="subst">#&#123;friend&#125;</span>"</span></span><br><span class="line">hello, <span class="constant">Snake</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> friend = <span class="string">'Queit'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Queit"</span></span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> puts <span class="string">"hello, <span class="subst">#&#123;friend&#125;</span>"</span></span><br><span class="line">hello, <span class="constant">Queit</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到以下几点：</p>
<ul>
<li>不用声明变量</li>
<li>每条 ruby 代码都会返回某个值</li>
<li>单引号表示直接解释</li>
<li>双引号包含的字符串会进行字符串替换</li>
</ul>
<h2 id="u7F16_u7A0B_u6A21_u578B"><a href="#u7F16_u7A0B_u6A21_u578B" class="headerlink" title="编程模型"></a>编程模型</h2><p>Ruby 是一门纯面向对象语言。从下面的例子就可以看出来：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="number">233</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">233</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> <span class="number">233</span>.class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">Fixnum</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> <span class="number">233</span> + <span class="number">233</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">466</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> <span class="number">233</span>.methods</span><br><span class="line"><span class="status">=&gt;</span> [<span class="symbol">:to_s</span>, <span class="symbol">:inspect</span>, <span class="symbol">:-@</span>, <span class="symbol">:+</span>, <span class="symbol">:-</span>, <span class="symbol">:*</span>, <span class="symbol">:/</span>, <span class="symbol">:div</span>, <span class="symbol">:%</span>, <span class="symbol">:modulo</span>, <span class="symbol">:divmod</span>, <span class="symbol">:fdiv</span>, <span class="symbol">:**</span>, <span class="symbol">:abs</span>, <span class="symbol">:magnitude</span>, <span class="symbol">:==</span>, <span class="symbol">:===</span>, <span class="symbol">:&lt;=&gt;</span>, <span class="symbol">:&gt;</span>, <span class="symbol">:&gt;=</span>, <span class="symbol">:&lt;</span>, <span class="symbol">:&lt;=</span>, <span class="symbol">:~</span>, <span class="symbol">:&amp;</span>, <span class="symbol">:|</span>, <span class="symbol">:^</span>, <span class="symbol">:[]</span>, <span class="symbol">:&lt;&lt;</span>, <span class="symbol">:&gt;&gt;</span>, <span class="symbol">:to_f</span>, <span class="symbol">:size</span>, <span class="symbol">:bit_length</span>, <span class="symbol">:zero?</span>, <span class="symbol">:odd?</span>, <span class="symbol">:even?</span>, <span class="symbol">:succ</span>, <span class="symbol">:integer?</span>, <span class="symbol">:upto</span>, <span class="symbol">:downto</span>, <span class="symbol">:times</span>, <span class="symbol">:next</span>, <span class="symbol">:pred</span>, <span class="symbol">:chr</span>, <span class="symbol">:ord</span>, <span class="symbol">:to_i</span>, <span class="symbol">:to_int</span>, <span class="symbol">:floor</span>, <span class="symbol">:ceil</span>, <span class="symbol">:truncate</span>, <span class="symbol">:round</span>, <span class="symbol">:gcd</span>, <span class="symbol">:lcm</span>, <span class="symbol">:gcdlcm</span>, <span class="symbol">:numerator</span>, <span class="symbol">:denominator</span>, <span class="symbol">:to_r</span>, <span class="symbol">:rationalize</span>, <span class="symbol">:singleton_method_added</span>, <span class="symbol">:coerce</span>, <span class="symbol">:i</span>, <span class="symbol">:+@</span>, <span class="symbol">:eql?</span>, <span class="symbol">:remainder</span>, <span class="symbol">:real?</span>, <span class="symbol">:nonzero?</span>, <span class="symbol">:step</span>, <span class="symbol">:quo</span>, <span class="symbol">:to_c</span>, <span class="symbol">:real</span>, <span class="symbol">:imaginary</span>, <span class="symbol">:imag</span>, <span class="symbol">:abs2</span>, <span class="symbol">:arg</span>, <span class="symbol">:angle</span>, <span class="symbol">:phase</span>, <span class="symbol">:rectangular</span>, <span class="symbol">:rect</span>, <span class="symbol">:polar</span>, <span class="symbol">:conjugate</span>, <span class="symbol">:conj</span>, <span class="symbol">:between?</span>, <span class="symbol">:nil?</span>, <span class="symbol">:=~</span>, <span class="symbol">:</span>!~, <span class="symbol">:hash</span>, <span class="symbol">:class</span>, <span class="symbol">:singleton_class</span>, <span class="symbol">:clone</span>, <span class="symbol">:dup</span>, <span class="symbol">:taint</span>, <span class="symbol">:tainted?</span>, <span class="symbol">:untaint</span>, <span class="symbol">:untrust</span>, <span class="symbol">:untrusted?</span>, <span class="symbol">:trust</span>, <span class="symbol">:freeze</span>, <span class="symbol">:frozen?</span>, <span class="symbol">:methods</span>, <span class="symbol">:singleton_methods</span>, <span class="symbol">:protected_methods</span>, <span class="symbol">:private_methods</span>, <span class="symbol">:public_methods</span>, <span class="symbol">:instance_variables</span>, <span class="symbol">:instance_variable_get</span>, <span class="symbol">:instance_variable_set</span>, <span class="symbol">:instance_variable_defined?</span>, <span class="symbol">:remove_instance_variable</span>, <span class="symbol">:instance_of?</span>, <span class="symbol">:kind_of?</span>, <span class="symbol">:is_a?</span>, <span class="symbol">:tap</span>, <span class="symbol">:send</span>, <span class="symbol">:public_send</span>, <span class="symbol">:respond_to?</span>, <span class="symbol">:extend</span>, <span class="symbol">:display</span>, <span class="symbol">:method</span>, <span class="symbol">:public_method</span>, <span class="symbol">:singleton_method</span>, <span class="symbol">:define_singleton_method</span>, <span class="symbol">:object_id</span>, <span class="symbol">:to_enum</span>, <span class="symbol">:enum_for</span>, <span class="symbol">:equal?</span>, <span class="symbol">:</span>!, <span class="symbol">:</span>!=, <span class="symbol">:instance_eval</span>, <span class="symbol">:instance_exec</span>, <span class="symbol">:__send__</span>, <span class="symbol">:__id__</span>]</span><br></pre></td></tr></table></figure>
<p>看出来了吗，ruby 中一切皆为对象，比方说数字就是 <code>Fixnum</code> 类型的对象，我们也可以用 <code>.</code> 来调用对象的各种方法。</p>
<blockquote>
<p>判断</p>
</blockquote>
<p>我们同样可以通过例子来研究研究。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> x = <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">4</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> x &lt; <span class="number">5</span></span><br><span class="line"><span class="status">=&gt;</span> true</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> x &lt;= <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> true</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> x &gt; <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> false</span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> false.class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">FalseClass</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> true.class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">TrueClass</span></span><br><span class="line"><span class="prompt">irb(main):007:0&gt;</span> puts <span class="string">'This is false'</span> unless x == <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):008:0&gt;</span> puts <span class="string">'This is true'</span> if x == <span class="number">4</span></span><br><span class="line"><span class="constant">This</span> is <span class="keyword">true</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):009:0&gt;</span> if x == <span class="number">4</span></span><br><span class="line"><span class="prompt">irb(main):010:1&gt;</span>     puts <span class="string">'This is true'</span></span><br><span class="line"><span class="prompt">irb(main):011:1&gt;</span> end</span><br><span class="line"><span class="constant">This</span> is <span class="keyword">true</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):012:0&gt;</span> unless x == <span class="number">4</span></span><br><span class="line"><span class="prompt">irb(main):013:1&gt;</span>    puts <span class="string">'This is false'</span></span><br><span class="line"><span class="prompt">irb(main):014:1&gt;</span> else</span><br><span class="line">irb(main)<span class="symbol">:</span><span class="number">015</span><span class="symbol">:</span><span class="number">1</span>*    puts <span class="string">'This is true'</span></span><br><span class="line"><span class="prompt">irb(main):016:1&gt;</span> end</span><br><span class="line"><span class="constant">This</span> is <span class="keyword">true</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):017:0&gt;</span> puts <span class="string">'This is true'</span> if not true</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):018:0&gt;</span> puts <span class="string">'This is ture'</span> if !true</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>比较什么的和其他语言大同小异，条件判断的话，主要是 <code>if</code> 和 <code>unless</code>（当然 <code>!</code> 和 <code>not</code> 都可以用，但是建议用 <code>unless</code> 比较清晰），在 Ruby 的语法中可以直接一行搞定判断一句，这样至少写起来很清晰。</p>
<p>除了 <code>nil</code> 和 <code>false</code> 之外，其他值都代表 <code>true</code>，注意！0 也是 <code>true</code>！</p>
<p>循环语句可以使用 <code>while</code> 和 <code>until</code>，比较简单，这里直接看例子，需要注意的是，Ruby 中没种对戏那个都有自己的相等的概念，对于数字来说，值相等就是相等。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> x = <span class="number">2</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> x = x + <span class="number">1</span> while x &lt; <span class="number">10</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> x</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">10</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> x = x - <span class="number">1</span> until x == <span class="number">1</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> x</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> while x &lt; <span class="number">10</span></span><br><span class="line"><span class="prompt">irb(main):007:1&gt;</span>   x = x + <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):008:1&gt;</span>   puts x</span><br><span class="line"><span class="prompt">irb(main):009:1&gt;</span> end</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>逻辑运算符和 C++/Java 有少许不同，<code>and</code>(<code>&amp;&amp;</code>) 是逻辑与，<code>or</code>(<code>||</code>) 是逻辑或，都是短路求值的，如果想要整个表达式都执行的话，使用 <code>&amp;</code> 和 <code>|</code> 来比较，具体为</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> true and false</span><br><span class="line"><span class="status">=&gt;</span> false</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> true or false</span><br><span class="line"><span class="status">=&gt;</span> true</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> false &amp;&amp; false</span><br><span class="line"><span class="status">=&gt;</span> false</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> true &amp;&amp; this_will_cause_an_error</span><br><span class="line"><span class="constant">NameError</span><span class="symbol">:</span> undefined local variable <span class="keyword">or</span> method <span class="string">`this_will_cause_an_error' for main:Object</span><br><span class="line">	from (irb):4</span><br><span class="line">	from /usr/local/bin/irb:11:in `</span>&lt;main&gt;<span class="string">'</span><br><span class="line">irb(main):005:0&gt; false &amp;&amp; this_will_not_cause_an_error</span><br><span class="line">=&gt; false</span><br><span class="line">irb(main):006:0&gt; true or this_will_not_cause_an_error</span><br><span class="line">=&gt; true</span><br><span class="line">irb(main):007:0&gt; true || this_will_not_cause_an_error</span><br><span class="line">=&gt; true</span><br><span class="line">irb(main):008:0&gt; true | this_will_cause_an_error</span><br><span class="line">NameError: undefined local variable or method `this_will_cause_an_error'</span> <span class="keyword">for</span> <span class="symbol">main:</span><span class="constant">Object</span></span><br><span class="line">	from (irb)<span class="symbol">:</span><span class="number">8</span></span><br><span class="line">	from /usr/local/bin/<span class="symbol">irb:</span><span class="number">11</span><span class="symbol">:in</span> <span class="string">`&lt;main&gt;'</span><br><span class="line">irb(main):009:0&gt; true | false</span><br><span class="line">=&gt; true</span></span><br></pre></td></tr></table></figure>
<p>基本来说还是一目了然的，这里不再赘述</p>
<blockquote>
<p>鸭子类型</p>
</blockquote>
<p>Ruby 是强类型语言，直到真正执行代码时，才进行类型检查，称为『动态类型』，但是这也带来了一些好处：多个类不必继承自相同父类，就能以相同方式使用，如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> i = <span class="number">0</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> a = [<span class="string">'100'</span>, <span class="number">100.0</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"100"</span>, <span class="number">100.0</span>]</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> while i &lt; <span class="number">2</span></span><br><span class="line"><span class="prompt">irb(main):004:1&gt;</span>   puts a[i].to_i</span><br><span class="line"><span class="prompt">irb(main):005:1&gt;</span>   i = i + <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:1&gt;</span> end</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>这其实就是面向对象设计思想中的重要原则：对接口编码。举个例子，对象若有 <code>push</code> 和 <code>pop</code>，那么就可以当做栈来使用。</p>
<blockquote>
<p>函数</p>
</blockquote>
<p>函数的定义也和简单，并且，函数也是一个对象</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tell_the_truth</span></span></span><br><span class="line">    <span class="keyword">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组</p>
</blockquote>
<p>同样先来看实例</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> animals = [<span class="string">'lions'</span>, <span class="string">'tigers'</span>, <span class="string">'bears'</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>]</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> puts animals</span><br><span class="line">lions</span><br><span class="line">tigers</span><br><span class="line">bears</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> animals[<span class="number">2</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"bears"</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> animals[<span class="number">3</span>]</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> animals[-<span class="number">1</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"bears"</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> animals[<span class="number">0</span>..<span class="number">2</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>]</span><br><span class="line"><span class="prompt">irb(main):007:0&gt;</span> (<span class="number">0</span>..<span class="number">1</span>).class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">Range</span></span><br></pre></td></tr></table></figure>
<p>具体部分比较好明白，唯一需要注意的是 <code>0..1</code> 其实是个对象。另外 <code>[]</code> 是 <code>Array</code> 类的方法，所以 <code>[]</code> 和 <code>[]=</code> 其实是语法糖。想要用的话，必须先在变量里放一个空数组。数组元素不必具有相同类型。</p>
<blockquote>
<p>散列表</p>
</blockquote>
<p>其实就是键值对存储，来看例子</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> numbers = &#123;<span class="number">1</span> =&gt; <span class="string">'one'</span>, <span class="number">2</span> =&gt; <span class="string">'two'</span>&#125;</span><br><span class="line"><span class="status">=&gt;</span> &#123;<span class="number">1</span>=&gt;<span class="string">"one"</span>, <span class="number">2</span>=&gt;<span class="string">"two"</span>&#125;</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> numbers[<span class="number">1</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"one"</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> stuff = &#123;<span class="symbol">:array</span> =&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="symbol">:string</span> =&gt; <span class="string">'Hi, mom!'</span>&#125;</span><br><span class="line"><span class="status">=&gt;</span> &#123;<span class="symbol">:array=&gt;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="symbol">:string=&gt;<span class="string">"Hi, mom!"</span></span>&#125;</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> stuff[<span class="symbol">:string</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Hi, mom!"</span></span><br></pre></td></tr></table></figure>
<p>这里尤其需要注意 <code>stuff</code> 这个散列表，我们使用了 symbol 的概念，就是变量名称前面加个冒号。这样做的意义在于，相同的 symbol 会指向相同的物理对象，比如下面的例子，两次 <code>&#39;string&#39;</code> 的 id 值不一样，但是 <code>:string</code> 的值是一样的</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):005:0&gt;</span> <span class="string">'string'</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">70186296639880</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> <span class="string">'string'</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">70186296271240</span></span><br><span class="line"><span class="prompt">irb(main):007:0&gt;</span> <span class="symbol">:string</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">156648</span></span><br><span class="line"><span class="prompt">irb(main):008:0&gt;</span> <span class="symbol">:string</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">156648</span></span><br></pre></td></tr></table></figure>
<p>散列表的一个应用就是模拟命名参数（就是不同的参数有不同的名字，这样可以根据名字来引用，而不是根据预订好的位置类进行引用），例如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="function"><span class="keyword">def</span> <span class="title">tell_the_truth</span><span class="params">(options=&#123;&#125;)</span></span></span><br><span class="line"><span class="prompt">irb(main):002:1&gt;</span>   if options[<span class="symbol">:profession</span>] == <span class="symbol">:lawyer</span></span><br><span class="line"><span class="prompt">irb(main):003:2&gt;</span>     <span class="string">'oh you are a laywer'</span></span><br><span class="line"><span class="prompt">irb(main):004:2&gt;</span>   else</span><br><span class="line">irb(main)<span class="symbol">:</span><span class="number">005</span><span class="symbol">:</span><span class="number">2</span>*     <span class="string">'who you are'</span></span><br><span class="line"><span class="prompt">irb(main):006:2&gt;</span>   end</span><br><span class="line"><span class="prompt">irb(main):007:1&gt;</span> end</span><br><span class="line"><span class="status">=&gt;</span> <span class="symbol">:tell_the_truth</span></span><br><span class="line"><span class="prompt">irb(main):008:0&gt;</span> tell_the_truth</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"who you are"</span></span><br><span class="line"><span class="prompt">irb(main):009:0&gt;</span> tell_the_truth <span class="symbol">:profession</span> =&gt; <span class="symbol">:lawyer</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"oh you are a laywer"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>options</code> 表示可选参数，如果不传入，默认就是空散列表</li>
<li>散列表用作最后一个参数的时候可以省略大括号</li>
</ul>
<blockquote>
<p>代码块和 yield</p>
</blockquote>
<p>代码块就是匿名函数，可以作为参数传递，比如说</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="number">3</span>.times &#123;puts <span class="string">'great day!'</span>&#125;</span><br><span class="line">great day!</span><br><span class="line">great day!</span><br><span class="line">great day!</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">3</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> animals = [<span class="string">'lions'</span>, <span class="string">'tigers'</span>, <span class="string">'bears'</span>, <span class="string">'rabbits'</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>, <span class="string">"rabbits"</span>]</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> animals.each &#123;|a| puts a&#125;</span><br><span class="line">lions</span><br><span class="line">tigers</span><br><span class="line">bears</span><br><span class="line">rabbits</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>, <span class="string">"rabbits"</span>]</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> animals.each do |a| \</span><br><span class="line">irb(main)<span class="symbol">:</span><span class="number">005</span><span class="symbol">:</span><span class="number">1</span>*                 puts a <span class="keyword">end</span></span><br><span class="line">lions</span><br><span class="line">tigers</span><br><span class="line">bears</span><br><span class="line">rabbits</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>, <span class="string">"rabbits"</span>]</span><br></pre></td></tr></table></figure>
<p>代码块只占一行时用 <code>{ / }</code>，多行的话则使用 <code>do / end</code>。如果我们要实现自己的 <code>times</code> 函数要怎么做呢？其实也很简单，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Fixnum</span></span></span><br><span class="line"><span class="prompt">irb(main):002:1&gt;</span>   <span class="function"><span class="keyword">def</span> <span class="title">my_times</span></span></span><br><span class="line"><span class="prompt">irb(main):003:2&gt;</span>     i = self</span><br><span class="line"><span class="prompt">irb(main):004:2&gt;</span>     while i &gt; <span class="number">0</span></span><br><span class="line"><span class="prompt">irb(main):005:3&gt;</span>       i = i - <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:3&gt;</span>       yield</span><br><span class="line"><span class="prompt">irb(main):007:3&gt;</span>     end</span><br><span class="line"><span class="prompt">irb(main):008:2&gt;</span>   end</span><br><span class="line"><span class="prompt">irb(main):009:1&gt;</span> end</span><br><span class="line"><span class="status">=&gt;</span> <span class="symbol">:my_times</span></span><br><span class="line"><span class="prompt">irb(main):010:0&gt;</span> <span class="number">3</span>.my_times &#123;puts <span class="string">'my own times!'</span>&#125;</span><br><span class="line">my own times!</span><br><span class="line">my own times!</span><br><span class="line">my own times!</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>因为代码块可以作为参数，于是类似于函数指针，可以更加灵活进行调用。</p>
<blockquote>
<p>面向对象</p>
</blockquote>
<p>主要是类和模块，这里设计的知识点比较繁杂，可以自行阅读参考链接中的文档，这里不再赘述</p>
<blockquote>
<p>优劣</p>
</blockquote>
<p>使用 Ruby 可以用一致的方向处理对象，还有各种不同的语法糖，可以有效提高编程的效率，不过这也导致一定的性能损失。另外，ruby 在并发条件下会产生严重问题（资源竞争）</p>
<h2 id="u4E60_u9898"><a href="#u4E60_u9898" class="headerlink" title="习题"></a>习题</h2><blockquote>
<p>替换字符串某一部分</p>
</blockquote>
<p>字符串相关的操作可以在<a href="http://ruby-doc.org/core-2.3.0/String.html" target="_blank" rel="external">这里</a>查看（其他的类也可以通过这种方式来学习）</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> title = <span class="string">"This is DaWang."</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"This is DaWang."</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> title[<span class="number">0</span>,<span class="number">3</span>] = <span class="string">"That"</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"That"</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> title</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Thats is DaWang."</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> title[<span class="number">0</span>,<span class="number">5</span>] = <span class="string">"That"</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"That"</span></span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> title</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"That is DaWang."</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意字符串的位置索引，具体可以试验一下。</p>
<blockquote>
<p>在字符串 <code>Hello, dawang</code> 中，找到 <code>dawang</code> 所在下标 </p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> s = <span class="string">'Hello, dawang'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Hello, dawang"</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> i = s.index(<span class="string">'dawang'</span>)</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>打印名字十次，并输出序号</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> name = <span class="string">'dawang'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"dawang"</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> i = <span class="number">0</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> while i &lt; <span class="number">10</span></span><br><span class="line"><span class="prompt">irb(main):004:1&gt;</span>   puts <span class="string">"<span class="subst">#&#123;i+<span class="number">1</span>&#125;</span> <span class="subst">#&#123;name&#125;</span>"</span></span><br><span class="line"><span class="prompt">irb(main):005:1&gt;</span>   i = i + <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:1&gt;</span> end</span><br><span class="line"><span class="number">1</span> dawang</span><br><span class="line"><span class="number">2</span> dawang</span><br><span class="line"><span class="number">3</span> dawang</span><br><span class="line"><span class="number">4</span> dawang</span><br><span class="line"><span class="number">5</span> dawang</span><br><span class="line"><span class="number">6</span> dawang</span><br><span class="line"><span class="number">7</span> dawang</span><br><span class="line"><span class="number">8</span> dawang</span><br><span class="line"><span class="number">9</span> dawang</span><br><span class="line"><span class="number">10</span> dawang</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从文件运行 Ruby 程序</p>
</blockquote>
<p>类似 python，直接 <code>ruby filename</code> 即可，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [8:47:56]</span></span><br><span class="line">$ cat test.rb</span><br><span class="line">name = <span class="string">'dawang'</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span></span><br><span class="line">    puts <span class="string">"#&#123;i+1&#125; #&#123;name&#125;"</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [8:48:36]</span></span><br><span class="line">$ ruby test.rb</span><br><span class="line"><span class="number">1</span> dawang</span><br><span class="line"><span class="number">2</span> dawang</span><br><span class="line"><span class="number">3</span> dawang</span><br><span class="line"><span class="number">4</span> dawang</span><br><span class="line"><span class="number">5</span> dawang</span><br><span class="line"><span class="number">6</span> dawang</span><br><span class="line"><span class="number">7</span> dawang</span><br><span class="line"><span class="number">8</span> dawang</span><br><span class="line"><span class="number">9</span> dawang</span><br><span class="line"><span class="number">10</span> dawang</span><br></pre></td></tr></table></figure>
<blockquote>
<p>生成一个 0~9 的随机数，让用户猜，并告知结果</p>
</blockquote>
<p>具体可以直接看代码</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [9:07:47]</span></span><br><span class="line"><span class="variable">$ </span>cat test.rb</span><br><span class="line">puts <span class="string">'Please input a number between 0~9: '</span></span><br><span class="line">numstr = gets</span><br><span class="line">num = numstr.to_i(base=<span class="number">10</span>)</span><br><span class="line">puts <span class="string">'Generating random number..'</span></span><br><span class="line">target = rand(<span class="number">10</span>)</span><br><span class="line">puts <span class="string">"The target number is <span class="subst">#&#123;target&#125;</span>"</span></span><br><span class="line"><span class="keyword">if</span> num == target</span><br><span class="line">    puts <span class="string">'You made it!'</span></span><br><span class="line"><span class="keyword">elsif</span> num &lt; target</span><br><span class="line">    puts <span class="string">'Answer Too Small!'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    puts <span class="string">'Answer Too Large!'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [9:07:53]</span></span><br><span class="line"><span class="variable">$ </span>ruby test.rb</span><br><span class="line"><span class="constant">Please</span> input a number between <span class="number">0</span>~<span class="number">9</span><span class="symbol">:</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="constant">Generating</span> random number..</span><br><span class="line"><span class="constant">The</span> target number is <span class="number">6</span></span><br><span class="line"><span class="constant">Answer</span> <span class="constant">Too</span> <span class="constant">Small</span>!</span><br></pre></td></tr></table></figure>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://ruby-doc.org/core-2.3.0/" target="_blank" rel="external">Ruby APi</a></li>
<li><a href="http://ruby-doc.com/docs/ProgrammingRuby/" target="_blank" rel="external">Programming Ruby: The Pragmatic Programmer’s Guide</a></li>
<li><a href="http://www.runoob.com/ruby/ruby-regular-expressions.html" target="_blank" rel="external">Ruby 正则表达式</a></li>
<li><a href="http://www.runoob.com/ruby/ruby-range.html" target="_blank" rel="external">Ruby 区间(range)</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>学编程就好比学有用，再好的理论也不如一头扎下水，扑腾着呼吸新鲜空气管用。这个系列的目的，就是帮助自己跳入水中，这一次我们来学 Ruby。</p>]]>
    
    </summary>
    
      <category term="Ruby" scheme="http://wdxtub.com/tags/Ruby/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="语言" scheme="http://wdxtub.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 习题课 6 设计模式进阶练习]]></title>
    <link href="http://wdxtub.com/2016/03/30/sad-r6/"/>
    <id>http://wdxtub.com/2016/03/30/sad-r6/</id>
    <published>2016-03-30T11:11:03.000Z</published>
    <updated>2016-04-02T20:46:16.000Z</updated>
    <content type="html"><![CDATA[<p>接着上次的练习，这次给出具体场景，来进行设计模式的应用，咱们直接看习题。</p>
<a id="more"></a>
<hr>
<blockquote>
<p>简单来说就是不同等级的领导可以批不同价格的订单，超出了价格范围就需要提交给上一级审批，这个时候用什么设计模式呢？如果具体的限制因素不止价格一个呢？</p>
</blockquote>
<p>顾名思义，直接用『责任链模式』。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DecisionMaker.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DecisionMaker</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> director = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> vp = <span class="number">25000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> president = <span class="number">100000</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">protected</span> string title;</span><br><span class="line">    <span class="comment">// next element in the chain</span></span><br><span class="line">    <span class="keyword">protected</span> DecisionMaker nextDM;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextDM</span><span class="params">(DecisionMaker dm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextDM = dm;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeDecision</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.price &gt; <span class="number">0</span> &amp;&amp; price &lt;= <span class="keyword">this</span>.price)&#123;</span><br><span class="line">            System.out.println(title + <span class="string">"can make the decision for price "</span>  + price);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextDM != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Handle to higher level decision maker"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DirectorDM.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectorDM</span> <span class="keyword">extends</span> <span class="title">DecisionMaker</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectorDM</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VPDM.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VPDM</span> <span class="keyword">extends</span> <span class="title">DecisionMaker</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VPDM</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PresidentDM.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PresidentDM</span> <span class="keyword">extends</span> <span class="title">DecisionMaker</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PresidentDM</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExecutiveMeetingDM</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutiveMeetingDM</span> <span class="keyword">extends</span> <span class="title">DecisionMaker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutiveMeetingDM</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DMDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DMDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DecisionMaker <span class="title">getChainOfDMs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DecisionMaker director = <span class="keyword">new</span> DirectorDM(<span class="number">10000</span>);</span><br><span class="line">        DecisionMaker vp = <span class="keyword">new</span> VPDM(<span class="number">25000</span>);</span><br><span class="line">        DecisionMaker president = <span class="keyword">new</span> PresidentDM(<span class="number">100000</span>);</span><br><span class="line">        <span class="comment">// -1 means infinitive</span></span><br><span class="line">        DecisionMaker exemeet = <span class="keyword">new</span> ExecutiveMeetingDM(-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        director.setNextDM(vp);</span><br><span class="line">        vp.setNextDM(president);</span><br><span class="line">        prsident.setNextDM(exemeet);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> director;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DecisionMaker dmChain = getChainofDMs();</span><br><span class="line">        </span><br><span class="line">        dmChain.makeDecision(<span class="number">5000</span>);</span><br><span class="line">        dmChain.makeDecision(<span class="number">12000</span>);</span><br><span class="line">        dmChain.makeDecision(<span class="number">32000</span>);</span><br><span class="line">        dmChain.makeDecision(<span class="number">302000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>机场一般由塔台统一协调控制，各个飞机之间不会有练习沟通，这里更适合用什么设计模式？</p>
</blockquote>
<p>一般使用中介者模式，用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tower.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Plane plane)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"["</span> + plane.toString() + <span class="string">"] Requested."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Plane.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plane</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String company;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plane</span><span class="params">(String c, String co)</span></span>&#123;</span><br><span class="line">        company = c;</span><br><span class="line">        code = co;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">sendRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Tower.handleRequest(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toSring</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> company + <span class="string">"-"</span> + code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Airport.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Airport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Plane p1 = <span class="keyword">new</span> Plane(<span class="string">"AA"</span>, <span class="string">"1000"</span>);</span><br><span class="line">        Plane p2 = <span class="keyword">new</span> Plane(<span class="string">"Delta"</span>, <span class="string">"2000"</span>);</span><br><span class="line">        </span><br><span class="line">        p1.sendRequest();</span><br><span class="line">        p2.sendRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CPU 的调度算法一般是 Round Robin，什么设计模式比较合适呢？画出类图并写出伪代码。</p>
</blockquote>
<p>（注）这个模式我也不是很确定</p>
<p>前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。</p>
<p>图和伪代码略</p>
<blockquote>
<p>弄一个消息系统，可以广播给所有的订阅者，什么设计模式比较合适呢？画出类图并写出伪代码。</p>
</blockquote>
<p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。</p>
<p>图和伪代码略</p>
<blockquote>
<p>同一个社区的方法除了颜色基本一致，什么设计模式比较合适呢？画出类图并写出伪代码。</p>
</blockquote>
<p>（注）这个模式我也不是很确定</p>
<p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>
<p>图和伪代码略</p>
<blockquote>
<p>给出一个实际生活中使用状态模式的例子</p>
</blockquote>
<p>编译器的词法解析器</p>
<blockquote>
<p>给出一个实际生活中使用状态模式的例子</p>
</blockquote>
<p>JSON 解析器</p>
<blockquote>
<p>给出一个实际生活中使用命令模式的例子</p>
</blockquote>
<p>各种 shell</p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html" target="_blank" rel="external">责任链模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/mediator-pattern.html" target="_blank" rel="external">中介者模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/front-controller-pattern.html" target="_blank" rel="external">前端控制器模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/observer-pattern.html" target="_blank" rel="external">观察者模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/flyweight-pattern.html" target="_blank" rel="external">享元模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/state-pattern.html" target="_blank" rel="external">状态模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/visitor-pattern.html" target="_blank" rel="external">访问者模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/command-pattern.html" target="_blank" rel="external">命令模式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>接着上次的练习，这次给出具体场景，来进行设计模式的应用，咱们直接看习题。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="习题" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
