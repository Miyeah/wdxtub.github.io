<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-03-26T20:32:15.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[【深入理解计算机系统】读书笔记]]></title>
    <link href="http://wdxtub.com/2016/03/26/csapp-book-note/"/>
    <id>http://wdxtub.com/2016/03/26/csapp-book-note/</id>
    <published>2016-03-26T19:55:57.000Z</published>
    <updated>2016-03-26T20:32:15.000Z</updated>
    <content type="html"><![CDATA[<p>这是我之前自学时的笔记，本文的内容为第二版，现在最新是第三版。</p>
<p><em>Notes from Da Wang, Feb.2 2015</em></p>
<a id="more"></a>
<hr>
<p>从程序员的角度来学习计算机系统是如何工作的会非常有趣，主要是因为你可以主动地来做这件事情。无论何时你学到一些新的东西，都可以马上试验并且直接看到运行结果。事实上，我们相信学习系统的唯一方法就是做(do)系统，即再真正的系统上解决具体的问题，或是编写和运行程序。</p>
<p>本书起源于1998年秋季，作者在 CMU 开设的编号为15-213的介绍性课程：计算机系统导论(Introduction to Computer Systems, ICS)，是大多数高级系统课程的先行必修课。宗旨是用一种不同的方式向学生介绍计算机，只讨论那些影响用户级 C 语言程序的性能、正确性或实用性的主题。</p>
<h1 id="u8BA1_u7B97_u673A_u7CFB_u7EDF_u6F2B_u6E38"><a href="#u8BA1_u7B97_u673A_u7CFB_u7EDF_u6F2B_u6E38" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h1><p>我们通过跟踪 helloworld 程序的生命周期来开始对系统的学习——从它被程序员创建，到在系统上运行，输出简单的消息，然后终止。</p>
<h2 id="u4FE1_u606F_u5C31_u662F_u4F4D_+__u4E0A_u4E0B_u6587"><a href="#u4FE1_u606F_u5C31_u662F_u4F4D_+__u4E0A_u4E0B_u6587" class="headerlink" title="信息就是位 + 上下文"></a>信息就是位 + 上下文</h2><p><img src="/images/csapp1.1.jpg" alt="csapp1.1"></p>
<p>hello.c 程序以字节序列的方式存储在文件中。每个字节都有一个整数值，而该整数值对应于某个字符。</p>
<p><img src="/images/csapp1.2.jpg" alt="csapp1.2"></p>
<p>hello.c 的表示方法说明了一个基本的思想：系统中所有的信息——包括磁盘文件、存储器中的程序、存储器中存放的用户数据以及网络上传送的数据，都是由一串位表示的。区分不同数据对象的唯一方式是我们读到这些数据对象时的上下文。</p>
<p><strong>C 编程语言的起源</strong></p>
<ul>
<li>贝尔实验室的 Dennis Ritchie 于 1969-1973 年创建</li>
<li>C 语言与 Unix 操作系统关系密切</li>
<li>C 语言小而简单</li>
<li>C 语言是为实践目的而设计的</li>
<li>C 语言是系统级编程的首选，同时它也非常适用于应用级程序的编写。然而，它也并非适用于所有的程序员和所有的情况。C 语言的指针是造成困惑和程序错误的一个常见原因。同时，C 语言还缺乏对非常有用的抽象（类、对象和异常）的显式支持。</li>
</ul>
<h2 id="u7A0B_u5E8F_u88AB_u5176_u4ED6_u7A0B_u5E8F_u7FFB_u8BD1_u6210_u4E0D_u540C_u7684_u683C_u5F0F"><a href="#u7A0B_u5E8F_u88AB_u5176_u4ED6_u7A0B_u5E8F_u7FFB_u8BD1_u6210_u4E0D_u540C_u7684_u683C_u5F0F" class="headerlink" title="程序被其他程序翻译成不同的格式"></a>程序被其他程序翻译成不同的格式</h2><p>hello 程序的生命周期是从一个高级 C 语言程序开始的，因为这种形式能够被人读懂。为了在系统上运行，每条 C 语句都必须被其他程序转化为一系列的低级<strong>机器语言</strong>指令。然后这些指令按照一种称为<strong>可执行目标程序</strong>的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为<strong>可执行目标文件</strong>。</p>
<p>在 Unix 系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：</p>
<pre><code>unix&gt; gcc -o hello hello.c
</code></pre><p>这个翻译过程可分为四个阶段。这行这四个阶段的程序（预处理器cpp、编译器ccl、汇编器as和链接器ld）一起构成了编译系统（compilation system）。</p>
<p><img src="/images/csapp1.3.jpg" alt="csapp1.3"></p>
<p><strong>GNU 项目</strong></p>
<p>GCC 是 GNU(GNU’s Not Unix) 项目开发出来的众多有用工具之一。GNU 项目已经开发出了一个包含 Unix 操作系统的所有主要部件的环境，但内核除外，内核是由 Linux 项目独立发展而来的。GNU 环境包括 EMACS 编辑器、GCC 编译器、GDB 调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件。</p>
<h2 id="u4E86_u89E3_u7F16_u8BD1_u7CFB_u7EDF_u5982_u4F55_u5DE5_u4F5C_u662F_u5927_u6709_u76CA_u5904_u7684"><a href="#u4E86_u89E3_u7F16_u8BD1_u7CFB_u7EDF_u5982_u4F55_u5DE5_u4F5C_u662F_u5927_u6709_u76CA_u5904_u7684" class="headerlink" title="了解编译系统如何工作是大有益处的"></a>了解编译系统如何工作是大有益处的</h2><p>知道编译系统是如何工作非常重要，原因如下：</p>
<ul>
<li><strong>优化程序性能</strong>。了解一些机器代码以及编译器将不同的 C 语句转换为机器代码的方式。<ul>
<li>一个 <code>switch</code> 语句是否总是比一系列 <code>if-else</code> 语句高效得多？</li>
<li>一个函数调用的开销有多大？</li>
<li><code>while</code> 循环比 <code>for</code> 循环更有效吗？</li>
<li>指针引用比数组索引更有效吗？</li>
</ul>
</li>
<li><strong>理解链接时出现的错误</strong>。一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。<ul>
<li>无法解析一个引用是什么意思？</li>
<li>静态变量和全局变量的区别是什么？</li>
<li>在不同 C 文件中定义的名字相同的两个全局变量会发生什么？</li>
<li>静态库和动态库的区别是什么？</li>
<li>我们在命令行上排列库的顺序有什么影响？</li>
</ul>
</li>
<li><strong>避免安全漏洞</strong>。学习安全变成的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。</li>
</ul>
<h2 id="u5904_u7406_u5668_u8BFB_u5E76_u89E3_u91CA_u5B58_u50A8_u5728_u5B58_u50A8_u5668_u4E2D_u7684_u6307_u4EE4"><a href="#u5904_u7406_u5668_u8BFB_u5E76_u89E3_u91CA_u5B58_u50A8_u5728_u5B58_u50A8_u5668_u4E2D_u7684_u6307_u4EE4" class="headerlink" title="处理器读并解释存储在存储器中的指令"></a>处理器读并解释存储在存储器中的指令</h2><p>要想在 Unix 系统上运行可执行目标文件 hello，将文件名输入到 shell 中：</p>
<pre><code>unix&gt; ./hello
hello, world
unix&gt;
</code></pre><p>shell 是一个命令行解释器，它输出一个提示符，等待你输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的 shell 命令，那么 shell 就会假设这是一个可执行文件的名字，它将加载并运行这个文件。</p>
<blockquote>
<p>系统的硬件组成</p>
</blockquote>
<p>下图是 Intel Pentium 系统产品系列的模型：</p>
<p><img src="/images/csapp1.4.jpg" alt="csapp1.4"></p>
<ol>
<li><strong>总线</strong>：贯穿整个系统的电子管道，携带信息字节并负责在各个部件间传递。通常总线呗设计成传送定长的字节块，也就是字(word)。假设字长为 4 个字节，并且总线每次只传送 1 个字。</li>
<li><strong>I/O 设备</strong>：系统与外部世界的联系通道。每个 I/O 设备都通过一个<strong>控制器</strong>或<strong>适配器</strong>与 I/O 总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是置于 I/O 设备本身的或者系统的主板上的芯片组，而适配器则是一块插在主板插槽上的卡。</li>
<li><strong>主存</strong>：临时存储设备，由一组动态随机存取存储器(DRAM)芯片组成。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一地址。</li>
<li><strong>处理器</strong>：解释(或执行)存储在主存中指令的引擎。核心是一个字长的存储设备(或寄存器)，称为程序计数器(PC)。在任何时刻，PC 都指向主存中的某条机器语言指令。从系统痛点开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，在更新程序计数器，使其指向下一条指令。</li>
</ol>
<blockquote>
<p>运行 hello 程序</p>
</blockquote>
<p>当我们输入“./hello”后，shell 程序将字符逐一读入寄存器，再把它存放到存储器中，如下图所示：</p>
<p><img src="/images/csapp1.5.jpg" alt="csapp1.5"></p>
<p>利用直接存储器存取(DMA)技术，数据可以不通过处理器而直接从磁盘到达主存</p>
<p><img src="/images/csapp1.6.jpg" alt="csapp1.6"></p>
<p>一旦目标文件中的代码和数据被加载到主存，处理器就开始执行 hello 程序的 main 程序中的机器语言指令。这些指令将“hello, world\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。</p>
<p><img src="/images/csapp1.7.jpg" alt="csapp1.7"></p>
<h2 id="u9AD8_u901F_u7F13_u5B58_u81F3_u5173_u91CD_u8981"><a href="#u9AD8_u901F_u7F13_u5B58_u81F3_u5173_u91CD_u8981" class="headerlink" title="高速缓存至关重要"></a>高速缓存至关重要</h2><p>这个简单的例子揭示了一个重要的问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。因此，系统设计者的一个主要目的就是使这些复制操作尽可能快地完成。</p>
<p><img src="/images/csapp1.8.jpg" alt="csapp1.8"></p>
<p>较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。针对这种差异，系统设计者采用了更小、更快的存储设备，即<strong>高速缓存存储器</strong>，作为暂时的集结区域，用一种叫<strong>做静态随机访问存储器(SRAM)</strong>的硬件技术实现。</p>
<h2 id="u5B58_u50A8_u8BBE_u5907_u5F62_u6210_u5C42_u6B21_u7ED3_u6784"><a href="#u5B58_u50A8_u8BBE_u5907_u5F62_u6210_u5C42_u6B21_u7ED3_u6784" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h2><p>从上至下，设备的访问速度越来越慢、容量越来越大，每字节的造价也越来越便宜。</p>
<p><img src="/images/csapp1.9.jpg" alt="csapp1.9"></p>
<h2 id="u64CD_u4F5C_u7CFB_u7EDF_u7BA1_u7406_u786C_u4EF6"><a href="#u64CD_u4F5C_u7CFB_u7EDF_u7BA1_u7406_u786C_u4EF6" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h2><p>我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。操作系统有两个基本功能：</p>
<ol>
<li>防止硬件被失控的应用程序滥用。</li>
<li>向应用程序提供简单一致的机制来控制复杂而又通常大相径庭的低级硬件设备。</li>
</ol>
<p><img src="/images/csapp1.10.jpg" alt="csapp1.10"></p>
<p>操作系统通过几个基本的抽象概念(进程、虚拟存储器和文件)来实现这两个功能。</p>
<p><strong>Unix 和 Posix</strong></p>
<p>20 世纪 60 年代是大型、复杂操作系统盛行的年代，如 IBM 的 OS/360 和 Honeywell 的 Multics 系统。贝尔实验室曾经是 Multics 项目的最初参与者，但是因为项目复杂和缺乏进展于 1969 年退出。这之后一组贝尔实验室的研究人员(Ken Thompson, Dennis Ritchie, Doug Mcllroy &amp; Joe Ossanna)从1969年开始在 DEC PDP-7 计算机上完全用机器语言编写了一个简单得多的系统，1970 年 Brian Kernighan 命名为“Unix”。1973 年用 C 语言重新编写内核，1974年开始对外发布。</p>
<p>发布之后不同的 Unix 厂商加入新的、往往不兼容的特性来使它们的程序与众不同，也带来很多麻烦，为了阻止这种趋势，IEEE 开始努力标准化 Unix 的开发，后来由 Richard Stallman 命名为“Posix”，称为 Posix 标准。</p>
<blockquote>
<p>进程</p>
</blockquote>
<p><strong>进程</strong>是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。无论是在单核还是多核系统中，一个 CPU 看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的，这种交错执行的机制称为<strong>上下文切换</strong>。</p>
<p>操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是<strong>上下文</strong>，它包括许多信息，例如 PC 和寄存器文件的当前值，以及主存的内容。</p>
<p><img src="/images/csapp1.12.jpg" alt="csapp1.12"></p>
<blockquote>
<p>线程</p>
</blockquote>
<p>一个进程实际上可以由多个称为<strong>线程</strong>的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器对并行处理的需求，线程称为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，一般来说也更高效。</p>
<blockquote>
<p>虚拟存储器</p>
</blockquote>
<p><strong>虚拟存储器</strong>是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的是一致的存储器，称为<strong>虚拟地址空间</strong>。</p>
<p>在 Linux 中，地址空间最上面的区域是为操作系统中的代码和数据保留的，这对所有进程来说都是一样的。地址空间的底部区域存放用户进程定义的代码和数据，请注意，图中的地址是从下往上增大的。</p>
<p><img src="/images/csapp1.13.jpg" alt="csapp1.13"></p>
<p>从最低的地址开始，逐步向上介绍：</p>
<ul>
<li><strong>程序代码和数据</strong>。对于所有的进程来说，代码是从同一固定地址开始，紧接着是和 C 全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。</li>
<li><strong>堆</strong>。代码和数据区后紧随着的是运行时堆。代码和数据区是在进程一开始运行就被规定了大小，与此不同，当调用如 <code>malloc</code> 和 <code>free</code> 这样的 C 标准库函数时，对可以在运行时动态地扩展和收缩。</li>
<li><strong>共享库</strong>。大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。</li>
<li><strong>栈</strong>。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。</li>
<li><strong>内核虚拟存储器</strong>。内核总是主流在内存中，是操作系统的一部分。地址空间顶部的区域是为内核保留的，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。</li>
</ul>
<blockquote>
<p>文件</p>
</blockquote>
<p><strong>文件</strong>就是字节序列，仅此而已。这个简单而精致的概念拥有极其丰富的内涵，它向应用程序提供了一个统一的视角，来看待系统中可能含有的所有 I/O 设备。</p>
<h2 id="u7CFB_u7EDF_u4E4B_u95F4_u5229_u7528_u7F51_u7EDC_u901A_u4FE1"><a href="#u7CFB_u7EDF_u4E4B_u95F4_u5229_u7528_u7F51_u7EDC_u901A_u4FE1" class="headerlink" title="系统之间利用网络通信"></a>系统之间利用网络通信</h2><p>从一个单独的系统来看，网络可视为一个 I/O 设备。当系统从主存将一串字节复制到网络适配器时，数据流经过网络到达另一台机器，而不是其他地方。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。</p>
<p><img src="/images/csapp1.14.jpg" alt="csapp1.14"></p>
<h2 id="u91CD_u8981_u4E3B_u9898"><a href="#u91CD_u8981_u4E3B_u9898" class="headerlink" title="重要主题"></a>重要主题</h2><p>系统不仅仅只是硬件，而是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序的最终目的。下面是几个贯穿计算机系统所有方面的重要概念：</p>
<blockquote>
<p>并发和并行</p>
</blockquote>
<p><strong>并发(concurrency)</strong>是一个通用的概念，指一个同时具有多个活动的系统；<strong>并行(parallelism)</strong>指的是用并发使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。</p>
<p><strong>1.线程级并发</strong></p>
<p>传统意义上，这种并发执行只是模拟出来的，是通过正在执行的进程间快速切换的方式实现的，这种配置称为<strong>单处理器系统</strong>。</p>
<p><img src="/images/csapp1.16.jpg" alt="csapp1.16"></p>
<p>当构建一个由单操作系统内核控制的多处理器组成的系统时，就得到了一个<strong>多处理器系统</strong>。超线程，有时称为<strong>同时多线程(simultaneous multi-threading)</strong>，是一项允许一个 CPU 执行多个控制流的技术。</p>
<p><img src="/images/csapp1.17.jpg" alt="csapp1.17"></p>
<p>多处理器的使用可以从两个方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。其次，它可以使应用程序运行得更快。</p>
<p><strong>2.指令级并行</strong></p>
<p>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为<strong>指令级并行</strong>。流水线(pipelining)的引入使得指令并行成为可能。如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为<strong>超标量(superscalar)</strong>处理器。</p>
<p><strong>3.单指令、多数据并行</strong></p>
<p>在最低层次上，许多处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，即 SIMD 并行。</p>
<blockquote>
<p>计算机系统中抽象的重要性</p>
</blockquote>
<p><strong>抽象</strong>的使用是计算机科学中最为重要的概念之一。</p>
<p><img src="/images/csapp1.18.jpg" alt="csapp1.18"></p>
<p>在处理器里，<strong>指令集结构</strong>提供了对实际处理器硬件的抽象。在操作系统中：<strong>文件</strong>是对 I/O 的抽象，<strong>虚拟存储器</strong>是对程序存储器的抽象，而<strong>进程</strong>是对一个正在运行的程序的抽象。虚拟机则是对整个计算机(包括操作系统、处理器和程序)的抽象。</p>
<hr>
<p><strong>第一部分：程序结构和执行</strong></p>
<p>计算机由处理器和存储器子系统组成。在核心部分，我们需要方法来表示基本数据类型，比如整数和实数运算的近似值。然后，我们考虑机器级指令如何操作这样的数据，以及编译器如何将 C 程序翻译成这样的指令。这一部分将帮助你深入了解如何表示和执行应用程序。</p>
<h1 id="u4FE1_u606F_u7684_u8868_u793A_u548C_u5904_u7406"><a href="#u4FE1_u606F_u7684_u8868_u793A_u548C_u5904_u7406" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h1><p>单个 bit 不是非常有用，然而，当把 bit 组合在一起，再加上某种解释(interpretation)，即给不同的可能位模式赋予含义，就能够表示任何有限集合的元素。计算机的表示法适用有限数量的 bit 来对一个数字编码，因此，当结果太大以至于不能表示时，某些运算就会<strong>溢出(overflow)</strong>。</p>
<p>浮点运算有完全不同的数学属性，由于精度有限，浮点运算是不可结合的。整数的表示虽然只能编码一个相对较小的数值范围，但这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但这种表示只是近似的。</p>
<p><strong>C 编程语言的演变</strong></p>
<p>C -> ANSI C -> ISO C90 -> ISO C99</p>
<p>GNU 编译器套装(GNU Compiler Collection, GCC)可以基于不同的命令行选项，依照多个不同版本的 C 语言规则来编译程序。</p>
<p><img src="/images/csapp2.1.jpg" alt="csapp2.1"></p>
<h2 id="u4FE1_u606F_u5B58_u50A8"><a href="#u4FE1_u606F_u5B58_u50A8" class="headerlink" title="信息存储"></a>信息存储</h2><p>大多数计算机使用8位的块，或者 byte 作为最小的可寻址的存储器单位，而不是在存储器中访问单独的 bit。机器级程序将存储器视为一个非常大的字节数组，称为<strong>虚拟存储器(virtual memory)</strong>。存储器的每个字节都由一个唯一的数字来标识，称为它的<strong>地址(address)</strong>，所有可能的地址集合称为<strong>虚拟地址空间(virtual address space)</strong>。</p>
<blockquote>
<p>十六进制表示法</p>
</blockquote>
<p>一个 byte 由 8 个 bit 组成。在二进制表示法中，它的值域是 00000000(2) ~ 11111111(2)；如果用十进制整数表示，它的值域就是 0 ~ 255。用十六进制书写，一个字节的值域为 00(16) ~ FF(16)。</p>
<p><img src="/images/csapp2.2.jpg" alt="csapp2.2"></p>
<blockquote>
<p>字</p>
</blockquote>
<p>每台计算机都有一个<strong>字长(word size)</strong>，指明整数和指针数据的<strong>标称大小(nominal size)</strong>。因为虚拟地址是以这样一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长尾 w 位的机器而言，虚拟地址的范围为 0 ~ 2^(w-1)，程序最多访问 2^w 个字节。现在的 32 位机器指的就是字长是 32 位，就限定了虚拟地址空间为 4GB。</p>
<blockquote>
<p>数据大小</p>
</blockquote>
<p>计算机和编译器支持多种不同方式编码的数字格式，如整数和浮点数，以及其他长度的数字。</p>
<p><img src="/images/csapp2.3.jpg" alt="csapp2.3"></p>
<p>程序员应该力图使他们的程序在不同的机器和编译器上是可移植的。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。</p>
<blockquote>
<p>寻址和字节顺序</p>
</blockquote>
<p>对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在存储器中如何排列这些字节。</p>
<p>某些机器选择在存储器中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则——最低有效字节在最前面的方式，称为<strong>小端法(little endian)</strong>。后一种规则——最高有效字节在最前面的方式，称为<strong>大端法(big endian)</strong>。许多比较新的微处理器使用<strong>双端法(bi-edian)</strong>，也就是说可以把它们配置成作为大端或者小端的机器运行。</p>
<p>几种机器所使用的字节顺序会成为问题的情况：</p>
<ol>
<li>在不同类型的机器之间通过网络传送二进制数据。</li>
<li>当阅读表示整数数据的字节序列时，字节顺序也很重要。</li>
<li>当编写规避正常的类型的系统时。</li>
</ol>
<p><strong>使用 typedef 命名数据类型</strong></p>
<p>C 语言中的 typedef 声明提供了一种给数据类型命名的方式。这能够极大地改善代码的可读性，因为深度嵌套的类型声明很难读懂。typedef 的语法与声明变量的语法十分相似，除了它使用的是类型名，而不是变量名。</p>
<blockquote>
<p>表示字符串</p>
</blockquote>
<p>C 语言中字符串被编码为一个以 null(其值为 0)字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是 ASCII 字符码。在使用 ASCII 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关，因此文本数据比二进制数据具有更强的平台独立性。</p>
<p><img src="/images/csapp0.2.jpg" alt="csapp0.2"></p>
<blockquote>
<p>表示代码</p>
</blockquote>
<p>考虑下面的 C 函数：</p>
<pre><code>int sum(int x, int y) {
    return x + y;
}
</code></pre><p>当我们在示例机器上编译时，生成如下字节表示的机器代码：</p>
<p><img src="/images/csapp0.3.jpg" alt="csapp0.3"></p>
<p>可以看到指令编码是不同的。不同的机器类型使用不同的且不兼容的指令和编码方式。因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。</p>
<blockquote>
<p>布尔代数简介</p>
</blockquote>
<p>二进制是计算机编码、存储和操作信息的核心，所以围绕 0 和 1 的研究演化出了丰富的数学知识体系。</p>
<p><img src="/images/csapp2.7.jpg" alt="csapp2.7"></p>
<blockquote>
<p>C 语言中的位级运算</p>
</blockquote>
<p>C 语言支持按位布尔运算，确定一个位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制并执行二进制运算，然后转换回十六进制。</p>
<p>位级运算的一个常见用法就是实现<strong>掩码</strong>运算，这里的掩码是一个位模式，表示从一个字中选出的位的集合。</p>
<blockquote>
<p>C 语言中的逻辑运算</p>
</blockquote>
<p>C 语言还提供了一组逻辑运算符 ||、&amp;&amp; 和 !，分别对应于命题逻辑中的 OR、AND 和 NOT 运算。</p>
<blockquote>
<p>C 语言中的移位运算</p>
</blockquote>
<p>C 语言还提供了一组移位运算，以便向左或者向右移动位模式：\&lt;\&lt;、>>。</p>
<p>x \&lt;\&lt; k 会生成一个值，x 向左移动 k 位，丢弃最高的 k 位，并在右端补 k 个 0。</p>
<p>右移 x >> k 比较微妙，一般而言，机器支持两种形式的右移：逻辑右移(补 0)和算术右移(补 1)。对于无符号数据，右移必须是逻辑的。对于有符号数据，几乎所有的编译器 / 机器组合都使用算术右移。</p>
<h2 id="u6574_u6570_u8868_u793A"><a href="#u6574_u6570_u8868_u793A" class="headerlink" title="整数表示"></a>整数表示</h2><blockquote>
<p>整型数据类型</p>
</blockquote>
<p>C 语言支持多种整型数据类型——表示有限范围的整数。C 语言标准定义了每种数据类型必须能够表示的最小的取值范围。</p>
<p><img src="/images/csapp2.8.jpg" alt="csapp2.8"></p>
<p><img src="/images/csapp2.9.jpg" alt="csapp2.9"></p>
<p><img src="/images/csapp2.10.jpg" alt="csapp2.10"></p>
<blockquote>
<p>无符号数的编码</p>
</blockquote>
<p>假设一共有 w 位，每个介于 0 ~ 2^w -1 之间的数都有唯一一个 w 位的值编码，即这个函数映射是一个双射。</p>
<blockquote>
<p>补码(two’s-complement)编码</p>
</blockquote>
<p>字的最高有效位解释为负权(negative weight)。</p>
<p><img src="/images/csapp2.13.jpg" alt="csapp2.13"></p>
<p>C 语言标准并没有要求用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。</p>
<p>其他的表示方法有<strong>反码(ones’ complement)</strong>和<strong>原码(sign-magnitude)</strong>，这两种表示方法都有一个奇怪的属性，就是对于数字 0 有两种不同的编码方式。</p>
<blockquote>
<p>有符号数和无符号数之间的转换</p>
</blockquote>
<p><img src="/images/csapp2.17.jpg" alt="csapp2.17"></p>
<blockquote>
<p>C 语言中的有符号数与无符号数</p>
</blockquote>
<p>C 语言允许无符号数和有符号数之间的转换。转换的原则是底层的位表示保持不变。</p>
<p><img src="/images/csapp2.18.jpg" alt="csapp2.18"></p>
<blockquote>
<p>扩展一个数字的位表示</p>
</blockquote>
<p>将一个无符号数转换为一个更大的数据类型，我们只需要简单地在表示的开头添加 0，这种运算称为<strong>零扩展(zero extension)</strong>。将一个补码数字转换为一个更大的数据类型可以执行<strong>符号扩展(sign extension)</strong>，规则是在表示中添加最高有效位的值的副本。</p>
<blockquote>
<p>截断数字</p>
</blockquote>
<p>截断一个数字可能会改变它的值——溢出的一种形式。</p>
<blockquote>
<p>关于有符号树与无符号数的建议</p>
</blockquote>
<p>有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换细微差别的错误很难被发现。因为这种强制类型转换是在代码中没有明确指示的情况下发生的，程序员经常忽视了它的影响。</p>
<p>避免这类错误的一种方法就是绝不使用无符号数。实际上，除了 C 以外，很少有语言支持无符号整数。</p>
<h2 id="u6574_u6570_u8FD0_u7B97"><a href="#u6574_u6570_u8FD0_u7B97" class="headerlink" title="整数运算"></a>整数运算</h2><p>理解计算机运算的细微之处能够帮助程序员编写更可靠的代码。</p>
<blockquote>
<p>无符号加法</p>
</blockquote>
<p>考虑两个非负整数 x 和 y，满足 $0 ≤ x, y ≤ 2^w - 1$。每个数都能表示为 w 位无符号数字。如果计算它们的和，我们就有一个可能的范围 $0 ≤ x + y ≤ 2^(w+1) - 2$，表示这个和可能需要 w + 1位。无符号运算可以被视为一种模运算形式。</p>
<blockquote>
<p>补码加法</p>
</blockquote>
<p>必须确定当结果太大(为正)或者太小(为负)时，应该做些什么。</p>
<p><img src="/images/csapp2.24.jpg" alt="csapp2.24"></p>
<blockquote>
<p>补码乘法</p>
</blockquote>
<p><img src="/images/csapp2.26.jpg" alt="csapp2.26"></p>
<blockquote>
<p>乘以常数</p>
</blockquote>
<p>在大多数机器上，整数乘法指令相当慢，需要 10 个或者更多的时钟周期，然而其他整数运算(例如加法、减法、位级运算和移位)只需要 1 个时钟周期。因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。</p>
<p>例如，假设一个程序包含表达式 x * 14。利用等式 $14 = 2^3 + 2^2 + 2^1$，编译器会将乘法重写为 (x \&lt;\&lt; 3) + (x \&lt;\&lt; 2) + (x \&lt;\&lt; 1)，实现了将一个乘法替换为三个移位和两个加法。更好的方法是 $14 = 2^4 - 2^1$，将乘法重写为(x \&lt;\&lt; 4) - (x \&lt;\&lt; 1)，这时只需要两个移位和一个减法。</p>
<blockquote>
<p>除以 2 的幂</p>
</blockquote>
<p>在大多数机器上，整数除法要比整数乘法更慢——需要 30 个或者更多的周期。除以 2 的幂也可以用移位运算右移来实现，无符号和补码数分别使用逻辑移位和算术移位来达到目的。</p>
<blockquote>
<p>关于整数运算的最后思考</p>
</blockquote>
<p>计算机执行“整数”运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。补码表示提供了一种既能表示负数也能表示正数的灵活方法，同时使用了与执行无符号算术相同的位级实现。</p>
<h2 id="u6D6E_u70B9_u6570"><a href="#u6D6E_u70B9_u6570" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点表示对形如 V = x * 2^y 的有理数进行编码，IEEE 标准 754 规定了如何表示浮点数及其运算。</p>
<blockquote>
<p>二进制小数</p>
</blockquote>
<p><img src="/images/csapp2.30.jpg" alt="csapp2.30"></p>
<p>增加二进制表示的长度可以提高表示的精度。</p>
<blockquote>
<p>IEEE 浮点表示</p>
</blockquote>
<p>用 V = (-1)^s * M * 2^E 的形式来表示一个数：</p>
<ul>
<li>符号(sign) s决定这个数是负数(s=1)还是正数(s=0)，对于数值 0 的符号位解释作为特殊情况处理。</li>
<li>尾数(significand) M 是一个二进制小数，它的范围是 1 ~ 2 - ε，或者是 0 ~ 1 - ε。</li>
<li>阶码(exponent) E 的作用是对浮点数加权，这个权重是 2 的 E 次幂(可能是负数)</li>
</ul>
<p>将浮点数的位表示划分为三个字段，分别对这些值进行编码：</p>
<ul>
<li>一个单独的符号位 s 直接编码符号 s。</li>
<li>k 位的阶码字段 exp = e(k-1)…e(1)e(0) 编码阶码 E。</li>
<li>n 位小数字段 frac = f(n-1)…f(1)f(0) 编码尾数 M，但是编码出来的值也依赖于阶码字段的值是否等于 0。</li>
</ul>
<p><img src="/images/csapp2.31.jpg" alt="csapp2.31"></p>
<p><img src="/images/csapp2.32.jpg" alt="csapp2.32"></p>
<blockquote>
<p>2.4.3 数字示例</p>
</blockquote>
<p><img src="/images/csapp2.33.jpg" alt="csapp2.33"></p>
<p><img src="/images/csapp2.34.jpg" alt="csapp2.34"></p>
<blockquote>
<p>2.4.4 舍入(rounding)</p>
</blockquote>
<p>因为表示方法限制类浮点数的范围和精度，浮点运算只能近似地表示实数运算。因此，对于值 x，我们一般想用一种系统的方法，能够找到“最接近的”匹配值，这就是舍入运算的任务。</p>
<blockquote>
<p>2.4.5 浮点运算</p>
</blockquote>
<p>浮点加法不具有结合性。浮点乘法在加法上不具备分配性。对于科学计算程序员和编译器编写者来说，这是很严重的问题，即使为了在三维空间中确定两条线是否交叉而写代码这样看上去很简单的任务，也可能成为一个很大的挑战。</p>
<blockquote>
<p>2.4.6 C 语言中的浮点数</p>
</blockquote>
<p>float 和 double。在 int、float 和 double 格式之间进行强制类型转换时，程序改变数值和位模式的原则如下(假设 int 是 32 位的)：</p>
<ul>
<li>从 int 转换成 float，不会溢出，可能被舍入。</li>
<li>从 int 或 float 转换成 double，能够保留精确的数值。</li>
<li>从 double 转换成 float，可能溢出成为正无穷或负无穷，也可能被舍入。</li>
<li>从 float 或者 double 转换成 int，值会向零舍入。例如 1.999 将被转换成 1。</li>
</ul>
<h2 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h2><p>计算机将信息按位编码，通常组织成字节序列。用不同的编码方式表示整数、实数和字符串。不同的计算机模型在编码数字和多字节数据中的字节排序时使用不同的约定。</p>
<p>由于编码的长度有限，与传统整数和实数运算想必，计算机运算具有完全不同的属性。当超出表示范围时，有限长度能够引起数值溢出。当浮点数非常接近于 0.0，从而转换成零时，也会瞎溢。</p>
<p>必须非常小心地使用浮点运算，因为浮点运算只有有限的范围和精度，而且不遵守普遍的算术属性，比如结合性。</p>
<h1 id="u7A0B_u5E8F_u7684_u673A_u5668_u7EA7_u8868_u793A"><a href="#u7A0B_u5E8F_u7684_u673A_u5668_u7EA7_u8868_u793A" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h1><p>计算机执行<strong>机器代码</strong>，用字节序列编码低级的操作，包括处理数据、管理存储器、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的原则、目标机器的指令集和操作系统遵循的规则，经过一系列的阶段产生机器代码。GCC C 语言汇编器以<strong>汇编代码</strong>的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后 GCC 调用<strong>汇编器</strong>和<strong>链接器</strong>，从而根据汇编代码生成可执行的机器代码。</p>
<h2 id="u5386_u53F2_u89C2_u70B9"><a href="#u5386_u53F2_u89C2_u70B9" class="headerlink" title="历史观点"></a>历史观点</h2><p>Intel 处理器系列俗称 x86，经历了一个长期的、不断进化的发展过程。</p>
<h2 id="u7A0B_u5E8F_u7F16_u7801"><a href="#u7A0B_u5E8F_u7F16_u7801" class="headerlink" title="程序编码"></a>程序编码</h2><p>假设一个 C 程序，有两个文件 p1.c 和 p2.c。我们在一台 IA32 机器上，用 Unix 命令行编译这些代码如下：</p>
<pre><code>unix&gt; gcc -O1 -o p p1.c p2.c
</code></pre><p>编译选项 -O1 告诉编译器使用第一级优化。使用更高级别的优化产生的代码会严重改变形式，以至于产生的机器代码和初始源代码之间的关系非常难以理解。实际中，从得到的程序性能方面考虑，第二级优化(-O2)被认为是较好的选择。</p>
<p>实际上 gcc 命令调用了一系列程序，将源代码转化成可执行代码。首先，<strong>C 预处理器</strong>扩展源代码，插入所有用 #include 命令指定的文件，并扩展所有用 #define 声明指定的宏。然后，<strong>编译器</strong>产生两个源代码的汇编代码，名字分别为 p1.s 和 p2.s。接下来，<strong>汇编器</strong>将汇编代码转化成二进制目标代码，文件名为 p1.o 和 p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入地址的全局值。最后，<strong>链接器</strong>将两个目标代码文件与实现库函数(例如 printf )的代码合并，并产生最终的可执行代码文件 p。</p>
<blockquote>
<p>机器级代码</p>
</blockquote>
<p>对于机器级变成来说，有两种抽象非常重要。第一种是机器级程序的格式和行为，定义为指<strong>令集体系结构(Instruction set architecture, ISA)</strong>，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。第二种抽象是，机器级程序使用的存储器地址是虚拟地址，提供的存储器模型看上去是一个非常大的字节数组。</p>
<p>在整个编译过程中，编译器会完成大部分的工作，将把用 C 语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。汇编代码非常接近于机器代码，与机器代码的二进制格式相比，汇编代码有一个主要特点，即它用可读性更好的文本格式来表示。能够理解汇编代码和它与原始的 C 代码的联系，是理解计算机如何执行程序的关键一步。</p>
<p>IA32 机器代码和原始的 C 代码差别非常大。一些通常对 C 语言程序员隐藏的处理器状态是可见的：</p>
<ul>
<li><strong>程序计数器</strong>(PC，用 %eip 表示)指示将要执行的下一条指令在存储器中的地址。</li>
<li>整数<strong>寄存器</strong>文件包含 8 个命名的位置，分别存储 32 位的值。这些寄存器可以存储地址(对应于 C 语言的指针)或证书数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器则用来保存临时数据。</li>
<li>条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化。</li>
<li>一组浮点寄存器存放浮点数据。</li>
</ul>
<p>汇编代码不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分指针和整数。</p>
<p>程序存储器(program memory)包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的存储器块。</p>
<p>一条指令只执行一个非常基本的操作。例如，将存放在寄存器中的两个数字相加，在存储器和寄存器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从而实现(像算术表达式求值、循环或过程调用和返回这样的)程序结构。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>假设我们写了一个 C 语言代码文件 code.c，内容如下：</p>
<pre><code>int accum = 0;

int sum(int x, int y){
    int t = x + y;
    accum += t;
    return t;
}
</code></pre><p>在命令行上使用 <code>-S</code> 选项，就能得到 C 语言编译器产生的汇编代码：</p>
<pre><code>unix&gt; gcc -O1 -S code.c
</code></pre><p>GCC 会运行编译器，产生一个汇编文件 code.s，但是不做其他进一步的工作。如果我们使用 <code>-c</code> 命令行选项，GCC 会编译并汇编该代码：</p>
<pre><code>unix&gt; gcc -O1 -c code.c
</code></pre><p>这就会产生目标代码文件 code.o，它是二进制格式，无法直接查看。机器实际执行的程序只是对一系列指令进行编码的字节序列。及其对产生这些指令的源代码几乎一无所知。</p>
<blockquote>
<p>关于格式的注释</p>
</blockquote>
<p>所有以 <code>.</code> 开头的行都是指导汇编器和链接器的命令，我们通常可以忽略这些行。</p>
<blockquote>
<p>数据格式</p>
</blockquote>
<p>由于是从 16 位体系结构扩展成 32 位的，Intel 用术语 word 表示 16 位数据类型。因此，称 32 位数为 double words，称 64 位数为 quad words。后面遇到的大多数指令都是对 word 或者 double words 操作的。</p>
<p><img src="/images/csapp3.1.jpg" alt="csapp3.1"></p>
<h2 id="u8BBF_u95EE_u4FE1_u606F"><a href="#u8BBF_u95EE_u4FE1_u606F" class="headerlink" title="访问信息"></a>访问信息</h2><p>一个 IA32 CPU 包含一组 8 个存储 32 位值的寄存器。这些寄存器用来存储整数数据和指针。它们的名字都以 %e 开头，不过它们都另有特殊的名字。</p>
<p><img src="/images/csapp3.2.jpg" alt="csapp3.2"></p>
<p>对前三个寄存器(%eax, %ecx, %edx)的保存和恢复惯例不同于接下来的三个寄存器(%ebx, %edi, %esi)。最后两个寄存器(%ebp, %esp)保存着指向程序栈中重要位置的指针。只有根据栈管理的标准惯例才能修改这两个寄存器中的值。</p>
<p>字节操作指令可以独立地读写前 4 个寄存器的 2 个低位字节。8086 中提供这样的特性是为了兼容 8008 和 8080。当一条字节指令更新这些单字节“寄存器元素”中的一个时，余下的 3 个字节不会改变。</p>
<blockquote>
<p>操作数指示符</p>
</blockquote>
<p>大多数指令有一个或多个<strong>操作数(operand)</strong>，指示出执行一个操作中要引用的源数据值，以及放置结果的目标位置。操作数可能被分为三种类型：</p>
<ol>
<li>立即数(immediate)，也就是常数值</li>
<li>寄存器(register)，表示某个寄存器的内容</li>
<li>存储器(memory)引用，它会根据计算出来的地址访问某个存储器位置</li>
</ol>
<p><img src="/images/csapp3.3.jpg" alt="csapp3.3"></p>
<blockquote>
<p>数据传送指令</p>
</blockquote>
<p>将数据从一个位置复制到另一个位置的指令是最频繁使用的指令。操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条指令才能完成的功能。</p>
<p><img src="/images/csapp3.4.jpg" alt="csapp3.4"></p>
<h2 id="u7B97_u672F_u548C_u903B_u8F91_u64CD_u4F5C"><a href="#u7B97_u672F_u548C_u903B_u8F91_u64CD_u4F5C" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h2><p>给出的每个指令类都有对字节、字和双字数据进行操作的指令。这些操作被分为四组：加载有效地址、亿元操作、二元操作和移位。</p>
<blockquote>
<p>加载有效地址</p>
</blockquote>
<p>加载有效地址(load effective address)指令 leal 实际上是 movl 指令的变形。它的指令形式是从存储器读数据到寄存器，但实际上它根本就没有引用存储器。它的第一个操作数看上去是一个存储器引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。</p>
<p><img src="/images/csapp3.7.jpg" alt="csapp3.7"></p>
<blockquote>
<p>一元操作和二元操作</p>
</blockquote>
<p>一元操作：一个操作数既是源又是目的</p>
<p>二元操作：第二个操作数既是源又是目的</p>
<blockquote>
<p>移位操作</p>
</blockquote>
<p>先给出移位量，第二项给出的是要移位的位数，可以进行算术和逻辑右移。</p>
<blockquote>
<p>讨论</p>
</blockquote>
<p><img src="/images/csapp3.8.jpg" alt="csapp3.8"></p>
<blockquote>
<p>特殊的算术操作</p>
</blockquote>
<p><img src="/images/csapp3.9.jpg" alt="csapp3.9"></p>
<h2 id="u63A7_u5236"><a href="#u63A7_u5236" class="headerlink" title="控制"></a>控制</h2><p>机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。</p>
<blockquote>
<p>条件码</p>
</blockquote>
<p>除了整数寄存器，CPU 还维护着一组单个 bit 的<strong>条件码(condition code)</strong> 寄存器，他们描述了最近的算术或逻辑操作的属性。</p>
<p><img src="/images/csapp0.4.jpg" alt="csapp0.4"></p>
<p><img src="/images/csapp3.10.jpg" alt="csapp3.10"></p>
<blockquote>
<p>访问条件码</p>
</blockquote>
<p>条件码通常不会直接读取，常用的使用方法有三种：</p>
<ol>
<li>可以根据条件码的某个组合，将一个字节设置为 0 或者 1</li>
<li>可以条件跳转到程序的某个其他的部分</li>
<li>可以有条件地传送数据</li>
</ol>
<p><img src="/images/csapp3.11.jpg" alt="csapp3.11"></p>
<blockquote>
<p>跳转指令及其编码</p>
</blockquote>
<p>跳转(jump)指令会导致执行切换到程序中的一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号(label)指明。</p>
<p><img src="/images/csapp3.12.jpg" alt="csapp3.12"></p>
<blockquote>
<p>翻译条件分支</p>
</blockquote>
<p>将条件表达式和语句从 C 语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转</p>
<p><img src="/images/csapp3.13.jpg" alt="csapp3.13"></p>
<blockquote>
<p>循环</p>
</blockquote>
<p>汇编中没有循环结构的指令存在，可以用条件测试和跳转组合起来实现循环的效果。大多数汇编器根据一个循环的 do-while形式来产生循环代码，即使在实际程序中这种形式用得相对较少。</p>
<p><img src="/images/csapp3.14.jpg" alt="csapp3.14"></p>
<p><img src="/images/csapp3.15.jpg" alt="csapp3.15"></p>
<blockquote>
<p>条件传送指令</p>
</blockquote>
<p>实现条件操作的传统方法是利用控制的条件转移。当条件满足时，程序沿着一条执行路径进行，反之走另一条路径。这种机制简单而通用，但是在现代处理器上，它可能会非常低效率。</p>
<p>数据的条件转移是一种替代的策略。这种方法先计算一个条件操作的两种结果，然后再根据条件是否满足从而选取一个。只有在一些受限制的情况下，这种策略才可行，但是如果可行，就可以用一条简单的条件传送指令来实现它。条件传送指令更好地匹配了现代处理器的性能特征。</p>
<p><img src="/images/csapp3.16.jpg" alt="csapp3.16"></p>
<p>这个机制和分支预测紧密相关。</p>
<p><img src="/images/csapp3.17.jpg" alt="csapp3.17"></p>
<blockquote>
<p>switch 语句</p>
</blockquote>
<p>switch 语句可以根据一个整数索引值进行多重分支(multi-way branching)。不仅提高了 C 代码的可读性，而且通过使用<strong>跳转表(jump table)</strong>和使用一组很长的 if-else 语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。GCC 根据开关情况的数量和开关情况值的 sprsity 来翻译开关语句。</p>
<p><img src="/images/csapp3.18.jpg" alt="csapp3.18"></p>
<h2 id="u8FC7_u7A0B"><a href="#u8FC7_u7A0B" class="headerlink" title="过程"></a>过程</h2><p>一个过程调用包括将数据和控制从代码的一部分传递到另一部分。另外，它还必须在进入时为过程的局部变量分配空间，并在退出时释放这些空间。大多数机器，包括 IA32，只提供转移控制到过程和从过程转移出控制这种简单的指令。数据传递、局部变量的分配和释放通过操纵程序栈来实现。</p>
<blockquote>
<p>栈帧结构</p>
</blockquote>
<p>IA32 程序用程序栈来支持过程调用。机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后回复，以及本地存储。为单个过程分配的那部分栈称为<strong>栈帧(stack frame)</strong>。</p>
<p><img src="/images/csapp3.21.jpg" alt="csapp3.21"></p>
<p>假设过程 P(调用者)调用过程 Q(被调用者)，则 Q 的参数放在 P 的栈帧中。另外，当 P 调用 Q 时，P 中的<strong>返回地址</strong>被压入栈中，形成 P 的栈帧的末尾。返回地址就是当程序从 Q 返回时应该继续执行的地方。</p>
<blockquote>
<p>转移控制</p>
</blockquote>
<p><img src="/images/csapp3.22.jpg" alt="csapp3.22"></p>
<blockquote>
<p>寄存器使用惯例</p>
</blockquote>
<p>程序寄存器组是唯一能够被所有过程共享的资源。虽然在给定时刻只能有一个过程是活动的，但是我们必须保证当一个过程调用另一个过程时，被调用者不会覆盖某个调用者稍后会使用的寄存器的值。</p>
<p>根据惯例，寄存器 %eax、%edx、%ecx 被划分为<strong>调用者保存</strong>寄存器。当过程 P 调用 Q 时，Q 可以覆盖这些寄存器，而不会破坏任何 P 所需要的数据。另一方面， 寄存器 %ebx、%esi、%edi 被划分为<strong>被调用者保存</strong>寄存器。</p>
<blockquote>
<p>过程示例</p>
</blockquote>
<p><img src="/images/csapp3.24.jpg" alt="csapp3.24"></p>
<blockquote>
<p>递归过程</p>
</blockquote>
<p><img src="/images/csapp3.25.jpg" alt="csapp3.25"></p>
<p><img src="/images/csapp3.27.jpg" alt="csapp3.27"></p>
<h2 id="u6570_u7EC4_u5206_u914D_u548C_u8BBF_u95EE"><a href="#u6570_u7EC4_u5206_u914D_u548C_u8BBF_u95EE" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h2><p>C 语言实现数组的方式非常简单，因此很容易翻译成机器代码。C 语言一个不同寻常的特点是可以产生指向数组中元素的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译成地址计算。</p>
<p>优化编译器非常善于简化数组索引所使用的地址计算。不过这使得 C 代码和它机器代码的翻译之间的对应关系有些难以理解。</p>
<blockquote>
<p>基本原则</p>
</blockquote>
<p>对于数据类型 T 和整型常数 N，声明如下：</p>
<pre><code>T A[N];
</code></pre><p>它有两个效果。首先，它在存储器中分配一个 L*N 字节的连续区域；这里 L 是数据类型 T 的大小(单位为字节)。可以用从 0 到 N-1 之间的整数索引来访问数组元素。数组元素 i 会被存放在地址为 xa + L * i 的地方(xa 为指向数组开头的指针)</p>
<p><img src="/images/csapp0.5.jpg" alt="csapp0.5"></p>
<blockquote>
<p>指针运算</p>
</blockquote>
<p>C 语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。也就是说，如果 p 是一个指向类型为 T 的数据的指针，p 的值为 xp，那么表达式 p+i 的值为 xp+L*i，这里 L 是数据类型 T 的大小。</p>
<p><img src="/images/csapp0.6.jpg" alt="csapp0.6"></p>
<blockquote>
<p>嵌套的数组</p>
</blockquote>
<pre><code>int A[5][3];
</code></pre><p>等价于下面的声明</p>
<pre><code>typedef int row3_t[3];
row3_t A[5];
</code></pre><p>数据类型<code>row3_t</code>被定义为一个 3 个整数的数组。数组 A 包含 5 个这样的元素，每个元素需要 12 个字节来存储 3 个整数。整个数组的大小就是 4x5x3=60 字节。</p>
<p><img src="/images/csapp0.7.jpg" alt="csapp0.7"></p>
<blockquote>
<p>定长数组</p>
</blockquote>
<p>C 语言编译器能够优化定长多维数组上的操作代码。</p>
<p><img src="/images/csapp3.28.jpg" alt="csapp3.28"></p>
<blockquote>
<p>变长数组</p>
</blockquote>
<p><img src="/images/csapp3.29.jpg" alt="csapp3.29"></p>
<h2 id="u5F02_u8D28_u7684_u6570_u636E_u7ED3_u6784"><a href="#u5F02_u8D28_u7684_u6570_u636E_u7ED3_u6784" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h2><p>C 语言提供了两种结合不同类型的对象来创建数据类型的机制：<strong>结构(structure)</strong>，用关键字<code>struct</code>声明，将多个对象集合到一个单位中；<strong>联合(union)</strong>，用关键字<code>union</code>声明，允许用几种不同的类型来引用一个对象。</p>
<blockquote>
<p>结构</p>
</blockquote>
<p>创建一个数据类型，将可能不同类型的对象聚合到一个对象中。结构的各个组成部分用名字来引用。类似于数组的实现，结构的所有组成部分都存放在存储器中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段(field)的字节偏移。它以这些偏移作为存储器引用指令中的位移，从而产生对结构元素的引用。</p>
<blockquote>
<p>联合</p>
</blockquote>
<p>提供了一种方式，能够规避 C 语言的类型系统，允许以多种类型来引用一个对象。联合声明的语法与结构的语法一样，只不过语义相差比较大。它们是用不同的字段来引用相同的存储器块。</p>
<blockquote>
<p>数据对齐</p>
</blockquote>
<p>许多计算机系统对基本数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是某个值 K(通常是 2、4、8)。这种对齐限制简化了形成处理器和存储器系统之间接口的硬件设计</p>
<p><strong>强制对齐的情况</strong></p>
<p>对于大多数 IA32 指令来说，保持数据对齐能够提高效率，但是它不会影响程序的行为。另一方面，如果数据未对齐，有些实现多媒体操作的 SSE 指令就无法正确工作。</p>
<h2 id="u7EFC_u5408_uFF1A_u7406_u89E3_u6307_u9488"><a href="#u7EFC_u5408_uFF1A_u7406_u89E3_u6307_u9488" class="headerlink" title="综合：理解指针"></a>综合：理解指针</h2><p>指针是 C 语言的一个重要特征。它们以一种统一方式，对不同数据结构中的元素产生引用。这里介绍一些指针和它们映射到机器代码的关键原则。</p>
<ul>
<li><strong>每个指针都对应一个类型。</strong>这个类型表明指针指向哪一类对象。</li>
<li><strong>每个指针都有一个值。</strong>这个值是某个指定类型对象的地址。特殊的 NULL(0) 值表示该指针没有指向任何地方</li>
<li><strong>指针用 &amp; 运算符创建。</strong>这个运算符可以应用到任何 lvalue 类的 C 表达式上。</li>
<li><strong>操作符用于指针的间接引用。</strong>其结果是一个值，它的类型与该指针的类型相关。间接引用是通过存储器引用来实现的，要么是存储到一个指定的地址，要么是从指定的地址读取。</li>
<li><strong>数组与指针紧密联系。</strong>一个数组的名字可以像一个指针变量一样引用(但是不能修改)。数组引用与指针运算和间接引用有一样的效果。数组引用和指针运算都需要用对象大小对偏移量进行伸缩。</li>
<li><strong>将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。</strong>强制类型转换的一个效果是改变指针运算的伸缩。来看一个例子，如果 p 是一个 char* 类型的指针，那么表达式(int<em>)p+7 计算为 p+28, 而(int</em>)(p+7)计算为 p+7。</li>
<li>指针也可以指向函数。这提供了一个很强大的存储和向代码传递引用的功能，这些引用可以被程序的某个其他部分调用。</li>
</ul>
<p><strong>函数指针</strong></p>
<p>假如我们有一个函数<code>int fun(int x, int *p)</code>，然后我们可以声明一个指针<code>fp</code>，将它赋值为这个函数：</p>
<pre><code>(int)(*fp)(int, int *);
fp = fun;
</code></pre><p>然后用以下真真来调用这个函数</p>
<pre><code>int y = 1;
int result = fp(3, &amp;y);
</code></pre><h2 id="u5E94_u7528_uFF1A_u4F7F_u7528_GDB__u8C03_u8BD5_u5668"><a href="#u5E94_u7528_uFF1A_u4F7F_u7528_GDB__u8C03_u8BD5_u5668" class="headerlink" title="应用：使用 GDB 调试器"></a>应用：使用 GDB 调试器</h2><p>启动 GDB:</p>
<pre><code>unix&gt; gdb prog
</code></pre><h2 id="u5B58_u50A8_u5668_u7684_u8D8A_u754C_u5F15_u7528_u548C_u7F13_u51B2_u533A_u6EA2_u51FA"><a href="#u5B58_u50A8_u5668_u7684_u8D8A_u754C_u5F15_u7528_u548C_u7F13_u51B2_u533A_u6EA2_u51FA" class="headerlink" title="存储器的越界引用和缓冲区溢出"></a>存储器的越界引用和缓冲区溢出</h2><p>C 对于数组引用不进行任何边界检查，而局部变量和状态信息，都存放在栈中。这两种情况结合到一起就可能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行 ret 指令时，就会出现很严重的错误。</p>
<p>缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击系统安全的方法。通常，输入和程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为**攻击代码(exploit code)，另外还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么执行 ret 指令的效果就是跳转到攻击代码。</p>
<p>一种攻击形式，攻击代码会使用系统调用启动一个外壳程序，给攻击者提供一组操作系统函数。另一种攻击形式是，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行 ret 指令，(表面上)正常返回给调用者。</p>
<p><strong>对抗缓冲区溢出攻击</strong></p>
<p>1.<strong>栈随机化</strong></p>
<p>为了在系统中插入攻击代码，攻击者不但要插入代码，还需要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。在过去，程序的栈地址非常容易预测。对于所有运行同样程序和操作系统版本的系统来说，在不同的机器之间，栈的位置是相当固定的。用传染病来打比方，许多系统都容易受到同一种病毒的攻击，这种现象常称作<strong>安全单一化(security monoculture)</strong>。</p>
<p><strong>栈随机化</strong>的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。实现的方式是：程序开始时，在栈上分配一段 0-n 字节之间的随机大小的空间。</p>
<p>在 Linux 系统中，栈随机化已经变成了标准行为。它是更大一类技术中的一种，这类技术称为**地址空间布局随机化(Address-Space Layout Randomization)，或者简称 ASLR。</p>
<p>然而一个执着的攻击者总是能够用蛮力克服随机化，他可以反复地用不同的地址进行攻击。一种常见的把戏就是在实际的攻击代码前插入很长一段的 nop 指令。执行这种指令除了对程序计数器加一，使指针指向下一条指令之外，没有任何的效果。只要攻击者能够猜中这段序列中的某个地址，程序就会经过这个序列，到达攻击代码。这个序列常用的术语是“空操作雪橇”(nop sled)。</p>
<p>2.<strong>栈破坏检测</strong></p>
<p><strong>栈保护者(stack protector)</strong>机制，用来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的<strong>金丝雀(canary)</strong>值，也称为<strong>哨兵值(guard value)</strong>，如下图所示。这个值是在程序每次运行时随机产生的，因此，攻击者没有简单的办法能够知道它是什么。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个函数的某个操作改变了。如果是，那么程序异常终止。</p>
<p>3.限制可执行代码区域</p>
<p>消除攻击者向系统中插入可执行代码的能力，只有保存编译器产生的代码的那部分妇女初期才是可执行的，其他部分可以被限制为只允许读和写</p>
<p><img src="/images/csapp3.33.jpg" alt="csapp3.33"></p>
<h2 id="x86-64_3A__u5C06_IA32__u6269_u5C55_u5230_64__u4F4D"><a href="#x86-64_3A__u5C06_IA32__u6269_u5C55_u5230_64__u4F4D" class="headerlink" title="x86-64: 将 IA32 扩展到 64 位"></a>x86-64: 将 IA32 扩展到 64 位</h2><p>IA32 的 32 位字长已经成为限制微处理器能力不断增长的主要因素。最重要的是，机器的字长定义了程序能够使用的虚拟地址范围，32 位字长就是 4GB 虚拟地址空间。现在机器很容易就可以配置 4G 以上 RAM，但是系统却不能有效利用它。</p>
<p>Intel 和 AMD 提供的新硬件和以这些为目标的 GCC 新版本的组合，使得 x86-64 代码与为 IA32 机器生成的代码有极大的不同。主要特性如下：</p>
<ul>
<li>指针和长整数是 64 位长。整数运算支持 8/16/32/64 位数据类型</li>
<li>通用目的寄存器组从 8 个扩展到 16 个</li>
<li>许多程序状态都保存在寄存器中，而不是栈上</li>
<li>如果可能，条件操作用条件传送指令实现，会得到比传统分支代码更好的性能</li>
<li>浮点操作用面向寄存器的指令集来实现</li>
</ul>
<p><img src="/images/csapp3.34.jpg" alt="csapp3.34"></p>
<h2 id="u6D6E_u70B9_u7A0B_u5E8F_u7684_u673A_u5668_u7EA7_u8868_u793A"><a href="#u6D6E_u70B9_u7A0B_u5E8F_u7684_u673A_u5668_u7EA7_u8868_u793A" class="headerlink" title="浮点程序的机器级表示"></a>浮点程序的机器级表示</h2><p>我们把存储模型、指令和传递规则的组合称为机器的<strong>浮点体系结构</strong>。由于 x86 处理器有很长的发展演变历史，它提供了多种浮点体系结构，目前有两种还在使用：x87 和 SSE</p>
<h2 id="u5C0F_u7ED3-1"><a href="#u5C0F_u7ED3-1" class="headerlink" title="小结"></a>小结</h2><p>机器级程序和它们的汇编代码表示，与 C 程序的差别很大。在汇编语言程序中，各种数据类型之间的差别很小。程序是以指令序列来表示的，每条指令都完成一个单独的操作。部分程序状态，如寄存器和运行时栈，对程序员来说是直接可见的。</p>
<p>C 语言中缺乏边界检查，使得许多程序容易出现缓冲区溢出。虽然最近的运行时系统提供了安全保护，而且编译器帮助使得程序更加安全，但是这已经使许多系统容易收到入侵者的恶意攻击。</p>
<h1 id="u5904_u7406_u5668_u4F53_u7CFB_u7ED3_u6784"><a href="#u5904_u7406_u5668_u4F53_u7CFB_u7ED3_u6784" class="headerlink" title="处理器体系结构"></a>处理器体系结构</h1><p>现代微处理器可以称得上时人类创造的最复杂的系统之一。一个处理器支持的指令和指令的字节级编码称为它的<strong>指令集体系结构(Instruction-Set Architecture, ISA)</strong>。不同的处理器家族，有不同的 ISA。一个程序编译成在一种机器上运行。</p>
<p>注：这一章偏硬件实现部分将较为简略，具体参看原书。</p>
<h2 id="Y86__u6307_u4EE4_u96C6_u4F53_u7CFB_u7ED3_u6784"><a href="#Y86__u6307_u4EE4_u96C6_u4F53_u7CFB_u7ED3_u6784" class="headerlink" title="Y86 指令集体系结构"></a>Y86 指令集体系结构</h2><p>定义一个指令集体系结构，包括定义各种状态元素、指令集和它们的编码、一组编程规范和异常事件处理。</p>
<blockquote>
<p>程序员可见的状态</p>
</blockquote>
<p>如下图所示，Y86 程序中的每条指令都会读取或修改处理器状态的某些部分，这称为<strong>程序员可见状态</strong>。在处理器视线中，只要我们保证机器级程序能够访问程序员可见状态，就不需要完全按照 ISA 隐含的方式来表示和组织这个处理器状态。</p>
<p><img src="/images/csapp4.1.jpg" alt="csapp4.1"></p>
<p>Y86 处理器有 8 个程序寄存器(每个存储一个字，%esp 被入栈、出栈、调用和返回指令作为栈指针)，3 个一位的条件码(保存最近的算术或逻辑指令所造成影响的有关信息)，程序计数器 PC 存放当前正在执行指令的地址。</p>
<p>存储器，从概念上说就是一个很大的数组，保存这程序和数据。 Y86 程序使用<strong>虚拟地址</strong>来引用存储器位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或<strong>物理地址</strong>，指明数据实际保存在存储器中的哪个地方。</p>
<p>状态码 Stat 表明程序执行的总体状态，它会指示是正常运行，还是出现了某种异常。</p>
<blockquote>
<p>Y86 指令</p>
</blockquote>
<p><img src="/images/csapp4.2.jpg" alt="csapp4.2"></p>
<p>具体说明</p>
<ul>
<li>4 个 movl 相关指令，显式指明源和目的的格式。源可以是立即数(i)、寄存器(r)或存储器(m)。指令名字的第一个字母表明了源的类型，第二个字母指明了目的类型</li>
<li>4 个整数操作指令，即上图的 OPl，它们是 addl、subl、andl 和 xorl。它们只对寄存器数据进行操作，并设置 3 个条件码 ZF、SF 和 OF(零、符号和一处)</li>
<li>7 个跳转指令，即上图的 jXX，它们是 jmp、jle、jl、je、jne、jge 和 jg。根据分支指令的类型和条件码的设置来选择分支</li>
<li>6 个条件传送指令，即上图的 cmovXX：cmovle、cmovl、cmove、cmovne、cmovge 和 cmovg，只有当条件码满足所需要的约束时，才会更新目的寄存器的值</li>
<li>call 指令将返回地址入栈，然后跳到目的地址。ret 指令从这样的过程调用中返回</li>
<li>pushl 和 popl 指令实现了入栈和出栈</li>
<li>halt 指令停止指令的执行</li>
</ul>
<blockquote>
<p>指令编码</p>
</blockquote>
<p>每条指令需要 1~6 个字节不等，每条指令的第一个字节表明指令的类型。这个字节分为两个部分，每部分 4 位：高 4 位是<strong>代码(code)</strong>部分，低 4 位是<strong>功能(function)部分</strong>。</p>
<p><img src="/images/csapp4.3.jpg" alt="csapp4.3"></p>
<p>CISC vs RISC</p>
<p><img src="/images/csapp0.8.jpg" alt="csapp0.8"></p>
<h2 id="u903B_u8F91_u8BBE_u8BA1_u548C_u786C_u4EF6_u63A7_u5236_u8BED_u8A00_HCL"><a href="#u903B_u8F91_u8BBE_u8BA1_u548C_u786C_u4EF6_u63A7_u5236_u8BED_u8A00_HCL" class="headerlink" title="逻辑设计和硬件控制语言 HCL"></a>逻辑设计和硬件控制语言 HCL</h2><p>在硬件设计中，用电子电路来计算来计算对位进行运算的函数，以及在各种存储器元素中存储位。大多数现代电路技术都用信号线上的高电压或低电压来表示不同的位值。</p>
<blockquote>
<p>逻辑门</p>
</blockquote>
<p>逻辑门是数字电路的基本计算元素。它们产生的输出，等于它们输入位值的某个布尔函数。</p>
<blockquote>
<p>组合电路和 HCL 布尔表达式</p>
</blockquote>
<p>将很多的逻辑门组合成一个网，就能构建计算块(computational block)，称为<strong>组合电路(combinational circuits)</strong>。构建这些网有两条限制：</p>
<ul>
<li>两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障</li>
<li>这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的回路会导致该网络计算的函数有歧义。</li>
</ul>
<blockquote>
<p>字级的组合电路和 HCL 整数表达式</p>
</blockquote>
<p>通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。</p>
<h2 id="Y86__u7684_u987A_u5E8F_u5B9E_u73B0"><a href="#Y86__u7684_u987A_u5E8F_u5B9E_u73B0" class="headerlink" title="Y86 的顺序实现"></a>Y86 的顺序实现</h2><p>将处理组织成阶段</p>
<p>取指(fetch)、译码(decode)、执行(execute)、访存(memory)、写回(write back)、更新 PC(PC update)</p>
<h2 id="u6D41_u6C34_u7EBF_u7684_u901A_u7528_u539F_u7406"><a href="#u6D41_u6C34_u7EBF_u7684_u901A_u7528_u539F_u7406" class="headerlink" title="流水线的通用原理"></a>流水线的通用原理</h2><p>参考 Foundation of Computer Architecture，此略</p>
<h2 id="u5C0F_u7ED3-2"><a href="#u5C0F_u7ED3-2" class="headerlink" title="小结"></a>小结</h2><p>有关处理器设计的几个重要经验：</p>
<ul>
<li>管理复杂性是首要问题。想要优化使用硬件资源，在最小的成本下获得最大的性能</li>
<li>我们不需要直接实现 ISA</li>
<li>硬件设计人员必须非常谨慎小心</li>
</ul>
<h1 id="u4F18_u5316_u7A0B_u5E8F_u6027_u80FD"><a href="#u4F18_u5316_u7A0B_u5E8F_u6027_u80FD" class="headerlink" title="优化程序性能"></a>优化程序性能</h1><blockquote>
<p>你能获得的对程序最大的加速比就是当你第一次让它工作起来的时候。 —— John K.Ousterhout</p>
</blockquote>
<p>写程序最主要的目标就是使它在所有可能的情况下都正确工作。程序员必须写出清晰简洁的代码，这样做不仅是为了程序员能够看懂代码，也是为了在检查代码和今后需要修改代码时，其他人能够读懂和理解代码。</p>
<p>编写高效程序需要几类活动：第一，我们必须选择一组合适的算法和数据结构。第二，我们必须编写出编译器能够有效优化以转换成搞笑可执行代码的源代码。对于第二点，理解优化编译器的能力和局限性是很重要的。</p>
<p>在程序开发和优化的过程中，我们必须考虑代码使用的方式，以及影响它的关键因素。通常，程序员必须在实现和维护程序的简单性与它的运行速度之间做出权衡。</p>
<p>程序优化的第一步就是消除不必要的内容，让代码尽可能有效地执行它期望的工作。这包括消除不必要的函数调用、条件测试和存储器引用。这些优化不依赖于目标机器的任何具体属性。</p>
<p>研究程序的汇编代码表示，是理解编译器，以及产生的代码如何运行的最有效的手段之一。仔细研究内循环的代码是一个很好的开端。</p>
<h2 id="u4F18_u5316_u7F16_u8BD1_u5668_u7684_u80FD_u529B_u548C_u5C40_u9650_u6027"><a href="#u4F18_u5316_u7F16_u8BD1_u5668_u7684_u80FD_u529B_u548C_u5C40_u9650_u6027" class="headerlink" title="优化编译器的能力和局限性"></a>优化编译器的能力和局限性</h2><p>现代编译器运用复杂精细的算法来确定一个程序中计算的是什么值，以及它们是被如何使用的。然后它们会利用一些机会来简化表达式，在几个不同的地方使用同一个计算，以及降低一个给定的计算必须被执行的次数。</p>
<p>限制编译器只进行安全的优化，消除了一些造成不希望的运行时行为的可能原因，但这也意味着程序员必须花费更大的力气写出程序使编译器能够将之转换成有效机器代码。请看下面这个例子</p>
<pre><code>void twiddle1(int *xp, int *yp){
    *xp += *yp;
    *xp += *yp;
}

void twiddle2(int *xp, int *yp){
    *xp += 2* *yp
}
</code></pre><p>初看这两个函数似乎有相同的行为，都是将存储在由指针 yp 指示的位置除的值两次加到指针 xp 指示的位置处的值。另一方面，函数 twiddle2 的效率更高一些，它只要求 3 次存储器引用(读 <code>*xp</code>，读 <code>*yp</code>，写 <code>*xp</code>)，而 twiddle1 需要 6 次。不过，当 xp 等于 yp 时，这两个函数的执行结果则会不一致，twiddle1 使 xp 的值增加 4 倍，而 twiddle2 则是 3 倍，因此，编译器不能产生 twiddle2 风格的代码作为 twiddle1 的优化版本。</p>
<p>这种两个指针可能指向同一个存储器位置的情况称为<strong>存储器别名使用(memory aliasing)</strong>。在只执行安全的优化中，编译器必须假设不同的指针可能会指向存储器中同一个位置。</p>
<p>第二个妨碍优化的因素是函数调用，例如：</p>
<pre><code>int f();

int func1(){
    return f() + f() + f() + f();
}

int func2(){
    return 4*f();
}
</code></pre><p>最初看上去两个过程计算都是相同的结果，但是 func2 只调用 f1 一次，比 func2 的四次要好。不过，考虑下面 f 的代码：</p>
<pre><code>int counter = 0;

int f(){
    return counter++;
}
</code></pre><p>这个函数有个副作用——它修改了全局程序状态的一部分。改变调用它的次数会改变程序的行为。所以，编译器会假设最早的情况，并保持所有函数调用不变。</p>
<h2 id="u8868_u793A_u7A0B_u5E8F_u6027_u80FD"><a href="#u8868_u793A_u7A0B_u5E8F_u6027_u80FD" class="headerlink" title="表示程序性能"></a>表示程序性能</h2><p>我们引入度量标准<strong>每元素的周期数(Cycles Per Element, CPE)</strong>作为一种表示性能并指导我们改进代码的方法。处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用<strong>千兆赫兹(GHz)</strong>，即十亿周期每秒来表示。CPE 越小越好。</p>
<p>许多过程含有在一组元素上迭代的循环。如下图中的函数 psum1 和 psum2 计算都是一个长度为 n 的向量的前置和(prefix sum)，对于向量 a={a0,a1,…,an-1}，前置和 p={p0,p1,…pn-1}定义为</p>
<pre><code>p0 = a0
pi = pi-1 + ai, 1&lt;= i &lt; n
</code></pre><p>函数 psum1 每次迭代计算结果向量的一个元素，第二个函数使用<strong>循环展开(loop unrolling)</strong>的技术，每次迭代计算两个元素。</p>
<p><img src="/images/csapp5.1.jpg" alt="csapp5.1"></p>
<p>我们发现，psum1 和 psum2 的运行时间(以时钟周期为单位)分辨近似于等式 496+10.0n 和 500+6.5n。</p>
<p><img src="/images/csapp5.2.jpg" alt="csapp5.2"></p>
<h2 id="u7A0B_u5E8F_u793A_u4F8B"><a href="#u7A0B_u5E8F_u793A_u4F8B" class="headerlink" title="程序示例"></a>程序示例</h2><p>考虑如下图所示的简单向量数据结构，由两个存储器块表示：头部和数据数组。头部是一个声明如下的结构</p>
<p><img src="/images/csapp5.3.jpg" alt="csapp5.3"></p>
<p>这个声明用数据类型 data_t 作为基本元素的数据类型。例如 <code>typedef int data_t</code>。</p>
<p><img src="/images/csapp5.4.jpg" alt="csapp5.4"></p>
<p>对向量元素求和</p>
<pre><code>#define IDENT 0
#define OP +
</code></pre><p>对向量元素求积</p>
<pre><code>#define IDENT 1
#define OP *
</code></pre><p><img src="/images/csapp5.5.jpg" alt="csapp5.5"></p>
<p>我们会进行一组变换，发现有很多智能带来很小的性能提高，而其他的能带来更巨大的效果。确定该使用哪些变换的组合确实是编写快速代码的魔术(black art)。</p>
<p>未经优化的代码是从 C 语言代码到机器代码的直接翻译，通常有明显的低效率。简单地使用命令行选项 <code>-O1</code>，就会进行一些基本的优化，可以显著提高性能。</p>
<h2 id="u6D88_u9664_u5FAA_u73AF_u7684_u4F4E_u6548_u7387"><a href="#u6D88_u9664_u5FAA_u73AF_u7684_u4F4E_u6548_u7387" class="headerlink" title="消除循环的低效率"></a>消除循环的低效率</h2><p>可以观察到，过程 combine1 调用函数 <code>vec_length</code> 作为 for 循环的测试条件。我们其实可以只计算一次向量的长度，然后在我们的测试条件中都使用这个值。如下图所示：</p>
<p><img src="/images/csapp5.6.jpg" alt="csapp5.6"></p>
<p>这个优化是一类常见的优化的一个例子，称为<strong>代码移动(code motion)</strong>。这类优化包括识别要执行多次(例如在循环里)但是计算结果不会改变的计算。因而可以将计算移动到代码前面不会被多次求值的部分。</p>
<p>编程时一个常见的问题就是一个看上去无足轻重的代码片段有隐藏的渐进低效率(asymptotic inefficiency)</p>
<h2 id="u51CF_u5C11_u8FC7_u7A0B_u8C03_u7528"><a href="#u51CF_u5C11_u8FC7_u7A0B_u8C03_u7528" class="headerlink" title="减少过程调用"></a>减少过程调用</h2><p>过程调用会代码相当大的开销，而且妨碍大多数形式的程序优化。从上图可以看出，每次循环迭代都会调用 <code>get_vec_element</code> 来获取下一个向量元素。我们可以直接访问数组，而不是利用函数调用并加上边界检查：</p>
<p><img src="/images/csapp5.9.jpg" alt="csapp5.9"></p>
<h2 id="u6D88_u9664_u4E0D_u5FC5_u8981_u7684_u5B58_u50A8_u5668_u5F15_u7528"><a href="#u6D88_u9664_u4E0D_u5FC5_u8981_u7684_u5B58_u50A8_u5668_u5F15_u7528" class="headerlink" title="消除不必要的存储器引用"></a>消除不必要的存储器引用</h2><p>累加过程中其实没有必要每次都把结果写入到 dest 中，可以使用一个临时变量，消除不必要的存储器引用：</p>
<p><img src="/images/csapp5.10.jpg" alt="csapp5.10"></p>
<h2 id="u7406_u89E3_u73B0_u4EE3_u5904_u7406_u5668"><a href="#u7406_u89E3_u73B0_u4EE3_u5904_u7406_u5668" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h2><p>要想获得充分提高的性能，需要仔细地分析程序，同时代码的生成也要针对目标处理器进行调整。由于可以将大量的晶体管继承到一块新品啊上，现代微处理器采用了复杂的硬件，试图使程序性能最大化。带来的一个后果就是处理器的实际操作与观察机器级程序锁察觉到的大相径庭。在代码级上，看上去似乎是一次执行一条指令，每条指令都包括从寄存器或存储器取值，执行一个操作，并把结果存回到一个寄存器或存储器位置。在实际的处理器中，是同时对多条指令求值，这个现象称为<strong>指令级并行</strong>。现代微处理器取得的了不起的功绩之一是：它们采用复杂而奇异的微处理器结构，其中，多条指令可以并行地执行，同时又呈现一种简单地顺序执行指令的表象。</p>
<p>两种下界描述了程序的最大性能。当一系列操作必须按照严格顺序执行时，就会遇到<strong>延迟界限(latency bound)</strong>，因为在下一条指令开始之前，这条指令必须结束。当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限定程序性能。<strong>吞吐量界限(throughput bound)</strong>刻画了处理器功能单元的原始计算能力。这个界限是程序性能的终极限制。</p>
<blockquote>
<p>整体操作</p>
</blockquote>
<p>Nehalem 微体系结构是 20 世纪 90 年代以来，许多制造商生产的典型的高端处理器。在工业界称为超标量(superscalar)，意思是可以在每个时钟周期执行多个操作，而且是乱序的(out-of-order)，意思就是指令执行的顺序不一定要与它们在机器级程序中的顺序一致。整个设计有两个主要部分：指令控制单元(Instruction Control Unit, ICU)和执行单元(Execution Unit, EU)。前者负责从存储器中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作；而后执行这些操作。</p>
<p>ICU 从指令高速缓存(instruction cache)中读取指令。指令高速缓存是一个特殊的高速缓存存储器，它包含最近访问的指令。通常，ICU 会在当前正在的指令很早之前取指，这样它才有足够的时间对指令译码，并把操作发送到 EU。不过，一个问题是党程序遇到分支时，程序有两个可能的前进方向。一种可能会选择分支，控制被传递到分支目标。另一种可能是，不选择分支，控制被传递到指令序列的下一条指令。现代处理器采用了一种称为<strong>分支预测(branch prediction)</strong>的技术<strong>，处理区会猜测是否会选择分支，同时还预测分支的目标地址。使用</strong>投机执行(speculative execution)**的技术，处理器会开始取出位于它预测的分支会跳到的地方的指令，并对指令译码，甚至在它确定分支预测是否正确之前就开始执行这些操作。如果过后确定分支预测错误，会将状态重新设置到分支点的状态，并开始取出和执行另一个方向上的指令。</p>
<blockquote>
<p>功能单元的特性</p>
</blockquote>
<p>每个运算都是由两个周期计数值来刻画的：一个是延迟(latency)，它表示完成运算所需要的总时间；另一个是发射时间(issue time)，它表示两个连续的同类型运算之间需要的最小时钟周期数。随着字长的增加，对于更复杂的数据类型，对于更复杂的运算，延迟也会增加。</p>
<blockquote>
<p>处理器操作的抽象模型</p>
</blockquote>
<p>我们会使用程序的数据流(data-flow)表示，作为分析在现代处理器上执行的机器级程序性能的一个工具，这是一种图形化的表示方法，展现了不同操作之间的数据相关是如何限制它们的执行顺序的。这种限制形成了图中的<strong>关键路径(critical path)</strong>，这是执行一组机器指令所需时钟周期数的一个下界。</p>
<h2 id="u5FAA_u73AF_u5C55_u5F00"><a href="#u5FAA_u73AF_u5C55_u5F00" class="headerlink" title="循环展开"></a>循环展开</h2><p>循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。循环展开能够从两个方面改善程序的性能。首先，它减少了不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支。其次，它提供了一些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。</p>
<h2 id="u63D0_u9AD8_u5E76_u884C_u6027"><a href="#u63D0_u9AD8_u5E76_u884C_u6027" class="headerlink" title="提高并行性"></a>提高并行性</h2><p>对于一个可结合和可交互的合并运算来说，比如说整数加法或乘法，我们可以通过将一组合并运算分割成两个或更多的部分，并在最后合并结果来提高性能。</p>
<h2 id="u4E00_u4E9B_u9650_u5236_u56E0_u7D20"><a href="#u4E00_u4E9B_u9650_u5236_u56E0_u7D20" class="headerlink" title="一些限制因素"></a>一些限制因素</h2><ul>
<li>寄存器溢出</li>
<li>分支预测和预测错误处罚</li>
</ul>
<p>通用原则：</p>
<ul>
<li>不要过分关心可预测的分支</li>
<li>书写适合用条件传送实现的代码</li>
</ul>
<p><img src="/images/csapp0.9.jpg" alt="csapp0.9"></p>
<h2 id="u7406_u89E3_u5B58_u50A8_u5668_u6027_u80FD"><a href="#u7406_u89E3_u5B58_u50A8_u5668_u6027_u80FD" class="headerlink" title="理解存储器性能"></a>理解存储器性能</h2><p>现代处理器有专门的功能单元来执行加载和存储操作，这些单元有内部的缓冲区来保存未完成的存储器操作请求集合。</p>
<blockquote>
<p>加载的性能</p>
</blockquote>
<p>一个包含加载操作的程序的性能既依赖于流水线的能力，也依赖于加载单元的延迟</p>
<blockquote>
<p>存储的性能</p>
</blockquote>
<p>存储操作将一个寄存器值写到存储器。</p>
<h2 id="u5E94_u7528_uFF1A_u6027_u80FD_u63D0_u9AD8_u6280_u672F"><a href="#u5E94_u7528_uFF1A_u6027_u80FD_u63D0_u9AD8_u6280_u672F" class="headerlink" title="应用：性能提高技术"></a>应用：性能提高技术</h2><ol>
<li>高级设计。为遇到的问题选择适当的算法和数据结构。要特别警觉，避免使用那些会渐进地产生糟糕性能的算法或编码技术。</li>
<li>基本编码原则。避免限制优化的因素，这样编译器就能产生高效的代码。<ul>
<li>消除连续的函数调用。在可能时，将计算移到循环外。考虑有选择地拖鞋程序的模块性以获得更大的效率</li>
<li>消除不必要的存储器引用。引入临时变量来保存中间结果。只有在最后的值计算出来时，才将结果存放到数组或全局变量中</li>
</ul>
</li>
<li>低级优化<ul>
<li>展开循环，降低开销，并且使得进一步的优化成为可能</li>
<li>通过使用多个累积变量和重新结合等技术，找到方法提高指令级并行</li>
<li>用功能的风格重写条件操作，使得编译采用条件数据传送</li>
</ul>
</li>
</ol>
<h2 id="u786E_u5B9A_u548C_u6D88_u9664_u6027_u80FD_u74F6_u9888"><a href="#u786E_u5B9A_u548C_u6D88_u9664_u6027_u80FD_u74F6_u9888" class="headerlink" title="确定和消除性能瓶颈"></a>确定和消除性能瓶颈</h2><p>系统优化的通用原则：Amdahl’s law</p>
<p>Unix 的程序剖析(profiling)工具 GPROF。这个程序产生两种形式的信息。首先，它确定程序中每个函数花费了多少 CPU 时间。其次，它计算每个函数被调用的次数，以执行调用的函数来分类。</p>
<p>运行时需要三个步骤</p>
<ol>
<li>程序必须为剖析而编译和链接，加上 <code>-pg</code>: <code>unix&gt; gcc -O1 -pg prog.c -o prog</code></li>
<li>然后像往常一样执行：<code>unix&gt; ./prog file.txt</code>，会产生额外的文件 <code>gmon.out</code></li>
<li>调用 GPROF 来分析 <code>gmon.out</code> 中的数据：<code>unix&gt; gprof prog</code></li>
</ol>
<p>具体的用法请参考书本或者网上的例子，此略</p>
<h2 id="u5C0F_u7ED3-3"><a href="#u5C0F_u7ED3-3" class="headerlink" title="小结"></a>小结</h2><p>没有任何编译器能用一个好的算法或数据结构代替低效率的算法或数据结构，因此程序设计时的这些方面仍然应该是程序员主要关心的。</p>
<h1 id="u5B58_u50A8_u5668_u5C42_u6B21_u7ED3_u6784"><a href="#u5B58_u50A8_u5668_u5C42_u6B21_u7ED3_u6784" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><p>存储器系统(memory system)是一个具有不同容量、成本和访问时间的存储设备的层次结构。CPU 寄存器保存着最常用的数据。靠近 CPU 的晓得、快速的<strong>高速缓存存储器(cache memory)</strong>作为一部分存储在相对慢速的主存储器(main memory)中的数据和指令的缓冲区域。主存暂时存放在容量较大的、慢速磁盘上的数据，而这些磁盘常常又作为存储在通过网络连接的其他机器的磁盘或磁带上的区域的缓冲区域。</p>
<p>如果你理解了系统是如何将数据在存储器层次结构中上上下下移动的，那么你就可以编写你的应用程序，使得它们的数据项存储在层次结构中较高的地方，在那里 CPU 能更快地访问到它们。</p>
<p>这个思想围绕着计算机程序的一个称为<strong>局部性(locality)</strong>的基本属性。具有良好局部性的程序倾向于一次又一次地访问相同的数据项集合，或是倾向于访问临近的数据项集合。</p>
<h2 id="u5B58_u50A8_u6280_u672F"><a href="#u5B58_u50A8_u6280_u672F" class="headerlink" title="存储技术"></a>存储技术</h2><p>计算机技术的成功很大程度上源自于存储技术的巨大进步。</p>
<blockquote>
<p>随机访问存储器</p>
</blockquote>
<p>随机访问存储器   (Random-Access Memory, RAM)分为两类：静态的和懂啊提的。SRAM 比 DRAM 更快，但也贵得多。SRAM 用来作为高速缓存存储器，既可以在 CPU 芯片上，也可以在片下。DRAM 用来作为主存以及图形系统的帧缓冲区。</p>
<blockquote>
<p>固态硬盘</p>
</blockquote>
<p>固态硬盘(Solid State Disk, SSD)是一种基于闪存的存储技术。一个 SSD 包由一个或多个闪存芯片和闪存翻译层(flash translation layer)组成，闪存芯片代替传统旋转磁盘中的机械驱动器，而闪存翻译层是一个硬件/固件设备，扮演与磁盘控制器相同的角色，将对逻辑块的清酒翻译成对底层物理设备的访问。</p>
<p><img src="/images/csapp6.16.jpg" alt="csapp6.16"></p>
<p>SSD 有着与旋转磁盘不同的性能特征。顺序读和写性能相当，不过，当按照随机顺序访问逻辑块时，写比读慢一个数量级。随机读和写的性能差别是由底层闪存基本属性决定的。如上图所示，一个闪存由 B 个块的序列组成，每个块由 P 页组成。通常，页的大小是 512~4KB，块是由 32~128 页组成的，块的大小为 16~512 KB。数据是以页为单位读写的。只有在一页所属的块整个被擦除之后，才能写这一页。不过，一旦一个块被擦除了，块中的每一个页都可以不需要再进行擦除就写一次。在大约进行 100000 次重复写之后，块就会磨损坏。</p>
<blockquote>
<p>存储技术趋势</p>
</blockquote>
<ul>
<li>不同的存储技术有不同的价格和性能折中</li>
<li>不同的存储技术的价格和性能属性一截然不同的速率变化着</li>
<li>DRAM 和磁盘的性能滞后于 CPU 的性能</li>
</ul>
<h2 id="u5C40_u90E8_u6027"><a href="#u5C40_u90E8_u6027" class="headerlink" title="局部性"></a>局部性</h2><p>一个编写良好的计算机程序常常具有良好的局部性(locality)。也就是说，它们倾向于引用临近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性，被称为<strong>局部性原理(principle of locality)</strong>，是一个持久的概念，对硬件和软件系统的设计和性能都有着极大的影响。</p>
<p>局部性通常有两种不同的形式：<strong>时间局部性(temporal locality)</strong>和<strong>空间局部性(spatial locality)</strong>。有良好局部性的程序比局部性差的程序运行得更快。</p>
<ul>
<li>重复引用同一个变量的程序有良好的时间局部性</li>
<li>对于具有步长为 k 的引用模式的程序，步长越小，空间局部性越好</li>
<li>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好</li>
</ul>
<h2 id="u5B58_u50A8_u5668_u5C42_u6B21_u7ED3_u6784-1"><a href="#u5B58_u50A8_u5668_u5C42_u6B21_u7ED3_u6784-1" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h2><p>存储器层次结构(memory hierarchy)如下图所示</p>
<p><img src="/images/csapp6.23.jpg" alt="csapp6.23"></p>
<blockquote>
<p>存储器层次结构中的缓存</p>
</blockquote>
<p>一般而言，高速缓存(cache)是一个小而快速的存储设备。使用高速缓存的过程称为缓存(caching)。</p>
<p>存储器层次结构的中心思想是，对于每个 k，位于 k 层的更快更小的存储设备作为位于 k+1 层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一次都缓存来自较低一层的数据对象。</p>
<p>数据总是以块大小为<strong>传送单元(transfer unit)</strong>在第 k 层和第 k+1 层之间来回拷贝的。虽然在层次结构中任何一对相邻的层次之间块大小是固定的，但是其他的层次对之间可以用不同的块大小。一般而言，层次结构较低的层(离 CPU 较远)的设备访问时间较长，因此为了补偿这些较长的访问时间，倾向于使用较大的块。</p>
<p><img src="/images/csapp6.24.jpg" alt="csapp6.24"></p>
<p><strong>缓存命中</strong></p>
<p>当程序需要第 k+1 层的某个数据对象 d 时，它首先在当前存储的第 k 层的一个块中查找 d。如果 d 刚好缓存在第 k 层中，那么就是<strong>缓存命中(cache hit)</strong>。</p>
<p><strong>缓存不命中</strong></p>
<p>如果第 k 层中没有缓存数据对象 d，那么就是<strong>缓存不命中(cache miss)</strong>。当发生 cache miss 时，会从下一次取出包含 d 的那个块，如果第 k 层的缓存已经满了的话，可能就会覆盖现存的一个块。</p>
<p>覆盖一个现存的块的过程称为<strong>替换(replacing)</strong>或<strong>驱逐(evicting)</strong>。被驱逐的看这个块有时也称为<strong>牺牲块(victim block)</strong>。决定该替换那个块是由缓存的<strong>替换策略(replacement policy)</strong>来控制的。(LRU, LFU 等等替换策略在这里可以使用)</p>
<p><strong>缓存不命中的种类</strong></p>
<p>一个空的缓存有时称为<strong>冷缓存(cold cache)</strong>，此类不命中称为<strong>compulsory miss</strong> 或 <strong>cold miss</strong>。</p>
<p>只要发生了 cache miss，第 k 层的缓存就必须执行某个<strong>放置策略(placement policy)</strong>，确定把它从第 k+1 层中取出的块放在哪里。一般来说是用映射来确定放在哪里，如果两个不同的块映射到同一个位置，就引起了 conflict miss。当工作集的大小超过缓存的大小时，就会有 capacity miss。</p>
<p><img src="/images/csapp6.25.jpg" alt="csapp6.25"></p>
<h2 id="u9AD8_u901F_u7F13_u5B58_u5B58_u50A8_u5668"><a href="#u9AD8_u901F_u7F13_u5B58_u5B58_u50A8_u5668" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h2><p>早期计算机系统的存储器结构只有三层：CPU 寄存器、DRAM 主存储器和磁盘存储。不过，由于 CPU 和主存之间逐渐增大的差距，系统设计者被迫在 CPU 寄存器文件和主存之间插入了一个小的 SRAM 高速缓存存储器，称为 L1 高速缓存。之后又插入了一个更大的高速缓存，称为 L2 高速缓存，之后还有 L3 高速缓存。周期数：L1(2~4), L2(~10), L3(~30~40)</p>
<h2 id="u7F16_u5199_u9AD8_u901F_u7F13_u5B58_u53CB_u597D_u7684_u4EE3_u7801"><a href="#u7F16_u5199_u9AD8_u901F_u7F13_u5B58_u53CB_u597D_u7684_u4EE3_u7801" class="headerlink" title="编写高速缓存友好的代码"></a>编写高速缓存友好的代码</h2><ul>
<li>让最常见的情况运行得快</li>
<li>在每个循环内部缓存不命中数量最小</li>
</ul>
<h2 id="u7EFC_u5408_uFF1A_u9AD8_u901F_u7F13_u5B58_u5BF9_u7A0B_u5E8F_u6027_u80FD_u7684_u5F71_u54CD"><a href="#u7EFC_u5408_uFF1A_u9AD8_u901F_u7F13_u5B58_u5BF9_u7A0B_u5E8F_u6027_u80FD_u7684_u5F71_u54CD" class="headerlink" title="综合：高速缓存对程序性能的影响"></a>综合：高速缓存对程序性能的影响</h2><blockquote>
<p>存储器山</p>
</blockquote>
<p>一个程序从存储系统中读数据的速率称为<strong>度吞吐量(read throughput)</strong>，或者有时称为<strong>读带宽(read bandwidth)</strong>。</p>
<p><img src="/images/csapp6.43.jpg" alt="csapp6.43"></p>
<blockquote>
<p>重新排列循环以提高空间局部性</p>
</blockquote>
<p>矩阵的循环优化，略</p>
<blockquote>
<p>在程序中利用局部性</p>
</blockquote>
<ul>
<li>将你的注意力集中在内循环上，大部分计算和存储器访问都发生在这里</li>
<li>通过按照数据对象存储在存储器中的顺序、以步长为 1 的来读数据，从而使得程序中的空间局部性最大</li>
<li>一旦从存储器中读入了一个数据对象，就尽可能多地使用它，从而使得程序中的时间局部性最大</li>
</ul>
<h2 id="u5C0F_u7ED3-4"><a href="#u5C0F_u7ED3-4" class="headerlink" title="小结"></a>小结</h2><p>程序员可以通过编写有良好空间和时间局部性的程序来显著地改进程序的运行时间。利用基于 SRAM 的高速缓存存储器特别重要。</p>
<h1 id="u94FE_u63A5"><a href="#u94FE_u63A5" class="headerlink" title="链接"></a>链接</h1><p>链接(linking)是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载到存储器并执行。链接可以执行于编译时(compile time)，也可以执行于加载时(load time)，甚至执行于运行时(run time)。</p>
<p>链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译(separate compilation)成为可能。</p>
<h2 id="u7F16_u8BD1_u5668_u9A71_u52A8_u7A0B_u5E8F"><a href="#u7F16_u8BD1_u5668_u9A71_u52A8_u7A0B_u5E8F" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h2><p>大多数编译系统提供<strong>编译驱动程序(compiler driver)</strong>，它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。</p>
<h2 id="u9759_u6001_u8FDE_u63A5"><a href="#u9759_u6001_u8FDE_u63A5" class="headerlink" title="静态连接"></a>静态连接</h2><p>静态链接器(static linker)以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节(section)组成。指令在一个 section 中，初始化的全局变量在另一个 section 中，而未初始化的变量又在另一个 section 中。</p>
<p><img src="/images/csapp7.2.jpg" alt="csapp7.2"></p>
<p>为了构造可执行文件，链接器必须完成两个主要任务：</p>
<ul>
<li>符号解析(symbol resolution)。目标文件定义和引用符号。符号解析的目的是将每个符号引用刚好和一个符号定义联系起来。</li>
<li>重定位(relocation)。编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义域一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定位这些节。</li>
</ul>
<p>关于链接器的一些基本事实：目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包含指导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。</p>
<h2 id="u76EE_u6807_u6587_u4EF6"><a href="#u76EE_u6807_u6587_u4EF6" class="headerlink" title="目标文件"></a>目标文件</h2><p>目标文件有三种形式：</p>
<ul>
<li>可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li>
<li>可执行目标文件。包含二进制代码和数据，其形式可以被直接拷贝到存储器并执行。</li>
<li>共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载到存储器并链接。</li>
</ul>
<h2 id="u53EF_u91CD_u5B9A_u4F4D_u76EE_u6807_u6587_u4EF6"><a href="#u53EF_u91CD_u5B9A_u4F4D_u76EE_u6807_u6587_u4EF6" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h2><p>下图是一个典型的 ELF 可重定位目标文件的格式。ELF 头(ELF header)以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。</p>
<p><img src="/images/csapp7.3.jpg" alt="csapp7.3"></p>
<h2 id="u7B26_u53F7_u548C_u7B26_u53F7_u8868"><a href="#u7B26_u53F7_u548C_u7B26_u53F7_u8868" class="headerlink" title="符号和符号表"></a>符号和符号表</h2><p>每个可重定位目标模块 m 都有一个符号表，它包含 m 所定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：</p>
<ul>
<li>由 m 定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的 C 函数以及被定义为不带 C static 属性的全局变量</li>
<li>由其他模块定义的并被模块 m 引用的全局符号。这些符号称为外部符号(external)，对应于定义在其他模块中的 C 函数和变量。</li>
<li>只被模块 m 定义和引用的本地符号。有的本地链接器符号对应于带 static 属性的 C 函数和全局变量。</li>
</ul>
<p>C 程序员使用 static 属性在模块内部隐藏变量和函数声明。</p>
<h2 id="u7B26_u53F7_u89E3_u6790"><a href="#u7B26_u53F7_u89E3_u6790" class="headerlink" title="符号解析"></a>符号解析</h2><p>链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义联系起来。对那些和引用定义在相同模块中的本地符号的引用，符号解析是非常简单明了的。编译器只允许每个模块中每个本地符号只有一个定义。编译器还确保静态本地变量，它们也会有本地链接器符号，拥有唯一的名字。</p>
<h2 id="u91CD_u5B9A_u4F4D"><a href="#u91CD_u5B9A_u4F4D" class="headerlink" title="重定位"></a>重定位</h2><p>一旦链接器完成了符号解析这一步，它就把代码中的每个符号引用和确定的一个符号定义联系起来。在此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。重定位由两步组成：</p>
<ul>
<li>重定位节和符号定义</li>
<li>重定位节中的符号引用</li>
</ul>
<h2 id="u53EF_u6267_u884C_u76EE_u6807_u6587_u4EF6"><a href="#u53EF_u6267_u884C_u76EE_u6807_u6587_u4EF6" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h2><p>可执行目标文件的格式类似于可重定位目标文件的格式，如下图所示。ELF 头部描述文件的总体格式。它还包括程序的入口点(entry point)，也就是当程序要执行的第一条指令的地址。</p>
<p><img src="/images/csapp7.11.jpg" alt="csapp7.11"></p>
<h2 id="u52A0_u8F7D_u53EF_u6267_u884C_u76EE_u6807_u6587_u4EF6"><a href="#u52A0_u8F7D_u53EF_u6267_u884C_u76EE_u6807_u6587_u4EF6" class="headerlink" title="加载可执行目标文件"></a>加载可执行目标文件</h2><p>要允许可执行目标文件 p，可以在 Unix 外壳的命令行中输入它的名字</p>
<pre><code>unix&gt; ./p
</code></pre><p>因为 p 不是一个内置的外壳命令，所以外壳会认为 p 是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器(loader)的操作系统代码来运行它。任何 Unix 程序都可以通过调用 execve 函数来调用加载器。加载器将可执行目标文件中的代码和数据从磁盘拷贝到存储器，然后通过跳转到程序的第一条指令或入口点(entry point)来运行该程序。这个将程序拷贝到存储器并运行的过程叫做加载(loading)。</p>
<p><img src="/images/csapp7.13.jpg" alt="csapp7.13"></p>
<p>每个 Unix 程序都有一个运行时存储器映像，如上图所示。在 32 位 Linux 系统中，代码段总是从地址 0x08048000 处开始。数据段是在接下来的下一个 4KB 对齐的地址处。运行时<strong>堆</strong>再读/写段之后接下来的第一个 4KB 对齐的地址处，并通过调用 malloc 库往上增长。还有一个段是为共享库保留的。用户栈总是从最大的合法用户地址开始，向下增长的(向低存储器地址方向增长)。从栈的上部开始的段是为操作系统主流存储器的部分(也就是内核)的代码和数据保留的。</p>
<h2 id="u52A8_u6001_u94FE_u63A5_u5171_u4EAB_u5E93"><a href="#u52A8_u6001_u94FE_u63A5_u5171_u4EAB_u5E93" class="headerlink" title="动态链接共享库"></a>动态链接共享库</h2><p>共享库(shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行时，可以加载到任意的存储器地址，并和一个在存储器中的程序链接起来。这个过程称为<strong>动态链接(dynamic linking)</strong>，是由一个叫做<strong>动态链接器</strong>的程序来执行的。</p>
<p>共享库也称为<strong>共享目标(shared object)</strong>，在 Unix 系统中通常用 .so 后缀来表示。微软的操作系统大量地利用了共享库，它们称为 DLL。</p>
<p><img src="/images/csapp7.15.jpg" alt="csapp7.15"></p>
<p>共享库是以两种不同方式来“共享”的。首先，在任何给定的文件系统中，对于一个库只有一个 .so 文件。所有引用该库的可执行目标文件共享这个 .so 文件中的代码和数据，而不是像静态库的内容那样被拷贝和嵌入到引用它们的可执行的文件中。</p>
<h2 id="u4E0E_u4F4D_u7F6E_u65E0_u5173_u7684_u4EE3_u7801_28PIC_29"><a href="#u4E0E_u4F4D_u7F6E_u65E0_u5173_u7684_u4EE3_u7801_28PIC_29" class="headerlink" title="与位置无关的代码(PIC)"></a>与位置无关的代码(PIC)</h2><p>PIC 数据引用；PIC 函数调用</p>
<h2 id="u5904_u7406_u76EE_u6807_u6587_u4EF6_u7684_u5DE5_u5177"><a href="#u5904_u7406_u76EE_u6807_u6587_u4EF6_u7684_u5DE5_u5177" class="headerlink" title="处理目标文件的工具"></a>处理目标文件的工具</h2><p>在 Unix 系统中有大量可用的工具可以帮助你理解和处理目标文件。特别的，GNU binutils 包尤其有帮助，而且可以运行在每个 Unix 平台上。</p>
<ul>
<li>AR: 创建静态库，插入、删除、列出和提取成员</li>
<li>STRINGS: 列出一个目标文件中所有可打印的字符串</li>
<li>STRIP: 从目标文件中删除符号表信息</li>
<li>NM: 列出一个目标文件的符号表中定义的符号</li>
<li>SIZE: 列出目标文件中节的名字和大小</li>
<li>READELF: 显示一个目标文件的完整结构，包括 ELF 头中编码的所有信息。包含 SIZE 和 NM 的功能</li>
<li>OBJDUMP: 二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编 .text 节中的二进制命令</li>
<li>LDD: 列出一个可执行文件在运行时所需要的共享库</li>
</ul>
<h2 id="u5C0F_u7ED3-5"><a href="#u5C0F_u7ED3-5" class="headerlink" title="小结"></a>小结</h2><p>链接可以在编译时由静态编译器来完成，也可以在加载时和运行时由动态链接器来完成。链接器处理称为目标文件的二进制文件，它又三种不同的形式：可重定位的、可执行的和共享的。可重定位的目标文件由静态链接器合并成一个可执行的目标文件，它可以加载到存储器中并执行。共享目标文件(共享库)是在运行时由动态链接器链接和加载的，或者隐含地在调用程序被加载和开始执行时，或者根据需要在程序调用 dlopen 库的函数时。</p>
<p>链接器的两个主要任务是符号解析和重定位，符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义，而重定位确定每个符号的最终存储器地址，并修改对那些目标的引用。</p>
<p>静态链接器是由像 GCC 这样的编译驱动器调用的。它们将多个可重定位目标文件合并成一个单独的可执行目标文件。多个目标文件可以定义相同的符号，而链接器用来悄悄地解析这些多重定义的规则可能在用户程序中引入的微妙错误。</p>
<p>多个目标文件可以被连接到一个单独的静态库中。链接器用库来解析其他目标模块中的符号引用。许多链接器通过从左到右的顺序扫描来解析符号引用，这是另一个引起迷惑的链接时错误来源。</p>
<p>加载器将可执行文件的内容映射到存储器，并运行这个程序。链接器还可能生成部分链接的可执行目标文件，这样的文件中有对定义在共享库中的程序和数据的未解析的引用。在加载时，加载器将部分链接的可执行文件映射到存储器，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链接任务。</p>
<p>被编译为位置无关代码的共享库可以加载到任何地方，也可以在运行时被多个进程共享。为了加载、链接和访问共享库的函数和数据，应用程序还可以在运行时使用动态链接器。</p>
<h1 id="u5F02_u5E38_u63A7_u5236_u6D41"><a href="#u5F02_u5E38_u63A7_u5236_u6D41" class="headerlink" title="异常控制流"></a>异常控制流</h1><p>系统必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。当子进程终止时，创造这些子进程的父进程必须得到通知。</p>
<p>线代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为<strong>异常控制流(Exceptional Control Flow, ECF)</strong>。异常控制流发生在计算机系统的各个层次。比如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文转换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送<strong>信号</strong>到另一个进程，而接受者会将控制突然转移到它的一个信号处理程序。一个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。</p>
<h2 id="u5F02_u5E38"><a href="#u5F02_u5E38" class="headerlink" title="异常"></a>异常</h2><p>异常是异常控制流的一种形式，它一部分是由硬件实现的，一部分是由操作系统实现的。因为它们有一部分是由硬件实现的，所以具体细节将随系统的不同而有所不同。然而，对于每个系统而言，基本的思想都是相同的。</p>
<p>异常(exception)就是控制流中的突变，用来响应处理器状态中的某些变化。如下图所示：</p>
<p><img src="/images/csapp8.1.jpg" alt="csapp8.1"></p>
<p>在图中，当处理器状态中发生一个重要的变化时，处理器正在执行某个当前指令。在处理器中，状态被编码为不同的位和信号。状态变化称为<strong>事件(event)</strong>。事件可能和当前指令的执行直接相关。比如，发生虚拟存储器缺页、算术溢出，或者一条指令试图除以零。另一方面，事件也可能和当前指令的执行没有关系。比如，一个系统定时器产生信号或者一个 I/O 请求完成。</p>
<p>在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做<strong>异常表(exception table)</strong>的跳转表，进行一个间接过程调用(异常)，到一個专门设计用来处理这类事件的操作系统子程序(异常处理程序, exception handler)</p>
<p>当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下三种情况中的一种：</p>
<ol>
<li>处理程序将控制返回给当前指令 I(curr)，即当事件发生时正在执行的指令。</li>
<li>处理程序将控制返回给 I(next)，即如果没有发生异常将会执行的下一条指令。</li>
<li>处理程序被中断的程序</li>
</ol>
<blockquote>
<p>异常处理</p>
</blockquote>
<p>系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号(exception number)。其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核的设计者分配的。前者的示例包括被零除、缺页、存储器访问违例以及算术溢出。后者的示例包括系统调用和来自外部 I/O 设备的信号。</p>
<p>在系统启动时，操作系统分配和初始化一张称为<strong>异常表</strong>的跳转表，使得条目 k 包含异常 k 的处理程序的地址。如下图所示</p>
<p><img src="/images/csapp8.2.jpg" alt="csapp8.2"></p>
<p>在运行时，处理器检测到发生了一个事件，并且确定了相应的异常号 k。随后，处理器触发异常，方法是执行间接过程调用，通过异常表的条目 k 转到相应的处理程序。下图展示了处理器如何使用异常表来形成适当的异常处理程序的地址。异常号是到异常表中的索引，异常表的起始地址放在一个叫做<strong>异常表基址寄存器(exception table base register)</strong>的特殊 CPU 寄存器里。</p>
<p><img src="/images/csapp8.3.jpg" alt="csapp8.3"></p>
<blockquote>
<p>异常的类别</p>
</blockquote>
<p>异常可以分为四类：中断(interrupt)、陷阱(trap)、故障(fault)和终止(abort)。下图是一些总结</p>
<p><img src="/images/csapp8.4.jpg" alt="csapp8.4"></p>
<p><strong>中断</strong></p>
<p>中断是异步发生的，是来自处理器外部的 I/O 设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序通常称为中断处理程序(interrupt handler)</p>
<p><img src="/images/csapp8.5.jpg" alt="csapp8.5"></p>
<p>剩下的异常类型(陷阱、故障和终止)是同步发生的，是执行当前指令的结果。我们把这类指令叫做故障指令(faulting instruction)。</p>
<p>陷阱和系统调用</p>
<p>陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做<strong>系统调用</strong>。</p>
<p>用户程序经常需要向内核请求服务，比如读一个文件(read)、创建一个新的进程(fork)、记在一个新的程序(execve)，或者终止当前进程(exit)。为了允许对这些内核服务的受控范文，处理器提供一条特殊的 <code>syscall n</code> 指令，当用户程序想要请求服务 n 时，可以执行这条指令。执行 <code>syscall</code> 指令会导致一个到异常处理程序的陷阱，这个处理程序对参数解码，并调用适当的内核程序。</p>
<p><img src="/images/csapp8.6.jpg" alt="csapp8.6"></p>
<p><strong>故障</strong></p>
<p>故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort 例程，abort 例程会终止引起故障的应用程序，如下图所示：</p>
<p><img src="/images/csapp8.7.jpg" alt="csapp8.7"></p>
<p>一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在存储器中，因此必须从磁盘中取出时，就会发生故障。就像我们将在第 9 章中看到的那样，一个页面就是虚拟存储器的一个连续的块。缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在存储器中了，指令就可以没有故障地运行完成了。</p>
<p><strong>终止</strong></p>
<p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者 SRAM 位被损坏时发生的奇偶错误。终止程序从不将控制返回给应用程序。如下图所示</p>
<p><img src="/images/csapp8.8.jpg" alt="csapp8.8"></p>
<blockquote>
<p>Linux/IA32 系统中的异常</p>
</blockquote>
<p>IA32 系统有高达256种不同的异常类型。0-31的号码对应的是由 Intel 架构师定义的异常，因此对任何 IA32 系统都是一样的。32-255的号码对应的是操作系统定义的终端和陷阱，如下图所示</p>
<p><img src="/images/csapp8.9.jpg" alt="csapp8.9"></p>
<p><strong>Linux/IA32 故障和终止</strong></p>
<ul>
<li>除法错误。当应用试图除以零时，或者当一个除法指令的结果对于目标操作数来说太大的时候，就会发生除法错误(异常0)。Unix 不会试图从除法错误中恢复，而是选择终止程序。Linux shell 通常会把除法错误报告为浮点异常(Floating exception)。</li>
<li>一般保护故障。许多原因都会导致不为人知的一般保护故障(异常13)，通常是因为一个程序引用了一个未定义的虚拟存储器区域，或者因为程序视图写一个只读的文本段。Linux 不会尝试恢复这类故障。Linux shell 通常会把这种一般保护故障报告为段故障(Segmentation fault)。</li>
<li>缺页(异常14)是会重新执行产生故障的指令的一个异常示例。</li>
<li>机器检查(异常18)是在导致故障的指令中检测到致命的硬件错误时发生的。机器检查处理程序从不返回控制给应用程序</li>
</ul>
<p><strong>Linux/IA32 系统调用</strong></p>
<p>每个系统调用都有一个唯一的整数号，对应于一个到内核中跳转表的偏移量。</p>
<p><img src="/images/csapp8.10.jpg" alt="csapp8.10"></p>
<h2 id="u8FDB_u7A0B"><a href="#u8FDB_u7A0B" class="headerlink" title="进程"></a>进程</h2><p>异常是允许操作系统提供<strong>进程(process)</strong>的概念所需要的基本构造块，进程是计算机可续重最深刻最成功的概念之一。当我们在一个现代系统上运行一个程序时，会得到一个假象，就好像我们的程序是系统中当前运行着的唯一的程序。</p>
<p>进程的经典定义就是一个<strong>执行中的程序的实例</strong>。系统中的每个程序都是运行在某个进程的<strong>上下文(context)</strong>中的。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在存储器中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p>
<p>每次用户通过向外壳输入一个可执行目标文件的名字，并运行一个程序时，shell 就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，且在这个新进程的上下文中运行它们自己的代码或其他应用程序。</p>
<blockquote>
<p>逻辑控制流</p>
</blockquote>
<p>即使在系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，好像它在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器(PC)的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或者是包含在运行时动态链接到程序的共享对象的指令。这个 PC 值的序列叫做<strong>逻辑控制流</strong>，或者简称<strong>逻辑流</strong>。</p>
<p><img src="/images/csapp8.12.jpg" alt="csapp8.12"></p>
<p>每个进程执行它的流的一部分，然后被<strong>抢占(preempted，暂时挂起)</strong>，然后轮到其他进程。</p>
<blockquote>
<p>并发流</p>
</blockquote>
<p>一个逻辑流的执行在时间上与另一个流重叠，称为<strong>并发流(concurrent flow)</strong>，这两个流被称为并发地运行。更准确地说，流 X 和 Y 互相并发，当且仅当 X 在 Y 开始之后和 Y 结束之前开始，或者 Y 在 X 开始之后和 X 结束之前开始。</p>
<p>多个流并发地执行的一般现象称为<strong>并发(concurrency)</strong>。一个进程和其他进程轮流运行的概念称为<strong>多任务(multitasking)</strong>。一个进程执行它的控制流的一部分的每一时间段叫做<strong>时间片(time slice)</strong>。因此，多任务也叫做<strong>时间分片(time slicing)</strong></p>
<p>注意，并发的思想与流运行的处理器核数或者计算机无关。如果两个流再时间上重叠，那么它们就是并发的，即使它们是运行在同一个处理器上的。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为<strong>并行流(parallel flow)</strong>。</p>
<blockquote>
<p>私有地址空间</p>
</blockquote>
<p>进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。尽管和每个私有地址空间相关联的存储器的内容一般是不同的，但是每个这样的空间都有相同的通用结构，如下图所示。</p>
<p><img src="/images/csapp8.13.jpg" alt="csapp8.13"></p>
<blockquote>
<p>用户模式和内核模式</p>
</blockquote>
<p>为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。</p>
<p>处理器通常是用某个控制寄存器中的一个<strong>模式位(mode bit)</strong>来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位，进程就运行在<strong>内核模式(超级用户模式)</strong>。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中任何存储器位置。</p>
<p>没有设置模式位时，进程就运行在<strong>用户模式</strong>中。用户模式中的进程不允许执行<strong>特权指令(priviledged instruction)</strong>，比如停止处理器、改变位模式，或者发起一个 I/O 操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。</p>
<p>Linux 提供了一种聪明的机制，叫做 /proc 文件系统，它允许用户模式进程访问内核数据结构的内容。/proc文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构。</p>
<blockquote>
<p>上下文切换</p>
</blockquote>
<p>操作系统内核使用一种称为<strong>上下文切换(context switch)</strong>的较高层形式的异常控制流来实现多任务。上下文切换机制是建立在8.1节中那些较低层异常机制之上的。</p>
<p>内核为每个进程维持一个<strong>上下文(context)</strong>。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描绘地址空间的页表、包含有关当前进程信息的<strong>进程表</strong>，以及包含进程已打开文件的信息的<strong>文件表</strong>。</p>
<p>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程。这种决定就叫做<strong>调度(schedule)</strong>，是由内核中称为<strong>调度器(scheduler)</strong>的代码处理的。当内核选择一个新的进程运行时，我们就说内核调度了这个进程。</p>
<p><img src="/images/csapp8.14.jpg" alt="csapp8.14"></p>
<h2 id="u7CFB_u7EDF_u8C03_u7528_u9519_u8BEF_u5904_u7406"><a href="#u7CFB_u7EDF_u8C03_u7528_u9519_u8BEF_u5904_u7406" class="headerlink" title="系统调用错误处理"></a>系统调用错误处理</h2><p>当 Unix 系统级函数遇到错误时，它们典型地会返回 -1，并设置全局帧数变量 errno 来表示什么出错了。通过使用<strong>错误处理包装(error-handling wrapper)</strong>函数，可以简化错误处理代码。</p>
<h2 id="u8FDB_u7A0B_u63A7_u5236"><a href="#u8FDB_u7A0B_u63A7_u5236" class="headerlink" title="进程控制"></a>进程控制</h2><p>Unix 提供了大量从 C 程序中操作进程的系统调用。</p>
<blockquote>
<p>获取进程 ID</p>
</blockquote>
<p>每个进程都有一个唯一的正数进程 ID(PID)。<code>getpid</code> 函数返回调用进程的 PID。<code>getppid</code> 函数返回它的父进程的 PID。</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t getpid(void);
pit_t getppid(void);
</code></pre><blockquote>
<p>创建和终止进程</p>
</blockquote>
<p>从程序员的角度，我们可以认为进程总是处于下面三种状态之一：</p>
<ul>
<li>运行。进程要么在 CPU 上执行，要么在等待被执行且最终会被内核调度。</li>
<li>停止。进程的执行被<strong>挂起(suspend)</strong>，且不会被调度。当收到 <code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIDTTIN</code> 或者 <code>SIGTTOU</code> 信号时，进程就停止，并且保持停止直到它收到一个 <code>SIGCONT</code> 信号，在这个时刻，进程再次开始运行。</li>
<li>终止。进程永远地停止了。进程会因为三种原因终止：1）收到一个默认行为是终止进程的信号，2）从主程序返回，3）调用 exit 函数</li>
</ul>
<p>该程序无返回值，<code>exit</code> 函数以 status 退出来终止进程。</p>
<pre><code>#include &lt;stdlib.h&gt;

void exit(int status);
</code></pre><p>父进程通过调用 <code>fork</code> 函数创建一个新的运行子进程，子进程返回0，父进程返回子进程的 PID，如果出错则为 -1。</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t fork(void);
</code></pre><p>新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份拷贝，包括文本、数据和 bss 段、以及用户栈。子进程还获得与父进程任何打开文件描述符相同的拷贝。父进程和新创建的子进程最大的区别在于他们有不同的 PID。</p>
<p><code>fork</code> 函数只被调用一次，却会返回两次(父进程与子进程)。因为子进程的 PID 总是非零的，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。</p>
<p><img src="/images/csapp8.15.jpg" alt="csapp8.15"></p>
<ul>
<li>调用一次，返回两次</li>
<li>并发执行。顺序不能保证</li>
<li>相同但是独立的地址空间，所以变量是分别独立的</li>
<li>共享文件，输出是指向同一个地方</li>
</ul>
<p><img src="/images/csapp8.16.jpg" alt="csapp8.16"></p>
<blockquote>
<p>回收子进程</p>
</blockquote>
<p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一中已终止的状态中，直到被它的父进程<strong>回收(reap)</strong>。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个终止了但还未被回收的进程称为<strong>僵死进程(zombie)</strong>。</p>
<p>如果父进程没有回收它的僵死子进程就终止了，那么内核就会安排 init 进程来回收它们。init 进程的 PID 为 1，并且是在系统初始化时由内核创建的。长时间运行的程序，比如 shell 或者服务器，总是应该回收它们的僵死子进程。即使僵死子进程没有运行，它们仍然小号系统的存储器资源。</p>
<p>一个进程可以通过调用 <code>waitpid</code> 函数来等待它的子进程终止或者停止。如果成功，则返回子进程的 PID，如果 WHOHANG ，则为 0，如果其他错误，则为 -1。</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

pit_t waitpid(pid_t pid, int *status, int options);
</code></pre><p>具体用法略</p>
<blockquote>
<p>让进程休眠</p>
</blockquote>
<p><code>sleep</code> 函数让一个进程挂起一段指定的时间。返回还要休眠的秒数。</p>
<pre><code>#include &lt;unistd.h&gt;
unsigned int sleep(unsigned int secs);
</code></pre><p>如果请求的时间量已经到了，<code>sleep</code>返回 0，否则返回还剩下要休眠的秒数。我们会发现很有用的另一个函数是 <code>pause</code> 函数，该函数让调用函数休眠，直到该进程收到一个信号。总是返回 -1。</p>
<pre><code>#include &lt;unistd.h&gt;
int pause(void);
</code></pre><blockquote>
<p>加载并运行程序</p>
</blockquote>
<p><code>execve</code> 函数子啊当前进程的上下文中加载并运行一个新程序。如果成功则不返回，如果错误，则返回 -1。</p>
<pre><code>#include &lt;unistd.h&gt;

int execve(const char *filename, const char *argv[], const char *envp[]);
</code></pre><p><code>execve</code> 函数加载并运行可执行目标文件 filename，且带参数列表 argv 和环境变量列表 envp。只有当出现错误时，<code>execve</code> 才会返回到调用程序。<code>execve</code> 调用一次并从不返回。</p>
<p><img src="/images/csapp8.19.jpg" alt="csapp8.19"></p>
<p>当 <code>main</code> 开始在一个 32 位 Linux 进程中执行时，用户栈有如下图所示的组织结构。</p>
<p><img src="/images/csapp8.21.jpg" alt="csapp8.21"></p>
<p><strong>程序与进程</strong></p>
<p>程序是一堆代码和数据；程序可以作为目标模块存在于磁盘上，或者作为段存在于地址空间中。进程执行中程序的一个具体的实例；程序总是运行在某个进程的上下文中。<code>fork</code>函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品。<code>execve</code> 函数在当前进程的上下文中加载并运行一个新的程序，会覆盖当前进程的地址空间，但并没有创建一个新进程。新的程序仍然拥有相同的 PID，并且继承了调用 <code>execve</code> 函数时已打开的所有文件描述符。</p>
<blockquote>
<p>利用 fork 和 execve 运行程序</p>
</blockquote>
<p>Shell 是一个交互型的应用级程序，它代表用户运行其他程序。最早的 shell 是 sh 程序，后面出现了一些变种，比如 csh, tcsh, ksh 和 bash。Shell 执行一系列的<strong>读/求值(read/evaluate)</strong>步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并代表用户运行程序。</p>
<h2 id="u4FE1_u53F7"><a href="#u4FE1_u53F7" class="headerlink" title="信号"></a>信号</h2><p>一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。下图是 Linux 系统支持的 30 种不同类型的信号。在 shell 中输入 <code>man 7 signal</code> 就能得到这个列表。</p>
<p><img src="/images/csapp8.25.jpg" alt="csapp8.25"></p>
<p>每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。比如，如果一个进程试图除以 0，那么内核就发送给他一个 <code>SIGFPE</code> 信号(8)。其他信号对应于内核或者其他用户进程中较高层的软件事件。比如，如果当进程在前台运行时，按下 ctrl-c，那么内核就会发送一个 <code>SIGINT</code> 信号(2)给这个前台进程。</p>
<blockquote>
<p>信号术语</p>
</blockquote>
<p>传送一个信号到目的进程是由两个不同步骤组成的：</p>
<ul>
<li><strong>发送信号</strong>。内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。发送信号可以用如下两个原因：1）内核检测到一个系统事件，比如被零除错误或者子进程终止。2）一个进程调用 kill 函数，显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。</li>
<li><strong>接收信号</strong>。当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为<strong>信号处理程序(signal handler)</strong>的用户层函数捕获这个信号。如下图所示</li>
</ul>
<p><img src="/images/csapp8.26.jpg" alt="csapp8.26"></p>
<p>一个只发出而没有被接收的信号叫做<strong>待处理信号(pending signal)</strong>。在任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为 k 的待处理信号，那么任何接下来发送到这个进程的类型为 k 的信号都不会排队等待，它们只是被简单地丢弃。一个进程可以有选择地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。</p>
<p>一个待处理信号最多只能被接收一次。内核为每个进程在 pending 位向量中维护着待处理信号的集合，而在 blocked 位向量中维护着被阻塞的信号集合。只要传送了一个类型为 k 的信号，内核就会设置 pending 中的第 k 位，而只要接收了一个类型为 k 的信号，内核就会清除 pending 中的第 k 位。</p>
<blockquote>
<p>发送信号</p>
</blockquote>
<p>Unix 系统提供了大量向进程发送信号的机制。所有这些机制都是基于<strong>进程组(process group)</strong>这个概念的。</p>
<p><strong>进程组</strong></p>
<p>每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的。<code>getpgrp</code> 函数返回当前进程的进程组 ID。</p>
<pre><code>#include &lt;unistd.h&gt;

pid_t getpgrp(void);
</code></pre><p>默认的，一个子进程和它的父进程同属一个进程组。一个进程可以通过使用 <code>setpgid</code> 函数来改变自己或者其他进程的进程组，成功则返回 0，否则返回 -1。</p>
<pre><code>#include &lt;unistd.h&gt;

int setpgid(pid_t pid, pid_t pgid);
</code></pre><p><strong>用 /bin/kill 程序发送信号</strong></p>
<p><code>/bin/kill</code> 程序可以向另外的进程发送任意的信号。比如</p>
<pre><code>unix&gt; /bin/kill -9 15213
</code></pre><p>发送信号9(SIGKILL)给进程 15213。</p>
<p><strong>从键盘发送信号</strong></p>
<p>Unix shell 使用<strong>作业(job)</strong>这个抽象概念来表示为对一个命令行求值而创建的进程。在任何时刻，至多只有一个前台作业和 0 个或多个后台作业。比如：</p>
<pre><code>unix&gt; ls | sort
</code></pre><p>创建一个由两个进程组成的前台作业，这两个进程是通过 Unix 管道连接起来的：一个进程运行 ls 程序，另一个运行 sort 程序。Shell 为每个作业创建一个独立的进程组。</p>
<p><strong>用 kill 函数发送信号</strong></p>
<p>进程通过调用 <code>kill</code> 函数发送信号给其他进程(包括它们自己)。如果 pid 大于零，那么 <code>kill</code> 函数发送信号 sig 给进程 pid。如果 pid 小于零，那么 kill 发送信号 sig 给进程组 abs(pid) 中的每个进程。</p>
<p><img src="/images/csapp8.28.jpg" alt="csapp8.28"></p>
<p><strong>用 alarm 函数发送信号</strong></p>
<p>进程可以通过调用 <code>alarm</code> 函数向它自己发送 SIGALRM 信号。返回前一次闹钟剩余的秒数，若以前没有设定闹钟，则为 0。</p>
<pre><code>#include &lt;unistd.h&gt;

unsigned int alarm(unsigned int secs);
</code></pre><blockquote>
<p>接收信号</p>
</blockquote>
<p>当内核从一个异常处理程序返回，准备将控制传递给进程 p 时，它会检查进程 p 的未被阻塞的待处理信号的集合(pending&amp;~blocked)。如果这个集合为空(通常情况下)，那么内核将控制传递到 p 的逻辑控制流中的下一条指令。</p>
<blockquote>
<p>信号处理问题</p>
</blockquote>
<p>当一个程序要补货多个信号时，一些细微的问题就产生了：</p>
<ul>
<li>待处理信号被阻塞</li>
<li>待处理信号不会排队等待</li>
<li>系统调用可以被中断</li>
</ul>
<p>不可以用信号来对其他进程中发生的事件计数。</p>
<blockquote>
<p>可移植的信号处理</p>
</blockquote>
<p>不同系统之间，信号处理语义的差异是 Unix 信号处理的一个缺陷。为了处理这个问题，Posix 标准定义了 <code>sigaction</code> 函数，它允许用户明确指定他们想要的信号处理语义。</p>
<blockquote>
<p>显式地阻塞和取消阻塞信号</p>
</blockquote>
<p>使用 <code>sigprocmask</code> 函数</p>
<blockquote>
<p>同步流以避免讨厌的并发错误</p>
</blockquote>
<p><strong>竞争(race)</strong>，经典同步错误</p>
<h2 id="u975E_u672C_u5730_u8DF3_u8F6C"><a href="#u975E_u672C_u5730_u8DF3_u8F6C" class="headerlink" title="非本地跳转"></a>非本地跳转</h2><p>C 语言提供了一种用户级一场控制流形式，称为<strong>非本地跳转(nonlocal jump)</strong>，它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用——返回序列，通过 <code>setjmp</code> 和 <code>longjmp</code> 函数来提供的。</p>
<pre><code>#include &lt;setjmp.h&gt;

int setjmp(jmp_buf env);
int sigsetjmp(sigjmp_buf env, int savesigs);
</code></pre><p><code>setjmp</code> 函数在 env 缓冲区中保存当前调用环境，以供后面 <code>longjmp</code> 使用，并返回 0。调用环境包括程序计数器、栈指针和通用目的寄存器。</p>
<pre><code>#include &lt;setjmp.h&gt;

void longjmp(jmp_buf env, int retval);
void siglongjmp(sigjmp_buf env, int retval);
</code></pre><p><code>longjmp</code> 函数从 env 缓冲区中恢复调用环境，然后触发一个从最近一次初始化 env 的 <code>setjmp</code> 调用的返回。然后 <code>setjmp</code> 返回，并带有非零的返回值 retval。</p>
<p><code>setjmp</code> 函数只被调用一次，但是返回<strong>多次</strong>：一次是当第一次调用 <code>setjmp</code>，而调用环境保存在缓冲区 env 时；一次是为每个相应的 <code>longjmp</code> 调用。另一方面，<code>longjmp</code> 函数被调用一次，但从不返回。</p>
<p>非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。如果在一个深层嵌套的函数调用中发现了一个错误，我们可以使用非本地跳转直接返回到一个普通的本地化的错误处理程序，而不是费力地解开调用栈。</p>
<p>非本地跳转的另一个重要应用是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。</p>
<p><img src="/images/csapp8.39.jpg" alt="csapp8.39"></p>
<h2 id="u64CD_u4F5C_u8FDB_u7A0B_u7684_u5DE5_u5177"><a href="#u64CD_u4F5C_u8FDB_u7A0B_u7684_u5DE5_u5177" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h2><p>Linux 系统提供了大量的监控和操作进程的有用工具：</p>
<ul>
<li>STRACE：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。用 <code>-static</code> 编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的 trace</li>
<li>PS：列出当前系统中的进程(包括僵死进程)</li>
<li>TOP：打印出关于当前进程资源使用的信息</li>
<li>PMAP：显示进程的存储器映射</li>
<li>/proc：一个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容，用户可以读取这些内容</li>
</ul>
<h2 id="u5C0F_u7ED3-6"><a href="#u5C0F_u7ED3-6" class="headerlink" title="小结"></a>小结</h2><p>异常控制流(ECF)发生在计算机系统的各个层次，是计算机系统中提供并发的基本机制。</p>
<p>在硬件层，异常是由处理器中的事件触发的控制流中的突变。控制流传递给一个软件处理程序，该处理程序进行一些处理，然后返回控制给被中断的控制流。</p>
<p>有四种不同类型的异常：中断、故障、终止和陷阱。</p>
<p>在操作系统层，内核用 ECF 提供进程的基本概念。进程提供给应用两个重要的抽象：1）逻辑控制流，它提供给每个程序一个假象，好像它是在独占地使用处理器，2）私有地址空间，它提供给每个程序一个假象，好像它是在独占地使用主存。</p>
<p>在操作系统和应用程序之间的接口处，应用程序可以创建子进程，等待它们的子进程停止或者终止，运行新的程序，以及不活来自其他进程的信号。信号处理的语义是微妙的，并且随着系统不同而不同。然而，在与 Posix 兼容的系统上存在着一些机制，允许程序清楚地指定期望的信号处理语义。</p>
<h1 id="u865A_u62DF_u5B58_u50A8_u5668"><a href="#u865A_u62DF_u5B58_u50A8_u5668" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><p>一个系统中的进程是与其他进程共享 CPU 和主存资源的。然而，共享主存会形成一些特殊的挑战。随着对 CPU 需求的增长，进程以某种合理的平滑方式慢了下来。但是如果太多的进程需要太多的存储器，那么它们中的一些就根本无法运行。当一个程序没有空间可用时，那就是它运气不好了。存储器还很容易被破坏。如果某个进程不小心写了另一个进程使用的存储器，它就可能以某种完全和程序逻辑无关的令人迷惑的方式失败。</p>
<p>为了更加有效地管理存储器并且少出错，现代系统提供了一种对主存的抽象概念，叫做<strong>虚拟存储器(VM)</strong>。虚拟存储器是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟存储器提供了三个重要的能力：1）它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。2）它为每个进程提供了一致的地址空间，从而简化了存储器管理。3）它保护了每个进程的地址空间不被其他进程破坏。</p>
<p>虚拟存储器是计算机系统最重要的概念之一。它成功的一个主要原因就是因为它是沉默地、自动地工作的，不需要应用程序员的任何干涉。</p>
<h2 id="u7269_u7406_u548C_u865A_u62DF_u5BFB_u5740"><a href="#u7269_u7406_u548C_u865A_u62DF_u5BFB_u5740" class="headerlink" title="物理和虚拟寻址"></a>物理和虚拟寻址</h2><p>计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的<strong>物理地址(Physical Address, PA)</strong>。第一个字节的地址为 0，接下来的字节地址为 1，再下一个为 2，以此类推。给定这种简单的结构，CPU 访问存储器的最自然的方式就是使用物理地址。我们把这种方式称为<strong>物理寻址(physical addressing)</strong>。如下图所示</p>
<p><img src="/images/csapp9.1.jpg" alt="csapp9.1"></p>
<p>当 CPU 执行这条加载指令时，它会生成一个有效物理地址，通过存储器总线，把它传递给主存。主存取出从物理地址 4 处开始的 4 字节的字，并将它返回给 CPU，CPU 会将它存放在一个寄存器里。</p>
<p>早起的 PC 使用 物理寻址，现代处理器使用的是一种称为<strong>虚拟寻址(virtual addressing)</strong>的寻址形式，如下图所示：</p>
<p><img src="/images/csapp9.2.jpg" alt="csapp9.2"></p>
<p>使用虚拟寻址时，CPU 通过生成一个<strong>虚拟地址(Virtual Address, VA)</strong>来访问主存，这个虚拟地址在被送到存储器之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做<strong>地址翻译(address translation)</strong>。就像异常处理一样，地址翻译需要 CPU 硬件和操作系统之间的紧密合作。CPU 芯片上叫做<strong>存储器管理单元(Memory Management Unit, MMU)</strong>的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容是由操作系统管理的。</p>
<h2 id="u5730_u5740_u7A7A_u95F4"><a href="#u5730_u5740_u7A7A_u95F4" class="headerlink" title="地址空间"></a>地址空间</h2><p><strong>地址空间(address space)</strong>是一个非负整数地址的有序集合：{0, 1, 2, …}。如果地址空间中的整数是连续的，那么我们说它是一个<strong>线性地址空间(linear address space)</strong>。</p>
<p>地址空间的概念是很重要的，因为它清楚地区分了数据对象(字节)和它们的属性(地址)。</p>
<h2 id="u865A_u62DF_u5B58_u50A8_u5668_u4F5C_u4E3A_u7F13_u5B58_u7684_u5DE5_u5177"><a href="#u865A_u62DF_u5B58_u50A8_u5668_u4F5C_u4E3A_u7F13_u5B58_u7684_u5DE5_u5177" class="headerlink" title="虚拟存储器作为缓存的工具"></a>虚拟存储器作为缓存的工具</h2><p>概念上而言，虚拟存储器(VM)被组织为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，这个唯一的虚拟地址是作为到数组的索引的。VM 系统通过将虚拟存储器分割为<strong>虚拟页(Virtual Page, VP)</strong>的大小固定的块来处理这个问题。每个虚拟页的大小为 P=2^p 字节。类似地，物理存储器被分割为<strong>物理页(Physical Page, PP)</strong>，大小也为 P 字节(物理页也称为<strong>页帧(page frame)</strong>)。</p>
<p>在任意时刻，虚拟页面的集合部分都分为三个不相交的子集：</p>
<ul>
<li>未分配的：VM 系统还未分配(或者创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。</li>
<li>缓存的：当前缓存在物理存储器中的已分配页。</li>
<li>未缓存的：没有缓存在物理存储器中的已分配页。</li>
</ul>
<p><img src="/images/csapp9.3.jpg" alt="csapp9.3"></p>
<blockquote>
<p>DRAM 缓存的组织结构</p>
</blockquote>
<p>这里用<strong>SRAM 缓存</strong>来表示位于 CPU 和主存之间的 L1, L2 和 L3 高速缓存，并且用<strong>DRAM 缓存</strong>来表示虚拟存储器系统的缓存，它在主存中缓存虚拟页。</p>
<p>DRAM 缓存的组织结构完全是由巨大的不命中开销驱动的。因为大的不命中处罚和访问第一字节的开销，虚拟页往往很大，典型地是<br>4KB-2MB。由于大的不命中处罚，DRAM 缓存是全相连的，也就是说，任何虚拟页都可以放置在任何的物理页中。不命中时的替换策略也很重要，因为替换错了虚拟页的出发也非常高。因此，与硬件对 SRAM 缓存相比，操作系统对 DRAM 缓存使用了更复杂精密的替换算法。最后，因为对磁盘的访问时间很长，DRAM 缓存总是使用写回(write back)，而不是直写。</p>
<blockquote>
<p>页表</p>
</blockquote>
<p>同任何缓存一样，虚拟存储器系统必须有某种方法来判定一个虚拟页是否存放在 DRAM 中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理存储器中选择一个牺牲页，并将虚拟页从磁盘拷贝到 DRAM 中，替换这个牺牲页。</p>
<p>这些功能是由许多软硬件联合提供的，包括操作系统软、MMU(存储器管理单元)中的地址翻译硬件和一个存放在物理存储器中叫做<strong>页表(page table)</strong>的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。</p>
<p>下图展示了一个页表的基本组织结构。页表就是一个<strong>页表条目(Page Table Entry, PTE)</strong>的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。</p>
<p><img src="/images/csapp9.4.jpg" alt="csapp9.4"></p>
<blockquote>
<p>页命中</p>
</blockquote>
<p><img src="/images/csapp9.5.jpg" alt="csapp9.5"></p>
<blockquote>
<p>缺页</p>
</blockquote>
<p>DRAM 缓存不命中称为<strong>缺页(page fault)</strong>。在虚拟存储器的习惯说法中，块被称为页。在磁盘和存储器之间传送页的活动叫做<strong>交换(swapping)</strong>或者<strong>页面调度(paging)</strong>。</p>
<p><img src="/images/csapp9.6.jpg" alt="csapp9.6"></p>
<p><img src="/images/csapp9.7.jpg" alt="csapp9.7"></p>
<blockquote>
<p>分配页面</p>
</blockquote>
<p><img src="/images/csapp9.8.jpg" alt="csapp9.8"></p>
<blockquote>
<p>又是局部性救了我们</p>
</blockquote>
<p>尽管在整个运行过程中程序引用的不同页面的总数可能超出物理存储器总的大小，但是局部性原则保证了在任意时刻，程序往往在一个较小的<strong>活动页面(active page)</strong>集合上工作，这个集合叫做<strong>工作集(working set)</strong>或者<strong>常驻集(resident set)</strong>。</p>
<h2 id="u865A_u62DF_u5B58_u50A8_u5668_u4F5C_u4E3A_u5B58_u50A8_u5668_u7BA1_u7406_u7684_u5DE5_u5177"><a href="#u865A_u62DF_u5B58_u50A8_u5668_u4F5C_u4E3A_u5B58_u50A8_u5668_u7BA1_u7406_u7684_u5DE5_u5177" class="headerlink" title="虚拟存储器作为存储器管理的工具"></a>虚拟存储器作为存储器管理的工具</h2><p>操作系统为每个进程提供了一个独立的页表，因为也就是一个独立的虚拟地址空间。如下图所示：</p>
<p><img src="/images/csapp9.9.jpg" alt="csapp9.9"></p>
<h2 id="u865A_u62DF_u5B58_u50A8_u5668_u4F5C_u4E3A_u5B58_u50A8_u5668_u4FDD_u62A4_u7684_u5DE5_u5177"><a href="#u865A_u62DF_u5B58_u50A8_u5668_u4F5C_u4E3A_u5B58_u50A8_u5668_u4FDD_u62A4_u7684_u5DE5_u5177" class="headerlink" title="虚拟存储器作为存储器保护的工具"></a>虚拟存储器作为存储器保护的工具</h2><p>如果一条指令违反了许可操作，那么 CPU 就出发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Unix shell 一般将这种异常报告为<strong>段错误(sgmentation fault)</strong>。</p>
<p><img src="/images/csapp9.10.jpg" alt="csapp9.10"></p>
<h2 id="u5730_u5740_u7FFB_u8BD1"><a href="#u5730_u5740_u7FFB_u8BD1" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>地址翻译的基础知识。</p>
<p><img src="/images/csapp9.11.jpg" alt="csapp9.11"></p>
<p><img src="/images/csapp9.12.jpg" alt="csapp9.12"></p>
<p>后面的暂略，几乎很少接触</p>
<h1 id="u7CFB_u7EDF_u7EA7_I/O"><a href="#u7CFB_u7EDF_u7EA7_I/O" class="headerlink" title="系统级 I/O"></a>系统级 I/O</h1><p>输入/输出是在主存和外部设备之间拷贝数据的过程。所有语言的运行时系统都提供执行 I/O 的较高级别的工具。</p>
<h2 id="Unix_I/O"><a href="#Unix_I/O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p>一个 Unix 文件就是一个 m 字节的序列。所有的 I/O 设备，如网络、磁盘和终端，都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许 Unix 内核引出一个简单、低级的应用接口，称为 Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行：</p>
<ul>
<li>打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O 设备。内核返回一个小的非负整数，叫做<strong>描述符</strong>，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。</li>
<li>改变当前的文件位置。</li>
<li>读写文件</li>
<li>关闭文件</li>
</ul>
<h2 id="u6253_u5F00_u548C_u5173_u95ED_u6587_u4EF6"><a href="#u6253_u5F00_u548C_u5173_u95ED_u6587_u4EF6" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h2><p>进程是通过调用 <code>open</code> 函数来打开一个已存在的文件或者创建一个新文件的。若成功则返回新文件描述符，否为返回 -1。</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int open(char *filename, int flags, mode_t mode);
</code></pre><p>进程通过调用 <code>close</code> 函数关闭一个打开的文件。若成功则返回 0，否则 -1。</p>
<pre><code>#include &lt;unistd.h&gt;

int close(int fd);
</code></pre><h2 id="u8BFB_u548C_u5199_u6587_u4EF6"><a href="#u8BFB_u548C_u5199_u6587_u4EF6" class="headerlink" title="读和写文件"></a>读和写文件</h2><p>应用程序是通过分别调用 <code>read</code> 和 <code>write</code> 函数来执行输入和输出的。</p>
<pre><code>#include &lt;unistd.h&gt;

ssize_t read(int fd, void *buf, size_t n);
ssize_t write(int fd, const void *buf, size_t n);
</code></pre><h2 id="u7528_RIO__u5305_u5065_u58EE_u5730_u8BFB_u5199"><a href="#u7528_RIO__u5305_u5065_u58EE_u5730_u8BFB_u5199" class="headerlink" title="用 RIO 包健壮地读写"></a>用 RIO 包健壮地读写</h2><p>提供两类不同的函数：无缓冲的输入输出函数与带缓冲的输入函数。</p>
<h2 id="u8BFB_u53D6_u6587_u4EF6_u5143_u6570_u636E"><a href="#u8BFB_u53D6_u6587_u4EF6_u5143_u6570_u636E" class="headerlink" title="读取文件元数据"></a>读取文件元数据</h2><p>应用程序能够通过调用 <code>stat</code> 和 <code>fstat</code> 函数，检索到关于文件的信息，有时也称为文件的<strong>元数据(metadata)</strong>。</p>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;

int stat(const char *filename, struct stat *buf);
int fstat(int fd, struct stat *buf);
</code></pre><p><img src="/images/csapp10.8.jpg" alt="csapp10.8"></p>
<h2 id="u5171_u4EAB_u6587_u4EF6"><a href="#u5171_u4EAB_u6587_u4EF6" class="headerlink" title="共享文件"></a>共享文件</h2><p>可以用许多不同的方式来共享 Unix 文件。内核用三个相关的数据结构来表示打开的文件：</p>
<ul>
<li>描述符表(descriptor table)。每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表指向<strong>文件表</strong>中的一个表项。</li>
<li>文件表(file table)。打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项包括当前的文件位置、**引用计数(reference count)，以及一个指向 <code>v-node 表</code>中对应表项的指针。</li>
<li>v-node 表(v-node table)。同文件表一样，所有的进程共享这张表。每个表项包含 stat 结构中的大多数信息。</li>
</ul>
<p><img src="/images/csapp10.11.jpg" alt="csapp10.11"></p>
<p><img src="/images/csapp10.12.jpg" alt="csapp10.12"></p>
<p><img src="/images/csapp10.13.jpg" alt="csapp10.13"></p>
<h2 id="I/O__u91CD_u5B9A_u5411"><a href="#I/O__u91CD_u5B9A_u5411" class="headerlink" title="I/O 重定向"></a>I/O 重定向</h2><p>Unix shell 提供了 I/O 重定向操作符，允许用户将磁盘文件和标准输入输出联系起来，例如</p>
<pre><code>unix&gt; ls &gt; foo.txt
</code></pre><p><img src="/images/csapp10.14.jpg" alt="csapp10.14"></p>
<h2 id="u6807_u51C6_I/O"><a href="#u6807_u51C6_I/O" class="headerlink" title="标准 I/O"></a>标准 I/O</h2><p>ANSI C 定义了一组高级输入输出函数，称为<strong>标准 I/O 库</strong>，为程序员提供了 Unix I/O 的较高级别的替代。这个库(libc)提供了打开和关闭文件的函数(<code>fopen</code>和<code>fclose</code>)，读和写字节的函数(<code>fread</code>和<code>fwrite</code>)，读和写字符串的函数(<code>fgets</code>和<code>fputs</code>)，以及复杂的格式化的 I/O 函数(<code>scanf</code>和<code>printf</code>)。</p>
<p>标准 I/O 库将一个打开的文件模型化为一个<strong>流</strong>。对于程序员而言，一个流就是一个指向 FILE 类型的结构的指针。</p>
<h2 id="u7EFC_u5408_uFF1A_u8BE5_u4F7F_u7528_u54EA_u4E9B_I/O__u51FD_u6570"><a href="#u7EFC_u5408_uFF1A_u8BE5_u4F7F_u7528_u54EA_u4E9B_I/O__u51FD_u6570" class="headerlink" title="综合：该使用哪些 I/O 函数"></a>综合：该使用哪些 I/O 函数</h2><p><img src="/images/csapp10.15.jpg" alt="csapp10.15"></p>
<p>标准 I/O 流，从某种意义上而言是<strong>全双工</strong>的，因为程序能够在同一个流上执行输入和输出。然而，对流的限制和对套接字的限制，有时候会互相冲突：</p>
<ul>
<li>限制一：跟在输出函数之后的输入函数。如果中间没有插入对 <code>fflush</code>, <code>fseek</code>, <code>fsetpos</code> 或者 <code>rewind</code> 的调用，一个输入函数不能跟随在一个输出函数之后。<code>fflush</code> 函数清空与流相关的缓冲区。后三个函数使用 Unix I/O <code>lseek</code> 函数来重置当前的文件位置。</li>
<li>限制二：跟在输入函数之后的输出函数。如果中间没有插入对 <code>fseek</code>, <code>fsetpos</code> 或者 <code>rewind</code> 的调用，一个输出函数不能跟随在一个输入函数之后，除非该输入函数遇到了一个 EOF。</li>
</ul>
<p>这些限制给网络应用带来了一个问题，因为对套接字使用 <code>lseek</code> 函数是非法的，所以在网络套接字上不要使用标准 I/O 进行输入和输出，而要使用健壮的 <code>RIO</code> 函数。</p>
<h2 id="u5C0F_u7ED3-7"><a href="#u5C0F_u7ED3-7" class="headerlink" title="小结"></a>小结</h2><p>Unix 提供了少量的系统级函数，它们允许应用程序打开、关闭、读和写文件，提取文件的元数据，以及执行 I/O 重定向。 Unix 的读和写操作会出现不足值，应用程序必须能正确地预计和处理这种情况。应用程序不应直接调用 Unix I/O 函数，而应该使用 RIO 包，RIO 包通过反复执行读写操作，直到传送完所有的请求数据，自动处理不足值。</p>
<p>Unix 内核使用三个相关的数据结构来表示打开的文件。描述符表中的表项指向打开文件表中的表项，而打开文件表中的表项又指向 v-node 表中的表项。</p>
<p>标准 I/O 库是基于 Unix I/O 实现的，并提供了一组强大的高级 I/O 例程。对于大多数应用程序而言，标准 I/O 更简单，是优于 Unix I/O 的选择。然而，因为对标准 I/O 和网络文件的一些相互不兼容的限制，Unix I/O 比标准 I/O 更适用于网络应用程序。</p>
<h1 id="u7F51_u7EDC_u7F16_u7A0B"><a href="#u7F51_u7EDC_u7F16_u7A0B" class="headerlink" title="网络编程"></a>网络编程</h1><p>网络应用随处可见。有趣的是，所有的网络应用都是基于相同的基本编程模型，有着相似的整体逻辑结构，并且一来相同的编程接口。</p>
<p>网络应用依赖于很多在系统研究正已经学习过的概念，例如，进程、信号、字节顺序、存储器映射以及动态存储分配，都扮演着重要的角色。</p>
<h2 id="u5BA2_u6237_u7AEF-_u670D_u52A1_u5668_u7F16_u7A0B_u6A21_u578B"><a href="#u5BA2_u6237_u7AEF-_u670D_u52A1_u5668_u7F16_u7A0B_u6A21_u578B" class="headerlink" title="客户端-服务器编程模型"></a>客户端-服务器编程模型</h2><p>每个网络应用都是基于<strong>客户端-服务器模型</strong>模型的。采用这个模型，一个应用是由一个<strong>服务器</strong>进程和一个或者多个<strong>客户端</strong>进程组成。服务器管理某种<strong>资源</strong>，并且通过操作这种资源来为它的客户端提供某种<strong>服务</strong>。</p>
<p>客户端-服务器模型中的基本操作是<strong>事务(transaction)</strong>，由四步组成，如下图所示：</p>
<p><img src="/images/csapp11.1.jpg" alt="csapp11.1"></p>
<h2 id="u7F51_u7EDC"><a href="#u7F51_u7EDC" class="headerlink" title="网络"></a>网络</h2><p>客户端和服务器通常运行在不同的主机上，并且通过<strong>计算机网络</strong>的硬件和软件资源来通信。对于一台主机而言，网络只是又一种 I/O 设备，作为数据源和数据接收方，如下图所示。</p>
<p><img src="/images/csapp11.2.jpg" alt="csapp11.2"></p>
<p>物理上而言，网络是一个按照地理远近组成的层次系统。最底层是 LAN(Local Area Network, 局域网)，在一个建筑或者校园范围内。迄今为止，最流行的局域网技术是<strong>以太网(Ethernet)</strong>。</p>
<p>每个以太网适配器都有一个全球唯一的 48 位地址，一台主机可以发送一段位，称为<strong>帧(frame)</strong>，到这个网段内的其他任何主机。每个帧包括一些固定数量的<strong>头部(header)</strong>位，用来标识此帧的源和目的地址以及此帧的长度，伺候紧随的就是数据位的<strong>有效载荷</strong>。每个主机适配器都能看到这个帧，但是只有目的主机实际读取它。</p>
<p>使用一些电缆和叫做网桥(bridge)的小盒子，多个以太网段可以连接成较大的局域网，称为**桥接以太网(bridged Ethernet)，如下图所示：</p>
<p><img src="/images/csapp11.4.jpg" alt="csapp11.4"></p>
<p>在层次更高的级别中，多个不兼容的局域网可以通过叫做<strong>路由器(router)</strong>的忒书计算机连接起来，组成一个<strong>internet(互联网络)</strong>。</p>
<p><img src="/images/csapp11.6.jpg" alt="csapp11.6"></p>
<p>协议软件消除了不同网络之间的差异，必须具备两种基本能力：命名机制和传送机制。</p>
<p>每台因特网主机都运行实现 <strong>TCP/IP 协议(Transmission Control Protocol/Internet Protocol)</strong>的软件，几乎每个现代计算机系统都支持这个协议。</p>
<p><img src="/images/csapp11.8.jpg" alt="csapp11.8"></p>
<p>TCP/IP 实际上是一个协议族，其中每一个都提供不同的功能。从程序员角度，我们可以把因特网看做一个世界范围的主机集合，满足以下特性：</p>
<ul>
<li>主机集合被映射为一组 32 位的 IP 地址</li>
<li>这组 IP 地址被映射为一组称为<strong>因特网域名(Internet domain name)</strong>的标识符</li>
<li>因特网主机上的进程能够通过<strong>连接(connection)</strong>和任何其他因特网主机上的进程通信</li>
</ul>
<blockquote>
<p>IP 地址</p>
</blockquote>
<p>一个 IP 地址就是一个 32 位无符号整数。IP 地址通常是以一种称为<strong>点分十进制表示法</strong>来表示的，这里，每个字节由它的十进制值表示，并且用句点和其他字节间分开。</p>
<p>因特网程序使用 <code>inet_aton</code> 和 <code>inet_ntoa</code> 函数来实现 IP 地址和点分十进制串之间的转换</p>
<pre><code>#include &lt;arpa/inet.h&gt;

int inet_aton(const char *cp, struct in_addr *inp);
char *inet_ntoa(struct in_addr in);
</code></pre><p>n 表示网络(network)，a 表示应用(application)。</p>
<blockquote>
<p>因特网域名</p>
</blockquote>
<p>域名集合形成了一个层次结构，每个域名编码了它在这个层次中的位置。</p>
<p><img src="/images/csapp11.10.jpg" alt="csapp11.10"></p>
<blockquote>
<p>因特网连接</p>
</blockquote>
<p>因特网客户端和服务器通过在<strong>连接</strong>上发送和接收字节流来通信。从连接一对进程的意义上而言，连接是点对点的。从数据可以同时双向流动的角度来说，它是<strong>全双工</strong>的。并且由源进程发出的字节流最终被目的进程以它发出的顺序收到它的角度来说，它是可靠的。</p>
<p>一个<strong>套接字</strong>是连接的一个端点。每个套接字都有相应的<strong>套接字地址</strong>，是由一个因特网地址和一个 16 位的整数<strong>端口</strong>组成的，用<code>地址:端口</code>来表示。当客户端发起一个连接请求时，客户端套接字地址中的端口是由内核自动分配的，称为<strong>临时端口(ephemeral port)</strong>。然而，服务器套接字地址中的端口通常是某个<strong>知名的端口</strong>，是和这个服务相对应的。例如，Web 服务器通常使用端口 80，而电子邮件服务器使用端口 25。在 Unix 机器上，文件 <code>/etc/services</code> 包含一张这台机器提供的服务以及它们的知名端口号的综合列表。</p>
<p>一个连接由它两端的套接字地址唯一确定。这对套接字地址叫做<strong>套接字对(socket pair)</strong>，由下列元组来表示：</p>
<pre><code>(cliaddr:cliport, servaddr:servport)
</code></pre><p><img src="/images/csapp11.13.jpg" alt="csapp11.13"></p>
<h2 id="u5957_u63A5_u5B57_u63A5_u53E3"><a href="#u5957_u63A5_u5B57_u63A5_u53E3" class="headerlink" title="套接字接口"></a>套接字接口</h2><p><strong>套接字接口(socket interface)</strong>是一组函数，它们和 Unix I/O 函数结合起来，用以创建网络应用。</p>
<p><img src="/images/csapp11.14.jpg" alt="csapp11.14"></p>
<blockquote>
<p>套接字地址结构</p>
</blockquote>
<p>从 Unix 内核的角度来看，一个套接字就是通信的一个端点。从 Unix 程序的角度来看，套接字就是一个有相应描述符的打开文件。</p>
<blockquote>
<p>socket 函数</p>
</blockquote>
<p>客户端和服务器使用 <code>socket</code> 函数来创建一个<strong>套接字描述符(socket descriptor)</strong></p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol);
</code></pre><blockquote>
<p>connect 函数</p>
</blockquote>
<p>客户端通过调用 <code>connect</code> 函数来建立和服务器的连接。</p>
<pre><code>#include &lt;sys/socket.h&gt;

int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);
</code></pre><p>剩下还有<code>bind</code>, <code>listen</code>, <code>accept</code> 等函数，略</p>
<h2 id="Web__u670D_u52A1_u5668"><a href="#Web__u670D_u52A1_u5668" class="headerlink" title="Web 服务器"></a>Web 服务器</h2><blockquote>
<p>Web 基础</p>
</blockquote>
<p>Web 客户端和服务器之间的交互用的是一个基于文本的应用级协议，叫做 HTTP(Hypertext Transfer Protocol)。HTTP 是一个简单的协议。一个 Web客户端打开一个到服务器的因特网连接，并且请求某些内容。服务器响应所请求的内容，然后关闭连接。浏览器读取这些内容，并把它显示在屏幕上。</p>
<blockquote>
<p>Web 内容</p>
</blockquote>
<p>对于 Web 客户端和服务器而言，内容是一个与 MIME(Multipurpose Internet Mail Extensions)类型相关的字节序列。</p>
<p><img src="/images/csapp11.22.jpg" alt="csapp11.22"></p>
<p>Web 服务器以两种不同的方式向客户端提供内容：</p>
<ul>
<li>取一个磁盘文件，并将它的内容返回给客户端。磁盘文件称为<strong>静态内容(static content)</strong>，而返回文件给客户端的过程称为<strong>服务静态内容(serving static content)</strong>。</li>
<li>运行一个可执行文件，并将它的输出返回给客户端。运行时可执行文件产生的输出称为<strong>动态内容(dynamic content)</strong>，而运行程序并返回它的输出到客户端的过程称为<strong>服务动态内容(serving dynamic content)</strong>。</li>
</ul>
<p>每条由 Web 服务器返回的内容都是和它管理的某个文件相关联的。这些文件中的每一个都有一个唯一的名字，叫做 URL(Universal Resource Locator)。</p>
<p>关于服务器如何解释一个 URL 的后缀，以下几点需要理解：</p>
<ul>
<li>确定一个 URL 指向的是静态内容还是动态内容没有标准的规则。每个服务器对它所管理的文件都有自己的规则。一种常见方法是，确定一组目录，例如 cgi-bin，所有的可执行文件都必须存放这些目录中。</li>
<li>后缀中的最开始的那个 <code>/</code> 不表示 Unix 的根目录。相反，它表示的是被请求内容类型的主目录。例如，可以将一个服务器配置成这样：所有的静态内容存放在目录 <code>/usr/httpd/html</code> 下。</li>
<li>最小的 URL 后缀是 <code>/</code> 字符，所有服务器将其扩展为某个默认的主页，例如 <code>/index.html</code>。这解释了为什么在浏览器中键入一个域名就可以取出一个网站的主页。浏览器在 URL 后添加缺失的 <code>/</code>，之后服务器把 <code>/</code> 扩展到某个默认的文件名。</li>
</ul>
<blockquote>
<p>HTTP 事务</p>
</blockquote>
<p>因为 HTTP 是基于在因特网连接上传送的文本行的，我们可以使用 Unix 的 TELNET 程序来和因特网上的任何 Web 服务器执行事务。</p>
<p><img src="/images/csapp11.23.jpg" alt="csapp11.23"></p>
<p><strong>HTTP 请求</strong></p>
<p>一个 HTTP 请求的组成是这样的：一个<strong>请求行(request line)</strong>(line 5)，后面跟随零个或更多个<strong>请求报头(request header)</strong>(line 6)，在跟随一个空的文本行来终止报头列表(line 7)。一个请求行的形式是</p>
<pre><code>&lt;method&gt; &lt;url&gt; &lt;version&gt;
</code></pre><p>HTTP 支持不同的方法，包括 GET, POST, OPTIONS, HEAD, PUT, DELETE 和 TRACE。主要应用的是 GET 方法。</p>
<p><strong>HTTP 响应</strong></p>
<p>HTTP 响应和 HTTP 请求是相似的。一个 HTTP 响应的组成是这样的：一个<strong>响应行(response line)</strong>(line 8)后面跟随着零个或者更多的<strong>响应报头(response header)</strong>(line 9-13)，再跟随一个终止报头的空行(line 14)，在跟随一个<strong>响应主体(response body)</strong>(line 15-17)。一个响应行的格式是</p>
<pre><code>&lt;version&gt; &lt;status code&gt; &lt;status message&gt;
</code></pre><p>版本字段描述的是响应所遵循的 HTTP 版本。<strong>状态码(status code)</strong>是一个三位数的正整数，指明对请求的处理。<strong>状态消息(status message)</strong>给出与错误代码等价的英文描述。第9-13行的响应报头提供了关于响应的附加信息。针对我们的目的，两个最重要的报头是 <code>Content-Type</code>(line 12)，它告诉客户端响应主体中内容 MIME 类型；以及 <code>Content-Length</code>(line 13)，用来指示响应主体的字节大小。</p>
<p><img src="/images/csapp11.24.jpg" alt="csapp11.24"></p>
<h2 id="u5C0F_u7ED3-8"><a href="#u5C0F_u7ED3-8" class="headerlink" title="小结"></a>小结</h2><p>Web 服务器使用 HTTP 协议和它们的客户端彼此通信。浏览器向服务器请求静态或者动态内容。CGI 标准提供了一组规则，来管理客户端如何将程序参数传递给服务器，服务器如何将这些参数以及其他信息传递给子进程，以及子进程如何将它的输出发送会客户端。</p>
<h1 id="u5E76_u53D1_u7F16_u7A0B"><a href="#u5E76_u53D1_u7F16_u7A0B" class="headerlink" title="并发编程"></a>并发编程</h1><p>应用级并发在以下情况下很有用：</p>
<ul>
<li>访问慢速 I/O 设备</li>
<li>与人交互</li>
<li>通过推迟工作以降低延迟</li>
<li>服务多个网络客户端</li>
<li>在多核机器上进行并行计算</li>
</ul>
<p>使用应用级并发的应用程序称为<strong>并发程序(concurrent program)</strong>。现代操作系统提供了三种基本的构造并发程序的方法：</p>
<ul>
<li>进程。用这种方法，每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显式的**进程间通信(interprocess communication, IPC)机制。</li>
<li>I/O 多路复用。在这种形式的并发编程中，应用程序在一个进程的上下文中显式地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态。因为程序是一个单独的进程，所以所有的流都共享同一个地址空间。</li>
<li>线程。线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。你可以把线程看成是其他两种方式的混合体，像进程流一样由内核进行调度，而像 I/O 多路复用一样共享同一个虚拟地址空间。</li>
</ul>
<h2 id="u57FA_u4E8E_u8FDB_u7A0B_u7684_u5E76_u53D1_u7F16_u7A0B"><a href="#u57FA_u4E8E_u8FDB_u7A0B_u7684_u5E76_u53D1_u7F16_u7A0B" class="headerlink" title="基于进程的并发编程"></a>基于进程的并发编程</h2><p>构造并发程序最简单的方法就是用进程，使用那些大家都很熟悉的函数，像 <code>fork</code>, <code>exec</code> 和 <code>waitpid</code>。</p>
<p><img src="/images/csapp12.1.jpg" alt="csapp12.1"></p>
<p><img src="/images/csapp12.2.jpg" alt="csapp12.2"></p>
<p><img src="/images/csapp12.3.jpg" alt="csapp12.3"></p>
<p><img src="/images/csapp12.4.jpg" alt="csapp12.4"></p>
<p>对于在父、子进程间共享状态信息，进程有一个非常清晰的模型：共享文件表，但是不共享用户地址空间。进程有独立的地址空间既是优点也是缺点。这样一来，一个进程不可能不小心覆盖另一个进程的虚拟存储器，这就消除了许多令人迷惑的错误。</p>
<p>另一方面，独立的地址空间使得进程共享状态信息变得更加困难。为了共享信息，它们必须使用显式的 IPC 机制。基于进程的设计的另一个缺点是，它们往往比较慢，因为进程控制和 IPC 的开销很高。</p>
<h2 id="u57FA_u4E8E_I/O__u591A_u8DEF_u590D_u7528_u7684_u5E76_u53D1_u7F16_u7A0B"><a href="#u57FA_u4E8E_I/O__u591A_u8DEF_u590D_u7528_u7684_u5E76_u53D1_u7F16_u7A0B" class="headerlink" title="基于 I/O 多路复用的并发编程"></a>基于 I/O 多路复用的并发编程</h2><p>I/O 多路复用可以用作并发<strong>事件驱动(event-driven)</strong>程序的基础，在事件驱动程序中，流是因为某种事件而前进的。一般概念是将逻辑流模型化为状态机。不严格地说，一个<strong>状态机(state machine)</strong>就是一组<strong>状态(state)</strong>、<strong>输入事件(input event)</strong>和<strong>转移(transition)</strong>，其中转移就是将状态和输入事件映射到状态。每个状态都将一个(输入状态，输入事件)对映射到一个输出状态。<strong>自循环(self-loop)</strong>是同一组输入和输出状态之间的转移。通常把状态机花城有向图，其中节点表示状态，有向弧表示转移，而弧上的标号表示输入事件。一个状态机从某种初始状态开始执行。每个输入事件都会引发一个从当前状态到下一状态的转移。</p>
<p>事件驱动设计的一个优点是，它比基于进程的设计给了程序员更多的对程序行为的控制。另一个优点是在流之间共享数据变得很容易，而且事件驱动设计常常比基于进程的设计要高效得多，因为它们不需要进程上下文切换来调度新的流。</p>
<p>事件驱动设计的一个明显的缺点就是编码复杂，另一重大缺点时它们不能充分利用多核处理器。</p>
<h2 id="u57FA_u4E8E_u7EBF_u7A0B_u7684_u5E76_u53D1_u7F16_u7A0B"><a href="#u57FA_u4E8E_u7EBF_u7A0B_u7684_u5E76_u53D1_u7F16_u7A0B" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h2><p><strong>线程(thread)</strong>就是运行在进程上下文中的逻辑流，由内核自动调度。每个线程都有它自己的<strong>线程上下文(thread context)</strong>，包括一个唯一的整数<strong>线程ID(Thread ID, TID)</strong>、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。</p>
<p><img src="/images/csapp12.12.jpg" alt="csapp12.12"></p>
<h2 id="u591A_u7EBF_u7A0B_u7A0B_u5E8F_u4E2D_u7684_u5171_u4EAB_u53D8_u91CF"><a href="#u591A_u7EBF_u7A0B_u7A0B_u5E8F_u4E2D_u7684_u5171_u4EAB_u53D8_u91CF" class="headerlink" title="多线程程序中的共享变量"></a>多线程程序中的共享变量</h2><p>从一个程序员的角度来看，线程很有吸引力的一个方面就是多个线程很容易共享相同的程序变量。然而，这种共享也是很棘手的。</p>
<blockquote>
<p>线程存储器模型</p>
</blockquote>
<p>一组并发线程运行在一个进程的上下文中。每个线程都有它自己独立的<strong>线程上下文</strong>，包括线程 ID、栈、栈指针、程序计数器、条件码和通用目的寄存器。每个线程和其他线程一个共享进程上下文的剩余部分。这包括整个用户虚拟地址空间，它是由只读文本(代码)、读/写数据、堆以及所有的共享库代码和数据区域组成的。</p>
<p>从实际操作的角度来说，让一个线程去读写另一个线程的寄存器是不可能的。寄存器是从不共享的，而虚拟存储器总是共享的。</p>
<blockquote>
<p>将变量映射到存储器</p>
</blockquote>
<p>线程化的 C 程序中变量根据它们的存储类型被映射到虚拟存储器：</p>
<ul>
<li>全局变量：在运行时，虚拟存储器的读/写区域只包含每个全局变量的一个实例，任何线程都可以引用</li>
<li>本地自动变量：定义在函数内部但是没有 static 属性的变量。在运行时，每个线程的栈都包含它自己的所有本地自动变量的实例</li>
<li>本地静态变量：定义在函数内部并有 static 属性的变量，和全局变量一样</li>
</ul>
<h2 id="u7528_u4FE1_u53F7_u91CF_u540C_u6B65_u7EBF_u7A0B"><a href="#u7528_u4FE1_u53F7_u91CF_u540C_u6B65_u7EBF_u7A0B" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h2><p>共享变量是十分方便的，但是它们也引入了<strong>同步错误(synchronization error)</strong>的可能性。一般而言，你没有办法预测操作系统是否将为你的线程选择一个正确的顺序。</p>
<p>一些关键词：进度图，信号量，使用信号量来实现互斥，生产者-消费者问题，两类读者-写者问题</p>
<h2 id="u5176_u4ED6_u5E76_u53D1_u95EE_u9898"><a href="#u5176_u4ED6_u5E76_u53D1_u95EE_u9898" class="headerlink" title="其他并发问题"></a>其他并发问题</h2><p>这些典型问题是任何类型的并发流操作共享资源时都会出现的。</p>
<blockquote>
<p>线程安全</p>
</blockquote>
<p>四个(不相交的)线程不安全函数类：</p>
<ul>
<li>不保护共享变量的函数</li>
<li>保持跨越多个调用的状态的函数</li>
<li>返回指向静态变量的指针的函数</li>
<li>调用线程不安全函数的函数</li>
</ul>
<blockquote>
<p>可重入性</p>
</blockquote>
<p>其特点在于当被多个线程调用时，不会引入任何共享数据。</p>
<p><img src="/images/csapp12.37.jpg" alt="csapp12.37"></p>
<blockquote>
<p>在线程化的程序中使用已存在的库函数</p>
</blockquote>
<p>大多数 Unix 函数，包括定义在标准 C 库中的函数都是线程安全，只有一小部分是例外：</p>
<p><img src="/images/csapp12.39.jpg" alt="csapp12.39"></p>
<blockquote>
<p>竞争</p>
</blockquote>
<p>当一个程序的正确性依赖于一个线程要在另一个线程达到 y 点之前达到它的控制流中的 x 点时，就会发生<strong>竞争(race)</strong>。</p>
<blockquote>
<p>死锁</p>
</blockquote>
<p>指的是一组线程被阻塞了，等待一个永远也不会为真的条件。进度图对于理解死锁是一个无价的工具。</p>
<p><img src="/images/csapp12.42.jpg" alt="csapp12.42"></p>
<p><img src="/images/csapp12.43.jpg" alt="csapp12.43"></p>
<p>重叠的禁止区域引起了一组称为<strong>死锁区域(deadlock region)</strong>的状态。</p>
<h2 id="u5C0F_u7ED3-9"><a href="#u5C0F_u7ED3-9" class="headerlink" title="小结"></a>小结</h2><p>无论哪种并发机制，同步对于共享数据的并发访问都是一个困难的问题。提出对信号的 P 和 V 操作就是为了帮助解决这个问题。信号量操作可以用来提供对共享数据的互斥访问，也对诸如生产者-消费者程序中有限缓冲区和读者-写者系统中的共享对象这样的资源访问进行调度。</p>
<p>并发也引入了其他一些困难的问题。被线程调用的函数必须具有一种称为线程安全的属性。竞争和死锁是并发程序中出现的另一些困难的问题。当程序员错误地假设逻辑流该如何调度时，就会发生竞争。当一个流等待一个永远不会发生的事件时，就会产生死锁。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是我之前自学时的笔记，本文的内容为第二版，现在最新是第三版。</p>
<p><em>Notes from Da Wang, Feb.2 2015</em></p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="原理" scheme="http://wdxtub.com/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[烤箱指南]]></title>
    <link href="http://wdxtub.com/2016/03/26/oven-guide/"/>
    <id>http://wdxtub.com/2016/03/26/oven-guide/</id>
    <published>2016-03-26T19:23:14.000Z</published>
    <updated>2016-03-26T19:38:34.000Z</updated>
    <content type="html"><![CDATA[<p>在美国学会的技能之一就是用烤箱做懒人食品，但烤箱也是有门道的，尤其是各种香料，这里收集了一些基本知识和技巧，分享给大家。</p>
<a id="more"></a>
<hr>
<p>刀工和颠勺两样，前者关乎食材的准备，后者关乎火候，这两样学会了，大抵就错不了。再后来我发现，除了这两样之外，还需要两样东西，就是对食材的感觉，和对自己的信心。</p>
<p>每次看到一个菜谱后自己做时，我不会纠结我手头的材料和菜谱不是一模一样，我不会纠结具体的制作时间和放多少调料这些细节，因为我对自己有信心，因为我对自己对食材的感觉有信心。</p>
<p>食材好，做出来的东西一般不会有大问题，所以在战术上要重视食材，再好的技术，没有好食材也做不出美食来。</p>
<p>但是不能被食材所左右，真正在操作的是自己，美味的界限由自己来拓展，好食材只是工具，这就是在战略上藐视食材。</p>
<h2 id="u70E4_u8089_u5668_u5177"><a href="#u70E4_u8089_u5668_u5177" class="headerlink" title="烤肉器具"></a>烤肉器具</h2><p><strong>器材</strong></p>
<ul>
<li>一个大烤盘。这是你最基本的烤箱器材，用来烤大批东西用，而且在其它器材不足的情况下可以勉强代替使用</li>
<li>一个带烤架的深盘。有些东西烤的时候要考虑到各个方位均匀加热，用烤架架着隔空烤更加合适。而且这个深盘平常可以用来烤别的东西</li>
<li>一个中号的玻璃或者陶瓷烤皿。用来焗东西，或者用来烤小批的东西</li>
<li>几个小号的烤皿。用来做些快速方便的吃食，或者做开胃菜</li>
<li>一个可以进烤箱的铸铁煎锅/铁板。有些肉类需要先煎然后再进烤箱烤，这个时候如果能整个锅放进烤箱就方便好多</li>
<li>肉类温度计。烤大块肉的之后，要知道肉的内部有没有熟就要靠肉类温度计了，具体样子上面的图已经出现过了</li>
<li>其它小配件。比如烤串用的竹签，烤箱手套，锡纸，注射用的针管等等</li>
</ul>
<p><strong>调料</strong></p>
<ul>
<li>基本：盐，黑胡椒</li>
<li>香料：罗勒、迷迭香、百里香、孜然和王守义十三香（具体参见香料详解）</li>
<li>其它调料：蜂蜜（有时候烤肉时能刷），洋葱，蒜，烤肉酱，番茄酱</li>
</ul>
<h2 id="u7B80_u6613_u83DC_u8C31"><a href="#u7B80_u6613_u83DC_u8C31" class="headerlink" title="简易菜谱"></a>简易菜谱</h2><h3 id="u7ECF_u5178_u871C_u6C41_u9E21_u7FC5"><a href="#u7ECF_u5178_u871C_u6C41_u9E21_u7FC5" class="headerlink" title="经典蜜汁鸡翅"></a>经典蜜汁鸡翅</h3><ul>
<li>难度★★</li>
<li>腌一腌：鸡翅用味极鲜酱油、蚝油、五香粉腌一晚上。番茄酱什么的也可以随意放，反正怎么都好吃。</li>
<li>烤一烤：上烤架，为了防粘，烤架上面铺锡纸，用叉子戳洞，方便滴油。下面放烤盘接油。200℃ 10分钟，拿出来刷蜂蜜，继续10分钟。再拿出来翻面刷蜂蜜，10分钟。</li>
</ul>
<h3 id="u7EAF_u7237_u4EEC_u7F8A_u8089_u4E32"><a href="#u7EAF_u7237_u4EEC_u7F8A_u8089_u4E32" class="headerlink" title="纯爷们羊肉串"></a>纯爷们羊肉串</h3><ul>
<li>难度★★★★</li>
<li>切一切：无骨的净羊肉切大块。</li>
<li>腌一腌：用大量孜然粉、大量辣椒粉、一点盐抓匀，有的话还可以放一点蒜粉和葱粉。</li>
<li>串一串：就是串竹签。</li>
<li>烤一烤：烤架+烤盘接油，220℃ 10分钟，翻面再8分钟。</li>
</ul>
<h3 id="u778E_u70E4_u9E21_u8089_u4E32"><a href="#u778E_u70E4_u9E21_u8089_u4E32" class="headerlink" title="瞎烤鸡肉串"></a>瞎烤鸡肉串</h3><ul>
<li>难度★★★★</li>
<li>切一切：鸡腿肉切块。蔬菜（青红辣椒、洋葱、大蒜之类的，随意）等腌好鸡腿肉再切块。</li>
<li>腌一腌：切好的鸡腿肉用蒜末、味极鲜、蜂蜜腌半天。</li>
<li>串一串：就是串竹签。</li>
<li>烤一烤：220℃正反面各6分钟，中间刷点番茄酱、辣椒酱什么的。</li>
</ul>
<h3 id="u5965_u5C14_u826F_u70E4_u91CC_u810A_u8089"><a href="#u5965_u5C14_u826F_u70E4_u91CC_u810A_u8089" class="headerlink" title="奥尔良烤里脊肉"></a>奥尔良烤里脊肉</h3><ul>
<li>难度★★★★</li>
<li>切一切：里脊肉切片。</li>
<li>腌一腌：网上买奥尔良腌肉料，按照说明腌三小时以上。</li>
<li>串一串：就是串竹签。</li>
<li>烤一烤：200℃正反面各8分钟。</li>
</ul>
<h3 id="u9500_u9B42_u626D_u8170_u867E"><a href="#u9500_u9B42_u626D_u8170_u867E" class="headerlink" title="销魂扭腰虾"></a>销魂扭腰虾</h3><ul>
<li>难度★★★</li>
<li>切一切：大虾从背部切开，取出虾线，</li>
<li>腌一腌：橄榄油+蒜末+小米辣+鸡精做成酱汁，一只虾塞一小勺。</li>
<li>烤一烤：烤盘铺锡纸，200℃ 10分钟。虾壳脆扑扑也能吃。</li>
<li>如果不想要扭腰效果就用竹签串起来烤。</li>
</ul>
<h3 id="u70E4_u4E32"><a href="#u70E4_u4E32" class="headerlink" title="烤串"></a>烤串</h3><ol>
<li>猪肩肉</li>
<li>腌料，一个柠檬，柠檬皮刨丝，柠檬汁挤出来，按照柠檬汁橄榄油1:3的比例加橄榄油，放入海盐、现磨黑椒、蒜头碎、花椒、小茴香籽、孜然籽、罗勒、百里香和王守义十三香粉，一点老抽上色用。手边香料不全的话不要太过于纠结，少几味就少几味吧。</li>
<li>肉切成块，然后用竹签在肉上面戳几个洞，取几个台湾小香肠，也戳几个洞，把肉和香肠放到腌料里面拌匀，腌制半个小时。没香肠也行，不影响肉的味道。</li>
<li>各种颜色甜椒去籽切片，洋葱去皮切块</li>
<li>串起来</li>
<li>放进预热的烤箱里面（最好用烤架），200摄氏度，烤30-40分钟，熟了就能吃</li>
</ol>
<h3 id="u70E4_u7F8A_u817F"><a href="#u70E4_u7F8A_u817F" class="headerlink" title="烤羊腿"></a>烤羊腿</h3><p>零基础能做出来的大菜。</p>
<ol>
<li>买一块羊腿，前腿、后腿做法一样，你看着买</li>
<li>在脂肪比较厚的地方随便切几刀，这是为了方便入味</li>
<li>然后弄点干腌料。想吃羊肉原味的只用盐和黑胡椒就够了（我还用了干迷迭香、孜然和辣椒粉，其它料你看着加）</li>
<li>把混好的腌料均匀的抹在羊腿表面</li>
<li>拿个容器装起来，用保鲜膜包住。放冰箱里一晚上入味</li>
</ol>
<p>第二天</p>
<ol>
<li>搞定洋葱和蒜，表面洗干净就好了，然后洋葱切大块，蒜掰成瓣，不需要去皮</li>
<li>把羊腿从冰箱拿出来，表面抹一层油。不要怕油多不健康，最后这些油都会流到下面去的</li>
<li>用锡纸把烤盘包严实了。因为是低温慢烤，如果不包严实最后会烤干掉</li>
<li>然后烤箱里160摄氏度烤四个小时</li>
<li>把垫底的料和油留在烤盘里，羊腿装盘就能上桌吃了</li>
</ol>
<p>Q&amp;A</p>
<blockquote>
<p>问：为什么蒜不用剥皮</p>
</blockquote>
<p>答：因为这个蒜是为了调味，不是为了吃的，烤四个小时候剥不剥皮都一样</p>
<blockquote>
<p>问：为什么要烤四个小时，能不能烤短一点</p>
</blockquote>
<p>答：如果肉比较小的话可以适当缩短时间，但是低温长时间是用烤箱把肉烤烂的必要过程</p>
<blockquote>
<p>问：烤盘底部烤焦的油很难洗的样子啊</p>
</blockquote>
<p>答：烤盘倒满水，泡一个晚上，第二天早上一抹就抹掉了。</p>
<h2 id="u5982_u4F55_u7528_u70E4_u7BB1_u70E4_u51FA_u597D_u5403_u7684_u9C7C_u7C7B_uFF08_u6D77_u9C9C_uFF09_u6599_u7406"><a href="#u5982_u4F55_u7528_u70E4_u7BB1_u70E4_u51FA_u597D_u5403_u7684_u9C7C_u7C7B_uFF08_u6D77_u9C9C_uFF09_u6599_u7406" class="headerlink" title="如何用烤箱烤出好吃的鱼类（海鲜）料理"></a>如何用烤箱烤出好吃的鱼类（海鲜）料理</h2><p>西餐中，鱼肉的处理使用烤箱是非常常见的，因为鱼肉相比其它肉类来说比较脆弱，易碎，比较难处理，鱼肉也比较适合低温处理，不会一下控制不好火候，烤过头，进烤箱的话，对于那些比较薄的鱼肉、全鱼或是鱼排来说都是非常好处理方法，干燥的烤箱也起到很好的浓缩鱼肉和调料香气的作用。</p>
<p>用烤箱烤鱼基本有以下几种方法：</p>
<h3 id="u9AD8_u6E29_u70D8_u70E4"><a href="#u9AD8_u6E29_u70D8_u70E4" class="headerlink" title="高温烘烤"></a>高温烘烤</h3><p><strong>1.烤箱‘油炸’法</strong></p>
<p>为了防止鱼变老，这里我们需要给”鱼“穿上一层”外衣“再进烤箱，最简单的方法，我们可以裹上：蛋黄酱、黑胡椒、柠檬汁、洋葱粉、再撒满面包屑和一些黄油或橄榄油，大概220度，烤制20分钟</p>
<p><strong>2.先煎再烤</strong></p>
<p>这个方法很像中国人做鱼的方法，先煎炸再炖煮，西方人是先煎炸再进烤箱，这样可以使鱼肉的表皮能有很好的酥脆度还有焦香，我们可以用铁平底锅煎制，煎制的时候将带皮的面朝下。</p>
<p>大概5-6分钟后，鱼皮开始出现焦香，之后将其放入烤箱，烤个6-7分钟，有了解西餐料理的朋友们，应该对此做法不陌生，这种先煎再烤的方法可以运用在各种肉类的烹调里，比如大名鼎鼎的 Beef Wellington。</p>
<p>从烤箱拿出来后，我们将另一面再稍微煎制十几秒钟，烤好之后可以撒一些 Parsley</p>
<h3 id="u4F4E_u6E29_u70D8_u70E4"><a href="#u4F4E_u6E29_u70D8_u70E4" class="headerlink" title="低温烘烤"></a>低温烘烤</h3><p>烤箱温度基本在100度-120度，烤出的鱼肉整体都非常嫩滑，这种方式基本是通过烤制过程中的水分蒸发对流将鱼肉”蒸熟“</p>
<h3 id="u5305_u88F9_u70D8_u70E4"><a href="#u5305_u88F9_u70D8_u70E4" class="headerlink" title="包裹烘烤"></a>包裹烘烤</h3><p>我们可以用油纸、锡纸、或酥皮，东南亚喜欢用芭蕉叶等味道不影响主食材味道的材料。这种方法主要是不让鱼肉直接受热、这种方法可以使鱼肉受热均匀，这种做法最大程度的保留了所有食材的味道。这种方法类似于低温烘烤。</p>
<h2 id="u897F_u9910_u5E38_u7528_u9999_u6599"><a href="#u897F_u9910_u5E38_u7528_u9999_u6599" class="headerlink" title="西餐常用香料"></a>西餐常用香料</h2><p>植物香料太多，世界各地的加起来估计能有个上百种吧，光罗勒就有很多不同的分类，香味和味道都不一样。还有地域性分别，比如柠檬草，在东南亚菜肴中很常见，别的地方就不多。再有一些植物可做观赏可入菜，比如薰衣草、茉莉花之类。</p>
<p>香料的使用没有硬性规定，通常的建议是味道和香气淡的香料配白肉和鱼，味道辛辣、香味重的配红肉，不同香料混搭很多，可以自己多尝试。当然不按着常规用法来用问题也不大，自己怎么喜欢就怎么来，吃的开心最重要。</p>
<p>说几种西餐常见的吧，按照字母顺序来：</p>
<blockquote>
<p>多香果（All Spice）</p>
</blockquote>
<p>运用广泛，从腌鱼、烧烤酱、德国香肠、印度咖喱等等都有用。我自己有时候拿来卤肉吃，不是常见用法，但是效果普遍不错，比传统的中式红卤更添一层味道。</p>
<blockquote>
<p>罗勒(Basil)</p>
</blockquote>
<p>罗勒大概是各种香草里面最常见的了，干罗勒基本和各种肉都百搭。新鲜罗勒经常用来点缀菜肴和增加香气，用法和香菜类似。我的各种烤肉里面用颇多的罗勒，新鲜罗勒在上次做洛林糕的时候也有用到</p>
<blockquote>
<p>香叶（Bay Leaf）</p>
</blockquote>
<p>这个东西中餐西餐都有用，西餐里面香叶一般是不摆上桌的，也就是说上桌前会从锅里拿走。主要是在汤类和各种肉类食物准备和烹调过程中增加香味的。</p>
<blockquote>
<p>小葱（Chives）</p>
</blockquote>
<p>这个东西中餐西餐都用的很多，不同种类味道略有差别，但基本都是葱。西餐主要用来沙拉上，也常用来和海鲜、鱼肉调味，和各种芝士搭配也多。</p>
<blockquote>
<p>肉桂(Cinnamon)</p>
</blockquote>
<p>也是中西通用，也分很多不同的种类，和香叶一样一般不摆上桌。适合红肉类的烹调。</p>
<blockquote>
<p>丁香（Clove)</p>
</blockquote>
<p>欧洲菜不太用，一般也不摆上桌，适合红肉类的烹调，和其它红肉类香料比如肉桂、八角什么搭配很好。</p>
<blockquote>
<p>香菜(Coriander)</p>
</blockquote>
<p>西餐里面常用这个，和什么肉都很搭。我一般用来拌凉菜吃，沙拉也可以用。</p>
<blockquote>
<p>莳萝（Dill）</p>
</blockquote>
<p>味道淡，一般放很多才有味道，适合配鱼和白肉。我用来用来腌三文鱼，泡橄榄油，炒鸡胸肉吃。下面这个我腌的gravlax里面用到了上面提到多香果。</p>
<blockquote>
<p>蒜（Garlic）</p>
</blockquote>
<p>蒜整个烤、切丁炒、做成蒜泥烤都行，和各种肉类都很搭，主要看自己的口味，之前做牛排的时候也抹蒜来着</p>
<blockquote>
<p>姜（Ginger）</p>
</blockquote>
<p>各种肉去腥什么的，就不多说了</p>
<blockquote>
<p>墨角兰（Majoram）</p>
</blockquote>
<p>一般用来给汤和酱料调味</p>
<blockquote>
<p>薄荷（Mint）</p>
</blockquote>
<p>薄荷清凉味，一般配饮料，如Mojito之类，或者甜点。做菜可以配一些味道淡的肉、鱼、蔬菜</p>
<blockquote>
<p>肉豆蔻（Nutmeg）</p>
</blockquote>
<p>一般配蔬菜，比如土豆什么的</p>
<blockquote>
<p>洋葱（Onion）</p>
</blockquote>
<p>洋葱种类很多，单独炒菜、烤肉、熬汤都行，是西餐的基本食材和基本配料之一。我一般用黄葱</p>
<blockquote>
<p>牛至（Oregano）</p>
</blockquote>
<p>香中带微苦，意大利菜尤多。我一般不单独用，都是和别的香料混着用。</p>
<blockquote>
<p>欧芹（Parsley）</p>
</blockquote>
<p>这个东西主要就是点缀用，本身味道太淡了。</p>
<blockquote>
<p>迷迭香（Rosemary)</p>
</blockquote>
<p>香味浓郁，略带苦味，配鸡肉和羊肉最佳。</p>
<blockquote>
<p>番红花（Saffron)</p>
</blockquote>
<p>最常见的是西班牙海鲜饭，主要为了染色，可以用姜黄粉代替，效果差点。番红花种植难收成少，特别贵，都是按克卖。</p>
<blockquote>
<p>鼠尾草（Sage）</p>
</blockquote>
<p>法国菜常见，微辣，适合配猪肉</p>
<blockquote>
<p>龙蒿（Tarragon）</p>
</blockquote>
<p>法国菜常见，清香微甜，适合白肉和鱼。</p>
<blockquote>
<p>百里香（Thyme）</p>
</blockquote>
<p>法国菜常见，香味浓郁，配鸡肉、猪肉都合适。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在美国学会的技能之一就是用烤箱做懒人食品，但烤箱也是有门道的，尤其是各种香料，这里收集了一些基本知识和技巧，分享给大家。</p>]]>
    
    </summary>
    
      <category term="烤箱" scheme="http://wdxtub.com/tags/%E7%83%A4%E7%AE%B1/"/>
    
      <category term="美食" scheme="http://wdxtub.com/tags/%E7%BE%8E%E9%A3%9F/"/>
    
      <category term="菜谱" scheme="http://wdxtub.com/tags/%E8%8F%9C%E8%B0%B1/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[租房手册]]></title>
    <link href="http://wdxtub.com/2016/03/26/rent-room-guide/"/>
    <id>http://wdxtub.com/2016/03/26/rent-room-guide/</id>
    <published>2016-03-26T18:46:57.000Z</published>
    <updated>2016-03-26T19:17:23.000Z</updated>
    <content type="html"><![CDATA[<p>对于不在家乡工作的人来说，找房子算是相当麻烦的事情，这里是我收集的一些资料，希望给大家一些参考。</p>
<a id="more"></a>
<hr>
<h2 id="u623F_u5B50_u7C7B_u578B"><a href="#u623F_u5B50_u7C7B_u578B" class="headerlink" title="房子类型"></a>房子类型</h2><ul>
<li>地下室<ul>
<li>每个小区都有地下室，并且大都出租，自己去小区转转就能找到，因为房东大都会在地下室前面立个牌子写上出租。价位不等，租客鱼龙混杂，洗刷间男女共用。如果不是十分的困难不建议住，尤其是女生。不同小区价位不等，环境也有很大差别，冬天住还可以，夏天就十分热。还要注意冬天的时候有的没有暖气。对于大多数初到北京的北漂，大都住过，我住过，那种感觉怎么说呢，如果一个人住会有很孤独压抑的感觉，后来租了一个有窗户的，略微有光，还好一点。</li>
</ul>
</li>
<li>平房<ul>
<li>我把一、二层的放到一起来写吧，同区的价位也就比地下室贵个一到两百（不同地区不同），但是好歹在地上，环境也稍微好一些。</li>
</ul>
</li>
<li>群租房、床位<ul>
<li>群租房就是很多人一起租，本质也属于合租房，但是由于跟合租差别还是很大，所以跟合租房分开说。群租房分两种，一种是打了很多隔断的，这种一般是小中介代理的。一种是做成宿舍那种的床位，人很多，一般也是中介代理。</li>
</ul>
</li>
<li>合租房<ul>
<li>指没有打过隔断或者只在客厅打过一间隔断的房子。这种房子还是比较推荐大家来住的，因为确实人少并且住着也舒服。并且价位也不贵，适合收入尚可的学生和白领。后面会着重介绍。</li>
</ul>
</li>
<li>普通住房<ul>
<li>开间就是客厅和卧室在一起，即一室0厅一厨一卫。标准一居室就是一室一厅一厨一卫。室指卧室，厅指客厅，厨指厨房，卫指卫生间。</li>
<li>四居五居比较少有（不包括隔断），一般是豪宅会有，比如说山水文园、观湖国际等。</li>
<li>三居室以上要注意有的三居室是两卫，即在主卧室多出一个卫生间，有的没有。</li>
</ul>
</li>
<li>商住两用住房<ul>
<li>一般公司需要注册的，又不需要在底商的，会要租这种房子。童鞋们一般不用考虑这类住房，或者应该避开一些商住两用的，为什么？同环境同户型价位比一般住房要贵一到两千，而且水电要比普通的住房要贵。但是这类的装修都还不错，比较有代表性的是林达海渔广场。</li>
<li>有需要办公而租住这类房子的要注意要问这房子之前是否被注册过，如果注册过的话可以先去销一下。</li>
</ul>
</li>
<li>写字楼，底商<ul>
<li>写字楼是办公、这大家都知道。底商就是指那些底层的一楼商铺。这类房子报价通常是说几块钱，比如说3块钱，这里指的是3块钱/平/天。</li>
</ul>
</li>
</ul>
<h2 id="u627E_u623F_u6B65_u9AA4"><a href="#u627E_u623F_u6B65_u9AA4" class="headerlink" title="找房步骤"></a>找房步骤</h2><h3 id="u5468_u671F"><a href="#u5468_u671F" class="headerlink" title="周期"></a>周期</h3><p>至少提前一周，看房两次到三次，每次至少两套。</p>
<p>理想状态是半个月吧，但是记住这时间只是个参考，如果立刻遇到自己满意的房子要马上交订金，尤其是在3-4月和6-8月，因为这是租房高峰期，尤其是好房子，大家都在抢（因为房东一般都是多家中介报盘，客户比较多）。有时候只要耽搁半天好房子马上就没了~在租房高峰尤其常见。</p>
<p>此外有一个叫做租房低峰，大概就是指年前一个月左右。租房是其实没有低峰的，年前一个月客户少一点是确实但是绝对不是淡出鸟那种，因为精明的人都会在那个时候出来先看看房。</p>
<p>不要以为在临近过年大家都在退房房子很好租还会降价，北京的房价不曾降过的亲~你要是不傻绝对不要在过年的时候退房，因为回来之后马上就是返京高峰，知道前后的房子价格差多少吗？年后的第一个月两到三居室房价一般都会小涨100~500多。</p>
<p>我知道大家都想租便宜的，租金低的，位置好的，朝向户型优越，家具家电全齐，性价比高的房子~~~别想了，那种房子一般不存在。</p>
<p>豪宅除外，一般同个区域同个小区相同户型同等装修的房子差价不会超过200块钱~大家都不是傻子，能租到跟自己要求符合百分之七十的就差不多了，百分之百的很难找到，除非你找房的周期很长。</p>
<p>有时你会听到某人现在租的房租很便宜的，但人家一般那是租住了好多年的房子，北京房价涨的很快，现在确实很变态。</p>
<p>外环的房子要比内环的便宜的很多，京南的房子要比京北的房子便宜。所以沿着地铁找还是比较合适的。</p>
<p>北京的房子中介费大都是客户出的，但是也有业主出的情况，让中介帮你争取，在中介带你看房子的时候，中介一般都会跟你说业主不出，所以在中介说出这话之前，你要透漏给他你不想出的意思，这样可以诱导中介回去跟业主提这件事。否则一般中介都不会提。</p>
<p>在网上看房，有时看好的打电话问却被说是房子没了。有两个原因，一是你看的是钓鱼贴，中介用来钓客户的。二是这房子确实是被租了，中介还没来得及下架。第一个原因多一点。</p>
<p>跟中介看房子，除非是年后一个月的那段时间，尽量第一次不要定，尤其不要交钱。</p>
<h3 id="u9009_u5B9A_u533A_u57DF"><a href="#u9009_u5B9A_u533A_u57DF" class="headerlink" title="选定区域"></a>选定区域</h3><p>选小区两种方法：</p>
<ol>
<li>找中介</li>
<li>自己百度地图</li>
</ol>
<p>百度地图的三种方法：</p>
<ol>
<li>找工作地点近的小区。</li>
<li>工作地点一两到两站公交左右范围内的小区。</li>
<li>如果工作地点距离地铁近的话，沿着地铁站找。当然如果在北京的话个人还是建议第三条，虽然路上费点时间，但是省钱。</li>
</ol>
<p>了解价位的方法：</p>
<ol>
<li>问中介，不想去店里面的话可以在网络上留言，比如58、赶集等。</li>
<li>在网络上查，在北京的推荐链家在线，很权威，不过有些地区你要在此基础上减一到两百，百分之七八十还是很靠谱的</li>
</ol>
<p>选择哪个网站查询：</p>
<p>链家在线的原因：虽然有点做广告的嫌疑，但是这个确实很牛逼，链家花大价钱请IBM做的。</p>
<p>链家在线的数据与其经纪人用的内网se系统是对接的，se系统则全是当前公司全部房源的内部报价。相比其他的网站。比如58或者赶集安居客更准确——因为经纪人只会把好的房子往那些网站发，而不会发差的房子。此外现在这个网站上有很多房评，也有一些借鉴价值。</p>
<p>除了豪宅（上万的月租前后可谈价位空间大都在一到两千浮动）外，房子前后差价不会多于200。并且上面的房源百分之90多都是真的——个别可能业主通过其他中介租出去了没有销。所以看房价还是很靠谱的，尤其是买房。</p>
<h3 id="u67E5_u8BE2_u623F_u6E90"><a href="#u67E5_u8BE2_u623F_u6E90" class="headerlink" title="查询房源"></a>查询房源</h3><ol>
<li>公司如果给提供是最好不过了，遇到这种公司你就嫁了吧</li>
<li>如果人脉够宽广，最好是找熟人介绍，这种一般还是比较靠谱的，还能免去中介费神马的，最方便，并且租金还便宜。</li>
<li>找中介。</li>
<li>网络上慢慢翻业主自己发的贴</li>
<li>街边小广告，这是一种找房的方法，就是比较费时间，并且有些也不靠谱。</li>
<li>有些小区的物业也会做做，但是大部分还是做卖的房子的，比如御景园，但是费用照样收的。</li>
</ol>
<p>网站上大部分都是中介发的房子，所以挑个顺眼的公司顺眼的经纪人就行。</p>
<p>有一些有区别的是大一些的中介公司比如链家、丽姿行等房源是内部共享的，新老经纪人的差距就是讲价的能力，房源优势是一样的。</p>
<p>而有一些小公司他们的经纪人会藏房源，建议找个老经纪人，但是如果你涉世未深，也更容易被忽悠，摆脱不掉。</p>
<p>网上发的房源超过半个月的就不要给他打电话了。</p>
<p>链家在线（链家独有的），58同城，赶集，安居客，搜房网这些是租赁经纪人常用的网络端口，房源多且新。</p>
<p>新浪、焦点网、搜狐，这些是买房的人必看的几个，租赁房源不如前几个。</p>
<blockquote>
<p>什么样的房子是好房子？</p>
</blockquote>
<ol>
<li>精装修，家具家电全齐</li>
<li>朝向：即主卧室窗户的朝向，南北通透或者东南向、西南向、南向</li>
<li>主要建筑类型按照舒适度和人的密度排名：<ul>
<li>板楼：简单说就是分单元的长条楼，人均密度比较低，一般是6层（例如十里河周庄家园），不带电梯。当然也有带电梯的高板（小高层，参考十里河山水文园）。板楼的南北通透户型比较多。</li>
<li>塔楼：人均密度比较高吧，其他的也都还可以。（参考御景园）</li>
<li>板塔结合：一般是出现在小区四个角上的楼型（例如十里河美景东方拐角的四个楼）。</li>
</ul>
</li>
<li>集中供暖</li>
<li>不把边：一般是相对于板楼来说的，就是不靠楼的最边上的意思，听说冬天会有一些问题，不过我觉得还好吧。</li>
<li>地铁房：其实我觉得步行在十分钟左右的房子都可以算。</li>
<li>不临街：在小区中间的房子，不吵。</li>
<li>人车分流：一般高档小区才会这样，一般租房不需要考虑这个。代表十里河的山水文园。</li>
<li>1000米内没有六类嫌恶设施（这个很重要）：飞机场（1000米）、加油站50米、高压电站（15米，这个说明一下，主要是要看看窗外是否有，孕妇要远离这样的房子，有辐射）、垃圾处理场（500米）、工厂（200米）、墓地/殡仪馆</li>
</ol>
<h3 id="u8054_u7CFB_u4E2D_u4ECB"><a href="#u8054_u7CFB_u4E2D_u4ECB" class="headerlink" title="联系中介"></a>联系中介</h3><p>首先给各个中介公司按照好感度排下号</p>
<p>链家地产（北京最大的中介公司）、丽姿行（专做高端豪宅的，普通住宅业务不涉及，有想租豪宅的可以去）、麦田房产、中原、21世纪（一般是加盟店，其实人员素质也是参差不齐，一般也不要找）、顺驰……我爱我家。</p>
<p>我爱我家还是比较没好感的，因为同事出现过被枪单还被威胁的，这仇真记一辈子啊made。</p>
<p>前三家还是不错的，虽然是竞争对手但是觉得麦田和丽姿行还是不错的。但是链家和丽姿行中介费不打折（只有小部分情况下会略有小折扣。），其他的中介公司折扣就比较大，做私单的也比较多，比如我爱我家。</p>
<p>关于跟中介打交道几个事项</p>
<ol>
<li>中介电话都是24小时开机，随便什么时间打都行。不建议在在网页上聊天，因为北京中介们大部分时间不会守着电脑的。建议电话联系。</li>
<li>尽可能完善的把你的需求告诉中介，北京的中介行业相对成熟，服务也还不错（当然收费也高），他会给你筛选，以促进成交。</li>
<li>一定要守时。经纪人倒是无所谓，其实关键是给房东留下好印象。大家都很忙，有些房东很在意时间问题。</li>
<li>如果选定了某个小区，一般看两~三次房再定。因为一般中介带你看房子，会给你准备三套房一套最差，一套最好，一套居中的房子，这是中介最常用的ABC法则，一般看完第一次房子中介就会逼定，就是逼你交订金，一定要挺住。</li>
</ol>
<p>原因：第一次中介带你看房，其实也是在试探你的需求，所以如果开始对房子有什么需求，一定要跟经纪人说（当然不要当着业主的面说，因为会伤到业主。）</p>
<p>你第一次没定之后，他会根据你的需求信息再一次的筛选更优质的房源，而且有时候好房的房主不一定有时间。</p>
<p>另外中介第一次带你去看的房子一般都是有钥匙的房子，房源不一定优质，而第二次或者第三次则是更精心选的。</p>
<h3 id="u770B_u623F"><a href="#u770B_u623F" class="headerlink" title="看房"></a>看房</h3><p>一般一次两三套就行了，具体参考前面好房子的特点，但是这几个特别注意：</p>
<ul>
<li>房主是否是本人。</li>
<li>嫌恶设施。</li>
<li>中介费谁出。</li>
<li>水电燃气取暖费和物业费谁来出。</li>
<li>家具家电是否齐全（床、空调、冰箱、洗衣机，缺什么跟房东说好了。）</li>
<li>卫生间。</li>
<li>朝向，房间的朝向指的是主卧的朝向。</li>
<li>如果是塔楼，问问是否是管道层。</li>
</ul>
<p>普及知识：其实一般的中介会在报价的时候藏价，但是也有一些是真的给你谈下来的。主导价格的因素主要有两个：经纪人能力和客户形象</p>
<p>在客户挑房子的时候其实业主也在挑客户。业主都是很爱惜自己的房子的。特别注意以下几点：</p>
<ul>
<li>进房之前要穿鞋套，中介会为您准备的。</li>
<li>如果业主在，热情的跟业主打声招呼，离开后问好，给业主留下好印象。</li>
<li>跟业主简单交流时注意把以下几点“透露给业主”：工作稳定，住的人少，爱干净，爱惜房子等</li>
<li>进门后如果业主在，不要说房子破旧不好，乱挑毛病来自己压价。不要跟业主起冲突。</li>
<li>有什么不满或者要求等出门以后再说，把自己理想的价位跟经纪人说让他去谈</li>
</ul>
<h3 id="u7F34_u7EB3_u610F_u5411_u91D1_u6216_u8005_u8BA2_u91D1"><a href="#u7F34_u7EB3_u610F_u5411_u91D1_u6216_u8005_u8BA2_u91D1" class="headerlink" title="缴纳意向金或者订金"></a>缴纳意向金或者订金</h3><p>想说一个叫做意向金的，其他公司不知道，在链家这个意向金还是挺好用的（其他公司不太清楚），尤其是在租房高峰时。意向金不是订金，没有法律效益，可以收回，中介拿这个意向金有四个作用：</p>
<ol>
<li>拿着这个钱去跟业主谈价（对，一般的房子是可以谈价格的，浮动大概在200~300左右。浮动的原因大概有两个：1因为中介会藏一些价格。2中介没有藏价而是后期跟业主谈判砍下来的。），意向金代表你的诚意，如果中介砍价成功那么中介就会将意向金交给业主变成订金，就拥有法律效益，业主违约归还订金加违约金，你违约会没收订金。</li>
<li>禁止同公司的人竞争，先交意向金或者订金的人可以先谈房子。</li>
<li>把控客户。</li>
<li>还有一个小小的擦边作用就是利用2中所说的禁止竞争占房子，在高峰期时自己还不确定是否租这个房子时候用。</li>
</ol>
<p>注：如果房子不满意不要随便交钱，还有这些个金其实也没有一定规定要交多少，通常中介会说一个月房租，但其实500—1000的都可以，当然如果对房子真的有意向那建议交齐。还有要对经纪人说非常重要的一点：我让你交你才交。但是小公司不要随便交钱，会扣压。</p>
<p>交意向金后会有一个单据，要收好。</p>
<h3 id="u7B7E_u7EA6"><a href="#u7B7E_u7EA6" class="headerlink" title="签约"></a>签约</h3><blockquote>
<p>三方到场</p>
</blockquote>
<p>（中介公司代理房除外，避免吃差价），签约时长大概需要2-4个小时，合同期限一般是一年。</p>
<p>所需材料</p>
<ul>
<li>客户需要带的材料：<ul>
<li>本人身份证原件，</li>
<li>钱（中介费、房租和订金）</li>
</ul>
</li>
<li>如果你是替朋友租房或者签合同，那么需要带上：<ul>
<li>你自己的身份证原件</li>
<li>你朋友的身份证原件或者复印件</li>
<li>你朋友手写的授权委托书（如果是打印的需要有签字和手印）</li>
</ul>
</li>
<li>业主需要的资料（客户最好仔细看一下）：<ul>
<li>业主身份证原件</li>
<li>房本，没有房本的需要购房合同</li>
</ul>
</li>
<li>如果签约人非房主本人：<ul>
<li>签约人身份证原件</li>
<li>房主的身份证原件或者复印件</li>
<li>房主手写或者打印的委托书，</li>
<li>房本,无房本的需要购房合同</li>
<li>如果房主为两个人，一位没有到场的话需要他的同意出租证明。</li>
</ul>
</li>
</ul>
<p><strong>起租期：</strong>这个要注意，就是开始计算房租的日期，一般是签约的第二天。但是呢，如果你房子还没到期，可以协商把起租期定的晚一点。你就说给个搬家的时间，房东一般都会同意。一般可以争取到三天到一个周（所以周天看房，最好周一二晚上签合同，拿钥匙做物业交割然后白住一个周，哈哈），按照北京的房价，可以省下好几百。</p>
<blockquote>
<p>付款方式</p>
</blockquote>
<p>押金+支付的月租金。押金和租金全部交给业主，押金在房子到期后返还。</p>
<p>一般分为：押一付一（即押一个月租金付一个月的租金），押一付三（也就是季付），押一付六（半年付），年付。当然个别情况还有押金交两个月的。</p>
<p>大多数情况都是季付，当然付款方式越好，越有利于中介砍价，押两个月的租金和半年付、年付都属于比较好的付款方式，这样一般的业主也都乐于把价格再低个100—200。</p>
<blockquote>
<p>一般中介费标准</p>
</blockquote>
<p>一般是一个月房租，不同公司会有不同，具体询问。</p>
<blockquote>
<p>押金问题</p>
</blockquote>
<p>代理房押金是交给中介的，如果不是代理房那么押金是交给业主的，注意区分，给业主的一般都会退，交给中介的不一定。可能会克扣。</p>
<blockquote>
<p>续租缴费</p>
</blockquote>
<p>中介的代理房，看情况。跟业主签约的房子不需要再给中介缴纳中介费，中介费一次性付清。</p>
<blockquote>
<p>发票问题</p>
</blockquote>
<p>好多人提到发票问题，说不给开，倒不是想要偷税漏税或者很难开什么的，在这里给大家略为科普一下：</p>
<p>租房用到的发票有两个：服务费发票和房租发票。</p>
<p>服务费发票：即中介费发票，中介可以给你开服务费发票，时间一般是半个月到一个月的时间。</p>
<p>房租发票：中介不给提供。原因是无权提供。在北京在租房需要到当地街道办事处登记，是需要缴5%的税，所以大部分业主不想登记。</p>
<p>现在一般是客户拿着公司的证明文件（这个应该还分个人租房和企业用房，具体的文件问经纪人）自己到当地街道办事处开取，自己付税费。</p>
<p>负责的经纪人会代你去开取。所以这些问题都应该提前说明白，否则有些经纪人在收了钱后根本不鸟你，因为开这个发票也要一些时间。</p>
<blockquote>
<p>优先购买权</p>
</blockquote>
<p>你住的房子如果要卖，现租客享有优先购买权。</p>
<blockquote>
<p>物业交割</p>
</blockquote>
<p>仔细仔细再仔细</p>
<ol>
<li>检查各种电器，看看是否能用，不能用的要换。</li>
<li>要把水电燃气的表数抄在合同上。</li>
<li>墙体，水管等地方。</li>
<li>业主的家具以及贵重物品等级，要细化到牌子型号。 </li>
</ol>
<h2 id="u6311_u9009_u81EA_u4F4F_u623F_u768416_u5927_u5173_u952E_u8BCD"><a href="#u6311_u9009_u81EA_u4F4F_u623F_u768416_u5927_u5173_u952E_u8BCD" class="headerlink" title="挑选自住房的16大关键词"></a>挑选自住房的16大关键词</h2><blockquote>
<p>地段</p>
</blockquote>
<p>这个已经在『只谈房事』第一期用整个专栏的时间说过了，对于地段的选择，无论是自住型还是投资型，都是同样重要的。</p>
<blockquote>
<p>小环境</p>
</blockquote>
<p>就是指小区周边和小区内的环境，有点楼盘地段很好，但是小环境不敢恭维，一定要注意周边是否有高压电线，工厂，发电站等污染源，另外周边紧靠城中村的楼盘也要打折扣。</p>
<blockquote>
<p>容积率</p>
</blockquote>
<p>如果你去售楼处看盘的时候，很随口地问一句，这楼盘的容积率是多少，实用率是多少，售楼小姐肯定不敢忽悠你，因为一听就知道你是个行家。其实这个概念很简单，容积率是建筑总面积与建筑用地面积的比。容积率是越小越好，根据经验，豪宅的容积率通常都会在1.5以下。</p>
<blockquote>
<p>实用率</p>
</blockquote>
<p>上面说到这也是个专有名词，意思就是你实际的使用面积和建筑面积之比，通常不带电梯的多层的实用率会高达92%以上，带电梯的小高层在85%以上，超过15层的高层在80%以上都属于正常。有些楼盘的实用率会低的离谱，例如“信和自由广场”的房子的实用率只有70%多点，实在让人想不通面积都分摊到哪里去了。因为买房是根据建筑面积来算价的，所以买这样的房子是很不划算的。买商铺的更要注意这个，有的商铺的实用率能高达100%，“海印长城”下面的商铺，实用率才只有40%。所以买房算价格不仅仅是看单价那么简单，里面的猫腻还是很多的。</p>
<blockquote>
<p>建筑质量</p>
</blockquote>
<p>这个需要在楼盘在建的阶段就去工地实地考察，而且具有一定的专业性才能看出来。如果楼盘已经封顶了，或者买二手楼，如何判断呢？很久很久以前有个叫半球的房事达人，对每个楼盘都会亲自考察，并写一篇详细的调查报告，不过半球先生早已蜕变成职业写软文的托了。浑浑的水还有一个绝招，在每个新楼盘在销售的时候，都会在知名房产网站（如搜房网，房地产信息网）建立一个业主联系论坛，去翻一下论坛的历史内容，就能对楼盘的缺点有个最直观的了解。你能想象“学林雅院”居然没有打地基吗？你能想象“名家富居”居然没有设计排烟管吗？我也不能想象，但是我能从业主论坛了解这些信息。</p>
<blockquote>
<p>噪音</p>
</blockquote>
<p>这是浑浑的水特别重视的一个因素，这可能严重影响到睡眠的质量。不要听经纪说这个房子装了真空隔音玻璃，关上窗就特别安静这样的鬼话，不开窗的房子是没法住的。要特别注意，靠近高速路，立交桥的楼盘，是无论如何都不会安静的，即使你买的是背靠噪音源的方向也不行，不信可以去问问住“滨海之窗”，或者“创世纪滨海花园”的业主。</p>
<blockquote>
<p>楼层</p>
</blockquote>
<p>一楼通常会很潮湿，因为出入方便，安全性也差一点，有架空层的会好一些。一般楼层越高，采光和通风越好，如果旁边是马路的话，因为声波衍射的关系噪音高层的反而会比低层的要大一些。对于有电梯的高层来说，楼层越高，价格越贵，对于无电梯的多层只要记得“金三银四”就可以了。</p>
<blockquote>
<p>朝向</p>
</blockquote>
<p>这也是浑浑的水很在意的一个因素。在深圳，最好的朝向是南北通，卧室和客厅都朝南。其次依次是朝正南，东南，西南，东西通，朝东，朝西，东北，西北，正北。朝南还是朝北，对于居住的感受差异非常大。朝北的房子夏天会暴晒，冬天一点都晒不到太阳，夏天没有风，冬天的北风那个吹啊。西晒的房子一般都比较热，会让你花更多的空调费。</p>
<blockquote>
<p>通风</p>
</blockquote>
<p>通风跟设计有关，通风必须要对流，只有单面朝向开窗的房子是不可能通风的。有一些的楼盘对通风的设计很有问题，完全不通风，这样的房子对健康很不好，要慎重考虑。</p>
<blockquote>
<p>采光</p>
</blockquote>
<p>假如生活缺少了阳光，你自己衡量吧，浑浑的水觉得比较重要。</p>
<blockquote>
<p>住宅性质</p>
</blockquote>
<p>住宅性质分住宅和商住楼，房产证上面就有写。通常，商住楼里是可以作为注册地开公司的，而住宅不允许，所以一般商住楼里都有几家是开公司的，例如“青春家园”里有美容院，“金钟大厦”有家政公司等等，而“海王大厦”里基本很少住家了，大部分都是开公司的。住在这样的楼盘，来来往往的人员会很杂，所以要综合考虑。如何辨别住宅性质，最直接的是看房产证，或者还有个简单的办法，通常裙楼是商铺的住宅，性质都是商住楼。还有一个问题要特别注意，就是商住楼商铺的营业性质，如果是餐饮业的话是最糟糕的，小心可能会被油烟污染，最好能避开。</p>
<blockquote>
<p>学位</p>
</blockquote>
<p>浑浑的水特别提出学位的重要性，每个房子都有划分的小学和中学，如果划分的学校好，那么是一定会有溢价的，这个很容易理解，家长对子女的教育，都是愿意花费血本的！。例如深圳的老片区“园岭小区”，从1栋到75栋的是划分到园岭小学第一分部，75栋以上划分到第二分部，仅因为第一分部的房子就会比第二分部的房子每平方贵1000元以上。</p>
<blockquote>
<p>批地时间</p>
</blockquote>
<p>也就是地皮被批准可以建房子的时间，这个影响到房子的使用年限。目前住宅的使用年限都是70年，从批地时间开始计算。有些楼盘虽然是新楼盘，但是批地很早，使用年限是要打折扣的，例如“半岛城邦”的批地时间是1996年，入伙是2007年，这里就少了11年的使用年限。不过这个因素也不用太在意，根据新的物权法，对于这个年限到期后怎么办，根据浑浑的水的理解，只要该地皮不另作其他用途，则会自动续期，业主需要补交土地使用费，就可以继续拥有房产。</p>
<blockquote>
<p>户型</p>
</blockquote>
<p>户型的要点就是两个字“方正”。浑浑的水有个朋友精通风水，他跟我说过一句话，如果不找人看风水的话，那么就记住选择户型方正的房子，房子只要是方方正正的，风水问题都不会很大。另外就是要看浪费的空间多不多，有些房子的走廊啊，拐角都会占用过多的面积。</p>
<blockquote>
<p>开发商和建筑商</p>
</blockquote>
<p>如果在了解上面的因素后还有精力，可以再去查一下楼盘的开发商和建筑商的资历，和过往开发过的楼盘的业主论坛。像招商地产，华侨城地产这样的开发商的楼盘，通常都是有质量保证的。</p>
<blockquote>
<p>价格</p>
</blockquote>
<p>没错，浑浑的水故意把价格放在最后来讲。这里先讲一个故事，去年某天浑浑的水跟朋友聊一款车，这款车带天窗的要加2万块，他很喜欢天窗，但是觉得这个价格太不划算了，后来知道他还是买了带天窗的版本，问他为什么，他说了一句很经典的话，“我后来想通了，如果买带天窗的，我最多只心疼这2万块，如果买了不带天窗的，我会心疼整台车的价钱。”对自住房最大的感触就是，对于自己很在乎的因素，一定不要太在意价格，最关键的还是看你和这个房子的缘分。而且因为贷款的关系，其实首付价格的差别并没有你想象的大。</p>
<h2 id="u4E2D_u4ECB_u9632_u5751"><a href="#u4E2D_u4ECB_u9632_u5751" class="headerlink" title="中介防坑"></a>中介防坑</h2><p>话入正题，今天我们来聊一下和房地产中介打交道的实战技巧。其实浑浑的水并不是像你们想象的那样对中介恨之入骨，只是跟他们浑久了，对中介的黑比一般人有更深一层的了解而已。事实上，浑浑的水有一些朋友不巧就是在地产中介上班的，黑只是他们工作必须的态度而已，而并非都是他们的本性。说白了，房客和中介的关系，不过是相互利用的关系而已，尔虞我诈是不可避免的。在国内由于相关的规范和法律很不健全，所以中介基本上全部是没有诚信的。这个跟劣币驱逐良币的原理一样，当大部分地产公司都足够黑的时候，不够黑的地产公司是一定会最先倒闭的。</p>
<p>当中介带你看房的时候，会让你签一份看楼书，假如将来你买下了这套房而没通过这个中介的时候，麻烦就来了，你将会受到最恶毒的骚扰，还会威胁跟你打官司，直到你受不了给他们一些钱为止，这绝不是浑浑的水在恐吓你，这种事情非常多见。可能的话，我会尽量不一个人去，而带一个不真正参与交易的朋友或家人去签这份看楼书，就算自己签，也会用个假的名字和电话号码。这样的好处是，你可以委托多家中介帮你谈价格，假如你能直接跟业主达成协议，完全可以随便找一家中介帮你办手续，通常给2，3千块手续费就够了，否则就要支付高达房价3%的佣金，当然，这样做也要考验你做人的道德标准，浑浑的水认为对待本来就不讲道德的地产公司，根本不需要有道德的顾虑。</p>
<p>当你表示对一套房子感兴趣的时候，中介通常会用各种手段让你交一笔定金，说明谈到什么价格之后就必须签约，如果到时你想不买，定金是不退的，即使这单谈不拢，有些黑地产公司也一样不肯乖乖退款，他们会让你继续看其他的房子，直到成交为止。特别注意的是，这个价格不单单只约定单价的价格，还必须约定各种手续费，中介费，赎楼费，税费等由哪一方支付，中介通常会故意不告诉你这些，然后用最不利于你的价格来判断这个约定是否成立。浑浑的水在签约之前，是从来不交任何费用的，因为即使你不交，中介为了促成这单，也一样会去跟卖家谈价格，如果交了定金，只会让你更被动，如果中介实在不配合，完全可以换一家地产公司继续谈。记住，在交钱之前，你还是爷们，一旦交了第一笔定金，你就变成孙子了。在交钱之前，一定一定要考虑的非常清楚，真正抢手的笋盘不是那么容易碰到的，不要担心今天不签明天就被别人签了，中介通常会虚构其他的买家来促使你尽快交定金，当然这招我在卖房的时候也经常用，而且通常都很管用。</p>
<p>在和中介交谈的时候，对他说的话一定不要太相信，一切都以眼见为实。例如看房的时候说一套房子有100平方，而看到房产证的时候通常就只有90多平方，只要相差不太多，很多买家也就认了。还有很多例如是他亲戚的房子啊，独家代理啊之类的话，绝对是假话。除了假话，中介对迫使你签约都是很有一套的，所以跟中介交往一定要脸皮够厚，不好意思的人往往就直接签约交钱了，这种买家还是不少的，如果你实在脸皮很薄，强烈建议你带一个买衣服砍价很厉害的朋友来帮忙。</p>
<p>签合同之后，定金是必须支付给卖家的，假如中介代收的话，也一定要开具定金收据给你。而首付款，你一定要委托银行做资金托管，不要怕麻烦交给地产公司，这里有很大的风险，中天置业事件和创辉事件就是实例。大的地产公司通常会正规一些，而很多小地产公司会千方百计的让你把首付款打入他公司的账户甚至是个人的账户中，遇到这种公司要学会拒绝。签合同的时候一定要买方，卖方和中介三方同时在场，如果卖家跟中介交易进行了委托公证的话，一定要核实清楚委托人是否跟房产证的业主是同一人，否则你很可能被骗或者被吃差价了。</p>
<p>最后谈一个关于打印房地产交易合同的事情。为了保证交易合同的合法性，市政府管理部门拟定了一份标准的合同，这份合同可以在任何一家地产公司打印，也可以在房地产交易中心打印，是免费的。但是后来房协管理之后，取消了在房地产交易中心的打印，这样就必须要在地产公司打印合同。这样地产公司之间就建立了一条潜规则，打印合同必须交纳高达上千元的打印费，前段时间在深圳台第一现场也报道了这个黑幕。浑浑的水教你一招，遇到这种情况，不要轻易交费，直接跟中介声明要打电话到房协投诉，投诉电话是83785630，83785851，这招通常都能搞定。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于不在家乡工作的人来说，找房子算是相当麻烦的事情，这里是我收集的一些资料，希望给大家一些参考。</p>]]>
    
    </summary>
    
      <category term="找房" scheme="http://wdxtub.com/tags/%E6%89%BE%E6%88%BF/"/>
    
      <category term="租房" scheme="http://wdxtub.com/tags/%E7%A7%9F%E6%88%BF/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[买车养车开车指南]]></title>
    <link href="http://wdxtub.com/2016/03/26/car-guide/"/>
    <id>http://wdxtub.com/2016/03/26/car-guide/</id>
    <published>2016-03-26T18:46:43.000Z</published>
    <updated>2016-03-26T19:00:06.000Z</updated>
    <content type="html"><![CDATA[<p>估计以后工作了，在所难免需要买车，这里是平时收集的一些经验技巧。最重要的，安全第一。</p>
<a id="more"></a>
<hr>
<h2 id="u9009_u8F66"><a href="#u9009_u8F66" class="headerlink" title="选车"></a>选车</h2><h3 id="u4E00_u3001_u9884_u7B97_u8303_u56F4"><a href="#u4E00_u3001_u9884_u7B97_u8303_u56F4" class="headerlink" title="一、预算范围"></a>一、预算范围</h3><p>划分选车范围最简单也是最直接的条件就是钱。一般的预算分为两种，一种叫做落地预算，一种叫做裸车预算。</p>
<p>落地预算你可以理解为这一辆车从购买到能够正式上路行驶所需要的总共花费的预算，包括了买车之后所需要交纳的各种税费保险等费用：</p>
<p>裸车预算你可以理解为单独对车辆的售价所做的预算，不包括买车之后所需要交纳的各种税费保险等费用。</p>
<p>相信大部分人的购车预算都是前者，但是用这个预算来选车则很容易出现实际预算超标的情况，因为 20 万预算实际上是不够买下一辆 18 万出头的车的，在天朝各种税费再加上保险成本还是非常高的。因此我建议大家都把自己的购车预算折合为裸车预算，同时提供一个经验化的、粗略的换算公式：</p>
<pre><code>裸车预算 ≈ 购车预算 * 0.85
</code></pre><p>实际上如果完全最佳按流程来，真实的裸预算车会比这个数值高一些，但是考虑到有些 4s 还有绑定条款如必须在店内买一年保险等，再考虑到很多车主会去选择做一些全车坐垫脚垫、贴膜这样汽车装潢，适当的留下一点机动空间是有必要的。</p>
<p>这么一来，我们候选车辆范围就从和太平洋一样大的一千多个车系缩减成了一般不超过 300 款了——不过还是有北冰洋那么大。</p>
<h3 id="u4E8C_u3001_u8F66_u578B_u9009_u62E9"><a href="#u4E8C_u3001_u8F66_u578B_u9009_u62E9" class="headerlink" title="二、车型选择"></a>二、车型选择</h3><p>这里的车型指的是：三厢轿车（包括掀背车）/ 两厢轿车 / SUV / MPV / 旅行车 / 跑车 /（后面还有皮卡货车啊客车专业车辆啊之类的等等等等）。对于大部分的普通消费者而言，都是在前面的 5 种车型 （三厢轿车 / 两厢轿车 / SUV / MPV / 旅行车）中进行选择，后面的由于比较小众同时购车群体一般目的性比较明确，就不作为重点来描述了。</p>
<p>那么我们的这一步的任务就是，在这 4-5 种车中选出一种（至多两种——由衷希望你没看见这个括号里面的内容）车型作为自己的目标。那么下面就按照一个一个问题的顺序，来做车型的排除法。</p>
<h4 id="u7B2C_u4E00_u4E2A_u95EE_u9898_uFF1A_u8FD9_u8F66_u6B63_u5E38_u60C5_u51B5_u4E0B_u6700_u591A_u8981_u5750_u51E0_u4E2A_u4EBA_uFF1F"><a href="#u7B2C_u4E00_u4E2A_u95EE_u9898_uFF1A_u8FD9_u8F66_u6B63_u5E38_u60C5_u51B5_u4E0B_u6700_u591A_u8981_u5750_u51E0_u4E2A_u4EBA_uFF1F" class="headerlink" title="第一个问题：这车正常情况下最多要坐几个人？"></a>第一个问题：这车正常情况下最多要坐几个人？</h4><p>如果不会超过 4 人的话 MPV 就可以划掉了，如果正常情况下需要带上的人数达到了 6-7 人，那么你只需要保留下来 MPV 和 SUV 这两种车型，当然，我是把杰德这样的“另类”直接当做 MPV 来看的，只不过这是只能坐 6 个人的 MPV。（至于超过 7 人的情况，本人对所有 C<br>照不能驾驶的车都无法提供任何有用的选车帮助）。</p>
<p>在此我只强调一点： 假如你的车长时间需要乘坐 5 个人（如夫妻父母加上一个孩子），并且这五个人块头都不小的话，那么我建议你多考虑一下六座七座车型，因为目前大部分的 A/B 级轿车在后排坐三个人的时候，长时间的乘坐体验都是非常差的 。</p>
<h4 id="u7B2C_u4E8C_u4E2A_u95EE_u9898_uFF1A_u4F60_u9700_u8981_u8D70_u4EC0_u4E48_u6837_u7684_u8DEF_uFF1F"><a href="#u7B2C_u4E8C_u4E2A_u95EE_u9898_uFF1A_u4F60_u9700_u8981_u8D70_u4EC0_u4E48_u6837_u7684_u8DEF_uFF1F" class="headerlink" title="第二个问题：你需要走什么样的路？"></a>第二个问题：你需要走什么样的路？</h4><p>也就是你对于通过性的需要。为了方便分类先定义了一个通过等级。以下的定义无法做到准确分类，但是具有宏观上的参考价值。</p>
<ul>
<li>零级通过性 ：纯正跑车；</li>
<li>一级通过性 ：普通的轿车（两厢三厢和轿跑均包括在内）；</li>
<li>二级通过性 ：城市 SUV；</li>
<li>三级通过性 ：越野 SUV（也可以理解为“真正的越野车”）。</li>
</ul>
<p>同理，我也对不同的道路路况等级进行了一个定义（路况等级具有向上兼容的特性，即高等级的路况包含了低等级路况的全部内容）：</p>
<ul>
<li>零级路况 ：高速公路，较好的城市道路；</li>
<li>一级路况 ：高速公路，所有的城市道路，大部分的乡村道路，部分有道路的山路，部分工地道路；</li>
<li>二级路况 ：高速公路，所有的城市道路，所有的乡村道路，大部分有道路的山路，大部分的工地道路，极少量没有道路的复杂路况；</li>
<li>三级路况 ：高速公路，所有的城市道路，所有的乡村道路，所有的有道路的山路，有的工地道路，较多的没有道路的复杂路况。</li>
</ul>
<p>基本上而言，几级的通过性就代表了能应付的几级路况，并且通过性高的车辆都向上兼容各种低级路况。比如一般而言通过性为零级的各种法拉利兰博基尼是根本无法到二级路况中的山路去撒欢的，但是你开个牧马人在跑跑高速则是一点儿问题也没有。</p>
<p>那么是不是通过性越高的车型就一定越好呢？——当然不是！如果那样的话，我还是推荐大家都去买 jeep 牧马人——因为一般而言越高的通过性往往意味着相同类似的空间、动力级别下更差的操控性、更贵的价格、更高的油耗（当然价格和油耗这两条对零级的超跑到一级的轿车的过渡时不成立，物极必反嘛！）。做个比喻，类似空间和动力系统（强调一下：仅仅是宏观上的类似）的高尔夫 GTI 和途观 2.0T，前者属于典型的一级通过性，后者则属于典型的二级通过性。GTI的动力能力、操控水平远远超过途观 2.0T，而途观 2.0T 则更贵、油耗更高。</p>
<p>因此我给大家的建议是： 尽量根据自己所面对的道路等级去挑选对应级别通过性的车型，假如因为自己的喜好的原因希望扩大范围，那么也请务必将误差幅度控制在一级之内。</p>
<p>此外，原则上不建议所选择的车辆通过性等级低于自己的所需求的等级——除非是预算真的有限 。</p>
<p>举个例子，如果你就是城市道路通勤偶尔自驾，我建议你去购买轿车，可是如果你真的很喜欢坐得高高的感觉，那么选个城市 SUV 也可以，但是你如果你非得去买什么帕杰罗、普拉多之类的——我真的觉得有必要拉住你。反过来，如果你是一个越野爱好者，我觉得买一辆 A4L 绝对不是一个正确的选择——哪怕销售一再和你鼓吹这是一辆四驱的 A4L。</p>
<h4 id="u7B2C_u4E09_u4E2A_u95EE_u9898_uFF1A_u8FD9_u8F66_u4F60_u662F_u5F00_u6765_u505A_u4EC0_u4E48_u7684_uFF1F"><a href="#u7B2C_u4E09_u4E2A_u95EE_u9898_uFF1A_u8FD9_u8F66_u4F60_u662F_u5F00_u6765_u505A_u4EC0_u4E48_u7684_uFF1F" class="headerlink" title="第三个问题：这车你是开来做什么的？"></a>第三个问题：这车你是开来做什么的？</h4><p>这一点很好理解。如果你是做生意的或者是一家三四口家用的，那么三厢轿车绝对是你两厢轿车来得实用。可是如果你是小年轻一个人自己用的，那么两厢车的灵活和时尚则成为了加分项。喜欢旅游？SUV 和旅行车呀！</p>
<p>总之， 每一种车型的存在都是有其设计的出发点的，尽量让其的特色有用。不要让你的旅行车的超大后备箱始终只是一个孤零零的摆设，或者是让你的两厢车后备箱装不下的行李长期只能放在后排乘客的腿上。当作商务使用的时候我也真的不觉得一辆A3 DS5 之类的车会比一辆老老实实的帕萨特雅阁好——哪怕其实你对后备箱实际上是没什么需求的。</p>
<p>好的，三个问题结束，相信大家都已经有了自己的答案了。当然，可能有的同学就要问了：我这三个问题的答案有些是冲突的怎么办？比如我需要坐六七个人需要一辆七座的MPV 或者是 SUV，可又是做生意的，按说可能三厢车更合适，咋办？</p>
<p>请注意：以上三个问题是有排序的，当前后的问题答案出现冲突之时，以前面问题的答案为准。因为这三个问题的刚需程度是依次下降的。</p>
<p>希望此事已经确定了一种（至多两种——好吧，再次由衷希望你没看见这个括号里面的内容）车型作为自己的目标。那么再把这个也填写到你的选车条件里面去吧。</p>
<p>说明：在很多选车工具中，轿车的分类是微型车(A00 级，代表如 Smart)、小型车 (A0 级，代表如 POLO)、紧凑型车 (A 级，代表如速腾)、中型车 (B 级，代表如帕萨特)、中大型车 (C 级，代表如奥迪 A6L)、豪华车（D 级，代表如宝马 7 系），选车目标是两厢轿车 / 三厢轿车 / 旅行车可以按照你自己预算和空间要求选择 1-2 个作为大小范围。两厢车和三厢车是在【结构】一栏中进行选择的。不建议通过”座位数“进行选车，因为大部分的网站数据都有一些问题。</p>
<p>我们的选车范围总算从三位数降低到了两位数，一般情况下这里还剩下不到 50 款的候选车型，再也不像是大洋一样大了——不过依然多得让人没欲望一个一个看。</p>
<h3 id="u4E09_u3001_u52A8_u529B_u9009_u62E9"><a href="#u4E09_u3001_u52A8_u529B_u9009_u62E9" class="headerlink" title="三、动力选择"></a>三、动力选择</h3><p>其实想单纯的从账面的动力系统去看一个车的动力都是非常难的。因为每款发动机的标示参数不一样，每个厂商标示的真实性不一样，不同发动机动力输出区间不一样，匹配的变速箱型号不一样，相同型号不同车型变速箱的调教不一样。因此如果我们想从一个非常科学研究的角度来研究这个问题，会显得非常力不从心。但是如果我们跳开这些微观上的细节，本着正态分布 2σ的偏差来看，也就是 95.4%的可靠度来看——一般而言，一款车的排量大小基本上可以反映出来这辆车的性能水平。</p>
<p>我定义三种人：</p>
<pre><code>第①类：对动力基本没啥需求的，够用就行；
第②类：在够用的基础上希望动力别太肉，可以偶尔撒撒欢，想超车时无压力；
第③类：对动力要求较高，希望可以跑赢大部分的车，动力储备充足甚至过剩
</code></pre><p>对于这些人所需要的排量，按照 6 类进行分类讨论，以下①代表第①类人，以此类推，自吸代表自然吸气，增压代表涡轮 / 机械增压.</p>
<p>A 级车：</p>
<p>①自吸≤1.8L，增压≤1.6T；②自吸 1.6-2.0，增压 1.4T-1.8T；③自吸≥1.8，增压≥1.6T</p>
<p>B 级车 / 大部分家用 MPV/ 旅行车：</p>
<p>①自吸≤2.0L，增压≤1.8T；②自吸 2.0-2.4，增压 1.6T-2.0T；③自吸≥2.4，增压≥2.0T</p>
<p>C 级车及以上 / 大型 MPV：</p>
<p>①自吸≤3.0L，增压≤2.0T；②自吸 2.5-3.7，增压 2.0T-3.0T；③自吸≥3.5，增压≥3.0T</p>
<p>紧凑型 / 小型城市 SUV：</p>
<p>①自吸≤2.0L，增压≤1.8T；②自吸 1.8-2.5，增压 1.4T-2.0T；③自吸≥2.4，增压≥2.0T</p>
<p>中型城市 SUV：</p>
<p>①自吸≤2.4L，增压≤2.0T；②自吸 2.4-3.7，增压 2.0T-3.0T；③自吸≥3.0，增压≥2.5T</p>
<p>中型以上 SUV 级越野 SUV：</p>
<p>①自吸≤3.0L，增压≤2.5T；②自吸 3.0-4.0，增压 2.0T-3.0T；③自吸≥3.5，增压≥3.0T</p>
<p>以上的动力配置基本上都是比较靠谱，且范围算是比较大的，避免了大部分的误杀情况。当然，因为一些妖孽一样的发动机的存在（如上面提到的雷克萨斯 CT200 的那台 1.8L，还有反过来的例子如全新一代沃尔沃 XC90T6 上的那台 320 马力的 2.0T 以及高尔夫 R400 上面的那台 400 马力的 2.0T），所以在不远的未来难免会有一些极端情况的出现。不过对于大部分的位于中间部分的普通消费者而言，这些变化对于他们的影响并不大。</p>
<p>一般而言更强的动力系统也意味着更高的价格和更大的油耗（注：混合动力、油电混合算是价格上的例外，不过换来的一般都是更低油耗；除此之外小马拉大车和更高科技的发动机也可能导致动力更高的实际油耗更低，不过一般还会带来更贵的价格）。并且绝大部分驾驶员都不太可能完全发挥一辆车的动力潜能——也就是俗话说的没有肉车只有肉人。因此除非不差钱，否则我不建议动力配置过剩，适合自己的才最重要 。</p>
<h3 id="u56DB_u3001_u4E2A_u4EBA_u559C_u597D_u9009_u62E9"><a href="#u56DB_u3001_u4E2A_u4EBA_u559C_u597D_u9009_u62E9" class="headerlink" title="四、个人喜好选择"></a>四、个人喜好选择</h3><p>这里，大家总算是可以开始轻松愉快地完全按照自己的对于汽车喜好进行一些筛选了。在很多人的选车过程中往往都把这个放到了第一步第二步，而我则放到了第四步——没错，我的选车范围的划分顺序也是按照需求的重要性来排列的，当一个人还不够足够地了解车的时候（如果一个人可以已经“足够地了解车”，无论是真懂是假懂，他应该都不会再需要什么“购车推荐”了吧？），我个人认为其的很多“个人喜好”的优先级的重要性应该是低于价格、实用性的，甚至应该是低于动力配置的选择的。</p>
<p>在这个环节，大家所需要做的就是开始完善选车工具中的各个选项。比如手动还是自动，汽油还是混动亦或是干脆电动（补充说明一下，本人暂时不建议大家购家用型柴油车），国产品牌、合资品牌还是进口车，当然还可以选择一下哪个国家哪个品牌的车要哪个国家哪个品牌的车不要（嗯，派系粉们在这里总算可以把自己所痛恶的东西干掉了）。</p>
<p>此外在可以选择配置的地方，大家也可以把自己非常在意的一些配置选上去，如有些人无天窗不买，有些人没倒车雷达不考虑，有些人没有定速巡航不考虑，诸如此类的。我仅仅给大家提出一个建议： 在预算超过 10 万元的情况下，请记得选上 ESP 。在此顺带强烈鄙视一些无良厂家在 ESP 这样的基础安全配置上面偷工减料。</p>
<p>这里强调一点，请务必确定被自己拉黑的选项是自己绝对不考虑的，否则建议大家还是尽量少的在这一步做过多的选择，因为这里不是在列优先级、列权重，而是在做一票否决权，请慎用你的否决权，尤其是对某个车系的拉黑——虽然我依然会尊重你的选择，但是毕竟这样是很狭隘的！</p>
<p>没错，在这个什么都要看脸（和身材）的社会，车和对象一样，虽然实用性很重要，但是长得自己满意（起码不恶心）也是非常重要的。大家得辛苦一下，把所有候选车辆逐一打开，看看它的前脸，腰线，车位，中控。然后把自己 完全不能接受的 默默从名单中划掉。温柔的阿姨们总算可以把各种蒙迪欧阿特兹 CC 去掉了，年轻小伙也总算可以把各种君越天籁凯美瑞给去掉了。据说外形和内饰丑哭了一片人的斯巴鲁和长得个性得没朋友的欧宝雷诺在这一环节被大量评委直接淘汰——反正这一环节你的审美（或者说是眼缘）是唯一的标准。</p>
<p>如果在上面一个环节时你比较“博爱”剩余的车型比较多，那么我建议你在“看脸”这个环节的时候稍微严格一点儿，好好得做一些删减。而如果你在上一个环节已经把目标锁定到了三五辆车，那么我觉得你还是别苛求太多了，毕竟选着选着选没了可不好。</p>
<h2 id="u4E70_u8F66"><a href="#u4E70_u8F66" class="headerlink" title="买车"></a>买车</h2><p>如果车子只是随意挑选或是临时被销售人员说服但还想退、改的，写订金；</p>
<ul>
<li>如果车子是自己很喜欢确定了的型号或确定了的颜色非要不可的，写定金。</li>
<li>车辆是期货，一定写双方都能达成的交付时间并留有余地，这一点和销售人员协商并确认。</li>
<li>车辆有现货，交付期写今天或者自定的黄道吉日皆可；无论如何，一定要写。</li>
<li>逛车行，经常都能在经销店看到某某经典版，某某科技版等在厂家型录之外的型号，从杀价角度，不要参考这些加装的车型，要看厂家指导价。</li>
<li>如果你不在北上广，那北上广的价格对你基本没有参考作用，就算你在北上广，你在网上看到的北上广的价格对你也还是没有参考作用。</li>
<li>询价最好、最简单的办法，同城同品牌不同店询价，店不多的话，那就找同价位但更便宜一些的竞品车型做幌子。议价是情报战和心理战，娴熟的销售顾问能够了解到竞争店的库存和优惠，所以扯幌子尺度大了，比如要价过高，人家很可能认为你没真实购买意向没诚意；不了解库存，你说的车型只有他店有的话，他就吃定你了。</li>
<li>议价一定要快，不能被销售人员认为是意向级别不高的，要不人家电话都懒得给你打，得自己觉着这几天就下单了，言语间那种焦急和迫切的心态，一两天内几家内反复询价，坐在一家经销店给另一家店里销售打电话的紧迫感，一般的销售顾问都受不了就把底价报出去了。</li>
<li>车型选择上，一般的车款最低配都是拉低售价区间，配置惨不忍睹，最高配都是起营销作用，配置华而不实，中配的才是实在款。让利最多的型号很多时候不一定是最高配，而是库存压力最大的配置，什么型号库存压力最大？销售人员会主动推荐的，通常这也是卖得最好的配置（厂家压货），库存压力大的车型，通常比其他型号再便宜一些经销店都愿意（红蓝绿黄冷门颜色招手ing）。</li>
<li>前装车一般都是在车辆运输过程中局部部件损坏，按道理说这种车就不是新车了，而是事故车了，应该要返厂的，但是这其中的运输费用就摊在了4S店上，为了避免这种损失，聪明的领导们发明了「前装车」，用一些局部零件的更换来遮掩以前的损伤，通常前装车都是补过漆的，如果你购买的话相当于新车的价格买了个二手车。</li>
<li>每次你走进4S店销售顾问，都会热情地向你介绍车型，他们一般都优先介绍高配车，因为高配车的利润高，从而销售人员的提成也高，所以对于他们说自己的原装导航/真皮座椅/BOSE音箱/多功能方向盘等全部屏蔽之，你要看的是车不是附属电子，原车上面的配置所多出来的钱，你用一半就可以在汽配城买到，低配车永远是最高性价比，然后怎么砍价，很简单，去看车，然后试驾，满意了直接问销售顾问价格，此时他会让你留电话，你一定要装出一副不情愿的样子说「我觉得XX（竞争对手）也挺好的」然后给他留个电话，第二天他绝逼会给你打电话回访，你就说你现在正往XX（竞争对手）公司去准备去试驾，好的话就买了。</li>
<li>接下来的两个小时你会接到他无数个电话，压了给发个短信，直接报一个他们想都不敢想的低价，比如「二十万的车你说十六万能拿我就考虑去你们那里」，然后他们会给你报一个价格，但是现在价格还没有到底，去他们店里，然后找销售总监，就说这个价格可以，但是你还得送我一个全车镀膜／底盘装甲／原装脚垫什么的，他肯定会表现得特别为难，说「我们底盘装甲闹下来要三千多，全车镀膜六千多，原车脚垫两千多……」什么什么的，他说的这个价格除以十就是市场上的价格，他答应你一个就说明价格还有这么大的余地，话锋一转说算了，这个东西我不要了，你再给我便宜（他说那个配置的价格除以十）元吧，嗯……你成功地把销售总监闹潮了，他现在会表现得超级不耐烦，然后现在这个价格就是全市最低价了……想买车砍价还是蛮费工夫的，祝你们幸福。</li>
</ul>
<h2 id="u517B_u8F66"><a href="#u517B_u8F66" class="headerlink" title="养车"></a>养车</h2><ol>
<li>车子和人一样是要保养的，请根据说明书的指示定期或定里程进行保养和检查。4S当然可以保养保修，但是出保后如果能找到一家信得过的汽修厂更好，省钱也放心。</li>
<li>给轮胎打气的时候，别忘了车里还有个备胎，要定期检查备胎气压是否在正常范围内。</li>
<li>轮胎的厂家推荐气压一般都标在油箱盖或驾驶侧车门上，满载与空载情况下需要打的气都是不一样的。走高速胎压宜高不宜低，因为偏低的胎压反而会增加高速爆胎的危险，胎压稍微高一些还可以省些油。爆胎这件事可大可小，或许车子不至于失控，但是我相信你也不想在大热天搬动十多公斤的备胎吧？</li>
<li>机械式胎压表误差在0.1左右，实际使用的时候影响并不大。标准胎压是厂家经过测试后平衡了性能及经济性的一个参数，适当高一点的确偏离了这个平衡。但轮胎在高胎压状况下，温度和压力上升都比低胎压时要慢。新手可能疏于检查胎压，适当的高我认为会更稳妥一些。现在轿车轮胎都是低压胎，不是货车使用的高压胎。低压胎大部分情况是因为缺气而胎壁变形被碾坏，而很难因为胎压过高而炸开。每条轮胎都会在胎壁上标示出允许的最高压力，一般轿车轮胎是常温态3.0左右。只要胎压不远超这个数值，是不会因为压力过大爆开的。</li>
<li>轮胎尽量换好些的，不管是夏利、吉利还是宾利，汽车动力再大也得通过四个脚才能发挥出来，用好些的轮胎能减少安全隐患。平时勤检测，磨损到警戒线就该买新的了</li>
<li>汽油标号按照说明书的指示就好，加高标号的汽油对发动机没有坏处，而且油耗会稍微低一点点，省油不省钱。</li>
<li>更高辛烷值的汽油不代表油品更好，国内有些油站的97号汽油是通过添加剂来帮助达到标准的，油品甚至没有正规油站的93号汽油好。</li>
<li>按照压缩比选择燃油是以往化油器车的经验，如今的发动机都是电喷的，会根据燃烧状况进行相应调节，只要燃油标号不低于推荐值就不会出问题。</li>
<li>加油尽量去大公司的直营油站，不要去小油站或者大公司的挂靠民营油站。如果当地有外资的加油站也比较放心。</li>
<li>机油大致分三种：矿物油、半合成和全合成。4S店保养通常用的矿物油或者半合成油，同等使用状况下用全合成或半合成机油可以延长机油寿命，可以通过机油试纸来判断机油衰减情况。</li>
</ol>
<p>另外：</p>
<ol>
<li>会换轮胎。我以前的状态是在有起落架的情况下30秒一只轮胎，一般来说后备厢应该常备一个千斤顶和套筒，在需要的时候能独立拆卸和安装轮胎，免得出现有设备没本事搞的尴尬状态，好比我表哥上礼拜轮胎没气还开了好远，最后车胎爆了，然后一个电话害我老爸开了50多公里去帮他换轮胎（感觉好弱！），另外实习生刚进去最先开始做的就是给轮胎打气，按照我小半个月的经验来说，轮胎气打到轮胎硬，踢上去能有轻微凹痕为宜，太满的话开高速容易爆胎！</li>
<li>知道机油汽油制动油和防冻液的使用。没事机油尺拉出来瞧瞧，看看油线的位置和油的颜色，随时补充机油，如果颜色实在太黑记得去维修点更换机油，油箱尽量不要出现空油状态，制动油的颜色和刻度线位置要熟知，如果缺少太多记得及时补充，防冻液不仅起着防冻作用，也起着防止爆沸的作用，因此平时要保持水箱中防冻液和水的补充，别到了大冬天才想着加，大热天也是很需要的，如果你只用水的话100摄氏度就开始沸腾了！你的车开在路上会冒烟的哈哈哈！</li>
<li>刹车和油门的问题。可能有人会觉得我小题大做，我前东家是上海一家著名的上牌点（以按排量分别收取服务费用而出名），最让我无力吐槽的是当时有个老板带着司机来上牌，是辆百万的雷克萨斯，上完牌后老板很开心，要求自己开车回去，然后出了咱们店门，左转，加速，撞墙，四个气囊全部弹出来……好吧，你牛B你有钱，NO ZUO NO DIE的最好体现……然后老生常谈一句：开车时右脚平时放在刹车上，要加速再轰油门，轰完油门请高抬贵脚放回刹车上，谢谢！！另外如果刹车和油门感觉有黏滞的话请马上前去维修，制动系的问题都是大问题，一定要重视！</li>
<li>如果想要学习的话，最简单的就是跑4S店的维修区域找那些维修师傅去唠唠，切记不要跑到维修接待（汽车售后维护顾问）那里去，说真的这些维修接待除非有维修经验，否则基本都是些没学历没水平的。不是我个人吐槽或者鄙视啥，在4S店里除了老师傅，新进的维修工基本都有大专或本科学历且为相关专业有相关证书，这些都是硬指标；而负责维修接待的那些人反而只有中专职校级别，这工作不需要特定证书和技能，只要你会忽悠！比如打方向盘有异响是明显的转向轴问题，他们的报修单上竟然会写：左转右转方向盘会发出嘎吱嘎吱的声音，我们这些搞维修的除了orz真是无力了……但是不得不说，他们装得会比较专业，所以有问题找维修师傅问会比较靠谱，而你问维修接待多半会让先让你进保，这是本质上的区别。这里我插两句，你可以试试问这些维修接待：1.车辆保养要做的轮胎动平衡，具体是为了什么目的才做的，怎么做？指标是什么？2.刚才楼上说的所谓的燃油添加剂，添加燃油添加剂主要目的是什么？润滑？去积碳？那么积碳主要的成因是什么？为什么现在的车辆会有积碳？难道仅仅是因为油品不好？</li>
</ol>
<p>首先，对于车辆的日常保养请务必用心</p>
<ol>
<li>每两周校准车胎压，高端车型记得给胎压做初始化。这要求你记得胎压值，或者能识别左前门上的胎压值标签。胎压不准确的后果，直观地说有两个：其一，容易使车辆跑偏。一腿长，一腿短，这个应该比较容易理解。其二，会吃胎。胎压过高吃中间，胎压过低吃两边。再往大了说，操控性、油耗、胎噪都会影响到。</li>
<li>定期打开车辆的前盖，看看里面有没有小喵、小汪、小吱（老鼠）的脚印。猫猫狗狗最多在里面取暖，小吱可就没有那么客气啦，它们会咬线哦！会嘘嘘哦！会在里面修房子哦！运气好的话，你还能看见它们的宝宝哦！如果有脚印了怎么办？请先反思一下你的停车位，是不是在老鼠王国——地下停车场？还是在垃圾桶的旁边？你从来没有打开过发动机的下护板，所以你不知道里面会有煎鸡蛋水果核编织袋鼠便便……</li>
<li>如果是高端车，建议使用燃油添加剂。它是发动机的保养品，就像女孩子的面霜一样，不一定能让你返老还童，至少让你衰老得慢一点。国内的油品质检我不做评价，我是见过很多加完汽油后发动机故障灯亮的汽车。那什么，您都打算买了，就还是买4S店里的吧，有点贵，但是你的发动机会更喜欢一点。加油站的……我没用过，不做推荐。</li>
<li>洗车时请注意保护你的雷达、摄像头：它们有点娇弱，不耐高压水枪的折磨。还有你的软顶敞篷也是哟～</li>
<li>你再洗车时，要记得清洁雨刮片和前挡玻璃。玻璃上团状的水痕主要是油渍引起的，汽车尾气里的油液、路边烧烤摊的油液都会附着在玻璃上，所以清洁玻璃不光是去砂石，还有去油渍哦！</li>
</ol>
<p>在雨刮条和玻璃之间，会藏着很多细小的沙石。如果你不清理掉它们，它们就一直躲在那里，你一动雨刮，玻璃和雨刮都会受到磨损。还有雨刮是橡胶制品，不耐晒，老化以后刮动会有声音，会抖动，所以请给它防晒！宝马给出的建议是每六个月更换一次雨刮片，仅供参考啦！雨刮片是安全件，它们还是很重要的啦！</p>
<p>雨刮水壶的位置一般位于叶子板的位置，所以它的盖盖也比较边缘化，统一的标识是一个蓝色的盖子，就像这样（手机传不上图片，请原谅T_T，大家打开前盖自己找找吧）保养它的时候，请你：</p>
<ol>
<li>使用专用的雨刮水。不要用洗衣粉、洗洁精……</li>
<li>定期加水。有些质量不过关的雨刮水在缺水情况下会变成果冻，然后它们会堵在管道和喷头处，然后就堵上了，堵、上、了……</li>
<li>加水请加干净的水。理由同上，避免堵塞。</li>
<li>请阅读车辆的使用说明，知道雨刮液位低的报警标志。（我一定不会告诉你，有客人给我打电话说是花盆里面冒出烟花的那个灯……）</li>
<li>没有水的时候强迫雨刮喷水，驱动马达会烧掉的！</li>
</ol>
<p>然后我们来说说冷却液（先说重点的）</p>
<ol>
<li>发动机的整个冷却系统都是带压的！！！我们可以把它理解为：热车状态下的冷却液，就像是被狠狠摇过的可乐——一旦被打开就会成喷射状往外冒（请脑补……脑补不来请实验）。而且它的温度很高哟，看看你的水温表，它指几度水就几度。</li>
<li>冷却液是有颜色的，或者红色，或者蓝色。如果有天你看见车子下面有水，先分辨它是油还是水，如果是水，看看它有没有颜色。没颜色的是空调水，有颜色的是冷却液。确定是冷却液泄露以后，直接叫拖车，不要启动发动机！因为你是新手司机，你能做的只有求助场外观众。</li>
<li>如果冷却液没有明显泄露，只是有一点点减少（你目测它少了），可能只是冷却系统压力比较大，把它压瘦了一点，释放掉压力后液位会回升。</li>
<li>冷却液的液位一般在Min和Max之间就可以了，不要像处女座那样较真╮(╯▽╰)╭</li>
<li>如果非要添加冷却液，请只！加！一！种！在4S店里买一瓶，备用就可以了，不要红的蓝的绿的看着是冷却液通通往里加。</li>
<li>如果你决定加水，请加纯！净！水！不要认真地说：我特地给它加了农夫山泉……发动机不缺钙铁锌硒维生素，它要的是液体良好的循环性，且不容易产生水垢，所以各大品牌矿泉水可以留着您自己喝哈~</li>
</ol>
<h2 id="u5F00_u8F66"><a href="#u5F00_u8F66" class="headerlink" title="开车"></a>开车</h2><ol>
<li>汽车能开多快，它对人造成的伤害就能有多大。无论如何人的血肉之躯是无法与具有钢铁车身的汽车抗衡的。ABS、ESP等只能辅助你避险，而汽车往哪里开、开多快最终是由驾驶者决定的。所以需要永远把安全放在第一位，时刻注意安全，自己不要去撞其他的人和车，也尽量避免其他车或人撞到自己。商业保险当然也是必需的，特别是强制的第三者责任险，最好能买50万以上额度的，国内一线城市请尽量买一百万以上的。</li>
<li>车子是一件工业产品，所以使用它之前，请认真阅读它的使用说明书。不仅要了解车子有什么功能，还要把这些功能发挥到极致，这才是一个好的使用者。况且你为这些功能付了钱却不用也是一种浪费。</li>
<li>不要把东西放在阻碍视线的地方，例如前挡风玻璃下面或者后尾厢的搁板上面。汽车工程师为了改善驾驶者的视野下了很大的工夫，不要让他们的心血因为车内花花绿绿的挂饰而白费。而且视线被遮挡会造成行车安全问题，这是最致命的，也是你最不希望看到的。</li>
<li>车子的行驶证是需要随车携带的，所以最好在车上找个隐蔽的地方把它藏起来，保险等车辆相关证件也是如此。但驾驶证是身份证件，需要随身携带，不要放在车上。</li>
<li>在车子的储物格里面放一些现金、手电筒、创可贴和胶带等备用物品，以备不时之需。</li>
<li>「对于借车这种事情需要慎重考虑，因为发生重大交通事故的话车主要承担连带责任，所以车子轻易不外借，要借也得给那些你愿意为他们承担责任的人。」简单来说，从《侵权责任法》颁布以来，就没有机动车所有人承担连带责任这一说了。</li>
<li>认得路上的常见车型，这样你就可以在发生交通事故的时候准确地向警察描述车辆特征，比如「一辆银色奥德赛与一辆浅蓝色马自达5在滨河大道西行方向赤尾人行天桥附近发生擦碰逃逸」。另外一个办法就是使用手机拍照或者在车内安装行车记录仪，这些措施都有助于事故的处理，同时还能防碰瓷。</li>
<li>一定会为新车的第一道划痕、第一次擦碰而懊恼。但车只是个工具，人身安全才是最重要的。小划痕不要太着急处理，注意一年内的出保次数，尽量不要超过三次，以免因此影响下年的保费。</li>
</ol>
<h3 id="u9A7E_u9A76_u7BC7"><a href="#u9A7E_u9A76_u7BC7" class="headerlink" title="驾驶篇"></a>驾驶篇</h3><ol>
<li>上车前，注意观察车子的外观和车轮状况，留意车周围有没有小孩或者宠物狗在玩耍，车轮气压是否在正常范围内。</li>
<li>开车前调整好座椅位置和后视镜的位置。一脚把刹车和离合器踩到底时膝盖还能适当弯曲的坐姿是比较合理的，方向盘应调至双手手腕能自然落在其顶端的位置。</li>
<li>挂P挡或从P挡挂到其他挡位的顿挫感是因为变速箱的P挡卡锁的锁紧或释放，挂到D挡的顿挫可能是因为冷车时的转速差异，N挡转D挡的顿挫也有可能是变速箱的匹配没有做得很好。</li>
<li>挂挡时从P挡挂到D挡，快速通过R挡时是不会执行换挡动作的。因为现在的变速箱都是电子信号控制的，短时间通过R挡并不会触发换挡动作。</li>
<li>高跟鞋不是用来开车的，女性驾驶员可以在车上备一双平底鞋。</li>
<li>让车上的每一个人都系上安全带，包括第二排和第三排的乘客，12岁以下的儿童乘车要正确使用安全座椅。安全气囊、车身结构和吸能区在乘客没有系好安全带的时候都是没有用的。</li>
<li>方向打死之后要记得回一点，长期打死方向会导致液压助力转向系统处于最大输出功率，容易减少助力转向系统寿命。电动助力转向系统不存在这个问题。</li>
<li>车子启动以后要经常注意刹车是否正常，车辆满载时要比平时提早刹车。</li>
<li>有机会的时候试试大力刹车，体验一下ABS顶脚的感觉。知道自己的车子在极限情况下的动态表现，大力刹车是每一个驾驶者都需要懂的技巧。当然大力刹车的时候要通过后视镜注意后车动态，最好在急刹车的同时开启双闪灯提醒后车注意，以免被追尾，如果后面跟着大货车还是别急刹了，保证安全的情况下赶紧换个车道保命要紧。</li>
<li>驾驶的过程中经常注意看左中右三块后视镜，变线的时候更要多注意后视镜。</li>
<li>变线前记得打转向灯，提醒他人自己要变线了。</li>
<li>变道时要通过第二块侧窗观察自己的侧后方，看看盲区里有没有车辆。自己行车时也尽量避免在其他车的盲区范围内长时间行驶。</li>
<li>变线的时候尽量比别人快，让后车踩刹车的变线不是安全的变线，如果变线条件不足应该放弃变线。</li>
<li>从匝道转入主道时一定要注意主道的车子，必要时减速让行。并入主线时一定要尽快加速到车流均速，成功并线的标准就是不让主道的车子刹车减速。我觉得欧洲一部分国家的做法很好：每次主道的车辆路过匝道时都会变线到快车道，给右边车辆充足的空间并入主道。</li>
<li>每一次上路其实是一次占用道路资源的行为，在不超速的情况下请尽量把车开快些，这样交通会畅顺很多。不要在城市快速道上慢行，路上最危险的不是绝对速度，而是相对速度。车流速度80，自己只开40也是一种非常危险的情况。</li>
<li>学会防御性驾驶，眼光放远一些，预判路上可能会出现的各种突发情况，同时心中要及时想到合理、有效的对应方案。</li>
<li>在路上尽量远离大货车与大客车，尾随大货车的话有可能会被货斗内掉落的石头砸坏挡风玻璃，大货车后轮卷起的碎石也能把前挡风玻璃刮花。被大车尾随也是很危险的，国内的大车安全标准不够高，超载严重，紧急刹车的时候距离要比小车多不少，容易引起追尾。</li>
<li>行车的时候不要与其他车辆并排，这样会使得你的注意力分散到两侧，忽视前方的状况，也会阻碍后面的车辆超车，没有公德。</li>
<li>车灯不光能照亮道路，也能让别人看到你的车子，所以天色灰暗，看不清其他车辆的时候就应该打开前车灯了。深色车辆尤其要注意。</li>
<li>市区夜晚会车时不要开远光灯，前面有车的时候也不要开远光灯，变线提前打灯。雨雾天能见度差的时候打开前后雾灯，紧急情况下开双闪灯。夜晚超车时，如果前车没有注意到你偏离了车道，可以适当闪动远/近光灯并鸣喇叭。</li>
<li>如果有人在你正后方闪动远光灯的话那应该是你开得太慢了，有条件的话可以变道让行；有人在你侧后方闪动远光灯的话那就是要超车了，这个时候要保持行车路线，不要变线。</li>
<li>通过任何路口的时候，脚永远要放在刹车上而不是油门上，毕竟你不知道路口会冲出来什么，非机动车和不守规矩的车辆随时都有可能出现。</li>
<li>等红灯的时候如果时间较短建议踩住刹车踏板，如果时间较长的话可以挂空挡拉手刹，自己可以放松一下右脚，后面的司机也不会被明亮的刹车灯晃到眼睛。</li>
<li>绿灯起步排在第一位的时候，如果周围视野良好，没有行人冲出来的话，请不要吝啬那一点汽油，果断大脚油门起步，这样一个信号周期可以多过几辆车，后面的人会感激你的。但如果车子两边都是大巴或者视线不好的话那起步就要小心，因为你不知道大巴车头会不会突然出现一个闯红灯的冒失鬼。</li>
<li>作为司机要照顾好车上的每一位乘客，告诉不熟悉车内设备的他们哪些开关是干什么用的，行车时要锁住全车车门，有儿童的时候记得锁上儿童锁。下车的时候，乘客必须听从司机指挥，不要自行打开车门，司机要通过后视镜确认后方安全后才能让乘客下车。</li>
<li>开在小路上也要留意路边停着的汽车，它们随时都有可能打开车门，所以有条件的话尽量和它们保持一定距离。如果避让不开则尽快减速。另外注意它们的车头，面对突然冲出来的行人或者自行车要有心理准备。</li>
<li>下雨天为了确保安全，可以打开后视镜电加热开关蒸干后视镜上的小水珠。下小雨的情况下如果侧窗玻璃有些模糊，可以通过升降玻璃这个动作来刮掉玻璃上的积水。</li>
<li>雨天开高速要遵守雨天建议限速，避免急刹车与急打方向。上次我在深汕高速亲眼看到一辆还没上牌的凯美瑞在暴雨中因为急打方向失控撞护栏。在市区压过路边积水的时候尽量慢点开，避免溅到路人。若看见前方有深的水坑尽量绕开。涉水时最好换到手动换挡模式，保持油门使得水不会通过排气管倒灌进去。如果发动机进水熄火则不应再次尝试启动，否则发动机需要拆开大修，这个修复费用可就贵了。</li>
<li>不幸在路上抛锚的时候，一定要在车子后方足够远的地方立起警示牌。所有人应尽快离开车辆，在公路护栏后相对安全的地方等候道路救援服务。</li>
<li>对路况不熟悉的时候不要随意掉头、变道或者倒车，很多事故发生就是因为司机不认路的时候鲁莽处理，后车躲避不及撞上。去陌生的地方事先查看地图，在路上使用导航，力求做到心中有数。错过路口时千万不要紧急停车，应该直接往前走，在前面路口掉头或者下了出口重新上反方向的高速。</li>
</ol>
<h3 id="u505C_u8F66_u7BC7"><a href="#u505C_u8F66_u7BC7" class="headerlink" title="停车篇"></a>停车篇</h3><ol>
<li>停车前可以把后视镜往下翻15度，方便观察地面标线及路沿。现在很多车也自带这个功能，非常实用。</li>
<li>停好车注意观察一下车子有没有停正，有没有占用多个车位，有没有给旁边的车子留下开车门的空间。不注意这些容易被别人刮碰，给别人方便也是给自己方便。</li>
<li>如果可能的话在车辆左边留多一些空间，副驾驶一般没有司机细心，猛一下开门容易碰到旁车。</li>
<li>车驶入地下室请开启近光灯，不要因为地下室灯光够亮就偷懒，开灯是为了让别人注意你。倒车的时候要把音响关掉，车窗打开，不然音乐会分散注意力，甚至让你错过倒车雷达的警示声音。</li>
<li>倒车时可以利用刹车灯和前后灯光进行距离估算，有的时候比倒车雷达还好用。</li>
<li>MPV和旅行车的尾厢门开启角度非常大，尾厢门会升得很高，在地下室打开尾厢的时候要防止尾厢门碰撞到地下室的通风管道。</li>
<li>下车的时候，记得确认所有门窗都关闭了，尤其是天窗，不然下起雨来就惨了；同时还要确认所有电器、灯光是否关闭，否则电池会很快没电，就会打不着火。停车时车内不要放显眼的财物。</li>
</ol>
<p>写了这么多，概括起来就是开车给人方便，别人就会给己方便。处处为人着想就会少很多不必要的麻烦。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>估计以后工作了，在所难免需要买车，这里是平时收集的一些经验技巧。最重要的，安全第一。</p>]]>
    
    </summary>
    
      <category term="安全" scheme="http://wdxtub.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="车" scheme="http://wdxtub.com/tags/%E8%BD%A6/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[北美二手车购买指南]]></title>
    <link href="http://wdxtub.com/2016/03/26/na-second-hand-car/"/>
    <id>http://wdxtub.com/2016/03/26/na-second-hand-car/</id>
    <published>2016-03-26T18:46:27.000Z</published>
    <updated>2016-03-26T18:52:15.000Z</updated>
    <content type="html"><![CDATA[<p>这里是之前收集的一些在美国买二手车的注意事项和相关技巧，分享给大家。</p>
<a id="more"></a>
<hr>
<h2 id="u6982_u8981"><a href="#u6982_u8981" class="headerlink" title="概要"></a>概要</h2><h3 id="u7B80_u5199_u540D_u8BCD_u6CE8_u91CA"><a href="#u7B80_u5199_u540D_u8BCD_u6CE8_u91CA" class="headerlink" title="简写名词注释"></a>简写名词注释</h3><ol>
<li>Kbb，指著名的二手车估计网站 www.kbb.com 。其中给出了具体年份里程车的参考价格。</li>
<li>Craigslist，简称 CL，著名的二手物品交易网站，美国的 58 同城。</li>
<li>Sedan，SUV，coupe 等等都是指车的类型，或者车的结构是怎么样的。比如 coupe 是特指两门或者三门的 跑车/运动型轿车  类型。具体细分，还有 full size，medium size，compact sedan。</li>
<li>MPG，miles per gallon，借代指车子的经济性价比，即省不省 gas。</li>
<li>Make/model，make 是指车的生产厂商，比如 本田/丰田/宝马/奔驰/奥迪/…，model 是指具体车的型号，比如 野马/3 series/A6/CTS 等等。结合起来，就是 Audi A6，Ford 等等。</li>
<li>DFBB，指北美四大神车，分别 Toyota Camry，Toyota Corolla，Honda Civic，Honda Accord，排名不分先后。在2000 年左右在北美华人论坛上很火，一直到现在。这四种车以保值性高，可靠性强，誉为神车。</li>
<li>Vin，是每辆车独有的号码，独一无二，相当于车的身份证号码。查车的历史就是通过 Vin 来查的，只有两个公司提供的报告可靠，一是 Carfax，另一个是 Autocheck。</li>
<li>DMV，即美国的车管所。车辆注册买卖，驾照什么的都在这里办。</li>
<li>Title，即车子的归属权。一般有 clean/clear title，salvage title，duplicate title 等等。其中，salvage title 是属于出过重大事故，车子被total了，即维修的估算超过了车的价值。出过事故的车也可能有 clean/clear title。有一种 title 是属于没有还清贷款的 title，忘了叫啥。总之，买车只买 clean/clear title 的车，尤其当你是车盲的时候。</li>
<li>Registration，指车辆的注册，在车牌会有一个小贴纸，写明了过期的年份月份，比如 08/15。如果过期需要去 DMV renew，过期不算犯法，但上路会被警察 pull over。如果你要买的车的 registration 过期了，去 renew 就可以了，不要紧的。</li>
<li>Smog check/emission test，指年检，没通过就不能  renew registration。各州法律不同，一般十年以上车龄的车需要做。在加州，如果卖家没有做好 smog check 就卖车，是违法的。</li>
</ol>
<h3 id="u4E70_u4E8C_u624B_u8F66_u7684_u539F_u5219"><a href="#u4E70_u4E8C_u624B_u8F66_u7684_u539F_u5219" class="headerlink" title="买二手车的原则"></a>买二手车的原则</h3><ol>
<li>车子必须CleanTitle。CleanTitle 说明不仅车子不是报废车，还说明车子的所有产权都是title上面的主人。没有欠银行贷款。</li>
<li>车子可以容忍大修的历史，撞过的历史，或者租过的历史。当然没有最好。</li>
<li>一手交钱一手交title，title需要车主的signature。</li>
<li>朋友/熟人/师生/情侣之间不做买卖，道理你懂的。</li>
</ol>
<h3 id="u4E70_u4E8C_u624B_u8F66_u7684_u57FA_u672C_u8FC7_u7A0B"><a href="#u4E70_u4E8C_u624B_u8F66_u7684_u57FA_u672C_u8FC7_u7A0B" class="headerlink" title="买二手车的基本过程"></a>买二手车的基本过程</h3><p>(在这里只谈CL即Craigslist的途径，其他情况可借鉴)</p>
<ol>
<li>找个一个合适的Post，打电话联系卖家。</li>
<li>要VIN#，利用Carfax或者AutoCheck的账户查车的历史。</li>
<li>确定见面看车时间地点，试车。</li>
<li>去一个修车厂找个mechanic做个inspection。</li>
<li>一手交钱一手交title。</li>
<li>去DMV办手续，也可以让AutoRegistration Company 代办，手续费大概40刀。</li>
<li>一番折腾后，终于拿到了带有你的名字的title。你落泪情绪飘零，来地里发经验求大米。</li>
</ol>
<h3 id="u9664_u53BB_u8F66_u4EF7_u5916_uFF0C_u517B_u8F66_u7684_u82B1_u9500"><a href="#u9664_u53BB_u8F66_u4EF7_u5916_uFF0C_u517B_u8F66_u7684_u82B1_u9500" class="headerlink" title="除去车价外，养车的花销"></a>除去车价外，养车的花销</h3><ol>
<li>去 DMV 注册的费用以及交易税。这部分费用一般不能减免，另外最好不要把交易的价格填得很低，这样虽然能省一点税，但对你不利。当然，各州情况不同，我这里是 CA 的情况，在 AZ 买车是没有交易税的。至于多少，一般 registration 的费用大概 100 刀左右，交易税是 8% 左右吧，不好估计。</li>
<li>保险。保险有得是按月份，有的是按年。我在大农村的地方，用的最低保险，300 刀管半年。保险这个因人而异。</li>
<li>油费。这个可以自己计算。利用车子的 MPG 和自己平时走的路程。保守点算。</li>
<li>维修与保养。其实很多活自己可以 DIY 做的，我也写了一些帖子介绍。比如换 brake pads，前后八片用中上档次的牌子，自己换的话一共用不了 80 刀。看到版上有人1000多刀换了这些，感到心痛。可见 dealer 有多黑，放血是往死里放。咳咳。</li>
<li>停车费用，自己看看学校 parking lot 的收费标准。</li>
<li>罚单。我平均6个月会收到一次停车的罚单，最近一次是在 Downtown LA 停车的时候，没有把咪表给的回执放到车窗前面。两个月后罚单寄到家里了。童鞋们要吸取教训，以后有在咪表的地方停车，需要把缴费的小单放到前窗显眼的位置。</li>
</ol>
<h2 id="u660E_u786E_u4E70_u8F66_u7684_u76EE_u7684_28WHY_29"><a href="#u660E_u786E_u4E70_u8F66_u7684_u76EE_u7684_28WHY_29" class="headerlink" title="明确买车的目的(WHY)"></a>明确买车的目的(WHY)</h2><p>主要是这两个方面</p>
<h3 id="u901A_u52E4"><a href="#u901A_u52E4" class="headerlink" title="通勤"></a>通勤</h3><p>包括上下学上下班什么的，每天至少10mile的来回。</p>
<p>主要特征：每天必须用车，车如果坏了的话基本生活大受影响(&gt;80%)。一年的里程数应该能到5000 miles。其实一年5000 miles 不算多了，如果在LA 这种大地方通勤，一年20000 miles也很正常。全美国汽车的平均年里程是10000 miles左右。如果你买车是来通勤，就可以稍微算算到时候卖车的里程数，看看值不值当。</p>
<p>评价：车子如同是鞋子，天天要用，reliability非常重要。另外如果往返距离比较长(超过30mile)，需要考虑一下车子的MPG (Mileage Per Gallon)。</p>
<h3 id="u8212_u9002"><a href="#u8212_u9002" class="headerlink" title="舒适"></a>舒适</h3><p>包括方便买菜、方便出去玩、住得不远(5mile来回或者有公交站)但有车方便。</p>
<p>主要特征：一周用2-3次，不是天天开，车如果坏了生活略受影响(&lt;30%)。一年的里程数有3000 miles就不错了，可能主要是去华人超市或者小长途(往返500miles)。这时候，比较高里程但年份新的车子就比较适合你了。等到resale的时候，虽然你的车买来时里程比较高，但由于你没怎么开，自然就和年份平衡了。</p>
<p>评价：车是提高生活质量的东西，所以没有必要上cheap used car。这时候可以重点考虑resale 的情况。</p>
<h2 id="u786E_u5B9A_u9884_u7B97"><a href="#u786E_u5B9A_u9884_u7B97" class="headerlink" title="确定预算"></a>确定预算</h2><p>根据你买车的目的，确定自己的预算。或者，由你的预算，确定你买什么车。(以下都是USD不是人刀)</p>
<ol>
<li>Tier 1。10k以上</li>
<li>Tier 2。8k- 10k</li>
<li>Tier 3。6k- 8k</li>
<li>Tier 4。4k- 6k</li>
<li>Tier 5。4k以下</li>
</ol>
<p>这里有一个很重要的前提，就是你的预算决定了你和什么人打交道。永远记住：如果车主不是个好人，那么他要卖给你的车肯定不值得买。社会有三教九流，而不同社会地位的人由于收入不一致，开的车档次当然不一致。这里粗略分了五个档次，大概说说：(四大神车不在讨论范围之内，DFBB)</p>
<ol>
<li>最顶层的人，卖的车子都在10k以上。一般来说，这样的人不太会缺钱，所以砍价比较好砍。另外，这些人也是有着好的收入，不会为了自己的二手车而浪费太多精力。所以，绝大部分这样的车都是trade-in给dealer了，能留到CL上面的这部分车不多。一般车主都是白富美或者高富帅学生，上完大学4年以后新车变老车便卖掉走人。值得注意的是，这类车由于价格高，其实在CL上面买家没有多少的，所以很多车主也就trade-in了。买这一类车，只要你的offer高于dealer给车主的trade-in价格2k以上，估计就十拿九稳了。</li>
<li>最下面的人，卖的车子都不超过4k。这部分人，相当的鱼龙混杂。相当大的几率你会遇上curbdealer，属于自己做car business 靠坑蒙拐骗赚黑心钱，这类人一般心狠手辣，专骗不会开车看车的新手。有前辈指出怎么分辨curb dealer，最简单就是直接问车况，不说 make 和 model。如果对方说 which one?，那么99%是curb dealer。其次，如果是 title 不是卖家的名字，但是却签好名了，那么也90%是curb dealer。剩下的基本都是收入低下的红脖、尼哥、莫莫或者是穷学生。对于要买这一类车的人，必须要有强大的汽修知识，开车熟练，方能在剩下的这一部分卖家的破烂里面找到适合自己的车。当然这里面也有好车的，可是买这一类车难度很大，跟赌博一样，如果你连车都开不稳，又没有预算，那就算了吧。</li>
<li>其余档次的人。这里的就是普通人了，无非是中产阶级家里长大的伪白富美或者小红脖。没有什么特别注意的地方，不过卖家一般都不会轻易松价，得一口口吃，别妄想一下砍1k以上。</li>
</ol>
<h2 id="u9009_u62E9_u5408_u9002_u7684_u6E20_u9053_28HOW_29"><a href="#u9009_u62E9_u5408_u9002_u7684_u6E20_u9053_28HOW_29" class="headerlink" title="选择合适的渠道(HOW)"></a>选择合适的渠道(HOW)</h2><ol>
<li>二手车行，即 dealer。车行的车比较全，而且买来方便，也会有 Warranty。在车行买车是可以讲价的，但别期望能讲得很低。Sales 们都是人精，会使用各种手脚胁迫你买车，一般人不好对付他们。所以，如果在车行买车，那么你肯定是不差钱的了。</li>
<li>租车公司，如 enterprise，hertz 等等。租车公司的车特点是新，一般是 2012年，2013年的车，迈数都很大，每年迈数在 30k 左右。二手车的价格是固定的，不能讲价。讲价的特例也就是除去运输费。比如说你想在 LA买一辆红色的 Camry，但不幸全洛杉矶都没有，只有 San Diego 有这样一辆车。而租车公司运车过来就要收运输费。这里的运输费可以讲下去，但是例子很少。Hertz 卖的车有三天的试驾时间，就是说如果你三天内想退车，可以退而且只会收你三天的租车费用。值得注意的是，租车公司是资本家，具有吸血的自带天赋，能 15000.01 刀卖你的车绝对不会 15000 就卖你，所以也算是一分钱一分货，价格比 Kbb 的 good 略微低一点点。</li>
<li>特殊的组织卖二手车，比如说学校、教会等等。比如说，campus police department 有一批退役的警车，就会定价在学校或者社会公开卖。可能价格是 fixed，也可能是拍卖的形式或者 best offer 的形式，因学校而异。而教会呢，这些二手车的来源可能是 donation，而且教会为了省事，会订出比较低的价格卖这些车变现。这种买车机会可遇不可求，一般情况下是遇不到的。</li>
<li>拍卖会，即 auction。拍卖，是获取大量二手车的主要途径。在拍卖行里面有很多的私人 dealer 或者是本地非著名的中型 dealer，很少私人买家。</li>
<li>在北美省钱快报上面买其他小留的二手车。这是个买二手车的新途径，而且很多车都是豪车或者是特别新的车。不过最近有华人 dealer 冒充卖家卖车，需要提高警惕性。缺点就是地理位置限制，另外数量也不多。</li>
<li>在二手网站 craigslist 上面买二手车。这种方法是本文提倡的，也是重点讲解的。</li>
</ol>
<p>总结一下，如果你想买豪车或者是很新的二手车，那么可以去车行、租车公司或者北美省钱快报，其他途径90%的情况下都没有你想要的车，你也没必要看这篇文章了；其他情况建议去craigslist。</p>
<h2 id="u9009_u62E9_u5408_u9002_u81EA_u5DF1_u7684_u4E8C_u624B_u8F66_28WHICH_ONE_29"><a href="#u9009_u62E9_u5408_u9002_u81EA_u5DF1_u7684_u4E8C_u624B_u8F66_28WHICH_ONE_29" class="headerlink" title="选择合适自己的二手车(WHICH ONE)"></a>选择合适自己的二手车(WHICH ONE)</h2><p>这节内容是假设你已经决定在craigslist上买车了，其内容也同样适用于其他买车途径。这里介绍我选车的方法，如果按照这种方法选车，相信最后在你面前出现的是好车的几率会大幅上升。做任何事情都有相对合适的方法，而如果方法得当，那么最后完成事情的成功率会比方法不正确的完成要高。我一直认为其实买二手车是很需要方法的，具体的技巧甚至是车型都是其次的。他们的区别在于，方法是战略，而mechanics或者make/model都是战术，在战略面前显得太过不重要了。不禁想起了当年校长的“以空间换时间”的战略，即便国家贫瘠，战斗力低下，但只要战略正确，还是可以有相对高的成功率的。废话有点多，还请见谅。Let’s do this, yo！参考在第一节里的“买二手车的基本过程”，下面参照其基本过程给出详细操作步骤。只有两大步，选车和见面。</p>
<h3 id="1-_u5728_CL__u7684_u521D_u6B65_u9009_u8F66/_u5E7F_u544A"><a href="#1-_u5728_CL__u7684_u521D_u6B65_u9009_u8F66/_u5E7F_u544A" class="headerlink" title="1.在 CL 的初步选车/广告"></a>1.在 CL 的初步选车/广告</h3><p>在 CL 上面选车是件长期的事情，要做好艰苦抗战的准备。一般没有30天每天1小时的间隔地刷，是找不到自己想到的车的，所以不要着急。另外，有些看似是Deal 的Post 会被卖家delete掉，也就是卖掉了，也没必要伤感。因为买二手车并不是抢Deal这么简单，它是要陪伴你好几年的坐骑咳，着急不得。邪恶一下，说不定这种Deal有个什么隐形的毛病，一时半会看不出来。比如高速堵车时水温容易过高的毛病，就需要高速20分钟以上同时堵车才能出现，所以说是隐形的。抢了车的人很可能事后后悔不已呢，咳咳。</p>
<p>如何有效地浏览各种 Post</p>
<p>打开 CL 你所在的城市，比如 Phoenix。如果你住的地方比较大，比如 Los Angeles，那么还可以选 Long Beach/Santa Monica 等等的各种郡。当然如果觉得太远的话就可以只看离自己地点近的地方，因人而异。点击 Cars/Trucks for Sale by Owners，进入各种 Post 的页面。然后选择 gallery 的方式， newest first 的排序，选必须有 pic。选好之后，再去 research 栏里面填期望的价格。注意一定要填一个最低价，以筛选掉很多陷阱或者垃圾。比如你预算是 6000 USD，那么价格可以填 min:4000，max:7000。之所以 max 比自己的预算高，那是因为最后的成交价一般会比卖家 Post  的低。好了，这样一来，很多无效的 Post 都已经被过滤掉了，下面进入第二步。</p>
<p>点开 Post 后的再次筛选</p>
<p>a. 首先看 Post 的日期，指第一次 Post 的日期。如果这个 Post 之前 Post 过，那么你应该有印象是好是坏，可以凭感觉甚至图片关掉。本着群众的眼睛是雪亮的道理，好 deal 是轮不到你猥琐男的，一出来就会被抢掉的。所以呢，剩下来的车一般都不是性价比最好的，好车况的车需要降降价。超过3天的 Post 一律不要看了，除非是由于卖家主动降价导致的 Repost，不然都不要看了。</p>
<p>b. 其次看车是不是 Auto Transmission 自动挡，手动车就直接略过 ctrl+W 吧，当然如果你会开或者不介意那没关系。没写的话默认它是自动挡。</p>
<p>c. 接着看 Year/Make/Model 和 Odometer。这里争议比较大，一般年份10年左右的也可以接受了，但是 Odometer 最好不要超过 130k。在这里还是要俗套地说一下：我觉得如果是德国车，超过 100k 的话就不要了吧；美国车，超过110k 就不要了吧；日本车，超过 120k 就不要了吧。当然只是大概，楼主我可能会被喷，不过各位看官权当看看，了解个大概就好了。<br>d. 然后看卖家写的介绍。几个关键词：clean/clear title(必须有，如果是 salvage title 那么最好不要)，1st owner(有最好，没有也行)，有没有电话(没有电话的一律假设是骗纸)，有没有 leaks，换过什么东西(验车的时候要重点查除了这几个之外的大件)。</p>
<p>e. 最后结合所有情况，决定要不要给卖家打电话。</p>
<p>打电话干什么</p>
<p>打电话问广告里面没有的内容，特别是没有给出的特别重要的信息。一般来说，没有给出关键信息说明卖家对这个信息持消极态度。也就是说，这个关键信息对车价的影响是不良/负面的。比如，如果原文没有给出 VIN，那么需要索要 VIN#，查一下看看有没有不良的记录。又例如，没有给出里程数，那么基本可以确定车的里程特别的高，因为里程数是很明显不可能 miss 的关键信息。然后根据纸面车况和历史，把价格初步砍一砍。最后如果不错，那么就约个时间见面试车吧！哎？等等，怎么个见面，也是有学问的！</p>
<p>见面的时间地点选择</p>
<p>时间选择，最好是工作日工作时间，比如3p mon Monday。原因很简单，一是如果要去做inspection，那么得在车行工作时间可以做。可以提前预约，也可以不预约排队。二是如果要交易，写check银行能马上出钱，同时银行有人可以开证明。当然，当天办title这个不是必须。如果你当天因为这些原因不能验车或者交易，那卖家第二天把车卖给别人了就很可惜了。地点选择，最好在餐厅，比如麦当劳之类的地方。一是有wifi，如果卖家没给你VIN，你可以过去后抄下来当场查；二是公共场合，能保证安全。三是麦当劳一般靠近所在地的主要干道，附近的公交车站密集，方便你回家。</p>
<h3 id="2-_u89C1_u9762_u51B3_u5B9A_u662F_u5426_u4EA4_u6613"><a href="#2-_u89C1_u9762_u51B3_u5B9A_u662F_u5426_u4EA4_u6613" class="headerlink" title="2.见面决定是否交易"></a>2.见面决定是否交易</h3><p>a. 根据卖家的表现，确定他|她卖车的真实目的。<br>凡事都有个因果。卖家之所以卖车，也无非是有原因的：</p>
<ol>
<li>修好破车或者倒卖车辆赚钱</li>
<li>避免trade-in给dealer或者贱卖junkyard 损失更多钱</li>
<li>甩掉包袱，破车修不好了，投入的钱太多了</li>
<li>升官发财后，猛将配好马，屌丝逆袭换车了</li>
<li>其他</li>
</ol>
<p>这里的1.&amp; 4. 是主动性卖车，2.&amp;3.　是被动性卖车。所谓主动，是车主并不着急，主动权在他|她手上；所谓被动，是车主不得不卖车，有他|她自己的个人小原因，可能是搬家横跨美国了，可能是老车毛病太多，不值得修了。如何得知卖家的真实意图呢？直接问就可以了。从卖家的言语神态还是可以捕捉到蛛丝马迹的，这里就看你的察言观色能力了。结合卖家的回答，再利用下面介绍的一些trick，揣摩卖家的真实意图。</p>
<p>Tips</p>
<ol>
<li>Why do you want to sell your vehicle?如果回答是说换车了，接2；如果回答是说搬家要卖车，接3；如果是其他回答，那么卖家基本说的实话，因为所有原因里面只有前两个最好，或者说最合理最有逻辑。</li>
<li>Cool, bro. Got a new car? Can I have a look at it?如果确实看到新车了，车主还打开车门让你看看的话，基本原因就属实。啰嗦几句，如果说是因为有孩儿换了大车(SUV，minivan)，那么看看有没有专门的儿童座椅，如果有的话，这肯定是实话了。又或者是老婆怀孕，那看她肚子就行了..</li>
<li>Move to where? What time will you leave? 如果你是在他|她house或者Apartment里面，随便问问有没有其他|她不需要的或者搬不走的东西，说不定还有好deal呢。应该能观察到房间里打包的行李什么的，而且如果卖家说什么家具都不卖，从而推测出卖家是否在说谎。当然，如果地点支支吾吾的最后说了个近的，比如住在LA说要搬去LasVegas 或者Phoenix，那么可疑了，这么短的距离为何不开车去呢？如果说要回国了，那么无解了。不过说回国的，那也出现一个优势，就是砍价的时候可以尽情往下去，直到比dealer给的trade-in价格高些就行了。因为如果回国，车子肯定要卖，卖谁都一样，给bestoffer 就会卖的。而且这种回国的人，随着时间的拖延，卖车欲望会指数增长。也就是说，如果你看到之前这个回国的卖家隔了几天又把车post出来了，那么就是急了。把价格稍微压一压就可以拿下了。</li>
</ol>
<p>下面分析，针对各种真实卖车原因：</p>
<ol>
<li>赚钱赚钱赚钱！这一条卖家卖车就只是为了赚钱。无论是修好的破车还是倒卖的车辆也好，如果卖家卖车是为了赚钱，那么这动机不纯洁，什么伤天害理的事情都会发生的。车子坚决不要！靠卖车赚钱的人通常车的title都会有问题，这是很明显的证据。比如说，title上面不是他的名字，但却签好字了，说明卖家在倒卖车；title的日期很近，比如说一个月之前卖家买了这辆车，这样就很不正常。</li>
<li>避免损失更多钱，指的是卖家不希望只得到dealer的lowball offer，想卖多一点钱，这时候车子的情况可能还是不错的，就是价格可能坚挺，毕竟主动权在卖家手上。</li>
<li>修不好的破车，无论到谁手上都是烫手的山芋。一般这样的车，有明显的缺陷。比如CheckEngine Light 亮着，或者是出了车祸前bumper破烂不堪Coolant洒了满地的。车况劣等。</li>
<li>发财换车，是件好事。一来卖家手上宽裕，买了新车心里高兴，砍价好些；二来旧车不是由于机械故障才出售的，所以车况一般不错。值得注意的是，由于一般买新车dealer都会主动要求trade-in客户的旧车，所以可以说这卖家是当时拒绝了dealer的lowball offer 的。当然也可能有其他原因，比如生了小BB，家里需要SUV而不是Sedan了。</li>
<li>情况比较复杂。这里不展开。</li>
</ol>
<p>b. 验车<br>验车可以分成两个部分：一是自己试开车或者朋友试开，一是去mechanicshop 做inspection。下面展开来说：</p>
<p>试开车。<br>以后自己的坐骑，如果试开就不爽，那以后可能天天不爽。试开呢，是很重要的，你需要了解这辆二手车。试开，可以查查下面几个部分：</p>
<ol>
<li>方向盘的轻重。如果非 pickup/truck 而方向盘很重的话，可能转向液 (power steering fluid) 寿命已过，车主没有及时保养。</li>
<li>刹车性能。如果刹车有尖锐的叫声从 rim 传来，说明刹车差不多磨没了，需要更换。</li>
<li>轮胎寿命。拿个5美分的硬币塞入轮胎的缝隙中，如果林肯的头能埋进去，说明寿命还够；如果没有，说明需要换轮胎了。</li>
<li>避震器。把车子的四个角往下使劲摁，如果几下恢复原状说明性能不错。</li>
<li>加速时有没有变速箱的 slipping。就是说，加速提档位的时候，有没有一种一格一格的感觉。老车自然会有一点这种 slipping，但如果很严重，变速箱液(ATF) 颜色味道又很烂，说明其寿命不长了。</li>
<li>开完车后，趴在车底下看看有没有什么液体漏在地上了。</li>
<li>如果在冬天验车，最好在车还没热起来的时候去点火。有些车冬天点火很不容易着，但如果提前热过车后，会很容易点火。</li>
<li>试试空调和收音机喇叭什么的是不是好的。</li>
<li>各种灯，大灯远光灯转向灯日行灯倒车灯刹车灯等等..</li>
<li>还会继续补充..</li>
</ol>
<p>去mechanicshop 做inspection。</p>
<p>原则上来说，不能去任何与卖家有瓜葛的店里做检查。可以选择些著名的黑店，比如说firestone..之所以选黑店，是因为黑店对很多车的小毛病都不放过，想骗你去修。而我们做inspection就是尽可能地找出这些毛病，用来砍价。所以，你懂的。当然，如果有什么很重大的毛病，车行说要很多钱修的话，你既可以于卖家商量把价格压低，也可以不买这辆车了。</p>
<p>交易</p>
<p>记得一手交钱，一手拿带有卖家签名的title。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里是之前收集的一些在美国买二手车的注意事项和相关技巧，分享给大家。</p>]]>
    
    </summary>
    
      <category term="二手车" scheme="http://wdxtub.com/tags/%E4%BA%8C%E6%89%8B%E8%BD%A6/"/>
    
      <category term="北美" scheme="http://wdxtub.com/tags/%E5%8C%97%E7%BE%8E/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Latex 常用符号表]]></title>
    <link href="http://wdxtub.com/2016/03/26/latex-notation-table/"/>
    <id>http://wdxtub.com/2016/03/26/latex-notation-table/</id>
    <published>2016-03-26T16:37:43.000Z</published>
    <updated>2016-03-26T16:44:18.000Z</updated>
    <content type="html"><![CDATA[<p>这里记录了常用的 Latex 符号及用法</p>
<a id="more"></a>
<hr>
<h2 id="u5B57_u4F53"><a href="#u5B57_u4F53" class="headerlink" title="字体"></a>字体</h2><ul>
<li><code>\mathrm{}</code>，正常字体</li>
<li><code>\mathit{}</code>，斜体</li>
<li><code>\mathbf{}</code>，粗体符号boldfont</li>
<li><code>\mathbb{}</code>，空心粗体blackboard</li>
<li><code>\mathnormal{}</code>，正常字体</li>
</ul>
<h2 id="u6570_u5B66_u516C_u5F0F"><a href="#u6570_u5B66_u516C_u5F0F" class="headerlink" title="数学公式"></a>数学公式</h2><p><img src="/images/14590103911299.jpg" alt=""></p>
<h2 id="u6392_u7248"><a href="#u6392_u7248" class="headerlink" title="排版"></a>排版</h2><ul>
<li><code>\quad</code> 生成一个空格（相当于大写’M’的宽度）</li>
<li><code>\qquad</code> 生成一个大空格</li>
<li><code>\,</code> 相当于3/18个\quad</li>
<li><code>:</code> 相当于4/18个\quad</li>
<li><code>\;</code> 相当于5/18个\quad</li>
<li><code>!</code> 生成一个负空格-3/18个\quad</li>
<li>将 <code>\left</code> 放在分隔符前，tex会自动调整分隔符的大小</li>
<li>但是每个 <code>\left</code> 必须要用一个<code>\right</code>关闭</li>
<li>如果分隔符仅有左括号则用<code>\right.</code>关闭</li>
</ul>
<p>$$\left{ x^2 \right}$$</p>
<h2 id="u7B26_u53F7_u8868"><a href="#u7B26_u53F7_u8868" class="headerlink" title="符号表"></a>符号表</h2><p><img src="/images/14590105384037.jpg" alt=""></p>
<p><img src="/images/14590105424692.jpg" alt=""></p>
<p><img src="/images/14590105464309.jpg" alt=""></p>
<p><img src="/images/14590105502032.jpg" alt=""></p>
<p><img src="/images/14590105541907.jpg" alt=""></p>
<p><img src="/images/14590105592350.jpg" alt=""></p>
<p><img src="/images/14590105659095.jpg" alt=""></p>
<p><img src="/images/14590105709311.jpg" alt=""></p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://hustlei.tk/2014/08/latex-math-equation.html" target="_blank" rel="external">latex数学公式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里记录了常用的 Latex 符号及用法</p>]]>
    
    </summary>
    
      <category term="Latex" scheme="http://wdxtub.com/tags/Latex/"/>
    
      <category term="符号" scheme="http://wdxtub.com/tags/%E7%AC%A6%E5%8F%B7/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google 搜索技巧]]></title>
    <link href="http://wdxtub.com/2016/03/26/google-tip/"/>
    <id>http://wdxtub.com/2016/03/26/google-tip/</id>
    <published>2016-03-26T16:15:16.000Z</published>
    <updated>2016-03-26T16:16:19.000Z</updated>
    <content type="html"><![CDATA[<p>这里记录一些非常有用的搜索技巧，熟练运用后可以有效提升自己的效率。</p>
<a id="more"></a>
<hr>
<h2 id="u64CD_u4F5C_u7B26"><a href="#u64CD_u4F5C_u7B26" class="headerlink" title="操作符"></a>操作符</h2><p><code>+</code> 强制搜索</p>
<p>由于Google会忽略和过滤一些常用词（称为stop words / common words），如and、how等。使用+可以让搜索引擎强制包括这些词。使用+还可以强制过滤关键词变体形式（不让搜索结果出现关键词的其它形式），如单复数、动词时态、ing形式等等。</p>
<p><code>-</code>  逻辑非</p>
<p>用于过滤-号后面的关键词。如：MP3 -MP4，表示只搜索MP3而不要MP4的搜索结果。 -号后面没有空格。</p>
<p><code>~</code> 同义词</p>
<p>关键词前加波浪线。如：~table 。</p>
<p><code>*</code> 通配符</p>
<p>如：Google was founded in * 。</p>
<p><code>**</code> 指数</p>
<p>作用同  ^ ，如：2**10 。</p>
<p><code>&quot; &quot;</code> 引号</p>
<p>用引号精确搜索，有时可只用左侧引号。如：”Google hacking” = “Google hacking 。</p>
<p><code>|</code> 逻辑或</p>
<p>作用同 OR ，如：Google hacking | hacks 。</p>
<p><code>..</code> 数字范围</p>
<p>用于限定数值范围，如：spring festival logo 2002..2009 。</p>
<p><code>^</code> 指数</p>
<p>作用同  ** ，如：2^10 。</p>
<h2 id="u64CD_u4F5C_u547D_u4EE4"><a href="#u64CD_u4F5C_u547D_u4EE4" class="headerlink" title="操作命令"></a>操作命令</h2><p><code>OR</code>  逻辑或</p>
<p>作用同 | ，如：Google hacking OR hacks 。</p>
<p><code>define:</code>  关键词定义</p>
<p>查询关键词的网络释义。如： define:google 。</p>
<p><code>ext:</code>  限定搜索指定文件类型</p>
<p>作用同 filetype:</p>
<p><code>filetype:</code>  限定搜索指定文件类型<br>    作用同 ext: 如：filetype:pdf = ext:pdf 。目前文件类型支持如下格式：<br>    Adobe Acrobat PDF (.pdf)<br>    Adobe Postscript (.ps)<br>    Autodesk DWF (.dwf)<br>    Google地球 KML (.kml)<br>    Google地球 KMZ (.kmz)<br>    Lotus 1-2-3（wk1、wk2、wk3、wk4、wk5、wki、wks、wku）<br>    Lotus WordPro (.lwp)<br>    MacWrite (.mw)<br>    Microsoft Excel (.xls)<br>    Microsoft Powerpoint (.ppt)<br>    Microsoft Word (.doc)<br>    Microsoft Works（wks、wps、wdb）<br>    Microsoft Write (.wri)<br>    Rich Text Format富文本格式 (.rtf)<br>    Shockwave Flash (.swf)<br>    纯文本（ans、txt）</p>
<p><code>intitle:</code>  限定搜索标题中含指定关键词的网页</p>
<p>如： intitle:google search guide 。限定多个关键词用 allintitle:</p>
<p><code>inurl:</code>  限定搜索url中含指定关键词的网页</p>
<p>如： inurl:google search guide 。通过inurl:view.shtml 你可以找到在线的网络摄像头。 限定多个关键词用 allinurl:</p>
<p><code>inanchor:</code>  限定搜索页面链接锚文本中含指定关键词的网页</p>
<p>如： inanchor:google search guide 。限定多个关键词用 allinanchor:</p>
<p><code>intext:</code>  限定搜索正文文本（不含标题和链接）中含指定关键词的网页</p>
<p>如： intext:google vs mircosoft。</p>
<h2 id="u7F51_u7AD9_u7F51_u9875_u547D_u4EE4"><a href="#u7F51_u7AD9_u7F51_u9875_u547D_u4EE4" class="headerlink" title="网站网页命令"></a>网站网页命令</h2><p><code>site:</code>  限定搜索某网站的网页</p>
<p>如： site:www.google.com 。</p>
<p><code>link:</code>  搜索链向某网站/网址的网页</p>
<p>如： link:www.google.com 。</p>
<p><code>related:</code>  搜索与某网页相似或相关的页面</p>
<p>如： related:www.google.com 。</p>
<p><code>cache:</code>  搜索某网页在Google缓存（网页快照）中的旧版本</p>
<p>如： cache:www.google.com 。</p>
<p><code>info:</code>  综合查询某网页的信息，即列出上述四个命令</p>
<p>如： info:www.google.com 。作用同 id:</p>
<h2 id="u56FE_u7247_u641C_u7D22_u4E0E_u5F71_u89C6_u641C_u7D22"><a href="#u56FE_u7247_u641C_u7D22_u4E0E_u5F71_u89C6_u641C_u7D22" class="headerlink" title="图片搜索与影视搜索"></a>图片搜索与影视搜索</h2><p>filetype: 限定搜索指定文件类型的图片，支持如下格式：</p>
<ul>
<li>filetype:jpg</li>
<li>filetype:gif</li>
<li>filetype:png</li>
<li>filetype:bmp</li>
</ul>
<p>imagesize: 限定搜索指定尺寸的图片，如: imagesize:800x600</p>
<p>URL 参数：加在图片搜索网页的 URL 后面，可以实现更精细的搜索</p>
<ul>
<li>&amp;imgtype=news 资讯</li>
<li>&amp;imgtype=face 脸部特写</li>
<li>&amp;imgtype=clipart 剪贴画</li>
<li>&amp;imgtype=lineart 素描</li>
<li>&amp;imgtype=photo 照片</li>
<li>&amp;imgc=gray 黑白图片</li>
<li>&amp;imgc=mono 灰阶图片</li>
<li>&amp;imgc=color 全彩图片</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里记录一些非常有用的搜索技巧，熟练运用后可以有效提升自己的效率。</p>]]>
    
    </summary>
    
      <category term="Google" scheme="http://wdxtub.com/tags/Google/"/>
    
      <category term="搜索" scheme="http://wdxtub.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux 的概念与体系]]></title>
    <link href="http://wdxtub.com/2016/03/26/linux-basic/"/>
    <id>http://wdxtub.com/2016/03/26/linux-basic/</id>
    <published>2016-03-26T15:17:06.000Z</published>
    <updated>2016-03-26T15:38:33.000Z</updated>
    <content type="html"><![CDATA[<p>这篇日志来自 <a href="http://www.cnblogs.com/vamei" target="_blank" rel="external">Vamei 博客</a> 中的系列文章，把一些基本的内容做了整合，方便查阅。</p>
<a id="more"></a>
<hr>
<h2 id="Linux_u7B80_u4ECB_u4E0E_u5382_u5546_u7248_u672C"><a href="#Linux_u7B80_u4ECB_u4E0E_u5382_u5546_u7248_u672C" class="headerlink" title="Linux简介与厂商版本"></a>Linux简介与厂商版本</h2><p><strong>Linux简介</strong></p>
<p>Linux可以有狭义和广义两种定义。狭义来说，Linux实际上指Linux kernel (内核)。内核负责管理硬件，并为上层应用提供接口。而广义来说，是指以Linux kernel为基础的，包括OS和各种应用在内的各个Linux版本(distribution)。尽管看起来版本眼花缭乱，但实际上，各个版本之间也只是大同小异，其差别往往体现在客户群、升级维护和界面等方面。</p>
<p>Linus Torvalds是Linux之父。他根据Minix系统的代码，参照UNIX系统的设计，写出了第一给Linux内核。Linus的创举在于将Linux内核的代码开源。后来，Linux内核和一套开源的应用软件GNU结合，共同采取开源协议，并迅速发展成熟。我们可以随意地使用和修改开源代码，但以此为基础开发的程序也要根据开源协议公开。Linux和GNU的开源性吸引了大批优秀的程序员参与到Linux相关的开发中。</p>
<p>从哲学和设计理念上，Linux与其他的UNIX版本相类似，并使用类似的接口。我们可以通过学习Linux的基本概念和机制来了解其它UNIX系统，比如Solaris, FreeBSD，还有基于FreeBSD的苹果公司的Mac OS。曾经Windows的兴起曾经让许多人认为UNIX将最终被Windows取代，但如今看到Linux和苹果产品的兴盛，我很感慨于UNIX体系的力量。</p>
<p>Linux的有如下比较重要的机制: 用于储存数据以及管理权限的文件系统，用于IO的文本操作API，用于管理操作的进程，用于实现多任务运行的多线程，以及进程间通信(我将信号和网络也都归入这一类中)。</p>
<p>特别推荐下面的一些文章，以便你对Linux有一个概观：</p>
<p><a href="http://www.catb.org/~esr/writings/cathedral-bazaar/introduction/" target="_blank" rel="external">大教堂和市集（The Cathedral and the Bazaar）</a>，作者Eric Raymond</p>
<p>可以说是为Linux正名的一篇文章，深入分析Linux成功的原因。你也可以通过名字来搜索中文翻译版本。</p>
<p>该作者的<a href="http://www.catb.org/~esr/writings/" target="_blank" rel="external">其他文章</a>也非常值得一读。</p>
<p>UNIX传奇，来自酷壳，作者陈皓</p>
<ul>
<li>上篇：<a href="http://coolshell.cn/articles/2322.html" target="_blank" rel="external">http://coolshell.cn/articles/2322.html</a></li>
<li>下篇：<a href="http://coolshell.cn/articles/2324.html" target="_blank" rel="external">http://coolshell.cn/articles/2324.html</a></li>
</ul>
<p>(作者博客内容丰富，又容易读，非常值得订阅。)</p>
<p><strong>Linux的厂商版本</strong></p>
<p>在Linux内核基础上，我们还有许多厂商版本。即使有了内核和GNU软件，Linux的安装和编译并不是简单的工作，Linux厂商就是瞄准了这个市场。这些厂商会在Linux内核的基础上，结合自己开发的软件，帮助用户安装和使用Linux，并提供技术支持。由于在服务器领域，Linux操作系统远远领先于Windows系统，而这些被政府部门、银行或者大学拥有的服务器往往承担很重要的信息处理和IO (input/outpt) 工作，所以尽管Linux开源，厂商还是可以根据其提供的商用软件和技术支持获得丰厚的利润。</p>
<p>(IBM是Linux设备最大的供应商，同时它的咨询业务很大一部份也来源于提供Linux相关的支持。我们所熟知的Android操作系统，也算是Google提供的一个厂商版本。)</p>
<p>我们这里主要介绍在PC上比较流行的Linux厂商版本:</p>
<p><strong>红帽系列</strong></p>
<ul>
<li>Red Hat linux: 大名鼎鼎的红帽，现在已经完结。以此为基础有以下分支:</li>
<li>Red Hat Enterprise: (www.redhat.com) 这个是企业级的linux，主要面向服务器。作为商业版，有比较好的配套软件和技术支持。RH的教材也堪称经典。</li>
<li>Fedora: (<a href="http://fedoraproject.org" target="_blank" rel="external">http://fedoraproject.org</a>) 由社区维护，去除了一些商业软件。红帽实际上赞助了这个项目，以便以此作为技术测试平台。</li>
<li>CentOS: (www.centos.org) 这个版本不来自红帽的公司，是收集红帽公开的源码组成的免费版本，由社区维护，和红帽完全兼容。版本号升级较慢，但有持续的技术支持，所以适合于不愿意频繁升级的情形，鸟哥中就推荐以CentOS来建站。</li>
</ul>
<p><strong>SUSE系列</strong></p>
<ul>
<li>SUSE Linux Enterprise: (www.suse.com) 和红帽商业版类似，是德国公司制作的，据说在欧洲比较流行，但我欧洲的朋友表示没怎么听说过。SUSE系列比较有特色的是YAST2，就是用来设置Linux的界面，对初级管理员比较方便。</li>
<li>openSUSE: (www.opensuse.org) SUSE的免费版本。以前SUSE不是很推这个免费版本，支持不好。现在似乎态度大大转变。就我个人的使用体验来说，还是觉得社区支持不足。</li>
</ul>
<p><strong>Debian系列</strong></p>
<ul>
<li>Debian: (www.debian.org) 完全免费，社区维护的Linux版本，有很大的用户群，所以遇到问题，基本都可以找到社区用户的支持。</li>
<li>Ubuntu: (www.ubuntu.com) 由一个基金提供支持的免费Linux版本。 继承自Debian。界面很友好。发邮件过去，还会送你免费安装CD (不知道现在还有没有)。现在的版本加载的东西有些多，速度有些慢。写《大教堂和市集》的Eric Raymond说它是最好的Linux。</li>
<li>Mint (<a href="http://www.linuxmint.com" target="_blank" rel="external">http://www.linuxmint.com</a>), 基于ubuntu。它提供了更加丰富的预装应用，以减少用户搜索并安装应用的麻烦。其使用的应用版本比较新，可能不是很稳定。</li>
</ul>
<p>此外，还有如下一些版本：</p>
<ul>
<li>Gentoo (www.gentoo.org) 基于源码的版本，提供给用户很大的自由度。为用户提供大量应用程序的源码，可以在用户的系统上重新编译建造。需要一定的系统配置的知识。</li>
<li>ArchLinux (www.archlinux.org)，推崇简洁，避免不必要和复杂的修改，是一个轻便灵活的版本。其配置文件有良好注释。</li>
<li>Mandriva (www.mandriva.com) 一个很方便用户使用的版本，其目标是使得新用户更容易使用linux。</li>
<li>Slackware (www.slackware.com) 稳定，基本。它的只包含稳定版本的应用程序。对于初级用户不是很友好。</li>
<li>TurboLinux (www.turbolinux.com) 在亚洲比较流行。商业版本，提供技术支持和咨询服务。</li>
</ul>
<h2 id="Linux_u5F00_u673A_u542F_u52A8"><a href="#Linux_u5F00_u673A_u542F_u52A8" class="headerlink" title="Linux开机启动"></a>Linux开机启动</h2><p>计算机开机是一个神秘的过程。我们只是按了开机键，就看到屏幕上的进度条或者一行行的输出，直到我们到达登录界面。然而，计算机开机又是个异常脆弱的过程，我们满心期望的登录界面可能并不会出现，而是一个命令行或者错误信息。了解计算机开机过程有助于我们修复开机可能出现的问题。</p>
<p><strong>最初始阶段</strong></p>
<p>当我们打开计算机电源，计算机会自动从主板的BIOS(Basic Input/Output System)读取其中所存储的程序。这一程序通常知道一些直接连接在主板上的硬件(硬盘，网络接口，键盘，串口，并口)。现在大部分的BIOS允许你从软盘、光盘或者硬盘中选择一个来启动计算机。</p>
<p>下一步，计算机将从你所选择的存储设备中读取起始的512 bytes(比如光盘一开是的512 bytes，如果我们从光盘启动的话)。这512 bytes叫做主引导记录MBR (master boot record)。MBR会告诉电脑从该设备的某一个分区(partition)来装载引导加载程序(boot loader)。Boot loader储存有操作系统(OS)的相关信息，比如操作系统名称，操作系统内核 (kernel)所在位置等。常用的boot loader有GRUB和LILO。</p>
<p>随后，boot loader会帮助我们加载kernel。kernel实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过kernel传达给硬件。Windows和Linux各自有自己kernel。狭义的操作系统就是指kernel，广义的操作系统包括kernel以及kernel之上的各种应用。</p>
<p>（Linus Torvalds与其说是Linux之父，不如说是Linux kernel之父。他依然负责Linux kernel的开发和维护。至于Ubuntu, Red Hat, 它们都是基于相同的kernel之上，囊括了不同的应用和界面构成的一个更加完整的操作系统版本。)</p>
<p>实际上，我们可以在多个分区安装boot loader，每个boot loader对应不同的操作系统，在读取MBR的时候选择我们想要启动的boot loader。这就是多操作系统的原理。</p>
<p>小结：BIOS -&gt; MBR -&gt; boot loader -&gt; kernel</p>
<p><strong>kernel</strong></p>
<p>如果我们加载的是Linux kernel，Linux kernel开始工作。kernel会首先预留自己运行所需的内存空间，然后通过驱动程序(driver)检测计算机硬件。这样，操作系统就可以知道自己有哪些硬件可用。随后，kernel会启动一个init进程。它是Linux系统中的1号进程(Linux系统没有0号进程)。到此，kernel就完成了在计算机启动阶段的工作，交接给init来管理。</p>
<p>小结: kernel -&gt; init process</p>
<p><strong>init process</strong></p>
<p>(根据boot loader的选项，Linux此时可以进入单用户模式(single user mode)。在此模式下，初始脚本还没有开始执行，我们可以检测并修复计算机可能存在的错误)</p>
<p>随后，init会运行一系列的初始脚本(startup scripts)，这些脚本是Linux中常见的shell scripts。这些脚本执行如下功能：</p>
<p>设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络……</p>
<p>当这些初始脚本，操作系统已经完全准备好了，只是，还没有人可以登录！！！init会给出登录(login)对话框，或者是图形化的登录界面。</p>
<p>输入用户名(比如说vamei)和密码，DONE！</p>
<p>在此后的过程中，你将以用户(user)vamei的身份操作电脑。此外，根据你创建用户时的设定，Linux还会将你归到某个组(group)中，比如可以是stupid组，或者是vamei组。</p>
<p>所以你将是用户vamei， 同时是vamei组的组员。(注意，组vamei和用户vamei只是重名而已，就好想你可以叫Dell, 同时还是Dell公司的老板一样。你完全也可以是用户vamei，同时为stupid组的组员)</p>
<p><strong>总结</strong></p>
<p>BIOS -&gt; MBR -&gt; boot loader -&gt; kernel -&gt; init process -&gt; login</p>
<p>用户，组。</p>
<h2 id="Linux_u6587_u4EF6_u7BA1_u7406"><a href="#Linux_u6587_u4EF6_u7BA1_u7406" class="headerlink" title="Linux文件管理"></a>Linux文件管理</h2><p>对于计算机来说，所谓的数据就是0和1的序列。这样的一个序列可以存储在内存中，但内存中的数据会随着关机而消失。为了将数据长久保存，我们把数据存储在光盘或者硬盘中。根据我们的需要，我们通常会将数据分开保存到文件这样一个个的小单位中(所谓的小，是相对于所有的数据而言)。但如果数据只能组织为文件的话，而不能分类的话，文件还是会杂乱无章。每次我们搜索某一个文件，就要一个文件又一个文件地检查，太过麻烦。文件系统(file system)是就是文件在逻辑上组织形式，它以一种更加清晰的方式来存放各个文件。</p>
<p><strong>路径与文件简介</strong></p>
<p>文件被组织到文件系统(file system)中，通常会成为一个树状(tree)结构。Linux有一个根目录/, 也就是树状结构的最顶端。这个树的分叉的最末端都代表一个文件，而这个树的分叉处则是一个目录(directory, 相当于我们在windows界面中看到的文件夹)。在图1中看到的是整个的一个文件树。如果我们从该树中截取一部分，比如说从目录vamei开始往下，实际上也构成一个文件系统。</p>
<p>要找到一个文件，除了要知道该文件的文件名，还需要知道从树根到该文件的所有目录名。从根目录开始的所有途径的目录名和文件名构成一个路径(path)。比如说，我们在Linux中寻找一个文件file.txt，不仅要知道文件名(file.txt)，还要知道完整路径，也就是绝对路径(/home/vamei/doc/file.txt)。从根目录录/, 也就是树状结构的最顶端出发，经过目录home, vamei, doc，最终才看到文件file.txt。整个文件系统层层分级(hierarchy)，vamei是home的子目录，而home是vamei的父目录。</p>
<p>在Linux中，我们用ls命令来显示目录下的所有文件，比如 $ls /home/vamei/doc</p>
<p><strong>目录</strong></p>
<p>在Linux系统中，目录也是一种文件。所以/home/vamei是指向目录文件vamei的绝对路径。</p>
<p>这个文件中至少包含有以下条目:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">.       </span>指向当前目录</span><br><span class="line"><span class="bullet">..      </span>指向父目录</span><br></pre></td></tr></table></figure>
<p>除此之外，目录文件中还包含有属于该目录的文件的文件名，比如vamei中就还要有如下条目，指向属于该目录的文件:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">doc</span></span><br><span class="line"><span class="keyword">movie</span><br><span class="line"></span><span class="label">photo</span></span><br></pre></td></tr></table></figure>
<p>Linux解释一个绝对路径的方式如下：先找到根目录文件，从该目录文件中读取home目录文件的位置，然后从home文件中读取vamei的位置……直到找到目录doc中的file.txt的位置。</p>
<p>由于目录文件中都有.和..的条目，我们可以在路径中加入.或者..来表示当前目录或者父目录，比如/home/vamei/doc/..与/home/vamei等同。</p>
<p>此外，Linux会在进程中，维护一个工作目录(present working directory)的变量。在shell中，你可以随时查询到到工作目录(在命令行输入<code>$pwd</code>)。这是为了省去每次都输入很长的绝对路径的麻烦。比如说我们将工作目录更改为/home/vamei (<code>$cd /home/vamei</code>)，那么此时我们再去找file.txt就可以省去/home/vamei/ (<code>$ls doc/file.txt</code>)，这样得到的路径叫相对路径(relative path)，上面的doc/file.txt就是这样一个相对路径。</p>
<p>当文件出现在一个目录文件中时，我们就把文件接入到文件系统中，我们称建立一个到文件的硬链接(hard link)。一个文件允许出现在多个目录中，这样，它就有多个硬链接。当硬链接的数目(link count)降为0时，文件会被Linux删除。所以很多时候，unlink与remove在Linux操作系统中是一个意思。由于软链接(soft link)的广泛使用(soft link不会影响link count，而且可以跨越文件系统)，现在较少手动建立硬连接。</p>
<p><strong>文件操作</strong></p>
<p>对于文件，我们可以读取(read)，写入(write)和运行(execute)。读取是从已经存在的文件中获得数据。写入是向新的文件或者旧的文件写入数据。如果文件储存的是可执行的二进制码，那么它可以被载入内存，作为一个程序运行。在Linux的文件系统中，如果某个用户想对某个文件执行某一种操作，那么该用户必须拥有对该文件进行这一操作的权限。文件权限的信息保存在文件信息(metadata)中, 见下一节。</p>
<p><strong>文件附加信息 (metadata)</strong></p>
<p>文件自身包含的只有数据。文件名实际上储存在目录文件。除了这些之外，还有操作系统维护的文件附加信息，比如文件类型，文件尺寸，文件权限，文件修改时间，文件读取时间等。可以用ls命令查询文件信息($ls -l file.txt)，得到如下结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- <span class="number">1</span> vamei vamei <span class="number">8445</span> Sep  <span class="number">8</span> <span class="number">07</span>:<span class="number">33</span> file1.txt</span><br></pre></td></tr></table></figure>
<p>各个部分的含义如下：</p>
<ul>
<li>我们先介绍最开始的-，它表示文件类型，说明file1.txt是常规文件(如果是目录文件，则应显示d)。</li>
<li>随后有九个字符，为rw-r–r–，它们用于表示文件权限。这九个字符分为三组，rw-, r–, r–，分别对应拥有者(owner)，拥有组(owner group)和所有其他人(other)。回顾Linux开机启动，登录后，我会有一个用户身份和一个组身份, 相当于我的名片。第一组表示，如果我的名片上的用户身份证明我是该文件的拥有者，那么我就可以对该文件有读取(r)，写入(w)该文件的权限，但不拥有执行(-，如果拥有执行权限，则为x)该文件的权限。第二组表示，如果我的名片上的组身份证明我所在的组是该文件的拥有组的一员，那么我有从该文件读入的权限。第三组表示，如果我的名片显示我既不是拥有者，也不是拥有组的一员，那么我只有读入的权限。当我想要进行一个读取操作时，Linux会先看我是否是拥有者下文会进一步解释拥有者和拥有组。</li>
<li>后面的1是硬连接(hard link)数目(link count)。</li>
<li>之后的vamei表示用户vamei是文件的拥有者(owner)，文件的拥有者有权更改文件权限(比如改为rwxrwxrwx)。而后面的vamei文件的拥有组是组vamei。文件的拥有者和拥有组在文件创建时就附加在文件上(相当于给文件上锁，只有有合适名片的用户才能打开操作)。要注意，Linux有一个超级用户root (也叫做根用户)，该用户拥有所有的文件。</li>
<li>随后的8445表示文件大小，单位为字节(byte)。</li>
<li>Sep 8 07:33表示文件的上一次写入的时间(modification time)。实际上在文件附加信息中还包含有文件的上一次读取时间(access time)，没有显示出来。</li>
</ul>
<p><strong>软链接 (soft link, or symbolic link)</strong></p>
<p>如上讨论硬链接时说到的，软链接不会影响文件的link count。如果还记得windows系统的快捷方式的话，Linux的软链接(soft link，也叫做symbolic link)就是linux的快捷方式。软链接本质上是一个文件，它的文件类型是symbolic link。在这个文件中，包含有链接指向的文件的绝对路径。当你从这个文件读取数据时，linux会把你导向所指向的文件，然后从那个文件中读取（就好像你双击快捷方式的效果一样）。软链接可以方便的在任何地方建立，并指向任何一个绝对路径。</p>
<p>软链接本身也是一个文件，也可以执行文件所可以进行的操作。当我们对软链接操作时，要注意我们是对软链接本身操作，还是对软链接指向的目标操作。如果是后者，我们就说该操作跟随链接指引(follow the link)。</p>
<p>umask</p>
<p>当我们创建文件的时候，比如使用touch，它会尝试将新建文件创建为权限666，也就是rw-rw-rw-。但操作系统要参照权限mask来看是否真正将文件创建为666。权限mask表示操作系统不允许设置的权限位，比如说037(—-wxrwx)的权限mask意味着不允许设置设置group的wx位和other的rwx位。如果是这个权限mask的话，最终的文件权限是rw-r—– (group的w位和other的rw位被mask)。</p>
<p>我们可以通过</p>
<pre><code>$umask 022
</code></pre><p>的方式改变权限mask。</p>
<p><strong>总结</strong></p>
<p>计算机本质上是对数据进行处理的工具，而文件是数据储存的逻辑载体，所以了解Linux文件系统很重要。对于文件系统的了解要结合Linux的其他方面(比如用户管理)进行有机的学习。</p>
<p>文件权限，拥有者，拥有组，超级用户root</p>
<p>硬链接，软链接，follow the link</p>
<h2 id="Linux_u7684_u67B6_u6784"><a href="#Linux_u7684_u67B6_u6784" class="headerlink" title="Linux的架构"></a>Linux的架构</h2><p>我以下图为基础，说明Linux的架构(architecture)。(该图参考《Advanced Programming in Unix Environment》)</p>
<p><img src="/images/14590055441877.jpg" alt=""></p>
<p>最内层是硬件，最外层是用户常用的应用，比如说firefox浏览器，evolution查看邮件，一个计算流体模型等等。硬件是物质基础，而应用提供服务。但在两者之间，还要经过一番周折。</p>
<p>还记得Linux启动。Linux首先启动内核 (kernel)，内核是一段计算机程序，这个程序直接管理管理硬件，包括CPU、内存空间、硬盘接口、网络接口等等。所有的计算机操作都要通过内核传递给硬件。</p>
<p>为了方便调用内核，Linux将内核的功能接口制作成系统调用(system call)。系统调用看起来就像C语言的函数。你可以在程序中直接调用。Linux系统有两百多个这样的系统调用。用户不需要了解内核的复杂结构，就可以使用内核。系统调用是操作系统的最小功能单位。一个操作系统，以及基于操作系统的应用，都不可能实现超越系统调用的功能。一个系统调用函数就像是汉字的一个笔画。任何一个汉字都要由基本的笔画（点、横、撇等等）构成。我不能臆造笔画。</p>
<p>在命令行中输入<code>$man 2 syscalls</code>可以查看所有的系统调用。你也可以通过<code>$man 2 read</code>来查看系统调用read()的说明。在这两个命令中的2都表示我们要在2类(系统调用类)中查询 (具体各个类是什么可以通过<code>$man man</code>看到)。</p>
<p>系统调用提供的功能非常基础，所以使用起来很麻烦。一个简单的给变量分配内存空间的操作，就需要动用多个系统调用。Linux定义一些库函数(library routine)来将系统调用组合成某些常用的功能。上面的分配内存的操作，可以定义成一个库函数(像malloc()这样的函数)。再比如说，在读取文件的时候，系统调用要求我们设置好所需要的缓冲。我可以使用Standard IO库中的读取函数。这个读取函数既负责设置缓冲，又负责使用读取的系统调用函数。使用库函数对于机器来说并没有效率上的优势，但可以把程序员从细节中解救出来。库函数就像是汉字的偏旁部首，它由笔画组成，但使用偏旁部首更容易组成字，比如”铁”。当然，你也完全可以不使用库函数，而直接调用系统函数，就像“人”字一样，不用偏旁部首。</p>
<p>(实际上，一个操作系统要称得上是UNIX系统，必须要拥有一些库函数，比如ISO C标准库，POSIX标准等。)</p>
<p>shell是一个特殊的应用。很多用户将它称为命令行。shell是一个命令解释器(interpreter)，当我们输入“ls -l”的时候，它将此字符串解释为</p>
<ol>
<li>在默认路径找到该文件(/bin/ls)，</li>
<li>执行该文件，并附带参数”-l”。</li>
</ol>
<p>我之前用&gt;表示重新定向，用|表示管道，也是通过shell解释&amp;或者|的含义。Shell接着通过系统调，用指挥内核，实现具体的重定向或者管道。在没有图形界面之前，shell充当了用户的界面，当用户要运行某些应用时，通过shell输入命令，来运行程序。shell是可编程的，它可以执行符合shell语法的文本。这样的文本叫做shell脚本(script)。可以在架构图中看到，shell下通系统调用，上通各种应用，同时还有许多自身的小工具可以使用。Shell脚本可以在寥寥数行中，实现复杂的功能。</p>
<p>UNIX的一条哲学是让每个程序尽量独立的做好一个小的功能。而shell充当了这些小功能之间的”胶水”，让不同程序能够以一个清晰的接口(文本流)协同工作，从而增强各个程序的功能。这也是Linux老鸟鼓励新手多用shell，少用图形化界面的原因之一。</p>
<p>(shell也有很多种，最常见的是bash, 另外还有sh, csh, tcsh, ksh。它们出现的年代不同，所支持的功能也有差异。)</p>
<p>一个shell对应一个终端 (terminal)。曾经来说，终端是一个硬件设备，用来输入并显示输出。如今，由于图形化界面的普及，终端往往就像上图一样，是一个图形化的窗口。你可以通过这个窗口输入或者输出文本。这个文本直接传递给shell进行分析解释，然后执行。</p>
<p>最后，我们进入一般的应用。应用是一个程序，它可以</p>
<ol>
<li>直接调用系统函数</li>
<li>调用库函数</li>
<li>运行shell脚本</li>
</ol>
<p>这些应用可以由多种语言开发。最常见的是C语言。</p>
<p><strong>总结</strong></p>
<p>Linux利用内核实现软硬件的对话。</p>
<p>通过系统调用的这个接口，Linux将上层的应用与下层的内核分离，隐藏了底层的复杂性，也提高了上层应用的可移植性。</p>
<p>库函数利用系统调用创造出模块化的功能，</p>
<p>Shell则提供了一个用户界面，并让我们可以利用shell的语法编写脚本，以整合程序。</p>
<h2 id="Linux_u547D_u4EE4_u884C_u4E0E_u547D_u4EE4"><a href="#Linux_u547D_u4EE4_u884C_u4E0E_u547D_u4EE4" class="headerlink" title="Linux命令行与命令"></a>Linux命令行与命令</h2><p>Linux的命令是很重要的工具，也往往是初学者最大的瓶颈。有朋友用了很长时间的Linux图形界面，基本不使用命令行输入命令执行，所以装的Linux最终成了摆设。这里总结一些命令行下常使用的命令，希望能有用。</p>
<p><strong>什么是命令</strong></p>
<p>我们通常所说的Linux命令行是运行在终端(terminal)的shell (阅读Linux架构以了解什么是shell以及它在Linux系统中的位置)</p>
<p>所谓的命令，是我们在命令行输入的一串字符。shell负责理解并执行这些字符串。shell命令可以分为如下几类 1）可执行文件(executable file) 2）shell内建函数(built-in function) 3) 别名(alias)。可执行文件为经过编译的程序文件，我们输入这些文件的路径来让shell运行，比如<code>$/bin/ls</code>。有些可执行文件被放在特殊的目录(默认路径)下面，从而使得操作系统可以通过文件名找到，而不用总是输入该文件的绝对路径(absolute path)。比如说<code>$ls</code>(实际上，shell自动帮我们补齐ls的路径)。随后，这些可执行文件中包含的程序运行，并成为进程。shell的内建函数与上面类似，只是其对应的程序被保存在shell的内部。别名是指我们给以上两种命令起一个简称，以便减少输入的工作量。</p>
<p>我们可以通过type命令来了解命令的类型：</p>
<ul>
<li><code>$type ls</code></li>
<li><code>$type cd</code></li>
</ul>
<p>命令的构成</p>
<p>当我们在命令行输入命令的时候，往往由以下方式构成:</p>
<pre><code>$ls -l /home
</code></pre><p>整个一行命令由空格分为三个部分（注意, $是自动出现的提示符，有时还会在此之前出现计算机名）。第一个为命令的名字ls，这个命令ls的功能是列出目录中所有文件，第二个-l是关键字，它告诉ls要列出每个文件的详细信息，第三个/home为参数，表示我所要列出的目录是/home。实际上关键字是一种特殊的参数，大部分情况下用来开关程序的某些特殊功能 （用来选择做出的是拿铁咖啡还是黑咖啡）。而参数是用来传递给程序的一般的变量。ls经过处理之后，将在终端输出/home下面包含的各个文件名 (该文件系统见:<a href="http://www.cnblogs.com/vamei/archive/2012/09/09/2676792.html)：" target="_blank" rel="external">http://www.cnblogs.com/vamei/archive/2012/09/09/2676792.html)：</a></p>
<pre><code>vamei another
</code></pre><p>关键字和参数可以不止有一个，比如:</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ls</span> -l -a /home /bin</span><br><span class="line"><span class="variable">$ls</span> -la /home /bin</span><br><span class="line">(上面两个命令等价)</span><br></pre></td></tr></table></figure>
<p>列出/home和/bin目录下的文件，-a表示列出全部文件(即使是隐藏文件也要列出)， -l表示列出每个文件的详细信息。</p>
<p>(如果命令没有被放在默认路径中，你也可以输入绝对路径来执行)</p>
<p>回忆Linux文件管理背景知识，我们知道，每个文件能否被执行要根据用户所拥有的权限。命令实际上是可执行文件，也是如此。系统相关的命令，或者某个命令中的定义的操作，往往会要求超级用户root的身份才能使用。如果你是用户vamei，那么你就无法使用这些命令。但以root的身份登录是个糟糕的想法。为了解决这一矛盾，你可以以vamei的身份登录，但在执行命令之前加上sudo， 以便临时以root的身份执行某条命令。比如<code>$sudo ls .</code></p>
<p>对于大多数的shell来说，都有命令补齐的功能。当你在<code>$</code>的后面输入命令的一部分时，比如rmdir的rmd的时候，按Tab键，Linux会帮你打剩下的字符，补充成为rmdir。不止是命令，如果你输入的是文件名，Linux也可以帮你补齐。比如说, <code>$ls a.txt</code>。当你输入到<code>$ls a.t</code>的时候，按Tab键，Linux会帮你补齐该文件名，成为<code>$ls a.txt</code>。当然，这样做的前提是你输入到rmd的时候，默认路径下能和它相符的命令只有一个rmdir了。如果有多个相符的命令，连按两下Tab，Linux会显示所有的相符的命令。</p>
<p><strong>多使用命令的好处</strong></p>
<p>实际上，许多命令的功能都可以通过图形化界面来实现，学习这些命令的意义在哪里呢？</p>
<p>在UNIX发育的大部分历史上，用户都是通过shell来工作的。大部分命令都已经经过了几十年的发展和改良，功能强大，性能稳定。Linux继承自UNIX，自然也是如此。此外Linux的图形化界面并不好，并不是所有的命令都有对应的图形按钮。更别说在图形化界面崩溃的情况下，你就要靠shell输入命令来恢复计算机了。</p>
<p>命令本身是一个函数 (function)，是一个小的功能模块。当我们想要让计算机做很复杂的事情 (比如说: 在晚上12:00下载某个页面的所有链接，然后复制到移动硬盘)的时候，不断地去按各个图形化按钮并不是个很聪明的事情 (1. 要点很多下，2. 必须等到12:00)。我们通常是通过shell编程来实现这样一些复杂任务，这时，就可以把命令作为函数，嵌入到我们的shell程序中, 从而让不同命令协同工作 (比如使用date来查询时间，再根据时间来使用wget下载等等)。</p>
<p><strong>如何了解一个陌生的命令</strong>？</p>
<p>有一些命令可以用来了解某个命令本身的情况，比如这个命令的绝对路径。</p>
<pre><code>$which ls
</code></pre><p>which 在默认路径中搜索命令，返回该命令的绝对路径。</p>
<pre><code>$whereis ls
</code></pre><p>whereis 在相对比较大的范围搜索命令，返回该命令的绝对路径。</p>
<pre><code>$whatis ls
</code></pre><p>whatis 用很简短的一句话来介绍命令。</p>
<pre><code>$man ls
</code></pre><p>man 查询简明的帮助手册。对于大部分的Linux自带的命令来说，当作者编写它的时候，都会带有一个帮助文档，告诉用户怎么使用这个命令。</p>
<p>(man可以说是我们了解Linux最好的百科全书，它不但可以告诉你Linux自带的命令的功能，还可以查询Linux的系统文件和系统调用。如果想要深入学习Linux，就必须要懂得如何用man来查询相关文档。)</p>
<pre><code>$info ls
</code></pre><p>info 查询更详细的帮助信息</p>
<p>此外，在shell中，你还可以用向上箭头来查看之前输入运行的命令。</p>
<p>你也可以用</p>
<pre><code>$history
</code></pre><p>来查询之前在命令行的操作。</p>
<p>当一个命令运行时，你中途想要停止它时，可以用Ctrl + c。如果你只是想暂时停止，使用Ctrl + z。具体机制与信号(signal)有关，我们将在以后介绍</p>
<p><strong>总结</strong></p>
<p>命令行: 使用shell解释输入的字符串，以运行程序</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span></span><br><span class="line">sudo</span><br><span class="line"><span class="keyword">which</span>, whereis, whatis, <span class="keyword">man</span>, info</span><br></pre></td></tr></table></figure>
<p>使用Tab自动补齐，向上箭头查询历史，history</p>
<pre><code>Ctrl + c, Ctrl + z
</code></pre><h2 id="Linux_u6587_u4EF6_u7BA1_u7406_u76F8_u5173_u547D_u4EE4"><a href="#Linux_u6587_u4EF6_u7BA1_u7406_u76F8_u5173_u547D_u4EE4" class="headerlink" title="Linux文件管理相关命令"></a>Linux文件管理相关命令</h2><p>在了解了Linux文件管理背景知识之后， 我们可以学习一些命令来管理我们的文件。</p>
<p><strong>文件操作相关</strong></p>
<p>有一些命令可以帮助我们”修剪”之前看到的文件树。</p>
<pre><code>$touch a.txt
</code></pre><p>如果a.txt不存在，生成一个新的空文档a.txt。如果a.txt存在，那么只更改该文档的时间信息。(这个命令实际上用得并不广泛，但可以帮我们创建一个空文件来实验下面操作)</p>
<pre><code>$ls .
</code></pre><p>是list的简写，列出当前目录下的所有文件名</p>
<pre><code>$ls -l a.txt
</code></pre><p>列出文件的详细信息</p>
<pre><code>$cp a.txt b.txt 
</code></pre><p>cp是copy的简写，用来复制文件。在工作目录下，将a.txt复制到文件b.txt</p>
<pre><code>$cp a.txt ..
</code></pre><p>将a.txt复制到父目录的a.txt</p>
<pre><code>$mv a.txt c.txt
</code></pre><p>mv是move的简写，用来移动文件。将a.txt移动成为c.txt (相当于重命名rename)</p>
<pre><code>$mv c.txt /home/vamei
</code></pre><p>将c.txt移动到/home/vamei目录</p>
<pre><code>$rm a.txt
</code></pre><p>rm是remove的缩写，用于删除文件。删除a.txt</p>
<pre><code>$rm -r /home/vamei 
</code></pre><p>删除从/home/vamei向下的整个子文件系统。-r表示recursive， 是指重复删除的操作，/home/vamei文件夹为空，然后删除/home/vamei文件夹本身。</p>
<p>(程序员总是对这个命令很感兴趣,   <code>$rm -rf /</code>   它会删除整个文件树。f的目的是告诉rm放心干，不用再确认了…… 一般情况下，应该没有人会用这个命令。)</p>
<pre><code>$mkdir /home/vamei/good
</code></pre><p>创建一个新的目录</p>
<pre><code>$rmdir /home/vamei/good
</code></pre><p>删除一个空的目录</p>
<p><strong>文件权限相关</strong></p>
<pre><code>$chmod 755 a.txt
</code></pre><p>(你必须是文件a.txt的拥有者才能运行此命令。或者以$sudo chmod 755 a.txt的方式，以超级用户的身份运行该命令。)</p>
<p>change mode 改变a.txt的读、写以及执行权限。还记得每个文件都有九位的读写执行权限(参看 Linux文件管理背景知识)，分为三组，分别对应拥有者(owner)，拥有组(owner group)中的用户和所有其他用户(other)。在这里，我们也有三个数字，755，对应三个组。7被分配给拥有者，5被分配给拥有组，最后一个5分配给其它用户。Linux规定: 4为有读取的权利，2为有写入的权利，1为有执行的权利。我们看到的7实际上是4 + 2 + 1，表示拥有者有读、写、执行三项权利。(想想5 意味着什么)</p>
<p>这时，运行<code>$ls -l a.txt</code>, 你应该看到九位的权限变成了rwxr-xr-x。根据自己的需要，你可以用比如444, 744代替755，来让文件有不同的权限。</p>
<pre><code>$sudo chown root a.txt
</code></pre><p>change owner 改变文件的拥有者为root用户。这个命令需要有超级用户权限才能执行，所以我们在命令之前加上sudo。</p>
<pre><code>$sudo chgrp root a.txt
</code></pre><p>change group 改变文件的拥有组为root组</p>
<p><strong>Linux文件名通配表达式</strong></p>
<p>(wild card, 也叫filename pattern matching)</p>
<p>之前所讲的命令，比如ls, mv, cp都可以接收多个参数，比如:</p>
<pre><code>$ls -l a.txt b.txt c.txt
</code></pre><p>就可以列出这三个文件的所有信息。</p>
<p>有时候，我们想列出工作目录下所有的以.txt结尾的文件的信息，可以用下面的方式:</p>
<pre><code>$ls -l *.txt
</code></pre><p><code>*.txt</code>的写法就运用了Linux通配表达式。它与正则表达式相类似，但语法有所不同。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Filename Pattern Matching</th>
<th style="text-align:center">对应含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">任意多个任意字符</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">任意一个字符</td>
</tr>
<tr>
<td style="text-align:center">[kl]</td>
<td style="text-align:center">字符k或者字符l</td>
</tr>
<tr>
<td style="text-align:center">[0-4]</td>
<td style="text-align:center">数字0到4字符中的一个</td>
</tr>
<tr>
<td style="text-align:center">[b-e]</td>
<td style="text-align:center">b到e字符中的一个</td>
</tr>
<tr>
<td style="text-align:center">[^mnp]</td>
<td style="text-align:center">一个字符，这个字符不是m,n,p</td>
</tr>
</tbody>
</table>
<p>Linux会找到符合表达式的文件名，然后用这些文件名作为参数传递给命令。注意，当使用rm的时候，要格外小心。下面两个命令，只相差一个空格，但效果大为不同:</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$rm</span> * .txt</span><br><span class="line"><span class="variable">$rm</span> *.txt</span><br></pre></td></tr></table></figure>
<p>第一个命令会删除当前目录下所有文件！</p>
<p><strong>总结</strong></p>
<p>touch, ls, mv, cp, rm, mkdir, rmdir</p>
<p>chmod, chown, chgrp</p>
<p>wild card</p>
<h2 id="Linux_u6587_u672C_u6D41"><a href="#Linux_u6587_u672C_u6D41" class="headerlink" title="Linux文本流"></a>Linux文本流</h2><p><strong>文本流</strong></p>
<p>文件用于数据的存储，相当于一个个存储数据的房子。我们之前说，所谓的数据是0或者1的序列，但严格来说，Linux以字节(byte)来作为数据的单位，也就是说这个序列每八位(bit)为一个单位(八位二进制对应的十进制范围为0到255)。使用ASCII编码，可以将这样一个字节转换成为字符。所以，在Linux中，我们所说的数据，完全可以用字符表达出来，也就是说文本(text)的形式。</p>
<p>实际上，如果以bit为单位处理字符的话，机器会更容易读懂和传输，效率会更高。但为什么Linux依然以字节为单位进行处理呢？原因在于，相对于以bit为单位处理数据，以byte为单位可以更容易将数据转化为字符。相对于枯燥的0和1，字符更容易被人读懂 (human readable)。然而，并不是所有的数据都是设计来让人读懂的，比如可执行文件包含的各种字符对于人来说并没有什么意义 (因为可执行文件是为了让机器读懂的)。但Linux依然以字节为单位处理所有文件，这是为了让所有文件能够共用一套接口 (virtual file system)，从而减少Linux设计的复杂度。</p>
<p>(“everything is a file”是通常所流传的UNIX设计的哲学之一，但Linus对此作出纠正，改为”everything is a stream of bytes”。)</p>
<p>然而，数据不是在找到了自己的房子(file)之后就永远的定居下来。它往往要被读入到内存 (就像是到办公室上班)，或者被传送到外部设备(好像去酒店休假)，或者搬到别的房子中。在这样的搬迁过程中，数据像是一个个排着队走路的人流，我们叫它文本流(text stream，或者byte stream)。然而，计算机不同设备之间的连接方法差异很大，从内存到文件的连接像是爬山，从内存到外设像是游过一条河。为此，Linux还定义了流 (stream)，以此作为修建连接各处的公路的标准。Stream的好处在于，无论你是从内存到外设，还是从内存到文件，所有的公路都是相同的 (至于公路下面是石头还是土地，都可以不用操心)。</p>
<p>我们再回味一下“everything is a stream of bytes”这句话。信息包含在文本流中，不断在计算机的各个组件之间流动，不断地接受计算机的加工，最终成为用户所需要的某种服务。</p>
<p>标准输入，标准输出，标准错误与重新定向</p>
<p>当Linux执行一个程序的时候，会自动打开三个流，标准输入(standard input)，标准输出(standard output)，标准错误(standard error)。比如说你打开命令行的时候，默认情况下，命令行的标准输入连接到键盘，标准输出和标准错误都连接到屏幕。对于一个程序来说，尽管它总会打开这三个流，但它会根据需要使用，并不是一定要使用。</p>
<p>想象一下敲击一个</p>
<pre><code>$ls
</code></pre><p>键盘敲击的文本流(“ls\n”，\n是回车时输入的字符，表示换行)命令行 (命令行实际上也是一个程序)。命令行随后调用/bin/ls得到结果(“a.txt”)，最后这个输出的文本流(“a.txt”)流到屏幕，显示出来，比如说：</p>
<pre><code>a.txt
</code></pre><p>假设说我们不想让文本流流到屏幕，而是流到另一个文件，我们可以采用重新定向(redirect)的机制。</p>
<pre><code>$ls &gt; a.txt
</code></pre><p>重新定向标准输出。这里的&gt;就是提醒命令行，让它知道我现在想变换文本流的方向了，我们不让标准输出输出到屏幕，而是要到a.txt这个文件 (好像火车轨道换轨)。此时，计算机会新建一个a.txt的文件，并将命令行的标准输出指向这个文件。</p>
<p>有另一个符号:</p>
<pre><code>$ls &gt;&gt; a.txt
</code></pre><p>这里&gt;&gt;的作用也是重新定向标准输出。如果a.txt已经存在的话，ls产生的文本流会附加在a.txt的结尾，而不会像&gt;那样每次都新建a.txt。</p>
<p>我们下面介绍命令echo：</p>
<pre><code>$echo IamVamei
</code></pre><p>echo的作用是将文本流导向标准输出。在这里，echo的作用就是将IamVamei输出到屏幕上。如果是</p>
<pre><code>$echo IamVamei &gt; a.txt
</code></pre><p>a.txt中就会有IamVamei这个文本。</p>
<p>我们也可以用&lt;符号来改变标准输入。比如cat命令，它可以从标准输入读入文本流，并输出到标准输出:</p>
<pre><code>$cat &lt; a.txt
</code></pre><p>我们将cat标准输入指向a.txt，文本会从文件流到cat，然后再输出到屏幕上。当然，我们还可以同时重新定向标准输出:</p>
<pre><code>$cat &lt; a.txt &gt; b.txt
</code></pre><p>这样，a.txt的内容就复制到了b.txt中。</p>
<p>我们还可以使用&gt;&amp;来同时重新定向标准输出和标准错误。假设我们并没有一个目录void。那么</p>
<pre><code>$cd void &gt; a.txt
</code></pre><p>会在屏幕上返回错误信息。因为此时标准错误依然指向屏幕。当我们使用:</p>
<pre><code>$cd void &gt;&amp; a.txt
</code></pre><p>错误信息被导向a.txt。</p>
<p>如果只想重新定向标准错误，可以使用2&gt;:</p>
<pre><code>$cd void 2&gt; a.txt &gt; b.txt
</code></pre><p>标准错误对应的总是2号，所以有以上写法。标准错误输出到a.txt，标准输出输出到b.txt。</p>
<p><strong>管道 (pipe)</strong></p>
<p>理解了以上的内容之后，管道的概念就易如反掌。管道可以将一个命令的输出导向另一个命令的输入，从而让两个(或者更多命令)像流水线一样连续工作，不断地处理文本流。在命令行中，我们用|表示管道：</p>
<pre><code>$cat &lt; a.txt | wc 
</code></pre><p>wc命令代表word count，用于统计文本中的行、词以及字符的总数。a.txt中的文本先流到cat，然后从cat的标准输出流到wc的标准输入，从而让wc知道自己要处理的是a.txt这个字符串。</p>
<p>Linux的各个命令实际上高度专业化，并尽量相互独立。每一个都只专注于一个小的功能。但通过pipe，我们可以将这些功能合在一起，实现一些复杂的目的。</p>
<p><strong>总结</strong></p>
<p>文本流，标准输入，标准输出，标准错误</p>
<p>cat, echo, wc</p>
<p><code>&gt;, &gt;&gt;, &lt;, |</code></p>
<h2 id="Linux_u8FDB_u7A0B_u57FA_u7840"><a href="#Linux_u8FDB_u7A0B_u57FA_u7840" class="headerlink" title="Linux进程基础"></a>Linux进程基础</h2><p>计算机实际上可以做的事情实质上非常简单，比如计算两个数的和，再比如在内存中寻找到某个地址等等。这些最基础的计算机动作被称为指令 (instruction)。所谓的程序(program)，就是这样一系列指令的所构成的集合。通过程序，我们可以让计算机完成复杂的操作。程序大多数时候被存储为可执行的文件。这样一个可执行文件就像是一个菜谱，计算机可以按照菜谱作出可口的饭菜。</p>
<p>那么，程序和进程(process)的区别又是什么呢?</p>
<p>进程是程序的一个具体实现。只有食谱没什么用，我们总要按照食谱的指点真正一步步实行，才能做出菜肴。进程是执行程序的过程，类似于按照食谱，真正去做菜的过程。同一个程序可以执行多次，每次都可以在内存中开辟独立的空间来装载，从而产生多个进程。不同的进程还可以拥有各自独立的IO接口。</p>
<p>操作系统的一个重要功能就是为进程提供方便，比如说为进程分配内存空间，管理进程的相关信息等等，就好像是为我们准备好了一个精美的厨房。</p>
<p><strong>看一眼进程</strong></p>
<p>首先，我们可以使用<code>$ps</code>命令来查询正在运行的进程，比如<code>$ps -eo pid,comm,cmd</code>，下图为执行结果:</p>
<p>(-e表示列出全部进程，-o pid,comm,cmd表示我们需要PID，COMMAND，CMD信息)</p>
<p><img src="/images/14590055629919.jpg" alt=""></p>
<p>每一行代表了一个进程。每一行又分为三列。第一列PID(process IDentity)是一个整数，每一个进程都有一个唯一的PID来代表自己的身份，进程也可以根据PID来识别其他的进程。第二列COMMAND是这个进程的简称。第三列CMD是进程所对应的程序以及运行时所带的参数。</p>
<p>(第三列有一些由中括号[]括起来的。它们是kernel的一部分功能，被打扮成进程的样子以方便操作系统管理。我们不必考虑它们。)</p>
<p>我们看第一行，PID为1，名字为init。这个进程是执行/bin/init这一文件(程序)生成的。当Linux启动的时候，init是系统创建的第一个进程，这一进程会一直存在，直到我们关闭计算机。这一进程有特殊的重要性，我们会不断提到它。</p>
<p><strong>如何创建一个进程</strong></p>
<p>实际上，当计算机开机的时候，内核(kernel)只建立了一个init进程。Linux kernel并不提供直接建立新进程的系统调用。剩下的所有进程都是init进程通过fork机制建立的。新的进程要通过老的进程复制自身得到，这就是fork。fork是一个系统调用。进程存活于内存中。每个进程都在内存中分配有属于自己的一片空间 (address space)。当进程fork的时候，Linux在内存中开辟出一片新的内存空间给新的进程，并将老的进程空间中的内容复制到新的空间中，此后两个进程同时运行。</p>
<p>老进程成为新进程的父进程(parent process)，而相应的，新进程就是老的进程的子进程(child process)。一个进程除了有一个PID之外，还会有一个PPID(parent PID)来存储的父进程PID。如果我们循着PPID不断向上追溯的话，总会发现其源头是init进程。所以说，所有的进程也构成一个以init为根的树状结构。</p>
<p>如下，我们查询当前shell下的进程：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@vamei:~# ps -o pid,ppid,cmd&#10;  PID  PPID CMD&#10;16935  3101 sudo -i&#10;16939 16935 -bash&#10;23774 16939 ps -o pid,ppid,cmd</span><br></pre></td></tr></table></figure>
<p>我们可以看到，第二个进程bash是第一个进程sudo的子进程，而第三个进程ps是第二个进程的子进程。</p>
<p>还可以用$pstree命令来显示整个进程树：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init&#9472;&#9516;&#9472;NetworkManager&#9472;&#9516;&#9472;dhclient&#10;     &#9474;                &#9492;&#9472;2*[&#123;NetworkManager&#125;]&#10;     &#9500;&#9472;accounts-daemon&#9472;&#9472;&#9472;&#123;accounts-daemon&#125;&#10;     &#9500;&#9472;acpid&#10;     &#9500;&#9472;apache2&#9472;&#9516;&#9472;apache2&#10;     &#9474;         &#9492;&#9472;2*[apache2&#9472;&#9472;&#9472;26*[&#123;apache2&#125;]]&#10;     &#9500;&#9472;at-spi-bus-laun&#9472;&#9472;&#9472;2*[&#123;at-spi-bus-laun&#125;]&#10;     &#9500;&#9472;atd&#10;     &#9500;&#9472;avahi-daemon&#9472;&#9472;&#9472;avahi-daemon&#10;     &#9500;&#9472;bluetoothd&#10;     &#9500;&#9472;colord&#9472;&#9472;&#9472;2*[&#123;colord&#125;]&#10;     &#9500;&#9472;console-kit-dae&#9472;&#9472;&#9472;64*[&#123;console-kit-dae&#125;]&#10;     &#9500;&#9472;cron&#10;     &#9500;&#9472;cupsd&#9472;&#9472;&#9472;2*[dbus]&#10;     &#9500;&#9472;2*[dbus-daemon]&#10;     &#9500;&#9472;dbus-launch&#10;     &#9500;&#9472;dconf-service&#9472;&#9472;&#9472;2*[&#123;dconf-service&#125;]&#10;     &#9500;&#9472;dropbox&#9472;&#9472;&#9472;15*[&#123;dropbox&#125;]&#10;     &#9500;&#9472;firefox&#9472;&#9472;&#9472;27*[&#123;firefox&#125;]&#10;     &#9500;&#9472;gconfd-2&#10;     &#9500;&#9472;geoclue-master&#10;     &#9500;&#9472;6*[getty]&#10;     &#9500;&#9472;gnome-keyring-d&#9472;&#9472;&#9472;7*[&#123;gnome-keyring-d&#125;]&#10;     &#9500;&#9472;gnome-terminal&#9472;&#9516;&#9472;bash&#10;     &#9474;                &#9500;&#9472;bash&#9472;&#9472;&#9472;pstree&#10;     &#9474;                &#9500;&#9472;gnome-pty-helpe&#10;     &#9474;                &#9500;&#9472;sh&#9472;&#9472;&#9472;R&#9472;&#9472;&#9472;&#123;R&#125;&#10;     &#9474;                &#9492;&#9472;3*[&#123;gnome-terminal&#125;]</span><br></pre></td></tr></table></figure>
<p>fork通常作为一个函数被调用。这个函数会有两次返回，将子进程的PID返回给父进程，0返回给子进程。实际上，子进程总可以查询自己的PPID来知道自己的父进程是谁，这样，一对父进程和子进程就可以随时查询对方。</p>
<p>通常在调用fork函数之后，程序会设计一个if选择结构。当PID等于0时，说明该进程为子进程，那么让它执行某些指令,比如说使用exec库函数(library function)读取另一个程序文件，并在当前的进程空间执行 (这实际上是我们使用fork的一大目的: 为某一程序创建进程)；而当PID为一个正整数时，说明为父进程，则执行另外一些指令。由此，就可以在子进程建立之后，让它执行与父进程不同的功能。</p>
<p><strong>子进程的终结(termination)</strong></p>
<p>当子进程终结时，它会通知父进程，并清空自己所占据的内存，并在kernel里留下自己的退出信息(exit code，如果顺利运行，为0；如果有错误或异常状况，为&gt;0的整数)。在这个信息里，会解释该进程为什么退出。父进程在得知子进程终结时，有责任对该子进程使用wait系统调用。这个wait函数能从kernel中取出子进程的退出信息，并清空该信息在kernel中所占据的空间。但是，如果父进程早于子进程终结，子进程就会成为一个孤儿(orphand)进程。孤儿进程会被过继给init进程，init进程也就成了该进程的父进程。init进程负责该子进程终结时调用wait函数。</p>
<p>当然，一个糟糕的程序也完全可能造成子进程的退出信息滞留在kernel中的状况（父进程不对子进程调用wait函数），这样的情况下，子进程成为僵尸（zombie）进程。当大量僵尸进程积累时，内存空间会被挤占。</p>
<p><strong>进程与线程(thread)</strong></p>
<p>尽管在UNIX中，进程与线程是有联系但不同的两个东西，但在Linux中，线程只是一种特殊的进程。多个线程之间可以共享内存空间和IO接口。所以，进程是Linux程序的唯一的实现方式。</p>
<p><strong>总结</strong></p>
<p>程序，进程，PID，内存空间</p>
<p>子进程，父进程，PPID，fork， wait</p>
<h2 id="Linux_u4FE1_u53F7_u57FA_u7840"><a href="#Linux_u4FE1_u53F7_u57FA_u7840" class="headerlink" title="Linux信号基础"></a>Linux信号基础</h2><p>Linux进程基础一文中已经提到，Linux以进程为单位来执行程序。我们可以将计算机看作一个大楼，内核(kernel)是大楼的管理员，进程是大楼的房客。每个进程拥有一个独立的房间(属于进程的内存空间)，而每个房间都是不允许该进程之外的人进入。这样，每个进程都只专注于自己干的事情，而不考虑其他进程，同时也不让别的进程看到自己的房间内部。这对于每个进程来说是一种保护机制。(想像一下几百个进程总是要干涉对方，那会有多么混乱，或者几百个进程相互偷窥……)</p>
<p>然而，在一些情况，我们需要打破封闭的房间，以便和进程交流信息。比如说，内核发现有一个进程在砸墙(硬件错误)，需要让进程意识到这样继续下去会毁了整个大楼。再比如说，我们想让多个进程之间合作。这样，我们就需要一定的通信方式。信号(signal)就是一种向进程传递信息的方式。我们可以将信号想象成大楼的管理员往房间的信箱里塞小纸条。随后进程取出小纸条，会根据纸条上的内容来采取一定的行动，比如灯坏了，提醒进程使用手电。(当然，也可以完全无视这张纸条，然而在失火这样紧急的状况下，无视信号不是个好的选择)。相对于其他的进程间通信方式(interprocess communication， 比如说pipe, shared memory)来说，信号所能传递的信息比较粗糙，只是一个整数。但正是由于传递的信息量少，信号也便于管理和使用。信号因此被经常地用于系统管理相关的任务，比如通知进程终结、中止或者恢复等等。</p>
<p>信号是由内核(kernel)管理的。信号的产生方式多种多样，它可以是内核自身产生的，比如出现硬件错误(比如出现分母为0的除法运算，或者出现segmentation fault)，内核需要通知某一进程；也可以是其它进程产生的，发送给内核，再由内核传递给目标进程。内核中针对每一个进程都有一个表存储相关信息(房间的信箱)。当内核需要将信号传递给某个进程时，就在该进程相对应的表中的适当位置写入信号(塞入纸条)，这样，就生成(generate)了信号。当该进程执行系统调用时，在系统调用完成后退出内核时，都会顺便查看信箱里的信息。如果有信号，进程会执行对应该信号的操作(signal action, 也叫做信号处理signal disposition)，此时叫做执行(deliver)信号。从信号的生成到信号的传递的时间，信号处于等待(pending)状态(纸条还没有被查看)。我们同样可以设计程序，让其生成的进程阻塞(block)某些信号，也就是让这些信号始终处于等待的状态，直到进程取消阻塞(unblock)或者无视信号。</p>
<p><strong>常见信号</strong></p>
<p>信号所传递的每一个整数都被赋予了特殊的意义，并有一个信号名对应该整数。常见的信号有SIGINT, SIGQUIT, SIGCONT, SIGTSTP, SIGALRM等。这些都是信号的名字。你可以通过</p>
<pre><code>$man 7 signal
</code></pre><p>来查阅更多的信号。</p>
<p>上面几个信号中，</p>
<ul>
<li><code>SIGINT</code>   当键盘按下CTRL+C从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是中断 (INTERRUPT) 该进程。</li>
<li><code>SIGQUIT</code>  当键盘按下CTRL+\从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是退出 (QUIT) 该进程。</li>
<li><code>SIGTSTP</code>  当键盘按下CTRL+Z从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是暂停 (STOP) 该进程。</li>
<li><code>SIGCONT</code>  用于通知暂停的进程继续。</li>
<li><code>SIGALRM</code>  起到定时器的作用，通常是程序在一定的时间之后才生成该信号。</li>
</ul>
<p><strong>在shell中使用信号</strong></p>
<p>下面我们实际应用一下信号。我们在shell中运行ping：</p>
<pre><code>$ping localhost
</code></pre><p>此时我们可以通过CTRL+Z来将SIGTSTP传递给该进程。shell中显示：</p>
<pre><code>[1]+  Stopped                 ping localhost
</code></pre><p>我们使用<code>$ps</code>来查询ping进程的PID (PID是ping进程的房间号), 在我的机器中为27397</p>
<p>我们可以在shell中通过$kill命令来向某个进程发出信号:</p>
<pre><code>$kill -SIGCONT  27397
</code></pre><p>来传递SIGCONT信号给ping进程。</p>
<p><strong>信号处理 (signal disposition)</strong></p>
<p>在上面的例子中，所有的信号都采取了对应信号的默认操作。但这并不绝对。当进程决定执行信号的时候，有下面几种可能：</p>
<ol>
<li>无视(ignore)信号，信号被清除，进程本身不采取任何特殊的操作</li>
<li>默认(default)操作。每个信号对应有一定的默认操作。比如上面SIGCONT用于继续进程。</li>
<li>自定义操作。也叫做获取 (catch) 信号。执行进程中预设的对应于该信号的操作。</li>
</ol>
<p>进程会采取哪种操作，要根据该进程的程序设计。特别是获取信号的情况，程序往往会设置一些比较长而复杂的操作(通常将这些操作放到一个函数中)。</p>
<p>信号常常被用于系统管理，所以它的内容相当庞杂。深入了解信号，需要一定的Linux环境编程知识。</p>
<p><strong>总结</strong></p>
<p>信号机制; generate, deliver, pending, blocking</p>
<p>signal action/dispositon; ignore, default action, catch signal</p>
<p><code>$kill</code></p>
<h2 id="Linux_u8FDB_u7A0B_u5173_u7CFB"><a href="#Linux_u8FDB_u7A0B_u5173_u7CFB" class="headerlink" title="Linux进程关系"></a>Linux进程关系</h2><p>Linux的进程相互之间有一定的关系。比如说，在Linux进程基础中，我们看到，每个进程都有父进程，而所有的进程以init进程为根，形成一个树状结构。我们在这里讲解进程组和会话，以便以更加丰富的方式了管理进程。</p>
<p><strong>进程组 (process group)</strong></p>
<p>每个进程都会属于一个进程组(process group)，每个进程组中可以包含多个进程。进程组会有一个进程组领导进程 (process group leader)，领导进程的PID (PID见Linux进程基础)成为进程组的ID (process group ID, PGID)，以识别进程组。</p>
<pre><code>$ps -o pid,pgid,ppid,comm | cat
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  PID  PGID  PPID COMMAND</span><br><span class="line"><span class="number">17763</span> <span class="number">17763</span> <span class="number">17751</span> bash</span><br><span class="line"><span class="number">18534</span> <span class="number">18534</span> <span class="number">17763</span> ps</span><br><span class="line"><span class="number">18535</span> <span class="number">18534</span> <span class="number">17763</span> cat</span><br></pre></td></tr></table></figure>
<p>PID为进程自身的ID，PGID为进程所在的进程组的ID， PPID为进程的父进程ID。从上面的结果，我们可以推测出如下关系：</p>
<p><img src="/images/14590055773563.jpg" alt=""></p>
<p>图中箭头表示父进程通过fork和exec机制产生子进程。ps和cat都是bash的子进程。进程组的领导进程的PID成为进程组ID。领导进程可以先终结。此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。</p>
<p>我们将一些进程归为进程组的一个重要原因是我们可以将信号发送给一个进程组。进程组中的所有进程都会收到该信号。我们会在下一部分深入讨论这一点。</p>
<p><strong>会话 (session)</strong></p>
<p>更进一步，在shell支持工作控制(job control)的前提下，多个进程组还可以构成一个会话 (session)。bash(Bourne-Again shell)支持工作控制，而sh(Bourne shell)并不支持。</p>
<p>会话是由其中的进程建立的，该进程叫做会话的领导进程(session leader)。会话领导进程的PID成为识别会话的SID(session ID)。会话中的每个进程组称为一个工作(job)。会话可以有一个进程组成为会话的前台工作(foreground)，而其他的进程组是后台工作(background)。每个会话可以连接一个控制终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。由终端产生的信号，比如CTRL+Z， CTRL+\，会传递到前台进程组。</p>
<p>会话的意义在于将多个工作囊括在一个终端，并取其中的一个工作作为前台，来直接接收该终端的输入输出以及终端信号。 其他工作在后台运行。</p>
<p>一个命令可以通过在末尾加上&amp;方式让它在后台运行:</p>
<pre><code>$ping localhost &gt; log &amp;
</code></pre><p>此时终端显示:</p>
<pre><code>[1] 10141
</code></pre><p>括号中的1表示工作号，而10141为PGID</p>
<p>我们通过如下方式查询更加详细的信息:</p>
<pre><code>$ps -o pid,pgid,ppid,sid,tty,comm
(tty表示控制终端）
</code></pre><p>信号可以通过kill</p>
<pre><code>$kill -SIGTERM -10141
</code></pre><p>或者</p>
<pre><code>$kill -SIGTERM %1
</code></pre><p>的方式来发送给工作组。上面的两个命令，一个是发送给PGID(通过在PGID前面加-来表示是一个PGID而不是PID)，一个是发送给工作1(%1)，两者等价。</p>
<p>一个工作可以通过$fg从后台工作变为前台工作:</p>
<pre><code>$cat &gt; log &amp;
$fg %1
</code></pre><p>当我们运行第一个命令后，由于工作在后台，我们无法对命令进行输入，直到我们将工作带入前台，才能向cat命令输入。在输入完成后，按下CTRL+D来通知shell输入结束。</p>
<p>进程组(工作)的概念较为简单易懂。而会话主要是针对一个终端建立的。当我们打开多个终端窗口时，实际上就创建了多个终端会话。每个会话都会有自己的前台工作和后台工作。这样，我们就为进程增加了管理和运行的层次。在没有图形化界面的时代，会话允许用户通过shell进行多层次的进程发起和管理。比如说，我可以通过shell发起多个后台工作，而此时标准输入输出并不被占据，我依然可以继续其它的工作。如今，图形化界面可以帮助我们解决这一需求，但工作组和会话机制依然在Linux的许多地方应用。</p>
<p><strong>总结</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process group, pgid</span><br><span class="line">session, sid, job, forground, background</span><br><span class="line"><span class="built_in">fg</span>, <span class="built_in">kill</span> -pid, &amp;, %</span><br></pre></td></tr></table></figure>
<h2 id="Linux_u7528_u6237"><a href="#Linux_u7528_u6237" class="headerlink" title="Linux用户"></a>Linux用户</h2><p>Linux的用户在登录(login)之后，就带有一个用户身份(user ID, UID)和一个组身份(group ID, GID)。在Linux文件管理背景知识中，我们又看到，每个文件又有九位的权限说明，用来指明该文件允许哪些用户执行哪些操作(读、写或者执行)。</p>
<p><strong>进程权限</strong></p>
<p>但是，在Linux中，用户的指令是在进程的范围内进行的。当我们向对某个文件进行操作的时候，我们需要在进程中运行一个程序，在进程中对文件打开，并进行读、写或者执行的操作。因此，我们需要将用户的权限传递给进程，以便进程真正去执行操作。例如我们有一个文件a.txt, 文件中为一个字符串:</p>
<pre><code>Hello world!
</code></pre><p>我以用户Vamei的身份登录，并在shell中运行如下命令：</p>
<pre><code>$cat a.txt
</code></pre><p>整个运行过程以及文件读取如下:</p>
<p><img src="/images/14590055890788.jpg" alt=""></p>
<p>我们可以看到，整个过程中我们会有两个进程，一个是shell本身(2256)，一个是shell复制自身，再运行/bin/cat (9913)。图中的fork, exec, PID可参看Linux进程基础。第二个进程总共对文件系统进行了两次操作，一次是执行(x)文件/bin/cat，另外一次是读取(r)文件a.txt。使用<code>$ls -l</code> 查看这两个文件的权限:</p>
<pre><code>$ls -l /bin/cat
-rwxr-xr-x 1 root root 46764 Apr  1  2012 /bin/cat

$ls -l a.txt
-rw-rw-r-- 1 Vamei Vamei 14 Oct  7 09:14 a.txt
</code></pre><p>从上面可以看到(参考Linux文件管理背景知识)，/bin/cat让所有用户都享有执行的权利，而Vamei作为a.txt的拥有者，对a.txt享有读取的权利。</p>
<p>让我们进入更多的细节 (The devil is in the details)。在进行这两次操作的时候，尽管用户Vamei拥有相应的权限，但我们发现，真正做工作的是进程9913。我们要让这个进程得到相应的权限。实际上，每个进程会维护有如下6个ID：</p>
<p>真实身份: real UID,       real GID</p>
<p>有效身份: effective UID,  effective GID</p>
<p>存储身份: saved UID,      saved GID</p>
<p>其中，真实身份是我们登录使用的身份，有效身份是当该进程真正去操作文件时所检查的身份，存储身份较为特殊，我们等一下再深入。当进程fork的时候，真实身份和有效身份都会复制给子进程。大部分情况下，真实身份和有效身份都相同。当Linux完成开机启动之后，init进程会执行一个login的子进程。我们将用户名和密码传递给login子进程。login在查询了/etc/passwd和/etc/shadow，并确定了其合法性之后，运行(利用exec)一个shell进程，shell进程真实身份被设置成为该用户的身份。由于此后fork此shell进程的子进程都会继承真实身份，所以该真实身份会持续下去，直到我们登出并以其他身份再次登录(当我们使用su成为root的时候，实际上就是以root身份再次登录，此后真实身份成为root)。</p>
<p><strong>最小权限原则</strong></p>
<p>每个进程为什么不简单地只维护真实身份，却选择费尽麻烦地去维护有效身份和存储身份呢？这牵涉到Linux的“最小特权”(least priviledge)的原则。Linux通常希望进程只拥有足够完成其工作的特权，而不希望赋予更多的特权给它。从设计上来说，最简单的是赋予每个进程以super user的特权，这样进程就可以想做什么做什么。然而，这对于系统来说是一个巨大的安全漏洞，特别是在多用户环境下，如果每个用户都享有无限制的特权，就很容易破坏其他用户的文件或者系统本身。“最小特权”就是收缩进程所享有的特权，以防进程滥用特权。</p>
<p>然而，进程的不同阶段可能需要不同的特权。比如一个进程最开始的有效身份是真实身份，但运行到中间的时候，需要以其他的用户身份读入某些配置文件，然后再进行其他的操作。为了防止其他的用户身份被滥用，我们需要在操作之前，让进程的有效身份变更回来成为真实身份。这样，进程需要在两个身份之间变化。</p>
<p>存储身份就是真实身份之外的另一个身份。当我们将一个程序文件执行成为进程的时候，该程序文件的拥有者(owner)和拥有组(owner group)可以被，存储成为进程的存储身份。在随后进程的运行过程中，进程就将可以选择将真实身份或者存储身份复制到有效身份，以拥有真实身份或者存储身份的权限。并不是所有的程序文件在执行的过程都设置存储身份的。需要这么做的程序文件会在其九位(bit)权限的执行位的x改为s。这时，这一位(bit)叫做set UID bit或者set GID bit。</p>
<pre><code>$ls -l /usr/bin/uuidd
-rwsr-sr-x 1 libuuid libuuid 17976 Mar 30  2012 /usr/sbin/uuidd
</code></pre><p>当我以root(UID), root(GID)的真实身份运行这个程序的时候，由于拥有者(owner)有s位的设定，所以saved UID被设置成为libuuid，saved GID被设置成为libuuid。这样，uuidd的进程就可以在两个身份之间切换。</p>
<p>我们通常使用chmod来修改set-UID bit和set-GID bit:</p>
<pre><code>$chmod 4700 file
</code></pre><p>我们看到，这里的chmod后面不再只是三位的数字。最前面一位用于处理set-UID bit/set-GID bit，它可以被设置成为4/2/1以及或者上面数字的和。4表示为set UID bit, 2表示为set GID bit，1表示为sticky bit (暂时不介绍)。必须要先有x位的基础上，才能设置s位。</p>
<p>作为一个Linux用户来说，我们并不需要特别关心上面的机制。但是，当我们去编写一个Linux应用程序的时候，就要注意在程序中实现以上切换(有必要的前提下)，以便让我们的程序符合”最小权限”的原则，不给系统留下可能的安全隐患</p>
<h2 id="Linux_u4ECE_u7A0B_u5E8F_u5230_u8FDB_u7A0B"><a href="#Linux_u4ECE_u7A0B_u5E8F_u5230_u8FDB_u7A0B" class="headerlink" title="Linux从程序到进程"></a>Linux从程序到进程</h2><p>计算机如何执行进程呢？这是计算机运行的核心问题。即使已经编写好程序，但程序是死的。只有活的进程才能产出。我们已经从Linux进程基础中了解了进程。现在我们看一下从程序到进程的漫漫征程。</p>
<p><strong>一段程序</strong></p>
<p>下面是一个简单的C程序，假设该程序已经编译好</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> glob=<span class="number">0</span>;                                             <span class="comment">/*global variable*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> main1=<span class="number">5</span>;                                          <span class="comment">/*local variable of main()*/</span></span><br><span class="line">  <span class="keyword">int</span> main2;                                            <span class="comment">/*local variable of main()*/</span></span><br><span class="line">  main2 = inner(main1);                                 <span class="comment">/* call inner() function */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"From Main: glob: %d \n"</span>, glob);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"From Main: main2: %d \n"</span>, main2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inner</span><span class="params">(<span class="keyword">int</span> inner1)</span> </span>&#123;                                 <span class="comment">/*inner1 is an argument, also local to inner()*/</span></span><br><span class="line">  <span class="keyword">int</span> inner2=<span class="number">10</span>;                                        <span class="comment">/*local variable of inner()*/</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"From inner: glob: %d \n"</span>, glob);</span><br><span class="line">  <span class="keyword">return</span>(inner1+inner2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(选取哪一个语言或者具体的语法并不是关键，大部分语言都可以写出类似上面的程序。在看Python教程的读者也可以利用Python的函数结构和print写一个类似的python程序。当然，还可以是C++，Java，Objective-C等等。选用C语言的原因是：它是为UNIX而生的语言。)</p>
<p>main()函数中调用了inner()函数。inner()中调用一次printf()以输出。最后，在main()中进行了两次printf()。</p>
<p>注意变量的作用范围。简单地说，变量可以分为全局变量和局部变量。在所有函数之外声明的变量为全局变量，比如glob，在任何时候都可以使用。在函数内定义的变量为局部变量，只能在该函数的作用域(range)内使用，比如说我们在inner()工作的时候不能使用main()函数中声明的main1变量，而在main()中我们无法使用inner()函数中声明的inner2变量。</p>
<p>不用太过在意这个程序的具体功能。要点是这个程序的运行过程。下图为该程序的运行过程，以及各个变量的作用范围：</p>
<p><img src="/images/14590056061703.jpg" alt=""></p>
<p><strong>进程空间</strong></p>
<p>为了进一步了解上面程序的运行，我们还需要知道，进程如何使用内存。当程序文件运行为进程时，进程在内存中获得空间。这个空间是进程自己的小屋子。</p>
<p>每个进程空间按照如下方式分为不同区域:</p>
<p><img src="/images/14590056162054.jpg" alt=""></p>
<p>Text区域用来储存指令(instruction)，说明每一步的操作。Global Data用于存放全局变量，栈(Stack)用于存放局部变量，堆(heap)用于存放动态变量 (dynamic variable. 程序利用malloc系统调用，直接从内存中为dynamic variable开辟空间)。Text和Global data在进程一开始的时候就确定了，并在整个进程中保持固定大小。</p>
<p>栈(Stack)以帧(stack frame)为单位。当程序调用函数的时候，比如main()函数中调用inner()函数，stack会向下增长一帧。帧中存储该函数的参数和局部变量，以及该函数的返回地址(return address)。此时，计算机将控制权从main()转移到inner()，inner()函数处于激活(active)状态。位于栈最下方的帧，和全局变量一起，构成了当前的环境(context)。激活函数可以从环境中调用需要的变量。典型的编程语言都只允许你使用位于stack最下方的帧 ，而不允许你调用其它的帧 (这也符合stack结构“先进后出”的特征。但也有一些语言允许你调用栈的其它部分，相当于允许你在运行inner()函数的时候调用main()中声明的局部变量，比如Pascal)。当函数又进一步调用另一个函数的时候，一个新的帧会继续增加到栈的下方，控制权转移到新的函数中。当激活函数返回的时候，会从栈中弹出(pop，读取并从栈中删除)该帧，并根据帧中记录的返回地址，将控制权交给返回地址所指向的指令(比如从inner()函数中返回，继续执行main()中赋值给main2的操作)。</p>
<p>下图是栈在运行过程中的变化。箭头表示栈的增长方向。每个方块代表一帧。开始的时候我们有一个为main()服务的帧，随着调用inner()，我们为inner()增加一个帧。在inner()返回时，我们再次只有main()的帧，直到最后main()返回，其返回地址为空，所以进程结束。</p>
<p><img src="/images/14590056276526.jpg" alt=""></p>
<p>在进程运行的过程中，通过调用和返回函数，控制权不断在函数间转移。进程可以在调用函数的时候，原函数的帧中保存有在我们离开时的状态，并为新的函数开辟所需的帧空间。在调用函数返回时，该函数的帧所占据的空间随着帧的弹出而清空。进程再次回到原函数的帧中保存的状态，并根据返回地址所指向的指令继续执行。上面过程不断继续，栈不断增长或减小，直到main()返回的时候，栈完全清空，进程结束。</p>
<p>当程序中使用malloc的时候，堆(heap)会向上增长，其增长的部分就成为malloc从内存中分配的空间。malloc开辟的空间会一直存在，直到我们用free系统调用来释放，或者进程结束。一个经典的错误是内存泄漏(memory leakage), 就是指我们没有释放不再使用的堆空间，导致堆不断增长，而内存可用空间不断减少。</p>
<p>栈和堆的大小则会随着进程的运行增大或者变小。当栈和堆增长到两者相遇时候，也就是内存空间图中的蓝色区域(unused area)完全消失的时候，再无可用内存。进程会出现栈溢出(stack overflow)的错误，导致进程终止。在现代计算机中，内核一般会为进程分配足够多的蓝色区域，如果清理及时，栈溢出很容易避免。即便如此，内存负荷过大，依然可能出现栈溢出的情况。我们就需要增加物理内存了。</p>
<p>Stack overflow可以说是最出名的计算机错误了，所以才有IT网站(stackoverflow.com)以此为名。</p>
<p><strong>进程附加信息</strong></p>
<p>除了上面的信息之外，每个进程还要包括一些进程附加信息，包括PID，PPID，PGID(参考Linux进程基础以及Linux进程关系)等，用来说明进程的身份、进程关系以及其它统计信息。这些信息并不保存在进程的内存空间中。内核会为每个进程在内核自己的空间中分配一个变量(task_struct结构体)以保存上述信息。内核可以通过查看自己空间中的各个进程的附加信息就能知道进程的概况，而不用进入到进程自身的空间 (就好像我们可以通过门牌就可以知道房间的主人是谁一样，而不用打开房门)。每个进程的附加信息中有位置专门用于保存接收到的信号(正如我们在Linux信号基础中所说的“信箱”)。</p>
<p><strong>fork &amp; exec</strong></p>
<p>现在，我们可以更加深入地了解fork和exec(参考Linux进程基础)的机制了。当一个程序调用fork的时候，实际上就是将上面的内存空间，包括text, global data, heap和stack，又复制出来一个，构成一个新的进程，并在内核中为改进程创建新的附加信息 (比如新的PID，而PPID为原进程的PID)。此后，两个进程分别地继续运行下去。新的进程和原有进程有相同的运行状态(相同的变量值，相同的instructions…)。我们只能通过进程的附加信息来区分两者。</p>
<p>程序调用exec的时候，进程清空自身内存空间的text, global data, heap和stack，并根据新的程序文件重建text, global data, heap和stack (此时heap和stack大小都为0)，并开始运行。</p>
<p>(现代操作系统为了更有效率，改进了管理fork和exec的具体机制，但从逻辑上来说并没有差别。具体机制请参看Linux内核相关书籍)</p>
<p>这一篇写了整合了许多东西，所以有些长。这篇文章主要是概念性的，许多细节会根据语言和平台乃至于编译器的不同而有所变化，但大体上，以上的概念适用于所有的计算机进程(无论是Windows还是UNIX)。更加深入的内容，包括线程(thread)、进程间通信(IPC)等，都依赖于这里介绍的内容。</p>
<p><strong>总结</strong></p>
<p>函数，变量的作用范围，global/local/dynamic variables</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">global data, text,</span><br><span class="line"><span class="built_in">stack</span>, <span class="built_in">stack</span> frame, <span class="keyword">return</span> address, <span class="built_in">stack</span> overflow</span><br><span class="line">heap, <span class="built_in">malloc</span>, <span class="built_in">free</span>, memory leakage</span><br><span class="line">进程附加信息, task_struct</span><br><span class="line">fork &amp; exec</span><br></pre></td></tr></table></figure>
<h2 id="Linux_u591A_u7EBF_u7A0B_u4E0E_u540C_u6B65"><a href="#Linux_u591A_u7EBF_u7A0B_u4E0E_u540C_u6B65" class="headerlink" title="Linux多线程与同步"></a>Linux多线程与同步</h2><p>典型的UNIX系统都支持一个进程创建多个线程(thread)。在Linux进程基础中提到，Linux以进程为单位组织操作，Linux中的线程也都基于进程。尽管实现方式有异于其它的UNIX系统，但Linux的多线程在逻辑和使用上与真正的多线程并没有差别。</p>
<p><strong>多线程</strong></p>
<p>我们先来看一下什么是多线程。在Linux从程序到进程中，我们看到了一个程序在内存中的表示。这个程序的整个运行过程中，只有一个控制权的存在。当函数被调用的时候，该函数获得控制权，成为激活(active)函数，然后运行该函数中的指令。与此同时，其它的函数处于离场状态，并不运行。如下图所示:</p>
<p><img src="/images/14590056454901.jpg" alt=""></p>
<p>我们看到，各个方块之间由箭头连接。各个函数就像是连在一根线上一样，计算机像一条流水线一样执行各个函数中定义的操作。这样的一个程序叫做单线程程序。</p>
<p>多线程就是允许一个进程内存在多个控制权，以便让多个函数同时处于激活状态，从而让多个函数的操作同时运行。即使是单CPU的计算机，也可以通过不停地在不同线程的指令间切换，从而造成多线程同时运行的效果。如下图所示，就是一个多线程的流程:</p>
<p><img src="/images/14590056551293.jpg" alt=""></p>
<p>main()到func3()再到main()构成一个线程，此外func1()和func2()构成另外两个线程。操作系统一般都有一些系统调用来让你将一个函数运行成为一个新的线程。</p>
<p>回忆我们在Linux从程序到进程中提到的栈的功能和用途。一个栈，只有最下方的帧可被读写。相应的，也只有该帧对应的那个函数被激活，处于工作状态。为了实现多线程，我们必须绕开栈的限制。为此，创建一个新的线程时，我们为这个线程建一个新的栈。每个栈对应一个线程。当某个栈执行到全部弹出时，对应线程完成任务，并收工。所以，多线程的进程在内存中有多个栈。多个栈之间以一定的空白区域隔开，以备栈的增长。每个线程可调用自己栈最下方的帧中的参数和变量，并与其它线程共享内存中的Text，heap和global data区域。对应上面的例子，我们的进程空间中需要有3个栈。</p>
<p>(要注意的是，对于多线程来说，由于同一个进程空间中存在多个栈，任何一个空白区域被填满都会导致stack overflow的问题。)</p>
<p><strong>并发</strong></p>
<p>多线程相当于一个并发(concunrrency)系统。并发系统一般同时执行多个任务。如果多个任务可以共享资源，特别是同时写入某个变量的时候，就需要解决同步的问题。比如说，我们有一个多线程火车售票系统，用全局变量i存储剩余的票数。多个线程不断地卖票(i = i - 1)，直到剩余票数为0。所以每个都需要执行如下操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*mu is a global mutex*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;                        <span class="comment">/*infinite loop*/</span></span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) i = i -<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"no more tickets"</span>);</span><br><span class="line">      <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只有一个线程执行上面的程序的时候(相当于一个窗口售票)，则没有问题。但如果多个线程都执行上面的程序(相当于多个窗口售票), 我们就会出现问题。我们会看到，其根本原因在于同时发生的各个线程都可以对i读取和写入。</p>
<p>我们这里的if结构会给CPU两个指令, 一个是判断是否有剩余的票(i != 0), 一个是卖票 (i = i -1)。某个线程会先判断是否有票(比如说此时i为1)，但两个指令之间存在一个时间窗口，其它线程可能在此时间窗口内执行卖票操作(i = i -1)，导致该线程卖票的条件不再成立。但该线程由于已经执行过了判断指令，所以无从知道i发生了变化，所以继续执行卖票指令，以至于卖出不存在的票 (i成为负数)。对于一个真实的售票系统来说，这将成为一个严重的错误 (售出了过多的票，火车爆满)。</p>
<p>在并发情况下，指令执行的先后顺序由内核决定。同一个线程内部，指令按照先后顺序执行，但不同线程之间的指令很难说清除哪一个会先执行。如果运行的结果依赖于不同线程执行的先后的话，那么就会造成竞争条件(race condition)，在这样的状况下，计算机的结果很难预知。我们应该尽量避免竞争条件的形成。最常见的解决竞争条件的方法是将原先分离的两个指令构成不可分隔的一个原子操作(atomic operation)，而其它任务不能插入到原子操作中。</p>
<p><strong>多线程同步</strong></p>
<p>对于多线程程序来说，同步(synchronization)是指在一定的时间内只允许某一个线程访问某个资源 。而在此时间内，不允许其它的线程访问该资源。我们可以通过互斥锁(mutex)，条件变量(condition variable)和读写锁(reader-writer lock)来同步资源。</p>
<p><strong>1) 互斥锁</strong></p>
<p>互斥锁是一个特殊的变量，它有锁上(lock)和打开(unlock)两个状态。互斥锁一般被设置成全局变量。打开的互斥锁可以由某个线程获得。一旦获得，这个互斥锁会锁上，此后只有该线程有权打开。其它想要获得互斥锁的线程，会等待直到互斥锁再次打开的时候。我们可以将互斥锁想像成为一个只能容纳一个人的洗手间，当某个人进入洗手间的时候，可以从里面将洗手间锁上。其它人只能在互斥锁外面等待那个人出来，才能进去。在外面等候的人并没有排队，谁先看到洗手间空了，就可以首先冲进去。</p>
<p>上面的问题很容易使用互斥锁的问题解决，每个线程的程序可以改为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*mu is a global mutex*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;                <span class="comment">/*infinite loop*/</span></span><br><span class="line">  mutex_lock(mu);           <span class="comment">/*aquire mutex and lock it, if cannot, wait until mutex is unblocked*/</span></span><br><span class="line">  <span class="keyword">if</span> (i != <span class="number">0</span>) i = i - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"no more tickets"</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_unlock(mu);         <span class="comment">/*release mutex, make it unblocked*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个执行mutex_lock()的线程会先获得mu。其它想要获得mu的线程必须等待，直到第一个线程执行到mutex_unlock()释放mu，才可以获得mu，并继续执行线程。所以线程在mutex_lock()和mutex_unlock()之间的操作时，不会被其它线程影响，就构成了一个原子操作。</p>
<p>需要注意的时候，如果存在某个线程依然使用原先的程序 (即不尝试获得mu，而直接修改i)，互斥锁不能阻止该程序修改i，互斥锁就失去了保护资源的意义。所以，互斥锁机制需要程序员自己来写出完善的程序来实现互斥锁的功能。我们下面讲的其它机制也是如此。</p>
<p><strong>2) 条件变量</strong></p>
<p>条件变量是另一种常用的变量。它也常常被保存为全局变量，并和互斥锁合作。</p>
<p>假设这样一个状况: 有100个工人，每人负责装修一个房间。当有10个房间装修完成的时候，老板就通知相应的十个工人一起去喝啤酒。</p>
<p>我们如何实现呢？老板让工人在装修好房间之后，去检查已经装修好的房间数。但多线程条件下，会有竞争条件的危险。也就是说，其他工人有可能会在该工人装修好房子和检查之间完成工作。采用下面方式解决：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*mu: global mutex, cond: global codition variable, num: global int*/</span></span><br><span class="line">mutex_lock(mu)</span><br><span class="line"></span><br><span class="line">num = num + <span class="number">1</span>;                      <span class="comment">/*worker build the room*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num &lt;= <span class="number">10</span>) &#123;                     <span class="comment">/*worker is within the first 10 to finish*/</span></span><br><span class="line">    cond_wait(mu, cond);            <span class="comment">/*wait*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"drink beer"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num = <span class="number">11</span>) &#123;                <span class="comment">/*workder is the 11th to finish*/</span></span><br><span class="line">  cond_broadcast(mu, cond);         <span class="comment">/*inform the other 9 to wake up*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutex_unlock(mu);</span><br></pre></td></tr></table></figure>
<p>上面使用了条件变量。条件变量除了要和互斥锁配合之外，还需要和另一个全局变量配合(这里的num, 也就是装修好的房间数)。这个全局变量用来构成各个条件。</p>
<p>具体思路如下。我们让工人在装修好房间(num = num + 1)之后，去检查已经装修好的房间数( num &lt; 10 )。由于mu被锁上，所以不会有其他工人在此期间装修房间(改变num的值)。如果该工人是前十个完成的人，那么我们就调用cond_wait()函数。<br>cond_wait()做两件事情，一个是释放mu，从而让别的工人可以建房。另一个是等待，直到cond的通知。这样的话，符合条件的线程就开始等待。</p>
<p>当有通知(第十个房间已经修建好)到达的时候，condwait()会再次锁上mu。线程的恢复运行，执行下一句prinft(“drink beer”) (喝啤酒！)。从这里开始，直到mutex_unlock()，就构成了另一个互斥锁结构。</p>
<p>那么，前面十个调用cond_wait()的线程如何得到的通知呢？我们注意到elif if，即修建好第11个房间的人，负责调用cond_broadcast()。这个函数会给所有调用cond_wait()的线程放送通知，以便让那些线程恢复运行。</p>
<p>条件变量特别适用于多个线程等待某个条件的发生。如果不使用条件变量，那么每个线程就需要不断尝试获得互斥锁并检查条件是否发生，这样大大浪费了系统的资源。</p>
<p><strong>3) 读写锁</strong></p>
<p>读写锁与互斥锁非常相似。r、RW lock有三种状态: 共享读取锁(shared-read), 互斥写入锁(exclusive-write lock), 打开(unlock)。后两种状态与之前的互斥锁两种状态完全相同。</p>
<p>一个unlock的RW lock可以被某个线程获取R锁或者W锁。</p>
<p>如果被一个线程获得R锁，RW lock可以被其它线程继续获得R锁，而不必等待该线程释放R锁。但是，如果此时有其它线程想要获得W锁，它必须等到所有持有共享读取锁的线程释放掉各自的R锁。</p>
<p>如果一个锁被一个线程获得W锁，那么其它线程，无论是想要获取R锁还是W锁，都必须等待该线程释放W锁。</p>
<p>这样，多个线程就可以同时读取共享资源。而具有危险性的写入操作则得到了互斥锁的保护。</p>
<p>我们需要同步并发系统，这为程序员编程带来了难度。但是多线程系统可以很好的解决许多IO瓶颈的问题。比如我们监听网络端口。如果我们只有一个线程，那么我们必须监听，接收请求，处理，回复，再监听。如果我们使用多线程系统，则可以让多个线程监听。当我们的某个线程进行处理的时候，我们还可以有其他的线程继续监听，这样，就大大提高了系统的利用率。在数据越来越大，服务器读写操作越来越多的今天，这具有相当的意义。多线程还可以更有效地利用多CPU的环境。</p>
<p>(就像做饭一样，不断切换去处理不同的菜。)</p>
<p>本文中的程序采用伪C的写法。不同的语言有不同的函数名(比如mutex_lock)。这里关注的是逻辑上的概念，而不是具体的实现和语言规范。</p>
<p><strong>总结</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">multiple </span>threads, <span class="keyword">multiple </span>stacks</span><br><span class="line"><span class="label">race</span> condition</span><br><span class="line"><span class="label">mutex</span>, condition variable, RW lock</span><br></pre></td></tr></table></figure>
<h2 id="Linux_u8FDB_u7A0B_u95F4_u901A_u4FE1"><a href="#Linux_u8FDB_u7A0B_u95F4_u901A_u4FE1" class="headerlink" title="Linux进程间通信"></a>Linux进程间通信</h2><p>我们在Linux信号基础中已经说明，信号可以看作一种粗糙的进程间通信(IPC, interprocess communication)的方式，用以向进程封闭的内存空间传递信息。为了让进程间传递更多的信息量，我们需要其他的进程间通信方式。这些进程间通信方式可以分为两种:</p>
<ul>
<li>管道(PIPE)机制。在Linux文本流中，我们提到可以使用管道将一个进程的输出和另一个进程的输入连接起来，从而利用文件操作API来管理进程间通信。在shell中，我们经常利用管道将多个进程连接在一起，从而让各个进程协作，实现复杂的功能。</li>
<li>传统IPC (interprocess communication)。我们主要是指消息队列(message queue)，信号量(semaphore)，共享内存(shared memory)。这些IPC的特点是允许多进程之间共享资源，这与多线程共享heap和global data相类似。由于多进程任务具有并发性 (每个进程包含一个进程，多个进程的话就有多个线程)，所以在共享资源的时候也必须解决同步的问题 (参考Linux多线程与同步)。</li>
</ul>
<p><strong>管道与FIFO文件</strong></p>
<p>一个原始的IPC方式是所有的进程通过一个文件交流。比如我在纸(文件)上写下我的名字和年纪。另一个人读这张纸，会知道我的名字和年纪。他也可以在同一张纸上写下他的信息，而当我读这张纸的话，同样也可以知道别人的信息。但是，由于硬盘读写比较慢，所以这个方式效率很低。那么，我们是否可以将这张纸放入内存中以提高读写速度呢？</p>
<p>在Linux文本流中，我们已经讲解了如何在shell中使用管道连接多个进程。同样，许多编程语言中，也有一些命令用以实现类似的机制，比如在Python子进程中使用Popen和PIPE，在C语言中也有popen库函数来实现管道 (shell中的管道就是根据此编写的)。管道是由内核管理的一个缓冲区(buffer)，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。</p>
<p><img src="/images/14590056730715.jpg" alt=""></p>
<p>从原理上，管道利用fork机制建立(参考Linux进程基础和Linux从程序到进程），从而让两个进程可以连接到同一个PIPE上。最开始的时候，上面的两个箭头都连接在同一个进程Process 1上(连接在Process 1上的两个箭头)。当fork复制进程的时候，会将这两个连接也复制到新的进程(Process 2)。随后，每个进程关闭自己不需要的一个连接 (两个黑色的箭头被关闭; Process 1关闭从PIPE来的输入连接，Process 2关闭输出到PIPE的连接)，这样，剩下的红色连接就构成了如上图的PIPE。</p>
<p><img src="/images/14590056811596.jpg" alt=""></p>
<p><strong>传统IPC</strong></p>
<p>这几种传统IPC实际上有很悠久的历史，所以其实现方式也并不完善 (比如说我们需要某个进程负责删除建立的IPC)。一个共同的特征是它们并不使用文件操作的API。对于任何一种IPC来说，你都可以建立多个连接，并使用键值(key)作为识别的方式。我们可以在一个进程中中通过键值来使用的想要那一个连接 (比如多个消息队列，而我们选择使用其中的一个)。键值可以通过某种IPC方式在进程间传递(比如说我们上面说的PIPE，FIFO或者写入文件)，也可以在编程的时候内置于程序中。</p>
<p>在几个进程共享键值的情况下，这些传统IPC非常类似于多线程共享资源的方式(参看Linux多线程与同步):</p>
<ul>
<li>semaphore与mutex类似，用于处理同步问题。我们说mutex像是一个只能容纳一个人的洗手间，那么semaphore就像是一个能容纳N个人的洗手间。其实从意义上来说，semaphore就是一个计数锁(我觉得将semaphore翻译成为信号量非常容易让人混淆semaphore与signal)，它允许被N个进程获得。当有更多的进程尝试获得semaphore的时候，就必须等待有前面的进程释放锁。当N等于1的时候，semaphore与mutex实现的功能就完全相同。许多编程语言也使用semaphore处理多线程同步的问题。一个semaphore会一直存在在内核中，直到某个进程删除它。</li>
<li>共享内存与多线程共享global data和heap类似。一个进程可以将自己内存空间中的一部分拿出来，允许其它进程读写。当使用共享内存的时候，我们要注意同步的问题。我们可以使用semaphore同步，也可以在共享内存中建立mutex或其它的线程同步变量来同步。由于共享内存允许多个进程直接对同一个内存区域直接操作，所以它是效率最高的IPC方式。</li>
</ul>
<p>消息队列(message queue)与PIPE相类似。它也是建立一个队列，先放入队列的消息被最先取出。不同的是，消息队列允许多个进程放入消息，也允许多个进程取出消息。每个消息可以带有一个整数识别符(message_type)。你可以通过识别符对消息分类 (极端的情况是将每个消息设置一个不同的识别符)。某个进程从队列中取出消息的时候，可以按照先进先出的顺序取出，也可以只取出符合某个识别符的消息(有多个这样的消息时，同样按照先进先出的顺序取出)。消息队列与PIPE的另一个不同在于它并不使用文件API。最后，一个队列不会自动消失，它会一直存在于内核中，直到某个进程删除该队列。</p>
<p>多进程协作可以帮助我们充分利用多核和网络时代带来的优势。多进程可以有效解决计算瓶颈的问题。互联网通信实际上也是一个进程间通信的问题，只不过这多个进程分布于不同的电脑上。网络连接是通过socket实现的。由于socket内容庞大，所以我们不在这里深入。一个小小的注解是，socket也可以用于计算机内部进程间的通信。</p>
<p><strong>总结</strong></p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PIPE, FIFO</span><br><span class="line">semaphore, message queue, <span class="keyword">shared</span> memory; <span class="keyword">key</span></span><br></pre></td></tr></table></figure>
<h2 id="Linux_u6587_u4EF6_u7CFB_u7EDF_u7684_u5B9E_u73B0"><a href="#Linux_u6587_u4EF6_u7CFB_u7EDF_u7684_u5B9E_u73B0" class="headerlink" title="Linux文件系统的实现"></a>Linux文件系统的实现</h2><p>Linux文件管理从用户的层面介绍了Linux管理文件的方式。Linux有一个树状结构来组织文件。树的顶端为根目录(/)，节点为目录，而末端的叶子为包含数据的文件。当我们给出一个文件的完整路径时，我们从根目录出发，经过沿途各个目录，最终到达文件。</p>
<p>我们可以对文件进行许多操作，比如打开和读写。在Linux文件管理相关命令中，我们看到许多对文件进行操作的命令。它们大都基于对文件的打开和读写操作。比如cat可以打开文件，读取数据，最后在终端显示：</p>
<pre><code>$cat test.txt
</code></pre><p>对于Linux下的程序员来说，了解文件系统的底层组织方式，是深入进行系统编程所必备的。即使是普通的Linux用户，也可以根据相关的内容，设计出更好的系统维护方案。</p>
<p><strong>存储设备分区</strong></p>
<p>文件系统的最终目的是把大量数据有组织的放入持久性(persistant)的存储设备中，比如硬盘和磁盘。这些存储设备与内存不同。它们的存储能力具有持久性，不会因为断电而消失；存储量大，但读取速度慢。</p>
<p>观察常见存储设备。最开始的区域是MBR，用于Linux开机启动(参考Linux开机启动)。剩余的空间可能分成数个分区(partition)。每个分区有一个相关的分区表(Partition table)，记录分区的相关信息。这个分区表是储存在分区之外的。分区表说明了对应分区的起始位置和分区的大小。</p>
<p><img src="/images/14590056923433.jpg" alt=""></p>
<p>我们在Windows系统常常看到C分区、D分区等。Linux系统下也可以有多个分区，但都被挂载在同一个文件系统树上。</p>
<p>数据被存入到某个分区中。一个典型的Linux分区(partition)包含有下面各个部分:</p>
<p><img src="/images/14590056997684.jpg" alt=""></p>
<p>分区的第一个部分是启动区(Boot block)，它主要是为计算机开机服务的。Linux开机启动后，会首先载入MBR，随后MBR从某个硬盘的启动区加载程序。该程序负责进一步的操作系统的加载和启动。为了方便管理，即使某个分区中没有安装操作系统，Linux也会在该分区预留启动区。</p>
<p>启动区之后的是超级区(Super block)。它存储有文件系统的相关信息，包括文件系统的类型，inode的数目，数据块的数目。</p>
<p>随后是多个inodes，它们是实现文件存储的关键。在Linux系统中，一个文件可以分成几个数据块存储，就好像是分散在各地的龙珠一样。为了顺利的收集齐龙珠，我们需要一个“雷达”的指引：该文件对应的inode。每个文件对应一个inode。这个inode中包含多个指针，指向属于该文件各个数据块。当操作系统需要读取文件时，只需要对应inode的”地图”，收集起分散的数据块，就可以收获我们的文件了。</p>
<p>最后一部分，就是真正储存数据的数据块们(data blocks)了。</p>
<p><strong>inode简介</strong></p>
<p>上面我们看到了存储设备的宏观结构。我们要深入到分区的结构，特别是文件在分区中的存储方式。</p>
<p>文件是文件系统对数据的分割单元。文件系统用目录来组织文件，赋予文件以上下分级的结构。在硬盘上实现这一分级结构的关键，是使用inode来虚拟普通文件和目录文件对象。</p>
<p>在Linux文件管理中，我们知道，一个文件除了自身的数据之外，还有一个附属信息，即文件的元数据(metadata)。这个元数据用于记录文件的许多信息，比如文件大小，拥有人，所属的组，修改日期等等。元数据并不包含在文件的数据中，而是由操作系统维护的。事实上，这个所谓的元数据就包含在inode中。我们可以用$ls -l filename来查看这些元数据。正如我们上面看到的，inode所占据的区域与数据块的区域不同。每个inode有一个唯一的整数编号(inode number)表示。</p>
<p>在保存元数据，inode是“文件”从抽象到具体的关键。正如上一节中提到的，inode储存由一些指针，这些指针指向存储设备中的一些数据块，文件的内容就储存在这些数据块中。当Linux想要打开一个文件时，只需要找到文件对应的inode，然后沿着指针，将所有的数据块收集起来，就可以在内存中组成一个文件的数据了。</p>
<p><img src="/images/14590057101211.jpg" alt=""></p>
<p>inode并不是组织文件的唯一方式。最简单的组织文件的方法，是把文件依次顺序的放入存储设备，DVD就采取了类似的方式。但如果有删除操作，删除造成的空余空间夹杂在正常文件之间，很难利用和管理。</p>
<p>复杂的方式可以使用链表，每个数据块都有一个指针，指向属于同一文件的下一个数据块。这样的好处是可以利用零散的空余空间，坏处是对文件的操作必须按照线性方式进行。如果想随机存取，那么必须遍历链表，直到目标位置。由于这一遍历不是在内存进行，所以速度很慢。</p>
<p>FAT系统是将上面链表的指针取出，放入到内存的一个数组中。这样，FAT可以根据内存的索引，迅速的找到一个文件。这样做的主要问题是，索引数组的大小与数据块的总数相同。因此，存储设备很大的话，这个索引数组会比较大。</p>
<p>inode既可以充分利用空间，在内存占据空间不与存储设备相关，解决了上面的问题。但inode也有自己的问题。每个inode能够存储的数据块指针总数是固定的。如果一个文件需要的数据块超过这一总数，inode需要额外的空间来存储多出来的指针。</p>
<p><strong>inode示例</strong></p>
<p>在Linux中，我们通过解析路径，根据沿途的目录文件来找到某个文件。目录中的条目除了所包含的文件名，还有对应的inode编号。当我们输入$cat /var/test.txt时，Linux将在根目录文件中找到var这个目录文件的inode编号，然后根据inode合成var的数据。随后，根据var中的记录，找到text.txt的inode编号，沿着inode中的指针，收集数据块，合成text.txt的数据。整个过程中，我们参考了三个inode：根目录文件，var目录文件，text.txt文件的inodes。</p>
<p>在Linux下，可以使用$stat filename，来查询某个文件对应的inode编号。</p>
<p><img src="/images/14590057224870.jpg" alt=""></p>
<p>在存储设备中实际上存储为：</p>
<p><img src="/images/14590057295211.jpg" alt=""></p>
<p>当我们读取一个文件时，实际上是在目录中找到了这个文件的inode编号，然后根据inode的指针，把数据块组合起来，放入内存供进一步的处理。当我们写入一个文件时，是分配一个空白inode给该文件，将其inode编号记入该文件所属的目录，然后选取空白的数据块，让inode的指针指像这些数据块，并放入内存中的数据。</p>
<p><strong>文件共享</strong></p>
<p>在Linux的进程中，当我们打开一个文件时，返回的是一个文件描述符。这个文件描述符是一个数组的下标，对应数组元素为一个指针。有趣的是，这个指针并没有直接指向文件的inode，而是指向了一个文件表格，再通过该表格，指向加载到内存中的目标文件的inode。如下图，一个进程打开了两个文件。</p>
<p><img src="/images/14590057435416.jpg" alt=""></p>
<p>可以看到，每个文件表格中记录了文件打开的状态(status flags)，比如只读，写入等，还记录了每个文件的当前读写位置(offset)。当有两个进程打开同一个文件时，可以有两个文件表格，每个文件表格对应的打开状态和当前位置不同，从而支持一些文件共享的操作，比如同时读取。</p>
<p>要注意的是进程fork之后的情况，子进程将只复制文件描述符的数组，而和父进程共享内核维护的文件表格和inode。此时要特别小心程序的编写。</p>
<p><strong>总结</strong></p>
<p>这里概括性的总结了Linux的文件系统。Linux以inode的方式，让数据形成文件。</p>
<p>了解Linux的文件系统，是深入了解操作系Linux原理的重要一步。</p>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/03/03/2871198.html" target="_blank" rel="external">Linux 常用命令</a></li>
<li><a href="http://www.cnblogs.com/peida/archive/2012/12/05/2803591.html" target="_blank" rel="external">每天一个linux命令目录</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇日志来自 <a href="http://www.cnblogs.com/vamei">Vamei 博客</a> 中的系列文章，把一些基本的内容做了整合，方便查阅。</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://wdxtub.com/tags/Linux/"/>
    
      <category term="Vamei" scheme="http://wdxtub.com/tags/Vamei/"/>
    
      <category term="概念" scheme="http://wdxtub.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第十一周 - 声律启蒙]]></title>
    <link href="http://wdxtub.com/2016/03/25/rhythm-inspiration/"/>
    <id>http://wdxtub.com/2016/03/25/rhythm-inspiration/</id>
    <published>2016-03-25T10:04:09.000Z</published>
    <updated>2016-03-25T10:59:31.000Z</updated>
    <content type="html"><![CDATA[<p>云对雨，雪对风，晚照对晴空。天浩浩，日融融，弯月对长虹。</p>
<a id="more"></a>
<hr>
<p>这周的状态不是特别好，睡了八个月的帐篷终于开始有些不习惯了，再加上早早做完了作业，反而是有了更多『想干嘛就干嘛』的时间。周二买了无论是质量还是设计都不走洗的毕业礼服，周三和同学边吃饭边聊天，其他时间不是在睡觉，就是在准备睡觉的路上。</p>
<p>当然也有好消息，总算是确定了自己毕业后要落脚的地方。经过这么长时间的逡巡，应该说找到的双方都比较满意的工作，既不用一轮轮刷题（总有种摇尾乞怜的感觉），也没有太多的不信任感（不需要花时间自证）。工作嘛，双向选择，适合自己的，有广阔发展前景的，可能才是最好的选择。</p>
<p>于我，机会在哪里，我就愿意在哪里，而不是为了所谓『光环』，去当一颗螺丝钉。不想当将军的厨子不是好士兵，不过话说回来，人各有志，喜欢就好。</p>
<p>我不知道用战术勤奋掩盖战略懒惰是不是身边同学的『习惯』，经常在群里能看到三四点还在问作业相关问题，又或者告诉大家自己三四十个小时没有合眼。</p>
<p>我不大理解，也并不觉得真的需要这么『拼』，或者都不能说是『拼』，只能说是用低效率乘以长时间最后感动了自己。一天能做完的事情做一周，这根本不是什么值得骄傲或者感动的地方吧。说什么『现在的泪是选课时脑子进的水』，估计不是选课时进的，是本来就是水，不多去想想怎么提高效率，遇到简单问题就到处问，怎么进步呢？</p>
<p>我个人是很讨厌大半夜二话不说就甩作业问题来的人的，即使很多时候就是一句话的事儿，但是我也不想看这个头，不然以后就没完没了了。既然只是一句话的事儿，为什么不自己看看文档资料研究一下呢？</p>
<p>反而是有一些工作经验的同学，无论是相处还是聊天，都自在得多，至少不会出现『沟通障碍』。学校的学习是很重要，但是更重要的可能是培养自己去观察去思考的能力，作业是一种方式，但绝不是最好的方式。</p>
<p>我有我的冷漠无情，我有我的满腔热血。只索取不给予的人，离我远点，谢谢。</p>
<p>两鬓霜，一客行，新绿衬酒红。七颗星，一袍风，佛陀对苍生。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>云对雨，雪对风，晚照对晴空。天浩浩，日融融，弯月对长虹。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="平淡" scheme="http://wdxtub.com/tags/%E5%B9%B3%E6%B7%A1/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写文章]]></title>
    <link href="http://wdxtub.com/2016/03/24/write-an-article/"/>
    <id>http://wdxtub.com/2016/03/24/write-an-article/</id>
    <published>2016-03-25T00:47:12.000Z</published>
    <updated>2016-03-25T01:50:11.000Z</updated>
    <content type="html"><![CDATA[<p>在这个风云千樯的夜晚，我们来聊聊写文章。</p>
<a id="more"></a>
<hr>
<p>从高中开始写博客，转眼也快写了十年了。当然前七年都是瞎折腾，最近几年，随着阅读量的增加，写作慢慢才有了点起色。不由得想起这么一句话『Garbage in, Garbage out』，有高质量的『输入』，高质量的『输出』才成为可能。</p>
<p>这篇日志是我对于写文章这个事儿的一点感悟，比较零碎。</p>
<p>动笔之前，腹稿是很重要的，中心思想是什么，怎么组织文章来表达自己的想法，可能由于天资的问题我没办法一边写一边完成，所以我通常都会在纸上写关键字列提纲，这样不至于写着写着都不知道自己在写什么。浪费读者时间就是砸自己招牌，这种事情，给钱也不应该做。</p>
<p>写故事是另一种风格，真的是需要一些灵感，强求不来，对于故事本身来说，也许一开始不设定套路，反而是最好的套路，不然很容易落入俗套。另外一定要控制好『描述』、『说理』和『传情』的比例。描述太多累赘，说理太多教条，传情太多矫情。</p>
<p>那些让自己不开心不爽的事情，其实最有写下来的价值，这种内心的冲突，最难写，但是也最能出彩，试着去观察自己，并描述出来，既是很好的发泄，也是绝佳的训练。</p>
<p>另外值得写的就是各种光怪陆离的梦境，对于有些违背常理的东西，想要说清楚是很难的，但是这种训练的目的，只是去练习表达而已，多写就有不一样的收获。</p>
<p>从某种角度来说，写作是一种肌肉记忆，比方说写周记，我通常就会在周四或周五的晚上写作，慢慢形成习惯之后，到时间自然而然就会进入状态，几乎不会出现不知道写啥的情况，几乎都是自然而然流淌出来的文字。</p>
<p>时不时需要看自己以前的文字，用现在的标准去审视，有没有个人的风格，有没有词汇的不恰当，慢慢去培养自己的感觉。很多时候进入写作状态之后，出来的文字是比较『原生态』的，如果想要更进一步，就需要仔细打磨。观察自己的写作特点，并据此决定之后的方向。</p>
<blockquote>
<p>生气、嫉妒和沮丧是你灵感之源的毒药，你把这些处于萌芽状态的迹象消灭得越早，你的写作就会越好。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这个风云千樯的夜晚，我们来聊聊写文章。</p>]]>
    
    </summary>
    
      <category term="写作" scheme="http://wdxtub.com/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="阅读" scheme="http://wdxtub.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[看电影]]></title>
    <link href="http://wdxtub.com/2016/03/24/see-a-movie/"/>
    <id>http://wdxtub.com/2016/03/24/see-a-movie/</id>
    <published>2016-03-25T00:46:45.000Z</published>
    <updated>2016-03-25T01:15:13.000Z</updated>
    <content type="html"><![CDATA[<p>在这个风云千樯的夜晚，我们来聊聊看电影。</p>
<a id="more"></a>
<hr>
<p>我不算一个电影爱好者，看得不多，写得不多，想得也不多。但作为一种艺术表达形式，其实很多东西都是相通的。总体来说，依然可以按照《人间词话》中的三层来划分。</p>
<blockquote>
<p>昨夜西风凋碧树，独上高楼，望尽天涯路</p>
</blockquote>
<p>第一层很简单，就是两个字——『代入』。喜剧片大笑，言情片大哭，动作片大叫。不同的电影像是不同的楼，走到楼顶，去看这栋楼给你的风景。</p>
<blockquote>
<p>衣带渐宽终不悔，为伊消得人憔悴</p>
</blockquote>
<p>第二层需要加入一些『思考』，主题、道理、文化、知识，虽然有一定的局限性，但是至少自己觉得这些『思考』是有价值的（实际不一定，因为电影毕竟是艺术表现，可能得到的所谓『经验』并没有什么用）。</p>
<p>之所以比第一层要高，是因为已经开始『加工』电影本身，夹带『私货』，从『体验』变成了『参与』。</p>
<blockquote>
<p>众里寻他千百度，回首蓦见，那人正在灯火阑珊处</p>
</blockquote>
<p>第三层的关键词，恐怕是『抽离』，以一个局外人的角度，去观察电影的表达形式，去挖掘镜头的细节和深度。也就是说，要以电影为起点，去追根溯源，找到作者当初灵感迸发的瞬间，并研究为什么要用这样那样的形式去表现。</p>
<p>也许得到的答案，也就是平时自己忽略的细小瞬间罢了。</p>
<p>或者可以这么说，电影是起点，终点则是生活本身。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这个风云千樯的夜晚，我们来聊聊看电影。</p>]]>
    
    </summary>
    
      <category term="欣赏" scheme="http://wdxtub.com/tags/%E6%AC%A3%E8%B5%8F/"/>
    
      <category term="电影" scheme="http://wdxtub.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[广州美食地图]]></title>
    <link href="http://wdxtub.com/2016/03/24/guangzhou-food-map/"/>
    <id>http://wdxtub.com/2016/03/24/guangzhou-food-map/</id>
    <published>2016-03-25T00:13:02.000Z</published>
    <updated>2016-03-25T00:25:38.000Z</updated>
    <content type="html"><![CDATA[<p>这里记录一下网上比较出名的广州美食，非常适合『按图索骥』，口味比较个人化。</p>
<a id="more"></a>
<hr>
<h2 id="u5C0F_u5403"><a href="#u5C0F_u5403" class="headerlink" title="小吃"></a>小吃</h2><h3 id="u4E1C_u5DDD_u8DEF_u7A57_u94F6_u80A0_u7C89_u5E97"><a href="#u4E1C_u5DDD_u8DEF_u7A57_u94F6_u80A0_u7C89_u5E97" class="headerlink" title="东川路穗银肠粉店"></a>东川路穗银肠粉店</h3><p>猪腰肠或者牛肉肠。只要过去那边一定吃一次。反正是我个人认为的最好吃的肠粉</p>
<h3 id="u9648_u6DFB_u8BB0"><a href="#u9648_u6DFB_u8BB0" class="headerlink" title="陈添记"></a>陈添记</h3><p>过了宝华面店斜对面有条小巷叫十五甫三巷，拐进去就能看到“陈添记”的招牌，  此店绝对是广州的老字号，陈添记有三宝：爽滑鱼皮、艇仔粥、猪肠粉，招牌鱼皮：里面有花生粒、葱、姜、辣椒丝、香菜、芹菜，用特制酱油来调配，味道够足且各种滋味分明~</p>
<h3 id="u65B0_u8054_u7C89_u80A0_u5E97"><a href="#u65B0_u8054_u7C89_u80A0_u5E97" class="headerlink" title="新联粉肠店"></a>新联粉肠店</h3><p>地址：荔湾区多宝路88号  营业时间:7:00–14:30 二十多年的老店，门面超小，人气却火爆。拉肠3块一碟，粥4块一碗，十分大众化兼符合西关人省钱观念。拉肠口感香滑，配上自制酱油，非常美味。要注意的是，店铺之营业到下午两点半，要吃就要趁早了！</p>
<h3 id="u963F_u5A46_u725B_u6742"><a href="#u963F_u5A46_u725B_u6742" class="headerlink" title="阿婆牛杂"></a>阿婆牛杂</h3><p>地址：陆居路陆居肉菜市场牌坊内  开档时间：下午4时  价格：1元/串</p>
<p>网传是人气最强牛杂  仅仅在牛杂汤里滚两下已经可以吃得人满口香。觉得最能尝出阿婆牛杂真味的是豆卜串，饱吸酱汁浓味香口。而且阿婆这里也是全市少见的卖牛杂兼卖鱼蛋和牛丸的。不过略嫌汤底味道重，容易口渴。</p>
<h3 id="u897F_u5173_u5C0F_u98DF_u5E97_u2014_u2014_u798F_u6765_u9601"><a href="#u897F_u5173_u5C0F_u98DF_u5E97_u2014_u2014_u798F_u6765_u9601" class="headerlink" title="西关小食店——福来阁"></a>西关小食店——福来阁</h3><p>荔湾区泮塘路(仁威庙对面)  招牌就是传统瀬粉——粘米粉+人工压制.还有就是用料十足的萝卜糕，还有好多好味的小吃.</p>
<h3 id="u6F6E_u5B9D"><a href="#u6F6E_u5B9D" class="headerlink" title="潮宝"></a>潮宝</h3><p>多宝路221号，地铁长寿路站E出口的恒宝华庭出来以后，从中国银行方向往上下九方向走，就会看到一间不显眼的小店。小吃店真的很不起眼，还是很陋室那种。但是毕竟姜是老的辣——买午餐的人排了一条长队。</p>
<h3 id="u5E99_u524D_u76F4_u8857_u4E91_u541E_u9762_u4E16_u5BB6"><a href="#u5E99_u524D_u76F4_u8857_u4E91_u541E_u9762_u4E16_u5BB6" class="headerlink" title="庙前直街云吞面世家"></a>庙前直街云吞面世家</h3><p>越秀区庙前直街10号(近7中)</p>
<p>推荐美食：蟹子云吞面（汤底很好，不放味精，云吞也好味，面是竹升面）</p>
<h3 id="u5468_u751F_u8BB0_u592A_u7237_u9E21"><a href="#u5468_u751F_u8BB0_u592A_u7237_u9E21" class="headerlink" title="周生记太爷鸡"></a>周生记太爷鸡</h3><p>龟岗大马路江岭东路4号龟岗市场第二档</p>
<p>推荐美食：太爷鸡、猪手</p>
<p>注：是一间烧腊店，在文明路和寺右新马路都有分店，是烟熏味的食品。这是间起码开了二十年的老字号，在北京吃过烤鸭的同学们请注意了，周生记太爷熏鸡在家禽烹饪界绝对不落烤鸭下风。今天你吃了几斤？</p>
<h3 id="u8FBE_u6768_u7096_u54C1"><a href="#u8FBE_u6768_u7096_u54C1" class="headerlink" title="达杨炖品"></a>达杨炖品</h3><p>广州越秀区文明路160号-1(近北京路)</p>
<p>推荐美食：炖鹌鹑、椰子炖乌鸡。不用说，绝对值得一赞</p>
<h3 id="u4E5D_u7237_u9E21"><a href="#u4E5D_u7237_u9E21" class="headerlink" title="九爷鸡"></a>九爷鸡</h3><p>广州越秀区文明路103号(近106车站)</p>
<p>推荐美食：油鸡、叉烧、烧鸭、白切鸡</p>
<h3 id="u8001_u897F_u5173_u6FD1_u7C89"><a href="#u8001_u897F_u5173_u6FD1_u7C89" class="headerlink" title="老西关濑粉"></a>老西关濑粉</h3><p>广州越秀区文明路216号(近中山图书馆)</p>
<p>推荐美食：濑粉、斋烧鹅、水菱角</p>
<h3 id="u534E_u5174_u80A0_u7C89_u5E97"><a href="#u534E_u5174_u80A0_u7C89_u5E97" class="headerlink" title="华兴肠粉店"></a>华兴肠粉店</h3><p>越秀区文明路(中山图书馆对面)</p>
<p>每次路过总看到无数当地人在津津有味的吃着，怎么能够错过。。</p>
<p>推荐美食：煲仔猪肠粉</p>
<h3 id="u80A5_u5988_u725B_u9AA8_u6C64"><a href="#u80A5_u5988_u725B_u9AA8_u6C64" class="headerlink" title="肥妈牛骨汤"></a>肥妈牛骨汤</h3><p>广州市惠福东路中街2号(大佛寺旁)</p>
<p>推荐美食：牛骨汤、大碗粉</p>
<h3 id="u5DE7_u7F8E_u4E91_u541E_u9762"><a href="#u5DE7_u7F8E_u4E91_u541E_u9762" class="headerlink" title="巧美云吞面"></a>巧美云吞面</h3><p>广州越秀区惠福东路401-403号(近起义路)</p>
<p>推荐美食：五宝云吞、五宝云吞面</p>
<p>这家面店据说是老字号！而且是因为蔡澜一直捧场过来吃！所以变得很有名气！</p>
<p>点了最有名的五宝云吞面！里面有五种不同的云吞 ！包括蟹子 鲜虾 鲜虾蟹子 鲍鱼仔 元贝五种！</p>
<p>扎实的馅料再加上打得又细又韧的竹升面！加上熬制很长时间的鲜美汤头！</p>
<h3 id="u98CE_u5473_u9986"><a href="#u98CE_u5473_u9986" class="headerlink" title="风味馆"></a>风味馆</h3><p>广州越秀区越秀南路161号</p>
<p>推荐美食：牛三星汤</p>
<p>门口的小妹妹，多少年如一日。现在终于有空调了。但是，无论它的环境如何，它的出品总是一如既往的有保证。如果没有去过的食客，请记住暗语“大汤”=大碗牛三星汤，“细汤”=小碗牛三星汤，粉只需要点大小就行，因为要去里面拿的，那个时候再选牛腩、牛杂也行。汤点完之后，拿着牌子在座位上面乖乖坐好即可。</p>
<h3 id="u8354_u6E7E_u540D_u98DF_u5BB6"><a href="#u8354_u6E7E_u540D_u98DF_u5BB6" class="headerlink" title="荔湾名食家"></a>荔湾名食家</h3><p>荔湾区第十甫路99号1楼</p>
<p>推荐美食：德昌咸煎饼</p>
<p>这里的拉肠都是传统的布拉肠啊，特别的薄。酱汁做得味道很好，有点甜甜的，让人很有食欲。</p>
<p>为了搭配拉肠，我都会要个艇仔粥或者及第粥。很喜欢把油炸鬼和粥一起吃得感觉，又脆又滑</p>
<h3 id="u5B9D_u534E_u9762_u5E97"><a href="#u5B9D_u534E_u9762_u5E97" class="headerlink" title="宝华面店"></a>宝华面店</h3><p>荔湾区宝华路117号</p>
<p>推荐美食：鲜虾云吞面、金牌猪手面</p>
<p>刚从广州回来的时候，每每到了晚上想吃东西的时候，都有想买张机票飞广州吃宝华面店的冲动，朋友回来嘴上也是常常念叨着要去吃宝华面店，从小到大从来不吃云吞，结果这一习惯被终结了。。。</p>
<h3 id="u897F_u5173_u4EBA_u5BB6"><a href="#u897F_u5173_u4EBA_u5BB6" class="headerlink" title="西关人家"></a>西关人家</h3><p>荔湾区德星路9号荔湾广场南塔4楼(近下九路)</p>
<p>很喜欢这里的老广州味道……好吃,环境是那种不讨厌的热闹.</p>
<h3 id="u4F0D_u6E5B_u8BB0"><a href="#u4F0D_u6E5B_u8BB0" class="headerlink" title="伍湛记"></a>伍湛记</h3><p>荔湾区第十甫路99号1楼荔湾名食家内</p>
<p>推荐美食：及第粥、艇仔粥</p>
<h3 id="u6797_u6797_u725B_u6742"><a href="#u6797_u6797_u725B_u6742" class="headerlink" title="林林牛杂"></a>林林牛杂</h3><p>荔湾区第十甫路188号十甫假日酒店1楼</p>
<p>推荐美食：萝卜牛杂</p>
<h3 id="u559C_u54E5_u751F_u869D"><a href="#u559C_u54E5_u751F_u869D" class="headerlink" title="喜哥生蚝"></a>喜哥生蚝</h3><p>地址:越秀区沿江路江湾酒店对面</p>
<p>湛江海鲜日日到，烧烤，砂锅粥令人食指大动，再也不用去天河立交底下吃没品位的大排档了，沙虫刺身好味道。</p>
<h2 id="u98CE_u5473"><a href="#u98CE_u5473" class="headerlink" title="风味"></a>风味</h2><h3 id="u5927_u54E5_u9910_u5385"><a href="#u5927_u54E5_u9910_u5385" class="headerlink" title="大哥餐厅"></a>大哥餐厅</h3><p>地址: 番禺市桥西丽南路</p>
<p>大哥餐厅的出品没人说过有差池，黑色的牛河，公主城堡，相信爱情，每一样东西都值得每日大量开二三十公里车来到番禺市桥就为了吃个茶餐厅的逼格食货们。老板是香港虔诚基督徒，用心做好每个细节，细节做到洗手间都充满港式文化。</p>
<h3 id="u591A_u5229_u6765_u9910_u5385"><a href="#u591A_u5229_u6765_u9910_u5385" class="headerlink" title="多利来餐厅"></a>多利来餐厅</h3><p>地址:越秀区八旗二马路</p>
<p>一间有着几十年历史的餐厅，功夫鲈鱼拿过不少大奖，老板亲自喂养回春鸽，谁吃谁知道，老餐厅自有老味道，来过说的出来的食客已经可以令专业吃货报以赏识表情！</p>
<h3 id="u82AD_u91CC_u9910_u5385"><a href="#u82AD_u91CC_u9910_u5385" class="headerlink" title="芭里餐厅"></a>芭里餐厅</h3><p>地址:番禺沙湾大桥底草河村</p>
<p>在沙湾大桥底下，稍微有点远，但是风情很好，不是农庄又生存在农村中，回头客很多，螃蟹焖飞鸭，榴莲炒饭，出品很具创意。来了不会有人说介绍错。</p>
<h3 id="MIX_u89C5_u98DF_u9910_u5385"><a href="#MIX_u89C5_u98DF_u9910_u5385" class="headerlink" title="MIX觅食餐厅"></a>MIX觅食餐厅</h3><p>地址:白云区万达广场金街出口背后母米粥旁</p>
<p>影视大红人，绝世好老公榜样文章是合伙人之一，MIX混搭风格装修，餐具都有爱情的味道，装修精致有情调，价格公道好味道，松茸鸡煲是口感有追求的食客最爱，香辣虾，香辣鲍鱼更是令好辣一族疯狂，冬天来了，去吃个娘惹羊排煲，最重要现在去不用等位，还门口还有免费停车场，有情人去到绝对有惊艳感觉。一间去签到过，会令资深食家们刮目相看的餐厅。</p>
<h3 id="u9EC4_u6C99_u6C34_u4EA7_u5E02_u573A_u697C_u4E0A_u6D77_u73CD_u822B_u5927_u9152_u697C_u3002"><a href="#u9EC4_u6C99_u6C34_u4EA7_u5E02_u573A_u697C_u4E0A_u6D77_u73CD_u822B_u5927_u9152_u697C_u3002" class="headerlink" title="黄沙水产市场楼上海珍舫大酒楼。"></a>黄沙水产市场楼上海珍舫大酒楼。</h3><p>去过七八次，虽然远了一些，但有空还是专程去吃吃吃。【海珍舫出品三个词可概括：「新鲜，大件，美味」。最最推荐超级无敌虾饺皇，每只有数整粒虾仁，不点多两笼都可惜。招牌珍味冻猪手皮脆肉爽，调出的酱油味道极美，淘饭亦佳。至尊烧麦皇、鲜竹牛肉球肉厚味香，一口咬下去幸福感爆棚。免费停车两小时，还够去黄沙市场逛一圈，拎几斤冰鲜三文鱼返屋企</p>
<h3 id="u4E1C_u5703_u4E2D_u5C71_u5927_u9E3D_u996D"><a href="#u4E1C_u5703_u4E2D_u5C71_u5927_u9E3D_u996D" class="headerlink" title="东圃中山大鸽饭"></a>东圃中山大鸽饭</h3><p>平均一周至少一次。从最早的特价6.8元/只到现在的19.8元/只，我不知为这家老板贡献了多少银纸。盐焗乳鸽优于红烧乳鸽，另外好吃的还包括油渣鸽杂炒菜心，酸辣藕尖，椰子煲鸽，拆骨猪手，以及萝卜条。</p>
<h3 id="u5927_u5934_u867E"><a href="#u5927_u5934_u867E" class="headerlink" title="大头虾"></a>大头虾</h3><p>广州越秀区西湖路63号光明广场8楼801铺(近北京路)</p>
<p>咖喱虾正宗，香茅豆腐口味独树一帜（豆腐还很嫩很滑喔！），麻油鸡和猪颈肉让口味挑剔的人都脱口称赞~</p>
<h3 id="u5929_u6CB3_u6C47_u6E58_u4E4B_u56ED"><a href="#u5929_u6CB3_u6C47_u6E58_u4E4B_u56ED" class="headerlink" title="天河汇湘之园"></a>天河汇湘之园</h3><p>剁椒鱼头。新鲜热辣，细嫩入味。去了大概十次以上吧。我一个常年呆在长沙的，推荐广州的剁椒鱼头，你知道有多美味了。</p>
<h3 id="u963F_u5F3A_u9178_u83DC_u9C7C"><a href="#u963F_u5F3A_u9178_u83DC_u9C7C" class="headerlink" title="阿强酸菜鱼"></a>阿强酸菜鱼</h3><p>广州天河北，阿强酸菜鱼。不夸张地说，88元/条（开发票加10元）的酸菜鱼，两个人可以干完。鱼肉十分之软嫩，酸麻鲜辣拿捏得很有水平，浇饭都算一绝。有预感以后要经常在这儿刷了。</p>
<h3 id="u7EA2_u57CE_u98CE_u5473"><a href="#u7EA2_u57CE_u98CE_u5473" class="headerlink" title="红城风味"></a>红城风味</h3><p>地址：西华路475号（南海中学对面）爱吃辣的童鞋一定会大爱的川菜馆，推荐：酸菜鱼、水煮牛肉、毛血旺、凉面，菜式好吃又正宗，价格都不贵，环境就一般，不适合约会，但适合同学聚会或同事聚餐；人均30元左右</p>
<h3 id="u7C73_u5E02_u8DEF_u6CD7_u5DF7_u7684_u6912_u76D0_u6FD1_u5C3F_u867E"><a href="#u7C73_u5E02_u8DEF_u6CD7_u5DF7_u7684_u6912_u76D0_u6FD1_u5C3F_u867E" class="headerlink" title="米市路泗巷的椒盐濑尿虾"></a>米市路泗巷的椒盐濑尿虾</h3><p>一间好小的大拍档，每款菜式都不会超过20元，除了必点的椒盐濑尿虾外，咸蛋黄炒云南小瓜，豆豉陈皮蒸鉗鱼，炒滑蛋等等都好吃到爆！五点半左右开档，超过六点就会有超多人排队，不会天天开档，所以去之前最好打个电话问下~电话：83372343</p>
<h3 id="u9648_u5BB6_u7960_u7684_u80A5_u4F6C_u7F8E_u98DF"><a href="#u9648_u5BB6_u7960_u7684_u80A5_u4F6C_u7F8E_u98DF" class="headerlink" title="陈家祠的肥佬美食"></a>陈家祠的肥佬美食</h3><p>陈家祠隔离的一条叫龙塘西尾的巷，康王北路公交车站就系巷口，行入巷到尾转右，过两三间屋就到，门牌号系6号，88259926  ，这个比米市路贵，但虾全都大只的，而且新鲜，至于味道就各有千秋，有盐水同椒盐两种味，无膏35元一例一斤左右，有膏就45元。其他菜色20左右，椒盐多春鱼，白灼墨鱼仔青口等都份大味道好。环境一般，折叠木台+矮凳，不过这样又有另一番风味~</p>
<h3 id="u548C_u98CE_u4E2D_u534E_u5C45_u9152_u5C4B"><a href="#u548C_u98CE_u4E2D_u534E_u5C45_u9152_u5C4B" class="headerlink" title="和风中华居酒屋"></a>和风中华居酒屋</h3><p>盘福路转入解放北右手边  这里的牛肉火锅很好味，豆腐很滑很香，入口即溶，牛肉煮得不老，刚刚好，分量足卖相好，价钱又不贵（25元）。另一推荐海鲜饼（25元）份量大，虽然没有海鲜在里面，但是铺了很多木鱼，很香口很满足。中午有特价便当送汤，15元左右，份量很足，味道不过不失</p>
<h3 id="u73AF_u7403_u6E14_u592B"><a href="#u73AF_u7403_u6E14_u592B" class="headerlink" title="环球渔夫"></a>环球渔夫</h3><p>地址:番禺美丽华酒店一楼展云轩</p>
<p>要吃到最新鲜的世界海产，这里有齐，刺身一绝，不是日本餐厅更多单纯海鲜的品味，还有两斤重的南非鲍鱼，绝对是土豪的隐蔽好去处，并且不失一个嘴刁食客的身份！</p>
<h3 id="u4E03_u7EAC_u7F18_u519C_u5E84"><a href="#u4E03_u7EAC_u7F18_u519C_u5E84" class="headerlink" title="七纬缘农庄"></a>七纬缘农庄</h3><p>地址：番禺金山大道</p>
<p>一大片的火龙果庄园，红肉的火龙果还可以做出各种菜式，农庄里有吃火龙果大的猪，鸡，鱼，周末一家大小可以耗一天的好去处，钓鱼，采摘，赶猪，吃全生态农庄菜，吃得放心，玩得开心！</p>
<h2 id="u7CA4_u83DC"><a href="#u7CA4_u83DC" class="headerlink" title="粤菜"></a>粤菜</h2><h3 id="u4EBA_u6C11_u4E2D_u8DEF_u51E4_u53A8_u987A_u5FB7_u79C1_u623F_u83DC"><a href="#u4EBA_u6C11_u4E2D_u8DEF_u51E4_u53A8_u987A_u5FB7_u79C1_u623F_u83DC" class="headerlink" title="人民中路凤厨顺德私房菜"></a>人民中路凤厨顺德私房菜</h3><p>这家的大师傅水准还是不错的。招牌凤厨鸡，鱼腐竹笙鱼肚浸时蔬，豉汁蒸大鱼头，煎焗骨腩，（以我偏淡的口味来说）除了稍咸半分外，基本无可挑剔。饭后来份双皮奶，边饮茶边吃南乳花生， 甚是惬意。说到美食，在广州的满意度确是要超过绝大多数城市。</p>
<h3 id="u4E91_u9999_u9152_u697C"><a href="#u4E91_u9999_u9152_u697C" class="headerlink" title="云香酒楼"></a>云香酒楼</h3><p>推荐理由：百年老字号，食客里好多都是公公婆婆，颇有几分怀旧的调调。点心款式不太多，但胜在分量超足，味道也可以;粤菜都是家常口味，价格几实惠，有几个特价菜好好味。环境就不咋样了，挺邋遢挺破旧的。</p>
<p>推荐菜式：冰花鸡蛋散，蛋挞，烧鹅，萝卜包，葱头鸡</p>
<p>人均消费：￥30</p>
<p>联系电话：020-37638057 020-83818661</p>
<p>详细地址：越秀区东华东路342号(近东川路)</p>
<h3 id="u798F_u65B0_u660C_u83DC_u9986"><a href="#u798F_u65B0_u660C_u83DC_u9986" class="headerlink" title="福新昌菜馆"></a>福新昌菜馆</h3><p>推荐理由：好火爆的一家粤菜馆，从没见过那么多桌子排得那么密集，还有好多人在等位。菜肴大众化，味道几靓，陈皮骨、牛肉丸尤其值得推荐，埋单更是便到出乎意料。环境就认真麻麻，岂是吵字可以形容。</p>
<p>推荐菜式：黄鳝煲，凉伴鱼皮，冰镇鳝片，陈皮骨，隔水蒸鸡，金牌甜薄撑，沙地金针浸牛滑，牛肉丸，煎面，乳鸽，烧鹅，香煎咸鲈鱼</p>
<p>人均消费：￥30-50</p>
<p>联系电话：020-84476298</p>
<p>详细地址：海珠区基立北街2号</p>
<h3 id="u5BCC_u4E34_u98DF_u5E9C"><a href="#u5BCC_u4E34_u98DF_u5E9C" class="headerlink" title="富临食府"></a>富临食府</h3><p>推荐理由：惠福东路上的一家“超正又实惠”的酒楼，是老饕街坊的聚脚点，位置很隐蔽，店面浅窄，位于一排灯饰店的中间。虽然环境一般，店面的装修和气氛，却有着毫不造作的朴实。而且出品好抵，碟头大，味道也好，招牌菜是脆皮猪手，简直是人间美味;饭后送的红豆沙也绝对比得起糖水铺的出品，服务态度又好，一家人吃饭就最 适合了。</p>
<p>推荐菜式：脆皮猪手，白灼牛肉，沙拉猪扒，德国咸猪手，葱油鸡，上汤苋菜，新味骨，姜酒鸡什煮鸡蛋，白切鸡，冰镇鳝片，丹青黄金条，叉烧，红烧乳鸽，水晶牛尾，煎面，红豆沙</p>
<p>人均消费：￥30-50</p>
<p>联系电话：020-83302789</p>
<p>详细地址：越秀区惠福东路417号(近教育路)</p>
<h3 id="u5411_u7FA4_u996D_u5E97_28_u9F99_u6D25_u8DEF_u603B_u5E97_29"><a href="#u5411_u7FA4_u996D_u5E97_28_u9F99_u6D25_u8DEF_u603B_u5E97_29" class="headerlink" title="向群饭店(龙津路总店)"></a>向群饭店(龙津路总店)</h3><p>推荐理由：向群的总店，出品很家常的住家菜式，而且价格普遍都非常实惠，位少人多，必需预先订位。推荐招牌豉油王葱油淋鸡，用料是“走地鸡”，皮爽脆，肉质嫩滑，味道很有家的感觉;其实要品尝有广州特色的粤菜，要在这些老字号的餐厅才算是正宗的。</p>
<p>推荐菜式：葱油淋鸡，酿炸面，捞肚尖，豉油皇鹅肠，肥叉鸡杂炒菜心，葱头鸡，煎鹅，果汁猪扒，酿油炸鬼，鲈鱼丁，让炸面，干炒牛河</p>
<p>人均消费：￥30-50</p>
<p>联系电话：020-81885146</p>
<p>详细地址：越秀区龙津东路853-857号</p>
<h3 id="u5229_u534E_u996D_u5E97"><a href="#u5229_u534E_u996D_u5E97" class="headerlink" title="利华饭店"></a>利华饭店</h3><p>推荐理由：老字号粤菜馆，出品地道的粤式风味，招牌陈皮骨、七彩捞蟮片、红葱头淋鸡、豉油鹅肠等，味道的确正宗，分量够大，价格又实惠，一家大小聚餐就最适合，老字号的环境与服务，自然就一般了，人多拥挤且嘈杂，但架不住出品的味道好，每天饭点都很多人排队等号;想一饱口福，又不太计较环境的，可以来试试。</p>
<p>推荐菜式：陈皮骨，红葱头鸡，鹅肠，七彩捞蟮片，冰浸鳝片，豉油皇鹅肠，茶叶虾，冰浸芥兰，羊肉煲，铁板烧汁鲈鱼，牛肉丸，捞起蟮片，咸蛋黄炒蟹，冬瓜盅。</p>
<p>人均消费：￥30-50</p>
<p>联系电话：020-83308399</p>
<p>详细地址：越秀区德政中路329号</p>
<h3 id="u5357_u56ED_u9152_u5BB6"><a href="#u5357_u56ED_u9152_u5BB6" class="headerlink" title="南园酒家"></a>南园酒家</h3><p>推荐理由：远近闻名的老字号餐厅，是广州四大园林酒家之一，环境气派，有种古色古香的岭南园林风格，以潮菜粤点而闻名;点心即点即蒸，味道正宗，尤其推荐虾饺;粤菜也做得精致，味道一流，价格合理，适合百姓人家常去，人非常多，去之前一定要先订位;也很适合宴请、婚宴等讲求排场的喜庆日子。</p>
<p>推荐菜式：佛跳墙，潮州烧雁鹅，潮州豆酱鸡，潮州扒大翅，护国菜，海南椰子盅，琼山豆腐，竹园椰奶鸡，三色马蹄糕，椰酱蛋角，生炸象生虾，虾饺，蛋挞，XO酱萝卜糕，顺德猪杂粥，奶皇包，流沙包，叉烧酥，拉肠，春卷，烧鹅</p>
<p>人均消费：￥50-100</p>
<p>联系电话：020-84448380</p>
<p>详细地址：海珠区前进路142号</p>
<h3 id="u9676_u9676_u5C45_u9152_u5BB6"><a href="#u9676_u9676_u5C45_u9152_u5BB6" class="headerlink" title="陶陶居酒家"></a>陶陶居酒家</h3><p>推荐理由：广州剩余为数不多的百年老字号，是广州市最著名最古老的大型酒家，创建于清光绪六年(1880年)，装修具广州风情，充满西关特色，是体验老广州生活的首选之地，也是外地人品尝地道广州美食的绝佳选择;出品的点心，可谓便宜实在，口味地道，还有各式粤式名菜，服务到位，人就非常多，所以经常看到有人等位。</p>
<p>推荐菜式：猪脑鱼羹、五彩鲜虾仁、姜葱炒肉蟹、西湖菊花鱼、手撕盐焗鸡、片皮挂炉鸭、云腿爽肚、雪里藏珍</p>
<p>人均消费：￥30-50</p>
<p>联系电话：020-81389632 020-81396111</p>
<p>详细地址：荔湾区第十甫路20号</p>
<h3 id="u53CB_u8054_u83DC_u9986"><a href="#u53CB_u8054_u83DC_u9986" class="headerlink" title="友联菜馆"></a>友联菜馆</h3><p>推荐理由：以吃清平鸡为特色的老字号粤菜。大排挡式，环境可以说非常的一般。鸡很不错， 也不贵，20多就半只，还是正宗的清平鸡，其他菜比如蒸肉丸都非常好吃，各类粤菜都很好，性价比超高!喜欢吃鸡的朋友不能错过，但喜欢环境舒服的，就不太合适了。原清平饭店以“友联菜馆”的名字从现江湖!饭店继续由原清平饭店“清平鸡”唯一传人及原清平饭店的大厨主理。经实践证明，主打的清平鸡果真是皮爽肉滑。</p>
<p>推荐菜式：清平鸡，猪手，鸡杂炒菜心，生炒骨，生炒菜心，葱茜捞肚尖，鱼肠煎蛋，桂花扎，道窖肉丸，钵仔鸡红。</p>
<p>人均消费：￥30-50</p>
<p>联系电话：020-81876751</p>
<p>详细地址：荔湾区杉木栏路163号</p>
<h2 id="u751C_u54C1"><a href="#u751C_u54C1" class="headerlink" title="甜品"></a>甜品</h2><h3 id="u73AB_u7470_u751C_u54C1_u5E97"><a href="#u73AB_u7470_u751C_u54C1_u5E97" class="headerlink" title="玫瑰甜品店"></a>玫瑰甜品店</h3><p>越秀区文明路218号(中山图书馆斜对面)  招牌芒果西米露，粒粒西米晶莹通透，好浓的芒果味；杏仁豆腐香甜爽滑，一个实在是爽啊</p>
<h3 id="GANSO"><a href="#GANSO" class="headerlink" title="GANSO"></a>GANSO</h3><p>彩虹桥店  电话：020-81369696  地址：荔湾区荔湾路100号新大新百货一楼</p>
<p>江燕店  电话：020-34368119  地址：海珠区江燕路245号</p>
<p>说实话我不喜欢吃太甜的东西，不过这个好可爱，38元6个，冰淇淋口味一个10元，店里还有其他日本点心，感觉嘛，有点小贵，喜欢倒是可以试一下</p>
<h3 id="u7F8E_u5229_u6743_u51B0_u5BA4"><a href="#u7F8E_u5229_u6743_u51B0_u5BA4" class="headerlink" title="美利权冰室"></a>美利权冰室</h3><p>越秀区北京路344号太平馆1楼  83197141  广州老字号的传统冰室，装修有点西餐厅的风格，出品的雪糕还保持着传统的手工做法，便宜又好吃;而特色的硬雪糕，在广州更几乎是独此一家！心水推荐：棉花雪糕，炸雪糕，椰子雪糕，焗雪山！</p>
<h3 id="u767E_u82B1_u751C_u54C1"><a href="#u767E_u82B1_u751C_u54C1" class="headerlink" title="百花甜品"></a>百花甜品</h3><p>广州越秀区文明路210号(近中山图书馆)</p>
<p>推荐美食：红豆沙、芝麻糊、凤凰奶糊等</p>
<h3 id="u5357_u4FE1"><a href="#u5357_u4FE1" class="headerlink" title="南信"></a>南信</h3><p>推荐美食：双皮奶、牛三星汤</p>
<h3 id="u987A_u8BB0_u51B0_u5BA4"><a href="#u987A_u8BB0_u51B0_u5BA4" class="headerlink" title="顺记冰室"></a>顺记冰室</h3><p>荔湾区宝华路85号</p>
<p>推荐美食：香芒雪糕</p>
<p>这是一个可以找到小时候感觉的冰室。浓浓的椰子雪糕，传统的配方，带着略粗野的口感，一样撩拨人的味蕾。芒果雪糕也不错，芒果肉很多，很香！</p>
<h3 id="u5F00_u8BB0_u7CD6_u6C34"><a href="#u5F00_u8BB0_u7CD6_u6C34" class="headerlink" title="开记糖水"></a>开记糖水</h3><p>荔湾区多宝路219号</p>
<p>推荐美食：绿豆沙、芝麻糊</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里记录一下网上比较出名的广州美食，非常适合『按图索骥』，口味比较个人化。</p>]]>
    
    </summary>
    
      <category term="广州" scheme="http://wdxtub.com/tags/%E5%B9%BF%E5%B7%9E/"/>
    
      <category term="美食" scheme="http://wdxtub.com/tags/%E7%BE%8E%E9%A3%9F/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简易 Shell 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/shell-guide/"/>
    <id>http://wdxtub.com/2016/03/24/shell-guide/</id>
    <published>2016-03-25T00:06:21.000Z</published>
    <updated>2016-03-25T00:07:50.000Z</updated>
    <content type="html"><![CDATA[<p>Shell 可以说是程序员最好的帮手了，这里简单记录一些常用的技巧，包括 shell 脚本与常用的命令。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u672C_u64CD_u4F5C"><a href="#u57FA_u672C_u64CD_u4F5C" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>脚本的第一行叫 shebang，用来告知系统如何执行该脚本 <code>#!/bin/bash</code></li>
<li>输出内容 <code>echo &quot;Hello world!&quot;</code></li>
<li>每一句指令用换行或分号隔开</li>
<li>声明一个变量(不能有空格) <code>VARIABLE=&quot;Some string&quot;</code></li>
<li>使用变量 <code>echo $VARIABLE</code>, <code>echo &quot;$VARIABLE&quot;</code>, <code>echo &#39;$VARIABLE&#39;</code></li>
<li>当赋值和 export 时，或者以其他方式使用变量时，变量名前不加 $</li>
<li>如果要使用变量的值，则要加 $</li>
<li>带你引号不会展开变量</li>
<li>在变量内部进行字符串替换 <code>echo ${VARIABLE/Some/A}</code> 会把 VARIABLE 中首次出现的 Some 替换成 A</li>
<li>内置变量 <code>$?</code>, <code>$$</code>, <code>$#</code>, <code>$@</code></li>
</ul>
<p>例子</p>
<pre><code>echo &quot;Last program return value: $?&quot;
echo &quot;Script&apos;s PID: $$&quot;
echo &quot;Number of arguments: $#&quot;
echo &quot;Scripts arguments: $@&quot;
echo &quot;Scripts arguments separated in different variables: $1 $2&quot;
</code></pre><ul>
<li>读取输入 <code>read NAME</code> 不需要声明新变量</li>
</ul>
<h2 id="u6761_u4EF6_u6D41_u7A0B"><a href="#u6761_u4EF6_u6D41_u7A0B" class="headerlink" title="条件流程"></a>条件流程</h2><p>通常的 IF</p>
<pre><code>if [ $NAME -ne $USER ]
then
    echo &quot;Your name is your username&quot;
else
    echo &quot;Your name isn&apos;t your username&quot;
fi
</code></pre><p>Bash 的 case 语句与 Java 和 C++ 中的 switch 语句类似:</p>
<pre><code>case &quot;$VARIABLE&quot; in
    # 列出需要匹配的字符串
    0) echo &quot;There is a zero.&quot;;;
    1) echo &quot;There is a one.&quot;;;
    *) echo &quot;It is not null.&quot;;;
esac
</code></pre><h2 id="u8868_u8FBE_u5F0F"><a href="#u8868_u8FBE_u5F0F" class="headerlink" title="表达式"></a>表达式</h2><ul>
<li>格式 <code>echo $(( 10 + 5 ))</code></li>
</ul>
<h2 id="u4E0A_u4E0B_u6587_u4F9D_u8D56"><a href="#u4E0A_u4E0B_u6587_u4F9D_u8D56" class="headerlink" title="上下文依赖"></a>上下文依赖</h2><ul>
<li>bash 运行时依赖上下文</li>
<li><code>ls</code> 列出当前目录</li>
<li><code>ls -l</code> 列出文件和目录的详细信息，指令可以带有选项</li>
<li>前一个指令的输出可以当做后一个指令的输入。<code>grep</code> 用来匹配字符串</li>
<li>用下面的指令列出当前目录下所有的 txt 文件 <code>ls -l | grep &quot;\.txt&quot;</code></li>
<li>重定向可以到输出，输入和错误输出。 &gt; 会覆盖已存在的文件，&gt;&gt; 会以累加的方式输出文件中</li>
</ul>
<p>例如</p>
<pre><code>python hello.py &lt; &quot;input.in&quot;
python hello.py &gt; &quot;output.out&quot;
python hellp.py &gt;&gt; &quot;error.err&quot;
</code></pre><ul>
<li>一个指令可用 <code>$()</code> 嵌套在另一个指令内部，如 <code>echo &quot;There are $(ls | wc -l) items here.&quot;</code></li>
</ul>
<h2 id="u5176_u4ED6"><a href="#u5176_u4ED6" class="headerlink" title="其他"></a>其他</h2><p>循环遍历给定的参数序列:变量$VARIABLE 的值会被打印 3 次。注意 ` ` 和 $( ) 等价。seq 返回长度为 3 的数组。</p>
<pre><code>for VARIABLE in `seq 3`
do
    echo &quot;$VARIABLE&quot;
done
</code></pre><p>你也可以使用函数，定义函数：</p>
<pre><code>function foo ()
{
    echo &quot;Arguments work just like script arguments: $@&quot;
    echo &quot;And: $1 $2...&quot;
    echo &quot;This is a function&quot;
    return 0
}
</code></pre><p>更简单的方法</p>
<pre><code>bar ()
{
    echo &quot;Another way to declare functions!&quot;
    return 0
}
</code></pre><p>调用函数</p>
<pre><code>foo &quot;My name is&quot; $NAME
</code></pre><p>有很多有用的指令需要学习:</p>
<pre><code>tail -n 10 file.txt
</code></pre><p>打印 file.txt 的最后 10 行</p>
<pre><code>head -n 10 file.txt
</code></pre><p>打印 file.txt 的前 10 行</p>
<pre><code>sort file.txt
</code></pre><p>将 file.txt 按行排序</p>
<pre><code>uniq -d file.txt
</code></pre><p>报告或忽略重复的行，用选项 -d 打印重复的行</p>
<pre><code>cut -d &apos;,&apos; -f 1 file.txt
</code></pre><p>打印每行中 ‘,’ 之前内容</p>
<h2 id="u57FA_u7840"><a href="#u57FA_u7840" class="headerlink" title="基础"></a>基础</h2><ul>
<li>学习 Bash 的基础知识。具体来说，输入 <code>man bash</code> 并至少全文浏览一遍; 它很简单并且不长。其他的 shell 可能很好用，但 Bash 功能强大且几乎所有情况下都是可用的 （ <em>只</em>学习 zsh，fish 或其他的 shell 的话，在你自己的电脑上会显得很方便，但在很多情况下会限制你，比如当你需要在服务器上工作时）。</li>
<li>学习并掌握至少一个基于文本的编辑器。通常 Vim （<code>vi</code>） 会是你最好的选择，因为在终端里进行随机编辑 Vim 真的毫无敌手，哪怕是 Emacs、某大型 IDE 甚至时下非常流行的编辑器。</li>
<li>学会如何使用 <code>man</code> 命令去阅读文档。学会使用 <code>apropos</code> 去查找文档。了解有些命令并不对应可执行文件，而是Bash内置的，可以使用 <code>help</code> 和 <code>help -d</code> 命令获取帮助信息。</li>
<li>学会使用 <code>&gt;</code> 和 <code>&lt;</code> 来重定向输出和输入，学会使用 <code>|</code> 来重定向管道。明白 <code>&gt;</code> 会覆盖了输出文件而 <code>&gt;&gt;</code> 是在文件未添加。了解标准输出 stdout 和标准错误 stderr。</li>
<li>学会使用通配符 <code>*</code> （或许再算上 <code>?</code> 和 <code>[</code>…<code>]</code>） 和引用以及引用中 <code>&#39;</code> 和 <code>&quot;</code> 的区别。</li>
<li>熟悉 Bash 任务管理工具：<code>&amp;</code>，<strong>ctrl-z</strong>，<strong>ctrl-c</strong>，<code>jobs</code>，<code>fg</code>，<code>bg</code>，<code>kill</code> 等。</li>
<li>了解 <code>ssh</code>，以及学会通过使用 <code>ssh-agent</code>，<code>ssh-add</code> 等命令来实现基本的无密码认证。</li>
<li>学会基本的文件管理：<code>ls</code> 和 <code>ls -l</code> （了解 <code>ls -l</code> 中每一列代表的意义），<code>less</code>，<code>head</code>，<code>tail</code> 和 <code>tail -f</code> （甚至 <code>less +F</code>），<code>ln</code> 和 <code>ln -s</code> （了解硬链接与软链接的区别），<code>chown</code>，<code>chmod</code>，<code>du</code> （硬盘使用情况概述：<code>du -hs *</code>）。 关于文件系统的管理，学习 <code>df</code>，<code>mount</code>，<code>fdisk</code>，<code>mkfs</code>，<code>lsblk</code>。知道 inode 是什么（与 <code>ls -i</code> 和 <code>df -i</code> 等命令相关）。</li>
<li>学习基本的网络管理：<code>ip</code> 或 <code>ifconfig</code>，<code>dig</code>。</li>
<li>熟悉正则表达式，以及 <code>grep</code>／<code>egrep</code> 里不同参数的作用，例如 <code>-i</code>，<code>-o</code>，<code>-v</code>，<code>-A</code>，<code>-B</code> 和 <code>-C</code>，这些参数是值得学习并掌握的。</li>
<li>学会使用 <code>apt-get</code>，<code>yum</code>，<code>dnf</code> 或 <code>pacman</code> （取决于你使用的 Linux 发行版）来查找或安装软件包。并确保你的环境中有 <code>pip</code> 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 <code>pip</code> 来安装会很方便）。</li>
</ul>
<h2 id="u65E5_u5E38_u4F7F_u7528"><a href="#u65E5_u5E38_u4F7F_u7528" class="headerlink" title="日常使用"></a>日常使用</h2><ul>
<li>在 Bash 中，可以使用 <strong>Tab</strong> 自动补全参数，使用 <strong>ctrl-r</strong> 搜索命令行历史（在按下之后，键入便可以搜索，重复按下 <strong>ctrl-r</strong> 会在更多匹配中循环，按下 <strong>Enter</strong> 会执行找到的命令，按下右方向键会将结果放入当前行中，使你可以进行编辑）。</li>
<li>在 Bash 中，可以使用 <strong>ctrl-w</strong> 删除你键入的最后一个单词，使用 <strong>ctrl-u</strong> 删除整行，使用 <strong>alt-b</strong> 和 <strong>alt-f</strong> 以单词为单位移动光标，使用 <strong>ctrl-a</strong> 将光标移至行首，使用 <strong>ctrl-e</strong> 将光标移至行尾，使用 <strong>ctrl-k</strong> 删除光标至行尾的所有内容，使用 <strong>ctrl-l</strong> 清屏。键入 <code>man readline</code> 查看 Bash 中的默认快捷键，内容很多。例如 <strong>alt-.</strong> 循环地移向前一个参数，以及 <strong>alt-*</strong> 展开通配符。</li>
<li>你喜欢的话，可以键入 <code>set -o vi</code> 来使用 vi 风格的快捷键，而 <code>set -o emacs</code> 可以把它改回来。</li>
<li>为了方便地键入长命令，在设置你的编辑器后（例如 <code>export EDITOR=vim</code>），键入 <strong>ctrl-x</strong> <strong>ctrl-e</strong> 会打开一个编辑器来编辑当前命令。在 vi 模式下则键入 <strong>escape-v</strong> 实现相同的功能。</li>
<li>键入 <code>history</code> 查看命令行历史记录。其中有许多缩写，例如 <code>!$</code>（最后键入的参数）和 <code>!!</code>（最后键入的命令），尽管通常被 <strong>ctrl-r</strong> 和 <strong>alt-.</strong> 取代。</li>
<li>回到上一个工作路径：<code>cd -</code></li>
<li>如果你输入命令的时候改变了主意，按下 <strong>alt-#</strong> 来在行首添加 <code>#</code>，或者依次按下 <strong>ctrl-a</strong>， <strong>#</strong>， <strong>enter</strong>。这样做的话，之后你可以很方便的利用命令行历史回到你刚才输入到一半的命令。</li>
<li><p>使用 <code>xargs</code> （ 或 <code>parallel</code>）。他们非常给力。注意到你可以控制每行参数个数（<code>-L</code>）和最大并行数（<code>-P</code>）。如果你不确定它们是否会按你想的那样工作，先使用 <code>xargs echo</code> 查看一下。此外，使用 <code>-I{}</code> 会很方便。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">'*.py'</span> | xargs grep some_<span class="keyword">function</span></span><br><span class="line">cat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>pstree -p</code> 有助于展示进程树。</p>
</li>
<li>使用 <code>pgrep</code> 和 <code>pkill</code> 根据名字查找进程或发送信号（<code>-f</code> 参数通常有用）。</li>
<li>了解你可以发往进程的信号的种类。比如，使用 <code>kill -STOP [pid]</code> 停止一个进程。使用 <code>man 7 signal</code> 查看详细列表。</li>
<li>使用 <code>nohup</code> 或 <code>disown</code> 使一个后台进程持续运行。</li>
<li>使用 <code>netstat -lntp</code> 或 <code>ss -plat</code> 检查哪些进程在监听端口（默认是检查 TCP 端口; 使用参数 <code>-u</code> 检查 UDP 端口）。</li>
<li>有关打开套接字和文件，请参阅 <code>lsof</code>。</li>
<li>使用 <code>uptime</code> 或 <code>w</code> 来查看系统已经运行多长时间。</li>
<li>使用 <code>alias</code> 来创建常用命令的快捷形式。例如：<code>alias ll=&#39;ls -latr&#39;</code> 使你可以方便地执行<code>ls -latr</code>命令。</li>
<li><p>在 Bash 脚本中，使用 <code>set -x</code> 去调试输出，尽可能的使用严格模式，使用 <code>set -e</code> 令脚本在发生错误时退出而不是继续运行，使用 <code>set -u</code> 来检查是否使用了未赋值的变量，使用 <code>set -o pipefail</code> 严谨地对待错误（尽管问题可能很微妙）。当牵扯到很多脚本时，使用 <code>trap</code>。一个好的习惯是在脚本文件开头这样写，这会使它检测一些错误，并在错误发生时中断程序并输出信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -euo pipefail</span><br><span class="line"><span class="built_in">trap</span> <span class="string">"echo 'error: Script failed: see failed command above'"</span> ERR</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Bash 脚本中，子 shell（使用括号 <code>(...)</code>）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># do something in current dir</span></span><br><span class="line">(<span class="built_in">cd</span> /some/other/dir &amp;&amp; other-command)</span><br><span class="line"><span class="comment"># continue in original dir</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Bash 中，要注意其中有许多形式的扩展。检查变量是否存在：<code>${name:?error message}</code>。例如，当 Bash 脚本需要一个参数时，可以使用这样的代码 <code>input_file=${1:?usage: $0 input_file}</code>。数学表达式：<code>i=$(( (i + 1) % 5 ))</code>。序列：<code>{1..10}</code>。截断字符串：<code>${var%suffix}</code> 和 <code>${var#prefix}</code>。例如，假设 <code>var=foo.pdf</code>，那么 <code>echo ${var%.pdf}.txt</code> 将输出 <code>foo.txt</code>。</p>
</li>
<li><p>使用括号扩展（<code>{</code>…<code>}</code>）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 <code>mv foo.{txt,pdf} some-dir</code>（同时移动两个文件），<code>cp somefile{,.bak}</code>（会被扩展成 <code>cp somefile somefile.bak</code>）或者 <code>mkdir -p test-{a,b,c}/subtest-{1,2,3}</code>（会被扩展成所有可能的组合，并创建一个目录树）。</p>
</li>
<li><p>通过使用 <code>&lt;(some command)</code> 可以将输出视为文件。例如，对比本地文件 <code>/etc/hosts</code> 和一个远程文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)</span><br></pre></td></tr></table></figure>
</li>
<li><p>了解 Bash 中的“here documents”，例如 <code>cat &lt;&lt;EOF ...</code>。</p>
</li>
<li><p>在 Bash 中，同时重定向标准输出和标准错误，<code>some-command &gt;logfile 2&gt;&amp;1</code>。通常，为了保证命令不会在标准输入里残留一个打开了的文件句柄导致你当前所在的终端无法操作，添加 <code>&lt;/dev/null</code> 是一个好习惯。</p>
</li>
<li><p>使用 <code>man ascii</code> 查看具有十六进制和十进制值的ASCII表。<code>man unicode</code>，<code>man utf-8</code>，以及 <code>man latin1</code> 有助于你去了解通用的编码信息。</p>
</li>
<li><p>使用 <code>screen</code> 或 <a href="https://tmux.github.io/" target="_blank" rel="external"><code>tmux</code></a> 来使用多个屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。另一个轻量级的解决方案是 <code>dtach</code>。</p>
</li>
<li><p>ssh 中，了解如何使用 <code>-L</code> 或 <code>-D</code>（偶尔需要用 <code>-R</code>）去开启隧道是非常有用的，例如当你需要从一台远程服务器上访问 web。</p>
</li>
<li><p>对 ssh 设置做一些小优化可能是很有用的，例如这个 <code>~/.ssh/config</code> 文件包含了防止特定环境下断开连接、压缩数据、多通道等选项：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TCPKeepAlive=<span class="literal">yes</span></span><br><span class="line">ServerAliveInterval=<span class="number">15</span></span><br><span class="line">ServerAliveCountMax=<span class="number">6</span></span><br><span class="line">Compression=<span class="literal">yes</span></span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath <span class="regexp">/tmp/</span>%r@%<span class="attribute">h</span>:%p</span><br><span class="line">ControlPersist <span class="literal">yes</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>部分其他的关于 ssh 的选项是安全敏感且应当小心启用的。例如在可信任的网络中：<code>StrictHostKeyChecking=no</code>，<code>ForwardAgent=yes</code></p>
</li>
<li><p>考虑使用 <a href="https://mosh.mit.edu/" target="_blank" rel="external"><code>mosh</code></a> 作为 ssh 的替代品，它使用 UDP 协议。</p>
</li>
<li><p>获取文件的八进制格式权限，使用类似如下的代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> -c <span class="string">'%A %a %n'</span> /etc/timezone</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <a href="https://github.com/mooz/percol" target="_blank" rel="external"><code>percol</code></a> 或者 <a href="https://github.com/junegunn/fzf" target="_blank" rel="external"><code>fzf</code></a> 可以交互式地从另一个命令输出中选取值。</p>
</li>
<li><p>使用 <code>fpp</code>（<a href="https://github.com/facebook/PathPicker" target="_blank" rel="external">PathPicker</a>）可以与基于另一个命令(例如 <code>git</code>）输出的文件交互。</p>
</li>
<li><p>将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：<br><code>python -m SimpleHTTPServer 7777</code> （使用端口 7777 和 Python 2）或<code>python -m http.server 7777</code> （使用端口 7777 和 Python 3）。</p>
</li>
<li><p>以某种权限执行命令，使用<code>sudo</code>（root 权限）或<code>sudo -u</code>（其他用户）。使用<code>su</code>或者<code>sudo bash</code>来启动一个以对应用户权限运行的 shell。使用<code>su -</code>模拟其他用户的登录。</p>
</li>
</ul>
<h2 id="u6587_u4EF6_u53CA_u6570_u636E_u5904_u7406"><a href="#u6587_u4EF6_u53CA_u6570_u636E_u5904_u7406" class="headerlink" title="文件及数据处理"></a>文件及数据处理</h2><ul>
<li><p>在当前路径下通过文件名定位一个文件，<code>find . -iname &#39;*something*&#39;</code>（或类似的）。在所有路径下通过文件名查找文件，使用 <code>locate something</code> （但请记住 <code>updatedb</code> 可能没有对最近新建的文件建立索引）。</p>
</li>
<li><p>使用 <a href="https://github.com/ggreer/the_silver_searcher" target="_blank" rel="external"><code>ag</code></a> 在源代码或数据文件里检索（比 <code>grep -r</code> 更好）。</p>
</li>
<li><p>将 HTML 转为文本：<code>lynx -dump -stdin</code></p>
</li>
<li><p>Markdown，HTML，以及所有文档格式之间的转换，试试 <a href="http://pandoc.org/" target="_blank" rel="external"><code>pandoc</code></a>。</p>
</li>
<li><p>如果你不得不处理 XML，<code>xmlstarlet</code> 宝刀未老。</p>
</li>
<li><p>使用 <a href="http://stedolan.github.io/jq/" target="_blank" rel="external"><code>jq</code></a> 处理 JSON。</p>
</li>
<li><p>使用 <a href="https://github.com/0k/shyaml" target="_blank" rel="external"><code>shyaml</code></a> 处理 YAML。</p>
</li>
<li><p>Excel 或 CSV 文件的处理，<a href="https://github.com/onyxfish/csvkit" target="_blank" rel="external">csvkit</a> 提供了 <code>in2csv</code>，<code>csvcut</code>，<code>csvjoin</code>，<code>csvgrep</code> 等工具。</p>
</li>
<li><p>关于 Amazon S3，<a href="https://github.com/s3tools/s3cmd" target="_blank" rel="external"><code>s3cmd</code></a> 很方便而 <a href="https://github.com/bloomreach/s4cmd" target="_blank" rel="external"><code>s4cmd</code></a> 更快。Amazon 官方的 <a href="https://github.com/aws/aws-cli" target="_blank" rel="external"><code>aws</code></a> 以及  <a href="https://github.com/donnemartin/saws" target="_blank" rel="external"><code>saws</code></a> 是其他 AWS 相关工作的基础。</p>
</li>
<li><p>了解如何使用 <code>sort</code> 和 <code>uniq</code>，包括 uniq 的 <code>-u</code> 参数和 <code>-d</code> 参数，详见后文单行脚本节。另外可以了解一下 <code>comm</code>。</p>
</li>
<li><p>了解如何使用 <code>cut</code>，<code>paste</code> 和 <code>join</code> 来更改文件。很多人都会使用 <code>cut</code>，但几乎都不会使用 <code>join</code>。</p>
</li>
<li><p>了解如何运用 <code>wc</code> 去计算新行数（<code>-l</code>），字符数（<code>-m</code>），单词数（<code>-w</code>）以及字节数（<code>-c</code>）。</p>
</li>
<li><p>了解如何使用 <code>tee</code> 将标准输入复制到文件甚至标准输出，例如 <code>ls -al | tee file.txt</code>。</p>
</li>
<li><p>了解语言环境对许多命令行工具的微妙影响，包括排序的顺序和性能。大多数 Linux 的安装过程会将 <code>LANG</code> 或其他有关的变量设置为符合本地的设置。意识到当你改变语言环境时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降<em>许多倍</em>。某些情况下（例如集合运算）你可以放心的使用 <code>export LC_ALL=C</code> 来忽略掉国际化并使用基于字节的顺序。</p>
</li>
<li><p>了解 <code>awk</code> 和 <code>sed</code> 关于数据的简单处理的用法。例如，将文本文件中第三列的所有数字求和：<code>awk &#39;{ x += $3 } END { print x }&#39;</code>. 这可能比同等作用的 Python 代码快三倍且代码量少三倍。</p>
</li>
<li><p>替换一个或多个文件中出现的字符串：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pi.bak <span class="operator">-e</span> <span class="string">'s/old-string/new-string/g'</span> my-files-*.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <a href="https://github.com/jlevy/repren" target="_blank" rel="external"><code>repren</code></a> 来批量重命名，或是在多个文件中搜索替换。（有些时候 <code>rename</code> 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Full rename of filenames, directories, and contents foo -&gt; bar:</span></span><br><span class="line">repren --full --preserve-case --from foo --to bar .</span><br><span class="line"><span class="comment"># Recover backup files whatever.bak -&gt; whatever:</span></span><br><span class="line">repren --renames --from <span class="string">'(.*)\.bak'</span> --to <span class="string">'\1'</span> *.bak</span><br><span class="line"><span class="comment"># Same as above, using rename, if available:</span></span><br><span class="line">rename <span class="string">'s/\.bak$//'</span> *.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据 man 页面的描述，<code>rsync</code> 真的是一个快速且非常灵活的文件复制工具。它通常被用于机器间的同步，但在本地也同样有用。它同时也是删除大量文件的<a href="https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html" target="_blank" rel="external">最快方法</a>之一：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>shuf</code> 从一个文件中随机选取多行。</p>
</li>
<li><p>了解 <code>sort</code> 的参数。处理数字方面，使用 <code>-n</code> 或者 <code>-h</code> 来处理可读性数字（例如 <code>du -h</code> 的输出）。明白键的工作原理（<code>-t</code> 和 <code>-k</code>）。例如，注意到你需要 <code>-k1，1</code> 来仅按第一个域来排序，而 <code>-k1</code> 意味着按整行排序。稳定排序（<code>sort -s</code>）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 <code>sort -k1，1 | sort -s -k2，2</code>。</p>
</li>
<li><p>如果你想在 Bash 命令行中写 tab 制表符，按下 <strong>ctrl-v</strong> <strong>[Tab]</strong> 或键入 <code>$&#39;\t&#39;</code> （后者可能更好，因为你可以复制粘贴它）。</p>
</li>
<li><p>标准的源代码对比及合并工具是 <code>diff</code> 和 <code>patch</code>。使用 <code>diffstat</code> 查看变更总览数据。注意到 <code>diff -r</code> 对整个文件夹有效。使用 <code>diff -r tree1 tree2 | diffstat</code> 查看变更总览数据。</p>
</li>
<li><p>对于二进制文件，使用 <code>hd</code> 使其以十六进制显示以及使用 <code>bvi</code> 来编辑二进制。</p>
</li>
<li><p>同样对于二进制文件，<code>strings</code>（包括 <code>grep</code> 等等）允许你查找一些文本。</p>
</li>
<li><p>二进制文件对比（Delta 压缩），使用 <code>xdelta3</code>。</p>
</li>
<li><p>使用 <code>iconv</code> 更改文本编码。而更高级的用法，可以使用 <code>uconv</code>，它支持一些高级的 Unicode 功能。例如，这条命令将所有元音字母转为小写并移除了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uconv <span class="operator">-f</span> utf-<span class="number">8</span> -t utf-<span class="number">8</span> -x <span class="string">'::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; '</span> &lt; input.txt &gt; output.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>拆分文件，查看 <code>split</code>（按大小拆分）和 <code>csplit</code>（按模式拆分）。</p>
</li>
<li><p>用 <a href="http://www.fresse.org/dateutils/" target="_blank" rel="external"><code>dateutils</code></a> 中的 <code>dateadd</code>, <code>datediff</code>, <code>strptime</code> 等工具操作日期和时间表达式。</p>
</li>
<li><p>使用 <code>zless</code>，<code>zmore</code>，<code>zcat</code> 和 <code>zgrep</code> 对压缩过的文件进行操作。</p>
</li>
</ul>
<h2 id="u7CFB_u7EDF_u8C03_u8BD5"><a href="#u7CFB_u7EDF_u8C03_u8BD5" class="headerlink" title="系统调试"></a>系统调试</h2><ul>
<li><p><code>curl</code> 和 <code>curl -I</code> 可以便捷地被应用于 web 调试中，它们的好兄弟 <code>wget</code> 也可以，或者是更潮的 <a href="https://github.com/jakubroztocil/httpie" target="_blank" rel="external"><code>httpie</code></a>。</p>
</li>
<li><p>使用 <code>iostat</code>、<code>netstat</code>、<code>top</code> （<code>htop</code> 更佳）和 <code>dstat</code> 去获取硬盘、cpu 和网络的状态。熟练掌握这些工具可以使你快速的对系统的当前状态有一个大概的认识。</p>
</li>
<li><p>使用 <code>netstat</code> 和 <code>ss</code> 查看网络连接的细节。</p>
</li>
<li><p>若要对系统有一个深度的总体认识，使用 <a href="https://github.com/nicolargo/glances" target="_blank" rel="external"><code>glances</code></a>。它在一个终端窗口中向你提供一些系统级的数据。这对于快速的检查各个子系统非常有帮助。</p>
</li>
<li><p>若要了解内存状态，运行并理解 <code>free</code> 和 <code>vmstat</code> 的输出。尤其注意“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，因此它与空闲内存无关。</p>
</li>
<li><p>Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 <code>kill -3 &lt;pid&gt;</code> 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准输出/日志文件。JDK 中的 <code>jps</code>，<code>jstat</code>，<code>jstack</code>，<code>jmap</code> 很有用。<a href="https://github.com/aragozin/jvm-tools" target="_blank" rel="external">SJK tools</a> 更高级.</p>
</li>
<li><p>使用 <code>mtr</code> 去跟踪路由，用于确定网络问题。</p>
</li>
<li><p>用 <code>ncdu</code> 来查看磁盘使用情况，它比常用的命令，如 <code>du -sh *</code>，更节省时间。</p>
</li>
<li><p>查找正在使用带宽的套接字连接或进程，使用 <code>iftop</code> 或 <code>nethogs</code>。</p>
</li>
<li><p><code>ab</code> 工具（捆绑于 Apache）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 <code>siege</code>。</p>
</li>
<li><p><code>wireshark</code>，<code>tshark</code> 和 <code>ngrep</code> 可用于复杂的网络调试。</p>
</li>
<li><p>了解 <code>strace</code> 和 <code>ltrace</code>。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（<code>-c</code>）和附加到一个运行的进程参数 （<code>-p</code>）。</p>
</li>
<li><p>了解使用 <code>ldd</code> 来检查共享库。</p>
</li>
<li><p>了解如何运用 <code>gdb</code> 连接到一个运行着的进程并获取它的堆栈轨迹。</p>
</li>
<li><p>学会使用 <code>/proc</code>。它在调试正在出现的问题的时候有时会效果惊人。比如：<code>/proc/cpuinfo</code>，<code>/proc/meminfo</code>，<code>/proc/cmdline</code>，<code>/proc/xxx/cwd</code>，<code>/proc/xxx/exe</code>，<code>/proc/xxx/fd/</code>，<code>/proc/xxx/smaps</code>（这里的 <code>xxx</code> 表示进程的 id 或 pid）。</p>
</li>
<li><p>当调试一些之前出现的问题的时候，<code>sar</code> 非常有用。它展示了 cpu、内存以及网络等的历史数据。</p>
</li>
<li><p>关于更深层次的系统分析以及性能分析，看看 <code>stap</code>（<a href="https://sourceware.org/systemtap/wiki" target="_blank" rel="external">SystemTap</a>），<a href="http://en.wikipedia.org/wiki/Perf_(Linux" target="_blank" rel="external"><code>perf</code></a>)，以及<a href="https://github.com/draios/sysdig" target="_blank" rel="external"><code>sysdig</code></a>。</p>
</li>
<li><p>查看你当前使用的系统，使用 <code>uname</code> ， <code>uname -a</code> （Unix／kernel 信息） 或者 <code>lsb_release -a</code> （Linux 发行版信息）。</p>
</li>
<li><p>无论什么东西工作得很欢乐时试试 <code>dmesg</code>（可能是硬件或驱动问题）。</p>
</li>
</ul>
<h2 id="u5355_u884C_u811A_u672C"><a href="#u5355_u884C_u811A_u672C" class="headerlink" title="单行脚本"></a>单行脚本</h2><p>一些命令组合的例子：</p>
<ul>
<li><p>当你需要对文本文件做集合交、并、差运算时，结合使用 <code>sort</code>/<code>uniq</code> 很有帮助。假设 <code>a</code> 与 <code>b</code> 是两内容不同的文件。这种方式效率很高，并且在小文件和上G的文件上都能运用 （<code>sort</code> 不被内存大小约束，尽管在 <code>/tmp</code> 在一个小的根分区上时你可能需要 <code>-T</code> 参数），参阅前文中关于 <code>LC_ALL</code> 和 <code>sort</code> 的 <code>-u</code> 参数的部分。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat a b | sort | uniq &gt; c   <span class="comment"># c is a union b</span></span><br><span class="line">cat a b | sort | uniq <span class="operator">-d</span> &gt; c   <span class="comment"># c is a intersect b</span></span><br><span class="line">cat a b b | sort | uniq -u &gt; c   <span class="comment"># c is set difference a - b</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>grep . *</code>（每行都会附上文件名）或者 <code>head -100 *</code>（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 <code>/sys</code>、<code>/proc</code>、<code>/etc</code>）时特别好用。</p>
</li>
<li><p>计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123; x += $3 &#125; END &#123; print x &#125;'</span> myfile</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你想在文件树上查看大小/日期，这可能看起来像递归版的 <code>ls -l</code> 但比 <code>ls -lR</code> 更易于理解：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -ls</span><br></pre></td></tr></table></figure>
</li>
<li><p>假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 <code>acct_id</code> 参数在URI中。如果你想计算出每个 <code>acct_id</code> 值有多少次请求，使用如下代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | egrep -o <span class="string">'acct_id=[0-9]+'</span> | cut <span class="operator">-d</span>= <span class="operator">-f</span>2 | sort | uniq -c | sort -rn</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">taocl</span></span>() &#123;</span><br><span class="line">  curl <span class="operator">-s</span> https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |</span><br><span class="line">    pandoc <span class="operator">-f</span> markdown -t html |</span><br><span class="line">    xmlstarlet fo --html --dropdtd |</span><br><span class="line">    xmlstarlet sel -t -v <span class="string">"(html/body/ul/li[count(p)&gt;0])[<span class="variable">$RANDOM</span> mod last()+1]"</span> |</span><br><span class="line">    xmlstarlet unesc | fmt -<span class="number">80</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="u51B7_u95E8_u4F46_u6709_u7528"><a href="#u51B7_u95E8_u4F46_u6709_u7528" class="headerlink" title="冷门但有用"></a>冷门但有用</h2><ul>
<li><p><code>expr</code>：计算表达式或正则匹配</p>
</li>
<li><p><code>m4</code>：简单地宏处理器</p>
</li>
<li><p><code>yes</code>：多次打印字符串</p>
</li>
<li><p><code>cal</code>：漂亮的日历</p>
</li>
<li><p><code>env</code>：执行一个命令（脚本文件中很有用）</p>
</li>
<li><p><code>printenv</code>：打印环境变量（调试时或在使用脚本文件时很有用）</p>
</li>
<li><p><code>look</code>：查找以特定字符串开头的单词</p>
</li>
<li><p><code>cut</code>、<code>paste</code> 和 <code>join</code>：数据修改</p>
</li>
<li><p><code>fmt</code>：格式化文本段落</p>
</li>
<li><p><code>pr</code>：将文本格式化成页/列形式</p>
</li>
<li><p><code>fold</code>：包裹文本中的几行</p>
</li>
<li><p><code>column</code>：将文本格式化成多列或表格</p>
</li>
<li><p><code>expand</code> 和 <code>unexpand</code>：制表符与空格之间转换</p>
</li>
<li><p><code>nl</code>：添加行号</p>
</li>
<li><p><code>seq</code>：打印数字</p>
</li>
<li><p><code>bc</code>：计算器</p>
</li>
<li><p><code>factor</code>：分解因数</p>
</li>
<li><p><a href="https://gnupg.org/" target="_blank" rel="external"><code>gpg</code></a>：加密并签名文件</p>
</li>
<li><p><code>toe</code>：terminfo entries 列表</p>
</li>
<li><p><code>nc</code>：网络调试及数据传输</p>
</li>
<li><p><code>socat</code>：套接字代理，与 <code>netcat</code> 类似</p>
</li>
<li><p><a href="https://github.com/mattthias/slurm" target="_blank" rel="external"><code>slurm</code></a>：网络可视化</p>
</li>
<li><p><code>dd</code>：文件或设备间传输数据</p>
</li>
<li><p><code>file</code>：确定文件类型</p>
</li>
<li><p><code>tree</code>：以树的形式显示路径和文件，类似于递归的 <code>ls</code></p>
</li>
<li><p><code>stat</code>：文件信息</p>
</li>
<li><p><code>time</code>：执行命令，并计算执行时间</p>
</li>
<li><p><code>lockfile</code>：使文件只能通过 <code>rm -f</code> 移除</p>
</li>
<li><p><code>logrotate</code>: 切换、压缩以及发送日志文件</p>
</li>
<li><p><code>watch</code>：重复运行同一个命令，展示结果并高亮有更改的部分</p>
</li>
<li><p><code>tac</code>：反向输出文件</p>
</li>
<li><p><code>shuf</code>：文件中随机选取几行</p>
</li>
<li><p><code>comm</code>：一行一行的比较排序过的文件</p>
</li>
<li><p><code>pv</code>：监视通过管道的数据</p>
</li>
<li><p><code>hd</code>，<code>hexdump</code>，<code>xxd</code>，<code>biew</code> 和 <code>bvi</code>：保存或编辑二进制文件</p>
</li>
<li><p><code>strings</code>：从二进制文件中抽取文本</p>
</li>
<li><p><code>tr</code>：转换字母</p>
</li>
<li><p><code>iconv</code> 或 <code>uconv</code>：简易的文件编码</p>
</li>
<li><p><code>split</code> 和 <code>csplit</code>：分割文件</p>
</li>
<li><p><code>sponge</code>：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 <code>grep -v something some-file | sponge some-file</code></p>
</li>
<li><p><code>units</code>：将一种计量单位转换为另一种等效的计量单位（参阅 <code>/usr/share/units/definitions.units</code>）</p>
</li>
<li><p><code>apg</code>：随机生成密码</p>
</li>
<li><p><code>7z</code>：高比例的文件压缩</p>
</li>
<li><p><code>ldd</code>：动态库信息</p>
</li>
<li><p><code>nm</code>：提取 obj 文件中的符号</p>
</li>
<li><p><code>ab</code>：性能分析 web 服务器</p>
</li>
<li><p><code>strace</code>：系统调用调试</p>
</li>
<li><p><code>mtr</code>：更好的网络调试跟踪工具</p>
</li>
<li><p><code>cssh</code>：可视化的并发 shell</p>
</li>
<li><p><code>rsync</code>：通过 ssh 或本地文件系统同步文件和文件夹</p>
</li>
<li><p><code>wireshark</code> 和 <code>tshark</code>：抓包和网络调试工具</p>
</li>
<li><p><code>ngrep</code>：网络层的 grep</p>
</li>
<li><p><code>host</code> 和 <code>dig</code>：DNS 查找</p>
</li>
<li><p><code>lsof</code>：列出当前系统打开文件的工具以及查看端口信息</p>
</li>
<li><p><code>dstat</code>：系统状态查看</p>
</li>
<li><p><a href="https://github.com/nicolargo/glances" target="_blank" rel="external"><code>glances</code></a>：高层次的多子系统总览</p>
</li>
<li><p><code>iostat</code>：硬盘使用状态</p>
</li>
<li><p><code>mpstat</code>: CPU 使用状态</p>
</li>
<li><p><code>vmstat</code>: 内存使用状态</p>
</li>
<li><p><code>htop</code>：top 的加强版</p>
</li>
<li><p><code>last</code>：登入记录</p>
</li>
<li><p><code>w</code>：查看处于登录状态的用户</p>
</li>
<li><p><code>id</code>：用户/组 ID 信息</p>
</li>
<li><p><code>sar</code>：系统历史数据</p>
</li>
<li><p><code>iftop</code> 或 <code>nethogs</code>：套接字及进程的网络利用</p>
</li>
<li><p><code>ss</code>：套接字数据</p>
</li>
<li><p><code>dmesg</code>：引导及系统错误信息</p>
</li>
<li><p><code>sysctl</code>: 在内核运行时动态地查看和修改内核的运行参数</p>
</li>
<li><p><code>hdparm</code>：SATA/ATA 磁盘更改及性能分析</p>
</li>
<li><p><code>lsb_release</code>：Linux 发行版信息</p>
</li>
<li><p><code>lsblk</code>：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息</p>
</li>
<li><p><code>lshw</code>，<code>lscpu</code>，<code>lspci</code>，<code>lsusb</code> 和 <code>dmidecode</code>：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等</p>
</li>
<li><p><code>lsmod</code> 和 <code>modinfo</code>：列出内核模块，并显示其细节</p>
</li>
<li><p><code>fortune</code>，<code>ddate</code> 和 <code>sl</code>：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用”</p>
</li>
</ul>
<h2 id="u4EC5_u9650_MacOS_X__u7CFB_u7EDF"><a href="#u4EC5_u9650_MacOS_X__u7CFB_u7EDF" class="headerlink" title="仅限 MacOS X 系统"></a>仅限 MacOS X 系统</h2><p>以下是<em>仅限于</em> MacOS 系统的技巧</p>
<ul>
<li><p>用 <code>brew</code> （Homebrew）或者 <code>port</code> （MacPorts）进行包管理。这些可以用来在 Mac 系统上安装以上的大多数命令。</p>
</li>
<li><p>用 <code>pbcopy</code> 复制任何命令的输出到桌面应用，用 <code>pbpaste</code> 粘贴输入。</p>
</li>
<li><p>若要在 Mac OS 终端中将 Option 键视为 alt 键（例如在上面介绍的 <strong>alt-b</strong>, <strong>alt-f</strong> 等命令中用到），打开 偏好设置 -&gt; 描述文件 -&gt; 键盘 并勾选“使用 Option 键作为 Meta 键”。</p>
</li>
<li><p>用 <code>open</code> 或者 <code>open -a /Applications/Whatever.app</code> 使用桌面应用打开文件。</p>
</li>
<li><p>Spotlight： 用 <code>mdfind</code> 搜索文件，用 <code>mdls</code> 列出元数据（例如照片的 EXIF 信息）。</p>
</li>
<li><p>注意 MacOS 系统是基于 BSD UNIX 的，许多命令（例如 <code>ps</code>，<code>ls</code>，<code>tail</code>，<code>awk</code>，<code>sed</code>）都和 Linux 中有些微的不同，这些极大的被 System V-style Unix 和 GNU 工具影响。你可以通过标题为 “BSD General Commands Manual” 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 <code>gawk</code> 和 <code>gsed</code> 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 <code>perl</code> ）或者经过仔细的测试。</p>
</li>
<li><p>用 <code>sw_vers</code> 获取 MacOS 的版本信息。</p>
</li>
</ul>
<h2 id="u66F4_u591A_u8D44_u6E90"><a href="#u66F4_u591A_u8D44_u6E90" class="headerlink" title="更多资源"></a>更多资源</h2><ul>
<li><a href="https://github.com/alebcay/awesome-shell" target="_blank" rel="external">awesome-shell</a>：一份精心组织的命令行工具及资源的列表。</li>
<li><a href="https://github.com/herrbischoff/awesome-osx-command-line" target="_blank" rel="external">awesome-osx-command-line</a>：一份针对 Mac OS 命令行的更深入的指南。</li>
<li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/" target="_blank" rel="external">Strict mode</a>：为了编写更好的脚本文件。</li>
<li><a href="https://github.com/koalaman/shellcheck" target="_blank" rel="external">shellcheck</a>：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。</li>
<li><a href="http://www.dwheeler.com/essays/filenames-in-shell.html" target="_blank" rel="external">Filenames and Pathnames in Shell</a>：有关如何在 shell 脚本里正确处理文件名的细枝末节。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Shell 可以说是程序员最好的帮手了，这里简单记录一些常用的技巧，包括 shell 脚本与常用的命令。</p>]]>
    
    </summary>
    
      <category term="命令行" scheme="http://wdxtub.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="技巧" scheme="http://wdxtub.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SVN 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/svn-guide/"/>
    <id>http://wdxtub.com/2016/03/24/svn-guide/</id>
    <published>2016-03-24T20:34:47.000Z</published>
    <updated>2016-03-24T20:35:18.000Z</updated>
    <content type="html"><![CDATA[<p>国内不少云平台都只支持 SVN，所以还是需要了解基本的操作的。和 Git 的思路不大一样，SVN 等于是总-分结构，虽然可能不如 git 灵活，但是还是比较方便的。</p>
<a id="more"></a>
<hr>
<h2 id="u64CD_u4F5C_u6D41_u7A0B"><a href="#u64CD_u4F5C_u6D41_u7A0B" class="headerlink" title="操作流程"></a>操作流程</h2><p>常见的操作如下：</p>
<ul>
<li>checkout（检出）项目</li>
<li>增加文件或目录 — add(增加)，commit(提交)</li>
<li>修改文件或目录 — commit(提交)</li>
<li>删除文件或目录 — commit(提交)</li>
<li>更新文件或目录 — update(更新)</li>
</ul>
<p>其中，checkout只进行一次，以后使用update更新即可。update、commit、add操作根据需要会经常使用。</p>
<p>简单来说可以这样理解：</p>
<ul>
<li>项目中增加了文件或目录，需要先通知服务器要增加，所以首先要 add</li>
<li>然后如果要让服务器知道这些变动，就 commit，具体参加下面的命令</li>
<li>如果要从服务器获取最新的代码，就 update</li>
</ul>
<p>首先checkout出$appname的svn仓库。</p>
<pre><code>$ svn checkout https://svn.sinacloud.com/$appname
</code></pre><p>进入代码目录，创建一个新的子目录 <code>1</code> 作为版本1的代码目录。</p>
<pre><code>$ mkdir 1
</code></pre><p>进入版本1的代码目录，编辑代码并版本1的代码部署到线上。</p>
<pre><code>$ svn add .
$ svn commit -m &quot;make it better&quot;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>国内不少云平台都只支持 SVN，所以还是需要了解基本的操作的。和 Git 的思路不大一样，SVN 等于是总-分结构，虽然可能不如 git 灵活，但是还是比较方便的。</p>]]>
    
    </summary>
    
      <category term="版本控制" scheme="http://wdxtub.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim 基本操作]]></title>
    <link href="http://wdxtub.com/2016/03/24/vim-basic-op/"/>
    <id>http://wdxtub.com/2016/03/24/vim-basic-op/</id>
    <published>2016-03-24T20:23:06.000Z</published>
    <updated>2016-03-24T20:31:14.000Z</updated>
    <content type="html"><![CDATA[<p>虽然我还是喜欢图形化界面编辑器，但是有的时候登录到远程机器，不得不使用 vim 来编辑文件，这里记录下基本的操作。</p>
<a id="more"></a>
<hr>
<ul>
<li><code>i</code> 进入 Insert 模式</li>
<li><code>x</code> 删除当前光标所在的字符</li>
<li><code>:w</code> 存盘(后面可以跟文件名) </li>
<li><code>:q</code> 退出</li>
<li><code>:wq</code> 存盘并退出</li>
<li><code>dd</code> 删除当前行，并存到剪贴板里</li>
<li><code>p</code> 粘贴剪贴板</li>
<li><code>:help &lt;command&gt;</code> 要 :q 退出帮助</li>
</ul>
<p>如何浏览帮助呢？请牢记如下秘籍：</p>
<ul>
<li>移动: 使用光标键，或者用 h 向左，j 向下，k 向上，l 向右。</li>
<li>退出: 使用 :q<enter>。</enter></li>
<li>跳转到一个主题: 将光标置于标签 (例如 usr_01.txt) 上然后输入 CTRL-]。</li>
<li>跳回: 键入 CTRL-T。</li>
<li>翻页：键入 CTRL-F/B</li>
</ul>
<h2 id="u63D2_u5165_u6A21_u5F0F"><a href="#u63D2_u5165_u6A21_u5F0F" class="headerlink" title="插入模式"></a>插入模式</h2><ul>
<li><code>a</code> 在光标后插入</li>
<li><code>o</code> 在当前行后插入一个新行</li>
<li><code>O</code> 在当前行前插入一个新行</li>
<li><code>cw</code> 替换从光标所在位置后到一个单词结尾的字符</li>
</ul>
<h2 id="u79FB_u52A8_u5149_u6807"><a href="#u79FB_u52A8_u5149_u6807" class="headerlink" title="移动光标"></a>移动光标</h2><ul>
<li><code>0</code> 数字零，到行头</li>
<li><code>^</code> 到本行第一个不是blank字符的位置</li>
<li><code>$</code> 到本行行尾</li>
<li><code>g_</code> 到本行最后一个不是blank字符的位置。</li>
<li><code>/pattern</code> 搜索 pattern 的字符串(按n到下一个)</li>
<li><code>w b</code> 词移动</li>
</ul>
<h2 id="u62F7_u8D1D/_u7C98_u8D34"><a href="#u62F7_u8D1D/_u7C98_u8D34" class="headerlink" title="拷贝/粘贴"></a>拷贝/粘贴</h2><ul>
<li><code>p</code> 在当前位置之后粘贴</li>
<li><code>P</code> 在当前位置之前粘贴</li>
<li><code>yy</code> 拷贝当前行，相当于 ddP</li>
</ul>
<h2 id="u64A4_u9500/_u91CD_u505A"><a href="#u64A4_u9500/_u91CD_u505A" class="headerlink" title="撤销/重做"></a>撤销/重做</h2><ul>
<li><code>u</code> undo</li>
<li><code>&lt;C-r&gt;</code> redo</li>
</ul>
<h2 id="u6253_u5F00/_u4FDD_u5B58/_u9000_u51FA/_u6539_u53D8_u6587_u4EF6_28Buffer_29"><a href="#u6253_u5F00/_u4FDD_u5B58/_u9000_u51FA/_u6539_u53D8_u6587_u4EF6_28Buffer_29" class="headerlink" title="打开/保存/退出/改变文件(Buffer)"></a>打开/保存/退出/改变文件(Buffer)</h2><ul>
<li><code>:e &lt;path/to/file&gt;</code> 打开一个文件</li>
<li><code>:w</code> 存盘</li>
<li><code>:saveas &lt;path/to/file&gt;</code> 另存为 <code>&lt;path/to/file&gt;</code></li>
<li><code>:x</code>, <code>ZZ</code> 或 <code>:wq</code> 保存并退出</li>
<li><code>:q!</code> 退出不保存 </li>
<li><code>:qa!</code> 强行退出所有文件。</li>
<li><code>:bn</code> 和 <code>:bp</code> 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。</li>
</ul>
<h2 id="u6280_u5DE7"><a href="#u6280_u5DE7" class="headerlink" title="技巧"></a>技巧</h2><ol>
<li>打开 Vim之后，可以用 <code>:split filename</code>或 <code>:vsplit filename</code> 或 <code>new filename</code> 横向或纵向切割窗口，使用 <code>ctrl + w</code> 可以在个窗口之间跳转，使用 <code>ctrl + 方向键</code> 可以按照方向切换窗口。</li>
<li>用 Vim 打开一个文件，如果我们想实现所有文本行翻转，那么可以执行如下命令：<code>:g/^/m 0</code></li>
<li>在 Vim 中统计文本行数和当前光标的位置，可以使用 <code>ctrl + g</code>，统计字节数，可以使用 <code>g + ctrl + g</code></li>
<li>对文本进行简单排序：用 <code>shift v</code> 选中多行文本，输入 <code>:!sort</code>，看看效果如何</li>
<li>如果你想把当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么依次执行如下命令： 在当前目录下执行：</li>
</ol>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim</span><br><span class="line">:n <span class="keyword">*</span><span class="keyword">*</span>/<span class="keyword">*</span>.java</span><br><span class="line">:argdo %s/apache/eclipse/ge |<span class="string"> update</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然我还是喜欢图形化界面编辑器，但是有的时候登录到远程机器，不得不使用 vim 来编辑文件，这里记录下基本的操作。</p>]]>
    
    </summary>
    
      <category term="编辑器" scheme="http://wdxtub.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gradle 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/gradle-guide/"/>
    <id>http://wdxtub.com/2016/03/24/gradle-guide/</id>
    <published>2016-03-24T20:14:58.000Z</published>
    <updated>2016-03-24T20:18:40.000Z</updated>
    <content type="html"><![CDATA[<p>Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。它提供灵活的通用构建工具，就像ant。同时完美兼容Maven或Ivy仓库</p>
<a id="more"></a>
<hr>
<p>Gradle的特点：</p>
<ul>
<li>一个像Ant一样非常灵活的通用构建工具</li>
<li>一种可切换的，像Maven一样基于约定的构建框架，约定优于配置</li>
<li>强大的对于多工程构建的支持</li>
<li>完全支持现有的Maven和lvy仓库</li>
<li>支持传递性依赖管理，而不需要远程仓库或者是pom.xml和ivy.xml文件</li>
<li>非常适合构建Ant tasks和build</li>
<li>支持Groovy构建脚本</li>
<li>非常丰富的域模型来描述你的构建</li>
</ul>
<p>2009年7月20日发行第一个版本0.7，到现在已经发行了20个大版本，目前最新版本是2.3。从2.0版本开始，Gradle提供了C和C++的支持，使得Gradle的构建、测试和提交工作不仅限于基于JVM的系统。</p>
<p>从2012年6月发布1.0以来，Gradle一直以八周一个新版本的速率稳步升级，从1.0到2.0，Gradle也逐渐成熟。现在越来越多的Java开发者开始使用Gradle进行项目的自动化构建 </p>
<h2 id="u5B89_u88C5Gradle"><a href="#u5B89_u88C5Gradle" class="headerlink" title="安装Gradle"></a>安装Gradle</h2><p>安装一个 Java JDK 或者 JRE. 而且 Java 版本必须至少是 6 以上<br>从 Gradle网站<a href="http://www.gradle.org/downloads下载任意一个已经发布的版本，并解压到任意目录" target="_blank" rel="external">http://www.gradle.org/downloads下载任意一个已经发布的版本，并解压到任意目录</a></p>
<p>添加一个 GRADLE_HOME 环境变量来指明 Gradle 的安装路径<br>添加 GRADLE_HOME/bin 到您的 PATH 环境变量中</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux:</span><br><span class="line">export GRADLE_HOME=&#123;your gradle path&#125;</span><br><span class="line">export PATH=<span class="variable">$PATH</span>:GRADLE_HOME/bin</span><br></pre></td></tr></table></figure>
<h2 id="Gradle_u7684_u57FA_u672C_u7EC4_u6210"><a href="#Gradle_u7684_u57FA_u672C_u7EC4_u6210" class="headerlink" title="Gradle的基本组成"></a>Gradle的基本组成</h2><p>项目(Project) 和 任务(tasks)，Gradle 里的任何东西都是基于这两个基础概念。</p>
<ul>
<li>项目是指我们的构建产物（比如Jar包）或实施产物（将应用程序部署到生产环境）。</li>
<li>任务是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）。</li>
<li>每一个构建都是由一个或多个 projects 构成的，每一个 project 是由一个或多个 tasks 构成的，一个 task是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）</li>
</ul>
<p><img src="/images/14588506801339.jpg" alt=""></p>
<p>一个工程的Build，是由多个Project组成，而一个Project又是由task组成的</p>
<h2 id="Gradle_u6784_u5EFA_u7CFB_u7EDF_u7684_u7EC4_u6210"><a href="#Gradle_u6784_u5EFA_u7CFB_u7EDF_u7684_u7EC4_u6210" class="headerlink" title="Gradle构建系统的组成"></a>Gradle构建系统的组成</h2><p>任何一个构建系统都是由多个构建文件组成，如Ant是由build.xml组成，Maven是由pom.xml组成，Make是由makefile组成。这些构建脚本定义了一系列的规则来指定项目编译流程。</p>
<p>Gradle的构建系统是由以下几个文件组成</p>
<ul>
<li>build.gradle 我们称这个文件为一个构建脚本，这个脚本定义了一个模块和编译用的tasks，它一般是放在项目的模块中，也可以放在项目的根目录用来作为编译结构全局设置，它是必须的</li>
<li>settings.gradle 它描述了哪一个模块需要参与构建。每一个多模块的构建都必须在项目结构的根目录中加入这个设置文件，它也是必须的</li>
<li>gradle.properties 用来配置构建属性，这个不是必须的</li>
</ul>
<p>settings.gradle和gradle.properties的用法都十分简单，这里就不再多加说明，后面会给出示例，看示例就能明白其用法，现在主要对build.gradle的进行说明。</p>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>Gradle是基于Groovy语言的构建系统（这里并不会详细解释Groovy语法的使用，有需要请参考Groovy的官方文档 — <a href="http://groovy-lang.org/single-page-documentation.html" target="_blank" rel="external">Groovy语法</a>），所以在构建脚本中可以使用Groovy语言来执行一些任务。</p>
<p>下面编写一个简单的build.gradle文件，定义一个task来打印hello world，如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> hello &#123; <span class="comment">//先定义一个hello的task</span></span><br><span class="line">    <span class="keyword">doLast</span> &#123; <span class="comment">//实现doLast方法</span></span><br><span class="line">        <span class="keyword">println</span> <span class="string">'Hello world!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在终端中运行gradle hello命令来执行这个task,就会看到以下输入内容：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">gradle</span> <span class="tag">hello</span></span><br><span class="line"><span class="pseudo">:hello</span></span><br><span class="line"><span class="tag">Hello</span> <span class="tag">world</span>!</span><br></pre></td></tr></table></figure>
<p>对于hello这个task，还可以使用更简单的定义方式，如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> hello &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello world!'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;&lt;</code> 就等价于 doLast，doLast 是gradle提供访问task任务的一个API，类似的还有 doFirst，当一个task被执行的时候，可以通过 doFirst 和 doLast 向task中动态添加操作。doFirst 和 doLast 会在task本身被执行之后才会被执行。例如：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> hello &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Earth'</span></span><br><span class="line">&#125;</span><br><span class="line">hello.<span class="keyword">doFirst</span> &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Venus'</span></span><br><span class="line">&#125;</span><br><span class="line">hello.<span class="keyword">doFirst</span> &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Mercury'</span></span><br><span class="line">&#125;</span><br><span class="line">hello.<span class="keyword">doLast</span> &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Mars'</span></span><br><span class="line">&#125;</span><br><span class="line">hello &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Jupiter'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入如下所示：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">Hello</span> Earth</span><br><span class="line">:hello</span><br><span class="line"><span class="label">Hello</span> Mercury</span><br><span class="line"><span class="label">Hello</span> Venus</span><br><span class="line"><span class="label">Hello</span> <span class="keyword">Mars</span><br><span class="line"></span><span class="label">Hello</span> Jupiter</span><br></pre></td></tr></table></figure>
<h2 id="Task_u4F9D_u8D56"><a href="#Task_u4F9D_u8D56" class="headerlink" title="Task依赖"></a>Task依赖</h2><p>上面示例展示了如何编写一个hello world的task，在Gradle中各个task并不是孤立的，它们可以是相互依赖的。要让一个task依赖另外一个task，只需要在task定义时加入 dependsOn: 说明即可，被依赖的task会优先依赖者被执行，例如：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> hello &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello world!'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">task</span> intro(dependsOn: hello) &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">"I'm Gradle"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行gradle intro命令后可以看到以下输出：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="blockquote">&gt; gradle intro</span></span><br><span class="line">Hello world!</span><br><span class="line">I'm Gradle</span><br></pre></td></tr></table></figure>
<h2 id="Gradle_u63D2_u4EF6"><a href="#Gradle_u63D2_u4EF6" class="headerlink" title="Gradle插件"></a>Gradle插件</h2><p>Gradle的设计理念是，所有有用的特性都由Gradle插件提供，例如编写一个Java项目时，需要使用到 Java 插件， 它会将许多任务自动的加入到你项目里。Gradle本身提供了一系列的标准插件，无需多余配置只需要在你的build.gradle文件中加入 <code>apply plugin: &#39;java&#39;</code></p>
<p>这样就可以引入许多task，只需要使用相应的task命令就可以进行项目构建。例如下列一些task:</p>
<ul>
<li>gradle build：编译整个项目，它会执行代码编译、代码检测和单元测试等</li>
<li>gradle assemble：编译并打包你的代码, 但是并不运行代码检测和单元测试</li>
<li>gradle clean：删除 build 生成的目录和所有生成的文件</li>
<li>gradle check：编译并测试你的代码。其它的插件会加入更多的检查步骤，如使用 checkstyle、pmd、findbugs</li>
</ul>
<p>Gradle各个task的关系图：</p>
<p><img src="/images/14588507104558.jpg" alt=""></p>
<p>从上图可以看出，我们通常在执行一个build命令时其实是将一些零散的命令批量执行了，我们也可以根据自己的需求执行其中某一个命令。</p>
<h2 id="u5916_u90E8_u4F9D_u8D56"><a href="#u5916_u90E8_u4F9D_u8D56" class="headerlink" title="外部依赖"></a>外部依赖</h2><p>通常, 一个 Java 项目将有许多外部的依赖, 既指向外部的 JAR 文件. 为了在项目里引用这些 JAR 文件, 你需要告诉 Gradle 去哪里找它们. 在 Gradle 中, JAR 文件位于一个仓库中，这里的仓库类似于 maven 的仓库。</p>
<p>首先，指定maven的仓库地址：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mavenCentral() 是Gradle内置的一个maven仓库地址，加入maven仓库后，就可以直接加入maven仓库中的外部依赖，如果这个外部依赖不存在，gradle会联网去maven仓库中自动下载它，并将它缓存到本地，下次再使用时会优先从本地缓存中查找该依赖。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">group</span>: <span class="string">'commons-collections'</span>, name: <span class="string">'commons-collections'</span>, version: <span class="string">'3.2'</span></span><br><span class="line">    <span class="comment">// 简化写法</span></span><br><span class="line">    <span class="comment">// compile 'commons-collections:commons-collections:3.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用一个外部依赖需要指定使用的group, name 和 version 属性，三者缺一不可。那从哪里得知JAR包的这三个属性呢？我们可以从mvnrepository中搜索到。</p>
<h2 id="u672C_u5730_u4F9D_u8D56"><a href="#u672C_u5730_u4F9D_u8D56" class="headerlink" title="本地依赖"></a>本地依赖</h2><p>Gradle也可以从本地目录中引入JAR包依赖，可以单一引入指定的某一JAR包，也可以引入某目录下所有的JAR包</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> files(<span class="string">'dir/file.jar'</span>)</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: <span class="string">'*.jar'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u9879_u76EE_u4F9D_u8D56"><a href="#u9879_u76EE_u4F9D_u8D56" class="headerlink" title="项目依赖"></a>项目依赖</h2><p>往往一个完整的项目由多个子项目构成。在Gradle中，使用文件settings.gradle定义当前项目的子项目。默认情况下，每个子项目的名称对应着当前操作系统目录下的一个子目录。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="symbol">'sub</span>-project1', <span class="symbol">'sub</span>-project2', <span class="symbol">'sub</span>-project3'</span><br></pre></td></tr></table></figure>
<p>如sub-project1依赖sub-project2，则在sub-project1的build.gradle中加入以下配置即可：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':sub-project2'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u4F9D_u8D56_u5173_u7CFB_u7BA1_u7406"><a href="#u4F9D_u8D56_u5173_u7CFB_u7BA1_u7406" class="headerlink" title="依赖关系管理"></a>依赖关系管理</h2><p>从宏观上说，依赖关系管理分为两个方面。首先，gradle需要知道你要构建或者运行的项目，以便找到它们。我们将这些导入的文件视为项目的依赖。第二，gradle需要构建或者打包你的项目产品。我们将这些导出的文件视为项目的发布。</p>
<p>例如在编译源码时项目需要Hibernate的某些jar包被加入到工程中，而在进行单元测试时还另需要Junit的某些jar被加入。这些被引入的jar包就是项目的依赖。Gradle允许对依赖进行相应的配置，通过不同的配置可以形成不同的依赖效果。例如：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'org.hibernate'</span>, <span class="string">name:</span> <span class="string">'hibernate-core'</span>, <span class="string">version:</span> <span class="string">'3.6.7.Final'</span></span><br><span class="line">    testCompile <span class="string">group:</span> <span class="string">'junit'</span>, <span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目编译时期，junit的jar包不会被引入，只有在单元测试时才会被引入。这样，就可以在不同的场景下加入相应的依赖关系，非常的灵活</p>
<p>Java 插件中定义了许多标准的配置，例如如下：</p>
<ul>
<li>compile: 用来编译项目源代码的依赖</li>
<li>runtime: 在运行时被生成的类使用的依赖。 默认的, 也包含了compile时的依赖。</li>
<li>testCompile: 编译测试代码的依赖。 默认的, 包含runtime时的依赖和compile时的依赖。</li>
<li>testRuntime: 运行测试所需要的依赖。 默认的, 包含上面三个依赖。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。它提供灵活的通用构建工具，就像ant。同时完美兼容Maven或Ivy仓库</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://wdxtub.com/tags/Android/"/>
    
      <category term="包管理" scheme="http://wdxtub.com/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sublime 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/sublime-guide/"/>
    <id>http://wdxtub.com/2016/03/24/sublime-guide/</id>
    <published>2016-03-24T20:08:06.000Z</published>
    <updated>2016-03-24T20:10:02.000Z</updated>
    <content type="html"><![CDATA[<p>Sublime 基本算是我的主力代码编辑器，这里简要介绍一些插件和技巧。</p>
<a id="more"></a>
<hr>
<h2 id="u63D2_u4EF6"><a href="#u63D2_u4EF6" class="headerlink" title="插件"></a>插件</h2><ol>
<li><a href="https://github.com/emmetio/emmet" target="_blank" rel="external">Emmet Git</a>，<a href="http://docs.emmet.io/" target="_blank" rel="external">Document</a>原名为：<code>Zencoding, 快速生成html,css</code>，默认扩展快捷为<code>tab</code>，如果<code>tab</code>按钮损坏，<code>ctrl+e</code>替换。 生成规则在：<code>Preferences -&gt; Browser packages -&gt; Emment -&gt; emment -&gt; snippets.json</code>中修改。<a href="http://www.iteye.com/news/27580" target="_blank" rel="external">@ Emmet 中文版文档</a></li>
<li><a href="https://github.com/titoBouzout/SideBarEnhancements" target="_blank" rel="external">Side Bar</a><code>增强的侧边栏</code></li>
<li><a href="https://github.com/spadgos/sublime-jsdocs" target="_blank" rel="external">Docblockr</a><code>增强js注释</code></li>
<li><a href="https://github.com/wbond/sublime_alignment" target="_blank" rel="external">Alignment</a><code>等号对齐</code>。在<code>Preferences -&gt; package settings -&gt; Alignment -&gt; Settings User</code>添加冒号对齐。<code>{ &quot;align_indent&quot;: false, &quot;alignment_chars&quot;: [&quot;=&quot;, &quot;:&quot;], &quot;alignment_space_chars&quot;: [&quot;=&quot;, &quot;:&quot;] }</code></li>
<li><a href="https://github.com/BoundInCode/AutoFileName" target="_blank" rel="external">AutoFileName</a>: <code>文件路径自动提示</code></li>
<li><a href="https://github.com/akira-cn/sublime-gbk" target="_blank" rel="external">gbk支持 GBK Encoding Support</a></li>
<li><a href="http://www.welefen.com/keymapmanager-add-check-plugins-keymap-conflict-feature.html" target="_blank" rel="external">检测快捷键冲突</a></li>
<li><a href="https://github.com/revolunet/sublimetext-markdown-preview" target="_blank" rel="external">markdown</a> <a href="http://www.tcreator.info/social/experience/markdown-to-pdf.html" target="_blank" rel="external">markdown 转为 pdf</a></li>
<li><a href="https://github.com/SublimeText/LineEndings" target="_blank" rel="external">LineEndings 设置换行符</a></li>
<li><a href="https://sublime.wbond.net/" target="_blank" rel="external">SublimeText插件列表</a></li>
<li><a href="https://github.com/rehorn/sublime-htmlbeautify" target="_blank" rel="external">html美化插件</a></li>
<li><a href="http://www.fantxi.com/blog/archives/sublime-template-engine-sublimetmpl/" target="_blank" rel="external">Sublime Text 新建文件的模版插件: SublimeTmpl</a></li>
<li><a href="http://www.cnblogs.com/liu-l/p/3902100.html" target="_blank" rel="external">前端自动化神器LiveReload配合浏览器和less/sass使用方法</a></li>
<li><a href="http://www.cnblogs.com/yili16438/p/3721896.html" target="_blank" rel="external">使用 Sublime Text 2 开发 Unity3D 项目</a></li>
<li><a href="http://www.cnblogs.com/lhb25/p/10-essential-sublime-text-plugins.html" target="_blank" rel="external">全栈开发必备的10款 Sublime Text 插件</a></li>
</ol>
<h2 id="u8BBE_u7F6E"><a href="#u8BBE_u7F6E" class="headerlink" title="设置"></a>设置</h2><ol>
<li>Font 推荐使用 <a href="http://code.google.com/p/uigroupcode/downloads/detail?name=YaHei.Consolas.1.12.zip&amp;can=2&amp;q=#makechanges" target="_blank" rel="external">YaHei.Consolas.1.12.ttf</a>，即为上图中所示字体。</li>
<li>Theme<ul>
<li>code style: 推荐使用这款<a href="http://code.google.com/p/uigroupcode/downloads/detail?name=Monokai.rar&amp;can=2&amp;q=#makechanges" target="_blank" rel="external">marktheme</a></li>
<li><a href="https://gist.github.com/1854721" target="_blank" rel="external">更换sidebar皮肤</a></li>
<li><a href="http://jamiewilson.io/predawn/" target="_blank" rel="external">分享一个sublime 主题 </a></li>
<li><a href="http://colorsublime.com/" target="_blank" rel="external">颜色配色</a></li>
</ul>
</li>
<li>Preferences -&gt; Settings - User</li>
<li><a href="http://baelabs.duapp.com/Sublime/indentation.html" target="_blank" rel="external">定制缩进</a></li>
<li><a href="http://baelabs.duapp.com/Sublime/spell_checking.html" target="_blank" rel="external">拼写检查</a></li>
<li><a href="http://baelabs.duapp.com/Sublime/distraction_free.html" target="_blank" rel="external">全屏模式，自由模式的定制</a></li>
<li><a href="http://www.cnblogs.com/jikey/archive/2013/03/12/2955230.html" target="_blank" rel="external">浏览器中预览</a></li>
<li><a href="http://baelabs.duapp.com/Sublime/settings.html" target="_blank" rel="external">其它配置</a></li>
</ol>
<h2 id="u7279_u6B8A_u64CD_u4F5C"><a href="#u7279_u6B8A_u64CD_u4F5C" class="headerlink" title="特殊操作"></a>特殊操作</h2><ol>
<li>按住 <code>ctrl</code> 键，鼠标单击就是多重选择。</li>
<li><a href="http://baelabs.duapp.com/Sublime/multiple_selection_with_the_keyboard.html" target="_blank" rel="external">键盘多重选择</a></li>
<li>根据选择文本自动添加 ‘, “”,(),[] 匹配。</li>
<li>搜索按钮的功能说明 (<a href="http://hi.baidu.com/chaoxinggsc/item/904a471aa937bc35f6625c42" target="_blank" rel="external">冷风贡献</a>)</li>
</ol>
<h2 id="u5FEB_u6377_u952E"><a href="#u5FEB_u6377_u952E" class="headerlink" title="快捷键"></a>快捷键</h2><ol>
<li>Ctrl+L             选择整行（按住-继续选择下行）</li>
<li>Ctrl+Shift+K(shhift+del)     删除整行，  ctrl + KK 从光标处删之行尾，Ctrl+K Backspace 从光标处删除至行首</li>
<li>Ctrl+Shift+D       复制光标所在整行，插入在该行之前</li>
<li>Ctrl+D             选词 （按住-继续选择下个相同的字符串，再按，可跳到相应的方法定义处</li>
<li>Ctrl+Shift+M       选择括号内的内容（按住-继续选择父括号）</li>
<li>Ctrl+/             注释整行（如已选择内容，同“Ctrl+Shift+/”效果）</li>
<li>Ctrl + alt + /     取消注释</li>
<li>Ctrl+Shift+UP      与上行互换  ctrl + shift + up: 列模式编辑</li>
<li>Ctrl + R           跳转当前页的目标方法</li>
<li>Ctrl+K + U        大写</li>
<li>Ctrl+K + L        小写</li>
<li>鼠标中间           列模式编辑</li>
<li>Ctrl+Shift+[]     代码折叠</li>
<li>ctrl+k ctrl+1:    折叠所有代码</li>
<li>Ctrl + K,B        打开侧边栏</li>
<li>ctrl + 回车：　　   光标后插入行，　Ctrl+Shift+Enter 光标前插入行</li>
<li>ctrl + m:         匹配括号</li>
<li>vim mode下        查找上一个下一个的快捷键是 是* #</li>
<li>ctrl +z, y:       撤销，恢复撤销</li>
<li>alt + .:          闭合当前标签</li>
<li>Ctrl+F2:          设置书签</li>
<li>F2:               下一个书签</li>
<li>Shift+F2:         上一个书签</li>
<li>ctrl + p:         即时的文件切换</li>
<li>ctrl + shift + a: 选择标签内的内容</li>
<li>ctrl + 单击：      多行随意位置添加光标</li>
<li>alt + F3( mac: ctrl + command + g): 选择页面中所有相同的词</li>
<li>ctrl + F3:        跳转到下一个选中的词</li>
<li>Ctrl+Shift+P Set Syntax:html : 设置文件类型</li>
<li>Shift + 右键:     连续多行光标选中 (by Gary Gauh)</li>
</ol>
<ul>
<li>非官方文档：<a href="https://sublime-text-unofficial-documentation.readthedocs.org/en/latest/" target="_blank" rel="external">Unofficial Document英文版</a></li>
<li><a href="http://baelabs.duapp.com/Sublime_unofficial/" target="_blank" rel="external">Unofficial Document中文版</a></li>
<li>sublime <a href="http://www.feelcss.com/sublime-text-2-settings.html" target="_blank" rel="external">配置详解</a></li>
<li>sublime <a href="http://baelabs.duapp.com/Sublime/" target="_blank" rel="external">其它文档</a></li>
</ul>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>如何删除安装的插件？</p>
<ol>
<li>ctr+shift+P,输入package</li>
<li>查找remove package</li>
<li>输入你要删除的package</li>
<li>回车，OK</li>
</ol>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/martomo/SublimeTextXdebug" target="_blank" rel="external">xdebug调试</a></li>
<li><a href="http://baelabs.duapp.com/Sublime%20text3" target="_blank" rel="external">sublimetext 3.0文档</a></li>
<li><a href="http://www.cnblogs.com/bananaplan/p/Sublime-Text-3-Powerful.html" target="_blank" rel="external">Sublime Text 3 绝对神器</a></li>
<li><a href="http://docs.sublimetext.tw/" target="_blank" rel="external">SublimeText手册-tw</a></li>
<li><a href="http://code-tech.diandian.com/post/2012-11-10/40041273125" target="_blank" rel="external">怎样从直接Github的repository安装Sublime Text插件</a></li>
<li><a href="http://code-tech.diandian.com/post/2012-11-14/40041132753" target="_blank" rel="external">Sublime text2的ThinkPHP插件</a></li>
<li><a href="http://code-tech.diandian.com/post/2012-11-21/40042403501" target="_blank" rel="external">sublime text 左侧菜单美化1</a></li>
<li><a href="http://zh.lucida.me/blog/sublime-text-complete-guide/" target="_blank" rel="external">Sublime Text 全程指南</a></li>
<li><a href="http://www.zhihu.com/question/24896283" target="_blank" rel="external">sublime 有哪些使用技巧</a></li>
<li><a href="http://www.html-js.com/article/The-frontend-tool-Megamix" target="_blank" rel="external">前端工程师手中的Sublime Text</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Sublime 基本算是我的主力代码编辑器，这里简要介绍一些插件和技巧。</p>]]>
    
    </summary>
    
      <category term="编辑器" scheme="http://wdxtub.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[VS Code 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/visual-code-guide/"/>
    <id>http://wdxtub.com/2016/03/24/visual-code-guide/</id>
    <published>2016-03-24T20:03:14.000Z</published>
    <updated>2016-03-24T20:08:33.000Z</updated>
    <content type="html"><![CDATA[<p>Visual Studio 终于把触角伸到了全平台，在加入了插件功能之后，VSC 事实上已经对各种老牌新生编辑器造成了强大的压力，为了紧跟时代脚步，还是要熟悉和了解一下 VSC 的。</p>
<p>这里基本上是官方教程的总结和翻译。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u7840_u77E5_u8BC6"><a href="#u57FA_u7840_u77E5_u8BC6" class="headerlink" title="基础知识"></a>基础知识</h2><p>归根到底 VSC 是一个代码编辑器，所以和其他的代码编辑器一样，基本的该有的甚至不该有的功能，都有。下面会简要介绍一下</p>
<h3 id="u6587_u4EF6_u3001_u6587_u4EF6_u5939_u548C_u9879_u76EE"><a href="#u6587_u4EF6_u3001_u6587_u4EF6_u5939_u548C_u9879_u76EE" class="headerlink" title="文件、文件夹和项目"></a>文件、文件夹和项目</h3><p>随意打开一个文件或者文件夹，就可以进行编辑，如果文件夹里包含 <code>package.json</code>, <code>project.json</code>, <code>tsconfig.json</code> 或者其他 ASP.NET 5 的 sln 文件，VSC 可以自动读取项目结构并且高亮显示出来</p>
<h3 id="u57FA_u7840_u89C6_u56FE"><a href="#u57FA_u7840_u89C6_u56FE" class="headerlink" title="基础视图"></a>基础视图</h3><p>Editor, Side Bar, Status Bar 和 View Bar 这里基本的标配都有</p>
<blockquote>
<p>Tip: 可以用 command+B 来切换显示侧边栏</p>
</blockquote>
<h3 id="u591A_u680F_u7F16_u8F91"><a href="#u591A_u680F_u7F16_u8F91" class="headerlink" title="多栏编辑"></a>多栏编辑</h3><p>只需要记住一些快捷键即可</p>
<ul>
<li>command+\ 分成多栏</li>
<li>command+1/2/3 通过数字键选择当前激活的文件</li>
<li>可以自由调整和重新排序</li>
</ul>
<h3 id="u6587_u4EF6_u6D4F_u89C8_u5668"><a href="#u6587_u4EF6_u6D4F_u89C8_u5668" class="headerlink" title="文件浏览器"></a>文件浏览器</h3><p>文件浏览器中可以进行基本的文件操作，对着文件点击右键即可，甚至还可以直接在 terminal 中打开！</p>
<blockquote>
<p>Tip: command+p 可以通过文件名快速查找并打开文件</p>
</blockquote>
<p>默认来说，VSC 会排除显示一些文件夹(例如 <code>.git</code>)，当然也可以在 user setting 中配置 <code>files.exclude</code> 来自定义排除规则（是支持通配符的如<code>\*.meta</code>）</p>
<h3 id="u5DF2_u6253_u5F00_u6587_u4EF6"><a href="#u5DF2_u6253_u5F00_u6587_u4EF6" class="headerlink" title="已打开文件"></a>已打开文件</h3><p>已打开文件会在边栏的上方显示，如果需要自定义，可以设置下面一些属性：</p>
<ul>
<li><code>explorer.workingFiles.maxVisible</code></li>
<li><code>explorer.workingFiles.dynamicHeight</code></li>
</ul>
<h3 id="u8DE8_u6587_u4EF6_u641C_u7D22"><a href="#u8DE8_u6587_u4EF6_u641C_u7D22" class="headerlink" title="跨文件搜索"></a>跨文件搜索</h3><p>快捷键 shift+command+f，支持全文搜索，中文英文都可以！简直爆炸！而且还支持正则表达式！</p>
<p>如果需要更高级的搜索，可以使用 shift+command+j</p>
<p>下面列出基本的正则表示：</p>
<ul>
<li><code>*</code> to match one or more characters in a path segment</li>
<li><code>?</code> to match on one character in a path segment</li>
<li><code>**</code> to match any number of path segments ,including none</li>
<li><code>{}</code> to group conditions (e.g. <code>{**/*.html,**/*.txt}</code> matches all html and txt files)</li>
<li><code>[]</code> to declare a range of characters to match (e.g., example.[0-9] to match on example.0, example.1, …</li>
</ul>
<p>注意可以自定义搜索范围，在设置中设定</p>
<ul>
<li><code>files.exclude</code></li>
<li><code>search.exclude</code></li>
</ul>
<h3 id="u547D_u4EE4_u677F"><a href="#u547D_u4EE4_u677F" class="headerlink" title="命令板"></a>命令板</h3><p>按 F1 就可以调出 Command Palette，这里可以快速输入各种命令，一些基本技巧</p>
<ul>
<li>command+p: 通过文件名找文件</li>
<li>control+tab: 可以循环切换之前打开的文件</li>
<li>shift+command+o: 可以导航到文件中的指定符号</li>
<li>control+g: 导航到指定行</li>
</ul>
<p>在 Command Palette 中输入 <code>?</code> 可以显示当前可用的操作</p>
<h3 id="u6587_u4EF6_u7F16_u7801_u652F_u6301"><a href="#u6587_u4EF6_u7F16_u7801_u652F_u6301" class="headerlink" title="文件编码支持"></a>文件编码支持</h3><p>在 <code>files.encoding</code> 设置中设置具体的编码，可以在 右下角的状态栏中看到。点击状态栏中的编码可以用指定编码打开或者保存文件(还需要选择具体的编码格式)</p>
<h2 id="u7F16_u8F91_u529F_u80FD"><a href="#u7F16_u8F91_u529F_u80FD" class="headerlink" title="编辑功能"></a>编辑功能</h2><p>理论上来说，基本上该有的功能都有，这里只列出一些超赞的功能</p>
<h3 id="u62EC_u53F7_u5339_u914D"><a href="#u62EC_u53F7_u5339_u914D" class="headerlink" title="括号匹配"></a>括号匹配</h3><p>括号会自动高亮匹配，可以用 <code>shift+command+]</code> 来跳到匹配的括号位置</p>
<h3 id="u591A_u884C_u9009_u62E9"><a href="#u591A_u884C_u9009_u62E9" class="headerlink" title="多行选择"></a>多行选择</h3><p>利用 <code>alt+click</code> 来激活多行选择，每个光标都是独立的，另一个比较方便添加光标的方式是 <code>option+command+↓</code> 和 <code>option+command+↑</code>，这会在正下方或上方添加光标</p>
<p><code>command+D</code> 选择当前单词，或者是当前单词下一次出现的位置，<code>command+K command+D</code> 会选择单词最后一次出现的位置</p>
<p>其他一些添加光标的方式是</p>
<ul>
<li><code>shift+command+l</code>: 在单词下一次出现处添加光标</li>
<li><code>command+f2</code>: 在下一个单词前添加光标</li>
</ul>
<h3 id="u7F29_u8FDB/_u6269_u5C55_u9009_u62E9"><a href="#u7F29_u8FDB/_u6269_u5C55_u9009_u62E9" class="headerlink" title="缩进/扩展选择"></a>缩进/扩展选择</h3><p>选择缩进/扩展，快捷键 <code>control+shift+command+←</code> / <code>control+shift+command+→</code></p>
<p><img src="/images/14588498234616.jpg" alt=""></p>
<h3 id="u667A_u80FD_u63D0_u793A"><a href="#u667A_u80FD_u63D0_u793A" class="headerlink" title="智能提示"></a>智能提示</h3><p>对于 JavaScript, JSON, HTML, CSS, Less, Sass, C#, TypeScript 都有智能提示，也可以用 <code>control+space</code> 手动激活，用 <code>.</code>, <code>tab</code>, <code>Enter</code> 来选择</p>
<p>默认会在输入的时候进行智能提示，即所谓 24x7 IntelliSense，可以在 <code>editor.quickSuggestions</code> 和 <code>editor.suggestOnTriggerCharacters</code> 中进行设置</p>
<h3 id="u53C2_u6570_u63D0_u793A"><a href="#u53C2_u6570_u63D0_u793A" class="headerlink" title="参数提示"></a>参数提示</h3><p>在 JavaScript, TypeScript 和 C# 中，会自动提示函数的参数，可以用方向键进行导航</p>
<h3 id="u4EE3_u7801_u7247_u6BB5"><a href="#u4EE3_u7801_u7247_u6BB5" class="headerlink" title="代码片段"></a>代码片段</h3><p>可以在 <code>User Snippets</code> (<code>File | Preferences</code>) 中设定自己的 snippet</p>
<h3 id="u8DF3_u8F6C_u5230_u5B9A_u4E49"><a href="#u8DF3_u8F6C_u5230_u5B9A_u4E49" class="headerlink" title="跳转到定义"></a>跳转到定义</h3><p>如果语言支持的话，可以用 <code>F12</code> 来跳转到定义。如果按着 <code>ctrl</code> 并把指针放到一个符号上，会有一个简单的预览框。如果需要跳转到定义处可以使用 <code>ctrl+click</code>。如果需要在另外一侧的窗口打开定义，使用 <code>ctrol+alt+click</code></p>
<h2 id="u6269_u5C55"><a href="#u6269_u5C55" class="headerlink" title="扩展"></a>扩展</h2><p>支持扩展是使编辑器更加强大的方法，这里简要介绍一些目前我觉得比较有用的扩展</p>
<h3 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h3><p>安装方法非常简单，用 <code>F1</code> 打开 命令行，然后输入 <code>ext inst</code> 来进行操作</p>
<p><a href="https://marketplace.visualstudio.com/#VSCode" target="_blank" rel="external">MarketPlace</a></p>
<ul>
<li>Markdown Theme Kit</li>
<li>Markdown 预览 <code>command+k v</code></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Visual Studio 终于把触角伸到了全平台，在加入了插件功能之后，VSC 事实上已经对各种老牌新生编辑器造成了强大的压力，为了紧跟时代脚步，还是要熟悉和了解一下 VSC 的。</p>
<p>这里基本上是官方教程的总结和翻译。</p>]]>
    
    </summary>
    
      <category term="编辑器" scheme="http://wdxtub.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python 编程思想]]></title>
    <link href="http://wdxtub.com/2016/03/24/thinking-in-python/"/>
    <id>http://wdxtub.com/2016/03/24/thinking-in-python/</id>
    <published>2016-03-24T19:36:15.000Z</published>
    <updated>2016-03-24T19:52:07.000Z</updated>
    <content type="html"><![CDATA[<p>这里收集了一些深入 python 机制的内容。</p>
<a id="more"></a>
<hr>
<h2 id="u6D45_u8C08_Python__u7684_with__u8BED_u53E5"><a href="#u6D45_u8C08_Python__u7684_with__u8BED_u53E5" class="headerlink" title="浅谈 Python 的 with 语句"></a>浅谈 Python 的 with 语句</h2><p>with 语句是从 Python 2.5 开始引入的一种与异常处理相关的功能（2.5 版本中要通过 <code>from __future__ import with_statement</code> 导入后才可以使用），从 2.6 版本开始缺省可用（参考 What’s new in Python 2.6? 中 with 语句相关部分介绍）。with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。</p>
<h3 id="u672F_u8BED"><a href="#u672F_u8BED" class="headerlink" title="术语"></a>术语</h3><p>要使用 with 语句，首先要明白上下文管理器这一概念。有了上下文管理器，with 语句才能工作。</p>
<p>下面是一组与上下文管理器和with 语句有关的概念。</p>
<p>上下文管理协议（Context Management Protocol）：包含方法 <code>__enter__()</code> 和 <code>__exit__()</code>，支持该协议的对象要实现这两个方法。</p>
<p>上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了<br><code>__enter__()</code> 和 <code>__exit__()</code> 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。</p>
<p>运行时上下文（runtime context）：由上下文管理器创建，通过上下文管理器的 <code>__enter__()</code> 和 <code>__exit__()</code> 方法实现，<code>__enter__()</code> 方法在语句体执行之前进入运行时上下文，<code>__exit__()</code> 在语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。</p>
<p>上下文表达式（Context Expression）：with 语句中跟在关键字 with 之后的表达式，该表达式要返回一个上下文管理器对象。</p>
<p>语句体（with-body）：with 语句包裹起来的代码块，在执行语句体之前会调用上下文管<br>理器的 <code>__enter__()</code> 方法，执行完语句体之后会执行 <code>__exit__()</code> 方法。</p>
<h3 id="u57FA_u672C_u8BED_u6CD5_u548C_u5DE5_u4F5C_u539F_u7406"><a href="#u57FA_u672C_u8BED_u6CD5_u548C_u5DE5_u4F5C_u539F_u7406" class="headerlink" title="基本语法和工作原理"></a>基本语法和工作原理</h3><p>with 语句的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> context_expression [<span class="keyword">as</span> target(s)]:</span><br><span class="line">    <span class="keyword">with</span>-body</span><br></pre></td></tr></table></figure>
<p>这里 context_expression 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 target(s) ，如果指定了 as 子句的话，会将上下文管理器的 <code>__enter__()</code> 方法的返回值赋值给 target(s)。target(s) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）。</p>
<p>Python 对一些内建对象进行改进，加入了对上下文管理器的支持，可以用于 with 语句中，比如可以自动关闭文件、线程锁的自动获取和释放等。假设要对一个文件进行操作，使用 with 语句可以有如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">r'somefileName'</span>) <span class="keyword">as</span> somefile:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> somefile:</span><br><span class="line">        <span class="keyword">print</span> line</span><br><span class="line">        <span class="comment"># ...more code</span></span><br></pre></td></tr></table></figure>
<p>这里使用了 with 语句，不管在处理文件过程中是否发生异常，都能保证 with 语句执行完毕后已经关闭了打开的文件句柄。如果使用传统的 try/finally 范式，则要使用类似如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">somefile = open(<span class="string">r'somefileName'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> somefile:</span><br><span class="line">        <span class="keyword">print</span> line</span><br><span class="line">        <span class="comment"># ...more code</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    somefile.close()</span><br></pre></td></tr></table></figure>
<p>比较起来，使用 with 语句可以减少编码量。已经加入对上下文管理协议支持的还有模块 threading、decimal 等。</p>
<p>PEP 0343 对 with 语句的实现进行了描述。with 语句的执行过程类似如下代码块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">context_manager = context_expression</span><br><span class="line">exit = type(context_manager).__exit__  </span><br><span class="line">value = type(context_manager).__enter__(context_manager)</span><br><span class="line">exc = <span class="keyword">True</span>   <span class="comment"># True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        target = value  <span class="comment"># 如果使用了 as 子句</span></span><br><span class="line">        <span class="keyword">with</span>-body     <span class="comment"># 执行 with-body</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># 执行过程中有异常发生</span></span><br><span class="line">        exc = <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常</span></span><br><span class="line">        <span class="comment"># 由外层代码对异常进行处理</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exit(context_manager, *sys.exc_info()):</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出</span></span><br><span class="line">    <span class="comment"># 或者忽略异常退出</span></span><br><span class="line">    <span class="keyword">if</span> exc:</span><br><span class="line">        exit(context_manager, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line">    <span class="comment"># 缺省返回 None，None 在布尔上下文中看做是 False</span></span><br></pre></td></tr></table></figure>
<ol>
<li>执行 context_expression，生成上下文管理器 context_manager</li>
<li>调用上下文管理器的 <code>__enter__()</code> 方法；如果使用了 as 子句，则将 <code>__enter__()</code> 方法的返回值赋值给 as 子句中的 target(s)</li>
<li>执行语句体 with-body</li>
<li>不管是否执行过程中是否发生了异常，执行上下文管理器的 <code>__exit__()</code> 方法，<code>__exit__()</code> 方法负责执行“清理”工作，如释放资源等。如果执行过程中没有出现异常，或者语句体中执行了语句 break/continue/return，则以 None 作为参数调用 <code>__exit__(None, None, None)</code> ；如果执行过程中出现异常，则使用 sys.exc_info 得到的异常信息为参数调用 <code>__exit__(exc_type, exc_value, exc_traceback)</code></li>
<li>出现异常时，如果 <code>__exit__(type, value, traceback)</code> 返回 False，则会重新抛出异常，让with 之外的语句逻辑来处理异常，这也是通用做法；如果返回 True，则忽略异常，不再对异常进行处理</li>
</ol>
<h2 id="Python_u7A0B_u5E8F_u7684_u6267_u884C_u539F_u7406"><a href="#Python_u7A0B_u5E8F_u7684_u6267_u884C_u539F_u7406" class="headerlink" title="Python程序的执行原理"></a>Python程序的执行原理</h2><p>Python先把代码(.py文件)编译成字节码，交给字节码虚拟机，然后虚拟机一条一条执行字节码指令，从而完成程序的执行。</p>
<p>字节码在Python虚拟机程序里对应的是PyCodeObject对象。</p>
<p>.pyc文件是字节码在磁盘上的表现形式。</p>
<p>PyCodeObject对象的创建时机是模块加载的时候，即import。</p>
<p>Python test.py会对test.py进行编译成字节码并解释执行，但是不会生成test.pyc。</p>
<p>如果test.py加载了其他模块，如import util，Python会对util.py进行编译成字节码，生成util.pyc，然后对字节码解释执行。</p>
<p>如果想生成test.pyc，我们可以使用Python内置模块py_compile来编译。</p>
<p>加载模块时，如果同时存在.py和.pyc，Python会尝试使用.pyc，如果.pyc的编译时间早于.py的修改时间，则重新编译.py并更新.pyc。</p>
<p>Python代码的编译结果就是PyCodeObject对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    int co_argcount;        /* 位置参数个数 */</span><br><span class="line">    int co_nlocals;         /* 局部变量个数 */</span><br><span class="line">    int co_stacksize;       /* 栈大小 */</span><br><span class="line">    int co_flags;   </span><br><span class="line">    PyObject *co_code;      /* 字节码指令序列 */</span><br><span class="line">    PyObject *co_consts;    /* 所有常量集合 */</span><br><span class="line">    PyObject *co_names;     /* 所有符号名称集合 */</span><br><span class="line">    PyObject *co_varnames;  /* 局部变量名称集合 */</span><br><span class="line">    PyObject *co_freevars;  /* 闭包用的的变量名集合 */</span><br><span class="line">    PyObject *co_cellvars;  /* 内部嵌套函数引用的变量名集合 */</span><br><span class="line">    /* The rest doesn’t count <span class="keyword">for</span> hash/cmp */</span><br><span class="line">    PyObject *co_filename;  /* 代码所在文件名 */</span><br><span class="line">    PyObject *co_name;      /* 模块名|函数名|类名 */</span><br><span class="line">    int co_firstlineno;     /* 代码块在文件中的起始行号 */</span><br><span class="line">    PyObject *co_lnotab;    /* 字节码指令和行号的对应关系 */</span><br><span class="line">    void *co_zombieframe;   /* <span class="keyword">for</span> optimization only (see frameobject.c) */</span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>
<p>加载模块时，模块对应的PyCodeObject对象被写入.pyc文件，格式如下：</p>
<p><img src="/images/14588486364401.jpg" alt=""></p>
<h3 id="u5206_u6790_u5B57_u8282_u7801"><a href="#u5206_u6790_u5B57_u8282_u7801" class="headerlink" title="分析字节码"></a>分析字节码</h3><p>Python提供了内置函数compile可以编译Python代码和查看PyCodeObject对象，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = ”hello”</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> s</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure>
<p>在Python交互式shell里编译代码得到PyCodeObject对象:</p>
<p><img src="/images/14588486530973.jpg" alt=""></p>
<p>dir(co)已经列出co的各个域，想查看某个域直接在终端输出即可：</p>
<p><img src="/images/14588486595605.jpg" alt=""></p>
<p>test.py的PyCodeObject</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">co.co_argcount    0</span><br><span class="line">co.co_nlocals     0</span><br><span class="line">co.co_names       (‘s’, ’func’)</span><br><span class="line">co.co_varnames    (‘s’, ’func’)</span><br><span class="line">co.co_consts      (‘hello’, &lt;code object func at 0x2aaeeec57110, file ”test.py”, line 3&gt;, None)</span><br><span class="line">co.co_code        ’d<span class="command">\x</span>00<span class="command">\x</span>00Z<span class="command">\x</span>00<span class="command">\x</span>00d<span class="command">\x</span>01<span class="command">\x</span>00<span class="command">\x</span>84<span class="command">\x</span>00<span class="command">\x</span>00Z<span class="command">\x</span>01<span class="command">\x</span>00e<span class="command">\x</span>01<span class="command">\x</span>00<span class="command">\x</span>83<span class="command">\x</span>00<span class="command">\x</span>00<span class="command">\x</span>01d<span class="command">\x</span>02<span class="command">\x</span>00S’</span><br></pre></td></tr></table></figure>
<p>Python解释器会为函数也生成的字节码PyCodeObject对象，见上面的co_consts[1]</p>
<p>func的PyCodeObject</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_argcount</span>   0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_nlocals</span>    0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_names</span>      <span class="params">(‘s’,)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_varnames</span>   <span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_consts</span>     <span class="params">(None,)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_code</span>       ‘<span class="title">t</span>\<span class="title">x00</span>\<span class="title">x00GHd</span>\<span class="title">x00</span>\<span class="title">x00S</span>’</span></span><br></pre></td></tr></table></figure>
<h3 id="u6267_u884C_u5B57_u8282_u7801"><a href="#u6267_u884C_u5B57_u8282_u7801" class="headerlink" title="执行字节码"></a>执行字节码</h3><p>Python虚拟机的原理就是模拟可执行程序再X86机器上的运行，X86的运行时栈帧如下图：</p>
<p><img src="/images/14588486859304.jpg" alt=""></p>
<p>假如test.py用C语言来实现，会是下面这个样子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s = “hello”;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(“%s\n”, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python虚拟机的原理就是模拟上述行为。当发生函数调用时，创建新的栈帧，对应Python的实现就是PyFrameObject对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _frame &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    struct _frame *f_back;    /* 调用者的帧 */</span><br><span class="line">    PyCodeObject *f_code;     /* 帧对应的字节码对象 */</span><br><span class="line">    PyObject *f_builtins;     /* 内置名字空间 */</span><br><span class="line">    PyObject *f_globals;      /* 全局名字空间 */</span><br><span class="line">    PyObject *f_locals;       /* 本地名字空间 */</span><br><span class="line">    PyObject **f_valuestack;  /* 运行时栈底 */</span><br><span class="line">    PyObject **f_stacktop;    /* 运行时栈顶 */</span><br><span class="line">    …….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么对应Python的运行时栈就是这样子：</p>
<p><img src="/images/14588486997857.jpg" alt=""></p>
<p>执行test.py的字节码时，会先创建一个栈帧，以下用f表示当前栈帧，执行过程注释如下：</p>
<p>test.py的符号名集合和常量集合</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">co<span class="class">.co_names</span>   (‘s’, ’func’)</span><br><span class="line">co<span class="class">.co_consts</span>  (‘hello’, &lt;<span class="tag">code</span> <span class="tag">object</span> func at <span class="number">0</span>x2aaeeec57110, file ”test.py”, line <span class="number">3</span>&gt;, None)</span><br></pre></td></tr></table></figure>
<p>如果你想查看当前栈帧，Python提供了<code>sys._getframe()</code>方法可以获取当前栈帧，你只需要在代码里加入代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    frame = sys._getframe()</span><br><span class="line">    <span class="keyword">print</span> frame.f_locals</span><br><span class="line">    <span class="keyword">print</span> frame.f_globals</span><br><span class="line">    <span class="keyword">print</span> frame.f_back.f_locals</span><br><span class="line">    <span class="comment">#你可以打印frame的各个域</span></span><br><span class="line">    <span class="keyword">print</span> s</span><br></pre></td></tr></table></figure>
<h2 id="Python__u9ED1_u9B54_u6CD5"><a href="#Python__u9ED1_u9B54_u6CD5" class="headerlink" title="Python 黑魔法"></a>Python 黑魔法</h2><h3 id="Python__u591A_u7EE7_u627F"><a href="#Python__u591A_u7EE7_u627F" class="headerlink" title="Python 多继承"></a>Python 多继承</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class A(object):</span><br><span class="line">   ...:         def foo(self):</span><br><span class="line">   ...:                 print("class A")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [2]: class B(object):</span><br><span class="line">   ...:         def foo(self):</span><br><span class="line">   ...:                 print("class B")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [3]: class C(A, B):</span><br><span class="line">   ...:         pass</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [4]: C().foo()</span><br><span class="line">class A # 例子很好懂, C继承了A和B，从左到右,发现A有foo方法,返回了</span><br></pre></td></tr></table></figure>
<p>看起来都是很简单, 有次序的从底向上,从前向后找,找到就返回. 再看例子:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [5]: class A(object):</span><br><span class="line">   ...:        def foo(self):</span><br><span class="line">   ...:               print("class A")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [6]: class B(A):</span><br><span class="line">   ...:        pass</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [7]: class C(A):</span><br><span class="line">   ...:        def foo(self):</span><br><span class="line">   ...:               print("class C")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [8]: class D(B,C):</span><br><span class="line">   ...:        pass</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [9]: D().foo()</span><br><span class="line">class C # ? 按道理, 顺序是 D-&gt;B-&gt;A,为什么找到了C哪去了</span><br></pre></td></tr></table></figure>
<p>这也就涉及了MRO(Method Resolution Order):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: D.__mro__</span><br><span class="line">Out[<span class="number">10</span>]: (__main__.D, __main__.B, __main__.C, __main__.A, object)</span><br></pre></td></tr></table></figure>
<p>简单的理解其实就是新式类是广度优先了， D-&gt;B, 但是发现C也是继承A，就先找C，最后再去找A</p>
<h3 id="u5217_u8868_u7684+_u548C+_3D_2C_append_u548Cextend"><a href="#u5217_u8868_u7684+_u548C+_3D_2C_append_u548Cextend" class="headerlink" title="列表的+和+=, append和extend"></a>列表的+和+=, append和extend</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: print(<span class="string">'ID:'</span>, id(a_list))</span><br><span class="line">(<span class="string">'ID:'</span>, <span class="number">4481323592</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: a_list += [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: print(<span class="string">'ID (+=):'</span>, id(a_list))</span><br><span class="line">(<span class="string">'ID (+=):'</span>, <span class="number">4481323592</span>) <span class="comment"># 使用+= 还是在原来的列表上操作</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: a_list = a_list + [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: print(<span class="string">'ID (list = list + ...):'</span>, id(a_list))</span><br><span class="line">(<span class="string">'ID (list = list + ...):'</span>, <span class="number">4481293056</span>) <span class="comment"># 简单的+其实已经改变了原有列表</span></span><br><span class="line">In [<span class="number">28</span>]: a_list = []</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: id(a_list)</span><br><span class="line">Out[<span class="number">29</span>]: <span class="number">4481326976</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: a_list.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: id(a_list)</span><br><span class="line">Out[<span class="number">31</span>]: <span class="number">4481326976</span> <span class="comment"># append 是在原有列表添加</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: a_list.extend([<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: id(a_list)</span><br><span class="line">Out[<span class="number">33</span>]: <span class="number">4481326976</span> <span class="comment"># extend 也是在原有列表上添加</span></span><br></pre></td></tr></table></figure>
<h3 id="datetime_u4E5F_u6709_u5E03_u5C14_u503C"><a href="#datetime_u4E5F_u6709_u5E03_u5C14_u503C" class="headerlink" title="datetime也有布尔值"></a>datetime也有布尔值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">34</span>]: <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: print(<span class="string">'"datetime.time(0,0,0)" (Midnight) -&gt;'</span>, bool(datetime.time(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)))</span><br><span class="line">(<span class="string">'"datetime.time(0,0,0)" (Midnight) -&gt;'</span>, <span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: print(<span class="string">'"datetime.time(1,0,0)" (1 am) -&gt;'</span>, bool(datetime.time(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)))</span><br><span class="line">(<span class="string">'"datetime.time(1,0,0)" (1 am) -&gt;'</span>, <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="u2019_3D_3D_u2019__u548C_is__u7684_u533A_u522B"><a href="#u2019_3D_3D_u2019__u548C_is__u7684_u533A_u522B" class="headerlink" title="’==’ 和 is 的区别"></a>’==’ 和 is 的区别</h3><p>我的理解是”is”是判断2个对象的身份, ==是判断2个对象的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">37</span>]: a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: print(<span class="string">'a is b'</span>, bool(a <span class="keyword">is</span> b))</span><br><span class="line">(<span class="string">'a is b'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: c = <span class="number">999</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: d = <span class="number">999</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: print(<span class="string">'c is d'</span>, bool(c <span class="keyword">is</span> d))</span><br><span class="line">(<span class="string">'c is d'</span>, <span class="keyword">False</span>) <span class="comment"># 原因是python的内存管理,缓存了-5 - 256的对象</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: print(<span class="string">'256 is 257-1'</span>, <span class="number">256</span> <span class="keyword">is</span> <span class="number">257</span>-<span class="number">1</span>)</span><br><span class="line">(<span class="string">'256 is 257-1'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: print(<span class="string">'257 is 258-1'</span>, <span class="number">257</span> <span class="keyword">is</span> <span class="number">258</span> - <span class="number">1</span>)</span><br><span class="line">(<span class="string">'257 is 258-1'</span>, <span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: print(<span class="string">'-5 is -6+1'</span>, -<span class="number">5</span> <span class="keyword">is</span> -<span class="number">6</span>+<span class="number">1</span>)</span><br><span class="line">(<span class="string">'-5 is -6+1'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: print(<span class="string">'-7 is -6-1'</span>, -<span class="number">7</span> <span class="keyword">is</span> -<span class="number">6</span>-<span class="number">1</span>)</span><br><span class="line">(<span class="string">'-7 is -6-1'</span>, <span class="keyword">False</span>)</span><br><span class="line">In [<span class="number">47</span>]: a = <span class="string">'hello world!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: b = <span class="string">'hello world!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: print(<span class="string">'a is b,'</span>, a <span class="keyword">is</span> b)</span><br><span class="line">(<span class="string">'a is b,'</span>, <span class="keyword">False</span>) <span class="comment"># 很明显 他们没有被缓存,这是2个字段串的对象</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: print(<span class="string">'a == b,'</span>, a == b)</span><br><span class="line">(<span class="string">'a == b,'</span>, <span class="keyword">True</span>) <span class="comment"># 但他们的值相同</span></span><br><span class="line"><span class="comment"># But, 有个特例</span></span><br><span class="line">In [<span class="number">51</span>]: a = float(<span class="string">'nan'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: print(<span class="string">'a is a,'</span>, a <span class="keyword">is</span> a)</span><br><span class="line">(<span class="string">'a is a,'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: print(<span class="string">'a == a,'</span>, a == a)</span><br><span class="line">(<span class="string">'a == a,'</span>, <span class="keyword">False</span>) <span class="comment"># 亮瞎我眼睛了~</span></span><br></pre></td></tr></table></figure>
<h3 id="bool_u5176_u5B9E_u662Fint_u7684_u5B50_u7C7B"><a href="#bool_u5176_u5B9E_u662Fint_u7684_u5B50_u7C7B" class="headerlink" title="bool其实是int的子类"></a>bool其实是int的子类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">97</span>]: isinstance(<span class="keyword">True</span>, int)</span><br><span class="line">Out[<span class="number">97</span>]: <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: <span class="keyword">True</span> + <span class="keyword">True</span></span><br><span class="line">Out[<span class="number">98</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: <span class="number">3</span> * <span class="keyword">True</span> + <span class="keyword">True</span></span><br><span class="line">Out[<span class="number">99</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: <span class="number">3</span> * <span class="keyword">True</span> - <span class="keyword">False</span></span><br><span class="line">Out[<span class="number">100</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: <span class="keyword">True</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">Out[<span class="number">104</span>]: <span class="number">1024</span></span><br></pre></td></tr></table></figure>
<h3 id="u5143_u7EC4_u662F_u4E0D_u662F_u771F_u7684_u4E0D_u53EF_u53D8_3F"><a href="#u5143_u7EC4_u662F_u4E0D_u662F_u771F_u7684_u4E0D_u53EF_u53D8_3F" class="headerlink" title="元组是不是真的不可变?"></a>元组是不是真的不可变?</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [111]: tup = ([],)</span><br><span class="line"></span><br><span class="line">In [112]: tup[0] += [1]</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-112-d4f292cf35de&gt; in &lt;module&gt;()</span><br><span class="line">----&gt; 1 tup[0] += [1]</span><br><span class="line"></span><br><span class="line">TypeError: 'tuple' object does not support item assignment</span><br><span class="line"></span><br><span class="line">In [113]: tup</span><br><span class="line">Out[113]: ([1],) # 我靠 又是亮瞎我眼睛,明明抛了异常 还能修改?</span><br><span class="line"></span><br><span class="line">In [114]: tup = ([],)</span><br><span class="line"></span><br><span class="line">In [115]: tup[0].extend([1])</span><br><span class="line"></span><br><span class="line">In [116]: tup[0]</span><br><span class="line">Out[116]: [1] # 好吧,我有点看明白了, 虽然我不能直接操作元组，但是不能阻止我操作元组中可变的子对象(list)</span><br></pre></td></tr></table></figure>
<p>+= 是一个特例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">117</span>]: my_tup = (<span class="number">1</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: my_tup += (<span class="number">4</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: my_tup = my_tup + (<span class="number">5</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: my_tup</span><br><span class="line">Out[<span class="number">120</span>]: (<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment"># ? 嗯 不是不能操作元组嘛?</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: my_tup = (<span class="number">1</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: print(id(my_tup))</span><br><span class="line"><span class="number">4481317904</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: my_tup += (<span class="number">4</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: print(id(my_tup))</span><br><span class="line"><span class="number">4480606864</span> <span class="comment"># 操作的不是原来的元组 所以可以</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: my_tup = my_tup + (<span class="number">5</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">126</span>]: print(id(my_tup))</span><br><span class="line"><span class="number">4474234912</span></span><br></pre></td></tr></table></figure>
<h3 id="u5F02_u5E38_u5904_u7406_u52A0_else"><a href="#u5F02_u5E38_u5904_u7406_u52A0_else" class="headerlink" title="异常处理加 else"></a>异常处理加 else</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">150</span>]: <span class="keyword">try</span>:</span><br><span class="line">   .....:     print(<span class="string">'third element:'</span>, a_list[<span class="number">2</span>])</span><br><span class="line">   .....: <span class="keyword">except</span> IndexError:</span><br><span class="line">   .....:     print(<span class="string">'raised IndexError'</span>)</span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:     print(<span class="string">'no error in try-block'</span>) <span class="comment"># 只有在try里面没有异常的时候才会执行else里面的表达式</span></span><br><span class="line">   .....:</span><br><span class="line">raised IndexError <span class="comment"># 抛异常了 没完全完成</span></span><br><span class="line">In [<span class="number">153</span>]: i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">154</span>]: <span class="keyword">while</span> i &lt; <span class="number">2</span>:</span><br><span class="line">   .....:     print(i)</span><br><span class="line">   .....:     i += <span class="number">1</span></span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:     print(<span class="string">'in else'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> <span class="keyword">else</span> <span class="comment"># while也支持哦~</span></span><br><span class="line">In [<span class="number">155</span>]: i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: <span class="keyword">while</span> i &lt; <span class="number">2</span>:</span><br><span class="line">   .....:         print(i)</span><br><span class="line">   .....:         i += <span class="number">1</span></span><br><span class="line">   .....:         <span class="keyword">break</span></span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:         print(<span class="string">'completed while-loop'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span> <span class="comment"># 被break了 没有完全执行完 就不执行else里面的了</span></span><br><span class="line">In [<span class="number">158</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">   .....:         print(i)</span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:         print(<span class="string">'completed for-loop'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">completed <span class="keyword">for</span>-loop</span><br><span class="line"></span><br><span class="line">In [<span class="number">159</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">   .....:         print(i)</span><br><span class="line">   .....:         <span class="keyword">break</span></span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:         print(<span class="string">'completed for-loop'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span> <span class="comment"># 也是因为break了</span></span><br></pre></td></tr></table></figure>
<h2 id="u6DF1_u62F7_u8D1D_u4E0E_u6D45_u62F7_u8D1D"><a href="#u6DF1_u62F7_u8D1D_u4E0E_u6D45_u62F7_u8D1D" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><h3 id="u5BF9_u8C61_u8D4B_u503C"><a href="#u5BF9_u8C61_u8D4B_u503C" class="headerlink" title="对象赋值"></a>对象赋值</h3><p>Python中，对象的赋值，拷贝（深/浅拷贝）之间是有差异的，如果使用的时候不注意，就可能产生意外的结果。</p>
<p>直接看一段代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">will = [<span class="string">"Will"</span>, <span class="number">28</span>, [<span class="string">"Python"</span>, <span class="string">"C#"</span>, <span class="string">"JavaScript"</span>]]</span><br><span class="line">wilber = will</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">"Wilber"</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">"CSS"</span>)</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br></pre></td></tr></table></figure>
<p><img src="/media/14521096832549/tip1.png" alt="tip1"></p>
<p>下面来分析一下这段代码：</p>
<ul>
<li>首先，创建了一个名为will的变量，这个变量指向一个list对象，从第一张图中可以看到所有对象的地址（每次运行，结果可能不同）</li>
<li>然后，通过will变量对wilber变量进行赋值，那么wilber变量将指向will变量对应的对象（内存地址），也就是说”wilber is will”，”wilber[i] is will[i]”</li>
<li>可以理解为，Python中，对象的赋值都是进行对象引用（内存地址）传递</li>
</ul>
<p>第三张图中，由于will和wilber指向同一个对象，所以对will的任何修改都会体现在wilber上<br>这里需要注意的一点是，str是不可变类型，所以当修改的时候会替换旧的对象，产生一个新的地址39758496</p>
<p><img src="/images/14588487955418.jpg" alt=""></p>
<h3 id="u6D45_u62F7_u8D1D"><a href="#u6D45_u62F7_u8D1D" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>下面就来看看浅拷贝的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">will = [<span class="string">"Will"</span>, <span class="number">28</span>, [<span class="string">"Python"</span>, <span class="string">"C#"</span>, <span class="string">"JavaScript"</span>]]</span><br><span class="line">wilber = copy.copy(will)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">"Wilber"</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">"CSS"</span>)</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br></pre></td></tr></table></figure>
<p>代码结果为：</p>
<p><img src="/images/14588488054814.jpg" alt=""></p>
<p>分析一下这段代码：</p>
<ul>
<li>首先，依然使用一个will变量，指向一个list类型的对象</li>
<li>然后，通过copy模块里面的浅拷贝函数copy()，对will指向的对象进行浅拷贝，然后浅拷贝生成的新对象赋值给wilber变量<ul>
<li>浅拷贝会创建一个新的对象，这个例子中”wilber is not will”</li>
<li>但是，对于对象中的元素，浅拷贝就只会使用原始元素的引用（内存地址），也就是说”wilber[i] is will[i]”</li>
</ul>
</li>
<li>当对will进行修改的时候<ul>
<li>由于list的第一个元素是不可变类型，所以will对应的list的第一个元素会使用一个新的对象39758496</li>
<li>但是list的第三个元素是一个可变类型，修改操作不会产生新的对象，所以will的修改结果会相应的反应到wilber上</li>
</ul>
</li>
</ul>
<p><img src="/images/14588488145630.jpg" alt=""></p>
<p>总结一下，当我们使用下面的操作的时候，会产生浅拷贝的效果：</p>
<ul>
<li>使用切片[:]操作</li>
<li>使用工厂函数（如list/dir/set）</li>
<li>使用copy模块中的copy()函数</li>
</ul>
<h3 id="u6DF1_u62F7_u8D1D"><a href="#u6DF1_u62F7_u8D1D" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>最后来看看深拷贝：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">will = [<span class="string">"Will"</span>, <span class="number">28</span>, [<span class="string">"Python"</span>, <span class="string">"C#"</span>, <span class="string">"JavaScript"</span>]]</span><br><span class="line">wilber = copy.deepcopy(will)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">"Wilber"</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">"CSS"</span>)</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br></pre></td></tr></table></figure>
<p>代码的结果为：</p>
<p><img src="/images/14588488380987.jpg" alt=""></p>
<p>分析一下这段代码：</p>
<ul>
<li>首先，同样使用一个will变量，指向一个list类型的对象</li>
<li>然后，通过copy模块里面的深拷贝函数deepcopy()，对will指向的对象进行深拷贝，然后深拷贝生成的新对象赋值给wilber变量<ul>
<li>跟浅拷贝类似，深拷贝也会创建一个新的对象，这个例子中”wilber is not will”</li>
<li>但是，对于对象中的元素，深拷贝都会重新生成一份（有特殊情况，下面会说明），而不是简单的使用原始元素的引用（内存地址）</li>
<li>例子中will的第三个元素指向39737304，而wilber的第三个元素是一个全新的对象39773088，也就是说，”wilber[2] is not will[2]”</li>
</ul>
</li>
<li>当对will进行修改的时候<ul>
<li>由于list的第一个元素是不可变类型，所以will对应的list的第一个元素会使用一个新的对象39758496</li>
<li>但是list的第三个元素是一个可变类型，修改操作不会产生新的对象，但是由于”wilber[2] is not will[2]”，所以will的修改不会影响wilber</li>
</ul>
</li>
</ul>
<p><img src="/images/14588488493152.jpg" alt=""></p>
<h3 id="u62F7_u8D1D_u7684_u7279_u6B8A_u60C5_u51B5"><a href="#u62F7_u8D1D_u7684_u7279_u6B8A_u60C5_u51B5" class="headerlink" title="拷贝的特殊情况"></a>拷贝的特殊情况</h3><p>其实，对于拷贝有一些特殊情况：</p>
<ul>
<li>对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有拷贝这一说<ul>
<li>也就是说，对于这些类型，”obj is copy.copy(obj)” 、”obj is copy.deepcopy(obj)”</li>
</ul>
</li>
<li>如果元组变量只包含原子类型对象，则不能深拷贝，看下面的例子</li>
</ul>
<p><img src="/images/14588488582446.jpg" alt=""></p>
<p>总结</p>
<p>本文介绍了对象的赋值和拷贝，以及它们之间的差异：</p>
<ul>
<li>Python中对象的赋值都是进行对象引用（内存地址）传递</li>
<li>使用copy.copy()，可以进行对象的浅拷贝，它复制了对象，但对于对象中的元素，依然使用原始的引用.</li>
<li>如果需要复制一个容器对象，以及它里面的所有元素（包含元素的子元素），可以使用copy.deepcopy()进行深拷贝</li>
<li>对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有被拷贝一说</li>
<li>如果元组变量只包含原子类型对象，则不能深拷贝，看下面的例子</li>
</ul>
<h2 id="Python__u4E2D_self__u7684_u542B_u4E49"><a href="#Python__u4E2D_self__u7684_u542B_u4E49" class="headerlink" title="Python 中 self 的含义"></a>Python 中 self 的含义</h2><p>刚开始学习Python的类写法的时候觉得很是麻烦，为什么定义时需要而调用时又不需要，为什么不能内部简化从而减少我们敲击键盘的次数？</p>
<h3 id="self_u4EE3_u8868_u7C7B_u7684_u5B9E_u4F8B_uFF0C_u800C_u975E_u7C7B_u3002"><a href="#self_u4EE3_u8868_u7C7B_u7684_u5B9E_u4F8B_uFF0C_u800C_u975E_u7C7B_u3002" class="headerlink" title="self代表类的实例，而非类。"></a>self代表类的实例，而非类。</h3><p>实例来说明</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line">        print(self.__class__)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Test object at <span class="number">0x000000000284E080</span>&gt;</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Test</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的例子中可以很明显的看出，self代表的是类的实例。而self.class则指向类。</p>
<h3 id="self_u4E0D_u5FC5_u975E_u5199_u6210self"><a href="#self_u4E0D_u5FC5_u975E_u5199_u6210self" class="headerlink" title="self不必非写成self"></a>self不必非写成self</h3><p>有很多童鞋是先学习别的语言然后学习Python的，所以总觉得self怪怪的，想写成this，可以吗？</p>
<p>当然可以，还是把上面的代码改写一下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(this)</span>:</span></span><br><span class="line">        print(this)</span><br><span class="line">        print(this.__class__)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure>
<p>改成this后，运行结果完全一样。</p>
<p>当然，最好还是尊重约定俗成的习惯，使用self。</p>
<h3 id="self_u53EF_u4EE5_u4E0D_u5199_u5417"><a href="#self_u53EF_u4EE5_u4E0D_u5199_u5417" class="headerlink" title="self可以不写吗"></a>self可以不写吗</h3><p>在Python的解释器内部，当我们调用t.prt()时，实际上Python解释成Test.prt(t)，也就是说把self替换成类的实例。</p>
<p>有兴趣的童鞋可以把上面的t.prt()一行改写一下，运行后的实际结果完全相同。</p>
<p>实际上已经部分说明了self在定义时不可以省略，如果非要试一下，那么请看下面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">()</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure>
<p>运行时提醒错误如下：prt在定义时没有参数，但是我们运行时强行传了一个参数。<br>由于上面解释过了t.prt()等同于Test.prt(t)，所以程序提醒我们多传了一个参数t。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"h.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    t.<span class="function"><span class="title">prt</span><span class="params">()</span></span></span><br><span class="line">TypeError: <span class="function"><span class="title">prt</span><span class="params">()</span></span> takes <span class="number">0</span> positional arguments but <span class="number">1</span> was given</span><br></pre></td></tr></table></figure>
<p>当然，如果我们的定义和调用时均不传类实例是可以的，这就是类方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">()</span>:</span></span><br><span class="line">        print(__class__)</span><br><span class="line">Test.prt()</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<pre><code>&lt;class &apos;__main__.Test&apos;&gt;
</code></pre><p>在继承时，传入的是哪个实例，就是那个传入的实例，而不是指定义了self的类的实例。<br>先看代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pprt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cprt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line">c = Child()</span><br><span class="line">c.cprt()</span><br><span class="line">c.pprt()</span><br><span class="line">p = Parent()</span><br><span class="line">p.pprt()</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__<span class="class">.Child</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A47080&gt;</span><br><span class="line">&lt;__main__<span class="class">.Child</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A47080&gt;</span><br><span class="line">&lt;__main__<span class="class">.Parent</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A47240&gt;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>运行c.cprt()时应该没有理解问题，指的是Child类的实例。</p>
<p>但是在运行c.pprt()时，等同于Child.pprt(c)，所以self指的依然是Child类的实例，由于self中没有定义pprt()方法，所以沿着继承树往上找，发现在父类Parent中定义了pprt()方法，所以就会成功调用。</p>
<p>在描述符类中，self指的是描述符类的实例</p>
<p>不太容易理解，先看实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desc</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, ins, cls)</span>:</span></span><br><span class="line">        print(<span class="string">'self in Desc: %s '</span> % self )</span><br><span class="line">        print(self, ins, cls)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    x = Desc()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'self in Test: %s'</span> % self)</span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br><span class="line">t.x</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self <span class="keyword">in</span> Test: &lt;__main__<span class="class">.Test</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A570B8&gt;</span><br><span class="line">self <span class="keyword">in</span> Desc: &lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000283E208&gt;</span><br><span class="line">&lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000283E208&gt; &lt;__main__<span class="class">.Test</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A570B8&gt; &lt;class <span class="string">'__main__.Test'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>大部分童鞋开始有疑问了，为什么在Desc类中定义的self不是应该是调用它的实例t吗？怎么变成了Desc类的实例了呢？</p>
<p>注意：此处需要睁大眼睛看清楚了，这里调用的是t.x，也就是说是Test类的实例t的属性x，由于实例t中并没有定义属性x，所以找到了类属性x，而该属性是描述符属性，为Desc类的实例而已，所以此处并没有顶用Test的任何方法。</p>
<p>那么我们如果直接通过类来调用属性x也可以得到相同的结果。</p>
<p>下面是把t.x改为Test.x运行的结果。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self <span class="keyword">in</span> Test: &lt;__main__<span class="class">.Test</span> <span class="tag">object</span> at <span class="number">0</span>x00000000022570B8&gt;</span><br><span class="line">self <span class="keyword">in</span> Desc: &lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000223E208&gt;</span><br><span class="line">&lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000223E208&gt; None &lt;class <span class="string">'__main__.Test'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>题外话：由于在很多时候描述符类中仍然需要知道调用该描述符的实例是谁，所以在描述符类中存在第二个参数ins，用来表示调用它的类实例，所以t.x时可以看到第三行中的运行结果中第二项为<main.test object="" at="" 0x0000000002a570b8="">。而采用Test.x进行调用时，由于没有实例，所以返回None。</main.test></p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>self在定义时需要定义，但是在调用时会自动传入。</li>
<li>self的名字并不是规定死的，但是最好还是按照约定是用self</li>
<li>self总是指调用时的类的实例。</li>
</ul>
<h2 id="Python_u7684_u5185_u5B58_u7BA1_u7406"><a href="#Python_u7684_u5185_u5B58_u7BA1_u7406" class="headerlink" title="Python的内存管理"></a>Python的内存管理</h2><p>以Python语言为例子，说明一门动态类型的、面向对象的语言的内存管理方式。</p>
<h3 id="u5BF9_u8C61_u7684_u5185_u5B58_u4F7F_u7528"><a href="#u5BF9_u8C61_u7684_u5185_u5B58_u4F7F_u7528" class="headerlink" title="对象的内存使用"></a>对象的内存使用</h3><p>赋值语句是语言最常见的功能了。但即使是最简单的赋值语句，也可以很有内涵。Python的赋值语句就很值得研究。</p>
<pre><code>a = 1
</code></pre><p>整数1为一个对象。而a是一个引用。利用赋值语句，引用a指向对象1。Python是动态类型的语言(参考动态类型)，对象与引用分离。Python像使用“筷子”那样，通过引用来接触和翻动真正的食物——对象。</p>
<p>为了探索对象在内存的存储，我们可以求助于Python的内置函数id()。它用于返回对象的身份(identity)。其实，这里所谓的身份，就是该对象的内存地址。</p>
<pre><code>a = 1
print(id(a))
print(hex(id(a)))
</code></pre><p>在我的计算机上，它们返回的是:</p>
<pre><code>11246696
’0xab9c68′
</code></pre><p>分别为内存地址的十进制和十六进制表示。</p>
<p>在Python中，整数和短小的字符，Python都会缓存这些对象，以便重复使用。当我们创建多个等于1的引用时，实际上是让所有这些引用指向同一个对象。</p>
<pre><code>a = 1
b = 1
print(id(a))
print(id(b))
</code></pre><p>上面程序返回</p>
<pre><code>11246696
11246696
</code></pre><p>可见a和b实际上是指向同一个对象的两个引用。</p>
<p>为了检验两个引用指向同一个对象，我们可以用is关键字。is用于判断两个引用所指的对象是否相同。</p>
<pre><code># True
a = 1
b = 1
print(a is b)

# True
a = &quot;good&quot;
b = &quot;good&quot;
print(a is b)

# False
a = &quot;very good morning&quot;
b = &quot;very good morning&quot;
print(a is b)

# False
a = []
b = []
print(a is b)
</code></pre><p>上面的注释为相应的运行结果。可以看到，由于Python缓存了整数和短字符串，因此每个对象只存有一份。比如，所有整数1的引用都指向同一对象。即使使用赋值语句，也只是创造了新的引用，而不是对象本身。长的字符串和其它对象可以有多个相同的对象，可以使用赋值语句创建出新的对象。</p>
<p>在Python中，每个对象都有存有指向该对象的引用总数，即引用计数(reference count)。</p>
<p>我们可以使用sys包中的getrefcount()，来查看某个对象的引用计数。需要注意的是，当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的多1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(getrefcount(a))</span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line">print(getrefcount(b))</span><br></pre></td></tr></table></figure>
<p>由于上述原因，两个getrefcount将返回2和3，而不是期望的1和2。</p>
<p>Python的一个容器对象(container)，比如表、词典等，可以包含多个对象。实际上，容器对象中包含的并不是元素对象本身，是指向各个元素对象的引用。</p>
<p>我们也可以自定义一个对象，并引用其它对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">from_obj</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, to_obj)</span>:</span></span><br><span class="line">        self.to_obj = to_obj</span><br><span class="line"></span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a = from_obj(b)</span><br><span class="line">print(id(a.to_obj))</span><br><span class="line">print(id(b))</span><br></pre></td></tr></table></figure>
<p>可以看到，a引用了对象b。</p>
<p>对象引用对象，是Python最基本的构成方式。即使是a = 1这一赋值方式，实际上是让词典的一个键值”a”的元素引用整数对象1。该词典对象用于记录所有的全局引用。该词典引用了整数对象1。我们可以通过内置函数globals()来查看该词典。</p>
<p>当一个对象A被另一个对象B引用时，A的引用计数将增加1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(getrefcount(a))</span><br><span class="line"></span><br><span class="line">b = [a, a]</span><br><span class="line">print(getrefcount(a))</span><br></pre></td></tr></table></figure>
<p>由于对象b引用了两次a，a的引用计数增加了2。</p>
<p>容器对象的引用可能构成很复杂的拓扑结构。我们可以用objgraph包来绘制其引用关系，比如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [x, dict(key1=x)]</span><br><span class="line">z = [y, (x, y)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> objgraph</span><br><span class="line">objgraph.show_refs([z], filename=<span class="string">'ref_topo.png'</span>)</span><br></pre></td></tr></table></figure>
<p>objgraph是Python的一个第三方包。安装之前需要安装xdot。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="keyword">install</span> xdot</span><br><span class="line">sudo pip <span class="keyword">install</span> objgraph</span><br></pre></td></tr></table></figure>
<p>两个对象可能相互引用，从而构成所谓的引用环(reference cycle)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">b = [a]</span><br><span class="line">a.append(b)</span><br></pre></td></tr></table></figure>
<p>即使是一个对象，只需要自己引用自己，也能构成引用环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">a.append(a)</span><br><span class="line">print(getrefcount(a))</span><br></pre></td></tr></table></figure>
<p>引用环会给垃圾回收机制带来很大的麻烦，我将在后面详细叙述这一点。</p>
<p>某个对象的引用计数可能减少。比如，可以使用del关键字删除某个引用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">print(getrefcount(b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line">print(getrefcount(b))</span><br></pre></td></tr></table></figure>
<p>del也可以用于删除容器元素中的元素，比如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> a[<span class="number">0</span>]</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>如果某个引用指向对象A，当这个引用被重新定向到某个其他对象B时，对象A的引用计数减少:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">print(getrefcount(b))</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">print(getrefcount(b))</span><br></pre></td></tr></table></figure>
<h3 id="u5783_u573E_u56DE_u6536"><a href="#u5783_u573E_u56DE_u6536" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>吃太多，总会变胖，Python也是这样。当Python中的对象越来越多，它们将占据越来越大的内存。不过你不用太担心Python的体形，它会乖巧的在适当的时候“减肥”，启动垃圾回收(garbage collection)，将没用的对象清除。在许多语言中都有垃圾回收机制，比如Java和Ruby。尽管最终目的都是塑造苗条的提醒，但不同语言的减肥方案有很大的差异。</p>
<p>从基本原理上，当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如某个新建对象，它被分配给某个引用，对象的引用计数变为1。如果引用被删除，对象的引用计数为0，那么该对象就可以被垃圾回收。比如下面的表:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> a</span><br></pre></td></tr></table></figure>
<p>del a后，已经没有任何引用指向之前建立的[1, 2, 3]这个表。用户不可能通过任何方式接触或者动用这个对象。这个对象如果继续待在内存里，就成了不健康的脂肪。当垃圾回收启动时，Python扫描到这个引用计数为0的对象，就将它所占据的内存清空。</p>
<p>然而，减肥是个昂贵而费力的事情。垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要总启动垃圾回收。所以，Python只会在特定条件下，自动启动垃圾回收。当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。</p>
<p>我们可以通过gc模块的get_threshold()方法，查看该阈值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">print(gc.get_threshold())</span><br></pre></td></tr></table></figure>
<p>返回(700, 10, 10)，后面的两个10是与分代回收相关的阈值，后面可以看到。700即是垃圾回收启动的阈值。可以通过gc中的set_threshold()方法重新设置。</p>
<p>我们也可以手动启动垃圾回收，即使用gc.collect()。</p>
<p>Python同时采用了分代(generation)回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。</p>
<p>小家伙要多检查</p>
<p>Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。</p>
<p>这两个次数即上面get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。</p>
<p>同样可以用set_threshold()来调整，比如对2代对象进行更频繁的扫描。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">gc.set_threshold(<span class="number">700</span>, <span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>引用环的存在会给上面的垃圾回收机制带来很大的困难。这些引用环可能构成无法使用，但引用计数不为0的一些对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">b = [a]</span><br><span class="line">a.append(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"><span class="keyword">del</span> b</span><br></pre></td></tr></table></figure>
<p>上面我们先创建了两个表对象，并引用对方，构成一个引用环。删除了a，b引用之后，这两个对象不可能再从程序中调用，就没有什么用处了。但是由于引用环的存在，这两个对象的引用计数都没有降到0，不会被垃圾回收。</p>
<p>为了回收这样的引用环，Python复制每个对象的引用计数，可以记为gc_ref。假设，每个对象i，该计数为gc_ref_i。Python会遍历所有的对象i。对于每个对象i引用的对象j，将相应的gc_ref_j减1。</p>
<p>在结束遍历后，gc_ref不为0的对象，和这些对象引用的对象，以及继续更下游引用的对象，需要被保留。而其它的对象则被垃圾回收。</p>
<h3 id="u603B_u7ED3-1"><a href="#u603B_u7ED3-1" class="headerlink" title="总结"></a>总结</h3><p>Python作为一种动态类型的语言，其对象和引用分离。这与曾经的面向过程语言有很大的区别。为了有效的释放内存，Python内置了垃圾回收的支持。Python采取了一种相对简单的垃圾回收机制，即引用计数，并因此需要解决孤立引用环的问题。Python与其它语言既有共通性，又有特别的地方。对该内存管理机制的理解，是提高Python性能的重要一步。</p>
<h2 id="u5B57_u5178_u63A8_u5BFC_28Dictionary_comprehensions_29_u548C_u96C6_u5408_u63A8_u5BFC_28Set_comprehensions_29"><a href="#u5B57_u5178_u63A8_u5BFC_28Dictionary_comprehensions_29_u548C_u96C6_u5408_u63A8_u5BFC_28Set_comprehensions_29" class="headerlink" title="字典推导(Dictionary comprehensions)和集合推导(Set comprehensions)"></a>字典推导(Dictionary comprehensions)和集合推导(Set comprehensions)</h2><p>大多数的Python程序员都知道且使用过列表推导(list comprehensions)。如果你对list comprehensions概念不是很熟悉——一个list comprehension就是一个更简短、简洁的创建一个list的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>some_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>another_list = [ x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> some_list ]</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>another_list</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>自从python 3.1 (甚至是Python 2.7)起，我们可以用同样的语法来创建集合和字典表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="comment"># Set Comprehensions</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>some_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>even_set = &#123; x <span class="keyword">for</span> x <span class="keyword">in</span> some_list <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>even_set</span><br><span class="line">set([<span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="comment"># Dict Comprehensions</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d = &#123; x: x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="number">1</span>: <span class="keyword">False</span>, <span class="number">2</span>: <span class="keyword">True</span>, <span class="number">3</span>: <span class="keyword">False</span>, <span class="number">4</span>: <span class="keyword">True</span>, <span class="number">5</span>: <span class="keyword">False</span>, <span class="number">6</span>: <span class="keyword">True</span>, <span class="number">7</span>: <span class="keyword">False</span>, <span class="number">8</span>: <span class="keyword">True</span>, <span class="number">9</span>: <span class="keyword">False</span>, <span class="number">10</span>: <span class="keyword">True</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个例子里，我们以some_list为基础，创建了一个具有不重复元素的集合，而且集合里只包含偶数。而在字典表的例子里，我们创建了一个key是不重复的1到10之间的整数，value是布尔型，用来指示key是否是偶数。</p>
<p>这里另外一个值得注意的事情是集合的字面量表示法。我们可以简单的用这种方法创建一个集合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>my_set</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>而不需要使用内置函数set()。</p>
<h2 id="Python_u8C03_u7528_u7CFB_u7EDF_u547D_u4EE4_u6216_u8005_u811A_u672C"><a href="#Python_u8C03_u7528_u7CFB_u7EDF_u547D_u4EE4_u6216_u8005_u811A_u672C" class="headerlink" title="Python调用系统命令或者脚本"></a>Python调用系统命令或者脚本</h2><p>使用 os.system() 调用系统命令 , 程序中无法获得到输出和返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>os.system(<span class="string">'ls -l /proc/cpuinfo'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>os.system(<span class="string">"ls -l /proc/cpuinfo"</span>)</span><br><span class="line">  -r--r--r-- <span class="number">1</span> root root <span class="number">0</span>  <span class="number">3</span>月 <span class="number">29</span> <span class="number">16</span>:<span class="number">53</span> /proc/cpuinfo</span><br><span class="line">  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>使用 os.popen() 调用系统命令, 程序中可以获得命令输出，但是不能得到执行的返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>out = os.popen(<span class="string">"ls -l /proc/cpuinfo"</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> out.read()</span><br><span class="line">  -r--r--r-- <span class="number">1</span> root root <span class="number">0</span>  <span class="number">3</span>月 <span class="number">29</span> <span class="number">16</span>:<span class="number">59</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure>
<p>使用 commands.getstatusoutput() 调用系统命令, 程序中可以获得命令输出和执行的返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> commands</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>commands.getstatusoutput(<span class="string">'ls /bin/ls'</span>)</span><br><span class="line">  (<span class="number">0</span>, <span class="string">'/bin/ls'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Python__u6355_u83B7_u7528_u6237_Ctrl+C__2CCtrl+D__u4E8B_u4EF6"><a href="#Python__u6355_u83B7_u7528_u6237_Ctrl+C__2CCtrl+D__u4E8B_u4EF6" class="headerlink" title="Python 捕获用户 Ctrl+C ,Ctrl+D 事件"></a>Python 捕获用户 Ctrl+C ,Ctrl+D 事件</h2><p>有些时候，需要在程序中捕获用户键盘事件，比如ctrl+c退出，这样可以更好的安全退出程序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    do_some_func()</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"User Press Ctrl+C,Exit"</span></span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"User Press Ctrl+D,Exit"</span></span><br></pre></td></tr></table></figure>
<h2 id="Python__u8BFB_u5199_u6587_u4EF6"><a href="#Python__u8BFB_u5199_u6587_u4EF6" class="headerlink" title="Python 读写文件"></a>Python 读写文件</h2><p>一次性读入文件到列表，速度较快，适用文件比较小的情况下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">track_file = <span class="string">"track_stock.conf"</span></span><br><span class="line">fd = open(track_file)</span><br><span class="line">content_list = fd.readlines()</span><br><span class="line">fd.close()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> content_list:</span><br><span class="line">    <span class="keyword">print</span> line</span><br></pre></td></tr></table></figure>
<p>逐行读入，速度较慢,适用没有足够内存读取整个文件(文件太大)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fd = open(file_path)</span><br><span class="line">fd.seek(<span class="number">0</span>)</span><br><span class="line">title = fd.readline()</span><br><span class="line">keyword = fd.readline()</span><br><span class="line">uuid = fd.readline()</span><br><span class="line">fd.close()</span><br></pre></td></tr></table></figure>
<p>写文件 write 与 writelines 的区别   </p>
<ul>
<li>Fd.write(str) : 把str写到文件中，write()并不会在str后加上一个换行符</li>
<li>Fd.writelines(content) : 把content的内容全部写到文件中,原样写入，不会在每行后面加上任何东西</li>
</ul>
<h2 id="u88C5_u9970_u5668"><a href="#u88C5_u9970_u5668" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器使一个函数或方法包装在另一个函数里头，可以在被包装的函数添加一些额外的功能，比如日志，还可以对参数、返回结果进行修改。装饰器有点类似Java中的AOP。下面这个例子是打印被装饰的函数里面的参数的装饰器，  </p>
<pre><code>&gt;&gt;&gt; def print_args(function):
&gt;&gt;&gt;     def wrapper(*args, **kwargs):
&gt;&gt;&gt;         print &apos;Arguments:&apos;, args, kwargs
&gt;&gt;&gt;         return function(*args, **kwargs)
&gt;&gt;&gt;     return wrapper

&gt;&gt;&gt; @print_args
&gt;&gt;&gt; def write(text):
&gt;&gt;&gt;     print text

&gt;&gt;&gt; write(&apos;foo&apos;)
Arguments: (&apos;foo&apos;,) {}
foo
</code></pre><p>@是语法糖，它等价于：  </p>
<pre><code>&gt;&gt;&gt; write = print_args(write)
&gt;&gt;&gt; write(&apos;foo&apos;)
arguments: (&apos;foo&apos;,) {}
foo
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这里收集了一些深入 python 机制的内容。</p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://wdxtub.com/tags/Python/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[个人知识管理指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/self-knowledge-management/"/>
    <id>http://wdxtub.com/2016/03/24/self-knowledge-management/</id>
    <published>2016-03-24T14:14:42.000Z</published>
    <updated>2016-03-24T15:06:19.000Z</updated>
    <content type="html"><![CDATA[<p>经过一年时间打磨，我的个人知识管理体系终于成型，在这里跟大家分享一下。</p>
<a id="more"></a>
<hr>
<p>在这个碎片化的时代，如何『聚合』是有门道的，甚至可以认为是『刚需』。各类门户各类新闻聚合各类资讯文章层出不穷，但是问题在于，作为个人，如何真正把看到的『信息』转化为『知识』呢？</p>
<p>在我之前的文章<a href="http://wdxtub.lofter.com/post/1a7a1d_5d46742" target="_blank" rel="external">《信息极简之道》</a>中，粗略介绍了基于七个不同组件的信息管理工作流，经过大半年的改进，最终形成了<a href="http://wdxtub.com/2016/01/02/cloud-workflow/">《极简解构工作流》</a>中介绍的方法。</p>
<blockquote>
<p>这套工作流的核心，在于『流』，也就是说，所有的一切，都是为了让信息在尽可能少的依赖和限制下自由流动。无论是不同的设备，不同的应用还是不同的形式，信息都应该能以最简单最自然的方式进行流动。并且，我也不希望整套工作流过分依赖某个步骤或者某个应用。</p>
</blockquote>
<p>前面的文章主要说的是思路，这篇文章中会结合实际应用详细介绍具体的工作流程（当然也有一些更新）。</p>
<h2 id="u8BBE_u8BA1_u54F2_u5B66"><a href="#u8BBE_u8BA1_u54F2_u5B66" class="headerlink" title="设计哲学"></a>设计哲学</h2><p>设计哲学主要有四点：极简、GTD、Unix 以及沉淀</p>
<ul>
<li>极简：所用工具简单，适应性稳定性强，对环境的依赖少，关注信息本身，自动完成琐碎繁杂工作，与此同时保持高可拓展性</li>
<li>GTD：规则化任务处理，尽量减少任务选择和切换时的消耗，断舍离，不陷入任务堆积的恶性循环中</li>
<li>Unix：所有信息通过文本文件的方式进行流动，减少了不同步骤和模块间的耦合，每一个步骤和模块都可以根据自己的喜好进行定制</li>
<li>沉淀：提取主题，写系列博客，把知识组织并分享出去</li>
</ul>
<p>根据这样的设计哲学，具体的设计和功能有：</p>
<ul>
<li>文件同步：Dropbox / Box / 百度云 / 金山云盘 / …<ul>
<li>不同文件夹表示不同笔记的类别，不同的笔记保存在不同的文本文件中</li>
<li>采用跨平台的文件同步服务，可以在不同电脑、手机上方便访问自己的笔记</li>
</ul>
</li>
<li>文本编辑：MWeb / Sublime / Atom / Visual Studio Code / Vim / Emacs / …<ul>
<li>基于 Markdown 语法的记录方式，利用文本文件实现不同的逻辑标记</li>
<li>任何文本编辑器都可以，只是显示效果可能有所差别</li>
</ul>
</li>
<li>信息导入：主要是 Kindle <ul>
<li>因为通常在使用 Kindle 进行阅读的时候会记录大量书摘，利用自己编写的信息导入插件，可以方便导出 kindle 书摘（成为文本文件），并无缝对接到知识管理系统中</li>
</ul>
</li>
<li>博客：Hexo / WordPress / …<ul>
<li>博客主要是用于记录和沉淀，并且能够把自己的思考分享出去</li>
</ul>
</li>
<li>随处访问：Github / Web / 手机 / 电脑<ul>
<li>因为基于简单的文件同步机制，所以在不同的平台上，都可以集成各种服务。比如说用 Github 进行版本控制，利用支持云盘同步的 APP 即可在手机上随时查看，博客内容也只需浏览器就可以方便浏览</li>
</ul>
</li>
</ul>
<h2 id="u5E94_u7528_u63A8_u8350"><a href="#u5E94_u7528_u63A8_u8350" class="headerlink" title="应用推荐"></a>应用推荐</h2><p>下面是我用着觉得比较顺手应用，推荐给大家（部分需要付费）</p>
<h3 id="MWeb"><a href="#MWeb" class="headerlink" title="MWeb"></a><a href="http://www.mweb.im/" target="_blank" rel="external">MWeb</a></h3><p><img src="/images/14588310376887.jpg" alt=""></p>
<ul>
<li>平台：Mac</li>
<li>功能：文件夹/文件管理，跨文件检索，即时预览，快捷插入图片，一键生成网站</li>
<li>简介：非常强大美观，可以说一次满足所有愿望，还是国人开发者的作品，良心</li>
</ul>
<h3 id="1Writer"><a href="#1Writer" class="headerlink" title="1Writer"></a><a href="http://1writerapp.com/" target="_blank" rel="external">1Writer</a></h3><p><img src="/images/14588312196908.jpg" alt=""></p>
<ul>
<li>平台：iPhone / iPad</li>
<li>功能：Markdown 支持，Dropbox 同步，文件夹/文件管理，导出 PDF，各种分享方式</li>
<li>简介：当之无愧的最佳，具体可以参考 <a href="http://wdxtub.com/2015/12/08/md-editor-ios/">iOS 上 Markdown 编辑器简评</a></li>
</ul>
<h2 id="Draft"><a href="#Draft" class="headerlink" title="Draft"></a><a href="https://play.google.com/store/apps/details?id=com.mvilla.draft" target="_blank" rel="external">Draft</a></h2><p><img src="/images/14588315888356.jpg" alt=""></p>
<ul>
<li>平台：Android</li>
<li>功能：Markdown 支持，Dropbox 同步，文件夹/文件管理，导出 PDF，各种分享方式</li>
<li>简介：因为小插件的缘故，甚至比 iOS 平台上的体验都好得多</li>
</ul>
<h3 id="Kindle_Voyage"><a href="#Kindle_Voyage" class="headerlink" title="Kindle Voyage"></a>Kindle Voyage</h3><p><img src="/images/14588317350582.jpg" alt=""></p>
<p>没啥好说的，还没买赶紧买买买啊！</p>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a><a href="https://hexo.io/" target="_blank" rel="external">Hexo</a></h3><p><img src="/images/14588317944639.jpg" alt=""></p>
<p>静态网站生成器，可以和 Github 完美对接（免费搭建自己的独立博客），相比其他的平台简单很多，我的博客就是由 hexo 搭建的</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这套工作流基本和工具解耦，能够很方便地根据自己的需要进行配置</p>
<ul>
<li>打通了各个设备的界限。微信订阅号的文章可以统一发送到 Kindle 上，在Kindle 上阅读批注后可以统一导入到电脑中</li>
<li>对操作系统和软件没有要求。整个工作流哪怕在一台全新的电脑上都可以快速展开，文件和文件夹是现代操作系统都有，系统也会自带编辑器和查找功能。唯一的区别就是，自己的电脑可以根据喜好进行配置，但是即使没有这些配置，整个工作流依然可以进行（比方说手头上没有自己电脑的时候）</li>
<li>所有的信息可以通过网络进行访问，无论是 Github 还是 Dropbox 或者是其他的云盘服务，都可以在线查看，只要有网，无论是手机还是电脑，都可以随时访问全部的信息</li>
<li>所有的内容保存在云端，可以方便进行场景的切换，比方说可以在手机上查看和编辑笔记，会自动同步到电脑上，随时可以切换到电脑继续刚才的工作</li>
<li>自动备份冗余：版本控制，更新时间等等都由云端处理，无须自己费心</li>
</ul>
<p>相信大家在具体的实践和摸索中，能找到最适合自己的方式。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>经过一年时间打磨，我的个人知识管理体系终于成型，在这里跟大家分享一下。</p>]]>
    
    </summary>
    
      <category term="信息" scheme="http://wdxtub.com/tags/%E4%BF%A1%E6%81%AF/"/>
    
      <category term="效率" scheme="http://wdxtub.com/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="自由" scheme="http://wdxtub.com/tags/%E8%87%AA%E7%94%B1/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
</feed>
