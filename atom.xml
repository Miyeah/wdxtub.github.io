<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-03-12T03:18:57.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[第九周 - 怕黑]]></title>
    <link href="http://wdxtub.com/2016/03/11/dark-fear/"/>
    <id>http://wdxtub.com/2016/03/11/dark-fear/</id>
    <published>2016-03-12T01:36:00.000Z</published>
    <updated>2016-03-12T03:18:57.000Z</updated>
    <content type="html"><![CDATA[<p>如果我说我忍住眼泪，如果我说我不会后悔，如果我说我忍住伤悲。因为我会怕黑，因为我厌倦雨打风吹，因为我隐藏我的眼泪。</p>
<a id="more"></a>
<hr>
<p>不知道什么时候开始怕黑，也不知道自己为什么怕黑。但是有句话这么说：Know God, No Fear; No God, Know Fear，想来我就是 No God 的那类人。看不一样的书，想不一样的理，做不一样的事，走不一样的路，自然就少了很多『牵绊』。</p>
<blockquote>
<p>It is no nation that we inhabit, but a language. by Emil Cioran</p>
</blockquote>
<p>倒是可以用这个句式来表达自己的心意：It is no goal that I pursue, but an experiment.</p>
<p>解释一下，对于目标来说，去追逐，意味着很多事情是冲着成功去做；而对于试验来说，更多是期待失败而去做。以目标的心态去做事情，成功开心，失败不开心；以试验的心态去做事情，无论成功还是失败，都算是验证了想法，都是下一次做得更好的基石。</p>
<p>这样去想，往往能放下很多没太多必要的『包袱』，轻装上阵反而更容易超水平发挥。很多人在真正达成目标的时候并没有想象中快乐，因为所谓的『快乐』本身就是虚幻的，即所谓 Phantom Happiness，不到最后，都没办法戳破自己吹的泡泡。不过话说回来，至少也达成了目标，也不是一件坏事儿。</p>
<p>Phantom Happiness 对应的恐怕就是 Phantom Pain 了，也就是 Metal Gear SOLID V 的标题。这要写起来就刹不住车了，还是留到专门的游戏评测里慢慢写个痛快，不过这里提三本相关的，严肃且黑暗的小说，看完这三本应该就对 Phantom Pain 有更深的了解，它们是《白鲸记》《一九八四》和《蝇王》。从无意义复仇，讲到极权统治双重思想，最后到个人意志与集体意志的冲突与湮灭，都是 MGS 这整个系列贯穿讨论的深刻哲学社会学问题。</p>
<p>前两天换了个莫(sha)西(ma)干(te)发型，开始了系统的运动健身计划，希望能以最好的精神面貌回国，现在真是数着日子过日子了。</p>
<blockquote>
<p>Two roads diverged in a wood, and I took the one less traveled by, And that has made all the difference.</p>
</blockquote>
<p>不要把心围上层层堡垒，不要让疲倦的心再枯萎，请不要让这一切变成不对。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果我说我忍住眼泪，如果我说我不会后悔，如果我说我忍住伤悲。因为我会怕黑，因为我厌倦雨打风吹，因为我隐藏我的眼泪。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="静静" scheme="http://wdxtub.com/tags/%E9%9D%99%E9%9D%99/"/>
    
      <category term="黑暗" scheme="http://wdxtub.com/tags/%E9%BB%91%E6%9A%97/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 Twitter 语料分析 6 MySQL 和 HBase 配置及测试]]></title>
    <link href="http://wdxtub.com/2016/03/11/cc-p6/"/>
    <id>http://wdxtub.com/2016/03/11/cc-p6/</id>
    <published>2016-03-11T11:10:38.000Z</published>
    <updated>2016-03-11T22:53:25.000Z</updated>
    <content type="html"><![CDATA[<p>完成了数据处理，我们就可以把清洗之后的数据导入数据库了，需要分别针对 MySQL 和 HBase 写两套代码。具体我们可以把数据库与前端分离，只要配置好能让前端来连接即可。</p>
<a id="more"></a>
<hr>
<h2 id="u6570_u636E_u5E93_u8BBE_u8BA1"><a href="#u6570_u636E_u5E93_u8BBE_u8BA1" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>我们需要做的很简单，就是返回某个用户用指定的 hashtag 发的 tweet，具体请求和响应的格式为：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">请求格式</span><br><span class="line"><span class="constant">GET</span> /q2?userid=uid&amp;hashtag=hashtag</span><br><span class="line"></span><br><span class="line">响应格式（如果有对应的推文）</span><br><span class="line"><span class="constant">TEAMID</span>,<span class="constant">TEAM_AWS_ACCOUNT_ID</span>\n</span><br><span class="line"><span class="constant">Sentiment_density1</span><span class="symbol">:Tweet_time1</span><span class="symbol">:Tweet_id1</span><span class="symbol">:Cencored_text1</span>\n</span><br><span class="line"><span class="constant">Sentiment_density2</span><span class="symbol">:Tweet_time2</span><span class="symbol">:Tweet_id2</span><span class="symbol">:Cencored_text2</span>\n</span><br><span class="line"><span class="constant">Sentiment_density3</span><span class="symbol">:Tweet_time3</span><span class="symbol">:Tweet_id3</span><span class="symbol">:Cencored_text3</span>\n</span><br><span class="line"></span><br><span class="line">响应格式（如果没有对应的推文）</span><br><span class="line"></span><br><span class="line"><span class="constant">TEAMID</span>,<span class="constant">TEAM_AWS_ACCOUNT_ID</span>\n</span><br><span class="line">\n</span><br></pre></td></tr></table></figure>
<p>可以看到，实际要在数据库中检索的内容，就是 <code>userid</code> 和 <code>hashtag</code>，其他的列只需要按照格式建立对应的列即可（后面需要用来排序）。</p>
<h3 id="MySQL_Schema"><a href="#MySQL_Schema" class="headerlink" title="MySQL Schema"></a>MySQL Schema</h3><p>一个可能的表格</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`q2`</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`q2`</span> (</span><br><span class="line">  <span class="string">`tweet_id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">UNSIGNED</span></span><br><span class="line">	<span class="string">`user_id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	<span class="string">`time`</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, </span><br><span class="line">	<span class="string">`content`</span> <span class="built_in">varchar</span>(<span class="number">140</span>),</span><br><span class="line">	<span class="string">`score`</span> <span class="built_in">REAL</span>,</span><br><span class="line">	<span class="string">`hashtag`</span> <span class="built_in">varchar</span>(<span class="number">14</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4 <span class="keyword">COLLATE</span> = utf8mb4_unicode_ci;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>索引要怎么建立</li>
<li>导入数据时可以使用 MyISAM engine，导入数据时较快，增加 <code>key_buffer_size</code></li>
</ul>
<p>创建的时候可以直接命令执行（直接用的之前的命令，注意对应改）</p>
<p><code>mysql -u root -pdb15319root song_db &lt; create_tables.sql</code></p>
<h3 id="HBase_Table"><a href="#HBase_Table" class="headerlink" title="HBase Table"></a>HBase Table</h3><p>HBase 的设计主要是需要决定具体的 rowkey 是什么（需要是唯一的），可以考虑用不同的项拼成一个 rowkey，然后剩下的数据放在 column family 中。</p>
<p>一个可能的设计是用 <code>tweet_id+user_id+hashtag</code> 作为 rowkey，具体怎么弄还要测试</p>
<ul>
<li>增加 BlockCache size</li>
<li>增加第二个索引: Phoenix -&gt; converted index</li>
</ul>
<h2 id="u5BFC_u5165_u6570_u636E"><a href="#u5BFC_u5165_u6570_u636E" class="headerlink" title="导入数据"></a>导入数据</h2><h3 id="u5BFC_u5165_MySQL"><a href="#u5BFC_u5165_MySQL" class="headerlink" title="导入 MySQL"></a>导入 MySQL</h3><p>大概的语法是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date</span><br><span class="line">mysqlimport --local --fields-terminated-by=<span class="string">'\t'</span> --lines-terminated-by=<span class="string">'\n'</span> -uroot -proot --default-character-set=utf8mb4 dbname filename</span><br><span class="line">date</span><br></pre></td></tr></table></figure>
<p>建立索引</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date</span><br><span class="line">mysql -uroot -proot dbname <span class="operator">-e</span> <span class="string">"create index iname on tablename (column1, column2,..)"</span></span><br><span class="line">date</span><br></pre></td></tr></table></figure>
<h3 id="u5BFC_u5165_HBase"><a href="#u5BFC_u5165_HBase" class="headerlink" title="导入 HBase"></a>导入 HBase</h3><p>需要使用 EMR 进行导入，具体参考 <a href="http://wdxtub.com/2016/02/22/cc-14/">云计算 第 14 课 文件 vs 数据库</a></p>
<ol>
<li>启动 EMR 集群：1 master &amp; 1 core <ul>
<li>在创建页面中选择 “Go to advanced options”</li>
<li>确保所有的实例都是 m1.large</li>
<li>确保 EMR 集群和存放 <code>runner.sh</code> 的实例在同一个区域</li>
<li>选择 AMI version 3.11.0 (hadoop version 2).</li>
<li>移除所有的已有服务(Pig &amp; Hive)并选择安装 HBase version 0.94.</li>
<li>指定 key-pair 以便 SSH 到 master 实例，ssh 的时候注意用户名是 hadoop</li>
<li>不要忘记设置标签：<code>15619project:phase1</code>,<code>15619backend:hbase</code></li>
<li>开启 “termination protection” 和 “keep-alive”</li>
</ul>
</li>
<li>master 和 core 节点的安全组都允许所有流量，使用 Master public DNS 来进行连接</li>
<li>ssh 到 master 节点之后，运行 <code>hadoop dfsadmin -report</code> 检查 HDFS 的状态</li>
</ol>
<p>这里我们用提供的 reference 来进行导入测试，注意需要先清理掉没有 hashtag 的内容，并且把数据组织成我们需要的形式（注意 hashtag 最后的 <code>\n</code>）。</p>
<p>这里可以下载下来本地跑，或者新开一个服务器来处理。</p>
<ul>
<li>根据设计的表来处理数据</li>
<li>用 awk 排序</li>
<li>合并数据，直接得到答案</li>
</ul>
<p>开启之后连接上去 <code>ssh -i group2 hadoop@dns.compute-1.amazonaws.com</code></p>
<p>然后用 <code>hadoop dfsadmin -report</code> 检查状态，一切正常之后就可以上传数据了，用如下命令即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir Q2</span><br><span class="line"><span class="built_in">cd</span> Q2</span><br><span class="line">scp -i group2.pem ./cdata hadoop@ec2-<span class="number">52</span>-<span class="number">91</span>-<span class="number">183</span>-<span class="number">102</span>.compute-<span class="number">1</span>.amazonaws.com:~/Q2/</span><br></pre></td></tr></table></figure>
<p>然后创建对应的 HDFS 目录，再把 csv 文件移过去：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir /housailei</span><br><span class="line">hadoop fs -mkdir /housailei/csv</span><br><span class="line">hadoop fs -put ./cdata /housailei/csv/</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">hadoop fs -ls /housailei/csv/</span><br></pre></td></tr></table></figure>
<p>然后进入 HBase Shell 操作 <code>hbase shell</code></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">001</span>:<span class="number">0</span>&gt; create <span class="string">'twitterdata'</span>,<span class="string">'data'</span></span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">002</span>:<span class="number">0</span>&gt; list</span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">003</span>:<span class="number">0</span>&gt; describe <span class="string">'twitterdata'</span></span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">004</span>:<span class="number">0</span>&gt; exit</span><br></pre></td></tr></table></figure>
<p>然后就需要具体的导入了，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 \t 为分隔符的话就不需要设定，这是默认的</span></span><br><span class="line">hbase org.apache.hadoop.hbase.mapreduce.ImportTsv -Dimporttsv.bulk.output=/hfile_groupt4 -Dimporttsv.columns=HBASE_ROW_KEY,data:useridtag,data:tweetid,data:time,data:score,data:content twitterdata /housailei/csv/cdata</span><br><span class="line"></span><br><span class="line">hbase org.apache.hadoop.hbase.mapreduce.LoadIncrementalHFiles /hfile_groupt4 twitterdata</span><br></pre></td></tr></table></figure>
<p>完成之后测试一下 <code>hbase shell</code>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">001</span>:<span class="number">0</span>&gt; scan <span class="string">'twitterdata'</span></span><br></pre></td></tr></table></figure>
<p>如果导入错误的话，可以在 hbase shell 中 <code>disable &#39;twitterdata&#39;</code> 之后 <code>drop &#39;twitterdata&#39;</code> 来删除这个表，还要原来的 shell 中删除原来的数据文件 <code>hadoop fs -rm /housailei/csv/cdata</code></p>
<p>重新导入的时候需要注意输出文件夹不能已存在，每次换新的就好。注意需要确保没有 <code>BAD_LINE</code> 才能继续。</p>
<h2 id="u524D_u7AEF_u8BBE_u8BA1"><a href="#u524D_u7AEF_u8BBE_u8BA1" class="headerlink" title="前端设计"></a>前端设计</h2><p>其实只需要写两个连接器用来连接对应的数据库，然后在 Undertow 的 handler 中对应调用即可。具体访问的方式同样可以参考 <a href="http://wdxtub.com/2016/02/22/cc-14/">云计算 第 14 课 文件 vs 数据库</a></p>
<ul>
<li>HBase 直接在 EMR 上做完，所以直接连接即可，不需要怎么配置</li>
<li>MySQL 就需要自己安装和配置了</li>
</ul>
<p>需要把换行符换回来</p>
<h2 id="u4F18_u5316_u6280_u5DE7"><a href="#u4F18_u5316_u6280_u5DE7" class="headerlink" title="优化技巧"></a>优化技巧</h2><h3 id="MySQL__u90E8_u5206"><a href="#MySQL__u90E8_u5206" class="headerlink" title="MySQL 部分"></a>MySQL 部分</h3><blockquote>
<p>为查询缓存优化你的查询</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询缓存不开启</span></span><br><span class="line">$r = mysql_query(<span class="string">"SELECT username FROM user WHERE signup_date &gt;= CURDATE()"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 开启查询缓存</span></span><br><span class="line">$today = date(<span class="string">"Y-m-d"</span>);</span><br><span class="line">$r = mysql_query(<span class="string">"SELECT username FROM user WHERE signup_date &gt;= '$today'"</span>);</span><br></pre></td></tr></table></figure>
<p>上面两条SQL语句的差别就是 CURDATE() ，MySQL的查询缓存对这个函数不起作用。所以，像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是用一个变量来代替MySQL的函数，从而开启缓存。</p>
<blockquote>
<p>为搜索字段建索引</p>
</blockquote>
<p>索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么，请为其建立索引吧。具体建立索引的方法前面有提过，这里不赘述。</p>
<blockquote>
<p>从 PROCEDURE ANALYSE() 取得建议</p>
</blockquote>
<p><a href="http://dev.mysql.com/doc/refman/5.0/en/procedure-analyse.html" target="_blank" rel="external">PROCEDURE ANALYSE()</a> 会让 MySQL 帮你去分析你的字段和其实际的数据，并会给你一些有用的建议。只有表中有实际的数据，这些建议才会变得有用，因为要做一些大的决定是需要有数据作为基础的。</p>
<p>例如，如果你创建了一个 INT 字段作为你的主键，然而并没有太多的数据，那么，PROCEDURE ANALYSE()会建议你把这个字段的类型改成 MEDIUMINT 。或是你使用了一个 VARCHAR 字段，因为数据不多，你可能会得到一个让你把它改成 ENUM 的建议。这些建议，都是可能因为数据不够多，所以决策做得就不够准。</p>
<p>一定要注意，这些只是建议，只有当你的表里的数据越来越多时，这些建议才会变得准确。一定要记住，你才是最终做决定的人。</p>
<blockquote>
<p>选择正确的存储引擎</p>
</blockquote>
<p>在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。</p>
<p>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 <code>SELECT COUNT(*)</code> 这类的计算是超快无比的。</p>
<p>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p>
<blockquote>
<p>参数配置</p>
</blockquote>
<p>打开配置文件 <code>vim /etc/my.cnf</code></p>
<ul>
<li>修改 <code>back_log</code> 参数值：由默认的50修改为500.（每个连接256kb,占用：125M）<ul>
<li><code>back_log</code> 值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果MySql的连接数据达到 <code>max_connections</code> 时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即<code>back_log</code>，如果等待连接的数量超过 <code>back_log</code>，将不被授予连接资源。</li>
<li><code>back_log</code> 值不能超过TCP/IP连接的侦听队列的大小。若超过则无效，查看当前系统的TCP/IP连接的侦听队列的大小命令：<code>cat /proc/sys/net/ipv4/tcp_max_syn_backlog</code>。对于 Linux 系统推荐设置为小于 512 的整数。</li>
<li><code>show variables like &#39;back_log&#39;;</code> 查看当前数量</li>
</ul>
</li>
<li>修改 <code>max_connections</code> 参数值，由默认的151，修改为3000（750M）<ul>
<li><code>max_connections</code> 是指MySql的最大连接数，如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySql会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。可以过’conn%’通配符查看当前状态的连接数量，以定夺该值的大小。</li>
<li>MySQL服务器允许的最大连接数16384；</li>
<li>查看系统当前最大连接数 <code>show variables like &#39;max_connections&#39;;</code></li>
</ul>
</li>
<li>修改 <code>thread_concurrency</code> 值<ul>
<li><code>thread_concurrency</code> 的值的正确与否, 对mysql的性能影响很大, 在多个cpu(或多核)的情况下，错误设置了 <code>thread_concurrency</code> 的值, 会导致mysql不能充分利用多cpu(或多核), 出现同一时刻只能一个cpu(或核)在工作的情况。</li>
<li><code>thread_concurrency</code> 应设为CPU核数的2倍. 比如有一个双核的CPU, 那<code>thread_concurrency</code> 的应该为4; 2个双核的cpu, thread_concurrency的值应为8.</li>
</ul>
</li>
</ul>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://coolshell.cn/articles/1846.html" target="_blank" rel="external">MySQL性能优化的最佳20+条经验</a></li>
<li><a href="http://dev.mysql.com/doc/refman/5.1/en/myisam-storage-engine.html" target="_blank" rel="external">target=”_blank”MyISAM Storage Engine</a></li>
<li><a href="http://dev.mysql.com/doc/refman/5.1/en/innodb.html" target="_blank" rel="external">InnoDB Storage Engine</a></li>
<li><a href="http://5434718.blog.51cto.com/5424718/1207526" target="_blank" rel="external">MySQL性能优化之参数配置</a></li>
<li><a href="https://blog.linuxeye.com/379.html" target="_blank" rel="external">MySQL性能调优my.cnf详解</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>完成了数据处理，我们就可以把清洗之后的数据导入数据库了，需要分别针对 MySQL 和 HBase 写两套代码。具体我们可以把数据库与前端分离，只要配置好能让前端来连接即可。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="HBase" scheme="http://wdxtub.com/tags/HBase/"/>
    
      <category term="MySQL" scheme="http://wdxtub.com/tags/MySQL/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="服务" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【潜龙谍影系列】故事、剧情与历史]]></title>
    <link href="http://wdxtub.com/2016/03/10/mgs/"/>
    <id>http://wdxtub.com/2016/03/10/mgs/</id>
    <published>2016-03-10T14:07:09.000Z</published>
    <updated>2016-03-10T19:49:33.000Z</updated>
    <content type="html"><![CDATA[<p>如果说这个世界上有第二个系列像 EVA 一样让我如痴如醉的话，那么肯定是 MGS 系列。在玩『潜龙谍影5：幻痛』的时候，每一段磁带（包含大量重要剧情信息）都认真听过之后，对于整个系列的剧情有了大概的认知。这篇文章会比较长，综合了网上的各种资料和我自己的理解，希望能给大家带来一个比较完整的阅读体验。</p>
<a id="more"></a>
<hr>
<p>Here’s to you Nicolas and Bart 尼古拉和巴特，这是献给你们的赞歌</p>
<p>Rest forever here in our hearts 你们将永远被铭记在心</p>
<p>The last and final moment is yours 最终的胜利属于你们</p>
<p>That agony is your triumph 那份痛苦和折磨就是你们的见证</p>
<p>Petals of white 片片白花</p>
<p>Cover fields flowing in grieving tears 漫散在这个被泪水淹没的地方</p>
<p>And all the hearts once new, old and shattered now 一颗颗曾年轻的心，如今也都已苍老破碎</p>
<p>Love can kill,love will die 爱能伤人，爱也会死</p>
<p>Give me wings to fly 给我翅膀去飞吧</p>
<p>Fleeing this world so cold 飞离这个冰冷的世界</p>
<p>I just wonder why 我只是不能理解这一切</p>
<p>Cold as the dark 寒冷如夜</p>
<p>Now my words, are frosted with every breath 话语已随气息而凝结</p>
<p>Still the hate burns wild, growing inside this heart 但那仇恨却越燃越盛，深深扎根于这颗心</p>
<p>When the wind changes course when the star align 若一切物是人非，沧海桑田</p>
<p>I will reach out to you and leave this all behind 我就会破除万难并回到你的身边</p>
<p>When heavens divide 当天堂破碎的时候……</p>
<p>I will see the choices within my hands 我才明了我选择的路</p>
<p>How can we ever protect and fight with our tiny souls 我们渺小的灵魂要怎样去抗争，去奋斗？</p>
<p>Let me shine like the sun through the doubts of fear 让我闪耀，像太阳一样，穿透那些恐惧的阴云</p>
<p>Do you feel the storm approach as the end draws near 而你又是否会感受到这场终结的风暴即将来临</p>
<p>When heavens divide当天堂破碎的时候</p>
<p>Time will come to softly lay me down 时间将会悄悄为我送葬</p>
<p>Then I can see a face that I long to see 这样我才能看到那个，我期盼已久的脸庞</p>
<p>And for you, only you I would give anything 为了你，只为了你，我愿意付出一切</p>
<p>Leaving a trace for love to find a way 筑出一条血路，去追寻你的足迹</p>
<p>When heavens divide当天堂破碎的时候</p>
<p>I will dive into the fire 我会为你赴汤蹈火</p>
<p>Spilling the blood of my desire 撒尽我的每一滴热血</p>
<p>The very last time 在最后的最后</p>
<p>My name scorched into the sky 我的名字将会刻入天际</p>
<h2 id="u5386_u53F2_u80CC_u666F"><a href="#u5386_u53F2_u80CC_u666F" class="headerlink" title="历史背景"></a>历史背景</h2><h3 id="1960__u5E74_u4E4B_u524D"><a href="#1960__u5E74_u4E4B_u524D" class="headerlink" title="1960 年之前"></a>1960 年之前</h3><p>1918 年同盟国（德国、奥匈、土耳其、保加利亚）和协约国（英国、法国、俄国、意大利）进行的世界大战，简称一战，约有6500万人参战，1000万人丧生，2000万人受伤。1918年，这场战争以协约国的胜利告终。</p>
<p>同年，弗拉基米尔·列宁在俄国建立了秘密情报机构格勒乌（GRU）。</p>
<p><img src="/images/14576194971120.jpg" alt=""></p>
<p>一战之后，美国、苏联、中国三大国最富有、最有权力的人——他们被称为智者议会（ Wisemen’s Committee），建立了秘密组织：哲学家（ThePhilosophers）。这些人拥有广泛的社会触角和近乎无限的资源，哲学家组织希望借助他们庞大的资源影响世界局势，让类似一战的大规模全球冲突不再重演。在成立后，哲学家的势力迅速增长，很快成为他们各自的国家政府背后的绝对权力。</p>
<p><strong>引领者出生 1922 年</strong></p>
<p><img src="/images/14576196418920.jpg" alt="引领者，又称 The Boss"></p>
<p>哲学家组织高级成员，智者议会成员的女儿引领者（TheBoss）出生。这个女子会成为美国乃至世界历史中的一位幕后的关键人物。</p>
<p><strong>第二次世界大战开始 1939 年</strong></p>
<p>1939年9月1日，德国集中强大兵力，对波兰发动“闪电战”，第二次世界大战全面爆发。</p>
<p>在二战期间，哲学家的成员收集了大量资源、金钱，总金额超过1000亿美元（大概相当于今天的1万6000亿美元左右）,意在发展新型战争手段：如核武器、眼镜蛇部队等，以终结战争。这笔巨额资产被称为“哲学家的遗产”（the Philosophers’ Legacy），而各国的哲学家组织则达成协议，在击败轴心国后，把这笔巨款返还各国。唯一取得这笔巨款的方式是一套微型胶片——胶片里储存着这些资金在各个银行的交易记录。然而，二战结束后，哲学家的遗产——即微型胶卷却被负责为哲学家洗钱的苏联军官鲍里斯·沃尔金（Boris Volgin）窃取。</p>
<p><img src="/images/14576198651470.jpg" alt="第二次世界大战"></p>
<p><strong>卡廷惨案</strong></p>
<p>第二次世界大战期间苏联秘密警察机关在苏共中央的批准下，于1940年4月至5月间对被俘的波兰战俘、知识分子、警察及其他公务员进行的大屠杀,共杀死2.2万人。因为4421人在卡廷森林被处决，故名卡廷事件。</p>
<p>窃取哲学家遗产的鲍里斯·沃尔金的儿子，时任苏联内务部内卫部队军官的叶夫根尼·鲍里索维奇·沃尔金（Yevgeny Borisovitch Volgin）上校参与了这场惨案。他的惯用手法是，将囚徒的眼罩掀开，再殴打致死。沃尔金还参与过1953年的东德反乱镇压和1956年的匈牙利动乱镇压，其本人曾不无得意地表示，他“处理”过超过10万人。</p>
<p>鲍里斯·沃尔金去世后，哲学家的遗产被其子叶夫根尼·鲍里索维奇·沃尔金继承。</p>
<p><img src="/images/14576200196071.jpg" alt="卡廷惨案"></p>
<p><strong>曼哈顿计划启动·眼镜蛇部队成军 1942 年</strong></p>
<p>二战期间，引领者创建了秘密特殊部队眼镜蛇部队。这支部队集合了联合国军最优秀的士兵，并由引领者亲自编成和训练。眼镜蛇部队所负责的任务一般绝对保密，在死前，该部队成员会用身上装备的小型炸弹进行自爆，以避免泄露秘密。在部队中，代号为苦痛者（The Pain）、恐惧者（The Fear）、末日者（The End）、狂怒者（The Fury）、悲哀者（The Sorrow）几位成员对引领者怀有特殊的情感，后来再次集结到她的身边。引领者本人则代号“欢乐”（The Joy），意为在战场上寻找到无上的欢乐。</p>
<p>同年，开发原子弹的工程曼哈顿计划在美国启动。</p>
<p><img src="/images/14576201575441.jpg" alt="曼哈顿计划"></p>
<p><strong>盟军进行诺曼底登陆行动 1944 年</strong></p>
<p>20世纪最大的登陆战役，盟军调集288万部队，横渡英吉利海峡，让英美军队重返欧洲战场。</p>
<p>由于眼镜蛇部队破坏了德军的V2导弹，在诺曼底登陆中发生了重要作用。引领者和悲哀者者的孩子山猫（Ocelot）在也在这场登陆战役中诞生，并在引领者的腹部留下一道蛇形的疤痕。</p>
<p><img src="/images/14576202257805.jpg" alt="诺曼底登陆"></p>
<p><strong>三一弹试爆，日本遭受原子弹轰炸&amp;修依·艾默里出生 1945 年</strong></p>
<p>第一颗原子弹——三一弹在美国试爆成功。同年，美国在日本投下两颗原子弹——小男孩、胖子。</p>
<p>同年，修依·艾默里克出生。他的父亲参与过曼哈顿计划，他则出生就双腿残疾。后来，他成为一名双足步行兵器的开发者。</p>
<p><strong>CIA成立·眼镜蛇部队解散 1947 年</strong></p>
<p>美国中央情报局（CIA）成立。同年，在二战中功勋卓著的部队“眼镜蛇”，在哲学家组织因为争夺哲学家遗产导致的紧张分裂态势下解散。</p>
<p><strong>朝鲜战争爆发·引领者与大首领相遇 1950 年</strong></p>
<p>1950年6月25日，朝鲜进攻韩国，朝鲜战争爆发。以美国为首的联合国军在当年9月15日从仁川登陆，帮助韩国进行反攻。10月25日，中国人民志愿军赴朝，与朝鲜并肩作战。</p>
<p>一个15岁的少年约翰（John）参与了朝鲜战争，而他将成为美国历史上最优秀的战士：大首领（Big Boss）。同样在这一年，约翰结识了传奇英雄引领者，并向引领者学习战斗、谍报、生存等多种技能超过10年以上，二人的关系和羁绊已经超越简单的师徒。二人一起创立了CQC近身格斗术。</p>
<p><strong>美国进行内华达州核爆实验·引领者暴露于大量核辐射 1951 年</strong></p>
<p>1950年，美国总统杜鲁门签署命令，宣布在内华达州的内利斯空军靶场建立内华达国家安全区。</p>
<p>1951年1月27日，内华达国家安全区在弗伦奇曼平底进行了第一次核试验，爆炸当量相当于1000吨TNT。</p>
<p>1951年11月1日，引领者参与内华达州核爆实验，暴露在大量核辐射下，失去了生育的能力。</p>
<p><img src="/images/14576205637151.jpg" alt="内华达州核爆实验"></p>
<p><strong>美国试爆第一枚氢弹·大首领暴露于大量辐射 1954 年</strong></p>
<p>美国在比基尼环礁上试爆了第一枚氢弹。约翰，即后来的大首领也被牵扯其中。他当时的朋友都因核辐射染上白血病、甲状腺癌等致命疾病，或直接死于辐射，但大首领并没有染上这类病症。尽管如此，大首领还是和他的导师引领者一样，在核辐射下失去了自然生殖的能力。</p>
<p><img src="/images/14576205854028.jpg" alt="试爆第一枚氢弹"></p>
<h3 id="1961__u5E74_-_1970__u5E74"><a href="#1961__u5E74_-_1970__u5E74" class="headerlink" title="1961 年 - 1970 年"></a>1961 年 - 1970 年</h3><p><strong>美政府实行“水星计划”·奇爱博士结识引领者 1961 年</strong></p>
<p>美国在1959年开始载人航天计划“水星计划”。尽管官方历史记载美国航天第一任是1961年5月5日进入太空的艾伦·B·谢泼德，但事实上，第一位进入太空的美国人是引领者，她在“水星计划”中扮演了重要角色，并在1961年4月进入太空，1961年4月12日返回地球。再入大气层时，引领者被宇宙辐射和再入大气层产生的热量严重灼伤，进入了长达6个月的严重昏迷。在太空俯瞰地球的震撼景象，让引领者深信世界应该团结一心，而非分阵营对立。</p>
<p>在水星计划中，引领者结识了水星计划科研人员奇爱博士，奇爱博士对引领者产生了深深的感情。</p>
<p><strong>古巴导弹危机 1962 年</strong></p>
<p>1962年，苏联在古巴秘密部署导弹，并被美国发现。肯尼迪总统大为震怒，宣布封锁古巴，要求苏联撤回已经部署的导弹设施。1962年，10月24日，美国出动90艘军舰，封锁了古巴海峡，所有导弹部队均处于高度戒备状态，全球性的核战争一触即发。最终，赫鲁晓夫同意撤回部署在古巴的导弹设施。</p>
<p>而事实上，赫鲁晓夫同意妥协的不为人知的重要原因，在于肯尼迪同意将逃往至美国的武器开发专家斯特潘诺维奇·索科洛夫遣返至苏联。被遣返回苏联后，这位武器专家被直接送到秘密设计局OKB-754。</p>
<p><img src="/images/14576208423544.jpg" alt="古巴导弹危机"></p>
<p><strong>肯尼迪遇刺身亡·小岛秀夫出生1963</strong></p>
<p>美国总统肯尼迪遇刺，其原因在于哲学家组织不满肯尼迪在猪湾事件中的表现，将其刺杀。</p>
<p>同年，日本人小岛秀夫出生。有传言他与哲学家、引领者、大首领均有神秘的关系，有人甚至认为这个出生晚于哲学家建立的日本人其实是一切的幕后黑手。实际联系至今亦不明朗，尚需进一步调查确认。（这个中二程度不轻啊）</p>
<p><img src="/images/14576209221127.jpg" alt="肯尼迪遇刺身亡"></p>
<p><strong>贞洁行动失败 1964 年 8 月 24 日</strong></p>
<p>美国政府则派出FOX部队——零少校（Major Zero）和引领者建立的CIA秘密行动小组，希望将遣返回美国的武器专家斯特潘诺维奇·索科洛夫再次营救回美国，这次任务的代号即为“贞洁行动”（Virtuous Mission）。约翰（John）,任务代号裸蛇（Naked Snake），FOX部队的第一个探员，被派往苏联丛林带回索科洛夫。</p>
<p>任务进行到一半，原本应是任务支援的引领者却向苏联变节，阻止了整个行动。引领者集结了眼镜蛇部队的一帮原成员，伙同苏联军官，哲学家遗产的拥有者沃尔金，将裸蛇打下吊桥，带走了索科洛夫。引领者将一枚微型核弹头作为见面礼送给了沃尔金，沃尔金则在苏联领土用这枚核弹打击了秘密设计局OKB-754。这枚美国核弹在苏联的引爆，导致美国的非法入侵被苏联指责，核大战危机再次一触即发。当然，贞洁行动也以失败告终。</p>
<p>在贞洁行动中，裸蛇完成了历史首次HALO降落——从高空跳下，并在低空打开降落伞。</p>
<p><img src="/images/14576210570962.jpg" alt="Metal Gear Solid 3 Snake Eater"></p>
<p>这段故事就是『潜龙谍影3：食蛇者』的剧情，于 2004年11月(PS2)/2011年11月(PS3，360版HD)/2012年6月(PSV版HD) 发售。可以看做是游戏系列里最先的一作。</p>
<p><strong>代号食蛇者行动·苏联军官沃尔金意外遭受雷击 1964 年 8 月 30 日</strong></p>
<p>为了抹杀变节者引领者,食蛇者行动展开。裸蛇乘坐单人驾驶式飞机，再次侵入苏联境内。在任务中，他得到了伊娃（Eva）的帮助，她表面上是一个前美国国安局间谍，其实是哲学家和某大国的双重间谍，裸蛇也遭遇了年轻的俄国格勒乌军官左轮山猫，与他数次交手，并在他的枪下失去了右眼，戴上眼罩。在重重的困难之中，裸蛇一一击败了前眼镜蛇部队的成员，并击毁了核搭载战车峡谷虎（Shagohod）。在追逐裸蛇的过程中，沃尔金遭雷劈，疑似死亡。</p>
<p><img src="/images/14576212112140.jpg" alt="代号食蛇者行动"></p>
<p><strong>代号食蛇者行动·引领者在苏联境内逝世</strong></p>
<p>在食蛇者行动的最后，引领者和大首领在一片花海之中展开命定的师徒之战。引领者吐露了自己的梦想，希望世界不要在冷战的阴云下割裂，而应该再次团结一心。大首领只有10分钟击败自己的导师，在时间结束之时，他们的所在地会遭到轰炸。大首领最终打败了自己的导师，在生命的最后时刻，引领者把记载着爱国者遗产交易记录的微缩胶片交给了大首领，并要求大首领杀死自己。枪响，白色的花海一片血红。</p>
<p><img src="/images/14576212725582.jpg" alt="Boss VS Big Boss"></p>
<p><strong>美国总统授予战斗英雄约翰大首领称号 1969 年</strong></p>
<p>由于成功击杀了引领者，裸蛇约翰被美国总统授予大首领的荣誉称号。但随后，他也了解到关于食蛇者行动的真相。引领者其实秘密为美国政府工作。沃尔金从他父亲手中继承了哲学家的遗产，而引领者变节的目的是接近沃尔金，拿回哲学家的遗产，但因为沃尔金意料之外地发射核弹，她的任务变了:她需要死在裸蛇手里，永远作为一个叛徒为世人所知，从而给愤怒的苏联一个交代，引领者也接受了这一任务的变化，最终死在自己门徒手中，并把哲学家遗产交给了美国。裸蛇对美国政府幻想破灭，他拒绝承认大首领的称号，并退出了FOX部队。引领者交给大首领的哲学家遗产只有一半，这一半遗产落入CIA之手，然而CIA的中央情报总监并未上报，只是留在自己的手中。</p>
<p><strong>阿帕网诞生 1969 年</strong></p>
<p>美国高级研究计划署组建了计算机网络：高级研究计划代理网络（Advanced Research Projects Agency Network），简称阿帕网。在阿帕网基础上，现代的互联网逐渐发展而来。信息串流和分享方式的革命给“爱国者”AI后来利用信息统治世界提供了技术基础。</p>
<p>事实上，后来的“爱国者”组织的创始人之一希金特也参与了阿帕网的开发，并在此后不久升任美国国防部高级研究计划局（DARPA）的局长。</p>
<p><img src="/images/14576214023876.jpg" alt="阿帕网"></p>
<p><strong>“爱国者”诞生 1970 年</strong></p>
<p>山猫刺杀了CIA的中央情报总监，取得了哲学家遗产。在哲学家遗产的基础上，大首领、零上校、左轮山猫，和两位参加了食蛇者行动的FOX前成员：空降护理和希金特建立了“爱国者”（The Patriots）组织。爱国者组织实际上是哲学家美国分布的重组。其建立目的是为了实现引领者关于世界大同的梦想。零把这个梦想解读为“没有边界的世界（World Without Borders）”，在一个规则下团结起整个世界。所以零大肆宣扬大首领的传奇，作为一种宣传控制的手段。斯内克相信零是为了自己的利益歪曲了引领者的心愿。</p>
<p><img src="/images/14576214873702.jpg" alt="The Patriots"></p>
<p><strong>黑历史之中的猎狐犬小队成立 1969~1970 年</strong></p>
<p>有着Big Boss称号的Snake早已从FOX小队中退役，开始过着训练新兵的生活。可是突然一天Snake等全部和FOX小队有关系的人员都被逮捕。原来FOX小队的指挥官Gene叛变了，Gene意图建立Army’s Heaven——这个只属于军人的国家，以打破世界的军事平衡。Big Boss在追击Gene的途中将很多人纳为了自己的同伴，比如NULL，Elisa和Johnthan等，同时这些人成立了猎狐犬小队，开始对FOX部队进行反击。最终BB干掉了MetalGear之后打倒了Gene。Gene在死前将手头上的所有资金设备全部交给了BB，并且声称BB以后一定会用到这笔资源。</p>
<p><img src="/images/14576215645424.jpg" alt="Metal Gear Solid : Portable Ops Plus"></p>
<p>这段故事就是 Metal Gear Solid : Portable Ops Plus 中的剧情，于 2006年12月/2007年9月(加强版) 在 PSP 平台发售。</p>
<h3 id="1971__u5E74_-_1980__u5E74"><a href="#1971__u5E74_-_1980__u5E74" class="headerlink" title="1971 年 - 1980 年"></a>1971 年 - 1980 年</h3><p><strong>美政府启动“魔童计划” 1971 年</strong></p>
<p>美国政府开始进行魔童计划（Les Enfants Terribles，法语，糟糕的，可怕的孩子，来自50年代同名电影）。该计划意图制造出传奇战士大首领的克隆体。该计划的幕后资助人是零，克拉克博士带头进行。零的意图不仅是要造出最强的战士，更是要保证如果和大首领分道扬镳，可以制造出另一个可以加以利用的偶像。克拉克博士参与过贞洁行动和食蛇者行动，当时代号空降护理（Para-Medic）。</p>
<p><img src="/images/14576216937761.jpg" alt="魔童计划"></p>
<p><strong>双蛇诞生 1972 年</strong></p>
<p>伊娃作为代孕母亲，魔童计划的成果——双蛇诞生。继承较优秀显性基因的孩子，就来被叫做利奎德·斯内克（Liquid Snake，液体蛇），而继承较劣质隐性基因的孩子，就是后来的索立德·斯内克（Solid Snake，固体蛇）。后来，继承了完美而平衡的基因的第三个克隆体，索利达斯·斯内克（Solidus Snake）诞生，即日后的美国总统乔治·希尔斯（George Sears）。</p>
<p>魔童计划并没有事先知会大首领，大首领为零私下进行这一计划感到愤怒。由于和零不可弥合的理念分歧，同年，大首领离开爱国者，与零分道扬镳。</p>
<p><img src="/images/14576217571827.jpg" alt="双蛇诞生"></p>
<p><strong>和平行者事件·AI核武器“和平行者”被毁 1974 年</strong></p>
<p>某一天，自称是和平大学教授的盖尔维兹与他的学生帕兹（Paz）来到无界之师的驻地，请求大首领前往哥斯达黎加调查一支神秘的武装部队，并许以一个人造浮岛基地，但是遭到了拒绝。最终由于一卷录有引领者声音的录音带，大首领答应了真实身份是为克格勃工作的盖尔维兹。</p>
<p>大首领之后在哥斯达黎加当地游击队桑地诺民族解放阵线（FSLN）的帮助下，发现神秘部队受美国中情局（CIA）指挥，将由AI控制的核武器运入哥斯达黎加。其中有一台搭载了引领者的AI——和平行者，也正是录音带中声音的来源。而这一切都是CIA中美洲站长冦尔德曼（Coldman）为了夺回自己在CIA中的地位，而计划另美苏再次陷入核危机之中。在冦尔德曼死在盖尔维兹（真名扎德尔诺夫）枪下之前，启动了和平行者的核弹发射指令。大首领在与和平行者一番激战之后，引领者的AI控制和平行者自己沉入湖中，再次给了世界一个和平的机会。</p>
<p><img src="/images/14576218515576.jpg" alt="Metal Gear Solid: Peace Walker"></p>
<p>这段故事就是 Metal Gear Solid: Peace Walker 的剧情，于 2010年4月(PSP)/2011年11月(PS3,360版HD) 发售。</p>
<p><strong>和平行者事件·三重间谍帕兹坠海失踪</strong></p>
<p>帕兹的真实身份是一名Cipher（零）的间谍。在“和平行者事件”后，回到无界之师的她开始了真正的任务。在试图破坏Metal Gear ZEKE的动力部时被奇科目击，不得已提前行动。帕兹表明Cipher希望大首领重新回到“爱国者”组织并以向美国东部发射核弹相威胁，但遭到拒绝，只能驾驶Metal Gear ZEKE与大首领开战，后被大首领击败，坠入太平洋中。</p>
<p><img src="/images/14576219542113.jpg" alt="帕兹 Paz"></p>
<p><strong>和平行者事件·雇佣兵团无界之师崛起</strong></p>
<p>通过“和平行者事件”，无界之师获得了“母基地”（Mother Base）作为基地，又说得了不少CIA与苏联的佣兵与人才，无论是兵力还是装备，都已经匹敌一个小国的军事实力，并且开始对外派遣佣兵，已可以称为民间军事企业。从和平行者上回收核弹头并自行开发了Metal Gear ZEKE后，无界之师已经成为“世界第七个核武器保有国”。</p>
<p>在击败帕兹，并再次粉碎Cipher的企图后，大首领发布了无界之师崛起宣言：“我们没有国家，没有信仰，没有意识形态。哪里需要我们我们就去哪里，不为国家，不为政府，我们为自己而战。我们战斗不需要理由，仅仅因为有人需要我们。我们会是那些无助者们的威慑力！我们是没有国界的士兵，我们的目标由我们所处的时代所决定！”</p>
<p><img src="/images/14576220334771.jpg" alt="无界之师"></p>
<p><strong>《自私的基因》发表·海上雇佣兵基地“母基地”被毁 1975 年</strong></p>
<p>修依坚持无界之师（MSF）应该向全世界证明自己的干净清白，于是MSF决定接受相关检查。在检查之夜，米勒和斯内克得到消息，帕兹活下来了，被关在欧米茄（OMEGA）营地——一个美国设在古巴的秘密据点。同时，小男孩奇科也被关在那里。帕兹和奇科都知道合金装备ZEKE，大首领必须在他们泄露信息前救回他们。</p>
<p>大首领侵入基地成功解救二人，返回时却发现母基地被攻击了，攻击者是谜之组织XOF，被神秘的疤面男子Skull Face(骷髅脸)领导。在一片混乱中大首领找到米勒，二人乘直升机逃走，母基地则毁于一片火海。但同时乘机的帕兹体内还有一枚炸弹。在帕兹跳下飞机的一刻，炸弹爆炸，大首领陷入长达9年的昏迷。（这也是 Ground Zero 原爆点的剧情，引发后面的毒蛇，山猫另其以为自己就是 Big Boss）</p>
<p>同年，美国科学作家理查德·道金斯发表著名文章《自私的基因》，首次使用模因（meme）一词，指“在诸如语言、观念、信仰、行为方式等的传递过程中与基因（gene）在生物进化过程中所起的作用相类似的那个东西。”后爱国者的“民智选择计划”和该理念有莫大关系。</p>
<p><img src="/images/14576222758289.jpg" alt="Metal Gear SOLID V: GROUNDZEROES"></p>
<p>去救出 Paz 和 Chico 的故事就是 Metal Gear SOLID V: GROUNDZEROES 的剧情，于 2014年3月20日(PS3,PS4,XBOX360,XBOXONE)，2014年12月18日(PC) 发售。</p>
<p><strong>两伊战争爆发&amp;哈尔·艾默里克出生 1980 年</strong></p>
<p>两伊战争，又称第一次波斯湾战争爆发。同年，苏联入侵阿富汗，新冷战爆发。</p>
<p>弗兰克·耶格在罗得西亚内战中，收养了成为孤儿的内奥米（Naomi）。</p>
<p><img src="/images/14576224704845.jpg" alt="两伊战争爆发"></p>
<h3 id="1981__u5E74_-_1990__u5E74"><a href="#1981__u5E74_-_1990__u5E74" class="headerlink" title="1981 年 - 1990 年"></a>1981 年 - 1990 年</h3><p><strong>1984~198X 年《潜龙谍影V：幻痛》绝密档案</strong></p>
<p>零少校为了保护大首领的安全，把大首领转移到塞浦路斯的一家医院治疗，并把大首领身边的医疗兵整形为大首领的模样，作为大首领的替身以保护大首领，代号毒蛇（Venom Snake），最后还委托山猫秘密保护大首领。大首领先于他的替身苏醒，并保护他的替身在骷髅脸的追杀下逃离医院。表达大首领苏醒的暗号即为“V has come to”。之后，大首领去建设他的军事国家，真正的“世外天堂”。毒蛇则在米勒和山猫的支持下经营壮大名为“钻石狗”的雇佣兵军队。</p>
<p>大首领的替身完成了对骷髅脸的复仇。骷髅脸研发了能携带核武器的新型合金装备：类人猿（Sahelanthropus），意图借此进入危险的核平衡。同时他强令密语者研制了一种声带寄生虫，它们寄生入人体后，如果暴露在一种特定的声音下，就会大量繁殖，杀死宿主的肺部。这种特定声音，就是某种特定的语言，即这种寄生虫能杀死说特定语言的宿主，以达到清除这种语言的目的。骷髅脸阴谋计划利用这种寄生虫杀死所有英语使用者，消灭世界通用语，让世界归于混乱和“自由”。大首领的幻影击败了骷髅脸，粉碎了他的阴谋。在过程中，大首领的幻影也遭遇了童年的魔童计划产物：利奎德·斯内克（就是白曼巴，Eli）和原本奉命杀死“大首领”，最后为了却救了他的命的狙击手“安静”（静静，Quiet）。</p>
<p>静静是Cipher安插到毒蛇身边的卧底，在医院的刺杀行动中她全身烧伤，在寄生虫疗法的帮助下幸存。她身上携带着英语种类的寄生虫，作为后备方案，把寄生虫传播到钻石狗部队和全世界。但静静怀抱着对毒蛇的特殊感情，一直闭口不言。直到静静被苏联军队抓取，毒蛇为了救她而陷入生命危险后，静静才迫不得已开口，指引直升机方向营救毒蛇。这导致了寄生虫在静静体内的爆发繁殖，静静也在开口后选择了离开。</p>
<p>而利奎德·斯内克（就是白曼巴，Eli）也在少年心理螳螂的帮助下，带着类人猿和少年士兵最终离开了钻石狗，并继续秉持着向“父亲”：大首领复仇的欲念。</p>
<p>这部分的故事就是 Metal Gear Solid V: Phantom Pain 的剧情，于 2015 年 9 月 2 日发售（PS4, XBOX ONE, PC）</p>
<p><img src="/images/14576228532142.jpg" alt="Metal Gear Solid V: Phantom Pain"></p>
<p><strong>佣兵国家“世外天堂”建立 198X 年</strong></p>
<p>80年代后期，具体年份未明，大首领利用雇佣兵时代积攒的财富扩张他的武装力量，并在南美建立了一个独立的国家：“世外天堂（Outer Heaven）”。在这个国家内，大首领建立了一个巨大的堡垒，作为他的雇佣兵公司的基地。世外天堂是大首领个人信念的产物，它一度成为了幻想破灭的士兵们的避难所，他们在世外天堂不必被当做政府的爪牙利用，也不会被社会抛弃。为了增强世外天堂的军事力量，大首领准备了TX-55型合金装备（TX-55 Metal Gear），一台两足战车，能在世界上任何一个地方直接发射核弹。</p>
<p><img src="/images/14576229516518.jpg" alt="世外天堂"></p>
<p><strong>利比里亚内战爆发·雷电参加利比里亚内战 1989 年</strong></p>
<p>1989年，利比里亚全国爱国阵线打回国内，利比里亚战争由此爆发。</p>
<p>杰克，代号雷电（Raiden）作为少年士兵参与了这场战争。索利达斯·斯内克杀死雷电的双亲后，作为教父收养了雷电，而雷电则一直被他当做战士训练培养，在战争中杀人无数，被称为“白恶魔”和“开膛手杰克”。</p>
<h3 id="1991__u5E74_-_2000__u5E74"><a href="#1991__u5E74_-_2000__u5E74" class="headerlink" title="1991 年 - 2000 年"></a>1991 年 - 2000 年</h3><p><strong>海湾战争爆发，苏联解体·索立德·斯内克加入猎狐犬部队 1991 年</strong></p>
<p>美国为首的多国部队于1991年1月17日对伊拉克开展的战争，目的是恢复科威特的领土。索立德·斯内克和利奎德·斯内克作为特种部队的成员都参加了这场战争。</p>
<p>在这场战争中，美军向士兵注射研究大首领时得到的“战斗基因”，引发了群体性的副作用。士兵们感觉肌肉疼痛、长期疲乏、失眠、丧失记忆、头晕、情绪低落、身体消瘦以及性功能减退，这些症状被统称为“海湾战争综合症”，被媒体广泛报道，但公众并不知道真正的原因。</p>
<p>同年，索立德·斯内克加入了猎狐犬部队。戈尔巴乔夫卸任苏共中央总书记一职，苏联正式宣告解体，冷战结束。</p>
<p><img src="/images/14576232053406.jpg" alt="海湾战争"></p>
<p><strong>索立德·斯内克突袭世外天堂 1995 年</strong></p>
<p>美国得知了世外天堂的存在，也得知了军事基地里有秘密大规模杀伤性武器TX-55型合金装备。此时大首领还是猎狐犬部队的指挥官，他和世外天堂的关系还不为人知。美政府决定让大首领和他的猎狐犬部队去解决危机。大首领派出了自己的儿子，索立德·斯内克(Solid 斯内克,固体蛇，那时还不知道自己是大首领的克隆儿子)去完成这个任务，但给了他一系列错误线索，让他进入一系列陷阱，不过SS都一一克服。斯内克救出了之前执行任务失败被困的灰狐，并最终打败了大首领。之后，北约对世外天堂进行了地毯式轰炸。大首领在爆炸中幸存，召集了麾下部队的幸存者，准备卷土重来。</p>
<p><img src="/images/14576232862358.jpg" alt="Metal Gear"></p>
<p>这部分的故事就是初代作品 Metal Gear 的剧情，于 1987年(MSX2/FC) 发售。</p>
<p><strong>克隆羊多利诞生·能源科学家马弗博士被绑架杀害 1999 年</strong></p>
<p>面对燃油极速消耗的世界性难题，基奥·马弗（Kio Marv)博士提出了一个解决方案：OILIX，一种综合燃料资源，可以解决潜在的全球危机。也因为此，他被一支叫桑给巴尔岛(Zanzibar Land)的武装力量绑架。罗伊·坎贝尔, 猎狐犬部队的现任头领，再次把已经退休的索立德·斯内克送上战场,营救博士。</p>
<p>在任务过程中，斯内克发现了很多冲击性的事实:灰狐已经成为了他的敌人，大首领还活着，此外——还有另外一台合金装备。马弗博士已经被折磨致死，OILIX的方程式落入灰狐之手。索立德·斯内克打败了灰狐和大首领。离开后，索立德·斯内克隐居在阿拉斯加。爱国者收回了大首领的遗体，利用纳米机器让大首领进入昏迷，其遗体一直被零上校保存。</p>
<p>同年，公众所知的第一个生物克隆体——克隆羊多利诞生</p>
<p><img src="/images/14576233891657.jpg" alt="Metal Gear：SOLID SNAKE"></p>
<p>这部分故事就是 Metal Gear：SOLID SNAKE 的剧情，于 1990年(MSX2平台) 发售。可以看做是 Solid Snake 与 Big Boss 的决战</p>
<h3 id="2001__u5E74_-_2010__u5E74"><a href="#2001__u5E74_-_2010__u5E74" class="headerlink" title="2001 年 - 2010 年"></a>2001 年 - 2010 年</h3><p><strong>911事件爆发 2001 年</strong></p>
<p>2001年9月11日上午，两架被恐怖分子劫持的民航客机分别撞向美国纽约世界贸易中心一号楼和世界贸易中心二号楼，两座建筑在遭到攻击后相继倒塌，世界贸易中心其余5座建筑物也受震而坍塌损毁；9时许，另一架被劫持的客机撞向位于美国华盛顿的美国国防部五角大楼，五角大楼局部结构损坏并坍塌。</p>
<p><img src="/images/14576235050107.jpg" alt="911事件"></p>
<p><strong>影子摩西岛事件·猎狐犬发动叛乱 2005 年</strong></p>
<p>时间已经到了20世纪，SS已在阿拉斯加隐居很久。</p>
<p>猎狐犬部队在影子摩西岛发动了叛乱，其时猎狐犬的指挥官是大首领的另一个克隆体——利奎德·斯内克。影子摩西岛存放着核武器和合金装备霸王（METAL GEAR REX）。利奎德·斯内克，左轮山猫，和其他猎狐犬部队的队友要求政府交出大首领的遗体和10亿美金，不然就要发射核弹。利奎德·斯内克的目的在于，通过大首领的遗体治疗手下基因士兵的怪病，并在影子摩西岛重现大首领的“世外天堂”。</p>
<p><img src="/images/14576235752201.jpg" alt="Metal Gear SOLID"></p>
<p>这一部分故事就是 Metal Gear SOLID 的剧情，是 Solid Snake 身世的首次揭开，也是 Metal Gear SOLID 系列的第一部作品，于 1998年(PS)/1999年(PS平台加强版)/2000(PC平台) 发售。</p>
<p><strong>影子摩西岛事件·索立德·斯内克孤身潜入影子摩西岛</strong></p>
<p>罗伊·坎贝尔再次把再次退休的索立德·斯内克拽上战场，去解救影子摩西岛的一些重要人物，然而，任务过程中，这些人全都死于死狐（FOXDIE）病毒引发的心脏病突发，而病毒是内奥米（Naomi）博士在任务前秘密注射进斯内克体内的。斯内克得知灰狐不仅没死，还被改造成了机械忍者。灰狐斩掉了左轮山猫的一只手。斯内克也在任务中遇到了坎贝尔上校的女儿梅丽尔（Meryl），和霸王的设计者哈尔·艾默里奇（修依博士的儿子），他们帮助了斯内克完成任务。</p>
<p><strong>影子摩西岛事件·利奎德·斯内克死于死狐病毒</strong></p>
<p>击败猎狐犬部队的几位成员后，索立德·斯内克得以面对他的兄弟利奎德·斯内克和合金装备“霸王”（Metal Gear Rex）。灰狐牺牲自己，给索立德·斯内克足够的时间摧毁了霸王。最终，索立德·斯内克和利奎德·斯内克近身决战，击败利奎德后，索立德·斯内克和梅丽尔一起逃出生天。利奎德不依不挠继续追逐，但最终还是死于死狐病毒。</p>
<p>而这一切的幕后黑手是时任的美国总统，这一切都是美国政府的阴谋，让斯内克带着死狐病毒进入基地，以杀死利奎德·斯内克等人。</p>
<p>当时的美国总统就是索利达斯·斯内克，总统时用名乔治·希尔斯。同年，他卸任美国总统一职。</p>
<p><strong>“慈善组织”建立 2006 年</strong></p>
<p>影子摩西岛事件之后，索立德·斯内克和奥塔肯建立了名为“慈善组织”的反合金装备非政府组织。这一组织尝试揭露关于影子摩西岛和“霸王”的真相，并呼吁世界停止建造合金装备。</p>
<p><img src="/images/14576238123776.jpg" alt="“慈善组织”建立 "></p>
<p><strong>曼哈顿油轮沉没事件 2007 年</strong></p>
<p>曼哈顿油轮事件，简称油轮事件。美国海军开发了两栖反合金装备武器“海魔鬼”（Metal Gear Ray），用一艘伪装的油轮途径纽约港运送。索立德·斯内克潜入了这艘游轮，试图拍照向世人揭露“海魔鬼”的存在和真相，呼吁停止建造合金装备。在他潜入的同时，格鲁科维奇上校也带领一队俄国士兵，准备夺去海魔鬼。正当斯内克拍摄过照片准备离开时，左轮山猫现身，杀死了格鲁科维奇上校，奉爱国者之命开走了海魔鬼，油轮被海魔鬼撕裂沉没。爱国者将这一切罪责均栽赃在索立德·斯内克身上。</p>
<p><img src="/images/14576239967912.jpg" alt="Metal Gear SOLID 2: SONS OF LIBERTY"></p>
<p>这部分故事就是 Metal Gear SOLID 2: SONS OF LIBERTY 的剧情，也是雷电首次登场，于 2001年11月(PS2)/2011年11月(PS3，360版HD)/2012年6月(PSV版HD) 发售。</p>
<p><strong>巨壳占据事件·“自由之子”劫持美国总统 2009 年</strong></p>
<p>油轮在纽约港沉没后引发了大量环境污染，美国海军趁此机会，在这里建立了建造了建造“玄武”（Arsenal Gear）的设施——巨壳（Big Shell）。玄武是一艘可潜水的巨大堡垒，为了爱国者的信息控制目的而建。一伙自称“自由之子”的恐怖分子劫持了巨壳，并控制了正在检查巨壳的美国总统詹姆斯·约翰逊。“自由之子”由美国前总统乔治·希尔斯，即索利达斯·斯内克带领，目的是获取“玄武”，并由此获取“爱国者”成员的名单。雷电（Raiden）作为一位没有任何经验的新兵，潜入巨壳营救美国总统。</p>
<p><img src="/images/14576241344850.jpg" alt="这部分同样是 Metal Gear SOLID 2: SONS OF LIBERTY 的剧情"></p>
<p><strong>巨壳占据事件&amp;美国前总统乔治·希尔斯去世</strong></p>
<p>雷电出色地一路战胜了“自由之子”的各个成员，并发现了关于巨壳建造“玄武”的真相。“玄武”守护着爱国者精心建造的大型AI：GW。事实上，在大首领离开后，零对一切失去信任，相信下一代不会明白他的意志，便建造了AI来继续爱国者的统治。爱国者的AI共分为5大部分，中枢JD，和4个分管AI：GW、AL、TR和TJ，它们统治着世界一切经济、信息、军事的运行。左轮山猫伪装成被利奎德·斯内克的右手操纵的样子，将玄武导引向曼哈顿，引发了一场大碰撞。在那里，雷电和索利达斯·斯内克决斗，并取得了胜利。</p>
<p><strong>巨壳占据事件·民智选择计划宣告成功</strong></p>
<p>雷电潜入巨壳的一切，其实都在爱国者的控制之下。爱国者试图用GW建立一个通过情报信息控制来控制人类意志的系统，目标是实现“民智选择”（称为3S计划），为达成社会思想上的健全化而进行选择。雷电潜入巨壳其实是对“影子摩西岛事件”的重演，为了测试GW能否在极限状态下发挥作用，控制雷电的行为。而随着雷电杀死索利达斯·斯内克，民智选择计划也宣告成功。在巨壳事件之后，GW这一AI就被爱国者废弃，并在后来被左轮山猫（液体山猫）重组利用。</p>
<p><strong>美国开始积极使用PMC 2010 年</strong></p>
<p>PMC是民间军事雇用企业的简称，指经营军事业务的法人企业。以玄武撞击曼哈顿事件为契机，美国开始积极使用PMC。由此，PMC在战争中的作用逐渐重要，并引发了一种新的经济模式：战争经济。到2014年，世界已形成5大PMC公司，美国2家，英国1家，法国1家，俄罗斯1家。而这些公司，都属于山猫控制的“世外天堂”。</p>
<h3 id="2011__u5E74_u81F3_u4ECA"><a href="#2011__u5E74_u81F3_u4ECA" class="headerlink" title="2011 年至今"></a>2011 年至今</h3><p><strong>“爱国者之枪”事件&amp;索立德·斯内克刺杀左轮失败2014</strong></p>
<p>为了阻止世界在战争经济中越陷越深，罗伊·坎贝尔再次请斯内克出山，刺杀领导PMC的，貌似已经被利奎德·斯内克彻底侵占意识的左轮山猫（现在被称为利奎德·山猫）。而诞生于魔童计划的斯内克，寿命被设定的极其短暂，此时已经急速衰老，呈现老人的模样，被称为老蛇（Old Snake)。在中东，斯内克和梅丽尔的小队一起行动，找到了山猫，但山猫启动了某种设备，所有体内有纳米机器士兵都陷入癫狂，斯内克本人也无奈倒地，并没有成功地刺杀他。</p>
<p><img src="/images/14576244368025.jpg" alt="Metal Gear Solid 4: Guns of the Patriots"></p>
<p>这部分故事就是 Metal Gear Solid 4: Guns of the Patriots 的剧情，也是 Solid Snake 的最后一个任务，于 2008年6月(PS3) 发售</p>
<p><strong>“爱国者之枪”事件·爱国者AI系统覆灭</strong></p>
<p>之后斯内克来到欧洲，找到了引他来此的伊娃，以及大首领的遗体。然而左轮的军队也追上了伊娃和斯内克，在和左轮部队的追逐战斗中伊娃死去，斯内克重伤，大首领的遗体则焚毁。左轮利用大首领的基因骗过了爱国者的AI网络，夺去了控制全世界武器枪械的“爱国者之子”系统。逃往影子摩西岛偷取了合金装备霸王的核弹头，去毁灭爱国者的中枢AI：JD。在最后的努力中，斯内克和他的战友们进入了左轮的海上基地：“玄武”级战舰，那里承载着被左轮重新利用的GW系统，左轮的阴谋是毁灭JD后，用GW取代JD，从而控制全世界。斯内克破坏了左轮的行动，向GW上传了活狐病毒。“活狐”以GW为跳板，摧毁了所有爱国者AI，世界被从爱国者的统治下解放出来。</p>
<p><strong>大首领死于死狐病毒</strong></p>
<p>SS在任务中遇到了很多熟人，包括给自己植入病毒的Namoi，Roy的女儿Meryl，爱国者的真相，还有在危机时刻舍生救自己的雷电(已被改造为半机械忍者形态)。</p>
<p>在这里简单说一下雷电吧，雷电在结束2代的剧情之后选择和女友Rose一起生活，但是由于雷电作为一个士兵，他无法适应这样和平又幸福的生活，而且他又害怕伤害到Rose，郁闷的雷电只好每日酗酒，再加上Rose说我们的儿子流产了，Rose改嫁Roy离开了雷电，雷电承受不了打击于是重返战场。实际上他们的儿并没有流产，因为雷电引起了爱国者的注意，在他身边不会安全。果然之后爱国者将回到战场的雷电抓了起来同时将它改造成了机械忍者。不甘被爱国者控制的雷电找到机会逃离了爱国者的控制，在路上遇到了Big mama(其实就是MGS3的Eva)，加入了他们的反爱国者组织。</p>
<p>一切结束后，斯内克去拜访引领者的坟墓。当爱国者AI离线后，大首领就从长年的昏迷中醒来。事实上，在欧洲被焚毁的尸体属于索利达斯·斯内克，而左轮被山猫的手侵占意志只是一出戏，目的是不让爱国者发现他真正的目的：唤醒大首领，找出零的位置。在引领者的墓前，大首领切断了垂垂老矣失去意识的零的生命维持设备，一场百年战争就此终结。随后，他和他的儿子——索立德·斯内克度过了一段难得的平静时光。因为和斯内克的接触，大首领感染了死狐病毒，并最终因此结束了生命。</p>
<p><strong>近未来·《合金装备崛起：复仇》时代</strong></p>
<p>其实《崛起》的时间轴是算在正专里面的，但是这是一部彻彻底底的以雷电为主角的动作游戏，所以还是单独挑出来说一下比较好。本作由小岛工作室和合金工作室合作开发，实际上一开始只有小岛工作室在开发，打算这次做一个还是以潜行为核心，但是会更注重战斗场面的游戏;但是之后白金工作室加入把本作核心放在了动作上，虽然变成一个彻头彻尾的动作游戏，但是游戏没有给MGS系列丢人。</p>
<p>主角雷电依然保持着MGS4中的机械忍者形象，而且这一次，玩家要操控他拿起手上的刀，将世界从战争危急中解救出来。游戏中会出现Sunny等一些老人物，同时也会对雷电这个人物做更多的。喜欢帅哥雷电同时又热爱高速爽快战斗的话，本作一定不能错过。
　　</p>
<h2 id="u4F5C_u54C1_u5217_u8868"><a href="#u4F5C_u54C1_u5217_u8868" class="headerlink" title="作品列表"></a>作品列表</h2><p>这里按照剧情时间顺序来介绍，而非作品的序号</p>
<p>《合金装备索利德3：食蛇者》→《合金装备索利德：掌上行动》→《合金装备索利德：和平行者》→《合金装备索利德5：原爆点》→《合金装备索利德5：幻痛》→《合金装备》→《合金装备2 ：索利德斯内克》→《合金装备索利德》→《合金装备索利德2：自由之子》→《合金装备索利德4：爱国者之枪》→《合金装备崛起：复仇》</p>
<ul>
<li>SS: Solid Snake</li>
<li>BB: Big Boss</li>
<li>MG: Metal Gear</li>
<li>MGS: Metal Gear Solid</li>
</ul>
<p><img src="/images/14576193203131.jpg" alt="系列作品年表"></p>
<p><img src="/images/14576193670265.jpg" alt="作品中的 Snake"></p>
<h3 id="MGS_3_3A_Snake_Eater"><a href="#MGS_3_3A_Snake_Eater" class="headerlink" title="MGS 3: Snake Eater"></a>MGS 3: Snake Eater</h3><p>发售日：2004年11月(PS2)/2011年11月(PS3，360版HD)/2012年6月(PSV版HD)</p>
<p>《合金装备》系列剧情的原点——故事的时间在1964年，主人公是一名美国特殊部队Fox Unit的成员，行动代号Naked Snake(裸蛇)。游戏的开场，Snake接到了一个任务——去营救被困在苏联的科学家，这名科学家的发明有着可以引发第三次世界大战的力量。在任务途中，Snake突然被自己的恩师The Boss背叛，Snake被打下山崖，任务自然以失败告终。九死一生的Snake在不久之后接到了新的任务，目的是再次拯救那位科学家，同时干掉背叛国家的The Boss。</p>
<p>最终，Snake与自己的恩师The Boss展开了决战并亲手杀掉了她。在最后我们才知道，The Boss是美国派去苏联的卧底，她的目的是拿到苏联的那份“哲学家的遗产”，但是当时的苏联将军 Volgin(沃尔金)将The Boss带来的核弹头直接在苏联境内发射了(核弹头是美方为了表示诚意以便The Boss成功潜入内部而准备的礼物。)，苏联上层不知情认为是美方所做，美国没有办法只好把锅都甩给TheBoss，决定要将她当作叛徒处理。所以就让Snake去解决掉她。所以The Boss至死都没有背叛过自己的祖国。The Boss在弥留之际说自己希望世界是一个整体而不是东方和西方。之后Snake因为干掉了TheBoss，为国家做出了贡献，被授予Big Boss的称号。</p>
<p>游戏的最后一幕就是成为了Big Boss的Snake在The Boss的无名之墓上敬礼并且留下了眼泪。这一幕在MGS系列乃至整个游戏界中都相当著名。</p>
<p>本作有令人耳目一新的“生存系统”，同时也是游戏的核心系统。玩家可以看到角色的身体状况，吃刚捕获的动物作为充饥的粮食(食物会随着PS2的系统时间的推移而腐化)，玩家需要凭借着自己的实力在森林之中找到食物，而且在中弹之后还需要手动进行包扎止血。游戏还真实的表现出CQC(近身搏斗)技巧，就像是真的潜入作战一样。</p>
<p>而且游戏不仅将“野外生存”这一主题有力地体现出来，游戏中的各种设定也十分有趣。直到现在，可以调整时间来让The End老死的设定依然让玩家津津乐道。</p>
<h3 id="MGS_3A_Portable_Ops_Plus"><a href="#MGS_3A_Portable_Ops_Plus" class="headerlink" title="MGS: Portable Ops Plus"></a>MGS: Portable Ops Plus</h3><p>发售时间：2006年12月(PSP)/2007年9月(加强版)</p>
<p>距离3代的故事已经过去了6年。有着Big Boss称号的Snake早已从FOX小队中退役，开始过着训练新兵的生活。可是突然一天Snake等全部和FOX小队有关系的人员都被逮捕。原来FOX小队的指挥官Gene叛变了，Gene意图建立Army’s Heaven——这个只属于军人的国家，以打破世界的军事平衡。Big Boss在追击Gene的途中将很多人纳为了自己的同伴，比如NULL，Elisa和Johnthan等，同时这些人成立了猎狐犬小队，开始对FOX部队进行反击。最终BB干掉了Metal Gear之后打倒了Gene。Gene在死前将手头上的所有资金设备全部交给了BB，并且声称BB以后一定会用到这笔资源。</p>
<p>作为PSP上第一款MGS作品，掌上行动已经很努力的将《合金装备》的精髓玩法带给了大家，而且大胆尝试了很多新的要素比如联机模式，招募伙伴。但是由于是第一次登陆掌机，各方面还不成熟，所以本作的实际游玩体验会打一些折扣，但是并不怎么影响掌上行动的素质，Fami也给出了39分的高分。虽然小岛没有把本作放在正传列表中，但是BB在故事中遇到的人和事其实都对之后的事件埋下了一些伏笔，所以说这款黑历史之中的《掌上行动》还是值得一玩的。</p>
<h3 id="MGS_3A_Peace_Walker"><a href="#MGS_3A_Peace_Walker" class="headerlink" title="MGS: Peace Walker"></a>MGS: Peace Walker</h3><p>发售时间：2010年4月(PSP)/2011年11月(PS3,360版HD)</p>
<p>不逊色于主机作品的掌机续作——这次故事发生在1974年，这时冷战时期也进入到了末期，形势看似和平，但是在哥斯达黎加，却遭受到了不明军队的袭击，可这里有着和平宪法的保护无法出动任何部队反击。这时在哥斯达黎加和平大学的女学生Paz和她的教授Galevz选择了请求“无国界军队”帮助，而这个部队正是由Big Boss所指挥。而且教授还给Big Boss了一份酷似The Boss声音的录音带，这让Big Boss没有理由拒绝这份委托。然而随着故事的进行，阴谋逐渐浮出水面，代号为Peace Walker的二足步行兵器(MG)已经开发完成并且加上了The Boss的AI，而Paz竟然是“CIPHER”的间谍，而且要毁灭BB全部的军队，最后经过一番苦战终于打败了Paz，Paz也坠入了大海。</p>
<p>FAMI通的满分作品，也是PSP平台非常少见的满分。在吸取了前作《掌上行动》的缺点之后，这次《和平行者》在画面，剧情和游戏性上堪称集大成之作。游戏保留了之前的漫画过场，联机与招募同伴的要素，而且在剧情上为了承上启下大下功夫，可以算是MGS的转折点。同时场景也丰富了很多，再加上成熟的动作与有趣的联动要素（比如和猎人的联动会让蛇叔和轰龙对决）使得本作算是PSP 平台不可多得的佳作。</p>
<h3 id="MGS_5_3A_Ground_Zeros"><a href="#MGS_5_3A_Ground_Zeros" class="headerlink" title="MGS 5: Ground Zeros"></a>MGS 5: Ground Zeros</h3><p>发售日：2014年3月20日(PS3,PS4,XBOX360,XBOXONE)，2014年12月18日(PC)</p>
<p>次世代的第一款MGS——故事发生在上一作《和平行者》事件结束的一段时间之后，依旧在无国界军队执行任务的Big Boss突然收到了消息称Paz没有死，而且偷偷去营救她的Chico也被一个组织抓住了，于是BB必须前去营救他们。但是同时，Huey单方面的同意了一个世界核组织对基地的检查，这就直接引出了开篇的一幕，一个称作Skull Face(骷髅脸)的角色率领了一个叫做XOF(FOX小队的对立面)小队，抓走Paz和Chico，随后他们撕下自己的XOF徽章伪装成世界核组织前去“检查”BB的基地。之后虽然BB成功的解救出了Paz和Chico但是却发现自己的基地已经被毁灭了，Paz也称自己体内还有炸弹于是自己跳下飞机爆炸，BB受重伤昏迷，无国界军队被XOF小队几乎全灭。等到BB苏醒之后，他要去复仇，找到毁灭自己基地的人究竟是谁，Huey等人为什么要背叛自己，只有接下来的《幻痛》能告诉我们真相了。</p>
<p>作为次世代的第一款MGS，《原爆点》只能算是一个《合金装备索利德5》的序章，但是本作的画面等细节方面非常出众，而且也包含了很多额外任务与彩蛋，为了迎接之后的《幻痛》，《原爆点》没有理由不去将它通关一次。</p>
<h3 id="MGS_5_3A_Phantom_Pain"><a href="#MGS_5_3A_Phantom_Pain" class="headerlink" title="MGS 5: Phantom Pain"></a>MGS 5: Phantom Pain</h3><p>故事发生在1984年，此时的游戏中和现实一样也在进行着阿富汗战争。尽管游戏大体和现实相同，但是玩家可以发现游戏内的武器和科技要远远比现实中的冷战时期先进。不光是“合金装备”本身，其他军事技术诸如外骨骼、双足机甲、光学隐形、全息影像都被各国谍报机关所使用着。其他科学技术诸如纳米技术、克隆、人工智能也进入了实用化的阶段。玩家还可以在游戏中发现一些陌生却又熟悉的枪械，例如类似AK74突击步枪的SVG-76突击步枪。而性能相对于现实有些夸张、但却让老玩家怀念的“富尔顿地对空回收系统”也重回作品并在游戏内扮演着举足轻重的角色。</p>
<p>同时，游戏还包含制作人小岛秀夫惯有的幽默气息。比如主角Big Boss可以使用的装备中有被称为“终极隐蔽科技”的道具纸箱子。玩家可以藏在纸箱子里进行移动，并突然钻出纸箱子用消音麻醉手枪击倒敌人。</p>
<p>在一手建立的佣兵组织“无界之师”（Militaires Sans Frontières）于《原爆点》结尾被摧毁后，主角大首领（Big Boss）也陷入了长达九年的昏迷。醒来后，世界发生了翻天覆地的变化，而他重新建立了佣兵组织“钻石狗”（Diamond Dogs）。在名为“毒蛇”（Venom Snake）的代号下，他重新卷入了位于阿富汗的苏联入侵行动中，目的是寻找要为袭击“无界之师”事件而负责的罪人。为了达成复仇，他重新召集了他的劲敌“山猫”（Ocelot）并与一批忠诚的战士们相遇，谱写新的历程。他与米勒（Kazuhira Miller）在复仇的过程中发现了名为“密码”（Cipher）的组织正在开发一款甚至可以超越合金装备的武器，而Big Boss的任务也迅速转变为消灭新的威胁。</p>
<p>毒蛇是本作的主角，玩家主要扮演他来进行任务。通常被称为“大首领”（Big Boss），而“毒蛇”（Venom Snake）是他行动的代号，被视为传奇。他本是“无国界之军”的一名医疗兵，在母基地遭受袭击，PAZ体内的第二颗炸弹爆炸（详情请看后面的PAZ介绍），他挡在了Big Boss前面（这就是为什么Venom Snake身体内有那么多人体碎片而BIGBOSS没有），之后陷入了长达九年的昏迷。苏醒后代替下落不明的大首领（naked snake）组建“钻石狗”，并成为领袖。率部深入阿富汗和非洲，在阿富汗战争中寻找摧毁了“无界之师”要塞的罪人并予以复仇。</p>
<h3 id="Metal_Gear"><a href="#Metal_Gear" class="headerlink" title="Metal Gear"></a>Metal Gear</h3><p>发售日：1987年(MSX2/FC)</p>
<p>包受争议的初代作品——剧情是在1995年左右，Big Boss已经建立了猎狐犬组织，这时突然得知在南非，出现了一个叫做“Outer Heaven”(世外天堂)的要塞国家，并且有消息传出这个国家在生产大杀器——Metal Gear 。于是Big Boss派出手下的一名新兵前去侦查这个国家并且营救之前去侦查结果失去联系的Grey Fox，这个人就是我们之后系列的主角Solid Snake。但是当SS不断深入之后发现Big Boss给自己的通信越来越奇怪，时常将自己引到陷阱之中。原来这个世外天堂的建立者就是自己的上司Big Boss。最终SS摧毁了整个基地，粉碎了Big Boss的野心。</p>
<p><img src="/images/14576254881646.jpg" alt="Metal Gear"></p>
<p>作为全系列的第一部作品，游戏本身的素质堪称上乘，潜入式的玩法在当时给人耳目一新的感觉，但由于MSX2平台只在日本地区发售的原因，本作并未在全球范围内引起热潮放在那个时代本身素质还算过得去，丰富的道具和有趣的游戏模式也算能让人玩的下去，但是这作而由于当时KONAMI错误的市场估计，所以之后在美国并未发行MSX2的初代合金装备(很大一部分原因是因为MSX2主机根本没有在日本以外的地区发售。)，更加糟糕的是，KONAMI在没有令小岛秀夫参与制作的情况下，单方面让美国分部在NES上发行所谓的FC版，而美国的小组则自作主张将游戏内容进行改编，反而使得游戏丧失了原版的精髓，最终BOSS也由Metal Gear变为了庸俗的所谓“控制MG的电脑”。小岛秀夫已经认定FC版的合金装备并非正统，甚至认为就是一款彻头彻尾的垃圾作品。所以本作的争议很大，这也直接导致小岛要出一个为自己正名的续作。</p>
<h3 id="Metal_Gear_2_3A_Solid_Snake"><a href="#Metal_Gear_2_3A_Solid_Snake" class="headerlink" title="Metal Gear 2: Solid Snake"></a>Metal Gear 2: Solid Snake</h3><p>发售日：1990年(MSX2平台)</p>
<p>Solid Snake与Big Boss的决战——故事发生在上作的4年后，Zanzibarland(桑给巴尔岛)上的一个军事政府突然突击了各国的核武器安放库，由于核平等条约的束缚，这个国家反倒成为了唯一可以使用核武器的国家，对世界造成了巨大威胁。这时解决了Outer Heaven危机的SS临危受命，前往这个小岛解救被绑架的Marv博士，这位博士发现了一个可以精炼石油的微生物，所以他对这个小岛统治全球的计划是关键性的人物，SS需要把世界从危急之中解救出来。</p>
<p><img src="/images/14576255533327.jpg" alt="Metal Gear 2：SOLID SNAKE"></p>
<p>在任务的最后，我们会遇到我们的熟人Big Boss，最终决战自然是以Big Boss战败收尾，而Big Boss也结束了他传奇的一生。SS也到阿拉斯加隐居起来，不再参与战事。值得一提的本作实际是只有日版，美版自己做了一款叫做《斯内克的复仇》的游戏，模式是类似于魂斗罗的横版射击，小岛自然无法认同这部被“糟蹋”的作品，再加上本作由于MSX2只有日版，所以《斯内克的复仇》压根没有在日本发售。</p>
<p><img src="/images/14576256407693.jpg" alt="Metal Gear 2：SOLID SNAKE"></p>
<h3 id="MGS"><a href="#MGS" class="headerlink" title="MGS"></a>MGS</h3><p>发售日：1998年(PS)/1999年(PS平台加强版)/2000(PC平台)</p>
<p>Solid Snake身世的首次揭开——时间已经到了20世纪，SS已在阿拉斯加隐居很久，但是突然有个部队占领了一个阿拉斯加的军事基地，并且抢到了正在做演习的Metal Gear Rex，而这个部队正是SS之前所在的猎狐犬小队，这次叛变也就被成为“影子摩西岛事件”。猎狐犬小队仗着自己拥有可以发射核武器的Metal Gear，向美国索要大量金钱，更重要的是他们还要Big Boss的遗体。当时在掌上行动中出现的ROY上校亲自请求SS出马，拯救被猎狐犬绑架的人质，解决这次危机。但是在SS在执行任务的途中，他发现自己要拯救的人质在看到他之后都会莫名其妙的突发心脏病死亡，而且还遇到了不少关系到SS命运的家伙，比如Ocelot(山猫，在与SS决斗的时候被NULL砍掉了一个手臂)，Meryl(ROY上校的侄女，不过实际上是女儿)，NULL(掌上行动时的忍者，也就是灰狐gray fox)，Otacon(MG Rex的设计师)。</p>
<p>最终我们遇到了实施整个事件的头目，他就是Liquid Snake。这个和SS拥有一样长相的人告诉了SS他们的身世：其实他们都是一个叫做魔童计划(Les Enfants Terribles/恐るべき子供达计划) 的产物，这个计划就是利用Big Boss的基因，制造出很多像BB一样伟大的战士，两个人都是克隆体，其实是兄弟。</p>
<p>但是Liquid说自己是继承了的是劣质基因，SS继承了优质基因，由于痛恨自己的基因不足必须干掉SS，而且还要超过Big Boss——重建世外天堂。不过最终Liquid还是败在了SS的手下，但是在最后时刻SS在一场汽车追逐战中翻了车，动弹不得，Liquid拿着枪走了过来却在准备开枪之时突然心脏病突发死亡。SS总归还是完美完成了任务。</p>
<p>实际上，Liquid率领的猎狐犬小队叛乱并不是他一个人的计划，而是在山猫和美国总统Solidus Snake的怂恿下进行的。而Solidus Snake则是BB的完美克隆体。而任务中的那些突发心脏病死亡的人其实是受到SS身上一种叫做死狐病毒(fox die)的影响，这种病毒可以直接引起一些特定基因的人死亡。这个病毒是一个叫Naomi的医学家在SS不知情的情况下为它注射的，Naomi是Gray Fox的妹妹，他知道以为自己的哥哥是被SS所杀所以想利用这个病毒杀掉SS复仇，但是由于期间和SS接触久了之后发现其实自己的哥哥并不恨SS，自己也知道SS当时也不迫不得已，但是由于已经注射了病毒，只好将死狐病毒的发作时间改成了随机发作(实际上一直到4代中才有些发作的体现。)</p>
<p>最后讽刺的是Liquid Snake实际上是优质基因的继承者，他的实力完全是在SS之上，但是最后的失败也正式MGS1想告诉玩家的主题——永远不要被命运或者基因所束缚。</p>
<p>《MGS1》开创3D潜入的先河，同时也率先引领了电影化叙事的潮流，而且剧情全部都是即时演算，这在当时大量依靠文字或者图片叙事的游戏之中，MGS这种表现手法实在让人眼前一亮。而且距离上一作距离8年之久，这样一个回归是非常令人震撼的，成功的为MGS在这个时代的平台树立起自己的招牌。</p>
<h3 id="MGS_2_3A_Sons_Of_Liberty"><a href="#MGS_2_3A_Sons_Of_Liberty" class="headerlink" title="MGS 2: Sons Of Liberty"></a>MGS 2: Sons Of Liberty</h3><p>发售日：2001年11月(PS2)/2011年11月(PS3，360版HD)/2012年6月(PSV版HD)</p>
<p>新主角雷电的初次登场——MGS2的故事大致可以分成前轮篇和Big Shell篇。</p>
<p><strong>油轮篇</strong></p>
<p>发生在MGS1结束后的2年，山猫夺取了MG的数据并且在黑市上兜售，这导致很多国家都可以制造出MG这种危险兵器。SS便和Otacon一起成立了一个反MG的组织——Philanthropy(慈善事业)，两人开始四处摧毁被制造出来的MG。突然他们得到消息，称纽约附近的油轮上有新型的两栖用MG，于是SS立即前去准备破坏它。但是在到达油轮底层之后发现了其实这一切都是山猫在捣鬼，他假装和其他国家的军官合作但最终的目的是为了夺取新型MG。当SS和山猫对峙的时候山猫右臂抽搐然后仿佛换了个人似的说：“好久不见了，兄弟。”原来当初山猫被砍掉右臂之后又移植了Liquid Snake的胳膊，所以Liquid Snake有时就会控制山猫的心智。之后山猫恢复了意识，驾驶MG破坏了游轮后逃走，并且在网上大肆散布SS在游轮上的照片，让大众将SS视作了恐怖分子，同时油轮篇的故事到这里为止了。<br>　　<br><strong>Big Shell篇</strong></p>
<p>雷电在执行这次任务之前也仅仅是一个新兵菜鸟。而这一次他的任务就是去海洋设施拯救人质(《MGS》非常喜欢用解救人质开头)。还记得之前油轮篇的油轮吗?山猫在将它破坏之后石油散落在大海之中，于是建立了一个海洋净化设施Big Shell，而这里明显不单单是一个环保设施。果然，雷电在执行任务的途中遇到了SS和Otacon等人，同时也知道了这个设施其实下面隐藏着一台由爱国者控制的超级数字战舰，而这一切都是由前任美国总统Solidus Snake，现在的恐怖组织头目所策划的，他自称Sons of Liberty(自由之子)，还绑架了即将当选的下任总统，而且Solidus Snake也是雷电的养父，是他将小时候的雷电从战场中捡了回来。<br>　　<br>当剧情进行到全部人员都汇集到超级战舰之上的时候，山猫终于说出了自己的目的：原来这一切都是爱国者计划好的，故事中的一切的事件都与影子摩西事件一模一样，都是为了重现当年的事件（详细可以查看S3计划）。随后山猫进入了Metal Gear Ray的驾驶舱，跳进了大海，SS也随即跳入海中，战舰上只留雷电和Solidus Snake两人。最终战舰撞向了美国纽约，最后在国家纪念堂前才停了下来。</p>
<p>这时Solidus Snake 也说明了自己做这一切的目的：他做的这一切都是为了摆脱爱国者的控制，现在爱国者过于强大了，我们全部的行为都会受到爱国者的保护，但是这样一来我们自己能为后代留下什么遗产?!一般人类还可以通过基因流传，而他和SS等克隆人没有生育的能力，他们最终只会被历史遗忘，他要做的就是永远的被历史所铭记，要战胜爱国者，解放人类，成为“自由之子”。之后雷电接到通信，通信中说明了爱国者现在的状态：爱国者现在其实是一个为了生命数字化而制造的超级电脑，如今人类身上都植入了纳米机器人用来治病或者强化身体，而爱国者正是通过这个机器人收集人类的信息，于是为了人类的未来，他会主动过滤掉一些无用的信息，从而慢慢控制人类的思想，感情。而这整个的事件，不过就是爱国者的试验罢了。<br>　　<br>最终，雷电和Solidus Snake的决战在所难免，雷电靠自己高超的剑术击败了Solidus Snake，Solidus Snake掉下房顶死亡。最终雷电打算加入SS寻找爱国者的所在，但是SS却说还有更重要的事在等着你，原来自己的女友Rose早已在后面等他。</p>
<p>跨入PS2时代的《MGS2》带不仅仅在画面上有了突破，更是正式加入了第一人称的射击视角(其实在MGS1代完全版中，只要你通关一遍即可开启第一人称视角。)，而且本作还有很多有趣的故事，比如用雷电裸奔的剧情，现在也时常会被玩家拿出来开玩笑。<br>　　<br>值得一提的是小岛在游戏发售之前没有任何一次提到过会换主角，宣传视频也一直就是蛇叔，但是当玩家拿到手上玩到雷电的时候，小岛承认是自己骗了大家，希望大家能自己感受到换主角那种惊喜。这款游戏还有一个小插曲，2001年在游戏宣传的时候提到过最后战舰冲向纽约破坏了一群建筑的剧情，其中就是纽约世贸大楼，但是就在之后9.11发生了，为了避免这一个敏感问题小岛只好直接剪掉了那一段动画，剧情也就变成了战舰冲向纽约之后直接切入最终战的样子。</p>
<h3 id="MGS_4_3A_Guns_of_the_Patriots"><a href="#MGS_4_3A_Guns_of_the_Patriots" class="headerlink" title="MGS 4: Guns of the Patriots"></a>MGS 4: Guns of the Patriots</h3><p>发售日：2008年6月(PS3)</p>
<p>老蛇的最后一个任务——故事发生在2014年，在这期间，上次驾驶MG逃走的山猫成立了全球级别的专业的佣兵部队PMC，同时将称为“SOP”(爱国者之子)系统的纳米机器人全部植入PMC之中，包括人和武器，而这个系统目的就是控制士兵情绪，达成降低战争成本的目的。而且山猫这时已经被称为Liquid Ocelot，拥有大量MG，这一切都需要让这位已经略显老态的传奇战士再次出马了。</p>
<p><img src="/images/14576260972014.jpg" alt="Metal Gear Solid 4: Guns of the Patriots"></p>
<p>SS在任务中遇到了很多熟人，包括给自己植入病毒的Namoi，Roy的女儿Meryl，爱国者的真相，还有在危机时刻舍生救自己的雷电。当然，最后我们面对的还是我们的老朋友——山猫。从山猫口中，我们得知其实Liquid并没有控制自己，或者说之前的双重人格都是山猫为了破坏爱国者而演出来的。因为爱国者早已控制了几乎整个世界，所以想骗过爱国者给它植入病毒那就必须先骗过自己，于是通过药物和心理暗示让自己成为Liquid。最终目的达到了，他成功的给爱国者的AI植入了FOXLIVE病毒使爱国者全部崩溃，解放了整个世界。但是最终，我们和山猫那持续了几十年的恩怨，也要在今天划上一个句号。</p>
<p>打败了山猫之后，SS来到了The Boss的墓地，拿出手枪准备了结自己，但在这个时候，我们看到了通过手术复活的Big Boss和已经成为植物人的Zero(爱国者的建立者，BB之前的同伴)，BB对SS说：“我们之前为了The Boss的理想做了那么多事，如今我们时代已经过去了，你一定要活下去。我从来没有把你当作儿子来看待，我一直看作你是一个伟大的战士，我认为即使当时是你面对着The Boss ，你也能扣下扳机。”，之后他拔掉了Zero的氧气管，走进SS自己主动感染他的死狐病毒。SS在帮BB点完一根雪茄之后，选择了坚强活下去，最终和Otacon一起出门旅游，蛇叔的传奇一生也到此为止了。</p>
<p>本作在科学的支持下蛇叔可以使用光学迷彩从而做到像变色龙一样的隐藏在周围的环境之中，带给玩家全新的体验。不过这次最强大的地方就是小岛把这部老蛇的最终作狠狠的玩了一把情怀，特别是当剧情进行到重回影子摩西岛，看到MGS1的故事地点在PS3上再现的时候，系类玩家都会为之感动。而且在最终和山猫决战时，好几个阶段的UI也是从1到4逐渐的变化，不得不说小岛这次真的是把情怀牌打到了极致。</p>
<h2 id="u4EBA_u7269_u4ECB_u7ECD"><a href="#u4EBA_u7269_u4ECB_u7ECD" class="headerlink" title="人物介绍"></a>人物介绍</h2><h3 id="u5F15_u9886_u8005_The_Boss"><a href="#u5F15_u9886_u8005_The_Boss" class="headerlink" title="引领者 The Boss"></a>引领者 The Boss</h3><p>事迹：二战时率领眼镜蛇部队加速结束战争/贞洁行动中做卧底假装背叛/食蛇者行动中死于BB手下</p>
<p>The Boss的一生是一段传奇，她最早是作为二战的眼镜蛇特种部队的队长为美国执行任务，但是在二战结束之后，她发现了这个世界的变化并不是她想象中的那样。虽然表面上战争结束了，但是 “哲学家”却开始了更加残酷的战斗，不仅仅世界四分五裂，连自己之前的部下也都各奔东西，甚至成为了敌人。而为国家一直战斗的The Boss最终被美国所抛弃，原本的间谍被当作叛徒，而亲手杀掉这个“叛徒”的人就是Snake，也就是之后的Big Boss。但是实际上，The Boss至死至终即使牺牲了自己的丈夫，离开了自己的儿子，都不曾背叛自己的国家，是一名伟大的爱国者。</p>
<p>但是在Snake看来，The Boss是自己的老师，她养育了Snake，教给了他知识与战斗的方式，但是他对The Boss更多的是爱，甚至超越了老师或者母亲。(EVA在MGS3领走的时候也说过：自己无法取代The Boss在Snake心中的地位。)所以在Snake击败The Boss之后，他获得了Big Boss的称号，同时也为了实现The Boss的理想走上了另一条道路。</p>
<blockquote>
<p>One must die and one must live. No victory, no defeat. The survivor will carry on the fight. It is our destiny… The one who survives will inherit the title of Boss. And the one who inherits the title of Boss will face an existence of endless battle.” ―The Boss to Naked Snake</p>
</blockquote>
<p>这是The Boss在最终决战的时候对Snake说的：“我们之间必须要死一个，不是为了胜利，也不会有失败，只是单纯的宿命罢了。胜者将会继承boss的名号而且之后也会带着它去面对无尽的战斗。”不得不说The Boss虽然本人只出现在了MGS3代，但是她给BB带来的影响才导致BB之后做的一连串事件，所以The Boss其实从开始一直贯穿到了全部故事的最后。</p>
<p>顺便一提在《和平行者》中，Peace Walker采用的AI就是The Boss，可以说是The Boss在一定意义上的复活，同时Peace Walker最后的自杀也表明着The Boss即使只留下一个思想，也不会背叛自己的祖国。</p>
<h3 id="Big_Boss"><a href="#Big_Boss" class="headerlink" title="Big Boss"></a>Big Boss</h3><p>事迹：食蛇者行动杀掉The Boss，成为Big Boss/成立爱国者组织/创立猎狐犬小队/创立无国界军队/创立世外天国</p>
<p>Big Boss的故事在之前的作品介绍中我们应该都能了解很多了。他是一个连国家都会害怕其力量的战士，Big Boss的一生到底去过哪些地方参加过多少战争已经很难统计了，但是可以确定的是，对于Big Boss，几乎没有不可能完成的任务。BB在3代食蛇者任务完成之后加入了爱国者组织。但是BB的思想其实一直离不开战斗，或者说BB就是一个天生的战士，最终他还是离开了组织，选择自己作为一个战士打开新的道路。</p>
<blockquote>
<p>We have no nation, no philosophy, no ideology. We go where we’re needed, fighting not for country, not for government, but for ourselves. We need no reason to fight. We fight because we are needed. We will be the deterrent for those with no other recourse. We are soldiers without borders, our purpose defined by the era we live in.</p>
</blockquote>
<p>BB的这句话诠释了自己——</p>
<p>“我们不属于任何国家，我们也不会为了任何国家或者政府而战斗。战斗的理由只因为我们自己需要而已。我们是不受国界约束的战士，我们生存的地方要由自己决定。”</p>
<p>当然这种思想也直接导致他后来建立世外天国打算用武力来实现The Boss世界统一的理想。而Big Boss也败在了自己的“儿子”——SS手上。在4代的结尾，年近80的BB已经彻底看开了这一切选择了离开这个世界。</p>
<blockquote>
<p>This is good… Isn’t it?</p>
</blockquote>
<p>这是他的最后一句台词。战斗了一生的Big Boss，这样安静的离开才是最好的结局吧。</p>
<h3 id="Solid_Snake"><a href="#Solid_Snake" class="headerlink" title="Solid Snake"></a>Solid Snake</h3><p>事迹：打败Big Boss，成功化解世外天国危机与桑给巴尔岛危机/化解影子摩西岛事件，打败Liquid/成立反MG组织/协助了MGS2中雷电的行动/打败山猫，破坏爱国者电脑</p>
<p>SS的故事同样是一段传奇，他曾数次将世界从危机之中拯救出来。他打败了自己的“好朋友”，“兄弟”甚至是“父亲”。和Big Boss不一样，SS并不喜欢战斗，相反，他在完成任务之后会选择隐居。但是作为一个战士，他也是无可挑剔的;不过作为一个人，他有一些可悲，SS本身就是为了当作一个战士而克隆出来的，而且当初克隆时为了防止BIG BOSS的基因外流(比如Solid Snake被敌人捕获，克隆出新的BIG BOSS样的战士)而特意设计出会让SS快速老化，所以在经历一定年限之后就会开始迅速老化，是不可遏制的，这些应该已经写进Snake的DNA，无法改变。</p>
<p>而且SS的体内还被注射了死狐病毒这一颗炸弹，他快速老化的身体环境还改变了旧的FOXDIE病毒，有可能传染给非特定基因人群，将成为生物武器。所以他身边人其实是被自己的病毒感染致死。不过在MGS4的最后，SS在和BB对话完了之后放弃了自杀选择在剩下的时间之内周游世界。这样的故事对于SS的一生，也算了令人满意的结局了。</p>
<h3 id="Liquid_Snake"><a href="#Liquid_Snake" class="headerlink" title="Liquid Snake"></a>Liquid Snake</h3><p>事迹：BB的克隆体，SS的兄弟，优质基因继承者/率领猎狐犬小队叛变，实施影子摩西岛事件/借山猫“复活”</p>
<p>Liquid是一个天才，因为他继承了BB的优质基因，所以无论是战斗力还是策略能力都在他的“孪蛇”兄弟SS之上。同时，他实施的影子摩西岛事件也成为了MGS走向的一个巨大转折点。但是这样一个天才，却因为对自己能力的不自信而认为SS才是优质基因继承者，于是他开始嫉妒又憎恨自己的兄弟。在MGS1故事的最后几场战斗，Liquid意外的都输给了SS，虽然在最后关头SS翻车被Liquid找到机会，但是他自己却被死狐病毒感染致死，也就是最终他也不知道其实自己并不是天生比SS弱，自己会输真的是因为基因无法决定命运。Liquid虽然就这么退场了，但是他告诉了SS的身世，幕后的几个黑手也都浮出水面。在《合金装备索利德5：幻痛》的预告片中，我们能看到一个叫做Eli的小男孩，从各方面看来他和Liquid真的是非常相似。同时还有一对双胞胎似的少年，下面写了魔童计划，相信《幻痛》会对这对孪蛇的这段时期有一个交代吧。</p>
<h3 id="Ocelot"><a href="#Ocelot" class="headerlink" title="Ocelot"></a>Ocelot</h3><p>事迹：创建爱国者组织/怂恿Liquid策划影子摩西岛事件/夺取REX设计图并买到黑市/怂恿Solidus Snake开始行动/用Liquid的人格骗过爱国者同时摧毁了爱国者电脑</p>
<p><img src="/images/14576382123468.jpg" alt="Ocelot"></p>
<p>山猫的父亲是The Sorrow(MGS3中出现过他的亡灵)，母亲就是The Boss。如果说BB或者SS是天生的超级战士的话，那么山猫就是天生的完美间谍，简单梳理一下山猫的一生：最早出生的时候就被 “哲学家”组织带走用来当作人质控制The Boss(实际上山猫不知道自己的父母是谁)，之后山猫就由“哲学家”培养成一名间谍安插在当时的CIA身边，而CIA又把他派去苏联在Volgin将军手下当间谍。所以单单在MGS3中，山猫就是一名双面间谍。</p>
<p>随后山猫在MGS3的最后拿到了那笔“哲学家的遗产”，创建了“爱国者”。故事就进行到了MGS1，山猫有作为间谍安插在当时的美国总统Solidus Snake身边，而Solidus Snake却不知道山猫其实就是一直控制自己的爱国者，Solidus Snake又将山猫派去Liquid身边当间谍，主要目的就是怂恿Liquid叛变，试验一下人类能否反抗爱国者。所以说Liquid自己也不过就是一个被利用的棋子罢了。在 MGS1的最后，山猫拿走了REX的设计图，同时之后移植的Liquid的右手之后形成的Liquid人格也成为了他反抗爱国者计划的重要的一环。</p>
<p>在MGS2中，山猫一开始夺取了RAY的原型机(油轮篇的剧情)，假装在Solidus手下帮他做事，实际上他是爱国者安排在Solidus身边收集集S3计划数据的人选。当收集数据的目标完成后，他主动坦白自己其实是爱国者的间谍，如今目的已经达成了。随后他变成Liquid的人格驾驶着原型机RAY逃离了战舰。</p>
<p>山猫组建PMC，同时开始了他最后一段间谍生涯——成为自己的间谍，破坏爱国者。山猫知道爱国者知道自己的想法，想要骗过它就必须骗过自己，于是Liquid，这个通过心理暗示出现的人格成功的骗了自己，也骗了爱国者。等于说是山猫实现了当时The Boss的理想，而最终败在自己一直追赶的偶像——Big Boss的克隆体手上，最后那一句：“You’re pretty good。”也代表着山猫和Snake家族这50多年的恩怨终于了结。</p>
<h3 id="Zero"><a href="#Zero" class="headerlink" title="Zero"></a>Zero</h3><p><img src="/images/14576381904423.jpg" alt="Zero"></p>
<p>事迹：建立“爱国者”组织</p>
<p>Zero其实没有在任何一代游戏之中作为主要人物出场，他一直处在一个幕后的位置，但是他所做的一切，在MGS系列中都有举足轻重的地位。首次登场就是在MGS3，他当时只是一个负责传达命令的配角，和其他人一样，Zero也不过是一个行动代号罢了，而且他还有一个很重要的外号，叫做Cipher(也有零的含义)。</p>
<p>在MGS3的最后，山猫拿到“哲学家遗产”之后就和Zero一起创建了爱国者组织，是爱国者的创始人之一。起初他们的目的就是利用手上的这笔财产实现The Boss当时世界统一的理想，但是之后他和Big Boss之间的理念产生了重大分歧(具体内容可以查看爱国者和魔童计划)，在Big Boss走后Zero变得非常恐惧，他非常害怕这样强大的Big Boss会与自己做对，于是魔童计划的产物孪蛇和solidus出现了。Zero也在bb的身边安插了间谍Paz(《和平行者》中的故事)，在Paz失败之后Zero开始专心着手爱国者AI的研究(期间的空白期5代可能会补充。)，在自己老了之后依靠着生命维持装置苟延残喘，最终被Big Boss拔掉了氧气管死亡。</p>
<h3 id="Paz"><a href="#Paz" class="headerlink" title="Paz"></a>Paz</h3><p>事迹：《和平行者》中BB身边的间谍，《原爆点》中BB需要解救的人质，疑似在《幻痛》之中的死而复生的神秘人物</p>
<p><img src="/images/14576382767731.jpg" alt="Paz"></p>
<p>Paz是Cipher安排在bb身边的间谍，她一开始说自己只有16岁，是一名大学生，当然这些都是伪造的，目的就是夺取MG，杀掉bb。但是这样一个看起来狡猾狠毒的间谍，随着故事的进行却渐渐的被BB一行人所改变。特别是在《和平行者》的后面，部队要举行聚会活动，士兵们都要求Paz上去唱歌，作为一个间谍大可不去理会，但是Paz心理却想先放下任务，去和大家一起庆祝。</p>
<blockquote>
<p>Paz：“士兵们也都很期待.事到如今也无法拒绝了。”<br>Paz：“虽然我没有在人前唱过歌.但是像这样被期待著感觉也不坏。”<br>Paz：“只少我敢保证唱的一定比米穆好。”<br>Paz：“可是ZEKE的改造已经完成了.我必须要达成我的使命不可了。”<br>Paz：“要是背叛了CIPHER.一定会让我尝到比死还恐怖的绝望吧。”<br>Paz：“可是。”<br>Paz：“应该也不是马上就得实施计画不可吧。”<br>Paz：“稍微晚一点实行应该也不是问题吧。”<br>Paz：“难得的和平日…只少等到那天应该没关系吧。”<br>Paz：“说不定.是我自己把问题给快转了也说不定。”<br>Paz：“到了那一天.不管怎麼样我跟Snake一定有一方会死。”<br>Paz：“就算这样…”<br>Paz：“只少在和平之日来临之前.先想办法瞒住CIPHER。”<br>Paz：“不知为何我开始想著这样的事….”</p>
</blockquote>
<p>这是在《和平行者》中Paz的录音记录，可以看出她并不是一个单纯甘心被利用的“机器”。之后，Paz掉入海中，被渔民救起却被XOF部队抓走进行虐待(《原爆点》剧情)。</p>
<h3 id="Chico"><a href="#Chico" class="headerlink" title="Chico"></a>Chico</h3><p><img src="/images/14576384343657.jpg" alt="Chico"></p>
<p>Chico是哥斯达黎加民间反抗组织——Sandinista National Liberation Front的一个少年兵，他有一个父亲，一个姐姐，他的父亲就是这个组织的首领，Chico算是这个组织里面的小少爷。可是之后他的父亲战死，组织的领导就落到了他的姐姐头上。而Chico一直想成为一名独当一面的战士，就像bb那样，于是乎他和姐姐率领这组织一同加入了bb的无国界军队。在军队之中，Chico看到了Paz并且对她一见钟情，当Paz坠海之后，大家都以为她死了。但是随后有人给军队放出消息称Paz没死，在我们手上做人质。Chico听到决定就独自一人触发营救Paz，结果就是《原爆点》的剧情，自己被俘虏还被虐待，最终还当了叛徒告诉了BB基地的所在位置，导致XOF部队能如此快速的对BB进行打击。故事的最后并没有给Chico一个具体的交代，看来只有在《幻痛》中才能知道这个少年的结局了。</p>
<h3 id="Kazuhira_Miller"><a href="#Kazuhira_Miller" class="headerlink" title="Kazuhira Miller"></a>Kazuhira Miller</h3><p>事迹：和BB一同管理无国界军队，一起战斗</p>
<p><img src="/images/14576384591948.jpg" alt="Kazuhira Miller"></p>
<p>Miller其实是在二战期间一位美国将军与一位日本女人生的孩子，在Miller长大之后他的母亲就去世了，他选择了加入日本自卫队保护国家，维护和平，他的名字中的Kazuhira其实就是和平的意思。但是Miller在做了一段之后发现日本自卫队并不能有他心理那种维护和平的感觉，于是他选择离开日本加入佣兵部队。在一次行动中他遇上了BB的小队，结果自己部队被全灭，他想使用手雷和BB同归于尽，但是却被BB救了。从此之后他就死心塌地一直跟随BB成立无国界军队，而自己在军队中处于一个管家的地位，负责后方为bb提供支援。</p>
<p>值得一提的是Miller非常喜欢美女，因为他总是和部队里面的女性扯出一些关系，BB还揍过他。但是在原爆点的最后，基地被炸毁无国界军队随之消失，他和BB之后的故事就只能期待《幻痛》了。</p>
<p>对于他的死其实并没有交代的特别清楚，在MGS2中，会有一名自称Miller的教官一直为你提供情报，关于这个教官官方的设定是：曾在日本陆上自卫队、SAS、陆军特殊部队军団、美国海军陆战队服役，还和Big Boss两度合作成立和经营佣兵组织，最后成为了Foxhound的教官。当时被称为“鬼教官”，队员们对他极为尊敬故称他为“Master Miller”。现在已辞退了教官之职，在阿拉斯加与大自然一起生活。</p>
<p>但是在最后Liquid告诉你那个Miller其实被自己干掉了，也就是说当年那个Miller其实死在了Liquid手下。</p>
<h3 id="Huey"><a href="#Huey" class="headerlink" title="Huey"></a>Huey</h3><p>事迹：开发Peace Walker/协助bb和无国界军队/“背叛”BB导致基地毁灭</p>
<p><img src="/images/14576385384049.jpg" alt="Huey"></p>
<p>Huey有2个很有名的孩子——其中一个就是Otacon，两者长的真的是一模一样，性格也是;还有一个就是Emma，也就是MGS2中制作病毒摧毁爱国者GW的那个妹子。Huey是一名MG的开发人员，Peace Walker就是他和奇爱博士一同开发完成的(他负责机械，奇爱负责AI。)，但是做出Peace Walker并不是他的本愿，他被寇曼所欺骗，认为制作这台机器的原因是为了保护和平。这一点和他儿子Otacon非常相似——都是天真的科学宅。Huey在知道和平行者要发射核弹之后毅然决然的离开了寇曼投奔BB，开始为BB做技术支援，之后也就有了《原爆点》的剧情。但是Huey不知为何私自答应一个所谓的“世界核武器检查”的组织的要求，同意他们来到基地。在这之后基地就被敌人袭击导致毁灭，Huey也被当作叛徒。从《幻痛》的预告来看，其中会有审讯Huey的情节，看来Huey叛变的原因也只能在幻痛中揭晓了。</p>
<h3 id="Punished__u201CVenom_u201D_Snake"><a href="#Punished__u201CVenom_u201D_Snake" class="headerlink" title="Punished “Venom” Snake"></a>Punished “Venom” Snake</h3><p>Venom是以Big Boss之名而存在，却实则并非Big Boss。真实且原先的身份是The Medic，即《潜龙谍影5：原爆点》负责在直升机紧急治疗Paz的医疗兵。根据判断，The Medic很可能是由Kiefer Sutherland配音，而真正的Big Boss仍由David Hayter负责。</p>
<p>The Medic最初是以普通士兵加入Big Boss创建的Militaires Sans Frontières军事无国界组织，并随后成为了Big Boss最为信任的人之一。由于声音的相似，因而成为Big Boss替身的最好选择，并最终在医院完成整容手术。</p>
<p>通过观察The Medic在《潜龙谍影5：原爆点》的直升机爆炸瞬间，可以发现其为保护Big Boss而所处的身位，导致其头部留有金属残片。通过完成任务46，可以发现真正的Big Boss的面部并无金属残片或明显伤痕。</p>
<p>The Medic接受过Eli的DNA测试，却发现与Big Boss的不符。且在随后Huey，Quiet，Liquid Snake都有质疑表现。</p>
<h3 id="Skull_face"><a href="#Skull_face" class="headerlink" title="Skull face"></a>Skull face</h3><p>Skullface是《潜龙谍影5》事件的元凶。其生于匈牙利，父母工作于秘密兵工厂，却皆遭炸弹袭击而受伤。</p>
<p>由于伤情严重且治疗有限，在基本遭到放弃的情况下，终因最新的寄生疗法而存货。然而，这种疗法的副作用影响了他的身理系统，使其不再能感到疼痛。</p>
<p>Skullface随后得到Zero的招募并成立XOF来监控Big Boss来预防其重要任务成功，注入《潜龙谍影3》的噬蛇者行动。多年为Zero工作并监视Big Boss，使其对两人感到愤怒，尤其是Zero。于是，他在1975年通过袭击Big Boss基地并在Paz体内安装炸弹谋求杀死Big Boss。</p>
<p>在其发现Zero与Dr. Strangelove正在研发爱国者AI智能，他便只做了一种寄生感染，能使人类喉咙病变而失声。这种寄生虫由Code Talker研发，也有解药却不愿公开。《潜龙谍影3》的眼镜蛇小队也是寄生感染技术的试验品。</p>
<p>根据《潜龙谍影5：原爆点》最后，Skullface根据Paz所透露的情报，使Zero感染该病毒病逐渐成为植物人状态。而Skullface更想通过ST-84 Metal Gear来传播。</p>
<p>在最后所有计划即将完成之际，The Third Child在Mantis发现Liquid Snake出现在XOF直升机之后，而发怒与Skullface决裂。Skullface因ST-84 Metal Gear受困，而Big Boss和Miller决定弃他而去使其受苦而死，但Hery无视他们的想法而最终杀死了Skullface。</p>
<h3 id="Quiet__u9759_u9759"><a href="#Quiet__u9759_u9759" class="headerlink" title="Quiet 静静"></a>Quiet 静静</h3><p>Quiet便是在医院袭击Big Boss和Venom的女性。因Big Boss的反击而受到重伤，但其特殊能力因寄生治疗而增强。</p>
<p>她的听力是普通士兵的10倍，且视力不受日夜交替影响，但却携带着导致失声的病变寄生源。其肌肤可以通过洗澡或雨水吸收水分，也是其体内寄生虫的影响。然而，水会对Quiet的特殊能力有所削弱。</p>
<p>在通过招募之后，其将会在任务43之后离队。在主要任务全部完成之后，Venom会在一个次要任务寻找其踪迹。在逃脱时，Venom被毒蛇所咬伤。Quiet必须不再沉默并说出实情，来解救Venom。但在最后，她仍然会独自消失于沙漠之中……</p>
<h3 id="Man_on_Fire"><a href="#Man_on_Fire" class="headerlink" title="Man on Fire"></a>Man on Fire</h3><p>The Man on Fire火男，即是《潜龙谍影3》的Volgin，现为The Third Child进行着精神控制。在与Big Boss对决后，Volgin仍然存活却呈脑死状态，其想要向Big Boss复仇的执念使其成为一个恶魔而存在，并被俄罗斯医生作为科学研究而供养。</p>
<p><img src="/images/14576392498262.jpg" alt="Man on Fire"></p>
<p>Venom在随后回收其身体并保存在基地，但因ST-84 Metal Gear袭击而损毁。  </p>
<h2 id="u540D_u8BCD_u89E3_u91CA"><a href="#u540D_u8BCD_u89E3_u91CA" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="u9B54_u7AE5_u8BA1_u5212"><a href="#u9B54_u7AE5_u8BA1_u5212" class="headerlink" title="魔童计划"></a>魔童计划</h3><p>魔童计划【Les Enfants Terribles(法文)/恐るべき子供たち】是由美国政府在20世纪70年代早期着手进行的一项试验，目的是通过基因克隆等手段，制造出更多像Big Boss这样的超级战士。值得一提的是这项计划的赞助者就是爱国者组织的领导——Zero，提供医学技术支持的是Dr. Clark，也是爱国者组织中的一员。在1972年，Zero等人通过提取了Big Boss的基因，再将Eva当作母体的方式成功制作出了2个克隆人。不过其实当时有8个成功的受精卵，但是为了做出最强的而消灭掉了6个来全力强化剩下的那2个。</p>
<p>但是Big Boss在知道这件事后，他愤怒的离开了爱国者组织。最终9个月后，Eva成功产出了2个婴儿，由于他们2个都是用Snake的基因制作出的，所以被称为“Twin Snakes(孪蛇)”。这2个也就是日后我们熟知的Liquid Snake和Solid Snake。而且因为Big Boss的离开，Zero也开始变得不再信任其他人，于是他将孪蛇当作爱国者组织的保险，以防Big Boss将来会与他为敌。随后不久，魔童计划又制作出了一名新蛇，不同于之前的SS和LS，他的名字既不是固体也不是液态，而是Solidus Snake。Solidus Snake是一个完美的克隆体，他不像之前的孪蛇一样分别继承了隐性和显性，而是完美的继承优良基因，所以他也会被爱国者选中成为美国总统。不过魔童计划也在Solidus Snake制作出之后就彻底终结了。所以Solidus可以说是魔童计划的最后一个也是最完美的产物。</p>
<h3 id="u7231_u56FD_u8005"><a href="#u7231_u56FD_u8005" class="headerlink" title="爱国者"></a>爱国者</h3><p>爱国者(The Patriots)最早是由一个当时在MGS3食蛇者行动之中存活下来的人们建立的一个可以控制世界军事，政治和经济形式的一个强大组织，成员有：Zero、Big Boss、Eva、Ocelot、 Sigint(技师，日后的机械忍者骨骼就是他所开发的)、Para-Medic(医生，研究死狐病毒，实行魔童计划的人物)。而让组织运作的资金就是3代最终山猫拿到的那份哲学家的遗产(Philosophers’ Legacy) 。哲学家(或称作“贤人”)是在二战结束之后世界各地的强大领导者聚集在一起形成的一个组织，但是随着世界格局的变化这个组织最终瓦解，但是却留下了一笔非常惊人的财富，也就是这份遗产。在3 代后，山猫拿着这份钱找到了Zero想要建立起一个组织来实现The Boss的理想，同时也极力推荐Big Boss等人的加入，最终这6人也就形成了最早的爱国者组织。</p>
<p>但是这样一个组织没有团结太久，Big Boss和Zero对The Boss的理念有着不同的看法，BB认为应当放任自由，但是不会放弃武力约束;Zero认为应当集权统治，独裁才能统一。最终再加上BB发现了Zero暗地里对自己做的魔童计划，终于分道扬镳。而BB在之后建立了世外天国的武装国家，Zero过于害怕BB的力量于是策划了桑吉巴尔岛事件，利用自己制作的Solid Snake干掉了BB。但是随着Zero的日益老去，再加上爱国者组织的成员不断减少而且Zero也没有增添新的成员，于是他决定利用人工智能电脑来辅佐爱国者的运作。不过随着时间的推移，Zero对AI的约束管理越来越少，再加上拥有高智能和全球人类数据的爱国者电脑不断的进化，结果就是AI自己制作出了一套引领人类进步的系统，也就是MGS4中提到的爱国者之子系统，通过纳米机器人控制人类的情绪，打算自己统领人类。而他对计划的测试就是整个2代的故事，最终在4代里，利用FOX ALIVE病毒才彻底消灭了爱国者。</p>
<p>顺带一提Patriots为了封闭信息，人体内的NANOMACHINE(纳米机器)在本体要说出爱国者这个词的时候会将其转变为LA LI LU LE LO……这也就是为什么在2代的时候，总会听到LA LI LU LE LO的原因。</p>
<h3 id="u6B7B_u72D0_u75C5_u6BD2"><a href="#u6B7B_u72D0_u75C5_u6BD2" class="headerlink" title="死狐病毒"></a>死狐病毒</h3><p>FOXDIE病毒能致死特定基因的人，影子摩西岛事件时被NAOMI注射入Snake身体的FOXDIE对应Liquid Snake\Kenneth Baker以及叛变的FOXHOUND成员，当年实际被FOXDIE致死的人只有Liquid Snake 、Kenneth Baker和Decoy Octopus。这一点，我们在MGS1的故事中都已经说了一些，但是死狐病毒不单单只会对特定人造成致命威胁，还有新的死狐病毒。</p>
<p>新的FOXDIE和FOXALIVE不同，后者是对爱国者的AI系统的，前者是爱国者研制出来由DREBIN893注射到Snake体内，他将FOXDIE的指向人群转为ZERO、BIG BOSS、LIQUID Ocelot、BIG MAMA以及当初发明死狐病毒的Namoi。新的FOXDIE病毒和旧的FOXDIE混合发生变异，DREBIN注射之后其实Snake不会成为生物武器了，所以他无需自杀，BIG BOSS出面告诉他，他才得知。但是他的身体也仍然在急速老化，剩下的时间不多了，因为不能繁衍后代，他将和Otacon、Sunny一起见证自己的存在。</p>
<p>DREBIN是很多人的总称，是战场上的洗枪者。DREBIN893是游戏中的人物，是孤儿，先被爱国者收养，后被反抗组织俘虏并为组织训练为洗枪者，893是一个代号而已。实际上他一直是接受爱国者的命令的。是爱国者特意安排他接近Snake，帮助Snake洗枪，并将新的死狐病毒混合在最新的纳米机器中注射入Snake体内。</p>
<h3 id="S3_u8BA1_u5212"><a href="#S3_u8BA1_u5212" class="headerlink" title="S3计划"></a>S3计划</h3><p>S3计划是由爱国者在MGS2中实施的一个计划，S3有2层含义：</p>
<p>表：“Solid Snake Simulation(模拟Solid Snake)”，即重现MGS1中影子摩西岛的事件，从而找到能再现像当年像SS一样的超级战士。所以之前也说MGS2中整个事件为什么和影子摩西岛那么相似，比如：</p>
<ul>
<li>Raiden ⇔ Snake (主角)</li>
<li>AI上校 ⇔ Roy Campbell上校 (任务指挥官)</li>
<li>伪装成石油分解平台的Big Shell ⇔ 伪装为核废弃储存设施的影子摩西 (背景舞台)</li>
<li>特工Richard Ames ⇔ DARPA局长Donald Anderson (第一个死于“心脏病”的人质)</li>
<li>总统James Johnson ⇔ Arms军工总裁Kenneth Baker (第二个死亡的人质)</li>
<li>Olga Gurlukovich/Mr X ⇔ Gray Fox/Deepthroat (机械忍者)</li>
<li>Emma Emmerich = Sniper Wolf (与Otacon相关且死去的女人)</li>
<li>目击Emma被Vamp刺中 ⇔ 目击Meryl被Wolf击中 (看见女孩受伤却爱莫能助的情况)</li>
<li>Solidus Snake ⇔ Liquid Snake (最终Boss与主角都有亲人般的联系)</li>
<li>电脑病毒 ⇔ 死狐病毒</li>
</ul>
<p>而S3的深层含义则是：“Selection for Societal Sanity(社会健全选择)/社会の思想的健全化のための淘汰”，说白了就是爱国者想要测试在MGS2那种高强度危机事件下，能否靠自己控制住人类的情绪，如果可以，那么之后就不会再担心会再有人反抗自己了。MGS2的那么多牺牲其实就是爱国者的一个实验罢了。S3的过程除了ss和Otacon真的出现之外堪称完美，而且就结果而言，爱国者成功的得到了它想要的结果，这也为MGS4中的事件打下了基础。</p>
<h3 id="Metal_Gear-1"><a href="#Metal_Gear-1" class="headerlink" title="Metal Gear"></a>Metal Gear</h3><p>游戏中的MG其实一种超级武器。其实最早的设计理念仅仅是开发“可移动型核战车”，随之就出现了2条分支，一种以履带驱动，一种是双足站立。其实最初和MG相关的故事就是在MGS3中，一开始的贞洁行动要去拯救的那位科学家索科洛夫(Sokolov)就是在研究可移动型核战车，也就是3代中的BOSS——峡谷虎(Shagohod)，Shagohod采用的是履带行动而非双足，所以在Shagohod战败之后也就舍弃了履带驱动这个分支，之后选择的都是双足站立的MG。</p>
<p>这里额外需要注明一下的就是Shagohod其实并不是MG，Shagohod和MG其实是以“可移动型核战车”为开发理念制作的不同分支，当然也不存在什么原型机一说。</p>
<p>在《合金装备》中有大大小小各种各样的Metal Gear，大到MGS2中的巨型战舰，小到量产型的月光(Gecko)。但是有3种Metal Gear是非常具有代表性的，分别是ZEKE，REX，RAY。</p>
<p>Metal Gear ZEKE，首次出场：《合金装备索利德：和平行者》</p>
<p><img src="/images/14576377622940.jpg" alt="Metal Gear ZEKE"></p>
<p>ZEKE最早是由BB下达指示，让huey着手开发的一台Metal Gear，其最开始的目的只是单纯的作业用辅助机器，但是在经理了和平行者中的事件之后，获得了Peace Walker(和平行者中出现的一台MG)的部分零件，再加上考虑到自己的部队可能也会需要这样的战斗力，于是将其改造成了一台战斗用MG，但是依旧是由AI控制。但是Paz在之后偷走了ZEKE并且将它改造成了人工驾驶，在游戏的最后和BB展开了对决。不过最终即使拥有众多强大武器的ZEKE也没有战胜BB，Paz也随着爆炸掉入海中结果被人俘虏，之后就是《合金装备索利德5：原爆点》的剧情了。</p>
<p>Metal Gear REX，首次出场：《合金装备索利德》</p>
<p><img src="/images/14576377952638.jpg" alt="Metal Gear REX"></p>
<p>REX虽然不是最早的，但是可能是最有名的一台MG。REX是由DARPA(美国国防部先进研究项目局)进行开发，之后在影子摩西岛进行轨道炮演习的时候被叛变的猎狐犬小队夺取，也就是MGS1代中的影子摩西岛事件。值得一提的是REX的主要开发人员就是Otacon，但是他是在不知情的情况下开发的，因为当时上面告诉他这个兵器的目的是为了反导弹，保证核安全，结果最后才知道自己被忽悠了，不过这也让Otacon决定之后走上的反MG道路。</p>
<p>REX的造型非常霸气，而是是第一个以3D形式呈现的MG，当然不仅仅是外表，REX的实力也不容小觑。它厚实的装甲可以抵御反坦克导弹的攻击，同时强大的机动性可以在打击之后快速撤离。最重要的是REX搭载的电磁轨道炮，如果利用其发射核弹的话完全不会被提前侦测到。最终在MGS1结束之时，山猫将REX的设计图偷走并在黑市上售卖，这直接引起了MG的量产，同时也为新一代MG做了准备。</p>
<p>Metal Gear RAY，首次出场：《合金装备索利德2：自由之子》</p>
<p><img src="/images/14576378455276.jpg" alt="Metal Gear RAY"></p>
<p>RAY可以当作是REX的一种进化，甚至可以说RAY的制作目的就是为了破坏REX。RAY在造型上仅仅继承了双足站立这一特点，其余都有非常大的进步。最明显的就是它那1对翅膀，这对翅膀可以帮助 RAY在水下推进，所以RAY是一种水路两栖用MG。RAY的武装也更加强大，它配置了水刀(高压水流切割装置)，威力几乎和激光剑等同，同时它还有标准的机枪和火箭发射器。而且RAY的机械部分采用了生物组织，不仅可以在受伤时分泌出粘性物质自我修复，机动力更是大幅度提高。所以RAY在2,4,乃至最后的《合金装备崛起：复仇》中都充当了相当重要的地位。</p>
<p>在MGS2中，RAY有一台原型机和数台量产机，但是量产机的实力很差，都被雷电全部摆平，最终山猫驾驶着原型机脱离了战场，同时在4代中，有着SS驾驶REX和山猫驾驶的RAY对战的场面，虽然就两者的性能而言剧情设定有些勉强但是还是REX获得了胜利。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.gamersky.com/handbook/201511/680245.shtml" target="_blank" rel="external">《合金装备》系列历史剧情 合金装备全系列历史剧情揭秘</a></li>
<li><a href="http://www.gamersky.com/handbook/201508/657226.shtml" target="_blank" rel="external">《合金装备》全系列回顾 合金装备全系列剧情回顾及人物介绍</a></li>
<li><a href="/"></a></li>
<li></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果说这个世界上有第二个系列像 EVA 一样让我如痴如醉的话，那么肯定是 MGS 系列。在玩『潜龙谍影5：幻痛』的时候，每一段磁带（包含大量重要剧情信息）都认真听过之后，对于整个系列的剧情有了大概的认知。这篇文章会比较长，综合了网上的各种资料和我自己的理解，希望能给大家带来一个比较完整的阅读体验。</p>]]>
    
    </summary>
    
      <category term="BigBOSS" scheme="http://wdxtub.com/tags/BigBOSS/"/>
    
      <category term="Quiet" scheme="http://wdxtub.com/tags/Quiet/"/>
    
      <category term="Snake" scheme="http://wdxtub.com/tags/Snake/"/>
    
      <category term="合金装备" scheme="http://wdxtub.com/tags/%E5%90%88%E9%87%91%E8%A3%85%E5%A4%87/"/>
    
      <category term="幻痛" scheme="http://wdxtub.com/tags/%E5%B9%BB%E7%97%9B/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 Twitter 语料分析 5 ETL 导入数据]]></title>
    <link href="http://wdxtub.com/2016/03/09/cc-p5/"/>
    <id>http://wdxtub.com/2016/03/09/cc-p5/</id>
    <published>2016-03-10T03:33:12.000Z</published>
    <updated>2016-03-11T11:00:06.000Z</updated>
    <content type="html"><![CDATA[<p>这一次我们需要利用 Map Reduce 处理大约 1T 的 Twitter 数据，并导入到对应的数据库中，这一部分因为奇奇怪怪的情况很多，所以一定要注意。</p>
<a id="more"></a>
<hr>
<h2 id="u6570_u636E_u5904_u7406"><a href="#u6570_u636E_u5904_u7406" class="headerlink" title="数据处理"></a>数据处理</h2><p>这一部分主要是写一个 mapper 和 reducer，把原始数据的 json 格式处理成我们需要的格式（也就是下一步中我们需要返回的内容）。</p>
<p>在决定具体需要获取什么内容之前，我们先来看看原始数据的结构。老师提供的数据地址是 <code>s3://cmucc-datasets/twitter/s16/part-00XXX</code>，我们可以直接用浏览器下载一个试试看，下载地址是 <code>http://s3.amazonaws.com/cmucc-datasets/twitter/s16/part-00000</code>（具体的转换过程可见参考资料）</p>
<p>下载完成之后发现有差不多 2G，我们在本地只是做一下测试当然用不着这么多数据，所以用下面的命令拆出来几个子集：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head -n <span class="number">100</span> part-<span class="number">00000</span> &gt; data100</span><br><span class="line">head -n <span class="number">1000</span> part-<span class="number">00000</span> &gt; data1K</span><br><span class="line">head -n <span class="number">10000</span> part-<span class="number">00000</span> &gt; data10K</span><br></pre></td></tr></table></figure>
<p>然后我们输出一行来看一下，很长，如下</p>
<p><code>{&quot;created_at&quot;:&quot;Thu May 15 09:02:20 +0000 2014&quot;,&quot;id&quot;:466866157933182977,&quot;id_str&quot;:&quot;466866157933182977&quot;,&quot;text&quot;:&quot;RT @Xxxshota7xxx: \u3010\u885d\u6483\u6620\u50cf\u3011\n\u30d0\u30e9\u30a8\u30c6\u30a3\u756a\u7d44\u3067\u30d0\u30a4\u30ad\u30f3\u30b0\u30fb\u5c0f\u5ce0\u306b\n\u4ed5\u639b\u3051\u305f\u30c9\u30c3\u30ad\u30ea\u304c\u9177\u3059\u304e\u3066\u5927\u708e\u4e0awww\n\n\u52d5\u753b\u306f\u3053\u3061\u3089\u21d2http:\/\/t.co\/DFtzc8nOcN\n\n\u4e2d\u5c45\u304f\u3093\u6016\u3059\u304e\u30ef\u30ed\u30bfww http:\/\/t.co\/Zph8jC6QzY&quot;,&quot;source&quot;:&quot;\u003ca href=\&quot;http:\/\/yahoo.co.jp\&quot; rel=\&quot;nofollow\&quot;\u003e\u3010\u7f8e\u4eba\u3011 \u60a9\u6bba\u7387100\uff05\u3067\u4eba\u6c17\u8870\u3048\u305a\uff01\u003c\/a\u003e&quot;,&quot;truncated&quot;:false,&quot;in_reply_to_status_id&quot;:null,&quot;in_reply_to_status_id_str&quot;:null,&quot;in_reply_to_user_id&quot;:null,&quot;in_reply_to_user_id_str&quot;:null,&quot;in_reply_to_screen_name&quot;:null,&quot;user&quot;:{&quot;id&quot;:1391544108,&quot;id_str&quot;:&quot;1391544108&quot;,&quot;name&quot;:&quot;v.i.p ryokun&quot;,&quot;screen_name&quot;:&quot;ryoryoryoryo10&quot;,&quot;location&quot;:&quot;\u26612013.06.29\u301c  m.love\u2026\u2661&quot;,&quot;url&quot;:null,&quot;description&quot;:&quot;Osaka Nishiyodogawa 17age Follow me Utajima 65th\u261eKitayodo51th&quot;,&quot;protected&quot;:false,&quot;followers_count&quot;:814,&quot;friends_count&quot;:689,&quot;listed_count&quot;:1,&quot;created_at&quot;:&quot;Tue Apr 30 08:53:33 +0000 2013&quot;,&quot;favourites_count&quot;:838,&quot;utc_offset&quot;:null,&quot;time_zone&quot;:null,&quot;geo_enabled&quot;:true,&quot;verified&quot;:false,&quot;statuses_count&quot;:9828,&quot;lang&quot;:&quot;ja&quot;,&quot;contributors_enabled&quot;:false,&quot;is_translator&quot;:false,&quot;is_translation_enabled&quot;:false,&quot;profile_background_color&quot;:&quot;C0DEED&quot;,&quot;profile_background_image_url&quot;:&quot;http:\/\/abs.twimg.com\/images\/themes\/theme1\/bg.png&quot;,&quot;profile_background_image_url_https&quot;:&quot;https:\/\/abs.twimg.com\/images\/themes\/theme1\/bg.png&quot;,&quot;profile_background_tile&quot;:false,&quot;profile_image_url&quot;:&quot;http:\/\/pbs.twimg.com\/profile_images\/464402846293573632\/iDbrYwVz_normal.jpeg&quot;,&quot;profile_image_url_https&quot;:&quot;https:\/\/pbs.twimg.com\/profile_images\/464402846293573632\/iDbrYwVz_normal.jpeg&quot;,&quot;profile_banner_url&quot;:&quot;https:\/\/pbs.twimg.com\/profile_banners\/1391544108\/1398871213&quot;,&quot;profile_link_color&quot;:&quot;0084B4&quot;,&quot;profile_sidebar_border_color&quot;:&quot;C0DEED&quot;,&quot;profile_sidebar_fill_color&quot;:&quot;DDEEF6&quot;,&quot;profile_text_color&quot;:&quot;333333&quot;,&quot;profile_use_background_image&quot;:true,&quot;default_profile&quot;:true,&quot;default_profile_image&quot;:false,&quot;following&quot;:null,&quot;follow_request_sent&quot;:null,&quot;notifications&quot;:null},&quot;geo&quot;:null,&quot;coordinates&quot;:null,&quot;place&quot;:null,&quot;contributors&quot;:null,&quot;retweeted_status&quot;:{&quot;created_at&quot;:&quot;Thu May 15 07:43:29 +0000 2014&quot;,&quot;id&quot;:466846313691115520,&quot;id_str&quot;:&quot;466846313691115520&quot;,&quot;text&quot;:&quot;\u3010\u885d\u6483\u6620\u50cf\u3011\n\u30d0\u30e9\u30a8\u30c6\u30a3\u756a\u7d44\u3067\u30d0\u30a4\u30ad\u30f3\u30b0\u30fb\u5c0f\u5ce0\u306b\n\u4ed5\u639b\u3051\u305f\u30c9\u30c3\u30ad\u30ea\u304c\u9177\u3059\u304e\u3066\u5927\u708e\u4e0awww\n\n\u52d5\u753b\u306f\u3053\u3061\u3089\u21d2http:\/\/t.co\/DFtzc8nOcN\n\n\u4e2d\u5c45\u304f\u3093\u6016\u3059\u304e\u30ef\u30ed\u30bfww http:\/\/t.co\/Zph8jC6QzY&quot;,&quot;source&quot;:&quot;\u003ca href=\&quot;http:\/\/yahoo.co.jp\&quot; rel=\&quot;nofollow\&quot;\u003e\u30d0\u30a4\u30ad\u30f3\u30b0\u30fb\u5c0f\u5ce0\u306b \u4ed5\u639b\u3051\u305f\u30c9\u30c3\u30ad\u30ea\u003c\/a\u003e&quot;,&quot;truncated&quot;:false,&quot;in_reply_to_status_id&quot;:null,&quot;in_reply_to_status_id_str&quot;:null,&quot;in_reply_to_user_id&quot;:null,&quot;in_reply_to_user_id_str&quot;:null,&quot;in_reply_to_screen_name&quot;:null,&quot;user&quot;:{&quot;id&quot;:962038489,&quot;id_str&quot;:&quot;962038489&quot;,&quot;name&quot;:&quot;\u3057\u3087\u30fc\u305f&quot;,&quot;screen_name&quot;:&quot;Xxxshota7xxx&quot;,&quot;location&quot;:&quot;\u5bcc\u7530\u6797&quot;,&quot;url&quot;:null,&quot;description&quot;:null,&quot;protected&quot;:false,&quot;followers_count&quot;:194,&quot;friends_count&quot;:156,&quot;listed_count&quot;:0,&quot;created_at&quot;:&quot;Wed Nov 21 08:46:53 +0000 2012&quot;,&quot;favourites_count&quot;:347,&quot;utc_offset&quot;:null,&quot;time_zone&quot;:null,&quot;geo_enabled&quot;:false,&quot;verified&quot;:false,&quot;statuses_count&quot;:2913,&quot;lang&quot;:&quot;ja&quot;,&quot;contributors_enabled&quot;:false,&quot;is_translator&quot;:false,&quot;is_translation_enabled&quot;:false,&quot;profile_background_color&quot;:&quot;C0DEED&quot;,&quot;profile_background_image_url&quot;:&quot;http:\/\/abs.twimg.com\/images\/themes\/theme1\/bg.png&quot;,&quot;profile_background_image_url_https&quot;:&quot;https:\/\/abs.twimg.com\/images\/themes\/theme1\/bg.png&quot;,&quot;profile_background_tile&quot;:false,&quot;profile_image_url&quot;:&quot;http:\/\/pbs.twimg.com\/profile_images\/378800000718547747\/89daed934729b4744480381a59081425_normal.jpeg&quot;,&quot;profile_image_url_https&quot;:&quot;https:\/\/pbs.twimg.com\/profile_images\/378800000718547747\/89daed934729b4744480381a59081425_normal.jpeg&quot;,&quot;profile_banner_url&quot;:&quot;https:\/\/pbs.twimg.com\/profile_banners\/962038489\/1387966350&quot;,&quot;profile_link_color&quot;:&quot;0084B4&quot;,&quot;profile_sidebar_border_color&quot;:&quot;C0DEED&quot;,&quot;profile_sidebar_fill_color&quot;:&quot;DDEEF6&quot;,&quot;profile_text_color&quot;:&quot;333333&quot;,&quot;profile_use_background_image&quot;:true,&quot;default_profile&quot;:true,&quot;default_profile_image&quot;:false,&quot;following&quot;:null,&quot;follow_request_sent&quot;:null,&quot;notifications&quot;:null},&quot;geo&quot;:null,&quot;coordinates&quot;:null,&quot;place&quot;:null,&quot;contributors&quot;:null,&quot;retweet_count&quot;:402,&quot;favorite_count&quot;:0,&quot;entities&quot;:{&quot;hashtags&quot;:[],&quot;symbols&quot;:[],&quot;urls&quot;:[{&quot;url&quot;:&quot;http:\/\/t.co\/DFtzc8nOcN&quot;,&quot;expanded_url&quot;:&quot;http:\/\/tinyurl.com\/lnpfgjb&quot;,&quot;display_url&quot;:&quot;tinyurl.com\/lnpfgjb&quot;,&quot;indices&quot;:[53,75]}],&quot;user_mentions&quot;:[],&quot;media&quot;:[{&quot;id&quot;:466846313540116480,&quot;id_str&quot;:&quot;466846313540116480&quot;,&quot;indices&quot;:[90,112],&quot;media_url&quot;:&quot;http:\/\/pbs.twimg.com\/media\/BnqSP6tCYAAt8C2.jpg&quot;,&quot;media_url_https&quot;:&quot;https:\/\/pbs.twimg.com\/media\/BnqSP6tCYAAt8C2.jpg&quot;,&quot;url&quot;:&quot;http:\/\/t.co\/Zph8jC6QzY&quot;,&quot;display_url&quot;:&quot;pic.twitter.com\/Zph8jC6QzY&quot;,&quot;expanded_url&quot;:&quot;http:\/\/twitter.com\/Xxxshota7xxx\/status\/466846313691115520\/photo\/1&quot;,&quot;type&quot;:&quot;photo&quot;,&quot;sizes&quot;:{&quot;large&quot;:{&quot;w&quot;:610,&quot;h&quot;:343,&quot;resize&quot;:&quot;fit&quot;},&quot;thumb&quot;:{&quot;w&quot;:150,&quot;h&quot;:150,&quot;resize&quot;:&quot;crop&quot;},&quot;small&quot;:{&quot;w&quot;:339,&quot;h&quot;:191,&quot;resize&quot;:&quot;fit&quot;},&quot;medium&quot;:{&quot;w&quot;:599,&quot;h&quot;:337,&quot;resize&quot;:&quot;fit&quot;}}}]},&quot;favorited&quot;:false,&quot;retweeted&quot;:false,&quot;possibly_sensitive&quot;:false,&quot;lang&quot;:&quot;ja&quot;},&quot;retweet_count&quot;:0,&quot;favorite_count&quot;:0,&quot;entities&quot;:{&quot;hashtags&quot;:[],&quot;symbols&quot;:[],&quot;urls&quot;:[{&quot;url&quot;:&quot;http:\/\/t.co\/DFtzc8nOcN&quot;,&quot;expanded_url&quot;:&quot;http:\/\/tinyurl.com\/lnpfgjb&quot;,&quot;display_url&quot;:&quot;tinyurl.com\/lnpfgjb&quot;,&quot;indices&quot;:[71,93]}],&quot;user_mentions&quot;:[{&quot;screen_name&quot;:&quot;Xxxshota7xxx&quot;,&quot;name&quot;:&quot;\u3057\u3087\u30fc\u305f&quot;,&quot;id&quot;:962038489,&quot;id_str&quot;:&quot;962038489&quot;,&quot;indices&quot;:[3,16]}],&quot;media&quot;:[{&quot;id&quot;:466846313540116480,&quot;id_str&quot;:&quot;466846313540116480&quot;,&quot;indices&quot;:[108,130],&quot;media_url&quot;:&quot;http:\/\/pbs.twimg.com\/media\/BnqSP6tCYAAt8C2.jpg&quot;,&quot;media_url_https&quot;:&quot;https:\/\/pbs.twimg.com\/media\/BnqSP6tCYAAt8C2.jpg&quot;,&quot;url&quot;:&quot;http:\/\/t.co\/Zph8jC6QzY&quot;,&quot;display_url&quot;:&quot;pic.twitter.com\/Zph8jC6QzY&quot;,&quot;expanded_url&quot;:&quot;http:\/\/twitter.com\/Xxxshota7xxx\/status\/466846313691115520\/photo\/1&quot;,&quot;type&quot;:&quot;photo&quot;,&quot;sizes&quot;:{&quot;large&quot;:{&quot;w&quot;:610,&quot;h&quot;:343,&quot;resize&quot;:&quot;fit&quot;},&quot;thumb&quot;:{&quot;w&quot;:150,&quot;h&quot;:150,&quot;resize&quot;:&quot;crop&quot;},&quot;small&quot;:{&quot;w&quot;:339,&quot;h&quot;:191,&quot;resize&quot;:&quot;fit&quot;},&quot;medium&quot;:{&quot;w&quot;:599,&quot;h&quot;:337,&quot;resize&quot;:&quot;fit&quot;}},&quot;source_status_id&quot;:466846313691115520,&quot;source_status_id_str&quot;:&quot;466846313691115520&quot;}]},&quot;favorited&quot;:false,&quot;retweeted&quot;:false,&quot;possibly_sensitive&quot;:false,&quot;lang&quot;:&quot;ja&quot;}</code></p>
<p>至于为什么这么长，我也不知道，具体要去问 Twitter，我们要做的就是从中挑出我们想要的信息。那么问题就来了，我们需要什么信息呢？这就要涉及到返回的数据是什么了。</p>
<p>我们需要做的很简单，就是返回某个用户用指定的 hashtag 发的 tweet，具体请求和响应的格式为：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">请求格式</span><br><span class="line"><span class="constant">GET</span> /q2?userid=uid&amp;hashtag=hashtag</span><br><span class="line"></span><br><span class="line">响应格式（如果有对应的推文）</span><br><span class="line"><span class="constant">TEAMID</span>,<span class="constant">TEAM_AWS_ACCOUNT_ID</span>\n</span><br><span class="line"><span class="constant">Sentiment_density1</span><span class="symbol">:Tweet_time1</span><span class="symbol">:Tweet_id1</span><span class="symbol">:Cencored_text1</span>\n</span><br><span class="line"><span class="constant">Sentiment_density2</span><span class="symbol">:Tweet_time2</span><span class="symbol">:Tweet_id2</span><span class="symbol">:Cencored_text2</span>\n</span><br><span class="line"><span class="constant">Sentiment_density3</span><span class="symbol">:Tweet_time3</span><span class="symbol">:Tweet_id3</span><span class="symbol">:Cencored_text3</span>\n</span><br><span class="line"></span><br><span class="line">响应格式（如果没有对应的推文）</span><br><span class="line"></span><br><span class="line"><span class="constant">TEAMID</span>,<span class="constant">TEAM_AWS_ACCOUNT_ID</span>\n</span><br><span class="line">\n</span><br></pre></td></tr></table></figure>
<p>所以从这里我们可以知道，需要从前面那一大堆数据中提取出来的数据有：</p>
<ul>
<li>tweet ID: 从 <code>id</code> 或 <code>id_str</code> 中获取</li>
<li>user ID: 从 <code>user</code> 下的 <code>id</code> 或 <code>id_str</code> 中获取</li>
<li>tweet Time: 从 <code>created_at</code> 中获取</li>
<li>tweet Text: 从 <code>text</code> 中获取</li>
<li>tweet Hashtag(if have): 从 <code>entities</code> 里获取</li>
</ul>
<p>有一些例外的情况需要过滤掉：</p>
<ul>
<li>tweet id 相同的行</li>
<li>无法被解析为 JSON 对象的行</li>
<li><code>id</code> 和 <code>id_str</code> 为空或者没有这两个域的行</li>
<li><code>created_at</code>、<code>text</code> 或 <code>entities</code> 为空或者直接没有这几个域的行</li>
</ul>
<p>还有一些需要注意的格式问题：</p>
<ul>
<li><code>Tweet_time</code> 的时间格式是 format:yyyy-MM-dd HH-mm-ss (UTC time, 24-hour clock)</li>
<li>在 ELT 阶段，换行符 ‘\n’ 应该被替换成两个符号 ‘\’ + ‘n’，而在返回请求时需要换回来</li>
<li>Tab 需要替换成空格</li>
</ul>
<p>了解了这些，就可以开始写代码了，这里我们暂时不考虑计算情感值和过滤敏感词的问题（具体可以考虑在 Reducer 里完成，这样不给 Mapper 太大负担）。这里多说两句，因为要考虑去重，可能直觉反应（刷题刷出来的）就是用 HashSet 之类的，小数据量没问题，但是数据量一大，内存轻轻松松不够用，注意考虑下用 O(1) 的方法来去重（利用 Reducer 已经排好序的特性）</p>
<p>写完代码之后可以本地测试一下，这里我的代码结构是这样的：</p>
<p><img src="/images/14576579118826.jpg" alt="代码结构"></p>
<p>其中 gson 和 data1K 分别是解析 json 和一个一千条的小数据集。因为代码中有引用其他类与依赖，所以编译和执行的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">$ javac Tweet.java Mapper.java -cp gson-<span class="number">2.6</span>.<span class="number">2</span>.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">$ java -cp gson-<span class="number">2.6</span>.<span class="number">2</span>.jar:./ Mapper</span><br></pre></td></tr></table></figure>
<p>这里的 <code>-cp</code> 就是 <code>classpath</code> 的意思，这样就可以正常引用了。结果如下：</p>
<p><img src="/images/14576581794601.jpg" alt="Mapper 结果"></p>
<p>（题外话，Twitter 上的各种小黄图小黄视频多不胜数，刚上车的同学可以按图索骥）</p>
<p>我们可以看到，因为设置了 utf-8 编码，基本上各种乱七八糟的字符都可以正常显示。其他就是具体代码编写的细节了，这里不再赘述。</p>
<p>不过具体到 EMR 上跑的时候还是有些需要注意的地方：</p>
<ul>
<li>用 java 1.7 编译</li>
<li>注意先用小数据集测试</li>
<li>小数据集通过测试也不代表大数据集没问题</li>
<li>具体如何使用 EMR，步骤可以参考<a href="http://wdxtub.com/2016/01/25/cc-10">云计算 第 10 课 Parallel Programming using EMR</a>，这里不再赘述</li>
</ul>
<p>处理完成数据之后记得大概查看一下有没有问题，本文暂时不涉及如何导入数据库（因为如何导入需要结合数据库的设计来弄）。</p>
<p>这一部分的内容有很多小的细节需要注意，大家在做的时候一定要细心（其实做任何特别耗时的工作之前都需要仔细检查）。</p>
<p>最后比较一下原始数据和 Mapper 之后数据的大小：</p>
<p><img src="/images/14576586987867.jpg" alt="大小比较"></p>
<p>少了非常多！但是这并不意味着写代码的时候可以太任性，一定要仔细思考在大数据量时候可能出现的问题！</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/AmazonS3.html" target="_blank" rel="external">Amazon Simple Storage Service (Amazon S3)</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一次我们需要利用 Map Reduce 处理大约 1T 的 Twitter 数据，并导入到对应的数据库中，这一部分因为奇奇怪怪的情况很多，所以一定要注意。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="EMR" scheme="http://wdxtub.com/tags/EMR/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="服务" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 Twitter 语料分析 4 Heartbeat 与 Authetication]]></title>
    <link href="http://wdxtub.com/2016/03/08/cc-p4/"/>
    <id>http://wdxtub.com/2016/03/08/cc-p4/</id>
    <published>2016-03-09T01:44:19.000Z</published>
    <updated>2016-03-09T04:37:59.000Z</updated>
    <content type="html"><![CDATA[<p>前面两课我们已经配置好了基本的环境，之后的任务都会在前面的基础上完成。因为主要会使用 undertow，所以我们制作了自己的镜像，用于对比的 vertx 则仍旧会以手动的方式进行配置。</p>
<a id="more"></a>
<hr>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>因为没有制作对应的镜像，所以需要重新配置一次，不过这次为了性能考虑，直接开启一个 <code>m4.large</code>，注意需要打上 <code>15619project:phase1</code> 标签。正常开启（记得要用小组的帐号）之后我们用<a href="http://wdxtub.com/2016/03/01/cc-p3/">Vert.x 配置部署</a>的步骤配置好基本的环境并检测运行，确认无误后可以继续。</p>
<p>这一部分的任务比较简单：每个请求都包含 key <code>Y</code> 和一段由 key <code>Z</code> 加密的文本，我们进行解密之后返回指定格式的内容（具体可以参考<a href="http://wdxtub.com/2016/02/25/cc-p1/#Query_1__28Heartbeat_and_Authentication_29">这里</a>）</p>
<h2 id="u9879_u76EE_u65E5_u5FD7"><a href="#u9879_u76EE_u65E5_u5FD7" class="headerlink" title="项目日志"></a>项目日志</h2><p>大概说一下步骤以及需要注意的地方：</p>
<p>要弄清楚 vert.x 如何处理诸如 <code>address/q1?key=40845969093821&amp;message=URYEXYBJB</code> 的请求，并在代码中获取到这两个参数：</p>
<p><img src="/images/14574935033615.jpg" alt="获取参数"></p>
<p>然后需要生成一个时间戳，并按照<a href="http://wdxtub.com/2016/02/25/cc-p1/#Query_1__28Heartbeat_and_Authentication_29">这里</a> 介绍的解密步骤还原出具体信息。</p>
<p>我们组把这部分功能代码封装成了一个类，使用的时候只需要传入 key 和 message 即可，而不用操心具体的算法问题（其实就类似于一个面试的算法题）。</p>
<p>然后我们按照具体的返回格式返回即可，类似下图</p>
<p><img src="/images/14574936621579.jpg" alt="返回结果"></p>
<p>这里有一点需要注意，每次会发送两次 GET 请求（其中一次是请求 favicon 的），要注意做一下错误处理，不然会报错，这还挺奇怪的，我用 safari 就没事，但是用 chrome 就不行，chrome 第二次请求就不带参数了，但是 safari 会带。</p>
<p>后来这个问题改成 80 端口即可，不过需要先 <code>sudo su</code> 才能监听。</p>
<p>因为这部分只是用来对比评测，所以没有进一步优化，大概能跑到 2W RPS 左右，而且是纯单线程，延迟会比较大，不过之后主要会在 undertow 上做，所以这里就不进一步优化了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面两课我们已经配置好了基本的环境，之后的任务都会在前面的基础上完成。因为主要会使用 undertow，所以我们制作了自己的镜像，用于对比的 vertx 则仍旧会以手动的方式进行配置。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Vertx" scheme="http://wdxtub.com/tags/Vertx/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="服务" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 习题课 5 Shelllab]]></title>
    <link href="http://wdxtub.com/2016/03/08/csapp-lab5/"/>
    <id>http://wdxtub.com/2016/03/08/csapp-lab5/</id>
    <published>2016-03-08T18:47:44.000Z</published>
    <updated>2016-03-10T00:41:08.000Z</updated>
    <content type="html"><![CDATA[<p>这次的作业，我们需要自己完成一个简单的 shell 程序，通过具体的实现，我们可以更加深入地计算机运行的机制（尤其是 Exceptional Control Flow 和进程）。</p>
<a id="more"></a>
<hr>
<p>在具体开始这次的试验之前，最好先复习一下基本概念（具体的细节可以参考前面的几课），这里放在文末的附录中。</p>
<p>这次的任务不简单！但是老师提供了很多辅助函数，确定先读懂已有代码再开始（注意代码风格），需要仔细查看的 man pages：</p>
<ul>
<li><code>sigemptyset()</code></li>
<li><code>sigaddset()</code></li>
<li><code>sigprocmask()</code></li>
<li><code>sigsuspend()</code></li>
<li><code>waitpid()</code></li>
<li><code>open()</code></li>
<li><code>dup2()</code></li>
<li><code>setpgid()</code></li>
<li><code>kill()</code></li>
</ul>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>先把文件上传到学校的机器中 <code>scp tshlab-handout.tar dawang@shark.ics.cs.cmu.edu:~/513</code>，然后登录上去 <code>ssh -X dawang@shark.ics.cs.cmu.edu</code>，登录成功后解压 <code>tar xvf tshlab-handout.tar</code></p>
<p>因为我比较习惯在本地写代码，所以把文件复制回来：</p>
<ul>
<li>服务器至本地<ul>
<li><code>scp -r dawang@shark.ics.cs.cmu.edu:~/513/tshlab-handout/* ./</code></li>
</ul>
</li>
<li>本地至服务器<ul>
<li><code>scp ./tsh.c dawang@shark.ics.cs.cmu.edu:~/513/tshlab-handout/</code></li>
</ul>
</li>
</ul>
<p>然后需要在 <code>tsh.c</code> 中填写 Andrew ID，这个文件中已经包含了一个基本的 shell 程序，但是还有很多东西没有完成，我们的任务是补全下列空函数：</p>
<ul>
<li><code>void eval(char *cmdline)</code>：解析命令与执行，约 300 行</li>
<li><code>void sigchld_handler(int sig)</code>：捕获 SIGCHLD 信号</li>
<li><code>void sigtstp_handler(int sig)</code>：捕获 SIGTSTP(ctrl-z) 信号</li>
<li><code>void sigint_handler(int sig)</code>：捕获 SIGINT(ctrl-c) 信号</li>
</ul>
<p>测试的时候先 <code>make</code> 然后 <code>./tsh</code> 即可，不过一开始好像没办法退出</p>
<h2 id="Shell__u7B80_u4ECB"><a href="#Shell__u7B80_u4ECB" class="headerlink" title="Shell 简介"></a>Shell 简介</h2><p>简单来说，shell 有两种执行模式：</p>
<ol>
<li>如果用户输入的命令是内置命令，那么 shell 会直接在当前进程执行（例如 <code>jobs</code>）</li>
<li>如果用户输入的是一个可执行程序的路径，那么 shell 会 fork 出一个新进程，并且在这个子进程中执行该程序（例如 <code>/bin/ls -l -d</code>）</li>
</ol>
<p>第二种情况中，每个子进程称为一个 job（当然也可以不止一个，通过管道机制，不过我们这里的实现不需要考虑管道）</p>
<p>如果命令以 <code>&amp;</code> 结束，那么这个 job 会在后台执行（比如 <code>/bin/ls -l -d &amp;</code>），也就是说 shell 本身不会等待 job 执行完成，直接可以继续输入其他命令；而在其他情况下，则是在前台运行，shell 会等待 job 完成，用户才可以继续输入命令。也就是说同一个时间只可能有一个前台任务，但是后台任务可以有任意多个。</p>
<p>程序的入口是 <code>int main(int argc, char *argv[])</code>，对于 <code>/bin/ls -l -d</code> 来说，我们有：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">argc</span> == <span class="number">3</span></span><br><span class="line"><span class="built_in">argv</span>[<span class="number">0</span>] == <span class="string">''</span>/bin/<span class="keyword">ls</span><span class="string">''</span></span><br><span class="line"><span class="built_in">argv</span>[<span class="number">1</span>] == <span class="string">''</span>-<span class="keyword">l</span><span class="string">''</span></span><br><span class="line"><span class="built_in">argv</span>[<span class="number">2</span>] == <span class="string">''</span>-<span class="keyword">d</span><span class="string">''</span></span><br></pre></td></tr></table></figure>
<p>另外两个需要支持功能是：</p>
<ul>
<li>job control：允许用户更改进程的前台/后台状态以及京城的状态(running, stopped, or terminated)<ul>
<li>ctrl-c 会触发 SIGINT 信号并发送给每个前台进程，默认的动作是终止该进程</li>
<li>ctrl-z 会触发 SIGTSTP 信号并发送给每个前台进程，默认的动作是挂起该进程，直到再收到 SIGCONT 信号才继续</li>
<li><code>jobs</code> 命令会列出正在执行和被挂起的后台任务</li>
<li><code>bg job</code> 命令可以让一个被挂起的后台任务继续执行</li>
<li><code>fg job</code> 命令可以让一个被挂起的前台任务继续执行</li>
</ul>
</li>
<li>I/O redirection：重定向输入输出<ul>
<li><code>tsh&gt; /bin/ls &gt; foo</code></li>
<li><code>tsh&gt; /bin/cat &lt; foo</code></li>
</ul>
</li>
</ul>
<h2 id="u4EFB_u52A1_u76EE_u6807"><a href="#u4EFB_u52A1_u76EE_u6807" class="headerlink" title="任务目标"></a>任务目标</h2><p>我们正在使用的 shell 其实包含很多复杂的功能，不过我们自己写的 shell 就简单很多，这里总结一下具体的实现规格：</p>
<ul>
<li>每一行会输出一个 <code>tsh&gt;</code>，然后等待用户输入</li>
<li>用户的输入包括 <code>name</code> 加上零个或多个参数，这些参数之间用一个或多个空格分隔。如果 <code>name</code> 是内置命令，那么直接执行，否则需要新建一个子进程，并在子进程中完成具体的工作</li>
<li>不需要支持管道，但是需要支持输入输出重定向，如 <code>tsh&gt; /bin/cat &lt; foo &gt; bar</code>（必须支持在同一行重定向输入以及输出）<ul>
<li>也需要支持内置命令的重定向，如 <code>tsh&gt; jobs &gt; foo</code> </li>
</ul>
</li>
<li>输入 <code>ctrl-c</code> 或 <code>ctrl-z</code> 会给当前的前台进程（包括其子进程）发送 SIGINT(SIGTSTP) 信号，如果没有前台任务，那么这俩信号没有任何效果</li>
<li>如果输入的命令以 <code>&amp;</code> 结尾，那么就要以后台任务的方式执行，否则按照前台执行</li>
<li>每个 job 都有其进程 ID(PID) 和 job ID(JID)，都是由 tsh 指定的正整数，JID 以 <code>%</code> 开头（如 <code>%5</code> 表示 JID 为 5，而 <code>5</code> 则表示 PID 为 5），这部分已提供了辅助函数</li>
<li>支持的内置命令有<ul>
<li><code>quit</code> 退出 shell</li>
<li><code>jobs</code> 列出所有的后台任务</li>
<li><code>bg job</code> 给后台 <code>job</code> 发送 SIGCONT 信号来继续执行该任务，具体的 <code>job</code> 数值可以是 PID 或 JID</li>
<li><code>fg job</code> 给前台 <code>job</code> 发送 SIGCONT 信号来继续执行该任务，具体的 <code>job</code> 数值可以是 PID 或 JID</li>
</ul>
</li>
<li>tsh 应该回收所有的僵尸进程，如果任何 job 因为接收了没有 catch 的信号而终止，tsh 应该识别出这个时间并且打印出 JID 和相关信号的信息</li>
</ul>
<h2 id="u6D4B_u8BD5_u65B9_u6CD5"><a href="#u6D4B_u8BD5_u65B9_u6CD5" class="headerlink" title="测试方法"></a>测试方法</h2><p>最简单（也是首先应该做的）是直接运行 tsh，然后输入命令试试看。如果需要参考，可以试试 <code>tshref</code> 这个程序。确定无误之后可以进行完整测试。</p>
<p>这里我们用 trace 文件来测试，具体使用命令 <code>./runtrace</code> 来测试，具体用法如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">./runtrace -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试某个特性</span></span><br><span class="line">./runtrace <span class="operator">-f</span> trace05.txt <span class="operator">-s</span> ./tsh</span><br></pre></td></tr></table></figure>
<p>如果想要进行完整的测试，可以使用 <code>./sdriver</code>，具体用法如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">./sdriver -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般来说可以直接使用默认设置测试</span></span><br><span class="line">./sdriver</span><br></pre></td></tr></table></figure>
<p>只需要提交 <code>tsh.c</code> 即可，系统会自动评分，具体每个文件在测试的内容是：</p>
<p><img src="/images/14575490108688.jpg" alt="trace 文件内容"></p>
<h2 id="u63D0_u793A"><a href="#u63D0_u793A" class="headerlink" title="提示"></a>提示</h2><ul>
<li>不要使用 <code>sleep()</code> 来同步</li>
<li>不要使用忙等待 <code>while(1);</code></li>
<li>使用 <code>sigsuspend</code> 来同步</li>
<li>竞争条件</li>
<li>僵尸进程回收（注意竞争条件以及正确处理信号）</li>
<li>等待前台任务（仔细思考怎么样才是好的方式）</li>
<li>不要假定进程的执行顺序</li>
<li>子进程挂掉的时候应该在一个限定时间内被回收</li>
<li>不要在多个地方调用 <code>waitpid</code>，很容易造成竞争条件，也会造成程序过分复杂</li>
<li>不要使用任何系统调用来管理 terminal group</li>
<li><code>waitpid</code>, <code>kill</code>, <code>fork</code>, <code>execve</code>, <code>setpgid</code>, <code>sigprocmask</code> 和 <code>sigsuspend</code> 都非常有用，<code>waitpid</code> 中的 WUNTRACED 和 WNOHANG 选项也是如此。</li>
<li>遇到不清晰的用 <code>man</code> 来查看细节</li>
<li>实现 signal handler 的时候注意给全部的前台进程组发送 SIGINT 和 SIGTSTP 信号</li>
<li>在 <code>kill</code> 函数中使用 <code>-pid</code> 的格式作为参数</li>
<li>在 shell 等待前台工作完成时，需要决定在 <code>eval</code> 及 <code>sigchold handler</code> 具体的分配，这里有一定技巧</li>
<li>在函数 <code>eval</code> 中，在 fork 出子进程之前，必须使用 <code>sigprocmask</code> 来阻塞 SIGCHLD, SIGINT 和 SIGTSTP 信号，完成之后再取消阻塞。调用 <code>addjob</code> 的时候也需要如此。注意，因为子进程也继承了之前的各种状态，所以在子进程中调用 <code>exec</code> 执行新程序的时候注意需要取消阻塞，同样也需要恢复默认的 handler（shell 本身已经忽略了这些信号），具体可以看书本的 8.5.6 节</li>
<li>不要使用 <code>top</code>, <code>less</code>, <code>vi</code>, <code>emacs</code> 之类的复杂程序，使用简单的文本程序如：<code>/bin/cat</code>, <code>/bin/ls</code>, <code>/bin/ps</code>, <code>/bin/echo</code></li>
<li>因为毕竟不是真正的 shell，所以在 fork 之后，execve 之前，子进程需要调用 <code>setpgid(0, 0)</code>，这样就把子进程放到一个新的进程组里。这样就保证我们的 shell 前台进程组中唯一的进程，当按下 ctrl-c 时，应该捕获 SIGINT 信号并发送给对应的前台进程组中。</li>
</ul>
<p>同样提供一个 <code>tshref</code> 参考程序来作为比对输出（除了进程 id 之外其他需要一模一样），具体是通过 <code>runtrace</code> 文件来测试，每个 trace 文件会测试一个特性</p>
<h2 id="u89E3_u9898_u653B_u7565"><a href="#u89E3_u9898_u653B_u7565" class="headerlink" title="解题攻略"></a>解题攻略</h2><p>最开始当时是要先读懂代码，尤其是整个程序到底在干什么，如果有仔细看我前面的介绍和课本的话，应该比较轻松能找到对应（毕竟这是一个简化的版本），所以这里废话不多说，直接开始完成基础工作。我们先来看看如何改动 <code>eval</code> 这个函数。</p>
<p>在这个函数中，我们会先解析命令（具体的解析已经有工具函数），然后得到一系列 token，结构如下</p>
<p><img src="/images/14575497659305.jpg" alt="token 的结构"></p>
<p>目前来说，对我们最有用的是这里面的枚举类型，我们可以先用这个来判断是否是内置函数，据此来决定走哪条分支。我们先把最基本的退出功能做了，这样就不会出现一旦开始就没办法结束的情况，具体方法也很简单，直接 <code>exit(0);</code> 即可，我们测试一下，发现已经可以正确退出了：</p>
<p><img src="/images/14575502436640.jpg" alt="退出程序"></p>
<p>接着我们来实现 <code>jobs</code> 这个命令，因为已经提供了 <code>listjobs</code> 这个函数，所以我们直接围绕着这个函数来做文章即可。留意到 token 结构体中有 <code>infile</code> 和 <code>outfile</code> 两项，这个就是用来重定向的判断（我们不需要担心解析的问题，可以直接用）。同样，我们来判断一下有没有 <code>outfile</code>，对应进行处理即可。注意输出的时候如果不需要重定向，那么就输出到 stdout，如果需要重定向，就输出到对应的 file descriptor 中（打开文件的时候需要设定 flag，具体可以 <code>man open</code> 进行查看）。</p>
<p>接着我们来实现 FG 和 BG 这两个命令，我们需要注意的地方有两个，一个是先根据判断传入的是 JID 还是 PID，然后发送信号之后需要等待进程完成（这里注意使用 <code>sigsuspend</code>）。</p>
<p>这里需要注意 <code>.</code> 和 <code>-&gt;</code> 这两个操作符的不同，简单来说，就是如果左边是一个指向结构体的指针，那么就要用 <code>-&gt;</code>；如果是一个结构体，那么就要用 <code>.</code>。</p>
<p>这些做完之后我们可以先来简单测试一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./runtrace <span class="operator">-f</span> trace00.txt <span class="operator">-s</span> ./tsh</span><br><span class="line">./runtrace <span class="operator">-f</span> trace00.txt <span class="operator">-s</span> ./tshref</span><br><span class="line">./runtrace <span class="operator">-f</span> trace01.txt <span class="operator">-s</span> ./tsh</span><br><span class="line">./runtrace <span class="operator">-f</span> trace01.txt <span class="operator">-s</span> ./tshref</span><br></pre></td></tr></table></figure>
<p><img src="/images/14575550290784.jpg" alt="测试结果"></p>
<p>看到和参考程序输出至少是一致的，我们就可以继续了。</p>
<p>接着我们需要来处理非内置命令的情况，参考课件中的代码，先把需要用到的 mask 之类的弄好，并且我们暂时不考虑重定向的问题。然后需要把对应的 signal handler 补充完整。</p>
<p>这之后我们可以来跑一次测试 <code>./sdriver</code>，最后的得分是 60/100，第一个错误出现在 trace08.txt 这个文件中，查表得知是发送 fatal SIGINT 给前台进程。我自己用 <code>./runtrace -f trace08.txt -s ./tsh</code> 测试了几次，发现有时候可以正确输出，有时候则会超时，说明是处理进程同步的时候出了问题。经过检查发现，阻塞信号的时候需要阻塞全部信号（之前我只阻塞了 SIGCHLD 会出问题），再测试的话，发现已经有了 80/100 分。</p>
<p>继续看看哪里出了问题，在输出的日志中寻找最先出错的地方，发现是 trace22.txt，功能是 I/O redirection(input)，这就对了，毕竟我们还没写这个功能。</p>
<p>我们现在就来写一下。不过在此之前，回答一下前面的问题，前面提到过：</p>
<blockquote>
<p>在 shell 等待前台工作完成时，需要决定在 <code>eval</code> 及 <code>sigchold handler</code> 具体的分配，这里有一定技巧</p>
</blockquote>
<p>那么技巧是什么呢？其实很简单，就是都在 eval 里做，handler 尽量短小精悍。</p>
<p>好，我们继续来做输入输出重定向，同样分为内置函数与其他两个类型，内置函数唯一需要输出的是 <code>jobs</code> 这个函数，不过我们之前已经处理过，这里暂且不管（出问题再说）。所以把主要精力集中在非内置的函数上。具体应该在 <code>setpgid(0,0)</code> 这句之后，且应该在 <code>execve</code> 之前。具体的操作也比较简单，就是打开文件（只读），然后利用 <code>dups</code> 重定向到 STDIN 中即可。对于输出的情况也是类似的，这里不赘述。唯一需要注意的一点是打开文件时候的 flag，设置错误会导致没办法正确重定向。</p>
<p>改完错误之后发现 trace15.txt 又出错了，而且经过测试发现死锁的问题还在，而且是内置函数的问题（果然一开始有小问题），后来发现是搞错了一个变量（但是仍旧有小概率会出现死锁，不过提交的时候似乎一切正常）</p>
<p>最后需要注意的是有些测试会直接修改源代码，所以每次都需要重新解压（还是蛮讨厌的）。总体来说只要理解了整个过程就不算太难，使用 <code>csapp.h</code> 的时候可能需要把代码复制到 <code>tsh.c</code> 中。</p>
<h2 id="u9644_u5F551_3A__u4E2D_u6587_man__u6587_u6863"><a href="#u9644_u5F551_3A__u4E2D_u6587_man__u6587_u6863" class="headerlink" title="附录1: 中文 man 文档"></a>附录1: 中文 man 文档</h2><p>如果觉得看英文太累（虽然建议看英文），可以使用中文的 man 文档，具体的使用步骤如下：</p>
<p>在<a href="http://manpages-zh.googlecode.com/files/manpages-zh-1.5.1.tar.gz" target="_blank" rel="external">这里</a>下载安装包，然后通过如下命令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf manpages-zh-<span class="number">1.5</span>.<span class="number">1</span>.tar.gz</span><br><span class="line"><span class="built_in">cd</span> manpages-zh-<span class="number">1.5</span>.<span class="number">1</span></span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/zhman --disable-zhtw</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>在 Mac 上会乱码，所以需要安装 groff，具体命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install homebrew/dupes/groff</span><br></pre></td></tr></table></figure>
<p>然后打开 <code>/etc/man.conf</code>，把 <code>NROFF</code> 的那一行改为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NROFF preconv <span class="operator">-e</span> UTF8 | /usr/<span class="built_in">local</span>/bin/nroff -Tutf8 -mandoc -c</span><br></pre></td></tr></table></figure>
<p>最后我么加一个别名，方便使用（根据自己使用的 shell 来针对改，bash 的话是 ~/.bashrc，zsh 的话是 ~/.zshrc），在文件中加入这么一句：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias cman='<span class="keyword">man</span> -<span class="keyword">M</span> /usr/<span class="keyword">local</span>/zhman/share/<span class="keyword">man</span>/zh_CN'</span><br></pre></td></tr></table></figure>
<p>然后 <code>source .zshrc</code> 启用，我们就可以通过 <code>cman</code> 命令来查看了，比如说输入 <code>cman kill</code>，就可以看到</p>
<p><img src="/images/14575529137049.jpg" alt="效果"></p>
<p>大功告成。</p>
<h2 id="u9644_u5F552_3A__u57FA_u7840_u77E5_u8BC6"><a href="#u9644_u5F552_3A__u57FA_u7840_u77E5_u8BC6" class="headerlink" title="附录2: 基础知识"></a>附录2: 基础知识</h2><p>开始之前需要理解的内容</p>
<h3 id="u5F02_u6B65_u5F02_u5E38_28_u4E2D_u65AD_29"><a href="#u5F02_u6B65_u5F02_u5E38_28_u4E2D_u65AD_29" class="headerlink" title="异步异常(中断)"></a>异步异常(中断)</h3><p><img src="/images/14574791971112.jpg" alt="Asynchronous Exceptions(Interrupts)"></p>
<h3 id="u540C_u6B65_u5F02_u5E38"><a href="#u540C_u6B65_u5F02_u5E38" class="headerlink" title="同步异常"></a>同步异常</h3><p><img src="/images/14574792452633.jpg" alt="Synchronous Exceptions"></p>
<h3 id="u8FDB_u7A0B"><a href="#u8FDB_u7A0B" class="headerlink" title="进程"></a>进程</h3><p><img src="/images/14574793369863.jpg" alt="Definition"></p>
<p><img src="/images/14574793444040.jpg" alt="Four basic States"></p>
<p><img src="/images/14574793738605.jpg" alt="Control States"></p>
<p>fork 函数详细介绍：</p>
<p><img src="/images/14574794567977.jpg" alt="fork"></p>
<p><img src="/images/14574794700303.jpg" alt="fork"></p>
<p>exec 函数详细介绍</p>
<p><img src="/images/14574794860146.jpg" alt="exec"></p>
<p>exit 函数详细介绍</p>
<p><img src="/images/14574795006407.jpg" alt=""></p>
<p>wait 函数详细介绍</p>
<p><img src="/images/14574795185122.jpg" alt=""></p>
<h3 id="u7B80_u5355_u7684_u8FDB_u7A0B_u4F8B_u5B50"><a href="#u7B80_u5355_u7684_u8FDB_u7A0B_u4F8B_u5B50" class="headerlink" title="简单的进程例子"></a>简单的进程例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (child_pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 这部分只有子进程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Child!\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 父进程通过下面这句等待子进程完成，才继续执行</span></span><br><span class="line">    waitpid(child_pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Parent!\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个使用 execvc 的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"><span class="keyword">char</span>* argv[] = &#123;<span class="string">"/bin/ls"</span>, <span class="string">"-l"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="keyword">char</span>* env[] = &#123;..., <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (child_pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 这部分只有子进程执行</span></span><br><span class="line">    execve(<span class="string">"/bin/ls"</span>, argv, env);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为已经被取代，所以 execve 之后的语句将不会被执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 父进程通过下面这句等待子进程完成，才继续执行</span></span><br><span class="line">    waitpid(child_pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 等待子进程结束之后继续执行父线程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Parent!\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u4FE1_u53F7"><a href="#u4FE1_u53F7" class="headerlink" title="信号"></a>信号</h3><p><img src="/images/14574798651564.jpg" alt="Three possible ways to react"></p>
<p><img src="/images/14574798879407.jpg" alt="Ohter Reaction Options"></p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.yurendu.com/read/install-man-command-chinese-help-documentation-on-mac-and-linux.html" target="_blank" rel="external">Mac/Linux 安装man命令的中文帮助文档</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这次的作业，我们需要自己完成一个简单的 shell 程序，通过具体的实现，我们可以更加深入地计算机运行的机制（尤其是 Exceptional Control Flow 和进程）。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Shelllab" scheme="http://wdxtub.com/tags/Shelllab/"/>
    
      <category term="习题课" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98%E8%AF%BE/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 15 课 System Level I/O]]></title>
    <link href="http://wdxtub.com/2016/03/06/csapp-15/"/>
    <id>http://wdxtub.com/2016/03/06/csapp-15/</id>
    <published>2016-03-06T12:47:39.000Z</published>
    <updated>2016-03-08T18:45:12.000Z</updated>
    <content type="html"><![CDATA[<p>了解完了 Exceptional Control Flow，我们再来看看系统级 IO 的相关内容，完成这一课之后，就可以开始写我们自己的 shell 程序了。</p>
<a id="more"></a>
<hr>
<h2 id="Unix_I/O"><a href="#Unix_I/O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p>在 Linux 中，文件实际上可以看做是字节的序列。更有意思的是，所有的 I/O 设备也是用文件来表示的，比如：</p>
<ul>
<li><code>./dev/sda2</code> (<code>/usr</code> disk partition)</li>
<li><code>/dev/tty2</code> (terminal)</li>
</ul>
<p>甚至连内核也是用文件来表示的：</p>
<ul>
<li><code>/boot/vmlinuz-3.13.0-55-generic</code> (kernel image)</li>
<li><code>/proc</code> (kernel data structures)</li>
</ul>
<p>因为 I/O 设备也是文件，所以内核可以利用称为 Unix I/O 的简单接口来处理输入输出，比如：</p>
<p><img src="/images/14574522789531.jpg" alt="Unix I/O Overview"></p>
<p>为了区别不同文件的类型，会有一个 <code>type</code> 来进行区别：</p>
<ul>
<li>普通文件：包含任意数据</li>
<li>目录：相关一组文件的索引</li>
<li>Socket：和另一台机器上的进程通信的类型</li>
</ul>
<p>其实还有一些比较特别的类型，但是这里提一下，不深入了解：</p>
<ul>
<li>Named pipes(FIFOs)</li>
<li>Symbolic links</li>
<li>Character and block devices</li>
</ul>
<h3 id="Regular_File"><a href="#Regular_File" class="headerlink" title="Regular File"></a>Regular File</h3><p>普通的文件包含任意数据，应用一般来说需要区分出 text files 和 binary files。文本文件只包含 ASCII 或 Unicode 字符。除此之外的都是 binary files(object files, JPEG images, etc)。对于内核来说其实并不能区分出个中的区别。</p>
<p>文本文件就是一系列的文本行，每行以 <code>\n</code> 结尾，新的一行是 <code>0xa</code>，和 ASCII 码中的 line feed 字符(LF) 一样。不同系统用用判断一行结束的符号不同(End of line, EOL)，如：</p>
<ul>
<li>Linux &amp; Mac OS: <code>\n</code>(0xa)<ul>
<li>line feed(LF) </li>
</ul>
</li>
<li>Windows &amp; Internet protocols: <code>\r\n</code> (0xd 0xa)<ul>
<li>Carriage return(CR) followed by line feed(LF)</li>
</ul>
</li>
</ul>
<h3 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a>目录</h3><p>目录包含一个 link 数组，并且每个目录至少包含两条记录：</p>
<ul>
<li><code>.</code>(dot) 当前目录</li>
<li><code>..</code>(dot dot) 上一层目录</li>
</ul>
<p>用来操作目录的命令主要有 <code>mkdir</code>, <code>ls</code>, <code>rmdir</code></p>
<p>目录是以树装结构组织的，跟目录是 <code>/</code>(slash)</p>
<p><img src="/images/14574529458797.jpg" alt="Directory Hierarchy"></p>
<p>内核会为每个进程保存 current working directory (cwd)，可以用 <code>cd</code> 命令来进行更改。</p>
<p>我们通过路径名来确定文件的位置，一般分为绝对路径和相对路径。</p>
<h3 id="u64CD_u4F5C_u6587_u4EF6"><a href="#u64CD_u4F5C_u6587_u4EF6" class="headerlink" title="操作文件"></a>操作文件</h3><p>接下来我们了解一下基本的文件操作。</p>
<p>在使用文件之前需要通知内核打开该文件：</p>
<p><img src="/images/14574530910656.jpg" alt="Opening Files"></p>
<p>返回值是一个小的整型称为 file descriptor（如果这个值等于 -1 则说明发生了错误）。每个由 Linux sheel 创建的进程都会默认打开三个文件：</p>
<ul>
<li>0: standard input(stdin)</li>
<li>1: standard output(stdout)</li>
<li>2: standar error(stderr)</li>
</ul>
<p>使用完毕之后同样需要通知内核关闭文件：</p>
<p><img src="/images/14574532174613.jpg" alt="Closing Files"></p>
<p>如果在此关闭已经关闭了的文件，会出大问题。所以一定要检查返回值，哪怕是 <code>close()</code> 函数（如上面的例子所示）</p>
<p>在打开和关闭之间就是读取文件，实际上就是把文件中对应的字节复制到内存中，并更新文件指针：</p>
<p><img src="/images/14574533193683.jpg" alt="Reading Files"></p>
<p>返回值是读取的字节数量，是一个 <code>ssize_t</code> 类型（其实就是一个 signed integer），如果 <code>nbytes &lt; 0</code> 那么表示出错。<code>nbytes &lt; sizeof(buf)</code> 这种情况(short counts) 是可能发生的，而且并不是错误。</p>
<p>写入文件是把内存中的数据复制到文件中，并更新文件指针：</p>
<p><img src="/images/14574534505640.jpg" alt="Wrting Files"></p>
<p>返回值是写入的字节数量，如果 <code>nbytes &lt; 0</code> 那么表示出错。<code>nbytes &lt; sizeof(buf)</code> 这种情况(short counts) 是可能发生的，而且并不是错误。</p>
<p>综合上面的操作，我们可以来看看 Unix I/O 的例子：</p>
<p><img src="/images/14574535145592.jpg" alt="Copying stdin to stdout, one byte at a time"></p>
<p>前面提到的 short count 会在下面的情形下发生：</p>
<ul>
<li>在读取的时候遇到 EOF(end-of-file)</li>
<li>从终端中读取文本行</li>
<li>读取和写入网络 sockets</li>
</ul>
<p>但是在下面的情况下不会发生</p>
<ul>
<li>从磁盘文件中读取（除 EOF 外）</li>
<li>写入到磁盘文件中</li>
</ul>
<p>最好总是允许 short count，这样就可以避免处理这么多不同的情况。</p>
<h2 id="Robust_I/O"><a href="#Robust_I/O" class="headerlink" title="Robust I/O"></a>Robust I/O</h2><p>RIO 实际上就是一个包装，用来在不同的应用中提供强壮的 IO 接口，主要有一下两类：</p>
<p><img src="/images/14574544870012.jpg" alt="The RIO Package"></p>
<p>可以从<a href="http://csapp.cs.cmu.edu/3e/code.html" target="_blank" rel="external">这里</a> 中下载（<code>src/csapp.c</code> 和  <code>include/csapp.h</code>）</p>
<p>无缓存的输入输出和 Unix 的 <code>read</code> 和 <code>write</code> 接口一致，如果要通过 network sockets 来传输数据，就非常拥有了：</p>
<p><img src="/images/14574546347971.jpg" alt="Unbuffered ROI Input and Output"></p>
<p>具体的实现是：</p>
<p><img src="/images/14574547191767.jpg" alt="Implementation of `rio_readn`"></p>
<p>有缓存的输入在从文件中读取数据的时候通过内置的内存缓冲区提高效率：</p>
<p><img src="/images/14574547952581.jpg" alt="Buffered RIO Input Functions"></p>
<p><img src="/images/14574548277481.jpg" alt=""></p>
<p>具体的实现如下：</p>
<p><img src="/images/14574548545398.jpg" alt="Buffered I/O: Implementation"></p>
<p>对应的结构体是：</p>
<p><img src="/images/14574549507104.jpg" alt=""></p>
<p>这是一个对应的例子：</p>
<p><img src="/images/14574549871674.jpg" alt="Copying the lines of a text file from standar input to standard output"></p>
<h2 id="Metadata_2C_Sharing__26amp_3B_Redirection"><a href="#Metadata_2C_Sharing__26amp_3B_Redirection" class="headerlink" title="Metadata, Sharing &amp; Redirection"></a>Metadata, Sharing &amp; Redirection</h2><p>元数据是用来描述数据的数据，由内核维护，可以通过 <code>stat</code> 和 <code>fstat</code> 函数来访问，其结构是：</p>
<p><img src="/images/14574550707059.jpg" alt="File Metadata"></p>
<p>对应的访问例子：</p>
<p><img src="/images/14574551947810.jpg" alt="Example of Accessing File Metadata"></p>
<p>了解了具体的结构之后，我们来看看内核是如何表示打开的文件的。其实过程很简单，每个进程都有自己的 Descriptor table，然后 Descriptor 1 指向终端，Descriptor 4 指向磁盘文件，如下图所示：</p>
<p><img src="/images/14574553689850.jpg" alt="How the Unix Kernel Represents Open Files"></p>
<p>两个不同的 descriptors 通过两个不同的 open file 记录来共享同一个磁盘文件（对应指向同一个 v-noe table）。</p>
<p>这里有一个需要说明的情况，就是使用 <code>fork</code>。子进程实际上是会继承父进程打开的文件，在调用 <code>fork</code> 之前，我们假设情况是这样的：</p>
<p><img src="/images/14574555865284.jpg" alt="Before fork call"></p>
<p>在 fork 之后，子进程实际上和父进程的指向是一样的，这里需要注意的是会把 <code>refcnt</code> 加上 1（也就是引用计数加 1）</p>
<p><img src="/images/14574556597788.jpg" alt="After fork"></p>
<p>了解了这个，我们我们就可以知道所谓的重定向是怎么实现的了。其实很简单，只要调用 <code>dup2(oldfd, newfd)</code> 函数即可。具体如下：</p>
<p><img src="/images/14574609050965.jpg" alt="I/O Redirection"></p>
<p>Step #1: open file to which stdout should be redirected(happends in child executing shell code, before <code>exec</code>)</p>
<p><img src="/images/14574609981392.jpg" alt="Step #1: open file to which stdout should be redirected"></p>
<p>Step #2: call <code>dup2(4,1)</code> -&gt; cause fd=1(stdout) to refer to disk file pointed at fd=4</p>
<p><img src="/images/14574613741105.jpg" alt="Step #2: call `dup2(4,1)`"></p>
<h2 id="Standar_I/O"><a href="#Standar_I/O" class="headerlink" title="Standar I/O"></a>Standar I/O</h2><p>C 标准库中包含一系列高层的标准 IO 函数，一些具体的函数：</p>
<p><img src="/images/14574614463046.jpg" alt="Examples of standard I/O functions"></p>
<p>标准 IO 会用流的形式打开文件，所谓流(stream)实际上是 file descriptor 和 buffer 在内存中的抽象。C 程序一般以三个流开始，如下所示：</p>
<p><img src="/images/14574615606437.jpg" alt="Standard I/O Streams"></p>
<p>接下来我们详细了解一下为什么需要使用缓冲区，程序经常会一次读入或者写入一个字符，比如 <code>getc</code>, <code>putc</code>, <code>ungetc</code>，同时也会一次读入或者写入一行，比如 <code>gets</code>, <code>fgets</code>。如果用 Unix I/O 的方式来进行调用，是非常昂贵的，比如说 <code>read</code> 和 <code>write</code> 因为需要内核调用，需要大于 10000 个时钟周期。</p>
<p>解决的办法就是利用 <code>read</code> 函数一次读取一块数据，然后再由高层的接口，一次从缓冲区读取一个字符（当缓冲区用完的时候需要重新填充），例如：</p>
<p><img src="/images/14574622326310.jpg" alt="Buffering in Standard I/O"></p>
<p>具体来看看这个例子：</p>
<p><img src="/images/14574622882078.jpg" alt="Standard I/O Buffering in Action"></p>
<p>注意右边的输出，实际上只写入了一次，一次六个字符，而不是程序中写的六次（这里好好感受下）</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>前面介绍了几种不同的 IO，它们的层级如下所示：</p>
<p><img src="/images/14574624849987.jpg" alt="Unix I/O vs. Standard I/O vs. RIO"></p>
<p>Unix I/O 的优劣：</p>
<p><img src="/images/14574625259926.jpg" alt="Pros and Cons of Unix I/O"></p>
<p>Standard I/O 的优劣：</p>
<p><img src="/images/14574625620916.jpg" alt="Pros and Cons of Standard I/O"></p>
<p>具体的选择建议为：</p>
<p><img src="/images/14574626154586.jpg" alt="Choosing I/O Functions"></p>
<p>最后是处理 binary files 的守则：</p>
<p><img src="/images/14574626867246.jpg" alt="Working with Binary Files"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解完了 Exceptional Control Flow，我们再来看看系统级 IO 的相关内容，完成这一课之后，就可以开始写我们自己的 shell 程序了。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="IO" scheme="http://wdxtub.com/tags/IO/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 14 课 Signals and Nonlocal Jumps]]></title>
    <link href="http://wdxtub.com/2016/03/06/csapp-14/"/>
    <id>http://wdxtub.com/2016/03/06/csapp-14/</id>
    <published>2016-03-06T12:47:36.000Z</published>
    <updated>2016-03-07T21:53:55.000Z</updated>
    <content type="html"><![CDATA[<p>了解完了异常与进程，异常处理中另外两个很重要的部分是信号和非局部跳转，也就是我们这节课要介绍的内容。</p>
<a id="more"></a>
<hr>
<p>Linux 的进程树，可以通过 <code>pstree</code> 命令查看，如下：</p>
<p><img src="/images/14573806185809.jpg" alt="Linux Process Hierarchy"></p>
<p>我们以 shell 为例子，来看看整个过程是如何实现的：</p>
<p><img src="/images/14573806718703.jpg" alt="Shell: Execution is a sequence of read/evaluate steps"></p>
<p><img src="/images/14573807472000.jpg" alt="Simple Shell eval Function"></p>
<p>如果只有前台进程的话，我们的 shell 可以在前台工作完成之后进行回收。但是后台进程则会在终止之后成为僵尸进程，不会被回收并且造成内存泄露。</p>
<p>这怎么办呢？同样可以利用 Exceptional control flow，当后台进程完成时，内核会中断常规执行并通知我们，具体的通知机制就是『信号』(signal)。</p>
<h2 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h2><blockquote>
<p>A signal is a small message that notifies a process that an event of some type has occurred in the system</p>
</blockquote>
<p>这样看来，其实是类似于 exception 和 interrupt 的，是由内核（在其他进程的请求下）向当前进程发出的。信号的类型由 1-30 的整数定义，信号所能携带的信息极少，一是对应的编号，二就是信号到达这个事实。下面是几个比较常用的信号的编号及简介：</p>
<p><img src="/images/14573811635888.jpg" alt=""></p>
<blockquote>
<p>Kernel sends a signal to a destination process by updating some state in the context of the destination process</p>
</blockquote>
<p>在下面两个场景中，内核会发送信号：</p>
<ul>
<li>内核检测到了如除以零(SIGFPE)或子进程终止(SIGCHLD)的系统事件</li>
<li>另一个进程调用了 <code>kill</code> 指令来请求内核发送信号给指定的进程</li>
</ul>
<blockquote>
<p>A destination process receives a signal when it is forced by the kernel to react in some way to the delivery of the signal</p>
</blockquote>
<p>一个进程在接收到了信号之后，可以有几种不同的操作：</p>
<ul>
<li><strong>忽略</strong>这个型号</li>
<li><strong>终止</strong>进程</li>
<li><strong>捕获</strong>信号，通过执行 signal handler 完成（类似于异步中断中的 exception handler）</li>
</ul>
<p>具体的过程如下：</p>
<p><img src="/images/14573814877982.jpg" alt=""></p>
<blockquote>
<p>A signal is pending if sent but not yet received</p>
</blockquote>
<p>同类型的信号至多只会有一个 pending signal，一定要注意这个特性，因为内部实现机制不可能提供较复杂的数据结构，所以信号的接收并不是一个队列。(If a process has a pending signal of type k, then subsequent signals of type k that are sent to that process are discarded)</p>
<p>一个 pending signal 至多只能被收到一次。</p>
<blockquote>
<p>A process can block the receipt of certain signals</p>
</blockquote>
<p>被阻塞的信号仍然可以发送，但是知道不阻塞之后才能被接收</p>
<p>内核用 pending 位向量 和 blocked 位向量来维护每个进程的信号相关状态</p>
<ul>
<li>pending: represents the set of pending signals<ul>
<li>Kernel sets bit k in <strong>pending</strong> when a signal of type k is delivered</li>
<li>Kernel clears bit k in <strong>pending</strong> when a signal of type k is received </li>
</ul>
</li>
<li>blocked: represent the set of blocked signals<ul>
<li>Can be set and cleared by using <code>sigprocmask</code> 函数</li>
<li>Also referred to as the <strong>signal mask</strong></li>
</ul>
</li>
</ul>
<p><strong>进程组</strong></p>
<p>每个进程都只属于一个进程组，如下图所示：</p>
<p><img src="/images/14573820359900.jpg" alt=""></p>
<p>我们可以据此指定一个进程组或者一个单独的进程，如：</p>
<p><img src="/images/14573821103841.jpg" alt="Sending Signals with `/bin/kill` Program"></p>
<p>这里可以看到，第一个命令只会杀掉编号为 24818 的进程，但是第二个命令，因为有两个进程都属于进程组 24817，所以会杀掉进程组中的每个进程。</p>
<p>键盘同样可以让内核向每个前台进程发送 SIGINT(SIGTSTP) 信号</p>
<ul>
<li>SIGINT - default action is to terminate each process</li>
<li>SIGTSTP - default action is to stop(suspend) each process</li>
</ul>
<p><img src="/images/14573823408948.jpg" alt="Example of ctrl-c and ctrl-z"></p>
<p>我们可以可以通过 <code>kill</code> 函数来发送信号：</p>
<p><img src="/images/14573824038965.jpg" alt="Sending Signals with kill Function"></p>
<h2 id="u63A5_u6536_u4FE1_u53F7"><a href="#u63A5_u6536_u4FE1_u53F7" class="headerlink" title="接收信号"></a>接收信号</h2><p>所有的上下文切换都是通过调用某个 exception handler 完成的，内核会计算对易于某个进程 p 的 pnb 值：<code>pnb = pending &amp; ~blocked</code></p>
<ul>
<li>如果 <code>pnb == 0</code><ul>
<li>那么就把控制交给进程 p 的逻辑流中的下一条指令</li>
</ul>
</li>
<li>否则<ul>
<li>选择 <code>pnb</code> 中最小的非零位 k，并强制进程 p 接收信号 k</li>
<li>接收到信号之后，进程 p 会执行对应的动作</li>
<li>对 <code>pnb</code> 中所有的非零位进行这个操作</li>
<li>最后把控制交给进程 p 的逻辑流中的下一条指令</li>
</ul>
</li>
</ul>
<p><strong>默认动作</strong></p>
<p>每个信号类型都有一个预定义的『默认动作』，可能是以下的情况：</p>
<ul>
<li>终止进程</li>
<li>终止进程并 dump core</li>
<li>停止进程，收到 <code>SIGCONT</code> 信号之后重启</li>
<li>忽略信号</li>
</ul>
<p><code>signal</code> 函数可以修改默认的动作：<code>handler_t *signal(int signum, handler_t *handler)</code>，具体来说：</p>
<p><img src="/images/14573845678378.jpg" alt="Different values for handler"></p>
<p>我们再通过具体的代码来感受下：</p>
<p><img src="/images/14573846209836.jpg" alt="Signal Handling Example"></p>
<p>可以这么理解 signal handler：</p>
<blockquote>
<p>A signal handler is a separate logical flow(not process) that runs concurrently with the main program</p>
</blockquote>
<p>如下图所示：</p>
<p><img src="/images/14573846875850.jpg" alt="Signals Handlers as Concurrent Flows"></p>
<p><img src="/images/14573847143072.jpg" alt="Another View of Signal Handlers as Concurrent Flows"></p>
<p>还是有一个需要注意的是，handler 也可以被其他的 handler 中断，控制流如下图所示：</p>
<p><img src="/images/14573848399013.jpg" alt="Nested Signal Handlers"></p>
<h2 id="u963B_u585E/_u4E0D_u963B_u585E_u4FE1_u53F7"><a href="#u963B_u585E/_u4E0D_u963B_u585E_u4FE1_u53F7" class="headerlink" title="阻塞/不阻塞信号"></a>阻塞/不阻塞信号</h2><p>隐式的机制是，内核会阻塞与当前在处理的信号同类型的其他 pending signal，也就是说，一个 SIGINT handler 是不能被另一个 SIGINT 信号中断的。</p>
<p>如果想要显式阻塞，就需要使用 <code>sigprocmask</code> 函数了，以及其他一些辅助函数：</p>
<ul>
<li><code>sigemptyset</code> - Create empty set</li>
<li><code>sigfillset</code> - Add every signal number to set</li>
<li><code>sigaddset</code> - Add signal number to set</li>
<li><code>sigdelset</code> - Delete signal number from set</li>
</ul>
<p>我们可以用下面折断代码来临时阻塞特定的信号：</p>
<p><img src="/images/14573850645959.jpg" alt="Temporarily Blocking Signals"></p>
<h2 id="u5B89_u5168_u5730_u5904_u7406_u4FE1_u53F7"><a href="#u5B89_u5168_u5730_u5904_u7406_u4FE1_u53F7" class="headerlink" title="安全地处理信号"></a>安全地处理信号</h2><blockquote>
<p>Handlers are tricky because they are concurrent with main program and share the same global data structures</p>
</blockquote>
<p>尤其要注意因为并行访问可能导致的数据损坏的问题，这里提供一些基本的指南（后面的课程会详细介绍）</p>
<p><img src="/images/14573852332585.jpg" alt="Guidelines for Writing Safe Handlers"></p>
<p>另外一个需要注意的问题是 Async-Signal-Safety。</p>
<blockquote>
<p>Function is async-signal-safe if either reentrant(all variables sotred on stack frame) or non-interruptible by signals</p>
</blockquote>
<p>Posix 标准指定了 117 个 async-signal-safe 的函数（可以通过 <code>man 7 signal</code> 查看）</p>
<p><img src="/images/14573853746526.jpg" alt="许多常用的函数都不是 async-signal-safe 的"></p>
<p>因为输出函数不是 async-signal-safe 的，所以最好使用课本中提供的 <code>csapp.c</code> 中的相关 handler</p>
<ul>
<li><code>ssize_t sio_puts(char s[])</code> - Put string</li>
<li><code>ssize_t sio_putl(long v)</code> - Put long</li>
<li><code>void sio_error(char s[])</code> - Put msg &amp; exit</li>
</ul>
<p><img src="/images/14573854667518.jpg" alt=""></p>
<p>正确的信号处理方法：</p>
<ul>
<li>You can’t use signals to count events, such as children terminating</li>
<li>Must wait for all terminated child processes.</li>
</ul>
<p><img src="/images/14573856728934.jpg" alt="Put `wait` in a loop to reap all terminated children"></p>
<p>还有一个问题，不同 Unix 版本有不同的 signal handling semantics，我们给出的解决方案是使用 <code>sigaction</code>，如下：</p>
<p><img src="/images/14573860066787.jpg" alt="Portable Signal Handling"></p>
<h2 id="u907F_u514D_u8FDB_u7A0B_u7ADE_u4E89"><a href="#u907F_u514D_u8FDB_u7A0B_u7ADE_u4E89" class="headerlink" title="避免进程竞争"></a>避免进程竞争</h2><p>我们之前的 shell 代码会出现微妙的同步错误，因为我们假设父进程会在子进程之前执行，代码如下：</p>
<p><img src="/images/14573866195444.jpg" alt=""></p>
<p><img src="/images/14573866343912.jpg" alt=""></p>
<p>我们需要在循环中添加同步条件，确保父进程和子进程的顺序（注意比较）</p>
<p><img src="/images/14573867961969.jpg" alt="Corrected Shell Program without Race"></p>
<h2 id="u663E_u5F0F_u7B49_u5F85_u4FE1_u53F7"><a href="#u663E_u5F0F_u7B49_u5F85_u4FE1_u53F7" class="headerlink" title="显式等待信号"></a>显式等待信号</h2><p>我们也可以用类似与等待前台任务执行的方式来等待子进程，方法如下：</p>
<p><img src="/images/14573869619954.jpg" alt="Handlers for program explicitly waiting for SIGCHLD to arrive"></p>
<p><img src="/images/14573869910604.jpg" alt="Handlers for program explicitly waiting for SIGCHLD to arrive"></p>
<p>这里的代码是正确的，但是我们注意 <code>while(!pid)</code> 这一句，通过忙等待的方式实现同步，非常浪费资源，而其他方式看起来也不行：</p>
<p><img src="/images/14573870533166.jpg" alt="Other options"></p>
<p>怎么办呢？我们的解决办法是 <code>sigsuspend</code>，函数为：</p>
<p><code>int sigsuspend(const sigset_t *mask)</code></p>
<p>等同于 atomic 版本的：</p>
<p><img src="/images/14573871178306.jpg" alt=""></p>
<p>所以代码如下：</p>
<p><img src="/images/14573871346551.jpg" alt="Wating for Signals with sigsuspend"></p>
<h2 id="Nonlocal_Jump"><a href="#Nonlocal_Jump" class="headerlink" title="Nonlocal Jump"></a>Nonlocal Jump</h2><p>这一部分比较简单，主要是使用 <code>setjmp</code> 与 <code>longjmp</code></p>
<p><img src="/images/14573872756594.jpg" alt="NoNonlocal Jumps: setjmp/longjmp"></p>
<p><img src="/images/14573873026532.jpg" alt="NoNonlocal Jumps: setjmp/longjmp"></p>
<p>我们可以利用这种方式，来跳转到其他的栈帧中，比方说在嵌套函数中，我们可以利用这个快速返回栈底的函数：</p>
<p><img src="/images/14573874602644.jpg" alt=""></p>
<p>但是也有限制，必须在栈中（也就是还没完成）才可以进行跳转，下面的例子中，因为 P2 已经返回，所以不能跳转了：</p>
<p><img src="/images/14573875130970.jpg" alt=""></p>
<p>最后是一个非常清晰的例子：</p>
<p><img src="/images/14573875598038.jpg" alt="A Program that restarts itself when ctrl-c"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这两个基本说完了 exceptional control flow 的全部内容，可能会稍微有点难以理解，我会在后面的习题课中尽可能详细说明。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解完了异常与进程，异常处理中另外两个很重要的部分是信号和非局部跳转，也就是我们这节课要介绍的内容。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="异常" scheme="http://wdxtub.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 13 课 Exceptions and Processes]]></title>
    <link href="http://wdxtub.com/2016/03/06/csapp-13/"/>
    <id>http://wdxtub.com/2016/03/06/csapp-13/</id>
    <published>2016-03-06T12:47:32.000Z</published>
    <updated>2016-03-06T23:16:54.000Z</updated>
    <content type="html"><![CDATA[<p>了解完了链接，我们来看看在程序出错的时候会发生什么事情，这一课我们主要来了解异常与进程。</p>
<a id="more"></a>
<hr>
<p>从开机到关机，CPU 做的工作其实很简单，就是不断读取并执行指令，每次执行一条，整个指令执行的序列，称为 CPU 的控制流。到目前为止，我们已经学过了两种改变控制流的方式：</p>
<ul>
<li>跳转和分支</li>
<li>调用和返回</li>
</ul>
<p>这对应于 program state 的改变。但是这实际上仅仅局限于程序的控制，没有办法去应对更加复杂的情况，比方说 system state 变化的时候：</p>
<ul>
<li>数据从磁盘或者网络适配器到达</li>
<li>指令除以了零</li>
<li>用户按下 ctrl+c</li>
<li>系统的计时器到时间</li>
</ul>
<p>所以我们这里会介绍另一种机制，称为 exceptional control flow。</p>
<h2 id="Exceptional_Control_Flow"><a href="#Exceptional_Control_Flow" class="headerlink" title="Exceptional Control Flow"></a>Exceptional Control Flow</h2><p>Exceptional Control Flow 存在于系统的每个层级：</p>
<p><img src="/images/14572937620861.jpg" alt=""></p>
<p>本节课我们先介绍前两种，下节课介绍后面两种。</p>
<h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><p>An <strong>exception</strong> is a transfer of control to the OS kernel in response to some event (i.e., change in processor state)</p>
<ul>
<li>Kernel 是操作系统常驻内存的一部分</li>
<li>Event: Divide by 0, arithmetic overflow, page fault, I/O request completes, typing ctrl-c</li>
</ul>
<p>具体的过程可以用下图表示：</p>
<p><img src="/images/14572946534326.jpg" alt="Exception 流程"></p>
<p>系统会通过 Exception Table 来确定跳转的位置，每种事件都有对应的唯一的异常编号，发生对应异常时就会调用对应的异常处理代码：</p>
<p><img src="/images/14572947301161.jpg" alt="Exception Table"></p>
<h3 id="Asynchronous_Exceptions__28Interrupts_29"><a href="#Asynchronous_Exceptions__28Interrupts_29" class="headerlink" title="Asynchronous Exceptions (Interrupts)"></a>Asynchronous Exceptions (Interrupts)</h3><p>异步异常称之为中断，是有处理器外面发生的事情引起的，这种情况下：</p>
<ul>
<li>需要设置处理器的 interrupt pin</li>
<li>处理完成后会返回之前控制流中的『下一条』指令</li>
</ul>
<p><img src="/images/14572948483518.jpg" alt="中断的两个例子"></p>
<h3 id="Synchronous_Exceptions"><a href="#Synchronous_Exceptions" class="headerlink" title="Synchronous Exceptions"></a>Synchronous Exceptions</h3><p>同步异常是因为执行某条指令所导致的事件，分为 Traps, Faults 和 Aborts 三种情况：</p>
<p><img src="/images/14572949405706.jpg" alt="同步异常的三种类型"></p>
<p>这里需要注意三种不同类型的处理方式，比方说 Traps 和终端一样，会返回执行『下一条』指令；而 Faults 会重新执行之前触发事件的指令；Aborts 则是直接退出当前的程序。</p>
<p><strong>System Call Example</strong></p>
<p>这里我们来了解一下系统调用 System Calls，系统调用看起来像是函数调用，但其实是走异常控制流的，在 x86-64 系统中，每个系统调用都有一个唯一的 ID，如：</p>
<p><img src="/images/14572951617051.jpg" alt=""></p>
<p>而具体的的调用过程如下所示：</p>
<p><img src="/images/14572951831475.jpg" alt=""></p>
<p><strong>Fault Example</strong></p>
<p>这里卫门以 Page Fault 为例，来说明 Fault 的机制。Page Fault 发生的条件是：</p>
<ul>
<li>用户写入内存位置</li>
<li>但该位置目前还不在内存中</li>
</ul>
<p>比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    a[<span class="number">500</span>] = <span class="number">13</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么系统会通过 Page Fault 把对应的部分载入到内存中，然后重新执行赋值语句：</p>
<p><img src="/images/14572953320001.jpg" alt=""></p>
<p>但是如果代码改为这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    a[<span class="number">5000</span>] = <span class="number">13</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是引用非法地址的时候，整个流程就会变成：</p>
<p><img src="/images/14572953822399.jpg" alt=""></p>
<p>具体来说会像用户进程发送 <code>SIGSEGV</code> 信号，用户进程会以 segmentation fault 的标记退出。</p>
<p>从上面我们就可以看到异常是非常底层的机制。</p>
<h2 id="Process__u8FDB_u7A0B"><a href="#Process__u8FDB_u7A0B" class="headerlink" title="Process 进程"></a>Process 进程</h2><blockquote>
<p>A process is an instance of a running program</p>
</blockquote>
<p>进程是计算机可续中最为重要的思想之一，注意，和 “program” 或 “processor” 都不一样。</p>
<p><img src="/images/14572960158600.jpg" alt="进程示意图"></p>
<p>进程给每个应用提供了两个非常关键的抽象：</p>
<p><img src="/images/14572959919795.jpg" alt="两个关键抽象"></p>
<p>计算机会同时运行多个进程，比如说不同的前台应用，或者后台任务，比方说在 Mac 下输入 <code>top</code>，可以看到如下的进程信息：</p>
<p><img src="/images/14572961362662.jpg" alt="我的电脑当前的状态"></p>
<p>具体的多线程模型如下所示：</p>
<p><img src="/images/14572962685162.jpg" alt="多线程模型（单核）"></p>
<ul>
<li>CPU 交替执行不同的进程</li>
<li>虚拟内存系统会负责管理地址空间</li>
<li>没有执行的进程的寄存器值会被保存在内存中</li>
</ul>
<p><img src="/images/14572963666951.jpg" alt="切换到另一个进程执行，会载入原先的寄存器值(context switch)"></p>
<p>而现代处理器一般有多个核心，所以可以真正同时执行多个进程：</p>
<p><img src="/images/14572964493864.jpg" alt="现代处理器执行模型"></p>
<p>进程之间，也分并行与串行的关系：</p>
<ul>
<li>Two processes run <strong>concurrently</strong> if their flows overlap in time</li>
<li>Otherwise, they are <strong>sequential</strong></li>
</ul>
<p>比方说下图中：</p>
<p><img src="/images/14572965827499.jpg" alt=""></p>
<ul>
<li>Concurrent: A&amp;B, A&amp;C</li>
<li>Sequential: B&amp;C</li>
</ul>
<p>不过在用户看来，执行的感觉是这样的：</p>
<p><img src="/images/14572966466237.jpg" alt=""></p>
<h3 id="Context_Switching"><a href="#Context_Switching" class="headerlink" title="Context Switching"></a>Context Switching</h3><p>具体切换进程时，kernel 会负责具体的调度。</p>
<blockquote>
<p>The kernel is not a separate process, but rather runs as part of some existing process</p>
</blockquote>
<p>控制流通过上下文切换的方式从一个进程到另一个进程，如下图所示：</p>
<p><img src="/images/14572967455790.jpg" alt="上下文切换 Context Switching"></p>
<h2 id="Process_Control__u8FDB_u7A0B_u63A7_u5236"><a href="#Process_Control__u8FDB_u7A0B_u63A7_u5236" class="headerlink" title="Process Control 进程控制"></a>Process Control 进程控制</h2><h3 id="System_Call_Error_Handling"><a href="#System_Call_Error_Handling" class="headerlink" title="System Call Error Handling"></a>System Call Error Handling</h3><p>在遇到错误的时候，Linux 系统级函数通常会返回 -1 并且设置 <code>errno</code> 这个全局变量来表示错误的原因。使用的时候记住两个规则：</p>
<ol>
<li>You must check the return status of every system-level function</li>
<li>Only exception is the handful of functions that return void</li>
</ol>
<p>例如，对于 <code>fork()</code> 函数，我们应该这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"fork error: %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果觉得这样写太麻烦，可以利用一个辅助函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unix_error</span><span class="params">(<span class="keyword">char</span> *msg)</span> <span class="comment">/* Unix-style error */</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: %s\n"</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的片段可以写为</span></span><br><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">"fork error"</span>);</span><br></pre></td></tr></table></figure>
<p>我们甚至可以更进一步，把整个 <code>fork()</code> 包装起来，就可以自带错误处理，比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> Fork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">"Fork error"</span>);</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的时候直接使用 <code>pid = Fork();</code> 即可（注意这里是大写的 F）</p>
<h3 id="u83B7_u53D6_u8FDB_u7A0B_u4FE1_u606F"><a href="#u83B7_u53D6_u8FDB_u7A0B_u4FE1_u606F" class="headerlink" title="获取进程信息"></a>获取进程信息</h3><ul>
<li><code>pid_t getpid(void)</code> - 返回当前进程的 PID</li>
<li><code>pid_t getppid(void)</code> - 返回当前进程的父进程的 PID</li>
</ul>
<p>我们可以认为，进程有三个状态：</p>
<ul>
<li>Running<ul>
<li>正在被执行、正在等待执行或者最终将会被执行</li>
</ul>
</li>
<li>Stopped<ul>
<li>执行被挂起，在进一步通知前不会计划执行</li>
</ul>
</li>
<li>Terminated<ul>
<li>进程被永久停止</li>
</ul>
</li>
</ul>
<p><strong>终止进程</strong></p>
<p>在下面三种情况时，进程会被终止：</p>
<ol>
<li>接收到一个终止信号</li>
<li>返回到 <code>main</code> </li>
<li>调用了 <code>exit</code> 函数</li>
</ol>
<p><img src="/images/14573038632263.jpg" alt="exit is called once but never returns"></p>
<p><strong>创建进程</strong></p>
<p>调用 <code>fork</code> 来创造新进程</p>
<p><img src="/images/14573039229956.jpg" alt="fork is interesting becasue it is called once but returns twice"></p>
<p>下面我们来看一个简单的例子：</p>
<p><img src="/images/14573039725814.jpg" alt=""></p>
<p>有以下几点需要注意：</p>
<ul>
<li>调用一次，但是会有两个返回值</li>
<li>并行执行，不能预计父进程和子进程的执行顺序</li>
<li>拥有自己独立的地址空间（也就是变量都是独立的），除此之外其他都相同</li>
<li>在父进程和子进程中 <code>stdout</code> 是一样的</li>
</ul>
<h3 id="u8FDB_u7A0B_u56FE"><a href="#u8FDB_u7A0B_u56FE" class="headerlink" title="进程图"></a>进程图</h3><p>进程图是一个很好的帮助我们理解进程执行的工具：</p>
<ul>
<li>每个节点代表一条执行的语句</li>
<li>a -&gt; b 表示 a 在 b 前面执行</li>
<li>边可以用当前变量的值来标记</li>
<li><code>printf</code> 节点可以用输出来进行标记</li>
<li>每个图由一个入度为 0 的节点作为起始</li>
</ul>
<p>对于进程图来说，只要满足拓扑排序，就是可能的输出。我们还是用刚才的例子：</p>
<p><img src="/images/14573044246995.jpg" alt=""></p>
<p>我们再来看三个稍微复制一点的例子：</p>
<p><img src="/images/14573045555520.jpg" alt="Two consecutive forks"></p>
<p><img src="/images/14573045862749.jpg" alt="Nested forks in parent"></p>
<p><img src="/images/14573046274270.jpg" alt="Nested forks in children"></p>
<h3 id="Reaping_Child_Processes"><a href="#Reaping_Child_Processes" class="headerlink" title="Reaping Child Processes"></a>Reaping Child Processes</h3><p>即使进程已经终止，也还在消耗系统资源，我们称之为『僵尸』。为了『打僵尸』，就可以采用『收割』(Reaping) 的方法。父进程利用 <code>wait</code> 或 <code>waitpid</code> 回收已终止的子进程，然后给系统提供相关信息，kernel 就会把 zombie child process 给删除。</p>
<p>如果父进程不『收割』的话，通常来说会被 <code>init</code> 进程(pid == 1)回收，所以一般不必显式回收。但是在长期运行的进程中，就需要显式回收（例如 shell 和 server）。下面是几个僵尸进程的例子：</p>
<p><img src="/images/14573049855888.jpg" alt="这里，子进程可以成功被回收"></p>
<p><img src="/images/14573050208627.jpg" alt="这里，因为子进程没有调用 `exit`，所以需要显式回收"></p>
<p><strong>wait: Synchronizing with Children</strong></p>
<p>父进程通过调用 <code>wait</code> 函数来『收割』子进程</p>
<p><img src="/images/14573055666401.jpg" alt=""></p>
<p>下面是一个具体的例子，同样用进程图来描述：</p>
<p><img src="/images/14573056037360.jpg" alt="wait: Synchronizing with Children"></p>
<p><img src="/images/14573056447947.jpg" alt="If multiple children completed, will take in arbitrary order. Can use macros WIFEXITED and WEXITSTATUS to get information about exit status"></p>
<p><strong>waitpid: Waiting for a Specific Process</strong></p>
<p>直接看例子：</p>
<p><img src="/images/14573057138513.jpg" alt=""></p>
<p><strong>execve: Loading and Running Programs</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span></span><br></pre></td></tr></table></figure>
<p>具体的行为是：</p>
<p><img src="/images/14573057856048.jpg" alt=""></p>
<p>为了理解 <code>execve</code> 的行为，我们要先理解程序在栈中的布局：</p>
<p><img src="/images/14573058581756.jpg" alt="栈的结构"></p>
<p>一个具体的例子：</p>
<p><img src="/images/14573058863617.jpg" alt="execve 例子"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Exceptions<ul>
<li>Events that require nonstandard control flow</li>
<li>Generated externally (interrupts) or internally (traps and faults)</li>
</ul>
</li>
<li>Processes<ul>
<li>At any given time, system has multiple active processes</li>
<li>Only one can execute at a time on a single core, though</li>
<li>Each process appears to have total control of processor + private memory space</li>
</ul>
</li>
<li>Spawning processes<ul>
<li>Call <code>fork</code></li>
<li>One call, two returns</li>
</ul>
</li>
<li>Process completion<ul>
<li>Call <code>exit</code></li>
<li>One call </li>
</ul>
</li>
<li>Reaping and waiting for processes<ul>
<li>Call <code>wait</code> or <code>waitpid</code></li>
</ul>
</li>
<li>Loading and running programs<ul>
<li>Call <code>execve</code></li>
<li>One call, (normally) no return</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解完了链接，我们来看看在程序出错的时候会发生什么事情，这一课我们主要来了解异常与进程。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="异常" scheme="http://wdxtub.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 12 课 Linking]]></title>
    <link href="http://wdxtub.com/2016/03/06/csapp-12/"/>
    <id>http://wdxtub.com/2016/03/06/csapp-12/</id>
    <published>2016-03-06T12:47:27.000Z</published>
    <updated>2016-03-06T18:48:49.000Z</updated>
    <content type="html"><![CDATA[<p>这一课我们要接触一个新概念：Linking，简单来说就是计算机如何让不同的代码协同工作的方式。</p>
<a id="more"></a>
<hr>
<p>我们先来看一个例子，假设有这么两个代码文件</p>
<p><img src="/images/14572758203003.jpg" alt=""></p>
<p>我们用下面的命令来编译执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; gcc -Og -o prog main.c sum.c</span><br><span class="line">linux&gt; ./prog</span><br></pre></td></tr></table></figure>
<p>编译器实际上会分别编译不同的源代码，生成 <code>.o</code> 文件，具体把这些文件链接在一起的是 Linker 链接器，整个过程如下图所示：</p>
<p><img src="/images/14572760766987.jpg" alt=""></p>
<blockquote>
<p>为什么要使用链接器？</p>
</blockquote>
<p>有如下两个原因。</p>
<ul>
<li>模块化角度考虑。我们可以把程序分散到不同的小的源代码中，而不是一个巨大的类中。这样带来的好处是可以复用常见的功能/库，比方说 Math library, standard C library.</li>
<li>效率角度考虑。改动代码时只需要重新编译改动的文件，其他不受影响。而常用的函数和功能可以封装成库，提供给程序进行调用（节省空间）</li>
</ul>
<blockquote>
<p>链接器做了什么？</p>
</blockquote>
<p>主要负责做两件事情</p>
<p><strong>第一步：Symbol resolution</strong></p>
<p>我们在代码中会声明变量及函数，之后会调用变量及函数，所有的符号声明都会被保存在符号表(symbol table)中，而符号表会保存在由汇编器生成的 object 文件中（也就是 <code>.o</code> 文件）。符号表实际上是一个结构体数组，每一个元素包含名称、大小和符号的位置。</p>
<p>在 symbol resolution 阶段，链接器会给每个符号应用一个唯一的符号定义，用作寻找对应符号的标志。</p>
<p><strong>第二步：Relocation</strong></p>
<p>这一步所做的工作是把原先分开的代码和数据片段汇总成一个文件，会把原先在 <code>.o</code> 文件中的相对位置转换成在可执行程序的绝对位置，并且据此更新对应的引用符号（才能找到新的位置）</p>
<p>在具体来看这两步做了啥之前，先要理解下面几个概念。</p>
<h2 id="u4E09_u79CD_Object_Files"><a href="#u4E09_u79CD_Object_Files" class="headerlink" title="三种 Object Files"></a>三种 Object Files</h2><p>所谓的 Object File 实际上是一个统称，具体来说有以下三种形式：</p>
<ul>
<li>Relocatable object file (<code>.o</code> file)<ul>
<li>每个 <code>.o</code> 文件都是由对应的 <code>.c</code> 文件生成，包含代码和数据，可以用来组合成 executable object file</li>
</ul>
</li>
<li>Executable object file (<code>a.out</code> file)<ul>
<li>包含代码和数据，可以直接被复制到内存中执行</li>
</ul>
</li>
<li>Shared object file (<code>.so</code> file)<ul>
<li>在 windows 中被称为 Dynamic Link Libraries(DLLs)，是一类特别的 relocatable object file，能够被载入内存并动态链接（载入时或运行时）</li>
</ul>
</li>
</ul>
<h2 id="Executable_and_Linkable_Format_28ELF_29"><a href="#Executable_and_Linkable_Format_28ELF_29" class="headerlink" title="Executable and Linkable Format(ELF)"></a>Executable and Linkable Format(ELF)</h2><p>上面提到的三种 obejct file 有统一的格式，即 Executable and Linkable Format(ELF)，因为，我们把它们统称为 ELF binaries，具体的文件格式如下</p>
<p><img src="/images/14572780724226.jpg" alt="ELF 文件格式"></p>
<p>下面分别介绍一下各个部分：</p>
<ul>
<li>ELF header<ul>
<li>包含 word size, byte ordering, file type (.o, exec, .so), machine type, etc</li>
</ul>
</li>
<li>Segment header table<ul>
<li>包含 page size, virtual addresses memory segments(sections), segment sizes</li>
</ul>
</li>
<li>.text section<ul>
<li>代码部分</li>
</ul>
</li>
<li>.rodata section<ul>
<li>只读数据部分，例如 jump tables</li>
</ul>
</li>
<li>.data section<ul>
<li>初始化的全局变量</li>
</ul>
</li>
<li>.bss section<ul>
<li>未初始化的全局变量</li>
<li>“Block Started by Symbol”</li>
<li>“Better Save Space”</li>
<li>有 section header 但实际上不占空间</li>
</ul>
</li>
<li>.symtab section<ul>
<li>包含 symbol table, procudure 和 static variable names 以及 section names 和 location</li>
</ul>
</li>
<li>.rel.txt section<ul>
<li>Relocation info for .text section</li>
<li>Addresses of instructions that will need to be modified in the executable</li>
<li>Instructions for modifying</li>
</ul>
</li>
<li>.rel.data section<ul>
<li>Relocation info for .data section</li>
<li>Addresses of pointer data that will need to be modified in the merged executable </li>
</ul>
</li>
<li>.debug section<ul>
<li>包含 symbolic debugging (<code>gcc -g</code>) 的信息 </li>
</ul>
</li>
<li>Section header table<ul>
<li>Offsets and sizes of each section</li>
</ul>
</li>
</ul>
<h2 id="Linker_Symbols"><a href="#Linker_Symbols" class="headerlink" title="Linker Symbols"></a>Linker Symbols</h2><p>而链接器实际上会处理三种不同的符号，对应于代码中不同写法的部分：</p>
<ul>
<li>Global symbols<ul>
<li>在当前模块中定义，且可以被其他代码引用的符号，例如非静态 C 函数和非静态全局变量</li>
</ul>
</li>
<li>External symbols<ul>
<li>同样是全局符号，但是是在其他模块（也就是其他的源代码）中定义的，但是可以在当前模块中引用</li>
</ul>
</li>
<li>Local symbols<ul>
<li>在当前模块中定义，只能被当前模块引用的符号，例如静态函数和静态全局变量</li>
<li>注意，Local linker symbol 并不是 local program variables</li>
</ul>
</li>
</ul>
<p>现在我们可以回过头来看看链接器具体做的工作了：</p>
<h2 id="u7B2C_u4E00_u6B65_uFF1ASymbol_resolution"><a href="#u7B2C_u4E00_u6B65_uFF1ASymbol_resolution" class="headerlink" title="第一步：Symbol resolution"></a>第一步：Symbol resolution</h2><p><img src="/images/14572791281425.jpg" alt="Symbol resolution"></p>
<p>我们可以看到，链接器只知道非静态的全局变量/函数，而对于局部变量一无所知。</p>
<p>然后我们来看看局部非静态变量和局部静态变量的区别</p>
<ul>
<li>局部非静态变量会保存在栈中</li>
<li>局部静态变量会保存在 <code>.bss</code> 或 <code>.data</code> 中</li>
</ul>
<p>例如：</p>
<p><img src="/images/14572793537491.jpg" alt=""></p>
<p>如果两个不同的源代码中使用了相同的全局变量名称，链接器会如何处理呢？</p>
<p>首先我们需要知道的是，不同的符号是有强弱之分的：</p>
<ul>
<li>Strong: procedures and initialized globals</li>
<li>Weak: uninitialized globals</li>
</ul>
<p>比如：</p>
<p><img src="/images/14572854731828.jpg" alt=""></p>
<p>在这个基础上，有如下规则：</p>
<p><img src="/images/14572855304555.jpg" alt=""></p>
<p>因为这个特性，可能会因为变量重名导致非常奇怪的现象，比如下面的情况：</p>
<p><img src="/images/14572855800167.jpg" alt=""></p>
<p>因此我们可以得到一条很重要的编程建议：</p>
<blockquote>
<p>如果可能，尽量避免使用全局变量</p>
</blockquote>
<p>如果一定要用的话，注意下面几点：</p>
<ul>
<li>使用静态变量</li>
<li>定义全局变量的时候初始化</li>
<li>注意使用 <code>extern</code> 关键字</li>
</ul>
<h2 id="u7B2C_u4E8C_u6B65_uFF1ARelocation"><a href="#u7B2C_u4E8C_u6B65_uFF1ARelocation" class="headerlink" title="第二步：Relocation"></a>第二步：Relocation</h2><p>大概的过程，通过下图就可以看得比较清楚，就是把不同的 relocatable object files 拼成 executable object file 的过程</p>
<p><img src="/images/14572863145911.jpg" alt=""></p>
<p>但具体是怎么做到的呢，还是刚才那个例子：</p>
<p><img src="/images/14572863618645.jpg" alt=""></p>
<p>对应的 relocatable object file 反编译出来 <code>objdump -r -d main.o</code> 可以看到汇编代码为：</p>
<p><img src="/images/14572864112503.jpg" alt=""></p>
<p>这里我们可以看到，编译器用 relocation entry 来标记不同的调用（注意看对应的代码后面四组数字都是零，就是留出位置让链接器在链接的时候填上对应的实际内存地址）</p>
<p>在完成链接之后我们得到 <code>prog</code> 这个程序，同样反编译 <code>objdump -dx prog</code> 可以看到：</p>
<p><img src="/images/14572865303343.jpg" alt=""></p>
<p>对应的地址已经被填上去了，这里注意用的是相对的位置，比方说 0x4004de 中的 05 00 00 00 的意思实际上是说要在下一句的基础上加上 0x5，也就是 0x4004e8，即 sum 函数的开始位置。</p>
<p>具体载入内存的时候，大概是这样的：</p>
<p><img src="/images/14572866787544.jpg" alt=""></p>
<p>这里需要注意左边的部分地址从上往下，右边则是从下往上，这里所有的程序都会从 0x400000 开始。</p>
<h2 id="u6253_u5305_u5E38_u7528_u7A0B_u5E8F"><a href="#u6253_u5305_u5E38_u7528_u7A0B_u5E8F" class="headerlink" title="打包常用程序"></a>打包常用程序</h2><p>基本上每个程序都会用到某些特定的函数，比如：Math, IO, memory management, string manipulation 等等，我们能用什么方法把它们结合到程序中呢，有以下两个思路：</p>
<ul>
<li>思路 1：把所有的函数放到一个源文件中，程序员每次把这一整个大块头链接到自己的程序中，这种做法从时间和空间上来说都比较低效</li>
<li>思路 2：不同的函数放到不同的源文件中，由程序员显式链接所需要的函数，这种做法效率更高，但是相当于是给程序员增加负担了</li>
</ul>
<h3 id="Static_Libraries"><a href="#Static_Libraries" class="headerlink" title="Static Libraries"></a>Static Libraries</h3><p>比较老式的做法就是所谓的静态库(Static Libraries, <code>.a</code> archive files)</p>
<ul>
<li>Concatenate related relocatable object files into a single file with an index (called an archive)</li>
<li>Enhance linker so that it tries to resolve unresolved external references by looking for the symbols in one or more archives</li>
<li>If an archive member file resolves reference, link it into the executable</li>
</ul>
<p>具体的过程如下：</p>
<p><img src="/images/14572879938673.jpg" alt=""></p>
<p>这里注意，Archiver 支持增量更新，如果有函数变动，只需要重新编译改动的部分。</p>
<p>下面是两个常用的库：C standard library 与 C math library</p>
<p><img src="/images/14572880658935.jpg" alt=""></p>
<p>接下来我们看一个具体的例子，通过静态库来连接：</p>
<p><img src="/images/14572880967573.jpg" alt=""></p>
<p>具体过程如下：</p>
<p><img src="/images/14572881242795.jpg" alt=""></p>
<p>具体的链接方式是：</p>
<p><img src="/images/14572882030642.jpg" alt=""></p>
<p>但是这样会带来一个问题：写编译命令的时候，顺序是很重要的！我们看下面这个例子</p>
<p><img src="/images/14572882337934.jpg" alt=""></p>
<p>第一条命令中，在编译链接的时候，如果在 libtest.o 中发现了外部引用，就会在 -lmine 中查找，但是如果反过来，在第二条语句中 libtest.o 后面没有东西，就会出现找不到引用的错误。所以建议就是要把静态库都放到后面去。</p>
<h3 id="Shared_Libraries"><a href="#Shared_Libraries" class="headerlink" title="Shared Libraries"></a>Shared Libraries</h3><p>现代的方法则是使用共享库，避免了在文件中静态库的大量重复。</p>
<p>动态链接可以在首次载入的时候执行(load-time linking)，这是 Linux 的标准做法，会由动态链接器 <code>ld-linux.so</code> 完成，Standard C library(libc.so) 通常是动态链接的。</p>
<p><img src="/images/14572885863404.jpg" alt="Dynamic Linking at Load-time"></p>
<p>动态链接也可以在程序开始执行的时候完成(run-time linking)，在 Linux 中使用 <code>dlopen()</code> 接口来完成（会使用函数指针，如下面的例子所示），通常用于分布式软件，高性能服务器上。而且共享库也可以在多个进程间共享，这在后面学习到虚拟内存的时候会介绍。</p>
<p><img src="/images/14572886125265.jpg" alt=""></p>
<p><img src="/images/14572886257737.jpg" alt="Dynamic Linking at Run-time"></p>
<p>总结一下：</p>
<ul>
<li>链接使得我们可以用多个 object files 构造我们的程序</li>
<li>链接可以发生在程序的不同阶段<ul>
<li>编译期间(when a program is compiled)</li>
<li>载入期间(when a program is loaded into memory)</li>
<li>运行期间(while program is executing)</li>
</ul>
</li>
<li>理解链接可以帮助我们避免遇到奇怪的错误</li>
</ul>
<h2 id="Case_Study_3A_Library_Interpositioning"><a href="#Case_Study_3A_Library_Interpositioning" class="headerlink" title="Case Study: Library Interpositioning"></a>Case Study: Library Interpositioning</h2><p>这是一个非常有意思的技术，我们可以通过这个技术让程序运行任意我们想要的代码，比方说我们的程序中使用了 <code>malloc</code>，我们可以通过 library interpositioning 让程序执行我们自定义的 <code>malloc</code> 而不是标准库中的 <code>malloc</code>。</p>
<p>因为这相当于是某种链接技术，所以同样可以在不同的时候发生，如：</p>
<ul>
<li>编译时：When the source code is compiled</li>
<li>链接时：When the relocatable object files are statically linked to form an executable object file</li>
<li>载入/运行时：When an executable object file is loaded into memory, dynamically linked, and then executed.</li>
</ul>
<p>这个技术可以应用在</p>
<ul>
<li>安全方面<ul>
<li>Confinement (sandboxing)</li>
<li>Behind the scenes encryption</li>
</ul>
</li>
<li>调试方面<ul>
<li>可以找到隐藏比较深的 bug</li>
</ul>
</li>
<li>监控和查看性能<ul>
<li>统计函数调用的次数</li>
<li>检测内存泄露</li>
<li>生成地址记录</li>
</ul>
</li>
</ul>
<p>我们用一个具体的例子来说明，先来看看程序，非常简单，只有几行：</p>
<p><img src="/images/14572895007610.jpg" alt=""></p>
<p>我们要做的事情也很简单，先申请一片内存空间，然后再释放掉。但是我们的目标是在不修改源代码的前提下，追踪分配地址的位置，要怎么办呢？</p>
<p>有三种方式，分别在编译、链接和运行时对 <code>malloc</code> 和 <code>free</code> 函数进行 interpositioning。</p>
<h3 id="Compile-time_Interpositioning"><a href="#Compile-time_Interpositioning" class="headerlink" title="Compile-time Interpositioning"></a>Compile-time Interpositioning</h3><p>我们写出另外两个函数，它们唯一做的事情就是输出地址，相当于把原来的函数做了个『包装』：</p>
<p><img src="/images/14572896784067.jpg" alt=""></p>
<p>然后在 <code>malloc.h</code> 利用宏进行改变：</p>
<p><img src="/images/14572897247442.jpg" alt=""></p>
<p>最后我们可以通过 <code>-I.</code> 这个选项来使得程序会调用我们自己写的函数，可以看到执行的时候会打印出地址</p>
<p><img src="/images/14572897797778.jpg" alt=""></p>
<h3 id="Link-time_Interpositioning"><a href="#Link-time_Interpositioning" class="headerlink" title="Link-time Interpositioning"></a>Link-time Interpositioning</h3><p>我们同样需要把两个函数包装一下：</p>
<p><img src="/images/14572898402918.jpg" alt=""></p>
<p>然后注意所用的命令：</p>
<p><img src="/images/14572898614846.jpg" alt=""></p>
<p>这里 <code>-Wl</code> 会告诉链接器，把每个逗号替换成空格。</p>
<p><code>--wrap,malloc</code> 这个参数会进行特殊方式的引用</p>
<ul>
<li>对 <code>malloc</code> 的引用会被解析为 <code>__wrap_malloc</code></li>
<li>对 <code>__real_malloc</code> 的引用会被解析为 <code>malloc</code></li>
</ul>
<h3 id="Load/Run-time_Interpositioning"><a href="#Load/Run-time_Interpositioning" class="headerlink" title="Load/Run-time Interpositioning"></a>Load/Run-time Interpositioning</h3><p>我们同样是对两个函数进行包装：</p>
<p><img src="/images/14572900345456.jpg" alt=""></p>
<p><img src="/images/14572900442044.jpg" alt=""></p>
<p>然后使用以下命令：</p>
<p><img src="/images/14572900675087.jpg" alt=""></p>
<p>这里的 <code>LD_PRELOAD</code> 环境变量会告诉动态链接器先在 <code>mymalloc.so</code> 中寻找所需的引用，就完成了 interpositioning 的效果。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一课我们要接触一个新概念：Linking，简单来说就是计算机如何让不同的代码协同工作的方式。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="链接" scheme="http://wdxtub.com/tags/%E9%93%BE%E6%8E%A5/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Programming iOS9 学习笔记 12 - Controls and Other Views]]></title>
    <link href="http://wdxtub.com/2016/03/06/programming-ios9-translation-12/"/>
    <id>http://wdxtub.com/2016/03/06/programming-ios9-translation-12/</id>
    <published>2016-03-06T12:39:13.000Z</published>
    <updated>2016-03-06T12:46:33.000Z</updated>
    <content type="html"><![CDATA[<p>这一章主要包含前面没有提到过的 <code>UIView</code> 的子类（由 UIKit 提供）</p>
<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<p>这一章主要包含前面没有提到过的 <code>UIView</code> 的子类（由 UIKit 提供）</p>]]>
    
    </summary>
    
      <category term="Control" scheme="http://wdxtub.com/tags/Control/"/>
    
      <category term="iOS9" scheme="http://wdxtub.com/tags/iOS9/"/>
    
      <category term="学习" scheme="http://wdxtub.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://wdxtub.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Programming iOS9 学习笔记 11 - Web Views]]></title>
    <link href="http://wdxtub.com/2016/03/06/programming-ios9-translation-11/"/>
    <id>http://wdxtub.com/2016/03/06/programming-ios9-translation-11/</id>
    <published>2016-03-06T11:12:42.000Z</published>
    <updated>2016-03-06T12:38:58.000Z</updated>
    <content type="html"><![CDATA[<p>Web view 实际是一个浏览器，知道如何从网络上获取资源，比如说渲染 HTML/CSS/JavaScript。不仅可以用于展示网络内容，而且还有一个强大的，可以用来布局、显示动画和多媒体的引擎。</p>
<a id="more"></a>
<hr>
<p>Web view 甚至还知道如何去显示 PDF/RTF/DOC/Pages 文件。</p>
<p><img src="/images/14572631505893.jpg" alt=""></p>
<p>Web view 中的资源加载是异步的，有一个另外的线程来完成这个工作，也就是说加载的时候用户仍然可以进行各种操作和访问。</p>
<p><img src="/images/14572632324008.jpg" alt=""></p>
<p>在 iOS 9 中，实际上有三类 web view 对象：</p>
<p><img src="/images/14572632568030.jpg" alt=""></p>
<p>这里主要讨论 <code>WKWebView</code> 和 <code>SFSafariViewController</code>。</p>
<p><img src="/images/14572633254117.jpg" alt=""></p>
<h2 id="WKWebView"><a href="#WKWebView" class="headerlink" title="WKWebView"></a>WKWebView</h2><p><code>WKWebView</code> 是 WebKit 框架的一部分，使用之前需要 <code>import WebKit</code> 并且在代码中创建 web view，比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> config = <span class="type">WKWebViewConfiguration</span>()</span><br><span class="line"><span class="comment">// .... 各种配置</span></span><br><span class="line"><span class="keyword">let</span> wv = <span class="type">WKWebView</span>(frame: <span class="type">CGRectZero</span>, configuration:config)</span><br></pre></td></tr></table></figure>
<p>当然也可以直接使用默认配置初始化，之后再进行修改，如</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wv = <span class="type">WKWebView</span>(frame: <span class="type">CGRectZero</span>)</span><br><span class="line"><span class="comment">// ... 各种配置</span></span><br></pre></td></tr></table></figure>
<p>无论用哪种方法，最好在开始载入之前就完成配置，因为不同的配置可能会导致渲染得到的页面不一样，比较常见的配置有：</p>
<p><img src="/images/14572640710901.jpg" alt=""></p>
<p><img src="/images/14572640995408.jpg" alt=""></p>
<p>也可以创建自定义的内容放到界面上，如：</p>
<p><img src="/images/14572641374200.jpg" alt=""></p>
<p><code>WKWebView</code> 并不是一个 scroll view，但是拥有一个 scroll view。</p>
<p>有下面四种方式可以让 <code>WKWebView</code> 显示内容：</p>
<p><img src="/images/14572642956567.jpg" alt=""></p>
<p><img src="/images/14572643064428.jpg" alt=""></p>
<p>以上四个方法都会返回 <code>WKNavigation</code> 对象</p>
<p>我们可以通过 <code>WKWebView</code> 的属性来跟踪其状态，比如：</p>
<ul>
<li><code>loading</code></li>
<li><code>estimatedProgress</code></li>
<li><code>URL</code></li>
<li><code>title</code></li>
</ul>
<p>我们可以通过这些属性来做一些操作，比如说在载入的时候在页面中间放一个进度指示器，并且在载入完成之后隐藏。具体代码如下</p>
<p><img src="/images/14572644352049.jpg" alt=""></p>
<p>我们可以通过 <code>backForwardList</code> 来进行前进和后退的操作，这是一个 <code>WKBackForwardList</code> 并且有以下属性</p>
<ul>
<li><code>currentItem</code></li>
<li><code>backItem</code></li>
<li><code>forwardItem</code></li>
<li><code>itemAtIndex</code></li>
</ul>
<p>列表中的每个项目都是 <code>WKBackForwardItem</code>，包含 <code>URL</code> 和 <code>title</code>。然后就可以调用 <code>goBack</code>, <code>goForward</code> 和 <code>goToBackForwardListItem:</code> 方法来进行导航。当然，也可以通过设定 <code>canGoBack</code> 和 <code>canGoForward</code> 来控制是否能够后退前进。</p>
<p>还有一个可以设置的属性 <code>allowsBackForwardNavigationGestures</code>，用来控制是否能够以手势返回，默认是 false，如果设置为 true，则在滑动边缘的时候能够返回。</p>
<p>通过设置 <code>WKWebView</code> 的 <code>navigationDelegate</code> 可以控制具体的导航行为，例如：</p>
<p><img src="/images/14572672880968.jpg" alt=""></p>
<p><img src="/images/14572672999616.jpg" alt=""></p>
<p>然后还有一些代理方法会通知目前的状态：</p>
<p><img src="/images/14572673546176.jpg" alt=""></p>
<p>如果想要给 <code>WKWebView</code> 中的网页发消息，可以调用 <code>evaluateJavaScript:completionHandler:</code> 方法，例子如下；</p>
<p><img src="/images/14572674300371.jpg" alt=""></p>
<p><img src="/images/14572674428385.jpg" alt=""></p>
<p>当然也可以反向来进行操作，比方说把页面的某些元素与按钮绑定，这里不深入。</p>
<p>最后需要注意的是，<code>WKWebView</code> 是不能在 nib 中初始化的（控件里的是 <code>UIWebView</code>）。并且在 iOS8 中，指向本地文件的链接无法在 <code>WKWebView</code> 中使用（iOS9 中已修复，但是考虑兼容性，只能使用 UIWebView）</p>
<p>另外一个问题是 <code>WKWebView</code> 不会自动参与到任何视图控制器的状态中（也就是无法保存和恢复），如果是显示本地内容的话可以人为进行保存恢复，这里不赘述</p>
<h2 id="Safari_View_Controller"><a href="#Safari_View_Controller" class="headerlink" title="Safari View Controller"></a>Safari View Controller</h2><p>简单来说，就是在你的应用中开一个单独的 safari 线程（提供比较完整的功能）。根据苹果的建议，如果是要显示内部的 HTML 内容，用 <code>WKWebView</code>，如果是访问网络，用 Safari view controller，这样可以省去很多麻烦。</p>
<p>使用需要 <code>import SafariServices</code>，如</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> svc = <span class="type">SFSafariViewController</span>(<span class="type">URL</span>: url)</span><br><span class="line"><span class="keyword">self</span>.presentViewController(svc, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/14572679027545.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Web view 实际是一个浏览器，知道如何从网络上获取资源，比如说渲染 HTML/CSS/JavaScript。不仅可以用于展示网络内容，而且还有一个强大的，可以用来布局、显示动画和多媒体的引擎。</p>]]>
    
    </summary>
    
      <category term="Webview" scheme="http://wdxtub.com/tags/Webview/"/>
    
      <category term="iOS9" scheme="http://wdxtub.com/tags/iOS9/"/>
    
      <category term="学习" scheme="http://wdxtub.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://wdxtub.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的软实力]]></title>
    <link href="http://wdxtub.com/2016/03/05/my-soft-skill/"/>
    <id>http://wdxtub.com/2016/03/05/my-soft-skill/</id>
    <published>2016-03-06T02:04:55.000Z</published>
    <updated>2016-03-06T11:15:44.000Z</updated>
    <content type="html"><![CDATA[<p>上一篇文章，<a href="http://wdxtub.com/2016/03/04/na-job-soft-skill/">北美找工作软实力指南</a>中提到了给自己定位的分析与思考方法，这里以自己为例子，来看看如何更好地找到自己并展示自己。</p>
<a id="more"></a>
<hr>
<p>自己比较适合游走在技术、管理与沟通之间的工作，所以就以这个为基准，作为这次思考的开始。</p>
<h2 id="u76EE_u6807"><a href="#u76EE_u6807" class="headerlink" title="目标"></a>目标</h2><p>我想找的工作职位是：项目经理（需要懂技术与管理，还需要与客户或者其他小组沟通协调，和微软的 Program Manager 的职责比较接近，而非传统那样只负责管理）。</p>
<p>选择这个职位作为走上社会的第一步，是经过深思熟虑的。我的性格、做事风格、技能、经历和喜好都非常适合这个职位，具体会在后面详细说明。</p>
<p><strong>短期职业目标</strong></p>
<p>我的短期职业目标是通过这份工作尽可能快得通过接触社会上各种类型的人来完成从学生到社会人这个身份的转换，并在具体实践中找到自己的方向。所以希望能不止局限于特定的工作，而是像『救火队员』一样，到最需要、最能学到东西、最能成长的地方，哪怕苦一点累一点，压力大一点也不怕。</p>
<p><strong>长期职业目标</strong></p>
<p>我的长期职业目标是通过接触不同领域，不同层次的项目和人群，建立其对技术、商业乃至于社会的整体框架，并利用自己的思考与行动力，带领志同道合的伙伴一起努力，为后辈创造一个更好的未来。我知道现在中国社会有太多太多的丑陋和需要改进的地方，我想通过自己的努力，从独当一面开始，真正能做一些影响到更多人的事情。简单来说就是想让世界 “Hear My Voice”</p>
<h2 id="u6280_u80FD"><a href="#u6280_u80FD" class="headerlink" title="技能"></a>技能</h2><p>对应于我的短期与长期的职业目标，我的以下技能是非常合适的：</p>
<h3 id="u6280_u80FD_u4E00_uFF1A_u9605_u8BFB"><a href="#u6280_u80FD_u4E00_uFF1A_u9605_u8BFB" class="headerlink" title="技能一：阅读"></a>技能一：阅读</h3><p>阅读能力的提升使得我能更快更好地把新知识融会贯通到已有的知识体系与认知架构中，我觉得这对于一个项目经理来说是很重要的。不谋万世者不足以谋一时，通过广泛涉猎建立起来的大局观与开放性思考问题的方式，相信对于完成这个职位所需要的工作有很大帮助。</p>
<p>从大四起，我有目的开始培养自己阅读的能力。书籍作为最重要且最有价值的信息来源，在这个碎片化的时代很容易被忽视。随着阅读量的增加，慢慢也有了一些影响力，成为了『多看特约书评人』，也积累了一些粉丝。</p>
<p><img src="/images/duokan-read.jpeg" alt="我在多看阅读中的一些数据"></p>
<p><a href="http://www.douban.com/people/wdx/" target="_blank" rel="external">这里</a>是我的豆瓣读书主页，也可以从中大概了解我的阅读兴趣。因为对这个世界好奇，所以基本上各个领域的书都有所涉猎，知识面比较广，每隔一段时间也会进行整理和反思。毫不夸张的说，阅读是我这几年快速成长的基础，具体可以参加下面几篇思考的日志：</p>
<ul>
<li><a href="http://wdxtub.com/2015/05/25/5000-hours/">写在五千小时</a></li>
<li><a href="http://wdxtub.com/2014/10/22/4000-hours/">写在四千小时</a></li>
<li><a href="http://wdxtub.com/2014/05/20/3000-hours/">写在三千小时</a></li>
<li><a href="http://wdxtub.com/2014/01/20/2000-hours/">写在两千小时</a></li>
<li><a href="http://wdxtub.com/2013/08/21/1000-hours/">写在一千小时</a></li>
</ul>
<h3 id="u6280_u80FD_u4E8C_uFF1A_u5199_u4F5C"><a href="#u6280_u80FD_u4E8C_uFF1A_u5199_u4F5C" class="headerlink" title="技能二：写作"></a>技能二：写作</h3><p>管理和沟通除了面对面交流之外，更重要的一部分是通过文字，因为文字可以跨域时空限制，清晰有逻辑的表述不但能够梳理思路，更能避免基本的思维误区。并且在不断的写作中，也通过和读者的沟通交流极大地提高自己跟不同行业的人介绍自己工作的能力，尤其是利用『比喻』的能力。我总是会利用比喻来尽可能让他人理解我要介绍的东西或者我的思维方式，这是我的最大收获。因为项目经理很多时候还需要进行协调沟通的工作，我的这个技能是很好的助力。</p>
<p>从高中开始就会在网上写写东西，起初都是没多少意义的流水账，开始有针对性阅读之后，就以书评的形式来组织自己的文章，从最简单的书摘，到慢慢有自己的见解，再到现在能够批判性去看待的观点，以及研究作者的思维方式，一步一步都让我得到了很多乐趣。</p>
<p>因为坚持时间比较长，<a href="http://wdxtub.lofter.com/" target="_blank" rel="external">我的博客</a>也慢慢积累了十万多粉丝，也认识了一批热爱文字，喜欢用笔尖思考的朋友，更重要的是使我能以他人的视角去看待问题。也曾受到 LOFTER 官方的推荐和转载，曾经（后来这个功能取消了）是『读书』分类下排在前十的『资深博客』。现在也会开始系列写作，把自己的想法组织成完整的观点，搭建一个整体框架来进行写作，比如下面的『人造系列』</p>
<ol>
<li><a href="http://wdxtub.com/2015/08/26/heroes-are-not-born/">人造英雄</a></li>
<li><a href="http://wdxtub.lofter.com/post/1a7a1d_5def559" target="_blank" rel="external">人造极简</a></li>
<li><a href="http://wdxtub.com/2015/02/06/manmade-peace/">人造定凝</a></li>
<li><a href="http://wdxtub.com/2015/01/31/manmade-speed/">人造速度</a></li>
<li><a href="http://wdxtub.com/2015/01/13/manmade-loss/">人造缺憾</a></li>
<li><a href="http://wdxtub.com/2015/01/05/manmade-startup/">人造创业</a></li>
<li><a href="http://wdxtub.com/2015/01/01/manmade-confidence/">人造自信</a></li>
<li><a href="http://wdxtub.com/2014/09/15/manmade-regret/">人造后悔</a></li>
</ol>
<h3 id="u6280_u80FD_u4E09_uFF1A_u601D_u8003"><a href="#u6280_u80FD_u4E09_uFF1A_u601D_u8003" class="headerlink" title="技能三：思考"></a>技能三：思考</h3><p>在前两个技能的基础上，以及非常幸运能获得高人点拨，慢慢也建立起自己的思考能力，从发现问题、观察问题、解决问题最后到寻找问题背后的核心，虽然现在还在努力练习，但是能感觉到自己走在正确的道路上。我觉得对于项目经理来说，思考是最重要的能力，因为很多时候需要从具体的细节中抽离出来，去寻找能把事情做得更好的方法，而思考就是找到这个宝藏的钥匙。希望能够在具体的工作中，不断应用和磨练自己的思考能力，站得更高，看得更远。</p>
<p>比方说最近看的《YC 创业课》与《穷查理宝典》，虽然仍旧未能完全领悟，但是也尽力从中汲取营养，<a href="http://wdxtub.com/2016/01/12/startup-and-investment/">《创业与投资》</a>这篇日志便是我的思考。</p>
<p>再比如我会以生活中的小事为引子深入思考，得到不一样的收获，把看似风马牛不相及的两个事情连接起来，<a href="http://wdxtub.com/2015/12/13/language-and-buybuybuy/">《学语言与买东西》</a>就是我从朋友的小举动中得到『无论是学语言还是买东西，如果从更高更长远的角度来看，都会得出和想当然完全不同的结论，年轻人应该努力去更高的地方看得更远，以发展的眼光看待问题。不管是什么事情，如果能从粒度和深度上细细考量，就会有不一样的答案』这样的结论。</p>
<h3 id="u6280_u80FD_u56DB_uFF1A_u6C9F_u901A"><a href="#u6280_u80FD_u56DB_uFF1A_u6C9F_u901A" class="headerlink" title="技能四：沟通"></a>技能四：沟通</h3><p>自己和其他同学相比最突出的可能就是沟通能力，我会尽力去争取机会做一些大家可能不会想到要去做的事来锻炼自己的沟通能力。我觉得这是作为项目经理非常重要的技能，双方互相理解的程度越高，事情就能办的越好。</p>
<p>我觉得自己给教授拜访朋友全程当口译的经历是一个非常好的锻炼，整个三天的双语互译给我带来了很大的震动，详情可以看<a href="http://wdxtub.com/2015/04/06/two-side/">《二向箔》</a>这篇日志，有几点结论我觉得还挺有意思的：</p>
<ol>
<li>从生活中学到的东西，才是最能运用到生活中去的。不要觉得说自己是学生，就下意识去逃避接触社会。如果担心自己表现得太糟糕，看书，能从别人的经验中学习。观察，总结，验证，慢慢去增长自己的阅历，渐渐开始有自己的理解和想法，这才是学习之道。</li>
<li>不同文化间的交流沟通，其实有点类似于自然界的生殖隔离，我给起了个名字叫文化隔离。具体指的是因为交流双方的文化不同，所处的位置，所站的立场不同，大部分沟通其实都停留在非常低层次的意义上(也就是事实类信息-吃了什么，最近怎么样)，而如果想要有更高层次的沟通，条件则严苛很多。一是对话双方至少要能达到较高的思想境界，二是作为中间人的口译着需要对于两种文化都有较深刻的认识。</li>
<li>比文化隔离低一些层次的隔离是教育隔离。不同于东西方差异，这种隔离更倾向于出现在同一个国家的人群中，因为受教育程度的不同，或者说受到的教育不同，使得不同人对身边世界的认知有着极大的差异，倘若对话双方都无法跳出原有思维进行更高层次的思考，恐怕盲人摸象，无言以对了。</li>
<li>文化隔离和教育隔离并不是不能解决的，至少只要双方达到标准，或者有一个合适的桥梁，就能够很大程度消除这种隔离。最为严重的一种隔离是心智隔离，一旦对话双方有心智隔离，这样的对话几乎很难有任何有意义的产出。心智隔离的产生是一个长期的过程，大量的阅读、思考和写作会有一定程度的帮助，但是从我的角度看来，一旦出现心智隔离，那么也许放弃治疗是最好的选择。</li>
</ol>
<h3 id="u6280_u80FD_u4E94_uFF1A_u7F16_u7A0B"><a href="#u6280_u80FD_u4E94_uFF1A_u7F16_u7A0B" class="headerlink" title="技能五：编程"></a>技能五：编程</h3><p>因为项目经理还需要参与技术，有扎实的技术背景，尤其是了解不同技术内在的本质及原理是非常重要的。在 CMU 学习的课程上至最火热的云计算与计算机视觉，下至汇编 C 语言与基本的硬件原理，再加上机器学习的相关知识以及软件架构的的具体应用，我对整个计算机学科有了更加深入和全面的的认识，我觉得这对于一个项目经理来说是非常重要的，尤其是在理解客户需求，转换成具体的功能上时，经过长期系统训练所得到的『直觉』会很有帮助。</p>
<p>最近我也在努力把正在学和已经学习的知识以课程笔记的形式分享出来，一是加深自己的理解，二是让更多的人能接触到高质量的中文资源。包括：</p>
<ul>
<li>云计算</li>
<li>深入理解计算系统(CSAPP)</li>
<li>软件架构与设计</li>
<li>并发编程</li>
<li>计算机学科基础知识</li>
<li>计算机相关工具指南</li>
<li>数据结构与算法</li>
<li>等等</li>
</ul>
<p>具体的列表可以参加<a href="http://wdxtub.com/about/">这里</a>，相信通过这种方式，不但自己的学习更扎实，也能把知识分享出去。我觉得这种开放和共赢的心态，对于一个项目经理也是非常重要的。</p>
<p>我也整理出了自己的历年来比较完整的项目作为<a href="http://wdxtub.com/portfolio/">作品集</a>，会比简历中说明得更加清晰。</p>
<h2 id="u7231_u597D"><a href="#u7231_u597D" class="headerlink" title="爱好"></a>爱好</h2><p>日常生活中我的兴趣爱好从某种程度来说也有助于我胜任项目经理这个职位。</p>
<ul>
<li>旅行<ul>
<li>去过除大西部外的大部分省份，在不同的环境中学习如何跟各行各业的人打交道</li>
<li>知道在什么情况下应该跟什么人怎么样说话</li>
</ul>
</li>
<li>运动<ul>
<li>日常长跑，在寻找与突破自己的生理极限中，更加深入理解自己</li>
<li>不断磨练自己的意志力，即使遇到困难也要尽力把事情坚持下去</li>
</ul>
</li>
</ul>
<h2 id="u957F_u5904"><a href="#u957F_u5904" class="headerlink" title="长处"></a>长处</h2><p>除了前面提到的技能，我还有下面一些特质让我能够胜任各项工作</p>
<ul>
<li>坚持<ul>
<li>遇到困难不会轻易放弃，而是从不同的失败中利用排除法摸索出正确的道路</li>
<li>即使犯了错误也能很快从打击中恢复，屡败屡战，朝抵抗力最大的路径走</li>
</ul>
</li>
<li>不好面子<ul>
<li>意识到自己弄错了会立刻承认，不会觉得丢面子，把事情做好才是最重要的</li>
<li>不会好大喜功，更愿意让真正做出贡献的人得到超出其预期的所得</li>
</ul>
</li>
<li>乐于分享<ul>
<li>希望能有更多高质量的中文资源被创造出来（也是为什么坚持写博客的原因）</li>
<li>共同进步，水涨船高，自己的水平是身边五个人的平均水平</li>
</ul>
</li>
</ul>
<h2 id="u77ED_u5904"><a href="#u77ED_u5904" class="headerlink" title="短处"></a>短处</h2><p>当然，也有一些日常工作学习逐渐累积下来的缺点</p>
<ul>
<li>有时过分相信自己的直觉<ul>
<li>应该从直觉开始，用数据和证据来验证自己的想法，而不是故意『凑』结论</li>
</ul>
</li>
<li>有时会比较固执<ul>
<li>应该更多接触不同的思维模型，尝试从不同角度去理解可能看起来『不太靠谱』的想法，并以此为基础共同讨论出最合理的方案</li>
</ul>
</li>
</ul>
<h2 id="u5199_u5728_u6700_u540E"><a href="#u5199_u5728_u6700_u540E" class="headerlink" title="写在最后"></a>写在最后</h2><p>以上就是我的职业规划和自己为什么想做，为什么能胜任项目经理这一职位的想法，可能有点啰嗦，但的确是希望能尽可能展示自己，希望能有机会进行进一步的沟通交流。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇文章，<a href="http://wdxtub.com/2016/03/04/na-job-soft-skill/">北美找工作软实力指南</a>中提到了给自己定位的分析与思考方法，这里以自己为例子，来看看如何更好地找到自己并展示自己。</p>]]>
    
    </summary>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="自我" scheme="http://wdxtub.com/tags/%E8%87%AA%E6%88%91/"/>
    
      <category term="软实力" scheme="http://wdxtub.com/tags/%E8%BD%AF%E5%AE%9E%E5%8A%9B/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo 主题 Maupassant 换图标教程]]></title>
    <link href="http://wdxtub.com/2016/03/05/maupassant-icon-config/"/>
    <id>http://wdxtub.com/2016/03/05/maupassant-icon-config/</id>
    <published>2016-03-05T17:08:20.000Z</published>
    <updated>2016-03-05T20:40:37.000Z</updated>
    <content type="html"><![CDATA[<p>折腾主题恐怕是搭建独立博客最痛并快乐的事情了。尤其是对我这种前端菜鸟来说，很多东西明明知道对应资源文件在哪里，却愣是不知道从何下手。今天我们说说，如何给 Hexo 主题 maupassant 换上自己喜欢的图标。</p>
<a id="more"></a>
<hr>
<p>使用 Hexo 以来，换过不少主题，不想用太『大众』的，『小众』的却往往文档不全想改也不知道从何下手。寻寻觅觅，总算找到了一个心仪的 —— <a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="external">Maupassant</a>（这里我用的是 tufu9441 个人定制的版本，也有两百多个 star 了，赞）。只因介绍中的一句话：</p>
<blockquote>
<p>大道至简</p>
</blockquote>
<p>整个博客非常简洁干净，虽然还有一些我觉得不是很满意的地方，不过暂时来说是小问题，我可以一边学一边改。目前来说，整体效果是这样的：</p>
<p><img src="/images/14572005603940.jpg" alt="整体效果"></p>
<p>接下来就是重点了，不同栏目的的图标（就是技术、生活、作品等）是我一直想定制的，其实文档里也给出了具体的方法和资源地址，可惜我不懂前端，看着也还是不会。隔一段时间总要试一试，屡败屡战，终于没有苦劳也有疲劳，算是弄清楚的怎么换图标。</p>
<p>其实思路也不难，就是先生成对应的图标，然后想办法在网页中显示出来，但是这着实让我摸索了一段时间。</p>
<p>第一步，到 <a href="https://icomoon.io/" target="_blank" rel="external">IcoMoon</a> 的网站中，点击右上角的 <a href="https://icomoon.io/app/#/select" target="_blank" rel="external">IcoMoon App</a>，然后就可以来到下面的图标选择页面：</p>
<p><img src="/images/14572008612929.jpg" alt="图标选择页面"></p>
<p>选择你喜欢的图标，然后点击右边的 Generate Font（我之前就一直以为是左边的 SVG 什么的，所以死活不成功），就会出现一个给你改名字的机会（这也就是对应生成的索引信息）</p>
<p><img src="/images/14572011524694.jpg" alt=""></p>
<p>然后再点击下载，正常情况下就可以了，下载之后就会得到这样一个文件夹：</p>
<p><img src="/images/14572009951366.jpg" alt=""></p>
<p>我们来比较一下 maupassant 主题的结构：</p>
<p><img src="/images/14572010529465.jpg" alt=""></p>
<p>发现了！都有 fonts 这个文件夹！里面的文件还一样，所以二话不说，赶紧复制粘贴过去，然后对应修改主题的配置文件（注意 icon 为前缀的图标名称）</p>
<p><img src="/images/14572012141830.jpg" alt=""></p>
<p>结果发现并没有用，甚至原来可以的都显示不出来了，但是发生了一个奇怪的现象，有一个图标能显示，但是错乱了位置，于是我猜想，肯定是哪里需要索引这些文件。再看看下载得到的 icomoon 文件夹中有一个 style.css，发现里面有这么一段：</p>
<p><img src="/images/14572013574673.jpg" alt="下载得到的 style.css"></p>
<p>于是一顿搜索，在 maupassant 主题的 style.scss 文件中也找到了类似的行，于是直接把整段复制过去。再部署，就可以看到效果啦！</p>
<p><img src="/images/14572015499052.jpg" alt=""></p>
<p>万万没想到原来这么简单，也要感谢这次尝试失败后的『灵机一动』，也因此找到了正确的用法。最后说一下选择这些图标的原因吧：</p>
<ul>
<li>首页：小房子的图标，基本是通用惯例了</li>
<li>技术：插电的图标，提醒自己要不断充电</li>
<li>生活：吃豆人的图标，提醒自己生活就是吃一个豆子再吃另一个，有些豆子会给自己不一样的力量</li>
<li>作品：无限的图标，激励自己要不停创造完整的作品</li>
<li>归档：软盘的图标，复古风，有保存的意思，也向上古和中古时代的程序员致敬</li>
<li>订阅：RSS 的图标，也算是惯例了</li>
</ul>
<p>希望以后能把自己的博客改得越来越好，虽然自己依然在纷繁的前端技术中找不到方向。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>折腾主题恐怕是搭建独立博客最痛并快乐的事情了。尤其是对我这种前端菜鸟来说，很多东西明明知道对应资源文件在哪里，却愣是不知道从何下手。今天我们说说，如何给 Hexo 主题 maupassant 换上自己喜欢的图标。</p>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://wdxtub.com/tags/Hexo/"/>
    
      <category term="icomoon" scheme="http://wdxtub.com/tags/icomoon/"/>
    
      <category term="主题" scheme="http://wdxtub.com/tags/%E4%B8%BB%E9%A2%98/"/>
    
      <category term="图标" scheme="http://wdxtub.com/tags/%E5%9B%BE%E6%A0%87/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Programming iOS9 学习笔记 10 - Text]]></title>
    <link href="http://wdxtub.com/2016/03/05/programming-ios9-translation-10/"/>
    <id>http://wdxtub.com/2016/03/05/programming-ios9-translation-10/</id>
    <published>2016-03-05T12:07:13.000Z</published>
    <updated>2016-03-05T14:34:48.000Z</updated>
    <content type="html"><![CDATA[<p>几乎所有的应用都需要显示文字，iOS 以简单的方式提供了强大且复杂的文字显示功能，很多时候我们只需要指定文字内容即可，这一章我们来看看 Text 的相关内容。</p>
<a id="more"></a>
<hr>
<p>Text 形式主要有两种：<code>NSString</code> 和 <code>NSAttributedString</code>，后者可以设定不同的风格，比如字符、段落、行距等等。具体显示只需要在 graphics context 上绘制，或者交给知道如何去绘制的对象：</p>
<p><img src="/images/14571810008511.jpg" alt=""></p>
<p>所有的文本绘制依赖于底层的 C API(<code>Core Text</code>)，不过现在 iOS 提供 <code>Text Kit</code> 使我们可以很方便的来进行操作。另一个绘制文字的方法是使用 web view，比方说 PDF, RTF, DOC 什么的。</p>
<h2 id="Fonts_and_Font_Descriptors"><a href="#Fonts_and_Font_Descriptors" class="headerlink" title="Fonts and Font Descriptors"></a>Fonts and Font Descriptors</h2><p>描述字体的方式有两种</p>
<ol>
<li><code>UIFont</code>：用于 <code>NSString</code> 或 UIKit 对象</li>
<li><code>CTFont</code>：用于 Core Text</li>
</ol>
<p>iOS 7 之前这俩居然协同起来不大方便，比方说要做一些变换，先要从 <code>UIFont</code> 换成 <code>CTFont</code>，然后在手动切换回来，不过现在已经没有这个问题了。另外一个比较重要的是 <code>CTFOntDescriptor</code>，在做 font transformation 的时候很有用。</p>
<p>字体是非常简单的对象，在初始化的时候可以指定名称和大小 <code>init(name:size:)</code>。下面的方法可以得到所有已安装字体的名字：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIFont</span>.familyNames().<span class="built_in">map</span> &#123;<span class="type">UIFont</span>.fontNamesForFamilyName($<span class="number">0</span>)&#125;</span><br><span class="line">    .forEach &#123;(n:[<span class="type">String</span>]) <span class="keyword">in</span> n.forEach &#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>系统字体可以通过 <code>systemFontOfSize:weight:</code> 来访问，weight 具体就是一个 <code>CGFloats</code>，如下：</p>
<p><img src="/images/14571820299805.jpg" alt=""></p>
<p><img src="/images/14571820506614.jpg" alt=""></p>
<h3 id="u52A8_u6001_u5B57_u4F53_u7C7B_u578B"><a href="#u52A8_u6001_u5B57_u4F53_u7C7B_u578B" class="headerlink" title="动态字体类型"></a>动态字体类型</h3><p>使用动态字体，用户可以在设置中更改字体的大小，对于不同的字体，我们不需要指定具体的大小，而是调用 <code>UIFont</code> 的 <code>preferredFontForTextStyle:</code>，可能的参数有：</p>
<p><img src="/images/14571823862991.jpg" alt=""></p>
<p><img src="/images/14571824014617.jpg" alt=""></p>
<p>为了能够根据用户的设置改变字体大小，需要注册 <code>UIContentSizeCategoryDidChangeNotification</code>，另外在字体大小变化的时候可能需要界面的改动，这时候 autolayout 就很有用了。下面是一个具体的例子，我们根据用户的设置来改变字体大小：</p>
<p><img src="/images/14571825459558.jpg" alt=""></p>
<p><img src="/images/14571825561811.jpg" alt=""></p>
<p>从 iOS 8 开始，<code>UITableView</code> 会依照设定自动更新而不用做这么多额外的工作</p>
<h3 id="u6DFB_u52A0_u5B57_u4F53"><a href="#u6DFB_u52A0_u5B57_u4F53" class="headerlink" title="添加字体"></a>添加字体</h3><p>有两种方法可以添加字体：</p>
<p><img src="/images/14571827009066.jpg" alt=""></p>
<p>如果要实时下载的话，需要 <code>import CoreText</code> 并且调用 <code>CTFontDescriptorMatchFontDescriptorsWithProgressHandler</code>（应该被放到后台线程），下面是一个具体的例子：</p>
<p><img src="/images/14571828209821.jpg" alt=""></p>
<p>这里注意，<code>print</code> 不是线程安全的，所以我们使用 <code>NSLog</code>。</p>
<p>Font Descriptors 部分内容比较基础，不懂时可以看看官方文档，这里略过</p>
<h2 id="Attributed_Strings"><a href="#Attributed_Strings" class="headerlink" title="Attributed Strings"></a>Attributed Strings</h2><p><img src="/images/14571829592932.jpg" alt=""></p>
<p>一个 <code>NSAttributedString</code> 包含 <code>NSString</code> 和对应的属性，比较重要的有：</p>
<p><img src="/images/14571830030382.jpg" alt=""></p>
<p><img src="/images/14571830182091.jpg" alt=""></p>
<p><img src="/images/14571830302896.jpg" alt=""></p>
<p><img src="/images/14571830444900.jpg" alt=""></p>
<p>构造 <code>NSAttributedString</code> 时，如果整个字符串的 attributes 相同的话可以使用 <code>init(string:attributes:)</code>，不然的话就使用 <code>NSMutableAttributedString</code>，这个类中我们可以具体设置不同 attributes 的范围。如果是段落属性的话则用 <code>NSParagraphStyle</code>。这俩都自带默认值，所以我们只需要设置关心的 attributes 就好。</p>
<p>我们来看一个具体的例子：</p>
<p><img src="/images/14571833506635.jpg" alt=""></p>
<p>如果我们想要让整一段居中的话，可以用如下的代码（注意 <code>firstLineHeadIndent</code> 需要单独设置）</p>
<p><img src="/images/14571834084982.jpg" alt=""></p>
<p><img src="/images/14571834298856.jpg" alt=""></p>
<p>再来一个例子，如果我们想让第一个字符变大的话，可以这么做：</p>
<p><img src="/images/14571834716206.jpg" alt=""></p>
<p>效果如下：</p>
<p><img src="/images/14571834811712.jpg" alt=""></p>
<p>但是可以看到第三行中缩进去了一块，我们可以用下面的代码来让它更好看一些：</p>
<p><img src="/images/14571835497442.jpg" alt=""></p>
<p>效果如下：</p>
<p><img src="/images/14571835610156.jpg" alt=""></p>
<p>最后是把两个效果合并起来的样子：</p>
<p><img src="/images/14571836150901.jpg" alt=""></p>
<p><strong>Tab stops</strong></p>
<p>有的时候我们还需要使用制表符，那么可以使用 <code>NSTextTab</code>，下面之际上例子（可以看到是按照小数点对齐的）：</p>
<p><img src="/images/14571839916429.jpg" alt=""></p>
<p><strong>Text attachments</strong></p>
<p>实际上就是内联的图像，使用图片数据来初始化 <code>NSTextAttachment</code> 即可，再来看一个例子：</p>
<p><img src="/images/14571840929748.jpg" alt=""></p>
<p>效果如下</p>
<p><img src="/images/14571841032318.jpg" alt=""></p>
<p><strong>从文件导入</strong></p>
<p>我们也可以直接从诸如 RTF 文件中直接导入格式，就不用在代码里设置这么麻烦了，比如：</p>
<p><img src="/images/14571844313983.jpg" alt=""></p>
<h3 id="Modifying_and_Querying_an_Attributed_String"><a href="#Modifying_and_Querying_an_Attributed_String" class="headerlink" title="Modifying and Querying an Attributed String"></a>Modifying and Querying an Attributed String</h3><p>基本的字符串操作也是支持的，也可以根据需要自定义每个字符的属性</p>
<p><img src="/images/14571845719969.jpg" alt=""></p>
<p>当然，我们也可以不用内置的控件，直接绘制文字，如：</p>
<p><img src="/images/14571846456322.jpg" alt=""></p>
<p>在这个例子中，直接把文字绘制到了图片的 context 中。同理，我们也可以直接在 UIView 的 <code>drawRect:</code> 方法中绘制，如：</p>
<p><img src="/images/14571847058762.jpg" alt=""></p>
<p>我们也可以用类似 <code>boundingRectWithSize:options:context:</code> 这样的方法来测量具体的大小，这里注意 <code>.UsesLineFragmentOrigin</code> 的设置，不然得到的值会非常小，获取到的高度可能带有小数部分，注意向上取整。</p>
<h2 id="Labels"><a href="#Labels" class="headerlink" title="Labels"></a>Labels</h2><p>对于 UILabel，<code>numberOfLines</code> 属性非常重要（配合上 line breaking 和 resizing），Line breaking 的一些规则如下：</p>
<p><img src="/images/14571849774329.jpg" alt=""></p>
<p><img src="/images/14571850016896.jpg" alt=""></p>
<p>要让 label 的文字自动适应长宽调整的大小的话，在代码中设置 <code>sizeToFit</code> 即可。</p>
<h2 id="Text_Fields"><a href="#Text_Fields" class="headerlink" title="Text Fields"></a>Text Fields</h2><p>这部分的内容比较基础，倒是跟文本框相关的另一个问题比较重要，就是怎么处理键盘。比方说可能遮挡内容，或者输入完成后如何让键盘消失。</p>
<p>但其实机制还是很简单的：</p>
<p><img src="/images/14571854772650.jpg" alt=""></p>
<p>所以实际上只要修改 first responder 的状况即可：</p>
<p><img src="/images/14571855137876.jpg" alt=""></p>
<p>奇怪的是，我们其实没办法很方便知道哪个 view 是 first responder。倒是有一个 <code>isFirstResponder</code> 方法来检测，不过这就意味着我们需要遍历所有 view 才能确定。一个方法是事先保存好谁是 first responder，一般在 text field 的 <code>textFieldDidBeginEditing:</code> 中设置。</p>
<p>如果想让用户在输入完成后按回车去掉键盘的话，可以重写 text field 的代理方法，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">textFieldShouldReturn</span><span class="params">(tf: UITextField)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    tf.resignFirstResponder()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Keyborad_Covers_Text_Field"><a href="#Keyborad_Covers_Text_Field" class="headerlink" title="Keyborad Covers Text Field"></a>Keyborad Covers Text Field</h3><p>处理键盘遮挡的时候，以下的通知会很有用：</p>
<p><img src="/images/14571860606126.jpg" alt=""></p>
<p>在 iPad 上因为键盘还可以分离，所以会有另外两个通知</p>
<p><img src="/images/14571861165823.jpg" alt=""></p>
<p>通知中的 <code>userInfo</code> 字典包含各类信息，如：</p>
<p><img src="/images/14571861447808.jpg" alt=""></p>
<p>具体来说，可以根据不同的界面风格，来选择如何处理遮挡问题，我们可以</p>
<ol>
<li>Sliding the interface，也就是整个界面往上飞</li>
<li>直接改变 frame 的大小</li>
</ol>
<p>具体的代码这里略过，注意保证应用中的处理方式比较一致即可</p>
<h3 id="Configuring_the_Keyborad"><a href="#Configuring_the_Keyborad" class="headerlink" title="Configuring the Keyborad"></a>Configuring the Keyborad</h3><p>可以定制键盘，加入一些额外的功能</p>
<p><img src="/images/14571864352162.jpg" alt=""></p>
<p>具体的做法是在键盘上添加一个 <code>inputAccessoryView</code>，然后就可以在之中做不同的操作了：</p>
<p><img src="/images/14571864705916.jpg" alt=""></p>
<p>比方说，有些键盘类型没有返回按键，这时候我们就需要自己来了。</p>
<p>iOS9 中，我们可以添加 bar button（<code>inputAssistantItem</code>，针对 iPad），比方说我们可以用如下代码添加一个照相机的按钮：</p>
<p><img src="/images/14571865845732.jpg" alt=""></p>
<h3 id="Text_Field_Delegate_and_Control_Event_Messages"><a href="#Text_Field_Delegate_and_Control_Event_Messages" class="headerlink" title="Text Field Delegate and Control Event Messages"></a>Text Field Delegate and Control Event Messages</h3><p>这里我们大概了解下相关的代理方法：</p>
<p><img src="/images/14571866342387.jpg" alt=""></p>
<p>比方说，我们可以只让用户输入小写字母，如下：</p>
<p><img src="/images/14571866536210.jpg" alt=""></p>
<p><img src="/images/14571866843681.jpg" alt=""></p>
<p>我们同样也可以在不同的时候给 text field 加上不同的 target-action 操作</p>
<p><img src="/images/14571867374814.jpg" alt=""></p>
<p>比方说，可以用下面的技巧，不写代码（或者很少代码）来让键盘自动消失：</p>
<p><img src="/images/14571868075239.jpg" alt=""></p>
<p>用户双击或者长按 text field 的时候，会出现菜单，比较常见的操作有：</p>
<p><img src="/images/14571869442936.jpg" alt=""></p>
<p>我们也可以自定义不同的菜单，加上对应的操作，具体这里不赘述</p>
<h2 id="Text_Views"><a href="#Text_Views" class="headerlink" title="Text Views"></a>Text Views</h2><p>Text View 和 text field 很类似，是一个 scroll view 的子类，但不是一个 control：</p>
<p><img src="/images/14571871067875.jpg" alt=""></p>
<p><img src="/images/14571871132224.jpg" alt=""></p>
<p>text view 的代理方法和通知同样和 text field 很类似：</p>
<p><img src="/images/14571871588928.jpg" alt=""></p>
<p>但是也有一些不同：</p>
<p><img src="/images/14571871701897.jpg" alt=""></p>
<p><img src="/images/14571871838313.jpg" alt=""></p>
<h2 id="Text_Kit"><a href="#Text_Kit" class="headerlink" title="Text Kit"></a>Text Kit</h2><p>在 <code>UITextView</code> 中可以直接访问 Text Kit 引擎，如：</p>
<p><img src="/images/14571879660310.jpg" alt=""></p>
<p>具体包括：</p>
<p><img src="/images/14571879856074.jpg" alt=""></p>
<p>具体有很多技巧，可以做出很浮夸的效果，以后专门写一篇，这里不深入了。</p>
<p>其实不需要 Text view 也可以使用 Text Kit，同样是直接绘制的方式。这部分内容还是需要更多的实践，后面会出实例教程的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>几乎所有的应用都需要显示文字，iOS 以简单的方式提供了强大且复杂的文字显示功能，很多时候我们只需要指定文字内容即可，这一章我们来看看 Text 的相关内容。</p>]]>
    
    </summary>
    
      <category term="Text" scheme="http://wdxtub.com/tags/Text/"/>
    
      <category term="iOS9" scheme="http://wdxtub.com/tags/iOS9/"/>
    
      <category term="学习" scheme="http://wdxtub.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://wdxtub.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[北美找工作软实力指南]]></title>
    <link href="http://wdxtub.com/2016/03/04/na-job-soft-skill/"/>
    <id>http://wdxtub.com/2016/03/04/na-job-soft-skill/</id>
    <published>2016-03-04T22:34:02.000Z</published>
    <updated>2016-03-05T02:22:39.000Z</updated>
    <content type="html"><![CDATA[<p>在北美找工作，除了基本的『硬实力』外，很多文化相关的『软实力』可能也起到了至关重要甚至是决定性的作用，这里总结了我在 CMU 研讨班学到的相关知识，希望能给还在努力『揾食』的同学们一些帮助。</p>
<a id="more"></a>
<hr>
<h2 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文的主要内容，来自于 ICC(Intercultural Communication Center) 关于找工作面试的讲义以及老师在研讨班上的讲解。上一次的学习记录在 <a href="http://wdxtub.com/2016/02/23/pronunciation-stress/">英语口语中的『噪声』</a> 一文中。</p>
<p>开始之前，一定要先摆正心态，之所以把这一点特别拿出来说明，因为我深知我们的文化中包含着的对『野路子草根逆袭』的『倾向』（比如说，对太平天国的『评价』）。但是至少在找工作这件事情上，有没有受过培训，有没有去刻意练习，身经百战的面试官肯定是能一眼看出来的。这里说的培训，主要指的是，在从学校过渡到社会的过程中，有没有针对性去进行职业态度的培训。从衣着仪态，到礼节谈吐，最后到对自己的认知，都是题中之义。当然，不可否认有些人天赋异禀，不需要太多训练就可以自然切换到『职业』模式，但是对于更多的人来说，参加不同的研讨班，有针对性地打磨自己的各项『软实力』，从依赖直觉（可能是天赋，也可能是幻想出来的）逐渐变成依赖技能，才是稳扎稳打的选择。</p>
<p>美国的学生从高中起就会开始做性格评估以寻找自己可能适合的工作，并且在找工作找实习的时候会花大量的时间上培训班，进行刻意练习。我们作为『外国人』，本身在语言和文化适应性上就差了一截，更应该花时间去认真打造自己的软实力，善于利用各种专业资源（研讨班，职业发展中心等等）来快速提高自己。闭门造车后『一鸣惊人』需要的天资和努力远超大部分人想象，还是不断在实践中提高自己比较靠谱（或者直接可以说，软实力闭门造车没用，因为最终还是需要根据实际来调整）。</p>
<p>另外，其实不存在某个『准备好了』的时间点，做任何事情（不只是找工作），我们都应该好好评估自己之前的经验，试着让下一次比上一次更好，用发展的眼光看问题，也许才是找到最终答案的『捷径』。</p>
<p>举个例子，CMU 定期有各种各样的培训班，细致到找工作的每一个环节，比如：</p>
<ul>
<li>推荐信是什么，应该怎么写</li>
<li>面试应该穿什么</li>
<li>面试过程中的仪态应该怎么样</li>
<li>作为打开话题的 Small Talk 应该怎么说</li>
<li>怎么样自我介绍</li>
<li>在边吃饭边面试的场景中，应该如何表现</li>
<li>如何利用所谓的『关系』</li>
<li>如何回答某些『常规』问题</li>
</ul>
<p>这些东西如果要自己模式，恐怕要花费大量的时间和精力，为什么不利用好学校的资源，去『武装』一下自己呢？（很多同学眼里只有刷题却不去准备自己的软实力，就属于看起来感动自己的勤奋却没多少功效的战术勤奋战略偷懒）</p>
<p>虽然很多东西无法『训练』出来，毕竟江山易改本性难移，但是我们至少可以变得更有『职业素养』一些。</p>
<h2 id="u95EE_u95EE_u81EA_u5DF1"><a href="#u95EE_u95EE_u81EA_u5DF1" class="headerlink" title="问问自己"></a>问问自己</h2><ul>
<li>What expectations/concerns do you have about job interviewing in the US?</li>
<li>Think about the kind of job you might look for. Be <strong>specific</strong>: job title, company, location, type, etc</li>
<li>Highlight your skills in relation to the job listed above</li>
<li>What are your strengths in relation to this job</li>
<li>What are your weaknesses</li>
<li>What are your <strong>short-term</strong> career goals</li>
<li>What are your <strong>long-term</strong> career goals</li>
</ul>
<p>这些问题其实一点都不好回答，无论是『找到自己』还是『认识自己』都是非常艰难的，但是不去找，就肯定找不到。</p>
<p>不过还是可以给出一点我自己的经验，多去试试，不知道自己想要什么，那么就不如排除法，看看自己不喜欢什么（这个一般比较容易感觉出来），慢慢就能找到方向了。</p>
<h2 id="u8F6F_u5B9E_u529B_u8981_u70B9"><a href="#u8F6F_u5B9E_u529B_u8981_u70B9" class="headerlink" title="软实力要点"></a>软实力要点</h2><ul>
<li>Highlight your skills and experience (not the time to be modest - you have to “sell yourself”)</li>
<li>Demonstrate cultrually appropriate trait, e.g. assertiveness, awareness of strengths and goals</li>
<li>Use “small talk” to show your social and cultural expertise</li>
<li>Communicate with non-verbal aspects of the interview: dress, handshakes, eye-contact, posture</li>
<li>Make use of the “networking” connections that are acceptable in the United States</li>
<li>Respond to the kinds of questions asked in US interviews</li>
</ul>
<p>下面是具体的要点叙述，篇幅所限不展开了（硬广：如果需要具体情况具体分析，欢迎来请我吃饭）</p>
<h3 id="Self_Promotion"><a href="#Self_Promotion" class="headerlink" title="Self Promotion"></a>Self Promotion</h3><ul>
<li>Assertiveness</li>
<li>Confidence in openly discussing goals and accomplishments</li>
<li>Follow-up(thank you notes, phone inquiries)</li>
<li>Appropriate dress</li>
</ul>
<p>不止要说自己的优点，还要用具体的事例证明，学会讲故事（不会讲故事的创业公司都死了）</p>
<p>如果可能，thank you note，一是表示态度，二是补充信息，充分展示自己</p>
<h3 id="Directness_in_Communication"><a href="#Directness_in_Communication" class="headerlink" title="Directness in Communication"></a>Directness in Communication</h3><ul>
<li>Open and direct responses to questions</li>
<li>Eye contact, relaxed posture and appropirate non-verbal behavior</li>
</ul>
<p>有啥说啥，明确说出来，比方说口音，或者语速，直接自己听不清楚，请求说清晰一点或慢一点</p>
<h3 id="Self-Disclosure"><a href="#Self-Disclosure" class="headerlink" title="Self-Disclosure"></a>Self-Disclosure</h3><ul>
<li>Personal descriptions of experiences, hobbies, strengths and weaknesses</li>
<li>Related answer to personality (e.g., leadership style, problem solving abilities)</li>
</ul>
<p>可以说兴趣爱好，但是要说明这些兴趣爱好给你带来了什么，对具体的工作有什么帮助。</p>
<p>想想产品发布会时候的用词和感觉。</p>
<p>是否了解自己，通过缺点和优点两个不同的视角来观察。</p>
<h3 id="Career_goals"><a href="#Career_goals" class="headerlink" title="Career goals"></a>Career goals</h3><ul>
<li>Demonstrating knowledge of self, career goals, and how they relate to this job</li>
<li>Discussion of long-range career plans</li>
</ul>
<p>什么都想做，就什么都做不好。</p>
<p>真的需要好好想这个问题</p>
<h3 id="Informality_of_Interview_Process"><a href="#Informality_of_Interview_Process" class="headerlink" title="Informality of Interview Process"></a>Informality of Interview Process</h3><ul>
<li>Congenial interviewing environment that encorages openness, some joking and exchange of information</li>
</ul>
<p>具体的语境切换，俗称『阅读空气』</p>
<h3 id="Individual_Equality"><a href="#Individual_Equality" class="headerlink" title="Individual Equality"></a>Individual Equality</h3><ul>
<li>Race, sex, age should not affect relationship</li>
</ul>
<p>我的建议是，最好彼此都抽离成一个无性别无年龄无人种的『综合个体』来进行交流</p>
<h3 id="Preparation_about_Organization"><a href="#Preparation_about_Organization" class="headerlink" title="Preparation about Organization"></a>Preparation about Organization</h3><ul>
<li>Obtain as much information as possible about job and organization</li>
<li>Demonstrate awareness in letters and in interview</li>
</ul>
<p>看起来要专业，形式影响心态，不要太随便，心态上认真。比如说即使是电话面试，事先准备好仪容仪表也是一个很好的热身。</p>
<h2 id="u5E38_u89C1_u95EE_u9898_u53CA_u89E3_u7B54"><a href="#u5E38_u89C1_u95EE_u9898_u53CA_u89E3_u7B54" class="headerlink" title="常见问题及解答"></a>常见问题及解答</h2><p>下面是面试中经常会出现的问题，准备好对应的故事来『证明』自己，尤其是后面几条 yes/no 的问题，千万不能说个答案（虽然通常肯定要答 yes）然后开始『谜之沉默』，要抓住机会展示自己。</p>
<p>留意下面问题中面试官可能想要听到的你的特质：</p>
<ul>
<li>Tell me about yourself</li>
<li>What are your major strengths</li>
<li>What are your major weakness</li>
<li>What are your short-range objectives</li>
<li>What are your career objectives</li>
<li>What was the last book you read?</li>
<li>If you could start again, what would you do differently? (Note: you cannot say “nothing”)</li>
<li>What interests you most about the position we have? What interests you least?</li>
<li>Why weren’t your grades better? or why haven’t you obtained a job so far? (Note: do not be defensive; this may be a test of your ability to handle pressure or to analyze your own situation)</li>
<li>What if you were in charge of this (company, research group, department)? Why should we hire you?</li>
</ul>
<p>注意拓展这些 yes/no 问题：</p>
<ul>
<li>Can you work under pressure</li>
<li>Are you a leader</li>
<li>Are you creative</li>
<li>Can you work as a member of a team</li>
</ul>
<p>所有的问题，可以记住关键词，但是整个叙述过程一定要自然，不要背课文。这里举一个例子，比如说面试官问 “Can you work under pressure?”，可以这么回答：</p>
<p>我可以承受压力，你知道在 CMU 期末考试压力非常大（可以具体渲染下如何压力大），但是我还是分配好了时间并得到高分，我觉得这是一个能抗压的表现。</p>
<p>其他的都可以按照这个思路回答。</p>
<h3 id="Small_Talk"><a href="#Small_Talk" class="headerlink" title="Small Talk"></a>Small Talk</h3><p>就是日常开启话题的闲聊，展示基本的社交能力，要注意像乒乓球，有来有回，不要出现『这话我没法接』的情况，具体怎么聊天，又是另一个话题，有空我再说。</p>
<ul>
<li>随口吹水的话题<ul>
<li>天气、居住城市、墙上的作品或者照片、共同兴趣、体育、旅行</li>
</ul>
</li>
<li>绝对不要提的话题<ul>
<li>年龄、宗教、政治、钱、婚姻状况</li>
</ul>
</li>
</ul>
<h2 id="u6700_u540E_u8BF4_u4E24_u53E5"><a href="#u6700_u540E_u8BF4_u4E24_u53E5" class="headerlink" title="最后说两句"></a>最后说两句</h2><p>其实上面任何一个小点都可以展开成一个很大的话题，这里简单举几个例子：</p>
<ul>
<li>仪容仪表<ul>
<li>男生，领带最好不要是红色(aggressive)，蓝色是比较安全的选择（体现团队合作）</li>
<li>女生，千万不要喷香水</li>
<li>穿正装不要穿白袜子</li>
<li>具体可以看看最近美国大选不同竞选人是怎么穿着，以及如何搭配他们对应的竞选风格的</li>
<li>一本书《Dress for Success》</li>
</ul>
</li>
<li>握手要坚定用点力，不过目的不是捏爆别人的手</li>
<li>上面提到的要求很多是有文化冲突的，也就是在美国大家习惯这样，可能在中国是另一套；我们需要意识到这种差别，但是千万不要矫枉过正，尽可能还是要按照自己舒服的方式来表现</li>
<li>守时！有些同学迟到半个小时，老师直接跟他们说 “too late to join”，我觉得这种惩罚方式很好，既然约定好了，就不要浪费大家的时间，或者把自己的话当放屁</li>
</ul>
<p>最后祝愿大家都能找到心仪的工作，贴一段我之前周记里写的话作为结束：</p>
<blockquote>
<p>找工作与其说是找一份工作，不如说是找到自己适合什么工作，化简一下就是找到自己。在不断的测试中了解自己擅长什么，喜欢什么，想要什么，这个很关键。具体到刷题之类的东西，其实是个人努力，有一个基准线在那里，过了就好。我想做什么工作，你能提供什么职位，这两个有多匹配，能不能接受，能接受咱们继续，不行就好聚好散。选择工作就是选择环境，不要被各种乱七八糟的光环亮瞎了双眼，还是那句话，要有自己的判断和选择，不能『随大流』。</p>
</blockquote>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.howtodothings.com/how-to-make-small-talk-during-a-job-interview" target="_blank" rel="external">How To Make Small Talk During a Job Interview</a></li>
<li><a href="https://www.youtube.com/watch?v=OTx_oXdHSis" target="_blank" rel="external">You Look Terrible: How NOT to Dress for a Job Interview</a></li>
<li><a href="https://www.cmu.edu/icc/index.shtml" target="_blank" rel="external">ICC 网站</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在北美找工作，除了基本的『硬实力』外，很多文化相关的『软实力』可能也起到了至关重要甚至是决定性的作用，这里总结了我在 CMU 研讨班学到的相关知识，希望能给还在努力『揾食』的同学们一些帮助。</p>]]>
    
    </summary>
    
      <category term="交际" scheme="http://wdxtub.com/tags/%E4%BA%A4%E9%99%85/"/>
    
      <category term="找工作" scheme="http://wdxtub.com/tags/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="文化" scheme="http://wdxtub.com/tags/%E6%96%87%E5%8C%96/"/>
    
      <category term="英语" scheme="http://wdxtub.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第八周 - 请走人行道]]></title>
    <link href="http://wdxtub.com/2016/03/04/walkway/"/>
    <id>http://wdxtub.com/2016/03/04/walkway/</id>
    <published>2016-03-04T13:13:24.000Z</published>
    <updated>2016-03-04T14:11:24.000Z</updated>
    <content type="html"><![CDATA[<p>不懂什么是骄傲，不懂什么是个性，不懂什么才算胡闹。</p>
<a id="more"></a>
<hr>
<p>腥风血雨的考试周总算是安然度过，虽然还有几百个坑要填，但是至少在接下来了两个月里有比较稳定的时间推进自己的计划了。少不了更高负荷的工作，不过做自己喜欢且想做的事情，本就没有苦与累。</p>
<p>最近的伙食标准比油价还低，基本都是做一顿吃两天，弄点肉加上豆子玉米胡萝卜，呼噜噜就是一大锅，有空的时候炒个青菜，这样每次煮个饭，往饭上一盖一浇，完事儿！时间久了，室友就吐槽『我都问吐了你还没吃吐嘛』。本来想回敬一波鸡汤，不过最后还是决定，只要她们不吐在我锅里，咱们就还是阳关道和独木桥。</p>
<p>不过这样吃有个好处，因为同样的肉往往要吃一个星期，现在对随着时间推移的肉质衰减以及不同部位的口感有了完全不同的认识。不过仔细想想这也有坏处，以后在学校吃快餐肯定得一边想着这是剩了几天的肉一边往肚子里塞了。另外一个收获是不同部位的差别真的跟价钱上反映出来的一致，一开始也许只能大概感觉出不同，但是一直吃吃吃，就真的能吃出个门道。</p>
<p>美国这边的肉（尤其是猪肉）大多带有奇怪的腥臭味（至少我家附近的超市里卖的是这样），区别就是贵的味道小一些，突出表现就是要么需要做之前焯一下，要么就煮的时候需要滤出血渣雪沫（不然味道不好）。抛开这个不说，切肉的时候，不同的纹理，不同的肥瘦，不同的切法都会影响最终的口感。总体来说，还是里脊部分（或者其他同等位置）的肉无论纹理还是口感最好（排骨不在比较之列，带骨头现在比较少吃了）。不过因为纹理结构比较深，最好提前腌制一下，这样更入味。</p>
<p>基础好的肉，口感衰减得比较慢，估计是因为内在结构更加紧密一些；基础差的肉，很快就散架了（可以想象肉松都是什么肉做的）。这个故事告诉我们，如果我们一定要做一块肉，那么要好好锻炼，成为有嚼劲紧实的肌肉，不要做松松垮垮的肥肉（但是五花肉也很好吃，纠结）。</p>
<p>最近身边的同学都进入了找工作找实习的白热化阶段，虽然我现在无论怎么样都有点『站着说话不腰疼』的感觉，不过还是觉得越是在意的事情，越应该淡定。在学校里要获得肯定，更多是一个单边操作，好好学习，好好考试，好好做研究，好好发论文，自然水涨船高。但是工作中不是养，变成了双边关系，很多老师未曾教过的东西，反而成为了关键。</p>
<p>找工作与其说是找一份工作，不如说是找到自己适合什么工作，化简一下就是找到自己。在不断的测试中了解自己擅长什么，喜欢什么，想要什么，这个很关键。具体到刷题之类的东西，其实是个人努力，有一个基准线在那里，过了就好。我想做什么工作，你能提供什么职位，这两个有多匹配，能不能接受，能接受咱们继续，不行就好聚好散。遇到的面试官很多，真正能让我看出有『智慧』的凤毛麟角（挑一道现成的面试题谁不会呢？），很多时候也影响了我对这家公司的看法。选择工作就是选择环境，不要被各种乱七八糟的光环亮瞎了双眼，还是那句话，要有自己的判断和选择，不能『随大流』。</p>
<p>前些天快到学校的时候，脑子里蹦出了『Form』 这个词，没想到特别合适的中文词汇（也许『形成』或者『塑造』合适？）。回忆过去，从小学到初中，从初中到高中，从高中到大学，从大学到研究生，虽然可能当时感觉不到太多的变化，但是按照历史课本的说法，总有那么一个标志性事件，把一条线段一分为二。在这个时间点之前，可以看做是发散的自我逐渐汇聚形成新自我的过程，而在这个时间点之后，是把自己重新散开等待下一个自我形成的过程。新的自我是怎么样的，就是『Form』的过程了。找到几个关键的核心，然后创造出新的『原子』和『分子』，最后形成全新的自己。不破不立，长肌肉是这样，成长同样也是这样。</p>
<p>既然如此，就不要害怕未知，不要害怕迷茫，每次都选择正确的事做很难，不如直接做自己喜欢做的事情（压根不需要选择了），坚持，直到它成为正确的事情。</p>
<p>世界很大无数奥妙，我要寻找我要奔跑，冲进那自由天地，什么事我都要做到。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>不懂什么是骄傲，不懂什么是个性，不懂什么才算胡闹。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="春假" scheme="http://wdxtub.com/tags/%E6%98%A5%E5%81%87/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 反思课 2 并发编程的策略与思考]]></title>
    <link href="http://wdxtub.com/2016/03/03/cc-rethink-2/"/>
    <id>http://wdxtub.com/2016/03/03/cc-rethink-2/</id>
    <published>2016-03-03T12:28:38.000Z</published>
    <updated>2016-03-03T15:03:41.000Z</updated>
    <content type="html"><![CDATA[<p>学习是一个不断改进方法论的过程，<a href="http://wdxtub.com/2016/02/29/cc-15/">第 15 课</a>中，因为自己缺乏对并发编程的基本认识，走了很多弯路。吃一堑长一智，本文着重讲三点：一是为什么我会犯错，二是对并发编程的一些思考，三是结合 Java 语言来探索相关细节。（感谢节瓜 @jiexing 的耐心指导）</p>
<a id="more"></a>
<hr>
<h2 id="u5E94_u7528_u573A_u666F"><a href="#u5E94_u7528_u573A_u666F" class="headerlink" title="应用场景"></a>应用场景</h2><p>因为涉及到具体的问题，所以先大概说明一下应用场景，方便之后的叙述。事情大概是这样的：</p>
<ul>
<li>后端有三台数据库服务器</li>
<li>需要支持两种不同的存储策略（复制机制与分区机制，详情参考<a href="http://wdxtub.com/2016/02/29/cc-15/">这里</a>）</li>
<li>由前端来接收和处理请求（不使用任何缓存）</li>
<li>请求有两种：GET（从数据库读取数据）与 PUT（向数据库写入数据）</li>
<li>数据的格式是键值对</li>
<li>保证数据的强一致性</li>
<li>按照请求的顺序返回响应（按照时间戳来排序）</li>
</ul>
<p>难点在于，每来一个请求，服务器都会新开一个线程来进行处理，多个线程的访问需要保证数据一致性及顺序，如果没有真正理解场景本身，很容易陷入无谓的复杂度，写出冗长却不完备的代码。</p>
<h2 id="u6211_u9519_u4E86"><a href="#u6211_u9519_u4E86" class="headerlink" title="我错了"></a>我错了</h2><p>写代码之前，我花了很多时间，试图找到一个合理的满足一致性和顺序的机制。根据文档的提示，用锁来保证一致性，用优先队列来保证顺序，万万没想到这就是一切复杂度的开端，最后我折腾出来的机制大概是这样的：</p>
<ul>
<li>每个 key 有自己的锁和优先队列</li>
<li>每来一个请求，把它加入到对应 key 的优先队列中</li>
<li>然后开一个线程，取出优先队列的队头进行处理</li>
<li>具体线程之间的同步由锁完成（在停止尝试之前已经变得很复杂，这里不详细展开，总的来说我试图利用三个状态手动控制线程的执行）</li>
<li>因为不同的线程可能需要访问同一个数据结构（这里我用 HashMap 来存储），也要考虑线程同步的问题，于是我决定依赖于『线程安全』的数据结构自动处理好访问冲突</li>
</ul>
<p>看起来还行，但是实际测试的时候既不能保证强一致性也没办法按顺序，甚至还引入了新的问题，这是为什么呢？我总结的原因如下：</p>
<ul>
<li>每次接收请求，新开的线程不一定执行这个请求对应的内容，而是执行队列头，让新线程做太复杂的工作</li>
<li>为了保证逻辑一致性被迫设计状态判断的机制，但是没办法穷举出所有的可能</li>
<li>控制线程时利用自动数据结构+手动逻辑控制，并没有得到半自动冲锋枪突突突的效果，而是乱成了一锅粥</li>
</ul>
<p>后来在瓜瓜的指引下找到了简单且有效的方法，关键点在于：</p>
<ul>
<li>要自动就全自动，要手动就全手动，不要依赖于自己并不完全理解的容器或者数据结构，因为很可能会和自己预期的表现不一样</li>
<li>每个线程应该就处理好传入的请求，而不是可能执行另外的请求（我之前的机制这种情况是可能出现的）</li>
<li>不要想当然去『控制』线程以达到最优性能，很多串行编程的思维在这里并不适用。</li>
</ul>
<p>从这样的思路拓展开去，就可以意识到自己之前的思路有多么『想当然』了。</p>
<h2 id="u4E00_u4E9B_u601D_u8003"><a href="#u4E00_u4E9B_u601D_u8003" class="headerlink" title="一些思考"></a>一些思考</h2><blockquote>
<p>Intuition is frequently wrong - be data intensive. [《Real-World Concurrency》 from ACM-Queue]</p>
</blockquote>
<p>如果要给云计算这门课一个关键词，当属 tradeoff。所谓权衡的艺术，从不同的角度来看，有不同的表现：</p>
<ul>
<li>从实现的角度，尽量以最小的代码换取最大的性能</li>
<li>从架构的角度，尽量以简洁的架构满足需求，减少复杂性</li>
<li>从经济的角度，尽力以最小的花费提供最好的服务质量</li>
</ul>
<p>同样的，对于并发编程，也是如此。</p>
<blockquote>
<p>Multi-threading is easy. Correct synchronization is hard</p>
</blockquote>
<p>最难的当属思维的转换，很多比较复杂的算法（或者说依赖比较多的算法），在并行环境中往往表现不好，比如说动态规划问题，原本是重复利用子问题的解，但是在多线程的条件下，子问题都不知道飞哪里去了；反而是分治算法，因为子问题独立，反而更适合并行。</p>
<p>而提到并发编程，就不得不提 OpenMP 了，这个学期当助教，我主要负责这一部分的内容，所以也算是有一些理解。OpenMP 的思路是利用尽可能少的代价，把串行代码弄成并行的，核心的机制是共享内存，然后利用线程执行不同的子问题，可能只需要几条 OpenMP 预编译指令，就可以带来明显的性能提升效果。</p>
<p>但是仔细想想，这种改进真的很大吗？在串行代码开发中，程序控制有一个清晰的流程。我们知道数据被访问和更改的方式，并了解其中的依赖关系。究其根本，OpenMP 依赖数据资源的锁定，和串行编程的思路是一样的，只是利用多核进行了简单的并行处理（相当于多叫几个人完成同一个工作，而不是大家做不同的工作）。如果使用不慎，除了带来性能问题之外，还可能造成数据不一致的问题。</p>
<p>而真正的并行程序中，有多个状态会同时发生和改变，依赖关系也会发生变化。必须思考如何同时执行多个指令，以及这些指令会对你的数据结构、变量、算法及其它一切产生什么影响。</p>
<p>总结一下：</p>
<ul>
<li>单线程逻辑设计的思路<ul>
<li>所有数据结构的生存期，以及对这些数据结构的访问都在同一个线程，不存在竞争条件，耗时的操作都给其他线程（IO线程、定时器线程，数据库线程等）做，做完之后向事件队列（多线程安全的队列，其他线程是生产者，逻辑线程是消费者）发送事件</li>
</ul>
</li>
<li>多线程逻辑设计的思路<ul>
<li>所有数据结构的生存期，以及对这些数据结构的访问不一定在同一个线程。需要考虑数据结构的竞争条件。网络事件、定时器事件唤醒工作线程（比方说 <code>notifyAll</code>）执行所有工作，一般不需要交换到其他线程</li>
</ul>
</li>
</ul>
<p>我们可以看出，最关键的就是如何访问数据的问题！线程执行和访问数据的时间没有确定的顺序。操作系统负责对线程进行调度，而它对于数据访问模式一无所知。并行程序中唯一的顺序是我们利用同步方法明确创建的（前面我把这部分工作交给自己并不熟悉的并行库来做，导致出问题）。最重要的是要牢牢记住所有并发线程，这样才能够创建更简单更有约束性的结构来限制并发情况。还有一个需要记得的点是，可能最优化的串行算法并不是好的并行算法。</p>
<p>最后的最后，并发编程真的是一门『纸上得来终觉浅』的艺术，最佳途径就是实践，实践，再实践。</p>
<h2 id="u4E00_u4E9B_u5BF9_u7B56"><a href="#u4E00_u4E9B_u5BF9_u7B56" class="headerlink" title="一些对策"></a>一些对策</h2><p>这里结合了 CMU 18645 How to Write Fast Code 课程上的一些思路，虽然对于具体场景不算特别适用，不过总体原则放到哪里都能用。</p>
<p>先说说优化并行部分的三个层面：</p>
<ul>
<li>逻辑层面：减少数据共享<ul>
<li>这一部分需要注意 false sharing 的问题，不然反而会造成大量的缓存浪费</li>
<li>解决方法也不算太难：线程本地存储 + 内存对齐，不过需要根据不同的机器不同处理</li>
</ul>
</li>
<li>编码层面：减少锁粒度<ul>
<li>同一个模块中，对不总是同时访问的数据，使用不同的锁（固定加锁顺序，防止死锁）</li>
<li>使用锁（临界区）来保护数据，而不是操作</li>
<li>将可能耗时的操作移到临界区外面（特别是 IO）</li>
<li>避免在临界区中调用未知代码 </li>
<li>谨慎使用读写锁，实现复杂，效率低下</li>
</ul>
</li>
<li>工具层面：使用轻量同步机制<ul>
<li>有些需要深入到内核态进行同步，对于基本的操作来说其实没必要这么兴师动众</li>
</ul>
</li>
</ul>
<p>换一个视角，可以总结出如下四条原则：</p>
<ol>
<li>单一职责：分离并发相关代码和其他代码（并发相关代码有自己的开发、修改和调优生命周期）</li>
<li>限制数据作用域：两个线程修改共享对象的同一字段时可能会相互干扰，导致不可预期的行为，解决方案之一是构造临界区，但是必须限制临界区的数量</li>
<li>使用数据副本：数据副本是避免共享数据的好方法，复制出来的对象只是以只读的方式对待</li>
<li>线程应尽可能独立：让线程存在于自己的世界中，不与其他线程共享数据。Servlet 就是以单实例多线程的方式工作，和每个请求相关的数据都是通过 Servlet 子类的 service 方法（或者是 doGet 或 doPost 方法）的参数传入的。只要 Servlet 中的代码只使用局部变量，Servlet 就不会导致同步问题</li>
</ol>
<p>在搜索资料的时候发现一个不错的提纲，不过因为刚接触，很多概念理解得不算特别清楚这里列出来，作为一个索引，感兴趣的同学可以按图索骥去深入了解下（参考资料中第二项）：</p>
<ul>
<li>资源并发访问的策略<ul>
<li>悲观策略<ul>
<li>lock based concurrency(theory)</li>
<li>java.util.concurrent (framework)</li>
<li>锁还是不锁，这是个问题， 锁多还是锁少，也是个问题(practice)</li>
</ul>
</li>
<li>乐观策略<ul>
<li>lock free concurrency(theory) : CAS</li>
<li>disruptor (framework)</li>
<li>并发度高，还是并发度低的时候使用，这是个问题(practice)</li>
</ul>
</li>
</ul>
</li>
<li>我拆我拆我拆拆拆（逻辑上拆分任务）<ul>
<li>task-based concurrency (theory)<ul>
<li>Runnable | Callable(model)</li>
<li>Executor | ExecutorService(framework)</li>
</ul>
</li>
<li>data-based concurrency(theory)<ul>
<li>Actor (model)</li>
<li>Akka(framework)</li>
</ul>
</li>
</ul>
</li>
<li>从单机到分布式<ul>
<li>divide and conquer<ul>
<li>map reduce pattern</li>
<li>master-worker pattern</li>
</ul>
</li>
<li>swarm framework(move computation instead of data)</li>
</ul>
</li>
<li>从软件到硬件<ul>
<li>GPU<ul>
<li>CUDA, jcuda, scuda</li>
<li>floating point computation, e.g. image reader and processing</li>
</ul>
</li>
<li>PPU<ul>
<li>物理计算</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>看了这么多，唯一的感受就是</p>
<blockquote>
<p>路漫漫其修远兮，吾将上下而求索。</p>
</blockquote>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.jianshu.com/p/053943a425c3" target="_blank" rel="external">Java并发编程的总结与思考</a></li>
<li><a href="http://afoo.me/posts/2013-03-12-concurrency_theory_frameworks_and_practices.html" target="_blank" rel="external">并发编程： 理论，框架与实践</a></li>
<li><a href="http://blog.csdn.net/lantian0802/article/details/19285937" target="_blank" rel="external">java并发编程学习总结（基础篇）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>学习是一个不断改进方法论的过程，<a href="http://wdxtub.com/2016/02/29/cc-15/">第 15 课</a>中，因为自己缺乏对并发编程的基本认识，走了很多弯路。吃一堑长一智，本文着重讲三点：一是为什么我会犯错，二是对并发编程的一些思考，三是结合 Java 语言来探索相关细节。（感谢节瓜 @jiexing 的耐心指导）</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="多线程" scheme="http://wdxtub.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 Twitter 语料分析 3 Vert.x 配置部署]]></title>
    <link href="http://wdxtub.com/2016/03/01/cc-p3/"/>
    <id>http://wdxtub.com/2016/03/01/cc-p3/</id>
    <published>2016-03-01T20:42:05.000Z</published>
    <updated>2016-03-02T00:19:44.000Z</updated>
    <content type="html"><![CDATA[<p>我们需要比较两个不同的 web 框架的性能，于是也选择了当下比较热门的 Vert.x 框架来做比较，网上的中文资源还是比较少的，这里同样记录一下如何在 EC2 上搭建和部署 Vert.x。</p>
<a id="more"></a>
<hr>
<h2 id="u73AF_u5883_u914D_u7F6E"><a href="#u73AF_u5883_u914D_u7F6E" class="headerlink" title="环境配置"></a>环境配置</h2><p>先启动一个标准的 Ubuntu 镜像（因为有 apt-get 安装软件比较方便）</p>
<p>我们需要安装 java 和 maven，并配置好对应的路径，具体参考下面的命令，这里和之前不同的是需要安装 Java 8，以及 maven 3：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 java,maven</span></span><br><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java8-installer</span><br><span class="line">sudo add-apt-repository <span class="string">"deb http://ppa.launchpad.net/natecarlson/maven3/ubuntu precise main"</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install maven3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认 jdk</span></span><br><span class="line">sudo update-alternatives --config java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 Java Home 编辑 ~/.bashrc</span></span><br><span class="line">JAVA_HOME=/usr/</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span></span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>同样用 maven 来创建项目，这次我们直接手动现在本地建立如下所示的文件层级：</p>
<p><img src="/images/14568662369892.jpg" alt="项目目录"></p>
<p>然后我们修改 <code>pom.xml</code> 文件，具体如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">project</span> <span class="attribute">xmlns</span>=<span class="value">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://maven.apache.org/POM/4.0.0</span><br><span class="line">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="title">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>housailei.vertx<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>vertx-server<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="title">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>io.vertx<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>vertx-core<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="title">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="title">source</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="title">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">execution</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="title">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="title">phase</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="title">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="title">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">transformers</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="title">transformer</span></span><br><span class="line">                    <span class="attribute">implementation</span>=<span class="value">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">manifestEntries</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="title">Main-Class</span>&gt;</span>io.vertx.core.Starter<span class="tag">&lt;/<span class="title">Main-Class</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="title">Main-Verticle</span>&gt;</span>housailei.vertx.App<span class="tag">&lt;/<span class="title">Main-Verticle</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="title">manifestEntries</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="title">transformer</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">transformers</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">artifactSet</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">outputFile</span>&gt;</span>$&#123;project.build.directory&#125;/$&#123;project.artifactId&#125;-$&#123;project.version&#125;-fat.jar<span class="tag">&lt;/<span class="title">outputFile</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们在 <code>src/main/java/housailei/vertx/</code> 下创建一个 <code>App.java</code> 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> housailei.vertx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.core.AbstractVerticle;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; fut)</span> </span>&#123;</span><br><span class="line">    vertx</span><br><span class="line">        .createHttpServer()</span><br><span class="line">        .requestHandler(r -&gt; &#123;</span><br><span class="line">          r.response().end(<span class="string">"&lt;h1&gt;Hello from my first "</span> +</span><br><span class="line">              <span class="string">"Vert.x 3 application! config by dawang&lt;/h1&gt;"</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .listen(<span class="number">8080</span>, result -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">            fut.complete();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fut.fail(result.cause());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们把代码上传回服务器上：<code>scp -i ../group.pem -r ./* ubuntu@dns.amazonaws.com:~/vertx-server/</code></p>
<p>执行的话稍微麻烦一点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn3 clean package</span><br><span class="line">java -jar target/vertx-server-<span class="number">1.0</span>-SNAPSHOT-fat.jar</span><br></pre></td></tr></table></figure>
<p>正常运行如下图所示：</p>
<p><img src="/images/14568725986794.jpg" alt="正常运行截图"></p>
<h2 id="u5B9E_u73B0_REST"><a href="#u5B9E_u73B0_REST" class="headerlink" title="实现 REST"></a>实现 REST</h2><p>前面的代码虽然可以工作，我们没办法设定不同的 api，也没办法做更进一步的处理，所以我们现在来更进一步，实现一个 RESTful 的简易 API。</p>
<p>我们先要在 <code>pom.xml</code> 文件中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>io.vertx<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>vertx-web<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后对应修改 <code>start</code> 方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; fut)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create a router object.</span></span><br><span class="line">   Router router = Router.router(vertx);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bind "/" to our hello message - so we are still compatible.</span></span><br><span class="line">   router.route(<span class="string">"/"</span>).handler(routingContext -&gt; &#123;</span><br><span class="line">   HttpServerResponse response = routingContext.response();</span><br><span class="line">   response</span><br><span class="line">      .putHeader(<span class="string">"content-type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">      .end(<span class="string">"&lt;h1&gt;Hello from my first "</span> +</span><br><span class="line">         <span class="string">"Vert.x 3 application! config by dawang&lt;/h1&gt;"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create the HTTP server and pass the "accept" method to the request handler.</span></span><br><span class="line">   vertx.createHttpServer().requestHandler(router::accept)</span><br><span class="line">       .listen(</span><br><span class="line">       <span class="comment">// Retrieve the port from the configuration,</span></span><br><span class="line">       <span class="comment">// default to 8080.</span></span><br><span class="line">       config().getInteger(<span class="string">"http.port"</span>, <span class="number">8080</span>), result -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">               fut.complete();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               fut.fail(result.cause());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在开始start方法里创建了一个 <code>Router</code> 对象。router 是 Vert.x Web 的基础，负责分发 HTTP 请求到 handler（处理器），在Vert.x Web中还有两个很重要的概念。</p>
<ul>
<li>Route - 定义请求的分发</li>
<li>Handler - 这是实际处理请求并且返回结果的地方。Handlers可以被链接起来使用。</li>
</ul>
<p>如果明白了这3个概念（Router、Routes、Handlers），就能明白 Vert.x Web 了。</p>
<p>重新运行一次，可以看到结果如下：</p>
<p><img src="/images/14568771965878.jpg" alt="再次配置成功"></p>
<p>然后我们多定义几个接口，并对应不同的方法来实现，同样是在 <code>start</code> 方法中，添加两条 router 规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">"/api/hou"</span>).handler(<span class="keyword">this</span>::HouHandler);</span><br><span class="line">router.get(<span class="string">"/api/sai"</span>).handler(<span class="keyword">this</span>::SaiHandler);</span><br></pre></td></tr></table></figure>
<p>然后创建对应的方法（就不用都写在一个函数里了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HouHandler</span><span class="params">(RoutingContext routingContext)</span></span>&#123;</span><br><span class="line">   routingContext.response()</span><br><span class="line">       .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json; charset=utf-8"</span>)</span><br><span class="line">       .end(<span class="string">"This is Hou HOu HOU!!! API!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SaiHandler</span><span class="params">(RoutingContext routingContext)</span></span>&#123;</span><br><span class="line">   routingContext.response()</span><br><span class="line">       .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json; charset=utf-8"</span>)</span><br><span class="line">       .end(<span class="string">"This is Sai SAi SAI!!! API!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再测试一下，可以看到 api 已经启用了：</p>
<p><img src="/images/14568776771132.jpg" alt="Hou Content"></p>
<p><img src="/images/14568776972444.jpg" alt="Sai Content"></p>
<p>有了这些，我们就可以自己来进行操作了，虽然可能代码丑一些，不过易上手，容易改。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://vertx.io/docs/" target="_blank" rel="external">官方文档</a></li>
<li><a href="http://vertx.io/docs/vertx-core/java/" target="_blank" rel="external">Vertx Core 手册</a></li>
<li><a href="http://vertx.io/docs/apidocs/" target="_blank" rel="external">Vertx Core API 文档</a></li>
<li><a href="http://vertx.io/docs/vertx-web/java/" target="_blank" rel="external">Vertx Web 手册</a></li>
<li><a href="http://vertx.io/docs/apidocs/" target="_blank" rel="external">Vertx Web API 文档</a></li>
</ul>
<p>非常有用的新手入门教程</p>
<ul>
<li><a href="http://vertx.io/blog/my-first-vert-x-3-application/index.html" target="_blank" rel="external">My first Vert.x 3 Application</a></li>
<li><a href="http://vertx.io/blog/vert-x-application-configuration/" target="_blank" rel="external">Vert.x Application Configuration</a></li>
<li><a href="http://vertx.io/blog/some-rest-with-vert-x/" target="_blank" rel="external">Some Rest with Vert.x</a></li>
<li><a href="http://vertx.io/blog/unit-and-integration-tests/" target="_blank" rel="external">Unit and Integration Tests</a></li>
<li><a href="https://github.com/quanke/vertx3_study_demo" target="_blank" rel="external">中文机器翻译版本</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们需要比较两个不同的 web 框架的性能，于是也选择了当下比较热门的 Vert.x 框架来做比较，网上的中文资源还是比较少的，这里同样记录一下如何在 EC2 上搭建和部署 Vert.x。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Vertx" scheme="http://wdxtub.com/tags/Vertx/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="服务" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 Twitter 语料分析 2 Undertow 配置部署]]></title>
    <link href="http://wdxtub.com/2016/03/01/cc-p2/"/>
    <id>http://wdxtub.com/2016/03/01/cc-p2/</id>
    <published>2016-03-01T14:41:11.000Z</published>
    <updated>2016-03-01T21:04:27.000Z</updated>
    <content type="html"><![CDATA[<p>因为项目有一定的性能要求，所以我们选择 Undertow 这个微框架来降低框架本身带来的性能影响，但是因为比较小众，所以网上很多资料都不全，这里记录下具体在 EC2 上如何配置和部署 Undertow。</p>
<a id="more"></a>
<hr>
<h2 id="u73AF_u5883_u914D_u7F6E"><a href="#u73AF_u5883_u914D_u7F6E" class="headerlink" title="环境配置"></a>环境配置</h2><p>先启动一个标准的 Ubuntu 镜像（因为有 apt-get 安装软件比较方便）</p>
<p>我们需要安装 java 和 maven，并配置好对应的路径，具体参考下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 java,maven</span></span><br><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java7-installer</span><br><span class="line">sudo apt-get install maven2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认 jdk</span></span><br><span class="line">sudo update-alternatives --config java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 Java Home 编辑 ~/.bashrc</span></span><br><span class="line">JAVA_HOME=/usr/</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span></span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure>
<p>如果一切正常的话，使用 <code>java -version</code> 可以看到：</p>
<p><img src="/images/14568475090854.jpg" alt="java -version"></p>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>我们创建一个项目来搭建服务器，因为 undertow 是使用 maven 来管理包和依赖的，所以我们也直接用 maven 来创建项目</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建项目，注意设置包名和项目名称</span></span><br><span class="line">mvn archetype:generate -DgroupId=housailei.undertow -DartifactId=p1_front -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=<span class="literal">false</span> -DartifactId=undertow-server</span><br></pre></td></tr></table></figure>
<p>为了编辑方便，我们把项目复制到本地</p>
<p><code>scp -i group.pem -r ubuntu@dns.amazonaws.com:~/undertow-server/* ./</code></p>
<p> 编辑完成可以用下面的命令上传回去（注意所在文件夹，我这里新建了一个文件夹用来存放源代码，密钥放在上一层）</p>
<p><code>scp -i ../group.pem -r ./* ubuntu@dns.compute-1.amazonaws.com:~/undertow-server/</code></p>
<p><img src="/images/14568478192103.jpg" alt="目录层级"></p>
<p>我们需要对 <code>App.java</code> 和 <code>pom.xml</code> 做一些修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> housailei.undertow;</span><br><span class="line"><span class="keyword">import</span> io.undertow.Undertow;</span><br><span class="line"><span class="keyword">import</span> io.undertow.server.*;</span><br><span class="line"><span class="keyword">import</span> io.undertow.util.Headers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// 设置成 0.0.0.0 开放访问以便测试</span></span><br><span class="line">        Undertow server = Undertow.builder().addHttpListener(<span class="number">8080</span>, <span class="string">"0.0.0.0"</span>)</span><br><span class="line">            .setHandler(<span class="keyword">new</span> HttpHandler() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> HttpServerExchange exchange)</span></span><br><span class="line">                       <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,</span><br><span class="line">                           <span class="string">"text/plain"</span>);</span><br><span class="line">               exchange.getResponseSender().send(<span class="string">"Hello World! This is wdxtub."</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;).build();</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 pom 文件的修改主要就是加上各类依赖，已经添加构建插件，我们这里选用了最新的 undertow，具体需要添加以下两个部分：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>io.undertow<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>undertow-core<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.3.18.Final<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>io.undertow<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>undertow-servlet<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.3.18.Final<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>和 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">build</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>exec-maven-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">execution</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="title">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">goal</span>&gt;</span>java<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="title">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">mainClass</span>&gt;</span>housailei.undertow.App<span class="tag">&lt;/<span class="title">mainClass</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后上传回 EC2 实例，就可以用以下代码执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile &amp;&amp; mvn <span class="built_in">exec</span>:java</span><br></pre></td></tr></table></figure>
<p>服务器正常开启之后，我们就可以在浏览器中访问了：</p>
<p><img src="/images/14568488280327.jpg" alt="访问网站"></p>
<h2 id="u6DFB_u52A0_Servlet"><a href="#u6DFB_u52A0_Servlet" class="headerlink" title="添加 Servlet"></a>添加 Servlet</h2><p>现在我们的服务器基本除了展示个页面没办法做任何事情，我们需要能让服务器运行 servlet 才行（最新版本的 undertow 会有一些小问题，会具体标记出来）</p>
<p>我们先写两个简单的 servlet，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个 servlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span>&#123;</span><br><span class="line">        message = <span class="string">"Hou HOu HOU!!!! Servlet!!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(<span class="string">"&lt;h1&gt;"</span> + message + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个 servlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaiServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span>&#123;</span><br><span class="line">        message = <span class="string">"Sai SAi SAI!!!! Servlet!!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(<span class="string">"&lt;h1&gt;"</span> + message + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改 <code>App.java</code> 把这两个 servlet 载入进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYAPP = <span class="string">"/hsl"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 官方例子中使用的 addServlets 方法不可用</span></span><br><span class="line">            <span class="comment">// 这里我用了 addServlet 方法</span></span><br><span class="line">            DeploymentInfo servletBuilder = Servlets.deployment()</span><br><span class="line">                .setClassLoader(App.class.getClassLoader())</span><br><span class="line">                .setContextPath(MYAPP)</span><br><span class="line">                .setDeploymentName(<span class="string">"test.war"</span>)</span><br><span class="line">                .addServlet(</span><br><span class="line">                        Servlets.servlet(<span class="string">"HouServlet"</span>, HouServlet.class)</span><br><span class="line">                                .addMapping(<span class="string">"/hou"</span>))</span><br><span class="line">                .addServlet(</span><br><span class="line">                        Servlets.servlet(<span class="string">"SaiServlet"</span>, SaiServlet.class)</span><br><span class="line">                                .addMapping(<span class="string">"/sai"</span>));</span><br><span class="line"></span><br><span class="line">            DeploymentManager manager = Servlets.defaultContainer().addDeployment(servletBuilder);</span><br><span class="line">            manager.deploy();</span><br><span class="line"></span><br><span class="line">            HttpHandler servletHandler = manager.start();</span><br><span class="line">            PathHandler path = Handlers</span><br><span class="line">                .path(Handlers.redirect(MYAPP))</span><br><span class="line">                .addPrefixPath(MYAPP, servletHandler);</span><br><span class="line"></span><br><span class="line">            Undertow server = Undertow.builder()</span><br><span class="line">                .addHttpListener(<span class="number">8080</span>, <span class="string">"0.0.0.0"</span>)</span><br><span class="line">                .setHandler(path)</span><br><span class="line">                .build();</span><br><span class="line">            server.start();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着还是传到服务器上并 <code>mvn compile &amp;&amp; mvn exec:java</code>，就可以看到结果</p>
<p><img src="/images/14568573432825.jpg" alt="SaiServlet 结果"></p>
<p><img src="/images/14568573815710.jpg" alt="HouServlet 结果"></p>
<p>之后的任务就可以在 Servlet 的 <code>doGet</code> 方法中对应写代码完成了。</p>
<p>后面应该会写一些脚本把配置的工作自动化，因为每次新建 EC2 都得重新配置还是挺麻烦的。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://undertow.io/undertow-docs/undertow-docs-1.3.0/index.html#introduction" target="_blank" rel="external">官方文档</a></li>
<li><a href="http://undertow.io/javadoc/1.3.x/index.html" target="_blank" rel="external">官方 JavaDoc</a></li>
<li><a href="https://github.com/undertow-io/undertow/tree/master/examples/src/main/java/io/undertow/examples" target="_blank" rel="external">官方样例代码</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为项目有一定的性能要求，所以我们选择 Undertow 这个微框架来降低框架本身带来的性能影响，但是因为比较小众，所以网上很多资料都不全，这里记录下具体在 EC2 上如何配置和部署 Undertow。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Undertow" scheme="http://wdxtub.com/tags/Undertow/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="服务" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
