<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-03-20T14:31:41.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[足球游戏简史]]></title>
    <link href="http://wdxtub.com/2016/03/20/game-history-football/"/>
    <id>http://wdxtub.com/2016/03/20/game-history-football/</id>
    <published>2016-03-20T14:07:35.000Z</published>
    <updated>2016-03-20T14:31:41.000Z</updated>
    <content type="html"><![CDATA[<p>足球游戏经历了怎样的发展？玩家喜爱哪些类型？足球手游有哪两大分支？作为世界第一大运动的衍生品，足球游戏经历了怎样的发展？玩家喜爱哪些类型？未来又会如何进化？</p>
<a id="more"></a>
<hr>
<h2 id="u7AEF_u6E38_u65F6_u4EE3_uFF0CEA_u4E0EKCEO_u4E8C_u5341_u5E74_u7EB7_u4E89"><a href="#u7AEF_u6E38_u65F6_u4EE3_uFF0CEA_u4E0EKCEO_u4E8C_u5341_u5E74_u7EB7_u4E89" class="headerlink" title="端游时代，EA与KCEO二十年纷争"></a>端游时代，EA与KCEO二十年纷争</h2><p>自上世纪90年代开始人们对于足球游戏的争论，便停留在了“实况”还是“FIFA”上面。</p>
<p>首款FIFA于1993年圣诞节，在PC平台发布，由加拿大人制作，基于电脑开发的FIFA很快的抢占了美洲的PC市场。次年，一款名为：《实况世界足球完美十一人》开始在SFC平台发售，这款游戏由KCEO小组制作的游戏，也就是后来的WE和PES的前身，它的发售也正式吹响了两款游戏近20年纷争号角。</p>
<p>两款游戏的特点对比十分明显，FIFA在游戏节奏上更注重快与流畅，联赛内容上更真实，AI相对与实况更加简单，拥有国际足联的完美授权。实况足球节奏比较慢，设计上更侧重于战术的拿捏，注重对球员个体的设计。</p>
<p>FIFA与实况的斗争也是此消彼长。2006年发售的实况足球PES6在设计上，修正了射门感觉，防守设定也变得合理，犯规不再频繁，只要你肯琢磨，Tiki-taka都不再是问题。节奏感方面，除了刻意的战术犯规外，比赛几乎可以做到不中断，这一代版本在欧洲上市仅8天就卖出了300万份。而FIFA2013更是仅在短短四周就卖出了740万份。</p>
<p>在2004年到2008年，虽然实况足球稳步前进，在PS2等主机平台上表现出色，但是从PES2009后，实况足球全平台全方位的一落千丈。反观FIFA，FIFA在主机方面完全压制实况足球，并且从2011开始全平台统一引擎，加上FIFA的商业能力，次世代引擎爆发的威力，各种细节全方位针对实况足球的学习，逐渐融合了两家的优点。</p>
<p>总结来看，自实况足球PES6之后，EA已经远远将K社甩在了身后。</p>
<h2 id="u53E6_u4E00_u79CD_u6D3B_u8DC3_u65B9_u5F0F"><a href="#u53E6_u4E00_u79CD_u6D3B_u8DC3_u65B9_u5F0F" class="headerlink" title="另一种活跃方式"></a>另一种活跃方式</h2><p>实况足球与FIFA只能代表足球游戏中的体育竞技类，关于其他类型，比如说模拟经营类的足球经理，也被玩家津津乐道。</p>
<p>足球经理是完全不同于实况足球和FIFA的游戏，它表现的不是足球比赛时的竞技与对抗，更多的乐趣来源于模拟。模拟现代足球在比赛背后的庞大产业，这来源于足球这一世界地运动所涉及的国家文化，风土人情、历史发展，玩家要对这一切有足够的了解，才会精通于此类游戏。</p>
<p>另一方面，还有一部分世界观完全架空的足球游戏也受到一部分玩家的喜爱。比如说《热血足球》，《雷门十一人》，《街头足球》等游戏，这些游戏大多以卡通动漫的画风，通过现实中难以做的到足球招式来满足玩家对足球更高动作表现的幻想与追求。</p>
<h2 id="u624B_u6E38_u65F6_u4EE3_uFF0C_u8DB3_u7403_u6E38_u620F_u7684_u4E24_u5927_u5206_u652F"><a href="#u624B_u6E38_u65F6_u4EE3_uFF0C_u8DB3_u7403_u6E38_u620F_u7684_u4E24_u5927_u5206_u652F" class="headerlink" title="手游时代，足球游戏的两大分支"></a>手游时代，足球游戏的两大分支</h2><p>最初，功能机时代的足球游戏大多是模仿与移植主机平台的游戏玩法。随着智能机的兴起，移动终端上的足球游戏逐渐演化成两个分支。</p>
<p>第一类是重度操作类，其特点是真实性强，基本上将PC上和大型家用游戏机上的游戏场景，还原到了手机和移动终端设备上，渴望还原给球迷玩家主机平台上足球游戏真实的代入感。《FIFA2013》，《PES2012》都是这种类型的代表作品，这两款游戏都强调将主机平台上，足球游戏的节奏感展现在手机上，从画面，音效，操作上给玩家身临其境的感觉。当然，这类型游戏的缺点也很明显，由于终端的限制，目前还不能通过单纯的点击、滑动等操作完成足球游戏的重度复杂的动作，没有键盘或者手柄的支持，习惯主机平台的玩家始终会觉得操作感不好。另外，过于强调球赛时的还原度必定增大游戏包的容量，追求更好的游戏画质还是选择更轻量级的安装包，如何优化，也是值得开发商商榷的问题。</p>
<p>第二类是养成类足球手游，此类游戏摒弃了足球的操作元素，强调对于球队和球员的养成，让玩家容易上手，也较容易在游戏中获得的成就感。这类游戏的代表就是Gameloft的世界足球系列。这类游戏的另一个变种就是将足球与卡牌融合，目前国内市场中此种卡牌类足球游戏居多，虽然将RPG与体育游戏结合算是一种创新，但是现状是此类游戏在设计时过于强调模拟经营元素、缺乏玩家与玩家之间的社交化联系，对于真实足球世界的还原明显缺失，代入感较差，而游戏的核心玩法，大多数也只是数值的堆砌。</p>
<h2 id="u5BF9_u521B_u65B0_u9898_u6750_u8DB3_u7403_u6E38_u620F_u7684_u5C55_u671B"><a href="#u5BF9_u521B_u65B0_u9898_u6750_u8DB3_u7403_u6E38_u620F_u7684_u5C55_u671B" class="headerlink" title="对创新题材足球游戏的展望"></a>对创新题材足球游戏的展望</h2><p>去年下半年到今年，市场上出现了许多新兴的足球游戏。比如游族的《马上踢足球》、热酷的《决战2014》、中手游代理的日本游戏BFB和光涛的《足球梦之队》等等。这里以3D战斗卡牌《足球梦之队》为例，谈谈足球游戏在手游上的新变化。</p>
<p>首先在玩法上，这款游戏并没有让玩家扮演一个球员或是一个经理，而是在足球游戏中扮演一个教练。这其实是融合了传统手机游戏的两家之长，在游戏中玩家不仅要考虑足球比赛时如何操作能够赢得比赛，又要注意球队的养成与管理。这款游戏在球赛时的玩法表现更像是即时战略类游戏，玩家的操作点不再聚焦到每个球员，而是整个球队，这种更注重整体战术规划的体育类游戏目前还是比较少见的。而在球队管理模式上，则依然沿袭了卡牌RPG的模式。</p>
<p>另一大方面，是这款游戏的语音操控，策划希望完全模拟教练在球场上的身份，让玩家以喊的方式告诉你的“球员”该如何踢球。</p>
<p>语音操控更好地结合了手机设备的特征，但也是一个十分有争议的设计，排除识别准确性等不安定因素外，如何能更好的设计好语音操控的体验，而不是让玩家只是抱有新鲜感才去使用，这也是开发商将要面对的一个问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>足球游戏经历了怎样的发展？玩家喜爱哪些类型？足球手游有哪两大分支？作为世界第一大运动的衍生品，足球游戏经历了怎样的发展？玩家喜爱哪些类型？未来又会如何进化？</p>]]>
    
    </summary>
    
      <category term="历史" scheme="http://wdxtub.com/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="足球" scheme="http://wdxtub.com/tags/%E8%B6%B3%E7%90%83/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[游戏发展史 - Blizzard]]></title>
    <link href="http://wdxtub.com/2016/03/20/game-history-blizzard/"/>
    <id>http://wdxtub.com/2016/03/20/game-history-blizzard/</id>
    <published>2016-03-20T14:07:28.000Z</published>
    <updated>2016-03-20T14:29:38.000Z</updated>
    <content type="html"><![CDATA[<p>暴雪的大名已如雷贯耳，虽然现在也面临着一些困难，但是回顾往昔，光芒依旧耀眼。</p>
<a id="more"></a>
<hr>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>就读于加州大学洛杉矶分校的迈克·默汉曾经对同学这样恶作剧：当艾伦·艾德涵暂时离开电脑时，默汉迅速把艾伦的电脑密码改成了 JOE，毫不知情的艾伦回来输入密码，竟然成功登陆了。这时轮到默汉大吃一惊，艾德涵究竟是怎么做到的？于是他招认了自己的恶作剧，然后请教艾德涵是如何破解的，然而，后者的惊讶程度丝毫不亚于默汉，他不过是输入了自己的密码而已。默汉终于明白了其中关键：由于机缘巧合，艾德涵自己的密码也刚好是 JOE。此后两人成为挚友，他们关系之好，最终又成为商业上的合作伙伴，之后20年中他们的工作室制作了数十款精品游戏，不仅成为游戏史上最伟大的传奇之一，更晋升为行业巨头，屹立于整个娱乐产业。他们的公司如此受欢迎，甚至拥有自己的年度大会。且不论两人是否还把 JOE 作为密码，在产品制作的完美程度和持续的卓越方面，世界上几乎少有同行能够同暴雪娱乐并驾齐驱，这是毋庸置疑的。</p>
<p>毕业之际，艾伦·艾德涵觉得这是实现理想的最佳时机，他热衷玩游戏，为何不以制作游戏为业呢？但是他不甘心在大公司当低级程序员，而是想自己当老板，自己决定工作计划。艾德涵决定创立自己的公司，于是他联系迈克·默汉，邀请他入伙，同时还联系了另外一名同学弗兰克·皮尔斯。</p>
<p>【弗兰克·皮尔斯】我与艾伦通过熟人认识，当时很凑巧，因为我确实很想制作游戏，觉得是一项很酷的事业，却苦于不知道如何着手，而艾伦对于自己想做的事情有着明确计划和确切的愿景，他想做的事刚好也是我感兴趣的，因为我少走了很多弯路，我们能够相遇是很幸运的。</p>
<p>【迈克·默汉】公司成立的第一天我才和弗兰克首次见面，当时我正在说话，一个陌生人出现了，于是我闭住了嘴，然后就这么结识了。</p>
<p>1991年2月8日，三人在加州科斯塔梅萨建立了他们的工作室『硅与神经键Silicon&amp;Synapse』，艾德涵担任总裁，默汉担任副总裁，皮尔斯则是程序员。他们决心不紧要制作出伟大的游戏，更要在其过程中享受到乐趣。</p>
<p>【弗兰克·皮尔斯】其实当初我和迈克都不太相信自己的公司能够这么成功，但是艾伦充满激情，积极乐观，他一直以为，如果几个聪明的头脑集思广益，自然能找出最正确的做事方式，无论是制作游戏还是别的。艾伦做事的原则是从不懈怠，他坚信只要大家投入时间精力，就没有克服不了的难关。艾伦说过，制作游戏并非火箭科技那样高深，只要我们几个聪明人齐心协力，也能同顶级公司一决高下。</p>
<p>当年他们便崭露头角，在 Commodore64平台早期游戏《毁灭赛车》的启发下，1991年他们为超级任天堂这个新机种开发了《RPM 赛车》。『硅与神经键』如今成为第一家为超任开发游戏的美国工作室，这是个良好的开端。1992年略有不同，这一年他们没有开发原创游戏，而是把已经把发行的游戏移植到其他平台。例如他们把《指环王》移植到 Amiga 平台，《战斗国际象棋》移植到 Windows 等等。游戏移植并非什么激动人心的工作，但报酬不错。原创游戏的开发无疑还是他们的热情所在，同年，硅与神经键在许多平台上发行了《失落的维京人》，在略为老套的剧情中，三名维京人主角被邪恶的 Tomator 吸入太空船中，必须尽力逃脱。作为一款平台跳跃游戏，本作加入了独一无二的要素，玩家能在三名维京人中任意切换，利用每个角色独有的能力来解开谜题。这是一款单人操纵多角色的游戏，通过杰出的艺术设计和幽默感，硅与神经键独树一帜的个性和卓越的制作水平得到了首次体现，这些品质而后都成为了暴雪的代名词。</p>
<p>【弗兰克·皮尔斯】作为我们的第一款完全原创游戏，《失落的维京人》有着特殊意义，开发过程中我们都很开心，学到了很多游戏设计的经验以及让玩家通过重复完成动作来实现目标的重要性。《失落的维京人》受欢迎程度之高，在街上遇到熟人都会问今天你玩了吗？这个游戏优秀之处在于它以难以阐明的魅力牢牢吸引了大众，太酷了。</p>
<p>《失落的维京人》成为工作室早期作品的典型，并在1995年出品了续作。1993年《摇滚赛车》在超任和世嘉上推出，硅与神经键的名声渐响，同年他们获得《电子游戏》杂志办法的最佳软件开发商奖项。麻烦的是，工作室的名字不太到位，硅与神经键原本用来象征科技和创造力的结合，然而合作的商家中没有一个知道神经键是个啥，名字起得让人疑惑不解，这对新生企业不利。于是他们改名混沌工作室，希望借此被更多人熟知。此外还有更大的问题接踵而来：首先，尽管成员都是凭借兴趣爱好走到一起，工作氛围却一点都不轻松。</p>
<p>【弗兰克·皮尔斯】我记得在创立之初自己特别拼命，每天都超时工作，一直持续几周，与当时相比，现在的工作规划实在太轻松了，在来到硅与神经键之前我从事航空业，早晨7点就上班，转行到游戏业之后我习惯不改：早上7:00-7:30到公司，埋头工作10到12小时之多。</p>
<p>【迈克·默汉】7点上班对我来说是天方夜谭，但是我加夜班到很晚。</p>
<p>火上浇油的是，虽然取得一些成绩，他们在财务方面却很困难。尽管只有15名员工，创始人们却不得不透支之际的信用卡以支付工资，有时候甚至要啃老。当父母的资助也不再可行时，他们知道必须痛定思痛了。1994年，混沌工作室开始对两份并购提议作出正式考量，一份来自大发行商 Interplay公司，另一份来自教育软件开发商戴维斯及联营公司。起初，二选一的答案看似毫无悬念，新兴企业应当寻求行业巨鳄的庇护，然而再三考虑后，他们意识到要加入 Interplay 就得甘当一枚不起眼的螺丝钉，失去自主权，相反戴维斯及联营公司在游戏业初来乍到，因此在产品开发方面愿意给予工作室全面自主。面对两难抉择，他们最终在业界菜鸟一边压下了赌注，最终戴维斯公司以一千万美元并购了混沌工作室，这对于当时的他们无异于雪中送炭。</p>
<p>【迈克·默汉】戴维斯的这次并购极为关键，它加速了我们的成长。公众所不了解的是，直到这次并购之前我们的预算一直很紧张，当时办公室甚至没有局域网，大家需要轮流用电脑等等。我们希望挺过来之后，能够实现资金自主和自主发行产品。并购后再也不用担心发不出工资，还有了新的高速局域网，我们终于能真正专注到制作游戏上。</p>
<p>当一切趋于稳定，他们发现不能再用混沌这个名字，商标权已经归属另一家软件公司，他们必须再度改名。几乎选定为食人魔工作室后，又被戴维斯的大老板否决，最后艾德涵翻字典找到了七个备选词，长期讨论后敲定了一个既酷又得到管理层首肯的名字，就是暴雪娱乐。即使在发展之初，因为不愿把自己局限到一种媒体，暴雪公司一开始就选定『娱乐』而不是『游戏』这个词，他们从不缺乏雄心壮志。同年，改头换面的暴雪娱乐受到发行商 Sunsoft 委托，将漫画史上最重要的大事件《超人之死》改编成游戏，8月《超人浴火重生》在超任上发行。这是一款简单的横版过关游戏，不过主角可是超人。游戏终章里主角没有打败最终 boss，而是同归于尽，之后玩家控制剩下的四名超人之一重新游戏，只有在五名超人都通关后才能看到真正结局。《超人浴火重生》这款作品无愧于暴雪公司响当当的名号，创立仅三年，他们就被娱乐界最大的巨头之一点名为其制作游戏。九月，暴雪公司在超任和 DOS 平台吓发布了一款新的原创射击动作游戏《黑色荆棘》。为了使人物动作尽可能逼真，工作人员把弗兰克·皮尔斯的动作拍摄下来，再把录像转化为游戏画面，这一技术被称为 Photoscoping。《黑色荆棘》同样以特立独行的艺术风格和怪诞幽默著称，在逐步形成的暴雪风格上又跨出了一步。至此1994年重大事件不断，公司被并购后又更名，其发行的两款游戏，一款以家喻户晓的超人作为题材，另一款则是原创的《黑色荆棘》，小规模的发行商能做到这份上，无疑是硕果累累。事实上他们远未满足，还计划在圣诞节发布一款小作品——《魔兽争霸》为94年画上完美句号。</p>
<p>早在1992年，Westwood 工作室发行了《沙丘魔堡2》这款战略游戏，游戏要求玩家利用资源发展建筑，而后通过建筑生产单位来与敌人作战，本作特点如此鲜明，最终发展成全新的游戏类型，称为即时战略或 RTS。该作算是小有收获，但是直到1994年，还没有一款跟风作品出炉。暴雪公司却别出心裁，要另辟蹊径。</p>
<p>【迈克·默汉】《沙丘魔堡2》问世时我们觉得大为震撼，感觉这种游戏题材真是酷毙，沙丘2仅限单人，我们就想，即时战略中如果能多人对战岂不是碉堡了。当然，那时我们都局限在魔幻题材下，专注魔幻30年可是我们的成功秘诀啊。</p>
<p>考虑到即时战略游戏的复杂性不适合手柄，《魔兽争霸》成为暴雪公司第一款 PC 专属作品，这也是他们首款自主发行的游戏，同时利用戴维斯和联营公司已然发展成熟的销售网络。游戏中两个种族的平衡性近乎完美，这是因为双方本质上一样，除少许例外，每个种族的攻击力和血量都相等。尽管如此，游戏画面堪称美轮美奂，魔幻背景的情节也是引人入胜，此外更有局域网多人对战模式，也允许技术宅们采用 IP 直连。尽管有这些限制，游戏引发的狂热对战浪潮真正是前所未有，作为沙丘2之后仅有的一款即时战略游戏，市场前景无法估量。《魔兽争霸：兽与人》一上市便受到欢迎，销售业绩颇佳，虽然算不上里程碑式的成功，但上级公司戴维斯即联营公司已经为续作开了绿灯。暴雪公司如今算是走上了正轨，有足够的资金进一步发展并逐步拥有了粉丝群，更重要的是，他们有着完全的创造自主权，这一切，仅仅在四年内就已经做到了。《魔兽争霸》问世后，他们又信心续作能更上一层楼，其实结果让他们自己都吃惊。</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>从加州大学洛杉矶分校毕业后，三个好朋友决定放手一搏成立自己的游戏公司。『硅与神经键』在超任上出品的《RPM 赛车》获得成功，并成为第一家为该平台开发游戏的美国公司。在制作几部移植作品之后，他们继而推出了《失落的维京人》和《摇滚赛车》等原创作品。1994年，这家新兴企业经历了不少变动，包括被戴维斯及联营公司并购，以及更名为暴雪娱乐，除了平台动作游戏《黑色荆棘》外，暴雪还推出了《魔兽争霸：兽与人》，魔兽作为整个即时战略类型游戏的第二款作品，更引入了前所未有的多人游戏模式，该作在评论界广受好评，全球销量也不错，暴雪公司逐渐得以立足，《魔兽争霸》成为了公司自主发行的首款游戏。时值1995年，暴雪在计划开发数款续作的同时，也在着手扩展公司的发行业务，期间暴雪逐渐脱颖而出，成为行业的佼佼者。</p>
<p>1994年暴雪再度接受委托，制作一款 DC 漫画超级英雄题材的游戏，《正义超人大对决》把漫画书的偶像英雄们带进格斗世界，此时格斗游戏作为新的游戏类型很受欢迎。发行商 Acclaim 召集了数家开发商共同开发，其中暴雪负责超任版本的制作，世嘉版则由位于红木城的 Condor 娱乐工作室开发。尽管两个小组之前没有合作经验，暴雪的 CEO 艾伦·艾德涵在一次大会上同 Condor 的几名负责人偶然会过面。之后在1995年1月，暴雪公司接到了一个意料之外的电话，是 Condor 打来的，后者正在开发一款完全原创的新游戏，想要找发行商。他们找遍了所有的大发行商，甚至连小一些的发行商也找过，但都无功而返，发行商们都认为 Condor 一定是秀逗了：这家工作室毫无 PC 平台的经验，却妄想开发一款史诗题材的粘土动画式回合制动作 RPG。如今 Condor 小组饥不择食，转而向在大会上仅有一面之缘的暴雪求助。暴雪在这个项目上看到了一些与众不同的东西，他们认为将有机会出品一款前所未有的崭新佳作，最后他们同意签约，Condor也有幸成为第一家为发行商暴雪制作游戏的公司，这款游戏的名称暂定为《暗黑破坏神》。</p>
<p>在 Condor 权力着手开发的同时，暴雪的《失落维京人2》也推出了，三名勇敢的主角再次被 Tomator 外星人绑架，不过这次他们学会了用外星人的武器武装自己，甚至还有龙和狼人加入队伍。从游戏性来说角色数量和能力都增加了，不过3名角色的限制还在。2代虽然没有带来前作那样的轰动，却也受到了好评。此时暴雪正在开发另一款续作，这是一款各方面都超越前作的游戏。《魔兽争霸2：黑潮》于1995年12月出品，表面看来同初代极为相似，都是魔幻背景的即时战略游戏，有着相似度颇高的两个种族，然而通过对几百个细节的关注，续作真正将该模式提升到了完美的极致。</p>
<p>【弗兰克·皮尔斯】可以说，魔兽2是第一款真正体现出暴雪精益求精风格的作品，通过千锤百炼制作出一款精品。虽然之前的作品也并非泛泛之辈，但是此时我们才真正展现了才华。</p>
<p>【迈克·默汉】我同意，并且魔兽2可以说是各方面都更进一步，游戏人数增加，解析度提高，有海陆空三军。我们在魔兽上投入已经一年，因而小组很清楚自己在开发时应该要做什么。</p>
<p>在《魔兽2》的许多改进中，对 RTS 类型最具重要意义的是持续存在的战争迷雾。在之前的即时战略中，地图区域探索过之后就持续可见了，魔兽2则不同，只有当玩家的单位正位于一个区域时，才能看到该处的状况，侦查因而成为对战中的关键之一，该设计被战略类游戏广泛采用。在本作中，暴雪的幽默和个性发展成了一种标志性的特色，无论是史诗剧情，还是单位的回应方式都大放异彩。游戏中充满生机的世界观，加上独有的个性从此成为暴雪与众不同的标志。另外2待最显著的改进都在多人游戏方面，对战不仅仅局限于一对一，分组对战中每组可容纳多达4名玩家，由此引入了大规模混战以及惊人的战略复杂性。然而在连接方式上，仍然仅限于局域网或 IP 直连。不过年内早些时候，几名爱好者编写了外挂程序，使得游戏跨域局域网在互联网上对战成为可能，这个程序名叫 Kali。这款并非暴雪操刀的第三方程序为魔兽2推波助澜，使其获得了空前的成功。</p>
<p>【弗兰克·皮尔斯】魔兽争霸一代很酷很有乐趣，但是在玩家社群方面颇受限制。我认为凭借互联网发展起来的魔兽2玩家群体对我们至关重要，他们的忠诚是无价的。</p>
<p>此时还有一场对战正在如火如荼地进行，这就是暴雪公司和即时战略元祖 Westwood 之间的较量。仅在魔兽2发售前几个月他们推出了《命令与征服》，另一款制作精良的战略游戏大作。两款近似的大作接踵而至，使得 RTS 类型空前火热。当然两款游戏各有其重视的拥趸群，互联网上也掀起一场关于孰优孰劣的大论战。至今不变的只有一点，对于狂热的粉丝来说，萝卜白菜各有所爱这种事情真是让人难以接受啊。当然，多亏这些唇枪舌战，两款游戏更为引人注目了。在暴雪方面，魔兽2的销量继而暴涨，仅在4个月内就售出50万份，对于1995年的一家小工作室来说，这是惊人的成绩，最终该作的销量甚至超过了神器的100万份，在当时少有游戏能享受此殊荣，对于10个月的开发期来说，这算是挺不错了。</p>
<p>在魔兽2已经颇具人气后，暴雪决定趁热打铁出资料片，由于他们自己正忙于新项目抽不开身，便将《黑暗之门》的开发交给 Cyberlore 工作室，后者于1996年完成了制作。同时 Condor 正在不遗余力进行《暗黑破坏神》这款回合制粘土动画动作游戏的制作，并取得了不错的进度。然而，新的发行商暴雪坚持要让他们做出一些改动：首先，要求他们把粘土动画改为3D 动画，此时3D 正在迅速崛起成为未来的新标准，而粘土动画这种方式也太怪异了；此外暴雪还希望 Condor 将回合制改成即时。Condor 起初的反应是抗拒，因为目前为止的制作都是围绕回合制来进行的。</p>
<p>【弗兰克·皮尔斯】两个工作室之间的沟通有了障碍，当时同他们工作室的远距离交涉是个很大的挑战，我们自己还很稚嫩，在项目管理方面初来乍到，他们也是头一次涉足游戏制作业，总之加上地理上的距离，使得我们的合作颇具挑战性。最后他们同意制作一份技术掩饰，测试实际的游戏效果。</p>
<p>Condor 立即就意识到采用即时方式后，游戏变得更为引人入胜了，于是他们把即时方式彻底应用到游戏中。很快暴雪就意识到，Condor 的这个项目将会是个惊天动地的大作，他们不满足于仅仅做发行商了，他们要自己拥有《暗黑破坏神》。</p>
<p>【迈克·默汉】Condor 正在开发《暗黑破坏神》并且进展相当顺利，彼此合作也很愉快，我们想把他们吸收过来成为兄弟工作室，于是同联营公司即我们的母公司提出了这个想法，他们也很有兴趣，于是不久后 Condor 成为了暴雪北方。</p>
<p>在1996年E3上，该作品终于向公众展示了庐山真面目并引起了很大反响，这种新颖的游戏设计真的是前所未见。凭借魔兽2，暴雪已经成为世界上最炙手可热的开发商之一，在同年 E3上，暴雪公司还有两项重大事件要发表：首先是 Battle.net 这个免费的在线多人游戏服务平台将同《暗黑破坏神》捆绑提供，玩家们无需再从 Kali 等第三方软件处寻求帮助。暴雪开始提供自己精心打造的联网服务，以供玩家通过互联网进行随机多人游戏。其次发表的第二项内容就不怎么让人惊喜了，这就是『无聊的魔兽争霸科幻山寨版』，连名字也如出一辙——《星际争霸》。最先暴雪的展台上有3个屏幕用于《暗黑破坏神》，另外三个用于《星际争霸》，到了展会结束时，星际被缩减到只有一个屏幕了。星际同去年的魔兽2相比，画面上没什么进步，游戏方式也是平淡无奇，当暴雪北方正在着力制作一款前所未有的创新作品的同时，他们的南方兄弟小组却似乎在用旧创意炒冷饭。展会后，暴雪必须要决定《星际争霸》何去何从，游戏已经有了相当的开发进度，而得到的反响却只能说差强人意。</p>
<p>【迈克·默汉】那届 E3有很多开发中的即时战略游戏参展，全都令人耳目一新，我们回到公司后开始讨论 RTS 类型的现状以及发展方向，并且意识到应该在《星际争霸》上做到百尺竿头更进一步。</p>
<p>最后他们做出了艰难的决定，将目前的进度放弃从头开始制作，而不是勉强发布一款平庸作品。之后几年内《星际争霸》从人们视野中消失了。与此同时《暗黑破坏神》却充分吸引了公众的关注，大有不征服市场不罢休之势，然而为了确保品质，暴雪未能按计划在1995年圣诞假日发售游戏。</p>
<p>【弗兰克·皮尔斯】《暗黑破坏神》的收尾工作到了关键时期，暴雪南方的员工们也临时到北方分部协助工作，而 Battle.net 的开发则在暴雪南方这边进行，我们在 Battle.net 平台的开发和暗黑的开发之间协调，并为即将发售的游戏提供支持。实际上《星际争霸》小组的大部分成员也被我们指派去协助暗黑的开发。人们所不知道的是，在《暗黑破坏神》中加入 Battle.net 支持这个决定是在游戏快接近完成时才做出的，因为这个点子太新，在上面投入的时间也短。</p>
<p>整个 Battle.net 的开发只用了几个月，实际上游戏于12月26日开发完成，刚好比圣诞节晚了一天，最终，游戏于1997年1月2日发售并引起了巨大的轰动。《暗黑破坏神》中的 RPG 升级体系和动作要素相辅相成，无疑是最完美的游戏设计，通过史诗般的剧情来完美衬托游戏过程，构成了引人入胜的世界观，更别处心裁的是，每个玩家经历的游戏体验都不同。这全靠随机声称的地牢设计，使得玩家每次冒险时见到的地形、物品和怪物都不一样，暗黑由此获得了杰出的重复可玩性，对于设计一成不变的游戏来说，这是不可企及的。此外玩家还能同他人结伴进入地牢冒险，游戏支持多人合作模式，最多同时支持4名英雄联手对敌。遗憾的是，在合作模式中没有关闭互伤这一选项，杀死盟友这种事情时有发生，这导致不少玩家故意杀光盟友以博得一笑，多么的邪恶啊！</p>
<p>除去游戏本身优越的品质外，《暗黑破坏神》也是暴雪采用专门小组制作剧情动画的首款作品，后者的任务是制作高品质预渲染的过场动画，为暴雪的游戏增光添彩，使其在同行间脱颖而出。以今天的眼光看这些开场画面颇为过时了，但它们代表着暴雪公司另一个标志性特色的开端。以上这些结合在一起，为暴雪公司带来又一款里程碑式的成功作品。《暗黑破坏神》最终销量也超过了100万，这是暴雪在魔兽2之后紧接着第二次实现这一成绩，当时能达到这个销量的游戏寥寥无几。暴雪公司如今已跻身整个行业最杰出的开发商之列，他们的游戏无论在制作精美度、表现方式和个性上都难有人与之并驾齐驱。他们当前唯一的问题就是那款舅舅不疼姥姥不爱的『魔兽科幻版山寨』，改进游戏质量的尝试也已停滞。现在的问题是：《星际争霸》究竟能否脱胎换骨，成为不愧于暴雪大名的又一款佳作？</p>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>1997年末的暴雪正是鸿运当头，从三名怀着梦想的毕业生这一平凡的起点，发展到连续出品两款销量百万的游戏，公司获得了空前成功。《魔兽争霸2》作为即时战略游戏有着热衷于对战的庞大拥趸群，而《暗黑破坏神》中角色扮演和动作珠联璧合的形式堪称前所未有。《魔兽争霸2》由位于加州欧文的暴雪总部（暴雪南方）出品，而《暗黑破坏神》则由位于圣马特奥的首家分公司暴雪北方制作，凭借两款大作和两家颇具实力的公司，暴雪似乎已然屹立 PC 市场。然而问题来了，欧文团队当前的项目在首次测试中遭到失败，除了游戏背景设定在太空之外，这款新作其实与《魔兽争霸》八九不离十，甚至名字听起来也相当一致——《星际争霸》。1996年 E3上的玩家和评论家们对这款新作丝毫不感冒，不过凭借着麾下的两款超级大作，暴雪能够调用足够的人力物力重新来过。所以，当北方小组开始着手开发《暗黑破坏神2》的时候，南方小组则推倒了《星际争霸》的全部进度，从零开始设计。</p>
<p>《暗黑破坏神》广受欢迎，资料片也毫无悬念地推出了，不过如同魔兽的资料片《黑暗之门》，《地狱火》并非由暴雪自己操刀制作，而是外包给 Synergistic 软件公司并于1997年11月发行。暴雪北方手头有更为紧要的工作：出品一款完整的续作，此时离二代问世还有数年。而南方小组的《星际争霸》终于开始收尾，并在1998年3月面世，这款游戏的里里外外都被重新制作一遍，从而在外观、游戏体验和手感上都焕然一新。其本质仍然是一款围绕资源、建筑和单位的即时战略游戏，但却有着革命性的彻底改变：三大种族不再彼此雷同，而是每个都独一无二，一个种族的玩法要套用到另一种族就完全行不通，这使得任何一场赛事中的战略以指数级复杂化，根据对手种族的不同，玩家必须要采取不同的打法，此外《星际争霸》的故事叙述水平更是登峰造极。《魔兽争霸》的剧情引人入胜，但仅限在人物之间的过场部分由旁白来讲述，兽族和人族的剧情体验明显一分为二，并无关联。《星际争霸》与此相反，整个剧情一气呵成，从人族开始，接着是残暴的虫族，最后以高等外星文明神族收尾，故事通过形形色色的角色之间的互动来讲述，其中许多角色都可以在任务中实际操作，这些角色在任务过程中甚至还会继续交流。换言之，剧情叙述和游戏过程一起构成了天衣无缝的娱乐体验，没有任何一款即时战略游戏能够与之媲美。</p>
<p>【迈克·默汉】我们认为背景故事对于玩家的投入度相当重要，首先要让玩家觉得自己在游戏中的行为师出有名，但最重要的是，暴雪的核心价值是游戏性第一，游戏性就是一切东西的核心，从游戏性角度出发，如果一种设计比其他设计更有趣，我们就会尝试从剧情方面来迎合游戏性的需求。</p>
<p>此外还有一个卖点，就是所谓多人对战，《星际争霸》全面支持暴雪的 Battle.net 服务，用于多人对战，尽管理论上同《魔兽争霸2》相比没有太多改变，三个截然不同的种族再加上多姿多彩的战略深度，在多人游戏中得以发挥到极致。《星际争霸》让人真正废寝忘食，到了史无前例的地步，那么销量究竟如何呢？可以这么说《魔兽争霸2》和《暗黑破坏神》各发行一百万份实现了巨大的商业成功，《星际争霸》也卖出一百万份，而且仅仅是在韩国这一个国家里。在韩国，一百万的销售量已经占到其人口的百分之二，再算上全球其他市场的销量，《星际争霸》一跃成为有史以来最畅销的 PC 游戏之一。</p>
<p>专业游戏联盟如雨后春笋般诞生，《星际争霸》也成为运动赛事中的竞技项目，问世十年后仍经久不衰——对于瞬息万变的游戏业来说，十年就是永恒。在韩国《星际争霸》至今仍然是一项重大观赏性运动，与传统运动分庭抗礼。最后《星际争霸》的累计销量达到了惊人的1100万份。在此之前暴雪已经跻身世界最成功的游戏开发商之列，现在更是天下无敌，从剧情到手法，再到表现形式，他们重新定义了战略游戏，甚至整个游戏媒介本身，该游戏影响之深远，甚至在1999年5月，发现号航天飞机执行首次国际空间站对接任务时也携带了一份。暴雪本可以做一部平庸作品了事，但凭借着对完美的执着，《星际争霸》成为了永恒经典。当然其资料片也很快跟进，如暴雪早期其他游戏一样，前两款资料片由第三方制作，由 Aztec New Media 制作发行的《起义》讲述了同主线剧情平行发展的分支故事，三个种族各有一套战役；《反攻》由 Stardock 开发，其本质基本相同，也是每个种族一套新战役，两套资料片在评论界波澜不惊，发行量也不大，如今它们已经被遗忘，无法购买得到。</p>
<p>终于在1998年11月，《星际争霸》的最后一款资料片问世，并引起了前所未有的巨大轰动。《母巢之战》从每个方面对游戏做出了核心上的彻底改进，非但延续了剧情，还引导其进入了全新的领域，同时针对多人对战进行了全新设计和扩充。该资料片显然不是由第三方制作，而是由暴雪自己在 Sapphire 公司的协助下亲自操刀完成。《星际争霸》的资料片中，只有《母巢之战》至今还广为流传。其后很长一段时间内，星际系列都没有发行续作。</p>
<p>暴雪接二连三的辉煌令人头晕目眩，人们往往忽视了他们的失败作品。《魔兽争霸：氏族之王》计划成为一款关于萨尔个人经历的冒险游戏，讲述一名逃跑的兽族奴隶如何陈伟氏族之王的故事。不幸的是，尽管部分暴雪员工对该作抱有相当的热情，其他人却不以为然，他们认为该游戏不符合暴雪的黄金标准，而且在98年2D和冒险游戏已经倍受冷落，另一个障碍源于该作的开发商 Animation Magic 远在俄罗斯，造成暴雪和他们之间的沟通困难，更糟的是当这款游戏正准备发行时，LucasArts 抢先发布了《猴岛小英雄3》和《冥界狂想曲》，暴雪意识到这两款优秀作品真正将冒险类游戏发挥到了极致，远远超过《氏族之王》。这是相当严峻的，如果他们迎头而上，照原计划发行游戏，玩家们会感觉这只是暴雪的一部跟风之作。最后的消息是，在离预订完成时间只有3个月的时候，暴雪取消了这个项目，他们再度贯彻了要么不做，要么做到完美的准则。</p>
<p>1998年还有一项重大改变：最早提出成立工作室的共同创始人艾伦·艾德涵辞去了暴雪总裁一职，作为总裁他一直从事商务领域的工作，因为期望回归到游戏制作上来，于是他和另一位创始人迈克·默汉交换了职位，后者至今扔担任该职。1999年暴雪公司没有大的动作，没有发行作品，甚至《暗黑破坏神2》也只预订在圣诞假期旺季发行，其延迟发售无疑让拥趸失望，然而此时人们已经习惯了暴雪为持续改进作品而跳票的方式，9月他们宣布《魔兽争霸3》即将发表，该作集公司最擅长的两种游戏类型于一身：即时战略和角色扮演，即时对暴雪来说这也是很激进的。游戏有六个种族，游戏视角始终以主角的英雄单位作为核心，类似《暗黑破坏神》，其他单位根据英雄发出的指令动作，而不是由玩家直接操控。游戏将采用无缝衔接的场景，由角色之间的对话场景来代替载入画面，除了期待暴雪下一部完美大作之外，粉丝们别无他求，全盘接受。然而有个小问题：在公开宣布后，暴雪制作了游戏概念的内部试玩版——效果连他们自己都讨厌。着手实验了自己的想法后，他们在意识到它有多糟糕。于是在2000年的 E3上暴雪发表了爆炸性消息：他们已经在着手全面改变《魔兽争霸3》，在保持英雄单位重要性的同时，使其更加接近传统即时战略，这也遭到了反对，因为这代表又一次延期，同时给人一种暴雪拒绝创新，却返回到保守安全领域的感觉。</p>
<p>人们再次议论纷纷，暴雪的游戏虽然品质优良却缺乏根本的创新，然而仅在一个月后暴雪就挽回了名声：2000年6月《暗黑破坏神2》终于问世，在最后一年里，初代的制作组暴雪北方日复一日埋头苦干，只为实现让续作在所有方面都超越前作的初衷。《暗黑破坏神2》有着更丰富的剧情，更庞大的关卡，更多的职业，全新的技能和各式各样种类繁多的武器装备，如此多的游戏内容的制作使得小组成员几乎崩溃，但最后证明这是值得的。《暗黑破坏神2》是一款当之无愧的动作游戏经典，游戏主角在地狱烈焰中的英勇征战令人热血沸腾，游戏当然不是没有缺点的，同4年前的初代相比，画质并无飞跃，游戏首发的几周内 Battle.net 服务也经常崩溃。但游戏在直观、流畅的操作和令人废寝忘食的游戏性方面脱颖而出，以上都是瑕不掩瑜。《暗黑破坏神2》成为了暴雪迄今销售最快的游戏，问世仅一个月就卖出了一百万份，本作经常被誉为游戏史上最优秀的动作 RPG，毋庸置疑的说，暴雪公司现在已经是全世界最受推崇最成功的游戏开发商之一，他们发行的每一款作品都能轻松达到百万销量，并随即成为游戏业的经典作品。暴雪已然称霸了90年代，而新世纪00年代也将成为他们的囊中之物，此时距暴雪成立甚至还不到十年。</p>
<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>自90年代起的10年间，暴雪娱乐从起初的无名小卒发展为如今的 PC 游戏界大亨，早起的《魔兽争霸》和《暗黑破坏神》的成功，推动了其续作达到新的高峰，经历了艰难的起步后《星际争霸》创造的传奇达到了艺术的高度。自1995年起，每款单机游戏至少卖出了100万份，且逐年递增。暴雪在创造方向和财政上都享有自由，他们的所有想法都得以实现，把游戏做成他们理想中的那样大胆而多样化。但出于各种原因，2000年年初时公司经历了数次挫折且几名高管卸任，最终仅有两款《魔兽争霸》系列的游戏见到了黎明的曙光，这两款游戏跻身于史上最知名最具影响力和最成功的游戏行列当中。即使是在糟糕透顶的时候，暴雪响当当的名号仍然如雷贯耳。</p>
<p>1998年11月，在完成了资料片《星际争霸：母巢之战》后，暴雪在加州欧文地区的主团队氛围两拨，一拨队伍负责新一代实时策略游戏《魔兽争霸3》，而另一组筹备全新科幻角色扮演游戏《Nomad》，遗憾的是《Nomad》 还没来得及对外宣布就胎死腹中，这就意味着该小组必须另辟项目。此时公司的另一个工作室暴雪北方正红得发紫，在2000年发布了《暗黑破坏神2》后，他们又自行开发了资料片。这种自行开发资料片，而不交给第三方的做法前所未有，如今《母巢之战》起头，暴雪所有的资料片都由游戏的原班人马操刀制作。这种新的策略效果显著：2001年6月发布的《毁灭之王》获得了巨大成功，暴雪北方便趁热打铁着手开发《暗黑破坏神3》，与南部兄弟小组在冒险游戏《魔兽争霸冒险》和《Nomad》项目上屡屡受挫不同，暴雪北方似乎志得意满，他们绝对没有想到，暗黑2将会是他们出品的最后一个游戏。2001年9月，暴雪宣布了一款新作，它是《Nomad》制作小组的后续项目。</p>
<p>【弗兰克·皮尔斯】当时许多成员都在玩大型多人在线游戏，在《Nomad》项目毫无进展的时候，我们决定改变方向打造大型多人在线游戏。关于应该采用哪个系列来做网游，以及是创造一个全新世界好，还是尝试利用现有游戏系列的题材好，我们都做了讨论。当开始审视魔兽系列时，我们觉得找到正确的题材了。</p>
<p>这就是《魔兽世界》的起源，然而按照暴雪的一贯作风，游戏并无确切的发布日期，考虑到小组精益求精的制作态度，游戏很可能数年后才会与玩家见面。同时南方小组正在为其它魔兽系列游戏收尾，2002年7月问世的《魔兽世界3：混乱之治》在初期理念上作出了大幅度的变动，原定的6个种族缩减到了4个，倍受关注的英雄角色并非玩家扮演的主角，而是强化版的单位，也就是说，游戏是传统的即时战略，英雄角色仅用于增色添彩。不过它在某些方面还是领先的：其一，它是暴雪的第一款全3D 游戏，尽管对游戏性没有造成太大的影响；其二，工作室在预渲染过场动画领域更上一层楼，这使得小组能够将单调的剧情叙述变得前所未有的充实，而游戏角色们仍然是焦点，这也也成就了一款注重情节的策略游戏，前无古人。除剧本外，更有暴雪一贯在游戏性方面的完美平衡，以及每个种族的独一无二的设计，所有这些加在一起促成了一款精品，至今仍被认为是最佳策略游戏之一。与《魔兽争霸》前作一样，本作也成为了世界级专业游戏锦标赛的典范。资料片毫无悬念地接踵而至——即2003年的《冰封王座》，与《暗黑破坏神2》一样，资料片同样由原班人马操刀完成，在保有原汁原味的同时确保了同等的高质量。归功于长篇的新剧情以及多人模式添加的多个新单位，资料片几乎是一款全新游戏。</p>
<p>现今，暴雪旗下三个主要游戏系列都在开发新作品，暴雪北方在开发《暗黑破坏神3》，南方分部着手《星际争霸》的续作以及《魔兽世界》，第三个小组『虚无软件』则在研发全新的《星际争霸》系列作品。2002年启动，预计2003年发布的《星际争霸：幽灵》将成为家用机上的第三人称动作游戏。尽管从1995年后暴雪不再涉足家用机领域，但这款游戏却完美复合家用机的模式，在星际大背景剧情下，故事围绕人族的高级特种兵展开，玩家对此的反馈很不错。暴雪几年内发布了许多截图、预告片以及文章，但游戏本身却不见踪影。按老规矩暴雪将游戏改了又改，发布时间一延再延。此时对《幽灵》团队来说是屋漏偏逢连夜雨，2003年6月《暗黑》项目领导人离开了暴雪北方，这些人起初成立的『秃鹰工作室』被暴雪吸收到麾下，而暴雪本身又是其他集团的子公司，当感觉到自己已经不再参与重大决策且无法保障自身成员的收益和前景时，暴雪北方管理层提出了抗议，他们甚至以辞职威胁获取话语权，不幸的是，辞职得到了批准。</p>
<p>失去领导人后，《暗黑》团队遭受了无法弥补的损失。祸不单行的是，2004年1月暴雪原团队的领导人也辞职了。艾伦·艾德涵大学毕业后按照自己的想法建立了一个游戏公司，13年后他选择退出。长时间高压的工作打垮了他，如今他希望投身金融领域，他的职位由共同创始人迈克·默汉接替，因而公司并未发生巨变。同年，暴雪停止聘用『虚无软件』公司开发《星际争霸：幽灵》，该游戏至今搁浅无人过问。不过欧文地区团队仍然对《幽灵》信心十足，并且让『飞猿工作室』继续这个项目，『飞猿』最终被暴雪收购，更名为暴雪家用机分布，之后所有暴雪公司的游戏不再外包，全部内部制作，于是《幽灵》的制作得以继续，然后就没有然后了…..与此同时，暴雪自己的续作《星际争霸2》却遥遥无期。</p>
<p>员工陆续辞职，公司屡屡受挫，有人开始觉得暴雪的巅峰期已经结束。之后在2004年11月，即第一款《魔兽争霸》出品后10周年，《魔兽世界》终于问世。历经4年开发，本作是工作迄今为止规模最大，投资最多的项目，公司成败在此一举。不过暴雪对本作仍然满怀信心，并预期实体店的销量能在第一年达到40万。</p>
<p>【弗兰克·皮尔斯】按现在的标准，我们当时的预计销量极为保守。我们在北美的设备能够为40万到50万活跃用户提供支持，当时估计，如果能在北美发展这个数量的用户就谢天谢地了，然后在以此为基础将魔兽系列游戏发展壮大。</p>
<p>仅仅在第一个月内，他们就如愿以偿，大型多人在线游戏当时还在蹒跚学步阶段，数千玩家汇聚在一个庞大的虚拟世界中，这在当时可是小众游戏，在重点市场如欧洲等地区少有人问津。《魔兽世界》靠离经叛道成为一匹世界级黑马，上述偏见自然也消失殆尽。该游戏类型的优势之一是公司可以向玩家收取月费，从而抵消游戏的开发维护费用。然而当用户群高达数十万之多，就形成了一种盈利模式。在不到一年里，《魔兽世界》用户增加到了史无前例的400万，每名用户的月费加起来，使得本作成为获利最高的单款游戏。否定论者说暴雪在走下坡路，而《魔兽世界》做出了有力的回击，数年来本作的人气有增无减，原班人马制作的每款资料片都在发售后被抢购一空，创造了记录，用户人数从600万逐渐增长到现今的1200万。这首先说明游戏的销售量至少也有1200万，再考虑到有些玩家购买游戏后又停止了付费，实际销量应该更高。另一方面，如果把全球所有玩家的付费加个总和，意味着暴雪仅靠月费每年就能赚取10亿美元，在过去整个游戏史上这是闻所未闻的。</p>
<p>是什么让人们对它如此着迷？和其他暴雪游戏相同，本作并无任何真正意义上的全新内容，游戏紧贴已然成型的大型多人在线游戏模式，以魔幻角色扮演为题材，着重升级和装备搜集，然则同其他暴雪产品一样，游戏的方方面面都被加工到了完美境界，游戏十分直观友好，任何瑕疵都由负责平衡性的部门快速修正，美工华丽而亲切，战斗体验在大型多人在线游戏中被公认为最佳。当然《魔兽》的金字招牌自首发起就吸引了大批玩家，总体来说，对于打造了数款精品大作，屡屡超越大众期待的暴雪来说，《魔兽世界》是一个新奇迹，到达游戏业巅峰后，暴雪公司再度登峰造极，已经很难有其他公司与之并驾齐驱。凭借着《魔兽世界》带来的这笔意外之财，暴雪接下来的发展势不可挡。当然，他们还得接着运营《魔兽争霸》，这带来了一些问题。尽管他们的大型多人在线巨作获得空前成功，其他项目并为从中受益。</p>
<p>【弗兰克·皮尔斯】对《魔兽争霸》玩家社群的支持成为我们的优先工作，尤其在 WOW 发布初期。我甚至觉得如果 WOW没有获得意想不到的成功，《星际争霸2》的推出应该还能更早一些。</p>
<h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>2000到2005年间暴雪娱乐状况不佳，由于辞职不断和大量烂尾项目，暴雪娱乐似乎要跌下游戏霸主的宝座，但是这一切随着2004年11月《魔兽世界》的发行而改变，这个大型多人在线游戏一炮打响，成为有史以来最火爆的游戏。接下来的几年，该游戏的付费人数超过了1200万，如此可观的收益流在整个游戏界是史无前例的，意外的收获本该让暴雪能够率性而为，然而游戏的火爆度始料未及，暴雪不得不勉力扩员，确保在支持《魔兽世界》的同时还能顾及其它项目。暴雪手头已经有大量未完成的游戏，此时同魔兽系列无关的游戏统统问题不断，发行严重滞后，如今最大的问题在于，暴雪能否应付《魔兽世界》突如其来的成功？</p>
<p>尽管《魔兽世界》如此成功令人难以置信，暴雪其他的项目依然处于挣扎之中，例如暴雪北方小组制作的《暗黑破坏神3》就迟迟无法完工，虽有暗黑这面金字招牌，续作却难以与时俱进，开发团队始终想不出有趣的设计点子，更糟糕的是，按照2005年的标准，游戏画面已经颇为过时，加上暴雪北方管理人也在2003年辞职，使得《暗黑破坏神3》最终失去了方向，最后，位于加利福尼亚欧文的暴雪南方公司的执行者们不得不做出一个艰难的决定，在希望对开发团队加紧管理但却难以远距离操控的情况下，他们于2005年8月决定关闭暴雪北方，同时告知前员工们可以选择到欧文继续开发《暗黑破坏神3》。一部分人加入了南方公司，另一部分人选择离开，但不管是走是留，这一巨变对制作组的自身文化和创作独立性都造成了打击，导致了《暗黑破坏神3》项目流产，此后《暗黑破坏神3》的开发又回到原点。正如暴雪的一贯作风，《暗黑破坏神3》从大众的视野中消失了数年。但2005年也有好的消息，10月，首届暴雪嘉年华拉开了帷幕，这是由暴雪主办的大型粉丝集会。本届参加者可以第一时间试玩《魔兽世界》资料片和《星际争霸：幽灵》，后者是开发中的家用机动作游戏。拥趸们也有机会同游戏的开发者——他们的偶像们见面，这次的大会极为成功，在2006年平息一年后，从2007年起暴雪嘉年华正式成为每年一度的活动，其规模逐年增加也并非巧合，从2009年起暴雪甚至不再出席E3，从此暴雪不用再对游戏社群大力宣传招揽，而是由后者自觉地参与进来。</p>
<p>【弗兰克·皮尔斯】如今我们有其他的宣传场合，如暴雪嘉年华，期间我们向粉丝们展示一些尚未测试的游戏，让他们有机会体验试玩，我们同时有机会倾听玩家对该游戏的第一时间反馈。基于第一印象的反馈信息极为珍贵，这也是唯一的机会。</p>
<p>尽管《星际争霸：幽灵》在暴雪嘉年华上得以抛头露面，本作却再度遭到挫折。XBOX360于2005年11月发售后，暴雪清楚 PS3和 Wii 也将随之推出，暴雪不断跳票直到游戏完美方才发售的作风在 PC 上一帆风顺，然而在家用机平台上却遭到了意想不到的麻烦，这就是家用机的更新换代。为 PS2、GameCube 和初代 XBOX 主机开发的《星际争霸：幽灵》，在消耗了大量的时间和金钱后，突然沦为上一代主机的游戏，甚至离完成之日还远。2006 年3月新一轮的筛选开始了，暴雪宣布该作将无限期延迟。《幽灵》一直到现在还在推迟，其实等同于取消开发，现在已经没有人在开发《星际争霸：幽灵》，员工早已经分配到魔兽和暗黑团队了，这些小问题都丝毫不影响《魔兽世界》迅速崛起和称霸游戏界。2006年5月暴雪自豪地宣布将同好莱坞的传奇影像工作室合作打造魔兽题材电影，不久又宣布《蜘蛛侠》的导演山姆·雷米加入到该项目，之后根据暴雪的典型作风，此事淡出视线，至今仍不为人知。</p>
<p>几年过去，暴雪除了推出一个又一个魔兽资料片，再没有其它动作，然而2008年公司有了重大动向，即发行巨头 Activision和维旺迪游戏合并了，你问这与暴雪何干？1994年新兴的暴雪被戴维斯及联营公司所收购，后者被 CUC 国际收购，后者不久又和 HFS 集团合并成为 CENDANT 公司，CENDANT 被指控做假帐之后，又被卖给法国哈维斯下属的娱乐部门，后者同一年又被维旺迪收购，维旺迪 vivendi 与2007年12月宣布同游戏发行巨头 Activision 合并，获得多数控股权并成立合资公司，以上都听明白了吗？</p>
<p>2008年7月时交易完成，合资形成的超级公司在利润方面无疑是业界之最，一半 Activision 一半 vivendi 组成的合资企业并不叫做动视维旺迪，而是叫动视暴雪。暴雪坚持要把自己的名头打出去，实际上他们最初希望公司叫做暴雪动视，最后暴雪做出妥协，允许游戏界首屈一指的 Activision 把名字放在前面而自己屈居第二，这是暴雪崇高地位的不二佐证。在合资公司中暴雪享有前所未闻的自主权，作为独立工作室自主管理，做出计划后仅向动视做出例行通知，直到现在动视对此并无异议，因为暴雪在魔兽上的巨大成功使动视非常满意，今后的合作关系将怎样，我们只能拭目以待（暴雪独立了）。暴雪的自主权使得他们能够维持原有风格，不吝惜时间而努力将游戏做到最好，即时有《幽灵》的前车之鉴，其他两款倍受期待的作品；《星际争霸2》和《暗黑破坏神3》数年来依旧按部就班地进行开发。</p>
<p>【弗兰克·皮尔斯】这么说吧，即使我们拥有魔兽、星际和暗黑这些知名系列，如果你回顾我们最近10年左右的记录，你可以说我们只是一家魔兽公司，但所有这些系列对我们来说都很重要，对游戏迷也一样重要，最重要的是我们如何将优秀的游戏体验提供给玩家们，而且保持游戏背景世界观的原汁原味，我们希望忠实地实现这点。过去十年来，我们的重点都放在魔兽系列上，最大的挑战在于如何不偏不倚地把三个系列都照顾好，要知道在最近六七年来为了给《魔兽世界》提供持续支持我们付出了极大努力。</p>
<p>最终在2011年7月，《星际争霸2》在首作问世多年后推出，游戏有着庞大的非线性关卡结构，依靠过场动画衔接的动人情节，游戏中嵌入的冒险要素，改进后的战网服务，对 Mod 社群的强力支持，此外自然还有举世闻名的多人对战模式，12年的辉煌对于游戏界来说已经不仅仅是不朽神话了，凭借寿命超越想象的星际原作和暴雪响当当的名号，《星际争霸2：自由之翼》在发布的当天就销售了100万份，并在头一个月达到了300万份的销售额，同魔兽系列相比这只是一般般，但和其他游戏公司相比，这是惊人的销量。这次发行后《星际争霸2》的故事还远未结束，原版《星际争霸》被分为三部剧情，第一段针对人类，其他两段对应两个外星种族，对于2代来说，暴雪将剧情分割为三个独立的游戏，现在《自由之翼》只是在讲述人类部分的故事而已。《星际争霸2：虫群之心》预计2012年发布，而三部曲的最后一作《星际争霸2：虚空之遗》将为剧情划上完满的句号。三款组拼之间具体会有什么不同，又会提供什么新的特性来吸引玩家？暴雪会吊住大家的胃口，我们只好慢慢等待了。</p>
<p>除此之外《暗黑破坏神3》这款千呼万唤始出来的大作，在数次停牌和复牌之后终于接近制作的尾声，故事发生在《暗黑破坏神2：毁灭之王》的20年后，使得老玩家可以延续前情，而新玩家可以有崭新的开始，总体来说，游戏性和风格延续旧作，在俯视视角下身怀绝技的英雄凭借着一身极品装备，像割草般击杀大批敌人，数次迭代后，本作在画风上同暴雪其他游戏靠拢，暴雪还表示，近期的《战神》等动作游戏启发他们在《暗黑破坏神3》中加入更多的视觉冲击，引发动作 RPG 中动作要素的回归，同时他们宣称要更强调角色和剧情，实现动作 RPG 中角色扮演内容的复兴，《暗黑破坏神3》将在2011年下半年或2012年上市，这是仅有的一款暴雪向全球正式公布的游戏。</p>
<p>然而2010年11月30日，一份包含游戏发行目录的内部文件在互联网上泄密，其中提到了前所未知的游戏，包括计划在2013年发布一款代号《泰坦》的作品，据说泄密文件中还包含敏感的财政数据，之后暴雪中国的总经理被开除，一般认为这证明了本次泄密的真实性，的确《泰坦》现已被暴雪证实确有其事，这将是1995年以来暴雪首款不属于魔兽、星际或是暗黑系列的游戏。</p>
<p>【迈克·默汉】我们已经开始对一款新的多人在线网游进行开发，这并不是《魔兽世界》续作，它是一款崭新的游戏，我们尝试投入这六年在魔兽上得到的经验和教训，打造一款全新的游戏来推动 MMO 类型的发展。</p>
<p>除了这次泄密的消息，还有传言说暴雪的另一团队真在开发另一个新系列，如果属实，在近10年内除魔兽外并无建树的暴雪，将再一次开拓新的领域。现在已经知道的是，除了魔兽、星际、暗黑、泰坦各有一个开发小组外，还可能有另一对人马在从事新的游戏。如果皇天不负有心人，接下来数年间暴雪将持续发布不同系列下的游戏作品，从而再度成为一个以多款精品游戏而驰名的公司。</p>
<p>艹，也该是时候了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>暴雪的大名已如雷贯耳，虽然现在也面临着一些困难，但是回顾往昔，光芒依旧耀眼。</p>]]>
    
    </summary>
    
      <category term="Blizzard" scheme="http://wdxtub.com/tags/Blizzard/"/>
    
      <category term="历史" scheme="http://wdxtub.com/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[游戏发展史 - Interplay]]></title>
    <link href="http://wdxtub.com/2016/03/20/game-history-interplay/"/>
    <id>http://wdxtub.com/2016/03/20/game-history-interplay/</id>
    <published>2016-03-20T14:07:21.000Z</published>
    <updated>2016-03-20T14:25:36.000Z</updated>
    <content type="html"><![CDATA[<p>Interplay 对于新玩家而言已经过于陌生了，虽然早已不复往昔，但是给游戏业界留下的财富，仍旧不可估量。</p>
<a id="more"></a>
<hr>
<h2 id="u65B0_u661F_u5D1B_u8D77_Meteoric_Rise"><a href="#u65B0_u661F_u5D1B_u8D77_Meteoric_Rise" class="headerlink" title="新星崛起 Meteoric Rise"></a>新星崛起 Meteoric Rise</h2><p>布莱恩·法戈的高中生涯都在 Apple II 游戏的陪伴下度过，毕业后他想到，如果自己去设计游戏，做出来的作品搞不好比手头这些都好玩。于是1992年他以Saber 软件公司的名义制作了《恶魔熔炉》，当时孤立一人的他，花费了整整一半的预算，在电脑杂志《Softtalk》上刊登了一则广告。之后为了吸引零售商进货，他又冒充普通玩家打电话给商店，询问能否买到杂志上宣传的这款酷毙了的新游戏。</p>
<p>计谋奏效了，零售商们也开始从 Saber 软件公司订购这款游戏，他们完全没有想到的是：所谓 Saber 实际上是一人企业，而他就是冒名电话背后的始作俑者。凭着这款游戏，法戈得到了 Boom 集团的关注，后一年他被吸收到该集团为他们工作，然而，当 Boom 的一次董事会以大打出手作结时，法戈意识到是该另立门户了。于是他召集死党，在1983年城里了自己的公司。</p>
<p>当时的他们对未来毫无头绪，然而他们没有料想到，公司将要经历的一系列大起大落是如此充满戏剧性，在整个游戏史上也属罕见。这家公司从小工作室起家，发展成为一流发行商，最后却不幸破产。当年也全亏他们慧眼识英雄，才扶持了暴雪、Bioware 和 Treyarch 这些如今行业的巨头。且听我以吟游诗人的曲调，将 Interplay 娱乐公司的这段兴衰史娓娓道来。</p>
<p>起初的 Interplay 并没有什么大作为，仅仅从事一些现有游戏的跨平台移植工作，甚至还从一家军事分包商处接活。最后他们终于同Activision达成协议，从事原创游戏开发。1984年他们的首部作品，冒险游戏《Mindshadow》问世，该作一定程度上基于罗伯特·卢德伦的小说《谍影重重》。在游戏中失忆的主角必须收集线索，找回自己不为人知的过去。游戏获得了一定的成功，Interplay 在原创游戏开发方面也借此迈出了一步。仅一年后，Interplay 出品了第一款真正意义上的大作《遗忘故事第一张：吟游诗人传奇》（冰城传奇），这款角色扮演游戏大量借鉴了《巫术》系列，而后者在病危获得官方授权的情况下，完美地运用了龙与地下城（DND）的规则体系。相比之下《吟游诗人传奇》要精致的多：多色彩，游戏音效和背景音乐的加入，使得 DND 式的冒险历程更为引人入胜。</p>
<p>尽管游戏剧情比较单一，但是开场动画中由一名吟游诗人讲述故事，而后玩家亲身经历冒险的设计，仍令人耳目一新。如同之前的《巫术》，《吟游诗人传奇》中也采用了搜集装备加上练级这种令人欲罢不能的设计。此外，想你的发行商专业化的市场宣传也功不可没，这家初来乍到的新兴企业名为：Electronic Art，EA。尘埃落定后《吟游诗人传奇》一共卖出了30万份，按照1985年的标准这是很惊人的，Interplay 由此从无名小卒一跃成为行业大亨。他们的初衷是把《遗忘故事》做成一个系列，然而本作一炮打响的同时也带来了意料之外的问题，玩家们总是以《吟游诗人传奇》来称呼它。Interplay 原本计划再出两部续作，分别命名为《大法师传奇》和《盗贼传奇》，如今 EA 告诉 Interplay 说，不管他们原本计划如何，现在续作必须得叫做《吟游诗人传奇2》和《吟游诗人传奇3》。当《吟游诗人传奇》的续作陆续获得成功时，也证明了 EA 这家发行商绝非泛泛之辈。Interplay 如今是佳绩不断，如同80年代后期的大部分发行商一样，他们着力于每年推出好几部作品。1988年《吟游诗人传奇3》和《Neuromancer》，后者由威廉·吉布森的著名计算机科幻小说改编。不过 Interplay 在88年最为重量级的作品还要数《废土》，一款以核战后美国西南地区为背景的，充满着道德争议的 RPG 游戏。当时这种崭新的游戏理念前所未闻，玩家可任意探索庞大的游戏世界，而不受单线式流程设计的束缚；游戏有着丰富的剧情，多种多样的角色阵容；地牢采用重复进入时不会复位的设计，而是能够记忆玩家已经杀死了哪些怪物，解开了哪些谜题；但是最具革命性的一点是，与以往 RPG 不同，游戏中不再是善恶分明的黑白世界，玩家的选择往往位于道德的中间灰色地带，有时玩家面临的处境相当灰暗，触及到其他游戏所不敢涉足的禁区。</p>
<p>这是 Interplay 又一款成功大作，发行商仍然是 EA。此时，Interplay 终于决定不再听命于人，决定要自主发行，此时距公司最初成立仅过去短短五年。他们自己发行了《战斗国际象棋》——只是普通的国际象棋，但是加入了其他国际象棋不具备的要素——暴力。在这款国际象棋中，吃子的时候不是简单的吃，而是通过像素动画，将两枚棋子之间为争夺方格而展开的殊死决战充分表现一番，这项貌似无足轻重的小改变成功吸引了玩家，本作也获得了不错的销量。时值80年代末期90年代伊始，Interplay 意得志满，似乎达到了世界巅峰。在布莱恩·法戈和团队的努力之下，公司发展成为了 RPG 界的重量级开发商，自主发行也很成功，还有最后一道疆界需要征服，即成为其他游戏公司的发行商。看到 Activision 和 EA 从自己的游戏中获取大量利润提成，他们意识到这才是最盈利的方式。如今 Interplay 认为自己的机会来了，决定孤注一掷。当时游戏业还属于新生产业，Interplay 决定把筹码压在一些初出茅庐但颇具才华的新生小组上。</p>
<p>最早的一批中，三名自称 Silicon&amp;Synapse 的大学毕业生赫然在列，1991年 Interplay 发行了《RPM赛车》，这是超任平台上第一款由美国公司制作的游戏。这对于 Interplay 来说意义非凡，因为至今他们只在 PC 平台上有所建树，如果能成功跨越到主机平台上，他们就能一跃成为行业佼佼者。之后几年，Silicon&amp;Synapse 持续开发了《失落的维京人》《摇滚赛车》等主机作品。最终 Interplay 提出全面并购这家小公司，然后后者（现已更名为暴雪娱乐）志不在此，当时的 Interplay 并不知道这意味着多大的损失。此时 Interplay 作为开发商仍然硕果累累，1992年他们获得了将原版《星际迷航》改编成游戏的授权，这个消息当时没有引起什么关注，该剧集已经持续播放了几十年，而现在的孩子们都只知道新的《下一代》系列续集。然而《星际迷航——25周年纪念版》在商业销量和评论口碑方面都成为了第一款真正成功的《星际迷航》改编游戏。在之后的 CDROM 版中 Interplay 甚至将原班演员齐聚一堂为游戏角色配音，一个游戏能有这般待遇，挺不错了。</p>
<p>90年代里，Interplay 保留了扶持新兴公司的好传统。1995年他们发行了 Parallax 软件公司制作的《天旋地转》，当时它一般被视为《DOOM》的模仿作品，其实更应该说是启发了《DOOM》的一些游戏的后继作品，类似《银河飞将》。凭借六轴控制，逼真的画面和令人流连忘返的多人模式，《天旋地转》撑了一款小众崇拜作品。Parallax 而后分成 Outrage 和 Volition 两家公司，而后数年，Volition 都委托 Interplay进行游戏发行。他们的《自由空间》系列被认为是一直以来最优秀的太空模拟游戏之一。之后在1996年 Interplay 发行了两部机甲题材游戏，但并未激起很大的波澜。Interplay 内部制作的《铁血兵团》是公司涉足战略类型的首部作品，在 Westwood 工作室推出《命令与征服》后，该游戏类型一夜之间变得火爆。《铁血兵团》与前者有很多共同点，不同之处在于是回合制而非即时。尽管如此，游戏得到了评论界很高的赞誉，许多评论家都声称《铁血兵团》比《命令与征服》更优秀。遗憾的是，玩家们并不这么想，这从本作效良平平上也能看出。同年 Interplay 发行了机甲对战游戏《破碎钢铁》，该作也算不上成功。考虑到本作是由毫无娱乐行业经验的学生制作而成，倒也算不上惊讶。尽管如此，Interplay 同这几名毛头小子保持了良好的关系，后者自称为 Bioware。Interplay 当时没有料到，这几个加拿大小子最终会成为自己最关键的商业伙伴。</p>
<p>1997年的 Interplay 对另一家公司寄予厚望，希望能借助后者跻身顶尖发行商的行列。Shiny 娱乐公司凭借《蚯蚓战士》系列在全球市场获得了成功，衍生的玩具，T 恤和动画片也接踵而至，Shiny 当时正在开发新的《孤胆枪手》系列，其上也炒作也达到了白热化的程度。如果有什么游戏注定会成为经典大作，那么非《孤胆枪手》莫属。自然而然的，Interplay 不只满足于签订发行协议了，他们直接把整家公司买下。最终在几年的万众瞩目和媒体关注后，《孤胆枪手》终于问世，销量却很一般。虽不能说这是款失败作品，却无疑令人失望。而后 Interplay 再度寄希望于 Shiny 的《Wild 9》试图占领主机市场，结果却令他们再度失望。总而言之，看起来 Interplay 只能专注于 PC 市场，而后者的利润正在一点点被主机平台瓜分。尽管形势不利，Interplay 旗下仍然有几款拿得出手的好游戏。Stainless Games 的《死亡赛车》疯狂到了极致，将道德伦理都抛诸九霄云外，玩家通过冲撞行人，摧毁对手车辆获得分数，游戏中还大胆采用了比较原始的物理引擎，尽管如此，玩家们却为之狂热。</p>
<p>1997年还有一款大作值得一提，这是一款回归《废土》的新作，系列的所有权仍归 EA 所有，Interplay 只得从零开始设计一个新系列，《辐射》系列由此诞生。同《废土》一样，辐射是一款颠覆传统道德观的核战后题材 RPG，这次在游戏中，玩家也同样必须作出残酷的决定，而没有轻松的路线可选。幸亏有其中的黑色幽默，赋予整个游戏以后总末日狂欢的意味。艺术设计采用上世界50年代通俗小说的复古风，有着机器人，镭射枪和阴极线管。广阔的世界任玩家探索，升级系统设计既有深度又容易上手，众多角色也令人过目不忘。对于同时期游戏来说，本作的配音阵容也是空前强大，其中包括 Richard Dean Anderson，Keith David 和 Tony Shalhoub，Ron Perlman 则是旁白。如同远足《废土》一样，《辐射》也引起了巨大的轰动，然而在销量方面却无法同《最终幻想7》等大作抗衡，最终败于下风。这给人的感觉是无论 Interplay 再怎么努力突破，再怎么获得评论界的满口赞誉，他们的销量始终比不过竞争对手。而现在，长期不利经营的后果也开始呈现。</p>
<p>此时 Interplay 业务庞大，发行游戏的数量丝毫不亚于 Activision 或者 EA。游戏发行需要庞大的资金投入，但 Interplay 惨淡的销售业绩却难以提供有力的支持。在利润收入方面，PC 成功作品同主机平台成功作品完全无法相提并论，如果 Interplay 无法在主机上尽快打出一块招牌或者让更多的产品扭亏为盈，他们的前景恐怕很不乐观。事实证明，之后的发展比他们想象的要糟糕得多。</p>
<h2 id="u5DE8_u661F_u9668_u843D_Meteoric_Crash"><a href="#u5DE8_u661F_u9668_u843D_Meteoric_Crash" class="headerlink" title="巨星陨落 Meteoric Crash"></a>巨星陨落 Meteoric Crash</h2><p>成立15年的 Interplay 从一场白日梦起头，发展撑了业内举足轻重的发行商。在创立人布莱恩·法戈的领导下，公司出品的《吟游诗人传奇》《废土》等 RPG 都获得了相当的成功。他们趁热打铁，开始涉足游戏发行。首先他们自主发行了《战斗国际象棋》，而后不久便开始为其他公司发行游戏，其中就包括暴雪和 Bioware 的处女作。在1998年，Interplay 的发行量同 Activision 和 EA 等发行巨头已经旗鼓相当，而这两家公司都曾经为 Interplay 发行过游戏。</p>
<p>在外人看来，他们是被所有新兴企业羡慕的楷模，这群年轻人通过投身热爱的游戏事业打造了一个帝国。然而即使在令人炫目的成功下，Interplay的处境仍然岌岌可危，游戏发行是一项耗资巨大的业务，如果不能多发行几部销量火爆的大作，就根本毫无利润可言。遗憾的是，即使像 Interplay 自主制作的《辐射》等大销量作品也无法弥补公司赤字。尽管 Interplay 最为重量级的游戏系列接下来即将登场，无奈生不逢时，也未能挽回最终的败局。</p>
<p>赚到不少钱之后，法戈培养了艺术收藏这个爱好，并成为画家 Gil Bruvel 的崇拜者。当法戈知道 Bruvel 也涉足3D 电脑艺术时，他想到了一个主意：请 Bruvel 为一款点选式冒险游戏做美工，如果能融入文学，神话和宗教的话，新游戏将会有着更为成熟的基调。游戏将探讨原罪与救赎等深层话题，通识彻底颠覆传统。简而言之，这个游戏将作出大胆尝试，把游戏媒介从简单的『玩』上升到艺术高度，然而失败了。1998年出品的《光与暗：预言》是一款七拼八凑的游戏，矫揉造作的同时令人困惑不解，敢于吃螃蟹的少数玩家最后也冷落了它。评论界认为本作有一些闪光的设计，并对其推陈出新的大胆尝试表示赞赏。然而这些都无法掩饰剧情晦涩难懂，过程单调重复的硬伤。当销量不尽人意时，也就不足为奇了。在发行前，游戏就经手了两家制作组，Interplay 还专门邀请好莱坞明星配音，并为 Bruvel 的美工设计支付相当的报酬。换言之，公司在这个游戏上做了很大投入，无奈血本无归。本作可说是 Interplay 所面临困境的缩影，在高瞻远瞩，不遗余力拼搏的同时，缺乏有力的后援。Interplay 一心一意推动创新的努力并为得到应有的回报。</p>
<p>同年早些时候，他们发行了由新的开发商 Treyarch 制作的《剑下亡魂》，游戏采用较原始的动作控制技术，即鼠标控制主角握剑的手，移动鼠标即挥剑。可惜手感欠佳，这个重要的特性也沦为噱头，Interplay 寄希望于新意的尝试再次落空。</p>
<p>在这个多事之秋，Interplay 做出了上市的决定。如今回想起来，当时并非 IPO 的最佳时机，然而募股事务需要很长的时间准备，一旦启动便无退路。1998年6月，Interplay 正式公开招股，期望借此筹得一些迫切需要的资金。正如他们的游戏一样，招股的结果并未达到期望。最初他们希望能达到8到10美元的每股价格，事实却是当天闭市时的牌价只有6美元。了解到公司产品不卖座的情况，投资者们十分谨慎，这令 Interplay 大失所望。讽刺的是，仅数个月后 Interplay 发行的游戏便接连引起轰动，其中包括公司历史上最为成功的一款经典作品。</p>
<p>9月他们发行了黑岛工作室的《辐射2》，且问黑岛工作室是哪位？黑岛工作室即当初制作第一代《辐射》的原班小组，如今他们也有了自己的品牌。之后黑岛继而推出了一系列大作，其中大多数基于 DND 的世界观设定。至于《辐射2》，同前作相比并无太大改变，但增加了大量内容，也如同前作一样，本作只能说是勉强成功，但扔不足以扭转 Interplay 的不利局面。之后在1998年11月，Interplay 发行了 Bioware 的第二款游戏，后者的处女作《破碎钢铁》成绩不佳，在吸取经验教训后，他们继而推出了基于 DND 背景的第二款作品，期望能取得更好的销量。事实证明《博德之门》实际上成为了 Interplay 整个生涯中最重量级的系列。《破碎钢铁》的剧情较为空洞，而《博德之门》却是一款充斥着许多经典角色的亦真亦幻的史诗大作，其庞大的世界任玩家探索。游戏采用快节奏而充满乐趣的设计，同时又不失策略性。DND 爱好者们发现，这款游戏完全忠实于他们熟知的规则体系，堪称完美。随着消息在玩家中不胫而走，Interplay 忽然意识到这群加拿大小子创造了一款经典，然而事不随人愿，《博德之门》操作太复杂，无法在主机上实现，也就是说 Interplay 仍然无法进军利润最为丰厚的家用机市场。尽管《博德之门》有了这样的成绩，Interplay 的季度财政结算仍然是亏损，接下来情况还会变得更糟。</p>
<p>1999年《天旋地转3》和《自由空间2》遭到了预料之外的挫败，其原因或许是同期发售的这两款游戏过于相似。造化弄人的是，他们之后发行的由 Xatrix 制作的风格粗犷的犯罪游戏《黑街太保》刚好同哥伦比亚高校枪击案撞到一起，于是沃尔玛和百思买等大型零售商纷纷将其下架。当时 Interplay 有几个项目被取消，并正在进行公司重组，其结果就是他们字啊99年的亏损比去年更大了。之后数年我们又见到了几款成功作品，例如 Bioware 的《博德之门2》和《孤胆枪手2》，黑岛的《异域镇魂曲》和《冰风谷传奇》等，但总体而言，他们发行的大部分游戏都成绩平平。</p>
<p>最终是壮士断腕的时候了，1999年法国科技公司 Titus 互动从 Interplay 购买了大量股权，而后在2001年，他们又提高股份获取了控制权。如今 Titus 享有所有的决策权，并为 Interplay 提供一些资金，事情似乎有了转机，然而这其实就是终章的开始。Titus 公司的创始人和 CEO 埃尔韦·卡昂在 Titus 取得控制权后成为了 Interplay 的新总裁。上任之后，他首先关闭了发行部门，从此 Interplay 只从事游戏开发，由 Vivendi 负责发行。自此公司失去了曾经的行业重要地位，当然，考虑到他们之前作为发行商不断亏损，这算是一个正确的决策。然而卡昂和 Interplay 创始人布莱恩·法戈的关系，只能说是水火不容。2002年1月，接管仅几个月后，法戈离开了公司。公司的决策过程已经完全不让他参与，他完全不能接受在自己的公司里当个局外人。选择自我放逐后，他成立了新的工作室，其名字也十分贴切：InXile 娱乐（与『流亡』 in exile 同音）。</p>
<p>如今的 Interplay 已经切断了其最重要的历史渊源，随之而来的其他动荡也在意料之中。手头拮据的卡昂开始转让公司旗下的知识产权，并持续吃老本吃了好几年。首先在2002年4月，他以4700万美院的价格把《孤胆枪手》的制作组 Shiny 娱乐卖给了 Infogrames，同时转让的还有《黑客帝国》系列电影的游戏改编权。这不能算贱卖，但失去 Shiny 的损失也是无法挽回的。不幸的是，Interplay 随即受到曾经的得力伙伴 Bioware 的起诉，卡昂领导的 Interplay 不再从事游戏发行，因而尝试将 Bioware 游戏的发行权转授给他人，但并未征求后者意见。义愤填膺的 Bioware 采取了法律手段，与此同时 Bioware 同《天旋地转》的制作方 Parallax 共同起诉 Interplay，理由是拖欠版权费，安检最终庭外和解，且双方同意 Interplay 不再参与 Bioware 的下部作品《无冬之夜》。这些消息还不够坏吗？继而，因其市价不足1美元，Interplay 的股票在2002年10月被纳斯达克退市，2003年 Interplay 因合同违约被自己的发行商 Vivendi 起诉，在此期间，公司每个季度的财政仍然在亏损，最终，不可避免的事情发生了。2003年12月，Interplay 关闭了黑岛工作室——公司自己的制作部门，此时黑岛刚刚完成《博德之门：黑暗联盟2》的制作，正在展开《辐射》下一部续作的开发，其代号为 Van Buren，黑岛的一大批成员预见到了结局，已经纷纷离开另起炉灶，这就是黑曜石娱乐的由来。</p>
<p>『黑曜石』的成员们很快同 Bioware 取得联系，迅速开始合作开发一部续作，2004年的《星战共和国武士2》得以问世。如今的 Interplay作为游戏公司，既不制作游戏，也没有发行游戏，公司最后仅剩下几个游戏版权，包括《蚯蚓战士》《孤胆枪手》《博德之门》及《辐射》等等。作为 Interplay 最后的盈利手段只有将这些版权转让或授权出去，曾经的行业巨头已经跌到了谷底。</p>
<h2 id="u52AB_u540E_u4F59_u6CE2_Life_in_the_Crater"><a href="#u52AB_u540E_u4F59_u6CE2_Life_in_the_Crater" class="headerlink" title="劫后余波 Life in the Crater"></a>劫后余波 Life in the Crater</h2><p>Interplay 始于创始人布莱恩·法戈眼中自信的光芒，凭借着雄心壮志和早期几部成功作品，公司很快跻身游戏业强者之林，在自行开发的同时，也为其他公司发行游戏。然而在90年代后期，Interplay 的大势已去，尽管已经成 RPG 类型的翘楚，他们的游戏没有一款真正获得突破性的成功。更糟的是，自从家用机一跃成为最盈利的游戏平台以来，Interplay 一直无法跨越 PC 和家用机之间的鸿沟。从2000年开始，形势不断下滑，公司每个季度的财政结算持续亏损。法国公司 Titus 互动购买了 Interplay 的控制股权，其所有人卡昂也成为 Interplay 的新总裁。很快地，Interplay 的发行部门被关闭，法戈离开了公司，而卡昂开始变卖旗下的工作室和产权，最终在2003年末，Interplay 停止了游戏开发，从此他们既不再开发游戏，也不发行游戏，手头仅剩下数款游戏版权。在这种情况下，大多数游戏公司都会选择认输，然而在过去这十年间，Interplay 勉力支撑了过来并几乎回归公众焦点，最后却还是功亏一篑。</p>
<p>总之，形势相当不利，而后在2004年6月，加州政府的人员上门了，什么原因呢？原来 Interplay 已经几个星期没有给员工发工资了，而薪金保险的提供商也未能偿付，这是违反加州法律的。同时，不缴纳州税也是违反加州法律的，还有，不缴纳联邦税是违反联邦法的，猜猜 Interplay 还有什么没缴纳的？别忘了 Interplay 还欠着房东40万美元的租金。不过卡昂很快就在新的办公楼重新开工，并获得了加州的许可，不过还有个小问题，卡昂的另一家公司 Titus（即 Interplay 的母公司）碰巧破产了，并且也没有钱为员工结算工资。卡昂的所作所为并没有给人信息或让人觉得他是能够力挽狂澜的救星，在2004年到2007年这段时间 Interplay 都默默无闻，偶尔会出现消息说采用 Interplay 版权的游戏将问世，而后又沉寂下去。在最难以预料的情况下，救星降临了。</p>
<p>角色扮演游戏大厂 Bethesda 突发奇想要出品一款《辐射》游戏，鉴于两家公司的规模悬殊，他们不满足于租用版权，而是要直接买断。2007年 Bethesda 以600万美元的价格买下了这个有着十年历史的系列，双方同时约定，卡昂获得授权制作一款辐射网游，前提是自行筹资，并在规定时间内启动开发。重复一遍，Bethesda 依法『授权Interplay』制作一款辐射网游！根据卡昂的弟弟 Eric 所说，该网友的开发权价值不菲，假如 Inerplay 没有得到授权，转让费就会高达5000万美元，而非600万。Bethesda 继而推出《辐射3》并获得了巨大成功，堪称历史上最成功的 RPG之一。他们最终将《辐射》品牌成功移植到了主机上，实现了 Interplay 的夙愿。突如其来的，《辐射》又再度成为了炙手可热的游戏系列，这正是 Interplay 所需要的，他们的辐射网游也将随之一步登天。然而在2009年9月，Bethesda 一纸诉状将 Interplay 告上法庭，根据合同 Interplay 必须在规定时间内着手网游的开发，如今时间已经超过。此外，趁着新的辐射热，Interplay 又将九班《辐射》游戏再度打包发售，鉴于系列的版权已经易主给 Bethesda，后者声称这是违法的。这场版权争夺战持续了许久，在法庭争端最激烈时，Bethesda 声称当他们授权 Interplay 开发『辐射网游』时，本意是『一款叫做《辐射》的网游』，换言之，同《辐射》系列有关的一切都禁止在游戏中采用：包括武器、角色、场景和著名的 Pip-Boy。根据 Bethesda 的说法，授权范围甚至不包括经典的辐射徽标，Interplay 所能做的，只是制作一款网游并取名为《辐射》。Interplay 无疑提出了抗议，他们认为『辐射网游』的授权本质上就等同于他们可以采用其中的情节、世界背景和一切要素，他们同时还声称网游的开发已经在进行了，当然，实际的开发成果谁也没见过。在此基础上，Interplay 进而提出犹豫 Bethesda 的违约行为，《辐射》系列的版权应当归还给他们。总而言之 Interplay 的处境十分不堪，2001年6月，公司的手头现金仅有3000美元，其债务却高达300万美元，他们通知投资方可能需要裁员。考虑到他们仅有11名员工，这可不是件小事情。即使他们在同 Bethesda 的反诉讼中胜出，也只能取得开发辐射游戏的授权，却不具备实施所需的资金。当然，他们至今还有手握《蚯蚓战士》和《博德之门》的版权，如果能授权或转让出去，应该能获得一些资金，这种商业模式真够诡异的。</p>
<p>无论当今遭遇如何，Interplay 为整个游戏业界留下的财富仍然有目共睹。暴雪如今是动视暴雪的持股方（虽然现在又分离了），他们的《魔兽争霸》《星际争霸》和《暗黑破坏神》都是有史以来最成功的游戏系列，初出茅庐的他们得到过 Interplay 的扶持。Bioware 如今负责 EA 的整个 RPG 部门，他们制作的一些游戏受到评论界有史以来的最高赞誉，初出茅庐的他们得到过 Interplay 的支持。Treyarch 继而开发了《使命召唤》系列，其中最新的《黑色行动》荣登美国历史上最卖座游戏的宝座，初出茅庐的他们也得到过Interplay 的扶持。由《辐射》原班人马组成的黑曜石娱乐，最终以《辐射：新维加斯》回归到了他们所热爱的游戏系列，他们自己说，假如黑岛没有关闭，那么《新维加斯》的故事就是他们当年在续作中想要表现的。至于 Interplay 创始人布莱恩·法戈新成立的 InXile 公司，则刚刚发行了他们的最新游戏《猎杀：恶魔熔炉》，引领着我们回归到那个最初的起点。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Interplay 对于新玩家而言已经过于陌生了，虽然早已不复往昔，但是给游戏业界留下的财富，仍旧不可估量。</p>]]>
    
    </summary>
    
      <category term="Interplay" scheme="http://wdxtub.com/tags/Interplay/"/>
    
      <category term="历史" scheme="http://wdxtub.com/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[游戏发展史 - Bioware]]></title>
    <link href="http://wdxtub.com/2016/03/20/game-history-bioware/"/>
    <id>http://wdxtub.com/2016/03/20/game-history-bioware/</id>
    <published>2016-03-20T14:07:15.000Z</published>
    <updated>2016-03-20T14:21:25.000Z</updated>
    <content type="html"><![CDATA[<p>一个公司能够成为欧美 RPG 玩家心目中『经典』的代言，不得不说是有两把刷子的。</p>
<a id="more"></a>
<hr>
<h2 id="u542F_u7A0B_Setting_Out"><a href="#u542F_u7A0B_Setting_Out" class="headerlink" title="启程 Setting Out"></a>启程 Setting Out</h2><p>1995年，电子游戏已经不再只是孩子的玩具，即使是医生也可能成为玩家。就在这一年，三名医学院毕业生决定在投身医药行业之前做出自己的游戏。就是这样， Ray Muzyka, Greg Zeschuk和Augustine Yip在Zeschuk的地下室创建了自己的公司。谁能想到这样一个组合最后能成为RPG巨匠？他们的名字代表着精品——Bioware.</p>
<p>公司制作的第一款游戏叫做《超钢战神》，这是1996年的一款为MS-DOS平台执着的第一人称载具射击游戏。Bioware尝试提升游戏画面表现，将可变形地表作为一大卖点。游戏还有着复杂的背景故事，在那个年代多数射击游戏内容都只是枪枪枪，这种级别的游戏内涵着实不平常，这也成为了公司以后的立足之本。</p>
<p>《超钢战神》之后Muzyka和Zeschuk想要继续制作游戏，但作为创业伙伴的Augustine Yip决定投身医药行业，离开了公司。尽管如此Bioware还是继续制作了他们的下一款游戏《战场：无垠》并且开始寻找发行商。当interplay旗下的黑岛工作室看过游戏之后，他们并不想仅仅发行游戏，而是想将其打造为公司的标志品牌，并授权Bioware将《战场》做成一款官方D&amp;D规则游戏，结果就是1998年的《博德之门》。</p>
<p>故事发生在AD&amp;D第二版规则设定的“遗忘之地”，游戏保有一切RPG的特性，从移动、攻击到施法，一切结果都是通过计算获得的。Bioware明智地决定让这一过程对玩家不可见，如此一来，即便是从未看过AD&amp;D规则书的玩家也能很快上手，投身进“遗忘之地”之中。游戏是实时进行的，这在D&amp;D电子游戏里尚属首例，玩家可以在战斗开始前按下“暂停”，选择每个队友的进攻路线，再继续游戏观看战略实施。游戏还拥有当时的顶尖画质，充分利用了PC业界的新技术——专用独立显卡。不同于《暗黑破坏神》的杀杀杀&amp;刷刷刷，《博德之门》将重心放在了剧情上，引人入胜的史诗般任务至少花费数十小时，一个法师学徒为其师父报仇的故事都能谋杀玩家的大量时间。支线任务大多也和主线一样有趣，D&amp;D饭也能遇到很多设定中的著名角色并与之互动，对很多玩家来说是梦想成真。虽然画面在今天看来已经过时，但时至今日博德之门依旧是游戏史上剧情最佳的游戏之一。这还没完，游戏提供了多人模式，允许好友组队一起完成任务。这是首款能这么做的PC RPG，这使得游戏大受欢迎，因为核心玩家能在游戏中一路帮助他缺乏经验的朋友。所有这一切成就了1998年最卖座的游戏之一，成为一代RPG名作。</p>
<p>仅仅成立3年并推出两部作品，Bioware从医生的爱好成为了业界领导者，这一切都来得太快，没人知道他们能否将这股劲头保持下去。幸运的是，Bioware的成功之路才刚刚开始。</p>
<h2 id="u7EC4_u961F_Gaining_Allies"><a href="#u7EC4_u961F_Gaining_Allies" class="headerlink" title="组队 Gaining Allies"></a>组队 Gaining Allies</h2><p>三名医学院毕业生决定转行，他们建立了一个叫做Bioware的游戏公司。他们的第一款游戏《超钢战神》并没有在业界引起多大反响，而他们的第二部作品就是角色扮演名作《博德之门》，一夜之间便成为了炙手可热得工作室。Bioware想要继续制作这一系列，但同时又不想固定只做一种类型的游戏。刚好《博德之门》的发行方黑岛，说需要一个开发商制作Shiny小组的MDK续作。我们的RPG大师决定同时制作三款游戏：一款要比原作更庞大的续作，一款全新的RPG，一款他们从未涉足过的3D设计游戏。</p>
<p>和Shiny小组之前的作品一样，MDK是一款风格搞怪的欢乐向游戏。当得知将由《博德之门》小组制作游戏时，MDK粉丝们感到很不安，担心他们会把游戏做得太文艺。幸运的是，即使是医生也懂得欣赏拿枪的战狗，Bioware完全接受了MDK的搞怪风格，续作保持了前作的精彩和幽默。</p>
<p>疯狂科学家，会说话的狗，一代的倒霉蛋清洁工悉数回归，这一次三人都是可玩的角色。更妙的是三人的玩法完全不同，彰显了三人个性的不同。科学家注重解谜，战狗注重射击，清洁工则是在平台间跳来跳去。三种游戏方式都很精妙好玩，这令玩家喜出望外。2000年游戏发售时获得的评价颇高，很多人认为MDK2已经超越了前作，Bioware作品依旧保持了良好的口碑。事实证明他们不仅仅只会照着D&amp;D规则书做游戏。除此之外，MDK2也是公司初次涉足游戏机，DC版是与PC版同步开发的，这一经验对公司之后的作品十分重要。</p>
<p>好像是觉得2000年仅发布一部大作还不够，晚些时候，Bioware还发布了《博德之门2：安姆的阴影》。在1代取得成功之后，B社明白得付出很多努力才对得起1代建立起的名声。尽管有压力，并且很多组员忙于其他项目，发售后《博德之门2》依旧广受好评——更大，更好，比前作更漂亮。博德之门2相比于一代突破并不大，但是2代将1代已有的优点进一步完善近乎完美。游戏还有着出色得剧情以及数百小时的流程，被认为是史上最佳RPG之一。</p>
<p>如果《博德之门1》使Bioware成为了一个3A厂，《博德之门2》则巩固了这一地位。两个项目完成之后，公司还有一个项目尚未完成，依靠对质量和细节的关注，B社使《博德之门》成为了一个成功的品牌，他们也聪明地意识到Mod对销量带来的贡献。考虑到网游越来越受欢迎，公司决定将单人战役，多人体验和MOD工具三合一，让玩家自行选择喜欢的游戏方式。</p>
<p>5年的开发之后，最终《无冬之夜》于2002年发售，这又是一款设定在“遗忘之地”的D&amp;D游戏，包含大量任务和颇具深度的剧情，既可以单人游戏也可以多人合作。随《无冬之夜》一起发售的还有开发工具包，事实上就是Bioware编写游戏使用的同款工具包，最棒的是工具包支持多人游戏，也就是说可以很容易地做出多人mod。不出意料，网上很快就出现了各种类型的mod，从全新的战役，到无双割草，再到网游化mod，这一切只需要一款游戏的价格。再一次的，一款杰作诞生了。这已经使《无冬之夜》成为史上内容最丰富的游戏之一，但这对Bioware来说还不够，他们还将D&amp;D的一大特色带进了游戏里，《无冬之夜》包含了地下城主多人模式，地下城主（DM）可以在其他玩家进行任务时实时添加游戏内容，这成就了变幻莫测的游戏体验，DM可以随心所欲设计冒险任务。令人激动的，富有挑战性的，或者让人玩不下去，完全取决于个人喜好，就像经典的纸笔D&amp;D游戏玩法一样。</p>
<p>同时开发三款游戏，全都叫好又叫座，Bioware无疑称霸了美式RPG市场，同时也涉足了游戏机市场，似乎两位加拿大医生的事业已经到达巅峰。但当他们公布下一款作品时，Bioware向世人揭示了他们的梦想是星辰大海。</p>
<h2 id="u5347_u7EA7_Leveling_Up"><a href="#u5347_u7EA7_Leveling_Up" class="headerlink" title="升级 Leveling Up"></a>升级 Leveling Up</h2><p>2002年，加拿大开发商Bioware，从只能在创始人的地下室办公，一跃成为业界顶尖工作室。《博德之门》系列和MDK2大获成功后，《无冬之夜》同样也叫好又叫座。但其实早在这些游戏发售前，就有一个发行商与Bioware接洽，帮他们制作第一款RPG。于是乎Bioware和“卢卡斯艺术”共同宣布，《无冬之夜》后公司将开发《旧共和国武士》</p>
<p>“卢卡斯艺术”在1999年底便初次与Bioware接触，询问是否能制作一款基于星战EP2的游戏。随着谈判的深入，Bioware也可以选择将设定改到电影发生前的4000年，只要B社愿意。意识到这么做有更大的创作自由而不必拘泥于电影的剧情，Bioware选择将时间设定在很久很久很久以前。“卢卡斯艺术”想要他们制作一款家用机游戏，在审视了市场上现有的游戏机后，Bioware选择了即将发售的微软XBOX，因为他们认为XBOX的开发环境最好。另外这也使其成为XBOX上的首款RPG，再加上《星球大战》的名号，大卖是板上钉钉的事情，而他们押对宝了。</p>
<p>当游戏于2003年发售时，经过数次为了保证质量的延期，发售后不仅星战迷，连评论家也赞不绝口。Bioware在星战科幻背景下编写了一个原创故事，塑造了一个形象生动的角色。游戏在剧情与故事之间找到了平衡，这样一来玩家不仅能带入故事中，还能玩得很开心。</p>
<p>另外Knights of the Old Republic和B社之前作品的差异没有想象中那么大，回合战斗系统依旧基于第三版D&amp;D规则，但有了光剑、激光枪和原力，游戏带来的妥妥是史诗般的星战体验。游戏不仅在商业上获得巨大成功，还拿到了一堆“年度最佳游戏”奖，时至今日依旧是最好的星战游戏之一，要知道星战游戏多如牛毛。一款续作自然也是板上钉钉，但Bioware将开发转交给了另一个开发商，此举震惊了游戏界。比起成为另一家专职星战游戏的开发商，他们更愿意制作自己的原创游戏。</p>
<p>在发布了PC版之后，Bioware又开始同步开发多个项目。在制作了多年的授权项目之后，他们决定回归制作自己的游戏。2004年，B社公布了一个全新的奇幻RPG《龙腾世纪》，花了足足五年这款游戏方才面世。2005年他们发布了《翡翠帝国》，一款游戏机平台上的动作RPG，自B社处女座《超钢战神》发售9年后的首款非授权游戏。</p>
<p>终于完成从回合制到实时战斗的跳跃，B社将叙事与紧张的战斗相结合。游戏背景的灵感来自香港功夫片，和其他Bioware游戏一样，游戏有着众多角色和史诗般的任务，除了拥有会记录你行为的道德系统外，还可以选择发展几段恋情。《翡翠帝国》获得的媒体评价很高，但是玩家受众群没有B社想象的多。游戏销量按其他小组的水平来讲还算不错，但与《博德之门》和《旧共和国武士》相比，仅有Bioware的名字还不足以大卖。另外这款游戏也让B社意识到，游戏的开发成本在成倍增长。即使有之前的成功，他们也得更加商业化，才有自己保质保量地做出他们想要的游戏。</p>
<p>2005年Bioware与Pandemic工作室合并，这是另一家与“卢卡斯艺术”合作过的工作室。如今两家公司的资源整合到了一起，B社准备好了制作它的下一款杰作。他们意识到游戏类型的界限已经越来越模糊，Bioware的下一个项目将是一款RPG与射击游戏的混合体，令公司走进了高清时代。</p>
<h2 id="u5C5E_u6027_u63D0_u5347_Upgrading_Stats"><a href="#u5C5E_u6027_u63D0_u5347_Upgrading_Stats" class="headerlink" title="属性提升 Upgrading Stats"></a>属性提升 Upgrading Stats</h2><p>自2004年就有传言说Bioware在制作一款RPG与射击混合的游戏，但直到2005年10月他们才正式公布《质量效益》，《质量效益》被设定为一个科幻史诗三部曲。虽然他们曾经制作过MDK2，但《质量效益》是公司首次制作核心向射击游戏。一般来说射击游戏的剧情都很弱，B社想将它们擅长的高质量剧情与“虚幻3引擎”相结合，借此同时吸引RPG玩家和射击游戏玩家。和其他Bioware游戏一样，经过数次延期，终于在2007年11月登陆XBOX360。</p>
<p>《质量效益》完全改变了RPG处理对话的方式，不同于在角色头顶冒出对话框或者将画面拉到角色面前的做法，《质量效益》中的对话采用了多角度运镜手法。另外《质量效益》还打破了RPG中只有一方开口说话的传统，主角拥有全程语音，不论玩家选择的角色是男是女。除此之外，B社重新构建了道德衡量标准，并不仅仅是简单的正邪选择，所有的抉择都偏向道德的灰色地带，代表不同的处事信条，迫使玩家在做出选择时得动动脑子，相比市场上的其他游戏更具挑战性。</p>
<p>《质量效益》有着丰富的内容，充满细节的世界观，有血有肉的角色以及史诗般的任务。不幸的是，游戏在拥有出色表现力的同时，还有着频繁的贴图载入延迟问题，极大的破坏了玩家的代入感。为了赶上已经数次延期的发售日，最终导致多数支线任务都很鸡肋。与游戏故事氛围不相称的糟糕设计系统。另外不得不提一下电梯，原本设计目的是为了让游戏在漫长的载入过程中能与NPC队友进行互动，这却成为了游戏的显著缺点之一。最终瑕不掩瑜，质量效益广受玩家和媒体的赞誉，同时也是2007年圣诞购物季销量最高的游戏之一。</p>
<p>然而2008年1月，游戏因为性爱场面受到了媒体关注，专栏作家Kevin McCullough发布一篇博客信口雌黄，随后上了福克斯新闻并在节目中以“SEXBOX”为标题，声称游戏允许青少年玩家能在游戏中推倒一切，而且全程可操控，正面全裸高清无码。不幸的是，这一切全是胡扯，这款M级游戏仅包含两段非互动的朦胧性爱场面。此事证明很多人眼中游戏依旧是儿童的玩物，比起暴力，人们对色情话题更为敏感。这一切都没有影响游戏的销售，晚些时候PC版也顺利发售。</p>
<p>尽管又一款游戏大卖，Bioware明白如果想让成功延续，就得有更多的资源。于是乎，2008年，B社与Pandemic小组的合资公司被EA收购。9月份，公司出品了被EA收购后制作的首款游戏，游戏由世嘉发行，NDS平台游戏《索尼克编年史：黑暗兄弟会》。这是世嘉吉祥物的首款RPG，索尼克需要在朋友们的帮助下解开谜题使世界免遭毁灭，听起来很耳熟是么？</p>
<p>俗套的剧情加上略为无脑的玩法，对于Bioware来说有些异乎寻常。本作的媒体评价只能说是一般，然而本作也因为忠实于索尼克系列的世界观而受到好评，在近几年的索尼克游戏里亦算佳作。</p>
<p>2009年初，有了EA的资金支持，Bioware又一次同时开发多个项目，以至于在蒙特利尔建立了一个新的小组，专门帮忙处理人手不足的项目。同年6月，EA宣布Bioware与另一家RPG开发商“Mythic娱乐”合并，也就是说EA让B社全权主导Mythic。B社原工作室保持不变，Mythic直接由B社领导。换言之，EA的整个RPG部门均由这个加拿大开发商领导。</p>
<p>同月，B社发布了他们的第二款手持设备游戏，iOS平台的《质量效益：银河》。这是一款两小时流程的俯视角射击游戏，展现出Bioware将《质量效益》打造成一个多媒体品牌的渴望。</p>
<p>公司09年真正的大手笔是制作了五年的《龙腾世纪：起源》。自《无冬之夜》后B社再次回归奇幻题材，游戏允许玩家在开始主线前从6个起源故事中选择一个，当然你还是得招募队友帮助你阻止邪恶势力。与以往的B社游戏不同，龙腾世纪更加成人向，战斗过后角色满身是血，即便是好人战斗时也十分无情。不顾《质量效益》引发的争议，《龙腾世纪》也可以发生几段恋情，并且最后啪啪啪，包括同性之间的恋情。整个游戏包含数十小时的流程，尤其当玩家想体验所有六个起源故事时。游戏在PC，Xbox360和PS3上的销量还不错，但作为《博德之门》的精神续作并没有对业绩造成太大冲击。</p>
<p>接下来，Bioware与2010年1月发布了《质量效益2》，这是首款会根据前作存档改变剧情的游戏，换言之，你在1代做出的决定会直接影响到2代。职业大幅平衡，更好的战斗体验，画面提升加上更快的电梯，不仅保持了《质量效益》的好名声，还在此基础上进一步发扬光大。</p>
<p>与此同时Bioware还在制作另一款大作：《星球大战：旧共和国》。这是B社首次涉足网游领域，我们的单机巨人能否在网游界立足？本作号称是史上首款全程语音网游，包括多语言支持。有着《星球大战》的名号，公司意识到这个项目会变得非常巨大，需要一个工作室专门负责该项目，于是他们在德克萨斯州建立了Bioware奥斯汀分部，专职制作这款游戏。与此同时Bioware宣称他们还有尚未公布的游戏正在制作中，是续作还是全新的作品？</p>
<p>他们已经宣布《质量效益3》在制作中（资料为2010年数据）。尽管他们也在尝试射击游戏和网游，但有一点始终未变：他们坚信任何游戏类型都可以拥有一个好的剧情故事。多数工作室把重心优先放在玩法而将剧情放在次要地位的时候，B社证明了对于细节的追求，复杂的道德选择，有血有肉的人物塑造一样能使游戏大卖。优秀的艺术设计，颇具代入感的游戏玩法，Bioware建立了只出精品的良好声誉，不论制作的是何种题材类型的游戏。</p>
<p>15年来一直在改变业界，而一切的开端不过是几个医生的个人爱好。</p>
<p>（光口头说是不够的，如果你这么轻易就被说服，我反而会失望，你亲自去瞧瞧吧）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个公司能够成为欧美 RPG 玩家心目中『经典』的代言，不得不说是有两把刷子的。</p>]]>
    
    </summary>
    
      <category term="Bioware" scheme="http://wdxtub.com/tags/Bioware/"/>
    
      <category term="历史" scheme="http://wdxtub.com/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[游戏发展史 - Valve]]></title>
    <link href="http://wdxtub.com/2016/03/20/game-history-valve/"/>
    <id>http://wdxtub.com/2016/03/20/game-history-valve/</id>
    <published>2016-03-20T14:07:09.000Z</published>
    <updated>2016-03-20T14:10:24.000Z</updated>
    <content type="html"><![CDATA[<p>Valve 虽然从来是『有再一再二，没有再三再四』，但是不得不承认，无论是半条命还是 steam，都称得上『划时代』。</p>
<a id="more"></a>
<hr>
<h2 id="u540D_u4E0D_u89C1_u7ECF_u4F20_u7684_u82F1_u96C4_Unlikely_Heroes"><a href="#u540D_u4E0D_u89C1_u7ECF_u4F20_u7684_u82F1_u96C4_Unlikely_Heroes" class="headerlink" title="名不见经传的英雄 Unlikely Heroes"></a>名不见经传的英雄 Unlikely Heroes</h2><p>1996年，微软已经从一个小作坊成长为世界上最富有的公司之一，最早的一批员工都已经成为了百万富翁。其中两名老员工一直爱玩游戏，现在有了足够的资金做自己想做的事情，他们决定成立自己的公司。</p>
<p>不幸的是，他们对游戏开发毫无经验，只参与过操作系统以及功能性产品的编写，后来一个好友将他们介绍给了著名的id软件创始人——约翰·卡马克，卡马克说服他们应该拿到Quake引擎的许可并做一个游戏。他们同意了，并认为追寻梦想的时机已到。</p>
<p>加布·纽维尔和麦克·哈灵顿为新公司想了几个名字，包括果蝇、全息盒子以及犀牛疤痕(Rhino Scar)，但最后他们选定了一个很简单的名字阀门(VALVE)。</p>
<p>和卡马克见面后，纽维尔和哈灵顿创建了他们的公司，并在纽维尔的婚礼遮天正式注册成立。</p>
<p>【G胖 加布·纽维尔 Valve创始人】：我最初建立一家游戏公司的动机带有一定社会性，我很享受与一帮聪明人一起工作，创造能影响不同群体的游戏。1996年，我在想有哪些选择，在这个问题上我又很大的自由，环游世界，度个假什么的。我最喜欢Valve的一点就是这种特定的工作环境。</p>
<p>不同于Bungie仅靠一人慢慢白手起家，Valve想立马就开始制作高预算游戏，两个人是远远不够的，尤其这两人还从来没做过游戏。于是Valve便开始物色人才，他们的做法不同于当时业界的标准，不仅招募专业人士，还有MOD作者。他们意识到某些mod作者可能比专业人士更有天赋。伺候Valve便开始开辟新的疆土。</p>
<p>公司完全依靠两位创始人的资金运作，这样一来公司便承担得起一般小工作室承受不了的风险。然而仅有两个想追梦的人还远远不够，没有人看好他们，找到一个愿意发行他们作品的发行商几乎不可能。尤其当纽维尔和哈灵顿宣称游戏采用了极其复杂的技术时，发行商们不相信他们能兑现诺言，最后他们找上了“雪乐山在线”(SIERRA Online)，雪乐山刚好打算发行一款3D动作游戏，最好使用Quake引擎制作。Valve团队令他们印象深刻，有了足够的信心与其展开合作，即使失败了，仅仅一款游戏的合约也让雪乐山有退路。</p>
<p>年轻的Valve在1997年E3展上公开了他们的游戏——《半条命(Half Life)》。游戏展现出来的技术和氛围，使其很快成为了展会上的热点。他们做到了，<br>似乎这款游戏注定要大卖。但到了《半条命》本应发售的假日季时，Valve团队意识到产品还未完成，发售日不得不延期。但问题是，他们的发行商雪乐山已经开始广告攻势并视其为年度大作。当Valve宣布延期时，合作关系差点因此破裂。除此之外，他们决定重新审视游戏，在一年的研发时间里，团队摸索出很多尚未加入游戏中的新点子。于是Valve迈出了冒险的一步，推翻多数内容并回炉重做，以加入很多新点子。多数开发商都不会愿意推翻重做，但纽维尔和哈灵顿愿意不惜代价这么做。</p>
<p>【G胖】：每一个Valve迷都知道，Valve的游戏总延期，不是吗？在资源、质量和发售日这几个要素中，我们总是会优先选择延期发售来提高质量。我们的想法是延期总比遗臭万年要好。</p>
<p>随着回炉重做，游戏继续延期，从98年春延期到了98年夏，继续延期到了98年秋，又延期到了98年感恩节。11月时一个游戏Demo泄露到了网上引起轰动，《半条命》成为了年度热点游戏，此时游戏甚至未发售。</p>
<p>万众期待下《半条命》终于在1998年11月上市，市场反响良好。与传统利用过场动画的叙事方式（如毁灭公爵3D, Duke Nukem 3D）和压根不讲剧情（DOOM）不同，《半条命》始终以主角戈登·弗里曼的视点进行，另外故事都是实时呈现的，让玩家代入感倍增，而不只是一个旁观者。</p>
<p>通过脚本，有很多有趣的事件在玩家周围发生，从同事被怪物吃掉，到场景破坏。尤其是游戏的开场部分，大段对话后伴随着实验事故，给人感觉如同互动电影一般。另外游戏的画面与人物动作史无前例。所有者一切都超出了人们的预期。由两个无游戏开发经验的人组成的新公司做出了年度最佳游戏。《半条命》最终成为一个颇具传奇性的游戏系列，时至今日仍旧是销量最高的游戏之一，更何况1998年时的游戏市场规模远不能与今天相比。</p>
<p>随着游戏的成功，大家都想知道何时会有续作。他们会发现《半条命》的未来不仅由Valve创造，玩家自己也参与其中。</p>
<h2 id="u534A_u6761_u547D_u7684_u7B2C_u4E8C_u6625_Half-Life_u2019s_Afterlife"><a href="#u534A_u6761_u547D_u7684_u7B2C_u4E8C_u6625_Half-Life_u2019s_Afterlife" class="headerlink" title="半条命的第二春 Half-Life’s Afterlife"></a>半条命的第二春 Half-Life’s Afterlife</h2><p>《半条命》的空前成功中可以得出以下结论：</p>
<ol>
<li>Valve赢得了豪赌并由此发达</li>
<li>世界需要更多的《半条命》</li>
</ol>
<p>【G胖】：我和麦克都有操作系统及相关产品编程的背景，我们当时很确定失败不可避免，根本就没有理由相信我们会成功。总的来说从商业角度出发我们有些焦虑，问题不是之前的工作完成的如何，而是接下来该干什么。</p>
<p>Valve明白下一个项目需要花“一点”时间，在这段时期gearbox被给予开发资料片的任务——《针锋相对(Opposing Force)》。资料片足够成功，第二个资料片《蓝色沸点(Blue Shift)》【TODO 这里翻译可能有误】的制作也顺理成章。游戏发生的时间地点与原版完全一样，但以不同角色的角度讲述整个故事。《针锋相对》里扮演的是与戈登·弗里曼为敌的海军陆战队员，《蓝色沸点》则扮演的是基地保安巴尼，和原版一样都是以科学定律命名。《针锋相对》指的是牛顿第三定律，《蓝色沸点》值的是多普勒效应。尽管销量不错，但留给人们的印象并不深。制作MOD，即允许玩家深度挖掘游戏代码并改写成新游戏，这一做法被某些工作室接受，比如id软件，而其他多数开发商则不允许。Valve决定向mod社区打开阀门，因为本身公司的很多雇员也来自那里。</p>
<p>【G胖】：《半条命》的特征之一就是被mod社区广泛接受。麦克和我都有操作系统编程经验，在我们研发操作系统时总是在想我们所编写的程序间接创造的价值。你所编写的工具被用来从其他消费者那创造价值。一个好的工具对于一个大公司的价值与在澳大利亚开发《军团要塞》的两个孩子来说其实差别不大。</p>
<p>随着《半条命》大量源代码的开放，很快网上便充斥着各种MOD，其中少数几个素质几乎与原版比肩。《胜利之日(Day of Defeat)》是一款二战射击游戏；《团队要塞(Team Fortress)》是一款很受欢迎的Quake mod，应玩家要求制作了《半条命》版。</p>
<p>但《半条命》最受欢迎也是世上最成功的MOD是——《反恐精英(Counter-Strike)》。作为一款团队回合制多人射击游戏，几乎完全重写了原作。原作的多人模式就是全员无差别大乱斗，当时的FPS多人游戏基本都是如此。《反恐精英》于1996年6月进行了首次Beta测试，不到一年，mod团队就因为游戏太受欢迎被Valve收编。</p>
<p>Valve之后买下了之前提到了所有3个MOD，这3个MOD之后都成为了商业化品牌。开发商一般都不愿放出自己的源代码，担心会对自己的品牌构成威胁。Valve证明了与mode社区的开放关系其实能增加销量，毕竟想要玩DOD或者CS还得先购买《半条命》。</p>
<p>【G胖】：多多沟通、信任并与玩家社区合作，就能获得更好的娱乐体验，从长远来说你的生意也能因此获得更多利润。</p>
<p>与多数游戏刚发售时销量很高，随后便一路走低不同，《半条命》一直保持着稳定的销量，玩家也有越来越多的理由继续玩下去。不过除去这些项目，大多数人都更像知道Valve下一步打算做什么。这么多年Valve没有放出一点消息，于是流言四起。</p>
<p>直到2003年E3展《半条命》发售5年后，Valve终于再次出手，向世界展示了没人能像他们一样做出《半条命》</p>
<h2 id="u7EED_u4F5C_u98CE_u6CE2_The_Trouble_with_Sequels"><a href="#u7EED_u4F5C_u98CE_u6CE2_The_Trouble_with_Sequels" class="headerlink" title="续作风波 The Trouble with Sequels"></a>续作风波 The Trouble with Sequels</h2><p>2003年E3展上《半条命2》的公布，在玩家群里引起轰动。依靠第一部建立起来的声望，所有人的翘首以盼2003年9月发售日的到来。就在游戏即将发售的时候，意想不到的事发生了。Valve的服务器被黑了，游戏源代码、地图、皮肤被匿名黑客窃取，这是游戏史上最严重的黑客事件之一。失窃的代码足以构建数个可玩的场景，这个泄露版充满了BUG，而且多数时候都很无聊，总之不具备可玩性。更糟的是Valve一次宣布游戏不能在03年内发售。</p>
<p>【G胖】：我们已经花费数年开发《半条命2》，我们的压力很大，不仅是长时间的工作，还担心产品设计和技术上的风险。有的员工十分不安，我们制作数年的心血以一种完成度极低的形态在网上大量传播，这事令我十分痛苦。就像是一大帮人用女性角色与一个科学家XXOO的场面做新品推荐一样。有人走进我的办公室问我，公司是不是要停业了，我们是不是应该忘掉《半条命2》去做点别的，因为这个产品已经被泄露事件毁了。</p>
<p>Valve立即联系了FBI，对黑客是谁展开调查。但Valve与玩家社区也一直保持着良好的关系，决定利用这一条件帮助调查。加布·纽维尔在论坛公开确认了泄露事件，并请求在线社区帮忙找出黑客。G胖得到了压倒性的支持，在玩家回复中也逐渐弄清楚了泄露的代码是如何在网上传播开的。尽管FBI和玩家们都作出了努力，黑客的身份一直是个谜。直到黑客自己现身说法，解释了他如何黑进服务器，并向Valve索取一个职位。Axel Gembe描述了黑客行为的细节，他利用了微软Outlook的发件箱安全漏洞。并声称自己并不是一个坏人而且真心实意愿意为Valve工作。Valve欣然答应，并通知了联邦调查局为其设下圈套。不幸的是Gembe觉察到了圈套，决定不离开德国，最终他被德国警察逮捕。</p>
<p>可能是还觉得不够有戏剧性，Valve与发行商陷入了合同纠纷。在亚洲，人们更多的在网吧玩PC游戏，而非在家用电脑上，这就使得网吧成为了主要市场。发行商“威望迪环球(VIVEND UNIVERSAL)”宣称他们买断了网吧销售权，而Valve则坚持他们有权通过数字发行在网吧销售游戏。</p>
<p>卡发着意识到自己处于一个尴尬境地，那就是和帮他们卖游戏的人打官司。这个纠纷在游戏发售后依旧持续数月，最终庭外和解。经过一系列跳票，《半条命2》终于在2004年11月16日上市，历经6年制作，负面新闻不断，玩家们担心是否能达到前作的高度。</p>
<p>幸运的是，玩家的超高期待是值得的。</p>
<h2 id="u534A_u6761_u547D_u7684_u4E8C_u6B21_u65B9_Half_Times_Two"><a href="#u534A_u6761_u547D_u7684_u4E8C_u6B21_u65B9_Half_Times_Two" class="headerlink" title="半条命的二次方 Half Times Two"></a>半条命的二次方 Half Times Two</h2><p>《半条命2》于2004年11月16日上市，巧合的是，此时距离另一款备受期待的科幻射击游戏上市不过一周。这部作品的名字开头也是“HAL”——《光环2(HALO 2)》。尽管《光环2》属于年度大作之一，但即便是士官长也难掩戈登·弗里曼的光环。</p>
<p>《半条命2》在发售前就已经开辟了新的疆土，超强的source图像引擎已经被用于更新CS，在《半条命2》发售前便可以开玩。这一切由Steam带来，Steam由Valve研发并包含：数字版权管理、软件商店，之后还添加了玩家社区。Steam允许玩家在线购买游戏，并直接通过Valve服务器进行下载，服务器会检测游戏是否合法。</p>
<p>【G胖】：我们认为这对游戏开发商来说是个好机会，我们改变了游戏的发行和更新方式。我们开始寻找眼光独到的开发商帮助我们编写这个系统，让像我们这样的游戏开发商和软件开发者登陆这个平台，之前没人这么做过着实令人惊讶。一个本地的开发团队有意接手此项目，我们便开始了合作，让他们主导steam团队，最后这波人在两年内相继离职，所这可能并不是最明智的做法。</p>
<p>Seam甚至允许用户在游戏发售前预先下载游戏，当然在发售日之前你还是进不了游戏，但时间一到就能立刻开玩，不需要再进行额外的下载，这标志着游戏业向数字发行方向迈出的一大步。如此一来Valve便不用付钱给发行商，利润自然也大大提高。这一新的发行方式正逐渐改变游戏业界的面貌，Valve是这一变革的先行者。</p>
<p>《半条命2》的游戏本身也是一款杰作，在这款氛围独特的游戏里，双眼所及之处都充满了故事。Valve构建了一个活生生的世界，NPC有着很高的AI，从凶恶的敌人到惊恐的平民，NPC都有生动的面部表情和嘴唇同步，精彩的台词和专业的配音。</p>
<p>玩家将再次扮演戈登·弗里曼，这次弗里曼将在一个已经被外星人占领的世界中作战。除了著名的source图像引擎，《半条命2》还使用了当时最为先进和精确的物理引擎。这就使得HL2里能够设置几个物理谜题，作为激烈战斗之后的调剂，这也使重力枪有了用武之地。这把枪能够举起并投掷游戏中的任何物体，玩起来各种欢乐。Valve在游戏发售后添加了更多内容，购买《半条命2》的人已经免费获得了CS:S，之后还添加了《半条命2：死亡竞赛》以及一个技术演示《消失的海岸线》，V社果然很良心。《消失的海岸线》甚至还包含了开发者评论内容，这在业界是前无古人的。</p>
<p>和前作一样，《半条命2》易于制作MOD，在steam上既可以运行官方产品也能运行mod，多年后依然有大量MOD推出。其中最受欢迎的是Garry’smod，与其说是游戏，不如说是个物理沙盒。mod允许玩家利用游戏的物理系统建造出能想象出的任何东西，极大的提高了玩家的创造力。</p>
<p>所有这一切造就了HL2的巨大成功。游戏评论者们爱它，玩家们膜拜它，总之深受广大消费者的欢迎，Valve再次完成了不可能的任务。随后HL2还登陆了Xbox、Xbox360和PS3，PC游戏界的杰作终于登陆了游戏主机。和前作一样HL2也成为了史上最具影响力和销量最高的游戏之一。但是Valve不打算再等6年才发售下一部作品，公司再次突破桎梏，改变了他们制作游戏的方式。</p>
<h2 id="u6E38_u620F_u9769_u65B0_u8005_Game_Changer"><a href="#u6E38_u620F_u9769_u65B0_u8005_Game_Changer" class="headerlink" title="游戏革新者 Game Changer"></a>游戏革新者 Game Changer</h2><p>Valve并没有直接开始制作《半条命3》，而是为《半条命2》做几个资料片，这一点并没有什么稀奇的，但是在制作的过程中，Valve意识到可以借此机会实验改变游戏开发和消费者的游戏体验方式。一般来说一个小组制作流程数十小时的作品，售价一般为50-60美元，这些游戏制作非常花费时间，通常为2-3年或者像HL2这样花了6年。</p>
<p>但Valve就想为什么不直接用HL2的source引擎，只做小小的升级，在短时间内制作一个流程相对短的游戏，仅售20美元。最后的结果就是独立资料片，按Valve的说法叫章节化，巧妙地命名为《半条命2：第一章》（不需要本体即可独立运行）</p>
<p>【G胖】：总的来说我们不认为定价属于某种策略，你得给人们一些选择，在产品之间有比较。价格因素能吸引大量不同的消费者，从而提高收入。我们在《半条命2》上运用的章节化做法本身对游戏内容的主干没什么影响。</p>
<p>第一章紧接着原作的结局，可以看到结局之后发生了什么。采用和HL2相同的图像和物理引擎，游戏本身依旧发生在17号城市。研发团队能很快从概念设计进入到实施阶段，因为一切都是现成的。</p>
<p>在原作发售后仅仅一年半，《第一章》以20美元的超低价开卖，提供了一个6小时的单人战役，让戈登·弗里曼重返被在原作中被他毁坏的城市。游戏本身对故事进程的推进不大，敌人也和原作基本相同，与其说是独立作品，不如说是对原作的拓展。尽管如此，销量依然不错，毕竟玩家们未曾想到这么快就能开始新的冒险。</p>
<p>在《第一章》获得商业成功后，所有人都翘首等待《第二章》，但他们等到的却是《橙盒版(The Orange Box)》。《橙盒版》是五款游戏的合集，却仅售一款游戏的价格，包含已发售的《半条命2》和《第一章》，以及新游戏《第二章》《军团要塞2》，以及解密游戏《传送门(Portal)》。距离《第一章》发售过去近一年，这是谁都没有预料到的。Valve的这种行为是一场豪赌：捆绑销售的销量会比拆开单卖的销量更多吗？</p>
<p>【G胖】：我们有一款全新的游戏《传送门》，我们想试探一下市场，《橙盒版》提供了媒介。我们有《第二章》和《军团要塞2》这样备受期待的作品，给《传送门》一个推广的机会，与其他游戏捆绑让尽可能多的人玩到这款游戏。即使《传送门》失败了也没什么，这毕竟是一款解谜游戏，本身就是一个很小众的游戏类型。</p>
<p>捆绑销售大获成功，每人都能各取所需。这次也证明Valve可以发售多平台游戏，因为PC版与XBOX360版同步上市。不幸的是，V社发现PS3的开发环境很糟，所以PS3版是依靠第三方帮忙移植的。</p>
<p>《第二章》把玩家和忠实的伙伴Alyx带到了17号城市之外，探索新地点，遭遇新敌人。本作同样包含6个小时的战役，但内容和故事比第一章丰富许多。</p>
<p>《军团要塞2》走的是风格化欢乐向路线，成为一款卡通化，有多兵种选择的射击游戏。</p>
<p>《传送门》是10年间最具创新性的大作，第一人称射击解谜游戏，彻底改变你的空间思考方式。尽管游戏流程只有3小时，但引人入胜的玩法和谜题以及别出心裁的结尾曲已经使这款作品成为了圈内的传奇。</p>
<p>随着意料之中的《第二章》以及意料之外的《军团要塞2》和《传送门》的发售，每个人都在想《第三章》会和什么游戏捆绑。但Valve再次出人意料，将视线远离《半条命》，转向了一个全新的游戏，于2008年公开。一款让猎头蟹都显得如同乖狗狗一般的恐怖游戏。</p>
<h2 id="u6CBB_u7597_u611F_u67D3_uFF0C_u4E00_u6B21_u4E00_u9897_u5B50_u5F39_Beyond_the_Crowbar_u2026_And_Beyond"><a href="#u6CBB_u7597_u611F_u67D3_uFF0C_u4E00_u6B21_u4E00_u9897_u5B50_u5F39_Beyond_the_Crowbar_u2026_And_Beyond" class="headerlink" title="治疗感染，一次一颗子弹 Beyond the Crowbar… And Beyond"></a>治疗感染，一次一颗子弹 Beyond the Crowbar… And Beyond</h2><p>《求生之路》是一款僵尸射击游戏，但又与其他同类游戏有着明显的差异。游戏注重玩家间的团队合作，玩家将操控由4人组成的幸存者团队，单人游戏时其他队友由电脑操控。和《半条命》一样，游戏通过一段段突然发生的战斗营造出一种紧张氛围，令人毛骨悚然。为了达到这种效果，Valve创造了“导演”系统，一个会根据玩家行为i不端改变的系统。</p>
<p>举个例子，加入四个高玩一路碾压，“导演”会产生更少的弹药和医疗包，并产生更多的僵尸群，顺便把路上的灯也给关了。假如是一个菜鸟与三名电脑同伴，游戏会减少僵尸数量并提供更多的医疗包。如此一来，每次的游戏体验都不会完全一样，大大增极爱了重复可玩性。</p>
<p>考虑到僵尸在娱乐文化中的再次流行以及Valve的良好形象，游戏大卖完全在意料之中，V社还承诺会在DLC中添加更多内容。但Valve从不按常理出牌，Valve震惊了业界，他们宣布立即开始了《求生之路2》的开发，尽在1代一年后便发售。如此短的时间便推出续作是前所未有的，人们担心Valve会赶工发售游戏。</p>
<p>【G胖】：《求生之路1》发售之后，我们想开始做《求生之路2》并且快速完成，也许我们是太过在意这个。这样不是很酷吗？《半条命1》延期一年，《半条命2》也延期一年，《半条命2：第三章》影子都没有。我们长期因为延期饱受批评，认为我们的进度管理很糟糕。我们就想“其实我们可以在一年的时间里做出L4D2”。本以为人们的反应会是“Valve终于不延期了，实在太酷了”。而事实上有些人觉得这很不科学，他们不认为这是Valve的一大进步，而把这当做是V社“变了”的信号，觉得我们会砸了牌子。</p>
<p>更糟的是，《求生之路》粉丝和《半条命》粉丝都觉得遭到了背叛。《求生之路》玩家担心续作会挤掉1代DLC制作并且分化两代的玩家。一些不满的玩家开始建立群组号召抵制续作，不到一个月就有成千上万的玩家加入。与此同时，苦等《第三章》的玩家希望破灭，因为比起猎头蟹僵尸，V社似乎对病毒感染僵尸更有兴趣。</p>
<p>V社一向很关注玩家群体，G胖本人公开回应了玩家们的顾虑，声明1代还会继续推出DLC和升级补丁。事实上V社也已经发布了两个DLC，包含新的多人模式和一个新的剧情。</p>
<p>【G胖】：做完《求生之路2》后团队里没人说“好吧，我们在一年内做出L4D3吧”</p>
<p>尽管发生了抵制活动，L4D2的预定量依旧超过1代。然而作为一个以亲近玩家为荣的公司，《求生之路2》引发的论战可能是自HL2泄露事件以来最大的一次倒退。</p>
<p>【G胖】：我们并为预料到玩家会如此反应，我们完全理解玩家为何会有这些顾虑，我们应该解释一下，作为《求生之路2》发售前准备工作的一部分，不幸的是我们没有这么做，结果就是一帮人发起了抵制活动，我们的责任就是打消这些人的顾虑，我们得和他们对话，确保他们明白我们怎么想的，决策是如何做出的，安抚他们。这是Valve一直以来的传统哲学，让玩家们能继续支持《求生之路1》并创造价值。最后我们邀请两位抵制活动的发起人来到公司总部，问题是所有人都说他们并无恶意，我们提供机会让他们坐下来试玩，这招似乎很管用，让玩家社区觉得他们的想法得到了重视。通过Steam平台，我们可以看到抵制小组内拥有L4D1的玩家购买L4D2的比例其实比全球范围内的L4D1小组要高。也就是说我们很好的打消了顾虑，向他们表明了我们的计划，发售时玩家的情绪比刚公布时平静许多。</p>
<p>有件事多年以来一直没变，那就是V社不按常理出牌。从游戏研发到发布数字平台，V社一直在小心翼翼地审视自己和整个业界以寻找新的路子推陈出新。和其他行业一样，多数游戏小组一直做固定的系列或游戏类型，只做很小的创新以保证销量，但Valve总是不走寻常路，偶尔也会遇到一些麻烦，但每次都能将危机化解，游戏大卖，叫好又叫座，<br>这一切都归功于之前从未制作过游戏，但清楚的知道自己想要什么的两个人。</p>
<p>（正义之子面对有悖于常理的世界，会使其天翻地覆）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Valve 虽然从来是『有再一再二，没有再三再四』，但是不得不承认，无论是半条命还是 steam，都称得上『划时代』。</p>]]>
    
    </summary>
    
      <category term="Valve" scheme="http://wdxtub.com/tags/Valve/"/>
    
      <category term="历史" scheme="http://wdxtub.com/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iTerm2 指南]]></title>
    <link href="http://wdxtub.com/2016/03/20/iterm2-guide/"/>
    <id>http://wdxtub.com/2016/03/20/iterm2-guide/</id>
    <published>2016-03-20T13:36:10.000Z</published>
    <updated>2016-03-20T13:37:01.000Z</updated>
    <content type="html"><![CDATA[<p>这里是 iTerm2 的基本入门操作，熟悉之后可以大幅提高效率。</p>
<a id="more"></a>
<hr>
<h2 id="u5149_u6807_u63A7_u5236"><a href="#u5149_u6807_u63A7_u5236" class="headerlink" title="光标控制"></a>光标控制</h2><ul>
<li>ctrl + a: 到行首</li>
<li>ctrl + e: 行末</li>
<li>ctrl + f/b: 前进后退，相当于左右方向键，但是显然比移开手按方向键更快</li>
<li>ctrl + p: 上一条命令，相当于方向键上</li>
<li>ctrl + r: 搜索命令历史，这个大家都应该很熟悉了</li>
<li>ctrl + d: 删除当前字符</li>
<li>ctrl + h: 删除之前的字符</li>
<li>ctrl + w: 删除光标前的单词</li>
<li>ctrl + k: 删除到文本末尾</li>
<li>ctrl + t: 交换光标处文本</li>
<li>⌘ + —/+/0: 调整字体大小</li>
<li>⌘ + r:清屏，其实是滚到新的一屏，并没有清空。ctrl + l 也可以做到。</li>
</ul>
<h2 id="u7A97_u53E3_u64CD_u4F5C"><a href="#u7A97_u53E3_u64CD_u4F5C" class="headerlink" title="窗口操作"></a>窗口操作</h2><ul>
<li>新建窗口：shift + command + d（横向）command + d（竖向）</li>
<li>关闭窗口：shift + command + w</li>
<li>前一个窗口：command + `</li>
<li>后一个窗口：command + ~</li>
<li>进入窗口 1,2,3：option + command + 编号</li>
</ul>
<h2 id="u6807_u7B7E_u9875_u64CD_u4F5C"><a href="#u6807_u7B7E_u9875_u64CD_u4F5C" class="headerlink" title="标签页操作"></a>标签页操作</h2><ul>
<li>新建标签页: Command + T</li>
<li>关闭标签页: Command + W</li>
<li>前一个标签页: Command + 左方向键，Shift + Command + [</li>
<li>后一个标签页: Command + 右方向键，Shitf + Command + ]</li>
<li>进入标签页1，2，3…: Command + 标签页编号</li>
<li>Expose 标签页: Option + Command + E（将标签页打撒到全屏，并可以全局搜索所有的标签页）</li>
</ul>
<h2 id="u9762_u677F_u64CD_u4F5C"><a href="#u9762_u677F_u64CD_u4F5C" class="headerlink" title="面板操作"></a>面板操作</h2><ul>
<li>垂直分割: Command + D</li>
<li>水平分割: Shift + Command + D</li>
<li>前一个面板: Command + [</li>
<li>后一个面板: Command + ]</li>
<li>切换到上/下/左/右面板: Option + Command + 上下左右方向键</li>
</ul>
<h2 id="u5176_u4ED6_u529F_u80FD"><a href="#u5176_u4ED6_u529F_u80FD" class="headerlink" title="其他功能"></a>其他功能</h2><ul>
<li>支持自定义全局快捷键用于显示和隐藏iTerm2 Preference -&gt; Keys －&gt; Show/hide iTerm2 with a system-wide hotkey 打上勾之后</li>
<li>进入和退出全屏: Command + Enter</li>
<li>查看当前终端中光标的位置: Command + /</li>
<li>命令自动补全: Command + ;（很少用这个，还是感觉Zsh的补全更好用）</li>
<li>开启和关闭背景半透明: Command + u</li>
<li>清屏（重置当前终端）: Command + r</li>
</ul>
<h2 id="u6587_u672C_u9009_u53D6"><a href="#u6587_u672C_u9009_u53D6" class="headerlink" title="文本选取"></a>文本选取</h2><p>文本选取有使用鼠标和不使用鼠标两种方式。</p>
<p>使用鼠标</p>
<p>默认情况下，选取的文字会自动复制到剪切板，可以使用以下方式进行文本选取：</p>
<ul>
<li>常见的点击并拖拽方式</li>
<li>双击选取整个单词</li>
<li>三击选取整行</li>
<li>选取某一部分，按住Shift，再点击某处，可以选取整个矩形内的文本（类似Windows下按住Shift可以批量选取图标）</li>
<li>按住Command + Option，可以用鼠标画出一个矩形，用类似截图的方式选取文本 另外，还可以使用鼠标完成以下操作： 按住Command然后点击某个URL，会在浏览器中打开这个URL，点击某个文件夹，会在Finder里打开这个文件夹（再也不用open . 啦），点击某个文件名，会打开这个文件（文本文件支持MacVim，TextMate和BBEdit，如果后面跟随一个冒号和行号，文件会在行号处打开，其它格式的文件似乎不能调用默认程序打开） 选取文本之后，按住Command 同时拖动文本，可以将文本粘贴到目标位置（Drag and Drop） 鼠标中键粘贴（这个太感人了，一下子找回Linux的感觉了）</li>
</ul>
<p>不使用鼠标</p>
<p>(这种方式最多只能选取一行文本) 使用 Command + f，会呼出一个搜索框，可以在当前面板中进行搜索，输入想要选取的部分内容，输入过程中，按Tab可以将选取部分向右扩展，按Shift + Tab向左扩展，按回车转到下一个匹配位置。使用Tab或Shift+Tab扩展得到想要的内容之后，选取内容会自动复制到剪切板，再次按Command + f隐藏搜索框。</p>
<h2 id="u4F4D_u7F6E_u4E66_u7B7E"><a href="#u4F4D_u7F6E_u4E66_u7B7E" class="headerlink" title="位置书签"></a>位置书签</h2><p>在当前会话中按Command + Shift + m可以保存当前位置，之后可以按Command + Shift + j跳回这个位置。</p>
<h2 id="u7C98_u8D34_u5386_u53F2"><a href="#u7C98_u8D34_u5386_u53F2" class="headerlink" title="粘贴历史"></a>粘贴历史</h2><p>使用Command + Shift + h 可以呼出粘贴历史，支持模糊检索。还可以设置将粘贴历史保存在磁盘上（Preferences -&gt; General）</p>
<h2 id="u5373_u65F6_u56DE_u653E"><a href="#u5373_u65F6_u56DE_u653E" class="headerlink" title="即时回放"></a>即时回放</h2><p>使用Command + Opt + b 打开即时回放，按Esc退出。即时回放可以记录终端输出的状态，让你“穿越时间”查看终端内容。默认每个会话最多储存4MB的内容，可以在设置中更改（Preferences -&gt; Genernal -&gt; Instant Replay）。</p>
<h2 id="u7A97_u53E3_u72B6_u6001"><a href="#u7A97_u53E3_u72B6_u6001" class="headerlink" title="窗口状态"></a>窗口状态</h2><p>通过 Window -&gt; Save Window Arrangement 可以保存当前窗口状态的快照，包括打开的窗口，标签页和面板。通过 Window -&gt; Restore Window Arrangement 还原。还可以在 Preferences -&gt; General -&gt; Open saved window arrangement 中设置在启动iTerm2时自动恢复窗口状态</p>
<h2 id="u7279_u8272_u529F_u80FD"><a href="#u7279_u8272_u529F_u80FD" class="headerlink" title="特色功能"></a>特色功能</h2><ul>
<li>command+; 根据上下文呼出自动完成窗口，上下键选择</li>
<li>全屏 command+enter</li>
<li>光标去哪了？command+/</li>
<li>用鼠标选中某个路径或者某个词汇就自动复制</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里是 iTerm2 的基本入门操作，熟悉之后可以大幅提高效率。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://wdxtub.com/tags/Mac/"/>
    
      <category term="Shell" scheme="http://wdxtub.com/tags/Shell/"/>
    
      <category term="iTerm2" scheme="http://wdxtub.com/tags/iTerm2/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Make 与 GCC 指南]]></title>
    <link href="http://wdxtub.com/2016/03/20/make-gcc-guide/"/>
    <id>http://wdxtub.com/2016/03/20/make-gcc-guide/</id>
    <published>2016-03-20T13:33:49.000Z</published>
    <updated>2016-03-20T13:35:45.000Z</updated>
    <content type="html"><![CDATA[<p>Make 可以简化编译过程，如果有一个近百个源文件的项目，如果有个文件更改后工程需要重新编译，那么一直用gcc -c a.c这些个命令敲来敲去会屎人的。运行make时候，他会寻找指定目录下（默认是 .）的 Makefile 文件并且分析依赖关系进行必要的编译。</p>
<a id="more"></a>
<hr>
<p>Makefile文件的基本格式很简单：</p>
<pre><code>目标文件： 依赖文件1 依赖文件2 依赖文件3 。。。。
[tab]编译命令
</code></pre><p>他的意思是目标文件是依赖于冒号后面几个文件的，如果这些依赖文件有更新的，那么其目标文件也需要更新。</p>
<p>Makefile 中可能有很多以上条目，他们共同组成了一个有向无回路图（DAG图），这样可以传递依赖。make 命令会把 Makefile 文件的第一个目标文件作为默认目标，当执行 make 命令时，make 会考察这个目标文件的依赖关系，进行编译。也可以指定，比如这个 Makefile：</p>
<pre><code>main: a.o b.o
[tab]gcc -o main a.o b.o
a.o : a.c c.h
[tab]gcc -c a.c -o a.o
b.o: b.c c.h
[tab]gcc -c b.c -o b.o

// [tab]的意思是这里用tab字符代替，不能有其他的什么字符
</code></pre><p>在命令行里执行make，分析关系并生成main，如果是make a.o那么他只会编译到 a.o 。</p>
<p>当然我们还可以设定伪目标，比如：</p>
<pre><code>clean：
[tab]rm a.o b.o
</code></pre><p>这样执行make clean的时候就把.o文件清除了,这里不会生成什么文件,只进行一些操作,更清楚的做法是在前面加上以下语句:</p>
<pre><code>.PHONY : clean install dest [其他伪目标]
</code></pre><p>下面来说下变量，Makefile 里的变量按惯例是大写，包括数字字母下划线。当我们需要一个变量的值的时候，通常用 ${NAME} 或者 $(NAME)。他有好几种变量定义的方法。</p>
<p>首先是常规法，就是A=content，等号两边可以有空格，和shell不一样。</p>
<p>其次是递归法，比如A=$(B)，B=$(C)，C=haha，那么当寻找A的定义的时候就会去找B，然后再找C，变量展开的时候就是当他被引用的时候，这种方法效率比较低，因为如果他引用了函数，那么每次展开都要调用函数，而且可能会出现无限递归（A=$(B),B=$(A)）。</p>
<p>然后是直接展开法。这个很容易理解，就像是c语言是按照顺序执行的，当变量定义的时候这个变量就已经展开了（如果他引用了变量A，引用的是他定义时候A的值），当被引用的时候就直接用他代表的字符串替代。但是他用的不是等号 是 := ,比如 A:=hello，A:=$(B)。</p>
<p>还有嵌套定义： A=B,B=haha,V=$($(A))类似于这种的V的值是haha</p>
<p>最后是替换引用定义，他会替换后缀，有个例子很好 foo := a.o b.o c.o ,bar := $(foo:.o=.c),我们可以知道bar的值就是 a.c b.c c.c。</p>
<p>变量还有分类：</p>
<p>1.预定义变量，当使用隐式规则的时候他会派上用场，常用的有以下几个：</p>
<pre><code>CC   c编译器的名称（默认gcc？）
CPP    c预编译器名称（默认$(CC) -E）
CXX c++编译器的名称(默认g++)
CFLAGS c编译器选项,无默认值
CXXFLAGS c++编译器选项,无默认值
</code></pre><p>2.自动变量,常用有以下:</p>
<pre><code>$@:表示当前规则中的完整目标文件名
$*:不包含扩展名的目标文件名
$&lt;:当前规则中第一个依赖文件名
$^:当前规则所有文件列表
$%:当目标为库文件时,表示库文件名
</code></pre><p>3.环境变量,Makefile对环境变量是可见的,可以引用.</p>
<p>Makefile还有个常用的东东就是隐式规则,make会自己推导.比如说</p>
<pre><code>c：a.o b.o
[tab]gcc -o c a.o b.o
</code></pre><p>这时我们可以省略下面的命令，直接用第一行就行。make自动分析生成a，此时预定义变量就有用了，CC，CFLAGS等也派上了用场。</p>
<p>由于把握不了隐式规则的底线和能力，我还是觉得隐式规则应用的不要太多太复杂影响阅读为好。。</p>
<p>make的工作过程大概是一下几步</p>
<ol>
<li>读取Makefile，根据make的选项查找Makefile</li>
<li>初始化Makefile，将Makefile中的变量进行替换，如果Makefile中包含其他文件，则加载他</li>
<li>解释规则，对其中的执行规则进行解析，推导隐藏规则，为目标建立关系链</li>
<li>分析变更，根据依赖关系和时间戳，判断有木有变化。</li>
<li>执行。</li>
</ol>
<h2 id="u7F16_u8BD1_u7684_u57FA_u672C_u6D41_u7A0B"><a href="#u7F16_u8BD1_u7684_u57FA_u672C_u6D41_u7A0B" class="headerlink" title="编译的基本流程"></a>编译的基本流程</h2><p>基本过程是以下四步：</p>
<p>1.<code>c(.c)</code>和<code>c++(.cc, .cpp, .cxx)</code>的源文件</p>
<pre><code>gcc -E a.c -o a.i
// 如果不加-o参数，gcc会把处理过的源文件放到标准输出中
</code></pre><p>2.预处理后的源文件。c源文件预处理后后缀为<code>.i</code>, c++为<code>.ii</code> 。</p>
<pre><code>gcc -S a.i
//会在当前文件夹下生成a.s
</code></pre><p>3.编译后生成的汇编源代码。后缀为<code>.s</code>,<code>.S</code>。</p>
<pre><code>gcc -c a.s
//只进行汇编生成目标文件,.o结尾的目标文件可以用
//(ar crv libabc.a a.o b.o c.o )打包成形如lib×××.a的静态库
</code></pre><p>4.目标文件与库文件进行链接，生成可执行文件。</p>
<pre><code>gcc a.o //在当前文件夹下生成a.out
</code></pre><p>其中任何一种状态，用 gcc 如果不加 <code>-c</code>，<code>-E</code>，<code>-S</code> 选项都会直接生成可执行文件，如果加上了选项，可以由之前任一状态生成所需要的文件（如<code>gcc -S a.c</code>可以直接生成<code>a.s，gcc -c a.i</code>可以直接生成<code>a.o</code> ）。如果是c++直接换用g++命令就行。</p>
<p>另外<code>gcc -v</code>可以输出编译过程的配置和版本信息。</p>
<h2 id="gcc__u8B66_u544A_u63D0_u793A"><a href="#gcc__u8B66_u544A_u63D0_u793A" class="headerlink" title="gcc 警告提示"></a>gcc 警告提示</h2><pre><code>-fsyntax-only   检查程序中的语法错误，不产生输出信息
-w 禁止所有警告信息
-Wunused 声明了木有用
-Wmain main函数定义不常规
-Wall 提供所有警告
-pedantic-errors 允许ansi c标准列出的全部信息
</code></pre><p>实际用的话，所有错误用一个“墙”就可以了</p>
<h2 id="u5176_u4ED6_u5E38_u7528_u9009_u9879"><a href="#u5176_u4ED6_u5E38_u7528_u9009_u9879" class="headerlink" title="其他常用选项"></a>其他常用选项</h2><ul>
<li>-g 加入调试信息，gdb调试的时候要用。</li>
<li>-On 优化选项。这里的n可以用0-3来替代。数字越大优化效果越好，-O0表示不进行优化。优化可能针对硬件进行优化，也可能针对代码优化（删除公共表达式，循环优化，删除无用信息）。优化可能大大增加编译时间和内存，他通常会将循环或函数展开，使他们以内联的方式进行，不是通过函数调用，这样可以显著提高性能，不过调试最好不要用优化选项。</li>
<li>-l 指定要用到的库，注意这里之后要加的是库的名字，如果是多线程，可能要用到pthread库，那么此时就要加上 -lpthread ，这样gcc就会到库目录中找名为libpthread.so（lib×××.so）的文件，如果是静态库的话是libpthread.a( lib×××.a)（貌似gcc先找动态库，再找静态库？）。</li>
<li>-L 指定所需要的库所在的文件夹。系统先寻找标准位置，再寻找指定位置（标准库一般在/lib或/usr/lib）。</li>
<li>-I 指定头文件的寻找路径。先找标准的，后找指定的（标准的一般在/usr/include）。</li>
<li>-static 只用静态库,再拿上面那个例子，如果加上-static，系统就会只寻找libpthread.a文件。</li>
<li>-shared 生成动态库（共享库）文件，形如 libxxx.so （gcc -shared dang.o -o libdang.so）</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Make 可以简化编译过程，如果有一个近百个源文件的项目，如果有个文件更改后工程需要重新编译，那么一直用gcc -c a.c这些个命令敲来敲去会屎人的。运行make时候，他会寻找指定目录下（默认是 .）的 Makefile 文件并且分析依赖关系进行必要的编译。</p>]]>
    
    </summary>
    
      <category term="Gcc" scheme="http://wdxtub.com/tags/Gcc/"/>
    
      <category term="Make" scheme="http://wdxtub.com/tags/Make/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ubuntu 工作环境搭建]]></title>
    <link href="http://wdxtub.com/2016/03/20/ubuntu-work-env/"/>
    <id>http://wdxtub.com/2016/03/20/ubuntu-work-env/</id>
    <published>2016-03-20T13:31:58.000Z</published>
    <updated>2016-03-20T13:33:12.000Z</updated>
    <content type="html"><![CDATA[<p>考虑到 mac 升级之后各种坑，latex 什么鬼都用不了，所以痛定思痛决定在 Ubuntu 上搞一个工作环境。基本就是云同步+markdown+pandoc+sublime 高亮编辑器。环境 Ubuntu 14.04 64-bit</p>
<a id="more"></a>
<hr>
<h2 id="u4E2D_u6587_u8F93_u5165_u6CD5"><a href="#u4E2D_u6587_u8F93_u5165_u6CD5" class="headerlink" title="中文输入法"></a>中文输入法</h2><p>首先当然是要安装输入法，现在搜狗已经在 linux 上出了输入法，直接用即可。<a href="http://pinyin.sogou.com/linux/help.php" target="_blank" rel="external">安装指南</a></p>
<p>下载 deb 包直接安装即可</p>
<p>安装完之后需要重启，在 language support 中把默认引擎改成 fcitx，然后选择搜狗拼音即可</p>
<h2 id="Dropbox"><a href="#Dropbox" class="headerlink" title="Dropbox"></a>Dropbox</h2><p>从<a href="https://www.dropbox.com/install?os=lnx" target="_blank" rel="external">这里</a>下载对应版本，然后登录设置正常使用即可</p>
<h2 id="Pandoc"><a href="#Pandoc" class="headerlink" title="Pandoc"></a>Pandoc</h2><p>从<a href="http://pandoc.org/installing.html" target="_blank" rel="external">这里</a> 下载 deb 包安装即可。</p>
<p>具体转换过程</p>
<pre><code>pandoc -s source.md -o target.pdf
</code></pre><p>注意目前纯英文才可以，图片需要是 PNG 格式</p>
<h2 id="Latex__u53CA_u4E2D_u6587_u652F_u6301"><a href="#Latex__u53CA_u4E2D_u6587_u652F_u6301" class="headerlink" title="Latex 及中文支持"></a>Latex 及中文支持</h2><p>各位阅读前，先说明以下总体上我们要做的几件事。</p>
<ol>
<li>安装TexLive。我们知道Latex只是一套排版的宏定义，为实现Latex，需要在各种操作系统上提供软件支持。TexLive就是实现此目的一个跨平台软件包。</li>
<li>Latex支持的字体非常多，自然包括中文。不过，为了更好地支持中日韩（因为这些是方块型的字符集，与字母类型的文字不同），需要安装CJK扩展包。</li>
<li>为了使用额外的中文字体，需要配置Latex以便使用它们。</li>
<li>使用测试文档，确认安装的字体不是已经生效了。</li>
</ol>
<p>打开终端，安装以下TexLive和常用的一些Latex宏包（可以根据自己的需要增改）：</p>
<pre><code>sudo apt-get install texlive texlive-math-extra texlive-latex-base texlive-latex-extra texlive-latex-recommended texlive-pictures texlive-science latex-beamer texlive-base texlive-bibtex-extra texlive-xetex texlive-latex-extra
</code></pre><p>如果硬盘充裕的话，直接完整安装也可以：</p>
<pre><code>sudo apt-get install texlive-full latex-beamer
</code></pre><p>安装完后，就可以安装CJK的相关软件包了，如果只需要获得中文支持，那么执行：</p>
<pre><code>sudo apt-get install latex-cjk-chinese ttf-arphic-* hbf-*
</code></pre><p>否则，建议安装 latex-cjk-all 以获取完整支持。</p>
<pre><code>sudo apt-get install latex-cjk-all
</code></pre><p>Linux下的中文字体，对于Ubuntu来说有现成的。因此，只要第一步正常安装完毕，就可以用下面的测试文件进行测试。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage&#123;CJKutf8&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gkai&#125;</span><br><span class="line">这是一个楷体中文测试，处理简体字。</span><br><span class="line">\<span class="keyword">end</span>&#123;CJK&#125;</span><br><span class="line">\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gbsn&#125;</span><br><span class="line">这是一个宋体中文测试，处理简体字。</span><br><span class="line">\<span class="keyword">end</span>&#123;CJK&#125;</span><br><span class="line">\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;bkai&#125;</span><br><span class="line">這是一個big5編碼的楷體中文測試，處理繁體文字。</span><br><span class="line">\<span class="keyword">end</span>&#123;CJK&#125;</span><br><span class="line">\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;bsmi&#125;</span><br><span class="line">這是一個个big5編碼的明體中文測試，處理繁體文字。</span><br><span class="line">\<span class="keyword">end</span>&#123;CJK&#125;</span><br><span class="line">\<span class="keyword">end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>将这部分代码粘贴到文本文件中，然后保存将其保存为test.tex。然后使用下面的命令生成PDF文档。</p>
<pre><code>pdflatex test.tex
evince test.pdf
</code></pre><h2 id="u5728_u5F53_u524D_u76EE_u5F55_u4E0B_u6253_u5F00_u7EC8_u7AEF"><a href="#u5728_u5F53_u524D_u76EE_u5F55_u4E0B_u6253_u5F00_u7EC8_u7AEF" class="headerlink" title="在当前目录下打开终端"></a>在当前目录下打开终端</h2><p>直接安装一个软件包nautilus-open-terminal</p>
<p>终端输入：<code>sudo apt-get install nautilus-open-terminal</code></p>
<p>重启系统！</p>
<h2 id="u5B89_u88C5_sublime_3"><a href="#u5B89_u88C5_sublime_3" class="headerlink" title="安装 sublime 3"></a>安装 sublime 3</h2><p>简单粗暴</p>
<pre><code>sudo add-apt-repository ppa:webupd8team/sublime-text-3
sudo apt-get update
sudo apt-get install sublime-text-installer
</code></pre><p>然后需要配置一下环境</p>
<p>先安装 package control，<a href="https://packagecontrol.io/installation" target="_blank" rel="external">教程</a></p>
<h3 id="u63D2_u4EF6_u7CBE_u9009"><a href="#u63D2_u4EF6_u7CBE_u9009" class="headerlink" title="插件精选"></a>插件精选</h3><ul>
<li>Theme: Gravity</li>
<li>Color Theme: Monokai Extended</li>
<li>MarkdownTOC</li>
<li><a href="https://github.com/titoBouzout/SideBarEnhancements" target="_blank" rel="external">SideBarEnhancements</a>: 侧边栏增强</li>
<li><a href="https://github.com/wbond/sublime_alignment" target="_blank" rel="external">Alignment</a>: 等号对齐</li>
<li><a href="https://github.com/BoundInCode/AutoFileName" target="_blank" rel="external">AutoFileName</a>: 文件路径自动提示</li>
</ul>
<h3 id="u5E38_u7528_u6280_u80FD"><a href="#u5E38_u7528_u6280_u80FD" class="headerlink" title="常用技能"></a>常用技能</h3><ol>
<li>按住 <code>ctrl</code> 键，鼠标单击就是多重选择。</li>
<li><a href="http://baelabs.duapp.com/Sublime/multiple_selection_with_the_keyboard.html" target="_blank" rel="external">键盘多重选择</a></li>
<li>根据选择文本自动添加 ‘, “”,(),[] 匹配。</li>
<li>搜索按钮的功能说明 (<a href="http://hi.baidu.com/chaoxinggsc/item/904a471aa937bc35f6625c42" target="_blank" rel="external">冷风贡献</a>)</li>
</ol>
<h3 id="u5E38_u7528_u5FEB_u6377_u952E"><a href="#u5E38_u7528_u5FEB_u6377_u952E" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><ol>
<li>Ctrl+L             选择整行（按住-继续选择下行）</li>
<li>Ctrl+Shift+K(shhift+del)     删除整行，  ctrl + KK 从光标处删之行尾，Ctrl+K Backspace 从光标处删除至行首</li>
<li>Ctrl+Shift+D       复制光标所在整行，插入在该行之前</li>
<li>Ctrl+D             选词 （按住-继续选择下个相同的字符串，再按，可跳到相应的方法定义处</li>
<li>Ctrl+Shift+M       选择括号内的内容（按住-继续选择父括号）</li>
<li>Ctrl+/             注释整行（如已选择内容，同“Ctrl+Shift+/”效果）</li>
<li>Ctrl + alt + /     取消注释</li>
<li>Ctrl+Shift+UP      与上行互换  ctrl + shift + up: 列模式编辑</li>
<li>Ctrl + R           跳转当前页的目标方法</li>
<li>Ctrl+K + U        大写</li>
<li>Ctrl+K + L        小写</li>
<li>鼠标中间           列模式编辑</li>
<li>Ctrl+Shift+[]     代码折叠</li>
<li>ctrl+k ctrl+1:    折叠所有代码</li>
<li>Ctrl + K,B        打开侧边栏</li>
<li>ctrl + 回车：　　   光标后插入行，　Ctrl+Shift+Enter 光标前插入行</li>
<li>ctrl + m:         匹配括号</li>
<li>vim mode下        查找上一个下一个的快捷键是 是* #</li>
<li>ctrl +z, y:       撤销，恢复撤销</li>
<li>alt + .:          闭合当前标签</li>
<li>Ctrl+F2:          设置书签</li>
<li>F2:               下一个书签</li>
<li>Shift+F2:         上一个书签</li>
<li>ctrl + p:         即时的文件切换</li>
<li>ctrl + shift + a: 选择标签内的内容</li>
<li>ctrl + 单击：      多行随意位置添加光标</li>
<li>alt + F3( mac: ctrl + command + g): 选择页面中所有相同的词</li>
<li>ctrl + F3:        跳转到下一个选中的词</li>
<li>Ctrl+Shift+P Set Syntax:html : 设置文件类型</li>
<li>Shift + 右键:     连续多行光标选中 (by Gary Gauh)</li>
</ol>
<h3 id="u914D_u7F6E_u66F4_u6539"><a href="#u914D_u7F6E_u66F4_u6539" class="headerlink" title="配置更改"></a>配置更改</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">caret_style</span>": <span class="value"><span class="string">"phase"</span></span>,</span><br><span class="line">    "<span class="attribute">color_scheme</span>": <span class="value"><span class="string">"Packages/Monokai Extended/Monokai Extended.tmTheme"</span></span>,</span><br><span class="line">    "<span class="attribute">draw_white_space</span>": <span class="value"><span class="string">"all"</span></span>,</span><br><span class="line">    "<span class="attribute">ensure_newline_at_eof_on_save</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">    "<span class="attribute">fade_fold_buttons</span>": <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">    "<span class="attribute">file_exclude_patterns</span>":</span><br><span class="line">    <span class="value">[</span><br><span class="line">        <span class="string">"*.Ulysses-Group.plist"</span>,</span><br><span class="line">        <span class="string">"*.pyc"</span>,</span><br><span class="line">        <span class="string">"*.pyo"</span>,</span><br><span class="line">        <span class="string">"*.exe"</span>,</span><br><span class="line">        <span class="string">"*.dll"</span>,</span><br><span class="line">        <span class="string">"*.obj"</span>,</span><br><span class="line">        <span class="string">"*.o"</span>,</span><br><span class="line">        <span class="string">"*.a"</span>,</span><br><span class="line">        <span class="string">"*.lib"</span>,</span><br><span class="line">        <span class="string">"*.so"</span>,</span><br><span class="line">        <span class="string">"*.dylib"</span>,</span><br><span class="line">        <span class="string">"*.ncb"</span>,</span><br><span class="line">        <span class="string">"*.sdf"</span>,</span><br><span class="line">        <span class="string">"*.suo"</span>,</span><br><span class="line">        <span class="string">"*.pdb"</span>,</span><br><span class="line">        <span class="string">"*.idb"</span>,</span><br><span class="line">        <span class="string">".DS_Store"</span>,</span><br><span class="line">        <span class="string">"*.class"</span>,</span><br><span class="line">        <span class="string">"*.psd"</span>,</span><br><span class="line">        <span class="string">"*.db"</span>,</span><br><span class="line">        <span class="string">"*.sublime-workspace"</span></span><br><span class="line">    ]</span>,</span><br><span class="line">    "<span class="attribute">folder_exclude_patterns</span>":</span><br><span class="line">    <span class="value">[</span><br><span class="line">        <span class="string">".svn"</span>,</span><br><span class="line">        <span class="string">".git"</span>,</span><br><span class="line">        <span class="string">".hg"</span>,</span><br><span class="line">        <span class="string">"CVS"</span></span><br><span class="line">    ]</span>,</span><br><span class="line">    "<span class="attribute">font_size</span>": <span class="value"><span class="number">19</span></span>,</span><br><span class="line">    "<span class="attribute">highlight_color_blue</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">    "<span class="attribute">highlight_line</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">    "<span class="attribute">highlight_modified_tabs</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">    "<span class="attribute">ignored_packages</span>":</span><br><span class="line">    <span class="value">[</span><br><span class="line">        <span class="string">"ActionScript"</span>,</span><br><span class="line">        <span class="string">"AppleScript"</span>,</span><br><span class="line">        <span class="string">"ASP"</span>,</span><br><span class="line">        <span class="string">"Clojure"</span>,</span><br><span class="line">        <span class="string">"D"</span>,</span><br><span class="line">        <span class="string">"Erlang"</span>,</span><br><span class="line">        <span class="string">"Go"</span>,</span><br><span class="line">        <span class="string">"Graphviz"</span>,</span><br><span class="line">        <span class="string">"Groovy"</span>,</span><br><span class="line">        <span class="string">"OCaml"</span>,</span><br><span class="line">        <span class="string">"OmniMarkupPreviewer"</span>,</span><br><span class="line">        <span class="string">"Pascal"</span>,</span><br><span class="line">        <span class="string">"R"</span>,</span><br><span class="line">        <span class="string">"Rails"</span>,</span><br><span class="line">        <span class="string">"Tag"</span>,</span><br><span class="line">        <span class="string">"TCL"</span>,</span><br><span class="line">        <span class="string">"Vintage"</span></span><br><span class="line">    ]</span>,</span><br><span class="line">    "<span class="attribute">rulers</span>":</span><br><span class="line">    <span class="value">[</span><br><span class="line">        <span class="number">80</span>,</span><br><span class="line">        <span class="number">100</span></span><br><span class="line">    ]</span>,</span><br><span class="line">    "<span class="attribute">soda_folder_icons</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">    "<span class="attribute">spell_check</span>": <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">    "<span class="attribute">theme</span>": <span class="value"><span class="string">"Gravity.sublime-theme"</span></span>,</span><br><span class="line">    "<span class="attribute">translate_tabs_to_spaces</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">    "<span class="attribute">trim_trailing_white_space_on_save</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">    "<span class="attribute">word_wrap</span>": <span class="value"><span class="literal">true</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>最后是屌丝license, Build 3083</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">—– BEGIN LICENSE —–</span><br><span class="line">Andrew Weber</span><br><span class="line">Single User License</span><br><span class="line">EA7E-<span class="number">855605</span></span><br><span class="line"><span class="number">813</span>A03DD <span class="number">5E4</span>AD9E6 <span class="number">6</span>C0EEB94 BC99798F</span><br><span class="line"><span class="number">942194</span>A6 <span class="number">02396E98</span> E62C9979 <span class="number">4</span>BB979FE</span><br><span class="line"><span class="number">91424</span>C9D A45400BF F6747D88 <span class="number">2F</span>B88078</span><br><span class="line"><span class="number">90F</span>5CC94 <span class="number">1</span>CDC92DC <span class="number">8457107</span>A F151657B</span><br><span class="line"><span class="number">1</span>D22E383 A997F016 <span class="number">42397640</span> <span class="number">33F</span>41CFC</span><br><span class="line">E1D0AE85 A0BBD039 <span class="number">0E9</span>C8D55 E1B89D5D</span><br><span class="line"><span class="number">5</span>CDB7036 E56DE1C0 EFCC0840 <span class="number">650</span>CD3A6</span><br><span class="line">B98FC99C <span class="number">8F</span>AC73EE D2B95564 DF450523</span><br><span class="line">—— END LICENSE ——</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>考虑到 mac 升级之后各种坑，latex 什么鬼都用不了，所以痛定思痛决定在 Ubuntu 上搞一个工作环境。基本就是云同步+markdown+pandoc+sublime 高亮编辑器。环境 Ubuntu 14.04 64-bit</p>]]>
    
    </summary>
    
      <category term="Ubuntu" scheme="http://wdxtub.com/tags/Ubuntu/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop 指南]]></title>
    <link href="http://wdxtub.com/2016/03/20/hadoop-guide/"/>
    <id>http://wdxtub.com/2016/03/20/hadoop-guide/</id>
    <published>2016-03-20T13:16:50.000Z</published>
    <updated>2016-03-20T13:31:06.000Z</updated>
    <content type="html"><![CDATA[<p>这里简要介绍一下 Hadoop 的基本原理及用法。</p>
<a id="more"></a>
<hr>
<h2 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h2><p>Hadoop Map/Reduce 是一个使用简易的软件框架，基于它写出来的应用程序能够运行在由上千个商用机器组成的大型集群上，并以一种可靠容错的方式并行处理上T级别的数据集。</p>
<p>一个 Map/Reduce 作业（job） 通常会把输入的数据集切分为若干独立的数据块，由  map 任务（task）以完全并行的方式处理它们。框架会对 map 的输出先进行排序， 然后把结果输入给 reduce 任务。通常作业的输入和输出都会被存储在文件系统中。 整个框架负责任务的调度和监控，以及重新执行已经失败的任务。</p>
<p>通常，Map/Reduce 框架和分布式文件系统是运行在一组相同的节点上的，也就是说，计算节点和存储节点通常在一起。这种配置允许框架在那些已经存好数据的节点上高效地调度任务，这可以使整个集群的网络带宽被非常高效地利用。</p>
<p>Map/Reduce 框架由一个单独的 master JobTracker 和每个集群节点一个 slave TaskTracker共同组成。master 负责调度构成一个作业的所有任务，这些任务分布在不同的 slave 上，master 监控它们的执行，重新执行已经失败的任务。而 slave 仅负责执行由 master 指派的任务。</p>
<p>应用程序至少应该指明输入/输出的位置（路径），并通过实现合适的接口或抽象类提供 map 和 reduce 函数。再加上其他作业的参数，就构成了作业配置（job configuration）。然后，Hadoop 的 job client 提交作业（jar包/可执行程序等）和配置信息给 JobTracker，后者负责分发这些软件和配置信息给 slave、调度任务并监控它们的执行，同时提供状态和诊断信息给 job-client。</p>
<p>虽然 Hadoop 框架是用 JavaTM 实现的，但 Map/Reduce 应用程序则不一定要用 Java 来写 。</p>
<h2 id="u8F93_u5165_u4E0E_u8F93_u51FA"><a href="#u8F93_u5165_u4E0E_u8F93_u51FA" class="headerlink" title="输入与输出"></a>输入与输出</h2><p>Map/Reduce框架运转在<code>&lt;key, value&gt;</code> 键值对上，也就是说， 框架把作业的输入看为是一组<code>&lt;key, value&gt;</code> 键值对，同样也产出一组 <code>&lt;key, value&gt;</code> 键值对做为作业的输出，这两组键值对的类型可能不同。</p>
<p>框架需要对 key 和 value 的类(classes)进行序列化操作， 因此，这些类需要实现 Writable接口。另外，为了方便框架执行排序操作，key 类必须实现 WritableComparable接口。</p>
<p>一个Map/Reduce 作业的输入和输出类型如下所示：</p>
<pre><code>(input) &lt;k1, v1&gt; -&gt; map -&gt; &lt;k2, v2&gt; -&gt; combine -&gt; &lt;k2, v2&gt; -&gt; reduce -&gt; &lt;k3, v3&gt; (output)
</code></pre><h2 id="u6838_u5FC3_u529F_u80FD_u63CF_u8FF0"><a href="#u6838_u5FC3_u529F_u80FD_u63CF_u8FF0" class="headerlink" title="核心功能描述"></a>核心功能描述</h2><p>应用程序通常会通过提供map和reduce来实现 Mapper 和 Reducer 接口，它们组成作业的核心。</p>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><p>Mapper 将输入键值对(key/value pair)映射到一组中间格式的键值对集合。</p>
<p>Map 是一类将输入记录集转换为中间格式记录集的独立任务。 这种转换的中间格式记录集不需要与输入记录集的类型一致。一个给定的输入键值对可以映射成0个或多个输出键值对。</p>
<p>Hadoop Map/Reduce 框架为每一个 InputSplit 产生一个map任务，而每个InputSplit是由该作业的InputFormat产生的。</p>
<p>概括地说，对 Mapper 的实现者需要重写 JobConfigurable.configure(JobConf) 方法，这个方法需要传递一个 JobConf 参数，目的是完成 Mapper 的初始化工作。然后，框架为这个任务的 InputSplit 中每个键值对调用一次 map(WritableComparable, Writable, OutputCollector, Reporter)操作。应用程序可以通过重写 Closeable.close() 方法来执行相应的清理工作。</p>
<p>输出键值对不需要与输入键值对的类型一致。一个给定的输入键值对可以映射成0个或多个输出键值对。通过调用 OutputCollector.collect(WritableComparable,Writable)可以收集输出的键值对。</p>
<p>应用程序可以使用Reporter报告进度，设定应用级别的状态消息，更新Counters（计数器），或者仅是表明自己运行正常。</p>
<p>框架随后会把与一个特定 key 关联的所有中间过程的值（value）分成组，然后把它们传给 Reducer 以产出最终的结果。用户可以通过 JobConf.setOutputKeyComparatorClass(Class) 来指定具体负责分组的 Comparator。</p>
<p>Mapper 的输出被排序后，就被划分给每个 Reducer。分块的总数目和一个作业的 reduce 任务的数目是一样的。用户可以通过实现自定义的 Partitioner 来控制哪个key被分配给哪个 Reducer。</p>
<p>用户可选择通过 JobConf.setCombinerClass(Class)指定一个 combiner，它负责对中间过程的输出进行本地的聚集，这会有助于降低从 Mapper 到 Reducer 数据传输量。</p>
<p>这些被排好序的中间过程的输出结果保存的格式是(key-len, key, value-len, value)，应用程序可以通过JobConf控制对这些中间结果是否进行压缩以及怎么压缩，使用哪种 CompressionCodec。</p>
<h3 id="u9700_u8981_u591A_u5C11_u4E2AMap_uFF1F"><a href="#u9700_u8981_u591A_u5C11_u4E2AMap_uFF1F" class="headerlink" title="需要多少个Map？"></a>需要多少个Map？</h3><p>Map的数目通常是由输入数据的大小决定的，一般就是所有输入文件的总块（block）数。</p>
<p>Map 正常的并行规模大致是每个节点（node）大约 10 到 100 个 map，对于 CPU 消耗较小的map 任务可以设到300个左右。由于每个任务初始化需要一定的时间，因此，比较合理的情况是 map 执行的时间至少超过1分钟。</p>
<p>这样，如果你输入 10TB 的数据，每个块（block）的大小是128MB，你将需要大约82,000个map来完成任务，除非使用 setNumMapTasks(int)（注意：这里仅仅是对框架进行了一个提示(hint)，实际决定因素见这里）将这个数值设置得更高。</p>
<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>Reducer 将与一个 key 关联的一组中间数值集归约（reduce）为一个更小的数值集。</p>
<p>用户可以通过 JobConf.setNumReduceTasks(int) 设定一个作业中 reduce 任务的数目。</p>
<p>概括地说，对 Reducer 的实现者需要重写 JobConfigurable.configure(JobConf) 方法，这个方法需要传递一个 JobConf 参数，目的是完成 Reducer 的初始化工作。然后，框架为成组的输入数据中的每个<code>&lt;key, (list of values)&gt;</code>对调用一次 reduce(WritableComparable, Iterator, OutputCollector, Reporter)方法。之后，应用程序可以通过重写 Closeable.close() 来执行相应的清理工作。</p>
<p>Reducer 有3个主要阶段：shuffle、sort 和 reduce。</p>
<h3 id="Shuffle"><a href="#Shuffle" class="headerlink" title="Shuffle"></a>Shuffle</h3><p>Reducer 的输入就是 Mapper 已经排好序的输出。在这个阶段，框架通过 HTTP 为每个 Reducer 获得所有 Mapper 输出中与之相关的分块。</p>
<h3 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h3><p>这个阶段，框架将按照 key 的值对 Reducer 的输入进行分组 （因为不同 mapper 的输出中可能会有相同的 key）。</p>
<p>Shuffle 和 Sort 两个阶段是同时进行的；map 的输出也是一边被取回一边被合并的。</p>
<h3 id="Secondary_Sort"><a href="#Secondary_Sort" class="headerlink" title="Secondary Sort"></a>Secondary Sort</h3><p>如果需要中间过程对 key 的分组规则和 reduce 前对 key 的分组规则不同，那么可以通过 JobConf.setOutputValueGroupingComparator(Class) 来指定一个 Comparator。再加上 JobConf.setOutputKeyComparatorClass(Class)可用于控制中间过程的 key 如何被分组，所以结合两者可以实现按值的二次排序。</p>
<h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><p>在这个阶段，框架为已分组的输入数据中的每个 <code>&lt;key, (list of values)&gt;</code>对调用一次 reduce(WritableComparable, Iterator, OutputCollector, Reporter)方法。</p>
<p>Reduce任务的输出通常是通过调用 OutputCollector.collect(WritableComparable, Writable)写入 文件系统的。</p>
<p>应用程序可以使用 Reporter 报告进度，设定应用程序级别的状态消息，更新 Counters（计数器），或者仅是表明自己运行正常。</p>
<p>Reducer 的输出是没有排序的。</p>
<h3 id="u9700_u8981_u591A_u5C11_u4E2AReduce_uFF1F"><a href="#u9700_u8981_u591A_u5C11_u4E2AReduce_uFF1F" class="headerlink" title="需要多少个Reduce？"></a>需要多少个Reduce？</h3><p>Reduce的数目建议是0.95或1.75乘以 <code>&lt;no. of nodes&gt; * mapred.tasktracker.reduce.tasks.maximum</code>。</p>
<p>用 0.95，所有 reduce 可以在 maps 一完成时就立刻启动，开始传输 map 的输出结果。用1.75，速度快的节点可以在完成第一轮 reduce 任务后，可以开始第二轮，这样可以得到比较好的负载均衡的效果。</p>
<p>增加 reduce 的数目会增加整个框架的开销，但可以改善负载均衡，降低由于执行失败带来的负面影响。</p>
<p>上述比例因子比整体数目稍小一些是为了给框架中的推测性任务（speculative-tasks） 或失败的任务预留一些 reduce 的资源。</p>
<h3 id="u65E0_Reducer"><a href="#u65E0_Reducer" class="headerlink" title="无 Reducer"></a>无 Reducer</h3><p>如果没有归约要进行，那么设置 reduce 任务的数目为零是合法的。</p>
<p>这种情况下，map任务的输出会直接被写入由 setOutputPath(Path)指定的输出路径。框架在把它们写入 FileSystem 之前没有对它们进行排序。</p>
<h3 id="Partitioner"><a href="#Partitioner" class="headerlink" title="Partitioner"></a>Partitioner</h3><p>Partitioner 用于划分键值空间（key space）。</p>
<p>Partitioner 负责控制 map 输出结果 key 的分割。Key（或者一个key子集）被用于产生分区，通常使用的是 Hash 函数。分区的数目与一个作业的 reduce 任务的数目是一样的。因此，它控制将中间过程的key（也就是这条记录）应该发送给 m 个 reduce 任务中的哪一个来进行 reduce操作。</p>
<p>HashPartitioner 是默认的 Partitioner。</p>
<h3 id="Reporter"><a href="#Reporter" class="headerlink" title="Reporter"></a>Reporter</h3><p>Reporter 是用于 Map/Reduce 应用程序报告进度，设定应用级别的状态消息， 更新 Counters（计数器）的机制。</p>
<p>Mapper 和 Reducer 的实现可以利用Reporter 来报告进度，或者仅是表明自己运行正常。在那种应用程序需要花很长时间处理个别键值对的场景中，这种机制是很关键的，因为框架可能会以为这个任务超时了，从而将它强行杀死。另一个避免这种情况发生的方式是，将配置参数 <code>mapred.task.timeout</code> 设置为一个足够高的值（或者干脆设置为零，则没有超时限制了）。</p>
<p>应用程序可以用 Reporter 来更新 Counter（计数器）。</p>
<h3 id="OutputCollector"><a href="#OutputCollector" class="headerlink" title="OutputCollector"></a>OutputCollector</h3><p>OutputCollector 是一个 Map/Reduce 框架提供的用于收集 Mapper 或 Reducer输出数据的通用机制（包括中间输出结果和作业的输出结果）。</p>
<p>Hadoop Map/Reduce 框架附带了一个包含许多实用型的 mapper、reducer 和 partitioner 的类库。</p>
<h2 id="u4F5C_u4E1A_u914D_u7F6E"><a href="#u4F5C_u4E1A_u914D_u7F6E" class="headerlink" title="作业配置"></a>作业配置</h2><p>JobConf 代表一个 Map/Reduce 作业的配置。</p>
<p>JobConf 是用户向 Hadoop 框架描述一个 Map/Reduce 作业如何执行的主要接口。框架会按照 JobConf 描述的信息忠实地去尝试完成这个作业，然而：</p>
<ul>
<li>一些参数可能会被管理者标记为 final，这意味它们不能被更改。</li>
<li>一些作业的参数可以被直截了当地进行设置（例如： setNumReduceTasks(int)），而另一些参数则与框架或者作业的其他参数之间微妙地相互影响，并且设置起来比较复杂（例如： setNumMapTasks(int)）。</li>
</ul>
<p>通常，JobConf会指明Mapper、Combiner(如果有的话)、 Partitioner、Reducer、InputFormat和 OutputFormat的具体实现。JobConf还能指定一组输入文件 (setInputPaths(JobConf, Path…) /addInputPath(JobConf, Path)) 和(setInputPaths(JobConf, String) /addInputPaths(JobConf, String)) 以及输出文件应该写在哪儿 (setOutputPath(Path))。</p>
<p>JobConf可选择地对作业设置一些高级选项，例如：设置Comparator； 放到DistributedCache上的文件；中间结果或者作业输出结果是否需要压缩以及怎么压缩； 利用用户提供的脚本(setMapDebugScript(String)/setReduceDebugScript(String)) 进行调试；作业是否允许预防性（speculative）任务的执行 (setMapSpeculativeExecution(boolean))/(setReduceSpeculativeExecution(boolean)) ；每个任务最大的尝试次数 (setMaxMapAttempts(int)/setMaxReduceAttempts(int)) ；一个作业能容忍的任务失败的百分比 (setMaxMapTaskFailuresPercent(int)/setMaxReduceTaskFailuresPercent(int)) ；等等。</p>
<p>当然，用户能使用 set(String, String)/get(String, String) 来设置或者取得应用程序需要的任意参数。然而，DistributedCache的使用是面向大规模只读数据的。</p>
<h2 id="u4EFB_u52A1_u7684_u6267_u884C_u548C_u73AF_u5883"><a href="#u4EFB_u52A1_u7684_u6267_u884C_u548C_u73AF_u5883" class="headerlink" title="任务的执行和环境"></a>任务的执行和环境</h2><p>TaskTracker是在一个单独的jvm上以子进程的形式执行 Mapper/Reducer任务（Task）的。</p>
<p>子任务会继承父TaskTracker的环境。用户可以通过JobConf中的 mapred.child.java.opts配置参数来设定子jvm上的附加选项，例如： 通过-Djava.library.path=&lt;&gt; 将一个非标准路径设为运行时的链接用以搜索共享库，等等。如果mapred.child.java.opts包含一个符号@taskid@， 它会被替换成map/reduce的taskid的值。</p>
<p>下面是一个包含多个参数和替换的例子，其中包括：记录jvm GC日志； JVM JMX代理程序以无密码的方式启动，这样它就能连接到jconsole上，从而可以查看子进程的内存和线程，得到线程的dump；还把子jvm的最大堆尺寸设置为512MB， 并为子jvm的java.library.path添加了一个附加路径。</p>
<pre><code>&lt;property&gt;
  &lt;name&gt;mapred.child.java.opts&lt;/name&gt;
  &lt;value&gt;
     -Xmx512M -Djava.library.path=/home/mycompany/lib -verbose:gc -Xloggc:/tmp/@taskid@.gc
     -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false
  &lt;/value&gt;
&lt;/property&gt;
</code></pre><p>用户或管理员也可以使用mapred.child.ulimit设定运行的子任务的最大虚拟内存。mapred.child.ulimit的值以（KB)为单位，并且必须大于或等于-Xmx参数传给JavaVM的值，否则VM会无法启动。</p>
<p>注意：mapred.child.java.opts只用于设置task tracker启动的子任务。为守护进程设置内存选项请查看 cluster_setup.html</p>
<h1 id="Hadoop__u539F_u7406_u5B66_u4E60"><a href="#Hadoop__u539F_u7406_u5B66_u4E60" class="headerlink" title="Hadoop 原理学习"></a>Hadoop 原理学习</h1><p>Hadoop 是 Apache 下的一个项目，由 HDFS、MapReduce、HBase、Hive 和 ZooKeeper 等成员组成。其中，HDFS 和 MapReduce 是两个最基础最重要的成员。</p>
<p>HDFS 是 Google GFS 的开源版本，一个高度容错的分布式文件系统，它能够提供高吞吐量的数据访问，适合存储海量(PB 级)的大文件(通常超过64M)，其原理如下图所示：</p>
<p><img src="/media/14521186972719/hadoop1.jpg" alt="hadoop1"></p>
<p>采用 Master/Slave 结构。NameNode 维护集群内的元数据，对外提供创建、打开、删除和重命名文件或目录的功能。DataNode 存储数据，并提负责处理数据的读写请求。DataNode 定期向 NameNode 上报心跳，NameNode 通过响应心跳来控制 DataNode。</p>
<p>Hadoop MapReduce的实现也采用了Master/Slave 结构。Master 叫做 JobTracker，而 Slave 叫做TaskTracker。用户提交的计算叫做 Job，每一个 Job 会被划分成若干个 Tasks。JobTracker 负责 Job 和 Tasks 的调度，而 TaskTracker 负责执行 Tasks。</p>
<h2 id="Shuffle__u548C_Sort__u5206_u6790"><a href="#Shuffle__u548C_Sort__u5206_u6790" class="headerlink" title="Shuffle 和 Sort 分析"></a>Shuffle 和 Sort 分析</h2><p>MapReduce 框架的核心步骤主要分两部分：Map 和 Reduce。当你向 MapReduce 框架提交一个计算作业时，它会首先把计算作业拆分成若干个 Map 任务，然后分配到不同的节点上去执行，每一个 Map 任务处理输入数据中的一部分，当 Map 任务完成后，它会生成一些中间文件，这些中间文件将会作为 Reduce 任务的输入数据。Reduce 任务的主要目标就是把前面若干个 Map 的输出汇总到一起并输出。从高层抽象来看，MapReduce 的数据流图如下图所示：</p>
<p><img src="/media/14521186972719/hadoop2.jpg" alt="hadoop2"></p>
<p>在本文中，Shuffle 是指从 Map 产生输出开始，包括系统执行排序以及传送 Map 输出到 Reducer 作为输入的过程。在这里我们将去探究 Shuffle 是如何工作的，因为对基础的理解有助于对 MapReduce 程序进行调优。</p>
<p>首先从 Map 端开始分析，当 Map 开始产生输出的时候，他并不是简单的把数据写到磁盘，因为频繁的操作会导致性能严重下降，他的处理更加复杂，数据首先是写到内存中的一个缓冲区，并作一些预排序，以提升效率，如图：</p>
<p><img src="/media/14521186972719/hadoop3.jpg" alt="hadoop3"></p>
<p>每个 Map 任务都有一个用来写入输出数据的循环内存缓冲区，这个缓冲区默认大小是 100M，可以通过 <code>io.sort.mb</code> 属性来设置具体的大小，当缓冲区中的数据量达到一个特定的阀值 <code>(io.sort.mb * io.sort.spill.percent，其中io.sort.spill.percent 默认是0.80)</code>时，系统将会启动一个后台线程把缓冲区中的内容 spill 到磁盘。在 spill 过程中，Map 的输出将会继续写入到缓冲区，但如果缓冲区已经满了，Map 就会被阻塞直到 spill 完成。spill 线程在把缓冲区的数据写到磁盘前，会对他进行一个二次排序，首先根据数据所属的 partition 排序，然后每个 partition 中再按 Key 排序。输出包括一个索引文件和数据文件，如果设定了Combiner，将在排序输出的基础上进行。Combiner 就是一个 Mini Reducer，它在执行 Map 任务的节点本身运行，先对 Map 的输出作一次简单的 Reduce，使得 Map 的输出更紧凑，更少的数据会被写入磁盘和传送到 Reducer。Spill 文件保存在由 <code>mapred.local.dir</code> 指定的目录中，Map 任务结束后删除。</p>
<p>每当内存中的数据达到 spill 阀值的时候，都会产生一个新的 spill 文件，所以在 Map 任务写完他的最后一个输出记录的时候，可能会有多个 spill 文件，在 Map 任务完成前，所有的 spill 文件将会被归并排序为一个索引文件和数据文件。如下图所示。这是一个多路归并过程，最大归并路数由 <code>io.sort.factor</code> 控制(默认是10)。如果设定了 Combiner，并且 spill 文件的数量至少是 3（由<code>min.num.spills.for.combine</code> 属性控制），那么 Combiner 将在输出文件被写入磁盘前运行以压缩数据。</p>
<p><img src="/media/14521186972719/hadoop4.jpg" alt="hadoop4"></p>
<p>对写入到磁盘的数据进行压缩（这种压缩同 Combiner 的压缩不一样）通常是一个很好的方法，因为这样做使得数据写入磁盘的速度更快，节省磁盘空间，并减少需要传送到 Reducer 的数据量。默认输出是不被压缩的，但可以很简单的设置 <code>mapred.compress.map.output</code> 为 <code>true</code> 启用该功能。压缩所使用的库由 <code>mapred.map.output.compression.codec</code> 来设定</p>
<p>当 spill 文件归并完毕后，Map 将删除所有的临时 spill 文件，并告知 TaskTracker 任务已完成。Reducers 通过 HTTP 来获取对应的数据。用来传输 partitions 数据的工作线程个数由 <code>tasktracker.http.threads</code> 控制，这个设定是针对每一个 TaskTracker 的，并不是单个 Map，默认值为 40，在运行大作业的大集群上可以增大以提升数据传输速率。</p>
<p>现在让我们转到 Shuffle 的 Reduce 部分。Map 的输出文件放置在运行 Map 任务的 TaskTracker 的本地磁盘上（注意：Map 输出总是写到本地磁盘，但是 Reduce 输出不是，一般是写到 HDFS），它是运行 Reduce 任务的 TaskTracker 所需要的输入数据。Reduce 任务的输入数据分布在集群内的多个 Map 任务的输出中，Map 任务可能会在不同的时间内完成，只要有其中一个 Map 任务完成，Reduce 任务就开始拷贝他的输出。这个阶段称为拷贝阶段，Reduce 任务拥有多个拷贝线程，可以并行的获取 Map 输出。可以通过设定 <code>mapred.reduce.parallel.copies</code> 来改变线程数。</p>
<p>Reduce 是怎么知道从哪些 TaskTrackers 中获取 Map 的输出呢？当 Map 任务完成之后，会通知他们的父 TaskTracker，告知状态更新，然后 TaskTracker 再转告 JobTracker，这些通知信息是通过心跳通信机制传输的，因此针对以一个特定的作业，jobtracker 知道 Map 输出与 tasktrackers 的映射关系。Reducer 中有一个线程会间歇的向 JobTracker 询问 Map 输出的地址，直到把所有的数据都取到。在 Reducer 取走了 Map 输出之后，TaskTracker 不会立即删除这些数据，因为 Reducer 可能会失败，他们会在整个作业完成之后，JobTracker 告知他们要删除的时候才去删除。</p>
<p>如果 Map 输出足够小，他们会被拷贝到 Reduce TaskTracker 的内存中（缓冲区的大小由 <code>mapred.job.shuffle.input.buffer.percnet</code> 控制），或者达到了 Map 输出的阀值的大小(由 <code>mapred.inmem.merge.threshold</code> 控制)，缓冲区中的数据将会被归并然后 spill 到磁盘。</p>
<p>拷贝来的数据叠加在磁盘上，有一个后台线程会将它们归并为更大的排序文件，这样做节省了后期归并的时间。对于经过压缩的 Map 输出，系统会自动把它们解压到内存方便对其执行归并。</p>
<p>当所有的 Map 输出都被拷贝后，Reduce 任务进入排序阶段（更恰当的说应该是归并阶段，因为排序在 Map 端就已经完成），这个阶段会对所有的 Map 输出进行归并排序，这个工作会重复多次才能完成。</p>
<p>假设这里有 50 个 Map 输出（可能有保存在内存中的），并且归并因子是 10（由 <code>io.sort.factor</code> 控制，就像 Map 端的 merge 一样），那最终需要 5 次归并。每次归并会把 10 个文件归并为一个，最终生成 5 个中间文件。在这一步之后，系统不再把 5 个中间文件归并成一个，而是排序后直接“喂”给 Reduce 函数，省去向磁盘写数据这一步。最终归并的数据可以是混合数据，既有内存上的也有磁盘上的。由于归并的目的是归并最少的文件数目，使得在最后一次归并时总文件个数达到归并因子的数目，所以每次操作所涉及的文件个数在实际中会更微妙些。譬如，如果有 40 个文件，并不是每次都归并 10 个最终得到 4 个文件，相反第一次只归并 4 个文件，然后再实现三次归并，每次 10 个，最终得到 4 个归并好的文件和 6 个未归并的文件。要注意，这种做法并没有改变归并的次数，只是最小化写入磁盘的数据优化措施，因为最后一次归并的数据总是直接送到 Reduce 函数那里。在Reduce 阶段，Reduce 函数会作用在排序输出的每一个 key 上。这个阶段的输出被直接写到输出文件系统，一般是 HDFS。在 HDFS 中，因为 TaskTracker 节点也运行着一个 DataNode 进程，所以第一个块备份会直接写到本地磁盘。到此，MapReduce 的 Shuffle 和 Sort 分析完毕。</p>
<h2 id="u5DE5_u4F5C_u539F_u7406"><a href="#u5DE5_u4F5C_u539F_u7406" class="headerlink" title="工作原理"></a>工作原理</h2><ul>
<li>Client: 作业提交发起者。</li>
<li>JobTracker: 初始化作业，分配作业，与 TaskTracker 通信，协调整个作业。</li>
<li>TaskTracker: 保持 JobTracker 通信，在分配的数据片段上执行 MapReduce 任务。</li>
</ul>
<p>提交作业</p>
<ul>
<li>在作业提交之前，需要对作业进行配置</li>
<li>程序代码，主要是自己书写的 MapReduce 程序。</li>
<li>输入输出路径</li>
<li>其他配置，如输出压缩等。</li>
<li>配置完成后，通过 JobClinet 来提交</li>
</ul>
<p>作业的初始化</p>
<ul>
<li>客户端提交完成后，JobTracker 会将作业加入队列，然后进行调度，默认的调度方法是 FIFO 调试方式。</li>
</ul>
<p>任务的分配</p>
<ul>
<li>TaskTracker 和 JobTracker 之间的通信与任务的分配是通过心跳机制完成的。</li>
<li>TaskTracker 会主动向 JobTracker 询问是否有作业要做，如果自己可以做，那么就会申请到作业任务，这个任务可以是 Map 也可能是 Reduce 任务。</li>
</ul>
<p>任务的执行</p>
<ul>
<li>申请到任务后，TaskTracker 会做如下事情：<ul>
<li>拷贝代码到本地</li>
<li>拷贝任务的信息到本地</li>
<li>启动JVM运行任务</li>
</ul>
</li>
</ul>
<p>状态与任务的更新</p>
<ul>
<li>任务在运行过程中，首先会将自己的状态汇报给 TaskTracker，然后由 TaskTracker 汇总告知 JobTracker。</li>
<li>任务进度是通过计数器来实现的。</li>
</ul>
<p>作业的完成</p>
<ul>
<li>JobTracker 是在接受到最后一个任务运行完成后，才会将任务标志为成功。</li>
<li>此时会做删除中间结果等善后处理工作。</li>
</ul>
<h2 id="u9519_u8BEF_u5904_u7406"><a href="#u9519_u8BEF_u5904_u7406" class="headerlink" title="错误处理"></a>错误处理</h2><p>任务失败</p>
<ul>
<li>MapReduce 在设计之出，就假象任务会失败，所以做了很多工作，来保证容错。</li>
<li>一种情况: 子任务失败</li>
<li>另一种情况: 子任务的 JVM 突然退出</li>
<li>任务的挂起</li>
</ul>
<p>TaskTracker 失败</p>
<ul>
<li>TaskTracker 崩溃后会停止向 Jobtracker 发送心跳信息。</li>
<li>Jobtracker 会将该 TaskTracker 从等待的任务池中移除。并将该 TaskTracker 上的任务，移动到其他地方去重新运行。</li>
<li>TaskTracker 可以被 JobTracker 放入到黑名单，即使它没有失败。</li>
</ul>
<p>JobTracker失败</p>
<ul>
<li>单点故障，Hadoop 新的0.23版本解决了这个问题。</li>
</ul>
<h2 id="u4F5C_u4E1A_u8C03_u5EA6"><a href="#u4F5C_u4E1A_u8C03_u5EA6" class="headerlink" title="作业调度"></a>作业调度</h2><ul>
<li>FIFO: Hadoop 中默认的调度器，它先按照作业的优先级高低，再按照到达时间的先后选 择被执行的作业</li>
<li>公平调度器: 为任务分配资源的方法，其目的是随着时间的推移，让提交的作业获取等量的集 群共享资源，让用户公平地共享集群。具体做法是：当集群上只有一个任务在运行 时，它将使用整个集群，当有其他作业提交时，系统会将 TaskTracker 节点空间的时 间片分配给这些新的作业，并保证每个任务都得到大概等量的CPU时间。</li>
<li>容量调度器: 支持多个队列，每个队列可配置一定的资源量，每个队列采用 FIFO 调度策略，为了防止同一个用户的作业独占队列中的资源，该调度器会对同一用户提交的作业所占资源量进行限定。调度时，首先按以下策略选择一个合适队列：计算每个队列中正在运行的任务数与其应该分得的计算资源之间的比值，选择一个该比值最小的队列；然后按以下策略选择该队列中一个作业：按照作业优先级和提交时间顺序选择 ，同时考虑用户资源量限制和内存限制。但是不可剥夺式</li>
</ul>
<h2 id="Shuffle__26amp_3B_Sort"><a href="#Shuffle__26amp_3B_Sort" class="headerlink" title="Shuffle &amp; Sort"></a>Shuffle &amp; Sort</h2><p>Mapreduce 的 map 结束后，把数据重新组织，作为 reduce 阶段的输入，该过程称之为 shuffle – 洗牌。而数据在 Map 与 Reduce 端都会做排序。</p>
<p>Map</p>
<ul>
<li>Map 的输出是由 collector 控制的</li>
<li>我们从 collect 函数入手</li>
</ul>
<p>Reduce</p>
<ul>
<li>reduce 的 Shuffle 过程，分成三个阶段：复制 Map 输出、排序合并、reduce 处理。</li>
<li>主要代码在 reduce的 run 函数</li>
</ul>
<p>Shuffle优化</p>
<ul>
<li>首先 Hadoop 的 Shuffle 在某些情况并不是最优的，例如，如果需要对2集合合并，那么其实排序操作时不需要的。</li>
<li>我们可以通过调整参数来优化 Shuffle</li>
<li>Map端: io.sort.mb</li>
<li>Reduce端: mapred.job.reduce.input.buffer.percent</li>
</ul>
<h2 id="u4EFB_u52A1_u7684_u6267_u884C_u65F6_u7684_u4E00_u4E9B_u7279_u6709_u7684_u6982_u5FF5"><a href="#u4EFB_u52A1_u7684_u6267_u884C_u65F6_u7684_u4E00_u4E9B_u7279_u6709_u7684_u6982_u5FF5" class="headerlink" title="任务的执行时的一些特有的概念"></a>任务的执行时的一些特有的概念</h2><p>推测式执行</p>
<ul>
<li>每一道作业的任务都有运行时间，而由于机器的异构性，可能会会造成某些任务会比所有任务的平均运行时间要慢很多。</li>
<li>这时 MapReduce 会尝试在其他机器上重启慢的任务。为了是任务快速运行完成。</li>
<li>该属性默认是启用的。</li>
</ul>
<p>JVM重用</p>
<ul>
<li>启动 JVM 是一个比较耗时的工作，所以在 MapReduce 中有 JVM 重用的机制。</li>
<li>条件是统一个作业的任务。</li>
<li>可以通过 <code>mapred.job.reuse.jvm.num.tasks</code>定义重用次数，如果属性是 -1 那么为无限制。</li>
</ul>
<p>跳过坏记录</p>
<ul>
<li>数据的一些记录不符合规范，处理时抛出异常，MapReduce 可以讲次记录标为坏记录。重启任务时会跳过该记录。</li>
<li>默认情况下该属性是关闭的。</li>
</ul>
<p>任务执行环境</p>
<ul>
<li>Hadoop 为 Map 与 Reduce 任务提供运行环境。</li>
<li>如：Map 可以知道自己的处理的文件</li>
<li>问题：多个任务可能会同时写一个文件</li>
<li>解决办法：将输出写到任务的临时文件夹。目录为：{mapred.out. put.dir}/temp/${mapred.task.id}</li>
</ul>
<h2 id="u6D41_u7A0B_u5206_u6790"><a href="#u6D41_u7A0B_u5206_u6790" class="headerlink" title="流程分析"></a>流程分析</h2><p>Map端：</p>
<ol>
<li>每个输入分片会让一个 map 任务来处理，默认情况下，以 HDFS 的一个块的大小（默认为 64M）为一个分片，当然我们也可以设置块的大小。map 输出的结果会暂且放在一个环形内存缓冲区中（该缓冲区的大小默认为 100M，由 <code>io.sort.mb</code> 属性控制），当该缓冲区快要溢出时（默认为缓冲区大小的80%，由 <code>io.sort.spill.percent</code> 属性控制），会在本地文件系统中创建一个溢出文件，将该缓冲区中的数据写入这个文件。</li>
<li>在写入磁盘之前，线程首先根据 reduce 任务的数目将数据划分为相同数目的分区，也就是一个 reduce 任务对应一个分区的数据。这样做是为了避免有些 reduce 任务分配到大量数据，而有些 reduce 任务却分到很少数据，甚至没有分到数据的尴尬局面。其实分区就是对数据进行 hash 的过程。然后对每个分区中的数据进行排序，如果此时设置了 Combiner，将排序后的结果进行 Combiner 操作，这样做的目的是让尽可能少的数据写入到磁盘。</li>
<li>当 map 任务输出最后一个记录时，可能会有很多的溢出文件，这时需要将这些文件合并。合并的过程中会不断地进行排序和 combiner 操作，目的有两个：1.尽量减少每次写入磁盘的数据量；2.尽量减少下一复制阶段网络传输的数据量。最后合并成了一个已分区且已排序的文件。为了减少网络传输的数据量，这里可以将数据压缩，只要将 <code>mapred.compress.map.out</code> 设置为 true 就可以了。</li>
<li>将分区中的数据拷贝给相对应的 reduce 任务。有人可能会问：分区中的数据怎么知道它对应的 reduce 是哪个呢？其实 map 任务一直和其父 TaskTracker 保持联系，而 TaskTracker 又一直和 JobTracker 保持心跳。所以 JobTracker 中保存了整个集群中的宏观信息。只要 reduce 任务向 JobTracker 获取对应的 map 输出位置就ok了哦。</li>
</ol>
<p>到这里，map 端就分析完了。那到底什么是 Shuffle 呢？Shuffle 的中文意思是“洗牌”，如果我们这样看：一个 map 产生的数据，结果通过 hash 过程分区却分配给了不同的 reduce 任务，是不是一个对数据洗牌的过程呢？呵呵。</p>
<p>Reduce端：</p>
<ol>
<li>Reduce 会接收到不同 map 任务传来的数据，并且每个 map 传来的数据都是有序的。如果 reduce 端接受的数据量相当小，则直接存储在内存中（缓冲区大小由 <code>mapred.job.shuffle.input.buffer.percent</code> 属性控制，表示用作此用途的堆空间的百分比），如果数据量超过了该缓冲区大小的一定比例（由 <code>mapred.job.shuffle.merge.percent</code> 决定），则对数据合并后溢写到磁盘中。</li>
<li>随着溢写文件的增多，后台线程会将它们合并成一个更大的有序的文件，这样做是为了给后面的合并节省时间。其实不管在 map 端还是 reduce 端，MapReduce 都是反复地执行排序，合并操作，现在终于明白了有些人为什么会说：排序是 hadoop 的灵魂。</li>
<li>合并的过程中会产生许多的中间文件（写入磁盘了），但 MapReduce 会让写入磁盘的数据尽可能地少，并且最后一次合并的结果并没有写入磁盘，而是直接输入到 reduce 函数。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里简要介绍一下 Hadoop 的基本原理及用法。</p>]]>
    
    </summary>
    
      <category term="Hadoop" scheme="http://wdxtub.com/tags/Hadoop/"/>
    
      <category term="MapReduce" scheme="http://wdxtub.com/tags/MapReduce/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SQL 指南]]></title>
    <link href="http://wdxtub.com/2016/03/20/sql-guide/"/>
    <id>http://wdxtub.com/2016/03/20/sql-guide/</id>
    <published>2016-03-20T12:59:34.000Z</published>
    <updated>2016-03-20T13:00:27.000Z</updated>
    <content type="html"><![CDATA[<p>这里记录一下对于 SQL 基本操作的理解和优化。</p>
<a id="more"></a>
<hr>
<h2 id="SQL__u662F_u4E00_u79CD_u58F0_u660E_u5F0F_u8BED_u8A00"><a href="#SQL__u662F_u4E00_u79CD_u58F0_u660E_u5F0F_u8BED_u8A00" class="headerlink" title="SQL 是一种声明式语言"></a>SQL 是一种声明式语言</h2><p>首先要把这个概念记在脑中：“声明”。 SQL 语言是为计算机声明了一个你想从原始数据中获得什么样的结果的一个范例，而不是告诉计算机如何能够得到结果。这是不是很棒？</p>
<p>（译者注：简单地说，SQL 语言声明的是结果集的属性，计算机会根据 SQL 所声明的内容来从数据库中挑选出符合声明的数据，而不是像传统编程思维去指示计算机如何操作。）</p>
<pre><code>SELECT first_name, last_name FROM employees WHERE salary &gt; 100000
</code></pre><p>上面的例子很容易理解，我们不关心这些雇员记录从哪里来，我们所需要的只是那些高薪者的数据（译者注： salary&gt;100000 ）。</p>
<p>我们从哪儿学习到这些？</p>
<p>如果 SQL 语言这么简单，那么是什么让人们“闻 SQL 色变”？主要的原因是：我们潜意识中的是按照命令式编程的思维方式思考问题的。就好像这样：“电脑，先执行这一步，再执行那一步，但是在那之前先检查一下是否满足条件 A 和条件 B ”。例如，用变量传参、使用循环语句、迭代、调用函数等等，都是这种命令式编程的思维惯式。</p>
<h2 id="SQL__u7684_u8BED_u6CD5_u5E76_u4E0D_u6309_u7167_u8BED_u6CD5_u987A_u5E8F_u6267_u884C"><a href="#SQL__u7684_u8BED_u6CD5_u5E76_u4E0D_u6309_u7167_u8BED_u6CD5_u987A_u5E8F_u6267_u884C" class="headerlink" title="SQL 的语法并不按照语法顺序执行"></a>SQL 的语法并不按照语法顺序执行</h2><p>SQL 语句有一个让大部分人都感到困惑的特性，就是：SQL 语句的执行顺序跟其语句的语法顺序并不一致。SQL 语句的语法顺序是：</p>
<ul>
<li>SELECT[DISTINCT]</li>
<li>FROM</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>UNION</li>
<li>ORDER BY</li>
</ul>
<p>为了方便理解，上面并没有把所有的 SQL 语法结构都列出来，但是已经足以说明 SQL 语句的语法顺序和其执行顺序完全不一样，就以上述语句为例，其执行顺序为：</p>
<ul>
<li>FROM</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>SELECT</li>
<li>DISTINCT</li>
<li>UNION</li>
<li>ORDER BY</li>
</ul>
<p>关于 SQL 语句的执行顺序，有三个值得我们注意的地方：</p>
<p>1、 FROM 才是 SQL 语句执行的第一步，并非 SELECT 。数据库在执行 SQL 语句的第一步是将数据从硬盘加载到数据缓冲区中，以便对这些数据进行操作。（译者注：原文为“The first thing that happens is loading data from the disk into memory, in order to operate on such data.”，但是并非如此，以 Oracle 等常用数据库为例，数据是从硬盘中抽取到数据缓冲区中进行操作。）</p>
<p>2、 SELECT 是在大部分语句执行了之后才执行的，严格的说是在 FROM 和 GROUP BY 之后执行的。理解这一点是非常重要的，这就是你不能在 WHERE 中使用在 SELECT 中设定别名的字段作为判断条件的原因。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> A.x + A.y <span class="keyword">AS</span> z</span><br><span class="line"><span class="keyword">FROM</span> A</span><br><span class="line"><span class="keyword">WHERE</span> z = <span class="number">10</span></span></span><br></pre></td></tr></table></figure>
<p>z 在此处不可用，因为SELECT是最后执行的语句！<br>如果你想重用别名z，你有两个选择。要么就重新写一遍 z 所代表的表达式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> A.x + A.y <span class="keyword">AS</span> z</span><br><span class="line"><span class="keyword">FROM</span> A</span><br><span class="line"><span class="keyword">WHERE</span> (A.x + A.y) = <span class="number">10</span></span></span><br></pre></td></tr></table></figure>
<p>或者求助于衍生表、通用数据表达式或者视图，以避免别名重用。请看下文中的例子。</p>
<p>3、 无论在语法上还是在执行顺序上， UNION 总是排在在 ORDER BY 之前。很多人认为每个 UNION 段都能使用 ORDER BY 排序，但是根据 SQL 语言标准和各个数据库 SQL 的执行差异来看，这并不是真的。尽管某些数据库允许 SQL 语句对子查询（subqueries）或者派生表（derived tables）进行排序，但是这并不说明这个排序在 UNION 操作过后仍保持排序后的顺序。</p>
<p>注意：并非所有的数据库对 SQL 语句使用相同的解析方式。如 MySQL、PostgreSQL和 SQLite 中就不会按照上面第二点中所说的方式执行。</p>
<p>我们学到了什么？</p>
<p>既然并不是所有的数据库都按照上述方式执行 SQL 预计，那我们的收获是什么？我们的收获是永远要记得： SQL 语句的语法顺序和其执行顺序并不一致，这样我们就能避免一般性的错误。如果你能记住 SQL 语句语法顺序和执行顺序的差异，你就能很容易的理解一些很常见的 SQL 问题。</p>
<p>当然，如果一种语言被设计成语法顺序直接反应其语句的执行顺序，那么这种语言对程序员是十分友好的，这种编程语言层面的设计理念已经被微软应用到了 LINQ 语言中。</p>
<h2 id="SQL__u8BED_u8A00_u7684_u6838_u5FC3_u662F_u5BF9_u8868_u7684_u5F15_u7528_uFF08table_references_uFF09"><a href="#SQL__u8BED_u8A00_u7684_u6838_u5FC3_u662F_u5BF9_u8868_u7684_u5F15_u7528_uFF08table_references_uFF09" class="headerlink" title="SQL 语言的核心是对表的引用（table references）"></a>SQL 语言的核心是对表的引用（table references）</h2><p>由于 SQL 语句语法顺序和执行顺序的不同，很多同学会认为SELECT 中的字段信息是 SQL 语句的核心。其实真正的核心在于对表的引用。</p>
<p>根据 SQL 标准，FROM 语句被定义为：</p>
<pre><code>&lt;from clause&gt; ::= FROM &lt;table reference&gt; [ { &lt;comma&gt; &lt;table reference&gt; }... ]
</code></pre><p>FROM 语句的“输出”是一张联合表，来自于所有引用的表在某一维度上的联合。我们们慢慢来分析：</p>
<pre><code>FROM a, b
</code></pre><p>上面这句 FROM 语句的输出是一张联合表，联合了表 a 和表 b 。如果 a 表有三个字段， b 表有 5 个字段，那么这个“输出表”就有 8 （ =5+3）个字段。</p>
<p>这个联合表里的数据是 <code>a*b</code>，即 a 和 b 的笛卡尔积。换句话说，也就是 a 表中的每一条数据都要跟 b 表中的每一条数据配对。如果 a 表有3 条数据， b 表有 5 条数据，那么联合表就会有 <code>15（=5*3）</code>条数据。</p>
<p>FROM 输出的结果被 WHERE 语句筛选后要经过 GROUP BY 语句处理，从而形成新的输出结果。我们后面还会再讨论这方面问题。</p>
<p>如果我们从集合论（关系代数）的角度来看，一张数据库的表就是一组数据元的关系，而每个 SQL 语句会改变一种或数种关系，从而产生出新的数据元的关系（即产生新的表）。</p>
<p>我们学到了什么？</p>
<p>思考问题的时候从表的角度来思考问题提，这样很容易理解数据如何在 SQL 语句的“流水线”上进行了什么样的变动。</p>
<h2 id="u7075_u6D3B_u5F15_u7528_u8868_u80FD_u4F7F_SQL__u8BED_u53E5_u53D8_u5F97_u66F4_u5F3A_u5927"><a href="#u7075_u6D3B_u5F15_u7528_u8868_u80FD_u4F7F_SQL__u8BED_u53E5_u53D8_u5F97_u66F4_u5F3A_u5927" class="headerlink" title="灵活引用表能使 SQL 语句变得更强大"></a>灵活引用表能使 SQL 语句变得更强大</h2><p>灵活引用表能使 SQL 语句变得更强大。一个简单的例子就是 JOIN 的使用。严格的说 JOIN 语句并非是 SELECT 中的一部分，而是一种特殊的表引用语句。 SQL 语言标准中表的连接定义如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">table</span> <span class="attribute">reference</span>&gt;</span> ::=</span><br><span class="line">    <span class="tag">&lt;<span class="title">table</span> <span class="attribute">name</span>&gt;</span></span><br><span class="line">  | <span class="tag">&lt;<span class="title">derived</span> <span class="attribute">table</span>&gt;</span></span><br><span class="line">  | <span class="tag">&lt;<span class="title">joined</span> <span class="attribute">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就拿之前的例子来说：</p>
<pre><code>FROM a, b
</code></pre><p>a 可能输如下表的连接：</p>
<pre><code>a1 JOIN a2 ON a1.id = a2.id
</code></pre><p>将它放到之前的例子中就变成了：</p>
<pre><code>FROM a1 JOIN a2 ON a1.id = a2.id, b
</code></pre><p>尽管将一个连接表用逗号跟另一张表联合在一起并不是常用作法，但是你的确可以这么做。结果就是，最终输出的表就有了 a1+a2+b 个字段了。</p>
<p>（译者注：原文这里用词为 degree ，译为维度。如果把一张表视图化，我们可以想象每一张表都是由横纵两个维度组成的，横向维度即我们所说的字段或者列，英文为columns；纵向维度即代表了每条数据，英文为 record ，根据上下文，作者这里所指的应该是字段数。）</p>
<p>在 SQL 语句中派生表的应用甚至比表连接更加强大，下面我们就要讲到表连接。</p>
<p>我们学到了什么？</p>
<p>思考问题时，要从表引用的角度出发，这样就很容易理解数据是怎样被 SQL 语句处理的，并且能够帮助你理解那些复杂的表引用是做什么的。</p>
<p>更重要的是，要理解 JOIN 是构建连接表的关键词，并不是 SELECT 语句的一部分。有一些数据库允许在 INSERT 、 UPDATE 、 DELETE 中使用 JOIN 。</p>
<h2 id="SQL__u8BED_u53E5_u4E2D_u63A8_u8350_u4F7F_u7528_u8868_u8FDE_u63A5"><a href="#SQL__u8BED_u53E5_u4E2D_u63A8_u8350_u4F7F_u7528_u8868_u8FDE_u63A5" class="headerlink" title="SQL 语句中推荐使用表连接"></a>SQL 语句中推荐使用表连接</h2><p>我们先看看刚刚这句话：</p>
<pre><code>FROM a, b
</code></pre><p>高级 SQL 程序员也许学会给你忠告：尽量不要使用逗号来代替 JOIN 进行表的连接，这样会提高你的 SQL 语句的可读性，并且可以避免一些错误。</p>
<p>利用逗号来简化 SQL 语句有时候会造成思维上的混乱，想一下下面的语句：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM <span class="tag">a</span>, <span class="tag">b</span>, c, d, e, f, g, h</span><br><span class="line">WHERE <span class="tag">a</span><span class="class">.a1</span> = <span class="tag">b</span><span class="class">.bx</span></span><br><span class="line">AND <span class="tag">a</span><span class="class">.a2</span> = c<span class="class">.c1</span></span><br><span class="line">AND d<span class="class">.d1</span> = <span class="tag">b</span><span class="class">.bc</span></span><br><span class="line">-- etc...</span><br></pre></td></tr></table></figure>
<p>我们不难看出使用 JOIN 语句的好处在于：</p>
<ul>
<li>安全。 JOIN 和要连接的表离得非常近，这样就能避免错误。</li>
<li>更多连接的方式，JOIN 语句能去区分出来外连接和内连接等。</li>
</ul>
<p>我们学到了什么？</p>
<p>记着要尽量使用 JOIN 进行表的连接，永远不要在 FROM 后面使用逗号连接表。</p>
<h2 id="SQL__u8BED_u53E5_u4E2D_u4E0D_u540C_u7684_u8FDE_u63A5_u64CD_u4F5C"><a href="#SQL__u8BED_u53E5_u4E2D_u4E0D_u540C_u7684_u8FDE_u63A5_u64CD_u4F5C" class="headerlink" title="SQL 语句中不同的连接操作"></a>SQL 语句中不同的连接操作</h2><p>SQL 语句中，表连接的方式从根本上分为五种：</p>
<ul>
<li>EQUI JOIN</li>
<li>SEMI JOIN</li>
<li>ANTI JOIN</li>
<li>CROSS JOIN</li>
<li>DIVISION</li>
</ul>
<h3 id="EQUI_JOIN"><a href="#EQUI_JOIN" class="headerlink" title="EQUI JOIN"></a>EQUI JOIN</h3><p>这是一种最普通的 JOIN 操作，它包含两种连接方式：</p>
<ul>
<li>INNER JOIN（或者是 JOIN ）</li>
<li>OUTER JOIN（包括： LEFT 、 RIGHT、 FULL OUTER JOIN）</li>
</ul>
<p>用例子最容易说明其中区别：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">- <span class="constant">This</span> table reference contains authors <span class="keyword">and</span> their books.</span><br><span class="line"></span>-<span class="ruby">- <span class="constant">There</span> is one record <span class="keyword">for</span> each book <span class="keyword">and</span> its author.</span><br><span class="line"></span>-<span class="ruby">- authors without books are <span class="constant">NOT</span> included</span><br><span class="line"></span>author JOIN book ON author.id = book.author_id</span><br><span class="line"></span><br><span class="line">-<span class="ruby">- <span class="constant">This</span> table reference contains authors <span class="keyword">and</span> their books</span><br><span class="line"></span>-<span class="ruby">- <span class="constant">There</span> is one record <span class="keyword">for</span> each book <span class="keyword">and</span> its author.</span><br><span class="line"></span>-<span class="ruby">- ... <span class="constant">OR</span> there is an <span class="string">"empty"</span> record <span class="keyword">for</span> authors without books</span><br><span class="line"></span>-<span class="ruby">- (<span class="string">"empty"</span> meaning that all book columns are <span class="constant">NULL</span>)</span><br><span class="line"></span>author LEFT OUTER JOIN book ON author.id = book.author_id</span><br></pre></td></tr></table></figure>
<h3 id="SEMI_JOIN"><a href="#SEMI_JOIN" class="headerlink" title="SEMI JOIN"></a>SEMI JOIN</h3><p>这种连接关系在 SQL 中有两种表现方式：使用 IN，或者使用 EXISTS。“ SEMI ”在拉丁文中是“半”的意思。这种连接方式是只连接目标表的一部分。这是什么意思呢？再想一下上面关于作者和书名的连接。我们想象一下这样的情况：我们不需要作者 / 书名这样的组合，只是需要那些在书名表中的书的作者信息。那我们就能这么写：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- <span class="keyword">Using</span> <span class="keyword">IN</span></span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> author.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> book.author_id <span class="keyword">FROM</span> book)</span><br><span class="line"></span><br><span class="line">-- <span class="keyword">Using</span> EXISTS</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> EXISTS (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> book.author_id = author.id)</span><br></pre></td></tr></table></figure>
<p>尽管没有严格的规定说明你何时应该使用 IN ，何时应该使用 EXISTS ，但是这些事情你还是应该知道的：</p>
<ul>
<li>IN 比 EXISTS 的可读性更好</li>
<li>EXISTS 比IN 的表达性更好（更适合复杂的语句）</li>
<li>二者之间性能没有差异（但对于某些数据库来说性能差异会非常大）</li>
</ul>
<p>因为使用 INNER JOIN 也能得到书名表中书所对应的作者信息，所以很多初学者机会认为可以通过 DISTINCT 进行去重，然后将 SEMI JOIN 语句写成这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Find only those authors who also have books</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> first_name, last_name</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">JOIN</span> book <span class="keyword">ON</span> author.<span class="keyword">id</span> = book.author_id</span></span><br></pre></td></tr></table></figure>
<p>这是一种很糟糕的写法，原因如下：</p>
<ul>
<li>SQL 语句性能低下：因为去重操作（ DISTINCT ）需要数据库重复从硬盘中读取数据到内存中。（译者注： DISTINCT 的确是一种很耗费资源的操作，但是每种数据库对于 DISTINCT 的操作方式可能不同）。</li>
<li>这么写并非完全正确：尽管也许现在这么写不会出现问题，但是随着 SQL 语句变得越来越复杂，你想要去重得到正确的结果就变得十分困难。</li>
</ul>
<h3 id="ANTI_JOIN"><a href="#ANTI_JOIN" class="headerlink" title="ANTI JOIN"></a>ANTI JOIN</h3><p>这种连接的关系跟 SEMI JOIN 刚好相反。在 IN 或者 EXISTS 前加一个 NOT 关键字就能使用这种连接。举个例子来说，我们列出书名表里没有书的作者：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- <span class="keyword">Using</span> <span class="keyword">IN</span></span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> author.id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> book.author_id <span class="keyword">FROM</span> book)</span><br><span class="line"></span><br><span class="line">-- <span class="keyword">Using</span> EXISTS</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> EXISTS (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> book.author_id = author.id)</span><br></pre></td></tr></table></figure>
<p>关于性能、可读性、表达性等特性也完全可以参考 SEMI JOIN。</p>
<h3 id="CROSS_JOIN"><a href="#CROSS_JOIN" class="headerlink" title="CROSS JOIN"></a>CROSS JOIN</h3><p>这个连接过程就是两个连接的表的乘积：即将第一张表的每一条数据分别对应第二张表的每条数据。我们之前见过，这就是逗号在 FROM 语句中的用法。在实际的应用中，很少有地方能用到 CROSS JOIN，但是一旦用上了，你就可以用这样的 SQL语句表达：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- Combine <span class="keyword">every</span> author with <span class="keyword">every</span> book</span><br><span class="line">author CROSS <span class="keyword">JOIN</span> book</span><br></pre></td></tr></table></figure>
<h3 id="DIVISION"><a href="#DIVISION" class="headerlink" title="DIVISION"></a>DIVISION</h3><p>DIVISION 的确是一个怪胎。简而言之，如果 JOIN 是一个乘法运算，那么 DIVISION 就是 JOIN 的逆过程。DIVISION 的关系很难用 SQL 表达出来，介于这是一个新手指南，解释 DIVISION 已经超出了我们的目的。</p>
<p>我们学到了什么？</p>
<p>学到了很多！让我们在脑海中再回想一下。 SQL 是对表的引用， JOIN 则是一种引用表的复杂方式。但是 SQL 语言的表达方式和实际我们所需要的逻辑关系之间是有区别的，并非所有的逻辑关系都能找到对应的 JOIN 操作，所以这就要我们在平时多积累和学习关系逻辑，这样你就能在以后编写 SQL 语句中选择适当的 JOIN 操作了。</p>
<h2 id="SQL__u4E2D_u5982_u540C_u53D8_u91CF_u7684_u6D3E_u751F_u8868"><a href="#SQL__u4E2D_u5982_u540C_u53D8_u91CF_u7684_u6D3E_u751F_u8868" class="headerlink" title="SQL 中如同变量的派生表"></a>SQL 中如同变量的派生表</h2><p>在这之前，我们学习到过 SQL 是一种声明性的语言，并且 SQL 语句中不能包含变量。但是你能写出类似于变量的语句，这些就叫做派生表：</p>
<p>说白了，所谓的派生表就是在括号之中的子查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- A derived table</span></span><br><span class="line">FROM (<span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> author)</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是有些时候我们可以给派生表定义一个相关名（即我们所说的别名）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- A derived table with an alias</span></span><br><span class="line">FROM (<span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> author) a</span></span><br></pre></td></tr></table></figure>
<p>派生表可以有效的避免由于 SQL 逻辑而产生的问题。举例来说：如果你想重用一个用 SELECT 和 WHERE 语句查询出的结果，这样写就可以（以 Oracle 为例）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Get authors' first and last names, and their age in days</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> first_name, last_name, age</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> first_name, last_name, <span class="keyword">current_date</span> - date_of_birth age</span><br><span class="line">  <span class="keyword">FROM</span> author</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- If the age is greater than 10000 days</span></span><br><span class="line"><span class="keyword">WHERE</span> age &gt; <span class="number">10000</span></span></span><br></pre></td></tr></table></figure>
<p>需要我们注意的是：在有些数据库，以及 SQL ： 1990 标准中，派生表被归为下一级——通用表语句（ common table experssion）。这就允许你在一个 SELECT 语句中对派生表多次重用。上面的例子就（几乎）等价于下面的语句：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> a <span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> first_name, last_name, current_date - date_of_birth age</span><br><span class="line">  <span class="keyword">FROM</span> author</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> a</span><br><span class="line"><span class="keyword">WHERE</span> age &gt; <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>当然了，你也可以给“ a ”创建一个单独的视图，这样你就可以在更广泛的范围内重用这个派生表了。更多信息可以阅读下面的文章（<a href="http://en.wikipedia.org/wiki/View_%28SQL%29）。" target="_blank" rel="external">http://en.wikipedia.org/wiki/View_%28SQL%29）。</a></p>
<p>我们学到了什么？</p>
<p>我们反复强调，大体上来说 SQL 语句就是对表的引用，而并非对字段的引用。要好好利用这一点，不要害怕使用派生表或者其他更复杂的语句。</p>
<h2 id="SQL__u8BED_u53E5_u4E2D_GROUP_BY__u662F_u5BF9_u8868_u7684_u5F15_u7528_u8FDB_u884C_u7684_u64CD_u4F5C"><a href="#SQL__u8BED_u53E5_u4E2D_GROUP_BY__u662F_u5BF9_u8868_u7684_u5F15_u7528_u8FDB_u884C_u7684_u64CD_u4F5C" class="headerlink" title="SQL 语句中 GROUP BY 是对表的引用进行的操作"></a>SQL 语句中 GROUP BY 是对表的引用进行的操作</h2><p>让我们再回想一下之前的 FROM 语句：</p>
<pre><code>FROM a, b
</code></pre><p>现在，我们将 GROUP BY 应用到上面的语句中：</p>
<pre><code>GROUP BY A.x, A.y, B.z
</code></pre><p>上面语句的结果就是产生出了一个包含三个字段的新的表的引用。我们来仔细理解一下这句话：当你应用 GROUP BY 的时候， SELECT 后没有使用聚合函数的列，都要出现在 GROUP BY 后面。（译者注：原文大意为“当你是用 GROUP BY 的时候，你能够对其进行下一级逻辑操作的列会减少，包括在 SELECT 中的列”）。</p>
<p>需要注意的是：其他字段能够使用聚合函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT A<span class="class">.x</span>, A<span class="class">.y</span>, <span class="function"><span class="title">SUM</span><span class="params">(A.z)</span></span></span><br><span class="line">FROM A</span><br><span class="line">GROUP BY A<span class="class">.x</span>, A.y</span><br></pre></td></tr></table></figure>
<p>还有一点值得留意的是： MySQL 并不坚持这个标准，这的确是令人很困惑的地方。（译者注：这并不是说 MySQL 没有 GROUP BY 的功能）但是不要被 MySQL 所迷惑。 GROUP BY 改变了对表引用的方式。你可以像这样既在 SELECT 中引用某一字段，也在 GROUP BY 中对其进行分组。</p>
<p>我们学到了什么？</p>
<p>GROUP BY，再次强调一次，是在表的引用上进行了操作，将其转换为一种新的引用方式。</p>
<h2 id="SQL__u8BED_u53E5_u4E2D_u7684_SELECT__u5B9E_u8D28_u4E0A_u662F_u5BF9_u5173_u7CFB_u7684_u6620_u5C04"><a href="#SQL__u8BED_u53E5_u4E2D_u7684_SELECT__u5B9E_u8D28_u4E0A_u662F_u5BF9_u5173_u7CFB_u7684_u6620_u5C04" class="headerlink" title="SQL 语句中的 SELECT 实质上是对关系的映射"></a>SQL 语句中的 SELECT 实质上是对关系的映射</h2><p>我个人比较喜欢“映射”这个词，尤其是把它用在关系代数上。（译者注：原文用词为 projection ，该词有两层含义，第一种含义是预测、规划、设计，第二种意思是投射、映射，经过反复推敲，我觉得这里用映射能够更直观的表达出 SELECT 的作用）。一旦你建立起来了表的引用，经过修改、变形，你能够一步一步的将其映射到另一个模型中。 SELECT 语句就像一个“投影仪”，我们可以将其理解成一个将源表中的数据按照一定的逻辑转换成目标表数据的函数。</p>
<p>通过 SELECT语句，你能对每一个字段进行操作，通过复杂的表达式生成所需要的数据。</p>
<p>SELECT 语句有很多特殊的规则，至少你应该熟悉以下几条：</p>
<ul>
<li>你仅能够使用那些能通过表引用而得来的字段；</li>
<li>如果你有 GROUP BY 语句，你只能够使用 GROUP BY 语句后面的字段或者聚合函数；</li>
<li>当你的语句中没有 GROUP BY 的时候，可以使用开窗函数代替聚合函数；</li>
<li>当你的语句中没有 GROUP BY 的时候，你不能同时使用聚合函数和其它函数；</li>
<li>有一些方法可以将普通函数封装在聚合函数中；</li>
<li>……</li>
</ul>
<p>一些更复杂的规则多到足够写出另一篇文章了。比如：为何你不能在一个没有 GROUP BY 的 SELECT 语句中同时使用普通函数和聚合函数？（上面的第 4 条）</p>
<p>原因如下：</p>
<ul>
<li>凭直觉，这种做法从逻辑上就讲不通。</li>
<li>如果直觉不能够说服你，那么语法肯定能。 SQL : 1999 标准引入了 GROUPING SETS，SQL： 2003 标准引入了 group sets : GROUP BY() 。无论什么时候，只要你的语句中出现了聚合函数，而且并没有明确的 GROUP BY 语句，这时一个不明确的、空的 GROUPING SET 就会被应用到这段 SQL 中。因此，原始的逻辑顺序的规则就被打破了，映射（即 SELECT ）关系首先会影响到逻辑关系，其次就是语法关系。（译者注：这段话原文就比较艰涩，可以简单理解如下：在既有聚合函数又有普通函数的 SQL 语句中，如果没有 GROUP BY 进行分组，SQL 语句默认视整张表为一个分组，当聚合函数对某一字段进行聚合统计的时候，引用的表中的每一条 record 就失去了意义，全部的数据都聚合为一个统计值，你此时对每一条 record 使用其它函数是没有意义的）。</li>
</ul>
<p>糊涂了？是的，我也是。我们再回过头来看点浅显的东西吧。</p>
<p>我们学到了什么？</p>
<p>SELECT 语句可能是 SQL 语句中最难的部分了，尽管他看上去很简单。其他语句的作用其实就是对表的不同形式的引用。而 SELECT 语句则把这些引用整合在了一起，通过逻辑规则将源表映射到目标表，而且这个过程是可逆的，我们可以清楚的知道目标表的数据是怎么来的。</p>
<p>想要学习好 SQL 语言，就要在使用 SELECT 语句之前弄懂其他的语句，虽然 SELECT 是语法结构中的第一个关键词，但它应该是我们最后一个掌握的。</p>
<h2 id="SQL__u8BED_u53E5_u4E2D_u7684_u51E0_u4E2A_u7B80_u5355_u7684_u5173_u952E_u8BCD_uFF1A_DISTINCT__uFF0C_UNION__uFF0C_ORDER_BY__u548C_OFFSET"><a href="#SQL__u8BED_u53E5_u4E2D_u7684_u51E0_u4E2A_u7B80_u5355_u7684_u5173_u952E_u8BCD_uFF1A_DISTINCT__uFF0C_UNION__uFF0C_ORDER_BY__u548C_OFFSET" class="headerlink" title="SQL 语句中的几个简单的关键词： DISTINCT ， UNION ， ORDER BY 和 OFFSET"></a>SQL 语句中的几个简单的关键词： DISTINCT ， UNION ， ORDER BY 和 OFFSET</h2><p>在学习完复杂的 SELECT 之后，我们再来看点简单的东西：</p>
<ul>
<li>集合运算（ DISTINCT 和 UNION ）</li>
<li>排序运算（ ORDER BY，OFFSET…FETCH）</li>
<li>集合运算（ set operation）：</li>
</ul>
<p>集合运算主要操作在于集合上，事实上指的就是对表的一种操作。从概念上来说，他们很好理解：</p>
<ul>
<li>DISTINCT 在映射之后对数据进行去重</li>
<li>UNION 将两个子查询拼接起来并去重</li>
<li>UNION ALL 将两个子查询拼接起来但不去重</li>
<li>EXCEPT 将第二个字查询中的结果从第一个子查询中去掉</li>
<li>INTERSECT 保留两个子查询中都有的结果并去重</li>
</ul>
<p>排序运算（ ordering operation）：</p>
<p>排序运算跟逻辑关系无关。这是一个 SQL 特有的功能。排序运算不仅在 SQL 语句的最后，而且在 SQL 语句运行的过程中也是最后执行的。使用 ORDER BY 和 OFFSET…FETCH 是保证数据能够按照顺序排列的最有效的方式。其他所有的排序方式都有一定随机性，尽管它们得到的排序结果是可重现的。</p>
<p>OFFSET…SET是一个没有统一确定语法的语句，不同的数据库有不同的表达方式，如 MySQL 和 PostgreSQL 的 LIMIT…OFFSET、SQL Server 和 Sybase 的 TOP…START AT 等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里记录一下对于 SQL 基本操作的理解和优化。</p>]]>
    
    </summary>
    
      <category term="SQL" scheme="http://wdxtub.com/tags/SQL/"/>
    
      <category term="数据库" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CUDA 简明指南]]></title>
    <link href="http://wdxtub.com/2016/03/20/cuda-note/"/>
    <id>http://wdxtub.com/2016/03/20/cuda-note/</id>
    <published>2016-03-20T12:05:36.000Z</published>
    <updated>2016-03-20T13:45:37.000Z</updated>
    <content type="html"><![CDATA[<p>简单的 CUDA 快速入门指南。</p>
<a id="more"></a>
<hr>
<h2 id="CUDA_u67B6_u6784"><a href="#CUDA_u67B6_u6784" class="headerlink" title="CUDA架构"></a>CUDA架构</h2><p>在 CUDA 的架构下,一个程序分为两个部份:host 端和 device 端。Host 端是指在 CPU 上执行 的部份,而 device 端则是在显示芯片上执行的部份。Device 端的程序又称为 “kernel(核心)”。 通常 host 端程序会将数据准备好后,复制到显卡的内存中,再由显示芯片执行 device 端程序,完 成后再由 host 端程序将结果从显卡的内存中取回。</p>
<p>在 CUDA 架构下,显示芯片执行时的最小单位是 thread(线程)。数个 thread 可以组成一个 block(块)。一个 block 中的 thread 能存取同一块共享的内存,而且可以快速进行同步的动作。</p>
<p>每一个 block 所能包含的 thread 数目是有限的。不过,执行相同程序的 block,可以组成 grid(格子)。不同 block 中的 thread 无法存取同一个共享的内存,因此无法直接互通或进行同步。因此, 不同 block 中的 thread 能合作的程度是比较低的。不过,利用这个模式,可以让程序不用担心显示芯片实际上能同时执行的 thread 数目限制。例如,一个具有很少量执行单元的显示芯片,可能会 把各个 block 中的 thread 顺序执行,而非同时执行。不同的 grid 则可以执行不同的程序(即 kernel)。</p>
<p>每个 thread 都有自己的一份 register 和 local memory 的空间。同一个 block 中的每个 thread 则有共享的一份 share memory。此外,所有的 thread(包括不同 block 的 thread)都共享一份 global memory、constant memory、和 texture memory。不同的 grid 则有各自的 global memory、 constant memory 和 texture memory。</p>
<h2 id="u6267_u884C_u6A21_u5F0F"><a href="#u6267_u884C_u6A21_u5F0F" class="headerlink" title="执行模式"></a>执行模式</h2><p>由于显示芯片大量并行计算的特性,它处理一些问题的方式,和一般 CPU 是不同的。主要的特点包括:</p>
<ol>
<li>内存存取 latency 的问题:CPU 通常使用 cache 来减少存取主内存的次数,以避免内存 latency 影响到执行效率。显示芯片则多半没有 cache(或很小),而利用并行化执行的方式来隐藏内存的 latency(即,当第一个 thread 需要等待内存读取结果时,则开始执行第二 个 thread,依此类推)。</li>
<li>分支指令的问题:CPU 通常利用分支预测等方式来减少分支指令造成的 pipeline bubble。显示芯片则多半使用类似处理内存 latency 的方式。不过,通常显示芯片处理分支的效率会比较差</li>
</ol>
<p>最适合利用 CUDA 处理的问题,是可以大量并行化的问题,才能有效隐藏内存的 latency, 并有效利用显示芯片上的大量执行单元。使用 CUDA 时,同时有上千个 thread 在执行是很正常的。 因此,如果不能大量并行化的问题,使用 CUDA 就没办法达到最好的效率了。</p>
<h2 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>streaming processor, sp: 最基本的处理单元，最后具体的指令和任务都是在 sp 上处理的。GPU 进行并行计算，也就是很多个 sp 同时做处理</li>
<li>streaming multiprocessor, sm: 多个 sp 加上存储资源组成一个 sm</li>
<li>warp: GPU 执行程序时的调度单位，目前 CUDA 的 warp 大小为32，同在一个 warp 的线程，以不同数据资源执行相同的指令。</li>
<li>thread, block, grid: 利用 CUDA 进行编程时，一个 grid 分为多个 block，一个 block 分为多个 thread (From a programmer’s perspective)</li>
</ul>
<h3 id="Some_Restrictions_First"><a href="#Some_Restrictions_First" class="headerlink" title="Some Restrictions First"></a>Some Restrictions First</h3><ul>
<li>All threads in a grid execute the same kernel function</li>
<li>A grid is organized as a 2D array of blocks(gridDim.X and gridDim.y)</li>
<li>Each block is organized as 3D array of threads(blockDim.x, blockDim.y, and blockDim.z)</li>
<li>Once a kernel is launched, its dimensions cannot change.</li>
<li>All blocks in a grid have the same dimension</li>
<li>The total size of a block is limited to 512 threads(? I’m not sure?)</li>
<li>Once assigned to an SM, the block must execute in its entirey by the SM.</li>
<li>Thread ID is unique within a block</li>
<li>Using block ID and thread ID we can make unique ID for each thread per kernel</li>
<li>Threads assigned to execution resources on a block-by-block basis</li>
<li>CUDA runtime automatically reduces number of blocks assigned to each SM</li>
<li>until resource usage is under limit.</li>
</ul>
<h3 id="SM_-Streaming_multi-processors_with_multiple_processing_cores"><a href="#SM_-Streaming_multi-processors_with_multiple_processing_cores" class="headerlink" title="SM -Streaming multi-processors with multiple processing cores"></a>SM -Streaming multi-processors with multiple processing cores</h3><ul>
<li>Each SM contains 32 processing cores</li>
<li>Execute in a Single Instruction Multiple Thread (SIMT) fashion</li>
<li>Up to 16 SMs on a card cor a maximum of 512 compute cores</li>
</ul>
<h3 id="Warps"><a href="#Warps" class="headerlink" title="Warps"></a>Warps</h3><ul>
<li>Once a block is assigned to an SM, it is divided into units called warps.</li>
<li>Thread IDs within a warp are consecutive and increasing</li>
<li>Warp 0 starts with Thread ID 0</li>
<li>Warp is unit of thread scheduling in SMs</li>
<li>Partitioning is always the same</li>
<li>DO NOT rely on any ordering between warps</li>
<li>Each warp is executed in a SIMD fashion (all threads within a warp must execute the same instruction at any given time)</li>
<li>Problem: branch divergence</li>
</ul>
<h3 id="Latency_Tolerance"><a href="#Latency_Tolerance" class="headerlink" title="Latency Tolerance"></a>Latency Tolerance</h3><ul>
<li>When an instruction executed by the threads in a warp must wait for the result of a previously initiated long-latency operation, the warp is not selected for execution -&gt; lantency hiding</li>
<li>Priority mechanism used to schedule ready warps</li>
<li>Scheduling does not introduce idle time -&gt; zero-overhead thread scheduling</li>
<li>Scheduling is used for tolerating long-latency operations, such as:</li>
<li>piplined floating-point arithmetic</li>
<li>branch instructions</li>
</ul>
<p>The only safe way to synchronize threads in different blocks is to terminate the kernel and start a new kernel for the acitivities after the synchronization point.</p>
<h2 id="u4EE3_u7801_u76F8_u5173"><a href="#u4EE3_u7801_u76F8_u5173" class="headerlink" title="代码相关"></a>代码相关</h2><ul>
<li>通过 cudaGetDeviceProperties 函数可以取得许多数据，除了装置支持的 CUDA 版本之外, 还有装置的名称、内存的大小、最大的 thread 数目、执行单元的频率等等</li>
<li>需要包含头文件<code>&lt;cuda_runtime.h&gt;</code></li>
<li>编译直接可以<code>nvcc xxx.cu</code></li>
<li>nvcc 是 CUDA 的 compile 工具,它会将 .cu 檔拆解出在 GPU 上执行的部份,及在 host 上执 行的部份,并呼叫适当的程序进行 compile 动作。在 GPU 执行的部份会透过 NVIDIA 提供的 compiler 编译成中介码,而 host 执行的部份则会透过系统上的 C++ compiler 编译(在 Windows 上使用 Visual C++ 而在 Linux 上使用 gcc)</li>
<li>cudaMalloc 和 cudaMemcpy 的用法和一般的 malloc 及 memcpy 类似,不过 cudaMemcpy 则多出一个参数,指示复制内存的方向。从主内存复制到显卡内存,所以使用 cudaMemcpyHostToDevice。如果是从显卡内存到主内存,则使用 cudaMemcpyDeviceToHost。</li>
<li>在 CUDA 中，在函数前面加上 <code>__global__</code> 表示这个函数是要在显示芯片上执行的。</li>
<li>在显卡上执行的程序有一些限制，例如它不能有返回值</li>
<li>让 CUDA 执行函数的语法<ul>
<li><code>function&lt;&lt;&lt;# block, # thread, shared memory size&gt;&gt;&gt;(para....)</code></li>
</ul>
</li>
<li>在 CUDA 中,一般的数据复制到的显卡内存的部份,称为 global memory。这些内存是没有 cache 的,而且,存取 global memory 所需要的时间(即 latency)是非常长的,通常是数百个 cycles。由于我们的程序只有一 个 thread,所以每次它读取 global memory 的内容,就要等到实际读取到数据、累加到 sum 之后, 才能进行下一步。</li>
<li>由于 global memory 并没有 cache,所以要避开巨大的 latency 的方法,就是要利用大量的 threads。假设现在有大量的 threads 在同时执行,那么当一个 thread 读取内存,开始等待结果的 时候,GPU 就可以立刻切换到下一个 thread,并读取下一个内存位置。因此,理想上当 thread 的 数目够多的时候,就可以完全把 global memory 的巨大 latency 隐藏起来了。</li>
<li>显卡上的内存是 DRAM,因此最有效率的存取方式,是以连续的方式存取。前面的程序,虽然看起 来是连续存取内存位置(每个 thread 对一块连续的数字计算平方和),但是我们要考虑到实际上 thread 的执行方式。前面提过,当一个 thread 在等待内存的数据时,GPU 会切换到下一个 thread。 也就是说,实际上执行的顺序是类似 thread0 -&gt; thread1 -&gt; thread2。因此,在同一个 thread 中连续存取内存,在实际执行时反而不是连续了。要让实际执行结果是连续 的存取,我们应该要让 thread 0 读取第一个数字,thread 1 读取第二个数字…依此类推。</li>
<li>在 CUDA 中,thread 是可以分组的,也就是 block。一个 block 中的 thread,具有一个共享的 shared memory,也可以进行同步工作。不同 block 之间的 thread 则不行。在我们的程序中,其 实不太需要进行 thread 的同步动作,因此我们可以使用多个 block 来进一步增加 thread 的数目</li>
<li>利用 <code>__shared__</code> 声明的变量表示这是 shared memory,是一个 block 中每个 thread 都共享的 内存。它会使用在 GPU 上的内存,所以存取的速度相当快,不需要担心 latency 的问题。</li>
<li>`__syncthreads()`` 是一个 CUDA 的内部函数,表示 block 中所有的 thread 都要同步到这个点,才能继续执行。</li>
</ul>
<h2 id="u7ECF_u9A8C_u6280_u5DE7"><a href="#u7ECF_u9A8C_u6280_u5DE7" class="headerlink" title="经验技巧"></a>经验技巧</h2><ul>
<li>利用 <code>threadIdx.x</code> 来分 thread 执行，考虑好邻接性。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>简单的 CUDA 快速入门指南。</p>]]>
    
    </summary>
    
      <category term="CUDA" scheme="http://wdxtub.com/tags/CUDA/"/>
    
      <category term="教程" scheme="http://wdxtub.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 学习笔记]]></title>
    <link href="http://wdxtub.com/2016/03/20/java-note/"/>
    <id>http://wdxtub.com/2016/03/20/java-note/</id>
    <published>2016-03-20T12:00:19.000Z</published>
    <updated>2016-03-20T12:55:05.000Z</updated>
    <content type="html"><![CDATA[<p>这里是我学习 Java 黄皮书时记录整理的笔记，时间比较久远，不保证时效性。</p>
<a id="more"></a>
<hr>
<h2 id="Java_u7A0B_u5E8F_u8BBE_u8BA1_u6982_u8FF0"><a href="#Java_u7A0B_u5E8F_u8BBE_u8BA1_u6982_u8FF0" class="headerlink" title="Java程序设计概述"></a>Java程序设计概述</h2><p>简要地介绍一下Java语言的发展历史。</p>
<p>Java并不只是一种语言，Java是一个完整的平台，有一个庞大的库，其中包含了很多可重用的代码和一个提供诸如安全性、跨操作系统的可一直性以及自动垃圾收集等服务的执行环境。</p>
<p>感兴趣的话可以参见<a href="http://java.sun.com/docs/white/langenv/" target="_blank" rel="external">这里</a></p>
<p><strong>简单性</strong></p>
<p>人们希望构建一个无需社脑的专业训练就可以进行编程的系统，并且要符合当今的标准惯例。Java提出了C++中许多很少使用、难以理解、易混淆的特性。在目前看来，这些特性带来的麻烦远远多于其带来的好处。</p>
<p><code>Java语法是C++语法的一个纯净”版本</code>。没有头文件、指针运算、结构、联合、操作符重载、虚基类等等。</p>
<p>简单的另一个方面是小。Java的目标之一是支持开发能够在小型机器上独立运行的软件。</p>
<p><strong>面向对象</strong></p>
<p>面向对象设计是一种程序设计技术。它将重点放在数据(即对象)和对象的接口上。具体来说，就是关注的是要做出什么，而不是用什么做出来。在本质上，Java的面向对象能力与C++是一样的。</p>
<p>Java与C++的主要不同点在于<code>多继承</code>，在Java中，取而代之的是简单的接口概念，以及Java的<code>元类(metaclass)</code>模型。</p>
<p><strong>网络技能</strong></p>
<p>Java又一个拓展的例程库，用于处理像HTTP和FTP这类的TCP/IP协议。Java应用程序能够通过URL打开和访问网络上的对象，其边界程度就好像访问本地文件一样。</p>
<p><strong>健壮性</strong></p>
<p>Java的设计目标之一在于使得Java编写的程序具有多方面的可靠性。Java和C++的最大不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能性。</p>
<p>Java编译器能够检测许多在其他语言中仅在运行时刻才能够检测出来的问题。</p>
<p><strong>安全性</strong></p>
<p>一开始Java就设计成能够防范各种袭击，其中包括</p>
<ol>
<li>运行时堆栈溢出。如，蠕虫等病毒常用的袭击手段。</li>
<li>在子集的处理空间之外破坏内存</li>
<li>未经授权读写文件。</li>
</ol>
<p><strong>体系结构中立</strong></p>
<p>编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码，只要有Java运行时系统，就可以在许多处理器上运行。Java编译器通过生成与特定的计算机体系结构无关的字节码指令来实现这一特性。精心设计的字节码不仅可以很容易地在任何机器上解释执行，而且还可以迅速地翻译成本地机器的代码。</p>
<p>解释字节码肯定会比全速地运行机器指令慢很多，但是虚拟机有一个选项，可以将使用最贫乏的字节码序列翻译成机器码，这一过程被称为即时编译。这一策略已经证明十分有效。</p>
<p><strong>可移植性</strong></p>
<p>与C和C++不同，Java规范中没有依赖具体实现”的地方，数据类型具有固定的大小，这消除了代码移植时令人头痛的主要问题。</p>
<p><strong>解释型</strong></p>
<p>Java解释器可已在任何移植了解释器的机器上执行Java字节码。由于链接是一个增值而简便的过程，所以开发过程也变得更加快捷</p>
<p><strong>高性能</strong></p>
<p>尽管对解释后的字节码性能已经比较满意，但在有些场合下却需要更加高效的性能。字节码可以(在运行时刻)快速地翻译成运行这个应用程序的特定CPU的机器码。</p>
<p><strong>多线程</strong></p>
<p>多线程可以带来更好的交互响应和实时行为。在不同的机器上，只是调用多线程的代码完全相同；Java把多线程的实现交给了底层的操作系统或线程库来完成。多线程编译的简单性是Java称为颇具魅力的服务器端开发语言的主要原因之一。</p>
<p><strong>动态性</strong></p>
<p>Java与C或C++相比更加具有动态性。它能够适应不断发展的环境。库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。在Java中找出运行时类型信息十分简单。</p>
<p><strong>Java Applet与Internet</strong></p>
<p>这里的想法很简单：用户从Internet下载Java字节码，并在子集的机器上运行。在网页中运行Java程序称为applet。为了使用applet，需要启用Java的Web浏览器执行字节码。由于Sun公司负责发放Java源代码的许可证，并坚持不允许对语言和基本类库的结构做出任何修改，因此，Java的applet应该可以运星在任何启用Java的浏览器上，并且无论何时访问包含applet的网页，都会得到程序的最终版本。</p>
<p>现在，当需要在浏览器中显示动态效果时，大多数网页都直接使用JavaScript或Flash。</p>
<h3 id="Java_u53D1_u5C55_u7B80_u53F2"><a href="#Java_u53D1_u5C55_u7B80_u53F2" class="headerlink" title="Java发展简史"></a>Java发展简史</h3><ul>
<li>1991年，由Patrick Naughton及其伙伴James Gosling带领的Sun公司的工程师小组想要设计一种小型的计算机语言，主要用于像有限电视转换盒这种设备。这种语言的关键是不能与任何特定的体系结构捆绑在一起，这个项目被命名为Green”。</li>
<li>代码短小、紧凑且与平台无关，这些要求促使开发团队联想起很早以前的一种模型，某些Pascal的实现曾经在早期的PC上尝试过这种模型。</li>
<li>不过，Sun公司的人都具有UNIX的应用背景。因此，所开发的语言以C++为基础，而不是Pascal。Gosling把这种语言称为Oak”。Sun公司的人后来发现Oak是一种已有的计算机语言的名字，于是将其改名为Java。</li>
<li>1992年，Green项目发布了它的第一个产品，称之为 <code>*7</code>，具有非常智能的远程控制，但是Sun公司对生产这个产品没有兴趣。</li>
<li>Green项目(这时换了一个新名字──Fist Person”公司)整个1993年和1994年上半年都在苦苦寻求其技术的买家。但是，一个也没有。1994年First Person公司解散了。</li>
<li>1994年中期，Java语言的开发者意识到它们能够建立一个最酷的浏览器。在1995年5月23日的SunWorld展示后，引发了人们延续至今的对Java的狂热追逐。</li>
<li>1996年初，Sun发布了Java的第1个版本。Java1.1弥补了其中的大多部分明显的缺陷。</li>
<li>1998年，Sun发布了Java1.2，后改名为Java2标准版软件开发工具箱1.2版”。</li>
<li>除了标准版之外，还有两个其他的版本，一个是用于手机等嵌入式设备的微型版”，另一个是用于服务器端处理的企业版”。</li>
<li>标准版的1.3和1.4版本对最初的Java 2版本做出了某些改进，拓展了标准类库，提高系统性能。</li>
<li>5.0版是自1.1版依赖第一个对Java语言做出重大改进的版本。</li>
<li>版本6(没有后缀.0)与2006年末发布。这个版本没有对语言方面再进行改进，而是改进了其他性能，并增强了类库。</li>
</ul>
<h3 id="u5173_u4E8EJava_u7684_u5E38_u89C1_u8BEF_u89E3"><a href="#u5173_u4E8EJava_u7684_u5E38_u89C1_u8BEF_u89E3" class="headerlink" title="关于Java的常见误解"></a>关于Java的常见误解</h3><blockquote>
<p>Java是HTML的拓展。</p>
</blockquote>
<p>Java是一种程序设计语言；HTML是一种描述网页结构的方式。</p>
<blockquote>
<p>使用XML，就不需要Java。</p>
</blockquote>
<p>Java是一种程序设计语言；XML是一种描述数据的方式。可以使用任何一种程序设计语言处理XML数据。</p>
<blockquote>
<p>Java是一种非常容易学习的程序设计语言。</p>
</blockquote>
<p>像Java这种功能强大的语言大都不太容易学习。</p>
<blockquote>
<p>Java将成为适用于所有平台的通用性编程语言。</p>
</blockquote>
<p>很多在桌面计算机上已经工作良好的应用程序，通常是用C或C++编写的，用Java重写一次似乎对于用户来说没有什么特别的好处。</p>
<blockquote>
<p>Java只不过是另外一种程序设计语言。</p>
</blockquote>
<p>程序设计语言的成功更多地取决于其支撑系统的能力，而不是优美的语法。Java的成功源于其类库能够让人们轻松地完成原本有一定难度的事情</p>
<blockquote>
<p>现在有了C#，Java过时了。</p>
</blockquote>
<p>C#借鉴了Java许多好的思想，例如：清晰的语言结构、虚拟机和垃圾收集器。最重要的是安全性和平台无关性。但是从求职广告判定，Java仍然是大多数开发者选择的语言。</p>
<blockquote>
<p>Java有专利，应该避免使用。</p>
</blockquote>
<p>Sun声称Java未来的版本将在General Public License下可用。Linux使用的是同一个开放源代码许可。开放源代码会使Java的生存期延长很多年。</p>
<blockquote>
<p>Java是解释型的，因此对于关键的应用程序速度太慢了。</p>
</blockquote>
<p>Java所写的代码某些程度上其运行速度与C++相差无几。Java有一些C++没有的额外开销。但是，硬件的发展很快的。</p>
<blockquote>
<p>所有的Java程序都是在网页中运行的。</p>
</blockquote>
<p>所有的Java applet都在网页浏览器中运行的。然而，大多数Java程序是运行在Web浏览器之外的独立应用程序。</p>
<blockquote>
<p>Java程序是主要的安全风险。</p>
</blockquote>
<p>相当可笑，不解释。</p>
<blockquote>
<p>JavaScript是Java的简易版。</p>
</blockquote>
<p>JavaScript是一种在网页中使用的脚本语言。JavaScript的语言类似Java，除此之外，两者无任何关系。额，名字有点像。更多可查阅<a href="http://www.apl.jhu.edu/~hall/java/FAQs-and-Tutorials.html" target="_blank" rel="external">Java FAQ(Java Frequently Question)</a></p>
<h2 id="Java_u57FA_u672C_u7684_u7A0B_u5E8F_u8BBE_u8BA1_u7ED3_u6784"><a href="#Java_u57FA_u672C_u7684_u7A0B_u5E8F_u8BBE_u8BA1_u7ED3_u6784" class="headerlink" title="Java基本的程序设计结构"></a>Java基本的程序设计结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstSample</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(Hello! I’m wdxtub”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是一个最简单的Java应用程序，但是所有的Java应用程序都具有这种结构。</p>
<p>Java对<code>大小写敏感</code>。关键字<code>public</code>称为<code>访问修饰符(access modifier)</code>，用于控制程序的其他部分对这段代码的访问级别。</p>
<p><code>类</code>是构建所有Java应用程序和applet的构建块。Java应用程序中的全部内容都必须放置在类中。关键字class后面紧跟类名。Java中定义类名的规则很宽松。名字必须以<code>字母开头</code>，后面可以跟字母和数字的任意组合。长度基本上没有限制。但是不能使用Java的保留字。</p>
<p>源代码的文件名必须与公有类的名字相同，并用<code>.java</code>作为扩展名。</p>
<p>运行编译程序时，Java 虚拟机将从指定类中的<code>main</code>方法开始执行，并且<code>main</code>方法必须声明为<code>public</code>。</p>
<p>注释有三种方法：</p>
<ol>
<li><code>//</code> 单行的注释，内容从 <code>//</code> 开始到本行结尾</li>
<li><code>/*...*/</code> 长篇的注释</li>
<li><code>/**...*/</code> 用于自动生成文档</li>
</ol>
<p>Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。Java中一共有8种基本类型(primitive type)。其中4种整型，2种浮点类型，1种char型，1种boolean类型。</p>
<p>整型表示没有小数部分的数值，可以是复数。分别为<code>int(4字节)</code>，<code>short(2字节)</code>，<code>long(8字节)</code>，<code>byte(1字节)</code>。由于Java程序必须保证在所有机器都能得到相同的运行结果，所以每一种数据类型的取值范围必须固定。</p>
<p>浮点类型用于表示有小数部分的数值。分别是<code>float(4字节，有效位数6～7位)</code>，<code>double(8字节，有效位数15位)</code>。</p>
<p><code>double</code>表示这种类型的数值精度是<code>float</code>的两倍。绝大部分程序都采用<code>double</code>类型。<code>float</code>类型的数值有一个后缀F，没有<code>后缀F</code>的浮点数值默认为<code>double</code>类型。</p>
<p>三个特殊的浮点数值：</p>
<ul>
<li>正无穷大</li>
<li>负无穷大</li>
<li>NaN(不是一个数字，Not a Number)</li>
</ul>
<p><code>char</code>类型用于表示单个字符。通常用来表示字符常量。</p>
<p><strong>我们强烈建议不要在程序中使用char类型，除非确实需要对UTF-16代码单元进行操作。最好将需要处理的字符串用抽象数据类型表示。</strong></p>
<p><code>boolean(布尔)</code>类型有两个值：<code>false</code>和<code>true</code>，用来判定逻辑条件。整型和布尔值之间不能进行相互转换。</p>
<p>每一个变量属于一种类型(type)。声明变量时，变量所属的类型位于变量名之前，每个声明以分号结束。</p>
<p>可以在一行中声明多个变量，不过不提倡使用这种风格。逐一声明每一个变量可以提高程序的可读性。</p>
<p>声明一个变量之后，必须用赋值语句对变量进行显式的初始化，千万不要使用未被初始化的变量。可以将声明放在代码中的任何地方，变量的声明应尽可能地靠近变量第一次使用的地方。</p>
<p>利用关键字final声明常量，表示这个变量只能被赋值一次。一旦被赋值后就不能再更改了。习惯上，常量名使用大写。</p>
<p>若希望某个常量可以在一个类中的多个方法中使用，通常将这些常量称为类常量，使用static final设置。</p>
<p>类常量的定义位于main方法的外部，所以在同一个类的其他方法中也可以使用这个常量。</p>
<h3 id="u8FD0_u7B97_u7B26"><a href="#u8FD0_u7B97_u7B26" class="headerlink" title="运算符"></a>运算符</h3><p>Java程序设计语言承认了最优性能与理想结果之间存在的冲突，并给予了改进。在默认情况下，虚拟机设计者允许中间结果采用拓展的精度。但对于strictfp关键字标记的方法必须使用严格的浮点计算来产生理想的结果。</p>
<p>自增运算符与自减运算符 前缀方式<code>先进行加一或减一</code>的运算，后缀方式则使用变量原来的值。建议不要在其他表达式的内部使用++，使人迷惑，产生bug。</p>
<p>关系运算符与boolean运算符，其中<code>==</code>，<code>!=</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code>，<code>||</code>，<code>&amp;&amp;</code>均与C++一致。</p>
<p>位运算符</p>
<ul>
<li><code>&amp;</code>(与)，<code>|</code>(或)，<code>^</code>(异或)，<code>-</code>(非)</li>
<li><code>&gt;&gt;</code>和<code>&lt;&lt;</code>运算符进行右移或左移操作，屏蔽某些位。</li>
<li><code>&gt;&gt;&gt;</code>运算符用0填充高位；<code>&gt;&gt;</code>运算符用符号填充高位，没有<code>&lt;&lt;&lt;</code>运算符。</li>
</ul>
<p>在Math类中，包含各种的数学函数。若得到一个完全可预测的结果比运行速度更重要的话，就应该使用StrictMath类。</p>
<p>整型转换为float或double型很有可能损失精度。</p>
<p>在圆括号中给出想要转换的目标类型，后面紧跟待转换的变量名，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">9.998</span>;</span><br><span class="line"><span class="keyword">int</span> nx = (<span class="keyword">int</span>)x;</span><br></pre></td></tr></table></figure>
<p>若想进行四舍五入计算，使用 <code>Math.round</code> 方法。</p>
<p>括号与运算符级别与正常情况下一致。少数结合性是从右向左的。</p>
<p>枚举类型包括有限个命名的值。</p>
<p>如 <code>enum Size{SMALL,MEDIUM,LARGE,EXTRA_LARGE}</code>。</p>
<p>Java字符串就是Unicode字符序列。</p>
<p>String类的substring方法可以从一个较大的字符串提取一个子串，容易计算子串长度，语句：<code>s.substring(a,b)</code>，长度即为<code>b-a</code>。</p>
<p>允许使用<code>+</code>号连接(拼接)两个字符串。</p>
<p><code>String</code>类没有提供用于修改字符串的方法，所以在Java文档中将String类对象称为<code>不可变字符串</code>。</p>
<p>不可变字符又一个优点：编译器可以让<code>字符串共享</code>。Java的设计者认为共享带来的高效率远远胜过于提取。</p>
<p>使用<code>equals</code>方法检测两个字符串是否相等。<code>s.equals(t)</code>，若 <code>s</code> 与 <code>t</code> 相等，则返回<code>true</code>，否则返回<code>false</code>。<code>s</code> 和 <code>t</code> 可以是字符串变量也可以是字符串常量，如<code>”Hello”.equals(greeting)</code>。</p>
<p>如果向不区分大小写，使用<code>equalsIgnoreCase</code>方法。一定不能使用 <code>==</code> 运算符检测两个字符串是否相等！这个运算符只能够确定两个字符是否放置在同一个位置上。</p>
<p>大多数的常用Unicode字符使用一个代码单元就可以表示，而辅助字符则需要一对代码来表示。</p>
<p><code>s.charAt(n)</code>将返回位置 <code>n</code> 的代码单元，<code>n</code>介于<code>0～s.length()-1</code>之间。对于那些一对代码单元表示的字符，就会出现问题。而<code>codePointAt</code>可以解决这个问题。</p>
<p>Java中的String类包含了50多个方法并且绝大多数都很有用。</p>
<p><strong>java.lang.string</strong></p>
<ul>
<li><code>char charAt( int index )</code><ul>
<li>返回给定位置的代码单元。除非对底层的代码单元感兴趣，否则不需要调用这个方法。</li>
</ul>
</li>
<li><code>int codePointAt( int index )</code><ul>
<li>返回从给定位置开始或结束的代码点。</li>
</ul>
</li>
<li><code>int offsetByCodePoints( int startIndex, int cpCount )</code><ul>
<li>返回从 startIndex 代码点开始，位移 cpCount 后的代码点索引。</li>
</ul>
</li>
<li><code>int compareTo( String other )</code><ul>
<li>按照字典顺序，如果字符串位于other之前，返回一个负数；位于other之后，返回一个正数；如果两个字符串相等，返回0。</li>
</ul>
</li>
<li><code>boolean endsWith( String suffix )</code><ul>
<li>如果字符串以suffix结尾，返回true。</li>
</ul>
</li>
<li><code>boolean equals( Object other )</code><ul>
<li>如果字符串以other相等，返回true。</li>
</ul>
</li>
<li><code>boolean equalsIgnoreCase( String other )</code><ul>
<li>如果字符串与other相等(忽略大小写)，返回true。</li>
</ul>
</li>
<li><code>int indexOf( String str )</code></li>
<li><code>int indexOf( String, int fromIndex )</code></li>
<li><code>int indexOf( int cp )</code></li>
<li><code>int indexOf( int cp, int fromIndex )</code><ul>
<li>返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromIndex开始计算。如果在原始串中不存在str，返回-1。</li>
</ul>
</li>
<li><code>int lastIndexOf( String str )</code></li>
<li><code>int lastIndexOf( String str, int  fromIndex )</code></li>
<li><code>int lastIndexOf( int cp )</code></li>
<li><code>int lastIndexOf( int cp, int fromIndex )</code><ul>
<li>返回与字符串str或代码点cp匹配的最后一个子串的开始位置。这个位置从原始串尾端或fromIndex开始计算。</li>
</ul>
</li>
<li><code>int length()</code><ul>
<li>返回字符串的长度。</li>
</ul>
</li>
<li><code>int codePointCount( int startIndex, int endIndex)</code><ul>
<li>返回startIndex和endIndex-1之间的代码点数量。没有配成对的代用字符将计入代码点。</li>
</ul>
</li>
<li><code>String replace(CharSequence oldString, CharSequence newString)</code><ul>
<li>返回一个新字符串。这个字符串用newString代替原始字符串中的所有oldString。可以用String或StringBuilder对象作为CharSequence参数。</li>
</ul>
</li>
<li><code>boolean startsWith( String prefix )</code><ul>
<li>如果字符串以prefix字符串开始，返回true。</li>
</ul>
</li>
<li><code>String substring( int beginIndex )</code></li>
<li><code>String substring( int beginIndex, int  endIndex )</code><ul>
<li>返回一个新字符串。这个字符串包含原始字符串中从beginIndex到串尾或endIndex-1的所有代码点。</li>
</ul>
</li>
<li><code>String toLowerCase()</code><ul>
<li>返回一个新字符串，这个字符串将原始字符串中的所有大写字母改成了小写字母。</li>
</ul>
</li>
<li><code>String toUpperCase()</code><ul>
<li>返回一个新字符串，这个字符串将原始字符串中的所有小写字母改成了大写字母。</li>
</ul>
</li>
<li><code>String trim()</code><ul>
<li>返回一个新字符串。这个字符串将山除了原始字符串头部和尾部的空格。</li>
</ul>
</li>
</ul>
<p>如果需要用许多小段的字符串构建一个字符串，那么应该按照下列步骤进行。首先，构建一个空的字符串构建器：</p>
<p><code>StringBuilder builder = new StringBuilder();</code></p>
<p>当每次需要添加一部分内容时，就调用append方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">builder.append(ch); <span class="comment">// appends a single character</span></span><br><span class="line">builder.append(str);    <span class="comment">// appends a string</span></span><br></pre></td></tr></table></figure>
<p><strong>java.lang.StringBuilder</strong></p>
<ul>
<li><code>StringBuilder()</code><ul>
<li>构造一个空的字符串构建器。</li>
</ul>
</li>
<li><code>int length()</code><ul>
<li>返回构建器或缓冲器中的代码单元数量。</li>
</ul>
</li>
<li><code>StringBuilder append( String str )</code><ul>
<li>追加一个字符串并返回this。</li>
</ul>
</li>
<li><code>StringBuilder append( char c )</code><ul>
<li>追加一个代码单元并返回this。</li>
</ul>
</li>
<li><code>StringBuilder appendCodePoint( int cp )</code><ul>
<li>追加一个代码点，并将其转换为一个或两个代码单元并返回this。</li>
</ul>
</li>
<li><code>void setCharAt( int i,char c )</code><ul>
<li>将第 i 个代码单元设置为 c。</li>
</ul>
</li>
<li><code>StringBuilder insert( int offset,String str )</code><ul>
<li>在offset位置插入一个字符串并返回this。</li>
</ul>
</li>
<li><code>StringBuilder insert( int offset,Char c )</code><ul>
<li>在offset位置插入一个代码单元并返回this。</li>
</ul>
</li>
<li><code>StringBuilder delete( int startIndex,int endIndex )</code><ul>
<li>删除偏移量从startIndex到-endIndex-1的代码单元并返回this。</li>
</ul>
</li>
<li><code>String toString()</code><ul>
<li>返回一个与构建器或缓冲器内容相同的字符串。</li>
</ul>
</li>
</ul>
<h3 id="u8F93_u5165_u8F93_u51FA"><a href="#u8F93_u5165_u8F93_u51FA" class="headerlink" title="输入输出"></a>输入输出</h3><p>要想通过控制台进行输入，首先需要构造一个<code>Scanner</code>对象，并与标准输入流”<code>System.in</code>关联。</p>
<pre><code>Scanner in = new Scanner(System.in);
</code></pre><p>现在就可以使用<code>Scanner</code>类的各种方法实现输入操作。例如可以用<code>nextLine</code>方法将输入一行(包括输入行中有空格的情况)，若想读取一个单词(以空格作为分隔符)，就调用next方法；想读取一个整数，就调用<code>nextInt</code>方法；想读取一个浮点数，就调用<code>nextDouble</code>方法。</p>
<pre><code>String name = in.nextLine();
String firstName = in.next();
int age = in.nextInt();
double salary = in.nextDouble();
</code></pre><p>最后在程序最开始加上 <code>import java.util.*;</code></p>
<p>当使用的类不是定义在基本<code>java.lang</code>包中时，一定要使用<code>import</code>指示将相应的包加载进来。</p>
<p><strong>java.util.Scanner</strong></p>
<ul>
<li><code>Scanner( InputStream in)</code><ul>
<li>用给定的输入流创建一个Scanner对象。</li>
</ul>
</li>
<li><code>String nextLine()</code><ul>
<li>读取输入的下一行内容。</li>
</ul>
</li>
<li><code>String next()</code><ul>
<li>读取输入的下一个单词(以空格作为分隔符)</li>
</ul>
</li>
<li><code>int nextInt()</code></li>
<li><code>double nextDouble()</code><ul>
<li>读取并转换下一个表示整数或浮点数的字符序列。</li>
</ul>
</li>
<li><code>boolean hasNext()</code><ul>
<li>检测输入中是否还有其他单词。</li>
</ul>
</li>
<li><code>boolean hasNextInt()</code></li>
<li><code>boolean hasNextDouble()</code><ul>
<li>检测是否还有表示整数或浮点数的下一个字符序列。</li>
</ul>
</li>
<li><code>Scanner( File f )</code><ul>
<li>构造一个从给定文件读取数据的Scanner。</li>
</ul>
</li>
<li><code>Scanner( String data)</code><ul>
<li>构造一个从给定字符串读取数据的Scanner。</li>
</ul>
</li>
</ul>
<p><strong>java.util.System</strong></p>
<ul>
<li><code>static Console console()</code><ul>
<li>如果有可能进行交互操作，就通过控制台窗口为交互的用户返回一个Console对象，否则返回null。</li>
</ul>
</li>
</ul>
<p><strong>java.io.Console</strong></p>
<ul>
<li><code>static char[] readPassword( String prompt, Object...args )</code></li>
<li><code>static String readLine( String prompt, Object...args)</code><ul>
<li>显示字符串prompt并且读取用户输入，直到输入行结束。args参数可以用来提供输入格式。</li>
</ul>
</li>
</ul>
<p>格式化输出沿用了C语言库函数中的printf方法，另外还可以给出控制格式化输出的各种标志</p>
<p>可以采用一个格式化的字符串指出要被格式化的参数索引。紧跟在%后面，并以$终止。还可以选择使用&lt;标志。它指示前面格式说明中的参数将再次使用。</p>
<p>文件输入与输出。要想对文件进行读取，就需要一个用<code>File</code>对象构造一个<code>Scanner</code>对象，例如：<code>Scanner in = new Scanner(new File(myfile.txt”));</code></p>
<p>如果文件名中包含反斜杠符号，就要记住在每个反斜杠之前再价一个额外的反斜杠：<code>c:\\mydirectory\\myfile.txt”</code>。</p>
<p>要想写入文件，就需要构造一个<code>PrintWriter</code>对象。在构造器中，主需要提供文件名：<code>PrintWriter out = new PrintWriter(myfile.txt”);</code></p>
<p>可以向输出到<code>System.out</code>一样使用<code>print</code>、<code>pinrtln</code>以及<code>printf</code>命令。</p>
<p><strong>java.io.PrintWriter</strong></p>
<ul>
<li><code>PrintWriter( File f)</code><ul>
<li>构造一个将数据写入给定文件的PrintWriter。</li>
</ul>
</li>
<li><code>PrintWriter( String fileName )</code><ul>
<li>构造一个将数据写入文件的PrintWriter。文件名由参数指定。</li>
</ul>
</li>
</ul>
<p><strong>java.io.File</strong></p>
<ul>
<li><code>File( String fileName )</code></li>
</ul>
<p>用给定的文件名，构造一个描述文件的File对象。注意这个文件当前不必存在。</p>
<p>有可能出发多个<code>case</code>分支。如果在<code>case</code>分支语句的末尾没有<code>break</code>语句，那么就会接着执行下一个<code>case</code>分支语句。这种情况相当危险，常常会引发错误。为此，尽量不要使用<code>switch</code>语句。</p>
<p>当在<code>switch</code>语句中使用枚举常量时，不必在每个标签中指明枚举名，可以由<code>switch</code>的表达式确定。例如：</p>
<pre><code>Size sz = {SMALL,LARGE,...}
switch (sz){
    case SMALL: // no need to use Size.SMALL
    ...
    break;
}
</code></pre><p>无限制地使用goto语句确实是导致错误的根源，但偶尔地使用goto跳出循环是有益处的，Java中增加了一条带标签的break以支持这种跳出。</p>
<p>请注意，标签必须放在希望跳出的最外层循环之前，必须紧跟一个冒号。如下所示：</p>
<pre><code>int n;
read_data:
while(...){ // this loop statement is tagged with the label
    ...
    for(...){ // this inner loop is not labeled
        if(...) break read_data; // break out of read_data loop
    }
}
// this statement is executed immediately after the labeled break

if(....){.....}
</code></pre><p>即可以直接跳出所标记的循环，继续执行下面的语句。</p>
<p>带标签的continue将跳到与标签匹配的循环首部。</p>
<h3 id="u5927_u6570_u503C"><a href="#u5927_u6570_u503C" class="headerlink" title="大数值"></a>大数值</h3><p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用<code>java.math</code>包中的两个很有用的类：<code>BigInterger</code>(任意精度的整数运算)和<code>BigDecimal</code>(任意精度的浮点数运算)。</p>
<p>使用静态的<code>valueOf</code>方法可以将普通的数值转换为大数值：</p>
<pre><code>BigInterger a = BigInteger.valueOf(100);
</code></pre><p>但是不能使用算数运算符，有专门的运算方法。</p>
<p><strong>java.math.BigInterger</strong></p>
<ul>
<li><code>BigInteger add( BigInteger other )</code></li>
<li><code>BigInteger subtract( BigInteger other)</code></li>
<li><code>BigInteger multiply( BigInteger other)</code></li>
<li><code>BigInteger divide( BigInteger other)</code></li>
<li><code>BigInteger mod( BigInteger other)</code><ul>
<li>返回这个大整数和另一个大整数other的和、差、积、商和余数。</li>
</ul>
</li>
<li><code>int compareTo( BigInteger other )</code><ul>
<li>如果这个大整数和另一个大整数other相等，返回0；如果这个大整数小于另一个大整数，返回负数；大于的话，返回正数。</li>
</ul>
</li>
<li><code>static BigInteger valueOf(long x)</code><ul>
<li>返回值等于x的大整数。</li>
</ul>
</li>
</ul>
<p><strong>java.math.BiDecimal</strong></p>
<ul>
<li><code>BigDecimal add( BigDecimal other )</code></li>
<li><code>BigDecimal subtract( BigDecimal other)</code></li>
<li><code>BigDecimal multiply( BigDecimal other)</code></li>
<li><code>BigDecimal divide( BigDecimal other, RoundingMode mode)</code><ul>
<li>返回这个大实数和另一个大实数other的和、差、积、商和余数。要想计算商，必须给出舍入方式(rounding mode)。RoundingMode.HALF_UP是四舍五入方式，其他的舍入方式参见API文档。</li>
</ul>
</li>
<li><code>int compareTo( BigDecimal other )</code><ul>
<li>如果这个大实数和另一个大实数other相等，返回0；如果这个大实数小于另一个大实数，返回负数；大于的话，返回正数。</li>
</ul>
</li>
<li><code>static BigDecimal valueOf( long x)</code></li>
<li><code>static BigDecimal valueOf( long x, int scale)</code><ul>
<li>返回值等于x或x/10scale的一个大实数。</li>
</ul>
</li>
</ul>
<h3 id="u6570_u7EC4"><a href="#u6570_u7EC4" class="headerlink" title="数组"></a>数组</h3><p>应该使用<code>new</code>运算符创建数组：<code>int[] a = new int[100];</code></p>
<p>要想获得数组中的元素个数，可以使用<code>array.length</code>。</p>
<p>一旦创建了数组，就不能再改变它的大小。如果经常需要在运行过程中拓展数组的大小，就应该使用另一种数据结构─数组列表(array list)。</p>
<p>Java SE 5.0增加了一种功能很强的循环结构，可以用来一次处理数组中的每个元素(其他类型的元素集合亦可)而不必为指定下标值而分心。</p>
<p>语句格式为：<code>for( variable : collection ) statement</code>    例如：</p>
<pre><code>for( int element : a )
    System.out.println( element );
</code></pre><p>就可以打印数组a的每一个元素。</p>
<p>有个更加简单的方式打印数组中的所有值，即利用Arrays类的toString方法。调用<code>Arrays.toString(a)</code>，返回一个包含数组元素的字符串，这些元素被放置在括号内，并用逗号分隔。</p>
<p>提供一种创建数组对象并同时赋予初始值的简化书写形式，如：</p>
<pre><code>int[] smallPrimes = { 2, 3, 5, 6};
</code></pre><p>使用这种语句时就不用调用<code>new</code>。</p>
<p>还可以初始化一个匿名的数组：<code>new int[]{ 11, 12, 14, 15};</code> 这种表示法将创建一个新数组并利用括号中提供的值进行初始化，数组的大小就是初始值的个数。使用这种语法形式可已在不创建新变量的情况下重新初始化一个数组。例如：<code>smallPrimes = new int[]{ 11, 12, 14, 15};</code></p>
<p>允许将一个数组变量拷贝给另一个数组变量。这是，两个变量就引用同一个数组：<code>int[] luckyNumbers = smallPrimes;</code></p>
<p>如果希望将一个数组的所有值拷贝到一个新的数组中，就要使用<code>Arrays</code>类的<code>copyOf</code>方法：<code>int[] copiedLuckyNumbers = Arrays.copyOf( luckyNumbers, luckyNumbers.length );</code></p>
<p>第二个参数是新数组的长度。这个方法通常用来增加数组的大小：<code>luckyNumbers = Arrays.copyOf( luckyNumbers, 2 * luckyNumbers.length);</code></p>
<p>如果数组元素是数值型，那么多余的元素将被赋值为<code>0</code>；如果数组元素是是布尔型，则将赋值为<code>false</code>。如果长度小于原始数组的长度，则只拷贝最前面的数据元素。</p>
<p>在Java SE 6之前，用<code>System</code>类的<code>arraycopy</code>方法将一个数组的元素拷贝到另一个数组中。调用这个方法的格式为：</p>
<pre><code>System.arraycopy( from, fromIndex, to, toIndex, count);
</code></pre><p>数组<code>to</code>必须有足够的空间存放拷贝的元素。意思为，从<code>from</code>数组的下标为<code>fromIndex</code>元素开始，拷贝<code>count</code>个元素到<code>to</code>数组，从<code>to</code>数组的下标为<code>toIndex</code>的元素开始变成被拷贝过来的元素。</p>
<p>可以使用Arrays类中的sort方法对数值型数组进行排序：</p>
<pre><code>int[] a = new int[1000];
...
</code></pre><p><code>Arrays.sort(a);</code> 这个方法使用了优化的快速排序算法，效率是比较高的。</p>
<p><strong>java.util.Arrays</strong></p>
<ul>
<li><code>static String toString( type[] a )</code><ul>
<li>返回包含a中数据元素的字符串，这些数据元素被放在括号内，并用逗号分隔。</li>
</ul>
</li>
<li><code>static type copyOf( type[] a, int length )</code></li>
<li><code>static type copyOf( type[] a, int start, int end )</code><ul>
<li>返回与a类型相同的一个数组，其长度为length或者 end-start，数组元素为a的值。</li>
</ul>
</li>
<li><code>static void sort( type[] a )</code><ul>
<li>采用优化的快速排序算法对数组进行排序。</li>
</ul>
</li>
<li><code>static int binarySearch( type[] a, type v)</code></li>
<li><code>static int binarySearch( type[] a, int start, int end, type v )</code><ul>
<li>采用二分搜索法查找值v。如果查找成功，则返回相应的下标值；否则，返回一个负数值r。-r-1是为保持a有序v应插入的位置。</li>
</ul>
</li>
<li><code>static void fill( type[] a, type v )</code><ul>
<li>将数组的所有数据元素值设置为v。</li>
</ul>
</li>
<li><code>static boolean equals( type[] a, type[] b)</code><ul>
<li>如果两个数组大小相同，并且下标相同的元素都对应相等，返回true。</li>
</ul>
</li>
<li><code>static int hashCode( type[] a )</code><ul>
<li>计算数组a的散列码。可以是int、long、short、char、byte、boolean、float或double的数组。</li>
</ul>
</li>
</ul>
<p><strong>java.lang.System</strong></p>
<ul>
<li><code>static void arraycopy( Object from, int fromIndex, Object to, int toIndex, int count )</code><ul>
<li>将第一个数组中的元素拷贝到第二个数组中。</li>
</ul>
</li>
</ul>
<p>多维数组使用<code>new</code>进行初始化：<code>balances = new double[NSIZE][MSIZE];</code></p>
<p>或者是：<code>int[][] magicSquare = { {16, 3, 2, 13},{5, 10, 11,8} };</code></p>
<p>一旦数组被初始化，就可以利用两个方括号访问每个元素。</p>
<p><code>for each</code>循环语句不能自动处理二维数组的每一个元素。它是按照行，也就是一维数组处理的。要想访问二维数组a的所有元素，需要使用两个嵌套的循环：</p>
<pre><code>for( double[] row: a )
    for( double value : row )
        do something with value
</code></pre><p>想要快速打印一个二维数组的数据元素列表，可以调用：<code>System.out.println( Arrays.deepToString(a));</code></p>
<h2 id="u5BF9_u8C61_u4E0E_u7C7B"><a href="#u5BF9_u8C61_u4E0E_u7C7B" class="headerlink" title="对象与类"></a>对象与类</h2><p>数据被放在第一位，然后再考虑操作数据的算法。</p>
<p><code>类(class)</code>是构造对象的模板或蓝图。由类<code>构造(construct)</code>对象的过程称为创建类的<code>实例(instance)</code>。</p>
<p><code>封装(encapsulation，有时称为数据隐藏)</code>是与对象功能有关的一个重要概念。对象中的数据称为<code>实例域(instance fields)</code>，操纵数据的过程称为<code>方法(method)</code>。对于每个特定的类实例(对象)都有一组特定的实例域值。这些值的集合就是这个对象的当前<code>状态(state)</code>。无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。</p>
<p>封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。</p>
<p>在对于一个已有的类扩展时，这个扩展后的新类具有所拓展的类的全部属性和方法。在新类中，只需要提供哪些仅适用于这个类的新方法和数据域就可以了。</p>
<p>要想使用OOP，一定要清楚对象的三个主要特性：</p>
<ol>
<li>对象的行为(behavior)──可以对对象施加哪些操作，或可以对对象施加哪些方法？</li>
<li>对象的状态(state)──当施加那些方法时，对象如何响应？</li>
<li>对象标识(identity)──如何辨别具有相同行为与状态的不同对象？</li>
</ol>
<p>此外，每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变，但这种改变不会是自发的。</p>
<p>对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份(identity)。需要注意，作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。对象的这些关键特性在彼此之间相互影响着。</p>
<p>识别类的简单规则是在分析问题的过程中寻找名词，而方法对应动词。在创建类的时候，哪些名词和动词是重要的完全取决于个人的开发经验。</p>
<p>在类之间最常见的关系有</p>
<ul>
<li>依赖(uses-a)</li>
<li>聚合(has-a)</li>
<li>继承(is-a)</li>
</ul>
<p><code>依赖(dependence)</code>，是一种最明显的、最常见的关系。如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。应该尽可能将相互依赖的类减至最少，即类之间的耦合度最小。</p>
<p><code>聚合(aggregation)</code>，是一种具体且易于理解的关系。集合意味着类A的对象包含类B的对象。</p>
<p><code>继承(inheritance)</code>，是一种表示特殊与一般的关系。一般而言，如果类A扩展类B，类A不但包含从类B继承的方法，还会拥有一些额外的功能。</p>
<p>要想使用对象，就必须首先构造对象，并指定其初状态。然后，对对象施加方法。在Java程序设计语言中，使用<code>构造器(constructor)</code>构造新实例。</p>
<p>构造器的名字应与类名相同，并且使用<code>new</code>操作符进行构造；也可以将这个对象传递给一个方法；另外<code>Date</code>类中有一个<code>toString</code>方法，返回日期的字符串描述，如下</p>
<pre><code>new Date(); // 被初始化为当前的日期和时间
System.out.println(new Date());
String s = new Date().toString();
</code></pre><p>如果希望构造的对象可以多次使用，就要把对象放在一个变量中：</p>
<pre><code>Date birthday = new Date();
</code></pre><p>可以让一个变量引用一个已存在的变量：<code>Date deadline = birthday;</code>则这两个变量引用同一个对象。</p>
<p>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用。可以显式地将对象变量设置为<code>null</code>，表明这个对象变量目前没有任何引用对象：<code>deadline = null;</code>变量不会自动初始化为<code>null</code>，而必须通过调用<code>new</code>或将它们设置为<code>null</code>进行初始化。</p>
<p>Date类只提供了少量的方法用来比较两个时间点。例如<code>before</code>和<code>after</code>方法分别表示一个时间点是否早于另一个时间点，或者晚于另一个时间点。</p>
<pre><code>if( today.before(birthday) )
    System.out.println(Still time to shop for a gift.”);
</code></pre><p><code>GregorianCalendar</code>类所包含的方法比<code>Date</code>类多得多，并且封装了实例域。</p>
<p>对实例域作出修改的方法被称为<code>更改器方法(mutator method)</code>，仅访问实例域而不进行修改的方法称为<code>访问器方法(accessor method)</code>。</p>
<p>通常的习惯是在访问器方法前面加上前缀<code>get</code>，在更改器方法前面加上前缀<code>set</code>。</p>
<p><strong>java.util.GregorianCalendar</strong></p>
<ul>
<li><code>GregorianCalendar()</code><ul>
<li>构造一个日历对象，用来表示默认地区、默认时区的当前时间。</li>
</ul>
</li>
<li><code>GregorianCalendar( int year, int month, int day )</code></li>
<li><code>GregorianCalendar( int year, int month, int day, int hour, int minutes, int seconds )</code><ul>
<li>用给定的日期和时间构造一个Gregorian日历对象。</li>
</ul>
</li>
<li><code>int get( int field )</code><ul>
<li>返回给定区域的值</li>
</ul>
</li>
<li><code>void set( int field, int value )</code></li>
<li><code>void set( int year, int month, int day )</code></li>
<li><code>void set( int year, int month, int day, int hour, int minutes, int seconds )</code><ul>
<li>将日期域和时间域设置为新值。</li>
</ul>
</li>
<li><code>void add( int field, int amount)</code><ul>
<li>对给定的时间域增加指定数量的时间。</li>
</ul>
</li>
<li><code>int getFistDayOfWeek()</code><ul>
<li>获得当前用户所在地区，一个星期中的第一天。</li>
</ul>
</li>
<li><code>void setTime( Date time )</code><ul>
<li>将日历设置为指定的时间点。</li>
</ul>
</li>
<li><code>Date getTime()</code><ul>
<li>获得这个日历对象当前值所表达的时间点</li>
</ul>
</li>
</ul>
<p><strong>java.text.DateFormatSymbols</strong></p>
<ul>
<li><code>String[] getShortWeekdays()</code></li>
<li><code>String[] getShortMonths()</code></li>
<li><code>String[] getWeekdays()</code></li>
<li><code>String[] getMonths()</code><ul>
<li>获得当前地区的星期几或月份的名称。利用Calendar的星期和月份常量作为数组索引值。</li>
</ul>
</li>
</ul>
<h3 id="u7528_u6237_u81EA_u5B9A_u4E49_u7C7B"><a href="#u7528_u6237_u81EA_u5B9A_u4E49_u7C7B" class="headerlink" title="用户自定义类"></a>用户自定义类</h3><p>复杂应用程序需要各种<code>主力类(workhorse class)</code>。通常这些类没有main方法，而却有自定义的实例域和实例方法。要想创建一个完整的程序，应该将若干类组合在一起，其中只有一个类有main方法。</p>
<p>在Java的类中最简单的类定义形式为：</p>
<pre><code>class ClassName{
    constructor1
    constructor2
    …
    Method1
    Method2
    …
    Field1
    Field2
…
}
</code></pre><p>文件名必须与<code>public</code>类的名字相匹配。在一个文件中，只能有一个公有类，但可以有任意数目的非公有类。</p>
<p>如果习惯于将每一个类存在一个单独的源文件中，将可以有两种编译源程序的方法。</p>
<p>一种是使用通配符调用编译器，即<code>*</code>代表不定的字符串。另一种是只对含有公有类的文件进行<code>javac</code>操作，如果在这里使用了某个类，那么会自动搜索这个类的源文件，进行编译。</p>
<p>可以认为Java编译器内置了<code>make</code>功能。</p>
<p>关键字<code>public</code>意味着任何类的任何方法都可以调用这些方法。关键字<code>private</code>确保只有该类自身的方法能够访问这些实例域，而其他类的方法不能够读取这些域。</p>
<p>构造器与类同名，将实例域初始化为所希望的状态。构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。</p>
<p>方法用于操作对象以及存取它们的实例域。例如，方法：</p>
<pre><code>public void raiseSalary( double byPercent ){
    double raise = salary * byPercent / 100;
    salary += raise;
}
</code></pre><p>将调用这个方法的对象的<code>salary</code>实例域设置为新值，看看下面这个调用：<code>number007.raiseSalary(5);</code> 它的结果将<code>number007.salary</code>域的值增加5%。<code>raiseSalary</code>方法有两个参数。第一个参数被称为<code>隐式(implicit)</code>参数，是出现在方法名前的类对象。第二个参数位于方法名后面括号中的数值，这是一个<code>显式(explicit)</code>参数。<br>在每个方法中，关键字<code>this</code>表示隐式参数。如果需要的话，可以用下列方式编写<code>raiseSalary</code>方法：</p>
<pre><code>public void raiseSalary( double by Percent ){
    double raise = this.salary * byPercent / 100;
    this.salary += raise;
}
</code></pre><p>有些程序员更偏爱这样的风格，因为这样可以将实例域与局部变量明显区分开来。</p>
<p>封装应提供下面三项内容：</p>
<ol>
<li>一个私有的数据域</li>
<li>一个公有的域访问器</li>
<li>一个公有的域更改器方法</li>
</ol>
<p>这样做有如下的好处：</p>
<ul>
<li>可以改变内部实现，除了该类的方法之外，不会影响其他代码。</li>
<li>更改器方法可以执行错误检查，然而直接对域进行赋值将不会进行这些处理。</li>
</ul>
<p>一个方法可以访问所属类的所有对象的私有数据，而不仅限于访问隐式参数的私有特性。C++也有同样的原则。</p>
<p>尽管绝大多数方法都被设计为公有的，但在某些特殊情况下，也可能设计为私有的。</p>
<p>可以将实例域定义为<code>final</code>。构建对象时必须初始化这样的域。也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。</p>
<p><code>final</code>修饰符大都应用于<code>基本数据(primitive)</code>类型域，或<code>不可变类(immutable)</code>的域。对于可变的类，使用<code>final</code>修饰符可能会造成混乱。</p>
<h3 id="u9759_u6001_u57DF_u4E0E_u9759_u6001_u65B9_u6CD5"><a href="#u9759_u6001_u57DF_u4E0E_u9759_u6001_u65B9_u6CD5" class="headerlink" title="静态域与静态方法"></a>静态域与静态方法</h3><p>如果将域定义为<code>static</code>，每个类中只有一个这样的域。它属于类，而不属于任何独立的对象。</p>
<p>静态变量使用得比较少，但静态常量却使用得比较多。例如，在<code>Math</code>类中定义一个静态常量：<code>public static final double PI = 3.1415926;</code>在程序中，可以用<code>Math.PI</code>的形式获得这个常量。</p>
<p>另一个多次使用的静态常量是<code>System.out</code>。</p>
<p>静态方法是一种不能向对象实施操作的方法。例如，Math类的pow方法就是一个静态方法。表达式<code>Math.pow(x,a);</code>计算<code>X^a</code>。在运算时，不使用任何<code>Math</code>的对象，即没有隐式的参数。因为静态方法不能操作对象，所以不能在静态方法中访问实例域。但是，静态方法可以访问自身类中的静态域。</p>
<p>静态方法的一种常见用途。相当于创建实例对象的new。即把创建对象的过程抽象封装出来，可以创建不同名字和返回类型的对象，并且使程序的扩展性和安全性更强。</p>
<p><code>main</code>方法部队任何对象进行操作。事实上，在启动程序时还没有任何一个对象。静态的main方法将执行并创建程序所需要的对象。</p>
<h3 id="u65B9_u6CD5_u53C2_u6570"><a href="#u65B9_u6CD5_u53C2_u6570" class="headerlink" title="方法参数"></a>方法参数</h3><p>Java程序设计语言总是采用值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。</p>
<p>把对象引用作为参数可以改变对象参数状态，因为方法得到的是对象引用的拷贝，对象引用和它的拷贝引用的是同一个对象，所以在对其拷贝进行了更改之后，原来的对象引用也会发生变化。</p>
<p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用进行的是值传递，传递的值是一个拷贝的对象引用并且和原来的对象引用指向的是同一个对象，也因为如此，对这个拷贝的对象引用进行修改，也会对原来的对象产生影响。</p>
<h3 id="u5BF9_u8C61_u6784_u9020"><a href="#u5BF9_u8C61_u6784_u9020" class="headerlink" title="对象构造"></a>对象构造</h3><p>如果多个方法有相同的名字、不同的参数，便产生了重载。编译器通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来判断选择对应的方法。如果编译器找不到匹配的参数，或者找出多个可能的匹配，就会产生编译时错误(此过程称为重载解析(overloading resolution))。</p>
<p>如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值：数值为0、布尔值为false、对象引用为null。这是很不好的习惯。</p>
<p>如果在编写一个类时没有编写构造器，那么系统就会提供一个默认构造器。这个默认构造器将所有的实例域设置为默认值。</p>
<p>如果类中提供了至少一个构造器，但是没有提供默认的构造器，则在构造对象时如果没有提供构造函数参数就会被视为不合法。</p>
<p>由于类的构造器方法可以重载，所以可以采用多种形式设置类的实例域的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值。这是一种很好的设计习惯。</p>
<p>可以在类定义中，直接将一个值赋给任何域。当一个类的所有构造器都希望把相同的值赋给某个特定的实例域时，这种方式特别有用。</p>
<p>初始值不一定是常量。可以调用方法对域进行初始化。</p>
<p>编写很小的构造器时，常常用单个字符命名：</p>
<pre><code>public Employee( String n, double s){
    name = n;
    salary = s;
}
</code></pre><p>这样的话，就只有阅读代码才能了解参数n和s的含义，所以可以用aName和aSalary来代替，这样就可以一眼看出参数的含义。</p>
<p>还有一种常用的技巧，原理如下：参数变量用同样的名字将实例域屏蔽起来，再利用this隐式参数(即被构造的对象)访问实例域：</p>
<pre><code>public Employee( String name, double salary){
    this.name = name;
    this.salary = salary;
}
</code></pre><p>关键字<code>this</code>引用方法的隐式参数。然而这个关键字还有另外一个含义。</p>
<p>如果构造器的第一个语句形如this(…)，这个构造器将调用同一个类的另一个构造器，例子如下：</p>
<pre><code>public Employee(double s){
    // calls Employee( String, double )
    this( Employee #” + nextId, s);
    nextId++;
}
</code></pre><p>当调用new Employee(6000)时，会调用Employee(String,double)构造器。采用这种方式使用this关键字非常有用，这样对公共的构造器代码部分只编写一次即可。</p>
<p>除了在构造器中设置值和在声明中赋值，Java还有第三种机制，称为<code>初始化块(initialization block)</code>。在一个类的声明中可以包含多个代码块。只要构造类的对象，这些块就会被执行。例如：</p>
<pre><code>class Employee{
    public Employee( String n, double s ){
        name = n;
        salary = s;
    }

    public Employee(){
        name = ”;
        salary = 0;
    }
    ........
    private static int nextId;
    private int id;
    private String name;
    private double salary;
    ........
    // object initialization block
    {
        id = nextId;
        nextId++;
    }
}
</code></pre><p>在这个例子中，无论使用哪个构造器构造对象，id域都在对象初始化块(最后的一段)中被初始化。首先运行初始化块，然后才运行构造器的主体部分。这种机制不是必须的，也不常见。建议将初始化块放在域定义之后。</p>
<p><strong>java.util.Random</strong></p>
<ul>
<li><code>Random()</code><ul>
<li>构造一个新的随机数生成器。</li>
</ul>
</li>
<li><code>int nextInt( int n )</code><ul>
<li>返回一个0~n-1之间的随机数。</li>
</ul>
</li>
</ul>
<p>有些面向对象的程序设计语言，特别是C++，有显式的析构器方法，其中反之一些当对象不在使用时需要执行的清理代码。在析构器中，最常见的操作是回收分配格对象的存储空间。由于Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器。</p>
<p>当然，某些对象使用了内存之外的其他资源，例如，文件或使用了系统资源的另一个句柄。在这种情况下，当资源不再需要时，将其回收和再利用将显得十分重要。</p>
<p>可以为任何一个类添加finalize方法。finalize方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能够调用。</p>
<p>如果某个资源需要在使用后立即被关闭，那么就需要人工来管理。可以应用一个类似<code>dispose</code>或<code>close</code>的方法完成相应的清理操作。如果一个类使用了这样的方法，使用完毕一定要记得调用它。</p>
<h3 id="u5305"><a href="#u5305" class="headerlink" title="包"></a>包</h3><p>Java允许使用包(package)将类组织起来。借助于包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。</p>
<p>标准的Java类库分布在多个包中，包括<code>java.lang</code>、<code>java.util</code>、<code>java.net</code>等。标准的Java包具有一个层次结构，所有标准的Java包都在java和javax包层次中。</p>
<p>使用包的主要原因是确保类名的唯一性。Sun公司建议将公司的因特网域名以逆序的形式作为包名，并且不同的项目使用不同的子包。若域名为www.wdx.cn，则包的名字就叫做 cn.wdx。</p>
<p>从编译器的角度来看，嵌套的包之间没有任何关系，每一个都拥有独立的类集合。</p>
<p>一个类可以使用所属包中的所有类，以及其他包中的公有类(public class)。可以使用两种方式访问包中的公有类。第一种就是每个类名前添加完整包名。另一种是使用import语句，可以用import语句导入一个特定的类或者整个包。import语句应位于源文件的顶部(但位于package语句后面)。</p>
<p>还可以使用<code>星号(*)</code>导入一个包：<code>import java.util.*</code></p>
<p>若两个不同包中有相同的类名，则可以添加特定的<code>import</code>语句来解决：<code>import java.util.Date;</code>若有冲突的类名都要用，则在每个类名的前面加上完整的包名。</p>
<p>从Java SE 5.0开始，import语句可以导入静态方法和静态域的功能。例如：<code>import static java.lang.System.*;</code>就可以使用<code>System</code>类的静态方法和静态域，而不必加类名前缀：</p>
<pre><code>out.println(GoodBye!My friend!”);  // i.e,System.out
exit(0);    // i.e., System.exit
</code></pre><p>静态导入的两个最实际的应用：</p>
<ol>
<li>算数函数：如果对Math类使用静态导入，就可以采用更加自然的方式使用静态导入：<code>sqrt( pow( x, 2 ) + pow( y, 2 ))</code></li>
<li>笨重的常量：如果需要使用大量带有冗长名字的常量，就应该使用静态导入，例如<code>calendar</code>类。</li>
</ol>
<p>要想将一个类放入包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前：<code>package cn.wdx;</code></p>
<p>如果没有在源文件中放置package语句，这个源文件中的类就被放置在一个默认包中(default package)。默认包是一个没有名字的包。</p>
<p>标记为<code>public</code>的部分可以被任意的类使用；标记为<code>private</code>的部分只能被定义它们的类使用。如果没有指定<code>public</code>或<code>private</code>，这个部分(类、方法或变量)可以被同一个包中的所有方法访问。</p>
<p>可以通过<code>包密封(package sealing)</code>机制来解决将各种包混杂在一起的问题。如果将一个包密封起来，就不能再向这个包添加类了。</p>
<p>类文件也可以存储在<code>JAR(Java归档)</code>文件中，JAR文件使用ZIP格式组织文件和子目录。<br>为了能使类能够被多个程序共享，需要做到下面几点：</p>
<ul>
<li>把类放到一个目录中。</li>
<li>将JAR文件放在一个目录中</li>
<li>设置类路径(class path)。类路径是所有包含类文件的路径的集合。</li>
</ul>
<p>如果在源代码中添加以专用的界定符/**开始的注释，那么可以很容易地生成一个看上去具有专业水准的文档。</p>
<p>javadoc实用程序(utility)从下面几个特性中抽取信息：</p>
<ul>
<li>包</li>
<li>公有类与接口</li>
<li>公有的和受保护的方法</li>
<li>公有的和受保护的域</li>
</ul>
<p>应该为上面几部分编写注释。注释应该放置在所描述的特性的前面。注释以<code>/**</code>开始，并以<code>*/</code>结束。</p>
<p>每个<code>/**...*/</code>文档注释在标记之后紧跟着自由格式文本(free-form text)。标记由@开始，如<code>@author</code>或<code>@param</code>。</p>
<p>自由格式文本的第一句应该是一个概要性的句子。<code>javadoc</code>实用程序自动地将这些句子抽取出来形成概要页。</p>
<p>在自由格式文本中，可以使用HTML修饰符，例如，用于强调的<code>&lt;em&gt;...&lt;/em&gt;</code>、用于设置等宽打字机”字体的<code>&lt;code&gt;...&lt;/code&gt;</code>、用于着重强调的<code>&lt;strong&gt;...&lt;/strong&gt;</code>以及包含图像的<code>&lt;img...&gt;</code>等。不过一定不要使用<code>&lt;h1&gt;</code>或<code>&lt;hr&gt;</code>，因为它们会与文档的格式产生冲突。</p>
<p>类注释必须放在import语句之后，类定义之前。例子如下：</p>
<pre><code>/**
 * A &lt;code&gt;Card&lt;/code&gt; object represents a playing card,such
 * as Queen of Hearts”. A card has a suit (Diamond, Heart,
 * Spade or Club) and a value ( 1 = Ace, 2....10,11 = Jack,
 * 12 = Queen, 13 = King).
 */
public class Card{
    .....
}
</code></pre><p>每一个方法在注释是必须放在所描述的方法之前。除了通用标记之外，还可以使用下面的标记：</p>
<pre><code>@param variable description
</code></pre><p>这个标记将对当前方法的<code>param(参数)</code>部分添加一个条目。这个描述可以占据多行，并可以使用HTML标记。一个方法的所有<code>@param</code>标记必须放在一起。</p>
<pre><code>@return description
</code></pre><p>这个标记将对当前方法添加<code>return(返回)</code>部分。这个描述可以跨越多行，并可以使用HTML标记。</p>
<pre><code>@throws class description
</code></pre><p>这个标记将添加一个注释，用于表示这个方法有可能抛出异常。</p>
<p>只需要对公有域(通常指的是静态常量)建立文档。例如：</p>
<pre><code>/**
 *  The Hearts” card suit
 */
public static final int HEARTS = 1;
</code></pre><p>用于类文档的注释</p>
<pre><code>@author name
</code></pre><p>这个标记将产生一个author”(作者)条目。可以使用多个@author标记，每个标记对应一个作者。</p>
<pre><code>@version text
</code></pre><p>这个标记将产生一个version”(版本)条目。这里的text可以是对当前版本的任何描述。<br>用于所有文档的注释</p>
<pre><code>@since text
</code></pre><p>这个标记将产生一个since”(始于)条目。这里的text可以是对引入特性的版本描述，例如<code>@since version 1.3.3</code>。</p>
<pre><code>@deprecated text
</code></pre><p>这个标记将对类、方法或变量添加一个不再使用的注释。text中给出了取代的建议。</p>
<pre><code>@see reference
</code></pre><p>这个标记将在see also”部分增加一个超级链接。它可以用于类中，也可以用于方法中。这里的reference可以选择下列情形之一：</p>
<ul>
<li>第一种情况最常见，只要提供类、方法或变量的名字，<code>javadoc</code>就在文档中插入一个超链接。例如，<code>@see cn.wdx.HelloWorld#text()</code> 就会建立一个链接到<code>cn.wdx.HelloWorld</code>类的<code>text</code>方法的超链接。注意要用#”分隔类名与方法名，或类名与变量名。</li>
<li>如果在<code>@see</code>标记后面有一个<code>&lt;</code>字符，就需要指定一个超链接。如果在<code>@see</code>标记后面有一个双引号字符，文本就会显示在<code>see also</code>部分。</li>
<li>可以为一个特性添加多个<code>@see</code>标记，但必须将它们放在一起。</li>
</ul>
<p>想要产生包注释，就需要在每一个包目录中添加一个单独的文件，可以有如下两个选择：</p>
<ol>
<li>提供一个以package.html命名的HTML文件。在标记<code>&lt;BODY&gt;...&lt;/BODY&gt;</code>之间的所有文本都会被抽取出来。</li>
<li>提供一个以<code>package-info.java</code>命名的Java文件。这个文件必须包含一个初始的以<code>/**和*/</code>界定的<code>Javadoc</code>注释，跟随在一个包语句之后。它不应该包含更多的代码或注释。</li>
</ol>
<p>还可以为所有的源文件提供一个概述性的注释。</p>
<p>这个注释被放置在一个名为<code>overview.html</code>的文件中，这个文件位于包含所有源文件的父目录中。标记<code>&lt;BODY&gt;...&lt;/BODY&gt;</code>之间的所有文本都会被抽取出来。</p>
<h3 id="u7C7B_u7684_u8BBE_u8BA1_u6280_u5DE7"><a href="#u7C7B_u7684_u8BBE_u8BA1_u6280_u5DE7" class="headerlink" title="类的设计技巧"></a>类的设计技巧</h3><ul>
<li>一定将数据设计为私有</li>
<li>一定要对数据初始化</li>
<li>不要在类中使用过多的基本数据类型。</li>
<li>不是所有的域都需要独立的域访问器和域更改器。</li>
<li>使用标准格式进行类的定义。</li>
</ul>
<p>采用下列顺序书写类的内容：</p>
<ul>
<li>公有访问特性部分</li>
<li>包作用域访问特性部分</li>
<li>私有访问特性部分</li>
</ul>
<p>在每一部分中应该按照下列顺序列出</p>
<ul>
<li>实例方法</li>
<li>静态方法</li>
<li>实例域</li>
<li>静态域</li>
</ul>
<p>将职责过多的类进行分解</p>
<p>类名和方法名要能够体现它们的职责</p>
<h2 id="u7EE7_u627F"><a href="#u7EE7_u627F" class="headerlink" title="继承"></a>继承</h2><h3 id="u7C7B_u3001_u8D85_u7C7B_u548C_u5B50_u7C7B"><a href="#u7C7B_u3001_u8D85_u7C7B_u548C_u5B50_u7C7B" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h3><p>is-a”关系是继承的一个明显特征，关键字extends表示继承。例如：</p>
<pre><code>class Manager extends Employee{
    .... // Manager类继承了Employee类
}
</code></pre><p>关键字<code>extends</code>表明正在构造的新类派生于一个已存在的类。已存在的类被称为<code>超类(superclass)</code>、<code>基类(base class)</code>或<code>父类(parent class)</code>；新类被称为<code>子类(subclass)</code>、<code>派生类(derived class)</code>或<code>孩子类(child class)</code>。超类和子类是Java程序员最常用的两个术语。</p>
<p>在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。因此在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。</p>
<p>若超类中的某些方法对于子类中并不适用，就需要提供一个新的方法来<code>覆盖(override)</code>超类中的这个方法。但如果在这个新的方法中需要调用超类中的同名方法的时候，可以用<code>super</code>来调用，例如：</p>
<pre><code>public double getSalary(){
    double baseSalary = super.getSalary();
    return baseSalary + bonus;
}
</code></pre><p>在子类中可以增加域、增加方法或覆盖超类的方法，然而绝不能删除继承的任何域和方法。<br>super在构造器中用来调用超类的构造器，例如：</p>
<pre><code>public Manager( String n, double s, int year ){
    super( n, s, year );
    bonus = 0;
}
</code></pre><p>如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则Java编译器将报告错误。</p>
<p>继承并不仅限于一个层次，由一个公共超类派生出来的所有类的集合被称为<code>继承层次(inheritance hierarchy)</code>。在继承层次中，从某个特定的类到其祖先的路径被称为该类的<code>继承链(inheritance chain)</code>。</p>
<p>通常，一个祖先类可以拥有多个子孙继承链。Java不支持多继承。</p>
<p>有一个用来判断是否应该设计为继承关系的简单规则，这就是<code>is-a</code>规则，它表明子类的每个对象也是超类的对象。</p>
<p><code>is-a</code>规则的另一种表述方式是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象置换。</p>
<p>在Java程序设计语言中，对象变量是多态的。一个超类变量既可以引用一个超类对象，也可以引用一个此超类的任何一个子类的对象。然而，不能将一个超类的引用赋给子类变量。</p>
<p>弄清调用对象方法的执行过程十分重要。下面是调用过程的描述：</p>
<p>编译器查看对象的声明类型和方法名。假设调用<code>x.f(param)</code>，且隐式参数<code>x</code>声明为C类的对象。编译器将会一一列举所有<code>C</code>类中名为<code>f</code>的方法和其他超类中访问属性为<code>public</code>且名为<code>f</code>的方法。</p>
<p>至此，编译器已获得所有可能被调用的候选方法。</p>
<p>接下来，编译器查看调用方法时提供的参数类型。如果在所有名为<code>f</code>的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为<code>重载解析(overloading resolution)</code>。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。</p>
<p>至此，编译器已获得需要调用的方法名字和参数类型。</p>
<p>如果是<code>private</code>方法、<code>static</code>方法、<code>final</code>方法或者构造器，那么编译器可以准确地知道应该调用哪个方法，这种调用方式称为静态绑定(static binding)。与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。</p>
<p>当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与<code>x</code>所引用对象的实际类型最合适的那个类的方法。</p>
<p>每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表(method table)，与C++中的VTABLE类似，其中列出了所有方法的签名和实际调用的方法。实际调用时查找此表即可。</p>
<p>动态绑定有一个非常重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展。</p>
<p>不允许扩展的类被称为<code>final</code>类。如果在定义类的时候使用了<code>final</code>修饰符就表明这个类是final类。可以阻止人们定义其子类，如：</p>
<pre><code>final class Executive extends Manager{...}
</code></pre><p>类中的方法也可以被声明为final如果这样做，子类就不能覆盖这个方法(<code>final</code>类中的所有方法自动成为<code>final</code>方法)。如：<code>public final int getValue()</code></p>
<p>将方法或类声明为final的意义在于：确保它们不会在子类中改变语义。</p>
<p>对象引用的转换语法与数值表达式的类型转换类似，仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。</p>
<p>在进行类型转换之前，先查看以下是否能够成功地转换。可以简单地使用instanceof运算符实现，如：</p>
<pre><code>if( staff[1] instanceof Manager){
    boss = (Manager) staff[1];
    ......
}
</code></pre><p>综上所述，有两个原则：</p>
<ol>
<li>只能在继承层次内进行类型转换。</li>
<li>在超类传唤成子类之前，应该使用<code>instanceof</code>检查。</li>
</ol>
<p>一般情况下，应该尽量少用类型转换和<code>instanceof</code>运算符。</p>
<p>如果自下而上仰视类的继承层次结构，位于上层的类更具有通用性，甚至可能更加抽象。从某种角度看，祖先类更加通用，人们只将它作为派生其他类的基类，而不作为想使用的特定实例类。</p>
<p>使用<code>abstract</code>关键字来声明抽象类。</p>
<pre><code>public abstract String getDescription();
// no implementation required
</code></pre><p>为了提高程序的清晰读，包含一个或多个抽象方法的类本身必须被声明为抽象的。除了抽象方法之外，抽象类还可以包含具体数据和具体方法。</p>
<p>抽象方法充当占位的角色，它们的具体实现在子类中。扩展抽象类可以有两种选择。一种是在子类中定义部分抽象方法或抽象方法也不定义，这样就必须将子类也标记为抽象类；另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。</p>
<p>类即使不含抽象方法，也可以将类声明为抽象类。</p>
<p>抽象类不能被实例化，即不能创建抽象类的对象。但是可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。</p>
<ul>
<li>仅对本类可见──private。</li>
<li>对所有类可见──public。</li>
<li>对本包和所有子类可见──protected。</li>
<li>对本包可见──默认。</li>
</ul>
<p>Java中的protected概念要比C++中的安全性差。</p>
<h3 id="Object__u6240_u6709_u7C7B_u7684_u8D85_u7C7B"><a href="#Object__u6240_u6709_u7C7B_u7684_u8D85_u7C7B" class="headerlink" title="Object 所有类的超类"></a>Object 所有类的超类</h3><p><code>Object</code>类是Java中所有类的最终祖先，在Java中每个类都是由它扩展而来的。如果没有明确地指出超类，<code>Object</code>就被认为是这个类的超类。</p>
<p>可以使用<code>Object</code>类型的变量引用任何类型的对象。当然，<code>Object</code>类型的变量只能用于作为各种值的通用持有者。要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的类型转换。</p>
<p>在Java中，只有<code>基本类型(primitive types)</code>不是对象。</p>
<p><code>Object</code>类中的<code>equals</code>方法用于检测一个对象是否等于另一个对象。在<code>Object</code>类中，这个方法将判断两个对象是否具有相同的引用。</p>
<p>Java语言规范要求equals方法具有下面的特性：</p>
<ul>
<li>自反性：对于任何非空引用<code>x</code>，<code>x.equals(x)</code>应该返回<code>true</code>。</li>
<li>对称性：对于任何引用<code>x</code>和<code>y</code>，当且仅当<code>y.equals(x)</code>返回<code>true</code>，<code>x.equals(y)</code>也应该返回<code>true</code>。</li>
<li>传递性：对于任何引用<code>x</code>、<code>y</code>和<code>z</code>，如果<code>x.equals(y)</code>返回<code>true</code>，<code>y.equals(z)</code>返回<code>true</code>，<code>x.equals(z)</code>也应该返回<code>true</code>。</li>
<li>一致性：如果<code>x</code>和<code>y</code>引用的对象没有发生变化，反复调用<code>x.equals(y)</code>应该返回同样的结果。</li>
<li>对于任意非空引用<code>x</code>，<code>x.equals(null)</code>应该返回<code>false</code>。</li>
</ul>
<p>可以从两个截然不同的情况看待getClass的使用：</p>
<ol>
<li>如果子类能够拥有子集的相等概念，则对称性需求将强制采用getClass进行检测。</li>
<li>如果由超类决定相等的概念，那么就可以使用instanceof进行检测，这样就可以在不同子类对象之间进行相等的比较。</li>
</ol>
<p>下面给出编写一个完美的equals方法的建议：</p>
<ul>
<li>显式参数命名为<code>otherObject</code>，稍后需要将它转换称另一个叫做<code>other</code>的变量。</li>
<li>检测<code>this</code>与<code>otherObject</code>是否引用同一个对象：<code>if( this == otherObject ) return true;</code></li>
<li>检测<code>otherObject</code>是否为<code>null</code>，如果为<code>null</code>，返回<code>false</code>。<code>if( otherObject == null ) return false;</code></li>
<li>比较<code>this</code>与<code>otherObject</code>是否属于同一个类。</li>
<li>如果<code>equals</code>语义在每个子类中有所改变，就使用<code>getClass</code>检测：<code>if (getClass() != otherObject.getClass()) return false;</code></li>
<li>如果所有的子类拥有统一的语义，就使用<code>instanceof</code>检测：<code>if( ! ( otherObject instanceof ClassName )) return false;</code></li>
<li>将<code>otherObject</code>转换相应的类型变量：<code>ClassName other = ( ClassName )otherObject;</code></li>
</ul>
<p>现在开始对所有需要比较的域进行比较。使用 <code>==</code> 比较基本类型域，使用<code>equals</code>比较对象域。如果所有都匹配，就返回<code>true</code>，否则返回<code>false</code></p>
<pre><code>return field1 == other.field1
    &amp;&amp; field2.equals(other.field2)
    &amp;&amp; ...;
</code></pre><p>如果在子类中重新定义<code>equals</code>，就要在其中包含调用<code>super.equals(other)</code>。</p>
<p><code>散列码(hash code)</code>是由对象导出的一个整型值，是没有规律的。可以用做来判断对象是否相等。</p>
<p><strong>java.lang.Object</strong></p>
<ul>
<li><code>int hashCode()</code><ul>
<li>返回对象的散列码。散列码可以是任意的整数，包括正数或负数。两个相等的对象要求返回相等的散列码。</li>
</ul>
</li>
<li><code>Class getClass()</code><ul>
<li>返回包含对象信息的类对象。Java提供了类运行时的描述，被封装在Class类中。</li>
</ul>
</li>
<li><code>boolean equals( Object otherObject )</code><ul>
<li>比较两个对象是否相等，如果两个对象指向同一块存储区域，方法放回true；否则方法返回false。在自定义类中，应该覆盖这个方法。</li>
</ul>
</li>
<li><code>String toString()</code><ul>
<li>返回描述该对象值的字符串。在自定义类中，应该覆盖这个方法。</li>
</ul>
</li>
<li><code>Object clone()</code><ul>
<li>创建一个对象的副本。Java运行时系统将为新实例分配存储空间，并将当前的对象复制到这块存储区域中。</li>
</ul>
</li>
</ul>
<p><strong>java.lang.Class</strong></p>
<ul>
<li><code>String getName()</code><ul>
<li>返回这个类的名字。</li>
</ul>
</li>
<li><code>Class getSuperclass()</code><ul>
<li>以Class对象的形式返回这个类的超类信息。</li>
</ul>
</li>
</ul>
<p>在<code>Object</code>中还有一个重要的方法，就是<code>toString</code>方法，它用于返回表示对象值的字符串。绝大多数的<code>toString</code>方法都遵循这样的格式：类的名字，随后是一对方括号括起来的域值。</p>
<p>如果<code>x</code>是任意一个对象，并调用<code>System.out.println(x)</code>; 就会直接调用<code>x.toString()</code>，并打印输出得到的字符串。</p>
<h3 id="u6CDB_u578B_u6570_u7EC4_u5217_u8868"><a href="#u6CDB_u578B_u6570_u7EC4_u5217_u8868" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h3><p>在Java SE 5.0中，<code>ArrayList</code>是一个采用<code>类型参数(type parameter)</code>的<code>泛型类(generic class)</code>。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面。下面声明和构造一个保存<code>Employee</code>对象的数组列表：</p>
<pre><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;();
</code></pre><p>使用<code>add</code>方法可以将元素添加到数组列表中。如果调用<code>add</code>且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。</p>
<p>如果已经清楚或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用<code>ensureCapacity</code>方法：</p>
<pre><code>staff.ensureCapacity(100);
</code></pre><p>这个方法调用将分配一个包含100个对象的内部数组。然后调用100次add，而不用重新分配空间。</p>
<p><strong>java.util.ArrayList<t></t></strong></p>
<ul>
<li><code>ArrayList&lt;T&gt;</code><ul>
<li>构造一个空数组列表</li>
</ul>
</li>
<li><code>ArrayList&lt;T&gt;(int initialCapacity)</code><ul>
<li>用指定容量initialCapacity构造一个空数组列表</li>
</ul>
</li>
<li><code>boolean add(T obj)</code><ul>
<li>在数组列表的尾端添加一个元素obj。永远返回true。</li>
</ul>
</li>
<li><code>int size()</code><ul>
<li>返回存储在数组列表中的当前元素数量。(这个值将小于或等于数组列表的容量)</li>
</ul>
</li>
<li><code>void ensureCapacity(int capacity)</code><ul>
<li>确保数组列表在不重新分配存储空间的情况下就能够保存给定数量的元素。</li>
</ul>
</li>
<li><code>void trimToSize()</code><ul>
<li>将数组列表的存储容量削减到当前尺寸。</li>
</ul>
</li>
<li><code>void set( int index, T obj )</code><ul>
<li>设置数组列表指定位置的元素值，此操作将覆盖这个位置的原有内容。</li>
</ul>
</li>
<li><code>T get( int index )</code><ul>
<li>获得指定位置的元素值。</li>
</ul>
</li>
<li><code>void add( int index, T obj )</code><ul>
<li>向后移动元素，以便插入元素。</li>
</ul>
</li>
<li><code>T remove( int index )</code><ul>
<li>删除一个元素并将后面的元素向前移动。被删除的元素由返回值返回。</li>
</ul>
</li>
</ul>
<p>数组列表自动扩展容量的便利增加了访问元素语法的复杂程度。使用<code>get</code>和<code>set</code>方法实现访问或改变数组元素的操作。例如：</p>
<pre><code>staff.set(i,harry);
Employee e = staff.get(i);
</code></pre><p>使用<code>add</code>方法为数组添加新元素，而不要使用<code>set</code>方法，它只能替换数组中已经存在的元素内容。</p>
<p>也可以使用<code>for each</code>循环对数组列表遍历：</p>
<pre><code>for(Employee e : staff)
    do something with e
</code></pre><p>请注意下面的变化：</p>
<ul>
<li>不必指出数组的大小。</li>
<li>使用<code>add</code>将任意多的元素添加到数组中。</li>
<li>使用<code>size()</code>替代<code>length</code>计算元素的数目。</li>
<li>使用<code>a.get(i)</code>替代<code>a[i]</code>访问元素。</li>
</ul>
<h3 id="u5BF9_u8C61_u5305_u88C5_u5668_u4E0E_u81EA_u52A8_u6253_u5305"><a href="#u5BF9_u8C61_u5305_u88C5_u5668_u4E0E_u81EA_u52A8_u6253_u5305" class="headerlink" title="对象包装器与自动打包"></a>对象包装器与自动打包</h3><p>有时，需要将int这样的基本类型转换为对象。所有的基本类型都有一个与之对应的类。例如，Integer类对应基本类型int。通常，这些类称为包装器(wrapper)。对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。对象包装器类还是final，因此不能定义它们的子类。</p>
<p>假设想定义一个整型数组列表。而尖括号中的类型参数不允许是基本类型，也就是说，不允许写成<code>ArrayList&lt;int&gt;</code>。这里就用到了<code>Integer</code>对象包装器类。我们可以声明一个<code>Integer</code>对象的数组列表。</p>
<pre><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
</code></pre><p>Java SE 5.0的另一个改进之处是更加便于添加或获得数组元素。</p>
<p><code>list.add(3);</code> 将自动变成 <code>list.add(new Integer(3));</code></p>
<p>这种变换被称为<code>自动打包(autoboxing)</code>。</p>
<p>相反的，当将一个<code>Integer</code>对象赋给一个<code>int</code>值时，会自动地拆包。包含在包装器中的内容不会改变。不能使用这些使用这些包装器类创建修改数值参数的方法。如果想要修改参数值的方法，就要使用<code>持有者(holder)</code>类型。</p>
<p>最后强调以下，打包和拆包是<strong>编译器</strong>认可的，而不是虚拟机。</p>
<p><strong>java.lang.Integer</strong></p>
<ul>
<li><code>int intValue()</code><ul>
<li>以int的形式返回Integer对象的值。</li>
</ul>
</li>
<li><code>static String toString( int i )</code><ul>
<li>以一个新String对象的形式返回给定数值 i 的十进制表示。</li>
</ul>
</li>
<li><code>static String toString( int i, int radix )</code><ul>
<li>返回数值 i 的基于给定radix参数进制的表示。</li>
</ul>
</li>
<li><code>static int parseInt( String s )</code></li>
<li><code>static int parseInt( String s, int radix )</code><ul>
<li>返回字符串 s 表示的整型数值，给定字符串表示的十进制的整数，或者是radix参数进制的整数。</li>
</ul>
</li>
<li><code>static Integer valueOf( String s )</code></li>
<li><code>static Integer valueOf( String s, int radix )</code><ul>
<li>返回用 s 表示的整型数值进行初始化后的一个新Integer对象，给定字符串表示的是十进制的整数，或者是radix参数进制的整数。</li>
</ul>
</li>
</ul>
<p><strong>java.text.NumberFormat</strong></p>
<ul>
<li><code>Number parse( String s )</code><ul>
<li>返回数字值，假设给定的String表示了一个数值。</li>
</ul>
</li>
</ul>
<h3 id="u53C2_u6570_u6570_u91CF_u53EF_u53D8_u7684_u65B9_u6CD5"><a href="#u53C2_u6570_u6570_u91CF_u53EF_u53D8_u7684_u65B9_u6CD5" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h3><p>可以用省略号…表明这个方法可以接收任意数量的对象。例如</p>
<pre><code>public static double max( double... values){
    double largest = Double.MIN_VALUE;
    for( double v : values) if (v &gt; largest ) largest = v;
    return largest;
}
</code></pre><h3 id="u679A_u4E3E_u7C7B"><a href="#u679A_u4E3E_u7C7B" class="headerlink" title="枚举类"></a>枚举类</h3><pre><code>public enum Size{ SMALL, MEDIUM, LARGE, EXTRA_LARGE };
</code></pre><p>实际上，这个声明定义的类型是一个类，它刚好有4个实例，在此尽量不要构造新对象。如果需要的话，可以在枚举类型中添加一些构造器、方法和域。当然构造器只是在构造枚举常量的时候被调用。</p>
<p>每个枚举类型都有一个静态的<code>values</code>方法，它将返回一个包含全部枚举值的数组。</p>
<p><strong>java.lang.Enum<e></e></strong></p>
<ul>
<li><code>static Enum valueOf( Class enumClass, String name )</code><ul>
<li>返回指定名字、给定类的枚举常量。</li>
</ul>
</li>
<li><code>String toString()</code><ul>
<li>返回枚举常量名。</li>
</ul>
</li>
<li><code>int ordinal()</code><ul>
<li>返回枚举常量在enum声明中的位置，位置从 0 开始计数。</li>
</ul>
</li>
<li><code>int compareTo(E other)</code><ul>
<li>如果枚举常量出现在other之前，则返回一个负值；如果this == other，则返回 0；否则，返回正值。枚举常量的出现次序在enum声明中给出。</li>
</ul>
</li>
</ul>
<h3 id="u53CD_u5C04"><a href="#u53CD_u5C04" class="headerlink" title="反射"></a>反射</h3><p><code>反射库(reflection library)</code>提供了一个非常丰富且精心设计的工具集，以便能编写能够动态操纵Java代码的程序。使用反射，Java可以支持Visual Basic用户习惯使用的工具。特别是在设计或运行中添加新类时，能够快速地应用开发工具动态地查询新添加类的能力。</p>
<p>能够分析类能力的程序被称为反射(reflective)。反射机制的功能极其强大。可以用反射机制：</p>
<ul>
<li>在运行中分析类的能力。</li>
<li>在运行中查看对象，例如，编写一个toString方法供所有类使用。</li>
<li>实现数组的操作代码。</li>
<li>利用Method对象，这个对象很像C++中的函数指针。</li>
<li>反射是一种功能强大且复杂的机制。使用它的主要对象是工具构造者。</li>
</ul>
<h2 id="u9644_u5F551_Cpp_u6CE8_u91CA"><a href="#u9644_u5F551_Cpp_u6CE8_u91CA" class="headerlink" title="附录1 Cpp注释"></a>附录1 Cpp注释</h2><blockquote>
<p>Java的类与C++的类</p>
</blockquote>
<p>Java中的所有函数都属于某个类的方法(标准术语称其为方法，而不是成员函数)。因此，Java中的所有函数都必须有一个外壳类并且<code>main</code>方法必须是静态的。如果<code>main</code>方法正确退出，那么Java应用程序的退出代码为0，如果想要在终止程序的时候返回其他代码，那就需要调用<code>System.exit</code>方法。</p>
<blockquote>
<p>Java的整型与C++的整型</p>
</blockquote>
<ul>
<li>在C和C++中，int表示的整型与目标机器相关。Java没有任何无符号类型(unsigned type)。</li>
<li>boolean值的不同</li>
<li>在C++中，数值或指针可以代替boolean值。0相当于false，非0值相当于true。在Java中就不行。</li>
</ul>
<blockquote>
<p>变量的声明与定义</p>
</blockquote>
<p>C和C++中变量的声明与定义是不同的。在Java中，不区分变量的声明与定义。</p>
<blockquote>
<p>const</p>
</blockquote>
<p><code>const</code>是Java的保留关键字，但目前并未使用，必须用<code>final</code>定义常量。</p>
<blockquote>
<p>移位操作</p>
</blockquote>
<p>在C和C++中无法确定 <code>&gt;&gt;</code> 操作执行的是算数移位(扩展符号位)，还是逻辑移位(高位填0)。实际上在C和C++中，<code>&gt;&gt;</code> 运算符实际上是只为非负数定义的。Java消除了这种含糊性。</p>
<blockquote>
<p>boolean的强制类型转换</p>
</blockquote>
<p>不要在boolean类型与任何数值类型之间进行强制类型转换，这样可能防止发生错误。</p>
<blockquote>
<p>逗号运算符？</p>
</blockquote>
<p>与C和C++不同，Java不使用逗号运算符，不过可以在for语句中用逗号隔开表达式列表。</p>
<blockquote>
<p>Java中的字符串</p>
</blockquote>
<p>与C++不同，Java字符串更加像char*指针，自动的垃圾回收也可以避免内存泄露。</p>
<blockquote>
<p>流程结构</p>
</blockquote>
<p>Java的控制流程功能结构与C和C++的控制流程结构一样，只有很少的例外情况。没有goto语句，但break语句可以带标签，可以利用它实现从内层循环跳出的目的。还有一种变形的for循环，类似于C#中的foreach循环。</p>
<blockquote>
<p>嵌套的块</p>
</blockquote>
<p>在C++中，可以在嵌套的块中重定义一个变量。在内层定义的变量会覆盖在外层定义的变量。这样，有可能导致程序设计错误，因此在Java中不允许这样做。</p>
<blockquote>
<p>运算符重载</p>
</blockquote>
<p>与C++不同，Java没有提供运算符重载功能。Java语言的设计者确实为字符串的连接重载了+运算符，但是没有重载其他运算符，也没有给Java程序员自己重载运算符的权利。</p>
<blockquote>
<p>Java数组与C++数组</p>
</blockquote>
<p>Java数组与C++数组在堆栈上有很大不同，但基本上与分配在堆(heap)上的数组指针一样。Java中的[]运算符被预定义为检查数组边界，而且没有指针运算，不能通过数组名加1来得到数组的下一个元素。</p>
<blockquote>
<p>Java对象变量</p>
</blockquote>
<p>在C++中没有空引用，并且引用不能被赋值。我们可以将Java的对象看作C++的对象指针。在Java中指针问题不再困扰。如果使用一个没有初始化的指针，系统就会产生一个运行时错误，而不是随机的结果。垃圾收集器会处理内存管理问题。</p>
<blockquote>
<p>更改器和访问器</p>
</blockquote>
<p>在C++中，带有const后缀的方法是访问器方法；默认为更改器方法。Java中，访问器方法与更改器方法语法上没有明显的区别。</p>
<blockquote>
<p>Java的构造器</p>
</blockquote>
<p>Java构造器的工作方式与C++一样。但是，要记住所有的Java对象都是在堆中构造的，构造器总是伴随着new操作符一起使用。C++程序员最容易犯得作物就是忘记new操作符。</p>
<blockquote>
<p>Java的内部定义</p>
</blockquote>
<p>在C++中，通常在类的外面定义方法，如果在类的内部定义方法，这个方法就自动成为内联方法。在Java中，所有的方法都必须在类的内部定义，但并不表示它们是内联方法。</p>
<blockquote>
<p>static的不同含义</p>
</blockquote>
<p>Java中的静态域与静态方法在功能上与C++相同。但是语法却有不同。C中static有三种含义：</p>
<ul>
<li>表示退出一个块后依然存在的局部变量。</li>
<li>不能被其他文件访问的全局变量和函数。</li>
<li>属于类且不属于类对象的变量和函数。这个含义与Java相同。</li>
</ul>
<blockquote>
<p>值调用和引用调用</p>
</blockquote>
<p>C++有值调用和引用调用，用<code>&amp;</code>符号标记，可以实现修改它们的引用参数的目的。而Java则不行，Java只有值调用。</p>
<blockquote>
<p>初始化</p>
</blockquote>
<p>在C++中，不能直接初始化实例域。所有的域必须在构造器中设置。但是，有一个特殊的初始化器列表语法。C++使用这种特殊的语法来调用域构造器。在Java中没有这种必要，因为对象没有子对象，只有指向其他对象的指针。</p>
<blockquote>
<p>构造器</p>
</blockquote>
<p>在Java中，this引用等价于C++的this指针。但是，在C++中，一个构造器不能调用另一个构造器。在C++中，必须将抽取初的公共初始代码编写成一个独立的方法。</p>
<blockquote>
<p><code>#include与import</code></p>
</blockquote>
<p>这两者并没有共同之处。在C++中，必须使用#include将外部特性的声明加载近来，因为C++编译器无法查看任何文件的内部，除了正在编译的文件以及在头文件中明确包含的文件。Java编译器可以查看其他文件的内部。</p>
<p>在Java中，通过显式地给出包名，就可以不使用import；而在C++中，无法避免使用#include。</p>
<p>在C++中，与包机制类似的是命名空间(namespace)。在Java中，package与import语句类似C++中的namespace和using指令(directive)。</p>
<blockquote>
<p>Java的继承和C++的继承</p>
</blockquote>
<p>Java与C++定义继承类的方式十分相似。Java用关键字extends代替了C++的冒号(:)。在Java中，所有的继承都是公有继承，而没有C++中的私有继承和保护继承。</p>
<blockquote>
<p>调用超类及虚拟方法</p>
</blockquote>
<p>在Java中使用关键字super调用超类的方法，而在C++中则采用超类名加上::操作符的形式。</p>
<p>在Java中，不需要将方法声明为虚拟方法。动态绑定是默认的处理方式。如果不希望让一个方法具有虚拟特性，可以将它标记为final。</p>
<blockquote>
<p>根类</p>
</blockquote>
<p>C++中没有类似Java中Object的根类，不过每个指针都可以转换成<code>void*</code>。</p>
<h2 id="u9644_u5F552_Java_u6CE8_u91CA_u4E0E_u8B66_u544A"><a href="#u9644_u5F552_Java_u6CE8_u91CA_u4E0E_u8B66_u544A" class="headerlink" title="附录2 Java注释与警告"></a>附录2 Java注释与警告</h2><ul>
<li><code>System.out</code>中的<code>println</code>方法输出后自动换行，而<code>print</code>方法不换行。</li>
<li><code>/*...*/</code>注释不能嵌套。</li>
<li>Java有一个能够表示任意精度的算数包，通常称为大数值”(big number)，并不是一种新的类型，而是一个Java对象。</li>
<li>在JDK5.0中，可以使用十六进制表示浮点数值，使用p表示指数，尾数采用十六进制，指数采用十进制。指数的基数是2。</li>
<li>浮点数值不适用于禁止出现舍入误差的金融计算中。</li>
<li><code>&amp;</code> 和 <code>|</code> 运算符应用于布尔值，得到的结果也是布尔值，不按短路”方式计算。</li>
<li>如果试图将一个数值从一种类型强制转换为另一种类型，而又超出了目标类型的表示范围，就会成为一个完全不同的值。</li>
</ul>
<p>因为输入是可见的，所有Scanner类不适用于从控制台读取密码。Java SE 6特别引入了Console类实现这个目的。要想读取一个密码，可以采用下列代码</p>
<pre><code>Console cons = System.console();
String username = cons.readLine(User name: ”);
char[] passwd = cons.readPassword(Password: ”);
</code></pre><p>为了安全起见，返回的密码存放在一维字符数组中，而不是字符串中。在对密码进行处理后，应该马上用一个填充值覆盖数组元素。采用Console对象处理输入不如采用Scanner对象方便。</p>
<ul>
<li>可以构造一个带有字符串参数的Scanner，但这个Scanner将字符串解释为数据，而不是文件名。</li>
<li>在循环中，检测两个浮点数是否相等需要格外小心。</li>
<li>可以使用下面两种形式声明数组：<code>int[] a;</code> 或 <code>int a[];</code> 大多数Java应用程序员喜欢第一种。</li>
<li>在Java中允许数组长度为0。数组长度为0与null不同。</li>
<li>类的方法在前面，域在后面这种风格有易于促使人们更加关注接口的概念，削减对实现的注意。</li>
<li>不要在构造器中定义与实例域重名的局部变量。</li>
<li>注意不要编写返回引用可变对象的访问器方法，这样会破坏封装性！如果需要返回一个可变对象的引用，应该首先对它进行克隆(clone)。</li>
<li>在绝大多数的面型对象程序设计语言中，静态域被称为类域。术语<code>static</code>只是沿用了C++的叫法，并无实际意义。</li>
<li>可以使用对象调用静态方法。不过这种方式很容易造成混淆，建议使用类名来调用静态方法。</li>
<li>每一个类可以有一个<code>main</code>方法。这是一个常用于对类进行单元测试的技巧。</li>
<li>Java允许重载任何方法。因此，要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的签名(signature)。返回类型不是方法签名的一部分。</li>
<li>如果文档中有到其他文件的链接，例如，图像文件(用户界面的组建的图表或图像等)，就应该将这些文件放到子目录<code>doc-files</code>中。<code>javadoc</code>实用程序将从源目录拷贝这些目录中及其中的文件到文档目录中。在联接种需要使用<code>doc-files</code>目录，例如：<code>&lt;img src=doc-files/uml.png” alt = UML diagram”&gt;</code>。</li>
<li>注释时没必要在每一行开始用星号<code>*</code>，大部分IDE会自动添加星号<code>*</code>。</li>
<li>关键字<code>this</code>有两个用途：一是引用隐式参数，二是调用该类其他的构造器。同样，<code>super</code>关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。</li>
<li>在覆盖一个方法时，子类方法不能低于超类方法的可见性。特别是，如果超类方法是<code>public</code>，子类方法一定要声明为<code>public</code>。</li>
<li>域也可以被声明为<code>final</code>，一旦如此，构造对象之后就不允许修改其值了。不过如果将一个类声明为<code>final</code>，只有其中的方法自动称为<code>final</code>，而不包括域。</li>
<li>强烈建议为自定义的每一个类增加<code>toString</code>方法。这样做不仅自己受益，而且所有使用这个类的程序员也会受益匪浅。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里是我学习 Java 黄皮书时记录整理的笔记，时间比较久远，不保证时效性。</p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://wdxtub.com/tags/Java/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cpp 学习笔记]]></title>
    <link href="http://wdxtub.com/2016/03/20/cpp-note/"/>
    <id>http://wdxtub.com/2016/03/20/cpp-note/</id>
    <published>2016-03-20T12:00:11.000Z</published>
    <updated>2016-03-20T12:49:03.000Z</updated>
    <content type="html"><![CDATA[<p>这里是我学习《Thinking in C++》时记录整理的笔记，时间比较久远，不保证时效性。</p>
<a id="more"></a>
<hr>
<h2 id="u7B2C1_u7AE0__u5BF9_u8C61_u5BFC_u8A00"><a href="#u7B2C1_u7AE0__u5BF9_u8C61_u5BFC_u8A00" class="headerlink" title="第1章 对象导言"></a>第1章 对象导言</h2><p>本章将介绍面向对象程序设计(OOP)的基本概念，包括OOP开发方法的概述。</p>
<p>所有的程序语言都提供抽象。可以说，人们能解决的问题的复杂性直接与抽象的类型和质量有关。汇编语言时对底层机器的小幅度抽象。其后的许多所谓“命令式”语言(例如Fortran、Basic和C)都是对汇编语言的抽象。OPP允许程序员用问题本市的术语来描述问题，而不是用要运行解决方案的计算机的术语来描述问题。每个对象看上去像一台小计算机，它有状态，有可执行的运算。这似乎是现实世界中对象的很好类比，它们都有特性和行为。</p>
<p>面向对象语言的五个基本特性：</p>
<ol>
<li>万物皆对象。</li>
<li>程序就是一组对象，对象之间通过发送消息互相通知做什么。</li>
<li>每个对象都有它子集的由其他对象构成的存储区。</li>
<li>每个对象都有一个类型。</li>
<li>一个特定类型的所有对象都能接收相同的消息。</li>
</ol>
<p>创建抽象数据类型是面向对象程序设计的基本思想。抽象数据类型几乎能完全像内部类型一样工作。</p>
<p>类描述了一组有相同特性(数据元素)和相同行为(功能)的对象，因此类实际上就是数据类型。面向对象程序设计的难题之一，是在问题空间中的元素和解空间中的对象之间建立一对一的映射。</p>
<p>必须有一种方法能向对象作出请求，使得它能做某些事情。可以向对象发出的请求是由它的<code>接口(interface)</code>定义的，而接口由类型确定。接口规定我们能向特定的对象发出什么请求。然后，必须有代码满足这种请求，再加上隐藏的数据，就组成了<code>实现(implementation)</code>。</p>
<p>C++语言使用了三个明确的关键字来设置类中的边界：<code>public</code>、<code>private</code>和<code>protected</code>。<code>public</code>意味着随后的定义对所有人都可用。相反，<code>private</code>关键字则意味着，除了该类型的创建者和该类型的内部成员函数之外，任何人都不能访问这些定义。继承的类可以访问<code>protected</code>成员，但不能访问<code>private</code>成员。</p>
<p>代码重用是面向对象程序设计语言的最大优点之一。可以用任何数量和类型的其他对象组成新类，通过组合得到新类所希望的功能。因为这是由已经存在的类组成新类，所以称为<code>组合(composition)</code>【或者更通常称为<code>聚合(aggregation)</code>】。组合常常被称为<code>has-a(有)</code>关系。</p>
<p>当创建新类时，程序员应当首先考虑组合，因为它更简单和更灵活。如果采用组合的方法，设计将变得清晰。</p>
<p>克服许多困难去创造一个类，并随后强制性地创造一个有类似功能地全新地类，似乎很愚蠢。如果能选取已存在地类、克隆它，然后对这个克隆增加和修改，则是再好不过地事。这是<code>继承(inheritance)</code>带来地好处，缺点是，如果原来的类(称为基类、超类或父类)被修改，则这个修改过的“克隆”(称为派生类、继承类或子类)也会表现出这些改变。</p>
<p>当我们从已经存在的类型来继承时，我们就创造了一个新类型。这个新类性不仅包含那个已经存在的类型的所有成员，还复制了这个基类的接口，这意味着这个派生类与这个基类是相同类型的。</p>
<p>有两种方法能使新派生类区别于原始基类。第一种相当直接，简单地向派生类添加全新的函数。这些新函数不是基类接口的一部分。着意味着，这个基类不能做我们希望它做的事情，所以必须添加函数。</p>
<p>虽然继承有时意味着向接口添加新函数，但这未必真的需要。是新类有别于基类的第二个和更重要的方法是，改变已经存在的基类函数的行为，这称为<code>重载(overriding)</code>这个函数。为了重载函数，可以简单地再派生类中创建新定义。相当于说：“我正再使用同一个接口函数，但是我希望它为我做不同的事情。”</p>
<p>只重载基类(并且不添加基类中没有的新成员函数)的继承意味着派生类和基类是完全相同的类型，因为它们有相同的接口。结果是，我们可以用派生类的对象代替基类的对象。因此这被认为是<code>纯代替(pure substitution)</code>，常常被称为<code>代替原则(substitution principle)</code>。这种情况下，我们常把基类和派生类直接的关系看作是一个<code>is-a(是)</code>关系。</p>
<p>有时需要向一个派生类型添加新的接口元素，这样就扩展了接口并创建了新类型。这个新类型仍然可以代替这个基类，但这个代替不是完美的，因为这些新函数不能从基类访问，这可以描述为“is-like-a(像)”关系。</p>
<p>如果试图把派生类型的对象看做是比它们自身更一般的基本类型(圆形看做形体，自行车看做车辆)，这里就有一个问题：如果一个函数告诉一个一般的形体去绘制它子集，或者告诉一个一般的车辆去行驶，则编译器再编译时就不能确切地知道应当执行哪段代码。同样地问题是，消息发送时，程序员并不想知道将执行哪段代码。编译器不能确切地知道执行哪段代码，那么它应该怎么办呢？</p>
<p>在面向对象的程序设计中，答案非常新奇：编译器并不做传统意义上的函数调用。非OOP编译器产生的函数调用会导致与被调用代码的<code>早捆绑(early binding)</code>，其意思是：编译器会对特定的函数名产生调用，而连接器将这个调用解析为要执行代码的绝对地址。</p>
<p>在OOP中，知道程序运行时，编译器才能确定执行代码的地址，所以，当消息被发送给一般对象时，需要采用其他的方案。为了解决这一问题，面向对象语言采用<code>晚捆绑(late binding)</code>的思想。当给对象发送消息时，在程序运行时才去确定被调用的代码。编译器保证这个被调用的函数存在，并执行参数和返回值的类型检查【其中不采用这种处理方式的语言称为<code>弱类型(weakly typed)</code>语言】，但是它并不知道将执行的确切代码。</p>
<p>为了执行晚捆绑，C++编译器在真正调用的地方插入一段特殊的二进制代码。通过使用存放在对象自身中的信息，这段代码在运行时计算被调用函数函数体的地址(详见第15章)。这样每个对象就能根据这段二进制代码的内容有不同的行为。当一个对象接收到消息时，它根据这个消息判断应当做什么。</p>
<p>我们可以用关键字<code>virtual</code>声明他希望某个函数有晚捆绑的灵活性。在C++中，必须记住添加<code>virtual</code>关键字，因为根据规定，默认情况下成员函数不能动态捆绑。<code>virtual</code>函数(虚函数)可用来表示出在相同家族中的类具有不同的行为。这些不同是产生多态行为的原因。<br>我们把处理派生类型就如同处理其基类型的过程称为<code>向上类型转换(upcasting)</code>。编译器和运行系统可以处理这些细节，我们只需要知道它会这样做和知道如何用它设计程序就行了。如果一个成员函数是<code>virtual</code>的，则当我们给一个对象发送消息时，这个对象将做正确的事情，即使是在有向上类型转换的情况下。</p>
<p>对象的数据存放在何处？如何控制对象的生命期？不同的设计语言有不同的处理方式。C++才去的方法是把效率控制作为最重要的问题，所以它为程序员提供了一个选择。为了最大化运行速度，通过将对象存放在栈中或静态存储区域中，存储和生命期可以在编写程序时确定。栈是内存中的一个区域，可以直接由微处理器在程序执行期间存放数据。在栈中的变量有时称<code>自动变量(automatic variable)</code>或<code>局部变量(scoped variable)</code>。静态存储区简单说是内存的一个固定块，在程序开始执行以前分配。使用栈或静态存储区，可以快速分配和释放，但是我们因此也牺牲了灵活性。</p>
<p>第二种方法是在称为<code>堆(heap)</code>的区域动态创建对象。用这种方法，可以直到运行时还不知道需要多少个对象，它们的生命期是什么和他们的准确数据类型是什么。这些决定是在程序运行之中作出的。如果需要心的对象，直接使用<code>new</code>关键字让它在堆上生成。当使用结束时，用关键字<code>delete</code>释放。</p>
<p>另一个问题是对象的生命期。如果在栈上或在静态存储上创建一个对象，编译器决定这个对象持续多长时间并能自动销毁它。然后，如果在堆上创建它，编译器则不知道它的生命期。在C++中，程序员必须编程决定何时销毁此对象。作为一个替换，运行环境可以提供一个称为<code>垃圾收集器(garbage collector)</code>的功能。当然，使用垃圾收集器编写程序是非常方便的，但是它需要所有应用软件能承受垃圾收集器的存在及垃圾收集的系统开销。</p>
<p>从程序设计语言出现开始，错误处理就是最重要的问题之一。因为设计一个好的错误处理方案非常困难，许多语言忽略这个问题，将这个问题转交给库的设计者，而库的设计者往往采取不彻底的措施，即可以在许多情况下起作用，但很容易被绕考，通常是被忽略。</p>
<p><code>异常处理(exception handling)</code>将错误处理直接与程序设计语言甚至有时是操作系统联系起来。异常是一个对象，它在出错的地方被抛出，并且被一段用以处理特定类型错误的<code>异常处理代码(exception handler)</code>所接收。异常处理似乎是另一个并行的执行路径，在出错的时候被调用。由于它使用一个单独的执行路径，它并不需要干涉正常的执行代码。因为不需经常检查错误，代码可以很简洁。另外，异常并不同于一个由函数返回的错误值或标记，后两者可以被忽略，而异常不能被忽略，必须保证它们在某些点上进行处理。最后，异常提供了一个从错误状态中进行可靠恢复的方法。除了从这个程序中退出以外，我们常常还可以作出正确的设置，并且回复程序执行，这有助于产生更健壮的系统。</p>
<p><code>方法(method)</code>［通常称为方法论(methodology)］是一系列的过程和探索，用以降低程序设计问题的复杂性。</p>
<p>经历开发过程时，最重要的问题是：不要迷路。如果不定因素不止一个，在没有创建一个能工作的原型之前，不要计划它将用多长时间和花费多少，这里的自由度太大了。</p>
<p>应当牢记我们正在努力寻找的是什么：</p>
<ul>
<li>什么是对象(如何将项目分成多个组成部分？)</li>
<li>它们的接口是什么？(需要向每个对象发送什么信息？)</li>
<li>整个过程可以分5个阶段完成，阶段0只是使用一些结构的初始约定。</li>
</ul>
<p>我们必须首先决定在此过程中应当有哪些步骤。无论建造什么系统，不管如何复杂，都有其基本的目的，有其要处理的业务，有所满足的基本需要。通过各种观察，我们将最终找出它的核心，通常简单而又直接。</p>
<p>这个相当重要，因为它设定了项目的基调，这是一种任务陈述。我们不必一开始就让它正确，但是要不停地努力使其越来越正确。</p>
<p>这一阶段我们有必要把注意力始终放在核心问提上：确定这个系统要做什么。为此，最有价值的工具是一组所谓的<code>用例(use case)</code>。用例之明了系统中的关键特性，它们将展现我们使用的一些节本的类。它们实际上是对类似于下列问题的描述性回答：</p>
<ul>
<li>“谁将使用这个系统？”</li>
<li>“执行者用这个系统做什么？”</li>
<li>“执行者如何用这个系统工作？”</li>
<li>“如果其他人也做这件事，或者同一个执行者有不同的目标，该怎么办？(揭示变化)”</li>
<li>“当使用这个系统时，会发生什么问题？(揭示异常)”</li>
</ul>
<p>只要符合用户的使用感受，系统实际上如何实现并不重要。</p>
<p>在这一阶段，我们必须作出设计，描述这些类和它们如何交互。确定类和交互的出色技术就是：<strong>类职责协同(Class-Responsibility-Collaboration，CRC)卡片</strong>。</p>
<p>这个技术非常简单：只要有一组小空白卡片，在上面书写。每张卡片描述一个类，所写的内容有：</p>
<ul>
<li>类的名字。体现类行为的本质，一目了然的作用。</li>
<li>类的职责。它应当做什么。通常，它可以仅由成员函数的名字陈述。</li>
<li>类的协同：它与其他类有哪些交互？如果一张小卡片上放不下类所需要的信息，那么这个类就太复杂了(或者是考虑过细了，或者应当创建多个类)。理想的类应该一目了然。</li>
</ul>
<p>对象开发准则：</p>
<ul>
<li>让特定问题生成一个类，然后在解决其他问题期间让这个类生长和成熟。</li>
<li>记住，发现所需要的类(和它们的接口)，是设计系统的主要内容。如果已经有了那些类，这个项目就不困难了。</li>
<li>不要强迫自己在一开始就知道每一件事情，应当不断学习。</li>
<li>开始编程，让一部分能够运行，这样就可以证明或否定已生成的设计。不要害怕过程型大杂烩式的代码──类的隔离性可以控制它们。坏的类不会破坏好的类。</li>
<li>尽量保持简单。具有明显用途的不太清楚的对象比很复杂的接口好。从小的和简单的类开始，当我们对它有了较好的理解时再拓展这个类接口，但是很难从一个类中删去元素。</li>
</ul>
<p>这是从粗线条设计向便宜和执行可执行代码体的最初转换阶段，特别是，它将证明或者否定我们的体系结构。这不是一遍的过程，而是反复地建立系统的一系列步骤的开始。</p>
<p>一旦代码框架运行起来，我们增加的每一组特征本身就是一个小项目。在一次<code>迭代(iteration)</code>期间，我们增加一组特征，一次迭代是一个相当短的开发时期。</p>
<p>理想情况下，每次迭代为一到三个星期，在这个期间的最后，我们得到一个集成的、测试过的、比前一周期有更多功能的系统。</p>
<p>通过这些过程，我们可以更早地揭露和解决严重问题，客户有足够的机会改变它们的意见，程序员会更满意，能更精确地掌握项目。</p>
<p>这是开发周期中，传统上称为“维护”的一个阶段。我们不可能第一次就使软件正确，所以应当为学习、返工和修改留有余地。</p>
<p>“使软件正确”的意思不只是使程序按照要求和用例工作，还意味着我们理解代码的内部结构，并且认识到它能很好地协同工作，没有拙笨的语法和过大的对象，也没有难看的暴露的代码。</p>
<p>提出一个漂亮的方案感觉上更接近于艺术，而不是技术。精致总是有回报的，这不是一种虚浮的追求。它不仅给除了一个容易建造和调试的程序，而且容易理解和维护，这就是其经济价值的体现。</p>
<p>XP既是程序设计工作的哲学，又是做程序设计的一组原则。有两个原则最重要：“先写测试”和“结对编程”。</p>
<p>先写测试有两个及其重要的作用：</p>
<ul>
<li>它强制类的接口有清楚的定义。</li>
<li>能在每次编连软件时运行这些测试。</li>
</ul>
<p><code>结对编程(pair programming)</code>反对深植于我们心中的个人主义，一个人编写代码时另一个人在思考。思考者的头脑中保持总体概念，不仅是手头问题这一段，而且还有XP指导方针。这种结对方式，使事情顺畅、有章可循。</p>
<h2 id="u7B2C2_u7AE0__u5BF9_u8C61_u7684_u521B_u5EFA_u4E0E_u4F7F_u7528"><a href="#u7B2C2_u7AE0__u5BF9_u8C61_u7684_u521B_u5EFA_u4E0E_u4F7F_u7528" class="headerlink" title="第2章 对象的创建与使用"></a>第2章 对象的创建与使用</h2><h3 id="u8BED_u8A00_u7684_u7FFB_u8BD1_u8FC7_u7A0B"><a href="#u8BED_u8A00_u7684_u7FFB_u8BD1_u8FC7_u7A0B" class="headerlink" title="语言的翻译过程"></a>语言的翻译过程</h3><p>任何一种计算机语言都要从某种人们理解的形式(源代码)转化成计算机能执行的形式(机器指令)。通常，翻译器分为两类：<code>解释器(interpreter)</code>和<code>编译器(compiler)</code>。</p>
<p><strong>解释器(interpreter)</strong></p>
<p>将源代码转化成一些动作并立即执行这些动作。使用解释器有许多好处。从写代码到执行代码的转换几乎能立即完成，并且源代码总是显存，所以一旦出现错误，解释器能很容易地指出。另外的优点是较好的交互性和适于快速程序开发。</p>
<p>做大项目时候就有某些局限性。要求一次输入整个源代码，一旦出现错误，就很难调试。</p>
<p><strong>编译器(compiler)</strong></p>
<p>编译器直接把源代码转化成汇编语言或机器指令。某些语言可以分别编译各段程序，最后使用<code>连接器(linker)</code>把各段程序连接成一个完整的可执行程序。这个过程称为<code>分段编译(separate compilation)</code>。</p>
<p>某些语言(特别是C/C++)编译时，首先要对源代码执行预处理。<code>预处理器(preprocessor)</code>是一个简单的程序，用程序员(利用预处理器指令)定义好的模式代替源代码中的模式。</p>
<p>编译一般分两遍进行。首先，对预处理过的代码进行语法分析。编译器把源代码分解成小的单元并把它们按树形结构组织起来。有时候会在编译的第一遍和第二遍之间使用<code>全局优化器(global optimizer)</code>来生成更短、更快的代码。</p>
<p>编译的第二遍由<code>代码生成器(code generator)</code>遍历语法分析树，把树的每个节点转化成汇编语言或机器代码。</p>
<p><code>类型检查(type checking)</code>是编译器在第一遍中完成的。类型检查是检查函数参数是否正确使用，以防止许多程序设计错误。由于类型检查是在编译阶段而不是程序运行阶段进行的，所以称之为<code>静态类型检查(static type checking)</code>。在C++里可以不使用静态类型检查。我们可以自己做动态类型检查──这只需要写一些代码。</p>
<h2 id="u7B2C3_u7AE0_C++_u4E2D_u7684C"><a href="#u7B2C3_u7AE0_C++_u4E2D_u7684C" class="headerlink" title="第3章 C++中的C"></a>第3章 C++中的C</h2><p>全局变量是在所有函数体的外部定义的，程序的所有部分(甚至其他文件中的代码)都可以使用。全局变量不受作用域的影响，总是可用的(也就是说，全局变量的生命期一直到程序的结束)。如果在一个文件中存在全局变量，那么这个文件可以使用这个数据。</p>
<p>局部变量出现在一个作用域内，它们是局限于一个函数的。局部变量经常被称为<code>自动变量(automatic variable)</code>，因为它们在进入作用域时自动生成，离开作用域时自动消失。<br>寄存器变量是一种局部变量，最好避免使用关键字<code>register</code>。</p>
<p>关键字<code>static</code>有一些独特的意义。通常，函数中定义的局部变量在函数作用域结束时小时。当再次调用这个函数时，会重新创建该变量的存储空间，其值会被重新初始化。如果想使局部变量的值在程序的整个生命期里仍然存在，就可以定义函数的局部变量为<code>static</code>，并给它一个初始值。初始化只在函数第一次调用时执行，函数调用之间变量的值保持不变。用这种方式，函数可以“记住”函数调用之间的一些信息片段。</p>
<p><code>static</code>变量的优点是在函数范围之外它是不可用的，所以它不可能被轻易地改变。这会使错误局部化。</p>
<p><code>static</code>的第二层意思和前面的含义相关，即“在某个作用域外不可访问”。当应用<code>static</code>于函数名和所有函数外部的变量时，它的意思是“在文件的外部不可以使用这个名字”。函数名或变量是局部于文件的；我们说它具有<code>文件作用域(file scope)</code>。即使在另一个文件用<code>extern</code>声明，连接器也不会找到它。</p>
<p><code>extern</code>关键字告诉编译器存在着一个变量和函数，即使编译器在当前编译的文件中没有看到它，这个变量或函数可能在另一个文件中或者在当前文件的后面定义。</p>
<p><strong>连接(linkage)</strong></p>
<p>连接用连接器所见的方式描述存储空间。连结方式有两种：<code>内部连接(internal linkage)</code>和<code>外部连接(external linkage)</code>。内部连接意味着只对正被编译的文件创建存储空间。用内部连接，别的文件可以使用相同的标识符或全局变量，连接器不会发现冲突──也就是为每一个标识符创建单独的存储空间。在C和C++中，内部连接是由关键字static指定的。</p>
<p>外部连接意味着所有被编译过的文件创建一片单独的存储空间。一旦创建存储空间，连接器必须解决所有对这片存储空间的引用。</p>
<p>所有的运算符都会从它们的操作数中产生一个值。除了赋值、自增、自减运算符之外，运算符所产生的值不会修改操作数。修改操作数被称为<code>副作用(side effect)</code>。一般使用修改操作数的运算就是为了产生这种副作用。</p>
<p>可以作为一个运算符用于分隔表达式。在这种情况下，它只产生最后一个表达式的值。在逗号分隔的列表中，其余的表达式的计算只完成它们的副作用。</p>
<p>通常，除了作为一个分隔符，逗号最好不作他用，因为人们不习惯把它看作是运算符。</p>
<h2 id="u7B2C4_u7AE0__u6570_u636E_u62BD_u8C61"><a href="#u7B2C4_u7AE0__u6570_u636E_u62BD_u8C61" class="headerlink" title="第4章 数据抽象"></a>第4章 数据抽象</h2><p>库只是他人已经写好的一些代码，按照某种方式包装在一起。通常，最小的包是带有拓展名(如lib)的文件和向编译器声明库中有什么的一个或多个头文件。在跨越多种体系结构的平台(例如Linux和Unix)上，通常，提供库的最明智的方法是使用源代码，这样它就能在心的目标机上被重新配置和编译。</p>
<p>所以，库大概是改进生产效率的最重要的方法。C++的主要设计目标之一就是使库使用起来更加容易。</p>
<p>在C++中，对象就是变量，它的最纯正的定义是“一块存储区”(更明确的说法是，“对象必须有惟一的标识”，在C++中是一个惟一的地址)。它是一块空间，在这里能存放数据，而且还隐含着对这些数据进行处理的操作。</p>
<p>将数据连同函数捆绑在一起的能力可以用于创建新的数据类型。这常常被称为封装(encapsulation)。称为抽象数据类型(abstract data type)，也许这是因为它能允许从问题空间抽象概念到解空间。对抽象数据类型[有时称为用户定义类型(user-defined type)]的类型检查就像对内建类型的类型检查一样严格。</p>
<p>头文件是我们和我们的库的用户之间的合约。这份合约描述了我们的数据结构，为函数调用贵点了参数和返回值。</p>
<p>通过要求我们在使用结构和函数之前声明所有这些结构和函数，在定义成员函数之前声明这些成员函数，编译器强制履行这个合约。</p>
<p>放到头文件中的基本原则是“只限于声明”，即只限于对编译器的信息，不涉及通过生成代码或创建变量而分配存储的任何信息。</p>
<p>对于包含结构的每个头文件，应当首先检查这个头文件是否已经包含在特定的cpp文件中，如：</p>
<pre><code>#ifndef HEADER_FLAG
#define HEADER_FLAG
// Type declaration here...
#endif // HEADER_FLAG
</code></pre><p>防止多次包含的这些预处理器语句常常称为包含守卫(include guard)。</p>
<h2 id="u7B2C5_u7AE0__u9690_u85CF_u5B9E_u73B0"><a href="#u7B2C5_u7AE0__u9690_u85CF_u5B9E_u73B0" class="headerlink" title="第5章 隐藏实现"></a>第5章 隐藏实现</h2><p>在任何关系中，设立相关各方面都遵从的边界是很重要的。需要控制对结构成员的访问有两个理由：一是让客户程序员远离一些它们不需要使用的工具，这些工具对数据类型内部的处理来说是必需的，但对客户程序员解决特定问题的接口却不是必须的。另一个理由是允许库的设计者改变struct的内部实现，而不必担心会对客户程序员产生影响。</p>
<p>引进了三个<code>访问说明符(access specifier)</code>：<code>public</code>、<code>private</code>和<code>protected</code>。无论什么时候使用访问说明符，后面必须加一个冒号。</p>
<ul>
<li><code>public</code>意味着在其后声明的所有成员可以被所有的人访问。</li>
<li><code>private</code>关键字则意味着，除了该类型的创建者和类的内部成员函数之外，任何人都不能访问。</li>
<li><code>protected</code>与<code>private</code>基本相似，只有一点不同：继承的结构可以访问<code>protected</code>成员，但不能访问<code>private</code>成员。</li>
</ul>
<p>如果想允许显示地不属于当前结构的一个成员函数访问当前结构中的数据，可以在该结构内部声明这个函数为<code>friend(友元)</code>。注意，一个<code>friend</code>必须在一个结构内声明，这一点很重要。</p>
<p>嵌套的结构并不能自动获得访问private成员的权限。要获得访问私有成员的权限，必须存手特定的规则：首先声明(而不定义)一个嵌套的结构，然后声明它是全局范围使用的一个<code>friend</code>，最后定义这个结构。结构的定义必须与<code>friend</code>声明分开，否则编译器将不把它看做成员。</p>
<p>C++不是完全的面向对象语言，而只是一个混合产品。增加friend关键字就是为了用来解决一些实际问题。这也说明了这种语言是不纯的。毕竟C++语言的设计目的是使用，而不是追求理想的抽象。</p>
<p>访问说明符是结构的一部分，它们并不影响从这个结构创建的对象。程序开始运行之前，所有的访问说明信息都消失了。访问说明信息通常是在编译期间消失的。</p>
<p>一般说来，在程序员编写程序时，依赖特定实现的任何东西都是不合适的。如确有必要，这些特定实现部分应封装在一个结构之内，这样当环境改变时，只需修改一个地方就行了。</p>
<p>访问控制通常是指<code>实现细节的隐藏(implementation hiding)</code>。将函数包含到一个结构内(常称为封装)来产生一种带数据和操作的数据类型，由访问控制在该数据类型之内确定边界。</p>
<p>然后在C++中的<code>class</code>逐渐变成了一个非必要的关键字。它和<code>struct</code>的每个方面都是一样的，除了class中的成员默认为<code>private</code>，而<code>struct</code>中的成员默认为<code>public</code>。</p>
<p>C++中的访问控制允许将实现部分与接口部分分开，但实现部分的隐藏是不完全的。编译器仍然必须知道一个对象所有部分的声明。但C++要尽可能多地在编译期间作静态类型检查。这意味着尽早捕获错误，也意味着程序具有更高的效率。然后包含似有实现部分会带来两个影响：一是既是客户程序员不能轻易地访问私有实现部分，但可以看到它；二是造成一些不必要的重复编译。</p>
<p>有些项目不可让最终客户程序员看到其实现部分，就有必要把一个变一号的实际结构放在实现文件中，而不是让其暴露在头文件中。</p>
<p>在我们的编译环境中，当一个文件被修改，或它所依赖的头文件被修改时，项目管理员需要重复编译该文件。这意味着程序员无论何时修改了一个类，无论修改的是公共的接口部分，还是私有成员的声明部分，他都必须再次编译包含头文件的所有文件。这就是通常所说的<code>易碎的基类问题(fragile base-class problem)</code>。对于一个大的项目而言，在开发初期这可能非常难以处理，因为内部实现部分可能需要经常改动。如果这个项目非常大，用于编译的时间过多可能妨碍项目的快速转型。</p>
<p>解决这个问题的技术有时称为<code>句柄类(handle class)</code>或称为<code>Cheshire cat</code>。有关实现的任何东西都消失了，只剩一个单指针“smile”。该指针指向一个结构，该结构的定义与其所有的成员函数的定义一同出现在实现文件中。这样，只要接口部分不改变，头文件就不需变动，而实现部分可以按需要任意更改，完成后只需要对实现文件进行重新编译，然后重新连接到项目中。</p>
<h3 id="u7B2C6_u7AE0__u521D_u59CB_u5316_u4E0E_u6E05_u9664"><a href="#u7B2C6_u7AE0__u521D_u59CB_u5316_u4E0E_u6E05_u9664" class="headerlink" title="第6章 初始化与清除"></a>第6章 初始化与清除</h3><p>C++中，初始化和清楚的概念是简化库的使用的关键所在，并可以减少那些在客户程序员忘记去完成这些操作时会引起的细微错误。</p>
<p>类的设计者可以通过提供一个叫做构造函数(constructor)的特殊函数来保证每个对象都被初始化。如果一个类有构造函数，编译器在创建对象时就自动调用这一函数。构造函数的名字与类的名字一样。这样的函数在初始化时会被自动调用。</p>
<p>构造函数和析构函数是两个非常特殊的函数：它们没有返回值。</p>
<p>在程序中创建和消除一个对象的行为非常特殊，就像出生和死亡，而且总是由编译器来调用这些函数以确保它们被执行。如果它们有返回值，要么编译器必须知道如何处理返回值，要么就只能由客户程序员子集来显式的调用构造函数与析构函数，这样一来，安全性就被破坏了。</p>
<p>在一个库中，对于一个曾经用过的对象，如果不做处理，对象就永远不会消失。在C++中，清除就像初始化一样重要，它通过析构函数来保证清除的执行。</p>
<p>析构函数的语言与构造函数一样，用类的名字作为函数名。然而析构函数前面加上一个代字号(～)，以和构造函数区别。</p>
<p>当对象超出它的作用域时，编译器将自动调用析构函数。</p>
<p>在C++中，应该在尽可能靠近变量的使用点处定义变量，并在定义时就初始化。这是出于安全性的考虑，通过减少变量在块中的生命周期，就可以减少该变量在块的其他地方被误用的机会。</p>
<p>集合(aggregate)就是多个事物聚集在一起。这个定义包括混合类型的集合。</p>
<p><code>默认构造函数(default constructor)</code>就是不带任何参数的构造函数。一旦有了一个构造函数，编译器就会确保不关在什么情况下它总是会被调用。</p>
<p>尽管编译器会创建一个默认的构造函数，但是编译器合成的构造函数的行为很少是我们期望的。我们应该把这个特征看成是一个安全网，但尽量少用它。一般说来，应该明确地定义子集的构造函数，而不让编译器来完成。</p>
<h2 id="u7B2C7_u7AE0__u51FD_u6570_u91CD_u8F7D_u4E0E_u9ED8_u8BA4_u53C2_u6570"><a href="#u7B2C7_u7AE0__u51FD_u6570_u91CD_u8F7D_u4E0E_u9ED8_u8BA4_u53C2_u6570" class="headerlink" title="第7章 函数重载与默认参数"></a>第7章 函数重载与默认参数</h2><p>能使名字方便使用，是任何程序设计语言的一个重要特征。</p>
<p>尽管函数重载对构造函数来说是必须的，但是它仍然是一个通用的方便手段，并可以与任意函数一起使用。另外，函数重载意味着，我们有两个库，它们都有同名的函数，只要它们的参数列表不同就不会发生冲突。</p>
<p>可以对不同的函数用同样的名字，只要求函数的参数不同，编译器会修饰这些名字、范围和参数来产生内部名以供它和连接器使用。</p>
<p>仅仅依靠返回值来重载函数实在过于微妙，所以在C++中禁止这样做。</p>
<p>对名字修饰还可以带来一个额外的好处。在C中，如果用户错误地声明了一个函数，或者更糟糕地，一个函数还没声明就调用了，而编译器则按照函数被调用的方式去推断函数的声明。若这样的推断不正确，那么就会变成一个很难发现的错误。</p>
<p>在C++中，所有的恶函数在被使用前都必须事先声明，因此出现上述情况的机会大大减少了。名字修饰会给我们提供一个安全网，这也就是人们常说的<code>类型安全连接(type-safe linkage)</code>。</p>
<p><code>默认参数(default argument)</code>是在函数声明时就已给定的一个值，如果在调用函数时没有指定这一参数的值，编译器就会自动地插上这个值。</p>
<p>在使用默认参数时必须记住两条规则。第一，只有参数列表的后部参数才是可默认的，也就是说，不可以在一个默认参数后面又跟一个非默认的参数。第二，一旦在一个函数调用中开始使用默认参数，那么这个参数后面的所有参数都必须是默认的。</p>
<p>默认参数只能放在函数声明中，通常在一个头文件中。编译器必须在使用该函数之前知道默认值。有时人们为了阅读方便在函数定义处放上你一些默认的注释值。</p>
<h2 id="u7B2C8_u7AE0__u5E38_u91CF"><a href="#u7B2C8_u7AE0__u5E38_u91CF" class="headerlink" title="第8章 常量"></a>第8章 常量</h2><p>常量概念(由关键字const表示)是为了使程序员能够在变和不变之间画一条界线。这在C++程序设计项目中提供了安全性和可控性。</p>
<p>可以使指针成为<code>const</code>。当处理<code>const</code>指针时，编译器仍将努力避免存储分配并进行常量折叠。如果程序员以后想在程序代码中改变<code>const</code>这种指针的使用，编译器将给出通知。这大大增加了安全性。</p>
<p>当使用带有指针的<code>const</code>时，有两种选择：<code>const</code>修饰指针正指向的对象，或者<code>const</code>修饰在指针里存储的地址。</p>
<p>定义指针的技巧是在标识符的开始处读它并从里向外读。<code>const</code>修饰“最靠近”它的那个。如：<code>const int* u;</code> 可以读成：u是一个指针，它指向一个<code>const int</code>。</p>
<p>使指针本身称为一个<code>const</code>指针，必须把<code>const</code>标明的部分放在<em>的右边。如：`int d = 1; int </em> const w = &d;<code>可以读成</code>w<code>是一个</code>const<code>指针指向一个</code>int`。</p>
<p>因为指针本事现在是<code>const</code>指针，编译器要求给它一个初始值，这个值在指针生命期内不变。然而要干煸它所指向的值是可以的：<code>*w = 2;</code></p>
<p>当然也可以把一个<code>const</code>指针指向一个<code>const</code>对象。</p>
<p>如果可能的话，一行只定义一个指针，并尽可能在定义时初始化。</p>
<p>可以把一个非<code>const</code>对象的地址赋给一个<code>const</code>指针，因为也许有时不想改变某些可以改变的东西。然后不能把一个<code>const</code>对象的地址赋给一个非<code>const</code>指针，因为这样做可能通过被赋值的指针改变这个对象的值。</p>
<p>如果函数是按值传递，则可用指定参数是<code>const</code>的。这里参数不能被改变。所以它其实是函数创建者的工具，而不是函数调用者的工具。</p>
<p>为了不使调用者很小，在函数内部用<code>const</code>限定参数优于在参数表里用<code>const</code>限定参数。可以用一个指针来实现，但更好的语法形式是“引用”。简而言之，引用相一个被自动间接引用的常量指针，它的作用是成为对象的别名。为建立一个引用，在定义里使用<code>&amp;</code>。</p>
<p>如果一个函数的返回值是一个常量(const)，这就约定了函数框架里的原变量不会被修改。另外，因为这是按值返回的，所以这个变量被制成副本，舍得初值不会被返回值所修改。</p>
<p>对于内部类型来说，按值返回的是否是一个const，是无关紧要的，所以按值返回一个内部类型时，应该去掉const，从而不使客户程序员混淆。</p>
<p>当处理用户定义的类型时，按值返回常量是很重要的。如果一个函数按值返回一个类对象为const时，那么这个函数的返回值不能是一个左值(不能被赋值或修改)。</p>
<p>如果传递或返回一个地址(一个指针或一个引用)，客户程序员去取地址并修改其初值是可能的。如果使这个指针或者引用成为const，就会阻止这类事的发生，这是非常重要的事情，事实上，无论什么时候传递一个地址给一个函数，都应该尽可能用const修饰它。如果不这样做，就不能以const指针参数的方式使用这个函数。</p>
<p>常数表达式使用常量的地方之一是在类里。典型的例子是在一个类里建立一个数组，并用const代替#define设置数组大小。数组大小一直隐藏在类里，这样，如果用size表示数组大小，就可以把size这个名字用在另一个类里而不发生冲突。</p>
<p>读者可能认为合乎逻辑的选择是把一个const放在类里。但这样不会产生预期的效果。在一个类里，const又部分恢复到它在C语言中的含义。它在每个类对象里分配存储并代表一个值，这个值一旦被初始化以后就不能改变。在一个类里使用const意味着“在这个对象生命期内，它是一个常量”。然而，对这个常量来讲，每个不同的对象可以含有一个不同的值。</p>
<p>这样，在一个类里建立一个普通的(非static的)const时，不能给它初值。这个初始化工作比须在构造函数里进行，当然，要在构造函数的某个特别的地方进行。因为const必须在建立它的地方被初始化，所以在构造函数的主体里，const必定已被初始化了。否则，就只有等待，直到在构造函数主体以后的某个地方给它初始化，这意味着过一会儿才给const初始化。当然，无法防止在构造函数主体的不同地方改变const的值。</p>
<p><strong>构造函数初始化列表</strong></p>
<p>在构造函数里有个专门初始化的地方，这就是<code>构造函数初始化列表(constructor initializer list)</code>，起初用在机成立。构造函数初始化列表是一个出现在函数参数表和冒号后，但在构造函数主体开头的花括号前的“函数调用列表”。这提醒人们，表里的初始化发生在构造函数的任何代码执行之前。这是初始化所有<code>const</code>的地方，若<code>size</code>是<code>Fred</code>类的一个<code>const</code>成员的话，其正确形式是：</p>
<pre><code>Fred::Fred(int sz) : size(sz){}
</code></pre><p>把一个内部类型风装载一个类里以保证用构造函数初始化，这是很有用的。</p>
<p>若要让类有编译期间的常量成员，就要求使用另外一个关键字<code>static</code>。在这种情况下，关键字<code>static</code>意味着“不管类的对象被创建多少次，都只有一个实例”。因此，一个内部类型的<code>static const</code>可以看作一个编译期间的常量。</p>
<p>必须在<code>static const</code>定义的地方对它进行初始化。</p>
<p>如果声明一个成员函数为<code>const</code>(修饰符<code>const</code>放在函数参数表的后面)，则等于告诉编译器该成员函数可以为一个<code>const</code>对象所调用。一个没有被明确声明为<code>const</code>的成员函数被堪称是将要修改数据成员的函数，而且编译器不允许它为一个<code>const</code>对象所调用。</p>
<p>关键字<code>const</code>必须同样的方式重复出现在定义里，否则编译器把它看成一个不同的函数！<br>一个<code>const</code>成员函数调用<code>const</code>和非<code>const</code>对象是安全的，因此，可以把它看做成员函数的最一般形式。不修改数据成员的任何函数都应该把它们声明为<code>const</code>，这样它可以和<code>const</code>对象一起使用。</p>
<p><code>volatile</code>的语法与<code>const</code>是一样的，但是<code>volatile</code>的意思是“在编译器认识的范围外，这个数据可以被改变”。不知何故，环境正在改变数据(可能通过多任务、多线程或者中断处理)，所以，<code>volatile</code>告诉编译器不要擅自作出有关该数据的任何假定，优化期间尤其如此。</p>
<h2 id="u7B2C9_u7AE0__u5185_u8054_u51FD_u6570"><a href="#u7B2C9_u7AE0__u5185_u8054_u51FD_u6570" class="headerlink" title="第9章 内联函数"></a>第9章 内联函数</h2><p>C++从C中集成的一个重要特征是效率。加入C++的效率显著地低于C的效率，那么就会有很大一批程序员不去使用它。</p>
<p>为了既保持预处理器宏的效率又增加安全性、而且还能像一般成员函数一样可以在类里访问自如，C++引入了内联函数(inline function)</p>
<p>预处理器宏存在问题的关键是我们可能认为预处理器的行为和编译器的行为一样。</p>
<p>在解决C++中宏访问private类成员的问题过程中，所有和预处理器宏有关的问题也随之排除了。这是通过使宏被编译器控制来实现的。在C++中，宏的概念是作为内联函数(inline function)来实现的，而内联函数无论从哪一方面上说都是真正的函数。</p>
<p>任何在类中定义的函数自动成为内联函数，但也可以在非类的函数前面加上inline关键字使之称为内联函数。但为了使之有效，必须使函数体和声明结合在一起，否则，编译器将它作为普通函数对待。</p>
<p>一般应该把内联定义放在头文件里。当编译器看到这个定义时，它把函数类型(函数名+返回值)和函数体放到符号表里。当使用函数时，编译器检查以确保调用是正确的且返回值被正确使用，然后将函数调用替换为函数体，因而消除了开销。内联代码的确占用空间，但假如函数较小，这实际上比为了一个普通函数调用而产生的代码(参数压栈和执行CALL)占用的空间还小。</p>
<p>类内部的内联函数节省了在外部定义成员函数的额外步骤，所以我们一定想在类声明内每一处都使用内联函数。但应记住，使用内联函数的目的是减少函数调用的开销。但是，假如函数较大，由于需要在调用函数的每一处重复复制代码，这样将使代码膨胀，在速度方面获得的好处就会减少。</p>
<p>在类中内联函数的最重要的使用之一是用做<code>访问函数(access function)</code>。这是一个小函数，它容许读或修改对象状态──即一个或几个内部变量。即最通常所说的<code>set</code>与<code>get</code>方法(修改器和访问器)。</p>
<p>对于函数，编译器在它的符号表里放入函数类型(即包括名字和参数类型的函数原型及函数的返回类型)。另外，当编译器看到内联函数和对内联函数体的分析没有发现错误时，就将对应于函数体的代码也放入符号表。代码是以源程序形式存放还是以编译过的汇编指令形式存放取决于编译器。</p>
<p>当调用一个内联函数时，编译器首先确保调用正确，即所有的参数类型必须满足：要么与函数参数表中的参数类型一样，要么编译器能够将其转换为正确类型，并且返回值在目标表达式里应该是正确类型或可改变为正确类型。</p>
<p>有两种编译器不能执行内联的情况。在这些情况下，它就像对非内联函数一样，根据内联函数定义和为函数建立存储空间，简单地将其转换为函数的普通形式。</p>
<p>加入函数太复杂，编译器将不能执行内联。这取决于特定的编译器，但对大多数编译器这时都回放弃内联方式，因为这时内联可能不能提高任何效率。一般地，任何种类的循环都被认为太复杂。</p>
<p>内联仅是编译器的一个建议，编译器不会被强迫内联任何代码。一个好的编译器将会内联小的、简单的函数，同时明智地忽略那些太复杂的内联。这将给我们想要的结果──具有宏效率的函数调用的真正语义学。</p>
<p>当一个内联函数在类中向前引用一个还没有声明的函数时，是可以正常工作的，因为C++语言规定：只有在类声明结束后，其中的内联函数才会被计算。</p>
<h2 id="u7B2C10_u7AE0__u540D_u5B57_u63A7_u5236"><a href="#u7B2C10_u7AE0__u540D_u5B57_u63A7_u5236" class="headerlink" title="第10章 名字控制"></a>第10章 名字控制</h2><p>创建名字是程序设计过程中一项最基本的活动，当一个项目很大时，它会不可避免地包含大量的名字。</p>
<p>关于static的所有使用最基本的概念是指“位置不变的某个东西”，不管这里是指在内存中的物理位置还是指在文件中的可见性。</p>
<p>在C和C++中，static都有两种基本的含义，并且这两种含义经常是相互冲突的：</p>
<ul>
<li>在固定的地址上进行存储分配，也就是说对象是在一个特殊的静态数据区(static data area)上创建的，而不是每次函数调用时在堆栈上产生的。这也是静态存储的概念。</li>
<li>对一个特定的编译单位来说是局部的。这样，static控制名字的可见性(visibility)，所以这个名字在这个单元或类外是不可见的。这也描述了连接的概念，它决定连接器将看到哪些名字。</li>
</ul>
<p>通常，在函数体内定义一个局部变量时，编译器在每次函数调用时使堆栈的指针下移到一个适当的位置，为这些局部变量非配内存。如果这个变量又一个初始化表达式，那么每当程序运行到此处，初始化就被执行。</p>
<p>然而，有时想在两次函数调用之间保留一个变量的值，可以通过定义一个全局变量来实现，但这样一来，这个变量就不仅仅只受到这个函数的控制。C和C++都允许在函数内部定义一个static对象，这个对象将存储在静态数据区中，而不是在堆栈中。这个对象只在第一次调用是初始化一次，以后它将在两次函数调用之间保持它的值。</p>
<p>一般情况下，在<code>文件作用域(file scope)</code>内的所有名字(即不嵌套在类或函数中的名字)对程序中的所有翻译单元来说都是可见的。这就是所谓的<code>外部连接(external linkage)</code>，因为在连接时这个名字对连接器来说是可见的，对单独的翻译单元来说，它是外部的。全局变量和普通函数都有外部连接。</p>
<p>在文件作用域内，一个被明确声明为static的对象或函数的名字对翻译单元来说是局部于该单元的。这些名字有<code>内部连接(internal linkage)</code>。</p>
<p>内部连接的一个好处是这个名字可以放在一个头文件中</p>
<h2 id="u7B2C11_u7AE0__u5F15_u7528_u548C_u62F7_u8D1D_u6784_u9020_u51FD_u6570"><a href="#u7B2C11_u7AE0__u5F15_u7528_u548C_u62F7_u8D1D_u6784_u9020_u51FD_u6570" class="headerlink" title="第11章 引用和拷贝构造函数"></a>第11章 引用和拷贝构造函数</h2><p>C不允许随便地把一个类型的指针赋给另一个类型，但允许通过<code>void*</code>来实现。由于C的这种功能允许把任何一种类型看做别的类型处理，这就在类型系统中流下了一个大的漏洞。C++不允许这样做，如果真想把某种类型当作别的类型处理，则必须显示地使用类型转换。</p>
<p>引用(reference)(&amp;)就像能自动地被编译器间接引用的常量型指针。它常用于函数的参数表中和函数的返回值，但也可以独立使用。</p>
<p>使用引用时有一定的规则：</p>
<ul>
<li>当引用被创建时，它必须被初始化(指针则可以在任何时候被初始化)。</li>
<li>一旦一个引用被初始化为指向一个对象，它就不能改变为另一个对象的引用(指针则可以在任何时候指向另一个对象)。</li>
<li>不可能有NULL引用。必须确保引用是和一块合法的存储单元关联。</li>
</ul>
<p>最经常看见引用的地方是在函数参数和返回值中。当引用被用做函数参数时，在函数内任何对引用的更改将对函数外的参数产生改变。当然，可以通过传递一个指针来做相同的事情，但引用具有更清晰的语法。</p>
<p>如果从函数中返回一个引用，必须像从函数中返回一个指针来一样对待。当函数返回时，无论引用关连的是什么都应该存在，否则，将不知道指向哪一个内存。</p>
<p>若想要改变指针本身而不是它所指向的内容，函数参数变成指针的引用，用不着取得指针的地址。</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
void increment(int*&amp; i){i++}
int main(){
    int *i = 0;
    cout &lt;&lt; “i = ” &lt;&lt; i &lt;&lt; endl;
    increment(i);
    cout &lt;&lt; “i = ” &lt;&lt; i &lt;&lt; endl;
}
</code></pre><p>当给函数传递参数时，人们习惯上是通过常量引用来传递。这种简单习惯可以大大提高效率：传值方式需要调用构造函数和析构函数，然而，如果不想改变参数，则可以通过常量引用传递，它仅需要将地址压栈。</p>
<p>拷贝构造函数是一个更令人混淆的概念，常被称为<code>X(X&amp;)(“X引用的X”)</code>，在函数调用时，这个构造函数是控制通过传值方式传递和返回用户定义类型的根本所在。这是很重要的。</p>
<p>在C和C++中，参数是从右向左进栈的，然后调用函数，调用代码负责清理栈中的参数。但是要注意，通过按值传递方式传递参数时，编译器简单地将参数拷贝压栈──编译器知道拷贝有多大，并知道如何对参数压栈，对它们正确拷贝。</p>
<p>当编译器为函数调用产生代码时，它首先把所有的参数压栈，然后调用函数。在函数内部，产生代码，向下移动栈指针为函数局部变量提供存储单元。</p>
<h2 id="u7B2C13_u7AE0__u52A8_u6001_u5BF9_u8C61_u521B_u5EFA"><a href="#u7B2C13_u7AE0__u52A8_u6001_u5BF9_u8C61_u521B_u5EFA" class="headerlink" title="第13章 动态对象创建"></a>第13章 动态对象创建</h2><p>有时我们能知道程序中对象的确切数量、类型和生命期。但情况不总是这样。为了解决这个普遍的编程问题，在运行时可以创建和销毁对象是最基本的要求。C提供了<code>动态内存分配(dynamic memory allocation)</code>函数<code>malloc()</code>和<code>free()</code>，这些函数在运行时从堆(也称自由内存)中分配存储单元。</p>
<p>然而，在C++中这些函数将不能很好的运行。因为构造函数不允许我们向它传递内存地址来进行初始化。</p>
<p>C++是如何保证正确的初始化和清理，有允许我们在堆上动态创建对象呢？</p>
<p>答案是，使动态对象称为语言的核心。malloc和free是库函数，因此不在编译器控制范围之内。然而，如果我们有一个完成动态内存分配及初始化组合动作的运算符和另一个完成清理及释放内存组合动作的运算符，编译器仍可以保证所有对象的构造函数和析构函数会被调用。</p>
<p>当创建一个C++对象，会发生两件事：</p>
<ul>
<li>为对象分配内存。</li>
<li>调用构造函数来初始化那个内存。</li>
</ul>
<p>到目前为止，因该确保步骤2一定发生。C++强迫这样做是因为未初始化的对象是程序出错的主要原因。对象在那里和如何创建无关紧要──构造函数总是需要被调用。</p>
<p>然而，步骤1可以用几种方式或在可选择的时间发生：</p>
<ul>
<li>在静态存储区域，存储空间在程序开始之前就可以分配。这个存储空间在整个程序运行期间都存在。</li>
<li>无论何时到达一个特殊的执行点(左大括号)时，存储单元都可以在栈上被创建。除了执行点(右大括号)，这个存储单元自动被释放。这些栈分配运算内置于处理器的指令集中，非常有效。然而，在写程序时，必须知道需要多少个存储单元，以便编译器生成正确的指令。</li>
</ul>
<p>存储单元也可以从一块称为堆(也被称为自由存储单元)的地方分配。这被称为动态内存分配。在运行时调用程序分配这些内存。这意味着可以在任何时候决定分配内存及分配多少内存。当然也需负责决定何时释放内存。这块内存的生存期由我们选择决定──而不受范围决定。</p>
<p>为了在运行时动态分配内存，如<code>malloc()</code>和<code>free()</code>。这些函数是有效的但较原始的，需要编程人员理解和小心使用。例如，必须对分配的空间进行显式地类型转换，还需要自行调用初始化的函数(构造函数并不能被显式地调用)。这很容易出错。所以，C程序设计者常常在静态内存区域使用虚拟内存机制分配很大的变量数组以避免使用动态内存分配。为了在C++中使得一般的程序员可以安全使用库函数而不费力，所以C的动态内存方法是不可接受的。</p>
<p>C++中的解决方案是把船舰一个对象所需的所有动作都结合在一个称为new的运算符里。当用new(new的表达式)创建一个对象时，它就在堆里为对象分配内存并为这块内存调用构造函数。等价于调用malloc()函数并调用构造函数。返回一个指向该对象的this指针。</p>
<pre><code>MyType *fp = new MyType;
</code></pre><p>默认的new还进行检查以确信在传递地址给构造函数之前内存分配是成功的，所以不必显式地确定调用是否成功。</p>
<p>我们可以看到，在堆里创建对象的过程变得简单了──只是一个简单的表达式，它带有内置的长度计算、类型转换和安全检查。这样在堆里创建一个对象何在栈里创建一个对象一样容易。</p>
<p><code>delete</code>表达式首先调用析构函数，然后释放内存(常调用free())。正如<code>new</code>表达式返回一个指向对象的指针一样，<code>delete</code>表达式需要一个对象的地址。</p>
<pre><code>delete fp；
</code></pre><p><code>delete</code>只用于删除由<code>new</code>创建的对象。</p>
<p>当在堆栈里自动创建对象时，对象的大小和它们的生存期被准确地内置在生成的代码里，这是因为编译器知道确切的类型、数量和范围。而在堆里创建的对象还包括另外的时间和空间的开销。以下是一个典型情况：</p>
<p>调用<code>malloc()</code>，即从堆里搜索一块足够大的内存来满足请求，可以通过检查按某种方式排列的映射或目录来实现，这样的映射或目录用以显示内存的使用情况。这个过程很快但可能要试探几次，所以它可能是不确定的──即每次运行<code>malloc()</code>并不是花费了相同的时间。</p>
<p>在栈或堆上创建一个对象数组是同样容易的。但这里有一个限制条件：由于不带参数的构造函数必须被每一个对象调用，所以除了在栈上整体初始化外还必须有一个默认的构造函数。</p>
<pre><code>MyType *fp = new MyType[100];
MyType *fp2 = new MyType;
</code></pre><p>我们知道其实fp和fp2是数组的起始地址。</p>
<pre><code>delete fp2; // OK
delete fp; // Not the desired effect
</code></pre><p>对于<code>fp</code>来说，另外99个析构函数没有调用，正确应该这样：</p>
<pre><code>delete []fp；
</code></pre><p>空的方括号告诉编译器产生代码，该代码的任务是将从数组创建时存放在某处的对象数量取回，并为数组的所有对象调用析构函数。</p>
<p>上面定义的fp可以被修改指向任何类型，但这对于一个数组的起始地址来说没有什么意义。一般来讲，把它定义为常量会更好些，因为这样任何修改指针的企图都会被认为出错。</p>
<p>使得指针指向的int不能修改(指针可以修改)：</p>
<pre><code>int const* q = new int[10];   or
const int* q = new int[10];
</code></pre><p>使得指针不能被修改(数组可以修改)：</p>
<pre><code>int * const q = new int[10];
</code></pre><p>当<code>operator new()</code>找不到组够大的连续内存块来安排对象时，一个称为<code>new-handler</code>的特殊函数将会被调用。首先，检查指向函数的指针，如果指针非0，那么它指向的函数将被调用。</p>
<p><code>new-handler</code>的默认动作是产生一个<code>异常(throw an exception)</code>。</p>
<h2 id="u7B2C14_u7AE0__u7EE7_u627F_u548C_u7EC4_u5408"><a href="#u7B2C14_u7AE0__u7EE7_u627F_u548C_u7EC4_u5408" class="headerlink" title="第14章 继承和组合"></a>第14章 继承和组合</h2><p>C++中最重要的特征之一是代码重用。但是如果希望更进一步，就不能仅仅用拷贝代码和修改代码的方法，而是要做更多的工作。</p>
<p>关键技巧是使用这些类，但不修改已存在的代码。第一种方法很直接：我们简单地在心类中创建已存在类的对象。因为新类是由已存在的类的对象组合而成，所以这种方法称为<code>组合(composition)</code>。</p>
<p>第二种方法要复杂些。我们创建一个新类作为一个已存在类的类型。我们不修改已存在的类，而是采取这个已存在类的形式，并将代码加入其中。这种巧妙方法称为<code>继承(inheritance)</code>，其中大量的工作是由编译器完成。继承是面向对象程序设计的基石。</p>
<p>在语法上和行为上，组合和继承大部分是相似的。</p>
<p>组合语法 直接把子对象放入新对象的组成中即可。</p>
<p>访问嵌入对象(称为子对象)的成员的成员函数只需再一次的成员选择。更常见的是把嵌入的对象设为私有，因此它们将称为内部实现的一部分(这意味着如果我们原因，可以改变这个实现)。新类的公有接口函数包括了对嵌入对象的使用，但没有必要模仿这个对象的接口。</p>
<p>当继承时，我们会发现“这个新类很像原来的类”。我们规定，在代码中和原来一样给出该类的名字，但在类的左括号的前面，加一个冒号和基类的名字(对于多重继承，要给出多个基类名，它们之间用逗号分开)。当昨晚这些时，将会自动地得到基类中的所用数据成员和成员函数。</p>
<pre><code>class Y：public X{//......}
</code></pre><p>我们可以看到<code>Y</code>对<code>X</code>进行了继承，这意味着Y将包含X中的所有数据成员和成员函数。所有<code>X</code>中的私有成员在<code>Y</code>中仍然是私有的，因为<code>Y</code>对<code>X</code>进行了继承并不意味着<code>Y</code>可以不遵守保护机制。</p>
<p>这里基类前面是<code>public</code>。由于在继承时，基类中所有的成员都是被预设为私有的，所以如果基类的前面没有<code>public</code>，这意味着基类的所有公有成员将在派生类中变为私有的。这显然不是所希望的，我们希望基类中的所有公有成员在派生类中仍是公有的，这可以在继承时通过使用关键字<code>public</code>来实现。</p>
<p>倘若<code>X</code>和<code>Y</code>类中均有一个<code>set()</code>函数，那么将会使用Y中重新定义的版本。这也就是说，如果不想使用某个继承而来的函数，我们可以改变它的内容。然而，当我们重新定义了一个函数之后，仍可能想调用基类的函数，为了调用基类<code>X</code>的<code>set()</code>函数，必须使用作用域运算符来显示地表明基类名。</p>
<p>在C++中保证正确的初始化是多么重要，这一点在组合和继承中也是一样。当创建一个对象时，编译器确保调用了所有子对象的构造函数。</p>
<p>但是，如果子对象没有默认构造函数或如果想改变构造函数的某个默认参数，就会出现问题，因为这个新类的构造函数没有权利访问这个子对象的私有数据成员，所以不能直接对它们初始化。</p>
<p>解决的方法很简单：对于子函数调用构造函数，C++为此提供了专门的语法，即构造函数的初始化表达式表。构造函数的初始化表达式的形式模仿继承活动。</p>
<p>对于继承，我们把基类至于冒号和这个类体的左括号之间。而在构造函数的初始化表达式中，可以将对子对象构造函数的调用语句放在构造函数参数表和冒号之后，在函数体的左括号之前。对于从Bar继承来的类MyType，如果Bar的构造函数只有一个int型参数，则可以表示为：</p>
<pre><code>MyType::MyType(int i) : Bar(i) { // ...
</code></pre><p>对于组合，也可以对成员对象使用同样语法，只是所给出的不是类名，而是对象的名字。如果在初始化表达式表中有多个构造函数的调用，应当用逗号加以隔开：</p>
<pre><code>MyType2::MyType(int i) : Bar(i), m(i+1) { // ...
</code></pre><p>这是类<code>MyType2</code>构造函数的开头，该类是从<code>Bar</code>继承来的，并且包含一个称为<code>m</code>的成员对象。请注意，虽然可以在这个构造函数的初始化表达式表中看到基类的类型，但只能看到成员对象的标识符。</p>
<p>构造函数的初始化表达式表允许我们显式地调用成员对象的构造函数。它的主要思想是，在进入新类的构造函数体之前调用所有其他的构造函数。这样，对于子对象的成员函数所做的任何调用都总是转到了这个被初始化的对象中。即使编译器可以隐藏地调用默认的构造函数，但在没有对所有的成员对象和基类对象的构造函数进行调用之前，就没有办法进入该构造函数体。这是C++的一个强化的机制，它确保了，如果没有调用对象的构造函数，就别想向下进行。</p>
<p>对于哪些没有构造函数的内部类型嵌入对象，这一切会怎么样？</p>
<p>为了使语法一致，可以把内部类型看做这样一种类型，它只有一个取单个参数的构造函数，而这个参数与正在初始化的变量类型相同。于是可以这么写：</p>
<pre><code>class X {
    int i;
    float f;
    char c;
    char* s;
public:
    X() : i(7), f(1.4), c(‘x’), s(“howdy”) {}
};
</code></pre><p>这些“伪构造函数调用”操作可以进行简单的赋值。这种方法很方便，并且具有良好的编码风格。甚至在类之外创建内部类型的变量是，也可以使用伪构造函数语法。</p>
<p>这使得内部类型的操作有点类似于对象，但是这些并不是真正的构造函数。特别地，如果没有显式的进行伪构造函数调用，初始化是不会执行的。</p>
<p>还可以把组合和继承放在一起使用。</p>
<p><strong>自动析构函数调用</strong></p>
<p>虽然常常需要在初始化表达式表中显式构造函数调用，但并不需要做显式的析构函数调用，因为对于任何类型只有一个析构函数，并且它并不取任何参数。然而，编译器仍要保证所有的析构函数被调用，这意味着，在整个层次中的所有析构函数中，从派生类最底层的析构函数开始调用，一直到根层。</p>
<p>构造是从类层次的最根处开始，而在每一层，首先会调用基类构造函数，然后调用成员对象构造函数。调用析构函数则严格按照构造函数相反的次序──这是很重要的，因为要考虑潜在的相关性(对于派生类中的构造函数和析构函数，必须假设基类子对象仍然可供使用并且已经被构造了──或者还未被消除)。</p>
<p>另一个有趣现象是，对于成员对象，构造函数调用的次序完全不受构造函数的初始化表达式表中的次序影响。该次序是由成员对象在类中声明的次序所决定的。</p>
<p>如果继承一个类并且对它的成员函数重新进行定义，可能会出现两种情况：</p>
<ul>
<li>第一种是正如在基类中所进行的定义一样，在派生类的定义中明确地定义操作和返回类型。这称之为对普通成员函数的重定义(redefining)，而如果基类的成员函数是虚函数的情况，又可称之为重写(overriding)。</li>
<li>任何时候重新定义了基类中的一个重载函数，在新类之中所有其他版本则被自动地隐藏了。</li>
</ul>
<p>如果通过修改基类中一个成员函数的操作与/或返回类型来改变了基类的接口，我们就没有使用继承通常所提供的功能，而是按另一种方式来重用了该类。这并不一定意味着做错了，只是由于继承的最终目标是为了实现<code>多态性(polymorphism)</code>。</p>
<p>不是所有的函数都能自动地从基类继承到派生类中的。构造函数和析构函数用来处理对象的创建和析构操作，但它们只知道对它们的特定层次上的的对象做些什么。所以，在该类以下各个层次中的所有构造函数和析构函数都必须被调用，也就是说，构造函数和析构函数不能被继承，必须为每一个特定的派生类分别创建。</p>
<p>另外，<code>operator=</code>也不能被继承，因为它完成类似于构造函数的活动。</p>
<p>静态(static)成员函数与非静态成员函数的共同点：</p>
<ul>
<li>它们均可被继承到派生类中。</li>
<li>如果我们重新定义了一个静态成员，所有在基类中的其他重载函数会被隐藏。</li>
<li>如果我们改变了基类中一个函数的特征，所有使用该函数名字的基类版本都将会被隐藏。然而，<code>静态(static)</code>成员函数不可以是<code>虚函数(virtual)</code>。</li>
</ul>
<p>组合通常是在希望新类内部具有已存在类的功能时使用，而不是希望已存在类作为它的接口。这就是说，嵌入一个对象用以实现新类的功能，而新类的用户看到的是新定义的接口而不是来自老类的接口。为此，在新类的内部嵌入已存在的<code>private</code>对象。</p>
<p>有时，又希望允许类用户直接访问新类的组成，这就让成员对象是<code>public</code>。由于成员对象使用自己的访问控制，所以是安全的，而当用户了结了我们所做的组装工作时，会更容易理解接口。</p>
<p><code>is-a</code>关系用继承表达，<code>has-a</code>关系用组合表达。</p>
<p>如果由一个已存在的类创建一个新类，并且希望这个类的每件东西都进来，就称为<code>子类型化(subtyping)</code>。这个新类与已存在的类有着严格相同的接口(希望增加任何我们想要加入的其他成员函数)，所以能在已经用过这个已存在的类的任何地方使用这个新类，这就是必须使用继承的地方。</p>
<p>通过在基类表中去掉<code>public</code>或通过显式地声明<code>private</code>，可以私有地继承基类。当私有继承时，我们是“照此实现”；也就是说，创建的新类具有基类的所有数据和功能，但这些功能是隐藏的，所以它只是部分的内部实现。该类的用户访问不到这些内部功能，并且一个对象不能被看做是这个基类的实例。</p>
<p>为了完整性，private继承被包含在该语言中。但是通常希望使用组合而不是private继承。</p>
<p>私有继承时，基类的所有public成员都变成了private。如果希望其中的任何一个是可视的，只要用派生类的public部分声明它们的名字即可</p>
<pre><code>using Pet::eat;
</code></pre><p>其中<code>Pet</code>是私有继承的类，这样就可以使用<code>Pet</code>类中的<code>eat</code>成员函数。</p>
<p>这样，如果想要隐藏基类的部分功能，则private继承是有用的。注意给出一个重载函数的名字将使基类中的所有它的重载版本公有化。</p>
<p>在使用private继承取代组合之前，应当仔细考虑，当与运行时类型标识相连时，私有继承特别复杂。</p>
<p>实际项目中，有时希望某些东西隐藏起来，但仍允许其派生类的成员访问，此时可用protected。它的意思是：“就这个类的用户而言，它是private的，但它可被从这个类继承来的任何类使用”。</p>
<p>最好让数据成员是<code>private</code>，因为我们应该保留改变内部实现的权利。然后才能通过<code>protected</code>成员函数控制对该类的继承者的访问。</p>
<p>保护继承的派生类意味着对其他类来说是“照此实现”，但它是对于派生类和友元是<code>is-a</code>。它是不常用的，它的存在只是为了语言的完备性。</p>
<p>除了赋值运算符以外，其余的运算符可以自动地继承到派生类中。</p>
<p>直到我们已经很好地学会程序设计并完全理解这个语言时，我们才能试着去用多重继承。不管我们如何认为我们必须用多重继承，我们总是能通过单继承完成。</p>
<p>多重继承引起很多含糊的可能性。</p>
<p>继承和组合的优点之一是它支持渐增式开发(incremental development)，它允许在已存在的代码中引进代码，而不会给原来的代码带来错误。</p>
<p>认识到程序开发就像人的学习过程一样，是一个渐增的过程，这是很重要的。我们能做尽可能多的分析，但当开始一个项目时，我们仍不可能知道所有的答案。</p>
<p>记住，继承首先是表示一种关系，即“新类属于老类的类型(a type of)”。我们的程序不应当关心怎样怎样摆布位，而应当关心如何创建和处理各类型的对象，以便用问题空间的术语表示模型。</p>
<p>继承最重要的方面不是它为新类提供了成员函数，而是它是基类与新类之间的关系，这种关系可被描述为：“新类属于原有类的类型”。</p>
<p>这个描述不仅仅是一种想象的解释继承的方法──它直接由编译器支持。将新类的引用或指针转变成基类的引用或指针的活动被称为<code>向上类型转换(upcasting)</code>。</p>
<p>为什么要“向上类型转换” 这个术语的引入是有其历史原因的，而且它也与类继承图的传统画法有关：在顶部是根，向下生长。</p>
<p>向上类型转换总是安全的。因为是从更专门的类型到更一般的类型──对于这个类接口可能出现的唯一事情是它失去成员函数，而不是获得它们。这就是编译器允许向上类型转换而不需要显式地说明或做其他标记的原因。</p>
<p>必须记住无论何时我们在创建了子集的拷贝构造函数时，都要正确地调用基类拷贝构造函数(正如编译器所作的)。</p>
<h2 id="u7B2C15_u7AE0__u591A_u6001_u6027_u548C_u865A_u51FD_u6570"><a href="#u7B2C15_u7AE0__u591A_u6001_u6027_u548C_u865A_u51FD_u6570" class="headerlink" title="第15章 多态性和虚函数"></a>第15章 多态性和虚函数</h2><p>多态性(在C++中通过虚函数来实现)是面向对象程序设计语言中数据抽象和继承之外的第三个基本特性。</p>
<p><code>多态性(polymorphism)</code>提供了接口与具体实现之间的另一层隔离，从而将<code>what</code>与<code>how</code>分离开来。多态性改善了代码的组织性和可读性，同时也使创建的程序具有可拓展性。</p>
<p><code>封装(encapsulation)</code>通过组合特性和行为来生成心的数据类型。访问控制通过使细节数据设为private，将接口从具体实现中分离开来。</p>
<p>C程序员可以用三步演变为C++程序员。</p>
<ol>
<li>第一步：简单地把C++作为一个“更好的C”。</li>
<li>第二步：进入“基于对象”的C++。</li>
<li>第三步：了解和使用虚函数，这是理解面向对象程序设计的转折点。不用虚函数，就等于还不懂得面向对象程序设计(OOP)，虚函数增强了类型概念，而不只是在结构内部隐蔽地封装代码。</li>
</ol>
<p>取一个对象的地址(指针或引用)，并将其作为基类的地址来处理，这被称为向上类型转换(upcasting)，因为继承树的绘制方式是以基类为顶点的。</p>
<p>把函数体与函数调用相联系称为捆绑(binding)。当捆绑在程序运行之前(由编译器和连接器)完成时，这称为早捆绑(early binding)。C编译只有一种函数调用方式，就是早捆绑。晚捆绑(late binding)意味着捆绑根据对象的类型，发生在运行时。晚捆绑又称为动态捆绑(dynamic binding)或运行时捆绑(runtime binding)。对于一种编译语言，编译器并不知道实际的对象类型，但它插入能找到和调用正确函数体的代码。</p>
<p>对于特定的函数，为了引起晚捆绑，C++要求在基类中声明这个函数时使用<code>virtual</code>关键字。晚捆绑只对<code>virtual</code>函数起作用，而且只在使用含有<code>virtual</code>函数的基类的地址时发生，尽管它们也可以在更早的基类中定义。</p>
<p>为了创建一个像<code>virtual</code>这样的成员函数，可以简单地在声明这个函数时使用<code>virtual</code>关键字。仅仅在声明的时候需要使用关键字virtual，定义时并不需要。如果一个函数在基类中被声明为<code>virtual</code>，那么在所有的派生类中它都是<code>virtual</code>的。在派生类中<code>virtual</code>函数的重定义通常称为<code>重写(overriding)</code>。</p>
<p>注意，仅需要在基类中声明一个函数为virtual。调用所有匹配基类声明行为的派生类函数都将使用虚机制。</p>
<p>在一个设计风格良好的OOP程序中，大多数甚至所有的函数都可以沿用基类的某个模型，只需与基类接口通信。这样的程序是可拓展的(extensible)，因为可以通过从公共基类继承新数据类型而增加新功能。操作基类接口的函数完全不需要改变就可以适合于这些新类。</p>
<p>关键字<code>virtual</code>告诉编译器它不应当执行早捆绑，相反，它应当自动安装对于实现晚捆绑必需的所有机制。</p>
<p>为了达到这个目的，典型的编译器对每个包含虚函数的类创建一个<code>表(VTABLE)</code>。在<code>VTABLE</code>中，编译器放置特定类的虚函数的地址。在每个带有虚函数的类中，编译器秘密地防止一个指针，称为<code>vpointer(缩写为VPTR)</code>，指向这个对象<code>VTABLE</code>。当通过基类指针做虚函数调用时(也就是做多台调用时)，编译器静态地插入能取得这个<code>VPTR</code>并在<code>VTABLE</code>表中查找函数地址的代码，这样就能调用正确的函数并引起晚捆绑的发生。</p>
<p>为每个类设置<code>VTABLE</code>，初始化<code>VPTR</code>、为虚函数调用插入代码，所有这些都是自动发生的。利用虚函数，即使在编译器还不知道这个对象的特定类型的情况下，也能调用这个对象中正确的函数。</p>
<p>如果有一个或多个虚函数，编译器都只在这个结构中插入一个单个指针(VPTR)，指向一个存放函数地址的表。我们只需要一个表，因为所有虚函数地址都包含在这个但个表里。</p>
<p>C++并不是对于绝对地址的一个简单的CALL，而是为设置虚函数调用需要两条以上的复杂的汇编指令。这既需要代码空间，又需要执行时间。</p>
<p>一些面向对象的语言已经接受了这种途径，即晚捆绑对于面向对象程序设计是性质所固有的，所以应当总是出现，它不应当是可选的，而且用户并不一定需要知道它。这是在创造语言的设计时决定的，而这种特殊的方法对于许多语言是适合的(smalltalk、Java和Python)。</p>
<p><code>virtual</code>关键字可以改变程序的效率。当设计类时，我们不应当为效率问题担心。如果使用多态，就处处使用虚函数。当试图加速代码时，只需寻找可以不使用虚函数的函数。</p>
<p>有些证据表明，C++中的规模和速度改进效果是在C的规模和速度的10%之内，并且常常更接近。能够得到更小的规模和更高速度的原因是C++可以有比C更快的方法设计程序，而且设计的程序更小。</p>
<p>在设计时，常常希望基类仅仅作为其派生类的一个接口。这就是说，仅想对基类进行向上类型转换，使用它的接口，而不希望用户实际地创建一个基类对象。就可以在基类中加入至少一个纯虚函数(pure virtual function)，来使基类成为抽象(abstract)类。纯虚函数使用关键字virtual，并且在其后面加上= 0。如果试着生成一个抽象类的对象，编译器会制止他。</p>
<p>当继承一个抽象类时，必须实现所有的纯虚函数，否则继承出的类也将是一个抽象类。创建一个纯叙述函数允许在接口中放置成员函数，而不一定要提供一段可能对这个函数毫无意义的代码。同时纯虚函数要求继承出的类对它提供一个定义。</p>
<p>建立公共接口的唯一原因是它能对于每个不同的子类有不同的表示。它建立一个基本的格式，用来确定什么是对于所有派生类是公共的──除此之外，别无用途。当仅希望通过一个公共接口来操纵一组类，且这个公共接口不需要实现(或者不需要完全实现)时，可以创建一个抽象类。语法为：</p>
<pre><code>virtual void f() = 0;
</code></pre><p>这样做，等于告诉编译器在VTABLE中为函数保留一个位置，但在这个特定位置中不放地址。只要有一个函数在类中被声明为纯虚函数，则VTABLE就是不完全的。</p>
<p>如果一个类的VTABLE是不完全的，当试图创建这个类的对象时，编译器就发出一个出错信息。这样，编译器就保证了抽象类的纯洁性，就不会被误用了。</p>
<p>一个类若全是纯虚函数，就称为纯抽象类(pure abstract class)。纯序函数是非常有用的，因为它们使得类有明显的抽象性，并告诉用户和编译器打算如何使用。</p>
<p>注意，纯虚函数禁止对抽象类的函数以传值方式调用。这也是防止对象切片(object slicing)的一种方法。通过抽象类，可以保证在向上类型转换期间总是使用指针或引用。</p>
<p>当实现继承和重新定义一些虚函数时，编译器对新类创建一个新的VTABLE表，并且插入新函数的地址，对于没有重新定义的虚函数使用基类函数的地址。无论如何，对于可被创建的每个对象(即它的类不含有纯虚函数)，在VTABLE中纵有一个函数地址的全集，所以绝对不能对不在其中的地址进行调用(否则结果将是灾难性的)。</p>
<p>若在派生(derived)类中继承或增加新的虚函数，那么通过基类的指针是无法进行调用的。</p>
<p>如果知道保存在一般容器中的所有对象的确切类型，会使我们的设计工作在最佳状态(或者没有选择)。这就是运行时类型辨认(Run-Time Type Identification,RTTI)问题。RTTI是有关向下类型转换基类指针到派生类指针的问题。向上类型转换是自动发生的，不需强制，因为它是绝对安全的。向下类型转换是不安全的，因为这里没有关于实际类型的编译时信息，所以必须准确地知道这个类实际是什么类型。如果把它转换称错误的类型，就会出现麻烦。</p>
<p>当多态地处理对象时，传地址与传值有明显的不同。如果对一个对象进行向上类型转换，而不使用地址或引用，这个对象将会被“切片”，直到剩下来的是适合于目的的子对象。确切地来说，派生类对象会被切片成一个基类对象。</p>
<p>对象切片实际上是当它拷贝到一个新的对象时，去掉原来对象的一部分，而不是像使用指针或引用那样简单地改变地址和内容。因此，不常使用对象向上类型转换，事实上，通常要提防或防止这种操作。</p>
<p>重新定义一个基类中的重载函数将会隐藏所有该函数的其他基类版本。而当对虚函数进行这些操作的时候，情况会有点不同。</p>
<p>编译器不允许我们改变重新定义过的虚函数的返回值(如果不是虚函数，则是允许的)。这是一个非常重要的限制，因为编译器必须保证我们能够多态地通过基类调用函数，若返回值不同，那么就会产生问题。</p>
<p>如果重新定义了基类中的一个重载成员函数，则在派生类中其他的重载函数将会被隐藏。例如，基类中有f(int)和f(string)这样的重载函数，如果我在派生类中重新定义了f(int)，那么对于这个派生类来说，f(string)就被隐藏了，不可用了。</p>
<p>通常，我们不能在重新定义过程中修改虚函数的返回类型，但是也有特例，如果返回一个指向基类的指针或引用，则该函数的重新定义版本可以从基类返回的内容中返回一个指向派生类的指针或引用。</p>
<p>当创建一个报含有虚函数的对象时，必须初始化它的VPTR以指向相应的VTABLE。这必须在对虚函数进行任何调用之前完成。编译器在构造函数开头部分秘密地插入能初始化VPTR的代码。</p>
<p>当寻找效率漏洞时，我们必须明白，编译器正在插入隐藏代码到我们构造函数中。这些隐藏代码不仅必须初始化VPTR，而且还必须检查this的值(以免operator new返回零)和调用基类构造函数。放在一起，这些代码可以影响我们认为是一个小内联函数的调用。特别是，构造函数的规模会抵消函数调用代价的减少。如果做大量的内联构造函数调用，代码长度就会增长，而在速度上没有任何好处。</p>
<p>当然，也许并不会立即把所有这些小构造函数都变成非内联，因为它们更容易写为内联构造函数。但是，当我们正在调整我们的代码时，务必去掉这些内联构造函数。</p>
<p>所有基类构造函数总是在继承类构造函数中被调用。派生类只访问它自己的成员，而不访问基类的成员。只有基类构造函数能正确地初始化它自己的成员。如果不在构造函数初始化表达式表中显式地调用基类构造函数，他就调用默认构造函数。如果没有默认构造函数，编译器将报告错误。</p>
<p>构造函数调用的顺序是重要的。当继承时，必须知道基类的全部成员并能访问基类的任何<code>public</code>和<code>protected</code>成员。在通常的成员函数中，构造已经发生，所以这个对象的所有部分的成员都已经建立。然而，在构造函数中，必须想办法保证所有成员都已经建立。保证它的惟一方法是让基类构造函数首先被调用。</p>
<p>只要可能，我们应当在构造函数初始化表达式表中初始化所有的成员对象。只要遵从这个做法，我们就能保证初始化所有基类成员和当前对象的成员对象。</p>
<p>对于在构造函数中调用一个虚函数的情况，被调用的只是这个函数的本地版本。也就是说，虚机制在构造函数中不工作。</p>
<p>构造函数的工作是生成一个对象。在任何构造函数中，可能只是部分形成对象──我们只能知道基类已被初始化，但并不能知道哪个类是从这个基类继承来的。然而，虚函数在继承层次上是“向前”和“向外”进行调用。它可以调用在派生类中的函数。如果我们在构造函数中也这样做，那么我们所调用的函数可能操作还没有被初始化的成员。这将导致灾难的发生。</p>
<p>当一个构造函数被调用时，它做的首要事情之一就是初始化它的<code>VPTR</code>。然而，它只能知道它属于“当前”类──即构造函数所在类。于是它完全忽视这个对象是否是基于其他类的。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码──既不是为基类，也不是为它的派生类。<code>VPTR</code>的状态是由被最后调用的构造函数确定的。</p>
<p>当这一系列构造函数调用正发生时，每个构造函数都已经设置<code>VPTR</code>指向子集的<code>VTABLE</code>。如果函数调用使用虚机制，它将只产生通过它自己的<code>VTABLE</code>的调用，而不是最后派生的<code>VTABLE</code>。</p>
<p>总之，在构造函数中调用虚函数都不能得到预期的结果。</p>
<p>构造函数是不能为虚函数的。但析构函数能够且常常必须是虚的。</p>
<p>构造函数有一项特殊工作，即一块一块地组合成一个对象。它首先调用基类构造函数，然后调用在继承顺序中的更晚派生的构造函数。类似地，析构函数也有一项特殊工作，即它必须拆卸属于某层次类的对象。析构函数自最晚派生的类开始，并向上到基类。</p>
<p>如果通过指向某个对象基类的指针操纵这个对象(也就是通过它的一般接口操纵这对象)，当我们想在<code>delete</code>在栈中已经用<code>new</code>创建的对象的指针时，就会出现这个问题。如果这个指针是指向基类的，在<code>delete</code>期间，编译器只能知道调用这个析构函数的基类版本，幸运的是，析构函数可以是虚函数。</p>
<p>不把析构函数设为虚函数是一个隐匿的错误，因为它常常不会对程序有直接的影响，但是会不知不觉引入存储器泄露(关闭程序时内存未释放)。同样，这样的析构操作还有可能掩盖发生的问题。</p>
<p>尽管纯虚析构函数在标准C++中是合法的，但在使用的时候有一个额外的限制：必须为纯虚析构函数提供一个函数体。纯虚析构函数和非纯虚虚构函数之间的唯一不同之处在于纯虚析构函数使得基类是抽象类，所以不能创建一个基类的对象(如果基类的任何其他函数是纯虚函数，也是具有同样的效果)。</p>
<p>当从某个含有虚析构函数的类中继承出一个类，情况变得有点复杂。不像其他的纯虚函数，我们不要求在派生类中提供纯虚函数的定义。</p>
<p>一般来说，如果在派生类中基类的纯虚函数(和所有其他纯虚函数)没有重新定义，则派生类将会成为抽象类。但是这里编译器将会自动地为每个类生成一个析构函数定义，基类的析构函数被重写(重新定义)，因此编译器会提供定义并且派生类实际上不会成为抽象类。</p>
<p>当我们的类仅含有一个纯虚函数时，就会发现这个唯一的差别：析构函数。这里析构函数的纯虚性的唯一效果是阻止基类的实例化。如果有其他的纯虚函数，则它们会阻止基类的实例化。</p>
<p>作为一个准则，任何时候我们的类中都要有一个虚函数，我们应当立即增加一个虚析构函数(即使它什么也不做)。这样，我们保证在后面不会出现问题。</p>
<p>在析构期间，有一些我们可能不希望马上发生的情况。如果正在一个普通的成员函数中，并且调用一个虚函数，则会使用晚捆绑机制来调用这个函数。而对于析构函数，这样不行，不论是虚的还是非虚的。在析构函数中，只有成员函数的“本地”版本被调用；虚机制被忽略。</p>
<p>负责动态对象创建(使用<code>new</code>)的对象进行<code>delete</code>调用的称之为“所有者”。在使用容器时的问题是，它们需要足够的灵活性用来接收不同类型的对象。为了做到这一点，容器使用<code>void</code>指针，因此它们并不知道所包容对象的类型。删除一个<code>void</code>指针并不调用析构函数，所以容器并不负责清除它的对象。</p>
<p>一种方法要求我们要为想在容器中容纳的每一种类型都派生出新类。</p>
<p>问题是我们希望容器可以容纳更多的类型，但我们不想使用void指针。另外一种解决方法是使用多态性，它通过强制容器内的所有对象从同一个基类继承而来。也就是说，容器容纳了具有同一基类的对象，并随后调用虚函数──特别地，我们可以调用虚析构函数来解决所有权问题。</p>
<p>这种解决方法使用<code>单根继承(singly-rooted hierarchy)</code>或<code>基于对象的继承(object-based hierarchy)</code>。事实上，除了C++，每种面向对象的语言都强制使用这样的体系──当创建一个类时，都会直接或间接地从一个公共基类中继承出它，这个基类是由该语言的创建者生成的。C++中认为，强制地使用这个公共基类会引起太多的开销，所有便没有使用它。</p>
<p>就像对成员函数那样，我们可以使用virtual运算符。然而，因为我们可能对两个不知道类型的对象进行操作，所以实现virtual运算符通常会很复杂。这通常用于处理数学部分。</p>
<p>C++提供了一个特殊的称为<code>dynamic_cast</code>的<code>显式类型转换(explicit cast)</code>，它就是一种<code>安全类型向下类型转换(type-safe downcast)</code>的操作。当使用<code>dynamic_cast</code>来试着向下类型转换一个特定的类型，仅当类型转换是正确的并且是成功的时，返回值会是一个指向所需类型的指针，否则它将会返回0来表示这并不是正确的类型。<br>当使用<code>dynamic_cast</code>时，必须对一个真正多态的层次进行操作──它含有虚函数──这因为<code>dynamic_cast</code>使用了存储在<code>VTABLE</code>中的信息来判断实际的类型，所以运行时需要一点额外的开销。</p>
<h2 id="u7B2C16_u7AE0__u6A21_u677F_u4ECB_u7ECD"><a href="#u7B2C16_u7AE0__u6A21_u677F_u4ECB_u7ECD" class="headerlink" title="第16章 模板介绍"></a>第16章 模板介绍</h2><p>继承和组合提供了重用对象代码的方法，而C++的模板特征提供了重用源代码的方法。</p>
<p>在一般程序设计问题中，程序员在编写程序时并不知道将来需要创建多少个对象。C++中有更好的解决方法：用new创建所需要的对象，将其指针放入容器中，待实际实用时将其取出并进行处理。用这种方法，所创建的只是确实需要的对象。通常，在启动程序时没有可用的初始化条件。new允许等待，直到在环境中相关事件发生后，再实际地创建这个对象。</p>
<p>有三种源代码重用的方法：</p>
<ul>
<li>C方法：应该摒弃，由于它表现繁琐、易发生错误、缺乏美感，是非常低效的技术。</li>
<li>Smalltalk方法：通过继承来实现代码重用，既简单又直观。每个容器类包含通用的基类Object的项目。这是一种单纯的技巧，因为Smalltalk类层次上的任何类都源于Object的派生，任何容器可容纳任何类(包括容器本身)。这种基于通用的基类(常称为Object，在Java中也有类似情况)的单树形层次类型称为“基于对象的层次结构”。</li>
</ul>
<p>尽管具有多重继承的基于对象的层次结构在概念上是直观的，但是在实践上较为困难。</p>
<p>模板对源代码进行重用，而不是通过继承和组合重用目标代码。容器不再存放称为Object的通用基类，而是存放一个未指明的参数。当用户使用模板时，参数由编译器来替换。</p>
<p>C++中，模板实现了参数化类型(parameterized type)的概念。模板方法的另一个优点是，使对继承不熟悉、不适应的新程序员也能正确地使用密封的容器类。</p>
<p>template这个关键字会告诉编译器，随后的类定义将操作一个或更多未指明的类型。当由这个模板产生实际类代码时，必须指定这些类型以使编译器能够替换它们。</p>
<pre><code>template&lt;class T&gt;
class Array{
    enum{ size = 100 };
    T A[size];
public:
    T&amp; operator[](int index){....}
};
int main(){
    Array&lt;int&gt; ia;
    Array&lt;double&gt; da;
    ...
}
</code></pre><p>这里T是替换参数，它代表一个类型名称。在容器类中，它将出现在那些原本由某以特定类型出现的地方。</p>
<p>有时我们希望有非内联成员函数的定义。这时编译器需要在成员函数定义之前看到<code>template</code>声明。</p>
<pre><code>template&lt;class T&gt;
class Array{
    enum{ size = 100 };
    T A[size];
public:
    T&amp; operator[](int index);
};
template&lt;class T&gt;
T&amp; Array&lt;T&gt;::operator[] (int index) {...}
</code></pre><p>注意在引用模板的类名的地方，必须伴游该模板的参数列表。可以想象，在内部，使用模板参数列表中的参数修饰类名，以便为每一个模板实例产生唯一的类名标识符。</p>
<p>在template&lt;…&gt;之后的任何东西都意味着编译器在当时不为它分配存储空间，而是一直处于等待状态直到被一个模板示例告知。在编译器和连接器中有机制能去掉同一模板的多重定义。所以为了使用方便，几乎总是在头文件中放置全部的模板声明和定义。</p>
<p>可以认为模板为C++提供了一种弱类型(weak typing)机制，C++通常是强类型语言。</p>
<p>模板参数并不局限于类定义的类型，可以使用编译器内置类型。这些参数值在编译期间编程模板的特定示例的常量。我们甚至可以对这些参数使用默认值。</p>
<pre><code>template&lt;class T, int size = 100&gt;
class Array{
    T array[size];
public:
    int length() const { return size; }
};
</code></pre><p>这里的<code>size</code>决不存放在类中，但对它的使用就如同是成员函数中的数据成员。</p>
<p>如果某个类有一个指向<code>Array</code>的指针，而不是指向类型<code>Array</code>的嵌入对象。该指针在构造函数中不被初始化，而是推迟到第一次访问时。这称为<code>懒惰初始化(lazy initialization)</code>。如果创造大量的对象，但不访问每一个对象，为了节省存储，可以使用懒惰初始化技术。</p>
<p>以值包含对象的容器通常无需担心所有权问题，因为它们清晰地拥有它们所包含的对象。但是，如果容器内包含指向对象的指针(这种情况在C++中相当普遍，有其在多态的情况下)，而这些指针很可能用于程序的其他地方，那么删除该指针指向的对象会导致在程序的其他地方的指针对已销毁的对象进行引用。为了避免上述情况，在设计和使用容器时必须考虑所有权问题。</p>
<p>处理所有权问题的最好方法是由客户程序员来选择。这常常通过构造函数的一个参数来完成，它默认地指明所有权。</p>
<p>如果我们没有模板，那么在一个一般的容器内创建对象的一个拷贝是一个复杂的问题。使用模板，事情噢那个就相对简单了，只要说我们存放对象而不是指针就行了。</p>
<p><code>迭代器(iterator)</code>是一个对象，它在其他对象的容器上遍历，每此选择它们中的一个，不需要提供对这个容器的实现的直接访问。迭代器提供了一种访问元素的标准方法，无论容器是否提供了直接访问元素的方法。迭代器常常与容器类联合使用，而且迭代器在标准C++容器的设计和使用中是一个基本概念。迭代器也是一种<code>设计模式(design pattern)</code>。</p>
<p>迭代器通常模仿大多数指针的运算。然而，不同的是，迭代器的设计更安全，所以数组越界的可能性更小。</p>
<p>习惯上，用构造函数来创建迭代器，并把它与一个容器对象联系，并且在它的生命期中，不把它与不同的容器联系。</p>
<h2 id="u7B2C19_u7AE0__u6DF1_u5165_u7406_u89E3_u6A21_u677F"><a href="#u7B2C19_u7AE0__u6DF1_u5165_u7406_u89E3_u6A21_u677F" class="headerlink" title="第19章 深入理解模板"></a>第19章 深入理解模板</h2><p>C++模板应用的便利性远远超出了它只是一种<code>T类型容器”(containers of T)</code>的范畴。尽管其最初的设计动机是为了能产生类型安全的通用容器，但在现在C++中，模板也用来生成自定义代码，这些代码通过编译时的程序设计构造来优化程序的执行。</p>
<p>模板有两类：函数模板和类模板。二者都是由它们的参数来完全地描绘模板的特性。每个模板参数描述了下述内容之一：</p>
<ul>
<li>类型(或者是系统固有类型或者是用户自定义类型)。</li>
<li>编译时常数值(例如，整数、指针和某些静态实体的引用，通常是作为无类型参数的引用)。</li>
</ul>
<p>其他模板。</p>
<p>一个无类型模板参数必须是一个编译时所知的整数值。</p>
<pre><code>template&lt;class T, size_t N&gt;
</code></pre><p>在类模板中，可以为模板参数提供默认(缺省)参数，但是在函数模板中却不行。作为默认的模板参数，它们只能被定义一次，编译器会知道第一次的模板声明或定义。一旦引入了一个默认参数，所有它之后的模板参数也必须具有默认值。</p>
<h1 id="C++__u6280_u5DE7"><a href="#C++__u6280_u5DE7" class="headerlink" title="C++ 技巧"></a>C++ 技巧</h1><p>变量定义指定了变量的类型和标识符，也可以为对象提供初始值。定义时制定了初始值的对象被成为是<code>已初始化的（initialized）</code>。C++支持两种初始化变量的形式：<code>复制初始化（copy－initialization）</code>和<code>直接初始化（direct－initialization）</code>。复制初始化语法用等号，直接初始化则是把初始化式放在括号中</p>
<pre><code>int ival（1024）； //direct-initialization
int ival = 1024；    //copy-initialization
</code></pre><p>C++中初始化和赋值是两种不同的操作，请注意。并且直接初始化语法更灵活而且效率更高。</p>
<hr>
<p>定义如何进行初始化的成员函数称为<code>构造函数（constructor）</code>。和其他函数一样，构造函数能接受多个参数。一个类可以定义几个构造函数，每个构造函数必须接受不同数目或者不同类型的参数。</p>
<hr>
<p>内置类型（如int）变量是否自动初始化取决于变量定义的位置。在函数体外定义的变量都初始化为0，在函数体里定义的内置类型变量不进行自动初始化。除了用作赋值操作符的左操作数，未初始化变量用作任何其他用途都是没有定义的。未初始化变量引起的错误难以发现，永远不要依赖未定义行为。</p>
<hr>
<p>建议每个内置类型的对象都要初始化。虽然这样做并不总是必需的，但是会更加容易和安全，除非你确定忽略初始化式不会带来风险。</p>
<hr>
<p>如果定义某个类的变量时没有提供初始化式，这个类也可以定义初始化时的操作。它是通过定义一个特殊的构造函数即<code>默认构造函数（default constructor）</code>来实现的。如果没有提供初始化式，那么就会使用默认构造函数。不管变量在哪里定义，默认构造函数都会被使用。</p>
<hr>
<p><code>变量的定义（definition）</code>用于为变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量有且仅有一个定义。<code>声明（declaration）</code>用于项程序表明变量的类型和名字。定义也是声明；当定义变量时我们声明了它的类型和名字。可以通过使用<code>extern</code>关键字声明变量而不定义它。不定义变量的声明包括对象名。对象类型和对象类型前的关键字<code>extern</code>。</p>
<hr>
<p>在C++语言中，变量必须且仅能定义一次，而且在使用变量之前必须定义或者声明变量。</p>
<hr>
<p>用来区分名字的不同意义的上下文称为<code>作用域（scope）</code>。作用域是程序的一段区域。一个名称可以和不同作用域中的不同实体相关联。C++语言中，大多数作用域是用花括号来界定的。一般来说，名字从其声明点开始直到其声明所在的作用域结束处都是可见的。</p>
<hr>
<p>定义在所有函数外部的名字具有<code>全局作用域（global scope）</code>，可以在程序中的任何地方访问。定义在<code>main</code>函数的作用域，则在整个<code>main</code>函数中可以使用，具有<code>局部作用域（local scope）</code>。而在某个语句中定义的（例如for语句中），则只能在语句中使用，具有<code>语句作用域（statement scope）</code>。</p>
<hr>
<p>C++中作用域可嵌套，若先定义了全局变量s1，而又在main中定义了局部变量s1，那么，局部变量s1就会屏蔽全局变量s1。要注意的是，像上面这样的定义方法很可能让他人大惑不解，同名总是不好的，建议局部变量最好使用不同的名字。</p>
<hr>
<p>一般来说，变量的定义或声明可以放在程序中能摆放语句的任何位置。变量在使用前必须先声明或定义。通常把一个对象定义在它首次使用的地方是一个很好的办法。</p>
<hr>
<p>定义一个变量代表某一常数的方法仍然有一个严重的问题。此变量是可以被修改的。<code>const</code>限定符提供了一个解决办法，它把一个对象转换成一个常量。如下：</p>
<pre><code>const int bufsize ＝ 512；
</code></pre><p>此时变量<code>bufsize</code>是不可修改的，任何修改<code>bufsize</code>的尝试都会导致编译错误。因为常量在定义后就不能被修改，所以定义时必须初始化。</p>
<hr>
<p><code>const</code>对象默认为文件的局部变量，此变量只存在于那个文件中，不能被其他文件访问。非<code>const</code>变量默认为<code>extern</code>。要使<code>const</code>变量能够在其他文件中访问，必须显式地指定它为<code>extern</code>。</p>
<hr>
<p><code>引用（reference）</code>就是对象的另一个名字。在实际程序中，引用主要用作函数的形式参数。引用式一种<code>复合类型（compound type）</code>，通过在变量名前添加<code>&amp;</code>符号来定义。复合类型是指用其他类型定义的类型。在引用的情况下，每一种引用类型都“关联到”某一其他类型。不能定义引用类型的引用，但可以定义其他任何类型的引用。引用必须用与该引用同类型的对象初始化：</p>
<pre><code>int ival ＝ 1024；
int &amp;refVal = ival; //ok: refVal refers to ival
int &amp;refVal2;       //error: a reference must be initialized
int &amp;refVal3 = 10;  //error: initializer must be an object
</code></pre><hr>
<p>引用只是它绑定的对象的另一个名字，作用在引用上的所有操作事实上都是作用在该引用绑定的对象上。当引用初始化后，只要该引用存在，它就保持绑定到初始化时指向的对象。不可能将引用绑定到另一个对象。</p>
<hr>
<p>const引用是指向const对象的引用</p>
<pre><code>const int ival ＝ 1024；
const int &amp;refVal = ival;   //ok: both reference and object are const
int &amp;ref2 = ival;       //error: nonconst reference of a const object
</code></pre><p>可以读取但是不能修改refVal，任何对refVal的赋值都是不合法的。同理，用ival初始化ref2也是不合法的：ref2是普通的非const引用（nonconst reference）。</p>
<hr>
<p>const引用可以初始化为不同类型的对象或者初始化为右值，如字面值常量：</p>
<pre><code>int i = 42;
// legal for const references only
const &amp;r = 42;
const &amp;r2 = r + i;
</code></pre><p>同样的初始化对于非const引用却是不合法的，而且会导致编译时错误。这里稍微解释一下</p>
<pre><code>double dval = 3.14;
const int &amp;ri = dval;
</code></pre><p>编译器会把这些代码转换成如以下形式的编码：</p>
<pre><code>int temp = dval;     // create temporary int from the double
const int &amp;ri = temp;   // bind ri to that temporary
</code></pre><p>如果<code>ri</code>不是<code>const</code>，那么可以给<code>ri</code>赋一个新值。这样做不会修改dval，而是修改了temp。期望对ri的赋值会修改dval的程序员会发现dval并没有被修改。仅允许const引用绑定到需要临时使用的值完全避免了这个问题，因为const引用是只读的。</p>
<hr>
<p>typedef可以用来定义类型的同义词：</p>
<pre><code>typedef double wages;   // wages is a synonym for double
typedef int exam_score; // exam_score is a synonym for int
</code></pre><p>typedef名字可以用作类型说明符：</p>
<pre><code>wages hourly,  weekly;  // double hourly, weekly;
</code></pre><hr>
<p>typedef通常被用于以下三种目的：为了隐藏特定类型的实现，强调使用类型的目的；简化复杂的类型定义，使其更易理解；允许一种类型用于多个目的，同时使得每次使用该类型的目的明确。</p>
<hr>
<p>枚举的定义包括关键字 enum，其后是一个可选的枚举类型名，和一个用花括号括起来、用逗号分开的枚举成员（enumerator）列表。</p>
<pre><code>// input is 0, output is 1, and append is 2
enum open_mode {input, output, append};
</code></pre><p> 默认地，第一个枚举成员赋值为0，后面地每个枚举成员赋的值比前面的大1。</p>
<pre><code>//shape is 1, sphere is 2, cylinder is 3, polygon is 4
enum Forms {shape = 1, sphere, cylinder, polygon};
</code></pre><p>枚举成员值可以是不唯一的。每个enum都定义一种唯一的类型。</p>
<hr>
<p>每个类都定义了一个接口（interface）和一个实现（implementation）。接口由使用该类的代码需要执行的操作组成。实现一般包括该类所需要的数据。实现还包括定义该类需要的但又不供一般性使用的函数。定义类时，通常先定义该类的接口，即该类所提供的操作，可以决定该类完成其功能所需要的数据，以及是否需要定义一些函数来支持该类的实现。</p>
<hr>
<p>类定义以关键字class开始，其后是该类的名字标识符。类体位于花括号里面。花括号后面必须要跟一个分号。类体可以为空，类体定义了组成该类型的数据和操作。这些操作和数据是类的一部分，也称为类的成员（member）。操作称为成员函数，而数据则称为数据成员（data member）。</p>
<hr>
<p>用class和struct关键字定义类的唯一差别在于默认访问级别：默认情况下，struct的成员为public，而class的成员为private。</p>
<hr>
<p>因为头文件包含在多个源文件中，所以不应该含有变量或函数的定义。如果const变量不是用常量表达式初始化，那么它就不应该在头文件定义。相反，和其他的变量一样，该const变量应该在一个源文件中定义并初始化。应在头文件中为它添加extern声明，以使其能被多个文件共享。</p>
<hr>
<p>使得头文件安全的通用做法，是使用预处理器定义头文件保护符（header guard）。</p>
<pre><code>#ifndef someheader.h
#define someheader.h
#endif
</code></pre><p>头文件应该含有保护符，即使这些头文件不会被其他头文件包含。编写头文件保护符并不困难，而且如果头文件被包含多次，它可以避免难以理解的编译错误。</p>
<hr>
<p>C++提供了更简洁的方式来使用命名空间成员。这里介绍一种最安全的机制：using声明。形式为：using namespace：：name；</p>
<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
using std::cin;
using std::cout;
int main()
{
.......
}
</code></pre><hr>
<p>一个using声明一次只能作用于一个命名空间成员。每个名字都需要一个using声明。</p>
<hr>
<p>标准库string类型支持长度可变的字符串。一般的声明格式如下：</p>
<pre><code>#include &lt;string&gt;
using std::string;
</code></pre><p>string标准库支持几个构造函数，如下：</p>
<pre><code>string s1；              默认构造函数，s1为空串
string s2（s1）；          将s2初始化为s1的一个副本
string s3（“value”）；     将s3初始化为一个字符串字面值副本
string s4（n，‘c’）；       将s4初始化为字符‘c’的n个副本
</code></pre><p>因为历史原因以及为了与C语言兼容，字符串字面值与标准库string类型不是同一种类型，编程时一定要注意区别。</p>
<hr>
<p>string类型的输入操作符：读取并忽略开头所有的空白字符（如空格，换行符，制表符）；读取字符直至再次遇到空白字符，读取中止。</p>
<hr>
<p>读入未知数目的string对象</p>
<pre><code>while(cin &gt;&gt; word)
    cout &lt;&lt; word &lt;&lt; endl;
</code></pre><hr>
<p>用getline读取整行文本，该函数接受两个参数：一个输入流对象和一个string对象。getline函数从输入流的下一行读取，并保存读取的内容到string中，但不包括换行符。</p>
<pre><code>string line;
while (getline(cin, line))
    cout &lt;&lt; line &lt;&lt; endl;
</code></pre><p>因为line不含换行符，如果需要逐行输出则需要自行添加。</p>
<hr>
<p>VC 6和Xcode中对于getline的使用都存在bug。具体的表现是VC6里要输入两次回车才能输出，而Xcode的出错则是释放了未分配的指针。具体的解决方案如下</p>
<p>VC6：</p>
<p>X:\Program Files\Microsoft Visual Studio\VC98\Include\string(注意是string文件，不是string.h)找到165行，下面的代码从163行开始</p>
<pre><code>else if (_Tr::eq((_E)_C, _D)) //163行
{_Chg = true;
//  _I.rdbuf()-&gt;snextc(); // 把这一行注释掉,添加下一行.
_I.rdbuf()-&gt;sbumpc(); //添加
break;}
</code></pre><p>Xcode：有两种方案，其实差不多，第一种是在代码最前面加上</p>
<pre><code>#define _GLIBCXX_FULLY_DYNAMIC_STRING 1 
#undef _GLIBCXX_DEBUG 
#undef _GLIBCXX_DEBUG_PEDANTIC
</code></pre><p>第二种如下：</p>
<p>The solution is to double-click on the target to open its Info window, go to the Build tab, and scroll down to the “GCC 4.2 - Preprocessing” section. In this section is a setting named “Preprocessor Macros” that by default has two entries, “_GLIBCXX_DEBUG=1” and “_GLIBCXX_DEBUG_PEDANTIC=1”. Remove these entries.</p>
<hr>
<p>string的size和empty操作。可以通过size操作获取。</p>
<pre><code>int main(){
    string st(“The expense of spirit\n”);
    cout &lt;&lt;  “The size of ” &lt;&lt;  st &lt;&lt;  “is ” &lt;&lt;  st.size() &lt;&lt; endl;
    return 0;}
</code></pre><p>empty成员函数将返回bool值，如果string对象为空则返回ture，否则返回false。</p>
<hr>
<p>size操作返回的是string::size_type类型的值。string类类型和许多其他库类型都定义了一些配套类型（companion type）。通过这些配套类型，库类型的使用就能与机器无关（machine－independent）。size_type就是这些配套类型的一种。定义为与unsigned型具有相同的含义，而且可以保证足够大能够存储任意string对象的长度。为了使用类型定义的size_type类型，程序员必须加上作用域操作符来说明所使用的size_type类型是由string类定义的。即std::size_type类型。不要把size的返回值赋给int变量！</p>
<hr>
<p>对string对象来说，可以把一个string对象赋值给另一个string对象。string对象的加法被定义为（concatenation）。如下</p>
<pre><code>string s1(“hello, ”);
string s2(“world\n”);
string s3 = s1 + s2;        // s3 is hello, world\n
</code></pre><p>如果要把s2直接追加到s1的末尾，就用＋＝</p>
<pre><code>s1 += s2;
</code></pre><hr>
<p>当进行string对象和字符串字面值混合连接操作时，＋操作符的左右操作数必须至少有一个是string类型的：</p>
<pre><code>string s4 = “hello” + “, ”;     // error: no string operand
string s5 = s1 + “, ” + “world ”;   // ok: each + has string operand
string s6 = “hello” + “,” + s2; // error: can’t add string literals
</code></pre><p>顺序是从左到右的，所以s5中的s1先和第二个加，还是string类型，然后和第二个加；而s6中的第一个和第二个相加就不满足条件了。</p>
<hr>
<p>string类型通过下标操作符（ [] ）来访问string对象中的单个字符。下标操作符需要取一个size_type类型的值，来标明要访问字符的位置。着下标中的值通常被称为“下标”或“索引（index）”。string对象的下标从0开始而s[s.size()-1]就是最后一个字符。</p>
<hr>
<p>vector是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。我们把vector称为容器，是 因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型的。在使用vector之前，必须包含相应的头文件。声明如下</p>
<pre><code>#include &lt;vector&gt;
using std::vector;
</code></pre><hr>
<p>vector是一个类模板（class template）。使用模板可以编写一个类定义或函数定义，而用于多个不同的数据类型。声明从类模板生产的某种类型的对象，需要提供附加信息，信息的种类取决于模板。以vector为例，必须说明vector保存何种对象的类型，通过将类型放在类模板名称后面的尖括号中来指定类型：</p>
<pre><code>vector&lt;int&gt; ivec;               // ivec holds objects of type int
vector&lt;Sales_item&gt; Sales_vec        // holds Sale_itmes
</code></pre><p>和其他变量定义一样，定义vector对象要指定类型和一个变量的列表。上面的第一个定义，类型是vector<int>，该类型即是含有若干int类型对象的vector，变量名为ivec。</int></p>
<hr>
<p>vector不是一种数据类型，而只是一个类模板，可用来定义多种数据类型。vector类型的每一种都指定了其保存元素的类型。因此，vector<int>和vector<string>都是数据类型。</string></int></p>
<hr>
<p>vector对象的初始化方式</p>
<pre><code>vector&lt;T&gt;  v1；          vector保存类型为T的对象，默认构造函数v1为空
vector&lt;T&gt;  v2；          v2是v1的一个副本
vector&lt;T&gt;  v3（n，i）；     v3包含n个值为i的元素
vector&lt;T&gt;  v4（n）；       v4含有值初始化的元素的n个副本
</code></pre><hr>
<p>vector对象（以及其他标准库容器对象）的重要属性就在于可以在运行时高效地添加元素。因为vector增长地效率高，在元素值已知的情况下，最好是动态地添加元素。</p>
<hr>
<p>vector对象的size</p>
<p>empty和size操作类似于string类型的相关操作。成员函数size返回相应vector类定义的size_type值。使用size_type类型时，必须指出该类型时在哪里定义的。vector类型总是包括vector的元素类型：</p>
<pre><code>vector&lt;int&gt;::size_type      // ok
vector::size_type           // error
</code></pre><hr>
<p>向vector添加元素。push_back()操作接受一个元素值，并将它作为一个新的元素添加到vector对象的后面。</p>
<pre><code>// read words from the standard input and store them as elements in vector
string word;
vector&lt;string&gt; text;                // empty vector
while(cin &gt;&gt; word){
    text.push_back(word);       // append word to text
}
</code></pre><hr>
<p>vector中的对象是没有命名的壳以按vector中对象的位置来访问它们。通常使用下标操作符来获取元素。vector元素的位置从0开始。</p>
<hr>
<p>必须是已存在的元素才能用下标操作符进行索引。通过下标操作进行赋值时，不会添加任何元素。如果想要插入新元素，写法如下：</p>
<pre><code>for (vector&lt;int&gt;::size_type ix = 0; ix != 10; ++ix)  //这样的话就保证了索引和实际一致
    ivec.push_back(ix);
</code></pre><hr>
<p>除了使用下标来访问vector对象的元素外，标准库还提供了另外一种访问元素的方式：使用迭代器（iterator），迭代器时一种检查容器内元素并遍历元素的数据类型。标准库为每一种标准容器（包括vector）定义了一种迭代器类型。迭代器类型提供了比下标操作更通用化的方法：所有的标准库容器都定义了相应的迭代器类型，而只有少数的容器支持下标操作。因此，现代C++程序更倾向于使用迭代器而不是下标来访问容器元素。</p>
<hr>
<p>容器的iterator类型，定义如下（以vector为例）</p>
<pre><code>vector&lt;int&gt;::iterator iter；
</code></pre><p>每种容器都定义了一对名为begin和end的函数，用于返回迭代器。如果容器中有元素的话，由begin返回的迭代器指向第一个元素：</p>
<pre><code>vector&lt;int&gt;::iterator iter ＝ ivec.begin();
</code></pre><p>上述语句把iter初始化为ivec[0]。由end操作返回的迭代器指向vector的“末端元素的下一个”。通常称为超出末端迭代器（off－the －end iterator），只是起一个哨兵（sentinel）的作用，表示我们已经处理完了vector中的所有元素。</p>
<hr>
<p>迭代器可以使用解引用操作符（*操作符）来访问迭代器所指向的元素</p>
<pre><code>*iter ＝ 0；  //即把iter当前指向的元素赋值为0
</code></pre><p>迭代器使用自增操作符向前移动迭代器指向容器中的下一个元素。</p>
<p>由于end操作返回的迭代器不指向任何元素，因此不能对它进行解引用或自增操作。</p>
<hr>
<p>用 == 或者 != 操作符来比较两个迭代器，如果两个迭代器对象指向同一个元素，则它们相等，否则就不相等。</p>
<hr>
<p>应用迭代器来编写的初始化为0的循环</p>
<pre><code>for(vector&lt;int&gt;::iterator iter = ivec.begin(); iter != ivec.end(); ++iter )
    *iter = 0;
</code></pre><hr>
<p>若定义为const_iterator类型，就只能用于读取容器内元素，但不能改变其值。而如果时const的iterator对象，那么这个迭代器就不能改变，这样基本就无用的。下面是一个const_iterator的例子：</p>
<pre><code>for(vector&lt;string&gt;::const_iterator iter = text.begin(); iter != text.end(); ++iter)
    cout &lt;&lt;  *iter &lt;&lt; endl;
</code></pre><hr>
<p>迭代器的算术操作（iterator arithmetic）：iter ＋ n与 iter － n。iter1 － iter2 用来计算两个迭代器对象的距离，该距离时名为difference_type的signed类型的值。例如求最靠近正中的元素，可用以下代码：</p>
<pre><code>vector&lt;int&gt;::iterator mid = vi.begin() + vi.size()/2;
</code></pre><p>任何改变vector长度的操作都会使已存在的迭代器失效。例如，在调用push_back后，就不能再信赖指向vector的迭代器的值了。</p>
<hr>
<p>标准库bitset类型可以用来处理二进制位的有序集，可以使用bitset处理，声明如下：</p>
<pre><code>#include &lt;bitset&gt;
using std::bitset;
</code></pre><hr>
<p>类似于vector，bitset类是一种类模板；而与vector不一样的是bitset类型对象的区别仅在其长度而不在其类型。定义bitset时，要明确bitset含有多少位，要在尖括号内给出它的长度值：</p>
<pre><code>bitset&lt;32&gt; bitvec;  // 32 bits, all zero
</code></pre><p>长度值必须定义为整型字面值常量或者是已用常量值初始化的整型的const对象。bitset中的位是没有命名的，程序员只能按位置访问。位集合的位置编号从0开始，以0位开始的位串是低阶位（low-order bit），以31位结束的位串是高阶位（high-order bit)。</p>
<hr>
<p>用unsigned值初始化bitset对象时，该值将转化为二进制的位模式。而bitset对象中的位集作为这种位模式的副本。如果bitset类型长度大于unsigned long值的二进制位数，则其余的高阶位将置为0；如果小于，则只使用unsigned值中的低阶位，其余的被丢弃。</p>
<hr>
<p>用string对象初始化bitset对象时，string对象直接表示为位模式。从string对象读入位集的顺序时从右向左：</p>
<pre><code>string strval(“111000”);
bitset&lt;32&gt; bitvec4(strval);
</code></pre><p>那么这时bitvec4的表示为：0000000000···000111（共32位）</p>
<pre><code>string str（“1111111000000011001101”）；
bitset&lt;32&gt; bitvec5(str, 5, 4);      //从str[5]开始的4个位。即1100
bitset&lt;32&gt; bitvec6（str，str.size()-4）    //取最后的四位。即1101
</code></pre><hr>
<p>现代C++程序应尽量使用vector和迭代器类型，而避免使用低级的数组和指针。设计良好的程序只有在强调速度时才在类实现的内部使用数组和指针。指针和数组容易产生不可预料的错误。其中一部分是概念上的问题：指针用于低级操作，容易产生与繁琐细节相关的（bookkeeping）错误。其他错误则源于使用指针的语法规则，特别是声明指针的语法。许多有用的程序都可不使用数组或指针实现，现代C++采用vector类型和迭代器取代一般的数组、采用string类型取代C风格字符串。</p>
<hr>
<p>如果可能的话，除非所指向的对象已经存在，否则不要先定义指针，这样可以避免定义一个未初始化的指针。如果必须分开定义指针和其所指向的对象，则将指针初始化未0。因为编译器可检测出0值的指针，程序可判断该指针并未指向一个对象。</p>
<hr>
<p>C++提供了一种特殊的指针类型 <code>void*</code>，它可以保存任何类型对象的地址。<code>void*</code>表明改指针与一地址值相关，但不清楚存储在此地址上的对象的类型。<code>void*</code>指针只支持几种有限的操作：与另一个指针进行比较；向函数传递<code>void*</code>指针或从函数返回<code>void*</code>指针；给另一个<code>void*</code>指针赋值。不允许使用<code>void*</code>指针操纵它所指向的对象。</p>
<hr>
<p>如果对左操作数进行解引用，则修改的是指针所指对象的值；如果没有使用解引用操作，则修改的是指针本身的值。</p>
<hr>
<p>如果指针指向const对象，则不允许用指针来改变其所指的const值。为了保证这个特性，C++语言强制要求指向const对象的指针也必须具有const特性：</p>
<pre><code>const double *cptr ;        // cptr may point to a double that is const
</code></pre><p>这里cptr是一个指向double类型const对象的指针，const限定了cptr指针所指向的对象类型，而并非cptr本身。也就是说cptr本身并不是const（这里推荐从右向左读以上语句，就可以理解为cptr指向一个const的double类型）。在定义的时候不需要初始化，也可以对其重新赋值，但不能通过cptr修改其所指向对象的值；把你个const对象的地址赋给一个普通的、非const对象的指针也会导致编译时的错误；不能使用<code>void*</code>指针保存const对象的地址，而必须使用<code>const void*</code>类型的指针保存const对象的地址；允许把const对象的地址赋给指向const对象的指针。</p>
<hr>
<p>不能使用指向const对象的指针修改基础对象，然后如果该指针指向的是一个非const对象，可用其他方法修改其所指的对象。</p>
<pre><code>const double *cptr;
dval = 3.14159;     // dval is not const
*cptr = 3.14159;        // error: cptr is a pointer to const
double *ptr = &amp;dval;        // ok: ptr points at non-const double
*ptr = 2.72;            // ok: ptr is plain pointer
cout &lt;&lt; *cptr;          // ok: prints 2.72
</code></pre><hr>
<p>从本质上说，由于没有方法分辨cptr所指的对象是否为const，系统会把它所有对象都视为const。如果指向const的指针所指的对象并非const，则可直接给该对象赋值或间接地利用普通地非const指针修改其值：毕竟这个值不是const。就是说不能保证指向const地指针所指对象的值一定不能修改。</p>
<hr>
<p>C++还提供了const指针——本身的值不能修改。任何企图给const指针赋值的行为（即使是赋同样的值）都会导致编译时的错误。定义方式如下：</p>
<pre><code>const double pi ＝ 3.14159；
const double *const pi_ptr = &amp; pi;
// pi_ptr is const and points to a const object
</code></pre><hr>
<p>C风格字符串（C-style character string）是以空字符null结束的字符数组。尽管C++支持C风格字符串，但不应该在C++程序中使用这个类型。C风格字符串常常带来许多错误，是导致大量安全问题的根源。</p>
<hr>
<p>可以这么样利用循环测试C风格字符串：</p>
<pre><code>const char *cp = “some value”;
while (*cp){
++cp；//注意一定是C风格字符串，因为这样才能保证结尾是null，否则不能结束
}
</code></pre><hr>
<p>用关系操作符（&gt; &lt; ==）来比较C风格字符串时，比较的时指针上存放的地址值，而不是它们所指向的字符串。</p>
<hr>
<p>调用者必须确保目标字符串具有足够的大小，但是却有潜在的严重错误。如果必须使用C风格字符串，strncat和strncpy比strcat和strcpy函数更安全。诀窍就是可以适当地控制复制字符地个数。特别是在复制和串联字符串时，一定要时刻记住算上结束符null。所以尽可能使用标准库类型string，不但安全性增强了，效率也提高了。</p>
<hr>
<p>数组类型的变量有三个重要的限制：数组长度固定不变，在编译时必须直到其长度，数组只有在定义它的块语句内存在。每一个程序在执行时都占用一块可用的内存空间，用于存放动态分配的对象，此内存空间称为程序的自由存储区（free store）或堆（heap）。C语言程序使用一对标准库函数malloc和free在自由存储区中分配存储空间，而C++语言则使用new和delete表达式实现相同的功能。</p>
<hr>
<p>允许动态分配空数组（编译的时候并不知道数组的长度）。可以用以下代码实现</p>
<pre><code>size_t n = get_size()   // get_size returns of elements needed
int* p = new int[n];
for(int* q = p; q !=p+n; ++q)
.........(可见ex3.17-3.21)
</code></pre><p>有趣的是，即使get_size返回的是0，代码依然可以正确执行。C++虽然不允许定义长度为0的数组变量，但明确指出，调用new动态创建长度为0的数组是合法的，返回有效的非零指针。</p>
<hr>
<p>动态分配的内存最后必须进行释放。C++为指针提供了delete []表达式释放指针所指向的数组空间。如 delete [ ] pia；就回收了pia指向的数组。如果遗漏了空方括号对，就无法告诉编译器该指针指向的是数组，将导致程序在运行时出错。</p>
<hr>
<p>使用数组初始化vector对象，必须指出用于初始化式的第一个元素以及数组最后一个元素的下一位置的地址：</p>
<pre><code>const size_t arr_size = 6;
int int_arr[arr_size] = {0,1,2,3,4,5};
// ivec has 6 elements: each a copy of the corresponding element in int_arr
vector&lt;int&gt; ivec(int_arr, int_arr + arr_size);
</code></pre><p>传递给ivec的两个指针标出了vector初值的范围。第二个指针指向被复制的最后一个元素之后的地址空间。</p>
<hr>
<p>用typedef简化指向多维数组的指针</p>
<pre><code>typedef int int_array[4];
int_array *ip = ia;
for (int_array *p = ia; p != ia + 3; ++p)
    for(int *q = *p; q != *p + 4; ++q)
        cout &lt;&lt; *q &lt;&lt; endl;
</code></pre><hr>
<p>逻辑与和逻辑或操作符总是先计算其左操作数，然后再计算其右操作数。只有仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解其右操作数。我们称这种求值策略为“短路求值（short-circuit evaluation）”。这么就引出了一个很有价值的用法：如果某边界条件使expr2的计算变得危险，那么显然expr1的计算结果为false。（expr1 &amp;&amp;(||)expr2）</p>
<hr>
<p>不应该串接使用关系操作符，虽然是左结合，但是由于其返回bool类型的结果，如果多个关系操作符串接起来使用，结果往往出乎意料。</p>
<hr>
<p>val本身是bool类型，或者val具有可转换为bool类型的数据类型。如果val是bool类型，那么if（val == true ）等价于 if（val）。</p>
<p>若val不是bool值，val和true的比较等效于 if （val == 1）</p>
<hr>
<p>位操作符使用整型的操作数。位操作符将其整型操作数视为二进制位的集合，为每一位提供检验和设置的功能（也可用于bitset类型）。位操作符操纵的整数的类型可以是有符号的也可以是没有符号的。如果操作数为负数，具体的处理情况就要依照机器的情况来判定，所以保险起见，用unsigned整型操作数。</p>
<hr>
<p>一般而言，标准库提供的bitset操作更直接，更容易阅读和书写、正确使用的可能性更高。而且，bitset对象的大小不受unsigned数的位数限制。通常来说，bitset优于整形术句的低级直接位操作。</p>
<hr>
<p>在赋值操作上加圆括号是必需的，因为赋值操作符的优先级低于不等操作符。</p>
<hr>
<p>对于for循环来说，例如：for（语句1；条件；增殖）这样的，先执行语句1，再判断是否满足条件，满足的话执行完循环体，再进行增殖，这里使用++i与i++的效果是一样的。但是只有再必要时才使用后置操作符（i++），因为前置操作需要做的工作更少。只需加1后返回加1后的结果即可。而后置操作符则必须先保存操作数原来的值，以便返回未加1之前的值作为操作的结果。对于int型对象和指针，编译器可优化掉这项额外工作。但是对于更多的复杂迭代器类型，这种额外工作可能花费更大的代价。因此，养成使用前置操作这个好习惯，就不必担心性能差异的问题。</p>
<hr>
<p>sizeof操作符的作用是返回一个对象或类型名的长度，返回值的类型为size_t，长度的单位是字节。sizeof表达式的结果是编译时常量。</p>
<hr>
<p>对char类型或值为char类型的表达式做sizeof操作保证得1。</p>
<p>对引用类型做sizeof操作将返回存放此引用类型对象所需的内存空间大小。</p>
<p>对指针做sizeof操作将返回存放指针所需的内存大小；注意，如果要获取该指针所指向的对象的大小，则必须对该指针进行解引用。</p>
<p>对数组做sizeof操作等效于将对其元素类型做sizeof的结果乘上数组元素的个数。所以用sizeof数组的结果除以sizeof其元素类型的结果，即可求得数组元素的个数。</p>
<hr>
<p>逗号表达式是一组由逗号分隔的表达式，这些表达式从左向右计算。逗号表达式的结果是其最右边表达式的值。</p>
<hr>
<p>含有两个或更多操作符的表达式称为复合表达式（compound expression）。在复合表达式中，操作数和操作符的结合方式决定了整个表达式的值。表达式的结果会因为操作符和操作数的分组结合方式的不同而不同。操作数的分组结合方式决定了整个表达式的值。表达式的结果会因为操作符和操作数的分组结合方式的不同而不同。优先级规定的是操作数的结合方式，但并没有说明操作数的计算顺序。在大多数情况下，操作数一般以最方便的次序求解。</p>
<hr>
<p>以下两个指导原则有助于处理复合表达式：</p>
<p>（1）如果有怀疑，则在表达式上按程序逻辑要求使用圆括号强制操作数的组合。</p>
<p>（2）如果要修改才做数的值，则不要在同一个语句的其他地方使用该操作数。如果必须使用改变的值，则把该表达式分割成两个独立语句：在一个语句中改变操作数的值，再在下一个语句使用它。</p>
<p>一个表达式里，不要在两个或更多的子表达式中对同一对象做自增或自减操作。</p>
<hr>
<p>定义变量时，必须指定其数据类型和名字。而动态创建对象时，只需指定其数据类型，而不必为该对象命名。取而代之的是，new表达式返回指向新创建对象的指针，我们通过该指针来访问此对象：</p>
<pre><code>int *pi = new int;  //pi points to dynamically allocated, unnamed, uninitialized int
</code></pre><p>这个new表达式在自由存储区中分配创建了一个整型对象，并返回此对象的地址，并用该地值初始化指针pi。</p>
<hr>
<p>动态创建的对象可用初始化变量的方式实现初始化：</p>
<pre><code>int *pi = new int(1024);        // object to which pi points is 1024
string *ps = new string(10, ‘9’);   // *ps is “9999999999”
</code></pre><p>正如我们（几乎）总是要初始化定义为变量的对象一样，在动态创建对象时，（几乎）总是对它做初始化也是一个好办法。</p>
<hr>
<p>动态创建的对象用完后，程序员必须显式地将该对象占用地内存返回给自由存储区。可以使用delete表达式释放指针所指向地地址空间。如：</p>
<pre><code>delete pi；该命令释放pi指向的int型对象占用的内存空间。
</code></pre><p>若指针指向不是用new分配的内存地址，则在该指针上使用delete是不合法的。C++没有明确定义如何释放指向不是用new分配的内存地址的指针。</p>
<hr>
<p>执行语句 delete p；之后，p变成没有定义。在很多机器上，尽管p没有定义，但仍然存放了它之前所指向的地址，然而p所指向的内存已经被释放，因此p不再有效。删除指针后，该指针变成悬垂指针（dangling pointer）。悬垂指针指向曾经存放对象的内存，但该对象已经不再存在了。悬垂指针往往导致程序错误，而且很难检测出来。</p>
<p>一旦删除了指针所指向的对象，立即将指针置为0，这样就非常清楚地表明指针不再指向任何对象。</p>
<hr>
<p>const对象地动态分配和回收</p>
<pre><code>const int *pic = new const int(1024);
</code></pre><p>动态创建的const对象必须在创建时初始化，并且一经初始化，其值就不能修改。</p>
<pre><code>delete pic；// ok: deletes a const object
</code></pre><hr>
<p>将enum对象或枚举成员提升为什么类型由机器定义，并且依赖于枚举成员的最大值。无论其最大值时什么，enum对象或枚举成员至少提升为int型。</p>
<hr>
<p>当使用非const对象初始化const对象的引用时，系统将非const对象转化为const对象。此外，还可以将非const对象的地址（或非const指针）转换为const类型的指针。</p>
<hr>
<p>显式转换也称为强制类型转换（cast），包括以下名字命名的强制类型转换操作符：static_cast、dynamic_cast、const_cast和reinterpret_cast。</p>
<p>虽然有时候确实需要强制类型转换，但是它们本质上是非常危险的。</p>
<hr>
<p>因为要覆盖通常的标准转换，所以需要显式使用强制类型转换</p>
<pre><code>double dval;
int ival;   //这里要先将ival转换称double型，然后再把double型的结果
ival *= dval;   //截取为int型，再赋值给ival。
</code></pre><p>为了去掉这个不必要的转换，可以强制将ival转换为int型<br>    ival *= static_cast<int>(dval);</int></p>
<p>显式使用强制类型转换的另一个原因是可能存在多种转换，需要选择一种特定的类型转换。</p>
<hr>
<p>const_cast，将转换掉表达式的const性质。dynamic_cast支持运行时识别指针或引用所指向的对象。reinterpret_cast通常为操作数的位模式提供较低层次的重新解释。</p>
<p>reinterpret_cast本质上依赖于机器。为了安全地使用reinterpret_cast，要求程序员完全理解所设计地数据类型，以及编译器实现强制类型转换的细节。</p>
<hr>
<p>编译器隐式执行的任何类型转换都可以由static_cast显式完成</p>
<pre><code>double d = 97.0;
char ch = static_cast&lt;char&gt;(d);
</code></pre><p>当需要将一个较大的算术类型赋值给较小的类型时，使用强制转换非常有用。此时强制类型转换告诉程序的读者和编译器：我知道并且不关心潜在的精度损失。这样警告信息就会消失。如果编译器不提供自动转换，使用<code>static_cast</code>来执行类型转换也是很有用的。例如下面的程序使用<code>static_cast</code>找回存放在<code>void*</code>指针中的值：</p>
<pre><code>void *p = &amp;d;
double *dp = static_cast&lt;double*&gt;p;
</code></pre><hr>
<p>强制类型转换关闭或挂起了正常的类型检查。强烈建议程序员避免使用强制类型转换，不依赖强制类型转换也能写出很好的C++程序。这个建议再如何看待<code>reinterpret_cast</code>的使用时非常重要。此类强制转换总是非常危险的。相似地，使用<code>const_cast</code>也总是预示着设计缺陷。设计合理的系统不需要使用强制类型转换抛弃const特性。如果非强制转换不可，则应限制强制转换值的作用域，并且记录所有假定涉及的类型，这样能减少错误发生的机会。</p>
<hr>
<p>如果在程序的某个地方，语法上需要一个语句，但逻辑上并不需要，此时应该使用空余句。这种用法常见于在循环条件判断部分就能完成全部循环工作的情况。</p>
<p>使用空语句时应该加上注释，以便任何读这段代码的人都知道该语句是有意义的。</p>
<hr>
<p>在条件表达式中定义的变量必须初始化，该条件检验的就是初始化对象的值。这种变量的作用域限制在语句体内。通常，语句体本身就是一个块语句，其中也可能包含了其他的块。一个在控制结构里引入的名字是该语句的局部变量，其作用域限在语句内部。</p>
<hr>
<p>很多编辑器和开发环境都提供工具自动根据语句结构缩排源代码。有效地利用这些工具将是一种很好的编程方法。</p>
<hr>
<p>所有语言的if语句普遍存在着潜在的二义性。这种情况往往称为悬垂else（dangling-else）问题，C++中悬垂else问题带来的二义性，通过将else匹配给最后出现的尚未匹配的if子句来解决。</p>
<hr>
<p>尽管没有严格要求在switch结构的最后一个标号之后指定break语句，但是，为了安全起见，最好在每个标号后面提供一个break语句，即使是最后一个标号也一样。如果以后在switch结构的末尾又需要添加一个新的case标号，则不用再前面添加break语句了。</p>
<p>故意省略case后面的break语句是很罕见的，因此应该提供一些注释说明其逻辑。</p>
<hr>
<p>default标号（default label）提供了相当于else子句的功能。如果所有的case标号与switch表达式的值都不匹配，并且default标号存在，则执行default标号后面的语句。哪怕没有语句要在default标号下执行，定义default标号仍然是有用的。定义default标号是为了告诉它的读者，表明这种情况已经考虑到了，只是没有什么要执行的。</p>
<hr>
<p>再循环条件中定义的变量再每次循环里都要经历创建和撤销的过程。</p>
<hr>
<p>do while循环保证循环体至少执行一次，并且总是以分号结束。</p>
<hr>
<p>goto语句提供了函数内部的无条件跳转，实现从goto语句跳转到同一函数内某个带标号的语句。语法规则位：    goto label； 其中label是用于标识带标号的语句的标识符。再任何语句前提供一个标识符和冒号，即得带标号得语句（labeled statement）：</p>
<pre><code>end： return；    // labeled statement, may be target of a goto
</code></pre><p>goto语句不能跨越变量得定义语句向前跳转：</p>
<pre><code>//  ...
goto end;
int ix = 10;        // error: goto bypasses declaration statement

end:
// error: code here could use ix but the goto bypassed its declaration
ix =  42;
</code></pre><p>如果确实需要再goto和其跳转对应得标号之间定义变量，则定义必须放在一个块语句中：</p>
<pre><code>// ...
goto end;
{
    int ix = 10;
    // ...code using ix
}
end: // ix no longer visible here
</code></pre><p>向后跳过已经执行得变量定义语句是合法的。</p>
<p>再涉及各种软件系统的过程中，处理程序中的错误和其他反常行为是最困难的部分之一。异常就是运行时出现的不正常，例如运行时耗尽了内存或遇到意外的非法输入。异常存在于程序的正常功能之外，并要求程序立即处理。在设计良好的系统中，异常是程序错误处理的一部分。当程序代码检查到无法处理的问题时，异常处理就特别有用。在这些情况下，检测出问题的那部分程序需要一种方法把控制权转到可以处理这个问题的那部分程序。错误检测程序还必须指出具体出现了什么问题，并且可能需要提供一些附加信息。</p>
<hr>
<p>异常机制提供程序中错误检测与错误处理部分之间的通信。C++的异常处理中包括：</p>
<p>throw表达式（throw expression），错误检测部分使用这种表达式来说明遇到了不可处理的错误。可以说，throw引发（raise）了异常条件。</p>
<p>try块（try block），错误处理部分使用它来处理异常。try语句块以try关键字开始，并以一个或多个catch子句（catch clause）结束。在try块中执行的代码所抛出（throw）的异常，通常会被其中一个catch子句处理。由于它们“处理”异常，catch子句也称为处理代码（handler）</p>
<p>由标准库定义的一组异常类（exception class），用来在throw和相应的catch之间传递有关的错误信息。</p>
<hr>
<p>系统通过throw表达式抛出异常。throw表达式由关键字throw以及尾随的表达式组成，通常以分号结束，这样它就称为了表达式语句。throw表达式的类型决定了所抛出异常的类型。下面是用throw抛出异常来改写检测代码(判断是否是同一本书，如果不是就输出信息并退出)：</p>
<pre><code>// first check that data is for the same item
if(!item1.same_isbn(item2))
    throw runtime_error(“Data must refer to same ISBN”);
// ok, if we’re still here the ISBNs are the same
std::cout &lt;&lt; item1 + item2 &lt;&lt; std::endl;
</code></pre><p>throw语句使用了一个表达式。这里是用的是runtime_error类型的对象，此类型是标准库异常类中的一种，在stdexcept头文件中定义，这样就可以提供更多相关信息。</p>
<hr>
<p>try块的通用语法形式是：</p>
<pre><code>try{
    program-statements
} catch (exception-specifier){
    handler-statements
} catch (exception-specifier){
    handler-statements
}   //......
</code></pre><p>try块以关键字try开始，后面是用花括号括起来的语句序列块。try块后面是一个或多个catch子句。每个catch子句包括三部分：关键字catch，圆括号内单个类型或者单个对象的声明，称为异常说明符（exception specifier），以及通常用花括号括起来的语句块。如果选择了一个catch子句来处理异常，则执行相关的块语句。一旦catch子句执行结束，程序流程立即继续执行紧随着最后一个catch子句的语句。try语句内的program-statement形成程序的正常逻辑。这里面可以包含任意C++语句，包括变量声明。与其他语句一样，try块引入局部作用域，在try块中声明的变量，包括catch子句中声明的变量，不能在try外面引用。</p>
<hr>
<p>对于111中抛出的错误，与用户交互的部分可能会包括以下代码：</p>
<p>   while(cin &gt;&gt; item1 &gt;&gt; item2 ){<br>        try{<br>        // execute code that will add the two Sales_items<br>        // if the addition fails, the code throws a runtime_error exception<br>    } catch(runtime_error err){<br>        // remind the user that ISBN must match and prompt for another pair<br>        cout &lt;&lt; err.what()<br>                &lt;&lt; “\nTry Again? Enter y or n” &lt;&lt; endl;<br>        char c;<br>        cin &gt;&gt; c;<br>        if(cin &amp;&amp; c == ‘n’)<br>            break;      //break out of the while loop<br>        }<br>    }</p>
<p>通过输出err.what()的返回值提示用户。这里what返回的C风格字符串，是用于初始化runtime_error的string对象的副本。</p>
<hr>
<p>在复杂的系统中，程序的执行路径也许在遇到抛出异常的代码之前，就已经经过了多个try块。例如一个try块可能调用了包含另一try块的函数，它的try块又调用了含有try块的另一函数，如此类推。</p>
<p>寻找处理代码的过程与函数调用链刚好相反。抛出一个异常时，首先要搜索的是抛出异常的函数。如果没有找到匹配的catch，则终止这个函数的执行，并在调用这个函数的函数中寻找相配的catch。如果仍然没有找到相应的处理代码，该函数同样要终止，搜索调用它的函数。如此类推，继续按执行路径回退，直到找到适当类型的catch为止。</p>
<p>如果不存在处理该异常的catch子句，程序的运行就要跳转到名为terminate的标准库函数，该函数在exception头文件中定义。通常情况下，其执行将导致程序非正常退出。</p>
<p>抛出异常的语句要在try中···不然会挂掉的。</p>
<hr>
<p>C++标准库定义了一组类，用于报告在标准库中函数遇到的问题。程序员可在自己编写的程序中使用这些标准异常类。exception头文件定义了最常见的异常类，类名是exception。这个类只通知异常的产生，不会提供更多的信息。stdexcept头文件定义了几种常见的异常类。new头文件定义了bad_alloc异常类型，提供因无法分配内存而由new抛出的异常。type_info头文件定义了bad_cast异常类型。</p>
<p>标准库异常类只提供很少的操作，包括创建、赋值异常类型对象以及异常类型对象的赋值。exception、bad_alloc以及bad_cast类型只定义了默认构造函数，无法在创建这些类型的对象时为它们提供初值。其他的异常类则只定义了一个使用string初始化式的构造函数，用于为所发生的错误提供更多的信息。</p>
<p>异常类型只定义了一个名为what的操作。这个函数不需要任何参数，并且返回const char*类型的值。它返回的指针指向一个C风格字符串，用来提供对异常的更详细的文字描述。</p>
<hr>
<p>C++程序员有时候也会使用预处理技术来有条件地执行用于调试的代码。这种想法是：程序所包含的调试代码仅在开发过程中执行，当应用程序已经完成，并且准备提交时，就会将调试代码关闭。可使用NDEBUG预处理变量实现有条件的调试代码。</p>
<pre><code>int main(){
#ifndef NDEBUG
cerr &lt;&lt; “starting main” &lt;&lt; endl;
#endif
// .......
</code></pre><p>如果NDEBUG未定义，那么程序就会将信息写到cerr中。如果NDEBUG已经定义了，那么程序执行时将会跳过#ifndef和#endif之间的代码。</p>
<hr>
<p>预处理器还定义了其余四在调试时非常有用的常量：</p>
<pre><code>_ _FILE_ _ 文件名              _ _LINE_ _ 当前行号
_ _TIME_ _ 文件被编译的时间     _ _DATE_ _ 文件被编译的日期
</code></pre><p>另一个常见的调试技术是使用NDEBUG预处理变量以及assert（断言）预处理宏（preprocessor macro）。assert宏是在cassert头文件中定义的。预处理宏有点像函数调用。assert宏需要一个表达式作为它的条件： assert（expr）<br>只要NDEBUG未定义，assert宏就求解表达式expr，如果结果为false，assert输出信息并且终止程序的执行。如果该表达式有一个非零，则assert不做任何操作。在成品代码中，assert语句不做任何工作，因此也没有任何运行时的代价。当然，也不会引起任何运行时的检查。assert仅用于检查确实不可能的条件，这只对程序的测试有帮助，但不能用来代替运行时的逻辑检查，也不能代替对程序可能产生的错误检测。</p>
<hr>
<p>函数可以看作程序员定义的操作。与内置操作符相同的是，每个函数都会实现一系列的计算。但与操作符不同的是，函数是有自己的函数名，而且操作数没有数量限制。与操作符一样，函数可以重载，这意味着同样的函数名可以对应多个不同的函数。</p>
<hr>
<p>函数不能返回另一个函数或者内置数组类型，但可以返回指向函数的指针，或者指向数组元素的指针的指针。C++是一种静态强类型语言，对于每一次的函数调用，编译时都会检查其实参。</p>
<hr>
<p>每次调用函数时，都会重新创建该函数所有的形参，此时所传递的实参将会初始化对应的形参。型材的初始化与变量的初始化一样：如果形参具有非引用类型，则赋值实参的值，如果形参为引用类型，则它只是实参的别名。</p>
<hr>
<p>普通的非引用类型的参数通过复制对应的实参实现初始化。当用实参副本初始化形参时，函数并没有访问调用所传递的实参本身，因此不会修改实参的值。非引用形参表示对应实参的局部副本。对这类形参的修改仅仅改变了局部副本的值。一旦函数执行结束，这些局部变量的值也就没有了。</p>
<hr>
<p>指针形参是指向const类型还是非const类型，将影响函数调用所使用的实参。在调用函数时，如果该函数使用非引用的非const形参，则既可给该函数传递const实参，也可传递非const的实参。</p>
<hr>
<p>复制实参并不是在所有的情况下都适合，不适合复制实参的情况包括：<br>当需要在函数中修改实参的值时。</p>
<p>当需要以大型对象作为实参传递时。对实际的应用而言，复制对象所付出的时间和存储空间代价往往过大。</p>
<p>当没有办法实现对象的复制时。</p>
<p>对于上述几种情况，有效的解决办法是将形参定义为引用或指针类型。</p>
<hr>
<p>如果想要在函数中交换实参的值，需要将形参定义为引用类型：</p>
<pre><code>void swap(int &amp;v1,int &amp;v2){
int temp = v2; v2 = v1; v1 =  temp;
}
</code></pre><p>与所有引用一样，引用形参直接关联到其所绑定的对象，而非这些对象的副本。定义引用时，必须用与该引用绑定的对象初始化该引用。引用形参完全以相同的方式工作。每次调用函数，引用形参被创建并与相应实参关联。</p>
<hr>
<p>使用引用形参返回额外的信息。例如，定义一个<code>find_val</code>函数，在一个整型vector对象的元素中搜索某个特定值。如果找到满足要求的元素，则返回指向该元素的迭代器；否则返回一个迭代器，执行该vector对象的end操作返回的元素。此外，如果该值出现了不止一次，我们还希望函数可以返回其出现的次数。在这种情况下，返回的迭代器应该指向具有要寻找的值的第一个元素。</p>
<p>我们可以定义一种包含一个迭代器和一个计数器的新类型。而更简便的解决方案给<code>find_val</code>传递一个额外的引用实参，用于返回出现册数的统计结果。</p>
<pre><code>// returns an iterator that refers to the first occurrence of value
// the reference parameter occurs contains a second return value
vector&lt;int&gt;::const_iterator find_val(
    vector&lt;int&gt;::const_iterator beg,        // first element
    vector&lt;int&gt;::const_iterator end,        // one past last element
    int value,                  // the value we want
    vector&lt;int&gt;::size_type &amp;occurs)     // number of times it occurs
{
    // res_iter will hold first occurrence, if any
    vector&lt;int&gt;::const_iterator res_iter = end;
    occurs = 0;                 // set occurrence count parameter
    for( ; beg != end; ++beg)
        if(*beg == value) {
            // remember first occurrence of value
            if(res_iter == end)
            res_iter = beg;
            ++occurs;               // increment occurrence count
    }
    return res_iter;                // count returned implicitly in occurs
}
</code></pre><p>调用<code>find_val</code>时，需传递四个实参：一对标识vector对象中要搜索的元素范围的迭代器，所查找的值，以及用于存储出现次数的<code>size_type</code>类型对象。假设ivec是vecter<int>类型的对象，it是一个适当类型的迭代器，而ctr则是size_type类型的变量，则可如此调用该函数：  </int></p>
<pre><code>it = find_val(ivec.begin(), ivec.end(), 42, ctr);
</code></pre><p>调用后，ctr的值将是42出现的次数，如果42在ivec中出现了，则it将指向其第一次出现的位置；否则it的值为ivec.end()，而ctr则为0。</p>
<hr>
<p>在向函数传递大型对象时，需要使用引用形参，对于大部分的类类型或者大型数组，复制实参的效率就太低了，此时就可以利用const引用直接访问实参对象，无须复制。</p>
<p>如果使用引用形参的唯一目的是避免复制实参，则应将形参定义为const引用。</p>
<hr>
<p>应该将不需要修改的引用形参定义为const引用。普通的非const引用形参在使用时不太灵活。这样的形参既不能用const对象初始化，也不能用字面值或产生右值的表达式实参初始化。</p>
<hr>
<p>通常，函数不应该有vector或其他标准库容器类型的形参。。调用含有普通的非引用vector形参的函数将会复制vector的每一个元素。从避免复制vector的角度出发，应考虑将形参声明为引用类型。事实上，C++程序员倾向于通过传递指向容器中需要处理的元素的迭代器来传递容器。</p>
<pre><code>// pass iterators to the first and one past the last element to print
void print(vector&lt;int&gt;::const_iterator beg,
    vector&lt;int&gt;::const_iterator end){
    while (beg != end){
        cout &lt;&lt; *beg++;
        if (beg != end)   cout &lt;&lt; “ ”;  // no space after last element
    }
cout &lt;&lt; endl;
}
</code></pre><hr>
<p>通常，将数组形参直接定义为指针要比使用数组语法定义更好。这样就明确地表示，函数操纵的是指向数组元素的指针，而不是数组本身。由于护绿了数组长度，形参定义中如果包含了数组长度则特别容易引起误解。当编译器检查数组形参关联的实参时，它只会检查实参是不是指针、指针的类型和数组元素的类型是否匹配，而不会检查数组的长度。</p>
<hr>
<p>若形参是数组的引用，编译器不会将数组实参抓化为指针，而是传递数组的引用本身。在这种情况下，数组大小称为形参和实参类型的一部分。编译器检查数组实参的大小与形参大小是否相配。</p>
<hr>
<p>和其他数组一样，多为数组以指向0号元素的指针方式传递。多维数组的元素本身就是数组。除了第一维以外的所有维德长度都是元素类型的一部分，必须明确指定：</p>
<pre><code>// first parameter is an array whose elements are arrays of 10 ints
void printValues(int (matrix*)[10], int rowSize);
</code></pre><p>除了第一维以外的所有维德长度都是元素类型的一部分，必须明确指定。我们也可以用数组语法定义多维数组。与一维数组一样，编译器忽略第一维的长度，所以最好不要把它包括在形参表内。</p>
<hr>
<p>非引用数组形参的类型检查只是确保实参是和数组元素具有同样类型的指针，而不会检查实参实际上是否指向指定大小的数组。任何处理数组的程序都要确保程序停留在数组的边界内。</p>
<hr>
<p>有三种常见的编程技巧确保函数的操作部超出数组实参的边界。第一种方法是在数组本身放置一个标记来检测数组的结束。C风格字符串就是采用这种方法的一个例子。第二种方法是传递指向数组第一个和最后一个元素的下一个位置的指针，这样就可以确定一个元素范围，程序就会安全。点钟方法是将第二个形参定义为表示数组的大小，即显示传递表示数组大小的形参。</p>
<hr>
<p>return语句用于结束当前正在执行的函数，并将控制权返回给调用此函数的函数。可以返回值，也可以不返回。不带返回值的return语句只能用于返回类型为void的函数。在返回类型为void的函数中，return返回语句不是必需的，隐式的return发生在函数的最后一个语句完成时。一般情况下，返回类型是void的函数使用return语句是为了引起函数的强制结束。在含有return语句的循环后没有提供return语句是很危险的，因为大部分的编译器不能检测出这个漏洞，运行时会出现什么问题是不确定的。</p>
<hr>
<p>返回类型不是void的函数必需返回一个值，但此规则有一个例外情况：允许主函数main没有返回值就可结束。</p>
<hr>
<p>返回非引用类型的时候，return都会在调用该函数的时候复制返回的对象。而返回引用类型的时候则是不复制的。</p>
<hr>
<p>理解返回引用至关重要的是：千万不能返回局部变量的引用。当函数执行完毕时，将释放分配给局部对象的存储空间。此时，对局部对象的引用就会指向不确定的内存。</p>
<p>确保返回引用安全的一个好方法是：请自问，这个引用指向哪个在此之前存在的对象？</p>
<hr>
<p>函数定义就是写明具体的执行过程，声明就是告诉编译器要使用这个函数。函数声明由函数返回类型、函数名和形参列表组成。形参列表必须包括形参类型，但是不必对形参命名。这三个元素被称为函数原型（function prototype），函数原型描述了函数的接口。</p>
<hr>
<p>函数也应当在头文件中声明，并在源文件中定义。定义函数的源文件应包含声明该函数的头文件。</p>
<hr>
<p>因为char是整形，因此把一个char值传递给int型形参是合法的，反之亦然。</p>
<hr>
<p>在C++语言中，每个名字都有作用域，而每个对象都有生命期（lifetime）。要弄清楚函数是怎么运行的，理解这两个概念十分重要。名字的作用域指的是知道该名字的程序文本区。对象的生命期则是在程序执行过程中对象存在的时间。</p>
<hr>
<p>默认情况下，局部变量的生命期局限于所在函数的每次执行期间。只有当定义它的函数被调用时才存在的对象称为自动对象（automatic object）。自动对象在每次调用函数时创建和撤销。在函数结束后，自动对象和形参的值都不能再访问了。</p>
<hr>
<p>一个变量如果位于函数的作用域内，但是生命期却跨域了这个函数的多次调用，这种变量往往很有用。则应该将这样的对象定义为static（静态的）。static局部对象（static local object）确保不迟于在程序执行流程第一经过该对象的定义语句时进行初始化。这种对象一旦被创建，在程序结束前都不会被撤销。当定义静态局部对象的函数结束时，静态对象不会被撤销。</p>
<pre><code>size_t count_calls(){
    static size_t ctr = 0;  // value will persist across calls
    return ++ctr;
}
int main(){
    for(size_t i = 0; i != 10; ++i)
        cout &lt;&lt; cout_calls() &lt;&lt; endl;
    return 0;
}
</code></pre><p>依次输出1到10（包含10）的整数。</p>
<hr>
<p>内联函数避免函数调用的开销，相当于在调用函数的时候用函数体替换，就可以加快速度。在函数返回类型前加上关键字inline就可以指定为内联函数。内联说明（inline specification）对于编译器来说只是一个建议，编译器可以选择忽略这个建议。一般来说，内联机制适用于优化小的、只有几行而且经常被调用的函数。大多数编译器都不支持递归函数的内联。</p>
<hr>
<p>内联函数应该在头文件中定义，这一点不同于其他函数。在头文件中加入或修改内联函数时，使用了该头文件的所有泊文件都必须得重新编译。</p>
<hr>
<p>成员函数的定义与普通函数的定义类似。和任何函数一样，成员函数也包含下面四个部分：函数返回类型、函数名、用逗号隔开的形参表（也可能是空的）、包含在一对花括号里面的函数体。函数原型必须在类中定义。但是，函数体则既可以在类中也可以在类外定义。类的所有成员都必须在类定义的花括号里声明，此后，就不能再为类增加任何成员。类的成员函数必须如声明的一般定义。类的成员函数既可以在类的定义内也可以在类的定义外定义。编译器隐式地将在类内定义的成员函数当作内联函数。类的成员函数可以访问该类的private成员。</p>
<hr>
<p>每个成员函数（除static成员函数外）都有一个额外的、隐含的形参this。在调用成员函数时，形参this初始化为调用函数的对象的地址。</p>
<hr>
<p>const对象、指向const对象的指针或引用只能调用其const成员函数，如果尝试用它们来调用非const成员函数，则是错误的。</p>
<hr>
<p>在成员函数中，不必显式地使用this指针来访问被调用函数所属对象的成员。对这个类的成员的任何没有前缀的引用，都被假定为通过指针this实现的引用。</p>
<hr>
<p>在类外定义成员函数就必须指明它们是类的成员</p>
<pre><code>double Sales_item::avg_price() const{
if (units_sold)
    return revenue/units_sold;
else
    return 0;
}
</code></pre><p>使用作用域操作符指明函数avg_price是在类Sales_item的作用域范围内定义的。</p>
<hr>
<p>构造函数（constructor）是特殊的成员函数，与其他成员函数不同，构造函数和类同名，而且没有返回类型。而与其他成员函数相同的是，构造函数也有形参表（可能为空）和函数体。一个类可以有多个构造函数，每个构造函数必须有与其他构造函数不同数目或类型的形参。构造函数也必须在类中声明，但是可以在类中或类外定义。构造函数放在类的public部分。</p>
<hr>
<p>如果没有为一个类显式定义任何构造函数，编译器将自动为这个类生成默认构造函数。合成的默认构造函数一般适用于仅包含类类型成员的类。而对于含有内置类型或复合类型成员的类。则通常应该定义他们自己的默认构造函数初始化这些成员。</p>
<hr>
<p>出现在相同作用域中的两个函数，如果具有相同的名字而形参表不同，则成为重载函数（overloaded function）。如果两个函数声明的返回类型和形参表完全匹配，则将第二个函数声明视为第一个的重复声明。如果两个函数的形参表完全相同，但返回类型不同，则第二个声明是错误的。</p>
<hr>
<p>一般作用域规则同样适用于重载函数名。如果局部地声明一个函数，则该函数将屏蔽而不是重载在外层作用域中声明的同名函数。所以，每一个版本的重载函数都应在同一个作用域中声明。一般来说，局部地声明函数时一种不明智的选择。函数的声明应放在头文件中。在C++中，名字查找发生在类型检查之前。</p>
<hr>
<p>函数重载确定（overload resolution，即函数匹配function matching）是将函数调用与重载函数集合中的一个函数相关联的过程。通过自动提取函数调用中实际使用的实参与重载集合中各个函数提供的形参做比较，编译器实现该调用与函数的匹配。</p>
<hr>
<p>为了确定最佳匹配，编译器将实参类型到相应形参类型的转换划分等级。转换等级以降序排列如下：精确匹配（exact match），实参与形参类型相同。通过类型提升（promotion）实现的匹配。通过标准转换（standard conversion）实现的匹配。通过类类型转换（class-type conversion）实现的匹配。</p>
<p>内置类型的提升和转换可能会使函数匹配产生意想不到的结果。但幸运的是，设计良好的系统很少会包含形参类型相当接近的函数。</p>
<hr>
<p>类型提升或转换适用于实参类型可通过某种标准转换提升或转换为适当的形参类型的情况。通过类型提升实现的转换优于其他标准的转换。</p>
<pre><code>void ff(int);
void ff(short);
ff(‘a’);            // char promotes to int, so matches ff(int)
</code></pre><hr>
<p>枚举类型enum的对象只能用同一枚举类型的另一个对象或一个枚举成员（enumerator）进行初始化。整数对象即使具有与枚举元素相同的值也不能用于调用期望获得枚举类型实参的函数。虽然无法将整型值传递给枚举类型的形参，但可以将枚举值传递给整数形参。此时，枚举值被提升为int型或更大的整形。具体的提升类型取决于枚举成员的值。</p>
<hr>
<p>仅当形参是引用或指针时，形参是否为const才有影响。</p>
<hr>
<p>函数指针是指指向函数而非指向对象的指针。像其他指针一样，函数指针也指向某个特定的类型。函数类型由其返回类型以及形参表确定，而与函数名无关。</p>
<pre><code>// pf points to function returning bool that takes two const string references
bool (*pf)(const string &amp;, const string &amp;);
</code></pre><p>其中<code>*pf</code>两侧的括号是必需的。或者是使用typedef为指针类型定义同义词，可将函数指针的使用大大简化。</p>
<pre><code>typedef bool (*cmpFcn) (const string &amp;, const string &amp;);
</code></pre><p>以后使用则直接用cmpFcn即可。</p>
<hr>
<p>在引用函数名但又没有调用该函数时，函数名将被自动解释为指向函数的指针。函数指针只能通过同类型的函数或函数指针或0值常量表达式进行初始化或赋值。</p>
<hr>
<p>指向函数的指针可用于调用它所指向的函数。可以不需要使用解引用操作符，直接通过指针调用函数。函数的形参可以是指向函数的指针。</p>
<hr>
<p>endl操纵符用于输出一个换行符并刷新缓冲区。而flush，用于刷新流，但不在输出中添加任何字符。还有一个比较少用的ends，这个操作符在缓冲区插入空字符null，然后刷新它。如果需要刷新所有输出，最好使用unitbuf操作符。这个操作符在每次执行完写操作后都刷新流： </p>
<pre><code>cout &lt;&lt; unitbuf &lt;&lt; “first” &lt;&lt; “ second” &lt;&lt; nounitbuf;   
</code></pre><p>等价于：</p>
<pre><code>cout &lt;&lt; “first” &lt;&lt; flush &lt;&lt; “second” &lt;&lt; flush;
</code></pre><p>nounitbuf操纵符将流恢复为使用正常的、由系统管理的缓冲区刷新方式。</p>
<hr>
<p>如果程序不正常结束，输出缓冲区将不会刷新。在尝试调试已崩溃的程序时，通常会根据最后的输出找出程序发生错误的区域。如果崩溃出现在某个特定的输出语句后面，则可知是在程序的这个位置之后出错。</p>
<p>调试程序时，必须保证期待写入的每个输出都确实被刷新了。如果需要使用最后的输出给程序错误定位，则必须确定所有要输出地都已经输出。为了确保用户看到程序实际上处理的所有输出，最好的方法是保证所有的输出操作都显式地调用了flush或endl。如果仅因为缓冲区没有刷新，程序员将浪费大量的时间跟踪调试并没有执行的代码。基于这个原因，输出时应多使用endl而非‘\n’。</p>
<hr>
<p>当输入流与输出流绑在一起时，任何读输入流的尝试都将首先刷新其输出流关联的缓冲区。交互式系统通常应确保它们的输入和输出流失绑在一起的。这样做意味着可以保证任何输出，包括给用户的提示，都在试图读之前输出。</p>
<hr>
<p>打开文件后，通常要检验打开是否成功，这是一个好习惯。</p>
<pre><code>// check that the open succeeded
if (!infile){
    cerr &lt;&lt; “error: unable to open input file : ”
        &lt;&lt; ifile &lt;&lt; endl;
    return -1;
}
</code></pre><p>如果程序员需要重用文件流读写多个文件，必须在读另一个文件之前调用clear清楚该流的状态。</p>
<hr>
<p>C++提供了使用抽象进行高效率编程的方式。标准库就是一个很好的例子：标准库定义了许多容器类以及一系列泛型算法，使程序员可以更简洁、抽象和有效地编写程序。这样可以让标准库操心那些繁琐的细节，特别是内存管理，我们的程序只需关注要解决的实际问题就行了。泛型算法中，所谓“泛型(generic)”指的是两个方面：这些算法可作用于各种不同的容器类型，而这些容器又可以容纳多种不同类型的元素。</p>
<p>为容器类型提供通用接口是设计库的目的。容器提供的操作和算法是一致定义的，这使得学习标准库更容易：只需理解一个操作如何工作，就能将该操作应用于其他的容器。更重要的是，接口的一致性使程序变得更灵活。</p>
<hr>
<p>标准库定义了三种顺序容器类型：vector（支持快速随机访问）、list（支持快速插入、删除）和deque（是双端队列“double-ended queue”的简写，发音为 “deck”）。它们的差别在于访问元素的方式，以及添加或删除元素相关操作的运行代价。标准库还提供了三种容器适配器（adaptor）。实际上，适配器是根据原始的容器类型所提供的操作，通过定义新的操作接口，来适应基础的容器类型。顺序容器适配器包括stack（后进先出LIFO栈）、queue（先进先出FIFO）和priority_queue类型（有优先级管理的队列）。容器只定义了少量操作。大多数额外操作则由算法库提供。标准库为由容器类型定义的操作加强了公共的接口。</p>
<hr>
<p>为了定义一个容器类型的对象，必须先包含相关的头文件<vector><list><deque>所有的容器都是类模板。要定义某种特殊的容器，必须在容器名后加一对尖括号，尖括号里面提供容器中存放的元素的类型。所有的容器类型都定义了默认构造函数，用于创建指定类型的空容器对象。为了使程序更清晰、简短，容器类型最常用的构造函数是默认构造函数。在大多数的程序中，使用默认构造函数能达到最佳运行时性能，并且使容器更容易使用。</deque></list></vector></p>
<hr>
<p>将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同。尽管不能将一种容器内的元素复制给另一种容器，但系统允许通过传递一对迭代器间接实现该功能。使用迭代器时，不要求容器类型相同。容器内的元素类型也可以不相同，只要他们相互兼容，能够将要复制的元素转换为所构建的新容器的元素类型，即可实现复制。</p>
<hr>
<p>创建顺序容器时，可显式指定容器大小和一个（可选的）元素初始化式。容器大小可以使常量或非常量表达式，元素初始化式则必须是可用于初始化其元素类型的对象的值。接受容器大小做形参的构造函数只适用于顺序容器，而关联容器不支持这种初始化。</p>
<hr>
<p>C++语言中，大多数类型都可用作容器的元素类型。容器元素类型必须满足以下两个约束：元素类型必须支持赋值运算；元素类型的对象必须可以复制。</p>
<hr>
<p>因为容器受容器元素类型的约束，所以可定义元素是容器类型的容器。例如</p>
<pre><code>vector&lt; vector&lt;string&gt; &gt; lines;     // vector of vectors
</code></pre><p>必须用空格隔开两个相邻的 &gt; 符号，以示这是两个分开的符号，否则，系统会认为&gt;&gt;是单个符号，为右移操作符，并结果导致编译时错误。</p>
<hr>
<p>在整个标准库中，经常使用形参为一对迭代器的构造函数。关系操作符只适用于vector和deque容器，这是因为只有这两种容器为其元素提供快速、随机的访问。它们确保可根据元素位置直接有效地访问指定的容器元素。</p>
<hr>
<p>迭代器范围这个概念是标准库的基础。C++语言使用一对迭代器标记迭代器范围（iterator range），这两个迭代器分别指向同一个容器中的两个元素或超出末端的下一位置，通常将它们命名为first和last，或beg和end，用于标记容器中的一段元素范围。称为左闭合区间（left-inclusive interval），其标准方式为：</p>
<pre><code>// to be read as: includes first and each element up to but not including last
[ first, last )
</code></pre><p>当first与last相等时，迭代器范围为空；</p>
<p>当first与last不相等时，迭代器范围内至少有一个元素，而且first指向该区间中的第一个元素。</p>
<hr>
<p>修改容器的内在状态或移动容器内的元素等操作使所有指向呗移动的元素的迭代器时效，也可能同时使其他迭代器失效。使用无效迭代器时没有定义的，可能会导致与悬垂指针相同的问题。使用迭代器编写程序时，必须留意那些操作会使迭代器失效。使用无效迭代器将会导致严重的运行时错误。</p>
<hr>
<p>使用迭代器时，通常可以编写程序使得要求迭代器有效地代码发内相对较短。然后，在该范围内，严格检查每一条语句，判断是否有元素添加或删除，从而相应地调整迭代器的值。</p>
<hr>
<p>除了push_back运算，list和deque容器类型还提供了类似的操作：push_front。这个操作实现再容器首部插入新元素的功能。</p>
<hr>
<p>再容器中添加元素时，系统是将元素值复制到容器里。类似地，使用一段元素初始化新容器时，新荣期存放的是原始元素的副本。被复制的原始值与新荣期中的元素各不相关，此后，容器内元素值发生变化时，被复制的原值不会收到影响，反之亦然。</p>
<hr>
<p>insert曹走提供了一组更通用的插入方法，实现在容器的任意指定位置插入新元素。</p>
<p>c.insert(p,t) 在迭代器p所指向的元素前面插入值为t的新元素。返回指向新添加元素的迭代器</p>
<p>c.insert(p,n,t) 在迭代器p所指向的元素前面插入n个值为t的新元素。返回void类型</p>
<p>c.insert(p,b,e) 在迭代器p所指向的元素前面插入由迭代器b和e标记的范围内的元素。返回void类型</p>
<hr>
<p>任何insert或push操作都可能导致迭代器失效。当编写循环将元素插入到vector或deque容器中时，程序必须确保迭代器在每次循环后都得到更新。</p>
<hr>
<p>在vector或deque容器中添加元素时，可能会导致某些或全部迭代器失效。假设所有迭代器失效是最安全的做法。这个建议特别适用于由end操作返回的迭代器。在容器的任何位置插入任何元素都会使该迭代器失效。为了避免存储end迭代器，可以在每次做完插入运算后重新计算。</p>
<pre><code>// safer:recalculate end on each trip whenever the loop adds/erases elements
while (first != v.end()){
      // do some processing
      first = v.insert(first, 42); // insert new value
      ++first; // advance first just past the element we added
}
</code></pre><hr>
<p>所有的容器类型都支持用关系操作符来实现两个容器的比较。比较的容器必须具有相同的容器类型，而且其元素类型也必须相同。</p>
<p>如果两个容器具有相同的长度而且所有元素都相等，那么这两个容器就相等；否则，它们就不相等。</p>
<p>如果两个容器的长度不相同，但较短的容器中所有元素都等于较长容器中对应的元素，则称较短的容器小于另一个容器。</p>
<p>如果两个容器都不是对方的初始子序列，则它们的比较结果取决于所比较的第一个不相等的元素。</p>
<hr>
<p>顺序容器大小的操作</p>
<pre><code>c.max_size()      返回容器c可容纳的最多元素个数，返回类型为c::size_type
c.resize(n)          调整容器c的长度大小，使其能容纳n个元素，如果n&lt;c.size()，则删除多出来的元素；否则，添加采用值初始化的新元素
c.resize(n,t)        调整容器c的大小，使其能容纳n个元素。所有新添加的元素值都为t
</code></pre><hr>
<p>resize操作可能会使迭代器失效。在vector或deque容器上做resize操作有可能会使所有的迭代器都失效。对于所有的容器类型，如果resize操作压缩了容器，则指向已删除的元素的迭代器失效。</p>
<hr>
<p>如果容器非空，那么容器类型的front和back成员将返回容器内第一个或最后一个元素的引用。使用越界的下标，或调用空容器的front或back函数，都会导致程序出现严重的错误。使用下标运算的另一个可选方案是at成员函数。这个函数的行为和下标运算相似，但是如果给出的下标无效，at函数将会抛出out_of_range异常。</p>
<hr>
<p>容器类型提供了通用的insert操作在容器的任何位置插入元素，并支持特定的push_front和push_back操作在容器首部或尾部插入新元素。类似地，容器类型提供了通用的erase操作和特定的pop_front和pop_back操作来删除容器内的元素。</p>
<pre><code>c.erase( k )            
</code></pre><p>删除迭代器 k 所指向的元素。返回一个迭代器，它指向被删除元素后面的元素，若 k 指向容器容器内的最后一个元素，则返回的迭代器指向容器的超出末端的下一位置。如果 k 本身就是指向超出末端的下一位置的迭代器，则该函数未定义。</p>
<pre><code>c.erase( b,e )         
</code></pre><p>删除迭代器 b 和 e 所标记的范围内所有的元素。返回一个迭代器，它指向被删除元素段后面的元素。如果 e 本身就是指向超出末端的下一位置的迭代器，那么返回的迭代器也指向容器超出末端的下一位置。</p>
<pre><code>c.clear()                 
</code></pre><p>删除容器 c 内的所有元素。返回void</p>
<pre><code>c.pop_back()         
</code></pre><p>删除容器 c 的最后一个元素。返回void。如果 c 为空容器，则该函数未定义。</p>
<pre><code>c.pop_front()          
</code></pre><p>删除容器 c 的第一个元素。返回void。如果 c 为空容器，则该函数未定义。</p>
<p>以上两个只能用于list或deque容器</p>
<hr>
<p>pop_front操作通常与front操作配套使用，实现以桟的方式处理容器：</p>
<pre><code>while (!ilist.empty()) {
    process(ilist.front());      // do something with the current top of ilist
    ilist.pop_front();       // done;remove first element
}
</code></pre><p>这个循环非常简单：使用front操作获取要处理的元素，然后调用pop_front函数从容器list中删除该元素。pop_front和pop_back函数的返回值并不是删除的元素的值，而是void。要获取删除的元素值，则必须在删除元素之前调用front或back函数。</p>
<hr>
<p>删除一个或一段元素更通用的方法是erase操作。如同其他操作一样，erase操作也不会检查它的参数。必须确保迭代器是有效的。</p>
<hr>
<p>赋值和 assign 操作使得作操作数容器的所有迭代器失效。swap 操作则不会使迭代器失效。完成 swap 后，尽管被交换的元素已经存放在另一容器中，但迭代器仍然指向相同的元素。</p>
<hr>
<p>顺序容器的赋值操作</p>
<pre><code>c1 ＝ c2            删除容器 c1 的所有元素，然后将 c2 的元素复制给 c1。c1 和 c2 的类型（包括容器类型和元素类型）必须相同。
c1.swap(c2)      交换内容：调用完该函数后，c1 中存放的是 c2 原来的元素，c2中存放的则是 c1原来的元素。c1 和 c2 的类型必须相同。该函数的执行速度通常要比将 c2 的元素复制到 c1 的操作快。
c.assign(b,e)     重新设置 c 中的元素：将迭代器 b 和 e 标记的范围内所有的元素复制到 c 中。b 和 e 必须不是指向 c 中元素的迭代器。
c.assign(n,t)      将容器 c 重新设置为存储 n 各值为 t 的元素
</code></pre><hr>
<p>是用 swap 操作以节省删除元素的成本，并且迭代器不会失效，原来指向哪里，现在还是指向哪里。</p>
<hr>
<p>在容器对象中 insert 或压入一个元素时，该对象的大小增加 1。类似地，如果 resize 容器以扩充其容量，则必须在容器中添加额外的元素。比起 list 和 deque 容器，vector 的增长效率通常会更高。会为 vector 预留额外的存储区。</p>
<hr>
<p>capacity 操作获取在容器需要分配更多的存储空间之前能够存储的元素总数，而 reserve 操作则告诉 vector 容器应该预留多少个元素的存储空间。size 指容器当前拥有的元素个数。每当 vector 容器不得不分配新的存储空间时，以加倍当前容量分配策略实现重新分配。vector 的每种实现都可自由地选择自己的内存分配策略。然后，它们都必须提供 reserve 和 capacity 函数，而且必须时到必要时才分配新的内存空间。分配多少内存取决于其实现方式。不同的库采用不同的策略实现。此外，每种实现都要求遵循以下原则：确保 <code>push_back</code> 操作高效地在 vector 中添加元素。从技术上说，在原来为空的 vector 容器上 n 次调用 <code>push_back</code> 函数，从而创建拥有 n 个元素的 vector 容器，其执行时间永远不能超过 n 的常量倍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里是我学习《Thinking in C++》时记录整理的笔记，时间比较久远，不保证时效性。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://wdxtub.com/tags/Cpp/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenMP 入门指南]]></title>
    <link href="http://wdxtub.com/2016/03/20/openmp-guide/"/>
    <id>http://wdxtub.com/2016/03/20/openmp-guide/</id>
    <published>2016-03-20T11:58:43.000Z</published>
    <updated>2016-03-20T13:45:52.000Z</updated>
    <content type="html"><![CDATA[<p>简单的 OpenMP 快速入门指南。<a href="http://blog.csdn.net/donhao" target="_blank" rel="external">主要来源</a></p>
<a id="more"></a>
<hr>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><p>这门课作为 ECE 中少有的跟计算机科学相关的课，自然是必上不可。不过无论是 OpenMP 还是 CUDA，对于平时极少接触并行编程的我来说，都是十分吃力的，第一次作业的 OpenMP 编程已经让意识到了个中的差别，当然，在单个核心的计算速度基本达到极致的现在，掌握并行编程可以算是程序员的基本素养，而 OpenMP 其实是一个非常好的开始，简单，易懂，见效飞快。所以我们的旅程，就从这里开始吧。</p>
<h2 id="Hello_OpenMP"><a href="#Hello_OpenMP" class="headerlink" title="Hello OpenMP"></a>Hello OpenMP</h2><p>OpenMP是一种面向共享内存以及分布式共享内存的多处理器多线程并行编程语言。一段简单的代码如下：</p>
<pre><code>#include &lt;omp.h&gt;
#include &lt;iostream&gt;
using namespace std;

int main(){
    #pragma omp parallel for 
    for (int i = 0; i &lt; 10; ++i)
    {
        cout &lt;&lt; i;
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre><p>通过#pragma omp预处理指示符指定要采用OpenMP</p>
<p>通过#pragma omp parallel for来指定下方的for循环采用多线程执行，此时编译器会根据CPU的个数来创建线程数，对于双核系统，编译器会默认创建两个线程执行并行区域的代码。</p>
<p>这段程序的输入如下（省略前面的终端信息）</p>
<pre><code>dawang$ ./a.out
3680479152
dawang$ ./a.out
8603971425
dawang$ ./a.out
3086419752
dawang$ ./a.out
6038714925
</code></pre><h3 id="u5E38_u7528_u7684_u5E93_u51FD_u6570"><a href="#u5E38_u7528_u7684_u5E93_u51FD_u6570" class="headerlink" title="常用的库函数"></a>常用的库函数</h3><p>函数原型 / 功能</p>
<pre><code>返回当前可用的处理器个数
int omp_get_num_procs(void) 

返回当前并行区域中的活动线程个数，如果在并行区域外部调用，返回1
int omp_get_num_threads(void)

返回当前的线程号（个人感觉这里为omp_get_thread_ID好一些）
int omp_get_thread_num(void) 

设置进入并行区域时，将要创建的线程个数
int omp_set_num_threads(void)
</code></pre><p>下面的这个例子演示了四个库函数</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;omp.h&gt;
using namespace std;

int main(){
    cout &lt;&lt; &quot;CPU number: &quot; &lt;&lt; omp_get_num_procs() &lt;&lt; endl;

    cout &lt;&lt; &quot;Parallel area 1: &quot; &lt;&lt; endl;

    #pragma omp parallel //下面大括号内部为并行区域
    {
        cout &lt;&lt; &quot;Num of threads is: &quot; &lt;&lt; omp_get_num_threads();
        cout &lt;&lt; &quot;; This thread ID is &quot; &lt;&lt; omp_get_thread_num() &lt;&lt; endl;
    }

    cout &lt;&lt; &quot;Parallel area 2:&quot; &lt;&lt; endl;
    omp_set_num_threads(4); // 设置为并行区域创建4个线程
    #pragma omp parallel //下面大括号内部为并行区域
    {
        cout &lt;&lt; &quot;Num of threads is: &quot; &lt;&lt; omp_get_num_threads();
        cout &lt;&lt; &quot;; This thread ID is &quot; &lt;&lt; omp_get_thread_num() &lt;&lt; endl;
    }

    return 0;
}
</code></pre><p>大家可以自己运行一次看看自己的输出</p>
<h2 id="u6570_u636E_u76F8_u5173_u6027"><a href="#u6570_u636E_u76F8_u5173_u6027" class="headerlink" title="数据相关性"></a>数据相关性</h2><p>在循环并行化时，由于多个线程同时执行循环，迭代的顺序是不确定的。如果是数据不相关的，则可以采用基本的#pragma omp parallel for预处理器指示符。</p>
<p>如果语句S2与语句S1相关，那么必然存在以下两种情况之一：</p>
<ol>
<li>语句S1在一次迭代中访问存储单元L，而S2在随后的一次迭代中访问统一存储单元，称之为循环迭代相关（Loop-Carried Dependence）；</li>
<li>S1和S2在同一循环迭代中访问统一存储单元L，但S1的执行在S2之前，称之为非循环迭代相关（Loop-Independent Dependence）。</li>
</ol>
<h3 id="for__u5FAA_u73AF_u5E76_u884C_u5316_u7684_u58F0_u660E_u5F62_u5F0F"><a href="#for__u5FAA_u73AF_u5E76_u884C_u5316_u7684_u58F0_u660E_u5F62_u5F0F" class="headerlink" title="for 循环并行化的声明形式"></a>for 循环并行化的声明形式</h3><pre><code>#include &lt;iostream&gt;
#include &lt;omp.h&gt;
using namespace std;

int main(){
    // for 循环并行化声明形式1
    #pragma omp parallel
    {
        #pragma omp for
        for (int i = 0; i &lt; 10; ++i){
            cout &lt;&lt; i &lt;&lt; endl;
        }
    }

    // for 循环并行化声明形式2
    #pragma omp parallel for
    for (int j = 0; j &lt; 10; ++j){
        cout &lt;&lt; j &lt;&lt; endl;
    }
    return 0;
}
</code></pre><p>上边代码的两种声明形式是一样的，很显然第二种声明形式更为简洁紧凑。但是第一种声明形式有一个好处，即可以在并行区域内、for循环以外写其他并行代码。</p>
<h3 id="for__u5FAA_u73AF_u5E76_u884C_u5316_u7684_u7EA6_u675F_u6761_u4EF6"><a href="#for__u5FAA_u73AF_u5E76_u884C_u5316_u7684_u7EA6_u675F_u6761_u4EF6" class="headerlink" title="for 循环并行化的约束条件"></a>for 循环并行化的约束条件</h3><p>尽管OpenMP可以方便地对for循环进行并行化，但并不是所有的for循环都可以进行并行化。以下几种情况不能进行并行化：</p>
<ol>
<li>for循环中的循环变量必须是有符号整形。例如，for (unsigned int i = 0; i &lt; 10; ++i){}会编译不通过；</li>
<li>for循环中比较操作符必须是&lt;, &lt;=, &gt;, &gt;=。例如for (int i = 0; i != 10; ++i){}会编译不通过；</li>
<li>for循环中的第三个表达式，必须是整数的加减，并且加减的值必须是一个循环不变量。例如for (int i = 0; i != 10; i = i + 1){}会编译不通过；感觉只能++i; i++; –i; 或i–；</li>
<li>如果for循环中的比较操作为&lt;或&lt;=，那么循环变量只能增加；反之亦然。例如for (int i = 0; i != 10; –i)会编译不通过；</li>
<li>循环必须是单入口、单出口，也就是说循环内部不允许能够达到循环以外的跳转语句，exit除外。异常的处理也必须在循环体内处理。例如：若循环体内的break或goto会跳转到循环体外，那么会编译不通过。</li>
</ol>
<h3 id="u57FA_u672C_for__u5FAA_u73AF_u5E76_u884C_u5316_u4E3E_u4F8B"><a href="#u57FA_u672C_for__u5FAA_u73AF_u5E76_u884C_u5316_u4E3E_u4F8B" class="headerlink" title="基本 for 循环并行化举例"></a>基本 for 循环并行化举例</h3><pre><code>#include &lt;iostream&gt;
#include &lt;omp.h&gt;

int main(){
    int a[10] = {1};
    int b[10] = {2};
    int c[10] = {0};

    #pragma omp parallel
    {
        #pragma omp for
        for (int i = 0; i &lt; 10; ++i){
            // c[i] 只跟 a[i] 和 b[i] 有关
            c[i] = a[i] + b[i];
        }
    }

    return 0;
}
</code></pre><h3 id="u5D4C_u5957_for__u5FAA_u73AF_u5E76_u884C_u5316_u4E3E_u4F8B"><a href="#u5D4C_u5957_for__u5FAA_u73AF_u5E76_u884C_u5316_u4E3E_u4F8B" class="headerlink" title="嵌套 for 循环并行化举例"></a>嵌套 for 循环并行化举例</h3><pre><code>#include &lt;omp.h&gt;

int main(){
    int a[10][5] = {1};
    int b[10][5] = {2};
    int c[10][5] = {3};

    #pragma omp parallel
    {
        #pragma omp for
        for (int i = 0; i &lt; 10; ++i){
            for (int j = 0; j &lt; 5; ++j){
                // c[i][j] 只跟 a[i][j] 和 b[i][j] 有关
                c[i][j] = a[i][j] + b[i][j];
            }
        }
    }

    return 0;
}
</code></pre><p>对于双核 CPU 来说，编译器会让第一个cpu完成：</p>
<pre><code>for (int i = 0; i &lt; 5; ++i){
    for (int j = 0; j &lt; 5; ++j){
        // c[i][j] 只跟 a[i][j] 和 b[i][j] 有关
        c[i][j] = a[i][j] + b[i][j];
    }
}
</code></pre><p>会让第二个 cpu 完成：</p>
<pre><code>for (int i = 5; i &lt; 10; ++i){
    for (int j = 0; j &lt; 5; ++j){
        // c[i][j] 只跟 a[i][j] 和 b[i][j] 有关
        c[i][j] = a[i][j] + b[i][j];
    }
}
</code></pre><h2 id="u6570_u636E_u7684_u5171_u4EAB_u4E0E_u79C1_u6709_u5316"><a href="#u6570_u636E_u7684_u5171_u4EAB_u4E0E_u79C1_u6709_u5316" class="headerlink" title="数据的共享与私有化"></a>数据的共享与私有化</h2><p>在并行区域中，若多个线程共同访问同一存储单元，并且至少会有一个线程更新数据单元中的内容时，会发送数据竞争。本节的数据共享与私有化对数据竞争做一个初步的探讨，后续会在同步、互斥相关章节中进行进一步描述。</p>
<p>除了以下三种情况外，并行区域中的所有变量都是共享的：</p>
<ol>
<li>并行区域中定义的变量</li>
<li>多个线程用来完成循环的循环变量</li>
<li>private、firstprivate、lastprivate或reduction字句修饰的变量</li>
</ol>
<p>例如：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;omp.h&gt;
using namespace std;

int main(){
    int share_a = 0; // 共享变量
    int share_to_private_b = 1; // 通过 private 子句修饰该变量之后在并行区域内变为私有变量

    #pragma omp parallel
    {
        int private_c = 2;

        #pragma omp for private(share_to_private_b)
        for (int i = 0; i &lt; 10; ++i) //该循环变量是私有的，若为两个线程，则一个线程执行0~4，另一个执行5~9
            cout &lt;&lt; i &lt;&lt; endl;

    }

    return 0;
}
</code></pre><p>声明方法 / 功能</p>
<pre><code>并行区域中变量val是私有的，即每个线程拥有该变量的一个拷贝
private(val1, val2, ...)

与private不同的是，每个线程在开始的时候都会对该变量进行一次初始化。
first_private(val1, val2, ...)      

与private不同的是，并发执行的最后一次循环的私有变量将会拷贝到val
last_private(val1, val2, ...)      

声明val是共享的
shared(val1, val2, ...)              
</code></pre><p>如果使用private，无论该变量在并行区域外是否初始化，在进入并行区域后，该变量均不会初始化。</p>
<h2 id="Reduction__u7684_u7528_u6CD5"><a href="#Reduction__u7684_u7528_u6CD5" class="headerlink" title="Reduction 的用法"></a>Reduction 的用法</h2><p>直接上例子</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;
using namespace std;

int main(){
    int sum = 0;
    cout &lt;&lt; &quot;Before: &quot; &lt;&lt; sum &lt;&lt; endl;

    #pragma omp parallel for reduction(+:sum)
    for (int i = 0; i &lt; 10; ++i){
        sum = sum + i;
        printf(&quot;%d\n&quot;, sum);
    }

    cout &lt;&lt; &quot;After: &quot; &lt;&lt; sum &lt;&lt; endl;

    return 0;
}
</code></pre><p>其中sum是共享的，采用reduction之后，每个线程根据reduction（+: sum）的声明算出自己的sum，然后再将每个线程的sum加起来。</p>
<p>reduction声明可以看作：</p>
<ol>
<li>保证了对sum的原则操作</li>
<li>多个线程的执行结果通过reduction中声明的操作符进行计算，以加法操作符为例：</li>
</ol>
<p>假设sum的初始值为10，reduction（+: sum）声明的并行区域中每个线程的sum初始值为0（规定），并行处理结束之后，会将sum的初始化值10以及每个线程所计算的sum值相加。</p>
<p>我们在上边已经了解了reduction的声明形式，其具体如下：</p>
<p>reduction (operator: var1, val2, …)</p>
<p>其中operator以及约定变量的初始值如下：</p>
<pre><code>运算符            数据类型            默认初始值
  +              整数、浮点             0
  -              整数、浮点             0
  *              整数、浮点             1
  &amp;                整数             所有位均为1
  |                整数                0
  ^                整数                0
  &amp;&amp;               整数                1
  ||               整数                0
</code></pre><h2 id="u7EBF_u7A0B_u540C_u6B65_u4E4B_atomic"><a href="#u7EBF_u7A0B_u540C_u6B65_u4E4B_atomic" class="headerlink" title="线程同步之 atomic"></a>线程同步之 atomic</h2><p>在OpenMP中，线程同步机制包括互斥锁同步机制和事件同步机制。互斥锁同步的概念类似于Windows中的临界区（CriticalSection）以及Windows和Linux中的Mutex，以及VxWorks中的SemTake何SemGive（初始化时信号量为满），即对某一块代码操作进行保护，以保证同时只能有一个线程执行该段代码。</p>
<h3 id="atomic_uFF08_u539F_u5B50_uFF09_u64CD_u4F5C_u8BED_u6CD5"><a href="#atomic_uFF08_u539F_u5B50_uFF09_u64CD_u4F5C_u8BED_u6CD5" class="headerlink" title="atomic（原子）操作语法"></a>atomic（原子）操作语法</h3><pre><code>#pragma omp atomic
x&lt; + or * or - or * or / or &amp; or | or &lt;&lt; or &gt;&gt; &gt;=expr
(例如x &lt;&lt;= 1; or x *=2;)
</code></pre><p>或</p>
<pre><code>#pragma omp atomic
x++ //or x--, --x, ++x
</code></pre><p>可以看到atomic的操作仅适用于两种情况：</p>
<ol>
<li>自加减操作</li>
<li>x&lt;上述列出的操作符&gt;=expr</li>
</ol>
<p>例如</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;omp.h&gt;
using namespace std;

int main(){
    int sum = 0;
    cout &lt;&lt; &quot;Before: &quot; &lt;&lt; sum &lt;&lt; endl;

    #pragma omp parallel for
    for (int i = 0; i &lt; 20000; ++i){
        #pragma omp atomic
        sum++;
    }
    cout &lt;&lt; &quot;Atomic-After: &quot; &lt;&lt; sum &lt;&lt; endl;

    sum = 0;
    #pragma omp parallel for
    for (int i = 0; i &lt; 20000; ++i){
        sum++;
    }
    cout &lt;&lt; &quot;None-atomic-After: &quot; &lt;&lt; sum &lt;&lt; endl;
    return 0;
}
</code></pre><p>输出20000。如果将#pragma omp atomic声明去掉，则输出值不确定。</p>
<h2 id="u7EBF_u7A0B_u540C_u6B65_u4E4B_critical"><a href="#u7EBF_u7A0B_u540C_u6B65_u4E4B_critical" class="headerlink" title="线程同步之 critical"></a>线程同步之 critical</h2><p>这里的临界区与Windows下的CriticalSection类似。<br>临界区声明方法</p>
<pre><code>#pragma omp critical [(name)] //[]表示名字可选
{
//并行程序块，同时只能有一个线程能访问该并行程序块
}
</code></pre><p>例如</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;omp.h&gt;
using namespace std;

int main(){
    int sum = 0;
    cout &lt;&lt; &quot;Before: &quot; &lt;&lt; sum &lt;&lt; endl;

    #pragma omp parallel for
    for (int i = 0; i &lt; 100; ++i){
        #pragma omp critical(a)
        {
            sum = sum + i;
            sum = sum + i * 2;
        }
    }

    cout &lt;&lt; &quot;After: &quot; &lt;&lt; sum &lt;&lt; endl;

    return 0;
}
</code></pre><p>critical 与 atomic 的区别在于，atomic 仅适用于上一节规定的两种类型操作，而且 atomic 所防护的仅为一句代码。critical 可以对某个并行程序块进行防护。</p>
<p>For a simple increment to a shared variable, atomic and critical are semantically equivalent, but atomic allows the compiler more opportunities for optimisation (using hardware instructions, for example). </p>
<p>In other cases, there are differences. If incrementing array elements (e.g. a[i]++ ), atomic allows different threads to update different elements of the array concurrently whereas critical does not. If there is a more complicated expression on the RHS (e.g. a+=foo() ) then the evaluation of foo() is protected from concurrent execution with critical but not with atomic. </p>
<p>Using a critical section is a legitimate way of implementing atomics inside the compiler/runtime, but most current OpenMP compilers do a better job than this. </p>
<h2 id="u7EBF_u7A0B_u540C_u6B65_u4E4B_u4E8B_u4EF6_u540C_u6B65_u673A_u5236"><a href="#u7EBF_u7A0B_u540C_u6B65_u4E4B_u4E8B_u4EF6_u540C_u6B65_u673A_u5236" class="headerlink" title="线程同步之事件同步机制"></a>线程同步之事件同步机制</h2><p>互斥锁同步包括atomic、critical、mutex函数，其机制与普通多线程同步的机制类似。而事件同步则通过nowait、sections、single、master等预处理器指示符声明来完成。</p>
<h3 id="u9690_u5F0F_u6805_u969C"><a href="#u9690_u5F0F_u6805_u969C" class="headerlink" title="隐式栅障"></a>隐式栅障</h3><p>barrier为隐式栅障，即并行区域中所有线程执行完毕之后，主线程才继续执行。</p>
<h3 id="nowait__u7528_u6765_u53D6_u6D88_u6805_u969C"><a href="#nowait__u7528_u6765_u53D6_u6D88_u6805_u969C" class="headerlink" title="nowait 用来取消栅障"></a>nowait 用来取消栅障</h3><p>其用法如下：</p>
<pre><code>#pragma omp for nowait //不能用#pragma omp parallel for nowait
或
#pragma omp single nowait
</code></pre><p>例如</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main(){
    #pragma omp parallel
    {
        #pragma omp for nowait
        for (int i = 0; i &lt; 1000; ++i){
            printf(&quot;%d+\n&quot;, i);
        }

        #pragma omp for
        for (int j = 0; j &lt; 10; ++j){
            printf(&quot;%d-\n&quot;, j);
        }
    }
    return 0;
}
</code></pre><p>第一个 for 循环的两个线程中的一个执行完之后，继续往下执行，因此同时打印出了第一个循环的 + 和第一个循环的 - 。</p>
<p>可以看到，第二个 for 循环的两个线程都执行完之后，才开始同时执行第三个 for 循环，并没有交叉。也就是说，通过 #pragma omp for 声明的 for 循环结束时有一个默认的栅障。</p>
<h3 id="u663E_u5F0F_u540C_u6B65_u6805_u969C__23pragma_omp_barrier"><a href="#u663E_u5F0F_u540C_u6B65_u6805_u969C__23pragma_omp_barrier" class="headerlink" title="显式同步栅障 #pragma omp barrier"></a>显式同步栅障 #pragma omp barrier</h3><pre><code>#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main(){
    #pragma omp parallel
    {
        for (int i = 0; i &lt; 100; ++i){
        printf(&quot;%d+\n&quot;, i);
        }
        #pragma omp barrier
        for (int j = 0; j &lt; 10; ++j){
            printf(&quot;%d-\n&quot;, j);
        }
    }    
}
</code></pre><p>两个线程(具体数目不同 CPU 不同)执行了第一个for循环，当两个线程同时执行完第一个for循环之后，在barrier处进行了同步，然后执行后边的for循环。</p>
<h3 id="master__u901A_u8FC7_23pragma_omp_mater_u6765_u58F0_u660E_u5BF9_u5E94_u7684_u5E76_u884C_u7A0B_u5E8F_u5757_u53EA_u7531_u4E3B_u7EBF_u7A0B_u5B8C_u6210_u3002"><a href="#master__u901A_u8FC7_23pragma_omp_mater_u6765_u58F0_u660E_u5BF9_u5E94_u7684_u5E76_u884C_u7A0B_u5E8F_u5757_u53EA_u7531_u4E3B_u7EBF_u7A0B_u5B8C_u6210_u3002" class="headerlink" title="master 通过#pragma omp mater来声明对应的并行程序块只由主线程完成。"></a>master 通过#pragma omp mater来声明对应的并行程序块只由主线程完成。</h3><pre><code>#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main(){
    #pragma omp parallel
    {
        #pragma omp master
        {
            for (int j = 0; j &lt; 10; ++j){
                printf(&quot;%d-\n&quot;, j);
            }
        }

        printf(&quot;This will be shown two or more times\n&quot;);
    }
    return 0;
}
</code></pre><p>进入 parallel 声明的并行区域之后，创建了两个(或更多)线程，主线程执行了 for 循环，而另一个线程没有执行 for 循环，而直接进入了 for 循环之后的打印语句，然后执行 for 循环的线程随后还会再执行一次后边的打印语句。</p>
<h3 id="section__u7528_u6765_u6307_u5B9A_u4E0D_u540C_u7684_u7EBF_u7A0B_u6267_u884C_u4E0D_u540C_u7684_u90E8_u5206"><a href="#section__u7528_u6765_u6307_u5B9A_u4E0D_u540C_u7684_u7EBF_u7A0B_u6267_u884C_u4E0D_u540C_u7684_u90E8_u5206" class="headerlink" title="section 用来指定不同的线程执行不同的部分"></a>section 用来指定不同的线程执行不同的部分</h3><p>通过一个示例说明其使用方法：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main(){
    #pragma omp parallel sections // 声明该区域分为若干个 section, section 之间的运行顺序为并行的关系
    {
        #pragma omp section // 第一个 section, 由某个线程单独完成
        for (int i = 0; i &lt; 5; ++i){
            printf(&quot;%d+\n&quot;, i);
        }

        #pragma omp section // 另一个 section, 由某个线程单独完成
        for (int j = 0; j &lt; 5; ++j){
            printf(&quot;%d-\n&quot;, j);
        }
    }
    return 0;
}
</code></pre><p>因为并行区域中有两个线程，所以两个section同时执行。</p>
<h2 id="u7EBF_u7A0B_u7684_u8C03_u5EA6_u4F18_u5316"><a href="#u7EBF_u7A0B_u7684_u8C03_u5EA6_u4F18_u5316" class="headerlink" title="线程的调度优化"></a>线程的调度优化</h2><p>通过前边的介绍，知道了并行区域，默认情况下会自动生成与CPU个数相等的线程，然后并行执行并行区域中的代码，对于并行区域中的for循环，有特殊的声明方式，这样不同的线程可以分别运行for循环变量的不同部分。通过锁同步（atomic、critical、mutex函数）或事件同步（nowait、signal、section、master）来实现并行区域的同步控制。</p>
<p>具体的调度策略均由底层完成，本节介绍几种可以在上层对for循环进行控制的调度策略。</p>
<p>determines which iterations are executed by each thread</p>
<ul>
<li>STATIC<ul>
<li>The iteration space is broken in chunks of approximately size N/(num of threads). Then these chunks are assigned to the threads in a Round-Robin fashion.    </li>
</ul>
</li>
<li>STATIC, CHUNK<ul>
<li>The iteration space is broken in chunks of size N. Then these chunks are assigned to the threads in a Round-Robin fashion.</li>
</ul>
</li>
<li>Characteristics of static schedules<ul>
<li>Low overhead</li>
<li>Good locality (usually)</li>
<li>Can have load imbalance problems</li>
</ul>
</li>
<li>DYNAMIC[,chunk]<ul>
<li>Threads dynamically grab chunks of N iterations until all iterations have been executed. If no chunk is specified, N = 1</li>
</ul>
</li>
<li>GUIDED[,chunk]<ul>
<li>Variant of dynamic. The size of the chunks deceases as the threads grab iterations, but it is at least of size N. If no chunk is specified, N = 1.</li>
</ul>
</li>
<li>Characteristics of static schedules<ul>
<li>Higher overhead</li>
<li>Not very good locality (usually)</li>
<li>Can solve imbalance problems</li>
</ul>
</li>
<li>AUTO<ul>
<li>The implementation is allowed to do whatever it wishes. (Do not expect much of it as of now)</li>
</ul>
</li>
<li>RUNTIME<ul>
<li>The decision is delayed until the program is run through the sched-nvar ICV. It can be set with:</li>
<li>The <code>OMP_SCHEDULE</code> environment variable</li>
<li>The <code>omp_set_schedule()</code> API call</li>
</ul>
</li>
</ul>
<p>能看到这里，如果都跑过一遍的话，应该也就差不多了。上课过程中有啥想法再追加吧。我要去改代码了再见。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>简单的 OpenMP 快速入门指南。<a href="http://blog.csdn.net/donhao">主要来源</a></p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="OpenMP" scheme="http://wdxtub.com/tags/OpenMP/"/>
    
      <category term="整理" scheme="http://wdxtub.com/tags/%E6%95%B4%E7%90%86/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 19 课 Dynamic Memory Allocation - Advanced Concept]]></title>
    <link href="http://wdxtub.com/2016/03/19/csapp-19/"/>
    <id>http://wdxtub.com/2016/03/19/csapp-19/</id>
    <published>2016-03-19T21:32:34.000Z</published>
    <updated>2016-03-20T03:32:44.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们来看看关于内存分配的延伸话题，包括更加复杂的选择机制以及垃圾回收等相关内容。</p>
<a id="more"></a>
<hr>
<p>这节课主要介绍后面三种方法，都是用来记录未分配空间的，具体如下：</p>
<p><img src="/images/14584386982186.jpg" alt="Keeping Track of Free Blocks"></p>
<h2 id="u663E_u5F0F_free__u5217_u8868"><a href="#u663E_u5F0F_free__u5217_u8868" class="headerlink" title="显式 free 列表"></a>显式 free 列表</h2><p>主要的改动在于，只记录 free block，而不是所有的 block。因为是指针，所以不仅需要记录后一个也需要记录前一个；与此同时，仍然需要 boundary tag 来作为合并的辅助信息。具体的结构如下：</p>
<p><img src="/images/14584389197608.jpg" alt="Explicit Free Lists"></p>
<p>因为是指针，逻辑上是连续的，但实际上可以是无序的，如下图：</p>
<p><img src="/images/14584389533544.jpg" alt="Logically vs Physically"></p>
<p>分配空间的过程就是指针重新指向的过程：</p>
<p><img src="/images/14584389995555.jpg" alt="Allocating From Explicit Free Lists"></p>
<p>然后我们来看看，当释放空间的时候，具体要把刚释放的 block，放在列表中的哪个位置呢？有两种策略：后入先出或按照地址排序。</p>
<p><img src="/images/14584390706378.jpg" alt="Freeing With Explicit Free Lists"></p>
<p>接下来是 LIFO 策略的几个不同的情况，灰色表示已经分配的空间：</p>
<p>Case 1</p>
<p><img src="/images/14584391317448.jpg" alt="Case 1"></p>
<p>Case 2</p>
<p><img src="/images/14584391482644.jpg" alt="Case 2"></p>
<p>Case 3</p>
<p><img src="/images/14584391607445.jpg" alt="Case 3"></p>
<p>Case 4</p>
<p><img src="/images/14584391818093.jpg" alt="Case 4"></p>
<p>总结一下，与隐式列表相比</p>
<ul>
<li>因为只记录 free block，在内存几乎满的时候效率很高</li>
<li>因为需要切分 block 以及维护列表，所以稍微复杂一点</li>
<li>对于每个链接来说需要 2 个额外的 word 来记录前面一个 free block 和后面一个 free block</li>
</ul>
<h2 id="Segregated_free__u5217_u8868"><a href="#Segregated_free__u5217_u8868" class="headerlink" title="Segregated free 列表"></a>Segregated free 列表</h2><blockquote>
<p>Most common use of linked lists is in conjunction with segregated free lists. Keep multiple linked lists of different size classes, or possibly for different types of objects.</p>
</blockquote>
<p>也就是说，每个不同大小 block 会在不同的列表里，对于较小的 size，一般会有单独的列表，对于稍大的 size，列表的范围也会更大，如下图所示：</p>
<p><img src="/images/14584404151349.jpg" alt="Each size class of blocks has its own free list"></p>
<p>要分配一个大小为 n 的 block：</p>
<ul>
<li>搜索比 n 大的 free list 列表</li>
<li>如果找到了合适的，切分 block 并且把剩余的放到对应的列表中（可选）</li>
<li>如果没有合适的 block，找更大的 size</li>
<li>重复上述过程，直到找到为止</li>
</ul>
<p>如果确实找不到：</p>
<ul>
<li>向系统请求额外的堆内存（使用 <code>sbrk()</code>）</li>
<li>在新的内存中分配对应的空间</li>
<li>把剩余的空间放到最大 size 的列表中</li>
</ul>
<p>释放空间时：</p>
<ul>
<li>合并 block 并放到对应的列表中</li>
</ul>
<p>Seglist allocator 的优势：</p>
<ul>
<li>更高的吞吐量(log time for power-of-two size classes)</li>
<li>更好的内存利用率<ul>
<li>First-fit search of segregated free list approximates a best-fit search of entire heap</li>
<li>Extreme case: Giving each block its own size class is equivalent to best-fit</li>
</ul>
</li>
</ul>
<h2 id="u5783_u573E_u56DE_u6536"><a href="#u5783_u573E_u56DE_u6536" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>所谓垃圾回收，就是我们不再需要显式释放所申请内存空间了，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* p block is now garbage*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种机制在许多动态语言中都有实现：Python, Ruby, Java, Perl, ML, Lisp, Mathematica。C 和 C++ 中也有类似的变种，但是需要注意的是，是不可能回收所有的垃圾的。</p>
<p>我们如何知道什么东西才是『垃圾』呢？简单！只要没有任何指针指向的地方，不管有没有用，因为都不可能被使用，当然可以直接清理掉啦。不过这其实是需要一些前提条件的：</p>
<ul>
<li>我们可以知道哪里是指针，哪里不是指针</li>
<li>每个指针都指向 block 的开头</li>
<li>指针不能被隐藏(by coercing them to an <code>int</code>, and then back again)</li>
</ul>
<p>相关的算法如下：</p>
<p><img src="/images/14584417083434.jpg" alt="Classical GC Algorithms"></p>
<p>这里我们主要讨论第一种 Mark-and-sweep collection 算法（居然已经有五十多年的历史了）</p>
<p>内存具体的分布，可以看做是一个有向图，每个 block 相当于一个节点，每个指针相当于一条边。那些不在堆中的且指向堆的指针称为根节点（如寄存器，栈，全局变量等），如下图所示：</p>
<p><img src="/images/14584420668262.jpg" alt="Memory as a Graph"></p>
<h3 id="Mark_and_Sweep_Collecting"><a href="#Mark_and_Sweep_Collecting" class="headerlink" title="Mark and Sweep Collecting"></a>Mark and Sweep Collecting</h3><p>这个机制可以在 malloc/free 的基础上实现。当空间不够的时候， 在每个 block 的头部增加一个额外的 mark bit。</p>
<ul>
<li>Mark: Start at roots and set mark bit on each reachable block</li>
<li>Sweep: Scan all blocks and free blocks that are not marked</li>
</ul>
<p>整个过程如下：</p>
<p><img src="/images/14584422740964.jpg" alt="Mark and Sweep Collecting"></p>
<p>一个简易实现的思路：</p>
<p><img src="/images/14584424812466.jpg" alt="Assumptions For a Simple Iimplementation"></p>
<p>代码如下：</p>
<p><img src="/images/14584426898133.jpg" alt=""></p>
<p>在 C 语言中，我们可以使用 <code>is_ptr()</code> 来判断是否为指针，但我们也知道，C 指针可能指向 block 的中间，这个时候我们要如何找到 block 的开头呢？</p>
<p><img src="/images/14584429046281.jpg" alt="指向中间"></p>
<p> 可以这么做</p>
<ul>
<li>Can use a balanced binary tree to keep track of all allocated blocks (key is start-of-block)</li>
<li>Balanced-tree pointers can be stored in header (use two additional words)</li>
</ul>
<p><img src="/images/14584429821424.jpg" alt="存储结构"></p>
<h2 id="u5185_u5B58_u76F8_u5173_u9677_u9631"><a href="#u5185_u5B58_u76F8_u5173_u9677_u9631" class="headerlink" title="内存相关陷阱"></a>内存相关陷阱</h2><p>关于内存的使用需要注意避免以下问题：</p>
<ul>
<li>Dereferencing bad pointers</li>
<li>Reading uninitialized memory</li>
<li>Overwriting memory</li>
<li>Referencing nonexistent variables</li>
<li>Freeing blocks multiple times</li>
<li>Referencing freed blocks</li>
<li>Failing to free blocks</li>
</ul>
<p>具体看上述问题前，我们先来了解 C 语言中操作符的顺序以及优先级：</p>
<p><img src="/images/14584431989892.jpg" alt="C operators"></p>
<p>下面是一些例子，一定要好好理解（指针什么的真的头疼）</p>
<p><img src="/images/14584433625063.jpg" alt="C Pointer Declarations"></p>
<h3 id="Dereferencing_Bad_Pointers"><a href="#Dereferencing_Bad_Pointers" class="headerlink" title="Dereferencing Bad Pointers"></a>Dereferencing Bad Pointers</h3><p>这是非常常见的例子，没有引用对应的地址，少了 <code>&amp;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, val);</span><br></pre></td></tr></table></figure>
<h3 id="Reading_Uninitialized_Memory"><a href="#Reading_Uninitialized_Memory" class="headerlink" title="Reading Uninitialized Memory"></a>Reading Uninitialized Memory</h3><p>不能假设堆中的数据会自动初始化为 0，下面的代码就会出现奇怪的问题</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* return y = Ax */</span><br><span class="line">int *matvec(int **A, int *x) &#123;</span><br><span class="line">    int *y = malloc(N * sizeof(int));</span><br><span class="line">    int i, j;</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; N; i++)</span><br><span class="line">        for (j = 0; j &lt; N; j++)</span><br><span class="line">            y[i] += A[i][j] * x[j];</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Overwriting_Memory"><a href="#Overwriting_Memory" class="headerlink" title="Overwriting Memory"></a>Overwriting Memory</h3><p>这里有挺多问题，第一种是分配了错误的大小，下面的例子中，一开始不能用 <code>sizeof(int)</code>，因为指针的长度不一定和 int 一样。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int **p;</span><br><span class="line">p = malloc(N * sizeof(int));</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; N; i++) </span><br><span class="line">    p[i] = malloc(M * sizeof(int));</span><br></pre></td></tr></table></figure>
<p>第二个问题是超出了分配的空间，下面代码的 for 循环中，因为使用了 <code>&lt;=</code>，会写入到其他位置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int **p;</span><br><span class="line"></span><br><span class="line">p = malloc(N * sizeof (int *));</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt;= N; i++)</span><br><span class="line">    p[i] = malloc(M * sizeof(int));</span><br></pre></td></tr></table></figure>
<p>第三种是因为没有检查字符串的长度，超出部分就写到其他地方去了（经典的缓冲区溢出攻击也是利用相同的机制）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">gets(s); <span class="comment">/* reads "123456789" from stdin */</span></span><br></pre></td></tr></table></figure>
<p>第四种是没有正确理解指针的大小以及对应的操作，应该使用 <code>sizeof(int *)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">search</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*p &amp;&amp; *p != null)</span><br><span class="line">        p += <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第五种是引用了指针，而不是其指向的对象，下面的例子中，<code>*size--</code> 一句因为 <code>--</code> 的优先级比较高，所以实际上是对指针进行了操作，正确的应该是 <code>(*size)--</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">BinheapDelete</span><span class="params">(<span class="keyword">int</span> **binheap, <span class="keyword">int</span> *size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *packet;</span><br><span class="line">    packet = binheap[<span class="number">0</span>];</span><br><span class="line">    binheap[<span class="number">0</span>] = binheap[*size - <span class="number">1</span>];</span><br><span class="line">    *size--;</span><br><span class="line">    Heapify(binheap, *size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Referencing_Nonexistent_Variables"><a href="#Referencing_Nonexistent_Variables" class="headerlink" title="Referencing Nonexistent Variables"></a>Referencing Nonexistent Variables</h3><p>下面的情况中，没有注意到局部变量会在函数返回的时候失效（所以对应的指针也会无效），这是传引用和返回引用需要注意的，传值的话则不用担心</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Freeing_Blocks_Multiple_Times"><a href="#Freeing_Blocks_Multiple_Times" class="headerlink" title="Freeing Blocks Multiple Times"></a>Freeing Blocks Multiple Times</h3><p>这个不用多说，不能重复搞两次</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = malloc(N * sizeof(int));</span><br><span class="line">//  &lt;manipulate x&gt;</span><br><span class="line">free(x);</span><br><span class="line"></span><br><span class="line">y = malloc(M * sizeof(int));</span><br><span class="line">//  &lt;manipulate y&gt;</span><br><span class="line">free(x);</span><br></pre></td></tr></table></figure>
<h3 id="Referencing_Freed_Blocks"><a href="#Referencing_Freed_Blocks" class="headerlink" title="Referencing Freed Blocks"></a>Referencing Freed Blocks</h3><p>同样是很明显的错误，不要犯</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = malloc(N * sizeof(int));</span><br><span class="line">//  &lt;manipulate x&gt;</span><br><span class="line">free(x);</span><br><span class="line">//  ....</span><br><span class="line"></span><br><span class="line">y = malloc(M * sizeof(int));</span><br><span class="line">for (i = 0; i &lt; M; i++)</span><br><span class="line">    y[i] = x[i]++;</span><br></pre></td></tr></table></figure>
<h3 id="Memory_Leaks"><a href="#Memory_Leaks" class="headerlink" title="Memory Leaks"></a>Memory Leaks</h3><p>用完没有释放，就是内存泄露啦</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo() &#123;</span><br><span class="line">    int *x = malloc(N * sizeof(int));</span><br><span class="line">    // ...</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者只释放了数据结构的一部分：</p>
<p><img src="/images/14584447178117.jpg" alt="Freeing only part of a data structure"></p>
<h3 id="u5BF9_u7B56"><a href="#u5BF9_u7B56" class="headerlink" title="对策"></a>对策</h3><p>我们可以使用下面的工具和方法来处理内存的 bug</p>
<p><img src="/images/14584447590453.jpg" alt="Dealing With Memory Bugs"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们来看看关于内存分配的延伸话题，包括更加复杂的选择机制以及垃圾回收等相关内容。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="内存分配" scheme="http://wdxtub.com/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 18 课 Dynamic Memory Allocation - Basic Concept]]></title>
    <link href="http://wdxtub.com/2016/03/19/csapp-18/"/>
    <id>http://wdxtub.com/2016/03/19/csapp-18/</id>
    <published>2016-03-19T21:32:26.000Z</published>
    <updated>2016-03-20T00:16:19.000Z</updated>
    <content type="html"><![CDATA[<p>前面了解了虚拟内存的相关知识，这节课我们来看看动态内存分配的基本概念，相信这之后就知道诸如 <code>malloc</code> 和 <code>new</code> 这类方法是怎么做的了。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u7840_u6982_u5FF5"><a href="#u57FA_u7840_u6982_u5FF5" class="headerlink" title="基础概念"></a>基础概念</h2><p>程序员通过动态内存分配（例如 <code>malloc</code>）来让程序在运行时得到虚拟内存。动态内存分配器会管理一个虚拟内存区域，称为堆(heap)，如下图所示：</p>
<p><img src="/images/14584238419962.jpg" alt="Dynamic Memory Allocation"></p>
<p>分配器以 block 为单位来维护 heap，可以进行 allocate 或 free。有两种类型的分配器：</p>
<ul>
<li>显式分配器：应用分配并且回收空间（C 语言中的 <code>malloc</code> 和 <code>free</code>）</li>
<li>隐式分配器：应用只负责分配，但是不负责回收（Java 中的垃圾收集）</li>
</ul>
<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>我们来看看 <code>malloc</code> 函数：</p>
<p><img src="/images/14584242618725.jpg" alt="The malloc Package"></p>
<p>一个简单的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void foo(int n) &#123;</span><br><span class="line">    int i, *p;</span><br><span class="line">    </span><br><span class="line">    /* Allocate a block of n ints */</span><br><span class="line">    p = (int *) malloc(n * sizeof(int));</span><br><span class="line">    if (p == NULL) &#123;</span><br><span class="line">        perror("malloc");</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* Initialize allocated block */</span><br><span class="line">    for (i=0; i&lt;n; i++)</span><br><span class="line">        p[i] = i;</span><br><span class="line"></span><br><span class="line">    /* Return allocated block to the heap */</span><br><span class="line">    free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这节课中，为了讲述方便，我们做如下假设：</p>
<ul>
<li>Memory is word addressed</li>
<li>Words are int-sized</li>
</ul>
<p><img src="/images/14584252386542.jpg" alt="Assumptions Made in This Lecture"></p>
<p>具体的例子：</p>
<p><img src="/images/14584253826838.jpg" alt="Allocation Example"></p>
<p>程序可以用任意的顺序发送 <code>malloc</code> 和 <code>free</code> 请求，<code>free</code> 请求必须作用与已被分配的 block。</p>
<p>分配器有如下的限制：</p>
<ul>
<li>不能控制已分配 block 的数量和大小</li>
<li>必须立即响应 <code>malloc</code> 请求（不能缓存或者给请求重新排序）</li>
<li>必须在未分配的内存中分配</li>
<li>不同的 block 需要对齐（32 位中 8 byte，64 位中 16 byte）</li>
<li>只能操作和修改未分配的内存</li>
<li>不能移动已分配的 block</li>
</ul>
<h2 id="u6027_u80FD_u6307_u6807"><a href="#u6027_u80FD_u6307_u6807" class="headerlink" title="性能指标"></a>性能指标</h2><p>现在我们可以来看看如何去评测具体的分配算法了。假设给定一个 <code>malloc</code> 和 <code>free</code> 的请求的序列：</p>
 $$R_0, R_1, ..., R_k, ..., R_{n-1}$$ 
<p>目标是尽可能提高吞吐量以及内存利用率（注意，这两个目标常常是冲突的）</p>
<p>吞吐量是在单位时间内完成的请求数量。假设在 10 秒中之内进行了 5000 次 <code>malloc</code> 和 5000 次 <code>free</code> 调用，那么吞吐量是 1000 operations/second</p>
<p>另外一个目标是 Peak Memory Utilization，就是最大的内存利用率，具体如下：</p>
<p><img src="/images/14584265326302.jpg" alt="Peak Memory Utilization"></p>
<p>影响内存利用率的主要因素就是『内存碎片』，有两种类型：</p>
<ul>
<li>internal fragmentation</li>
<li>external fragmentation0</li>
</ul>
<h3 id="u5185_u90E8_u788E_u7247"><a href="#u5185_u90E8_u788E_u7247" class="headerlink" title="内部碎片"></a>内部碎片</h3><p>对于给定的 block，internal fragmentation 主要是因为 payload 小于 block size 造成的，如下图所示：</p>
<p><img src="/images/14584268109274.jpg" alt="internal fragmentation"></p>
<p>主要是由以下原因导致；</p>
<ul>
<li>Overhead of maintaining heap data structures</li>
<li>Padding for alignment purposes</li>
<li>Explicit policy decisions</li>
</ul>
<p>只依赖于上一个请求的具体模式，所以比较容易测量。</p>
<h3 id="u5916_u90E8_u788E_u7247"><a href="#u5916_u90E8_u788E_u7247" class="headerlink" title="外部碎片"></a>外部碎片</h3><p>指的是内存中没有足够的连续空间，如下图所示：</p>
<p><img src="/images/14584269418830.jpg" alt="External Fragmentation"></p>
<p>依赖于未来的请求模式，所以比较难测量。</p>
<h3 id="u5B9E_u73B0_u7EC6_u8282"><a href="#u5B9E_u73B0_u7EC6_u8282" class="headerlink" title="实现细节"></a>实现细节</h3><p>在具体实现之前，需要考虑以下问题：</p>
<ul>
<li>给定一个指针，我们如何知道需要释放多少内存？</li>
<li>如何记录未分配的 block ？</li>
<li>实际需要的空间比未分配的空间要小的时候，剩下的空间怎么办？</li>
<li>如果有多个区域满足条件，如何选择？</li>
<li>释放空间之后如何进行记录？</li>
</ul>
<p>一个标准的方式是在指针的前一个  word 中保存 block 的大小，通常称之为 header field 或 header，这种方式需要额外的一个 word，具体如下：</p>
<p><img src="/images/14584273450722.jpg" alt="Standard method"></p>
<p>这里我们先给出常用的四种方式，这节课主要介绍第一种，下节课会介绍后面的方法：</p>
<p><img src="/images/14584273923045.jpg" alt="Keeping Track of Free Blocks"></p>
<h2 id="u9690_u5F0F_free__u5217_u8868"><a href="#u9690_u5F0F_free__u5217_u8868" class="headerlink" title="隐式 free 列表"></a>隐式 free 列表</h2><p>对于每个 block 来说，我们需要知道大小和具体的状态（已分配/未分配），可以用两个 word 来存储，但是这样太浪费了。</p>
<p>如果一个 block 已经对其，低位地址一定是 0，所以我们可以用来当做 allocated/free 标志，当读入 word 大小的时候，需要标记出这个值。</p>
<p><img src="/images/14584304354717.jpg" alt="Implicit List"></p>
<p><img src="/images/14584304662424.jpg" alt="Detailed Implicit Free List Example"></p>
<p>寻找未分配的空间的方式如下，主要有三种：</p>
<p><img src="/images/14584305912848.jpg" alt="Finding a Free Block"></p>
<p>确定空间之后，具体进行分配如下：</p>
<p><img src="/images/14584306987840.jpg" alt="Allocating in Free Block"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addblock</span><span class="params">(ptr p, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newsize = ((len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;  <span class="comment">// round up to even</span></span><br><span class="line">    <span class="keyword">int</span> oldsize = *p &amp; -<span class="number">2</span>;                <span class="comment">// mask out low bit</span></span><br><span class="line">    *p = newsize | <span class="number">1</span>;                     <span class="comment">// set new length</span></span><br><span class="line">    <span class="keyword">if</span> (newsize &lt; oldsize)</span><br><span class="line">        *(p+newsize) = oldsize - newsize; <span class="comment">// set length in remaining</span></span><br><span class="line">                                          <span class="comment">// part of block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在释放空间的时候如果 block 后面也是未分配的空间，只做基本的处理的话，会出现有足够的位置，但是因为多余的分隔而找不到对应的位置，如下所示：</p>
<p><img src="/images/14584314075261.jpg" alt="Freeing a Block"></p>
<p>解决的办法是 Coalescing：</p>
<p><img src="/images/14584314805605.jpg" alt="coalesce"></p>
<p>另一种方法是双向 coalescing：</p>
<p><img src="/images/14584318651163.jpg" alt="Bidirectional Coalescing"></p>
<p>具体 coalescing 的时候有四种情况：</p>
<p><img src="/images/14584319803616.jpg" alt="Constant Time Coalescing"></p>
<p>下面是四种情况的：</p>
<p>Case 1：</p>
<p><img src="/images/14584322811295.jpg" alt="Case 1"></p>
<p>Case 2：</p>
<p><img src="/images/14584322969946.jpg" alt="Case 2"></p>
<p>Case 3：</p>
<p><img src="/images/14584323407555.jpg" alt="Case 3"></p>
<p>Case 4：</p>
<p><img src="/images/14584323554767.jpg" alt="Case 4"></p>
<p>Boundary Tags 的坏处就是会导致 internal fragmentation。</p>
<p>总结一下：</p>
<p><img src="/images/14584328927396.jpg" alt="Summary of Key Allocator Policies"></p>
<p>最后是 implicit list 的总结：</p>
<p><img src="/images/14584329366933.jpg" alt="Implicit Lists: Summary"></p>
<p>总体来说这一部分还是比较简单的，虽然简单，但是一定要理解清楚，因为下节课会介绍更加复杂的机制。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面了解了虚拟内存的相关知识，这节课我们来看看动态内存分配的基本概念，相信这之后就知道诸如 <code>malloc</code> 和 <code>new</code> 这类方法是怎么做的了。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="内存分配" scheme="http://wdxtub.com/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第十周 - Deacon Blue]]></title>
    <link href="http://wdxtub.com/2016/03/18/deacon-blue/"/>
    <id>http://wdxtub.com/2016/03/18/deacon-blue/</id>
    <published>2016-03-19T02:37:13.000Z</published>
    <updated>2016-03-19T11:55:43.000Z</updated>
    <content type="html"><![CDATA[<p>You can’t control what life presents. Keep it moving man, one day you’ll make it through.</p>
<a id="more"></a>
<hr>
<p>不知不觉就来到了第十周，回顾上个学期的周记，清楚地意识到，恐怕再写六周，就真的要告别『校园生活』了。没有太多不舍，因为已经尽力去体验了校园中的各种角色；没有太多遗憾，因为很多事情已经做到了足够好；甚至没有太多期待，人来人往，熙熙攘攘，桃源室外，锦城何在？</p>
<p>万万没想到，记录一下对于课程的理解，翻译一下逻辑混乱语句不同的课程资料，竟收到了老师的『警告』：因为涉及题目的思路以及相关课程内容，必须把相关日志都删掉，否则老师很生气，后果很严重。我其实没有任何选择，人在屋檐下，不得不低头，二十多篇很用心写的日志不得不『消失』，虽有些气不过，但是更多的是失望。既然都写到这儿了，一不做二不休，来说说所谓的『老师』，和所谓的『课程』：</p>
<ol>
<li>我不知道老师到底干了啥，如果他真的有看课程资料的话，是如何容忍毫无逻辑且经常前后矛盾的作业说明的？</li>
<li>我不知道助教到底是为啥一肚子坏水，说明写得不清不楚就算了，样例代码写得像下水道大学出来的一样就算了，但是拿着鸡毛当令箭真的好吗？</li>
<li>我不知道作业中为啥老师和助教工作的不严谨，要让全体同学的时间来买单，很多明显是故意设置出来『浪费』大家时间的设定，我真心觉得这已经背离了『传道授业解惑』的范畴？</li>
</ol>
<p>日志就是我的武器，用重新组织的逻辑清晰的描述完备的文字，让大家尽可能明白每次的作业到底是要做什么，把时间节约起来，去做自己真正想做的事情。然而这个不知道在哪『梦游』的老师直接用行政压力让我缴械。势单力薄，除了投降我还能做什么？</p>
<p>缺乏基本的语文能力是理工科学生的通病，又或者因为平时的生活学习节奏压根没有太多的表达训练，我真的真的遇到了太多哭笑不得的沟通障碍。举个例子，一旦走到专业之外，文化的范畴中，很多人就成了盲人。他们感受不到不同词汇不同句法背后蕴藏的深意，他们不去思考专业外的东西，眼中只有短期目标，一旦视线离开这个点，就成了无头苍蝇。</p>
<p>跟六七十岁的教授讨论起文化、哲学、历史相关的话题，才真正有『沟通』的体验：一点即通，不会在细枝末节上浪费太多精力；一针见血，直接把最核心的问题拿出来打磨讨论，用思考来切磋。</p>
<p>最近一直在玩《合金装备 5：幻痛》，整个剧情及世界观的设定和《白鲸记》《一九八四》以及《蝇王》有非常深的联系，跟同学聊起，没有人读过这些书，根本没办法进入游戏理念已经具体通过游戏来表达想法的技术讨论。</p>
<p>这真的是很痛苦的事情。聊得来是非常高的标准，至少需要双方有同等水平的思维能力。</p>
<p>最近也慢慢进入了找到工作互相请客的状态，看着大家一路坚持过来到最终实现自己的目标，我还是很开心的。借由自己的疏离感带来的观察，更加深刻理解了『性格即命运』。</p>
<p>各种各样的性格，面对问题的时候也有各种各样的解法。从我的角度来说，除了一种人需要远离之外，其他怎么折腾都行。</p>
<blockquote>
<p>远离那些野心很大，自己却配不上这份野心的人。</p>
</blockquote>
<p>他们是最可能放弃一切尊严和道德，用力把你拉下水或者会为了一丁点微不足道的东西铤而走险的人。</p>
<p>估计是因为没睡够的缘故，整篇周记的风格竟然成了这样，最后当然还是要 look on the bright side。</p>
<p>很久没有聊过这么久的电话，即使特别困也想要多说两句，高质量的沟通真的是非常愉快的事情，找到加速度差不多的人真的不容易。</p>
<p>最后说一句，AI 能取代的终究是那些思维强度太低的人，最好的做法就是多读多写多思考，人类在推动技术发展的同时，技术也在引导着人类进步的方向，跟不上时代的注定要淘汰，物竞天择，优胜劣汰。</p>
<p>Set your goal high. Be sure to stay true.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>You can’t control what life presents. Keep it moving man, one day you’ll make it through.</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="变化" scheme="http://wdxtub.com/tags/%E5%8F%98%E5%8C%96/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="春天" scheme="http://wdxtub.com/tags/%E6%98%A5%E5%A4%A9/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 17 课 Virtual Memory - System]]></title>
    <link href="http://wdxtub.com/2016/03/18/csapp-17/"/>
    <id>http://wdxtub.com/2016/03/18/csapp-17/</id>
    <published>2016-03-18T13:48:57.000Z</published>
    <updated>2016-03-19T02:21:36.000Z</updated>
    <content type="html"><![CDATA[<p>了解了基本的虚拟内存概念，这节课我们来具体看看 Core i7 和 Linux 的内存系统，相信会对虚拟内存这一套机制有更深刻的认识。</p>
<a id="more"></a>
<hr>
<p>开始之前我们还是先复习一下基本的概念：</p>
<p><img src="/images/14583183552533.jpg" alt="Review of Symbols"></p>
<h2 id="u5730_u5740_u7FFB_u8BD1_u5B9E_u4F8B"><a href="#u5730_u5740_u7FFB_u8BD1_u5B9E_u4F8B" class="headerlink" title="地址翻译实例"></a>地址翻译实例</h2><p>然后来看一个简单的例子：</p>
<ul>
<li>14 位的虚拟地址</li>
<li>12 位的物理地址</li>
<li>page size 为 64 字节</li>
</ul>
<p>如下图所示</p>
<p><img src="/images/14583359973808.jpg" alt="Addressing"></p>
<p>TLB 的配置为：</p>
<ul>
<li>16 entries</li>
<li>4-way associative</li>
</ul>
<p>如下图所示</p>
<p><img src="/images/14583376303817.jpg" alt="TLB"></p>
<p>然后来看看 page table，一共有 256 个 entry，这里列出前 16 个：</p>
<p><img src="/images/14583376858566.jpg" alt="Page Table"></p>
<p>最后来看看系统本身缓存：</p>
<ul>
<li>16 lines, 4-byte block size</li>
<li>Physically addressed</li>
<li>Direct mapped</li>
</ul>
<p><img src="/images/14583377349696.jpg" alt="Cache"></p>
<p>一定要注意好不同部分的所代表的位置，这里我也会尽量写得清楚一些，来看第一个例子：</p>
<blockquote>
<p>虚拟地址为 <code>0x03D4</code></p>
</blockquote>
<p>具体的转换过程如下图所示：</p>
<p><img src="/images/14583479163395.jpg" alt="第一个例子"></p>
<p>具体来梳理一次：</p>
<p>先看 TLB 中有没有对应的条目，所以先看虚拟地址的第 6-13 位，在前面的 TLB 表中，根据 TLBI 为 3 这个信息，去看这个 set 中有没有 tag 为 3 的项目，发现有，并且对应的 PPN 是 0x0D，所以对应到物理地址，就是 PPN 加上虚拟地址的 0-5 位，而具体的物理地址又可以在缓存中找到（利用 cache memory 的机制），就可以获取到对应的数据了。</p>
<p>下面的例子同样可以按照这个方法来进行分析</p>
<p><img src="/images/14583493888490.jpg" alt="第二个例子"></p>
<h2 id="u6848_u4F8B_u5B66_u4E60_uFF1ACore_i7"><a href="#u6848_u4F8B_u5B66_u4E60_uFF1ACore_i7" class="headerlink" title="案例学习：Core i7"></a>案例学习：Core i7</h2><p>我们先来看看整体的架构</p>
<p><img src="/images/14583495456299.jpg" alt="Intel Core i7 Memory System"></p>
<p>这里先留意一点，为什么 L1 d-cache 比上 L2 unified cache，和 L1 d-TLB 比上 L2 unified TLB 的比例一样呢？</p>
<p><img src="/images/14583500587332.jpg" alt="End-to-end Core i7 Address Translation"></p>
<p>可以清楚地看到，从 TLB 到 Page table 以及对应 cache 的转换，结合上面的说明仔细体会下。接下来的内容比较偏理论，大家有一个基本的认识即可（因为平时编程理论上也不会涉及到这些）</p>
<p>Core i7 有 4 层的 page table，前 3 层的结构一样，如下图所示</p>
<p><img src="/images/14583503794880.jpg" alt="Core i7 Level 1-3 Page Table Entries"></p>
<p>第四层有少许不同，具体看下面的说明：</p>
<p><img src="/images/14583505732854.jpg" alt="Core i7 Level 4 Page Table Entries"></p>
<p>具体的翻译过程为：</p>
<p><img src="/images/14583506241439.jpg" alt="Core i7 Page Table Translation"></p>
<p>接下来就可以回答前面的问题了，为啥是成比例的呢？原因很简单！用来加速 L1 的访问！</p>
<blockquote>
<p>Virtually indexed, physically tagged</p>
</blockquote>
<p><img src="/images/14583509113693.jpg" alt="Cute Trick for Speeding Up L1 Access"></p>
<h2 id="u6848_u4F8B_u5B66_u4E60_uFF1ALinux_Process"><a href="#u6848_u4F8B_u5B66_u4E60_uFF1ALinux_Process" class="headerlink" title="案例学习：Linux Process"></a>案例学习：Linux Process</h2><p>这一部分也是了解一下即可（具体可以不用太深究）</p>
<p><img src="/images/14583511838723.jpg" alt="Virtual Address Space of a Linux Process"></p>
<p>Linux 以不同的『区域』来组织虚拟内存</p>
<p><img src="/images/14583514430157.jpg" alt="Linux Organizes VM as Collection of &quot;Areas&quot;"></p>
<p>下面是处理 page fault 的机制：</p>
<p><img src="/images/14583519002966.jpg" alt="Linux Page Fault Handling"></p>
<h2 id="u5185_u5B58_u6620_u5C04"><a href="#u5185_u5B58_u6620_u5C04" class="headerlink" title="内存映射"></a>内存映射</h2><p>初始化虚拟内存的过程，实际上就是把对应的虚拟内存和磁盘上的对象关联起来的过程，称之为内存映射(memory mapping)</p>
<p><img src="/images/14583529040142.jpg" alt=""></p>
<p>Linux 中所谓的『交换分区』就是这么来的（我估计）</p>
<p><img src="/images/14583530219645.jpg" alt="Shared Objects"></p>
<ul>
<li>Process 1 maps the shared object</li>
<li>Process 2 maps the shared object</li>
<li>Two processes mapping a <strong>private copy-on-write(COW)</strong> object</li>
<li>Area flagged as private copy-on-write</li>
<li>PTEs in private areas are flagged as read-only</li>
</ul>
<p><img src="/images/14583530323902.jpg" alt="Private Copy-on-write(COW) Objects"></p>
<ul>
<li>Instruction writing to private page triggers protection fault</li>
<li>Handler creates new R/W page</li>
<li>Instruction restarts upon handler return</li>
<li>Copying deferred as long as possible!</li>
</ul>
<p>Fork 函数就是这种机制的一个很好的例子：</p>
<p><img src="/images/14583534506790.jpg" alt="The `fork` Function"></p>
<p>接着来看看 <code>execve</code> 函数</p>
<p><img src="/images/14583535882515.jpg" alt="The `execve` Function"></p>
<p>最后介绍了 <code>mmap</code> 函数，这里不赘述了。</p>
<p>这一部分比较偏向实际，主要还是要理解虚拟内存的机制（具体现代的处理器和操纵系统已经『太』复杂了）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解了基本的虚拟内存概念，这节课我们来具体看看 Core i7 和 Linux 的内存系统，相信会对虚拟内存这一套机制有更深刻的认识。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="虚拟内存" scheme="http://wdxtub.com/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 16 课 Virtual Memory - Concepts]]></title>
    <link href="http://wdxtub.com/2016/03/18/csapp-16/"/>
    <id>http://wdxtub.com/2016/03/18/csapp-16/</id>
    <published>2016-03-18T13:48:52.000Z</published>
    <updated>2016-03-18T16:11:31.000Z</updated>
    <content type="html"><![CDATA[<p>这节课开始，我们会接触到计算机系统中另外一个非常重要的概念：虚拟内存。这个机制提供给了上层应用一个统一的地址空间，而无须操心物理内存的位置。</p>
<a id="more"></a>
<hr>
<p>在具体讲述之前，我们先来看看什么是物理地址，什么是虚拟地址。</p>
<p><img src="/images/14583091815694.jpg" alt="物理地址"></p>
<p>物理地址一般应用在简单的嵌入式微控制器中（汽车、电梯、电子相框等），因为应用的范围有严格的限制，不需要在内存管理中引入过多的复杂度。</p>
<p>但是对于计算机（以及其他智能设备）来说，虚拟地址则是必不可少的，通过 MMU(Memory management unit)把虚拟地址(Virtual Address, VA)转换为物理地址(Physical Address, PA)，再由此进行实际的数据传输。大致的过程如下图所示</p>
<p><img src="/images/14583093850630.jpg" alt="虚拟地址"></p>
<p>使用虚拟内存主要是基于下面三个考虑：</p>
<ol>
<li>可以更有效率的使用内存：使用 DRAM 当做部分的虚拟地址空间的缓存</li>
<li>简化内存管理：每个进程都有统一的线性地址空间</li>
<li>隔离地址控件：进程之间不会相互影响；用户程序不能访问内核信息和代码</li>
</ol>
<h2 id="u4F5C_u4E3A_u7F13_u5B58_u5DE5_u5177"><a href="#u4F5C_u4E3A_u7F13_u5B58_u5DE5_u5177" class="headerlink" title="作为缓存工具"></a>作为缓存工具</h2><p>概念上来说，虚拟内存就是存储在磁盘上的 N 个连续字节的数组。这个数组的部分内容，会缓存在 DRAM 中，在 DRAM 中的每个 cache block 就称为 page（页），具体的大小为 $P=2^p$（这里 p 表示具体的位数），如下图所示：</p>
<p><img src="/images/14583098368523.jpg" alt=""></p>
<p>大致的思路和之前的 cache memory 是类似的，就是利用 DRAM 比较快的特性，把最常用的数据换缓存起来。如果要访问磁盘的话，大约会比访问 DRAM 慢一万倍，所以我们的目标就是尽可能从 DRAM 中拿数据。为此，我们需要：</p>
<ul>
<li>更大的 page size：通常是 4KB，有的时候可以达到 4MB</li>
<li>全相联 Fully associative：每一个 virual page 可以放在任意的 physical page 中，没有限制。</li>
<li>映射函数非常复杂，所以没有办法用硬件实现</li>
<li>通常使用 Write-back 而非 Write-through 机制<ul>
<li>Write-through: 命中后更新缓存，同时写入到内存中</li>
<li>Write-back: 直到这个缓存需要被置换出去，才写入到内存中（需要额外的 dirty bit 来表示缓存中的数据是否和内存中相同，因为可能在其他的时候内存中对应地址的数据已经更新，那么重复写入就会导致原有数据丢失）</li>
</ul>
</li>
</ul>
<p>具体怎么做呢？通过 page table。每个 page table 实际上是一个数组，数组中的每个元素称为 page table entry(PTE)，每个 PTE 负责把 virtual page 映射到 physical page 上。在 DRAM 中，每个进程都有自己的 page table，具体如下</p>
<p><img src="/images/14583104118576.jpg" alt="Page Table"></p>
<p>因为有一个表可以查询，就会遇到两种情况，一种是 Page Hit，另一种则是 Page Fault。</p>
<blockquote>
<p>Page hit: reference to VM word that is in physical memory (DRAM cache hit)</p>
</blockquote>
<p>访问到 page table 中蓝色条目的地址时，因为在 DRAM 中有对应的数据，可以直接访问。</p>
<blockquote>
<p>Page fault: reference to VM word that is not in physical memory (DRAM cache miss)</p>
</blockquote>
<p>访问到 page table 中灰色条目的时候，因为在 DRAM 中并没有对应的数据，所以需要执行一系列操作（从磁盘复制到 DRAM 中），具体为：</p>
<ul>
<li>触发 Page fault，也就是一个异常</li>
<li>Page fault handler 会选择 DRAM 中需要被置换的 page，并把数据从磁盘复制到 DRAM 中</li>
<li>重新执行访问指令，这时候就会是 page hit</li>
</ul>
<p>复制过程中的等待时间称为 demand paging。</p>
<p>仔细留意上面的 page table，会发现有一个条目是 null，也就是没有分配。具体的分配过程（比方说声明了一个大数组），就是让该条目指向虚拟内存（在磁盘上）的某个 page（但并不复制到 DRAM，只有当出现 page fault 的时候才需要赋值）</p>
<p>看起来『多此一举』，但是由于局部性原理，虚拟内存其实是非常高效的机制，这一部分最后提到了 working set 的概念，比较简单，这里不再赘述：</p>
<p><img src="/images/14583113431902.jpg" alt="working set"></p>
<h2 id="u4F5C_u4E3A_u5185_u5B58_u7BA1_u7406_u5DE5_u5177"><a href="#u4F5C_u4E3A_u5185_u5B58_u7BA1_u7406_u5DE5_u5177" class="headerlink" title="作为内存管理工具"></a>作为内存管理工具</h2><p>前面提到，每个进程都有自己的虚拟地址空间，这样一来，对于进程来说，它们看到的就是简单的线性空间（但实际上在物理内存中可能是间隔、支离破碎的），具体的映射过程可以用下图表示：</p>
<p><img src="/images/14583114512897.jpg" alt="maping"></p>
<p>在内存分配中没有太多限制，每个 virtual page 都可以被映射到任何的 physical page 上。这样也带来一个好处，如果两个进程间有共享的数据，那么直接指向同一个 physical page 即可（也就是上图 PP 6 的状况，只读数据）</p>
<p>虚拟内存带来的另一个好处就是可以简化链接和载入的结构（因为有了统一的抽象，不需要纠结细节），如下图所示：</p>
<p><img src="/images/14583116383432.jpg" alt="Simplifying Linking and Loading"></p>
<h2 id="u4F5C_u4E3A_u5185_u5B58_u4FDD_u62A4_u5DE5_u5177"><a href="#u4F5C_u4E3A_u5185_u5B58_u4FDD_u62A4_u5DE5_u5177" class="headerlink" title="作为内存保护工具"></a>作为内存保护工具</h2><p>Page table 中的每个条目的高位部分是表示权限的位，MMU 可以通过检查这些位来进行权限控制（读、写、执行）</p>
<p><img src="/images/14583120873244.jpg" alt="Permission bits"></p>
<h2 id="u5730_u5740_u7FFB_u8BD1"><a href="#u5730_u5740_u7FFB_u8BD1" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>开始之前先来了解以下概念：</p>
<p><img src="/images/14583133332593.jpg" alt="Summary of Address Translation Symbols"></p>
<p>然后我们通过一个具体的例子来说明如何进行地址翻译</p>
<p><img src="/images/14583134329438.jpg" alt="Address Translation With a Page Table"></p>
<p>具体的访问过程为：</p>
<ul>
<li>通过虚拟地址找到 page table 中对应的条目</li>
<li>检查 valid bit，是否需要触发 page fault</li>
<li>然后根据 page table 中的 physical page number 找到内存中的对应地址</li>
<li>最后把 virtual page offset 和前面的实际地址拼起来，就是最终的物理地址了</li>
</ul>
<p>这里又分两种情况：Page Hit 和 Page Fault，具体过程如下：</p>
<p><img src="/images/14583139236125.jpg" alt="Page Hit"></p>
<ol>
<li>Processor sends virtual address to MMU</li>
<li>MMU fetches PTE from page table in memory</li>
<li>MMU fetches PTE from page table in memory</li>
<li>MMU sends physical address to cache/memory</li>
<li>Cache/memory sends data word to processor</li>
</ol>
<p><img src="/images/14583140218329.jpg" alt="Page Fault"></p>
<ol>
<li>Processor sends virtual address to MMU</li>
<li>MMU fetches PTE from page table in memory</li>
<li>MMU fetches PTE from page table in memory</li>
<li>Valid bit is zero, so MMU triggers page fault exception</li>
<li>Handler identifies victim (and, if dirty, pages it out to disk)</li>
<li>Handler pages in new page and updates PTE in memory</li>
<li>Handler returns to original process, restarting faulting instruction</li>
</ol>
<p>把这个和我们前面提到的 cache memory 结合起来就是：</p>
<p><img src="/images/14583153762095.jpg" alt="Integrating VM and Cache"></p>
<ul>
<li>VA: virtual address, PA: physical address</li>
<li>PTE: page table entry, PTEA = PTE address</li>
</ul>
<p>但是我们会发现，这样其实还不够快，L1 cache 虽然快，为什么不能直接在 MMU 进行一部分的工作呢？于是就有了另外一个设计：Translation Lookaside Buffer(TLB)</p>
<ul>
<li>Small set-associative hardware cache in MMU</li>
<li>Maps virtual page numbers to physical page numbers</li>
<li>Contains complete page table entries for small number of pages</li>
</ul>
<p>我们使用 Virtual Page Number 部分当做访问 TLB 的索引，具体如下（和 cache memory 非常相似）：</p>
<p><img src="/images/14583156462414.jpg" alt="Accessing the TLB"></p>
<p>同样分两个情况：TLB Hit 和 TLB Miss</p>
<blockquote>
<p>A TLB hit eliminates a memory access</p>
</blockquote>
<p><img src="/images/14583156886189.jpg" alt="TLB Hit"></p>
<blockquote>
<p>A TLB miss incurs an additional memory access(the PTE)</p>
</blockquote>
<p><img src="/images/14583157195012.jpg" alt="TLB Miss"></p>
<h3 id="Multi-Level_Page_Tables"><a href="#Multi-Level_Page_Tables" class="headerlink" title="Multi-Level Page Tables"></a>Multi-Level Page Tables</h3><p>Page table 的另一个问题就是，因为往往虚拟地址的位数比物理内存的位数要大得多，所以保存 page table entry(PTE) 也是一个问题。举个例子：</p>
<p>假设一个 page 的大小是 4KB($2^12$)，每个地址有 48 位，一条 PTE 记录有 8 个字节，那么要全部保存下来，需要的大小是：</p>
<p>$$2^{48} \times 2^{-12} \times 2^3 = 2^{39} bytes$$</p>
<p>整整 512 GB!</p>
<p>所以解决办法就是，多层的 page table，第一层的 page table 中的条目指向其他的 page table，然后再去寻找具体的地址：</p>
<p><img src="/images/14583164443493.jpg" alt="A Two-Level Page Table Hierarchy"></p>
<p>具体的翻译过程如下：</p>
<p><img src="/images/14583165384715.jpg" alt="Translating with a k-level Page Table"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Programmer’s view of virtual memory<ul>
<li>Each process has its own private linear address space</li>
<li>Cannot be corrupted by other processes</li>
</ul>
</li>
<li>System view of virtual memory<ul>
<li>Use memory efficiently by caching virtual memory pages<ul>
<li>Efficient only because of locality </li>
</ul>
</li>
<li>Simplifies memory management and programming</li>
<li>Simplifies protection by providing a convenient interpositioning point to check permissions</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课开始，我们会接触到计算机系统中另外一个非常重要的概念：虚拟内存。这个机制提供给了上层应用一个统一的地址空间，而无须操心物理内存的位置。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="虚拟内存" scheme="http://wdxtub.com/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 20 课 设计模式]]></title>
    <link href="http://wdxtub.com/2016/03/17/sad-20/"/>
    <id>http://wdxtub.com/2016/03/17/sad-20/</id>
    <published>2016-03-17T17:33:55.000Z</published>
    <updated>2016-03-18T01:30:19.000Z</updated>
    <content type="html"><![CDATA[<p>前面讲了这么多『玄学』概念，这一次终于回到软件开发的主战场——设计模式！</p>
<a id="more"></a>
<hr>
<p>设计模式可以算得上是软件架构中最有门道的一部分，也是大家最熟悉却又最陌生的一部分。熟悉是因为任何软件工程的课一定会提到，陌生则是因为『纸上得来终觉浅』，往往在实际应用中，会出现很多问题。总体来说，设计模式可以看作是解决某种特定问题的成功经验的提炼，学习设计模式，等于是站在巨人的肩膀上，能看得更远。</p>
<p>因为自己对这个话题也很有兴趣，所以就不按照老师课堂的讲述来编排了（实话说我觉得她讲的非常一般），课堂上主要介绍了工厂模式、单例模式、建造者模式和原型模式（本文都会涉及）。</p>
<p>本文主要写自己对不同模式，以及模式之间的一些思考。</p>
<h2 id="u5148_u5520_u53E8_u4E24_u53E5"><a href="#u5148_u5520_u53E8_u4E24_u53E5" class="headerlink" title="先唠叨两句"></a>先唠叨两句</h2><p>从前提到『设计模式』，总觉得是特别高大上的东西。随着代码越写越多，接触的事物越来越广泛，慢慢开始意识到这些所谓的『规则』，是保护，也是束缚。也开始怀疑过去不知道为什么就会去『相信』的东西，比如说本文的『设计模式』，以及与之密切相关的『面向对象』。</p>
<p>学术界的一大问题在于，有的时候为了凸现自己的不同，会强行『发明』一些东西。层出不穷的理论与技术，结合不同时代的主题，颇有种『一代补丁一代神』的循环感。最近特别火的 AlphaGO，最终不可避免会遇到 PS4 的尴尬——是在模拟地球，还是在模拟地球仪？</p>
<p>最近几年听到看到的各路流派给自己贴光环的故事已经太多，从 OO 到 SOA，从 Vim 到 Emac，从 Windows 到 Linux/Unix，例子不胜枚举。问题在于，它们都想用一个东西解决所有问题，但是真有这么个东西，早就解决了你想要解决这个解决问题的问题了（是不是被绕了？）。不能只有一种声音，不能只有一种思路，甚至可以从《一九八四》中『偷』来这么个概念——双重思想。</p>
<p>C++ STL 库的作者关于面向对象说过这么一段话（虽有断章取义之嫌，但应该还是能表达出他的理念）：</p>
<blockquote>
<p>I find OOP technically unsound. It attempts to decompose the world in terms of interfaces that vary on a single type. To deal with the real problems you need multisorted algebras – families of interfaces that span multiple types. I find OOP philosophically unsound. It claims that everything is an object. Even if it is true it is not very interesting – saying that everything is an object is saying nothing at all. I find OOP methodologically wrong. It starts with classes. It is as if mathematicians would start with axioms. You do not start with axioms – you start with proofs. Only when you have found a bunch of related proofs, can you come up with axioms. You end with axioms. The same thing is true in programming: you have to start with interesting algorithms. Only when you understand them well, can you come up with an interface that will let them work.</p>
</blockquote>
<p>就拿 Java 来说，所有东西都是对象，这跟所有东西都不是对象又有什么区别呢？纵观《设计模式》一书所说的 23 种设计模式，说白了就是：</p>
<ul>
<li>多组合少继承</li>
<li>面向接口而非实现</li>
<li>高内聚低耦合</li>
</ul>
<p>其实都是平时听得太多以至于不太在意的概念。或者很多时候我们被『想当然』封印住了思考，本能就往 OO 或者 SOA 的方向跳了。</p>
<p>然后说说 SOA，从大三刚开始接触的时候，我就感觉非常不科学。SOA 的想法很好，方向也很好，但是遇到的一个悖论就是，在业务复杂到足以体现 SOA 的优势的时候，往往 SOA 本身已经复杂得没人弄得懂了。因为大家都是提供一个服务给别人调用，那么调用背后发生的事情就是一团乱麻了，基本上一个功能完成后就只有两个命运：用一段时间，需要更新的时候直接重写。</p>
<p>这种时候不妨回过头来看看『传统』的数据驱动编程，就会发现只有一直抓住问题的本质，才不至于人为增加太多复杂度（所以这个学期的云计算课程人为浪费大家时间我真心感受到了助教的恶意）。</p>
<blockquote>
<p>Keep It Simple, Stupid!</p>
</blockquote>
<h2 id="u5E38_u89C1_u6A21_u5F0F"><a href="#u5E38_u89C1_u6A21_u5F0F" class="headerlink" title="常见模式"></a>常见模式</h2><ul>
<li>工厂模式的本质，实际上是以一个统一的角度去理解所有的资源，具体根据特定的标志符来进行对应处理</li>
<li>抽象工厂的本质，其实就是一组配置文件，搞得那么玄乎，真心还就是几个文本文件可以解决的问题</li>
<li>原型模式的本质，Unix 中的 <code>fork</code> 可以说是完美体现，反正我先原样搞出来一个，剩下的自己继续处理</li>
<li>单例模式的本质，更像是中央集权，可以通过穿透层级进行信息的快速传递，减少消耗</li>
<li>适配器模式的本质，就是带面具，和病毒欺骗细胞完成匹配一个意思</li>
</ul>
<p>这样列下去还有很多，术语之所以存在，是为大家提供一个概念上的平台，在平台之上，就可以放开手脚自由发挥，而不是被平台所限制。</p>
<blockquote>
<p>人法地、地法天、天法道、道法自然</p>
</blockquote>
<p>多去观察，多去思考，而不是借由所谓的『权威』代替自己的劳动，才是不断进步的动力。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>那些我们习以为常觉得『自然』的东西，其实才是最重要的『模式』。</p>
<p>（这真是一篇头重脚轻的日志，实在没意思赘述概念了，具体在后面的参考链接都有）</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://design-patterns.readthedocs.org/zh_CN/latest/" target="_blank" rel="external">图说设计模式</a></li>
<li><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="external">Java之美从菜鸟到高手演变之设计模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="external">设计模式</a></li>
<li><a href="http://coolshell.cn/articles/8961.html" target="_blank" rel="external">从面向对象的设计模式看软件设计</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面讲了这么多『玄学』概念，这一次终于回到软件开发的主战场——设计模式！</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
