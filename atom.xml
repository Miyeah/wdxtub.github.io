<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-01-26T04:26:18.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[云计算 第 9 课 Parallel Programming using EMR]]></title>
    <link href="http://wdxtub.com/2016/01/25/cc-10/"/>
    <id>http://wdxtub.com/2016/01/25/cc-10/</id>
    <published>2016-01-26T00:42:38.000Z</published>
    <updated>2016-01-26T04:26:18.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们来看看，如何利用 AWS 来进行并行处理，完成与上节课类似的文本处理任务。</p>
<a id="more"></a>
<hr>
<p>这周的主要任务有下面四个：</p>
<ol>
<li>探索一个大数据集</li>
<li>利用 MapReduce 来处理一个大数据集</li>
<li>使用 EMR(Elastic MapReduce) 在云上运行一个 MapReduce 工作</li>
<li>理解使用诸如 MapReduce 这样的框架来处理大数据的优势</li>
</ol>
<p>注意！EMR 非常贵！所以从小的数据集开始。有两个部分要收钱：per-instance EMR 费用和实际的  EC2 实例费用。使用竞价实例来减小第二部分的花费。</p>
<blockquote>
<p>先使用 WordCount 的例子来熟悉如何设置 cluster。</p>
</blockquote>
<p>这次的的限额是 <code>$15</code>，大概就是有 2 次跑全数据的测试。</p>
<p>任务和上一周的类似，用上个月的维基百科页面访问的数据来进行分析。我们先从上个 project 所做的 filtering 开始，然后把所有的 2015 年 12 月的页面访问数据聚合起来。取出那些最重要的记录并输出到一个小的输出文件中，然后做一些处理来得到真正有用的信息。</p>
<p>上一次我们顺序处理了一个单一文件，但是没办法回答以下这些问题：</p>
<ul>
<li>2015 年 12 月最受欢迎的页面是哪个</li>
<li>某个页面在某一天得到了多少点击</li>
</ul>
<p>如果想要回答这两个问题，我们必须：</p>
<ul>
<li>把所有的访问次数聚合起来，并且</li>
<li>对每个我们感兴趣的文章，生成每天的页面访问时间轴</li>
</ul>
<p>为了处理这么大的一个数据集（压缩后 65 GB），我们会设置一个 Elastic MapReduce 工作来完成。需要写简单的 Map 和 Reduce 函数/程序。</p>
<p>开始之前，最好先弄明白 <a href="https://aws.amazon.com/elasticmapreduce/pricing/" target="_blank" rel="external">EMR 怎么收费</a>。</p>
<blockquote>
<p>别忘了打上 Project: 1.2 的标签</p>
</blockquote>
<h2 id="Introduction_to_MapReduce"><a href="#Introduction_to_MapReduce" class="headerlink" title="Introduction to MapReduce"></a>Introduction to MapReduce</h2><p>MapReduce 是用许多机器来进行大数据处理的编程模型。Hadoop 是开源版本的 MapReduce 实现。Hadoop 把 MapReduce 当做一个分析引擎，并使用 Hadoop Distributed File System(HDFS) 来进行存储。HDFS 把数据集分成固定大小的块，分布式存放在不同的节点上。具体要执行的任务可以在不同的机器上并行处理。MapReduce 会把整个大任务分成不同的小的 map 和 reduce 任务。所有的 map 任务都在 map 阶段进行，所有的 reduce 任务都在 reduce 阶段进行。map 阶段可能有 1 个或多个任务，reduce 阶段可以有 0 个或多个 reduce 任务。</p>
<p><img src="/images/14537775895092.jpg" alt="MapReduce 概览"></p>
<p>上图</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们来看看，如何利用 AWS 来进行并行处理，完成与上节课类似的文本处理任务。</p>]]>
    
    </summary>
    
      <category term="AWS" scheme="http://wdxtub.com/tags/AWS/"/>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="EMR" scheme="http://wdxtub.com/tags/EMR/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="文本处理" scheme="http://wdxtub.com/tags/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 习题课 2 不同架构风格应用]]></title>
    <link href="http://wdxtub.com/2016/01/24/sad-r2/"/>
    <id>http://wdxtub.com/2016/01/24/sad-r2/</id>
    <published>2016-01-24T14:16:36.000Z</published>
    <updated>2016-01-24T16:38:24.000Z</updated>
    <content type="html"><![CDATA[<p>这次的作业主要是利用课上所学过的各种架构风格来对之前设计的 ATM 来进行不同的理念尝试。</p>
<a id="more"></a>
<hr>
<h2 id="Main_program_and_sub_routines"><a href="#Main_program_and_sub_routines" class="headerlink" title="Main program and sub routines"></a>Main program and sub routines</h2><p>这个风格实际上跟程序设计的思路很像，就是利用顺序、分支和循环来构建整个系统的逻辑，具体的设计主要就是根据 ATM 所需要执行的事务，合并公共部分，再利用分发机制由主程序切换到子任务，完成后再返回后续处理，设计如下：</p>
<p><img src="/images/14536454405819.jpg" alt=""></p>
<h2 id="Object_Oriented"><a href="#Object_Oriented" class="headerlink" title="Object Oriented"></a>Object Oriented</h2><p>面向对象的设计就和上周的作业差不多了，实际上就是每个组件能够独立完成需要这个组件参与的行动，然后组件之间通过过程调用来进行联系，具体如下：</p>
<p><img src="/images/14536455334542.jpg" alt=""></p>
<h2 id="Virtual_machines"><a href="#Virtual_machines" class="headerlink" title="Virtual machines"></a>Virtual machines</h2><p>虚拟机实际上就是分层风格，不同层次之间通过 API 进行通信。那么对于 ATM 来说，一个可能的分层模型就是每一层暴露给下一层的都是一个统一的标准化的操作，具体如下：</p>
<p><img src="/images/14536462486833.jpg" alt=""></p>
<h2 id="Client_Server"><a href="#Client_Server" class="headerlink" title="Client Server"></a>Client Server</h2><p>设计的逻辑其实和上面的虚拟机比较类似，只是把整个具体操作分离成了服务端与客户端。其中客户端负责做一些简单的验证和计算，服务端通过更加强大的硬件系统保证一致性。ATM 机的设计其实天然符合这种架构，如下：</p>
<p><img src="/images/14536470725789.jpg" alt=""></p>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC 模型其实不算特别适合 ATM 机，因为本身来说，显示的状态和内容有限，而且由于数据和逻辑紧密联系，分开来其实会带来一些不安全的因素，但是也是可以来尝试用这种架构来设计的，如下：</p>
<p><img src="/images/14536475501848.jpg" alt=""></p>
<h2 id="Batch_Sequence"><a href="#Batch_Sequence" class="headerlink" title="Batch Sequence"></a>Batch Sequence</h2><p>这个架构风格和一开始根据事务流程，有些类似，差别在于这个的设计重点在于数据的流动，然后根据数据的流动方向来设计对应的逻辑和步骤，具体如下：</p>
<p><img src="/images/14536477765273.jpg" alt=""></p>
<h2 id="Pipe_and_filter"><a href="#Pipe_and_filter" class="headerlink" title="Pipe and filter"></a>Pipe and filter</h2><p>这种模式实际上不大适合 ATM 机的交互，因为 ATM 需要在每个步骤都由用户确定来保证安全性，如果硬要用这种模式，就是用户一开始输入所有的内容，然后进行自动流程处理，如下：</p>
<p><img src="/images/14536483943938.jpg" alt=""></p>
<h2 id="Blackboard"><a href="#Blackboard" class="headerlink" title="Blackboard"></a>Blackboard</h2><p>Blackboard 的模式实际上跟 Client Server 有点类似，通过统一的数据访问接口，由 Blackboard 进行中心管理和流程控制，实话说不是特别适合 ATM，一个可能的设计如下：</p>
<p><img src="/images/14536489292256.jpg" alt=""></p>
<h2 id="Rule_Based__26amp_3B_MapReduce"><a href="#Rule_Based__26amp_3B_MapReduce" class="headerlink" title="Rule Based &amp; MapReduce"></a>Rule Based &amp; MapReduce</h2><p>这两种都不太适合 ATM 的设计，原因如下：</p>
<ul>
<li>基于规则的需要逻辑推理引擎，既然是推理，就有出错的可能，对于银行业务来说这是不允许的</li>
<li>MapReduce 是一个分布式计算框架，我没有特别想明白这个和 ATM 架构有什么太大的联系</li>
</ul>
<h2 id="Interpreter__26amp_3B_Mobile_Code"><a href="#Interpreter__26amp_3B_Mobile_Code" class="headerlink" title="Interpreter &amp; Mobile Code"></a>Interpreter &amp; Mobile Code</h2><p>这两种同样不算特别适合 ATM，主要是设计思想的问题，无论是 interpreter 还是 mobile code，强调的都是灵活性。那么对于 ATM 来说，如果要排序的话，灵活性可能是最后一位的。因为灵活的同时不可避免就不太安全。</p>
<p>至于 Mobile Code，如果 mobile 一段恶意代码，显然要出大事，所以几乎不会被考虑。</p>
<h2 id="Peer_to_peer"><a href="#Peer_to_peer" class="headerlink" title="Peer to peer"></a>Peer to peer</h2><p>这个模式在 ATM 的架构中也不算太合适，因为如果按照点对点的设计，那么一端是 ATM，另一端是银行，但是对于很多 ATM 来说，因为一端必须是银行，所以就变成了类似 Client Server 架构了。</p>
<h2 id="C2"><a href="#C2" class="headerlink" title="C2"></a>C2</h2><p>基本的思路是通过事件来进行各个组件的连接和交互，简单来说如下：</p>
<p><img src="/images/14536519165284.jpg" alt=""></p>
<h2 id="CORBA"><a href="#CORBA" class="headerlink" title="CORBA"></a>CORBA</h2><p>这个架构的目标主要是兼容各种平台各种平台，因此也带来了很多复杂性。ATM 还是一个比较需要稳定，也不会有太多变化，所以不是特别适合。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这一课的主要目的是自己动手尝试设计不同的架构风格，学习就是先不要管对错，试试再说，可以慢慢修正嘛。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这次的作业主要是利用课上所学过的各种架构风格来对之前设计的 ATM 来进行不同的理念尝试。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="习题" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="风格" scheme="http://wdxtub.com/tags/%E9%A3%8E%E6%A0%BC/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 13 课 总结]]></title>
    <link href="http://wdxtub.com/2016/01/23/programmer-startline-13/"/>
    <id>http://wdxtub.com/2016/01/23/programmer-startline-13/</id>
    <published>2016-01-23T22:48:13.000Z</published>
    <updated>2016-01-24T14:17:59.000Z</updated>
    <content type="html"><![CDATA[<p>最后一节课写点感想，除了鸡汤就是情怀。</p>
<a id="more"></a>
<hr>
<p>今天暴雪，在雪中跑了几步，满是有劲没地方使的感觉，相信这也是从学校到社会转变的必经之路。一味用蛮力，哪怕脚步再快，进两步退一步，也是事倍功半。</p>
<p>比较好的做法是，先撒盐，看清路了，再一路向前。</p>
<p>所以这个系列，虽然列出了很多题目，但是题目本身并不重要，重要的是启发思路，而不是把答案背下来，毕竟真正有用的，是解决问题的能力。</p>
<p>去弄懂问题背后的原因，或者说组成问题本身的概念，往往有助于去真正理解问题，进而去解决问题。</p>
<p>有一类问题，比如说这个和那个哪个比较好。这类问题其实我是不愿意回答的。一来，怎么样才是『好』，不同人不同的立场，自然有不同的看法，二来，我的判断是基于自己的实际情况做出的，即使客观，程度也有限，我能做的可能是给出几个思考的角度，具体的思考过程，是谁也不能代替的。</p>
<p>遇到不懂的问题，一定要弄明白自己到底是哪里不懂，这个可能比问题本身更重要，因为这些『卡壳』的地方，往往是自己思维的误区盲区，只有看见，才能跨过去，进而解决许多甚至都还没有遇到的问题。</p>
<p>行文匆忙，定有不少疏漏重复之处，还请大家睁大双眼仔细分辨。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最后一节课写点感想，除了鸡汤就是情怀。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="总结" scheme="http://wdxtub.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 12 课 其他知识]]></title>
    <link href="http://wdxtub.com/2016/01/23/programmer-startline-12/"/>
    <id>http://wdxtub.com/2016/01/23/programmer-startline-12/</id>
    <published>2016-01-23T22:48:09.000Z</published>
    <updated>2016-01-24T02:26:19.000Z</updated>
    <content type="html"><![CDATA[<p>这一章包括剩余一些比较基本的常识性知识，具体可能是以聊天的形式来进行交流，关键就在于理解，不要死记硬背。其实计算机学科的各种概念联系都比较紧密，梳理清晰自然就记住了。</p>
<a id="more"></a>
<hr>
<h2 id="u7F51_u7EDC"><a href="#u7F51_u7EDC" class="headerlink" title="网络"></a>网络</h2><p>计算机之间的交互模型通常是指Open Systems Interconnection model (OSI)，该模型将网络通信系统抽象成了七层</p>
<h3 id="u8DEF_u7531"><a href="#u8DEF_u7531" class="headerlink" title="路由"></a>路由</h3><p>从用户角度来看，路由(Routing)是指将数据从一个用户终端，通过网络节点(例如路由器，交换机等)，发送到另一个用户节点的过程。理论上说，对于一个拥有多个节点的拓扑网络而言，路由是指在Network Layer(OSI model的第三层)，将数据包(data packet)从一个节点以最优路径发送到目标节点的实现方法。其核心包括：如何获得邻近节点的信息，如何估计链路质量，如何寻址，如何构建网络拓扑结构“等等。 通过路由器之间的路由协议(routing protocol)，可以实现两个网络节点之间信息(包括网络域名，邻近节点，链路质量等)的交换和散布，通过不断重复该过程，每个节点都会获得足够多关于所在网络的拓扑信息。当有数据包需要传送时，路由器再通过路由算法(routing algorithm)计算传递当前数据包的最优路径，并把数据包发送给下一个邻近节点。许多路由算法基于图理论，实现了最小生成树，最短路径等等经典的拓扑算法。关于路由算法的进一步讨论，请参考“工具箱”中提到的参考教材。</p>
<p>网络中，所谓的地址是指IP地址，IPv4规定利用32bits作为IP地址。但随着网络设备的增多，IPv4已经不能满足人们的需求，故互联网逐渐向IPv6进行演进，IPv6利用128bits作为IP地址。</p>
<p>事实上，直观而言，network routing的过程就相当于传统意义上的邮包寄送，IP地址可以类比于邮政编码，路由器就相当于邮局，通过目的地邮政编码与邮局系统中的递送路径进行比较，由此确定下一步应该把当前包裹传递到哪里。</p>
<h3 id="u5E38_u7528_u7F51_u7EDC_u7EDF_u8BA1_u6307_u6807"><a href="#u5E38_u7528_u7F51_u7EDC_u7EDF_u8BA1_u6307_u6807" class="headerlink" title="常用网络统计指标"></a>常用网络统计指标</h3><p>衡量网络质量通常有下面两个指标：</p>
<p>1) 带宽/速率(Bandwidth/Rate)</p>
<p>所谓的带宽是指一个网络节点能以多快的速度将数据接收／发送出去，单位是bits per second(bps)。对于对实时性要求不高的数据，例如下载等，带宽是影响用户体验的主要因素。两个终端节点之间的带宽由路径中所有节点的最小带宽决定。同时，终端的数据发送速度不应该超过当前的上载带宽，否则会对网络造成压力导致拥堵(congestion)。</p>
<p>2) One-way Delay / Round Trip Time (RTT)</p>
<p>One-way Delay用以衡量网络的延迟。假设在时间点A从一个节点发送数据到另一个节点，目的地节点在时间点B收到数据，则两个时间点之差即为One-way Delay。类似地，RTT则是数据完成一个Round Trip回到始发节点的时间差，一般RTT可以近似估计为One-way Delay的两倍。对于网络会议，IP电话等等，延迟是影响用户体验的主要因素。延迟可能是由网络中某个节点处理数据速度慢，突然有大规模数据需要传输，或者某条链路不断重传数据造成的。延迟与带宽有一定的相关性，但没有必然联系：可以类比某个路口，假设每秒可以有一辆车通过该路口，但现在突然来了100辆车，路口的通过效率并没有变化(即带宽不变)，但每辆车通过路口的等待时间却变长了(延迟增加)。</p>
<h3 id="Transmission_Control_Protocol_uFF0CTCP"><a href="#Transmission_Control_Protocol_uFF0CTCP" class="headerlink" title="Transmission Control Protocol，TCP"></a>Transmission Control Protocol，TCP</h3><p><strong>Reliable Protocol</strong></p>
<p>TCP是一种可靠的传输协议，即在网络条件正常的情况下，TCP协议能够保证接收端收到所有数据，并且接收到的数据顺序与发送端一致。TCP通过在发送端给每个数据包分配单调递增的sequence number，以及在接受端发送ACK(acknowledgement)实现可靠传输。每个发送的数据包都包含序列号，当接收端收到数据包时，会发送ACK告诉发送端当前自己期待的下一个序列号是多少。例如，发送端分别发送了序列号为99，100，101，102的四个数据包，接收端收到数据包99后，会发送ACK100，意味着接收端期待下一个数据包编号100。如果由于某些原因，数据包100没有到达接收端，但数据包101，102到达了，那么接收端会继续发送ACK100。当发送端发现当前发送的数据包编号超过了100，但接收端仍然期望收到100，那么发送端就会重新发送数据包100。“如果接收端收到了重新发送的数据包100，那么接收端会回复ACK103，继续进行剩下的数据传输，并且把数据包99，100，101，102按顺序传递给上一层。</p>
<p><strong>Flow Control</strong></p>
<p>TCP使用了end-to-end flow control以避免发送端发送数据过快导致接收端无法处理。TCP采用了滑动窗口(sliding window)实现流量控制。接收端通过ACK告诉发送端自己还能够接收多少数据，发送端不能发送超过该值的数据量。当接收端返回的窗口大小为0时，发送端停止发送数据，直到窗口大小被更新。由于ACK是由发送端发送的数据触发，可能接收端窗口已经打开，但是由于发送端已经停止发送，故接收端没有机会通过ACK告知发送端新的窗口大小，在这种情况下会造成死锁。在实际实现中，发送端会设置一个timer，如果timer到期，发送端会尝试发送小数据包，以触发接收端的ACK。</p>
<p><strong>Congestion Control</strong></p>
<p>为了控制传输速度防止堵塞网络，并且在网络容量允许的范围内尽可能多地传输数据，TCP引入congestion control，用以判断当前的网络负荷，并且调整传输速率。TCP通常采用additive increase，multiplicative decrease的算法，即如果按时收到对应的ACK，则下一次传输速率线性增加，否则则视为发生了网络堵塞，下一次传输的比特数折半。所谓的“按时”基于RTT：发送端会估计RTT，并且期望当数据包发送以后，在RTT时间内收到对应的ACK。“现代TCP需要分别实现Slow-start，congestion avoidance，fast retransmit和fast recovery，以达到最高的效率。具体请参考“工具箱”给出的资料。</p>
<h3 id="User_Datagram_Protocol_uFF0CUDP"><a href="#User_Datagram_Protocol_uFF0CUDP" class="headerlink" title="User Datagram Protocol，UDP"></a>User Datagram Protocol，UDP</h3><p>相比于TCP，UDP简单许多：连接建立时不需要经过类似于TCP的三次握手，只需要知道接收端的IP和端口，发送端就可以直接发送数据。同时，UDP也没有ACK，flow control和congestion control，故UDP本身不能保证传输是可靠的。由于UDP本身只负责把数据传输到目的地，故可扩展性比较强。有些应用可以实现基于UDP 的特定算法，使得传输效率高于TCP。例如，当发生丢包时，TCP会重传该数据包，但该操作增加了传输延时。对于某些实时性要求较高的应用，可能继续传输新的数据更为重要，故基于UDP的传输方式可以更好地满足该要求。</p>
<p>通常而言，如果需要满足可靠性，有序接收，自适应带宽等要求，应该优先考虑TCP，因为其协议本身确保了这点。如果对实时性要求较高，或者应用需要特定的网络传输特性，则可以实现基于UDP的传输协议。往往，这样的协议需要实现congestion control，flow control，retransmission等机制，故通常情况下都可以直接采用TCP以减小开发成本。</p>
<h2 id="u6570_u636E_u5E93"><a href="#u6570_u636E_u5E93" class="headerlink" title="数据库"></a>数据库</h2><p>事务的概念来自于两个独立的需求：并发数据库访问，系统错误恢复。</p>
<p>一个事务是可以被看作一个单元的一系列SQL语句的集合。</p>
<h3 id="u4E8B_u52A1_u7684_u7279_u6027_uFF08ACID_uFF09"><a href="#u4E8B_u52A1_u7684_u7279_u6027_uFF08ACID_uFF09" class="headerlink" title="事务的特性（ACID）"></a>事务的特性（ACID）</h3><ul>
<li>A, atomacity 原子性 事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。</li>
<li>C, consistency 一致性。事务将数据库从一种一致状态转变为下一种一致状态。也就是说，事务在完成时，必须使所有的数据都保持一致状态（各种 constraint 不被破坏）。</li>
<li>I, isolation 隔离性 由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。换句话说，一个事务的影响在该事务提交前对其他事务都不可见。</li>
<li>D, durability 持久性。事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。</li>
</ul>
<h3 id="u4E8B_u52A1_u7684_u9694_u79BB_u7EA7_u522B"><a href="#u4E8B_u52A1_u7684_u9694_u79BB_u7EA7_u522B" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>如果不对数据库进行并发控制，可能会产生异常情况：</p>
<ol>
<li>脏读(Dirty Read)<ul>
<li>当一个事务读取另一个事务尚未提交的修改时，产生脏读。</li>
<li>同一事务内不是脏读。 一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险的，因为很可能所有的操作都被回滚，也就是说读取出的数据其实是错误的。</li>
</ul>
</li>
<li>非重复读(Nonrepeatable Read) 一个事务对同一行数据重复读取两次，但是却得到了不同的结果。同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生非重复读。</li>
<li>幻像读(Phantom Reads) 事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。<ul>
<li>当对某行执行插入或删除操作，而该行属于某个事务正在读取的行的范围时，会发生幻像读问题。</li>
</ul>
</li>
<li>丢失修改(Lost Update)<ul>
<li>第一类：当两个事务更新相同的数据源，如果第一个事务被提交，第二个却被撤销，那么连同第一个事务做的更新也被撤销。</li>
<li>第二类：有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。</li>
</ul>
</li>
</ol>
<p>为了兼顾并发效率和异常控制，在标准SQL规范中，定义了4个事务隔离级别，（ Oracle 和 SQL Server 对标准隔离级别有不同的实现 ）</p>
<ol>
<li>未提交读(Read Uncommitted)<ul>
<li>直译就是”读未提交”，意思就是即使一个更新语句没有提交，但是别的事务可以读到这个改变。</li>
<li>Read Uncommitted允许脏读。</li>
</ul>
</li>
<li>已提交读(Read Committed)<ul>
<li>直译就是”读提交”，意思就是语句提交以后，即执行了 Commit 以后别的事务就能读到这个改变，只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别。</li>
<li>Read Commited 不允许脏读，但会出现非重复读。</li>
</ul>
</li>
<li>可重复读(Repeatable Read)：<ul>
<li>直译就是”可以重复读”，这是说在同一个事务里面先后执行同一个查询语句的时候，得到的结果是一样的。</li>
<li>Repeatable Read 不允许脏读，不允许非重复读，但是会出现幻象读。</li>
</ul>
</li>
<li>串行读(Serializable)<ul>
<li>直译就是”序列化”，意思是说这个事务执行的时候不允许别的事务并发执行。完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。</li>
<li>Serializable 不允许不一致现象的出现。</li>
</ul>
</li>
</ol>
<h3 id="u4E8B_u52A1_u9694_u79BB_u7684_u5B9E_u73B0_u2014_u2014_u9501"><a href="#u4E8B_u52A1_u9694_u79BB_u7684_u5B9E_u73B0_u2014_u2014_u9501" class="headerlink" title="事务隔离的实现——锁"></a>事务隔离的实现——锁</h3><ol>
<li>共享锁(S锁)<ul>
<li>用于只读操作(SELECT)，锁定共享的资源。共享锁不会阻止其他用户读，但是阻止其他的用户写和修改。</li>
</ul>
</li>
<li>更新锁(U锁)<ul>
<li>用于可更新的资源中。防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。</li>
</ul>
</li>
<li>独占锁(X锁，也叫排他锁)<ul>
<li>一次只能有一个独占锁用在一个资源上，并且阻止其他所有的锁包括共享缩。写是独占锁，可以有效的防止“脏读”。</li>
</ul>
</li>
</ol>
<p>Read Uncommited 如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。</p>
<p>Read Committed 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。可以通过“瞬间共享读锁”和“排他写锁”实现。</p>
<p>Repeatable Read 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。可以通过“共享读锁”和“排他写锁”实现。</p>
<p>Serializable 读加共享锁，写加排他锁，读写互斥。</p>
<h3 id="u7D22_u5F15"><a href="#u7D22_u5F15" class="headerlink" title="索引"></a>索引</h3><p>数据库创建索引能够大大提高系统的性能。</p>
<ol>
<li>通过创建唯一性的索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度，这也使创建索引的最主要的原因。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著的减少查询中查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ol>
<p>增加索引也有许多不利的方面。</p>
<ol>
<li>创建索引和维护索引需要消耗时间，这种时间随着数量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占据数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要额空间就会更大。</li>
<li>当对表中的数据进行增加，删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ol>
<p>应该对如下的列建立索引</p>
<ol>
<li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构。</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度。</li>
<li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的。</li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li>在经常使用在where子句中的列上面创建索引，加快条件的判断速度。</li>
</ol>
<p>有些列不应该创建索引</p>
<ol>
<li>在查询中很少使用或者作为参考的列不应该创建索引。</li>
<li>对于那些只有很少数据值的列也不应该增加索引（比如性别，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度）。</li>
<li>对于那些定义为text，image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li>
<li>当修改性能远远大于检索性能时，不应该创建索引，因为修改性能和检索性能是矛盾的。</li>
</ol>
<p>创建索引的方法：直接创建和间接创建（在表中定义主键约束或者唯一性约束时，同时也创建了索引）。</p>
<p>索引的特征：</p>
<p>唯一性索引和复合索引。唯一性索引保证在索引列中的全部数据是唯一的，不会包含冗余数据。复合索引就是一个索引创建在两个列或者多个列上。可以减少一在一个表中所创建的索引数量。</p>
<h2 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h2><p>在面试软件开发的过程中，面试官可能也会询问关于软件开发流程以及测试方法相关的问题。在大多数互联网公司，许多部门不一定配有专门的QA(Quality Assurance)，在这种情况下，程序员本身需要对自己开发的模块和系统进行测试。另一方面，程序员在开发过程中测试自己的程序也是非常好的习惯，这样可以确保开发效率。基于上述原因，面试软件开发职位但遇到测试相关的问题并不少见。</p>
<h3 id="u6D4B_u8BD5_u73B0_u5B9E_u4E16_u754C_u7684_u7269_u4F53_u3001_u8F6F_u4EF6_u6216_u51FD_u6570"><a href="#u6D4B_u8BD5_u73B0_u5B9E_u4E16_u754C_u7684_u7269_u4F53_u3001_u8F6F_u4EF6_u6216_u51FD_u6570" class="headerlink" title="测试现实世界的物体、软件或函数"></a>测试现实世界的物体、软件或函数</h3><p>三者并无本质的差别，问题的核心均在于：测试对象在不同的输入下，能否实现预计的功能，提供恰当的输出。 一般情况下，总是需要考虑以下几个方面，以全面测试对象对于不同类型输入的效果：</p>
<p>(1) 常规情况(Normal cases)</p>
<p>输入不同类型的合法数据，主要用以判断对象的功能性：在给定输入的情况下能否给出期望的输出，由此判断功能的实现是否正确。比如，测试银行账户的转账功能：假设账户中有1000元，可以输入100，2000等并判断余额及转出钱数是否符合期望。</p>
<p>(2) 极端情况(Extreme cases)</p>
<p>测试一些边界条件或极端情况。所谓的极端情况包括多用户或多线程情况下频繁地访问／更新数据。比如，继续测试银行账户的转账功能：假设账户中有1000元，可以测试边界条件，取出1000元等。或者测试极端情况，假设用户开了多个页面，并在每个页面上几乎同时都尝试转出1000元，或者用户通过ATM机和手机APP同时进行转账操作等。</p>
<p>(3) 非法情况(Invalid case)</p>
<p>主要测试用户输入非法数据时系统不会崩溃，并且能够给出恰当的反馈。比如，测试银行账户的转账功能：当用户输入大于账户余额的数字时，或者当接收人账户错误时，系统能否给出错误提示等。</p>
<h3 id="u6545_u969C_u6392_u9664_28Troubleshooting_29"><a href="#u6545_u969C_u6392_u9664_28Troubleshooting_29" class="headerlink" title="故障排除(Troubleshooting)"></a>故障排除(Troubleshooting)</h3><p>另一大类的常见问题是给出一个有问题的测试现象，让面试者判断问题出现在哪里。对于这类问题，首先考虑测试对象由生成，到运行，到产生最终结果的完整流程，其次判断每一步执行了什么，需要依赖哪些参数，该步骤的异常是否会导致最终的测试现象，并且考虑如何验证自己的判断。 例如，测试用户无法访问你开发的网站。首先考虑主要流程，简述如下：用户连接到网络，发送HTTP请求到网站，网站发送数据包给用户，用户浏览器显示页面。在此例中，每一步都有可能导致无法访问网站的情况，具体描述如下：</p>
<p>(1) 用户连接到网络：这一步用户需要获得有效的IP，获取访问互联网的权限。需要依赖用户的网卡是否工作正常，是否能够被分配到有效的IP，是否能够从路由器或者服务器获得互联网访问权限等等。检验方式可以是：可以打开终端用ping命令，尝试建立与大型网站的连接。或者直接用浏览器尝试访问其他大型网站。如果不能建立与其他网站的连接，则网络接入有问题。</p>
<p>(2) 发送HTTP请求到网站：用户首先会通过DNS获取服务器地址，然后发送HTTP请求到对应的IP。需要依赖用户能否正确获取网站IP地址。检验方式可以是：在用户端利用抓包软件，例如WireShark，tcpdump等，观察是否有HTTP请求发送到网站服务器。如果没有发送HTTP请求或目的地IP有问题，则DNS可能有错。</p>
<p>(3) 网站发送数据包给用户：这一步需要网站接收到HTTP请求，并且将对应数据传回给用户。需要依赖网站能否收到HTTP请求以及对于HTTP请求的处理是否正确。检验方式可以是：在服务器端通过log判断是否有新用户接入，接入请求的处理是否正确，以及发送给用户的数据是什么。如果网站没有收到请求，则服务器端的网络可能有问题。如果服务器无法处理HTTP请求或抛出异常，则服务器的实现可能有问题。</p>
<p>(4) 用户浏览器显示页面： 这一步需要用户接收到网站发回的数据，浏览器解析数据并显示页面。需要依赖于用户能否收到数据，以及收到的数据是否能够被浏览器正确解析及显示。检验方式可以是：在用户端利用抓包软件，观察是否有来自服务器的数据。一般来说，如果用户用的是商用浏览器，即能够正确解析数据。故如果能收到服务器数据但是不能正常显示，我们可以认为服务器的数据有问题。</p>
<h3 id="u6D4B_u8BD5_u7684_u65B9_u6CD5"><a href="#u6D4B_u8BD5_u7684_u65B9_u6CD5" class="headerlink" title="测试的方法"></a>测试的方法</h3><p><strong>AB Testing</strong></p>
<p>AB测试是一种对比测试方案。测试人员对于不同用户随机生成两种方案，例如，某些用户看到的网页按钮是圆形的，其他用户看到的网页按钮是方形的。通过用户对于不同测试方案的反应，来决定最终部署哪种方案。具体请参考：<br><a href="http://en.wikipedia.org/wiki/A/B_testing" target="_blank" rel="external">http://en.wikipedia.org/wiki/A/B_testing</a></p>
<p><strong>Black Box Testing</strong></p>
<p>黑箱测试主要用于测试程序的功能，而不是内部结构或运作。测试者秩序知道输入以及对应的输出，就可以生成测试数据。黑箱测试的目的在于快速检测程序的功能性。特别地，黑箱测试还应该包括非法的输入数据，以确保程序不会崩溃。</p>
<p><strong>White Box Testing</strong></p>
<p>与黑箱测试相对，白箱测试主要用于测试程序的内部结构或运作。测试人员需要从程序设计的角度生成测试案例：输入测试数据并验证程序按照既定的流程执行。</p>
<h3 id="u5DE5_u4E1A_u754C_u6D4B_u8BD5_u6D41_u7A0B"><a href="#u5DE5_u4E1A_u754C_u6D4B_u8BD5_u6D41_u7A0B" class="headerlink" title="工业界测试流程"></a>工业界测试流程</h3><p><strong>Unit Test</strong></p>
<p>优良的软件设计强调模块化，即模块之间通过API进行交互，每个模块负责实现相对独立的功能。单元测试的目的在于对于每个模块设计相应的测试数据，用以检验模块的功能。通常，单元测试采用黑箱测试，通过运行脚本完成。测试人员将测试数据输入脚本，将输出结果与期望的输出数据进行比较。单元测试不仅仅可以用于新模块的开发，还可以用于对于已有模块的更新，维护。对于模块的每次更改都应该运行相应的单元测试以确保功能的完整性。</p>
<p><strong>Alpha Test</strong></p>
<p>Alpha测试通常是阶段性开发完成后开始进行。主要是面向内部开发人员，在模拟环境中输入模拟的数据进行测试，以验证系统符合使用者以及设计者的需求。</p>
<p><strong>Beta Test</strong></p>
<p>当Alpha阶段完成后，可以进入由公众参与的beta测试阶段。Beta测试通常使用真实的运行环境，并且使用实际数据进行测试，以确认系统效率。测试的主要目的在于进一步测试及完善功能。</p>
<h2 id="u64CD_u4F5C_u7CFB_u7EDF"><a href="#u64CD_u4F5C_u7CFB_u7EDF" class="headerlink" title="操作系统"></a>操作系统</h2><p>大部分互联网公司的软件开发职位面试可能不会直接涉及这一层面的知识，但并不意味着这部分知识不重要。对于计算机底层实现的深入理解，能帮助你了解计算机的运行原理，能够更好地设计高效的架构，并且有助于调试、判断错误。特别地，对于多线程的理解尤为重要：现今的程序架构都需要并发处理，如何协调不同线程之间的分工协作，避免死锁、同步出错等等问题，是程序员应当具备的技能。对于后端工程师而言，良好的操作系统知识基础更是深刻理解并实现复杂分布式系统的前提条件。</p>
<h3 id="u8FDB_u7A0B"><a href="#u8FDB_u7A0B" class="headerlink" title="进程"></a>进程</h3><p>进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。</p>
<p>进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。</p>
<h4 id="u8FDB_u7A0B_u7684_u57FA_u672C_u72B6_u6001"><a href="#u8FDB_u7A0B_u7684_u57FA_u672C_u72B6_u6001" class="headerlink" title="进程的基本状态"></a>进程的基本状态</h4><ol>
<li>等待态：等待某个事件的完成；</li>
<li>就绪态：等待系统分配处理器以便运行；</li>
<li>运行态：占有处理器正在运行。</li>
<li>运行态→等待态 往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。</li>
</ol>
<p>等待态→就绪态 则是等待的条件已满足，只需分配到处理器后就能运行。</p>
<p>运行态→就绪态 不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。</p>
<p>就绪态→运行态 系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态</p>
<h3 id="u8FDB_u7A0B_u8C03_u5EA6"><a href="#u8FDB_u7A0B_u8C03_u5EA6" class="headerlink" title="进程调度"></a>进程调度</h3><h4 id="u8C03_u5EA6_u79CD_u7C7B"><a href="#u8C03_u5EA6_u79CD_u7C7B" class="headerlink" title="调度种类"></a>调度种类</h4><p>高级、中级和低级调度作业从提交开始直到完成，往往要经历下述三级调度：</p>
<ul>
<li>高级调度：(High-Level Scheduling)又称为作业调度，它决定把后备作业调入内存运行；</li>
<li>低级调度：(Low-Level Scheduling)又称为进程调度，它决定把就绪队列的某进程获得CPU；</li>
<li>中级调度：(Intermediate-Level Scheduling)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。</li>
</ul>
<h4 id="u975E_u62A2_u5360_u5F0F_u8C03_u5EA6_u4E0E_u62A2_u5360_u5F0F_u8C03_u5EA6"><a href="#u975E_u62A2_u5360_u5F0F_u8C03_u5EA6_u4E0E_u62A2_u5360_u5F0F_u8C03_u5EA6" class="headerlink" title="非抢占式调度与抢占式调度"></a>非抢占式调度与抢占式调度</h4><ul>
<li>非抢占式<ul>
<li>分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度进程调度某事件而阻塞时，才把处理机分配给另一个进程。</li>
</ul>
</li>
<li>抢占式<ul>
<li>操作系统将正在运行的进程强行暂停，由调度程序将CPU分配给其他就绪进程的调度方式。</li>
</ul>
</li>
</ul>
<h4 id="u8C03_u5EA6_u7B56_u7565_u7684_u8BBE_u8BA1"><a href="#u8C03_u5EA6_u7B56_u7565_u7684_u8BBE_u8BA1" class="headerlink" title="调度策略的设计"></a>调度策略的设计</h4><p>响应时间: 从用户输入到产生反应的时间</p>
<p>周转时间: 从任务开始到任务结束的时间</p>
<p>CPU任务可以分为交互式任务和批处理任务，调度最终的目标是合理的使用CPU，使得交互式任务的响应时间尽可能短，用户不至于感到延迟，同时使得批处理任务的周转时间尽可能短，减少用户等待的时间。</p>
<h4 id="u8C03_u5EA6_u7B97_u6CD5"><a href="#u8C03_u5EA6_u7B97_u6CD5" class="headerlink" title="调度算法"></a>调度算法</h4><ol>
<li>FIFO或First Come, First Served (FCFS)<ul>
<li>调度的顺序就是任务到达就绪队列的顺序。</li>
<li>公平、简单(FIFO队列)、非抢占、不适合交互式。未考虑任务特性，平均等待时间可以缩短</li>
</ul>
</li>
<li>Shortest Job First (SJF)<ul>
<li>最短的作业(CPU区间长度最小)最先调度。</li>
<li>可以证明，SJF可以保证最小的平均等待时间。</li>
<li>Shortest Remaining Job First (SRJF)</li>
<li>SJF的可抢占版本，比SJF更有优势。</li>
<li>SJF(SRJF): 如何知道下一CPU区间大小？根据历史进行预测: 指数平均法。</li>
</ul>
</li>
<li>优先权调度<ul>
<li>每个任务关联一个优先权，调度优先权最高的任务。</li>
<li>注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象。</li>
<li>FCFS是RR的特例，SJF是优先权调度的特例。这些调度算法都不适合于交互式系统。</li>
</ul>
</li>
<li>Round-Robin(RR)<ul>
<li>设置一个时间片，按时间片来轮转调度（“轮叫”算法）</li>
<li>优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多；</li>
<li>如何确定时间片？</li>
<li>时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为FCFS。</li>
</ul>
</li>
<li>多级队列调度<ul>
<li>按照一定的规则建立多个进程队列</li>
<li>不同的队列有固定的优先级（高优先级有抢占权）</li>
<li>不同的队列可以给不同的时间片和采用不同的调度方法</li>
<li>存在问题1：没法区分I/O bound和CPU bound；</li>
<li>存在问题2：也存在一定程度的“饥饿”现象；</li>
</ul>
</li>
<li>多级反馈队列<ul>
<li>在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务。</li>
<li>可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”。</li>
<li>最通用的调度算法，多数OS都使用该方法或其变形，如UNIX、Windows等。</li>
</ul>
</li>
</ol>
<h3 id="u8FDB_u7A0B_u540C_u6B65"><a href="#u8FDB_u7A0B_u540C_u6B65" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="u4E34_u754C_u8D44_u6E90_u4E0E_u4E34_u754C_u533A"><a href="#u4E34_u754C_u8D44_u6E90_u4E0E_u4E34_u754C_u533A" class="headerlink" title="临界资源与临界区"></a>临界资源与临界区</h4><p>在操作系统中，进程是占有资源的最小单位（线程可以访问其所在进程内的所有资源，但线程本身并不占有资源或仅仅占有一点必须资源）。但对于某些资源来说，其在同一时间只能被一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源。典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等(如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题)。</p>
<p>对于临界资源的访问，必须是互斥进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。而进程内访问临界资源的代码被成为临界区。</p>
<p>对于临界区的访问过程分为四个部分：</p>
<ol>
<li>进入区:查看临界区是否可访问，如果可以访问，则转到步骤二，否则进程会被阻塞</li>
<li>临界区:在临界区做操作</li>
<li>退出区:清除临界区被占用的标志</li>
<li>剩余区：进程与临界区不相关部分的代码</li>
</ol>
<p>解决临界区问题可能的方法：</p>
<ol>
<li>一般软件方法</li>
<li>关中断方法</li>
<li>硬件原子指令方法</li>
<li>信号量方法</li>
</ol>
<h3 id="u7EBF_u7A0B"><a href="#u7EBF_u7A0B" class="headerlink" title="线程"></a>线程</h3><p>线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。</p>
<p>线程具有以下属性：</p>
<ol>
<li>轻型实体 线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。TCB包括以下信息：<ul>
<li>线程状态。</li>
<li>当线程不运行时，被保存的现场资源。</li>
<li>一组执行堆栈。</li>
<li>存放每个线程的局部变量主存区。</li>
<li>访问同一个进程中的主存和其它资源。</li>
<li>用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。</li>
</ul>
</li>
<li>独立调度和分派的基本单位。<ul>
<li>在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。</li>
</ul>
</li>
<li>可并发执行。 在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。</li>
<li>共享进程资源。 在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。 线程共享的环境包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</li>
</ol>
<h3 id="u534F_u7A0B"><a href="#u534F_u7A0B" class="headerlink" title="协程"></a>协程</h3><p>协程，又称微线程，纤程。英文名Coroutine。</p>
<p>协程可以理解为用户级线程，协程和线程的区别是：线程是抢占式的调度，而协程是协同式的调度，协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。</p>
<p>使用协程改写生产者-消费者问题：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import <span class="tag">time</span></span><br><span class="line"></span><br><span class="line">def <span class="function"><span class="title">consumer</span><span class="params">()</span></span>:</span><br><span class="line">    r = <span class="string">''</span></span><br><span class="line">    while True:</span><br><span class="line">        n = yield r</span><br><span class="line">        <span class="keyword">if</span> not n:</span><br><span class="line">            return</span><br><span class="line">        <span class="function"><span class="title">print</span><span class="params">(<span class="string">'[CONSUMER] Consuming %s...'</span> % n)</span></span></span><br><span class="line">        <span class="tag">time</span>.<span class="function"><span class="title">sleep</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line">        r = <span class="string">'200 OK'</span></span><br><span class="line"></span><br><span class="line">def <span class="function"><span class="title">produce</span><span class="params">(c)</span></span>:</span><br><span class="line">    c.<span class="function"><span class="title">next</span><span class="params">()</span></span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    while n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="title">print</span><span class="params">(<span class="string">'[PRODUCER] Producing %s...'</span> % n)</span></span></span><br><span class="line">        r = c.<span class="function"><span class="title">send</span><span class="params">(n)</span></span></span><br><span class="line">        <span class="function"><span class="title">print</span><span class="params">(<span class="string">'[PRODUCER] Consumer return: %s'</span> % r)</span></span></span><br><span class="line">    c.<span class="function"><span class="title">close</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    c = <span class="function"><span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="title">produce</span><span class="params">(c)</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到，使用协程不再需要显式地对锁进行操作</p>
<h3 id="u8FDB_u7A0B_vs-__u7EBF_u7A0B"><a href="#u8FDB_u7A0B_vs-__u7EBF_u7A0B" class="headerlink" title="进程 vs. 线程"></a>进程 vs. 线程</h3><p>进程(process)与线程(thread)最大的区别是进程拥有自己的地址空间，某进程内的线程对于其他进程不可见，即进程A不能通过传地址的方式直接读写进程B的存储区域。进程之间的通信需要通过进程间通信(Inter-process communication，IPC)。与之相对的，同一进程的各线程间之间可以直接通过传递地址或全局变量的方式传递信息。</p>
<p>此外，进程作为操作系统中拥有资源和独立调度的基本单位，可以拥有多个线程。通常操作系统中运行的一个程序就对应一个进程。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。相比进程切换，线程切换的开销要小很多。线程于进程相互结合能够提高系统的运行效率。</p>
<p>线程可以分为两类：</p>
<p>一类是用户级线程(user level thread)。对于这类线程，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。在应用程序启动后，操作系统分配给该程序一个进程号，以及其对应的内存空间等资源。应用程序通常先在一个线程中运行，该线程被成为主线“程。在其运行的某个时刻，可以通过调用线程库中的函数创建一个在相同进程中运行的新线程。 用户级线程的好处是非常高效，不需要进入内核空间，但并发效率不高。</p>
<p>另一类是内核级线程(kernel level thread)。对于这类线程，有关线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只能调用内核线程的接口。内核维护进程及其内部的每个线程，调度也由内核基于线程架构完成。内核级线程的好处是，内核可以将不同线程更好地分配到不同的CPU，以实现真正的并行计算。</p>
<p>事实上，在现代操作系统中，往往使用组合方式实现多线程，即线程创建完全在用户空间中完成，并且一个应用程序中的多个用户级线程被映射到一些内核级线程上，相当于是一种折中方案。</p>
<h3 id="u4E0A_u4E0B_u6587_u5207_u6362"><a href="#u4E0A_u4E0B_u6587_u5207_u6362" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>对于单核单线程CPU而言，在某一时刻只能执行一条CPU指令。上下文切换(Context Switch)是一种将CPU资源从一个进程分配给另一个进程的机制。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。</p>
<h3 id="u7CFB_u7EDF_u8C03_u7528"><a href="#u7CFB_u7EDF_u8C03_u7528" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用(System call)是程序向系统内核请求服务的方式。可以包括硬件相关的服务(例如，访问硬盘等)，或者创建新进程，调度其他进程等。系统调用是程序和操作系统之间的重要接口。</p>
<p>在讲系统调用之前，先说下进程的执行在系统上的两个级别：用户级和核心级，也称为用户态和系统态(user mode and kernel mode)。</p>
<p>程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件等，就需要向操作系统发出调用服务的请求，这就是系统调用。</p>
<p>Linux系统有专门的函数库来提供这些请求操作系统服务的入口，这个函数库中包含了操作系统所提供的对外服务的接口。当进程发出系统调用之后，它所处的运行状态就会由用户态变成核心态。但这个时候，进程本身其实并没有做什么事情，这个时候是由内核在做相应的操作，去完成进程所提出的这些请求。</p>
<p>系统调用和中断的关系就在于，当进程发出系统调用申请的时候，会产生一个软件中断。产生这个软件中断以后，系统会去对这个软中断进行处理，这个时候进程就处于核心态了。</p>
<p>那么用户态和核心态之间的区别是什么呢？（以下区别摘至《UNIX操作系统设计》）</p>
<ol>
<li>用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据）。然而，核心态下的进程能够存取内核和用户地址</li>
<li>某些机器指令是特权指令，在用户态下执行特权指令会引起错误</li>
</ol>
<p>对此要理解的一个是，在系统中内核并不是作为一个与用户进程平行的估计的进程的集合，内核是为用户进程运行的。</p>
<h3 id="Semaphore/Mutex"><a href="#Semaphore/Mutex" class="headerlink" title="Semaphore/Mutex"></a>Semaphore/Mutex</h3><p>当用户创立多个线程／进程时，如果不同线程／进程同时读写相同的内容，则可能造成读写错误，或者数据不一致。此时，需要通过加锁的方式，控制核心区域(critical section)的访问权限。对于semaphore而言，在初始化变量的时候可以控制允许多少个线程／进程同时访问一个critical section，其他的线程／进程会被堵塞，直到有人解锁。</p>
<p>Mutex相当于只允许一个线程／进程访问的semaphore。此外，根据实际需要，人们还实现了一种读写锁(read-write lock)，它允许同时存在多个阅读者(reader)，但任何时候至多只有一个写者(writer)，且不能于读者共存。</p>
<p>信号量是一个确定的二元组（s，q），其中s是一个具有非负初值的整形变量，q是一个初始状态为空的队列，整形变量s表示系统中某类资源的数目：</p>
<ul>
<li>当其值 ≥ 0 时，表示系统中当前可用资源的数目</li>
<li>当其值 ＜ 0 时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目</li>
</ul>
<p>除信号量的初值外，信号量的值仅能由P操作和V操作更改，操作系统利用它的状态对进程和资源进行管理</p>
<p><strong>P操作</strong></p>
<p>P 操作记为P(s)，其中s为一信号量，它执行时主要完成以下动作：</p>
<pre><code>s.value = s.value - 1；  /*可理解为占用1个资源，若原来就没有则记帐“欠”1个*/
</code></pre><p>若s.value ≥ 0，则进程继续执行，否则（即s.value &lt; 0），则进程被阻塞，并将该进程插入到信号量s的等待队列s.queue中</p>
<p>说明：实际上，P操作可以理解为分配资源的计数器，或是使进程处于等待状态的控制指令</p>
<p><strong>V操作</strong></p>
<p>V 操作记为V(s)，其中s为一信号量，它执行时，主要完成以下动作：</p>
<pre><code>s.value = s.value + 1；/*可理解为归还1个资源，若原来就没有则意义是用此资源还1个欠帐*/
</code></pre><p>若s.value &gt; 0，则进程继续执行，否则（即s.value ≤ 0）,则从信号量s的等待队s.queue中移出第一个进程，使其变为就绪状态，然后返回原进程继续执行</p>
<p>说明：实际上，V操作可以理解为归还资源的计数器，或是唤醒进程使其处于就绪状态的控制指令</p>
<p>信号量方法实现：生产者 − 消费者互斥与同步控制</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore fullBuffers = 0; /<span class="keyword">*</span>仓库中已填满的货架个数<span class="keyword">*</span>/</span><br><span class="line">semaphore emptyBuffers = BUFFER_SIZE;/<span class="keyword">*</span>仓库货架空闲个数<span class="keyword">*</span>/</span><br><span class="line">semaphore mutex = 1; /<span class="keyword">*</span>生产-消费互斥信号<span class="keyword">*</span>/</span><br><span class="line"></span><br><span class="line">Producer()</span><br><span class="line">&#123;</span><br><span class="line">    while(True)</span><br><span class="line">    &#123;</span><br><span class="line">       /<span class="keyword">*</span>生产产品item<span class="keyword">*</span>/</span><br><span class="line">       emptyBuffers.P();</span><br><span class="line">       mutex.P();</span><br><span class="line">       /<span class="keyword">*</span>item存入仓库buffer<span class="keyword">*</span>/</span><br><span class="line">       mutex.V();</span><br><span class="line">       fullBuffers.V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer()</span><br><span class="line">&#123;</span><br><span class="line">    while(True)</span><br><span class="line">    &#123;</span><br><span class="line">        fullBuffers.P();</span><br><span class="line">        mutex.P();</span><br><span class="line">        /<span class="keyword">*</span>从仓库buffer中取产品item<span class="keyword">*</span>/</span><br><span class="line">        mutex.V();</span><br><span class="line">        emptyBuffers.V();</span><br><span class="line">        /<span class="keyword">*</span>消费产品item<span class="keyword">*</span>/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用pthread实现的生产者－消费者模型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BUFFER_SIZE <span class="number">10</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> buffer[BUFFER_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> consumer, producer;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond_producer, cond_consumer;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consume</span><span class="params">(<span class="keyword">void</span>* _)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"empty buffer, wait producer\n"</span>);</span><br><span class="line">      pthread_cond_wait(&amp;cond_consumer, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"consume a item\n"</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_cond_signal(&amp;cond_producer);</span><br><span class="line">    <span class="comment">//pthread_mutex_unlock(&amp;mutex);</span></span><br><span class="line">  &#125;</span><br><span class="line">  pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">produce</span><span class="params">(<span class="keyword">void</span>* _)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span>(count == BUFFER_SIZE)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"full buffer, wait consumer\n"</span>);</span><br><span class="line">      pthread_cond_wait(&amp;cond_producer, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"produce a item.\n"</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_cond_signal(&amp;cond_consumer);</span><br><span class="line">    <span class="comment">//pthread_mutex_unlock(&amp;mutex);</span></span><br><span class="line">  &#125;</span><br><span class="line">  pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">  pthread_cond_init(&amp;cond_consumer, <span class="literal">NULL</span>);</span><br><span class="line">  pthread_cond_init(&amp;cond_producer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> err = pthread_create(&amp;consumer, <span class="literal">NULL</span>, consume, (<span class="keyword">void</span>*)<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"consumer thread created failed\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err = pthread_create(&amp;producer, <span class="literal">NULL</span>, produce, (<span class="keyword">void</span>*)<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"producer thread created failed\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pthread_join(producer, <span class="literal">NULL</span>);</span><br><span class="line">  pthread_join(consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//sleep(1000);</span></span><br><span class="line"></span><br><span class="line">  pthread_cond_destroy(&amp;cond_consumer);</span><br><span class="line">  pthread_cond_destroy(&amp;cond_producer);</span><br><span class="line">  pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u6B7B_u9501"><a href="#u6B7B_u9501" class="headerlink" title="死锁"></a>死锁</h3><p>在引入锁的同时，我们遇到了一个新的问题：死锁(Deadlock)。死锁是指两个或多个线程／进程之间相互阻塞，以至于任何一个都不能继续运行，因此也不能解锁其他线程／进程。例如，线程A占有lock A，并且尝试获取lock B；而线程2占有lock B，尝试获取lock A。此时，两者相互阻塞，都无法继续运行。</p>
<p>总结产生死锁的四个条件(只有当四个条件同时满足时才会产生死锁)：</p>
<ol>
<li>Mutual Exclusion – Only one process may use a resource at a time</li>
<li>Hold-and-Wait – Process holds resource while waiting for another</li>
<li>No Preemption – Can’t take a resource away from a process</li>
<li>Circular Wait – The waiting processes form a cycle</li>
</ol>
<h3 id="u751F_u4EA7_u8005_u6D88_u8D39_u8005"><a href="#u751F_u4EA7_u8005_u6D88_u8D39_u8005" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><p>生产者消费者模型是一种常见的通信模型：生产者和消费者共享一个数据管道，生产者将数据写入buffer，消费者从另一头读取数据。对于数据管道，需要考虑为空和溢出的情况。同时，通常还需要将这部分共享内存用mutex加锁。在只有一个生产者一个消费者的情况下，可以设计无锁队列(lockless queue)，线程安全地直接读写数据。</p>
<h3 id="u8FDB_u7A0B_u95F4_u901A_u4FE1"><a href="#u8FDB_u7A0B_u95F4_u901A_u4FE1" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>本地进程间通信的方式有很多，可以总结为下面四类：</p>
<ul>
<li>消息传递（管道、FIFO、消息队列）</li>
<li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li>
<li>共享内存（匿名的和具名的）</li>
<li>远程过程调用（Solaris门和Sun RPC）</li>
</ul>
<p>在介绍进程的时候，我们提起过一个进程不能直接读写另一个进程的数据，两者之间的通信需要通过进程间通信(inter-process communication, IPC)进行。进程通信的方式通常遵从生产者消费者模型，需要实现数据交换和同步两大功能。</p>
<p>1) Shared-memory + semaphore</p>
<p>不同进程通过读写操作系统中特殊的共享内存进行数据交换，进程之间用semaphore实现同步。</p>
<p>2) Message passing</p>
<p>进程在操作系统内部注册一个port，并且监测有没有数据，其他进程直接写数据到该port。该通信方式更加接近于网络通信方式。事实上，网络通信也是一种IPC，只是进程分布在不同机器上而已。</p>
<p>逻辑地址/物理地址/虚拟内存</p>
<p>所谓的逻辑地址，是指计算机用户(例如程序开发者)，看到的地址。例如，当创建一个长度为100的整型数组时，操作系统返回一个逻辑上的连续空间：指针指向数组第一个元素的内存地址。由于整型元素的大小为4个字节，故第二个元素的地址时起始地址加4，以此类推。事实上，逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址(在内存条中所处的位置)，并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维。</p>
<p>另一个重要概念是虚拟内存。操作系统读写内存的速度可以比读写磁盘的速度快几个量级。但是，内存价格也相对较高，不能大规模扩展。于是，操作系统可以通过将部分不太常用的数据移出内存，“存放到价格相对较低的磁盘缓存，以实现内存扩展。操作系统还可以通过算法预测哪部分存储到磁盘缓存的数据需要进行读写，提前把这部分数据读回内存。虚拟内存空间相对磁盘而言要小很多，因此，即使搜索虚拟内存空间也比直接搜索磁盘要快。唯一慢于磁盘的可能是，内存、虚拟内存中都没有所需要的数据，最终还需要从硬盘中直接读取。这就是为什么内存和虚拟内存中需要存储会被重复读写的数据，否则就失去了缓存的意义。</p>
<p>现代计算机中有一个专门的转译缓冲区(Translation Lookaside Buffer，TLB)，用来实现虚拟地址到物理地址的快速转换。</p>
<p>与内存／虚拟内存相关的还有如下两个概念：</p>
<p>1) Resident Set</p>
<p>当一个进程在运行的时候，操作系统不会一次性加载进程的所有数据到内存，只会加载一部分正在用，以及预期要用的数据。其他数据可能存储在虚拟内存，交换区和硬盘文件系统上。被加载到内存的部分就是resident set。</p>
<p>2) Thrashing</p>
<p>由于resident set包含预期要用的数据，理想情况下，进程运行过程中用到的数据都会逐步加载进resident set。但事实往往并非如此：每当需要的内存页面(page)不在resident set中时，操作系统必须从虚拟内存或硬盘中读数据，这个过程被称为内存页面错误(page faults)。当操作系统需要花费大量时间去处理页面错误的情况就是thrashing。</p>
<h3 id="u6587_u4EF6_u7CFB_u7EDF"><a href="#u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="文件系统"></a>文件系统</h3><p>Unix风格的文件系统利用树形结构管理文件。每个节点有多个指针，指向下一层节点或者文件的磁盘存储位置。文件节点还附有文件的操作信息(metadata)，包括修改时间，访问权限等等。</p>
<p>用户的访问权限通过访问控制表(Access Control List)和能力表(Capability List)实现。前者从文件角度出发，标注了每个用户可以对该文件进行何种操作。后者从用户角度出发，标注了某用户可以以什么权限操作哪些文件。</p>
<p>Unix的文件权限分为读、写和执行，用户组分为文件拥有者，组和所有用户。可以通过命令对三组用户分别设置权限。</p>
<h3 id="u5B9E_u65F6_vs-_u5206_u65F6_u64CD_u4F5C_u7CFB_u7EDF"><a href="#u5B9E_u65F6_vs-_u5206_u65F6_u64CD_u4F5C_u7CFB_u7EDF" class="headerlink" title="实时 vs.分时操作系统"></a>实时 vs.分时操作系统</h3><p>操作系统可以分为实时操作系统(Real-time system)，和分时操作系统(Sharing time system)。通常计算机采用的是sharing time，即多个进程／用户之间共享CPU，从形势上实现多任务。各个用户／进程之间的调度并非精准度特别高，如果一个进程被锁住，可以给它分配更多的时间。而实时操作系统则不同，软件和硬件必须遵从严格的deadline，超过时限的进程可能直接被终止。在这样的操作系统中，每次加锁都需要仔细考虑。</p>
<h3 id="u7F16_u8BD1_u5668"><a href="#u7F16_u8BD1_u5668" class="headerlink" title="编译器"></a>编译器</h3><p>对于高级语言来说，代码需要通过编译才能够运行。编译通过编译器(compiler)实现，是一个将程序源代码转换成二进制机器码的过程。计算机可以直接执行二进制代码。在编译的过程中，编译器需要进行词法分析(lexical analysis)，解析(parsing)和过渡代码生成(intermediate code generation)。编译器的好坏可以直接影响最终代码的执行效率。</p>
<h3 id="u4E2D_u65AD"><a href="#u4E2D_u65AD" class="headerlink" title="中断"></a>中断</h3><p>所谓的中断就是在计算机执行程序的过程中，由于出现了某些特殊事情，使得CPU暂停对程序的执行，转而去执行处理这一事件的程序。等这些特殊事情处理完之后再回去执行之前的程序。中断一般分为三类：</p>
<ol>
<li>由计算机硬件异常或故障引起的中断，称为内部异常中断；</li>
<li>由程序中执行了引起中断的指令而造成的中断，称为软中断（这也是和我们将要说明的系统调用相关的中断）；</li>
<li>由外部设备请求引起的中断，称为外部中断。简单来说，对中断的理解就是对一些特殊事情的处理。</li>
</ol>
<p>与中断紧密相连的一个概念就是中断处理程序了。当中断发生的时候，系统需要去对中断进行处理，对这些中断的处理是由操作系统内核中的特定函数进行的，这些处理中断的特定的函数就是我们所说的中断处理程序了。</p>
<p>另一个与中断紧密相连的概念就是中断的优先级。中断的优先级说明的是当一个中断正在被处理的时候，处理器能接受的中断的级别。中断的优先级也表明了中断需要被处理的紧急程度。每个中断都有一个对应的优先级，当处理器在处理某一中断的时候，只有比这个中断优先级高的中断可以被处理器接受并且被处理。优先级比这个当前正在被处理的中断优先级要低的中断将会被忽略。</p>
<p>典型的中断优先级如下所示：</p>
<p>机器错误 &gt; 时钟 &gt; 磁盘 &gt; 网络设备 &gt;  终端 &gt; 软件中断</p>
<p>当发生软件中断时，其他所有的中断都可能发生并被处理；但当发生磁盘中断时，就只有时钟中断和机器错误中断能被处理了。</p>
<p>系统调用</p>
<p>在讲系统调用之前，先说下进程的执行在系统上的两个级别：用户级和核心级，也称为用户态和系统态(user mode and kernel mode)。</p>
<p>程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件等，就需要向操作系统发出调用服务的请求，这就是系统调用。</p>
<p>Linux系统有专门的函数库来提供这些请求操作系统服务的入口，这个函数库中包含了操作系统所提供的对外服务的接口。当进程发出系统调用之后，它所处的运行状态就会由用户态变成核心态。但这个时候，进程本身其实并没有做什么事情，这个时候是由内核在做相应的操作，去完成进程所提出的这些请求。</p>
<p>系统调用和中断的关系就在于，当进程发出系统调用申请的时候，会产生一个软件中断。产生这个软件中断以后，系统会去对这个软中断进行处理，这个时候进程就处于核心态了。</p>
<p>那么用户态和核心态之间的区别是什么呢？（以下区别摘至《UNIX操作系统设计》）</p>
<ol>
<li>用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据）。然而，核心态下的进程能够存取内核和用户地址</li>
<li>某些机器指令是特权指令，在用户态下执行特权指令会引起错误</li>
</ol>
<p>对此要理解的一个是，在系统中内核并不是作为一个与用户进程平行的估计的进程的集合，内核是为用户进程运行的。</p>
<h3 id="IO_u591A_u8DEF_u590D_u7528"><a href="#IO_u591A_u8DEF_u590D_u7528" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><h4 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h4><p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：</p>
<ol>
<li>当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。</li>
<li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li>
<li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</li>
<li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</li>
<li>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</li>
</ol>
<p>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</p>
<h4 id="u5E38_u89C1_u7684IO_u590D_u7528_u5B9E_u73B0"><a href="#u5E38_u89C1_u7684IO_u590D_u7528_u5B9E_u73B0" class="headerlink" title="常见的IO复用实现"></a>常见的IO复用实现</h4><p>select(Linux/Windows/BSD Unix), epoll(Linux)，kqueue(BSD/Mac OS X)</p>
<h3 id="u5185_u5B58_u5206_u914D"><a href="#u5185_u5B58_u5206_u914D" class="headerlink" title="内存分配"></a>内存分配</h3><ul>
<li>虚拟地址：用户编程时将代码（或数据）分成若干个段，每条代码或每个数据的地址由段名称 + 段内相对地址构成，这样的程序地址称为虚拟地址</li>
<li>逻辑地址：虚拟地址中，段内相对地址部分称为逻辑地址</li>
<li>物理地址：实际物理内存中所看到的存储地址称为物理地址</li>
<li>逻辑地址空间：在实际应用中，将虚拟地址和逻辑地址经常不加区分，通称为逻辑地址。逻辑地址的集合称为逻辑地址空间</li>
<li>线性地址空间：CPU地址总线可以访问的所有地址集合称为线性地址空间</li>
<li>物理地址空间：实际存在的可访问的物理内存地址集合称为物理地址空间</li>
<li>MMU(Memery Management Unit内存管理单元)：实现将用户程序的虚拟地址（逻辑地址） → 物理地址映射的CPU中的硬件电路</li>
<li>基地址：在进行地址映射时，经常以段或页为单位并以其最小地址（即起始地址）为基值来进行计算</li>
<li>偏移量：在以段或页为单位进行地址映射时，相对于基地址的地址值</li>
</ul>
<p>虚拟地址先经过分段机制映射到线性地址，然后线性地址通过分页机制映射到物理地址。</p>
<h3 id="u865A_u62DF_u5185_u5B58"><a href="#u865A_u62DF_u5185_u5B58" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>请求调页，也称按需调页，即对不在内存中的“页”，当进程执行时要用时才调入，否则有可能到程序结束时也不会调入</p>
<h3 id="u9875_u9762_u7F6E_u6362_u7B97_u6CD5"><a href="#u9875_u9762_u7F6E_u6362_u7B97_u6CD5" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ul>
<li>FIFO算法<ul>
<li>先入先出，即淘汰最早调入的页面。</li>
</ul>
</li>
<li>OPT(MIN)算法<ul>
<li>选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。</li>
<li>可惜，MIN需要知道将来发生的事，只能在理论中存在，实际不可应用。</li>
</ul>
</li>
<li>LRU(Least-Recently-Used)算法<ul>
<li>用过去的历史预测将来，选最近最长时间没有使用的页淘汰(也称最近最少使用)。</li>
<li>LRU准确实现：计数器法，页码栈法。</li>
<li>由于代价较高，通常不使用准确实现，而是采用近似实现，例如Clock算法。</li>
</ul>
</li>
</ul>
<p><strong>内存抖动现象</strong>：页面的频繁更换，导致整个系统效率急剧下降，这个现象称为内存抖动（或颠簸）。抖动一般是内存分配算法不好，内存太小引或者程序的算法不佳引起的。</p>
<p><strong>Belady现象</strong>：对有的页面置换算法，页错误率可能会随着分配帧数增加而增加。</p>
<p>FIFO会产生Belady异常。</p>
<p>栈式算法无Belady异常，LRU，LFU（最不经常使用），OPT都属于栈式算法。</p>
<h3 id="u78C1_u76D8_u8C03_u5EA6"><a href="#u78C1_u76D8_u8C03_u5EA6" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><p>磁盘访问延迟 = 队列时间 + 控制器时间 + 寻道时间 + 旋转时间 + 传输时间</p>
<p>磁盘调度的目的是减小延迟，其中前两项可以忽略，寻道时间是主要矛盾。</p>
<h3 id="u78C1_u76D8_u8C03_u5EA6_u7B97_u6CD5"><a href="#u78C1_u76D8_u8C03_u5EA6_u7B97_u6CD5" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><ul>
<li>FCFS<ul>
<li>先进先出的调度策略，这个策略具有公平的优点，因为每个请求都会得到处理，并且是按照接收到的顺序进行处理。</li>
</ul>
</li>
<li>SSTF(Shortest-seek-time First 最短寻道时间优先)<ul>
<li>选择使磁头从当前位置开始移动最少的磁盘I/O请求，所以 SSTF 总是选择导致最小寻道时间的请求。</li>
<li>总是选择最小寻找时间并不能保证平均寻找时间最小，但是能提供比 FCFS 算法更好的性能，会存在饥饿现象。</li>
</ul>
</li>
<li>SCAN<ul>
<li>SSTF+中途不回折，每个请求都有处理机会。</li>
<li>SCAN 要求磁头仅仅沿一个方向移动，并在途中满足所有未完成的请求，直到它到达这个方向上的最后一个磁道，或者在这个方向上没有其他请求为止。</li>
<li>由于磁头移动规律与电梯运行相似，SCAN 也被称为电梯算法。</li>
<li>SCAN 算法对最近扫描过的区域不公平，因此，它在访问局部性方面不如 FCFS 算法和 SSTF 算法好。</li>
</ul>
</li>
<li>C-SCAN<ul>
<li>SCAN+直接移到另一端，两端请求都能很快处理。</li>
<li>把扫描限定在一个方向，当访问到某个方向的最后一个磁道时，磁道返回磁盘相反方向磁道的末端，并再次开始扫描。</li>
<li>其中“C”是Circular（环）的意思。</li>
</ul>
</li>
<li>LOOK 和 C-LOOK<ul>
<li>釆用SCAN算法和C-SCAN算法时磁头总是严格地遵循从盘面的一端到另一端，显然，在实际使用时还可以改进，即磁头移动只需要到达最远端的一个请求即可返回，不需要到达磁盘端点。这种形式的SCAN算法和C-SCAN算法称为LOOK和C-LOOK调度。这是因为它们在朝一个给定方向移动前会查看是否有请求。</li>
</ul>
</li>
</ul>
<h3 id="u5206_u533A_u8868"><a href="#u5206_u533A_u8868" class="headerlink" title="分区表"></a>分区表</h3><ul>
<li>MBR：支持最大卷为2 TB（Terabytes）并且每个磁盘最多有4个主分区（或3个主分区，1个扩展分区和无限制的逻辑驱动器）</li>
<li>GPT：支持最大卷为18EB（Exabytes）并且每磁盘的分区数没有上限，只受到操作系统限制（由于分区表本身需要占用一定空间，最初规划硬盘分区时，留给分区表的空间决定了最多可以有多少个分区，IA-64版Windows限制最多有128个分区，这也是EFI标准规定的分区表的最小尺寸。另外，GPT分区磁盘有备份分区表来提高分区数据结构的完整性。</li>
</ul>
<h3 id="RAID__u6280_u672F"><a href="#RAID__u6280_u672F" class="headerlink" title="RAID 技术"></a>RAID 技术</h3><p>磁盘阵列（Redundant Arrays of Independent Disks，RAID），独立冗余磁盘阵列之。原理是利用数组方式来作磁盘组，配合数据分散排列的设计，提升数据的安全性。</p>
<ul>
<li>RAID 0<ul>
<li>RAID 0是最早出现的RAID模式，需要2块以上的硬盘，可以提高整个磁盘的性能和吞吐量。</li>
<li>RAID 0没有提供冗余或错误修复能力，其中一块硬盘损坏，所有数据将遗失。</li>
</ul>
</li>
<li>RAID 1<ul>
<li>RAID 1就是镜像，其原理为在主硬盘上存放数据的同时也在镜像硬盘上写一样的数据。</li>
<li>当主硬盘（物理）损坏时，镜像硬盘则代替主硬盘的工作。因为有镜像硬盘做数据备份，所以RAID 1的数据安全性在所有的RAID级别上来说是最好的。</li>
<li>但无论用多少磁盘做RAID 1，仅算一个磁盘的容量，是所有RAID中磁盘利用率最低的。</li>
</ul>
</li>
<li>RAID 2<ul>
<li>这是RAID 0的改良版，以汉明码（Hamming Code）的方式将数据进行编码后分区为独立的比特，并将数据分别写入硬盘中。因为在数据中加入了错误修正码（ECC，Error Correction Code），所以数据整体的容量会比原始数据大一些，RAID2最少要三台磁盘驱动器方能运作。</li>
</ul>
</li>
<li>RAID 3<ul>
<li>采用Bit－interleaving（数据交错存储）技术，它需要通过编码再将数据比特分割后分别存在硬盘中，而将同比特检查后单独存在一个硬盘中，但由于数据内的比特分散在不同的硬盘上，因此就算要读取一小段数据资料都可能需要所有的硬盘进行工作，所以这种规格比较适于读取大量数据时使用。</li>
</ul>
</li>
<li>RAID 4<ul>
<li>它与RAID 3不同的是它在分区时是以区块为单位分别存在硬盘中，但每次的数据访问都必须从同比特检查的那个硬盘中取出对应的同比特数据进行核对，由于过于频繁的使用，所以对硬盘的损耗可能会提高。（块交织技术，Block interleaving）</li>
</ul>
</li>
</ul>
<p><strong>RAID 2/3/4 在实际应用中很少使用</strong></p>
<ul>
<li>RAID 5<ul>
<li>RAID Level 5是一种储存性能、数据安全和存储成本兼顾的存储解决方案。它使用的是Disk Striping（硬盘分区）技术。</li>
<li>RAID 5至少需要三块硬盘，RAID 5不是对存储的数据进行备份，而是把数据和相对应的奇偶校验信息存储到组成RAID5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上。</li>
<li>RAID 5 允许一块硬盘损坏。</li>
<li>实际容量 Size = (N-1) * min(S1, S2, S3 … SN)</li>
</ul>
</li>
<li>RAID 6<ul>
<li>与RAID 5相比，RAID 6增加第二个独立的奇偶校验信息块。两个独立的奇偶系统使用不同的算法，数据的可靠性非常高，即使两块磁盘同时失效也不会影响数据的使用。</li>
<li>RAID 6 至少需要4块硬盘。</li>
<li>实际容量 Size = (N-2) * min(S1, S2, S3 … SN)</li>
</ul>
</li>
<li>RAID 10/01（RAID 1+0，RAID 0+1）<ul>
<li>RAID 10是先镜射再分区数据，再将所有硬盘分为两组，视为是RAID 0的最低组合，然后将这两组各自视为RAID 1运作。</li>
<li>RAID 01则是跟RAID 10的程序相反，是先分区再将数据镜射到两组硬盘。它将所有的硬盘分为两组，变成RAID 1的最低组合，而将两组硬盘各自视为RAID 0运作。</li>
<li>当RAID 10有一个硬盘受损，其余硬盘会继续运作。RAID 01只要有一个硬盘受损，同组RAID 0的所有硬盘都会停止运作，只剩下其他组的硬盘运作，可靠性较低。如果以六个硬盘建RAID 01，镜射再用三个建RAID 0，那么坏一个硬盘便会有三个硬盘脱机。因此，RAID 10远较RAID 01常用，零售主板绝大部份支持RAID 0/1/5/10，但不支持RAID 01。</li>
<li>RAID 10 至少需要4块硬盘，且硬盘数量必须为偶数。</li>
</ul>
</li>
</ul>
<h4 id="u5E38_u89C1_u6587_u4EF6_u7CFB_u7EDF"><a href="#u5E38_u89C1_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="常见文件系统"></a>常见文件系统</h4><ul>
<li>Windows: FAT, FAT16, FAT32, NTFS</li>
<li>Linux: ext2/3/4, btrfs, ZFS</li>
<li>Mac OS X: HFS+</li>
</ul>
<h3 id="Linux_u6587_u4EF6_u6743_u9650"><a href="#Linux_u6587_u4EF6_u6743_u9650" class="headerlink" title="Linux文件权限"></a>Linux文件权限</h3><p>Linux文件采用10个标志位来表示文件权限，如下所示：</p>
<pre><code>-rw-r--r--  1 skyline  staff    20B  1 27 10:34 1.txt
drwxr-xr-x   5 skyline  staff   170B 12 23 19:01 ABTableViewCell
</code></pre><p>第一个字符一般用来区分文件和目录，其中：</p>
<ul>
<li>d：表示是一个目录，事实上在ext2fs中，目录是一个特殊的文件。</li>
<li>－：表示这是一个普通的文件。</li>
<li>l: 表示这是一个符号链接文件，实际上它指向另一个文件。</li>
<li>b、c：分别表示区块设备和其他的外围设备，是特殊类型的文件。</li>
<li>s、p：这些文件关系到系统的数据结构和管道，通常很少见到。</li>
</ul>
<p>第2～10个字符当中的每3个为一组，左边三个字符表示所有者权限，中间3个字符表示与所有者同一组的用户的权限，右边3个字符是其他用户的权限。</p>
<p>这三个一组共9个字符，代表的意义如下：</p>
<ul>
<li>r(Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限</li>
<li>w(Write,写入)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。</li>
<li>x(eXecute，执行)：对文件而言，具有执行文件的权限；对目录来说该用户具有进入目录的权限。</li>
</ul>
<p>权限的掩码可以使用十进制数字表示：</p>
<ul>
<li>如果可读，权限是二进制的100，十进制是4；</li>
<li>如果可写，权限是二进制的010，十进制是2；</li>
<li>如果可运行，权限是二进制的001，十进制是1；</li>
</ul>
<p><strong>具备多个权限，就把相应的 4、2、1 相加就可以了：</strong></p>
<pre><code>若要 rwx 则 4+2+1=7 若要 rw- 则 4+2=6 若要 r-x 则 4+1=5 若要 r-- 则 =4 若要 -wx 则 2+1=3 若要 -w- 则 =2 若要 --x 则 =1 若要 --- 则 =0
</code></pre><p>默认的权限可用umask命令修改，用法非常简单，只需执行umask 777命令，便代表屏蔽所有的权限，因而之后建立的文件或目录，其权限都变成000，</p>
<p>依次类推。通常root帐号搭配umask命令的数值为022、027和 077，普通用户则是采用002，这样所产生的权限依次为755、750、700、775。</p>
<h4 id="chmod_u547D_u4EE4"><a href="#chmod_u547D_u4EE4" class="headerlink" title="chmod命令"></a>chmod命令</h4><p>chmod命令非常重要，用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。</p>
<p>该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。</p>
<ol>
<li>文字设定法<ul>
<li>chmod ［who］ ［+ | - | =］ ［mode］ 文件名</li>
<li>命令中各选项的含义为：</li>
<li>操作对象who可是下述字母中的任一个或者它们的组合：<ul>
<li>u 表示“用户（user）”，即文件或目录的所有者。</li>
<li>g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。</li>
<li>o 表示“其他（others）用户”。</li>
<li>a 表示“所有（all）用户”。它是系统默认值。</li>
</ul>
</li>
<li>操作符号可以是：<ul>
<li>添加某个权限。</li>
<li>取消某个权限。</li>
<li>= 赋予给定权限并取消其他所有权限（如果有的话）。</li>
</ul>
</li>
<li>设置mode所表示的权限可用下述字母的任意组合：<ul>
<li>r 可读。</li>
<li>w 可写。</li>
<li>x 可执行。</li>
<li>X 只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性。</li>
<li>s 在文件执行时把进程的属主或组ID置为该文件的文件属主。方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位。</li>
<li>t 保存程序的文本到交换设备上。</li>
<li>u 与文件属主拥有一样的权限。</li>
<li>g 与和文件属主同组的用户拥有一样的权限。</li>
<li>o 与其他用户拥有一样的权限。</li>
</ul>
</li>
<li>文件名：以空格分开的要改变权限的文件列表，支持通配符。</li>
<li>在一个命令行中可给出多个权限方式，其间用逗号隔开。例如：chmod g+r，o+r example 使同组和其他用户对文件example 有读权限。</li>
</ul>
</li>
<li>数字设定法<ul>
<li>直接使用数字表示的权限来更改：</li>
<li>例： $ chmod 644 mm.txt</li>
</ul>
</li>
</ol>
<h4 id="chgrp_u547D_u4EE4"><a href="#chgrp_u547D_u4EE4" class="headerlink" title="chgrp命令"></a>chgrp命令</h4><ul>
<li>功能：改变文件或目录所属的组。</li>
<li>语法：chgrp ［选项］ group filename</li>
<li>例：$ chgrp - R book /opt/local /book</li>
<li>改变/opt/local /book/及其子目录下的所有文件的属组为book。</li>
</ul>
<h4 id="chown_u547D_u4EE4"><a href="#chown_u547D_u4EE4" class="headerlink" title="chown命令"></a>chown命令</h4><ul>
<li>功能：更改某个文件或目录的属主和属组。这个命令也很常用。例如root用户把自己的一个文件拷贝给用户xu，为了让用户xu能够存取这个文件，root用户应该把这个文件的属主设为xu，否则，用户xu无法存取这个文件。</li>
<li>语法：chown ［选项］ 用户或组 文件</li>
<li>说明：chown将指定文件的拥有者改为指定的用户或组。用户可以是用户名或用户ID。组可以是组名或组ID。文件是以空格分开的要改变权限的文件列表，支持通配符。</li>
<li>例：把文件shiyan.c的所有者改为wang。</li>
<li><code>chown wang shiyan.c</code></li>
</ul>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://wdxtub.com/interview/14520603814585.html">After URL</a></li>
<li><a href="http://wdxtub.com/interview/14520603814632.html">Reliable UDP</a></li>
<li><a href="http://wdxtub.com/interview/14520603814674.html">TCP or UDP</a></li>
<li><a href="http://wdxtub.com/interview/14520607787127.html">Test Binary Search</a></li>
<li><a href="http://wdxtub.com/interview/14520607787180.html">Test a Login System</a></li>
<li><a href="http://wdxtub.com/interview/14520607787230.html">Test a Pen</a></li>
<li><a href="http://wdxtub.com/interview/14520607787281.html">Web Browser debug</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一章包括剩余一些比较基本的常识性知识，具体可能是以聊天的形式来进行交流，关键就在于理解，不要死记硬背。其实计算机学科的各种概念联系都比较紧密，梳理清晰自然就记住了。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="操作系统" scheme="http://wdxtub.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据库" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="网络" scheme="http://wdxtub.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 11 课 面向对象]]></title>
    <link href="http://wdxtub.com/2016/01/23/programmer-startline-11/"/>
    <id>http://wdxtub.com/2016/01/23/programmer-startline-11/</id>
    <published>2016-01-23T22:48:04.000Z</published>
    <updated>2016-01-24T01:19:34.000Z</updated>
    <content type="html"><![CDATA[<p>设计题可以分成两个类别：系统架构设计和利用面向对象编程原理进行程序设计。重点是要体现出自己的想法和思路，毕竟设计类问题，没有所谓标准答案。</p>
<a id="more"></a>
<hr>
<ol>
<li>题目描述<ul>
<li>往往非常简单，如：设计一个XX系统。或者：你有没有用过XXX，给你看一下它的界面和功能，你来设计一个。</li>
</ul>
</li>
<li>阐述题意<ul>
<li>面试者需向面试官询问系统的具体要求。如，需要什么功能，需要承受的流量大小，是否需要考虑可靠性，容错性等等。</li>
</ul>
</li>
<li>面试者提供一个初步的系统设计</li>
<li>面试官这对初步的系统中提出一些后续的问题：如果要加某个功能怎么办，如果流量大了怎么办，如何考虑一致性，如果机器挂了怎么办。</li>
<li>面试者根据面试官的后续问题逐步完善系统设计</li>
<li>完成面试</li>
</ol>
<p>总体特点是以交流为主，画图和代码为辅。</p>
<p>根据我们面试别人和参与面试的经验，先从面试官的角度给出一些考量标准：</p>
<ul>
<li>适应变化的需求(Adapt to the changing requirements )</li>
<li>设计干净，优美，考虑周到的系统(Produce a system that is clean, elegant, well thought )</li>
<li>解释为何这么实现(Explain why you choose this implementation )</li>
<li>对自己的能力水平很熟练(Be familiar with your experience level to make decisions )</li>
<li>在一些高层结构和复杂性方面有设计(Answer in high level of scale and complexity )</li>
</ul>
<p>按照评分体系的化，分成下面4个等级</p>
<table>
<thead>
<tr>
<th style="text-align:center">Scoring</th>
<th style="text-align:center">Candidate</th>
<th style="text-align:center">Criteria</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1.0</td>
<td style="text-align:center">Bad</td>
<td style="text-align:center">No sense of requirement, no scoping</td>
</tr>
<tr>
<td style="text-align:center">2.0</td>
<td style="text-align:center">Poor</td>
<td style="text-align:center">Limited knowledge, common sense</td>
</tr>
<tr>
<td style="text-align:center">3.0</td>
<td style="text-align:center">Good</td>
<td style="text-align:center">Reasonable Solution, explain clearly</td>
</tr>
<tr>
<td style="text-align:center">4.0</td>
<td style="text-align:center">Great</td>
<td style="text-align:center">Out of expectation, well thoughtful, trade-off</td>
</tr>
</tbody>
</table>
<p>其实大家大可不必追求完美，在真正的面试中，没有人能对答如流，往往面试官也会给出善意的提示，就算你没回答某个子问题，在面试后的评价中也会综合衡量，跟其他的面试者比较，最终打出一个分数</p>
<h2 id="u89E3_u9898_u7B56_u7565"><a href="#u89E3_u9898_u7B56_u7565" class="headerlink" title="解题策略"></a>解题策略</h2><h3 id="Abstractions_2C_Object_and_Decoupling"><a href="#Abstractions_2C_Object_and_Decoupling" class="headerlink" title="Abstractions, Object and Decoupling"></a>Abstractions, Object and Decoupling</h3><p>通常，关于OOP，面试官会让面试者设计一个程序框架，该程序能够实现一些特定的功能。比如，如何实现一个音乐播放器，如何设计一个车库管理程序等等。对于此类问题，设计的关键过程一般包括抽象(abstraction)，设计对象(object)和设计合理的层次／接口(decoupling)。这里，我们举一个例子简单说明这些过程分别需要做些什么，在“模式识别”给出更为具体和完整的实例。</p>
<h3 id="u7EE7_u627F/_u7EC4_u5408/_u53C2_u6570_u5316_u7C7B_u578B"><a href="#u7EE7_u627F/_u7EC4_u5408/_u53C2_u6570_u5316_u7C7B_u578B" class="headerlink" title="继承/组合/参数化类型"></a>继承/组合/参数化类型</h3><p>在面向对象中最常用的两种代码复用技术就是继承和组合。在设计对象的时候，“Is-A”表示一种继承关系。比如，班长“Is-A”学生，那么，学生就是基类，班长就是派生类。在确定了派生关系之后，我们需要分析什么是基类变量(base class variables)什么是子类变量(sub class variables)，并由此确定基类和派生类之间的联系。而“Has-A”表示一种从属关系，这就是组合。比如，班长“Has-A”眼镜，那就可以解释为班长实例中拥有一个眼镜实例变量(instance variable)。在具体实现的时候，班长类中定义一个眼镜的基类指针。“在生成班长实例的时候，同时生成一个眼镜实例，利用眼镜的基类指针指向这个实例。任何关于眼镜的操作函数都可以利用这个基类指针实现多态(polymorphism)。注意，多态是OOP相关的一个重要概念，也是面试常考的概念之一。关于多态的解释请见“工具箱”。</p>
<p>在通常情况下，我们更偏向于“Has-A”的设计模式。因为该模式减少了两个实例之间的相关性。对于继承的使用，通常情况下我们会定义一个虚基类，由此派生出多个不同的实例类。在业界的程序开发中，多重继承并不常见，Java甚至不允许从多个父类同时继承，产生一个子类。</p>
<p>此外，我们还要提及参数化类型。参数化类型，或者说模版类也是一种有效的代码复用技术。在C++的标准模版库中大量应用了这种方式。例如，在定义一个List<string>的变量时，List被另一个类型String所参数化。</string></p>
<p>设计模式着重于代码的复用，所以在选择复用技术上，有必要看看上述三种复用技术优劣。</p>
<p><strong>继承</strong></p>
<ul>
<li>通过继承方式，子类能够非常方便地改写父类方法，同时</li>
<li>保留部分父类方法，可以说是能够最快速地达到代码复用。</li>
<li>继承是在静态编译时候就定义了，所以无法再运行时刻改写父类方法。</li>
<li>因为子类没有改写父类方法的话，就相当于依赖了父类这个方法的实现细节,被认为破坏封装性。</li>
<li>并且如果父类接口定义需要更改时，子类也需要提更改响应接口。</li>
</ul>
<p><strong>组合</strong></p>
<ul>
<li>对象组合通过获得其他对象引用而在运行时刻动态定义的。</li>
<li>组合要求对象遵守彼此约定，进而要求更仔细地定义接口，而这些接口并不妨碍你将一个对象和另外一个对象一起使用。</li>
<li>对象只能够通过接口来访问，所以我们并没有破坏封装性。</li>
<li>而且只要抽象类型一致，对象是可以被替换的。</li>
<li>使用组合方式，我们可以将类层次限制在比较小的范围内，不容易产生类的爆炸。</li>
<li>相对于继承来说,组合可能需要编写“更多的代码。</li>
</ul>
<p><strong>参数化类型</strong></p>
<ul>
<li>参数化类型方式是基于接口的编程，在一定程度上消除了类型给程序设计语言带来的限制。</li>
<li>相对于组合方式来说，缺少的是动态修改能力。</li>
<li>因为参数化类型本身就不是面向对象语言的一个特征，所以在面向对象的设计模式里面，没有一种模式是于参数化类型相关的。</li>
<li>实践上我们方面是可以使用参数化类型来编写某种模式的。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>对象组合技术允许你在运行时刻改变被组合的行为，但是它存在间接性，相对来说比较低效。</li>
<li>继承允许你提供操作的缺省实现，通过子类来重定义这些操作，但是不能够在运行时改变。</li>
<li>参数化允许你改变所使用的类型，同样不能够在运行时改变。</li>
</ul>
<h2 id="u8BBE_u8BA1_u6A21_u5F0F"><a href="#u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="设计模式"></a>设计模式</h2><p>所谓的设计模式是指人们在开发软件的过程中，对于一些普适需求而总结的设计模版。根据模式目的可以分为三类：</p>
<ul>
<li>创建型(Creational).创建型模式与对象的创建相关。</li>
<li>结构型(Structural).结构型模式处理类或者是对象的组合。</li>
<li>行为型(Behavioral).行为型模式对类或者是对象怎样交互和怎样分配职责进行描述。</li>
</ul>
<p>下面我们对每种类型进行介绍。具体的模式请见“工具箱”。值得提醒的是，在面试或工作中不可盲目相信设计模式。设计模式更多地只是提供一些思路，能够直接套用设计模式的情况并不多，更多的时候是对现成设计模式的改进和组合。所以对于设计模式的学习更多应该着眼于模式的意图，而不是模式的具体实现方法。</p>
<h3 id="u521B_u5EFA_u578B"><a href="#u521B_u5EFA_u578B" class="headerlink" title="创建型"></a>创建型</h3><p>一个类的创建型模式使用继承改变被实例化的类，而一个对象的创建型模式将实例化委托给另外一个对象。 在这些模式中有两种不断出现的主旋律：</p>
<ul>
<li>将该系统使用哪些具体的类封装起来</li>
<li>隐藏了实例是如何被创建和存储的</li>
</ul>
<p>总而言之，效果就是用户创建对象的结果是得到一个基类指针，用户通过基类指针调用继承类的方法。用户不需要知道在使用哪些继承类。</p>
<h4 id="u5355_u4F8B_u6A21_u5F0F"><a href="#u5355_u4F8B_u6A21_u5F0F" class="headerlink" title="单例模式"></a>单例模式</h4><p>意图：单例模式(Singleton Pattern)是一种常见的设计模式。其目的在于保证一个类仅仅有一个实例并且提供一个访问它的全局访问点。</p>
<p>这个模式主要的对比对象就是全局变量。相对于全局变量，单例有下面这些好处：</p>
<ul>
<li>全局变量不能够保证只有一个实例。</li>
<li>某些情况下面，我们需要稍微计算才能够初始化这个单例。全局变量也行但是不自然。</li>
<li>C++下面没有保证全局变量的初始化顺序.</li>
</ul>
<p>比如，在我们之前说的音乐播放器设计中，我们引入了歌曲管理器实现数据的存储。歌曲管理器在整个程序中应当实例化一次，其他所有关于数据的操作都应该在这个实例上进行。所以，歌曲管理器应该应用单例模式。实现单例模式的关键在于利用静态变量(static variable)，通过判断静态变量是否已经初始化判断该类是否已经实例化。此外，还需要把构造函数设为私有函数，通过公共接口getSharedInstance进行调用。我们举例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example for singleton pattern</span></span><br><span class="line"><span class="comment">// class definition</span></span><br><span class="line"><span class="keyword">class</span> MySingleton &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// Private Constructor</span></span><br><span class="line">    MySingleton();</span><br><span class="line"><span class="comment">// Stop the compiler generating methods of copy the object</span></span><br><span class="line">    MySingleton(<span class="keyword">const</span> MySingleton &amp;copy);    <span class="comment">// Not Implemented</span></span><br><span class="line">    MySingleton &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MySingleton &amp;copy);    <span class="comment">// Not Implemented</span></span><br><span class="line">    <span class="keyword">static</span> MySingleton *m_pInstance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> MySingleton *<span class="title">getSharedInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_pInstance) &#123;</span><br><span class="line">            m_pInstance = <span class="keyword">new</span> MySingleton;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in the source file</span></span><br><span class="line">MySingleton *MySingleton::m_pInstance = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>注意，本例中的实现方式针对非多线程的情况。如果有过个线程想要同时调用getSharedInstance函数，则需要用mutex保护下列代码：</p>
<pre><code>pthread_mutex_lock(&amp;mutex);
if (!m_pInstance) {
    m_pInstance = new MySingleton;
}
pthread_mutex_unlock(&amp;mutex);
</code></pre><h4 id="u5DE5_u5382_u6A21_u5F0F"><a href="#u5DE5_u5382_u6A21_u5F0F" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>意图：抽象类需要创建一个对象时，让子类决定实例化哪一个类</p>
<p>所谓的工厂模式(Factory Pattern)，就是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。通常，接口提供传入参数，用以决定实例化什么类。工厂模式常见于工具包和框架中，当需要生成一系列类似的子类时，可以考虑使用工厂模式。举例如下：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// <span class="class"><span class="keyword">class</span> <span class="title">for</span> <span class="title">factory</span> <span class="title">pattern</span></span></span><br><span class="line">enum ImageType&#123;</span><br><span class="line">    GIF,</span><br><span class="line">    JPEG</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageReader</span> &#123;</span></span><br><span class="line">    // implementation <span class="keyword">for</span> image reader base <span class="class"><span class="keyword">class</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GIFReader</span> : <span class="title">public</span> <span class="title">ImageReader</span> &#123;</span></span><br><span class="line">    // implementation <span class="keyword">for</span> GIF reader derived <span class="class"><span class="keyword">class</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JPEGReader</span> : <span class="title">public</span> <span class="title">ImageReader</span> &#123;</span></span><br><span class="line">    // implementation <span class="keyword">for</span> JPEG reader derived <span class="class"><span class="keyword">class</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageReaderFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    static ImageReader *imageReaderFactoryMethod(ImageType imageType) &#123;</span><br><span class="line">        ImageReader *product = <span class="literal">NULL</span>;</span><br><span class="line">        switch (imageType) &#123;</span><br><span class="line">            <span class="keyword">case</span> GIF:</span><br><span class="line">                product = <span class="keyword">new</span> GIFReader();</span><br><span class="line">            <span class="keyword">case</span> JPEG:</span><br><span class="line">                product = <span class="keyword">new</span> JPEGReader();</span><br><span class="line">                //...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="u7ED3_u6784_u578B"><a href="#u7ED3_u6784_u578B" class="headerlink" title="结构型"></a>结构型</h3><p>类的结构型模式采用继承机制来组合接口。对象的结构型模式不是对接口进行组合， 而是描述如何对一些对象进行组合，从而实现新功能。</p>
<h4 id="u9002_u914D_u5668"><a href="#u9002_u914D_u5668" class="headerlink" title="适配器"></a>适配器</h4><p>意图：适配器(Adapter)将一个类的接口转化成为客户希望的另外一个接口。</p>
<p>假设A实现了Foo()接口，但是B希望A同样实现一个Bar()接口，事实上Foo()基本实现了Bar()接口功能。 Adapter模式就是设计一个新类C，C提供Bar()接口，但实现的方式是内部调用 A的Foo()。</p>
<p>在实现层面上可以通过继承和组合两种方式达到目的：C可以继承A，或者C把A作为自己的成员变量。两者孰优孰劣需要视情况而定。</p>
<h3 id="u884C_u4E3A_u578B"><a href="#u884C_u4E3A_u578B" class="headerlink" title="行为型"></a>行为型</h3><p>行为型涉及到算法和对象之间职责的分配。行为模式不仅描述对象或者类的功能行为，还描述它们之间的通信模式。 这些模式刻画了在运行时难以追踪的控制流，它们将你的注意从控制流转移到对象之间的联系上来。</p>
<h4 id="u89C2_u5BDF_u8005"><a href="#u89C2_u5BDF_u8005" class="headerlink" title="观察者"></a>观察者</h4><p>意图：观察者模式(observer)定义对象之间的依赖关系，当一个对象“状态发生改变的话，所有依赖这个对象的对象都会被通知并且进行更新。</p>
<p>被观察的对象需要能够动态地增删观察者对象，这就要求观察者提供一个公共接口比如Update()。然后每个观察者实例注册到被观察对象里面去，在被观察对象状态更新时候能够遍历所有注册观察者并且调用Update()。</p>
<p>至于观察者和被观察之间是采用push还是pull模式完全取决于应用。对于观察这件事情来说的话， 我们还可以引入方面(Aspect)这样一个概念，在注册观察者的时候不仅仅只是一个观察者对象， 还包括一个Aspect参数，可以以此告诉被观察者仅在发生某些变化时通过调用Update()通知我。</p>
<h4 id="u72B6_u6001"><a href="#u72B6_u6001" class="headerlink" title="状态"></a>状态</h4><p>意图：状态模式(state)允许一个对象在其内部状态改变时改变它的行为。</p>
<p>这里状态模式意图是，对于实例A，当A的状态改变时，将A可能改变的行为封装成为一个类S(有多少种可能的状态就有多少个S的子类,比如S1,S2,S3等)。当A的状态转换时，在A内部切换S的实例。从A的用户角度来看，A的接口不变，但A的行为因A的状态改变而改变，这是因为行为的具体实现由S完成。</p>
<h2 id="u5DE5_u5177_u7BB1"><a href="#u5DE5_u5177_u7BB1" class="headerlink" title="工具箱"></a>工具箱</h2><h3 id="u6709_u9650_u72B6_u6001_u673A"><a href="#u6709_u9650_u72B6_u6001_u673A" class="headerlink" title="有限状态机"></a>有限状态机</h3><p>参见<a href="http://en.wikipedia.org/wiki/Finite-state_machine" target="_blank" rel="external">这里</a></p>
<h3 id="u591A_u6001"><a href="#u591A_u6001" class="headerlink" title="多态"></a>多态</h3><p>在C++中，最常见的多态指的是用基类指针指向一个派生类的实例，当用该指针调用一个基类中的虚函数时，实际调用的是派生类的函数实现，而不是基类函数。如果该指针指向另一个派生类实例，则调用另一个派生类的函数实现。因此，比如工厂模式返回一个实例，上层函数不需要知道实例来自哪个派生类，只需要用一个基类指针指向它，就可以直接获得需要的行为。从编译的角度来看，函数的调用地址并不是在编译阶段静态决定，而是在运行阶段，动态地决定函数的调用地址。</p>
<p>多态是通过虚函数表实现的。当基类中用virtual关键字定义函数时，系统自动分配一个指针，指向该类的虚函数表。虚函数表中存储的是函数指针。在生成派生类的时候，会将派生类中对应的函数的地址写到虚函数表。之后，当利用基类指针调用函数时，先通过虚函数表指针找到对应的虚函数表，再通过表内存储的函数指针调用对应函数。由于函数指针指向派生类的实现，因此函数行为自然也就是派生类中定义的行为了。</p>
<h3 id="u521B_u5EFA_u578B_u8BBE_u8BA1_u6A21_u5F0F_u8865_u5145"><a href="#u521B_u5EFA_u578B_u8BBE_u8BA1_u6A21_u5F0F_u8865_u5145" class="headerlink" title="创建型设计模式补充"></a>创建型设计模式补充</h3><h4 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h4><p><strong>意图：将一个复杂对象构建过程和元素表示分离。</strong></p>
<p>假设我们需要创建一个复杂对象，而这个复杂对象是由很多元素构成的。这些元素的组合逻辑可能非常复杂， 但是逻辑组合和创建这些元素是无关的，独立于这些元素本身的。</p>
<p>那么我们可以将元素的组合逻辑以及元素构建分离，元素构建我们单独放在Builder这样一个类里面，而元素的组合逻辑通过Director来指导，Director内部包含Builder对象。创建对象是通过Director来负责组合逻辑部分的， Director内部调用Builder来创建元素并且组装起来。最终通过Builder的GetResult来获得最终复杂对象。</p>
<h3 id="u7ED3_u6784_u578B_u8BBE_u8BA1_u6A21_u5F0F_u8865_u5145"><a href="#u7ED3_u6784_u578B_u8BBE_u8BA1_u6A21_u5F0F_u8865_u5145" class="headerlink" title="结构型设计模式补充"></a>结构型设计模式补充</h3><h4 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h4><p><strong>意图：将抽象部分和具体实现相分离，使得它们之间可以独立变化。</strong></p>
<p>一个很简单的例子就是类Shape,有个方法Draw[抽象]和DrawLine[具体]和DrawText[具体],而Square和SquareText 继承于Shape实现Draw()这个方法，Square调用DrawLine()，而SquareText调用DrawLine()+DrawText()。而且假设DrawLine和DrawText分别有LinuxDrawLine,LinuxDrawText和Win32DrawLine和Win32DrawText。如“果我们简单地 使用子类来实现的话，比如构造LinuxSquare,LinuxSquareText,Win32Square和Win32SquareText，那么很快就会类爆炸。</p>
<p>事实上我们没有必要在Shape这个类层面跟进变化，即通过继承Shape类实现跨平台，而只需要在实现底层跟进变化。为此我们就定义一套接口，如例子中的DrawLine和DrawText，然后在Linux和Win32下实现一个这样接口实例(比如称为跨平台GDI)，最终 Shape内部持有这个GDI对象，Shape的DrawLine和DrawText只是调用GDI的接口而已。这样，我们把Shape及其子类的DrawLine和DrawText功能Bridge到GDI，GDI可以通过工厂模式在不同平台下实现不同的实例。</p>
<p>例子中Shape成为了完全抽象的部分，具体实现完全交给GDI类，若以后需要增加更多的平台支持，开发者也不需要添加更多的Shape子类，只需要扩展GDI即可。总之，抽象部分是和具体实现部分需要独立开来的时候，就可以使用Bridge模式。</p>
<h4 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h4><p><strong>意图：将对象组合成为树形以表示层级结构，对于叶子和非叶子节点对象使用需要有一致性。</strong></p>
<p>Composite模式强调在这种层级结构下，叶子和非叶子节点需要一致对待，所以关键是需要定义一个抽象类，作为叶节点的子节点。 然后对于叶子节点操作没有特殊之处，而对于非叶子节点操作不仅仅需要操作自身，还要操作所管理的子节点。 至于遍历子节点和处理顺序是由应用决定的，在Composite模式里面并不做具体规定。</p>
<h4 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h4><p><strong>意图：动态地给对象添加一些额外职责，通过组合而非继承方式完成。</strong></p>
<p>给对象添加一些额外职责，例如增加新的方法，很容易会考虑使用子类方式来实现。使用子类方式实现很快但是却不通用，考虑一个抽象类X，子类有SubX1,SubX2等。现在需要为X提供一个附加方法echo，如果用继承的方式添加，那么需要为每个子类都实现echo方法，并且代码往往是重复的。我们可以考虑Decorator模式，定义一个新类，使其持有持有指向X基类的指针，并且新类只需要单独实现echo方法，而其他方法直接利用X基类指针通过多态调用即可。</p>
<p>值得注意的是，装饰出来的对象必须包含被装饰对象的所有接口。所以很明显这里存在一个问题， 那就是X一定不能够有过多的方法，不然Echo类里面需要把X方法全部转发一次(理论上说Echo类可以仅转发X的部分方法，但Decorator默认需要转发被装饰类的全部方法)。</p>
<h4 id="Fa_E7ade"><a href="#Fa_E7ade" class="headerlink" title="Façade"></a>Façade</h4><p><strong>意图：为子系统的一组接口提供一个一致的界面。</strong></p>
<p>编译器是一个非常好的的例子。对于编译器来说，有非常多的子系统包括词法语法解析，语义检查,中间代码生成，代码优化，以及代码生成这些逻辑部件。但是对于大多数用户来说，不关心这些子系统，而只是关心编译这一个过程。</p>
<p>所以我们可以提供Compiler的类，里面只有很简单的方法比如Compile()，让用户直接使用Compile()这个接口。 一方面用户使用起来简单，另外一方面子系统和用户界面耦合性也降低了。</p>
<p>Facade模式对于大部分用户都是满足需求的。对于少部分不能够满足需求的用户，可以让他们绕过Facade模式提供的界面， 直接控制子系统即可。就好比GCC提供了很多特殊优化选项来让高级用户来指定，而不是仅仅指定-O2这样的选项。</p>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p><strong>意图：为其他对象提供一种代理以控制对这个对象的访问。</strong></p>
<p>通常使用Proxy模式是想针对原本要访问的对象做一些手脚，以达到一定的目的，包括访问权限设置，访问速度优化，或者是加入一些自己特有的逻辑。至于实现方式上，不管是继承还是组合都行，可能代价稍微有些不同，视情况而定。但是偏向组合方式，因为对于Proxy而言，完全可以定义一套新的访问接口。</p>
<p>Adapter,Decorator以及Proxy之间比较相近，虽然说意图上差别很大，但是对于实践中， 三者都是通过引用对象来增加一个新类来完成的，但是这个新类在生成接口方面有点差别：</p>
<ul>
<li>Adapter模式的接口一定要和对接的接口相同。</li>
<li>Decorator模式的接口一定要包含原有接口，通常来说还要添加新接口。</li>
<li>Proxy模式完全可以重新定义一套新的接口</li>
</ul>
<h3 id="u884C_u4E3A_u578B_u8BBE_u8BA1_u6A21_u5F0F_u8865_u5145"><a href="#u884C_u4E3A_u578B_u8BBE_u8BA1_u6A21_u5F0F_u8865_u5145" class="headerlink" title="行为型设计模式补充"></a>行为型设计模式补充</h3><h4 id="Chain_of_Responsibility"><a href="#Chain_of_Responsibility" class="headerlink" title="Chain of Responsibility"></a>Chain of Responsibility</h4><p><strong>意图：将对象连成一条链并沿着链传递某个请求，直到有某个对象处理它为止。</strong></p>
<p>大部分情况下连接起来的对象本身就存在一定的层次结构关系，少数情况下面这些连接起来的对象是内部构造的。 职责链通常与Composite模式一起使用，一个构件的父构件可以作为它的后继结点。许多类库使用职责链模式来处理事件， 比如在UI部分的话View本来就是相互嵌套的，一个View对象可能存在Parent View对象。如果某个UI不能够处理事件的话， 那么完全可以交给Parent View来完成事件处理以此类推。 </p>
<h4 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h4><p><strong>意图：将一个请求封装成为一个对象。</strong></p>
<p>Command模式可以说是回调机制(Callback)的一个面向对象的替代品。对于回调函数来说需要传递一个上下文参数(context)， 同时内部附带一些逻辑。将上下文参数以及逻辑包装起来的话那么就是一个Command对象。 Command对象接口可以非常简单只有Execute/UnExecute，但是使用Command对象来管理请求之后， 就可以非常方便地实现命令的复用，排队，重做，撤销，事务等。</p>
<h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><p><strong>意图：提供一种方法顺序访问一个聚合对象中各个元素，但是又不需要暴露该对象内部表示。</strong></p>
<p>将遍历机制与聚合对象表示分离，使得我们可以定义不同的迭代器来实现不同的迭代策略，而无需在聚合对象接口上面列举他们。 一个健壮的迭代器,应该保证在聚合对象上面插入和删除操作不会干扰遍历，“同时不需要copy这个聚合对象。 一种实现方式就是在聚合对象上面注册某个迭代器，一旦聚合对象发生改变的话，需要调整迭代器内部的状态。</p>
<h4 id="Template_Method"><a href="#Template_Method" class="headerlink" title="Template Method"></a>Template Method</h4><p><strong>意图：定义一个操作里面算法的骨架，而将一些步骤延迟到子类。</strong></p>
<p>假设父类A里面有抽象方法Step1(),Step2(),默认方法Step3()。并且A提供一个操作X()，分别依次使用Step1(),Step2(),Step3()。对于A的子类，通过实现自己的Step1(),Step2() (选择性地实现Step3())，提供属于子类的X具体操作。 这里操作X()就是算法的骨架，子类需要复写其中部分step，但不改变X的执行流程。</p>
<p>很重要的一点是模板方法必须指明哪些操作是钩子操作(可以被重定义的，比如Step3),以及哪些操作是抽象操作“(必须被重定义，比如Step1和Step2)。要有效地重用一个抽象类，子类编写者必须明确了解哪些操作是设计为有待重定义的。</p>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://wdxtub.com/interview/14520604447774.html">Web Crawler</a></li>
<li><a href="http://wdxtub.com/interview/14520604447653.html">Tiny URL</a></li>
<li><a href="http://wdxtub.com/interview/14520604447530.html">Stock Data</a></li>
<li><a href="http://wdxtub.com/interview/14520604447397.html">Social Network</a></li>
<li><a href="http://wdxtub.com/interview/14520604447289.html">Singleton</a></li>
<li><a href="http://wdxtub.com/interview/14520604447186.html">Sales Rank</a></li>
<li><a href="http://wdxtub.com/interview/14520604447071.html">Rank from Stream</a></li>
<li><a href="http://wdxtub.com/interview/14520604446948.html">Personal Financial Manager</a></li>
<li><a href="http://wdxtub.com/interview/14520604446839.html">Peeking Iterator</a></li>
<li><a href="http://wdxtub.com/interview/14520604446725.html">Pastebin</a></li>
<li><a href="http://wdxtub.com/interview/14520604446608.html">Parking Lot</a></li>
<li><a href="http://wdxtub.com/interview/14520604446509.html">Othello</a></li>
<li><a href="http://wdxtub.com/interview/14520604446403.html">Online Book Reader</a></li>
<li><a href="http://wdxtub.com/interview/14520604446344.html">Music Player</a></li>
<li><a href="http://wdxtub.com/interview/14520604446282.html">Minesweeper</a></li>
<li><a href="http://wdxtub.com/interview/14520604446223.html">LRU Cache</a></li>
<li><a href="http://wdxtub.com/interview/14520604446169.html">Jukebox</a></li>
<li><a href="http://wdxtub.com/interview/14520604446101.html">Jigsaw</a></li>
<li><a href="http://wdxtub.com/interview/14520604446041.html">Hash Table</a></li>
<li><a href="http://wdxtub.com/interview/14520604445970.html">File System</a></li>
<li><a href="http://wdxtub.com/interview/14520604445920.html">Elevator</a></li>
<li><a href="http://wdxtub.com/interview/14520604445872.html">Deck of Cards</a></li>
<li><a href="http://wdxtub.com/interview/14520604445829.html">Chat Server</a></li>
<li><a href="http://wdxtub.com/interview/14520604445788.html">Call Center</a></li>
<li><a href="http://wdxtub.com/interview/14520604445745.html">Animal Shelter</a></li>
<li><a href="http://wdxtub.com/interview/14520604445699.html">Add and Search Word - Data structure design</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>设计题可以分成两个类别：系统架构设计和利用面向对象编程原理进行程序设计。重点是要体现出自己的想法和思路，毕竟设计类问题，没有所谓标准答案。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="面向对象" scheme="http://wdxtub.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 10 课 位操作]]></title>
    <link href="http://wdxtub.com/2016/01/23/programmer-startline-10/"/>
    <id>http://wdxtub.com/2016/01/23/programmer-startline-10/</id>
    <published>2016-01-23T22:48:01.000Z</published>
    <updated>2016-01-24T00:50:38.000Z</updated>
    <content type="html"><![CDATA[<p>位运算是一个很多歪门邪道技巧的题目类型，就我感觉来说，很多基本靠脑洞，不过更多的还是比较基本的几个操作组合组合就可以完成了。</p>
<a id="more"></a>
<hr>
<p>对于网络、操作系统、嵌入式系统等职位的面试，位运算也是常见的题目类型之一。所谓的位运算，是指按二进制进行的运算。常见运算包括求反，与运算，或运算，异或运算及位移。</p>
<p>在C/C++中，基本的位运算符总结如下，其中运算符优先级为从上到下递减，且&lt;&lt;，&gt;&gt;优先级相同：</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">位求反</td>
<td style="text-align:center">~var</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">左移(乘法)</td>
<td style="text-align:center">var &lt;&lt; position</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt;</td>
<td style="text-align:center">右移(除法)</td>
<td style="text-align:center">var &gt;&gt; position</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">位与</td>
<td style="text-align:center">var1 &amp; var2</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">位异或</td>
<td style="text-align:center">var1 ^ var2</td>
</tr>
<tr>
<td style="text-align:center">一条竖线</td>
<td style="text-align:center">位或</td>
<td style="text-align:center">var1 竖线 var2</td>
</tr>
</tbody>
</table>
<p>需要注意的是，位运算符只能用在带符号或无符号的char、short、int与long类型上。在实际应用中，建议用unsigned整型操作数，以免带符号操作数因为不同机器导致的结果不同：无符号数左移／右移默认移入的新比特是0。对于符号数，当最高位是1(代表负数)时，有的机器认为右移移入的新比特是1。此外，复杂的位运算建议都用括号强制计算顺序，而不是依赖于优先级，这样做可以增加可读性并避免错误。</p>
<p>用十六进制(hex)定义一个变量如下所示：</p>
<pre><code>unsigned short value = 0xFFFF;
</code></pre><p>等价于二进制(binary)定义：</p>
<pre><code>unsigned short value = 0b1111111111111111;
</code></pre><p>等价于十进制定义：</p>
<pre><code>unsigned short value = 65535;
</code></pre><h2 id="u89E3_u9898_u7B56_u7565"><a href="#u89E3_u9898_u7B56_u7565" class="headerlink" title="解题策略"></a>解题策略</h2><h3 id="u57FA_u672C_u7684_u4F4D_u8FD0_u7B97"><a href="#u57FA_u672C_u7684_u4F4D_u8FD0_u7B97" class="headerlink" title="基本的位运算"></a>基本的位运算</h3><p>最基本的操作包括获取位、设置位和清除位。获取位可以利用&amp;1：&amp;(0x1 &lt;&lt; pos) ；设置位可以利用|1: | (0x1 &lt;&lt; pos) ；清除位可以利用&amp;0: &amp;(~(0x1 &lt;&lt; pos))。判断某位是否相同用^：(A &amp; (0x1 &lt;&lt; pos)) ^ (B &amp; (0x1 &lt;&lt; pos))。</p>
<h3 id="u4F4D_u63A9_u7801"><a href="#u4F4D_u63A9_u7801" class="headerlink" title="位掩码"></a>位掩码</h3><p>选择合适的位掩码(bit mask)，然后与给定的二进制数进行基本位操作。而掩码，通常可以通过对~0，1 进行基本操作和加减法得到。例如，我们要构造一个第i到第j位为0，其他位为1的位掩码，则可以对~0进行左移操作获得形如111…0000的mask，再对~0进行右移操作，获得形如000…111的mask，最后通过位或(此处相当于相加)得到最终的位掩码。</p>
<p>在寻求得到一个特定的掩码时，还是利用最基本的获取位、设置位或清除位得到所需掩码的形态。另外，应当尽可能避免直接出现常数，比如使用32-i这样的情况(这里默认想要操作一个32bit的整型)，而应当定义一个意义明确的宏，以提高可读性：<code>#define INT_BIT_LENTH (32)</code>。</p>
<h3 id="XOR__u5F02_u6216"><a href="#XOR__u5F02_u6216" class="headerlink" title="XOR 异或"></a>XOR 异或</h3><blockquote>
<p>异或：相同为0，不同为1。也可用「不进位加法」来理解。</p>
</blockquote>
<p>异或操作的一些特点：</p>
<pre><code>x ^ 0 = x
x ^ 1s = ~x // 1s = ~0
x ^ (~x) = 1s
x ^ x = 0 // interesting and important!
a ^ b = c =&gt; a ^ c = b, b ^ c = a // swap
a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c // associative
</code></pre><h3 id="u79FB_u4F4D_u64CD_u4F5C"><a href="#u79FB_u4F4D_u64CD_u4F5C" class="headerlink" title="移位操作"></a>移位操作</h3><p>移位操作可近似为乘以/除以2的幂。0b0010 * 0b0110等价于0b0110 &lt;&lt; 2. 下面是一些常见的移位组合操作。</p>
<ol>
<li>将x最右边的n位清零 <code>x &amp; (~0 &lt;&lt; n)</code></li>
<li>获取x的第n位值(0或者1) <code>x &amp; (1 &lt;&lt; n)</code></li>
<li>获取x的第n位的幂值 <code>(x &gt;&gt; n) &amp; 1</code></li>
<li>仅将第n位置为1 <code>x | (1 &lt;&lt; n)</code></li>
<li>仅将第n位置为0 <code>x &amp; (~(1 &lt;&lt; n))</code></li>
<li>将x最高位至第n位(含)清零 <code>x &amp; ((1 &lt;&lt; n) - 1)</code></li>
<li>将第n位至第0位(含)清零 <code>x &amp; (~((1 &lt;&lt; (n + 1)) - 1))</code></li>
<li>仅更新第n位，写入值为v; v为1则更新为1，否则为0 <code>mask = ~(1 &lt;&lt; n); x = (x &amp; mask) | (v &lt;&lt; i)</code></li>
</ol>
<hr>
<ul>
<li>Two’s Complement - 负数可以看作是最高位的 1 为负，其他位为正，相加得到最后的值<ul>
<li>例如 -1 = (1111) 最高位的 1 表示 -8， 剩下三位等于 7，相加后等于 -1</li>
</ul>
</li>
<li>logical right shift - put a <code>0</code> in the most significant bit - <code>&gt;&gt;&gt;</code></li>
<li>arithmetic right shift - put a <code>1</code> in the most significant bit - <code>&gt;&gt;</code></li>
</ul>
<h3 id="Get_Bit"><a href="#Get_Bit" class="headerlink" title="Get Bit"></a>Get Bit</h3><p>Shifts 1 over by <code>i</code> bits, creating a value that looks like <code>00010000</code>. AND operation</p>
<pre><code>boolean getBit(int num, int i){
    return ((num &amp; (1 &lt;&lt; i)) != 0);
}
</code></pre><h3 id="Set_Bit"><a href="#Set_Bit" class="headerlink" title="Set Bit"></a>Set Bit</h3><p>Shifts 1 over by <code>i</code> bits, creating a value like <code>00010000</code>. OR operation</p>
<pre><code>int setBit(int num, int i){
    return num | (1 &lt;&lt; i);
}
</code></pre><h3 id="Clear_Bit"><a href="#Clear_Bit" class="headerlink" title="Clear Bit"></a>Clear Bit</h3><p>Create a number like <code>11101111</code> by creating the reverse of it (<code>00010000</code>). AND operation.</p>
<pre><code>int clearBit(int num, int i){
    int mask = ~(1 &lt;&lt; i);
    return num &amp; mask;
}
</code></pre><p>To clear all bits from the most significant bit through <code>i</code> (inclusive), we create a mask with a <code>1</code> at the ith bit(1 &lt;&lt; i). Then we subtract 1 from it, giving us a sequence of 0s followed by i 1s. AND operation.</p>
<pre><code>int clearBitsMSBthroughI(int num, int i){
    int mask = (1 &lt;&lt; i) - 1;
    return num &amp; mask;
}
</code></pre><p>To clear bits from i through 0 (inclusive), we take a sequence of 1s (which is -1) and shift it over by 31 - i bits.</p>
<pre><code>int clearBitsIthrough0(int num, int i){
    int mask = ~(-1 &gt;&gt;&gt; (31 - i));
    return num &amp; mask;
}
</code></pre><h3 id="Update_Bit"><a href="#Update_Bit" class="headerlink" title="Update Bit"></a>Update Bit</h3><p>Set the ith bit to a value <code>v</code></p>
<pre><code>int updateBit(int num, int i, boolean bitIs1){
    int value = bitIs1 ? 1 : 0;
    int mask = ~(1 &lt;&lt; i);
    return (num &amp; mask) | (value &lt;&lt; i);
}
</code></pre><h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://wdxtub.com/interview/14520596469127.html">Swap Bits</a></li>
<li><a href="http://wdxtub.com/interview/14520596469033.html">Square of Two</a></li>
<li><a href="http://wdxtub.com/interview/14520596468981.html">Single Element</a></li>
<li><a href="http://wdxtub.com/interview/14520596468879.html">Single Element II</a></li>
<li><a href="http://wdxtub.com/interview/14520596468931.html">Single Element III</a></li>
<li><a href="http://wdxtub.com/interview/14520596468825.html">Set Bits</a></li>
<li><a href="http://wdxtub.com/interview/14520596468781.html">Reverse Bits</a></li>
<li><a href="http://wdxtub.com/interview/14520596468734.html">Number of One</a></li>
<li><a href="http://wdxtub.com/interview/14520596468686.html">Next Number</a></li>
<li><a href="http://wdxtub.com/interview/14520596468613.html">Flip Bits</a></li>
<li><a href="http://wdxtub.com/interview/14520596468570.html">Draw Line</a></li>
<li><a href="http://wdxtub.com/interview/14520596468530.html">Divide Two Integers</a></li>
<li><a href="http://wdxtub.com/interview/14520596468493.html">Check Power of Two</a></li>
<li><a href="http://wdxtub.com/interview/14520596468456.html">Bitwise AND of Numbers Range</a></li>
<li><a href="http://wdxtub.com/interview/14520596468418.html">A Plus B</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>位运算是一个很多歪门邪道技巧的题目类型，就我感觉来说，很多基本靠脑洞，不过更多的还是比较基本的几个操作组合组合就可以完成了。</p>]]>
    
    </summary>
    
      <category term="位操作" scheme="http://wdxtub.com/tags/%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 9 课 数学]]></title>
    <link href="http://wdxtub.com/2016/01/23/programmer-startline-9/"/>
    <id>http://wdxtub.com/2016/01/23/programmer-startline-9/</id>
    <published>2016-01-23T21:30:05.000Z</published>
    <updated>2016-01-24T01:00:10.000Z</updated>
    <content type="html"><![CDATA[<p>虽然说编程中用到的数学都不算特别复杂，但是在具体的实现中，还是有一些技巧和门道的。</p>
<a id="more"></a>
<hr>
<h2 id="u89E3_u9898_u7B56_u7565"><a href="#u89E3_u9898_u7B56_u7565" class="headerlink" title="解题策略"></a>解题策略</h2><p>数学的问题，比较突出的体现在，一些常见的数学形式，比方说：</p>
<ul>
<li>排列</li>
<li>组合</li>
<li>质数</li>
<li>开方</li>
<li>幂次</li>
</ul>
<p>还有一些概率的问题，需要一定的概率基础，这里就不再赘述了。具体更多可以参考题目。</p>
<p>最后一类是脑筋急转弯问题，也就是看脑洞的，这个就随缘了。</p>
<p>（这一章实在没啥好写的，数学这个东西，懂就是懂，不懂就是不懂，还真没太多技巧）</p>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://wdxtub.com/interview/14520604913655.html">Kth Permuation</a></li>
<li><a href="http://wdxtub.com/interview/14520595470004.html">Check Permutation</a></li>
<li><a href="http://wdxtub.com/interview/14520604917011.html">Nth Prime</a></li>
<li><a href="http://wdxtub.com/interview/14520604918229.html">Pow(x, n)</a></li>
<li><a href="http://wdxtub.com/interview/14520604911732.html">Combinations</a></li>
<li><a href="http://wdxtub.com/interview/14520604910652.html">All Permutation</a></li>
<li><a href="http://wdxtub.com/interview/14520604910607.html">All Permutations II</a></li>
<li><a href="http://wdxtub.com/interview/14520606004545.html">Sqrt(x)</a></li>
<li><a href="http://wdxtub.com/interview/14520603231966.html">Remove Digit</a></li>
<li><a href="http://wdxtub.com/interview/14520603231831.html">Quick Pow</a></li>
<li><a href="http://wdxtub.com/interview/14520603231697.html">Previous Permuation</a></li>
<li><a href="http://wdxtub.com/interview/14520603231576.html">Poison</a></li>
<li><a href="http://wdxtub.com/interview/14520603231466.html">Permutation Sequence</a></li>
<li><a href="http://wdxtub.com/interview/14520603231334.html">Perfect Squares</a></li>
<li><a href="http://wdxtub.com/interview/14520603231230.html">Number of Digit</a></li>
<li><a href="http://wdxtub.com/interview/14520603231129.html">Number of Digit One</a></li>
<li><a href="http://wdxtub.com/interview/14520603231017.html">Next Permutation</a></li>
<li><a href="http://wdxtub.com/interview/14520603230913.html">Max Points on a Line</a></li>
<li><a href="http://wdxtub.com/interview/14520603230810.html">Jugs of Water</a></li>
<li><a href="http://wdxtub.com/interview/14520603230712.html">Index of Permuation</a></li>
<li><a href="http://wdxtub.com/interview/14520603230618.html">Index of Permutation II</a></li>
<li><a href="http://wdxtub.com/interview/14520603230526.html">The Heavy Pill</a></li>
<li><a href="http://wdxtub.com/interview/14520603230426.html">Hash Function</a></li>
<li><a href="http://wdxtub.com/interview/14520603230367.html">Happy Number</a></li>
<li><a href="http://wdxtub.com/interview/14520603230311.html">Fraction to Recurring Decimal</a></li>
<li><a href="http://wdxtub.com/interview/14520603230254.html">Factorial Trailing Zeroes</a></li>
<li><a href="http://wdxtub.com/interview/14520603230202.html">The Egg Drop Problem</a></li>
<li><a href="http://wdxtub.com/interview/14520603230148.html">Divide Number</a></li>
<li><a href="http://wdxtub.com/interview/14520603230094.html">均分 01</a></li>
<li><a href="http://wdxtub.com/interview/14520603230019.html">Count Primes</a></li>
<li><a href="http://wdxtub.com/interview/14520603229974.html">Cosine Similarity</a></li>
<li><a href="http://wdxtub.com/interview/14520603229929.html">Basketball</a></li>
<li><a href="http://wdxtub.com/interview/14520603229887.html">The Apocalypse</a></li>
<li><a href="http://wdxtub.com/interview/14520603229844.html">Ants on a Triangle</a></li>
<li><a href="http://wdxtub.com/interview/14520603229804.html">Add Digits</a></li>
<li><a href="http://wdxtub.com/interview/14520603229761.html">100 Lockers</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然说编程中用到的数学都不算特别复杂，但是在具体的实现中，还是有一些技巧和门道的。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="数学" scheme="http://wdxtub.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 8 课 排序和搜索]]></title>
    <link href="http://wdxtub.com/2016/01/23/programmer-startline-8/"/>
    <id>http://wdxtub.com/2016/01/23/programmer-startline-8/</id>
    <published>2016-01-23T14:20:57.000Z</published>
    <updated>2016-01-24T00:00:13.000Z</updated>
    <content type="html"><![CDATA[<p>排序和搜索其实比较相似，最重要的就是理解好二分的思想。无论是稍微复杂一点的排序算法，还是搜索，实际上都是分而治之思想的体现。</p>
<a id="more"></a>
<hr>
<h2 id="Bubble_Sort__u5192_u6CE1_u6392_u5E8F"><a href="#Bubble_Sort__u5192_u6CE1_u6392_u5E8F" class="headerlink" title="Bubble Sort 冒泡排序"></a>Bubble Sort 冒泡排序</h2><p>冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p>
<p>步骤：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(arry)</span>:</span></span><br><span class="line">    n = len(arry)                   <span class="comment">#获得数组的长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n-i):</span><br><span class="line">            <span class="keyword">if</span>  arry[j-<span class="number">1</span>] &gt; arry[j] :       <span class="comment">#如果前者比后者大</span></span><br><span class="line">                arry[j-<span class="number">1</span>],arry[j] = arry[j],arry[j-<span class="number">1</span>]      <span class="comment">#则交换两者</span></span><br><span class="line">    <span class="keyword">return</span> arry</span><br></pre></td></tr></table></figure>
<p>针对上述代码还有两种优化方案。</p>
<p>优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。</span></span><br><span class="line"><span class="comment">#用一个标记记录这个状态即可。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort2</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        flag = <span class="number">1</span>                    <span class="comment">#标记</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n-i):</span><br><span class="line">            <span class="keyword">if</span>  ary[j-<span class="number">1</span>] &gt; ary[j] :</span><br><span class="line">                ary[j-<span class="number">1</span>],ary[j] = ary[j],ary[j-<span class="number">1</span>]</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> flag :                   <span class="comment">#全排好序了，直接跳出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<p>优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序了。</span></span><br><span class="line"><span class="comment"># 因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort3</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    k = n                           <span class="comment">#k为循环的范围，初始值n</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,k):        <span class="comment">#只遍历到最后交换的位置即可</span></span><br><span class="line">            <span class="keyword">if</span>  ary[j-<span class="number">1</span>] &gt; ary[j] :</span><br><span class="line">                ary[j-<span class="number">1</span>],ary[j] = ary[j],ary[j-<span class="number">1</span>]</span><br><span class="line">                k = j               <span class="comment">#记录最后交换的位置</span></span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> flag :</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="Selection_Sort__u9009_u62E9_u6392_u5E8F"><a href="#Selection_Sort__u9009_u62E9_u6392_u5E8F" class="headerlink" title="Selection Sort 选择排序"></a>Selection Sort 选择排序</h2><p>选择排序无疑是最简单直观的排序。它的工作原理如下。</p>
<p>步骤：</p>
<ol>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>以此类推，直到所有元素均排序完毕。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">        min = i                             <span class="comment">#最小元素下标标记</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> ary[j] &lt; ary[min] :</span><br><span class="line">                min = j                     <span class="comment">#找到最小值的下标</span></span><br><span class="line">        ary[min],ary[i] = ary[i],ary[min]   <span class="comment">#交换两者</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="Insertion_Sort__u63D2_u5165_u6392_u5E8F"><a href="#Insertion_Sort__u63D2_u5165_u6392_u5E8F" class="headerlink" title="Insertion Sort 插入排序"></a>Insertion Sort 插入排序</h2><p>插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>步骤：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        <span class="keyword">if</span> ary[i] &lt; ary[i-<span class="number">1</span>]:</span><br><span class="line">            temp = ary[i]</span><br><span class="line">            index = i           <span class="comment">#待插入的下标</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):  <span class="comment">#从i-1 循环到 0 (包括0)</span></span><br><span class="line">                <span class="keyword">if</span> ary[j] &gt; temp :</span><br><span class="line">                    ary[j+<span class="number">1</span>] = ary[j]</span><br><span class="line">                    index = j   <span class="comment">#记录待插入下标</span></span><br><span class="line">                <span class="keyword">else</span> :</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            ary[index] = temp</span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="Shell_Sort__u5E0C_u5C14_u6392_u5E8F"><a href="#Shell_Sort__u5E0C_u5C14_u6392_u5E8F" class="headerlink" title="Shell Sort 希尔排序"></a>Shell Sort 希尔排序</h2><p>希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。</p>
<p>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。</p>
<p>例如，假设有这样一组数<code>[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]</code>，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<pre><code>13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
</code></pre><p>然后我们对每列进行排序：</p>
<pre><code>10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45
</code></pre><p>将上述四行数字，依序接在一起时我们得到：<code>[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]</code>。这时10已经移至正确位置了，然后再以3为步长进行排序：</p>
<pre><code>10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
</code></pre><p>排序之后变为：</p>
<pre><code>10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
</code></pre><p>最后以1步长进行排序（此时就是简单的插入排序了）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    gap = round(n/<span class="number">2</span>)       <span class="comment">#初始步长 , 用round四舍五入取整</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap,n):        <span class="comment">#每一列进行插入排序 , 从gap 到 n-1</span></span><br><span class="line">            temp = ary[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> ( j &gt;= gap <span class="keyword">and</span> ary[j-gap] &gt; temp ):    <span class="comment">#插入排序</span></span><br><span class="line">                ary[j] = ary[j-gap]</span><br><span class="line">                j = j - gap</span><br><span class="line">            ary[j] = temp</span><br><span class="line">        gap = round(gap/<span class="number">2</span>)                     <span class="comment">#重新设置步长</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<p>上面源码的步长的选择是从n/2开始，每次再减半，直至为0。步长的选择直接决定了希尔排序的复杂度</p>
<h2 id="Merge_Sort__u5F52_u5E76_u6392_u5E8F"><a href="#Merge_Sort__u5F52_u5E76_u6392_u5E8F" class="headerlink" title="Merge Sort 归并排序"></a>Merge Sort 归并排序</h2><p>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p>
<p>先考虑合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p>
<p>再考虑递归分解，基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(ary) &lt;= <span class="number">1</span> : <span class="keyword">return</span> ary</span><br><span class="line">    num = int(len(ary)/<span class="number">2</span>)       <span class="comment">#二分分解</span></span><br><span class="line">    left = merge_sort(ary[:num])</span><br><span class="line">    right = merge_sort(ary[num:])</span><br><span class="line">    <span class="keyword">return</span> merge(left,right)    <span class="comment">#合并数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left,right)</span>:</span></span><br><span class="line">    <span class="string">'''合并操作，</span><br><span class="line">    将两个有序数组left[]和right[]合并成一个大的有序数组'''</span></span><br><span class="line">    l,r = <span class="number">0</span>,<span class="number">0</span>           <span class="comment">#left与right数组的下标指针</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> l &lt; len(left) <span class="keyword">and</span> r &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[l] &lt; right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">    result += left[l:]</span><br><span class="line">    result += right[r:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="Quick_Sort__u5FEB_u901F_u6392_u5E8F"><a href="#Quick_Sort__u5FEB_u901F_u6392_u5E8F" class="headerlink" title="Quick Sort 快速排序"></a>Quick Sort 快速排序</h2><p>快速排序通常明显比同为Ο(n log n)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。</p>
<p>步骤：</p>
<ol>
<li>从数列中挑出一个元素作为基准数。</li>
<li>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。</li>
<li>再对左右区间递归执行第二步，直至各区间只有一个数。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> qsort(ary,<span class="number">0</span>,len(ary)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(ary,left,right)</span>:</span></span><br><span class="line">    <span class="comment">#快排函数，ary为待排序数组，left为待排序的左边界，right为右边界</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right : <span class="keyword">return</span> ary</span><br><span class="line">    key = ary[left]     <span class="comment">#取最左边的为基准数</span></span><br><span class="line">    lp = left           <span class="comment">#左指针</span></span><br><span class="line">    rp = right          <span class="comment">#右指针</span></span><br><span class="line">    <span class="keyword">while</span> lp &lt; rp :</span><br><span class="line">        <span class="keyword">while</span> ary[rp] &gt;= key <span class="keyword">and</span> lp &lt; rp :</span><br><span class="line">            rp -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> ary[lp] &lt;= key <span class="keyword">and</span> lp &lt; rp :</span><br><span class="line">            lp += <span class="number">1</span></span><br><span class="line">        ary[lp],ary[rp] = ary[rp],ary[lp]</span><br><span class="line">    ary[left],ary[lp] = ary[lp],ary[left]</span><br><span class="line">    qsort(ary,left,lp-<span class="number">1</span>)</span><br><span class="line">    qsort(ary,rp+<span class="number">1</span>,right)</span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="Heap_Sort__u5806_u6392_u5E8F"><a href="#Heap_Sort__u5806_u6392_u5E8F" class="headerlink" title="Heap Sort 堆排序"></a>Heap Sort 堆排序</h2><p>堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 。</p>
<p><strong>二叉堆具有以下性质：</strong></p>
<ol>
<li>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</li>
<li>每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</li>
</ol>
<p><strong>步骤：</strong></p>
<ol>
<li>构造最大堆（<code>Build_Max_Heap</code>）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</li>
<li>堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0…n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0…n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</li>
<li>最大堆调整（<code>Max_Heapify</code>）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(ary)</span> :</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    first = int(n/<span class="number">2</span>-<span class="number">1</span>)       <span class="comment">#最后一个非叶子节点</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(first,-<span class="number">1</span>,-<span class="number">1</span>) :     <span class="comment">#构造大根堆</span></span><br><span class="line">        max_heapify(ary,start,n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> range(n-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):           <span class="comment">#堆排，将大根堆转换成有序数组</span></span><br><span class="line">        ary[end],ary[<span class="number">0</span>] = ary[<span class="number">0</span>],ary[end]</span><br><span class="line">        max_heapify(ary,<span class="number">0</span>,end-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ary</span><br><span class="line"></span><br><span class="line"><span class="comment">#最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点</span></span><br><span class="line"><span class="comment">#start为当前需要调整最大堆的位置，end为调整边界</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_heapify</span><span class="params">(ary,start,end)</span>:</span></span><br><span class="line">    root = start</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span> :</span><br><span class="line">        child = root*<span class="number">2</span> +<span class="number">1</span>               <span class="comment">#调整节点的子节点</span></span><br><span class="line">        <span class="keyword">if</span> child &gt; end : <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> child+<span class="number">1</span> &lt;= end <span class="keyword">and</span> ary[child] &lt; ary[child+<span class="number">1</span>] :</span><br><span class="line">            child = child+<span class="number">1</span>             <span class="comment">#取较大的子节点</span></span><br><span class="line">        <span class="keyword">if</span> ary[root] &lt; ary[child] :     <span class="comment">#较大的子节点成为父节点</span></span><br><span class="line">            ary[root],ary[child] = ary[child],ary[root]     <span class="comment">#交换</span></span><br><span class="line">            root = child</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="u6307_u6807_u5BF9_u6BD4"><a href="#u6307_u6807_u5BF9_u6BD4" class="headerlink" title="指标对比"></a>指标对比</h2><table>
<thead>
<tr>
<th style="text-align:center">排序方法</th>
<th style="text-align:center">平均情况</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">辅助空间</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">O(nlogn)~O(n2)</td>
<td style="text-align:center">O(n1.3)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(logn)~O(n)</td>
<td style="text-align:center">不稳定</td>
</tr>
</tbody>
</table>
<h2 id="Bucket_Sort__u6876_u6392_u5E8F"><a href="#Bucket_Sort__u6876_u6392_u5E8F" class="headerlink" title="Bucket Sort 桶排序"></a>Bucket Sort 桶排序</h2><p>桶排序和归并排序有那么点点类似，也使用了归并的思想。大致步骤如下：</p>
<ol>
<li>设置一个定量的数组当作空桶。</li>
<li>Divide - 从待排序数组中取出元素，将元素按照一定的规则塞进对应的桶子去。</li>
<li>对每个非空桶进行排序，通常可在塞元素入桶时进行插入排序。</li>
<li>Conquer - 从非空桶把元素再放回原来的数组中。”</li>
</ol>
<h2 id="Counting_Sort__u8BA1_u6570_u6392_u5E8F"><a href="#Counting_Sort__u8BA1_u6570_u6392_u5E8F" class="headerlink" title="Counting Sort 计数排序"></a>Counting Sort 计数排序</h2><p>计数排序，顾名思义，就是对待排序数组按元素进行计数。使用前提是需要先知道待排序数组的元素范围，将这些一定范围的元素置于新数组中，新数组的大小为待排序数组中最大元素与最小元素的差值。</p>
<p>维基上总结的四个步骤如下：</p>
<ol>
<li>定新数组大小——找出待排序的数组中最大和最小的元素</li>
<li>统计次数——统计数组中每个值为i的元素出现的次数，存入新数组C的第i项</li>
<li>对统计次数逐个累加——对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>
<li>反向填充目标数组——将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>
<li>其中反向填充主要是为了避免重复元素落入新数组的同一索引处。</li>
</ol>
<h2 id="u89E3_u9898_u7B56_u7565"><a href="#u89E3_u9898_u7B56_u7565" class="headerlink" title="解题策略"></a>解题策略</h2><h3 id="u52A8_u6001_u6570_u636E_u7ED3_u6784_u7684_u7EF4_u62A4"><a href="#u52A8_u6001_u6570_u636E_u7ED3_u6784_u7684_u7EF4_u62A4" class="headerlink" title="动态数据结构的维护"></a>动态数据结构的维护</h3><p>维护动态数据(data stream)的最大值、最小值或中位数，可以考虑使用堆。如果是动态数据求最大的k个元素，因为元素总数量不确定，不能使用quick select，这种情况下也应该用堆解决。</p>
<p>如果需要一个动态插入/删除的有序数据结构，那么可以使用二叉搜索树，因为它天生就是一个动态的有序数组，并且支持检索。</p>
<h3 id="u5BF9_u4E8E_u6709_u5E8F_uFF0F_u90E8_u5206_u6709_u5E8F_u5BB9_u5668_u7684_u641C_u7D22"><a href="#u5BF9_u4E8E_u6709_u5E8F_uFF0F_u90E8_u5206_u6709_u5E8F_u5BB9_u5668_u7684_u641C_u7D22" class="headerlink" title="对于有序／部分有序容器的搜索"></a>对于有序／部分有序容器的搜索</h3><p>用二分查找(binary search)。</p>
<h3 id="u6570_u636E_u8303_u56F4_u6709_u9650_u3001_u79BB_u6563"><a href="#u6570_u636E_u8303_u56F4_u6709_u9650_u3001_u79BB_u6563" class="headerlink" title="数据范围有限、离散"></a>数据范围有限、离散</h3><p>数据范围有限、离散(或存在大量重复数据，即密集数据)的排序问题，一般可以使用桶排序。对于有限位数的数据(如string, <code>vector&lt;int&gt;</code>, int)，可以利用基数排序进行数值序或词典序排序。</p>
<h3 id="Scalability__26amp_3B_Memory_Limits__u95EE_u9898"><a href="#Scalability__26amp_3B_Memory_Limits__u95EE_u9898" class="headerlink" title="Scalability &amp; Memory Limits 问题"></a>Scalability &amp; Memory Limits 问题</h3><p>对这类问题一般采用Divide &amp; Conquer策略，即对问题进行预处理，将问题的输入进行分割、归类(sorting)，放入相应的桶(单机上的某一块Chunk，或者分布式系统中的一台单机)，再对每个桶进行后期处理，最后合并结果。</p>
<p>整个过程中应该用到哈希函数: 对于Memory Limits问题，一般可以直接利用哈希函数建立对象到索引的直接映射；对Scalability问题，一般可以用哈希表来记录对象与存储该对象的机器之间的映射，在该机器上进一步做映射以获得索引。</p>
<h2 id="u5E38_u89C1_u7684_u5916_u6392_u5E8F_u7B97_u6CD5"><a href="#u5E38_u89C1_u7684_u5916_u6392_u5E8F_u7B97_u6CD5" class="headerlink" title="常见的外排序算法"></a>常见的外排序算法</h2><p>外排序算法的核心思路在于把文件分块读到内存，在内存中对每块文件依次进行排序，最后合并排序后的各块数据，依次按顺序写回文件。相比于内排序，外排序需要进行多次磁盘读写，因此执行效率往往低于内排序，时间主要花费于磁盘读写上。我们给出外排序的算法步骤如下：</p>
<p>假设文件需要分成k块读入，需要从小到大进行排序</p>
<ol>
<li>依次读入每个文件块，在内存中对当前文件块进行排序(应用恰当的内排序算法)。此时，每块文件相当于一个由小到大排列的有序队列</li>
<li>在内存中建立一个最小值堆，读入每块文件的队列头</li>
<li>弹出堆顶元素，如果元素来自第i块，则从第i块文件中补充一个元素到最小值堆。弹出的元素暂存至临时数组</li>
<li>当临时数组存满时，将数组写至磁盘，并清空数组内容。</li>
<li>重复过程3)，4)，直至所有文件块读取完毕</li>
</ol>
<h2 id="u5FEB_u901F_u9009_u62E9_u7B97_u6CD5__28quick_selection_algorithm_29"><a href="#u5FEB_u901F_u9009_u62E9_u7B97_u6CD5__28quick_selection_algorithm_29" class="headerlink" title="快速选择算法 (quick selection algorithm)"></a>快速选择算法 (quick selection algorithm)</h2><p>快速选择算法能够在平均O(n)时间内从一个无序数组中返回第k大的元素。算法实际上利用了快速排序的思想，将数组依照一个轴值分割成两个部分，左边元素都比轴值小，右边元素都比轴值大。由于轴值下标已知，则可以判断所求元素落在数组的哪一部分，并在那一部分继续进行上述操作，直至找到该元素。与快排不同，由于快速选择算法只在乎所求元素所在的那一部分，所以时间复杂度是O(n)。关于算法复杂度的理论分析请见“工具箱”给出的参考资料。我们给出算法实现如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int <span class="built_in">partition</span>( int array[], int <span class="keyword">left</span>, int <span class="keyword">right</span> ) &#123;</span><br><span class="line">    int pivot = array[<span class="keyword">right</span>];</span><br><span class="line">    <span class="keyword">while</span>( <span class="keyword">left</span> != <span class="keyword">right</span> )&#123;</span><br><span class="line">        <span class="keyword">while</span>( array[<span class="keyword">left</span>] &lt; pivot &amp;&amp; <span class="keyword">left</span> &lt; <span class="keyword">right</span>)</span><br><span class="line">            <span class="keyword">left</span>++;</span><br><span class="line">            <span class="keyword">left</span>++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">left</span> &lt; <span class="keyword">right</span>) &#123;</span><br><span class="line">            <span class="built_in">swap</span>( array[<span class="keyword">left</span>], array[<span class="keyword">right</span>--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( array[<span class="keyword">right</span>] &gt; pivot &amp;&amp; <span class="keyword">left</span> &lt; <span class="keyword">right</span>)</span><br><span class="line">            <span class="keyword">right</span>--;</span><br><span class="line">        <span class="keyword">if</span>( <span class="keyword">left</span> &lt; <span class="keyword">right</span> )</span><br><span class="line">            <span class="built_in">swap</span>( array[<span class="keyword">left</span>++], array[<span class="keyword">right</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">left</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int quick_select(int array[], int <span class="keyword">left</span>, int <span class="keyword">right</span>, int k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">left</span> &gt;= <span class="keyword">right</span> )</span><br><span class="line">        <span class="keyword">return</span> array[<span class="keyword">left</span>];</span><br><span class="line">    int index = <span class="built_in">partition</span>(array, <span class="keyword">left</span>, <span class="keyword">right</span>);</span><br><span class="line">    int size = index - <span class="keyword">left</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( size == k )</span><br><span class="line">        <span class="keyword">return</span> array[<span class="keyword">left</span> + k - <span class="number">1</span>]; <span class="comment">// the pivot is the kth largest element</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( size &gt; k )</span><br><span class="line">        <span class="keyword">return</span> quick_select(array, <span class="keyword">left</span>, index - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> quick_select(array, index + <span class="number">1</span>, <span class="keyword">right</span> , k - size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Get the k largest elements in an array with O(n) expected time, they don’t need to be sorted.</p>
</blockquote>
<p>解题分析：实际上和quick select的应用场景是一致的，先找到第k大的元素，再将数组重新整理，找出比第k大的元素小的所有元素。</p>
<blockquote>
<p>There are n points on a 2D plan, find the k points that are closest to origin ( x= 0, y= 0).</p>
</blockquote>
<p>解题分析：在这里已知点的数量，因此k个点到原点的距离构成size确定的静态数组，应该对这个数组使用快速选择算法。</p>
<h2 id="u4E8C_u5206_u67E5_u627E__28Binary_search_29"><a href="#u4E8C_u5206_u67E5_u627E__28Binary_search_29" class="headerlink" title="二分查找 (Binary search)"></a>二分查找 (Binary search)</h2><p>对于已排序的有序线性容器而言(比如数组，vector)，二分查找(Binary search)几乎总是最优的搜索方案。二分查找将容器等分为两部分，再根据中间节点与待搜索数据的相对大小关系，进一步搜索其中某一部分。二分查找的算法复杂度为O(logn)，算法复杂度的具体分析请见“工具箱”给出的参考资料。算法实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="comment">// value not found</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = right - (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[mid] == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[mid] &lt; value) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(<span class="built_in">array</span>, mid + <span class="number">1</span>, right, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(<span class="built_in">array</span>, left, mid - <span class="number">1</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于局部有序的数据，也可以根据其局部有序的特性，尽可能地利用逼近、剪枝，使用二分查找的变种进行搜索。</p>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://wdxtub.com/interview/14520606004678.html">Stream Integer</a></li>
<li><a href="http://wdxtub.com/interview/14520606004412.html">Sparse Search</a></li>
<li><a href="http://wdxtub.com/interview/14520606004279.html">Sorted Search, No Size</a></li>
<li><a href="http://wdxtub.com/interview/14520606004147.html">Sort Colors</a></li>
<li><a href="http://wdxtub.com/interview/14520606003957.html">Sort Colors II</a></li>
<li><a href="http://wdxtub.com/interview/14520606003704.html">Sort Age</a></li>
<li><a href="http://wdxtub.com/interview/14520606003582.html">Social Network</a></li>
<li><a href="http://wdxtub.com/interview/14520606003458.html">Search Rotated Array</a></li>
<li><a href="http://wdxtub.com/interview/14520606003336.html">Search Range</a></li>
<li><a href="http://wdxtub.com/interview/14520606003219.html">Search Insert Position</a></li>
<li><a href="http://wdxtub.com/interview/14520606003106.html">Search 2D matrix</a></li>
<li><a href="http://wdxtub.com/interview/14520606002879.html">Nuts &amp; Bolts Problem</a></li>
<li><a href="http://wdxtub.com/interview/14520606002777.html">Missing Number</a></li>
<li><a href="http://wdxtub.com/interview/14520606002660.html">Find Minimum in Rotated Sorted Array</a></li>
<li><a href="http://wdxtub.com/interview/14520606002549.html">Median of Two Sorted Array</a></li>
<li><a href="http://wdxtub.com/interview/14520606002445.html">Maximum Gap</a></li>
<li><a href="http://wdxtub.com/interview/14520606002338.html">Kth Smallest Number</a></li>
<li><a href="http://wdxtub.com/interview/14520606002263.html">Kth Largest in Sorted Matrix</a></li>
<li><a href="http://wdxtub.com/interview/14520606002197.html">Kth Largest Element</a></li>
<li><a href="http://wdxtub.com/interview/14520606002136.html">Inverted Index</a></li>
<li><a href="http://wdxtub.com/interview/14520606002077.html">Index Equals to Value</a></li>
<li><a href="http://wdxtub.com/interview/14520606002015.html">Hit Counter</a></li>
<li><a href="http://wdxtub.com/interview/14520606001958.html">Group Anagrams</a></li>
<li><a href="http://wdxtub.com/interview/14520606001885.html">Group Anagrams List</a></li>
<li><a href="http://wdxtub.com/interview/14520606001824.html">First Missing Positive Number</a></li>
<li><a href="http://wdxtub.com/interview/14520606001769.html">First Error Version</a></li>
<li><a href="http://wdxtub.com/interview/14520606001720.html">Find Peak Element</a></li>
<li><a href="http://wdxtub.com/interview/14520606001667.html">名人问题</a></li>
<li><a href="http://wdxtub.com/interview/14520606001623.html">Count Plane</a></li>
<li><a href="http://wdxtub.com/interview/14520606001575.html">Binary Search</a></li>
<li><a href="http://wdxtub.com/interview/14520607214993.html">Cut Wood</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>排序和搜索其实比较相似，最重要的就是理解好二分的思想。无论是稍微复杂一点的排序算法，还是搜索，实际上都是分而治之思想的体现。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="排序" scheme="http://wdxtub.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="搜索" scheme="http://wdxtub.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 7 课 树和图]]></title>
    <link href="http://wdxtub.com/2016/01/23/programmer-startline-7/"/>
    <id>http://wdxtub.com/2016/01/23/programmer-startline-7/</id>
    <published>2016-01-23T14:20:51.000Z</published>
    <updated>2016-01-23T23:57:19.000Z</updated>
    <content type="html"><![CDATA[<p>树和图的问题，说难也难，说简单也简单。难在思路和理解，简单在很多时候可以利用递归得到非常优雅的解法。</p>
<a id="more"></a>
<hr>
<h2 id="u89E3_u9898_u7B56_u7565"><a href="#u89E3_u9898_u7B56_u7565" class="headerlink" title="解题策略"></a>解题策略</h2><p>对于树和图的性质，一般全局解依赖于局部解。通常可以用DFS来判断子问题的解，然后综合得到当前的全局结论。</p>
<p>值得注意的是，当我们在传递节点指针的时候，其实其代表的不只是这个节点本身，而是指对整个子树、子图进行操作。只要每次递归的操作对象的结构一致，我们就可以选择Divide and Conquer(事实上对于树和图总是如此，因为subgraph和subtree仍然是graph和tree结构)。实现函数递归的步骤是：首先设置函数出口，就此类问题而言，递归出口往往是node == NULL。其次，在构造递归的时候，不妨将递归调用自身的部分视为黑盒，并想象它能够完整解决子问题。以二叉树的中序遍历为例，函数的实现为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    InOrderTraversal(root-&gt;left);</span><br><span class="line">    root-&gt;print();</span><br><span class="line">    InOrderTraversal(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想象递归调用的部分 <code>InOrderTraversal(root-&gt;left)／InOrderTraversal(root-&gt;right)</code>能够完整地中序遍历一棵子树，那么根据中序遍历“按中序遍历左子树；访问根结点；按中序遍历右子树”的定义，写出上述实现就显得很自然了。</p>
<h3 id="DFS__u5904_u7406_u6811_u7684_u95EE_u9898"><a href="#DFS__u5904_u7406_u6811_u7684_u95EE_u9898" class="headerlink" title="DFS 处理树的问题"></a>DFS 处理树的问题</h3><p>有一类关于树的问题是， 要求找出一条满足特定条件的路径 。对于这类问题，通常都是传入一个 vector 记录当前走过的路径(为尽可能模版化，统一记为path)，传入 path 的时候可以是引用，可以是值。还需要传入另一个 vector 引用记录所有符合条件的 path (为尽可能模版化，统一记为result)。注意， result 可以用引用或指针形式，相当于一个全局变量，或者就开辟一个独立于函数的成员变量。由于 path 通常是vector ，那么result就是 <vector> 。当然，那个特定条件，也是函数的一个输入变量。</vector></p>
<p>在解答此类问题的时候，通常都采用DFS来访问，利用回溯思想，直到无法继续访问再返回。值得注意的是，如果path本身是以引用(reference)的形式传入，那么需要在返回之前消除之前所做的影响(回溯)。因为传引用(Pass by reference)相当于把path也看作全局变量，对path的任何操作都会影响其他递归状态，而传值(pass by value)则不会。传引用的好处是可以减小空间开销。</p>
<h3 id="u6811_u548C_u5176_u4ED6_u6570_u636E_u7ED3_u6784_u7684_u76F8_u4E92_u8F6C_u6362"><a href="#u6811_u548C_u5176_u4ED6_u6570_u636E_u7ED3_u6784_u7684_u76F8_u4E92_u8F6C_u6362" class="headerlink" title="树和其他数据结构的相互转换"></a>树和其他数据结构的相互转换</h3><p>这类题目要求将树的结构转化成其他数据结构，例如链表、数组等，或者反之，从数组等结构构成一棵树。前者通常是通过树的遍历，合并局部解来得到全局解，而后者则可以利用D&amp;C的策略，递归将数据结构的两部分分别转换成子树，再合并。</p>
<h3 id="u5BFB_u627E_u7279_u5B9A_u8282_u70B9"><a href="#u5BFB_u627E_u7279_u5B9A_u8282_u70B9" class="headerlink" title="寻找特定节点"></a>寻找特定节点</h3><p>此类题目通常会传入一个当前节点，要求找到与此节点具有一定关系的特定节点：例如前驱、后继、左／右兄弟等。</p>
<p>对于这类题目，首先可以了解一下常见特定节点的定义及性质。在存在指向父节点指针的情况下，通常可以由当前节点出发，向上倒推解决。如果节点没有父节点指针，一般需要从根节点出发向下搜索，搜索的过程就是DFS。</p>
<h3 id="u56FE_u7684_u8BBF_u95EE"><a href="#u56FE_u7684_u8BBF_u95EE" class="headerlink" title="图的访问"></a>图的访问</h3><p>关于图的问题一般有两类。一类是前面提到的关于图的基本问题，例如图的遍历、最短路径、可达性等；另一类是将问题转化成图，再通过图的遍历解决问题。第二类问题有一定的难度，但也有一些规律可循：如果题目有一个起始点和一个终止点，可以考虑看成图的最短路径问题。</p>
<h2 id="u6811"><a href="#u6811" class="headerlink" title="树"></a>树</h2><h3 id="u6811_u7684_u6982_u5FF5"><a href="#u6811_u7684_u6982_u5FF5" class="headerlink" title="树的概念"></a>树的概念</h3><p>树(tree)是一种能够分层存储数据的重要数据结构，树中的每个元素被称为树的节点，每个节点有若干个指针指向子节点。从节点的角度来看，树是由唯一的起始节点引出的节点集合。这个起始结点称为根(root)。树中节点的子树数目称为节点的度(degree)。在面试中，关于树的面试问题非常常见，尤其是关于二叉树(binary tree)，二叉搜索树(Binary Search Tree, BST)的问题。</p>
<p>所谓的二叉树，是指对于树中的每个节点而言，至多有左右两个子节点，即任意节点的度小于等于2。而广义的树则没有如上限制。二叉树是最常见的树形结构。二分查找树是二叉树的一种特例，对于二分查找树的任意节点，该节点存储的数值一定比左子树的所有节点的值大比右子树的所有节点的值小“(与之完全对称的情况也是有效的：即该节点存储的数值一定比左子树的所有节点的值小比右子树的所有节点的值大)。</p>
<p>基于这个特性，二分查找树通常被用于维护有序数据。二分查找树查找、删除、插入的效率都会于一般的线性数据结构。事实上，对于二分查找树的操作相当于执行二分搜索，其执行效率与树的高度(depth)有关，检索任意数据的比较次数不会多于树的高度。这里需要引入高度的概念：对一棵树而言，从根节点到某个节点的路径长度称为该节点的层数(level)，根节点为第0层，非根节点的层数是其父节点的层数加1。树的高度定义为该树中层数最大的叶节点的层数加1，即相当于于从根节点到叶节点的最长路径加1。由此，对于n个数据，二分查找树应该以“尽可能小的高度存储所有数据。由于二叉树第L层至多可以存储 2^L 个节点，故树的高度应在logn量级，因此，二分查找树的搜索效率为O(logn)。</p>
<p>直观上看，尽可能地把二分查找树的每一层“塞满”数据可以使得搜索效率最高，但考虑到每次插入删除都需要维护二分查找树的性质，要实现这点并不容易。特别地，当二分查找树退化为一个由小到大排列的单链表(每个节点只有右孩子)，其搜索效率变为O(n)。为了解决这样的问题，人们引入平衡二叉树的概念。所谓平衡二叉树，是指一棵树的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。通过恰当的构造与调整，平衡二叉树能够保证每次插入删除之后都保持平衡性。平衡二叉树的具体实现算法包括AVL算法和红黑算法等。由于平衡二叉树的实现比较复杂，故一般面试官只会问些概念性的问题。</p>
<h3 id="u6811_u578B_u7684_u6982_u5FF5"><a href="#u6811_u578B_u7684_u6982_u5FF5" class="headerlink" title="树型的概念"></a>树型的概念</h3><p>满二叉树(full binary tree)：如果一棵二叉树的任何结点，或者是叶节点，或者左右子树都存在，则这棵二叉树称作满二叉树。</p>
<p>完全二叉树(complete binary tree)：如果一棵二叉树最多只有最下面的两层节点度数可以小于2，并且最下面一层的节点都集中在该层最左边的连续位置上，则此二叉树称作完全二叉树。</p>
<h3 id="u4E8C_u53C9_u6811_u7684_u904D_u5386"><a href="#u4E8C_u53C9_u6811_u7684_u904D_u5386" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的常见操作包括树的遍历，即以一种特定的规律访问树中的所有节点。常见的遍历方式包括：</p>
<ul>
<li>前序遍历(Pre-order traversal)：访问根结点；按前序遍历左子树；按前序遍历右子树。</li>
<li>中序遍历(In-order traversal)：按中序遍历左子树；访问根结点；按中序遍历右子树。特别地，对于二分查找树而言，中序遍历可以获得一个由小到大或者由大到小的有序序列。</li>
<li>后续遍历(Post-order traversal)：按后序遍历左子树；按后序遍历右子树；访问根结点。</li>
</ul>
<p>以上三种遍历方式都是深度优先搜索算法(depth-first search)。深度优先算法最自然的实现方式是通过递归实现，事实上，大部分树相关的面试问题都可以优先考虑递归。此外，另一个值得注意的要点是：深度优先的算法往往都可以通过使用栈数据结构将递归化为非递归实现。这里利用了栈先进后出的特性，其数据的进出顺序与递归顺序一致(请见 Stack and Queue) 。</p>
<p>层次遍历(Level traversal)：首先访问第0层，也就是根结点所在的层；当第i层的所有结点访问完之后，再从左至右依次访问第i+1层的各个结点。层次遍历属于广度优先搜索算法(breadth-first search)。广度优先算法往往通过队列数据结构实现。</p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>字典树(trie or prefix tree)是一个26叉树，用于在一个集合中检索一个字符串，或者字符串前缀。字典树的每个节点有一个指针数组代表其所有子树，其本质上是一个哈希表，因为子树所在的位置(index)本身，就代表了节点对应的字母。节点与每个兄弟具有相同的前缀，这就是trie也被称为prefix tree的原因。</p>
<p>假设我们要存储如下名字，年龄：</p>
<pre><code>Amy 12
Ann 18
Bob 30
</code></pre><p>则构成的字典树如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.                 root: level <span class="number">0</span></span><br><span class="line">a---------b       level <span class="number">1</span></span><br><span class="line">|         |  </span><br><span class="line">m---n     o       level <span class="number">2</span></span><br><span class="line">|   |     |</span><br><span class="line">y   n     b       level <span class="number">3</span></span><br><span class="line">|   |     |</span><br><span class="line"><span class="number">12</span>  <span class="number">18</span>   <span class="number">30</span>       level <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>由于Amy和Ann共享前缀a，故第二个字母m和n构成兄弟关系。</p>
<p>字典树以及字典树节点的原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> TrieNode &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T mContent;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TrieNode*&gt; mChildren;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Node();</span><br><span class="line">        ~Node();</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> Trie;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Trie &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Trie();</span><br><span class="line">    ~Trie();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="built_in">string</span> s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchWord</span><span class="params">(<span class="built_in">string</span> s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteWord</span><span class="params">(<span class="built_in">string</span> s)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>字典树的基本功能如下：</p>
<p>1) void addWord(string key, int value);</p>
<p>添加一个键:值对。添加时从根节点出发，如果在第i层找到了字符串的第i个字母，则沿该节点方向下降一层(注意，如果下一层存储的是数据，则视为没有找到)。否则，将第i个字母作为新的兄弟插入到第i层。将键插入完成后插入值节点。</p>
<p>2) bool searchWord(string key, int &amp;value);</p>
<p>查找某个键是否存在，并返回值。从根节点出发，在第i层寻找字符串中第i个字母是否存在。如果是，沿着该节点方向下降一层；否则，返回false。</p>
<p>3) void deleteWord(string  key)</p>
<p>删除一个键:值对。删除时从底层向上删除节点，“直到遇到第一个有兄弟的节点(说明该节点向上都是与其他节点共享的前缀)，删除该节点。</p>
<h2 id="u5806_u4E0E_u4F18_u5148_u961F_u5217"><a href="#u5806_u4E0E_u4F18_u5148_u961F_u5217" class="headerlink" title="堆与优先队列"></a>堆与优先队列</h2><p>通常所说的堆(Heap)是指二叉堆，从结构上说是完全二叉树，从实现上说一般用数组。以数组的下标建立父子节点关系：对于下标为i的节点，其父节点为(int)i/2，其左子节点为2i，右子节点为2i+1。堆最重要的性质是，它满足部分有序(partial order)：最大(小)堆的父节点一定大于等于(小于等于)当前节点，且堆顶元素一定是当前所有元素的最大(小)值。</p>
<p>堆算法的核心在于插入，删除算法如何保持堆的性质(以下讨论均以最大堆为例):</p>
<p>下移(shift-down)操作：下移是堆算法的核心。对于最大值堆而言，对于某个节点的下移操作相当于比较当前节点与其左右子节点的相对大小。如果当前节点小于其子节点，则将当前节点与其左右子节点中较大的子节点对换，直至操作无法进行(即当前节点大于其左右子节点)。</p>
<p>建堆：假设堆数组长度为n，建堆过程如下，注意这里数组的下标是从 1 开始的：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="tag">i</span>, n/<span class="number">2</span> downto <span class="number">1</span></span><br><span class="line">    do <span class="function"><span class="title">shift-down</span><span class="params">(A,i)</span></span></span><br></pre></td></tr></table></figure>
<p>插入：将新元素插入堆的末尾，并且与父节点进行比较，如果新节点的值大于父节点，则与之交换，即上移(shift-up)，直至操作无法进行。</p>
<p>弹出堆顶元素：弹出堆顶元素(假设记为A[1]，堆尾元素记为A[n])并维护堆性质的过程如下：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output = <span class="literal">A</span>[<span class="number">1</span>]</span><br><span class="line">exchange <span class="literal">A</span>[<span class="number">1</span>] &lt;-&gt; <span class="literal">A</span>[n]</span><br><span class="line">heap size -= <span class="number">1</span></span><br><span class="line">shift-down(<span class="literal">A</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<p>值得注意的是，堆的插入操作逐层上移，耗时O(log(n))，与二叉搜索树的插入相同。但建堆通过下移所有非叶子节点(下标n/2至1)实现，耗时O(n)，小于BST的O(nlog(n))。</p>
<p>通过上述描述，不难发现堆其实就是一个优先队列。对于C++，标准模版库中的priority_queue是堆的一种具体实现。</p>
<h2 id="u56FE"><a href="#u56FE" class="headerlink" title="图"></a>图</h2><p>图(Graph)是节点集合的一个拓扑结构，节点之间通过边相连。图分为有向图和无向图。有向图的边具有指向性，即AB仅表示由A到B的路径，但并不意味着B可以连到A。与之对应地，无向图的每条边都表示一条双向路径。</p>
<p>图的数据表示方式也分为两种，即邻接表(adjacency list)和邻接矩阵(adjacency matrix)。对于节点A，A的邻接表将与A之间相连的所有节点以链表的形势存储起来，节点A为链表的头节点。这样，对于有V个节点的图而言，邻接表表示法包含V个链表。因此，链接表需要的空间复杂度为O(V+E)。邻接表适用于边数不多的稀疏图。但是，如果要确定图中边(u, v)是否存在，则只能在节点u对应的邻接表中以O(E)复杂度线性搜索。</p>
<p>对于有V个节点的图而言，邻接矩阵用V*V的二维矩阵形式表示一个图。矩阵中的元素Aij表示节点i到节点j之间是否直接有边相连。若有，则Aij数值为该边的权值，否则Aij数值为0。特别地，对于无向图，由于边的双向性，其邻接矩阵的转置矩阵为其本身。邻接矩阵的空间复杂度为O(V^2 )，适用于边较为密集的图。邻接矩阵在检索两个节点之间是否有边相连这样一个需求上，具有优势。</p>
<h2 id="u56FE_u7684_u904D_u5386"><a href="#u56FE_u7684_u904D_u5386" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>对于图的遍历(Graph Transversal)类似于树的遍历(事实上，树可以看成是图的一个特例)，也分为广度优先搜索和深度优先搜索。算法描述如下：</p>
<h3 id="u5E7F_u5EA6_u4F18_u5148"><a href="#u5E7F_u5EA6_u4F18_u5148" class="headerlink" title="广度优先"></a>广度优先</h3><p>对于某个节点，广度优先会先访问其所有邻近节点，再访问其他节点。即，对于任意节点，算法首先发现距离为d的节点，当所有距离为d的节点都被访问后，算法才会访问距离为d+1的节点。广度优先算法将每个节点着色为白，灰或黑，白色表示未被发现，灰色表示被发现，黑色表示已访问。算法利用先进先出队列来管理所有灰色节点。一句话总结，广度优先算法先访问当前节点，一旦发现未被访问的邻近节点，推入队列，以待访问。</p>
<p>《算法导论》第22章图的基本算法给出了广度优先的伪代码实现，引用如下：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BFS(<span class="keyword">G</span>, s)</span><br><span class="line"><span class="keyword">For</span> each vertex <span class="keyword">u</span> exept <span class="literal">s</span></span><br><span class="line">    <span class="keyword">Do</span> Color[<span class="keyword">u</span>] = WHITE</span><br><span class="line">        Distance[<span class="keyword">u</span>] = <span class="literal">MAX</span></span><br><span class="line">        Parent[<span class="keyword">u</span>] = NIL</span><br><span class="line">Color[s] = GRAY</span><br><span class="line">Distance[s] = 0</span><br><span class="line">Parent[s] = NIL</span><br><span class="line">Enqueue(Q, s)</span><br><span class="line"><span class="keyword">While</span> Q not empty</span><br><span class="line">    <span class="keyword">Do</span> <span class="keyword">u</span> = Dequeue(Q)</span><br><span class="line">        <span class="keyword">For</span> each v is the neighbor of <span class="keyword">u</span></span><br><span class="line">            <span class="keyword">Do</span> <span class="keyword">if</span> Color[v] == WHITE</span><br><span class="line">                Color[v] = GRAY</span><br><span class="line">                Distance[v] = Distance[<span class="keyword">u</span>] + 1</span><br><span class="line">                Parent[v] = <span class="keyword">u</span></span><br><span class="line">                Enqueue(Q, v)</span><br><span class="line">            Color[<span class="keyword">u</span>] = BLACK”</span><br></pre></td></tr></table></figure>
<h3 id="u6DF1_u5EA6_u4F18_u5148"><a href="#u6DF1_u5EA6_u4F18_u5148" class="headerlink" title="深度优先"></a>深度优先</h3><p>深度优先算法尽可能“深”地搜索一个图。对于某个节点v，如果它有未搜索的边，则沿着这条边继续搜索下去，直到该路径无法发现新的节点，回溯回节点v，继续搜索它的下一条边。深度优先算法也通过着色标记节点，白色表示未被发现，灰色表示被发现，黑色表示已访问。算法通过递归实现先进后出。一句话总结，深度优先算法一旦发现没被访问过的邻近节点，则立刻递归访问它，直到所有邻近节点都被访问过了，最后访问自己。</p>
<p>《算法导论》第22章图的基本算法给出了深度优先的伪代码实现，引用如下：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DFS(<span class="keyword">G</span>)</span><br><span class="line"><span class="keyword">For</span> each vertex v <span class="keyword">in</span> <span class="keyword">G</span></span><br><span class="line">    <span class="keyword">Do</span> Color[v] = WHITE</span><br><span class="line">    Parent[v] = NIL</span><br><span class="line"><span class="keyword">For</span> each vertex v <span class="keyword">in</span> <span class="keyword">G</span></span><br><span class="line">    DFS_Visit(v)</span><br><span class="line"></span><br><span class="line">DFS_Visit(<span class="keyword">u</span>)</span><br><span class="line">Color[<span class="keyword">u</span>] = GRAY</span><br><span class="line"><span class="keyword">For</span> each v is the neighbor of <span class="keyword">u</span></span><br><span class="line">    <span class="keyword">If</span> Color[v] == WHITE</span><br><span class="line">        Parent[v] = <span class="keyword">u</span></span><br><span class="line">        DFS_Visit(v)</span><br><span class="line">Color[<span class="keyword">u</span>] = BLACK</span><br></pre></td></tr></table></figure>
<h2 id="u5355_u6E90_u6700_u77ED_u8DEF_u5F84_u95EE_u9898"><a href="#u5355_u6E90_u6700_u77ED_u8DEF_u5F84_u95EE_u9898" class="headerlink" title="单源最短路径问题"></a>单源最短路径问题</h2><p>对于每条边都有一个权值的图来说，单源最短路径问题是指从某个节点出发，到其他节点的最短距离。该问题的常见算法有Bellman-Ford和Dijkstra算法。前者适用于一般情况(包括存在负权值的情况，但不存在从源点可达的负权值回路)，后者仅适用于均为非负权值边的情况。Dijkstra的运行时间可以小于Bellman-Ford。本小节重点介绍Dijkstra算法。</p>
<p>特别地，如果每条边权值相同(无权图)，由于从源开始访问图遇到节点的最小深度 就等于到该节点的最短路径，因此 Priority Queue就退化成Queue，Dijkstra算法就退化成BFS。</p>
<p>Dijkstra的核心在于，构造一个节点集合S，对于S中的每一个节点，源点到该节点的最短距离已经确定。进一步地，对于不在S中的节点，“我们总是选择其中到源点最近的节点，将它加入S，并且更新其邻近节点到源点的距离。算法实现时需要依赖优先队列。一句话总结，Dijkstra算法利用贪心的思想，在剩下的节点中选取离源点最近的那个加入集合，并且更新其邻近节点到源点的距离，直至所有节点都被加入集合。关于Dijkstra算法的正确性分析，可以使用数学归纳法证明，详见《算法导论》第24章，单源最短路径。 给出伪代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DIJKSTRA(G, s)</span><br><span class="line">S = EMPTY</span><br><span class="line"><span class="operator"><span class="keyword">Insert</span> all vertexes <span class="keyword">into</span> Q</span><br><span class="line"><span class="keyword">While</span> Q <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">empty</span></span><br><span class="line">    u = Q.top</span><br><span class="line">    S.<span class="keyword">insert</span>(u)</span><br><span class="line">    <span class="keyword">For</span> <span class="keyword">each</span> v <span class="keyword">is</span> the neighbor <span class="keyword">of</span> u</span><br><span class="line">        <span class="keyword">If</span> <span class="keyword">d</span>[v] &gt; <span class="keyword">d</span>[u] + weight(u, v)</span><br><span class="line">            <span class="keyword">d</span>[v] = <span class="keyword">d</span>[u] + weight(u, v)</span><br><span class="line">            <span class="keyword">parent</span>[v] = u</span></span><br></pre></td></tr></table></figure>
<h2 id="u4EFB_u610F_u4E24_u70B9_u4E4B_u95F4_u7684_u6700_u77ED_u8DDD_u79BB"><a href="#u4EFB_u610F_u4E24_u70B9_u4E4B_u95F4_u7684_u6700_u77ED_u8DDD_u79BB" class="headerlink" title="任意两点之间的最短距离"></a>任意两点之间的最短距离</h2><p>另一个关于图常见的算法是，如何获得任意两点之间的最短距离(All-pairs shortest paths)。直观的想法是，可以对于每个节点运行Dijkstra算法，该方法可行，但更适合的算法是Floyd-Warshall算法。</p>
<p>Floyd算法的核心是动态编程，利用二维矩阵存储i，j之间的最短距离，矩阵的初始值为i，j之间的权值，如果i，j不直接相连，则值为正无穷。动态编程的递归式为：d(k)ij = min(d(k-1)ij, d(k-1)ik+ d(k-1)kj)  (1&lt;= k &lt;= n)。直观上理解，对于第k次更新，我们比较从i到j只经过节点编号小于k的中间节点(d(k-1)ij)，和从i到k，从k到j的距离之和(d(k-1)ik+ d(k-1)kj)。Floyd算法的复杂度是O(n^3)。关于Floyd算法的理论分析，请见《算法导论》第25章，每对顶点间的最短路径。 给出伪代码如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FLOYD<span class="list">(<span class="keyword">G</span>)</span></span><br><span class="line">Distance<span class="list">(<span class="number">0</span>)</span> = Weight<span class="list">(<span class="keyword">G</span>)</span></span><br><span class="line">For k = <span class="number">1</span> to n</span><br><span class="line">    For i = <span class="number">1</span> to n</span><br><span class="line">        For j = <span class="number">1</span> to n</span><br><span class="line">Distance<span class="list">(<span class="keyword">k</span>)</span>ij = min<span class="list">(<span class="keyword">Distance</span> <span class="list">(<span class="keyword">k-1</span>)</span>ij, Distance <span class="list">(<span class="keyword">k-1</span>)</span>ik+ Distance<span class="list">(<span class="keyword">k-1</span>)</span>kj)</span>  </span><br><span class="line">Return Distance<span class="list">(<span class="keyword">n</span>)</span></span><br></pre></td></tr></table></figure>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://wdxtub.com/interview/14520607221934.html">Zigzag Level Order Traversal</a></li>
<li><a href="http://wdxtub.com/interview/14520607221747.html">Word Ladder</a></li>
<li><a href="http://wdxtub.com/interview/14520607221562.html">Word Ladder II</a></li>
<li><a href="http://wdxtub.com/interview/14520607221359.html">Valid Binary Search Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607221154.html">Unique Binary Search Trees</a></li>
<li><a href="http://wdxtub.com/interview/14520607220949.html">Unique Binary Search Trees II</a></li>
<li><a href="http://wdxtub.com/interview/14520607220765.html">Implement Trie (Prefix Tree)</a></li>
<li><a href="http://wdxtub.com/interview/14520607220590.html">Topological Sort</a></li>
<li><a href="http://wdxtub.com/interview/14520607220397.html">Convert Sorted List to Binary Search Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607220201.html">Sorted Array to Binary Search Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607220001.html">Serialize and Deserialize</a></li>
<li><a href="http://wdxtub.com/interview/14520607219827.html">Search Range</a></li>
<li><a href="http://wdxtub.com/interview/14520607219664.html">Scramble String</a></li>
<li><a href="http://wdxtub.com/interview/14520607219495.html">Route Between Nodes</a></li>
<li><a href="http://wdxtub.com/interview/14520607219333.html">Root Path Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520607219173.html">Binary Tree Right Side View</a></li>
<li><a href="http://wdxtub.com/interview/14520607219009.html">Reverse Binary Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607218845.html">Recover Binary Search Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607218687.html">Preorder Traversal</a></li>
<li><a href="http://wdxtub.com/interview/14520607218530.html">Postorder Traversal</a></li>
<li><a href="http://wdxtub.com/interview/14520607218372.html">Node Path Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520607218218.html">Paths with Sum II</a></li>
<li><a href="http://wdxtub.com/interview/14520607218066.html">Populating Next Right Pointers in Each Node</a></li>
<li><a href="http://wdxtub.com/interview/14520607217915.html">Next Node without Parent</a></li>
<li><a href="http://wdxtub.com/interview/14520607217765.html">Next Node</a></li>
<li><a href="http://wdxtub.com/interview/14520607217620.html">Next Node in BST</a></li>
<li><a href="http://wdxtub.com/interview/14520607217464.html">Neighbor Node</a></li>
<li><a href="http://wdxtub.com/interview/14520607217318.html">Minimum Path Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520607217172.html">Min Height of Binary Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607217172.html">Min Height of Binary Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607217030.html">Maximum Path Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520607216892.html">Height of Binary Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607216756.html">Level Order Traversal</a></li>
<li><a href="http://wdxtub.com/interview/14520607216621.html">Level Order Traversal II</a></li>
<li><a href="http://wdxtub.com/interview/14520607216488.html">Leaf Path Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520607216345.html">Kth Smallest Element in a BST</a></li>
<li><a href="http://wdxtub.com/interview/14520607216180.html">Is Subtree</a></li>
<li><a href="http://wdxtub.com/interview/14520607216053.html">Insert node to BST</a></li>
<li><a href="http://wdxtub.com/interview/14520607215936.html">Inorder Traversal</a></li>
<li><a href="http://wdxtub.com/interview/14520607215811.html">Flatten Binary Tree to Linked List</a></li>
<li><a href="http://wdxtub.com/interview/14520607215690.html">First Common Ancestor</a></li>
<li><a href="http://wdxtub.com/interview/14520607215576.html">First Common Ancestor of a Binary Search Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607215459.html">Different BST</a></li>
<li><a href="http://wdxtub.com/interview/14520607215341.html">Different BST II</a></li>
<li><a href="http://wdxtub.com/interview/14520607214882.html">Course Schedule</a></li>
<li><a href="http://wdxtub.com/interview/14520607214780.html">Course Schedule II</a></li>
<li><a href="http://wdxtub.com/interview/14520607214651.html">Connected Nodes in Undirected Graph</a></li>
<li><a href="http://wdxtub.com/interview/14520607214579.html">Complete Tree Node Count</a></li>
<li><a href="http://wdxtub.com/interview/14520607214515.html">Clone Graph</a></li>
<li><a href="http://wdxtub.com/interview/14520607214451.html">Symmetric Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607214387.html">Same Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607214326.html">Build Order</a></li>
<li><a href="http://wdxtub.com/interview/14520607214254.html">BST Sequences</a></li>
<li><a href="http://wdxtub.com/interview/14520607214194.html">Binary Tree to Linked List</a></li>
<li><a href="http://wdxtub.com/interview/14520607214136.html">Construct Binary Tree from Preorder and Inorder Traversal</a></li>
<li><a href="http://wdxtub.com/interview/14520607214067.html">Construct Binary Tree from Inorder and Postorder Traversal</a></li>
<li><a href="http://wdxtub.com/interview/14520607214003.html">Binary Tree Depth</a></li>
<li><a href="http://wdxtub.com/interview/14520607213955.html">Binary Search Tree Iterator</a></li>
<li><a href="http://wdxtub.com/interview/14520607213899.html">Balance Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607213899.html">Balance Tree</a></li>
<li><a href="http://wdxtub.com/interview/14520607213844.html">All Path</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>树和图的问题，说难也难，说简单也简单。难在思路和理解，简单在很多时候可以利用递归得到非常优雅的解法。</p>]]>
    
    </summary>
    
      <category term="图" scheme="http://wdxtub.com/tags/%E5%9B%BE/"/>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="树" scheme="http://wdxtub.com/tags/%E6%A0%91/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 6 课 递归与动态规划]]></title>
    <link href="http://wdxtub.com/2016/01/23/programmer-startline-6/"/>
    <id>http://wdxtub.com/2016/01/23/programmer-startline-6/</id>
    <published>2016-01-23T14:20:47.000Z</published>
    <updated>2016-01-23T23:54:26.000Z</updated>
    <content type="html"><![CDATA[<p>递归和动态规划应该算是算法问题中的难点。核心解法很简单，就是要找到状态转移方程，也就是如何把原问题分解成子问题，然后分而治之。所以说，更多像是一种思维方式，而不是具体的步骤技巧。</p>
<a id="more"></a>
<hr>
<h2 id="u89E3_u9898_u7B56_u7565"><a href="#u89E3_u9898_u7B56_u7565" class="headerlink" title="解题策略"></a>解题策略</h2><h3 id="u7528_u52A8_u6001_u7F16_u7A0B_28_u81EA_u5E95_u5411_u4E0A_29_u89E3_u51B3_u6536_u655B_u7ED3_u6784_u95EE_u9898"><a href="#u7528_u52A8_u6001_u7F16_u7A0B_28_u81EA_u5E95_u5411_u4E0A_29_u89E3_u51B3_u6536_u655B_u7ED3_u6784_u95EE_u9898" class="headerlink" title="用动态编程(自底向上)解决收敛结构问题"></a>用动态编程(自底向上)解决收敛结构问题</h3><p>具有强收敛性属性的问题（特解，或最值，或总和，或数量的问题），都可以用整数坐标映射所有节点，且当前节点的解只依赖于前驱节点(无论是顺序还是倒序)。那么，这类问题往往可以用DP解决。解决的关键是建立子问题的解之间的递推关系：</p>
<p>$$ f(n) = G[f(n-1), f(n-2), … , f(1)] $$</p>
<p>或 </p>
<p>$$ f(i, j) = G[f(i-1, j-1), f(i, j -1), f(i-1,j)] $$</p>
<p>其中 G[ ] 表示子问题到原问题的映射关系，例如对于斐波那契数列，有递推式：</p>
<p>$$ f(n) = G[f(n-1), f(n-2)] = f(n-1) + f(n-2) $$</p>
<p>解决这类问题的时候，可以把上述递推关系写在手边，这样做非常有利于理清算法实现的思路。实际实现算法时，往往以问题的一端为循环开端，另一端为循环终止条件，将当前节点的解（或往往是，以当前节点为末节点的问题的解，抑或是以当前两个坐标为输入的问题的解）用 DP 数组记录下来（如果当前节点只由之前紧接的若干个节点决定，那么用若干个变量也够了），数组的下标即为子问题的输入变量，也就是递推关系中的函数参数，只是把 <code>f(i,j)</code> 表示成<code>array[i][j]</code> 而已。</p>
<p>如果问题除了要计算动归终点的数值以外，还需要记录具体的到达路径，则可记录每个节点的前驱节点（<code>prev[n]</code>）或前驱路径（<code>vector&lt;vector&lt;int&gt;&gt; prev</code>），然后用终点出发通过回溯处理成 path。这时候记录的前驱们都是经过了 DP 的剪枝，每一条路径都是符合条件的正确路径。</p>
<p>注意，如果出现类似于“所有解”，“所有路径”等关键词，则用自上而下方法更为直接。</p>
<h3 id="u7528_Memorization_28Top-Down_29_u89E3_u51B3_u6536_u655B_u7ED3_u6784_u95EE_u9898"><a href="#u7528_Memorization_28Top-Down_29_u89E3_u51B3_u6536_u655B_u7ED3_u6784_u95EE_u9898" class="headerlink" title="用 Memorization(Top-Down)解决收敛结构问题"></a>用 Memorization(Top-Down)解决收敛结构问题</h3><p>Memorization 是自顶向下形式的动态编程，并且受到的制约更少 ，自然也可以用来解决前述的问题（但空间上可能效率不及自底向上形式的DP）。</p>
<p>Memorization 的核心在于，在原有递归框架下，存储子问题的计算结果，在重复计算子问题时返回已经计算的值。</p>
<p>值得注意的是，这里所谓的“重复计算子问题”，在自顶向下结构下必须与前驱节点无关，因为子问题并不知道原问题是如何到达当前节点的。举例来说，求二叉树从根节点到叶节点的权值最大路径，对于当前节点到叶节点的路径与之前如何到达当前节点没有关系，只要计算当前节点到叶节点的路径，就一定是重复的计算，可以直接返回结果。作为反例，在一个字母矩阵当中寻找词典中的单词，当前路径能否构成单词，不仅与之后走的过程有关，也与之前的过程有关。因此，从当前节点出发，哪怕走过相同的路径，也不能看成是重复计算的子问题。</p>
<h3 id="u7528_u56DE_u6EAF_u6CD5_28_u81EA_u4E0A_u800C_u4E0B_29_u89E3_u51B3_u53D1_u6563_u7ED3_u6784_u95EE_u9898"><a href="#u7528_u56DE_u6EAF_u6CD5_28_u81EA_u4E0A_u800C_u4E0B_29_u89E3_u51B3_u53D1_u6563_u7ED3_u6784_u95EE_u9898" class="headerlink" title="用回溯法(自上而下)解决发散结构问题"></a>用回溯法(自上而下)解决发散结构问题</h3><p>对于发散性问题(例如“所有组合”，“全部解”)，可以选取其问题空间“收敛”的一端作为起点，沿着节点发散的方向(或者说，当前节点的多种选择)进行递归，直到</p>
<ol>
<li>当前节点“不合法” 或</li>
<li>当前节点发散方向搜索完毕，才会return</li>
</ol>
<p>举例来说，考虑树的遍历：根节点方向就是“收敛”的一端，节点发散的方向就是子节点。对于某个树的节点，其孩子就是当前决策的多种选择。当达到叶节点是，其孩子为NULL，即达到“不合法”的边界条件。回溯法的核心在于选择哪些方向/决策，才是最合理，不重复的。所谓“剪枝”(pruning)，就是指：只选择尽可能少的、可能到达“胜利条件”的方向，而不是搜索当前节点的所有发散方向。这样，可能将幂指数级的复杂度降低到阶乘级。</p>
<p>值得注意的是，invalid前的最末节点未必意味着胜利(不是所有的问题走通就算满足条件)，胜利的节点也未必代表不需要继续走下去(比如寻找到一个单词之后，继续走下去可能能找到以这个单词为前缀的另一个单词)。因此我们强烈推荐将invalid的判定与胜利条件的判定总是分开，即使在某些题目中它们是一致的。当然，如果经过充分剪枝之后，所有搜索只会沿着“正确”的方向行进，那么当前节点“不合法”往往也就意味着胜利条件。</p>
<p>如果需要记录决策的路径，可以用 <code>vector&lt;int&gt; &amp;path</code> 沿着搜索的方向记录，在满足胜利条件时记录当前 <code>path</code> (通常是将 <code>path</code> 存入 <code>vector&lt;vector&lt;int&gt;&gt; &amp;paths</code>)。</p>
<p>注意，我们传入的 path 是引用形式，属于全局变量。Backtracking(回溯)本身隐含的含义是，在访问完这个节点返回时，需要恢复原本的状态(即回到该节点)，以访问其他路径。具体实现时，意味着需要:</p>
<ol>
<li>在 return 前，删除 path 中的当前节点。</li>
<li>如果搜索的方向有出现环路的可能，那么可以使用 <code>bool []</code> 或<code>unordered_map</code> 来记录该节点是否已被使用，在访问时以及 return 前维护。</li>
</ol>
<p>如果以传值形式传入 path，由于 path 成了局部变量，故在某些情况下不需要显式回溯，相当于把状态复制给了子问题。可能有人觉得这样做比较直观，但其缺点是需要额外的空间。</p>
<p>回溯法的典型模板如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">( P node, <span class="built_in">vector</span>&lt;P&gt; &amp;path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;P&gt; &gt;&amp;paths )</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!node )  <span class="comment">// invalid node</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	path.push_back(node);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> success =  ;  <span class="comment">// condition for success</span></span><br><span class="line">	<span class="keyword">if</span>( success )  </span><br><span class="line">		paths.push_back( <span class="built_in">vector</span>&lt;P&gt;(path.begin(),path.end()) ); </span><br><span class="line">     <span class="comment">// don't return here</span></span><br><span class="line">        </span><br><span class="line">	<span class="keyword">for</span>( P next: all directions )</span><br><span class="line">		backtracking( next, path, paths );</span><br><span class="line">	</span><br><span class="line">	path.pop_back();	</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u7528_Divide_and_Conquer__u89E3_u51B3_u72EC_u7ACB_u5B50_u95EE_u9898"><a href="#u7528_Divide_and_Conquer__u89E3_u51B3_u72EC_u7ACB_u5B50_u95EE_u9898" class="headerlink" title="用 Divide and Conquer 解决独立子问题"></a>用 Divide and Conquer 解决独立子问题</h3><p>如果能将问题由几个孤立但类似的部分组成，则可以优先选择使用D&amp;C策略：将问题分割解决，再合并结果。特别地，如果期望将问题的复杂度由O(n)进一步降低到O(logn)，一般总是可以联想到使用D&amp;C策略，将问题分割而治。</p>
<h3 id="u4ECE_u5B50_u95EE_u9898_u5F97_u5230_u6700_u7EC8_u89E3"><a href="#u4ECE_u5B50_u95EE_u9898_u5F97_u5230_u6700_u7EC8_u89E3" class="headerlink" title="从子问题得到最终解"></a>从子问题得到最终解</h3><p>递归和动态编程能解决的问题都有一个特性：原问题(problem)可以分解成若干个子问题(sub-problem)，只有先解决了子问题才能进一步解决原问题。子问题的解决方式形式上与原问题一致。从题目描述来看，可以提示我们尝试用递归、DP解决的关键词有：compute nth element (value, sum, max, etc.), return all the paths, return all the combinations, return all the solutions…</p>
<p>既然动规与递归都能解决相同类型的问题，那么DP和递归有什么不同？最大的区别在于，DP存储子问题的结果，当子问题已经被计算过，直接返回结果。因此，当需要重复计算子问题时，DP的时间效率高很多，但需要额外的空间。</p>
<p>特别地，具有聚合属性的问题(Aggregate)，例如在所有组合中寻找符合特定条件的特解(比如二叉树求一条从根节点到叶节点和为定值的路径，或第n个元素)，或最优解(包括最值)，或总和，或数量的问题(其实看一下SQL里的聚合函数(aggregate function)就明白了)。因为这些问题它们只需要一个聚合的或者特殊的结果，而不是所有满足条件的集合，所以它们具有很强的收敛性质。这类问题往往也可以用DP来解决。</p>
<p>这里将问题处理的每一个最小的元素/步骤，称为节点，就好比一维/二维/三维数组中的一个element，或者每一次递归中独立解决的那个元操作。 我们把节点空间“两端收敛”的问题，归结为收敛结构；将节点空间“发散”的问题，归结为发散结构。形象地说，收敛问题是由若干个子问题共同决定当前状态，即状态的总数逐渐“收敛”，例如斐波那契数列问题(前两个节点决定当前节点)；发散问题是当前状态会衍生出多个下一状态，例如遍历已知根节点的二叉树(下一层的状态以指数形式增加)。抽象地说，能够在多项式时间内解决的问题，是收敛问题(P类问题)，不能在多项式内解决的问题(如阶乘级或指数级)，是发散问题(NP类问题)。定义“收敛”和“发散”是为了方便本章节描述和区分这两类问题，并非是公认的准则。</p>
<p>我们再次强调：动态编程的核心在于，如果在一个问题的解决方案中，子问题被重复计算，那么就可以利用记录中间结果，达到用空间换取时间的目的。</p>
<h2 id="u7B97_u6CD5_u7B56_u7565"><a href="#u7B97_u6CD5_u7B56_u7565" class="headerlink" title="算法策略"></a>算法策略</h2><p>以下回顾一些利用到DP思想的经典算法策略：</p>
<ul>
<li>分而治之(Divide and Conquer)<ul>
<li>这里只谈狭义的D&amp;C，即将问题分成几个部分，每一部分相互独立，互不重叠，假定每个部分都可以得到解决来进行递归调用，合并每一部分的结果。</li>
<li>例如Merge Sort， Quick Sort (Merge Sort的divide容易，但Conquer/Merge复杂，Quick Sort的divide复杂，但Conquer/Merge容易)</li>
</ul>
</li>
<li>动态编程(Dynamic Programming)<ul>
<li>尽可能不重复计算每个子问题，而是将计算结果存储下来，以确定后驱问题的解。</li>
<li>与贪心算法的区别是，会记录下所有可能通向全局最优解的局部解，以便在计算后驱问题时综合考虑多个前驱问题的解。</li>
</ul>
</li>
<li>贪婪算法(Greedy Algorithm)<ul>
<li>只做出当下最优的判断，并且以此为基础进行下一步计算。当前判断最优时，不考虑对全局/未来的影响，所以所以从全局来说并不能保证总是最优。</li>
<li>贪心算法每次更新当前的最优解。如Dijkstra算法就是贪心算法的实例之一。</li>
</ul>
</li>
<li>回溯 (Backtracking)<ul>
<li>一种暴力(穷举)的深度优先搜索法：搜索，直到节点空间的尽头，然后再返回到上次的节点，再往其他方向深度搜索。</li>
<li>树或图的DFS是回溯的实例之一。</li>
</ul>
</li>
</ul>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li>动态规划<ul>
<li><a href="http://wdxtub.com/interview/14520604921847.html">Word Break</a></li>
<li><a href="http://wdxtub.com/interview/14520604921620.html">Word Break II</a></li>
<li><a href="http://wdxtub.com/interview/14520604921399.html">Wildcard Matching</a></li>
<li><a href="http://wdxtub.com/interview/14520604918826.html">Regular Expression Matching</a></li>
<li><a href="http://wdxtub.com/interview/14520604921164.html">Unique Path</a></li>
<li><a href="http://wdxtub.com/interview/14520604920947.html">Unique Path II</a></li>
<li><a href="http://wdxtub.com/interview/14520604920730.html">Ugly Number</a></li>
<li><a href="http://wdxtub.com/interview/14520604920507.html">Ugly Number II</a></li>
<li><a href="http://wdxtub.com/interview/14520604920305.html">Trap Water</a></li>
<li><a href="http://wdxtub.com/interview/14520595472823.html">Longest Consecutive Sequence</a></li>
<li><a href="http://wdxtub.com/interview/14520604919653.html">Continuous Subarray Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520604919436.html">Subarray Sum to K</a></li>
<li><a href="http://wdxtub.com/interview/14520604918412.html">Product of Array Except Self</a></li>
<li><a href="http://wdxtub.com/interview/14520604917885.html">Palindrom Partition</a></li>
<li><a href="http://wdxtub.com/interview/14520604918057.html">Palindrome Partitioning II</a></li>
<li><a href="http://wdxtub.com/interview/14520604917521.html">Package Problem</a></li>
<li><a href="http://wdxtub.com/interview/14520604917350.html">Package Problem II</a></li>
<li><a href="http://wdxtub.com/interview/14520604916850.html">N Queen</a></li>
<li><a href="http://wdxtub.com/interview/14520604916662.html">N-Queens II</a></li>
<li><a href="http://wdxtub.com/interview/14520604916164.html">Min Sum Subarray</a></li>
<li><a href="http://wdxtub.com/interview/14520604916010.html">Min Adjustment Cost</a></li>
<li><a href="http://wdxtub.com/interview/14520604915856.html">Maximum Subarray</a></li>
<li><a href="http://wdxtub.com/interview/14520604915702.html">Max Sum Subarray Index</a></li>
<li><a href="http://wdxtub.com/interview/14520604915546.html">Max Sum 2 Subarray</a></li>
<li><a href="http://wdxtub.com/interview/14520604915394.html">Max Square</a></li>
<li><a href="http://wdxtub.com/interview/14520604915232.html">Maximal Rectangle</a></li>
<li><a href="http://wdxtub.com/interview/14520604915082.html">Max Product Subarray</a></li>
<li><a href="http://wdxtub.com/interview/14520595474431.html">Min Difference 2 Array</a></li>
<li><a href="http://wdxtub.com/interview/14520604914933.html">Max Difference 2 Subarray</a></li>
<li><a href="http://wdxtub.com/interview/14520604914337.html">Longest Increasing Sequence</a></li>
<li><a href="http://wdxtub.com/interview/14520604914202.html">Longest Increasing Consecutive Sequence</a></li>
<li><a href="http://wdxtub.com/interview/14520604914067.html">Longest Common Substring</a></li>
<li><a href="http://wdxtub.com/interview/14520604913939.html">Longest Common Subsequence</a></li>
<li><a href="http://wdxtub.com/interview/14520604913809.html">Largest Rectangle in Histogram</a></li>
<li><a href="http://wdxtub.com/interview/14520604913528.html">Jump Game</a></li>
<li><a href="http://wdxtub.com/interview/14520604913406.html">Jump Game II</a></li>
<li><a href="http://wdxtub.com/interview/14520604913280.html">Interleaving String</a></li>
<li><a href="http://wdxtub.com/interview/14520604913150.html">House Robbery</a></li>
<li><a href="http://wdxtub.com/interview/14520604912979.html">House Robbery II</a></li>
<li><a href="http://wdxtub.com/interview/14520604912743.html">Gas Station</a></li>
<li><a href="http://wdxtub.com/interview/14520604912625.html">Fibonacci</a></li>
<li><a href="http://wdxtub.com/interview/14520604912393.html">Edit Distance</a></li>
<li><a href="http://wdxtub.com/interview/14520604912043.html">Different Subsequence</a></li>
<li><a href="http://wdxtub.com/interview/14520604911938.html">Decode Ways</a></li>
<li><a href="http://wdxtub.com/interview/14520604911834.html">Container with Most Water</a></li>
<li><a href="http://wdxtub.com/interview/14520604911320.html">Coin</a></li>
<li><a href="http://wdxtub.com/interview/14520604911261.html">Coin Game</a></li>
<li><a href="http://wdxtub.com/interview/14520604911204.html">Coin Game II</a></li>
<li><a href="http://wdxtub.com/interview/14520604911145.html">Climb Stairs</a></li>
<li><a href="http://wdxtub.com/interview/14520604911084.html">Climb Stairs - Triple Step</a></li>
<li><a href="http://wdxtub.com/interview/14520604911019.html">Boggle Game - Word Search</a></li>
<li><a href="http://wdxtub.com/interview/14520604910956.html">Boggle Game: Word Search II</a></li>
<li><a href="http://wdxtub.com/interview/14520604910906.html">Best Time to Buy and Sell Stock</a></li>
<li><a href="http://wdxtub.com/interview/14520604910739.html">Best Time to Buy and Sell Stock II</a></li>
<li><a href="http://wdxtub.com/interview/14520604910785.html">Best Time to Buy and Sell Stock III</a></li>
<li><a href="http://wdxtub.com/interview/14520604910834.html">Best Time to Buy and Sell Stock IV</a></li>
</ul>
</li>
<li>递归<ul>
<li><a href="http://wdxtub.com/interview/14520604920091.html">Towers of Hanoi</a></li>
<li><a href="http://wdxtub.com/interview/14520604919872.html">Surrounded Regions</a></li>
<li><a href="http://wdxtub.com/interview/14520604919240.html">Stack of Box</a></li>
<li><a href="http://wdxtub.com/interview/14520604919038.html">Restore IP Addresses</a></li>
<li><a href="http://wdxtub.com/interview/14520604918618.html">Recursive Multiply</a></li>
<li><a href="http://wdxtub.com/interview/14520604917714.html">Paint Fill</a></li>
<li><a href="http://wdxtub.com/interview/14520604917181.html">Number of Island</a></li>
<li><a href="http://wdxtub.com/interview/14520604912864.html">Generate Parentheses</a></li>
<li><a href="http://wdxtub.com/interview/14520604912510.html">Expression Add Operators</a></li>
<li><a href="http://wdxtub.com/interview/14520604912257.html">Dungeon Game</a></li>
<li><a href="http://wdxtub.com/interview/14520604912153.html">Different Ways to Add Parentheses</a></li>
<li><a href="http://wdxtub.com/interview/14520604911617.html">Combination Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520604911420.html">Combination Sum II</a></li>
<li><a href="http://wdxtub.com/interview/14520604911516.html">Combination Sum III</a></li>
<li><a href="http://wdxtub.com/interview/14520604910695.html">All Subsets</a></li>
<li><a href="http://wdxtub.com/interview/14520606002989.html">Recursive Integer Traversal</a></li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>递归和动态规划应该算是算法问题中的难点。核心解法很简单，就是要找到状态转移方程，也就是如何把原问题分解成子问题，然后分而治之。所以说，更多像是一种思维方式，而不是具体的步骤技巧。</p>]]>
    
    </summary>
    
      <category term="动态规划" scheme="http://wdxtub.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="递归" scheme="http://wdxtub.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 5 课 链表]]></title>
    <link href="http://wdxtub.com/2016/01/22/programmer-startline-5/"/>
    <id>http://wdxtub.com/2016/01/22/programmer-startline-5/</id>
    <published>2016-01-22T20:51:05.000Z</published>
    <updated>2016-01-23T22:42:12.000Z</updated>
    <content type="html"><![CDATA[<p>链表，作为在内存中非连续分配的数据结构，因为其灵活性往往容易出错，这里我们会通过深入理解来教大家一些解决链表问题的基本方法。</p>
<a id="more"></a>
<hr>
<h2 id="u89E3_u9898_u7B56_u7565"><a href="#u89E3_u9898_u7B56_u7565" class="headerlink" title="解题策略"></a>解题策略</h2><p>链表(linked list)是一种常见的线性数据结构。对于单向链表(singly linked list)，每个节点有一个 next 指针指向后一个节点，还有一个成员变量用以存储数值；对于双向链表(doubly Linked List)，还有一个 prev 指针指向前一个节点。与数组类似，搜索链表需要O(n)的时间复杂度，但是链表不能通过常数时间 O(1) 读取第k个数据。链表的优势在于能够以较高的效率在任意位置插入或删除一个节点。</p>
<ul>
<li>当涉及对头节点的操作，我们不妨考虑创建哑节点</li>
<li>由于题目涉及在链表中寻找特定位置，我们用两个指针变量以不同的速度遍历该链表</li>
<li>实现链表的逆转时，循环遍历链表, 每次只处理当前指针的 next 变量</li>
</ul>
<h3 id="u94FE_u8868_u7684_u57FA_u672C_u64CD_u4F5C"><a href="#u94FE_u8868_u7684_u57FA_u672C_u64CD_u4F5C" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h3><p>凡是修改单向链表的操作，只需考虑：</p>
<ol>
<li>哪个节点的next指针会受到影响，则需要修正该指针；</li>
<li>如果待删除节点是动态开辟的内存空间，则需要释放这部分空间(C/C++)</li>
</ol>
<p>毕竟，一个链表节点，无非是包含value和next这两个成员变量的数据结构而已。对于双向链表，类似的，则只需额外考虑谁的prev指针会受到影响。</p>
<p>举例如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void delNode(<span class="constant">ListNode </span>*prev) &#123;</span><br><span class="line">  <span class="constant">ListNode </span>*curr = prev-&gt;<span class="keyword">next</span>;</span><br><span class="line">  <span class="regexp">//</span> 删除curr节点只会使prev节点的<span class="keyword">next</span>受到影响</span><br><span class="line">  prev-&gt;<span class="keyword">next</span> = curr-&gt;<span class="keyword">next</span>;    </span><br><span class="line">  delete curr;    <span class="regexp">//</span> 清理trash指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：操作链表时务必注意边界条件：curr == head, curr == tail 或者 curr == NULL</p>
<ul>
<li><strong>两种存储方式</strong><ul>
<li>顺序存储结构：随机读取，访问时是 O(1)</li>
<li>链式存储结构：插入和删除 O(1)，访问时最坏是 O(n)</li>
</ul>
</li>
<li>分类（根据指针域）<ul>
<li>单向链表</li>
<li>双向链表</li>
<li>循环链表</li>
</ul>
</li>
</ul>
<h3 id="u53CD_u8F6C_u94FE_u8868"><a href="#u53CD_u8F6C_u94FE_u8868" class="headerlink" title="反转链表"></a>反转链表</h3><ul>
<li>访问某个节点 <code>curt.next</code> 时，要检验 <code>curt</code> 是否为 <code>null</code></li>
<li>要把反转后的最后一个节点（即第一个节点）指向 <code>null</code></li>
</ul>
<h3 id="u5220_u9664_u67D0_u4E2A_u8282_u70B9"><a href="#u5220_u9664_u67D0_u4E2A_u8282_u70B9" class="headerlink" title="删除某个节点"></a>删除某个节点</h3><ul>
<li>由于需要知道前继节点的信息，而前继节点可能会导致表头产生变化，所以需要一些技巧 <code>Dummy Node</code></li>
<li>链表指针的鲁棒性<ul>
<li>访问某个节点 <code>curt.next</code> 时，要检验 <code>curt</code> 是否为 <code>null</code></li>
<li>全部操作结束后，判断是否有环；若有，则置其中一端为 <code>null</code></li>
</ul>
</li>
</ul>
<h3 id="Dummy_Node"><a href="#Dummy_Node" class="headerlink" title="Dummy Node"></a>Dummy Node</h3><ul>
<li>是一个虚拟节点 <code>dummy.next = head</code></li>
<li>针对单向链表没有前向指针的问题，保证链表的 <code>head</code> 不会在删除操作中丢失</li>
<li>也可以用来进行 <code>head</code> 节点（但比较少见）</li>
<li>当链表的 <code>head</code> 可能有变化时，使用 dummy node 可以简化代码，最后返回 <code>dummy.next</code> 即可</li>
</ul>
<h3 id="u5FEB_u6162_u6307_u9488"><a href="#u5FEB_u6162_u6307_u9488" class="headerlink" title="快慢指针"></a>快慢指针</h3><ul>
<li>快慢指的是指针向前移动的步长，一般来说，快指针每次移动 2，慢指针每次移动 1</li>
<li>主要有两个应用<ul>
<li><strong>快速找出未知长度单链表的中间节点</strong><ul>
<li>设置两个指针 <code>*fast</code> 和 <code>*slow</code> 都指向头节点</li>
<li><code>*fast</code> 移动速度是 <code>*slow</code> 的两倍</li>
<li><code>*fast</code> 指向末尾节点时，<code>*slow</code> 正好就在中间</li>
</ul>
</li>
<li><strong>判断单链表是否有环</strong><ul>
<li>设置两个指针 <code>*fast</code> 和 <code>*slow</code> 都指向头节点</li>
<li><code>*fast</code> 移动速度是 <code>*slow</code> 的两倍</li>
<li>如果 <code>*fast == null</code> 说明该单链表不是循环链表</li>
<li>如果 <code>*fast == *slow</code> 说明该链表是循环链表</li>
</ul>
</li>
</ul>
</li>
<li>其他应用<ul>
<li><strong>找倒数第 N 个节点</strong><ul>
<li>设置两个指针 <code>*fast</code> 和 <code>*slow</code> 都指向头节点</li>
<li><code>*fast</code> 先移动 N 步，然后两个指针一起前进</li>
<li><code>*fast</code> 到达末尾时，<code>*slow</code> 即为倒数第 N 个节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://wdxtub.com/interview/14520597852720.html">Swap Adjacent Node</a></li>
<li><a href="http://wdxtub.com/interview/14520597852604.html">Start of Circle</a></li>
<li><a href="http://wdxtub.com/interview/14520597852502.html">Sort List</a></li>
<li><a href="http://wdxtub.com/interview/14520597852382.html">Rotate List</a></li>
<li><a href="http://wdxtub.com/interview/14520597852276.html">Reversely List Traverse</a></li>
<li><a href="http://wdxtub.com/interview/14520597852177.html">Reverse Nodes in k-Group</a></li>
<li><a href="http://wdxtub.com/interview/14520597852065.html">Reverse List</a></li>
<li><a href="http://wdxtub.com/interview/14520597851968.html">Reverse List Range</a></li>
<li><a href="http://wdxtub.com/interview/14520597851880.html">Reorder List</a></li>
<li><a href="http://wdxtub.com/interview/14520597851782.html">Remove Linked List Elements</a></li>
<li><a href="http://wdxtub.com/interview/14520597851695.html">Remove Duplicates from Unsorted List</a></li>
<li><a href="http://wdxtub.com/interview/14520597851601.html">Remove Duplicates from Sorted List</a></li>
<li><a href="http://wdxtub.com/interview/14520597851549.html">Remove Duplicates from Sorted List II</a></li>
<li><a href="http://wdxtub.com/interview/14520597851500.html">Partition Linked List</a></li>
<li><a href="http://wdxtub.com/interview/14520597851449.html">Partitiom List Sorted</a></li>
<li><a href="http://wdxtub.com/interview/14520597851399.html">Middle of List</a></li>
<li><a href="http://wdxtub.com/interview/14520597851346.html">Merge Two Lists</a></li>
<li><a href="http://wdxtub.com/interview/14520597851075.html">Merge K Linked List</a></li>
<li><a href="http://wdxtub.com/interview/14520597851031.html">Kth to Last</a></li>
<li><a href="http://wdxtub.com/interview/14520597850990.html">Insertion Sort List</a></li>
<li><a href="http://wdxtub.com/interview/14520597850946.html">Copy List with Random Pointer</a></li>
<li><a href="http://wdxtub.com/interview/14520597850907.html">Palindrome Linked List</a></li>
<li><a href="http://wdxtub.com/interview/14520597850871.html">Check Intersection</a></li>
<li><a href="http://wdxtub.com/interview/14520597850832.html">Check Cycle</a></li>
<li><a href="http://wdxtub.com/interview/14520597850789.html">Add Two Numbers</a></li>
<li><a href="http://wdxtub.com/interview/14520607215217.html">Delete Node in a Linked List</a></li>
<li><a href="http://wdxtub.com/interview/14520607215107.html">Delete Middle Node</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>链表，作为在内存中非连续分配的数据结构，因为其灵活性往往容易出错，这里我们会通过深入理解来教大家一些解决链表问题的基本方法。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="链表" scheme="http://wdxtub.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 4 课 栈和队列]]></title>
    <link href="http://wdxtub.com/2016/01/22/programmer-startline-4/"/>
    <id>http://wdxtub.com/2016/01/22/programmer-startline-4/</id>
    <published>2016-01-22T20:51:02.000Z</published>
    <updated>2016-01-23T05:22:52.000Z</updated>
    <content type="html"><![CDATA[<p>栈和队列，因为其特殊的性质，如果巧妙利用，可以解决许多原本比较复杂的问题，而且还是 BFS 和 DFS 的基础，这一讲我们就来看看对于栈和队列的相关知识。</p>
<a id="more"></a>
<hr>
<h2 id="u89E3_u9898_u7B56_u7565"><a href="#u89E3_u9898_u7B56_u7565" class="headerlink" title="解题策略"></a>解题策略</h2><p>对于栈和队列的题目，一定要意识到这两个数据结构背后所代表的含义。</p>
<p>比方说，有一类问题有这样的特性：当前节点的解依赖后驱节点。也就是说，对于某个当前节点，如果不能获知后驱节点，就无法得到有意义的解。这类问题可以通过栈(或等同于栈的若干个临时变量)解决：先将当前节点入栈，然后看其后继节点的值，直到其依赖的所有节点都完备时，再从栈中弹出该节点求解。某些时候，甚至需要反复这个过程：将当前节点的计算结果再次入栈，直到其依赖的后继节点完备。</p>
<p>更进一步来看，只要是利用递归的过程，其实都可以去用栈来模拟，毕竟递归实际上就是一个隐式的栈调用。</p>
<p>具体解题的时候，从最基本的情况出发，根据题意推倒整个计算流程。这样做的好处是：</p>
<ol>
<li>确保自己正确地理解了题目 </li>
<li>从简单的情况出发，找找解题思路。该方法特别适用于递归，动态编程等题目类型</li>
</ol>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="http://wdxtub.com/interview/14520595470575.html">Evaluate Reverse Polish Notation</a></li>
<li><a href="http://wdxtub.com/interview/14520606685840.html">Implement Stack using Queues</a></li>
<li><a href="http://wdxtub.com/interview/14520606685720.html">Stack of Plates</a></li>
<li><a href="http://wdxtub.com/interview/14520606685665.html">Sort Stack</a></li>
<li><a href="http://wdxtub.com/interview/14520606685606.html">Queue of Stack</a></li>
<li><a href="http://wdxtub.com/interview/14520606685544.html">Min Stack</a></li>
<li><a href="http://wdxtub.com/interview/14520606685475.html">Max Stack</a></li>
<li><a href="http://wdxtub.com/interview/14520606685419.html">Longest Valid Parentheses</a></li>
<li><a href="http://wdxtub.com/interview/14520606685367.html">In Order Travesal with Stack</a></li>
<li><a href="http://wdxtub.com/interview/14520606685319.html">Hanoi Tower with Stack</a></li>
<li><a href="http://wdxtub.com/interview/14520606685269.html">Basic Calculator</a></li>
<li><a href="http://wdxtub.com/interview/14520606685216.html">Basic Calculator II</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>栈和队列，因为其特殊的性质，如果巧妙利用，可以解决许多原本比较复杂的问题，而且还是 BFS 和 DFS 的基础，这一讲我们就来看看对于栈和队列的相关知识。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="栈" scheme="http://wdxtub.com/tags/%E6%A0%88/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="队列" scheme="http://wdxtub.com/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 3 课 数组和字符串]]></title>
    <link href="http://wdxtub.com/2016/01/22/programmer-startline-3/"/>
    <id>http://wdxtub.com/2016/01/22/programmer-startline-3/</id>
    <published>2016-01-22T20:50:55.000Z</published>
    <updated>2016-01-23T21:47:35.000Z</updated>
    <content type="html"><![CDATA[<p>数组和字符串作为最基本的元素，涉及的知识点非常多，许多高级的应用如堆，栈，队列，动态规划等都可以基于数组，这一讲我们主要还是集中在数组本身性质的习题上。</p>
<a id="more"></a>
<hr>
<h2 id="u9898_u76EE_u5206_u7C7B_u4E0E_u89E3_u9898_u7B56_u7565"><a href="#u9898_u76EE_u5206_u7C7B_u4E0E_u89E3_u9898_u7B56_u7565" class="headerlink" title="题目分类与解题策略"></a>题目分类与解题策略</h2><p>原本以为这一章内容不会很多，但是整理资料的时候发现，我把不少稍微有些『难度』的题目，也放到了这个类别下，不过也没有问题，万事开头难，熬过这一波就好了。</p>
<p>我们先来分析一下具体的题目类型，因为很多题目万变不离其宗，只要抓住解题思路，剩下的就是时间问题了（具体的题目列表在最后的附录中），下面是几个大类的问题及对应的思路：</p>
<h3 id="u6B21_u6570_u7EDF_u8BA1"><a href="#u6B21_u6570_u7EDF_u8BA1" class="headerlink" title="次数统计"></a>次数统计</h3><p>这类题目就是哈希表大显身手的时候了，比方说找唯一出现的字母或数字，或者是统计元素出现的次数，都可以用哈希表来快速完成。因为哈希表可以做到 O(1) 时间的检索，所以效率会很高。看一次这个分类下的题目就会发现，问题的突破口往往就是找到对应的建立哈希表的方式。</p>
<p>哈希表(Hash Table)几乎是最为重要的数据结构，主要用于基于“键(key)”的查找，存储的基本元素是键-值对(key-value pair)。逻辑上，数组可以作为哈希表 的一个特例：键是一个非负整数。注意，通常哈希表会假设键是数据的唯一标识，相同的键默认表示同一个基本存储元素。</p>
<p>哈希表的本质是当使用者提供一个键，根据哈希表自身定义的哈希函数(hash function)，映射出一个下标，根据这个下标决定需要把当前的元素存储在什么位置。在一些合理的假设情况下，查找一个元素的平均时间复杂度是O(1)，插入一个元素的平摊(amortized)时间复杂度是O(1)。</p>
<p>当对于不同的键，哈希函数提供相同的存储地址时，哈希表就遇到了所谓的冲突(collision)。解决冲突的方式有链接法(chaining)和开放地址法(open addressing)两种。简单来说，链接法相当于利用辅助数据结构(比如链表)，将哈希函数映射出相同地址的那些元素链接起来。而开放地址法是指以某种持续的哈希方式继续哈希，直到产生的下标对应尚未被使用的存储地址，然后把当前元素存储在这个地址里。</p>
<p>通常而言，链接法实现相对简便，但是可能需要附加空间，并且利用当前空间的效率不如开放地址法高。开放地址法更需要合理设计的连续哈希函数，但是可以获得更好的空间使用效率。需要注意的是，过于频繁的冲突会降低哈希表的搜索效率，此时需要哈希表的扩张。</p>
<p>比较有特点的题目是：</p>
<ul>
<li><a href="http://wdxtub.com/interview/14520595478736.html">01 相等的串</a></li>
<li><a href="http://wdxtub.com/interview/14520595469735.html">Check Duplicate</a></li>
</ul>
<h3 id="u7279_u5B9A_u6A21_u5F0F"><a href="#u7279_u5B9A_u6A21_u5F0F" class="headerlink" title="特定模式"></a>特定模式</h3><p>这个类型的题目比较多变化，比方说，找回文串，子串匹配，或者是两个数组中相差最小的两个元素，又或者是字符串按照一定规则变成数字。这类问题有一个特点，就是可以很容易想出暴力解法，但是暴力解法会有很多重复运算，效率不高，于是需要进一步进行优化。具体的优化方式有很多，比方说找回文串，如果比较复杂一点的 manacher 算法没办法保证百分百写对的话，那么以每个字符为中心开始延展的方式，也是不错的做法。</p>
<p>具体来说，就是一定要清楚地知道，具体在操作的元素是哪个，以及对应的匹配关系，一开始可能会比较慢，但是熟悉了之后就好了。比较有特点的题目是：</p>
<ul>
<li><a href="http://wdxtub.com/interview/14520595479135.html">Shortest Palindrome</a></li>
<li><a href="http://wdxtub.com/interview/14520595475576.html">One Away</a></li>
<li><a href="http://wdxtub.com/interview/14520595471113.html">Gray Code</a></li>
</ul>
<h3 id="u533A_u95F4_u95EE_u9898"><a href="#u533A_u95F4_u95EE_u9898" class="headerlink" title="区间问题"></a>区间问题</h3><p>区间问题的复杂性在于，需要处理多种情况，如果不事先想好的话，很容易出错。另外就是处理区间取数的问题，会涉及到一些动态规划的思想，当然，有些问题也可以用哈希表来解决。解决问题的关键在于，一定要意识到多种情况的可能，并且在代码中做对应的处理。比较有特点的题目是：</p>
<ul>
<li><a href="http://wdxtub.com/interview/14520595473642.html">最大间隔问题</a></li>
<li><a href="http://wdxtub.com/interview/14520595476141.html">Peaks and Valleys</a></li>
<li><a href="http://wdxtub.com/interview/14520595469247.html">2 Sum</a></li>
</ul>
<h3 id="u77E9_u9635_u76F8_u5173"><a href="#u77E9_u9635_u76F8_u5173" class="headerlink" title="矩阵相关"></a>矩阵相关</h3><p>矩阵就是二维数组，具体来说，难度在于，怎么处理好两个维度的问题。具体来说，就是要看题目中有没有给出一些明显的信息，比方说排好序。写关键代码的时候，一定要列好前条件和后条件，保证不出问题。比较有特点的题目是：</p>
<ul>
<li><a href="http://wdxtub.com/interview/14520595478930.html">Set Matrix Zero</a></li>
<li><a href="http://wdxtub.com/interview/14520595479796.html">Spiral Matrix</a></li>
<li><a href="http://wdxtub.com/interview/14520595474607.html">Min Triangle Path Sum</a></li>
</ul>
<h3 id="u903B_u8F91_u64CD_u4F5C"><a href="#u903B_u8F91_u64CD_u4F5C" class="headerlink" title="逻辑操作"></a>逻辑操作</h3><p>这个类别包括的题目千奇百怪，理论上来说很难总结一个普适的规律，因为实际上就是根据特定的逻辑规则来进行操作。比方说以特定格式输出，旋转，排序，交换，合并，堆等等。因为变化太多，所以这里只能给出一个比较通用的建议：列出前条件后条件，注意每一步操作及可能带来的副作用，善于利用数据结构本身的能力。比较有特点的题目有：</p>
<ul>
<li><a href="http://wdxtub.com/interview/14520595480445.html">String Compression</a></li>
<li><a href="http://wdxtub.com/interview/14520595474265.html">Merge Two Sorted Array</a></li>
<li><a href="http://wdxtub.com/interview/14520595472329.html">Largest Number</a></li>
<li><a href="http://wdxtub.com/interview/14520595471461.html">Heapify</a></li>
</ul>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><ul>
<li>次数统计（唯一性，是否出现，个数相等）<ul>
<li><a href="http://wdxtub.com/interview/14520595481622.html">Unique Character</a></li>
<li><a href="http://wdxtub.com/interview/14520595480211.html">String Composition</a></li>
<li><a href="http://wdxtub.com/interview/14520595479999.html">String Comparison</a></li>
<li><a href="http://wdxtub.com/interview/14520595481118.html">Substring with Concatenation of All Words</a></li>
<li><a href="http://wdxtub.com/interview/14520595478736.html">01 相等的串</a></li>
<li><a href="http://wdxtub.com/interview/14520595477318.html">Repeated DNA Sequences</a></li>
<li><a href="http://wdxtub.com/interview/14520595476547.html">Remove Duplicates from Sorted Array</a></li>
<li><a href="http://wdxtub.com/interview/14520595476340.html">Remove Duplicates from Sorted Array II</a></li>
<li><a href="http://wdxtub.com/interview/14520595473349.html">Majority Element</a></li>
<li><a href="http://wdxtub.com/interview/14520595473082.html">Majority Element II</a></li>
<li><a href="http://wdxtub.com/interview/14520595473216.html">Majority Element III</a></li>
<li><a href="http://wdxtub.com/interview/14520595472951.html">Longest Word in Dictionary</a></li>
<li><a href="http://wdxtub.com/interview/14520595470900.html">Find Anagram</a></li>
<li><a href="http://wdxtub.com/interview/14520595470471.html">Determine String Permutation</a></li>
<li><a href="http://wdxtub.com/interview/14520595469735.html">Check Duplicate</a></li>
<li><a href="http://wdxtub.com/interview/14520595469566.html">Check Duplicate II</a></li>
<li><a href="http://wdxtub.com/interview/14520595469610.html">Check Duplicate III</a></li>
<li><a href="http://wdxtub.com/interview/14520595469690.html">Find Duplicates</a></li>
</ul>
</li>
<li>特定模式（回文串，子串，相差最少）<ul>
<li><a href="http://wdxtub.com/interview/14520595479135.html">Shortest Palindrome</a></li>
<li><a href="http://wdxtub.com/interview/14520595480652.html">Implement strStr()</a></li>
<li><a href="http://wdxtub.com/interview/14520595477901.html">Roman to Integer</a></li>
<li><a href="http://wdxtub.com/interview/14520595471853.html">Integer to Roman</a></li>
<li><a href="http://wdxtub.com/interview/14520595475576.html">One Away</a></li>
<li><a href="http://wdxtub.com/interview/14520595479365.html">Simplify File Path</a></li>
<li><a href="http://wdxtub.com/interview/14520595472570.html">Letter Combinations of a Phone Number</a></li>
<li><a href="http://wdxtub.com/interview/14520595472084.html">Isomorphic Strings</a></li>
<li><a href="http://wdxtub.com/interview/14520595471113.html">Gray Code</a></li>
<li><a href="http://wdxtub.com/interview/14520595469921.html">Palindrome Permutation</a></li>
<li><a href="http://wdxtub.com/interview/14520595469833.html">Check Palindrome</a></li>
<li><a href="http://wdxtub.com/interview/14520595469782.html">Palindrome Number</a></li>
<li><a href="http://wdxtub.com/interview/14520604914478.html">Longest Palindromic Substring</a></li>
</ul>
</li>
<li>区间问题<ul>
<li><a href="http://wdxtub.com/interview/14520595473959.html">Merge Range</a></li>
<li><a href="http://wdxtub.com/interview/14520595473642.html">最大间隔问题</a></li>
<li><a href="http://wdxtub.com/interview/14520595476141.html">Peaks and Valleys</a></li>
<li><a href="http://wdxtub.com/interview/14520595475403.html">奇偶调序</a></li>
<li><a href="http://wdxtub.com/interview/14520595474923.html">Move Zeroes</a></li>
<li><a href="http://wdxtub.com/interview/14520595471966.html">Interleaving Array</a></li>
<li><a href="http://wdxtub.com/interview/14520595472695.html">Longest Common Prefix</a></li>
<li><a href="http://wdxtub.com/interview/14520595471570.html">Insert Range</a></li>
<li><a href="http://wdxtub.com/interview/14520595469247.html">2 Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520595469329.html">3 Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520595469298.html">3 Sum Closest</a></li>
<li><a href="http://wdxtub.com/interview/14520595469361.html">4 Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520595472209.html">K Sum II</a></li>
<li><a href="http://wdxtub.com/interview/14520604916479.html">Minimum Subarray for Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520604916322.html">Minimum Window Substring</a></li>
<li><a href="http://wdxtub.com/interview/14520604914788.html">Longest Substring Without Repeating Characters</a></li>
<li><a href="http://wdxtub.com/interview/14520604914642.html">Longest Substring with K Unique Characters</a></li>
</ul>
</li>
<li>矩阵相关<ul>
<li><a href="http://wdxtub.com/interview/14520595478930.html">Set Matrix Zero</a></li>
<li><a href="http://wdxtub.com/interview/14520595479796.html">Spiral Matrix</a></li>
<li><a href="http://wdxtub.com/interview/14520595479570.html">Spiral Matrix II</a></li>
<li><a href="http://wdxtub.com/interview/14520595480877.html">Submatrix Sum Zero</a></li>
<li><a href="http://wdxtub.com/interview/14520595478302.html">Rotate Image</a></li>
<li><a href="http://wdxtub.com/interview/14520595475941.html">Pascal’s Triangle</a></li>
<li><a href="http://wdxtub.com/interview/14520595475767.html">Pascal’s Triangle II</a></li>
<li><a href="http://wdxtub.com/interview/14520595475237.html">二进制矩阵中 1 的个数</a></li>
<li><a href="http://wdxtub.com/interview/14520595474607.html">Min Triangle Path Sum</a></li>
<li><a href="http://wdxtub.com/interview/14520595473495.html">Matrix ZigZag Traversal</a></li>
<li><a href="http://wdxtub.com/interview/14520595471005.html">Game of Life</a></li>
<li><a href="http://wdxtub.com/interview/14520595470188.html">Check Valid Sudoku</a></li>
</ul>
</li>
<li>逻辑操作（特定格式，旋转，排序，特定元素交换，合并，堆）<ul>
<li><a href="http://wdxtub.com/interview/14520595481874.html">ZigZag Conversion</a></li>
<li><a href="http://wdxtub.com/interview/14520595481376.html">Text Justification</a></li>
<li><a href="http://wdxtub.com/interview/14520595480445.html">String Compression</a></li>
<li><a href="http://wdxtub.com/interview/14520595478523.html">Rotate String</a></li>
<li><a href="http://wdxtub.com/interview/14520595478107.html">Rotate Array</a></li>
<li><a href="http://wdxtub.com/interview/14520595477695.html">Reverse Sentence</a></li>
<li><a href="http://wdxtub.com/interview/14520595477503.html">Reverse Integer</a></li>
<li><a href="http://wdxtub.com/interview/14520595477117.html">Reorder String by Case</a></li>
<li><a href="http://wdxtub.com/interview/14520595476933.html">Reorder Rotated Array</a></li>
<li><a href="http://wdxtub.com/interview/14520595476748.html">Remove Element</a></li>
<li><a href="http://wdxtub.com/interview/14520595475077.html">Multiply Strings</a></li>
<li><a href="http://wdxtub.com/interview/14520595474770.html">Modify String</a></li>
<li><a href="http://wdxtub.com/interview/14520595474265.html">Merge Two Sorted Array</a></li>
<li><a href="http://wdxtub.com/interview/14520595474103.html">Sorted Two Sorted Array II</a></li>
<li><a href="http://wdxtub.com/interview/14520595473794.html">Median of Unsorted Array</a></li>
<li><a href="http://wdxtub.com/interview/14520595472449.html">Length of Last Word</a></li>
<li><a href="http://wdxtub.com/interview/14520595472329.html">Largest Number</a></li>
<li><a href="http://wdxtub.com/interview/14520595471740.html">Integer to English Words</a></li>
<li><a href="http://wdxtub.com/interview/14520595471461.html">Heapify</a></li>
<li><a href="http://wdxtub.com/interview/14520595471345.html">H-Index</a></li>
<li><a href="http://wdxtub.com/interview/14520595471233.html">H-Index II</a></li>
<li><a href="http://wdxtub.com/interview/14520595470785.html">Excel Sheet Column Title</a></li>
<li><a href="http://wdxtub.com/interview/14520595470670.html">Excel Sheet Column Number</a></li>
<li><a href="http://wdxtub.com/interview/14520595470378.html">Count and Say</a></li>
<li><a href="http://wdxtub.com/interview/14520595470276.html">Compare Version Numbers</a></li>
<li><a href="http://wdxtub.com/interview/14520595470088.html">Check Valid Number</a></li>
<li><a href="http://wdxtub.com/interview/14520595469517.html">Candy</a></li>
<li><a href="http://wdxtub.com/interview/14520595469475.html">Binary to String</a></li>
<li><a href="http://wdxtub.com/interview/14520595469437.html">Add One</a></li>
<li><a href="http://wdxtub.com/interview/14520595469400.html">Add Binary</a></li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>数组和字符串作为最基本的元素，涉及的知识点非常多，许多高级的应用如堆，栈，队列，动态规划等都可以基于数组，这一讲我们主要还是集中在数组本身性质的习题上。</p>]]>
    
    </summary>
    
      <category term="字符串" scheme="http://wdxtub.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="数组" scheme="http://wdxtub.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 2 课 Big O 分析]]></title>
    <link href="http://wdxtub.com/2016/01/22/programmer-startline-2/"/>
    <id>http://wdxtub.com/2016/01/22/programmer-startline-2/</id>
    <published>2016-01-22T20:50:51.000Z</published>
    <updated>2016-01-22T23:08:08.000Z</updated>
    <content type="html"><![CDATA[<p>前一讲大概了解了这个系列会涉及的内容，这一讲就从最重要的概念，Big O 开始讲起。既然我们要找到效率更高的算法，首先就得知道，怎么样才是高效率。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u672C_u6CD5_u5219"><a href="#u57FA_u672C_u6CD5_u5219" class="headerlink" title="基本法则"></a>基本法则</h2><p>我们先来了解一下程序分析的基本法则。一般来说，常见的输入输出以及简单的赋值语句，可以认为时间复杂度是 O(1)。在算复杂度的时候乘以一个常数复杂度不变，即 $O(Cf(n)) = O(f(n))$，其中C是一个正常数。</p>
<p>我们知道，程序设计中无非是三种形态：顺序，选择和循环，只要能够算清楚这三种形态的复杂度，那么整个算法的复杂度也就不在话下了。</p>
<p>先来看看顺序结构，因为是顺序执行，所以可以通过求和法则来进行计算。若算法的 2 个部分时间复杂度分别为 $T1(n)=O(f(n))$ 和 $T2(n)=O(g(n))$,则 $T1(n)+T2(n)=O(max(f(n), g(n)))$。如果这两个部分的参数不一样的话，即 $T1(m)=O(f(m))$ 和 $T2(n)=O(g(n))$,则 $T1(m)+T2(n)=O(f(m) + g(n))$</p>
<p>然后是选择结构，选择本身判断是耗费 O(1) 时间的，但是主要时间还是在执行不同的子句上，所以转换为分析子句的时间复杂度。</p>
<p>最后来看看循环结构，一般来说可能包括多次循环，所以使用乘法法则。若算法的2个部分时间复杂度分别为 $T1(n)=O(f(n))$ 和 $T2(n)=O(g(n))$,则 $T1 \times T2=O(f(n) \times g(n))$ 。</p>
<p>基本上理解了什么时候用求和法则，什么时候用乘法法则，再加上一点点运算，就可以推算出时间复杂度了。</p>
<h2 id="u9012_u5F52"><a href="#u9012_u5F52" class="headerlink" title="递归"></a>递归</h2><p>递归问题应该算是求复杂度问题中比较麻烦的了，并不像其他非递归的算法可以用上面提到的基本法则来进行分析。一般来说，遇到递归问题，有两种做法：</p>
<ol>
<li>主定理法</li>
<li>递归树法</li>
</ol>
<p>实际上主定理法可以看作是递归树法的一个总结，这里用一个例子来说明，假设我们的递归函数是：$T(n) = T(\frac{n}{3}) + T(\frac{2n}{3}) + n$，那么画出递归树就是：</p>
<p><img src="/images/14535025616030.jpg" alt=""></p>
<p>每层都会多出来一个 n，而从根到叶节点的最长路径是：$n \to \frac{2}{3}n \to (\frac{2}{3})^2n \to \dots \to 1$，假设一共有 k 层，因为 $(\frac{2}{3})^kn = 1$，所以  $k=log_{3/2}n$ ，也就是说  $T(n) \le \sum_{i=0}^k n = (k+1)n = n(log_{3/2}n+1 )$  ，即 $T(n) = O(nlog\;n)$</p>
<p>我们来看看用主定理方法的话，这个复杂度要怎么算。首先我们要把递推公式转换为如下形式：</p>
<p>$$f(n)=af(\frac{n}{b}) + d(n)$$</p>
<p>然后分情况进行讨论：</p>
<p><img src="/images/14535029849534.jpg" alt=""></p>
<p>而这题中 $T(n) = T(\frac{n}{3}) + T(\frac{2n}{3}) + n$，化简之后相当于 $a=3,b=3$，于是在第二种情况中找到 $a=b$ 的情况，就得到了最后的结果 $O(nlog\; n)$</p>
<h2 id="u4F8B_u9898"><a href="#u4F8B_u9898" class="headerlink" title="例题"></a>例题</h2><p>这里主要是提及一些容易出错的地方。</p>
<blockquote>
<p>不是出现了树结构，就一定会产生 log 的复杂度</p>
</blockquote>
<p>假设代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum(node.left) + node.value + sum(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为实际上是遍历所有的节点一次，于是复杂度是 O(n)</p>
<blockquote>
<p>有的时候可以通过这个代码的做用来进行复杂度判断</p>
</blockquote>
<p>来看看下面这两个代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 片段 1</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">2</span>; x * x &lt;= n; x++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % x == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permuation</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    permutation(str, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(String str, String prefix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">            String rem = str.substring(<span class="number">0</span>,i) + str.substring(i+<span class="number">1</span>);</span><br><span class="line">            permutation(rem, prefix + str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一题比较简单，因为是求质数，在 $\sqrt n$ 时间就可以完成，对应的时间复杂也就是出来了。</p>
<p>第二题做得是一个全排列，可以从两个思路：What It Means 和 What It Does。</p>
<ul>
<li>What It Means：因为是求排列，如果一个字符串有n个字符，那么所有的可能为 <code>n*(n-1)*...*2*1 -&gt; O(n!)</code></li>
<li>What It Does：设一共有 n 个字符，第一次循环，有 n 次递归调用，第二次有 n-1 次，到最后一共有 <code>n*(n-1)*...*2*1 -&gt; O(n!)</code></li>
</ul>
<p>最后再举一个递归的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里每一次递归，都会由原来的一个分成两个，而一共有 n 层，于是时间复杂度为 $O(2^N)$</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>当然，很多时候还需要具体问题具体分析，最关键的，是对算法过程的清晰理解和掌握，有了这个，哪怕从头开始一点一点分析，也可以推导出正确答案。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前一讲大概了解了这个系列会涉及的内容，这一讲就从最重要的概念，Big O 开始讲起。既然我们要找到效率更高的算法，首先就得知道，怎么样才是高效率。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第二周 - Welcome]]></title>
    <link href="http://wdxtub.com/2016/01/22/welcome/"/>
    <id>http://wdxtub.com/2016/01/22/welcome/</id>
    <published>2016-01-22T17:48:32.000Z</published>
    <updated>2016-01-22T20:35:00.000Z</updated>
    <content type="html"><![CDATA[<p>Ain’t no way to shut me down. Or to take the path I’ve taken.</p>
<a id="more"></a>
<hr>
<p>第二周算是完全进入了状态，各项工作都在有条不紊地推进中，去西雅图和三藩的行程确定了下来，准备加入一个 Swift 的翻译小组，甚至还申请当助教，加上之前所说的『微小的工作』，这个学期真的算是有史以来最火力全开的了。</p>
<p>按照以往的经验，这种高强度的工作通常持续不了太久，不过这周去吃了一次海鲜自助餐，算是大大满足了一番，真是无论如何，美酒美食，不能停止了供应。</p>
<p>很让自己高兴的一点是慢慢开始从更长远的角度去考虑问题和指定计划了。比方说，高中时候写日志大多是流水账，之后可能稍微有一些主题，但是比较零散，但是现在开始谋划一个大主题，然后分成不同的小主题，逐个写完，组合起来能发挥比以前单篇文章更大的效果。而一个个主题又是为了更大的目标而努力，这种垒积木居然还蛮有意思的。感觉像是散兵游勇终于凑到一起，训练了一两年，成了正规军了。</p>
<p>但是正规军也不是啥都好，少了些灵气，就我现在来说，还是更喜欢李云龙独立团那种血性，年轻人还是要敢打敢拼一点，可能欠缺些考虑甚至有点鲁莽，那也要比永远留在安全舒适区来得好。</p>
<p>想做的能做的事情还有很多，摩拳擦掌，蓄势待发。（因为本周末的寒潮+大雪，估计只能在家多发文章了，哈哈）</p>
<p>And maybe I’ve been left out. Never let this be mistaken.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Ain’t no way to shut me down. Or to take the path I’ve taken.</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="改变" scheme="http://wdxtub.com/tags/%E6%94%B9%E5%8F%98/"/>
    
      <category term="面试" scheme="http://wdxtub.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 1 课 总览]]></title>
    <link href="http://wdxtub.com/2016/01/22/programmer-startline-1/"/>
    <id>http://wdxtub.com/2016/01/22/programmer-startline-1/</id>
    <published>2016-01-22T14:35:39.000Z</published>
    <updated>2016-01-23T00:59:34.000Z</updated>
    <content type="html"><![CDATA[<p>学了这么多年计算机和编程，在快要步入社会之前，在不断地碰壁和尝试之后，终于摸到了一点门路。这个系列的文章，更接近于编程入门指南，讲的是从数据结构到算法最终到解决问题的方法和思路。</p>
<a id="more"></a>
<hr>
<p>我想，对于大多数经历过或者正在经历从校园转入社会的人来说，找工作本身就是一个很好的学习过程。如果想要成为一个程序员，尤其是在北美的话，那么刷题（也就是做各种数据结构算法的题目）就是必不可少的了，颇有应试教育的味道。</p>
<p>学习并不是为了考试，可是分数是简单粗暴评判学习效果的方法；编程并不是为了刷题，可是能否给出解答是简单粗暴评判编程水平的方法。虽然不合理不科学，但是在人力物力有限的条件下，这就是游戏规则。</p>
<p>在这个过程中，你会发现，聪明人，或者说善于学习的人，很快就会从应试模式转变为探索模式。题目背后是知识，不同的知识点交织成为学科，死记硬背只能解决见过的问题，但是如果在这个过程中培养了逻辑推理的能力，哪怕遇到一个『新』问题，也能通过类比，找到用『旧』方法稍微变化就可以解决的途径。</p>
<p>如果了解了计算机发展的历史，就会发现，所有现在看起来非常复杂的东西，都是建立在非常简单的基础——零和一——之上的。从最简单的基本类型，到数据结构和算法，通通都是为了解决实际问题而产生的高效解决方案。的确，无论是计算机科学，还是编程，都是非常大的话题，但是并不意味着起跑会很难。在我看来，需要了解的内容，大概有下面这几类（这里参考了 Google 面试指南的部分内容）：</p>
<ol>
<li>掌握一门基本的编程语言。最好是强类型，支持面向对象编程（比如 C++/Java/C#）的语言。这里说的掌握，不仅仅是语法，而是对语言本身的一些设计特点和具体实现方式的理解。</li>
<li>能够以 Big O 的方式去分析一个算法的时间/空间复杂度，这样才有一个标准的方式去分析算法的效率。</li>
<li>基本数据结构的理解和使用，比如<ul>
<li>哈希表 Hashtable，及其背后所代表的哈希的思想是如何应用的不同问题的，如果只能用数组来实现，要如何实现</li>
<li>树 Tree，    树的构建(trie)，遍历和修改。遍历包括 BFS 和 DFS（前序中序后序），及其对应的思想。如果了解至少一种平衡树（及实现方式）就更好了。</li>
<li>图 Graph，图的三种表达方式及优缺点，基本的遍历算法（还是 BFS 和 DFS），知道这些算法的复杂度以及权衡利弊。如果了解一些如 Dijkstra 和 A* 算法就更好了。</li>
<li>其他的数据结构：堆栈队列链表</li>
</ul>
</li>
<li>基本算法的理解和使用，比如排序和搜索，以及递归和动态规划。nlogn 时间的排序，logn 时间的搜索。以及了解什么是 NP 问题（旅行商等等）。</li>
<li>基本的数学知识，排列组合及概率，和一些公式化简。这里可能还可以算上正则表达式。</li>
<li>操作系统，编译器，及计算机系统的基本知识。比如说进程线程，互斥锁信号量，死锁出现的条件及如何避免，进程线程的资源和上下文切换，多核处理的相关知识。重要的是对计算机相关工具的理解，除了上面提到的，还有 shell 之类的用法。</li>
<li>基本的设计能力。面向对象设计，代码风格及优化。</li>
<li>如何清晰表达自己的想法，去快速构建一个问题的解决方案。</li>
</ol>
<p>还是那句话，刷题仅仅只是一个效率很低的练习过程，真正的学习是进行『刻意练习』，也是我这个系列文章中想要强调的内容。</p>
<p>一通百通，悟道之后就会发现，一招一式固然重要，但那些都是基础，更重要的是解决问题的方法和思路，这，可能就需要多动一点脑子了。</p>
<p>最后说一下大概的写作内容的范围：</p>
<ul>
<li>正文部分力争简明扼要，说重点，说思想，注意语言逻辑和风格</li>
<li>不贴大段的代码，而是会在文章最后给出题目分类及对应链接</li>
<li>会挑选重点，经典题目进行思路讲解</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>学了这么多年计算机和编程，在快要步入社会之前，在不断地碰壁和尝试之后，终于摸到了一点门路。这个系列的文章，更接近于编程入门指南，讲的是从数据结构到算法最终到解决问题的方法和思路。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 9 课 Machine Advanced]]></title>
    <link href="http://wdxtub.com/2016/01/21/csapp-9/"/>
    <id>http://wdxtub.com/2016/01/21/csapp-9/</id>
    <published>2016-01-22T00:16:21.000Z</published>
    <updated>2016-01-22T20:35:42.000Z</updated>
    <content type="html"><![CDATA[<p>这一讲是机器代码的最后一部分，会介绍一些『高级』话题，比如程序在内存中的组织，缓冲区溢出引起的攻防大战，以及 Union 的具体实现方式。</p>
<a id="more"></a>
<hr>
<p>我们先来看看程序在内存中是如何组织的（x86-64 Linux）：</p>
<p><img src="/images/14534337498107.jpg" alt=""></p>
<p>最上面是运行时栈，有 8MB 的大小限制，一般用来保存局部变量。然后是堆，动态的内存分配会在这里处理，例如 <code>malloc()</code>, <code>calloc()</code>, <code>new()</code> 等。然后是数据，指的是静态分配的数据，比如说全局变量，静态变量，常量字符串。最后是共享库等可执行的机器指令，这一部分是只读的。</p>
<p>看个具体分配的例子：</p>
<p><img src="/images/14534340388277.jpg" alt=""></p>
<p>经过观察大概是这样的：</p>
<p><img src="/images/14534340592122.jpg" alt=""></p>
<p>这里注意一点，分配堆的时候是两头分配的，到中间相遇的时候就说明没有空间了，具体是怎么在两头分配的呢？老师也表示不知道。</p>
<h2 id="Buffer_Overflow"><a href="#Buffer_Overflow" class="headerlink" title="Buffer Overflow"></a>Buffer Overflow</h2><p>缓冲区溢出需要注意两个方面，一是为什么会产生这种情况，二是在黑客利用这种漏洞来进行攻击时，能够怎么防范。</p>
<p>先看看之前提到过的例子：</p>
<p><img src="/images/14534345803640.jpg" alt=""></p>
<p>之所以会产生这种错误，是因为访问内存的时候跨过了数组本身的界限修改了 d 的值：</p>
<p><img src="/images/14534346212614.jpg" alt=""></p>
<p>你没看错，这是个大问题！#1 technical cause of security vulnerabilities! #1 overall cause is social enginnering / user ignorance!</p>
<p>如果不检查输入字符串的长度，就很容易出现这种问题，尤其是针对在栈上有界限的字符数组。</p>
<p>在 Unix 中，<code>gets()</code> 函数的实现是这样的：</p>
<p><img src="/images/14534348853894.jpg" alt=""></p>
<p>可以看到并没有去检测最多能读入多少字符（于是很容易出问题），类似的情况还在 <code>strcpy</code>, <code>strcat</code>, <code>scanf</code>, <code>fscanf</code>, <code>sscanf</code> 中出现。比如说</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">4</span>]; <span class="comment">// 太小</span></span><br><span class="line">	gets(buf);</span><br><span class="line">	<span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_echo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	echo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们输入一长串，可以看到：</p>
<p><img src="/images/14534352714657.jpg" alt=""></p>
<p>为什么命名只给了 4 个 char，居然一开始输入这么多都没问题？我们到汇编代码里去看看：</p>
<p><img src="/images/14534354107024.jpg" alt=""></p>
<p>可以看到实际上是给 %rsp 分配了 0x18 的空间的。</p>
<p><img src="/images/14534362980014.jpg" alt=""></p>
<p>在调用之前，可以看到内存的摆放是这样的，但是调用了 <code>call_echo</code> 之后，就变成：</p>
<p><img src="/images/14534363898271.jpg" alt=""></p>
<p>虽然缓冲区溢出了，但是并没有损害当前的状态，程序还是可以继续运行（也就是没有出现段错误），但是如果再多一点的话：</p>
<p><img src="/images/14534366083059.jpg" alt=""></p>
<p>就把返回地址给覆盖掉了，但是段错误之后发现还可以继续运行，是因为返回代码会返回到 <code>main</code> 中，和具体的地址无关：</p>
<p><img src="/images/14534367016302.jpg" alt=""></p>
<p>在这个例子中没有问题，但是在下面的例子中，就会出问题了</p>
<p><img src="/images/14534367347277.jpg" alt=""></p>
<p>原本函数 P 的返回地址是 A，但是因为 Buffer 一直在被写，直接改到了 P 的栈帧，那么之后跳转就会跳转到奇怪的地方了。</p>
<p>那么我们现在来看看，怎么处理缓冲区溢出攻击，有几种方式：</p>
<ol>
<li>好好写代码，尽量不让缓冲区异常</li>
<li>程序容易出问题，那么提供系统层级的保护</li>
<li>编译器也可以来个认证(stack canaries)</li>
</ol>
<p>第一种，避免缓冲区溢出，我们用更安全的方法，如：<code>fgets</code>, <code>strncpy</code> 等等。</p>
<p>第二种，栈的位置不确定，让缓冲区溢出没办法影响到，并且每次位置都不一样，就不怕被暴力破解：</p>
<p><img src="/images/14534373336480.jpg" alt=""></p>
<p>并且也可以把一段内存标记为只读，那么就避免因为缓冲区溢出而导致的重写。</p>
<p>第三种，使用 Stack Canaries。简单来说，就是在超出缓冲区的位置加一个特殊的值，如果发现这个值变化了，那么就知道出问题了。</p>
<p>但是，除了缓冲区溢出，还有另一种攻击的方式，就是把返回的位置给改了。可以利用修改已有的代码，来绕过系统和编译器的保护机制。这里就不详细展开了。</p>
<h2 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h2><p>和结构体对应的一种结构，但是其实我在编程的时候感觉不是非常常见，这里简单了解下实现原理：</p>
<p><img src="/images/14534375732251.jpg" alt=""></p>
<p>具体的拜访可以是：</p>
<p><img src="/images/14534376064591.jpg" alt=""></p>
<p>下面是三种不同系统上的排布：</p>
<p><img src="/images/14534376440995.jpg" alt=""></p>
<p><img src="/images/14534376568110.jpg" alt=""></p>
<p><img src="/images/14534376658164.jpg" alt=""></p>
<p>这一讲的内容就到这里，下一讲是非常有趣的关于如何优化代码的内容，我自己都很期待。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一讲是机器代码的最后一部分，会介绍一些『高级』话题，比如程序在内存中的组织，缓冲区溢出引起的攻防大战，以及 Union 的具体实现方式。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 8 课 Machine Data]]></title>
    <link href="http://wdxtub.com/2016/01/21/csapp-8/"/>
    <id>http://wdxtub.com/2016/01/21/csapp-8/</id>
    <published>2016-01-21T16:16:14.000Z</published>
    <updated>2016-01-22T20:35:47.000Z</updated>
    <content type="html"><![CDATA[<p>上一讲我们了解了过程调用是如何用机器代码实现的，这一讲我们来看看基本的数据是如何存储在计算机中的。</p>
<a id="more"></a>
<hr>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>数组其实就是连续分配的地址空间，比如说 <code>T A[L]</code>，意思就是类型 T 且长度为 L 的数组，需要分配 <code>L*sizeof(T)</code> 个字节的空间。</p>
<p><img src="/images/14534188845612.jpg" alt=""></p>
<p>既然是连续的地址空间，就有很多不同的访问方式，举个例子：</p>
<p><img src="/images/14534189454190.jpg" alt=""></p>
<p>那么对应的一些访问方式为：</p>
<p><img src="/images/14534189637879.jpg" alt=""></p>
<p>再举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> ZLEN <span class="number">5</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> zip_dig[ZLEN];</span><br><span class="line"></span><br><span class="line">zip_dig cmu = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/14534198336930.jpg" alt=""></p>
<p>假设我们要取数组中的某一位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_digit</span><span class="params">(zip_dig z, <span class="keyword">int</span> digit)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> z[digit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码是：</p>
<p><img src="/images/14534198966151.jpg" alt=""></p>
<p>这里寄存器 %rdi 中存着数组的起始地址，寄存器 %rsi 存着序号，我们要访问的地址等价于 <code>%rdi + 4*%rsi</code>，用内存引用的方式就是 <code>(%rdi, %rsi, 4)</code>。</p>
<p>再看一个数组循环的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zincr</span><span class="params">(zip_dig z)</span></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ZLEN; i++)</span><br><span class="line">		z[i]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编是，注意红字的部分，相当于等价实现了 <code>++</code> 操作</p>
<p><img src="/images/14534201884816.jpg" alt=""></p>
<p>对于多维的数组，基本形式是 <code>T A[R][C]</code>，R 是行，C 是列，如果类型 T 占 K 个字节的话，那么数组所需要的内存是 <code>R*C*K</code> 字节。具体在内存里的排列方式如下：</p>
<p><img src="/images/14534202945733.jpg" alt=""></p>
<p>多维数组的第一维可以看作是每行起始的地址：</p>
<p><img src="/images/14534203418848.jpg" alt=""></p>
<p>因为如此，所以访问可以是这样的：</p>
<p><img src="/images/14534205890785.jpg" alt=""></p>
<p>这里 <code>pgh[index][dig]</code> 是 int 类型。地址 <code>pgh + 20*index + 4*dig = pgh + 4*(5*index + dig)</code>。</p>
<p>还有另外一种组合数组的方式，不是连续分配，而是存储每个数组的起始地址，例如：</p>
<p><img src="/images/14534208481488.jpg" alt=""></p>
<p><img src="/images/14534208616228.jpg" alt=""></p>
<p>获取具体某个元素的地址其实就是计算时的起始地址有变换，对应的代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_univ_digit</span><span class="params">(size_t index, size_t digit)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> univ[index][digit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编为：</p>
<p><img src="/images/14534209862505.jpg" alt=""></p>
<p>这里等同于进行两次内存访问 <code>Mem[Mem[univ+8*index]+4*digit]</code>，</p>
<p>对比一下</p>
<p><img src="/images/14534218752318.jpg" alt=""></p>
<p>在 C 语言中看起来差不多，但是实际上差别很大：</p>
<p><code>Mem[pgh+20*index+4*digit]</code> vs <code>Mem[Mem[univ+8*index]+4*digit]</code></p>
<h2 id="Structures"><a href="#Structures" class="headerlink" title="Structures"></a>Structures</h2><p>结构体是如何表示的呢，大概是这样：</p>
<p><img src="/images/14534222886026.jpg" alt=""></p>
<p>这里我们发现刚好都是 4 的倍数，如果换一种方式来组合，会是怎么样的呢？会像下图这样吗？</p>
<p><img src="/images/14534225034162.jpg" alt=""></p>
<p>答案是，并不会，会在内存中进行对齐：</p>
<p><img src="/images/14534225338581.jpg" alt=""></p>
<p>具体对齐的原则是，如果 primitive data type 需要 K 个字节，那么地址都必须是 K 的倍数。为什么要这样呢，因为内存访问通常来说是 4 或者 8 个字节位单位的，不对齐的话访问起来效率不高。具体来看的话，是这样：</p>
<ul>
<li>1 字节：char, …<ul>
<li>没有地址的限制</li>
</ul>
</li>
<li>2 字节：short, …<ul>
<li>地址最低的 1 比特必须是 $0_2$</li>
</ul>
</li>
<li>4 字节：int, float, …<ul>
<li>地址最低的 2 比特必须是 $00_2$</li>
</ul>
</li>
<li>8 字节：double, long, char *, …<ul>
<li>地址最低的 3 比特必须是 $000_2$</li>
</ul>
</li>
<li>16 字节：long double (GCC on Linux)<ul>
<li>地址最低的 4 比特必须是 $0000_2$</li>
</ul>
</li>
</ul>
<p>对于一个结构体来说，所占据的内存空间必须是最大的类型所需字节的倍数，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> S2 &#123;</span><br><span class="line">	<span class="keyword">double</span> v;</span><br><span class="line">	<span class="keyword">int</span> i[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure>
<p><img src="/images/14534232756482.jpg" alt=""></p>
<p>如果是结构体数组的话，那就是像这样：</p>
<p><img src="/images/14534233087461.jpg" alt=""></p>
<p>具体到访问结构体中的例子，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> S3 &#123;</span><br><span class="line">	<span class="keyword">short</span> i;</span><br><span class="line">	<span class="keyword">float</span> v;</span><br><span class="line">	<span class="keyword">short</span> j;</span><br><span class="line">&#125; a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p><img src="/images/14534233625482.jpg" alt=""></p>
<p>那么根据这种特点，就有一些技巧了。例如，要把大的数据类型放到前面，看这个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> S4 &#123;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> d;</span><br><span class="line">&#125; *p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> S5 &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">char</span> d;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure>
<p>那么这两种的对应排列就是：</p>
<p><img src="/images/14534240460958.jpg" alt=""></p>
<p>可以看到，下面那种省了 4 个字节。</p>
<h2 id="Floating_Point"><a href="#Floating_Point" class="headerlink" title="Floating Point"></a>Floating Point</h2><p>浮点数的部分在课上介绍的不是很多，这里简要介绍一下。</p>
<p>最开始是 x87 FP（比较丑陋），之后是 SSE FP（利用了向量指令），然后是 AVX FP（类似与 SSE）。</p>
<p>SSE3 对于 XMM 寄存器一共有 16 个，每个 16 字节：</p>
<p><img src="/images/14534252071793.jpg" alt=""></p>
<p>下面是对标量和 SIMD 操作的描述：</p>
<p><img src="/images/14534254596599.jpg" alt=""></p>
<p>具体的机制也是类似的，传入的参数存储在 %xmm0, %xmm1，返回参数在 %xmm0，所有的 XMM 寄存器都会被保存在调用者的栈帧中：</p>
<p><img src="/images/14534255846801.jpg" alt=""></p>
<p>这一讲到此结束，之后会进入更深入的话题（因为作业大概两到三周一次，所以可能先把重点放在概念的理解上）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一讲我们了解了过程调用是如何用机器代码实现的，这一讲我们来看看基本的数据是如何存储在计算机中的。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 7 课 Machine Procedures]]></title>
    <link href="http://wdxtub.com/2016/01/21/csapp-7/"/>
    <id>http://wdxtub.com/2016/01/21/csapp-7/</id>
    <published>2016-01-21T16:15:37.000Z</published>
    <updated>2016-01-22T20:35:51.000Z</updated>
    <content type="html"><![CDATA[<p>之前我们学习了机器是如何利用跳转实现流程控制的，这一讲我们来看一个更加复杂的机制：过程调用（也就是调用函数）具体在 CPU 和内存中是怎么实现了。理解之后，对于递归会有更加清晰的认识。</p>
<a id="more"></a>
<hr>
<p>在过程调用中主要涉及三个重要的方面：</p>
<ol>
<li>传递控制：包括如何开始执行过程代码，以及如何返回到开始的地方</li>
<li>传递数据：包括过程需要的参数以及过程的返回值</li>
<li>内存管理：如何在过程执行的时候分配内存，以及在返回之后释放内存</li>
</ol>
<p>以上这三点，都是凭借机器指令实现的</p>
<h2 id="Stack_Structure"><a href="#Stack_Structure" class="headerlink" title="Stack Structure"></a>Stack Structure</h2><p>在 x86-64 中，所谓的栈，实际上一块内存区域，这个区域的数据进出满足先进后出的原则。越新入栈的数据，地址越低，所以栈顶的地址是最小的。下图中箭头所指的就是寄存器 %rsp 的值，这个寄存器是栈指针，用来记录栈顶的位置。</p>
<p><img src="/images/14533820160341.jpg" alt=""></p>
<p>对于 <code>push</code> 操作，对应的是 <code>pushq Src</code> 指令，具体会完成下面三个步骤：</p>
<ol>
<li>从地址 <code>Src</code> 中取出操作数</li>
<li>把 %rsp 中的地址减去 8（也就是到下一个位置）</li>
<li>把操作数写入到 %rsp 的新地址中 </li>
</ol>
<p>如下图所示：</p>
<p><img src="/images/14533823825128.jpg" alt=""></p>
<p>对于 <code>pop</code> 操作，对应的是 <code>popq Dest</code> 指令，具体会完成下面三个步骤：</p>
<ol>
<li>从 %rsp 中存储的地址中读入数据</li>
<li>把 %rsp 中的地址增加 8（回到上一个位置）</li>
<li>把刚才取出来的值放到 <code>Dest</code> 中（这里必须是一个寄存器）</li>
</ol>
<p>如下图所示：</p>
<p><img src="/images/14533826092815.jpg" alt=""></p>
<h2 id="Calling_Conventions"><a href="#Calling_Conventions" class="headerlink" title="Calling Conventions"></a>Calling Conventions</h2><p>了解了栈的结构之后，我们先通过一个函数调用的例子，来感受一下（代码中有详细注释，请理解后再继续）：</p>
<p><img src="/images/14533827066202.jpg" alt=""></p>
<p>可以看到，过程调用是利用栈来进行的，通过 <code>call label</code> 来进行调用（先把返回地址入栈，然后跳转到对应的 label），返回的地址，将是下一条指令的地址，通过 <code>ret</code> 来进行返回（把地址从栈中弹出，然后跳转到对应地址）</p>
<p>用上面的代码来做说明：</p>
<p><img src="/images/14533831060878.jpg" alt=""></p>
<p>在执行到 400544 那一行的时候 %rsp 指向栈顶（存储着栈顶的地址），%rip 指向当前要执行的指令（也就是 400544）</p>
<p><img src="/images/14533832007622.jpg" alt=""></p>
<p>在上一步操作完成之后，因为跳转的关系，%rip 指向 mult2 函数开始的地方（也就是 400550），之前的压栈操作也使得栈顶改变（返回值的位置），于是 %rsp 对应进行改变。</p>
<p><img src="/images/14533833724077.jpg" alt=""></p>
<p>接着执行到了 <code>retq</code> 那句，这个时候要做的就是从栈中取出栈顶位置（这样就可以从跳转处继续了），然后对寄存器做对应的修改，最后得到下图：</p>
<p><img src="/images/14533834735407.jpg" alt=""></p>
<p>具体的传值我们可以发现，是利用 %rax 来保存过程调用的返回值，以便程序继续运行的。这就是基本的过程调用的控制流程。</p>
<p>那么过程调用的参数会放在哪里呢？</p>
<p>如果参数没有超过六个，那么会放在：%rdi, %rsi, %rdx, %rcx, %r8, %r9 中。如果超过了，会另外放在一个栈中。而返回值会放在 %rax 中。</p>
<p>还是刚才的例子，看看数据的存放：</p>
<p><img src="/images/14533838086805.jpg" alt=""></p>
<p>既然是利用栈来进行函数调用，自然而然就可以推广到递归的情况，而对于每个过程调用来说，都会在栈中分配一个帧 Frames。每一帧里需要包含：</p>
<ul>
<li>返回信息</li>
<li>本地存储（如果需要）</li>
<li>临时空间（如果需要）</li>
</ul>
<p>整一帧会在过程调用的时候进行空间分配，然后在返回时进行回收，如下图所示（箭头所指位栈顶）：</p>
<p><img src="/images/14533842524928.jpg" alt=""></p>
<p>这里是一个调用的例子：</p>
<p><img src="/images/14533843491372.jpg" alt=""></p>
<p>在 x86-64/Linux 中，栈帧的结构是固定的，当前的要执行的栈中包括：</p>
<ul>
<li>Argument Build: 需要使用的参数</li>
<li>如果不能保存在寄存器中，会把一些本地变量放在这里</li>
<li>已保存的寄存器上下文</li>
<li>老的栈帧的指针（可选）</li>
</ul>
<p>而调用者的栈帧则包括：</p>
<ul>
<li>返回地址（因为 <code>call</code> 指令被压入栈的）</li>
<li>调用所需的参数</li>
</ul>
<p>具体如下图所示：</p>
<p><img src="/images/14533846615880.jpg" alt=""></p>
<p>下面用一个程序来说明一下，就比较清晰了：</p>
<p><img src="/images/14533847155070.jpg" alt=""></p>
<p>在函数调用前，需要移动 %rsp 指针存入调用者的变量压入栈中</p>
<p><img src="/images/14533848182706.jpg" alt=""></p>
<p>具体调用的时候，会根据返回值对应修改地址和数据。</p>
<p>寄存器保存数值的时候也有一些习惯的用法，这里也举个例子说明：</p>
<p><img src="/images/14533849340898.jpg" alt=""></p>
<p>这里的 <code>yoo</code> 被称为调用者 caller，<code>who</code> 被称为被调用者 callee。于是就有一个问题，能不能用寄存器（这里是 %rdx）来保存临时变量呢？</p>
<p>似乎不大可以，因为在两个函数中都进行了修改，所以在这之前需要做一些额外的操作。对于调用者来说，需要把临时变量保存在栈帧中，然后进行调用；对于被调用者来说，可以在栈帧中保存临时变量，但是在返回的时候需要恢复成原来的样子（让调用者继续工作）</p>
<p>一般来说用法是这样的：</p>
<p><img src="/images/14533857001617.jpg" alt=""></p>
<p>这里的变量都会被保存到 caller 的栈帧中（因为可能之后会被修改）</p>
<p><img src="/images/14533857595809.jpg" alt=""></p>
<p>除了 %rsp 外，这里都会保存在 callee 的栈帧中，并且在调用完成之后需要恢复成原来的数值。</p>
<h2 id="u9012_u5F52_u7684_u63CF_u8FF0"><a href="#u9012_u5F52_u7684_u63CF_u8FF0" class="headerlink" title="递归的描述"></a>递归的描述</h2><p>有了前面的的基础，要理解递归就简单很多了，直接上例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pcount_r</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> (x &amp; <span class="number">1</span>) + pcount_r(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码为：</p>
<p><img src="/images/14533859204097.jpg" alt=""></p>
<p>实际执行的过程中，会不停进行压栈，知道最后返回，所以递归本身就是一个隐式的栈实现，但是系统一般对于栈的深度有限制（每次一都需要保存当前栈帧的各种数据），所以一般来说会把递归转换成显式栈来进行处理以防溢出。</p>
<p>这一讲的内容就这么多，需要好好理解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前我们学习了机器是如何利用跳转实现流程控制的，这一讲我们来看一个更加复杂的机制：过程调用（也就是调用函数）具体在 CPU 和内存中是怎么实现了。理解之后，对于递归会有更加清晰的认识。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 第 9 课 Sequential Programming]]></title>
    <link href="http://wdxtub.com/2016/01/20/cc-9/"/>
    <id>http://wdxtub.com/2016/01/20/cc-9/</id>
    <published>2016-01-20T20:05:54.000Z</published>
    <updated>2016-01-22T20:35:15.000Z</updated>
    <content type="html"><![CDATA[<p>这一讲我们就要开始实际接触一个真实的项目——处理一个大文本数据集了。在云上编程和平时学习的可能有一些不同，这里会尽量写得详细一些。</p>
<a id="more"></a>
<hr>
<p>先来具体说说这节课的任务：</p>
<ol>
<li>用顺序执行的程序在云上处理一个大文本数据集。</li>
<li>在这个过程中了解顺序方法的限制</li>
</ol>
<p>这次我们会在特定的 AMI(可以理解为系统镜像)上进行操作，注意不能用外部依赖（也就是不能 <code>sudo apt-get install</code> 任何软件或库，即使装了在测试的时候也没办法运行）</p>
<p>数据集来自维基的<a href="http://dumps.wikimedia.org/other/pagecounts-raw/" target="_blank" rel="external">页面访问统计数据 hourly page view statistics</a></p>
<h2 id="u5173_u4E8E_u6570_u636E_u96C6"><a href="#u5173_u4E8E_u6570_u636E_u96C6" class="headerlink" title="关于数据集"></a>关于数据集</h2><p><code>Wikimedia</code> 会维护所有保存在服务器的对象的每小时页面访问数据并以开放数据集的形式给大家使用。我们会使用这些数据来分析一定时间内页面浏览的趋势。</p>
<p><img src="/images/14532371430507.jpg" alt=""><br>A simplified diagram of a page access form Wikimedia. <a href="http://en.wikipedia.org/wiki/Wikimedia_Foundation#Hardware" target="_blank" rel="external">More information</a></p>
<p>每个对于维基服务器的请求会被当做一个 <a href="http://en.wikipedia.org/wiki/Squid_%28software%29" target="_blank" rel="external">squid cache proxy</a> 来进行处理，同时也会把这些请求记录到日志中。这些日志每个小时更新，大家都可以访问。文件里的每一行对应着一次访问记录，格式如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[项目名称] [页面标题] [访问次数] [总共返回的字节数]</span><br></pre></td></tr></table></figure>
<p><code>[项目名称]</code>包括两个部分，一个是语言标识符和一个子项目后缀，具体如下：</p>
<ul>
<li><code>(no suffix)</code> : wikipedia</li>
<li><code>.b</code> : wikibooks</li>
<li><code>.d</code> : wiktionary</li>
<li><code>.m</code> : wikimedia</li>
<li><code>.mw</code> : wikipedia mobile</li>
<li><code>.n</code> : wikinews</li>
<li><code>.q</code> : wikiquote</li>
<li><code>.s</code> : wikisource</li>
<li><code>.v</code> : wikiversity</li>
<li><code>.w</code> : mediawiki</li>
</ul>
<p>举个例子，假设有一行是这样的：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fr.b <span class="constant">Special</span><span class="symbol">:Recherche/All_Mixed_Up</span> <span class="number">1</span> <span class="number">730</span></span><br></pre></td></tr></table></figure>
<p>就说明这条记录的产生是因为有人访问了 <code>French Wikibooks</code> 中的 <code>Special:Recherche/All_Mixed_Up</code> 页面 1 次，并且总共传输了 730 个字节。</p>
<p>这个项目中，我们主要会分析 2015 年 12 月的数据。不过现在我们只需要处理 12 月 1 日的第一个小时的数据。数据在 <code>s3://cmucc-datasets/wikipediatraf/201512/pagecounts-20151201-000000.gz</code>。可以使用 <code>aws-cli</code>, <code>s3cmd</code> 或者 S3 查看器来了解。但是在服务器上，就需要用 <code>wget</code> 来下载了，具体的地址是 <a href="https://cmucc-datasets.s3.amazonaws.com/wikipediatraf/201512/pagecounts-20151201-000000.gz" target="_blank" rel="external">https://cmucc-datasets.s3.amazonaws.com/wikipediatraf/201512/pagecounts-20151201-000000.gz</a></p>
<p>命令为 <code>wget https://cmucc-datasets.s3.amazonaws.com/wikipediatraf/201512/pagecounts-20151201-000000.gz</code></p>
<p>如果不是很了解如何访问 Amazon S3，可以回头看看<a href="http://wdxtub.com/2016/01/15/cc-2/">云计算 第 2 课 AWS 简介</a></p>
<h2 id="Data_Filtering"><a href="#Data_Filtering" class="headerlink" title="Data Filtering"></a>Data Filtering</h2><p>简单来说，我们要从维基的访问数据中，用各类数据分析的方法，看看能不能找到些什么有意思的东西。</p>
<p>我们会先从第一个小时的维基流量日志开始分析，主要关注英文维基的内容。这种从完整数据的一个子集开始测试起并最终应用到全部数据的方法，在之后的项目中会很有用。</p>
<p>我们先使用 <code>ami-95e9cdff</code>（社区 AMI 中）来创建一个 <code>t1.micro</code> 实例，记得在右上角把地区切换为 <code>弗吉尼亚北部</code>。允许 SSH 和 HTTP 连接（可以使用之前的安全组）。像下面这样：</p>
<p><img src="/images/14533207601658.jpg" alt=""></p>
<p>这里我选择的是竞价型实例（因为会便宜一点），但需要注意的是申请成功之后一定要注意重新打上标签：<code>{&quot;Key&quot;:&quot;Project&quot;,&quot;Value&quot;:&quot;1.1&quot;}</code>。</p>
<p>然后我们耐心等待实例创建，然后使用 <code>ssh -i demo.pem ubuntu@ec2-54-165-218-37.compute-1.amazonaws.com</code> 来进行连接，如下图：</p>
<p><img src="/images/14533217554276.jpg" alt=""></p>
<p>然后进入 <code>Project1_1</code> 文件夹，先把第一个小时的日志文件下载下来，命令为：<code>wget https://cmucc-datasets.s3.amazonaws.com/wikipediatraf/201512/pagecounts-20151201-000000.gz</code></p>
<p>下载速度还是很快的(20MB/s)，然后是一些注意事项：</p>
<p><strong>需要过滤的内容 1</strong></p>
<p>有些行只有 3 个（或更少）元素，需要过滤掉，如 </p>
<p><code>en 1282 10636194</code></p>
<p><strong>需要过滤的内容 2</strong></p>
<p>那些不是来自英文维基的页面访问需要过滤掉，也就是说，如果某一行不是以 <code>en</code> 开始的（大小写敏感），就需要过滤</p>
<p><strong>需要过滤的内容 3</strong></p>
<p>维基的特殊页面在这里不需要考虑，排除那些以如下字段开始的标题（大小写敏感）：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">Media:</span></span><br><span class="line"><span class="label">Special:</span></span><br><span class="line"><span class="label">Talk:</span></span><br><span class="line"><span class="label">User:</span></span><br><span class="line"><span class="label">User_talk:</span></span><br><span class="line"><span class="label">Project:</span></span><br><span class="line"><span class="label">Project_talk:</span></span><br><span class="line"><span class="label">File:</span></span><br><span class="line"><span class="label">File_talk:</span></span><br><span class="line"><span class="label">MediaWiki:</span></span><br><span class="line"><span class="label">MediaWiki_talk:</span></span><br><span class="line"><span class="label">Template:</span></span><br><span class="line"><span class="label">Template_talk:</span></span><br><span class="line"><span class="label">Help:</span></span><br><span class="line"><span class="label">Help_talk:</span></span><br><span class="line"><span class="label">Category:</span></span><br><span class="line"><span class="label">Category_talk:</span></span><br><span class="line"><span class="label">Portal:</span></span><br><span class="line"><span class="label">Wikipedia:</span></span><br><span class="line"><span class="label">Wikipedia_talk:</span></span><br></pre></td></tr></table></figure>
<p><strong>需要过滤的内容 4</strong></p>
<p>维基的政策规定所有的英文文章都必须以大写字母开头，过滤掉那些以小写字母开头的访问记录。注意，有些页面的标题是非英文字符，应该保留。</p>
<p><strong>需要过滤的内容 5</strong></p>
<p>还有一些记录是引用图片文件的，同样需要过滤掉标题以下列扩展名结尾的记录</p>
<p><code>.jpg, .gif, .png, .JPG, .GIF, .PNG, .txt, .ico</code></p>
<p><strong>需要过滤的内容 6</strong></p>
<p>还有一些无关的页面记录需要移除，如果页面标题是如下内容（大小写敏感），需要过滤掉：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">404</span>_error/</span><br><span class="line">Main_Page</span><br><span class="line">Hypertext_Transfer_Protocol</span><br><span class="line">Search</span><br></pre></td></tr></table></figure>
<p>这些都完成之后，把剩余的记录用下面的格式输出：</p>
<p><code>[page title]\t[number of accesses]</code></p>
<p>注意：</p>
<ul>
<li>你可能会发现语言包括 <code>en</code>, <code>EN</code> 和 <code>EN</code>，只对 <code>en</code> 的部分进行处理</li>
<li>输出应该根据访问次数降序排列</li>
</ul>
<p>接下来会用几种不同的方式来完成，我们先解压文件 <code>gzip -d pagecounts-20151201-000000.gz</code></p>
<h3 id="awk__u7248_u672C"><a href="#awk__u7248_u672C" class="headerlink" title="awk 版本"></a>awk 版本</h3><p>因为第一步只是做简单的文字处理，所以用命令行自带的 awk 应用就可以完成。awk 的用法这里不详细介绍，在 <code>runner.sh</code> 中的 <code>answer_0()</code> 函数中填写下面代码：</p>
<p><img src="/images/14533240490475.jpg" alt=""></p>
<p>然后执行 <code>./runner.sh</code>，就可以看到：</p>
<p><img src="/images/14533240848416.jpg" alt=""></p>
<p>我们现在来试着提交一下：</p>
<p><code>./submitter -a dawang -l bash</code></p>
<p>如果引用了其他的内容，需要把对应的资料放到 <code>reference</code> 文件夹中，不然抄袭后果很严重。</p>
<p>因为这一问不评分，所以并没有结果。</p>
<p>这里我又用 java 重写了一次，这里建议大家最好在本地测试运行一下再上传到 AWS 上。考虑到 python 性能比较差，所以从一开始就用 java。</p>
<h3 id="Data_Analysis"><a href="#Data_Analysis" class="headerlink" title="Data Analysis"></a>Data Analysis</h3><p>接下来就是完成 <code>runner.sh</code> 中的各项任务了，具体任务如下：</p>
<ol>
<li>输出过滤前所有的行数</li>
<li>输出过滤前所有的访问数的总和</li>
<li>过滤之后有还剩多少行</li>
<li>过滤后的最受欢迎的文章是什么，输出标题即可</li>
<li>在过滤后的数据集中，包含『cloud』和『computing』的文章有多少个，这里注意是精确匹配，也不区分大小写</li>
<li>过滤后的数据集中最受欢迎的电影的次数，注意，电影的话标题里会有『film』</li>
<li>过滤后的数据集中访问次数在 2500~3000 之间的有多少个</li>
<li>以一个数字开头，之后是字母的页面有多少次访问（注意是开头，正则表达式要匹配上）</li>
<li>是 2014 年的电影更热门还是 2015 年的更热门，搜索『2014_film』和『2015_film』，注意大小写敏感</li>
</ol>
<p>这里需要注意的是，因为在 <code>runner.sh</code> 中分成了九个不同的函数来做，而其实这些都可以一次处理完，所以我会把结果存在临时文件里，然后用 bash 输出。</p>
<p>如果不想在命令行里编程，可以把文件弄到本地来进行编写，命令如下：</p>
<p>远程到本地 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo scp -i demo.pem ubuntu@ec2-<span class="number">54</span>-<span class="number">165</span>-<span class="number">218</span>-<span class="number">37</span>.compute-<span class="number">1</span>.amazonaws.com:~/Project1_1/SeqProg.java ./</span><br><span class="line"></span><br><span class="line">sudo scp -i demo.pem ubuntu@ec2-<span class="number">54</span>-<span class="number">165</span>-<span class="number">218</span>-<span class="number">37</span>.compute-<span class="number">1</span>.amazonaws.com:~/Project1_1/runner.sh ./</span><br></pre></td></tr></table></figure>
<p>本地到远程 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo scp -i demo.pem ./SeqProg.java ubuntu@ec2-<span class="number">54</span>-<span class="number">165</span>-<span class="number">218</span>-<span class="number">37</span>.compute-<span class="number">1</span>.amazonaws.com:~/Project1_1/</span><br><span class="line"></span><br><span class="line">sudo scp -i demo.pem ./runner.sh ubuntu@ec2-<span class="number">54</span>-<span class="number">165</span>-<span class="number">218</span>-<span class="number">37</span>.compute-<span class="number">1</span>.amazonaws.com:~/Project1_1/</span><br></pre></td></tr></table></figure>
<p>提交用：</p>
<p><code>./submitter -a dawang -l java</code></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>一定要认真看题</li>
<li>一定要认真看题</li>
<li>一定要认真看题</li>
<li>AWS 上有时候 java 表现会很奇怪，暂时未知</li>
</ol>
<p>本来打算两种语言都写一下的，但是因为踩了太多坑已经阵亡，最后就只用 Java 实现了（毕竟是会快一点）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一讲我们就要开始实际接触一个真实的项目——处理一个大文本数据集了。在云上编程和平时学习的可能有一些不同，这里会尽量写得详细一些。</p>]]>
    
    </summary>
    
      <category term="AWS" scheme="http://wdxtub.com/tags/AWS/"/>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="文本处理" scheme="http://wdxtub.com/tags/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
