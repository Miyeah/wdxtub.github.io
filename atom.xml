<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-01-22T23:26:35.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[编程起跑线 第 5 课 链表]]></title>
    <link href="http://wdxtub.com/2016/01/22/programmer-startline-5/"/>
    <id>http://wdxtub.com/2016/01/22/programmer-startline-5/</id>
    <published>2016-01-22T20:51:05.000Z</published>
    <updated>2016-01-22T23:26:35.000Z</updated>
    <content type="html"><![CDATA[<p>链表，作为在内存中非连续分配的数据结构，因为其灵活性往往容易出错，这里我们会通过深入理解来教大家一些解决链表问题的基本方法。</p>
<a id="more"></a>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>链表，作为在内存中非连续分配的数据结构，因为其灵活性往往容易出错，这里我们会通过深入理解来教大家一些解决链表问题的基本方法。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 4 课 栈和队列]]></title>
    <link href="http://wdxtub.com/2016/01/22/programmer-startline-4/"/>
    <id>http://wdxtub.com/2016/01/22/programmer-startline-4/</id>
    <published>2016-01-22T20:51:02.000Z</published>
    <updated>2016-01-22T23:25:15.000Z</updated>
    <content type="html"><![CDATA[<p>栈和队列，因为其特殊的性质，如果巧妙利用，可以解决许多原本比较复杂的问题，而且还是 BFS 和 DFS 的基础，这一讲我们就来看看对于栈和队列的相关知识。</p>
<a id="more"></a>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>栈和队列，因为其特殊的性质，如果巧妙利用，可以解决许多原本比较复杂的问题，而且还是 BFS 和 DFS 的基础，这一讲我们就来看看对于栈和队列的相关知识。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="栈" scheme="http://wdxtub.com/tags/%E6%A0%88/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="队列" scheme="http://wdxtub.com/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 3 课 数组和字符串]]></title>
    <link href="http://wdxtub.com/2016/01/22/programmer-startline-3/"/>
    <id>http://wdxtub.com/2016/01/22/programmer-startline-3/</id>
    <published>2016-01-22T20:50:55.000Z</published>
    <updated>2016-01-22T23:23:58.000Z</updated>
    <content type="html"><![CDATA[<p>数组和字符串作为最基本的元素，涉及的知识点非常多，许多高级的应用如堆，栈，队列，动态规划等都可以基于数组，这一讲我们主要还是集中在数组本身性质的习题上。</p>
<a id="more"></a>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>数组和字符串作为最基本的元素，涉及的知识点非常多，许多高级的应用如堆，栈，队列，动态规划等都可以基于数组，这一讲我们主要还是集中在数组本身性质的习题上。</p>]]>
    
    </summary>
    
      <category term="字符串" scheme="http://wdxtub.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="数组" scheme="http://wdxtub.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 2 课 Big O 分析]]></title>
    <link href="http://wdxtub.com/2016/01/22/programmer-startline-2/"/>
    <id>http://wdxtub.com/2016/01/22/programmer-startline-2/</id>
    <published>2016-01-22T20:50:51.000Z</published>
    <updated>2016-01-22T23:08:08.000Z</updated>
    <content type="html"><![CDATA[<p>前一讲大概了解了这个系列会涉及的内容，这一讲就从最重要的概念，Big O 开始讲起。既然我们要找到效率更高的算法，首先就得知道，怎么样才是高效率。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u672C_u6CD5_u5219"><a href="#u57FA_u672C_u6CD5_u5219" class="headerlink" title="基本法则"></a>基本法则</h2><p>我们先来了解一下程序分析的基本法则。一般来说，常见的输入输出以及简单的赋值语句，可以认为时间复杂度是 O(1)。在算复杂度的时候乘以一个常数复杂度不变，即 $O(Cf(n)) = O(f(n))$，其中C是一个正常数。</p>
<p>我们知道，程序设计中无非是三种形态：顺序，选择和循环，只要能够算清楚这三种形态的复杂度，那么整个算法的复杂度也就不在话下了。</p>
<p>先来看看顺序结构，因为是顺序执行，所以可以通过求和法则来进行计算。若算法的 2 个部分时间复杂度分别为 $T1(n)=O(f(n))$ 和 $T2(n)=O(g(n))$,则 $T1(n)+T2(n)=O(max(f(n), g(n)))$。如果这两个部分的参数不一样的话，即 $T1(m)=O(f(m))$ 和 $T2(n)=O(g(n))$,则 $T1(m)+T2(n)=O(f(m) + g(n))$</p>
<p>然后是选择结构，选择本身判断是耗费 O(1) 时间的，但是主要时间还是在执行不同的子句上，所以转换为分析子句的时间复杂度。</p>
<p>最后来看看循环结构，一般来说可能包括多次循环，所以使用乘法法则。若算法的2个部分时间复杂度分别为 $T1(n)=O(f(n))$ 和 $T2(n)=O(g(n))$,则 $T1 \times T2=O(f(n) \times g(n))$ 。</p>
<p>基本上理解了什么时候用求和法则，什么时候用乘法法则，再加上一点点运算，就可以推算出时间复杂度了。</p>
<h2 id="u9012_u5F52"><a href="#u9012_u5F52" class="headerlink" title="递归"></a>递归</h2><p>递归问题应该算是求复杂度问题中比较麻烦的了，并不像其他非递归的算法可以用上面提到的基本法则来进行分析。一般来说，遇到递归问题，有两种做法：</p>
<ol>
<li>主定理法</li>
<li>递归树法</li>
</ol>
<p>实际上主定理法可以看作是递归树法的一个总结，这里用一个例子来说明，假设我们的递归函数是：$T(n) = T(\frac{n}{3}) + T(\frac{2n}{3}) + n$，那么画出递归树就是：</p>
<p><img src="/images/14535025616030.jpg" alt=""></p>
<p>每层都会多出来一个 n，而从根到叶节点的最长路径是：$n \to \frac{2}{3}n \to (\frac{2}{3})^2n \to \dots \to 1$，假设一共有 k 层，因为 $(\frac{2}{3})^kn = 1$，所以  $k=log_{3/2}n$ ，也就是说  $T(n) \le \sum_{i=0}^k n = (k+1)n = n(log_{3/2}n+1 )$  ，即 $T(n) = O(nlog\;n)$</p>
<p>我们来看看用主定理方法的话，这个复杂度要怎么算。首先我们要把递推公式转换为如下形式：</p>
<p>$$f(n)=af(\frac{n}{b}) + d(n)$$</p>
<p>然后分情况进行讨论：</p>
<p><img src="/images/14535029849534.jpg" alt=""></p>
<p>而这题中 $T(n) = T(\frac{n}{3}) + T(\frac{2n}{3}) + n$，化简之后相当于 $a=3,b=3$，于是在第二种情况中找到 $a=b$ 的情况，就得到了最后的结果 $O(nlog\; n)$</p>
<h2 id="u4F8B_u9898"><a href="#u4F8B_u9898" class="headerlink" title="例题"></a>例题</h2><p>这里主要是提及一些容易出错的地方。</p>
<blockquote>
<p>不是出现了树结构，就一定会产生 log 的复杂度</p>
</blockquote>
<p>假设代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum(node.left) + node.value + sum(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为实际上是遍历所有的节点一次，于是复杂度是 O(n)</p>
<blockquote>
<p>有的时候可以通过这个代码的做用来进行复杂度判断</p>
</blockquote>
<p>来看看下面这两个代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 片段 1</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">2</span>; x * x &lt;= n; x++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % x == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permuation</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    permutation(str, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(String str, String prefix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">            String rem = str.substring(<span class="number">0</span>,i) + str.substring(i+<span class="number">1</span>);</span><br><span class="line">            permutation(rem, prefix + str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一题比较简单，因为是求质数，在 $\sqrt n$ 时间就可以完成，对应的时间复杂也就是出来了。</p>
<p>第二题做得是一个全排列，可以从两个思路：What It Means 和 What It Does。</p>
<ul>
<li>What It Means：因为是求排列，如果一个字符串有n个字符，那么所有的可能为 <code>n*(n-1)*...*2*1 -&gt; O(n!)</code></li>
<li>What It Does：设一共有 n 个字符，第一次循环，有 n 次递归调用，第二次有 n-1 次，到最后一共有 <code>n*(n-1)*...*2*1 -&gt; O(n!)</code></li>
</ul>
<p>最后再举一个递归的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里每一次递归，都会由原来的一个分成两个，而一共有 n 层，于是时间复杂度为 $O(2^N)$</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>当然，很多时候还需要具体问题具体分析，最关键的，是对算法过程的清晰理解和掌握，有了这个，哪怕从头开始一点一点分析，也可以推导出正确答案。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前一讲大概了解了这个系列会涉及的内容，这一讲就从最重要的概念，Big O 开始讲起。既然我们要找到效率更高的算法，首先就得知道，怎么样才是高效率。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第二周 - Welcome]]></title>
    <link href="http://wdxtub.com/2016/01/22/welcome/"/>
    <id>http://wdxtub.com/2016/01/22/welcome/</id>
    <published>2016-01-22T17:48:32.000Z</published>
    <updated>2016-01-22T20:35:00.000Z</updated>
    <content type="html"><![CDATA[<p>Ain’t no way to shut me down. Or to take the path I’ve taken.</p>
<a id="more"></a>
<hr>
<p>第二周算是完全进入了状态，各项工作都在有条不紊地推进中，去西雅图和三藩的行程确定了下来，准备加入一个 Swift 的翻译小组，甚至还申请当助教，加上之前所说的『微小的工作』，这个学期真的算是有史以来最火力全开的了。</p>
<p>按照以往的经验，这种高强度的工作通常持续不了太久，不过这周去吃了一次海鲜自助餐，算是大大满足了一番，真是无论如何，美酒美食，不能停止了供应。</p>
<p>很让自己高兴的一点是慢慢开始从更长远的角度去考虑问题和指定计划了。比方说，高中时候写日志大多是流水账，之后可能稍微有一些主题，但是比较零散，但是现在开始谋划一个大主题，然后分成不同的小主题，逐个写完，组合起来能发挥比以前单篇文章更大的效果。而一个个主题又是为了更大的目标而努力，这种垒积木居然还蛮有意思的。感觉像是散兵游勇终于凑到一起，训练了一两年，成了正规军了。</p>
<p>但是正规军也不是啥都好，少了些灵气，就我现在来说，还是更喜欢李云龙独立团那种血性，年轻人还是要敢打敢拼一点，可能欠缺些考虑甚至有点鲁莽，那也要比永远留在安全舒适区来得好。</p>
<p>想做的能做的事情还有很多，摩拳擦掌，蓄势待发。（因为本周末的寒潮+大雪，估计只能在家多发文章了，哈哈）</p>
<p>And maybe I’ve been left out. Never let this be mistaken.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Ain’t no way to shut me down. Or to take the path I’ve taken.</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="改变" scheme="http://wdxtub.com/tags/%E6%94%B9%E5%8F%98/"/>
    
      <category term="面试" scheme="http://wdxtub.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程起跑线 第 1 课 总览]]></title>
    <link href="http://wdxtub.com/2016/01/22/programmer-startline-1/"/>
    <id>http://wdxtub.com/2016/01/22/programmer-startline-1/</id>
    <published>2016-01-22T14:35:39.000Z</published>
    <updated>2016-01-22T20:49:30.000Z</updated>
    <content type="html"><![CDATA[<p>学了这么多年计算机和编程，在快要步入社会之前，在不断地碰壁和尝试之后，终于摸到了一点门路。这个系列的文章，更接近于编程入门指南，讲的是从数据结构到算法最终到解决问题的方法和思路。</p>
<a id="more"></a>
<hr>
<p>我想，对于大多数经历过或者正在经历从校园转入社会的人来说，找工作本身就是一个很好的学习过程。如果想要成为一个程序员，尤其是在北美的话，那么刷题（也就是做各种数据结构算法的题目）就是必不可少的了，颇有应试教育的味道。</p>
<p>学习并不是为了考试，可是分数是简单粗暴评判学习效果的方法；编程并不是为了刷题，可是能否给出解答是简单粗暴评判编程水平的方法。虽然不合理不科学，但是在人力物力有限的条件下，这就是游戏规则。</p>
<p>在这个过程中，你会发现，聪明人，或者说善于学习的人，很快就会从应试模式转变为探索模式。题目背后是知识，不同的知识点交织成为学科，死记硬背只能解决见过的问题，但是如果在这个过程中培养了逻辑推理的能力，哪怕遇到一个『新』问题，也能通过类比，找到用『旧』方法稍微变化就可以解决的途径。</p>
<p>如果了解了计算机发展的历史，就会发现，所有现在看起来非常复杂的东西，都是建立在非常简单的基础——零和一——之上的。从最简单的基本类型，到数据结构和算法，通通都是为了解决实际问题而产生的高效解决方案。的确，无论是计算机科学，还是编程，都是非常大的话题，但是并不意味着起跑会很难。在我看来，需要了解的内容，大概有下面这几类（这里参考了 Google 面试指南的部分内容）：</p>
<ol>
<li>掌握一门基本的编程语言。最好是强类型，支持面向对象编程（比如 C++/Java/C#）的语言。这里说的掌握，不仅仅是语法，而是对语言本身的一些设计特点和具体实现方式的理解。</li>
<li>能够以 Big O 的方式去分析一个算法的时间/空间复杂度，这样才有一个标准的方式去分析算法的效率。</li>
<li>基本数据结构的理解和使用，比如<ul>
<li>哈希表 Hashtable，及其背后所代表的哈希的思想是如何应用的不同问题的，如果只能用数组来实现，要如何实现</li>
<li>树 Tree，    树的构建(trie)，遍历和修改。遍历包括 BFS 和 DFS（前序中序后序），及其对应的思想。如果了解至少一种平衡树（及实现方式）就更好了。</li>
<li>图 Graph，图的三种表达方式及优缺点，基本的遍历算法（还是 BFS 和 DFS），知道这些算法的复杂度以及权衡利弊。如果了解一些如 Dijkstra 和 A* 算法就更好了。</li>
<li>其他的数据结构：堆栈队列链表</li>
</ul>
</li>
<li>基本算法的理解和使用，比如排序和搜索，以及递归和动态规划。nlogn 时间的排序，logn 时间的搜索。以及了解什么是 NP 问题（旅行商等等）。</li>
<li>基本的数学知识，排列组合及概率，和一些公式化简。这里可能还可以算上正则表达式。</li>
<li>操作系统，编译器，及计算机系统的基本知识。比如说进程线程，互斥锁信号量，死锁出现的条件及如何避免，进程线程的资源和上下文切换，多核处理的相关知识。重要的是对计算机相关工具的理解，除了上面提到的，还有 shell 之类的用法。</li>
<li>基本的设计能力。面向对象设计，代码风格及优化。</li>
<li>如何清晰表达自己的想法，去快速构建一个问题的解决方案。</li>
</ol>
<p>还是那句话，刷题仅仅只是一个效率很低的练习过程，真正的学习是进行『刻意练习』，也是我这个系列文章中想要强调的内容。</p>
<p>一通百通，悟道之后就会发现，一招一式固然重要，但那些都是基础，更重要的是解决问题的方法和思路，这，可能就需要多动一点脑子了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>学了这么多年计算机和编程，在快要步入社会之前，在不断地碰壁和尝试之后，终于摸到了一点门路。这个系列的文章，更接近于编程入门指南，讲的是从数据结构到算法最终到解决问题的方法和思路。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="技能" scheme="http://wdxtub.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 9 课 Machine Advanced]]></title>
    <link href="http://wdxtub.com/2016/01/21/csapp-9/"/>
    <id>http://wdxtub.com/2016/01/21/csapp-9/</id>
    <published>2016-01-22T00:16:21.000Z</published>
    <updated>2016-01-22T20:35:42.000Z</updated>
    <content type="html"><![CDATA[<p>这一讲是机器代码的最后一部分，会介绍一些『高级』话题，比如程序在内存中的组织，缓冲区溢出引起的攻防大战，以及 Union 的具体实现方式。</p>
<a id="more"></a>
<hr>
<p>我们先来看看程序在内存中是如何组织的（x86-64 Linux）：</p>
<p><img src="/images/14534337498107.jpg" alt=""></p>
<p>最上面是运行时栈，有 8MB 的大小限制，一般用来保存局部变量。然后是堆，动态的内存分配会在这里处理，例如 <code>malloc()</code>, <code>calloc()</code>, <code>new()</code> 等。然后是数据，指的是静态分配的数据，比如说全局变量，静态变量，常量字符串。最后是共享库等可执行的机器指令，这一部分是只读的。</p>
<p>看个具体分配的例子：</p>
<p><img src="/images/14534340388277.jpg" alt=""></p>
<p>经过观察大概是这样的：</p>
<p><img src="/images/14534340592122.jpg" alt=""></p>
<p>这里注意一点，分配堆的时候是两头分配的，到中间相遇的时候就说明没有空间了，具体是怎么在两头分配的呢？老师也表示不知道。</p>
<h2 id="Buffer_Overflow"><a href="#Buffer_Overflow" class="headerlink" title="Buffer Overflow"></a>Buffer Overflow</h2><p>缓冲区溢出需要注意两个方面，一是为什么会产生这种情况，二是在黑客利用这种漏洞来进行攻击时，能够怎么防范。</p>
<p>先看看之前提到过的例子：</p>
<p><img src="/images/14534345803640.jpg" alt=""></p>
<p>之所以会产生这种错误，是因为访问内存的时候跨过了数组本身的界限修改了 d 的值：</p>
<p><img src="/images/14534346212614.jpg" alt=""></p>
<p>你没看错，这是个大问题！#1 technical cause of security vulnerabilities! #1 overall cause is social enginnering / user ignorance!</p>
<p>如果不检查输入字符串的长度，就很容易出现这种问题，尤其是针对在栈上有界限的字符数组。</p>
<p>在 Unix 中，<code>gets()</code> 函数的实现是这样的：</p>
<p><img src="/images/14534348853894.jpg" alt=""></p>
<p>可以看到并没有去检测最多能读入多少字符（于是很容易出问题），类似的情况还在 <code>strcpy</code>, <code>strcat</code>, <code>scanf</code>, <code>fscanf</code>, <code>sscanf</code> 中出现。比如说</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">4</span>]; <span class="comment">// 太小</span></span><br><span class="line">	gets(buf);</span><br><span class="line">	<span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_echo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	echo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们输入一长串，可以看到：</p>
<p><img src="/images/14534352714657.jpg" alt=""></p>
<p>为什么命名只给了 4 个 char，居然一开始输入这么多都没问题？我们到汇编代码里去看看：</p>
<p><img src="/images/14534354107024.jpg" alt=""></p>
<p>可以看到实际上是给 %rsp 分配了 0x18 的空间的。</p>
<p><img src="/images/14534362980014.jpg" alt=""></p>
<p>在调用之前，可以看到内存的摆放是这样的，但是调用了 <code>call_echo</code> 之后，就变成：</p>
<p><img src="/images/14534363898271.jpg" alt=""></p>
<p>虽然缓冲区溢出了，但是并没有损害当前的状态，程序还是可以继续运行（也就是没有出现段错误），但是如果再多一点的话：</p>
<p><img src="/images/14534366083059.jpg" alt=""></p>
<p>就把返回地址给覆盖掉了，但是段错误之后发现还可以继续运行，是因为返回代码会返回到 <code>main</code> 中，和具体的地址无关：</p>
<p><img src="/images/14534367016302.jpg" alt=""></p>
<p>在这个例子中没有问题，但是在下面的例子中，就会出问题了</p>
<p><img src="/images/14534367347277.jpg" alt=""></p>
<p>原本函数 P 的返回地址是 A，但是因为 Buffer 一直在被写，直接改到了 P 的栈帧，那么之后跳转就会跳转到奇怪的地方了。</p>
<p>那么我们现在来看看，怎么处理缓冲区溢出攻击，有几种方式：</p>
<ol>
<li>好好写代码，尽量不让缓冲区异常</li>
<li>程序容易出问题，那么提供系统层级的保护</li>
<li>编译器也可以来个认证(stack canaries)</li>
</ol>
<p>第一种，避免缓冲区溢出，我们用更安全的方法，如：<code>fgets</code>, <code>strncpy</code> 等等。</p>
<p>第二种，栈的位置不确定，让缓冲区溢出没办法影响到，并且每次位置都不一样，就不怕被暴力破解：</p>
<p><img src="/images/14534373336480.jpg" alt=""></p>
<p>并且也可以把一段内存标记为只读，那么就避免因为缓冲区溢出而导致的重写。</p>
<p>第三种，使用 Stack Canaries。简单来说，就是在超出缓冲区的位置加一个特殊的值，如果发现这个值变化了，那么就知道出问题了。</p>
<p>但是，除了缓冲区溢出，还有另一种攻击的方式，就是把返回的位置给改了。可以利用修改已有的代码，来绕过系统和编译器的保护机制。这里就不详细展开了。</p>
<h2 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h2><p>和结构体对应的一种结构，但是其实我在编程的时候感觉不是非常常见，这里简单了解下实现原理：</p>
<p><img src="/images/14534375732251.jpg" alt=""></p>
<p>具体的拜访可以是：</p>
<p><img src="/images/14534376064591.jpg" alt=""></p>
<p>下面是三种不同系统上的排布：</p>
<p><img src="/images/14534376440995.jpg" alt=""></p>
<p><img src="/images/14534376568110.jpg" alt=""></p>
<p><img src="/images/14534376658164.jpg" alt=""></p>
<p>这一讲的内容就到这里，下一讲是非常有趣的关于如何优化代码的内容，我自己都很期待。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一讲是机器代码的最后一部分，会介绍一些『高级』话题，比如程序在内存中的组织，缓冲区溢出引起的攻防大战，以及 Union 的具体实现方式。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 8 课 Machine Data]]></title>
    <link href="http://wdxtub.com/2016/01/21/csapp-8/"/>
    <id>http://wdxtub.com/2016/01/21/csapp-8/</id>
    <published>2016-01-21T16:16:14.000Z</published>
    <updated>2016-01-22T20:35:47.000Z</updated>
    <content type="html"><![CDATA[<p>上一讲我们了解了过程调用是如何用机器代码实现的，这一讲我们来看看基本的数据是如何存储在计算机中的。</p>
<a id="more"></a>
<hr>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>数组其实就是连续分配的地址空间，比如说 <code>T A[L]</code>，意思就是类型 T 且长度为 L 的数组，需要分配 <code>L*sizeof(T)</code> 个字节的空间。</p>
<p><img src="/images/14534188845612.jpg" alt=""></p>
<p>既然是连续的地址空间，就有很多不同的访问方式，举个例子：</p>
<p><img src="/images/14534189454190.jpg" alt=""></p>
<p>那么对应的一些访问方式为：</p>
<p><img src="/images/14534189637879.jpg" alt=""></p>
<p>再举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> ZLEN <span class="number">5</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> zip_dig[ZLEN];</span><br><span class="line"></span><br><span class="line">zip_dig cmu = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/14534198336930.jpg" alt=""></p>
<p>假设我们要取数组中的某一位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_digit</span><span class="params">(zip_dig z, <span class="keyword">int</span> digit)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> z[digit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码是：</p>
<p><img src="/images/14534198966151.jpg" alt=""></p>
<p>这里寄存器 %rdi 中存着数组的起始地址，寄存器 %rsi 存着序号，我们要访问的地址等价于 <code>%rdi + 4*%rsi</code>，用内存引用的方式就是 <code>(%rdi, %rsi, 4)</code>。</p>
<p>再看一个数组循环的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zincr</span><span class="params">(zip_dig z)</span></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ZLEN; i++)</span><br><span class="line">		z[i]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编是，注意红字的部分，相当于等价实现了 <code>++</code> 操作</p>
<p><img src="/images/14534201884816.jpg" alt=""></p>
<p>对于多维的数组，基本形式是 <code>T A[R][C]</code>，R 是行，C 是列，如果类型 T 占 K 个字节的话，那么数组所需要的内存是 <code>R*C*K</code> 字节。具体在内存里的排列方式如下：</p>
<p><img src="/images/14534202945733.jpg" alt=""></p>
<p>多维数组的第一维可以看作是每行起始的地址：</p>
<p><img src="/images/14534203418848.jpg" alt=""></p>
<p>因为如此，所以访问可以是这样的：</p>
<p><img src="/images/14534205890785.jpg" alt=""></p>
<p>这里 <code>pgh[index][dig]</code> 是 int 类型。地址 <code>pgh + 20*index + 4*dig = pgh + 4*(5*index + dig)</code>。</p>
<p>还有另外一种组合数组的方式，不是连续分配，而是存储每个数组的起始地址，例如：</p>
<p><img src="/images/14534208481488.jpg" alt=""></p>
<p><img src="/images/14534208616228.jpg" alt=""></p>
<p>获取具体某个元素的地址其实就是计算时的起始地址有变换，对应的代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_univ_digit</span><span class="params">(size_t index, size_t digit)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> univ[index][digit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编为：</p>
<p><img src="/images/14534209862505.jpg" alt=""></p>
<p>这里等同于进行两次内存访问 <code>Mem[Mem[univ+8*index]+4*digit]</code>，</p>
<p>对比一下</p>
<p><img src="/images/14534218752318.jpg" alt=""></p>
<p>在 C 语言中看起来差不多，但是实际上差别很大：</p>
<p><code>Mem[pgh+20*index+4*digit]</code> vs <code>Mem[Mem[univ+8*index]+4*digit]</code></p>
<h2 id="Structures"><a href="#Structures" class="headerlink" title="Structures"></a>Structures</h2><p>结构体是如何表示的呢，大概是这样：</p>
<p><img src="/images/14534222886026.jpg" alt=""></p>
<p>这里我们发现刚好都是 4 的倍数，如果换一种方式来组合，会是怎么样的呢？会像下图这样吗？</p>
<p><img src="/images/14534225034162.jpg" alt=""></p>
<p>答案是，并不会，会在内存中进行对齐：</p>
<p><img src="/images/14534225338581.jpg" alt=""></p>
<p>具体对齐的原则是，如果 primitive data type 需要 K 个字节，那么地址都必须是 K 的倍数。为什么要这样呢，因为内存访问通常来说是 4 或者 8 个字节位单位的，不对齐的话访问起来效率不高。具体来看的话，是这样：</p>
<ul>
<li>1 字节：char, …<ul>
<li>没有地址的限制</li>
</ul>
</li>
<li>2 字节：short, …<ul>
<li>地址最低的 1 比特必须是 $0_2$</li>
</ul>
</li>
<li>4 字节：int, float, …<ul>
<li>地址最低的 2 比特必须是 $00_2$</li>
</ul>
</li>
<li>8 字节：double, long, char *, …<ul>
<li>地址最低的 3 比特必须是 $000_2$</li>
</ul>
</li>
<li>16 字节：long double (GCC on Linux)<ul>
<li>地址最低的 4 比特必须是 $0000_2$</li>
</ul>
</li>
</ul>
<p>对于一个结构体来说，所占据的内存空间必须是最大的类型所需字节的倍数，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> S2 &#123;</span><br><span class="line">	<span class="keyword">double</span> v;</span><br><span class="line">	<span class="keyword">int</span> i[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure>
<p><img src="/images/14534232756482.jpg" alt=""></p>
<p>如果是结构体数组的话，那就是像这样：</p>
<p><img src="/images/14534233087461.jpg" alt=""></p>
<p>具体到访问结构体中的例子，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> S3 &#123;</span><br><span class="line">	<span class="keyword">short</span> i;</span><br><span class="line">	<span class="keyword">float</span> v;</span><br><span class="line">	<span class="keyword">short</span> j;</span><br><span class="line">&#125; a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p><img src="/images/14534233625482.jpg" alt=""></p>
<p>那么根据这种特点，就有一些技巧了。例如，要把大的数据类型放到前面，看这个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> S4 &#123;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> d;</span><br><span class="line">&#125; *p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> S5 &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">char</span> d;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure>
<p>那么这两种的对应排列就是：</p>
<p><img src="/images/14534240460958.jpg" alt=""></p>
<p>可以看到，下面那种省了 4 个字节。</p>
<h2 id="Floating_Point"><a href="#Floating_Point" class="headerlink" title="Floating Point"></a>Floating Point</h2><p>浮点数的部分在课上介绍的不是很多，这里简要介绍一下。</p>
<p>最开始是 x87 FP（比较丑陋），之后是 SSE FP（利用了向量指令），然后是 AVX FP（类似与 SSE）。</p>
<p>SSE3 对于 XMM 寄存器一共有 16 个，每个 16 字节：</p>
<p><img src="/images/14534252071793.jpg" alt=""></p>
<p>下面是对标量和 SIMD 操作的描述：</p>
<p><img src="/images/14534254596599.jpg" alt=""></p>
<p>具体的机制也是类似的，传入的参数存储在 %xmm0, %xmm1，返回参数在 %xmm0，所有的 XMM 寄存器都会被保存在调用者的栈帧中：</p>
<p><img src="/images/14534255846801.jpg" alt=""></p>
<p>这一讲到此结束，之后会进入更深入的话题（因为作业大概两到三周一次，所以可能先把重点放在概念的理解上）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一讲我们了解了过程调用是如何用机器代码实现的，这一讲我们来看看基本的数据是如何存储在计算机中的。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 7 课 Machine Procedures]]></title>
    <link href="http://wdxtub.com/2016/01/21/csapp-7/"/>
    <id>http://wdxtub.com/2016/01/21/csapp-7/</id>
    <published>2016-01-21T16:15:37.000Z</published>
    <updated>2016-01-22T20:35:51.000Z</updated>
    <content type="html"><![CDATA[<p>之前我们学习了机器是如何利用跳转实现流程控制的，这一讲我们来看一个更加复杂的机制：过程调用（也就是调用函数）具体在 CPU 和内存中是怎么实现了。理解之后，对于递归会有更加清晰的认识。</p>
<a id="more"></a>
<hr>
<p>在过程调用中主要涉及三个重要的方面：</p>
<ol>
<li>传递控制：包括如何开始执行过程代码，以及如何返回到开始的地方</li>
<li>传递数据：包括过程需要的参数以及过程的返回值</li>
<li>内存管理：如何在过程执行的时候分配内存，以及在返回之后释放内存</li>
</ol>
<p>以上这三点，都是凭借机器指令实现的</p>
<h2 id="Stack_Structure"><a href="#Stack_Structure" class="headerlink" title="Stack Structure"></a>Stack Structure</h2><p>在 x86-64 中，所谓的栈，实际上一块内存区域，这个区域的数据进出满足先进后出的原则。越新入栈的数据，地址越低，所以栈顶的地址是最小的。下图中箭头所指的就是寄存器 %rsp 的值，这个寄存器是栈指针，用来记录栈顶的位置。</p>
<p><img src="/images/14533820160341.jpg" alt=""></p>
<p>对于 <code>push</code> 操作，对应的是 <code>pushq Src</code> 指令，具体会完成下面三个步骤：</p>
<ol>
<li>从地址 <code>Src</code> 中取出操作数</li>
<li>把 %rsp 中的地址减去 8（也就是到下一个位置）</li>
<li>把操作数写入到 %rsp 的新地址中 </li>
</ol>
<p>如下图所示：</p>
<p><img src="/images/14533823825128.jpg" alt=""></p>
<p>对于 <code>pop</code> 操作，对应的是 <code>popq Dest</code> 指令，具体会完成下面三个步骤：</p>
<ol>
<li>从 %rsp 中存储的地址中读入数据</li>
<li>把 %rsp 中的地址增加 8（回到上一个位置）</li>
<li>把刚才取出来的值放到 <code>Dest</code> 中（这里必须是一个寄存器）</li>
</ol>
<p>如下图所示：</p>
<p><img src="/images/14533826092815.jpg" alt=""></p>
<h2 id="Calling_Conventions"><a href="#Calling_Conventions" class="headerlink" title="Calling Conventions"></a>Calling Conventions</h2><p>了解了栈的结构之后，我们先通过一个函数调用的例子，来感受一下（代码中有详细注释，请理解后再继续）：</p>
<p><img src="/images/14533827066202.jpg" alt=""></p>
<p>可以看到，过程调用是利用栈来进行的，通过 <code>call label</code> 来进行调用（先把返回地址入栈，然后跳转到对应的 label），返回的地址，将是下一条指令的地址，通过 <code>ret</code> 来进行返回（把地址从栈中弹出，然后跳转到对应地址）</p>
<p>用上面的代码来做说明：</p>
<p><img src="/images/14533831060878.jpg" alt=""></p>
<p>在执行到 400544 那一行的时候 %rsp 指向栈顶（存储着栈顶的地址），%rip 指向当前要执行的指令（也就是 400544）</p>
<p><img src="/images/14533832007622.jpg" alt=""></p>
<p>在上一步操作完成之后，因为跳转的关系，%rip 指向 mult2 函数开始的地方（也就是 400550），之前的压栈操作也使得栈顶改变（返回值的位置），于是 %rsp 对应进行改变。</p>
<p><img src="/images/14533833724077.jpg" alt=""></p>
<p>接着执行到了 <code>retq</code> 那句，这个时候要做的就是从栈中取出栈顶位置（这样就可以从跳转处继续了），然后对寄存器做对应的修改，最后得到下图：</p>
<p><img src="/images/14533834735407.jpg" alt=""></p>
<p>具体的传值我们可以发现，是利用 %rax 来保存过程调用的返回值，以便程序继续运行的。这就是基本的过程调用的控制流程。</p>
<p>那么过程调用的参数会放在哪里呢？</p>
<p>如果参数没有超过六个，那么会放在：%rdi, %rsi, %rdx, %rcx, %r8, %r9 中。如果超过了，会另外放在一个栈中。而返回值会放在 %rax 中。</p>
<p>还是刚才的例子，看看数据的存放：</p>
<p><img src="/images/14533838086805.jpg" alt=""></p>
<p>既然是利用栈来进行函数调用，自然而然就可以推广到递归的情况，而对于每个过程调用来说，都会在栈中分配一个帧 Frames。每一帧里需要包含：</p>
<ul>
<li>返回信息</li>
<li>本地存储（如果需要）</li>
<li>临时空间（如果需要）</li>
</ul>
<p>整一帧会在过程调用的时候进行空间分配，然后在返回时进行回收，如下图所示（箭头所指位栈顶）：</p>
<p><img src="/images/14533842524928.jpg" alt=""></p>
<p>这里是一个调用的例子：</p>
<p><img src="/images/14533843491372.jpg" alt=""></p>
<p>在 x86-64/Linux 中，栈帧的结构是固定的，当前的要执行的栈中包括：</p>
<ul>
<li>Argument Build: 需要使用的参数</li>
<li>如果不能保存在寄存器中，会把一些本地变量放在这里</li>
<li>已保存的寄存器上下文</li>
<li>老的栈帧的指针（可选）</li>
</ul>
<p>而调用者的栈帧则包括：</p>
<ul>
<li>返回地址（因为 <code>call</code> 指令被压入栈的）</li>
<li>调用所需的参数</li>
</ul>
<p>具体如下图所示：</p>
<p><img src="/images/14533846615880.jpg" alt=""></p>
<p>下面用一个程序来说明一下，就比较清晰了：</p>
<p><img src="/images/14533847155070.jpg" alt=""></p>
<p>在函数调用前，需要移动 %rsp 指针存入调用者的变量压入栈中</p>
<p><img src="/images/14533848182706.jpg" alt=""></p>
<p>具体调用的时候，会根据返回值对应修改地址和数据。</p>
<p>寄存器保存数值的时候也有一些习惯的用法，这里也举个例子说明：</p>
<p><img src="/images/14533849340898.jpg" alt=""></p>
<p>这里的 <code>yoo</code> 被称为调用者 caller，<code>who</code> 被称为被调用者 callee。于是就有一个问题，能不能用寄存器（这里是 %rdx）来保存临时变量呢？</p>
<p>似乎不大可以，因为在两个函数中都进行了修改，所以在这之前需要做一些额外的操作。对于调用者来说，需要把临时变量保存在栈帧中，然后进行调用；对于被调用者来说，可以在栈帧中保存临时变量，但是在返回的时候需要恢复成原来的样子（让调用者继续工作）</p>
<p>一般来说用法是这样的：</p>
<p><img src="/images/14533857001617.jpg" alt=""></p>
<p>这里的变量都会被保存到 caller 的栈帧中（因为可能之后会被修改）</p>
<p><img src="/images/14533857595809.jpg" alt=""></p>
<p>除了 %rsp 外，这里都会保存在 callee 的栈帧中，并且在调用完成之后需要恢复成原来的数值。</p>
<h2 id="u9012_u5F52_u7684_u63CF_u8FF0"><a href="#u9012_u5F52_u7684_u63CF_u8FF0" class="headerlink" title="递归的描述"></a>递归的描述</h2><p>有了前面的的基础，要理解递归就简单很多了，直接上例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pcount_r</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> (x &amp; <span class="number">1</span>) + pcount_r(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码为：</p>
<p><img src="/images/14533859204097.jpg" alt=""></p>
<p>实际执行的过程中，会不停进行压栈，知道最后返回，所以递归本身就是一个隐式的栈实现，但是系统一般对于栈的深度有限制（每次一都需要保存当前栈帧的各种数据），所以一般来说会把递归转换成显式栈来进行处理以防溢出。</p>
<p>这一讲的内容就这么多，需要好好理解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前我们学习了机器是如何利用跳转实现流程控制的，这一讲我们来看一个更加复杂的机制：过程调用（也就是调用函数）具体在 CPU 和内存中是怎么实现了。理解之后，对于递归会有更加清晰的认识。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 第 9 课 Sequential Programming]]></title>
    <link href="http://wdxtub.com/2016/01/20/cc-9/"/>
    <id>http://wdxtub.com/2016/01/20/cc-9/</id>
    <published>2016-01-20T20:05:54.000Z</published>
    <updated>2016-01-22T20:35:15.000Z</updated>
    <content type="html"><![CDATA[<p>这一讲我们就要开始实际接触一个真实的项目——处理一个大文本数据集了。在云上编程和平时学习的可能有一些不同，这里会尽量写得详细一些。</p>
<a id="more"></a>
<hr>
<p>先来具体说说这节课的任务：</p>
<ol>
<li>用顺序执行的程序在云上处理一个大文本数据集。</li>
<li>在这个过程中了解顺序方法的限制</li>
</ol>
<p>这次我们会在特定的 AMI(可以理解为系统镜像)上进行操作，注意不能用外部依赖（也就是不能 <code>sudo apt-get install</code> 任何软件或库，即使装了在测试的时候也没办法运行）</p>
<p>数据集来自维基的<a href="http://dumps.wikimedia.org/other/pagecounts-raw/" target="_blank" rel="external">页面访问统计数据 hourly page view statistics</a></p>
<h2 id="u5173_u4E8E_u6570_u636E_u96C6"><a href="#u5173_u4E8E_u6570_u636E_u96C6" class="headerlink" title="关于数据集"></a>关于数据集</h2><p><code>Wikimedia</code> 会维护所有保存在服务器的对象的每小时页面访问数据并以开放数据集的形式给大家使用。我们会使用这些数据来分析一定时间内页面浏览的趋势。</p>
<p><img src="/images/14532371430507.jpg" alt=""><br>A simplified diagram of a page access form Wikimedia. <a href="http://en.wikipedia.org/wiki/Wikimedia_Foundation#Hardware" target="_blank" rel="external">More information</a></p>
<p>每个对于维基服务器的请求会被当做一个 <a href="http://en.wikipedia.org/wiki/Squid_%28software%29" target="_blank" rel="external">squid cache proxy</a> 来进行处理，同时也会把这些请求记录到日志中。这些日志每个小时更新，大家都可以访问。文件里的每一行对应着一次访问记录，格式如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[项目名称] [页面标题] [访问次数] [总共返回的字节数]</span><br></pre></td></tr></table></figure>
<p><code>[项目名称]</code>包括两个部分，一个是语言标识符和一个子项目后缀，具体如下：</p>
<ul>
<li><code>(no suffix)</code> : wikipedia</li>
<li><code>.b</code> : wikibooks</li>
<li><code>.d</code> : wiktionary</li>
<li><code>.m</code> : wikimedia</li>
<li><code>.mw</code> : wikipedia mobile</li>
<li><code>.n</code> : wikinews</li>
<li><code>.q</code> : wikiquote</li>
<li><code>.s</code> : wikisource</li>
<li><code>.v</code> : wikiversity</li>
<li><code>.w</code> : mediawiki</li>
</ul>
<p>举个例子，假设有一行是这样的：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fr.b <span class="constant">Special</span><span class="symbol">:Recherche/All_Mixed_Up</span> <span class="number">1</span> <span class="number">730</span></span><br></pre></td></tr></table></figure>
<p>就说明这条记录的产生是因为有人访问了 <code>French Wikibooks</code> 中的 <code>Special:Recherche/All_Mixed_Up</code> 页面 1 次，并且总共传输了 730 个字节。</p>
<p>这个项目中，我们主要会分析 2015 年 12 月的数据。不过现在我们只需要处理 12 月 1 日的第一个小时的数据。数据在 <code>s3://cmucc-datasets/wikipediatraf/201512/pagecounts-20151201-000000.gz</code>。可以使用 <code>aws-cli</code>, <code>s3cmd</code> 或者 S3 查看器来了解。但是在服务器上，就需要用 <code>wget</code> 来下载了，具体的地址是 <a href="https://cmucc-datasets.s3.amazonaws.com/wikipediatraf/201512/pagecounts-20151201-000000.gz" target="_blank" rel="external">https://cmucc-datasets.s3.amazonaws.com/wikipediatraf/201512/pagecounts-20151201-000000.gz</a></p>
<p>命令为 <code>wget https://cmucc-datasets.s3.amazonaws.com/wikipediatraf/201512/pagecounts-20151201-000000.gz</code></p>
<p>如果不是很了解如何访问 Amazon S3，可以回头看看<a href="http://wdxtub.com/2016/01/15/cc-2/">云计算 第 2 课 AWS 简介</a></p>
<h2 id="Data_Filtering"><a href="#Data_Filtering" class="headerlink" title="Data Filtering"></a>Data Filtering</h2><p>简单来说，我们要从维基的访问数据中，用各类数据分析的方法，看看能不能找到些什么有意思的东西。</p>
<p>我们会先从第一个小时的维基流量日志开始分析，主要关注英文维基的内容。这种从完整数据的一个子集开始测试起并最终应用到全部数据的方法，在之后的项目中会很有用。</p>
<p>我们先使用 <code>ami-95e9cdff</code>（社区 AMI 中）来创建一个 <code>t1.micro</code> 实例，记得在右上角把地区切换为 <code>弗吉尼亚北部</code>。允许 SSH 和 HTTP 连接（可以使用之前的安全组）。像下面这样：</p>
<p><img src="/images/14533207601658.jpg" alt=""></p>
<p>这里我选择的是竞价型实例（因为会便宜一点），但需要注意的是申请成功之后一定要注意重新打上标签：<code>{&quot;Key&quot;:&quot;Project&quot;,&quot;Value&quot;:&quot;1.1&quot;}</code>。</p>
<p>然后我们耐心等待实例创建，然后使用 <code>ssh -i demo.pem ubuntu@ec2-54-165-218-37.compute-1.amazonaws.com</code> 来进行连接，如下图：</p>
<p><img src="/images/14533217554276.jpg" alt=""></p>
<p>然后进入 <code>Project1_1</code> 文件夹，先把第一个小时的日志文件下载下来，命令为：<code>wget https://cmucc-datasets.s3.amazonaws.com/wikipediatraf/201512/pagecounts-20151201-000000.gz</code></p>
<p>下载速度还是很快的(20MB/s)，然后是一些注意事项：</p>
<p><strong>需要过滤的内容 1</strong></p>
<p>有些行只有 3 个（或更少）元素，需要过滤掉，如 </p>
<p><code>en 1282 10636194</code></p>
<p><strong>需要过滤的内容 2</strong></p>
<p>那些不是来自英文维基的页面访问需要过滤掉，也就是说，如果某一行不是以 <code>en</code> 开始的（大小写敏感），就需要过滤</p>
<p><strong>需要过滤的内容 3</strong></p>
<p>维基的特殊页面在这里不需要考虑，排除那些以如下字段开始的标题（大小写敏感）：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">Media:</span></span><br><span class="line"><span class="label">Special:</span></span><br><span class="line"><span class="label">Talk:</span></span><br><span class="line"><span class="label">User:</span></span><br><span class="line"><span class="label">User_talk:</span></span><br><span class="line"><span class="label">Project:</span></span><br><span class="line"><span class="label">Project_talk:</span></span><br><span class="line"><span class="label">File:</span></span><br><span class="line"><span class="label">File_talk:</span></span><br><span class="line"><span class="label">MediaWiki:</span></span><br><span class="line"><span class="label">MediaWiki_talk:</span></span><br><span class="line"><span class="label">Template:</span></span><br><span class="line"><span class="label">Template_talk:</span></span><br><span class="line"><span class="label">Help:</span></span><br><span class="line"><span class="label">Help_talk:</span></span><br><span class="line"><span class="label">Category:</span></span><br><span class="line"><span class="label">Category_talk:</span></span><br><span class="line"><span class="label">Portal:</span></span><br><span class="line"><span class="label">Wikipedia:</span></span><br><span class="line"><span class="label">Wikipedia_talk:</span></span><br></pre></td></tr></table></figure>
<p><strong>需要过滤的内容 4</strong></p>
<p>维基的政策规定所有的英文文章都必须以大写字母开头，过滤掉那些以小写字母开头的访问记录。注意，有些页面的标题是非英文字符，应该保留。</p>
<p><strong>需要过滤的内容 5</strong></p>
<p>还有一些记录是引用图片文件的，同样需要过滤掉标题以下列扩展名结尾的记录</p>
<p><code>.jpg, .gif, .png, .JPG, .GIF, .PNG, .txt, .ico</code></p>
<p><strong>需要过滤的内容 6</strong></p>
<p>还有一些无关的页面记录需要移除，如果页面标题是如下内容（大小写敏感），需要过滤掉：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">404</span>_error/</span><br><span class="line">Main_Page</span><br><span class="line">Hypertext_Transfer_Protocol</span><br><span class="line">Search</span><br></pre></td></tr></table></figure>
<p>这些都完成之后，把剩余的记录用下面的格式输出：</p>
<p><code>[page title]\t[number of accesses]</code></p>
<p>注意：</p>
<ul>
<li>你可能会发现语言包括 <code>en</code>, <code>EN</code> 和 <code>EN</code>，只对 <code>en</code> 的部分进行处理</li>
<li>输出应该根据访问次数降序排列</li>
</ul>
<p>接下来会用几种不同的方式来完成，我们先解压文件 <code>gzip -d pagecounts-20151201-000000.gz</code></p>
<h3 id="awk__u7248_u672C"><a href="#awk__u7248_u672C" class="headerlink" title="awk 版本"></a>awk 版本</h3><p>因为第一步只是做简单的文字处理，所以用命令行自带的 awk 应用就可以完成。awk 的用法这里不详细介绍，在 <code>runner.sh</code> 中的 <code>answer_0()</code> 函数中填写下面代码：</p>
<p><img src="/images/14533240490475.jpg" alt=""></p>
<p>然后执行 <code>./runner.sh</code>，就可以看到：</p>
<p><img src="/images/14533240848416.jpg" alt=""></p>
<p>我们现在来试着提交一下：</p>
<p><code>./submitter -a dawang -l bash</code></p>
<p>如果引用了其他的内容，需要把对应的资料放到 <code>reference</code> 文件夹中，不然抄袭后果很严重。</p>
<p>因为这一问不评分，所以并没有结果。</p>
<p>这里我又用 java 重写了一次，这里建议大家最好在本地测试运行一下再上传到 AWS 上。考虑到 python 性能比较差，所以从一开始就用 java。</p>
<h3 id="Data_Analysis"><a href="#Data_Analysis" class="headerlink" title="Data Analysis"></a>Data Analysis</h3><p>接下来就是完成 <code>runner.sh</code> 中的各项任务了，具体任务如下：</p>
<ol>
<li>输出过滤前所有的行数</li>
<li>输出过滤前所有的访问数的总和</li>
<li>过滤之后有还剩多少行</li>
<li>过滤后的最受欢迎的文章是什么，输出标题即可</li>
<li>在过滤后的数据集中，包含『cloud』和『computing』的文章有多少个，这里注意是精确匹配，也不区分大小写</li>
<li>过滤后的数据集中最受欢迎的电影的次数，注意，电影的话标题里会有『film』</li>
<li>过滤后的数据集中访问次数在 2500~3000 之间的有多少个</li>
<li>以一个数字开头，之后是字母的页面有多少次访问（注意是开头，正则表达式要匹配上）</li>
<li>是 2014 年的电影更热门还是 2015 年的更热门，搜索『2014_film』和『2015_film』，注意大小写敏感</li>
</ol>
<p>这里需要注意的是，因为在 <code>runner.sh</code> 中分成了九个不同的函数来做，而其实这些都可以一次处理完，所以我会把结果存在临时文件里，然后用 bash 输出。</p>
<p>如果不想在命令行里编程，可以把文件弄到本地来进行编写，命令如下：</p>
<p>远程到本地 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo scp -i demo.pem ubuntu@ec2-<span class="number">54</span>-<span class="number">165</span>-<span class="number">218</span>-<span class="number">37</span>.compute-<span class="number">1</span>.amazonaws.com:~/Project1_1/SeqProg.java ./</span><br><span class="line"></span><br><span class="line">sudo scp -i demo.pem ubuntu@ec2-<span class="number">54</span>-<span class="number">165</span>-<span class="number">218</span>-<span class="number">37</span>.compute-<span class="number">1</span>.amazonaws.com:~/Project1_1/runner.sh ./</span><br></pre></td></tr></table></figure>
<p>本地到远程 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo scp -i demo.pem ./SeqProg.java ubuntu@ec2-<span class="number">54</span>-<span class="number">165</span>-<span class="number">218</span>-<span class="number">37</span>.compute-<span class="number">1</span>.amazonaws.com:~/Project1_1/</span><br><span class="line"></span><br><span class="line">sudo scp -i demo.pem ./runner.sh ubuntu@ec2-<span class="number">54</span>-<span class="number">165</span>-<span class="number">218</span>-<span class="number">37</span>.compute-<span class="number">1</span>.amazonaws.com:~/Project1_1/</span><br></pre></td></tr></table></figure>
<p>提交用：</p>
<p><code>./submitter -a dawang -l java</code></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>一定要认真看题</li>
<li>一定要认真看题</li>
<li>一定要认真看题</li>
<li>AWS 上有时候 java 表现会很奇怪，暂时未知</li>
</ol>
<p>本来打算两种语言都写一下的，但是因为踩了太多坑已经阵亡，最后就只用 Java 实现了（毕竟是会快一点）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一讲我们就要开始实际接触一个真实的项目——处理一个大文本数据集了。在云上编程和平时学习的可能有一些不同，这里会尽量写得详细一些。</p>]]>
    
    </summary>
    
      <category term="AWS" scheme="http://wdxtub.com/tags/AWS/"/>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="文本处理" scheme="http://wdxtub.com/tags/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 6 课 Machine Control]]></title>
    <link href="http://wdxtub.com/2016/01/20/csapp-6/"/>
    <id>http://wdxtub.com/2016/01/20/csapp-6/</id>
    <published>2016-01-20T16:15:32.000Z</published>
    <updated>2016-01-22T20:35:54.000Z</updated>
    <content type="html"><![CDATA[<p>上一讲我们了解了关于机器代码，汇编和 CPU 相关的基础知识，这一讲要来说一下具体机器是怎么实现代码中常见的流程控制的。这一部分涉及的代码和思路稍微有些不容易理解，我会尽量写得详细一些。</p>
<a id="more"></a>
<hr>
<p>我们先来回顾一下 x86-64 处理器中不同的寄存器，这一部分很重要，务必要弄明白：</p>
<p><img src="/images/14533022194673.jpg" alt=""></p>
<p>首先要理解的是，寄存器中存储着当前正在执行的程序的相关信息：</p>
<ul>
<li>临时数据存放在 (%rax, …)</li>
<li>运行时栈的地址存储在 (%rsp) 中</li>
<li>目前的代码控制点存储在 (%rip, …) 中</li>
<li>目前测试的状态放在 CF, ZF, SF, OF 中</li>
</ul>
<h2 id="Condition_Codes"><a href="#Condition_Codes" class="headerlink" title="Condition Codes"></a>Condition Codes</h2><p>最后的四个寄存器（CF, ZF, SF, OF）就是用来辅助程序的流程控制的，意思是：</p>
<ul>
<li>CF: Carry Flag (for unsigned)</li>
<li>ZF: Zero Flag</li>
<li>SF: Sign Flag (for signed)</li>
<li>OF: Overflow Flag (for signed)</li>
</ul>
<p>可以看到以上这四个寄存器，表示四种不同的状态，举个例子，假如我们有一条诸如 <code>t = a + b</code> 的语句，汇编之后假设用的是 <code>addq Src, Dest</code>，那么根据这个操作结果的不同，会相应设置上面提到的四个寄存器，而因为这个是执行类似操作时顺带尽心设置的，称为隐式设置，例如：</p>
<ul>
<li>如果两个数相加，在最高位还需要进位（也就是溢出了），那么 CF 寄存器就会被设置</li>
<li>如果 t 等于 0，那么 ZF 寄存器会被设置</li>
<li>如果 t 小于 0，那么 SF 寄存器会被设置</li>
<li>如果 2’s complement 溢出，那么 OF 寄存器会被设置为 1（溢出的情况是 <code>(a&gt;0 &amp;&amp; b &gt; 0 &amp;&amp; t &lt;0) || (a&lt;0 &amp;&amp; b&lt;0 &amp;&amp; t&gt;=0)</code>）</li>
</ul>
<p>这就发现了，其实这四个条件代码，是用来标记上一条命令的结果的各种可能的，是自动会进行设置的。注意，使用 <code>leaq</code> 指令的话不会进行设置。</p>
<p>除了隐形设置，还可以显式进行设置，具体的方法是使用 <code>cmpq</code> 指令，这里的 q 指的是 64 位的地址。具体来说 <code>cmpq Src2(b), Src1(a)</code> 等同于计算 <code>a-b</code>（注意 a b 顺序是颠倒的），然后利用 <code>a-b</code> 的结果来对应进行条件代码的设置：</p>
<ul>
<li>如果在最高位还需要进位（也就是溢出了），那么 CF 寄存器就会被设置</li>
<li>a 和 b 相等时，也就是 <code>a-b</code> 等于零时，ZF 寄存器会被设置</li>
<li>如果 a &lt; b，也就是 <code>(a-b)&lt;0</code> 时，那么 SF 寄存器会被设置</li>
<li>如果 2’s complement 溢出，那么 OF 寄存器会被设置（溢出的情况是 <code>(a&gt;0 &amp;&amp; b &gt; 0 &amp;&amp; t &lt;0) || (a&lt;0 &amp;&amp; b&lt;0 &amp;&amp; t&gt;=0)</code>）</li>
</ul>
<p>另一种进行显式设置的方法是使用 <code>testq</code> 指令，具体来说 <code>testq Src2(b), Src1(a)</code> 等同于计算 <code>a&amp;b</code>（注意 a b 顺序是颠倒的），然后利用 <code>a-b</code> 的结果来对应进行条件代码的设置，通常来说会把其中一个操作数作为 mask：</p>
<ul>
<li>当 <code>a&amp;b == 0</code> 时，ZF 寄存器会被设置</li>
<li>当 <code>a&amp;b &lt; 0</code> 时，SF 寄存器会被设置</li>
</ul>
<p>有了这四个条件码，就可以通过不同的组合方式，来产生不同的条件判断，例如：</p>
<p><img src="/images/14533038073018.jpg" alt=""></p>
<p>具体来说只会设置最右边的一个 byte（也就是 %al 的部分），其他的都不会改变（通过下面的例子会更清晰）</p>
<p><img src="/images/14533038709749.jpg" alt=""></p>
<p>举个例子，假设我们有一条这样的语句，用来判断 x 和 y 的大小，转换成汇编之后，有几个需要注意的地方，一是 %rsi 存的是 y，%rdi 存的是 x，这个就是前面说的顺序问题。然后我们设置最右边的一个 byte（也就是 %al 的部分，见上图），最后利用 <code>movzbl</code> 指令把返回值复制到 %eax 寄存器中。</p>
<p><img src="/images/14533041584630.jpg" alt=""></p>
<p>这里有一点要进行说明，到底 %eax 寄存器在哪里呢？图上怎么没有？其实 %eax 就是 %rax 寄存器的后 32 位的名称。</p>
<p>那为什么我们要用 32 位的指令呢，剩下的高位怎么办？这是因为在 x86-64 的架构设计中有一条规则『如果对 64 位寄存器设置 32 位数据，那么高位会被设置为 0』，所以可以通过 32 位的指令对 %eax 进行操作处理（如果忽略这个很容易让人困惑），相当于是处理好了 64 位的 %rax 寄存器。</p>
<h2 id="Condition_Branch"><a href="#Condition_Branch" class="headerlink" title="Condition Branch"></a>Condition Branch</h2><p>介绍完了条件代码，就可以来看看具体的跳转了，跳转实际上就是根据条件代码的不同，来进行跳转，具体如下：</p>
<p><img src="/images/14533045268420.jpg" alt=""></p>
<p>我们先来看一个比较原始的例子（编译器没有进行主要优化）：</p>
<p><img src="/images/14533045995659.jpg" alt=""></p>
<p>这里我们是要给出两个数的绝对值的差，所以需要判断谁大谁小，蓝色和红色的部分就分别代表两条分支。考虑到汇编不算特别直观，这里我们用 goto 语句重写一次，基本上就和汇编出来的代码逻辑类似了，方便之后的讲解：</p>
<p><img src="/images/14533047116967.jpg" alt=""></p>
<p>我们再看另一种条件语句要如何翻译，比如 <code>val = Test ? Then_Expr : Else_Expr;</code>，重写上面的函数就是：<code>val = x&gt;y ? x-y : y-x;</code></p>
<p>转换成 goto 形式就是：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	ntest = <span class="comment">!Test;</span></span><br><span class="line">	<span class="keyword">if</span> (ntest) <span class="keyword">goto</span> <span class="keyword">Else</span>;</span><br><span class="line">	<span class="keyword">value</span> = Then_Expr;</span><br><span class="line">	<span class="keyword">goto</span> Done;</span><br><span class="line"><span class="keyword">Else</span>:</span><br><span class="line">	val = Else_Expr;</span><br><span class="line">Done:</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>但是实际上汇编出来的代码，并不是这样的，会采用另一种方法来加速分支语句的执行。现在我们先来说一说，为什么分支语句会对性能造成很大的影响。</p>
<p>我们知道现在的 CPU 都是依靠流水线工作的，比方说执行一系列操作需要 ABCDE 五个步骤，那么在执行 A 的时候，实际上执行 B 所需的数据会在执行 A 的同时加载到寄存器中，这样运算器执行外 A，就可以立刻执行 B 而无须等待数据载入。如果程序一直是顺序的，那么这个过程就可以一直进行下去，效率会很高。但是一旦遇到分支，那么可能执行完 A 下一步要执行的是 C，但是载入的数据是 B，这时候就要把流水线清空（因为后面载入的东西都错了），然后重新载入 C 所需要的数据，这就带来了很大的性能影响。为此人们常常用『分支预测』这一技术来解决（分支预测是另一个话题这里不展开），但是对于这类只需要判断一次的条件语句来说，其实有更好的方法。</p>
<p>处理器有一条指令支持 <code>if(Test) Dest &lt;- Src</code> 的操作，也就是说可以不用跳转，利用条件代码来进行赋值，于是编译器在可能的时候会把上面的 goto 程序改成如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = Then_Expr;</span><br><span class="line">eval = Else_Expr;</span><br><span class="line">nt = !Test;</span><br><span class="line"><span class="keyword">if</span> (nt) result = eval;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>具体的做法是：反正一共就两个分支，我都算出行不行，然后利用上面的条件指令来进行赋值，这样就完美避免了因为分支可能带来的性能问题（需要清空流水线），像下面这样：</p>
<p><img src="/images/14533057292618.jpg" alt=""></p>
<p>这个方法好是好，但是也有一些情况并不适用于：</p>
<ul>
<li>因为会把两个分支的运算都提前算出来，如果这两个值都需要大量计算的话，就得不偿失了，所以需要分支中的计算尽量简单。</li>
<li>另外在涉及指针操作的时候，如 <code>val = p ? *p : 0;</code>，因为两个分支都会被计算，所以可能导致奇怪问题出现</li>
<li>最后一种就是如果分支中的计算是有副作用的，那么就不能这样弄 <code>val = x &gt; 0 ? x*= 7 : x+= 3;</code>，这种情况下，因为都计算了，那么 x 的值肯定就不是我们想要的了。</li>
</ul>
<h2 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h2><p>先来看看并不那么常用的 Do-While 语句：</p>
<p><img src="/images/14533062342446.jpg" alt=""></p>
<p>这个函数计算参数 x 中有多少位是 1，翻译成汇编如下：</p>
<p><img src="/images/14533063334333.jpg" alt=""></p>
<p>其中 %rdi 中存储的是参数 x，%rax 存储的是返回值。换成更通用的形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C Code</span></span><br><span class="line"><span class="function"><span class="keyword">do</span></span><br><span class="line">	Body</span><br><span class="line">	<span class="title">while</span> <span class="params">(Test)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Goto Version</span></span><br><span class="line">loop:</span><br><span class="line">	<span class="function">Body</span><br><span class="line">	<span class="title">if</span> <span class="params">(Test)</span></span><br><span class="line">		<span class="keyword">goto</span> loop</span></span><br></pre></td></tr></table></figure>
<p>而对于 While 语句的转换，会直接跳到中间，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C While version</span></span><br><span class="line"><span class="keyword">while</span> (Test)</span><br><span class="line">	Body</span><br><span class="line"></span><br><span class="line"><span class="comment">// Goto Version</span></span><br><span class="line">	<span class="keyword">goto</span> test;</span><br><span class="line">loop:</span><br><span class="line">	Body</span><br><span class="line">test:</span><br><span class="line">	<span class="keyword">if</span> (Test)</span><br><span class="line">		<span class="keyword">goto</span> loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<p>举个具体的例子：</p>
<p><img src="/images/14533065773830.jpg" alt=""></p>
<p>如果在编译器中开启 <code>-O1</code> 优化，那么会把 While 先翻译成 Do-While，然后再转换成对应的 Goto 版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C While version</span></span><br><span class="line"><span class="keyword">while</span> (Test)</span><br><span class="line">	Body</span><br><span class="line"></span><br><span class="line"><span class="comment">// C Do-While Version</span></span><br><span class="line">	<span class="keyword">if</span> (!Test)</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	<span class="function"><span class="keyword">do</span></span><br><span class="line">		Body</span><br><span class="line">		<span class="title">while</span><span class="params">(Test)</span></span>;</span><br><span class="line">done:</span><br><span class="line"></span><br><span class="line"><span class="comment">// Goto Version</span></span><br><span class="line">	<span class="keyword">if</span> (!Test)</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">loop:</span><br><span class="line">	<span class="function">Body</span><br><span class="line">	<span class="title">if</span> <span class="params">(Test)</span></span><br><span class="line">		<span class="keyword">goto</span> loop</span>;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<p>具体的例子是：</p>
<p><img src="/images/14533068824241.jpg" alt=""></p>
<p>为什么要这样做呢，因为 Do-While 语句执行起来更快，更符合 CPU 的运算模型。</p>
<p>然后来看看最常用的 For 循环，也可以一步一步转换成 While 的形式，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For</span></span><br><span class="line"><span class="keyword">for</span> (Init; Test; Update)</span><br><span class="line">	Body</span><br><span class="line">	</span><br><span class="line"><span class="comment">// While Version</span></span><br><span class="line">Init;</span><br><span class="line"><span class="keyword">while</span> (Test) &#123;</span><br><span class="line">	Body</span><br><span class="line">	Update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在具体转换成 Do-While 模式的时候，会把最初的测试优化去除</p>
<p><img src="/images/14533070757433.jpg" alt=""></p>
<h2 id="Switch_Statement"><a href="#Switch_Statement" class="headerlink" title="Switch Statement"></a>Switch Statement</h2><p>最后我们来看看最复杂的 switch 语句，这种类型的语句一次判断会有多种可能的跳转路径（知道 CPU 的分支预测会多抓狂吗）。这里用一个具体的例子来进行讲解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">switch_eg</span> <span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y, <span class="keyword">long</span> z)</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> w = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">switch</span> (x) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			w = y*z;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			w = y/z;</span><br><span class="line">			<span class="comment">// fall through</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			w += z;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">			w -= z;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			w = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中包含了大部分比较特殊的情况：</p>
<ul>
<li>共享的条件：5 和 6</li>
<li>fall through：2 也会执行 3 的部分（这个要小心，一般来说不这么搞，如果确定要用，务必写上注释）</li>
<li>缺失的条件：4</li>
</ul>
<p>具体怎么办呢？简单来说，使用跳转表（你会发现表的解决方式在很多地方都有用：虚函数，继承甚至动态规划），如下所示：</p>
<p><img src="/images/14533075034521.jpg" alt=""></p>
<p>转换出来如下：</p>
<p><img src="/images/14533079929851.jpg" alt=""></p>
<p>这里需要注意，我们先跟 6 进行比较（因为 6 是最大的），然后利用 <code>ja</code> 指令进行跳转，为什么，因为如果是负数的话，<code>ja</code> 是处理无符号数的，所以负数情况肯定大于 6，于是直接利用 <code>ja</code> 跳转到 default 的分支。</p>
<p><img src="/images/14533081508060.jpg" alt=""></p>
<p>然后下一句 <code>jmp *.L4(,%rdi, 8) # goto *JTab[x]</code>，是一个间接跳转，通过看上面的跳转列表来进行跳转。</p>
<p>比如说，直接跳转 <code>jmp .L8</code>，就直接跳到 <code>.L8</code> 所在的标签，也就是 x = 0</p>
<p>如果是 <code>jmp *.L4(,%rdi,8)</code> 那么就先找到 <code>.L4</code> 然后往后找 8 个字节（或 8 的倍数），于是就是 0~6 的范围。具体的对应关系如下：</p>
<p><img src="/images/14533122886722.jpg" alt=""></p>
<p>处理 fall through 的方式：</p>
<p><img src="/images/14533123220172.jpg" alt=""></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这节课我们学到了</p>
<ul>
<li>C 语言的控制流程<ul>
<li>if-then-else</li>
<li>do-while</li>
<li>while, for</li>
<li>switch</li>
</ul>
</li>
<li>汇编的控制流程<ul>
<li>条件跳转</li>
<li>条件转移</li>
<li>间接跳转（通过跳转表）</li>
<li>编译器会生成代码序列来实现更加复杂的控制</li>
</ul>
</li>
<li>标准技术<ul>
<li>把循环转换位 do-while 的形式或者 jump-to-middle 形式</li>
<li>大的 switch 语句会用跳转表</li>
<li>处理 switch 语句可能会用到决策树（if-elseif-elseif-else）</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一讲我们了解了关于机器代码，汇编和 CPU 相关的基础知识，这一讲要来说一下具体机器是怎么实现代码中常见的流程控制的。这一部分涉及的代码和思路稍微有些不容易理解，我会尽量写得详细一些。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一点微小的工作]]></title>
    <link href="http://wdxtub.com/2016/01/19/a-little-work/"/>
    <id>http://wdxtub.com/2016/01/19/a-little-work/</id>
    <published>2016-01-20T04:40:52.000Z</published>
    <updated>2016-01-20T05:35:16.000Z</updated>
    <content type="html"><![CDATA[<p>可能很久之后回忆这段留学的时光，让自己开心的不是绩点和景点，而是朋友，和一点微小的工作。</p>
<a id="more"></a>
<hr>
<p>先说主题：我在把这个学期上的课程以及自己的学习经历以日志的形式记录并共享出来，一是督促自己更深刻理解所学知识，二是让更多人能够接触到高质量的教学课程。希望能以这一点微小的工作，帮助更多人。也希望大家也能更多地把自己学习和思考的东西写出来分享出来，真正去创造些高质量的可以传承的东西。</p>
<p>（以下是目前正在进行的三门课程的文章列表）</p>
<p><img src="/images/list.jpg" alt="list"></p>
<p>为什么在做这样一件事情呢？</p>
<p>本科在中山大学读完之后（还度过了一段研究生时光），来到 CMU，才真切地感受到国内外教育质量的差距。高兴的是能有机会接触到最顶尖的教育，惭愧的是只能独善吾身，却不能兼济天下。即使心里想着做些什么去改变这种状况，却迟迟没有动手。每每念及高中同学向芯，除了佩服她（以及她的小伙伴）多年如一日勉力经营青草（『让中国青少年成为有爱，有思想，有行动力的人』，参考<a href="http://www.douban.com/note/258430473/" target="_blank" rel="external">这里</a>），还在想，作为我这样一个资质平平也没有治国平天下理想的普通青年，能做些什么。</p>
<p>至少我能把我所学所想写下来，让更多人能通过我的文字，来了解『教育也可以是这样的』。南非前总统曼德拉曾经说：“如果你隐藏自己，不敢让别人看到你如何做自己喜欢的事，别人就会认为，他们也不能做到。但如果你让他们看见，就等于允许他们像你一样去做自己喜欢的事，就等于解放了他们的愿望。这并不是说要让他们去做和你一样的事，而是让每一个都做最适合自己、自己最希望做的事。”</p>
<p>这也是为什么，我想要把这些写下来的原因。</p>
<p>本来是打算等学期结束再整理分享，但是想到早一些分享，可能就会多一些人参与。虽然可能目前有各种各样的错漏，但是相信在大家的监督点拨下，我们都能做得更好。</p>
<p>我不大会起那些特别吸引眼球的标题，更多是想踏踏实实把一件事情坚持下来，如果可能的话，做得尽量好一些。也希望能用自己这一点微小的工作，让大家看到，即使是小小的贡献，积累起来也能是大大的改变。</p>
<p>具体的文章目录可以在<a href="http://wdxtub.com/about/">这里</a>查看，欢迎加我的个人微信交流讨论</p>
<p>更希望能帮忙转发一下，让更多人能看到并参与进来。</p>
<p><img src="/images/me.jpeg" alt="me"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>可能很久之后回忆这段留学的时光，让自己开心的不是绩点和景点，而是朋友，和一点微小的工作。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="分享" scheme="http://wdxtub.com/tags/%E5%88%86%E4%BA%AB/"/>
    
      <category term="学习" scheme="http://wdxtub.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="课程" scheme="http://wdxtub.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 8 课 Choosing Connectors]]></title>
    <link href="http://wdxtub.com/2016/01/19/sad-8/"/>
    <id>http://wdxtub.com/2016/01/19/sad-8/</id>
    <published>2016-01-19T13:24:49.000Z</published>
    <updated>2016-01-22T20:35:21.000Z</updated>
    <content type="html"><![CDATA[<p>上一讲中我们了解了连接器的基本概念，这一讲我们来看看，在这么多不同的选项中，如何找到最适合项目的连接器。</p>
<a id="more"></a>
<hr>
<p>具体到连接器的选择，涉及到选择，我们就应该意识到，上一讲其实是了解了选项，这一讲来说说如何选择。但是实话说，不要说一讲能说清楚，一百讲估计都不行，因为对于现实生活来说，本来就没有十全十美的选择。</p>
<p>工程没有人生这么复杂，可是需要考虑的东西仍然太多，看得到的是几个选项，看不到的是选项背后错综复杂的关系网。就拿连接器来说，基本功能，如何交互，这是需要考虑的，交互下面分几个大方向：communication, coordination, conversion, facilitation，根据这些选择合适的类型，确定作用的范围，再根据实际需要进行组合。</p>
<p>一个描述交互的模型，叫做 Interconnection models(IM)，从微观到宏观有三个层次：unit, syntactic, semantic。接下来简要介绍一下这几个不同的层级</p>
<h2 id="Unit_Interconnection"><a href="#Unit_Interconnection" class="headerlink" title="Unit Interconnection"></a>Unit Interconnection</h2><p>定义了不同系统单元（组件，模块合作文件）之间的关系，最基础的单元关系就是依赖。下面是一些例子：</p>
<p><img src="/images/14532537450817.jpg" alt=""><br>是比较粗粒度的静态相互连接，并不能描述组件之间的交互，主要是集中于相关性的描述</p>
<h2 id="Syntactic_Interconnection"><a href="#Syntactic_Interconnection" class="headerlink" title="Syntactic Interconnection"></a>Syntactic Interconnection</h2><p>描述句法元素间的关系，比方说变量定义和使用，函数的声明和调用。下面是一些例子：</p>
<p><img src="/images/14532538558847.jpg" alt=""><br>是比较细粒度的相互连接，可以是动态也可以是静态的。但是实际上是不完整的相互连接的描述，因为可能在语义层级是不允许的。</p>
<h2 id="Semantic_Interconnection"><a href="#Semantic_Interconnection" class="headerlink" title="Semantic Interconnection"></a>Semantic Interconnection</h2><p>描述系统组件如何被使用，可以正规进行定义：</p>
<ul>
<li>前条件</li>
<li>后条件</li>
<li>动态交互协议（例如 CSP, FSM）</li>
</ul>
<p>举个例子：</p>
<p><img src="/images/14532542194874.jpg" alt=""></p>
<p>基于 syntactic interconnections，可以是静态或者动态的，在架构层面是必须的，包括大的组件，复杂的交互以及组件重用。当然还有其他很多东西要考虑，如：鲁棒性，可靠性，安全性，可用性等等。</p>
<h2 id="u7EC4_u5408_u57FA_u672C_u7684_u8FDE_u63A5_u5668"><a href="#u7EC4_u5408_u57FA_u672C_u7684_u8FDE_u63A5_u5668" class="headerlink" title="组合基本的连接器"></a>组合基本的连接器</h2><p>许多时候我们需要组合多个连接器，但是要注意，不是所有的都可以搭配，有些是会相互冲突的，并且各有各的妥协。它们的关系为：</p>
<p><img src="/images/14532544518305.jpg" alt=""></p>
<p>其实是有一张很大的表格：</p>
<p><img src="/images/14532545047453.jpg" alt=""></p>
<p>这里不展开，不过列出一些知名的复合连接器：</p>
<ul>
<li>Grid Connectors(e.g. Globus)<ul>
<li>Procedure call</li>
<li>Data access</li>
<li>Stream</li>
<li>Distributor</li>
</ul>
</li>
<li>Peer-to-peer connectors (e.g. Bittorrent)<ul>
<li>Arbitrator</li>
<li>Data access</li>
<li>Stream</li>
<li>Distributor</li>
</ul>
</li>
<li>Client-server connectors</li>
<li>Event-based connectors</li>
</ul>
<p>这一讲的内容就这么多，其实还是蛮抽象的，之后的习题课会用具体的例子来分析，现在大概感受一下即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一讲中我们了解了连接器的基本概念，这一讲我们来看看，在这么多不同的选项中，如何找到最适合项目的连接器。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 7 课 Software Connectors]]></title>
    <link href="http://wdxtub.com/2016/01/19/sad-7/"/>
    <id>http://wdxtub.com/2016/01/19/sad-7/</id>
    <published>2016-01-19T13:22:16.000Z</published>
    <updated>2016-01-22T20:35:24.000Z</updated>
    <content type="html"><![CDATA[<p>在了解了整体的框架之后，这节课我们来看架构中很重要的一部分——连接器。这里主要是一些概念和设计的介绍。</p>
<a id="more"></a>
<hr>
<p>我们首先要回答的问题就是：什么是连接器？</p>
<p>连接器是一个架构元素，负责组件之间的交互。组件之间的交互可以很简单，比如过程调用和共享变量访问，当然也可以很复杂，比如说客户端-服务端协议，数据库访问协议或者异步事件广播。所以总体来看，每个连接器要保证交互的方式和内容。</p>
<p><img src="/images/14532500030394.jpg" alt=""><br>看看上面的图，就会发现，好像找不到所谓的连接器。的确，连接器在具体的实现中，可能没有明确的代码和实体，反而是一种分布式的实现，横跨不同的模块和交互机制。</p>
<p>但是在软件架构中，连接器是一等实体，有具体的身份，用来描述所有的系统交互。</p>
<p>可能有同学要问，为什么代码里没有，非要在概念上独立出来呢？</p>
<p>因为连接器和组件不同，组件提供应用相关的功能，而连接器是提供应用无关的交互机制，一旦交互变得复杂，这种抽象就非常有用。至少有如下好处：</p>
<ol>
<li>分离计算和交互</li>
<li>最小化组件间的相互依赖</li>
<li>支持软件的演化</li>
<li>支持动态设计</li>
<li>方便多种实现方式</li>
<li>易于分布式</li>
<li>有助于系统分析和测试</li>
</ol>
<p>连接器主要扮演下面的角色：</p>
<ul>
<li>是不同组件交互的地方</li>
<li>定义协议规范的属性<ul>
<li>支持的接口类型</li>
<li>保证交互属性</li>
<li>交互顺序规则</li>
<li>性能</li>
</ul>
</li>
<li>负责 communication, coordination, conversion, facilitation</li>
</ul>
<p>作为 communicator，连接器支持不同的通信机制，例如过程调用，RPC，共享数据访问，消息传递；同时限制规范通信的结构和方向，也保证服务质量。更重要的是，可以分离通信与计算，可能会影响到非功能性的系统特性（如性能，可拓展性，安全性）</p>
<p>作为 coordinator，连接器控制计算和数据传递，分离控制和计算，让 communication, conversion 和 facilitation 正交，互不影响。</p>
<p>作为 converter，连接器使得交互可以独立设计，解耦不同的组件（类型，数量，频次，顺序），比如 Adaptor 和 Wrapper</p>
<p>作为 facilitator，连接器让不同的组件协同工作，控制共享信息的访问，保证性能（负载均衡）以及提供同步机制（关键区，Monitor）</p>
<p>总结一下，常见的连接器类型有：</p>
<ul>
<li>Procedure call</li>
<li>Data access</li>
<li>Event</li>
<li>Stream</li>
<li>Linkage</li>
<li>Distributor</li>
<li>Arbitrator</li>
<li>Adaptor</li>
</ul>
<p>下面是一些具体的例子：</p>
<p><img src="/images/14532510393162.jpg" alt=""><br><img src="/images/14532510519338.jpg" alt=""><br><img src="/images/14532510622462.jpg" alt=""><br><img src="/images/14532510727822.jpg" alt=""><br><img src="/images/14532510800150.jpg" alt=""><br><img src="/images/14532510875753.jpg" alt=""><br><img src="/images/14532510958393.jpg" alt=""></p>
<p><img src="/images/14532511040878.jpg" alt=""></p>
<p>连接器使得为复杂交互进行抽象和建模成为可能，通过这种灵活性，是的系统可以方便地进行变化，但是需要注意在性能和灵活性之间进行权衡。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在了解了整体的框架之后，这节课我们来看架构中很重要的一部分——连接器。这里主要是一些概念和设计的介绍。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 6 课 Styles and Greenfield Design]]></title>
    <link href="http://wdxtub.com/2016/01/19/sad-6/"/>
    <id>http://wdxtub.com/2016/01/19/sad-6/</id>
    <published>2016-01-19T13:22:11.000Z</published>
    <updated>2016-01-22T20:35:27.000Z</updated>
    <content type="html"><![CDATA[<p>前一讲了解了简单的架构风格，这节课看一下稍微复杂一点的风格，以及针对 Greenfield 设计（类似于开放式问题）的相关内容。</p>
<a id="more"></a>
<hr>
<p>其他的一些风格会稍微复杂一些，相当于是简单风格的组合，如：</p>
<ul>
<li>REST</li>
<li>C2: Implicit invocation + Layering + other constraints</li>
<li>Distributed objects: OO + client-server network style, CORBA</li>
</ul>
<h2 id="C2"><a href="#C2" class="headerlink" title="C2"></a>C2</h2><p>An indirect invocation style in which independent components communicate exclusively through message routing connectors. Strict rules on connections between components and connectors induce layering.</p>
<p>组件包括独立，可潜在并行的信息产生器或消费者。连接器包括消息路由，可以过滤，翻译，转发通知或者请求。数据元素主要是消息和通知。</p>
<p>Layers of Componnets and connectors, with a defined “top” and “bottom”, wherein notifications flow downwards and requests upwards.</p>
<p><img src="/images/14532424727100.jpg" alt=""></p>
<h2 id="Distributed_Objects_3A_CORBA"><a href="#Distributed_Objects_3A_CORBA" class="headerlink" title="Distributed Objects: CORBA"></a>Distributed Objects: CORBA</h2><p>用多种语言编写的对象在多个主机上运行。对象通过良好定义的接口提供服务。对象通过远程过程调用(Remote procedure calls, RPCs)在不同的主机，进程和语言边界间调用方法。</p>
<p>组件主要是对象，连接器是过程调用。数据元素是方法的参数，返回值和异常。</p>
<p>General graph of objects from callers to callees.</p>
<p>这种风格是 location, platform, language transparency 的，也就是说不受以上的限制。</p>
<p><img src="/images/14532429040620.jpg" alt=""></p>
<h2 id="Observations"><a href="#Observations" class="headerlink" title="Observations"></a>Observations</h2><p>这是一种在不同架构中有不同表现的风格。主要关注问题（领域）和 resulting system。</p>
<p>下面是总结</p>
<p><img src="/images/14532456127563.jpg" alt=""></p>
<p><img src="/images/14532456260782.jpg" alt=""></p>
<p><img src="/images/14532456351981.jpg" alt=""></p>
<p><img src="/images/14532456453748.jpg" alt=""></p>
<h2 id="Design_Recovery"><a href="#Design_Recovery" class="headerlink" title="Design Recovery"></a>Design Recovery</h2><p>主要的任务是检查已有的代码基和审查系统的组件，连接器和总体的拓扑结构。一个常见的方法是把实现层的实体通过聚类的方法组成架构元素，两种方法：句法聚类和语义聚类。</p>
<h3 id="Syntactic_Clustering"><a href="#Syntactic_Clustering" class="headerlink" title="Syntactic Clustering"></a>Syntactic Clustering</h3><p>主要是针对代码级实体的静态关系，不需要运转系统就可以操作，例如 coupling 和 cohesion。但是可能会漏掉一些细微的关系，毕竟是没有动态信息的。</p>
<h3 id="Semantic_Clustering"><a href="#Semantic_Clustering" class="headerlink" title="Semantic Clustering"></a>Semantic Clustering</h3><p>语义包含句法，从定义上就能很清楚的得知这个方法力图包含系统领域知识的方方面面，这也导致了比较难以自动化进行。</p>
<h2 id="Greenfield"><a href="#Greenfield" class="headerlink" title="Greenfield"></a>Greenfield</h2><p>所谓 Greenfield 实际上就是说对于当前问题所处的领域大家都没有什么经验，有下面这三种指导思想：</p>
<ul>
<li>Divergence: shake off inadequate prior approaches and discover or admit a variety of new ideas</li>
<li>Transformation: combination of analysis and selection</li>
<li>Convergence: selecting and further refining ideas</li>
</ul>
<p>不断在基本的步骤里尝试直到找到比较可行的解决方案，我感觉来说就是不断试错找到最优解。下面列出一些基本方法：</p>
<ul>
<li>类比搜索：通过类比去找不相关但相似的问题，看看他们是怎么结局问题的，例如『神经网络』的提出</li>
<li>头脑风暴：这个是老生常谈了，唯一需要注意的是不要因为某些不合理的规则限制了大家的想象力</li>
<li>文献搜索：他山之石，可以攻玉</li>
<li>词法表：先列出主要的功能，然后给出对应的解决办法，有了这些办法，再进行下一步的设计和优化</li>
<li>跳出盒子：不要给自己设限，试试跳跃性思维</li>
</ul>
<p>还可以尝试其他各种方法，但是注意一定要有所限制：</p>
<ul>
<li>不然会越来越复杂</li>
<li>需要批判性思考和决定</li>
<li>考虑研究和试错的花费</li>
<li>隔离不确定的决定</li>
<li>不断评估系统的需求，确定设计边界</li>
</ul>
<p>最重要的，实在没有什么想法的话，多读读需求，俗话说得好，『读书百遍，其义自见』</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前一讲了解了简单的架构风格，这节课看一下稍微复杂一点的风格，以及针对 Greenfield 设计（类似于开放式问题）的相关内容。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 5 课 Architectural Styles]]></title>
    <link href="http://wdxtub.com/2016/01/19/sad-5/"/>
    <id>http://wdxtub.com/2016/01/19/sad-5/</id>
    <published>2016-01-19T13:21:57.000Z</published>
    <updated>2016-01-22T20:35:30.000Z</updated>
    <content type="html"><![CDATA[<p>前面我们大致了解了一下整体的系统设计与领域相关知识组合的各种设计阶段，这一讲我们主要来看看架构风格。</p>
<a id="more"></a>
<hr>
<h2 id="u9762_u5411_u5BF9_u8C61_u98CE_u683C"><a href="#u9762_u5411_u5BF9_u8C61_u98CE_u683C" class="headerlink" title="面向对象风格"></a>面向对象风格</h2><p>这个风格大家应该都比较熟悉了，主要是分为组件和连接器，各个部分都按照面向对象的几个大的原则：封装继承多态来设计。好处在于各个组件分工明确并且不需要关注组件内部实现，自由度比较高。</p>
<h2 id="u5206_u5C42_u98CE_u683C"><a href="#u5206_u5C42_u98CE_u683C" class="headerlink" title="分层风格"></a>分层风格</h2><p>层次结构，层与层之间通过 API 来进行通信，每层对于上下两层扮演服务端和客户端的角色，操作系统就是一个很好的例子。</p>
<p>好处在于增加了抽象层级，并且可以不断进化，改动一层，最多影响两层，很好进行重用。只要保证接口，实现可以多样化，标准化的接口使得库和框架开发都很方便。不好之处在于不是特别通用，过多的抽象也会影响性能。</p>
<h2 id="u5BA2_u6237_u7AEF-_u670D_u52A1_u7AEF_u98CE_u683C"><a href="#u5BA2_u6237_u7AEF-_u670D_u52A1_u7AEF_u98CE_u683C" class="headerlink" title="客户端-服务端风格"></a>客户端-服务端风格</h2><p>组件被费城客户端和服务端两种，服务端对于客户端的数量和身份都未知，但是客户端知道服务端的，不同的连接器基于 RPC 网络交互协议 RPC-based network interaction protocol.</p>
<p><img src="/images/14532184327954.jpg" alt=""></p>
<h2 id="u6570_u636E_u6D41_u98CE_u683C"><a href="#u6570_u636E_u6D41_u98CE_u683C" class="headerlink" title="数据流风格"></a>数据流风格</h2><p>不同的程序按顺序执行，数据在这个过程中进行传递，这里的连接器就类似于一个通道。常用于金融系统的交易处理，称为『The Granddaddy of Styles』</p>
<p><img src="/images/14532185361937.jpg" alt=""></p>
<h2 id="u7BA1_u9053_u548C_u8FC7_u6EE4_u5668_u98CE_u683C"><a href="#u7BA1_u9053_u548C_u8FC7_u6EE4_u5668_u98CE_u683C" class="headerlink" title="管道和过滤器风格"></a>管道和过滤器风格</h2><p>组件是过滤器，用来处理数据；连接器是管道，用来控制数据流。每个过滤器只知道自己的事情，不知道其他的。例如：Unix Shell，信号处理，分布式系统，并行计算。用代码的话就比如：<code>ls invoices | grep -e August | sort</code></p>
<p>有一些变种，比如 Pipeline，Bounded pipes 和 Typed pipes。好处在于系统的行为就是组件的连续行为。过滤器可以方便的添加替换和重用，也比较容易分析吞吐量，延迟，死锁等等。对于独立的任务，可以并行处理。</p>
<p>不好的地方在于所有操作批处理容易出现问题，对于交互程序没有办法使用或者比较难用</p>
<h2 id="u9ED1_u677F_u98CE_u683C"><a href="#u9ED1_u677F_u98CE_u683C" class="headerlink" title="黑板风格"></a>黑板风格</h2><p>有两种类型的组件，一种是中央数据结构，叫做黑板，而另一种就是在黑板上操作的组件。系统的控制是基于黑板的状态。例如人工智能系统，集成软件环境，编译器</p>
<p><img src="/images/14532188392639.jpg" alt=""></p>
<h2 id="u57FA_u4E8E_u89C4_u5219_u98CE_u683C"><a href="#u57FA_u4E8E_u89C4_u5219_u98CE_u683C" class="headerlink" title="基于规则风格"></a>基于规则风格</h2><p>组件包括用户界面，推理引擎和知识库，连接器则是紧密相联的（通过过程调用或共享内存），数据元素是事实和查询。系统的行为可以通过增加规则来方便地修改。但是大量的规则可能会导致冲突和难以理解</p>
<h2 id="u89E3_u91CA_u5668_u98CE_u683C"><a href="#u89E3_u91CA_u5668_u98CE_u683C" class="headerlink" title="解释器风格"></a>解释器风格</h2><p>解析和执行输入命令，然后根据解释器来更新状态。组件包括：命令解释器，程序状态，用户界面。连接器则是紧密相联的（通过过程调用或共享内存）</p>
<p>这种风格非常灵活，但是对于用户的要求很高，例如 Lisp 和 Scheme</p>
<h2 id="Mobile-Code__u98CE_u683C"><a href="#Mobile-Code__u98CE_u683C" class="headerlink" title="Mobile-Code 风格"></a>Mobile-Code 风格</h2><p>这个风格的主要思想是，组件是一个可以执行各类代码的工具，然后具体的代码可以通过不同的来源输入并执行</p>
<p><img src="/images/14532203014560.jpg" alt=""></p>
<h2 id="Implicit_Invocation__u98CE_u683C"><a href="#Implicit_Invocation__u98CE_u683C" class="headerlink" title="Implicit Invocation 风格"></a>Implicit Invocation 风格</h2><p>这种风格是事件声明而非方法调用。有一个侦听器来检测方法是否被请求，具体什么时候执行由系统决定。WPF 的编程模型有一种就是如此。好处在于组件可以重用，无论是在构建阶段还是使用阶段都可以进行系统演化。不好之处在于这种设计比较反直觉，具体的控制需要系统计算。实际也不知道哪个组件在处理也不知道什么时候处理。</p>
<h2 id="u53D1_u5E03_u8BA2_u9605_u98CE_u683C"><a href="#u53D1_u5E03_u8BA2_u9605_u98CE_u683C" class="headerlink" title="发布订阅风格"></a>发布订阅风格</h2><p>同步或异步广播，然后接受者接收到了进行对应的处理，通常经过网络协议。数据类型包括 Subscription, notification 和 published information</p>
<p>Subscribers connect to publishers either directly or may receive notifications via a network protocol from intermediaries</p>
<p><img src="/images/14532212712908.jpg" alt=""></p>
<h2 id="u57FA_u4E8E_u4E8B_u4EF6_u98CE_u683C"><a href="#u57FA_u4E8E_u4E8B_u4EF6_u98CE_u683C" class="headerlink" title="基于事件风格"></a>基于事件风格</h2><p>不同的组件异步发出和接受小溪，通过事件总线进行连接。</p>
<p>Components communicate with the event buses, not directly to each other.</p>
<p>非常高的拓展性，对分布式系统有很好的支持</p>
<p><img src="/images/14532215931442.jpg" alt=""></p>
<h2 id="u70B9_u5BF9_u70B9_u98CE_u683C"><a href="#u70B9_u5BF9_u70B9_u98CE_u683C" class="headerlink" title="点对点风格"></a>点对点风格</h2><p>每个组件都是一个小的自治系统，一般来说通过网络协议（通常自定义）来进行沟通，互相发送网络消息。</p>
<p>Network (may have redundant connections between peers) can vary arbitrarily and dynamically</p>
<p>具有很高的鲁棒性，但是后期协议可能会是问题（因为规模越来越大）</p>
<p><img src="/images/14532220209237.jpg" alt=""></p>
<p>这一讲是各个风格的简要介绍，具体还是要在实例中进行学习和分析</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面我们大致了解了一下整体的系统设计与领域相关知识组合的各种设计阶段，这一讲我们主要来看看架构风格。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 4 课 Designing Architectures]]></title>
    <link href="http://wdxtub.com/2016/01/19/sad-4/"/>
    <id>http://wdxtub.com/2016/01/19/sad-4/</id>
    <published>2016-01-19T13:21:54.000Z</published>
    <updated>2016-01-22T20:35:32.000Z</updated>
    <content type="html"><![CDATA[<p>有了前面的基本概念和第一次作业的练习，这一讲我们主要来看看如何设计架构。</p>
<a id="more"></a>
<hr>
<p>设计架构的目标主要有两个方面，一个是创新，一个是方法。创新的意思是拓展自己的技能树，使用一些新的工具；而方法的意思是去找到那些高效的技术。在开发的时候往往需要做一些取舍：什么时候用去开发新方法，什么时候去使用已经验证的有效方法。</p>
<p>具体到做工程，设计的过程主要分以下几个阶段：</p>
<ul>
<li>Feasibility stage：可行性分析，找到一些可行的概念</li>
<li>Preliminary design stage：初步设计，选择和拓展最佳的概念</li>
<li>Detailed design stage：详细设计，做出这些概念的工程上的描述</li>
<li>Planning stage：计划阶段，根据产品，贡献，消耗和产品退出市场综合评估和改变这些概念</li>
</ul>
<p>每一步实际上可能都不是那么一帆风顺，比如说：</p>
<ul>
<li>如果设计者没有办法产出可行的概念，那么整个流程就无法继续</li>
<li>在问题越来越多，产品越来越大越来越复杂的时候，每一步成功的概率也在降低</li>
<li>标准的方法没有充分去考虑市场因素，比如不同产品线之间的影响</li>
</ul>
<p>所以主要矛盾就是日益增长的复杂度与设计者经验的不足之间的矛盾，为此，必须采用一些新的方法，比如：</p>
<ul>
<li>Standard：也就是之前提到的线性模型</li>
<li>Cyclic：可以从后面的步骤跳回到之前的步骤</li>
<li>Parallel：独立的过程可以并行处理</li>
<li>Adaptive：就是走一步看一步</li>
<li>Incremental：每一个阶段可以看作是在上一个阶段的基础上进行优化</li>
</ul>
<p>在继续讲下去之前，先说明若干概念，首先是『抽象』，抽象有两种方式，对应于软件工程中两类比较大的工程思路：自底向上和自顶向下。来看看下面的概念：</p>
<blockquote>
<p>Abstraction: The act or process of separating in thought, of considering a thing independently of its associations; or a substance independently of its attributes; or an attribute or quality independently of the substance to which it belongs.</p>
<p>Reification: The mental conversion of …[an] abstract concept into a thing.</p>
<p>Deduction: The process of drawing a conclusion from a principle already known or assumed; spec. in Logic, inference by reasoning from generals to particulars; opposed to INDUCTION.</p>
<p>Induction: The process of inferring a general law or principle from the observation of particular instances; opposed to DEDUCTION.</p>
</blockquote>
<p>最开始的时候，如果不知道从何入手，可以考虑 simple machine 方法，具体的意思就是，剥离大部分非核心的功能，从最基础的入手，比方说，要设计一个传真机，那么对应的 simple machine 就是一个状态机，先把这个状态机的状态确定好，然后再慢慢尽心迭代优化。对于不同的应用来说，通常都有对应的 simple machine，可以当作是万里长征第一步，一些常见的如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Domain</th>
<th style="text-align:center">Simple Machines</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Graphics</td>
<td style="text-align:center">Pixel arrays, Transformation matrices, Widgets, Abstract depiction graphs</td>
</tr>
<tr>
<td style="text-align:center">Word processing</td>
<td style="text-align:center">Structured documents, Layouts</td>
</tr>
<tr>
<td style="text-align:center">Process control</td>
<td style="text-align:center">Finite state machines</td>
</tr>
<tr>
<td style="text-align:center">Income Tax Software</td>
<td style="text-align:center">Hypertext, Spreadsheets, Form templates</td>
</tr>
<tr>
<td style="text-align:center">Web pages</td>
<td style="text-align:center">Hypertext, Composite documents</td>
</tr>
<tr>
<td style="text-align:center">Scientific computing</td>
<td style="text-align:center">Matrices, Mathematical functions</td>
</tr>
<tr>
<td style="text-align:center">Banking</td>
<td style="text-align:center">Spreadsheets, Databases, Transactions</td>
</tr>
</tbody>
</table>
<p>如果决定使用抽象来作为设计工具，那么有两个问题必须要搞清楚，一个是抽象的层级，一个是需要讨论的犯愁。这两个为什么重要呢？举个例子，假设我们在讨论宇宙，有意义的抽象的层级应该是一致的，不能说一个人在讨论行星恒星黑洞，另一个人在讨论水星火星地球。在层级一样之后，还需要确定的是具体到某个层级要讨论的范围，这样才能真正落到实处。</p>
<p>这里可以采用概念划分的方法，也就是把根据不同的子问题，划分出相互独立的几个部分，然后可以分别进行讨论。但是其实系统中各个部分或多或少都是相互联系的，那么如何分往往是需要取舍的。在软件工程中，一个比较关键的例子是组件（用于计算）和连接器（用于通信）直接的划分。</p>
<p>设计之中过去的经验也是很重要的，经验丰富的系统设计师经过长期训练所得到的直觉非常可靠（大部分情况下），我们还需要从过去的成功或失败中学习经验。失败是最好的老师，成功同样可以是，但是需要排除那些偶然因素影响的部分，去找到真正开启成功大门的钥匙。</p>
<p>然后我们来整体看一下不同部分在坐标系的位置，越靠近右上角，说明越需要领域相关的知识，同时也是从更高层的抽象来思考问题。</p>
<p><img src="/images/14532127643541.jpg" alt=""></p>
<p>Domain-Specific Software Architecutres, DSSA 是一系列软件组件的组合，针对特定的领域，使用标准的组件。这种特性也使得 DSSA 只对特定的领域有关系，普适性较低。</p>
<p>Architectural Patterns 是一组架构设计决定，可以根据图中的位置来大概感受其特点。一个比较常见的三层模型为：</p>
<p><img src="/images/14532130749730.jpg" alt=""></p>
<p>另一种是我们常常听到的 MVC，MVC 在移动应用中开发广泛使用（当然也有 MVVM）</p>
<p><img src="/images/14532131812505.jpg" alt=""></p>
<p>而对于嵌入式带有各种传感器的应用，一般是这样的架构：</p>
<p><img src="/images/14532132171147.jpg" alt=""></p>
<p>Architectural Styles 是软件系统设计的经验准则，需要更少的领域相关的内容。不同的风格之间是可以共存的。一些基本属性：</p>
<ul>
<li>设计元素的词汇表<ul>
<li>包括组件类型，连接器类型，数据元素等等</li>
<li>例如：pipes, filters, objects, servers</li>
</ul>
</li>
<li>一组配置规则<ul>
<li>不同组件间的限制与拓扑规则</li>
<li>例如：一个组件在当前条件下最多只能和其他两个组件相连</li>
</ul>
</li>
<li>语义描述<ul>
<li>设计的组件需要有意义</li>
</ul>
</li>
</ul>
<p>使用 Styles 的好处有很多，例如：</p>
<ul>
<li>设计重用</li>
<li>代码重用</li>
<li>系统组织容易理解</li>
<li>Interoperability：也就是互用性</li>
<li>特定风格分析</li>
<li>可视化</li>
</ul>
<p>一些可以问自己的问题：</p>
<ul>
<li>What is the design vocabulary?</li>
<li>What are the allowable strucural patterns?</li>
<li>What is the underlying computational model?</li>
<li>What are the essential invariants of the style?</li>
<li>What are common examples of its use?</li>
<li>What are the (dis)advantages of using the style?</li>
<li>What are the style’s specializations?</li>
</ul>
<p>一些比较常见的风格（保证准确这里不翻译）：</p>
<ul>
<li>Traditional, language-influenced styles<ul>
<li>Main program and subroutines</li>
<li>Object-oriented</li>
</ul>
</li>
<li>Layered<ul>
<li>Virtual machines</li>
<li>Client-server</li>
<li>MVC</li>
</ul>
</li>
<li>Data-flow styles<ul>
<li>Batch sequential</li>
<li>Pipe and filter</li>
</ul>
</li>
<li>Shared memory<ul>
<li>Blackboard</li>
<li>Rule based</li>
<li>MapReduce</li>
</ul>
</li>
<li>Interpreter<ul>
<li>Interpreter</li>
<li>Mobile code</li>
</ul>
</li>
<li>Implicit invocation<ul>
<li>Event-based</li>
<li>Publish-subscribe</li>
</ul>
</li>
<li>Peer-to-peer </li>
<li>“Derived” styles <ul>
<li>C2</li>
<li>CORBA</li>
<li>SOA</li>
</ul>
</li>
</ul>
<p>至此这一讲的内容就结束了，后面会详细说明不同风格。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有了前面的基本概念和第一次作业的练习，这一讲我们主要来看看如何设计架构。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 习题课 1 Datalab]]></title>
    <link href="http://wdxtub.com/2016/01/18/csapp-lab1/"/>
    <id>http://wdxtub.com/2016/01/18/csapp-lab1/</id>
    <published>2016-01-18T13:01:12.000Z</published>
    <updated>2016-01-22T20:35:58.000Z</updated>
    <content type="html"><![CDATA[<p>这一讲主要是介绍第一次作业 Datalab 的相关内容以及解法，还包括如何在远程机器上编写代码和测试。</p>
<a id="more"></a>
<hr>
<p>我们先来看看 Datalab 需要我们做什么。主要是通过这次的作业来熟悉整型及浮点数的位表达形式，简单来说，就是解开一些人工谜题。列表如下：</p>
<p><img src="/images/csapp28.jpg" alt="csapp28"></p>
<p><img src="/images/csapp29.jpg" alt="csapp29"></p>
<p><img src="/images/csapp30.jpg" alt="csapp30"></p>
<p>一共 13 个需要补充的函数（会在后面分别详细说明），要开始做 lab，有以下四个步骤（针对 CMU 学生）</p>
<ol>
<li>从 Autolab 下载 lab 文件和文档</li>
<li>lab 的代码需要在远程机器上执行，需要解压文件（可能还需要修改权限 <code>chmod xxx filename</code>）</li>
<li>修改 <code>bits.c</code> 文件，测试的话有三种方式：<code>btest</code>, <code>dlc</code>, 和 <code>BDD checker</code>，另外 <code>driver.pl</code> 是 autolab 将要进行的测试</li>
<li>有无限次提交，但是不要用 autolab 来当做测试的方式，用 <code>driver.pl</code> 测试，Autolab 需要在网页端提交（使用 <code>tar -cvzf out.tar.gz file1 file2 ...</code> 这样来压缩，可以 tcp 赋复制到自己的电脑中）</li>
</ol>
<p>一些小技巧：</p>
<ul>
<li>在函数开始时声明所有变量</li>
<li><code>}</code> 应该在第一列</li>
<li>注意运算符号的优先级，使用括号确保顺序的正确</li>
<li>关注 !, 0, TMin 等</li>
</ul>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们先登录到远程机器，命令为 <code>ssh -X dawang@shark.ics.cs.cmu.edu</code>，输入密码后可以看到如下界面</p>
<p><img src="/images/csapp31.jpg" alt="csapp31"></p>
<p>然后另开一个终端，把之前下载好的 <code>datalab-handout.tar</code> 传到服务器上，命令是 <code>scp datalab-handout.tar dawang@shark.ics.cs.cmu.edu:</code></p>
<p><img src="/images/csapp32.jpg" alt="csapp32"></p>
<p>可以看到上吗有一些我之前课程的内容，我们创建一个新的文件夹 <code>513</code> 并把这个压缩包移动进去</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="number">513</span></span><br><span class="line">mv datalab-handout.tar ./<span class="number">513</span></span><br><span class="line">clear <span class="comment"># 让屏幕向后翻一页，看得更清楚一些</span></span><br></pre></td></tr></table></figure>
<p>这里稍微啰嗦一点，如果想要一边改动文件，然后一边编译测试的话，可以开启两个终端连接到远程机器上，这样就不用切换来切换去了。</p>
<p>解压这次试验所需的文件： <code>tar xvf datalab-handout.tar</code></p>
<p><img src="/images/csapp33.jpg" alt="csapp33"></p>
<p>这次的作业主要是在 <code>bits.c</code> 文件里完成，我们来看看里面的内容 <code>vim bits.c</code></p>
<p><img src="/images/csapp34.jpg" alt="csapp34"></p>
<p>任务指引还是比较清晰的，主要有以下一些说明：</p>
<ol>
<li>整型的范围是 0 到 255(0xFF)，不允许用更大</li>
<li>只能包含参数和局部变量</li>
<li>一元操作符 <code>!</code> <code>~</code></li>
<li>二元操作符 <code>&amp;</code> <code>|</code> <code>+</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code></li>
</ol>
<p>不允许的操作有：</p>
<ol>
<li>使用任何条件控制语句</li>
<li>定义和使用宏</li>
<li>定义其他的函数</li>
<li>调用函数</li>
<li>使用其他的操作符</li>
<li>使用类型转换</li>
<li>使用除 int 之外的类型（针对整型）</li>
<li>使用除 int, unsigned 之外的类型（针对浮点数）</li>
</ol>
<p>可以认为机器：</p>
<ul>
<li>使用 2’s complent，32位</li>
<li>执行算术右移</li>
<li>移动超过字长的位数会出问题</li>
</ul>
<p>其他需要注意的事情有：</p>
<ol>
<li>使用 dlc(data lab checker) 来检测代码的合法性（有没有使用不给使用的符号语法等等）</li>
<li>每个函数都有操作数的上限值，注意 <code>=</code> 不算</li>
<li>使用 btest 来测试结果的正确与否</li>
<li>使用 BDD checker 来正规测试你的函数</li>
</ol>
<h2 id="u9898_u76EE_u53CA_u89E3_u6CD5"><a href="#u9898_u76EE_u53CA_u89E3_u6CD5" class="headerlink" title="题目及解法"></a>题目及解法</h2><h3 id="thirdBits"><a href="#thirdBits" class="headerlink" title="thirdBits"></a>thirdBits</h3><ul>
<li>题目要求：return word with every third bit (starting from the LSB) set to 1</li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：8</li>
<li>分值：1</li>
</ul>
<p>我们返回的结果是：<code>0100 1001 0010 0100 1001 0010 0100 1001</code>，因为题目要求每个变量不可以超过 255，也就是最多 <code>1111 1111</code>，所以只能分步骤来进行组合，如下面代码所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Desired output: <span class="number">0100</span> <span class="number">1001</span> <span class="number">0010</span> <span class="number">0100</span> <span class="number">1001</span> <span class="number">0010</span> <span class="number">0100</span> <span class="number">1001</span> </span><br><span class="line">Step <span class="number">1</span>:         <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0100</span> <span class="number">1001</span>  <span class="number">0x49</span></span><br><span class="line">Step <span class="number">2</span>:         <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1001</span> <span class="number">0010</span> <span class="number">0000</span> <span class="number">0000</span>  Shift &lt;&lt; <span class="number">9</span></span><br><span class="line">Step <span class="number">3</span>:         <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1001</span> <span class="number">0010</span> <span class="number">0100</span> <span class="number">1001</span>  Add <span class="number">0x49</span></span><br><span class="line">Step <span class="number">4</span>:         <span class="number">0100</span> <span class="number">1001</span> <span class="number">0010</span> <span class="number">0100</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span>  Shift &lt;&lt; <span class="number">18</span></span><br><span class="line">Step <span class="number">5</span>:         <span class="number">0100</span> <span class="number">1001</span> <span class="number">0010</span> <span class="number">0100</span> <span class="number">1001</span> <span class="number">0010</span> <span class="number">0100</span> <span class="number">1001</span>  Add result from step <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thirdBits</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0x49</span>;</span><br><span class="line">  <span class="keyword">int</span> b = (a &lt;&lt; <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">int</span> c = b + a;</span><br><span class="line">  <span class="keyword">return</span> (c &lt;&lt; <span class="number">18</span>) + c; <span class="comment">// Steps 4 and 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们来测试一下正确性，先保存代码，然后：<code>make; ./btest</code>，结果如下：</p>
<p><img src="/images/csapp35.jpg" alt="csapp35"></p>
<p>可以看到第一个函数已经写对的得到了一分，然后我们再来检测一下有没有用非法的操作符：<code>./dlc -e bits.c</code></p>
<p><img src="/images/csapp36.jpg" alt="csapp36"></p>
<p>可以看到没有显示错误信息，<code>-e</code> 会输出操作符的数量，这里也都没有问题。接下来的题目都会用这种方式测试，但是就不会再贴图了。</p>
<h3 id="isTmin"><a href="#isTmin" class="headerlink" title="isTmin"></a>isTmin</h3><ul>
<li>题目要求：returns 1 if x is the minimum, two’s complement number, and 0 otherwise</li>
<li>允许操作：<code>! ~ &amp; ^ | +</code></li>
<li>操作数限制：10</li>
<li>分值：1</li>
</ul>
<p>根据 2’s complement 的定义，Tmin 的值是 <code>10000000 00000000 00000000 00000000</code>，我们要怎么判断一个数是不是 Tmin 呢，原则上来说，只需要把 x 和 Tmin 做 <code>&amp;</code> 操作，判断即可，但是题目要求不能左移，于是就要想其他的办法了，观察 Tmin 的值，发现如果左移一次，就变成全部为 0，但是全部为零的情况还有另外一种就是本身全部就是 0，所以只要排除第二种情况，就可以判断是否是 Tmin 了，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面一部分用于判断左移一位后是否全部为0，后面一部分用来判断 x 值是否为 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmin</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> !(x+x)&amp;!!(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="isNotEqual"><a href="#isNotEqual" class="headerlink" title="isNotEqual"></a>isNotEqual</h3><ul>
<li>题目要求：return 0 if x == y, and 1 otherwise <ul>
<li>例如: isNotEqual(5,5) = 0, isNotEqual(4,5) = 1</li>
</ul>
</li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：6</li>
<li>分值：2</li>
</ul>
<p>这题比较简单，发现可以使用异或操作，那么只需要判断两个数异或后结果是否为 0 即可，这里同样使用了 !! 来把 bit 转换成 boolean 值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isNotEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>(!!(x ^ y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="anyOddBit"><a href="#anyOddBit" class="headerlink" title="anyOddBit"></a>anyOddBit</h3><ul>
<li>题目要求：return 1 if any odd-numbered bit in word set to 1<ul>
<li>例如： anyOddBit(0x5) = 0, anyOddBit(0x7) = 1</li>
</ul>
</li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：12</li>
<li>分值：2</li>
</ul>
<p>我们依旧不能超过 0xFF 的限制，所以需要把前面的 24 位都用 <code>|</code> 和 <code>&gt;&gt;</code> 运算符移动到最后八位中，再和 <code>10101010</code> 来做 <code>&amp;</code> 操作，只要不为零，就说明在偶数位上有不为 0 位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anyOddBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !!((x | (x &gt;&gt; <span class="number">8</span>) | (x &gt;&gt; <span class="number">16</span>) | (x &gt;&gt; <span class="number">24</span>)) &amp; <span class="number">0xaa</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><ul>
<li>题目要求：return -x<ul>
<li>例如：negate(1) = -1. </li>
</ul>
</li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：5</li>
<li>分值：2</li>
</ul>
<p>第一感觉就是用到取反 <code>~</code> 符号，但需要考虑三种情况：正，零，负</p>
<ul>
<li>假设是 <code>0010</code>(2)，取反之后是 <code>1101</code>(-3)</li>
<li>假设是 <code>1110</code>(-2)，取反之后是 <code>0001</code>(1)</li>
<li>假设是 <code>0000</code>(0)，取反之后是 <code>1111</code>(-1) </li>
</ul>
<p>可以发现一个规律，就是都差 1，为什么呢，就是因为 2’s complement 的定义中是加上了 1 的，所以只要再加一就好。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h3><ul>
<li>题目要求：same as x ? y : z<ul>
<li>例如：conditional(2,4,5) = 4 </li>
</ul>
</li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：16</li>
<li>分值：3</li>
</ul>
<p>这一题稍微有一些复杂，我们来看看怎么去想。因为不能用 if 来做流程判断，所以我们返回的表达式例一定要包含 y 和 z，但是可以根据 x 的值来进行变换，所以大概的式子是 <code>(y op expr) | (z op expr)</code>(op 表示操作符， expr 是某个表达式)。</p>
<p>然后就简单很多了，我们只要想办法做一个 expr，要么为 <code>0x00000000</code>，要么为 <code>0xffffffff</code> 即可，于是表达式 <code>~!x + 1</code> 就可以满足我们的需求，x 为 0 时，表达式为 <code>0xffffffff</code>，不等于 0 时也满足条件，就等于有了答案</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     *if x!=0,mask=0x00000000,so y&amp;~mask==y and z&amp;mask==0</span><br><span class="line">     *if x==0,mask=0xffffffff,so y&amp;~mask = y&amp;0 =0; z&amp;mask=z</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">int</span> mask= ~!x+<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">return</span> (y &amp; ~mask)|(z &amp; mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="subOK"><a href="#subOK" class="headerlink" title="subOK"></a>subOK</h3><ul>
<li>题目要求：Determine if can compute x-y without overflow<ul>
<li>例如：</li>
<li>subOK(0x80000000,0x80000000) = 1</li>
<li>subOK(0x80000000,0x70000000) = 0</li>
</ul>
</li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：20</li>
<li>分值：3</li>
</ul>
<p>这题也不算轻松，但是我们可以一步一步来搞定，首先，既然是计算 x-y，我们要能够知道结果，由于不给使用减号，那就用倒数（之前的方法），所以 x-y 的结果为 <code>~y+1+x</code>。然后需要怎么判断呢，观察发现，只有在以下这两种情况同时发生的时候，才是 overflow</p>
<ol>
<li>x 和 y 符号不同</li>
<li>x-y 的符号和 x 不同</li>
</ol>
<p>可能有点难以理解，overflow 指的是除符号位的最高位进位，也就是说符号会变化，所以需要 x 和 y 的符号不同（这样 x-y 就等同于两个同符号的加法），也就是第一个条件；符号到底有没有变化呢，就要看 x-y 与 x 的符号是否相同，也就是第二个条件。所以代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subOK</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * overflow of sub happens iff </span><br><span class="line">   * 1) x and y have different signs</span><br><span class="line">   * 2) res = x - y has different sign with x</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">int</span> res = x + (~y + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> sameSign = x ^ y;</span><br><span class="line">  <span class="keyword">int</span> resSign = res ^ x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> !((sameSign &amp; resSign) &gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="isGreater"><a href="#isGreater" class="headerlink" title="isGreater"></a>isGreater</h3><ul>
<li>题目要求：if x &gt; y  then return 1, else return 0<ul>
<li>例如：isGreater(4,5) = 0, isGreater(5,4) = 1</li>
</ul>
</li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：24</li>
<li>分值：3</li>
</ul>
<p>因为要考虑正负号，所以这个问题变成：</p>
<ol>
<li>两个数符号相同的情况</li>
<li>两个数符号不同的情况</li>
</ol>
<p>具体可以参见代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isGreater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="comment">// Boolean value indicating sign of x</span></span><br><span class="line">        <span class="comment">// 1 = Negative</span></span><br><span class="line">        <span class="comment">// 0 = Non-Negative</span></span><br><span class="line">        <span class="keyword">int</span> sign_x = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Boolean value indicating sign of y</span></span><br><span class="line">        <span class="comment">// 1 = Negative</span></span><br><span class="line">        <span class="comment">// 0 = Non-Negative</span></span><br><span class="line">        <span class="keyword">int</span> sign_y = y &gt;&gt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if the signs are equal, then</span></span><br><span class="line">	<span class="comment">// if x is larger, sign bit of (~y + x) is 0</span></span><br><span class="line">	<span class="comment">// if y is larger, sign bit of (~y + x) is 1</span></span><br><span class="line">	<span class="keyword">int</span> equal = !(sign_x ^ sign_y) &amp; ((~y + x) &gt;&gt; <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if signs are not equal, these principles are reversed.</span></span><br><span class="line">	<span class="keyword">int</span> notEqual = sign_x &amp; !sign_y;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// this | returns 0 when it is x is greater, so you have to negate it.</span></span><br><span class="line">	<span class="keyword">return</span> !( equal | notEqual);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bitParity"><a href="#bitParity" class="headerlink" title="bitParity"></a>bitParity</h3><ul>
<li>题目要求：returns 1 if x contains an odd number of 0’s<ul>
<li>例如：bitParity(5) = 0, bitParity(7) = 1</li>
</ul>
</li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：20</li>
<li>分值：4</li>
</ul>
<p>这道题要我们统计有有多少个零，这里我们需要利用一个特点，就是堆两个数进行异或操作，不改变奇偶性，所以只需要一步一步来异或就可以了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitParity</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* XORing two numbers returns a number with same bit parity.</span><br><span class="line">     Keep shifting half of our number until reduced to 1 bit simple case.*/</span></span><br><span class="line"></span><br><span class="line">  x = ( x &gt;&gt; <span class="number">16</span> ) ^ x;</span><br><span class="line">  x = ( x &gt;&gt; <span class="number">8</span> ) ^ x;</span><br><span class="line">  x = ( x &gt;&gt; <span class="number">4</span> ) ^ x;</span><br><span class="line">  x = ( x &gt;&gt; <span class="number">2</span> ) ^ x;</span><br><span class="line">  x = ( x &gt;&gt; <span class="number">1</span>) ^ x;</span><br><span class="line">  <span class="keyword">return</span> (x &amp; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h3><ul>
<li>题目要求：return the minimum number of bits required to represent x in two’s complement<ul>
<li>例如：</li>
<li>howManyBits(12) = 5</li>
<li>howManyBits(298) = 10</li>
<li>howManyBits(-5) = 4</li>
<li>howManyBits(0)  = 1</li>
<li>howManyBits(-1) = 1</li>
<li>howManyBits(0x80000000) = 32</li>
</ul>
</li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：90</li>
<li>分值：4</li>
</ul>
<p>这题从操作数限制的数目来看就知道比较复杂，但是代码还是比较清晰的，可以直接查看代码中的注释（特别鸣谢：@guojiex）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=x^(x&gt;&gt;<span class="number">31</span>);<span class="comment">//get positive of x;</span></span><br><span class="line">    <span class="keyword">int</span> isZero=!temp;</span><br><span class="line">    <span class="comment">//notZeroMask is 0xffffffff</span></span><br><span class="line">    <span class="keyword">int</span> notZeroMask=(!(!temp)&lt;&lt;<span class="number">31</span>)&gt;&gt;<span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> bit_16,bit_8,bit_4,bit_2,bit_1;</span><br><span class="line">    bit_16=!(!(temp&gt;&gt;<span class="number">16</span>))&lt;&lt;<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//see if the high 16bits have value,if have,then we need at least 16 bits</span></span><br><span class="line">    <span class="comment">//if the highest 16 bits have value,then rightshift 16 to see the exact place of  </span></span><br><span class="line">    <span class="comment">//if not means they are all zero,right shift nothing and we should only consider the low 16 bits</span></span><br><span class="line">    temp=temp&gt;&gt;bit_16;</span><br><span class="line">    bit_8=!(!(temp&gt;&gt;<span class="number">8</span>))&lt;&lt;<span class="number">3</span>;</span><br><span class="line">    temp=temp&gt;&gt;bit_8;</span><br><span class="line">    bit_4=!(!(temp&gt;&gt;<span class="number">4</span>))&lt;&lt;<span class="number">2</span>;</span><br><span class="line">    temp=temp&gt;&gt;bit_4;</span><br><span class="line">    bit_2=!(!(temp&gt;&gt;<span class="number">2</span>))&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    temp=temp&gt;&gt;bit_2;</span><br><span class="line">    bit_1=!(!(temp&gt;&gt;<span class="number">1</span>));</span><br><span class="line">    temp=bit_16+bit_8+bit_4+bit_2+bit_1+<span class="number">2</span>;<span class="comment">//at least we need one bit for 1 to tmax,</span></span><br><span class="line">    <span class="comment">//and we need another bit for sign</span></span><br><span class="line">    <span class="keyword">return</span> isZero|(temp&amp;notZeroMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="float_half"><a href="#float_half" class="headerlink" title="float_half"></a>float_half</h3><ul>
<li>题目要求：Return bit-level equivalent of expression (float) x. Result is returned as unsigned int, but it is to be interpreted as the bit-level representation of a single-precision floating point values.</li>
<li>允许操作：Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</li>
<li>操作数限制：30</li>
<li>分值：4</li>
</ul>
<p>这个就是考察基本的对于 IEEE 浮点数格式的转换了，思路也比较清晰，就是根据不同的部分来求出对应的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_half</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> round, S, E, maskE, maskM, maskS,maskEM, maskSM, tmp;</span><br><span class="line">  round = !((uf&amp;<span class="number">3</span>)^<span class="number">3</span>);</span><br><span class="line">  maskS = <span class="number">0x80000000</span>;</span><br><span class="line">  maskE = <span class="number">0x7F800000</span>;</span><br><span class="line">  maskM = <span class="number">0x007FFFFF</span>;</span><br><span class="line">  maskEM= <span class="number">0x7FFFFFFF</span>;</span><br><span class="line">  maskSM= <span class="number">0x807FFFFF</span>;</span><br><span class="line">  E = uf&amp;maskE;</span><br><span class="line">  S = uf&amp;maskS;</span><br><span class="line">  <span class="comment">//Nan or Infinity</span></span><br><span class="line">  <span class="keyword">if</span> (E==<span class="number">0x7F800000</span>) <span class="keyword">return</span> uf;</span><br><span class="line">  <span class="comment">//E=1 - specialcase</span></span><br><span class="line">  <span class="keyword">if</span> (E==<span class="number">0x00800000</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> S | (round + ((uf &amp; maskEM)&gt;&gt;<span class="number">1</span>)) ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//E=0 - denormalized</span></span><br><span class="line">  <span class="keyword">if</span> (E==<span class="number">0x00000000</span>) &#123;</span><br><span class="line">    tmp = (uf&amp;maskM)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> S | (tmp + round);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//normalized case</span></span><br><span class="line">  <span class="keyword">return</span> (((E&gt;&gt;<span class="number">23</span>)-<span class="number">1</span>)&lt;&lt;<span class="number">23</span>) | (uf &amp; maskSM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="float_i2f"><a href="#float_i2f" class="headerlink" title="float_i2f"></a>float_i2f</h3><ul>
<li>题目要求：Return bit-level equivalent of expression (float) x. Result is returned as unsigned int, but it is to be interpreted as the bit-level representation of a single-precision floating point values.</li>
<li>允许操作：Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</li>
<li>操作数限制：30</li>
<li>分值：4</li>
</ul>
<p>和上题一样，这个就是考察基本的对于 IEEE 浮点数格式的转换了，思路也比较清晰，就是根据不同的部分来求出对应的值（特别鸣谢@guojiex）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_i2f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*int exponent=0;</span><br><span class="line">    return ((sign&lt;&lt;31)|(exponent&lt;&lt;23)|fraction)+flag;*/</span></span><br><span class="line">    <span class="keyword">int</span> sign=x&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> exponent; </span><br><span class="line">    <span class="keyword">int</span> fraction; </span><br><span class="line">    <span class="keyword">int</span> delta;</span><br><span class="line">    <span class="keyword">int</span> fraction_mask;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)<span class="comment">//||x==0x8000000)</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0x80000000</span>)</span><br><span class="line">        exponent=<span class="number">158</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sign)<span class="comment">//turn negtive to positive</span></span><br><span class="line">            x = -x;</span><br><span class="line">        i = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">while</span> ( !(x &gt;&gt; i) )<span class="comment">//see how many bits do x have(rightshift until 0) </span></span><br><span class="line">            i--;</span><br><span class="line">        <span class="comment">//printf("%x %d\n",x,i);</span></span><br><span class="line">        exponent = i + <span class="number">127</span>;</span><br><span class="line">        x = x &lt;&lt; (<span class="number">31</span> - i);<span class="comment">//clean all those zeroes of high bits</span></span><br><span class="line">        fraction_mask = <span class="number">0x7fffff</span>;<span class="comment">//(1 &lt;&lt; 23) - 1;</span></span><br><span class="line">        fraction = fraction_mask &amp; (x &gt;&gt; <span class="number">8</span>);<span class="comment">//right shift 8 bits to become the fraction,sign and exp have 8 bits total</span></span><br><span class="line">        x = x &amp; <span class="number">0xff</span>;</span><br><span class="line">        delta = x &gt; <span class="number">128</span> || ((x == <span class="number">128</span>) &amp;&amp; (fraction &amp; <span class="number">1</span>));<span class="comment">//if lowest 8 bits of x is larger than a half,or is 1.5,round up 1</span></span><br><span class="line">        fraction += delta;</span><br><span class="line">        <span class="keyword">if</span>(fraction &gt;&gt; <span class="number">23</span>) &#123;<span class="comment">//if after rounding fraction is larger than 23bits</span></span><br><span class="line">            fraction &amp;= fraction_mask;</span><br><span class="line">            exponent += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (sign&lt;&lt;<span class="number">31</span>)|(exponent&lt;&lt;<span class="number">23</span>)|fraction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="float_f2i"><a href="#float_f2i" class="headerlink" title="float_f2i"></a>float_f2i</h3><ul>
<li>题目要求：Return bit-level equivalent of expression (int) f for floating point argument f. Argument is passed as unsigned int, but it is to be interpreted as the bit-level representation of a single-precision floating point value. Anything out of range (including NaN and infinity) should return 0x80000000u.</li>
<li>允许操作：Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</li>
<li>操作数限制：30</li>
<li>分值：4</li>
</ul>
<p>和上题一样，这个就是考察基本的对于 IEEE 浮点数格式的转换了，思路也比较清晰，就是根据不同的部分来求出对应的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">float_f2i</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">  <span class="keyword">int</span> frac = uf &amp; <span class="number">0x007FFFFF</span>;</span><br><span class="line">  <span class="keyword">int</span> sign = uf &amp; <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="keyword">int</span> bias = <span class="built_in">exp</span> - <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">255</span> || bias &gt; <span class="number">30</span>) &#123;</span><br><span class="line">    <span class="comment">// exponent is 255 (NaN), or number is too large for an int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">exp</span> || bias &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// number is very small, round down to 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// append a 1 to the front to normalize</span></span><br><span class="line">  frac = frac | <span class="number">1</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// float based on the bias</span></span><br><span class="line">  <span class="keyword">if</span> (bias &gt; <span class="number">23</span>) &#123;</span><br><span class="line">    frac = frac &lt;&lt; (bias - <span class="number">23</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    frac = frac &gt;&gt; (<span class="number">23</span> - bias);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sign) &#123;</span><br><span class="line">    <span class="comment">// original number was negative, make the new number negative</span></span><br><span class="line">    frac = ~(frac) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> frac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u68C0_u67E5_u4E0E_u63D0_u4EA4"><a href="#u68C0_u67E5_u4E0E_u63D0_u4EA4" class="headerlink" title="检查与提交"></a>检查与提交</h2><p>全部题目做完之后，就可以检查一下了，这里我们可以用另外一个命令 <code>./driver.pl</code>，结果如下：</p>
<p><img src="/images/csapp37.jpg" alt="csapp37"></p>
<p>这样就算完成啦，提交的时候只需要提交 <code>bits.c</code> 所以我们先把它从远程主机复制回来 <code>scp dawang@shark.ics.cs.cmu.edu:513/datalab-handout/bits.c ./</code></p>
<p>不用压缩，直接提交即可，检查无误之后，至此本次实验完成。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一讲主要是介绍第一次作业 Datalab 的相关内容以及解法，还包括如何在远程机器上编写代码和测试。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Datalab" scheme="http://wdxtub.com/tags/Datalab/"/>
    
      <category term="习题课" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98%E8%AF%BE/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 5 课 Machine Basics]]></title>
    <link href="http://wdxtub.com/2016/01/18/csapp-5/"/>
    <id>http://wdxtub.com/2016/01/18/csapp-5/</id>
    <published>2016-01-18T13:00:53.000Z</published>
    <updated>2016-01-22T20:36:01.000Z</updated>
    <content type="html"><![CDATA[<p>从这一讲开始，我们接触到更多机器相关的内容，这次要说的是基础知识，为之后更深入讲解打下基础。</p>
<a id="more"></a>
<hr>
<h2 id="Intel__u5904_u7406_u5668_u7B80_u53F2"><a href="#Intel__u5904_u7406_u5668_u7B80_u53F2" class="headerlink" title="Intel 处理器简史"></a>Intel 处理器简史</h2><p>这一讲的部分内容在我之前上过的 18640 Foundation of Computer Architecture 中也有涉及，但是重点不同，这里会结合这两门课的内容做一个简单的介绍。</p>
<p>首先介绍的就是处理器，作为计算机的大脑，虽然有很多种，这里只介绍 Intel x86 架构的处理器。课堂上介绍了 Intel 处理器的大致发展历史和特点，我简要说明一下。</p>
<p>作为统治笔记本桌面电脑服务器市场的处理器，x86 处理器是一个一直在进化的产品，甚至兼容 1978年的 8086 的指令集。值得注意的是，x86 采用的是 Complex instruction set computer(CISC)，之所以称为复杂指令，是因为有许许多多不同格式的不同指令（对应的是 RISC）</p>
<p>整个 Intel x86 的发展史很长，这里提几个关键的时间节点和对应产品：</p>
<ul>
<li>1978 年：8086，第一个 16 位处理器，主要为 IBM PC 和 DOS 设计，有 1MB 的地址空间</li>
<li>1985 年：386，第一个 32 位 Intel 处理器(IA32)，添加了 flat addressing，使得可以运行 Unix</li>
<li>2004 年：Pentium 4E，第一个 64 位 Intel 处理器(x86-64)</li>
<li>2006 年：Core 2，第一个 多核 Intel 处理器</li>
<li>2008 年：Core i7，四核（也就是我们做实验用的机器）</li>
</ul>
<p><img src="/images/14531672465886.jpg" alt=""></p>
<p>随着时代和科技的发展，除了最基本的运算指令集，还有一些其他的特性：</p>
<ul>
<li>增加了支持多媒体操作处理的指令</li>
<li>启用了更加高效的执行条件操作的指令</li>
<li>从 32 位迁移的 64 位</li>
<li>更多的运算核心</li>
</ul>
<p>一个另外的趋势是集成，比如说 2015 年的 Core i7 Broadwell，可以从下图看到处理器芯片中加入了原来主板才有的许多部件，如 PCIe, SATA, DDR3 等等。</p>
<p><img src="/images/14531674473247.jpg" alt=""></p>
<p>顺带说一下千年老二 AMD，主打性价比，研发的 Opteron 系列是 Pentium 4 的强劲对手，并且开发了自己的 64 位拓展 x86-64。但是近年来 Intel 重新找回厂子，AMD 开始打酱油。</p>
<p>Intel 在 64 位处理器的发展并不算顺风顺水，2001 年本打算使用全新的架构快速从 IA32 转换到 IA64，但是糟糕的性能反倒给了 AMD 机会。后者在 2003 年发布的 x86-64(现在叫 AMD64) 架构明显更厉害，搞得 Intel 疲于应战，最后在 2004 年搞出来一个叫 EM64T 的东西，其实几乎和 AMD64 一样。现在除了某些低端的处理器，几乎都支持 x86-64，这也是这门课主要要讲的内容。</p>
<h2 id="C__u8BED_u8A00_uFF0C_u6C47_u7F16_u548C_u673A_u5668_u4EE3_u7801"><a href="#C__u8BED_u8A00_uFF0C_u6C47_u7F16_u548C_u673A_u5668_u4EE3_u7801" class="headerlink" title="C 语言，汇编和机器代码"></a>C 语言，汇编和机器代码</h2><p>先介绍一些定义：</p>
<blockquote>
<p>Architecture: (also ISA, instruction set architecture) The parts of a processor design that one needs to understand or write assembly/machine code. (Examples: instruction set specification, registers)</p>
<p>Microarchitecture: Implementation of the architecture. (Examples: cache sizes and core frequency)</p>
</blockquote>
<ul>
<li>Code Forms:<ul>
<li>Machine Code: The byte-level programs that a processor executes</li>
<li>Assembly Code: A text prepresentation of machine code</li>
</ul>
</li>
<li>Example ISAs:<ul>
<li>Intel: x86, IA32, Itanium, x86-64</li>
<li>ARM: Used in almost all mobile phones</li>
</ul>
</li>
</ul>
<p><img src="/images/14531688992654.jpg" alt=""></p>
<p>现在简单介绍下几个比较重要的部分：</p>
<ul>
<li>PC: Program counter，里面存着下一条指令的地址，在 x86-64 中称为 RIP</li>
<li>Register: 寄存器，用来存储数据以便操作</li>
<li>Codition codes: 条件代码，通常保存最近的算术或逻辑操作的信息，用来做条件跳转</li>
<li>Memory: 内存，有地址数组，代码和用户数据，以及栈</li>
</ul>
<p>我们知道机器只能执行机器代码，我们写的 C 语言代码是如何成为机器代码的呢？可以参见下图：</p>
<p><img src="/images/14531691105504.jpg" alt=""></p>
<p>这里的 <code>-Og</code> <code>-S</code> 是编译器的参数，意思是进行不那么优化的优化（这样我们才能看得懂编译出来的汇编语言）以及汇编完输出汇编结果。</p>
<p>我们有如左图所示的代码，使用命令 <code>gcc -Og -S sum.c</code> 就可以产生 <code>sum.s</code> 文件，我们来对比看一下。（注意不同的平台不同的编译器不同的参数会有不同的结果，和下图可能差别很大）</p>
<p><img src="/images/14531692047447.jpg" alt=""></p>
<p>这里先不展开讲每条指令是做什么的，先来说说汇编语言的数据类型</p>
<ul>
<li>整型：有 1，2，4，8 个字节，可以存数据，也可以存地址（地址是无类型的指针）</li>
<li>浮点数：有 4，8，10 个字节，和整型分不同的寄存器</li>
<li>代码：由一系列指令编码而成的字节序列</li>
<li>注意，是没有类似数组和结构体这种组合的，这些其实都只是在内存中连续分配的字节</li>
</ul>
<p>能够执行的操作也很有限：</p>
<ul>
<li>对寄存器或者内存中的数据执行算术运算</li>
<li>在内存和寄存器之间传输数据</li>
<li>传输控制（非条件跳转和条件分支）</li>
</ul>
<p><img src="/images/14531700919485.jpg" alt=""></p>
<p>汇编器会把 <code>.s</code> 文件转换成 <code>.o</code>，把每条指令转换成二进制代码，基本上就是可以执行的代码了，除了不同文件的连接之外。</p>
<p>连接器会把不同文件之间的引用处理好，顺带也会吧静态库给连接进去（例如 <code>malloc</code> <code>printf</code> 的代码），注意，有些代码是动态连接的，也就是在执行时才连接，这样就可以减少一些编译出来的文件大小。</p>
<p>举个例子</p>
<p><img src="/images/14531703812373.jpg" alt=""></p>
<p>除了汇编，还可以反汇编，<code>objdum -d sum</code> 比如：</p>
<p><img src="/images/14531704316866.jpg" alt=""></p>
<p>反汇编有什么用呢：</p>
<ul>
<li>检查代码</li>
<li>分析指令的结构模式</li>
<li>生成近似的汇编代码</li>
<li>可以对 <code>a.out</code> 或者 <code>.o</code> 文件进行反汇编</li>
<li>注意，有些软件的用户协议里说明是不能反编译的，例如：windows</li>
</ul>
<h2 id="u6C47_u7F16_u57FA_u7840"><a href="#u6C47_u7F16_u57FA_u7840" class="headerlink" title="汇编基础"></a>汇编基础</h2><p>先来看看 x86-64 的整型寄存器</p>
<p><img src="/images/14531710081185.jpg" alt=""></p>
<p>发现其实大的里面还包含小的（灰色部分），为什么呢？看看 IA32 的架构就明白了</p>
<p><img src="/images/14531716085778.jpg" alt=""></p>
<p>发现没有？%rsp 里面包含 %esp，%esp 里面又包含 %sp，这样就保证了可以从 64 位兼容 32 位再到最初的 16 位，是不是很精妙的设计？</p>
<h3 id="u79FB_u52A8_u6570_u636E"><a href="#u79FB_u52A8_u6570_u636E" class="headerlink" title="移动数据"></a>移动数据</h3><p>操作数主要有三种类型，一种是立即数，也就是直接给的一个数字，第二种是寄存器，第三种是内存</p>
<p><img src="/images/14531723678160.jpg" alt=""></p>
<h3 id="u5BFB_u5740"><a href="#u5BFB_u5740" class="headerlink" title="寻址"></a>寻址</h3><p>普通模式，(R)，相当于 <code>Mem[Reg[R]]</code>，也就是说寄存器 R 指定内存地址，类似于 C 语言中的指针，语法为：<code>movq (%rcx), %rax</code> 也就是说以 %rcx 寄存器中存储的地址去内存里找对应的数据，存到寄存器 %rax 中</p>
<p>移位模式，D(R)，相当于 <code>Mem[Reg[R]+D]</code>，寄存器 R 给出起始的内存地址，然后 D 是偏移量，语法为：<code>movq 8(%rbp),%rdx</code> 也就是说以 %rbp 寄存器中存储的地址再加上 8 个偏移量去内存里找对应的数据，存到寄存器 %rdx 中</p>
<p>举个交换两个数字的例子</p>
<p><img src="/images/14531730491322.jpg" alt=""></p>
<p>前面的两种属于简单模式，完整的更通用的模式是这样的：</p>
<p><img src="/images/14531733075157.jpg" alt=""></p>
<p>举个例子：%rdx 的存着的地址是 0xf000；%rcx 的存着的地址是 0x0100，那么有：</p>
<p><img src="/images/14531733728296.jpg" alt=""></p>
<h2 id="u7B97_u672F_u8FD0_u7B97_u4E0E_u903B_u8F91_u8FD0_u7B97"><a href="#u7B97_u672F_u8FD0_u7B97_u4E0E_u903B_u8F91_u8FD0_u7B97" class="headerlink" title="算术运算与逻辑运算"></a>算术运算与逻辑运算</h2><p>一条比较重要的指令是 <code>leaq Src, Dst</code>，其中 <code>Src</code> 是地址的表达式，然后把计算的值存入 <code>Dst</code> 指定的寄存器，也就是说，无须内存引用就可以计算，类似于 <code>p = &amp;x[i];</code></p>
<p>举个例子：</p>
<p><img src="/images/14531767663611.jpg" alt=""></p>
<p>可以看到是直接对 %rdi 寄存器中存的地址所对应的内存例的数据进行操作。</p>
<p>一些常见的算术运算指令如下，注意参数的顺序，而且对于有符号和无符号数都是一样的：</p>
<p><img src="/images/14531768882688.jpg" alt=""></p>
<p><img src="/images/14531768992534.jpg" alt=""></p>
<p>更多的信息可以参考书籍和对应的文档。</p>
<p>再来看一个例子：</p>
<p><img src="/images/14531769425822.jpg" alt=""></p>
<p>对应的语句和寄存器的值如下（确保弄明白整个过程）：</p>
<p><img src="/images/14531769778782.jpg" alt=""></p>
<p>这一讲的内容到这里就这么多，其实还是需要比较多基础知识才好理解，尤其是汇编这部分，可以去网上找一下可视化的寄存器及内存数据交换过程看看，增加了解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从这一讲开始，我们接触到更多机器相关的内容，这次要说的是基础知识，为之后更深入讲解打下基础。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="基础" scheme="http://wdxtub.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 4 课 Floating Point]]></title>
    <link href="http://wdxtub.com/2016/01/18/csapp-4/"/>
    <id>http://wdxtub.com/2016/01/18/csapp-4/</id>
    <published>2016-01-18T13:00:49.000Z</published>
    <updated>2016-01-22T20:36:06.000Z</updated>
    <content type="html"><![CDATA[<p>了解了数据在内存中的基本存储形式，同时也知道了整型的表达方法，这一讲我们来看看另一大类别的数字——浮点数——是如何在计算机中表示的。</p>
<a id="more"></a>
<hr>
<p>二进制浮点数的表示，其实和我们日常生活中常见的十进制的方式是一致的，都是相当于每一位的系数，乘以每一位的数值，然后把结果加起来，如下图所示：</p>
<p><img src="/images/csapp13.jpg" alt="csapp13"></p>
<p>所以我们其实可以用一个统一的公式来表达：</p>
<p>$$ \sum_{k=-j}^ib_k\times 2^k $$</p>
<p>例如</p>
<p>$$ 5\frac{3}{4}=101.11_2 \;,\; 2\frac{7}{8}=10.111_2 \;,\; 1\frac{7}{16}=1.0111_2 $$</p>
<p>可以看到除以二就相当于右移，并且可以横跨小数点。注意 $0.111…_2$ 非常接近于 1，因为 </p>
<p>$$ 1/2 + 1/4 + 1/8 + … + 1/2^i + … \to 1.0$$</p>
<p>通常用 $1.0-\epsilon$ 来表示这个值。</p>
<p>细心的同学就会发现，这种表达方式其实是比较明显的限制的，比如说，只有形为 $\frac{x}{2^k}$ 的小数部分可以被精确表示，其他的数字会变成循环的小数，例如：$\frac{1}{3}=0.0101010101[01]…_2$。</p>
<p>除此之外，另一个问题在于，如果给定了 w 个比特，能够表达的数字其实是有限的。</p>
<h2 id="IEEE_Floating_Point"><a href="#IEEE_Floating_Point" class="headerlink" title="IEEE Floating Point"></a>IEEE Floating Point</h2><p>实话说，这个标准更多是从数值角度来建立的，对于舍入，上溢出和下溢出都有比较好的处理方法，但与此同时，给硬件优化带来了比较大的困难。从理解的角度来看，也不够直观，但是好在主流的 CPU 都支持浮点数，所以我们不必过多涉及这方面的细节，但是了解定义本身还是很重要的。</p>
<p>我们用下面的公式来表达浮点数：</p>
<p>$$(-1)^s \; M \; 2^E$$</p>
<p>其中 s 是符号位，决定正负；M 通常是一个值在 [1.0, 2.0) 的小数；E 是次方数。具体编码的时候是这样的：</p>
<p><img src="/images/csapp14.jpg" alt="csapp14"></p>
<p>其中 s 对应着符号位，exp 对应着 E（注意，不一定等于 E，因为位数限制表达能力有限），frac 对应着 M（注意，不一定等于 M，因为位数限制表达能力有限）。</p>
<p>不同的位数就代表了不同的表示能力，也就是单精度，双精度，扩展精度的来源，具体的位数表示如下：</p>
<p><img src="/images/csapp15.jpg" alt="csapp15"></p>
<h3 id="Normalized_Values"><a href="#Normalized_Values" class="headerlink" title="Normalized Values"></a>Normalized Values</h3><p>在 $exp \ne 000…0$ 和 $exp \ne 111…1$ 时，表示的其实都是规范化的值，为什么说是规范化呢？这里只需要大概知道因为实数轴上原来连续的值会被规范到有限的定值上并且这些定值之间的间距也是不一样的，具体可以通过后面给出的例子来理解（所以现在不明白也不用担心）</p>
<p>$$v=(-1)^s \; M \; 2^E$$</p>
<p>这里的 E 是一个偏移的值 $$E=Exp-Bias$$，其中</p>
<ul>
<li>Exp: 是 exp 编码区域的无符号数值</li>
<li>Bias：值为 $2^{k-1} - 1$ 的偏移量，其中 k 是 exp 编码的位数，也就是说<ul>
<li>单精度：127（Exp: 1…254, E: -126…127）</li>
<li>双精度：1023（Exp: 1…2046, E: -1022…1023）</li>
</ul>
</li>
</ul>
<p>之所以需要采用一个偏移量，是为了保证 exp 编码只需要以无符号数来处理。</p>
<p>而对于 M，一定是以 1 开头的：也就是 $M=1.xxx…x_2$。其中 xxx 的部分就是 frac 的编码部分，当 frac=000.00 的时候值最小（$M=1.0$），当 frac=111。。。1 的时候值最大（$M=2.0-\epsilon$），也就是说开头的 1 是『免费附送的』，并不需要实际的编码位。</p>
<p>举个例子，<code>float F = 15213.0;</code>，那么</p>
<p>$$15213_{10}=11101101101101_2=1.1101101101101_2 \times 2^13$$</p>
<p>于是 frac 部分的值就是小数点后面的数值，而 Exp = E + Bias = 13 + 127 = 140 = $10001100_2$，于是编码出来的浮点数是这样的：</p>
<p><img src="/images/csapp16.jpg" alt="csapp16"></p>
<h3 id="Denormalized_Values"><a href="#Denormalized_Values" class="headerlink" title="Denormalized Values"></a>Denormalized Values</h3><p>当 $exp = 000…0$ 的时候，值是非规范化的，意思是，虽然实数轴上原来连续的值会被规范到有限的定值上，但是并些定值之间的间距也是一样的，具体可以通过后面给出的例子来理解（所以现在不明白也不用担心）</p>
<p>$$v=(-1)^s \; M \; 2^E$$</p>
<p>和前面不同的是 </p>
<p>$$E = 1 - Bias$$</p>
<p>而且 $M=0.xxx…x_2$，不是以 1 开头了。</p>
<p>当 exp=000…0 且 frac = 000…0 时，表示 0，而且因为符号位的缘故，实际上是有 +0 和 -0 两种的。</p>
<p>而在 exp=000..0 且 $frac \ne 000…0$ 时，数值是接近 0 的，并且间距是一致的</p>
<h3 id="Special_Values"><a href="#Special_Values" class="headerlink" title="Special Values"></a>Special Values</h3><p>还有一种特殊情况，就是 $exp = 111…1$ 时，表示一些特殊值。</p>
<p>当 exp=111…1 且 frac = 000…0 时，表示 $\infty$，而且因为符号位的缘故，实际上是有 $+\infty$ 和 $-\infty$ 两种的。那些会溢出的操作就会用这个来表示，比如 $1.0/0.0=-1.0/0.0=+\infty\;,\;1.0/-0.0=-\infty$</p>
<p>而在 exp=111…1 且 $frac \ne 000…0$ 时，我们认为这不是一个数值（Not-a-Number，NaN），用来表示那些没办法确定的值，比如 $sqrt(-1),\infty-\infty,\infty\times 0$</p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>可能通过文字描述还是不够清晰，我们来看看上面各种情况对应到数轴中是怎么样的：</p>
<p><img src="/images/csapp17.jpg" alt="csapp17"><br>（对应理解一下上面所说的内容）</p>
<p>接下来举一个实际的例子，我们的编码形式是这样的：</p>
<p><img src="/images/csapp18.jpg" alt="csapp18"></p>
<p>简单起见，我们用 8 个 bit 来做演示，exp 部分是 4 位，所以 bias=7，后三位用来编码小数。下面列出正数部分的表格：</p>
<p><img src="/images/csapp19.jpg" alt="csapp19"></p>
<p>观察上表，我们可以发现如下一些比较有意思的规律：</p>
<ul>
<li>在 exp=0000 时，也就是 denorm 的情况，间距是一致的，都是 1/8</li>
<li>因为位数的限制，从零到一之间的数字只能以 1/8 为最小单位来表示，且相邻数字间间距一样</li>
<li>在 norm 的部分，可以发现由于 exp 部分的不同，所以相邻数字间的间隔也是不同的，比方说最接近 1 的数字是 15/16 和 9/8，分别相差 1/16 和 1/8，这也是由于 IEEE 浮点数表示法的公式决定的</li>
</ul>
<p>从上面的例子大概了解了值的范围，我们再缩小一点，用 6-bit，来看看具体数值的分布</p>
<p><img src="/images/csapp20.jpg" alt="csapp20"></p>
<p>这里因为 exp 有 3 位，所以 Bias = 3，分布如下</p>
<p><img src="/images/csapp21.jpg" alt="csapp21"></p>
<p>拉近一点（主要是 0 附近）</p>
<p><img src="/images/csapp22.jpg" alt="csapp22"></p>
<p>总结起来，IEEE 编码有以下一些需要注意的性质</p>
<ul>
<li>浮点数的 0 和整型的 0 一样，所有位都是 0</li>
<li>可以使用无符号整型的比较方法来比较大小<ul>
<li>必须先比较符号位</li>
<li>必须考虑 -0=0 的情况</li>
<li>注意 NaN 的情况</li>
<li>其他时候都是没有问题的</li>
</ul>
</li>
</ul>
<h3 id="Rounding"><a href="#Rounding" class="headerlink" title="Rounding"></a>Rounding</h3><p>对于浮点数的加法和乘法来说，基本的思路如下：</p>
<ul>
<li>先计算出准确值</li>
<li>然后转换到合适的精度<ul>
<li>可能会溢出</li>
<li>可能需要舍入来满足 frac 的精度</li>
</ul>
</li>
</ul>
<p>舍入的方式有很多种，举个例子：</p>
<p><img src="/images/csapp23.jpg" alt="csapp23"></p>
<p>舍入到最近的偶数比较特别，中心思想是：舍入之后最右边的值要是偶数，从下面一个例子就可以明白：</p>
<p><img src="/images/csapp24.jpg" alt="csapp24"></p>
<p>对于二进制数也是类似的</p>
<p><img src="/images/csapp25.jpg" alt="csapp25"></p>
<h3 id="u6D6E_u70B9_u6570_u4E58_u6CD5"><a href="#u6D6E_u70B9_u6570_u4E58_u6CD5" class="headerlink" title="浮点数乘法"></a>浮点数乘法</h3><p>$$(-1)^{s1}\; M1 \; 2^{E1} \times (-1)^{s2}\; M2 \; 2^{E2}$$</p>
<p>结果是 $(-1)^{s}\; M \; 2^{E}$，其中 s= s1 ^ s2, M = M1 * M2, E = E1 + E2</p>
<ul>
<li>如果 M 大于等于 2，那么把 M 右移，并增加 E 的值。</li>
<li>如果 E 超出了可以表示的范围，溢出</li>
<li>把 M 舍入到 frac 的精度</li>
</ul>
<p>基本性质</p>
<ul>
<li>相乘可能产生 infinity 或者 NaN</li>
<li>满足交换率</li>
<li>不满足结合律（因为舍入会造成精度损失）</li>
<li>乘以 1 等于原来的数</li>
<li>不满足分配率 <code>1e20*(1e20-1e20)=0.0</code> 但 <code>1e20*1e20-1e20*1e20=NaN</code></li>
<li>除了 infinity 和 NaN，满足单调性，即 $a\ge b \to a\times c \ge a\times b$</li>
</ul>
<h3 id="u6D6E_u70B9_u6570_u52A0_u6CD5"><a href="#u6D6E_u70B9_u6570_u52A0_u6CD5" class="headerlink" title="浮点数加法"></a>浮点数加法</h3><p>$$(-1)^{s1}\; M1 \; 2^{E1} + (-1)^{s2}\; M2 \; 2^{E2}$$，这里假设 E1 &gt; E2</p>
<p><img src="/images/csapp26.jpg" alt="csapp26"></p>
<p>结果是 $(-1)^{s}\; M \; 2^{E}$，其中 s= s1 ^ s2, M = M1 + M2, E = E1</p>
<ul>
<li>如果 M 大于等于 2，那么把 M 右移，并增加 E 的值</li>
<li>如果 M 小于 1，把 M 左移 k 位，E 减少 k</li>
<li>如果 E 超出了可以表示的范围，溢出</li>
<li>把 M 舍入到 frac 的精度</li>
</ul>
<p>基本性质</p>
<ul>
<li>相加可能产生 infinity 或者 NaN</li>
<li>满足交换率</li>
<li>不满足结合律（因为舍入会造成精度损失，如 <code>3.14+1e10)-1e10=0</code>，但 <code>3.14+(1e10-1e10)=3.14</code>）</li>
<li>加上 0 等于原来的数</li>
<li>除了 infinity 和 NaN，每个元素都有对应的倒数</li>
<li>除了 infinity 和 NaN，满足单调性，即 $a\ge b \to a+c \ge a+b$</li>
</ul>
<h3 id="C__u8BED_u8A00_u4E2D_u7684_u6D6E_u70B9_u6570"><a href="#C__u8BED_u8A00_u4E2D_u7684_u6D6E_u70B9_u6570" class="headerlink" title="C 语言中的浮点数"></a>C 语言中的浮点数</h3><p>保证两种精度：float(单精度)，double(双精度)</p>
<p>在 int, float, double 间转换会改变其 bit </p>
<ul>
<li>double/float 到 int<ul>
<li>去掉小数部分</li>
<li>类似与向 0 舍入</li>
<li>当值是 NaN 时没有定义，一般来说会设置为 TMin</li>
</ul>
</li>
<li>int 到 double<ul>
<li>精确转换，只要 int 的字长不超过 53 bit</li>
</ul>
</li>
<li>int 到 float<ul>
<li>可能需要舍入</li>
</ul>
</li>
</ul>
<h3 id="Puzzles"><a href="#Puzzles" class="headerlink" title="Puzzles"></a>Puzzles</h3><p>声明下面变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = ...;</span><br><span class="line"><span class="keyword">float</span> f = ...;</span><br><span class="line"><span class="keyword">double</span> d = ...;</span><br></pre></td></tr></table></figure>
<p>判断下面的表达式是否正确</p>
<ul>
<li><code>x == (int)(float)x</code> 错误，可能会损失精度，因为 float 的位数不足以表达所有可能的 int</li>
<li><code>x == (int)(double)x</code> 正确，int 到 double 是精确转换</li>
<li><code>f == (float)(double)f</code> 正确</li>
<li><code>d == (double)(float)d</code> 错误，可能会损失精度</li>
<li><code>f == -(-f)</code> 正确，只是改变符号位</li>
<li><code>2/3 == 2/3.0</code> 错误，前面会舍入到 0，后面是一个小数</li>
<li><code>d &lt; 0.0</code> 推出 <code>(d*2) &lt; 0.0</code> 正确，即使溢出，也是负无穷</li>
<li><code>d &gt; f</code> 推出 <code>-f &gt; -d</code> 正确</li>
<li><code>d * d &gt;= 0.0</code> 正确</li>
<li><code>(d+f)-d == f</code> 错误，可能会因为舍入损失精度</li>
</ul>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>IEEE 浮点数有明确的数学性质</li>
<li>使用 $M\times 2^E$ 的形式来表达数值</li>
<li>操作实际上是与实现方式无关的，因为需要满足同样的数学规律，具体怎么实现不重要</li>
<li>和实际的数学有一些不同<ul>
<li>不满足结合律和分配率</li>
<li>给编译器和需要高精度的运算程序带来了很大困扰</li>
</ul>
</li>
</ul>
<p><img src="/images/csapp27.jpg" alt="csapp27"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解了数据在内存中的基本存储形式，同时也知道了整型的表达方法，这一讲我们来看看另一大类别的数字——浮点数——是如何在计算机中表示的。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="浮点数" scheme="http://wdxtub.com/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
