<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-02-29T13:18:28.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[云计算 第 15 课 分区和复制]]></title>
    <link href="http://wdxtub.com/2016/02/29/cc-15/"/>
    <id>http://wdxtub.com/2016/02/29/cc-15/</id>
    <published>2016-02-29T12:01:54.000Z</published>
    <updated>2016-02-29T13:18:28.000Z</updated>
    <content type="html"><![CDATA[<p>之前我们做的是计算能力的伸缩拓展，这次我们也要对数据库做类似的事情，并且通过具体的场景，来了解键值对存储的应用特点。</p>
<a id="more"></a>
<hr>
<h2 id="u5B66_u4E60_u76EE_u6807"><a href="#u5B66_u4E60_u76EE_u6807" class="headerlink" title="学习目标"></a>学习目标</h2><ol>
<li>了解分布式键值对存储的设计空间和动机</li>
<li>比较在键值对存储中使用复制和分区的异同及优劣</li>
<li>利用复制或分区机制来拓展分布式键值对存储</li>
<li>了解并实现一致性哈希算法，并借此说明其在分布式键值对存储中的分区起到的作用</li>
<li>把复制和分区技术应用到现实场景中</li>
</ol>
<p>一致性哈希算法的要求很简单：</p>
<blockquote>
<p>在任何时候，对于同一个 key，要返回同一个 value</p>
</blockquote>
<p>理论上的要求很简洁，但具体实现的时候就会有需要细节了，比方说如何平均分配不同的 key，如果处理错误的状况等等。</p>
<h2 id="u80CC_u666F_u77E5_u8BC6"><a href="#u80CC_u666F_u77E5_u8BC6" class="headerlink" title="背景知识"></a>背景知识</h2><p>随着互联网、电子商务和社交媒体的快速发展，很多公司都不得不面对日益增长的数据量。如何存储、处理和分析这些数据越来越成为巨大的挑战。因为数据量已经远超一台机器可以承载的范围，我们需要分布式可拓展的存储系统。这里我们会专注于分布式键值对存储系统（也是 NoSQL 存储系统）。键值对存储系统支持两个基本操作：</p>
<ol>
<li><code>PUT</code> 请求，把一条记录放到数据库中</li>
<li><code>GET</code> 请求，从数据库中获取指定数据</li>
</ol>
<p>分布式键值对存储包含多个节点（可能不在一个地方），一个比较常见的做法是利用最近的服务器来处理对应请求以减少延迟。</p>
<p>说到数据库的扩展性，我们可以通过下面的视频来进行基本的了解</p>
<p><a href="https://www.youtube.com/watch?v=opYWHWG-vVg" target="_blank" rel="external">Video 1: Database Scaling</a></p>
<p>下面是视频中的要点：</p>
<ul>
<li>Vertical Scaling：提高硬件和软件配置（CPU, Memory, Disk, Network）<ul>
<li>优势：迁移简单，使用已有的软件</li>
<li>限制：硬件成本快速增长，可能最强大的硬件也不够用</li>
</ul>
</li>
<li>Horizontal Scaling：从一台数据库服务器扩展为数据库服务器集群，有下面两种机制来进行<ul>
<li>Replication 复制：每台数据库服务器都有同样的数据，读数据的时候没有问题，写数据的时候需要考虑数据同步的问题。对读数据性能要求较高的应用可以采用这种机制。</li>
<li>Sharding 分区：每台数据库服务器保存部分的数据库文件，需要决定什么时候访问哪台服务器，需要一个分区表。具体的分隔可以以行来分(Horizontal Partitioning)或者以列来分(Vertical Partitioning)。对写数据性能要求较高的应用可以采用这种机制。</li>
</ul>
</li>
</ul>
<p>这两个机制各有侧重点，这里简要介绍一下。</p>
<h3 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h3><p>对于复制机制来说，每次更新数据，都需要把改动『广播』到所有的节点上以保证数据一致性，如果系统的容错性要求很高，那么复制机制可能是比较好的选择，下图是一个例子：</p>
<p><img src="/images/14567497209474.jpg" alt="有 3 个复制节点的数据库"></p>
<p>在复制的情况下，主要的优化机制是提供不同级别的一致性保证。在一个数据库节点的某条记录被修改时，其他数据库中对应的记录是不可访问的，直到三个数据库的数据完全同步之后才可以，如下：</p>
<p><img src="/images/14567498771413.jpg" alt="强一致性保证"></p>
<p>并且，操作的不同顺序也会以时间戳的方式进行记录和排序，为了保证强一致性，需要保证任何时候从任何复制节点读取的数据都是一样的，具体的规则如下表所示</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">强一致性</td>
<td style="text-align:center">任何时候从任何复制节点中相同的 key 对应相同的 value</td>
</tr>
<tr>
<td style="text-align:center">严格排序</td>
<td style="text-align:center">按时间顺序处理请求</td>
</tr>
<tr>
<td style="text-align:center">原子操作</td>
<td style="text-align:center">所有的操作都应该是原子的，不能同时更新</td>
</tr>
<tr>
<td style="text-align:center">访问控制</td>
<td style="text-align:center">一个 key 在被更新时其他节点中的对应 key 不能访问</td>
</tr>
</tbody>
</table>
<h3 id="Sharding"><a href="#Sharding" class="headerlink" title="Sharding"></a>Sharding</h3><p>对于分区机制来说，可以直接用下图来描述与复制机制的区别（比较简单这里不详细介绍）</p>
<p><img src="/images/14567501863377.jpg" alt="三种方式的对比"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前我们做的是计算能力的伸缩拓展，这次我们也要对数据库做类似的事情，并且通过具体的场景，来了解键值对存储的应用特点。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="数据库" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 期中考试复习]]></title>
    <link href="http://wdxtub.com/2016/02/28/csapp-midterm-review/"/>
    <id>http://wdxtub.com/2016/02/28/csapp-midterm-review/</id>
    <published>2016-02-28T13:08:37.000Z</published>
    <updated>2016-02-29T03:22:04.000Z</updated>
    <content type="html"><![CDATA[<p>这一次我们主要来回顾一下重要的知识点，以及讲解一些往年试题中容易混淆的概念。</p>
<a id="more"></a>
<hr>
<h2 id="u77E5_u8BC6_u70B9_u68B3_u7406"><a href="#u77E5_u8BC6_u70B9_u68B3_u7406" class="headerlink" title="知识点梳理"></a>知识点梳理</h2><p>范围是第 1-3 章和第 6 章，下面是部分知识点（每个其实都包含不少内容，建议再看一次我前面写过的系列，这里还是会挑一些重点来写以下）</p>
<ul>
<li>十六进制表示</li>
<li>数据类型的字节表示</li>
<li>C 语言中的位操作、逻辑操作、左移右移操作</li>
<li>整型的表示方法及运算方式</li>
<li>浮点数的表示方法及运算方式</li>
<li>理解汇编：访问数据，算术和逻辑运算，控制，过程调用，数组的内存空间分配和访问，结构体/联合体的表示，数据对齐</li>
<li>理解指针，栈帧以及常见的攻击方式</li>
<li>内存相关话题：Locality, Memory Hierarchy, Cache Memories</li>
</ul>
<h3 id="u5E03_u5C14_u8FD0_u7B97"><a href="#u5E03_u5C14_u8FD0_u7B97" class="headerlink" title="布尔运算"></a>布尔运算</h3><p>集合 A</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01101001</span> &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="number">76543210</span></span><br></pre></td></tr></table></figure>
<p>集合 B</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01010101</span> &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="number">76543210</span></span><br></pre></td></tr></table></figure>
<p>那么不同的布尔运算就代表：</p>
<ul>
<li><code>&amp;</code> 交集 Intersection <code>01000001</code> {0, 6}</li>
<li><code>|</code> 并集 Union <code>01111101</code> {0, 2, 3, 4, 5, 6}</li>
<li><code>^</code> 差集 Symmetric difference <code>00111100</code> {2, 3, 4, 5}</li>
<li><code>~</code> 补集 Complement <code>10101010</code> {1, 3, 5, 7}</li>
</ul>
<p>以上这四种运算 C 语言都支持，只要是『数值型』即可：<code>long</code>, <code>int</code>, <code>short</code>, <code>char</code>, <code>unsigned</code>。每个参数都会被看做是位向量。</p>
<h3 id="u6574_u578B_u7684_u8868_u793A"><a href="#u6574_u578B_u7684_u8868_u793A" class="headerlink" title="整型的表示"></a>整型的表示</h3><p>针对有符号数和无符号数，有两种不同的形式，这里的 w 表示 word size：</p>
<ul>
<li>无符号数：$B2U(X)=\sum_{i=0}^{w-1}x_i·2^i$</li>
<li>有符号数： $B2T(X)=-x_{w-1}·2^{w-1}+\sum_{i=0}^{w-2}x_i·2^i$ </li>
</ul>
<p>为了方便讲解，下面定义几个常量，这里 w 是 word size：</p>
<ul>
<li>UMin = 0 即 000…0</li>
<li>UMax = $2^w-1$ 即 111…1</li>
</ul>
<p>Two’s Complement 值</p>
<ul>
<li>TMin = $-2^{w-1}$ 即 100…0</li>
<li>TMax = $2^{w-1}-1$ 即 011…1</li>
</ul>
<p>其他值</p>
<ul>
<li>Minus 1 即 111…1</li>
</ul>
<p>观察可以得知两个很重要的特性</p>
<ul>
<li>|TMin| = TMax + 1 (范围并不是对称的)</li>
<li>UMax = 2*TMax + 1</li>
</ul>
<p>有符号数和无符号数在非负数的编码是一样的，每一个数字的编码是唯一的，这两者可以互换：</p>
<ul>
<li>$U2B(x)=B2U^{-1}(x)$</li>
<li>$T2B(x)=B2T^{-1}(x)$</li>
</ul>
<p><img src="/images/csapp2.jpg" alt="2&#39;s Complement vs Unsigned"></p>
<h3 id="u62D3_u5C55_u548C_u88C1_u526A"><a href="#u62D3_u5C55_u548C_u88C1_u526A" class="headerlink" title="拓展和裁剪"></a>拓展和裁剪</h3><p>有的时候我们需要扩展一个变量的位数，比如说从 32 位扩展到 64 位。更通用一点的话，给定一个 w 位的有符号整数 x，要把它转换成 w+k 位的整数（保持值不变），只需要在左边添加 k 个与符号位相同的数值即可，如下图：</p>
<p><img src="/images/csapp3.jpg" alt="从 32 位拓展到 64 位"></p>
<ul>
<li>扩展（例如从 <code>short int</code> 到 <code>int</code>）<ul>
<li>无符号数：加 0</li>
<li>有符号数：加符号位</li>
<li>都可以得到预期的结果</li>
</ul>
</li>
<li>缩短（例如 <code>unsigned</code> 到 <code>unsigned short</code>）<ul>
<li>均会截取</li>
<li>无符号数：mod 操作</li>
<li>有符号数：近似 mod 操作</li>
<li>对于小的数字可以得到预期的结果</li>
</ul>
</li>
</ul>
<h3 id="u6EA2_u51FA_u95EE_u9898"><a href="#u6EA2_u51FA_u95EE_u9898" class="headerlink" title="溢出问题"></a>溢出问题</h3><p>无符号加法和有符号加法有不同的溢出方式：</p>
<p><img src="/images/csapp5.jpg" alt="无符号加法的溢出"></p>
<p><img src="/images/csapp7.jpg" alt="有符号加法的两种溢出"></p>
<h3 id="u6D6E_u70B9_u6570"><a href="#u6D6E_u70B9_u6570" class="headerlink" title="浮点数"></a>浮点数</h3><p>二进制浮点数的表示，其实和我们日常生活中常见的十进制的方式是一致的，都是相当于每一位的系数，乘以每一位的数值，然后把结果加起来，如下图所示：</p>
<p><img src="/images/csapp13.jpg" alt="浮点数表示"></p>
<p>所以我们其实可以用一个统一的公式来表达：</p>
<p>$$ \sum_{k=-j}^ib_k\times 2^k $$</p>
<p>例如</p>
<p>$$ 5\frac{3}{4}=101.11_2 \;,\; 2\frac{7}{8}=10.111_2 \;,\; 1\frac{7}{16}=1.0111_2 $$</p>
<p>细心的同学就会发现，这种表达方式其实是比较明显的限制的，比如说，只有形为 $\frac{x}{2^k}$ 的小数部分可以被精确表示，其他的数字会变成循环的小数，例如：$\frac{1}{3}=0.0101010101[01]…_2$。</p>
<p>除此之外，另一个问题在于，如果给定了 w 个比特，能够表达的数字其实是有限的。</p>
<h3 id="IEEE__u6D6E_u70B9_u6570"><a href="#IEEE__u6D6E_u70B9_u6570" class="headerlink" title="IEEE 浮点数"></a>IEEE 浮点数</h3><p>我们用下面的公式来表达浮点数：</p>
<p>$$(-1)^s \; M \; 2^E$$</p>
<p>其中 s 是符号位，决定正负；M 通常是一个值在 [1.0, 2.0) 的小数；E 是次方数。具体编码的时候是这样的：</p>
<p><img src="/images/csapp14.jpg" alt="浮点数的格式"></p>
<p>其中 s 对应着符号位，exp 对应着 E（注意，不一定等于 E，因为位数限制表达能力有限），frac 对应着 M（注意，不一定等于 M，因为位数限制表达能力有限）。</p>
<p>不同的位数就代表了不同的表示能力，也就是单精度，双精度，扩展精度的来源，具体的位数表示如下：</p>
<p><img src="/images/csapp15.jpg" alt="单精度、双精度、拓展精度"></p>
<p>注意区别 normalized 和 denormalized 的区别</p>
<p>舍入到最近的偶数比较特别，中心思想是：舍入之后最右边的值要是偶数，从下面一个例子就可以明白：</p>
<p><img src="/images/csapp24.jpg" alt="舍入到最近的偶数"></p>
<p>对于二进制数也是类似的</p>
<p><img src="/images/csapp25.jpg" alt="二进制数舍入到最近的偶数"></p>
<h3 id="u6D6E_u70B9_u6570_u4E58_u6CD5"><a href="#u6D6E_u70B9_u6570_u4E58_u6CD5" class="headerlink" title="浮点数乘法"></a>浮点数乘法</h3><p>$$(-1)^{s1}\; M1 \; 2^{E1} \times (-1)^{s2}\; M2 \; 2^{E2}$$</p>
<p>结果是 $(-1)^{s}\; M \; 2^{E}$，其中 s= s1 ^ s2, M = M1 * M2, E = E1 + E2</p>
<ul>
<li>如果 M 大于等于 2，那么把 M 右移，并增加 E 的值。</li>
<li>如果 E 超出了可以表示的范围，溢出</li>
<li>把 M 舍入到 frac 的精度</li>
</ul>
<p>基本性质</p>
<ul>
<li>相乘可能产生 infinity 或者 NaN</li>
<li>满足交换率</li>
<li>不满足结合律（因为舍入会造成精度损失）</li>
<li>乘以 1 等于原来的数</li>
<li>不满足分配率 <code>1e20*(1e20-1e20)=0.0</code> 但 <code>1e20*1e20-1e20*1e20=NaN</code></li>
<li>除了 infinity 和 NaN，满足单调性，即 $a\ge b \to a\times c \ge a\times b$</li>
</ul>
<h3 id="u6D6E_u70B9_u6570_u52A0_u6CD5"><a href="#u6D6E_u70B9_u6570_u52A0_u6CD5" class="headerlink" title="浮点数加法"></a>浮点数加法</h3><p>$$(-1)^{s1}\; M1 \; 2^{E1} + (-1)^{s2}\; M2 \; 2^{E2}$$，这里假设 E1 &gt; E2</p>
<p><img src="/images/csapp26.jpg" alt="浮点数加法"></p>
<p>结果是 $(-1)^{s}\; M \; 2^{E}$，其中 s= s1 ^ s2, M = M1 + M2, E = E1</p>
<ul>
<li>如果 M 大于等于 2，那么把 M 右移，并增加 E 的值</li>
<li>如果 M 小于 1，把 M 左移 k 位，E 减少 k</li>
<li>如果 E 超出了可以表示的范围，溢出</li>
<li>把 M 舍入到 frac 的精度</li>
</ul>
<p>基本性质</p>
<ul>
<li>相加可能产生 infinity 或者 NaN</li>
<li>满足交换率</li>
<li>不满足结合律（因为舍入会造成精度损失，如 <code>3.14+1e10)-1e10=0</code>，但 <code>3.14+(1e10-1e10)=3.14</code>）</li>
<li>加上 0 等于原来的数</li>
<li>除了 infinity 和 NaN，每个元素都有对应的倒数</li>
<li>除了 infinity 和 NaN，满足单调性，即 $a\ge b \to a+c \ge a+b$</li>
</ul>
<h3 id="u79FB_u52A8_u6570_u636E_u4E0E_u5BFB_u5740"><a href="#u79FB_u52A8_u6570_u636E_u4E0E_u5BFB_u5740" class="headerlink" title="移动数据与寻址"></a>移动数据与寻址</h3><p>操作数主要有三种类型，一种是立即数，也就是直接给的一个数字，第二种是寄存器，第三种是内存</p>
<p><img src="/images/14531723678160.jpg" alt=""></p>
<p>普通模式，(R)，相当于 <code>Mem[Reg[R]]</code>，也就是说寄存器 R 指定内存地址，类似于 C 语言中的指针，语法为：<code>movq (%rcx), %rax</code> 也就是说以 %rcx 寄存器中存储的地址去内存里找对应的数据，存到寄存器 %rax 中</p>
<p>移位模式，D(R)，相当于 <code>Mem[Reg[R]+D]</code>，寄存器 R 给出起始的内存地址，然后 D 是偏移量，语法为：<code>movq 8(%rbp),%rdx</code> 也就是说以 %rbp 寄存器中存储的地址再加上 8 个偏移量去内存里找对应的数据，存到寄存器 %rdx 中</p>
<p><img src="/images/14531733075157.jpg" alt=""></p>
<p>举个例子：%rdx 的存着的地址是 0xf000；%rcx 的存着的地址是 0x0100，那么有：</p>
<p><img src="/images/14531733728296.jpg" alt=""></p>
<h3 id="u6761_u4EF6_u7801_u4E0E_u4EE3_u7801_u63A7_u5236"><a href="#u6761_u4EF6_u7801_u4E0E_u4EE3_u7801_u63A7_u5236" class="headerlink" title="条件码与代码控制"></a>条件码与代码控制</h3><p>最后的四个寄存器（CF, ZF, SF, OF）就是用来辅助程序的流程控制的，意思是：</p>
<ul>
<li>CF: Carry Flag (for unsigned)</li>
<li>ZF: Zero Flag</li>
<li>SF: Sign Flag (for signed)</li>
<li>OF: Overflow Flag (for signed)</li>
</ul>
<p>可以看到以上这四个寄存器，表示四种不同的状态，举个例子，假如我们有一条诸如 <code>t = a + b</code> 的语句，汇编之后假设用的是 <code>addq Src, Dest</code>，那么根据这个操作结果的不同，会相应设置上面提到的四个寄存器，而因为这个是执行类似操作时顺带尽心设置的，称为隐式设置，例如：</p>
<ul>
<li>如果两个数相加，在最高位还需要进位（也就是溢出了），那么 CF 寄存器就会被设置</li>
<li>如果 t 等于 0，那么 ZF 寄存器会被设置</li>
<li>如果 t 小于 0，那么 SF 寄存器会被设置</li>
<li>如果 2’s complement 溢出，那么 OF 寄存器会被设置为 1（溢出的情况是 <code>(a&gt;0 &amp;&amp; b &gt; 0 &amp;&amp; t &lt;0) || (a&lt;0 &amp;&amp; b&lt;0 &amp;&amp; t&gt;=0)</code>）</li>
</ul>
<p>这就发现了，其实这四个条件代码，是用来标记上一条命令的结果的各种可能的，是自动会进行设置的。注意，使用 <code>leaq</code> 指令的话不会进行设置。</p>
<h3 id="u6808_u5E27"><a href="#u6808_u5E27" class="headerlink" title="栈帧"></a>栈帧</h3><p>在 x86-64/Linux 中，栈帧的结构是固定的，当前的要执行的栈中包括：</p>
<ul>
<li>Argument Build: 需要使用的参数</li>
<li>如果不能保存在寄存器中，会把一些本地变量放在这里</li>
<li>已保存的寄存器上下文</li>
<li>老的栈帧的指针（可选）</li>
</ul>
<p>而调用者的栈帧则包括：</p>
<ul>
<li>返回地址（因为 <code>call</code> 指令被压入栈的）</li>
<li>调用所需的参数</li>
</ul>
<p>具体如下图所示：</p>
<p><img src="/images/14533846615880.jpg" alt="栈帧的例子"></p>
<h3 id="u5B58_u50A8_u76F8_u5173"><a href="#u5B58_u50A8_u76F8_u5173" class="headerlink" title="存储相关"></a>存储相关</h3><p>总的访问时间  Taccess =  寻址时间 Tavg seek + 旋转时间 Tavg rotation + 传输时间 Tavg transfer</p>
<ul>
<li>寻址时间 Tavg seek 因为物理规律的限制，一般是 3-9 ms</li>
<li>旋转延迟 Tavg rotation 取决于硬盘具体的转速，一般来说是 7200 RPM</li>
<li>传输时间 Tavg tranfer 就是需要读取的 sector 数目</li>
</ul>
<p>举个例子，假设转速是 7200 RPM，平均寻址时间 9ms，平均每个 track 的 sector 数目是 400，那么我们有：</p>
<ul>
<li>Tavg rotation = 1/2 x (60 secs / 7200 RPM) x 1000 ms/sec = 4 ms</li>
<li>Tavg transfer = 60 / 7200 RPM x 1/400 secs/track x 1000 ms/sec = 0.02 ms</li>
<li>Taccess = 9 ms + 4 ms + 0.02 ms</li>
</ul>
<p>从这里可以看出，主要决定访问时间的是寻址时间和旋转延迟；读取一个 sector 的第一个 bit 是非常耗时的，之后的都几乎可以忽略不计；硬盘比 SRAM 慢 40,000 倍，比 DRAM 慢 2500 倍。</p>
<h3 id="Locality__u4E0E_Memory_Heirarchy"><a href="#Locality__u4E0E_Memory_Heirarchy" class="headerlink" title="Locality 与 Memory Heirarchy"></a>Locality 与 Memory Heirarchy</h3><p>Locality 的思路很简单，就是如果一个数据最近被访问过，很可能还会被再次访问：</p>
<ul>
<li>Temporal locality: Recently referenced items are likely to be referenced again in the near future</li>
<li>Spatial locality: Items with nearby addresses tend to be referenced close together in time</li>
</ul>
<p>一种介质的速度越快，就会越贵，同时也消耗更多的电量，所以一般容量比较小。而 CPU 和内存之间的速度差距越来越大，所以好的程序都会尽可能利用 locality。根据这些特性，也就引申出了一个安排存储的方式，称为 memory hierarchy。</p>
<p><img src="/images/14555647586566.jpg" alt="Memory Heirarchy"></p>
<p>这里就涉及到一个技术：缓存。缓存可以看作是把大且缓慢的设备中的数据的一部分拿出来存储到其中的更快的存储设备。在 memory hierarchy 金字塔中，每一层都可以看作是下一层的缓存。利用 locality，程序会更倾向于访问第 k 层的数据，而非第 k+1 层，这样就减少了访问时间。</p>
<p><img src="/images/14555654345569.jpg" alt="访问时间比较"></p>
<h3 id="Cache_Miss"><a href="#Cache_Miss" class="headerlink" title="Cache Miss"></a>Cache Miss</h3><p>Cache miss 有三种：</p>
<ul>
<li>Cold(compulsory) Miss: CPU 第一次访问相应 cache 块，cache 中肯定没有该 cache 块，这是不可避免的</li>
<li>Confilict Miss: 在直接相联或组相联的 cache 中，不同的 cache 块由于 index 相同相互替换，引起的失效叫做冲突失效<ul>
<li>假设这里有 32KB 直接相联的 cache</li>
<li>如果有两个 8KB 的数据需要来回访问，但是这两个数组都映射到相同的地址，cache 大小足够存储全部的数据，但是因为相同地址发生了冲突需要来回替换，发生的失效则全都是冲突失效（第一次访问失效依旧是强制性失效），这时 cache 并没有存满</li>
</ul>
</li>
<li>Capacity Miss: 有限的 cache 容量导致 cache 放不下而被替换出 cache 块，被替换出去的 cache 块再被访问，引起的失效叫做容量失效<ul>
<li>假设这里有 32KB 直接相联的 cache</li>
<li>如果有一个 64KB 的数组需要重复访问，数组的大小远远大于 cache 大小，没办法全部放入 cache。第一次访问数组发生的失效全都是强制性失效。之后再访问数组，再发生的失效则全都是容量失效，这时 cache 已经存满，容量不足以存储全部数据</li>
</ul>
</li>
</ul>
<h3 id="Cache_Memories"><a href="#Cache_Memories" class="headerlink" title="Cache Memories"></a>Cache Memories</h3><p>通常来说，是按照如下图所示的方式来组织的，一定要注意 S/E/B 具体在说什么：</p>
<p><img src="/images/14555690389309.jpg" alt=""></p>
<p>实际上可以理解为三种层级关系，对应不同的索引，这样分层的好处在于，通过层级关系简化搜索需要的时间，并且和字节的排布也是一一对应的（之后介绍缓存的时候就体现得更加明显）。</p>
<p>具体的例子请参考<a href="http://wdxtub.com/2016/02/15/csapp-12/">深入理解计算机系统 第 12 课 Cache Memories</a></p>
<h3 id="Memory_Mountain"><a href="#Memory_Mountain" class="headerlink" title="Memory Mountain"></a>Memory Mountain</h3><p><img src="/images/14556314890158.jpg" alt=""></p>
<p>注意，这是根据 Core i7 得出来的图，不同的处理器可能因为不同的设计和架构而有所区别，但是可以通过不同的颜色和层次，看出不同 size 和 stride 对性能的影响。山脚是我们应该尽量避免的，山顶是我们力求达到的，也就是说，尽量一次访问一个 stride，一次读入的数据大小也不宜太大，最好和 L1 缓存数值上吻合。</p>
<h2 id="u5F80_u5E74_u8BD5_u9898_u8BB2_u89E3"><a href="#u5F80_u5E74_u8BD5_u9898_u8BB2_u89E3" class="headerlink" title="往年试题讲解"></a>往年试题讲解</h2><h3 id="u9009_u62E9_u9898_u77E5_u8BC6_u70B9"><a href="#u9009_u62E9_u9898_u77E5_u8BC6_u70B9" class="headerlink" title="选择题知识点"></a>选择题知识点</h3><ul>
<li><code>test</code> 指令和 <code>and</code> 指令一样，只设置 flag 不改变结果</li>
<li>在一个 32 位的 Linux 系统中，<code>long</code> 的大小为 <code>4 bytes</code></li>
<li>在一个 64 位的 Linux 系统中，并不是所有的参数都在栈上传递</li>
</ul>
<h3 id="u6D6E_u70B9_u6570_u7F16_u7801"><a href="#u6D6E_u70B9_u6570_u7F16_u7801" class="headerlink" title="浮点数编码"></a>浮点数编码</h3><p>这里我们考虑两种 6 位数的 IEEE 浮点数格式</p>
<ul>
<li>格式 A<ul>
<li>1 个符号位 s</li>
<li>k = 3 个 exponent bits，bias 为 $2^{k-1} - 1 = 3$</li>
<li>n = 2 个 fraction bits</li>
</ul>
</li>
<li>格式 B<ul>
<li>1 个符号位 s</li>
<li>k = 2 个 exponent bits，bias 为 $2^{k-1} - 1 = 1$</li>
<li>n = 3 个 fraction bits</li>
</ul>
</li>
</ul>
<p>注意</p>
<ul>
<li>对应于 denormalized 的情况，E = 1 - bias</li>
<li>对应于 normalized 的情况，E = exp - bias</li>
</ul>
<p>需要填写下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">Value</th>
<th style="text-align:center">Format A Bits</th>
<th style="text-align:center">Format B Bits</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Zero</td>
<td style="text-align:center">0 000 00</td>
<td style="text-align:center">0 00 000</td>
</tr>
<tr>
<td style="text-align:center">One</td>
<td style="text-align:center">0 011 00</td>
<td style="text-align:center">0 01 000</td>
</tr>
<tr>
<td style="text-align:center">$\frac{1}{2}$</td>
<td style="text-align:center">0 010 00</td>
<td style="text-align:center">0 00 100</td>
</tr>
<tr>
<td style="text-align:center">$\frac{11}{8}$</td>
<td style="text-align:center">0 011 10</td>
<td style="text-align:center">0 01 011</td>
</tr>
</tbody>
</table>
<p>我们来对应看一下具体要怎么填。</p>
<p>首先需要知道的是 IEEE 浮点数的具体格式，是 s | exp | frac。接下来要知道什么时候是 denormalized，什么时候是 normalized，简单来说就是如果 exp 全为 0 或全为 1 时，属于 denormalized，其他时候属于 normalized。</p>
<p>对应浮点数的公式</p>
<p>$$(-1)^s \; M \; 2^E$$</p>
<p>我们知道如果要表示 1，那么 E 应该等于 0，M 部分应该为 1（M 的形式应该是是 1.xxxxx，其中 xxx 是 frac 的部分，于是 frac 应该为 0）。这里 E 因为属于 normalized 的情况，所以 E = exp - bias，而 E 需要等于 0，所以 exp = bias，针对不同的格式，就可以找到对应的答案（格式 A 中 bias = 3，所以 exp 部分是 011；格式 B 中 bias = 1，所以 exp 部分是 01；frac 部分均为 0）</p>
<p>然后我们来看看如何表示 0.5，根据公式，E 应该等于 -1，那么对于格式 A，E = exp - bias，所以 exp = -1 + 3 = 2，exp 部分就是 010。但是对于格式 B 就有点不同，因为这时候是属于 denormalized 的，这时 E = 1 - bias = 0，我们需要对 frac 部分做出处理，在这种情况下(M 的形式是 0.xxx)，frac 的第一位就表示 0.5，所以最终的结果如上表所示。</p>
<p>最后我们来看看 $\frac{11}{8}$ 要如何表示，实际上就是 1 加上 $\frac{3}{8}$，因为前面已经表示过 1，所以只要在 frac 部分做做文章即可，这次我们先来看格式 B，根据浮点数的定义，我们很快就可以知道 frac 应该为 011，完成！对于格式 A，因为 frac 只有 2 位，那么就需要进行舍入（到最近的偶数），也就是 <code>011 -&gt; 01 + 01 -&gt; 10</code>，所以最终的结果如上表所示。</p>
<h3 id="u6C47_u7F16_u7A0B_u5E8F_u9605_u8BFB"><a href="#u6C47_u7F16_u7A0B_u5E8F_u9605_u8BFB" class="headerlink" title="汇编程序阅读"></a>汇编程序阅读</h3><p>假设有这么一段汇编程序</p>
<p><img src="/images/14566917311963.jpg" alt=""></p>
<p>根据上面的信息，补充完整下面对应的程序代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">transform</span><span class="params">(<span class="keyword">unsigned</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b, m;</span><br><span class="line">    <span class="keyword">for</span> (m = __; _____; _____)&#123;</span><br><span class="line">        b = ____;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            ______;</span><br><span class="line">        &#125;</span><br><span class="line">        ______;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们应该熟悉，这里 <code>%eax</code> 中存放的变量是 <code>m</code>，<code>%edx</code> 中存放的变量是 <code>n</code>。在 &lt;+6&gt; 这一行把 <code>0x0</code> 放到了 <code>%eax</code> 中，所以循环的初始条件是 <code>m=0</code>，然后 &lt;+11&gt; 这一句实际是判断 <code>%edx</code> 是否为 0，如果为 0，则跳转到 &lt;+28&gt;，所以终止条件是 <code>n != 0</code>。接着就是循环体里的内容，&lt;+15&gt; 用 <code>%dl</code> 和 <code>0x1</code> 做 <code>&amp;</code> 操作，在汇编中结果会保存到对应的 flag 中，在代码中我们就保存到了 <code>b</code> 中，如果 <code>b == 0</code>，那么就跳转到 &lt;+24&gt;，进行移位操作，也就是循环操作为 <code>n &gt;&gt;= 1</code>，否则先要执行 &lt;+20&gt;，这一句实际上就是 <code>m = m + m + 1</code>，综上所述，就可以得到最终答案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">transform</span><span class="params">(<span class="keyword">unsigned</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b, m;</span><br><span class="line">    <span class="keyword">for</span> (m = <span class="number">0</span>; n != <span class="number">0</span>; m &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        b = n &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = m + m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u7ED3_u6784_u4F53_u7684_u5185_u5B58_u6392_u5217"><a href="#u7ED3_u6784_u4F53_u7684_u5185_u5B58_u6392_u5217" class="headerlink" title="结构体的内存排列"></a>结构体的内存排列</h3><p>假设我们有下面这个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">long</span> b;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">    <span class="keyword">char</span> d[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> *e;</span><br><span class="line">    <span class="keyword">short</span> *f;</span><br><span class="line">&#125; foo;</span><br></pre></td></tr></table></figure>
<p>请给出具体的内存排列顺序。</p>
<p>首先我们需要知道每个数据类型所占据的字节数目，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 2 字节：short</span></span><br><span class="line">    <span class="comment">// 16 字节：long double</span></span><br><span class="line">    <span class="keyword">char</span> a;    <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="keyword">long</span> b;    <span class="comment">// 8 字节（其他 8 字节的有 double, 指针）</span></span><br><span class="line">    <span class="keyword">float</span> c;   <span class="comment">// 4 字节（其他 4 字节的有 int）</span></span><br><span class="line">    <span class="keyword">char</span> d[<span class="number">3</span>]; <span class="comment">// 1 x 3 字节</span></span><br><span class="line">    <span class="keyword">int</span> *e;    <span class="comment">// 8 字节</span></span><br><span class="line">    <span class="keyword">short</span> *f;  <span class="comment">// 8 字节</span></span><br><span class="line">&#125; foo;</span><br></pre></td></tr></table></figure>
<p>所以具体的排列为（用 x 表示 padding 的字节）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span> x x x x x x x <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span></span><br><span class="line">c c c c d d d x e e e e e e e e</span><br><span class="line">f f f f f f f f</span><br></pre></td></tr></table></figure>
<p> 如果想要紧凑一点，其实可以进行对其，把 a, c, d 组合一下，如</p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span> d d d c c c c <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span></span><br><span class="line">e e e e e e e e f f f f f f f f</span><br></pre></td></tr></table></figure>
<p>这样就省了 8 个字节出来</p>
<h3 id="u7ED3_u6784_u4F53_u7684_u8BBF_u95EE"><a href="#u7ED3_u6784_u4F53_u7684_u8BBF_u95EE" class="headerlink" title="结构体的访问"></a>结构体的访问</h3><p>给出下面的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> confuse &#123;</span><br><span class="line">    <span class="keyword">char</span> systems;</span><br><span class="line">    <span class="keyword">long</span> theory;</span><br><span class="line">    <span class="keyword">struct</span> applications &#123;</span><br><span class="line">        <span class="keyword">char</span> web[<span class="number">3</span>];</span><br><span class="line">    &#125; database;</span><br><span class="line">    <span class="keyword">int</span> *languages;</span><br><span class="line">    <span class="keyword">struct</span> confuse *math;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题是，右边的汇编程序分别对应哪个函数：</p>
<p><img src="/images/14566942080505.jpg" alt=""></p>
<p>根据上一题，我们可以先画出具体的内存排列，用变量的首字母作为缩写，用 x 表示 padding：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s x x x x x x x t t t t t t t t</span><br><span class="line">w w w x x x x x <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span></span><br><span class="line"><span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="literal">m</span></span><br></pre></td></tr></table></figure>
<p>然后根据偏移量来数对应的变量即可，其中要注意的是十六进制转十进制的运算。比较简单，最后的对应为：</p>
<ul>
<li>A - phd</li>
<li>B - bachelors</li>
<li>C = masters</li>
</ul>
<h3 id="Switch__u8BED_u53E5"><a href="#Switch__u8BED_u53E5" class="headerlink" title="Switch 语句"></a>Switch 语句</h3><p>我们先来看跳转表：</p>
<p><img src="/images/14566960252571.jpg" alt="跳转表"></p>
<p>接着是汇编程序</p>
<p><img src="/images/14566960458022.jpg" alt=""></p>
<p>我们要做的是补充完整下面的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">4</span>;   </span><br><span class="line">    <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            _____;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            _____;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            result = ____;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            _____;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            _____;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            _____;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编程序中负责跳转的是 <code>0x40047b    jmpq  *0x400598(, %rdi, 8)</code>，其中 <code>%rdi</code> 就是变量 <code>a</code> 的值，仔细观察跳转表和程序，可以发现一些规律：</p>
<ul>
<li>a 等于 0 或 1 的时候，做的事情是一样的，并且直到执行完 a 等于 2 的语句才会返回</li>
<li>a 等于 5 时是一套独立的指令</li>
<li>a 等于 3 和 7 时，做的事情类似，并且最后都会执行默认的命令</li>
<li>switch 语句中有些有 break，有些没有</li>
</ul>
<p>有了这些线索，就可以『翻译』对应的汇编代码了，答案如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">4</span>;   </span><br><span class="line">    <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            result = c - <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            result = c * <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            result = <span class="number">0x15213</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            c = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            b = b &amp; c;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = b + <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u6808_u7684_u5E94_u7528"><a href="#u6808_u7684_u5E94_u7528" class="headerlink" title="栈的应用"></a>栈的应用</h3><p>这一题主要考察函数调用时候压栈出栈以及栈指针和返回地址的理解，C 代码和对应的汇编代码为：</p>
<p><img src="/images/14567011035267.jpg" alt=""></p>
<p>我们需要画出栈中的数据存放表示，具体的函数是 <code>foo(3, 4, 5)</code>，注意要标志出 <code>%ebp</code> 的值</p>
<p>在调用 <code>foo</code> 函数时 <code>%ebp</code> 的值为 <code>0xffffd858</code>，调用 <code>foo</code> 的函数的返回地址是 <code>0x080483c9</code></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stack      The diagram starts with theaddresss   arguments for foo()</span><br><span class="line">           +-----------------------------------+0xffffd850 |<span class="string">                5                  </span>|           +-----------------------------------+0xffffd84c |<span class="string">                4                  </span>|           +-----------------------------------+0xffffd848 |<span class="string">                3                  </span>|           +-----------------------------------+0xffffd844 |<span class="string">      return addr 0x080483c9       </span>|           +-----------------------------------+0xffffd840 |<span class="string">        old ebp 0xffffd858         </span>|           +-----------------------------------+0xffffd83c |<span class="string">                3                  </span>|           +-----------------------------------+0xffffd838 |<span class="string">                4                  </span>|           +-----------------------------------+0xffffd834 |<span class="string">      return addr 0x08048397       </span>|           +-----------------------------------+0xffffd830 |<span class="string">        old ebp 0xffffd858         </span>|           +-----------------------------------+</span><br></pre></td></tr></table></figure>
<p>我们来看看这题要怎么做。首先，老师还是很贴心的给出了第一个参数在栈中的位置，不过开始之前还是先要弄明白我们到底需要在栈中放什么东西。首先是函数的参数（倒着放，这样第一个参数才能先弹出来），然后是返回值地址和旧的 <code>%ebp</code> 指针，这俩是为了告诉指令该去哪，以及栈要去哪的。</p>
<p>所以答案就呼之欲出了，前三个简单，543 一路下来即可；接下来是返回地址，也就是题目给出的初始条件；再下来是题目给出的初始 ebp；接着是调用 <code>bar</code> 函数的栈排列，也还是参数，但是这里题目是换了顺序的，所以先 3 后 4；然后是返回值地址，找到汇编代码中 call 的下一句，就是它了；最后一句可有可无，不过为了清晰 ebp 的做用，还是写上，应该指向旧的 ebp 地址，也就是 <code>0xffffd840</code>，至此，题目完成。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一次我们主要来回顾一下重要的知识点，以及讲解一些往年试题中容易混淆的概念。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="复习" scheme="http://wdxtub.com/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 期中考试复习]]></title>
    <link href="http://wdxtub.com/2016/02/27/sad-midterm-review/"/>
    <id>http://wdxtub.com/2016/02/27/sad-midterm-review/</id>
    <published>2016-02-28T03:10:51.000Z</published>
    <updated>2016-02-28T05:12:56.000Z</updated>
    <content type="html"><![CDATA[<p>这一部分是根据老师给出的复习提纲总结的部分相关内容，但是由于架构这个东西太抽象，所以只能尽力去理解一下了。</p>
<a id="more"></a>
<hr>
<p>一想到要背这么多东西我就头疼，尽量利用已有知识理解之后串起来。</p>
<blockquote>
<p>Why software architecture is important?</p>
</blockquote>
<p>自己的一些思考，之所以重要是因为：</p>
<ul>
<li>软件架构影响到传统软件开发的每一个环节</li>
<li>清晰的软件架构是项目正常推进的指引</li>
<li>方便重用与修改</li>
<li>易于分析和测试</li>
</ul>
<blockquote>
<p>Various view points</p>
</blockquote>
<p>这里应该就是<a href="http://wdxtub.com/2016/01/31/sad-r3/">习题课 3 从不同视角描述系统</a>的内容，几个视角是：</p>
<ul>
<li>Function View: 各个模块图，包括接口和依赖</li>
<li>Information View: 展示 schema，数据模型和数据流，用状态机图来描述系统的信息模型</li>
<li>Concurrency View: 软件的组件需要在哪里部署和运行</li>
<li>Deployment View: 主要的软件包是什么</li>
<li>Development View: 在不同地方运行时，系统是如何运行的。你会如何保证数据一致性？</li>
</ul>
<blockquote>
<p>What does it mean by architecture through software lifecycle?</p>
</blockquote>
<p>这个题目在问什么我都有点迷糊，是不是说软件架构在软件的生命周期中的作用？还是其他什么的，大概分下面几个阶段：</p>
<ul>
<li>Requirements</li>
<li>Design </li>
<li>Coding</li>
<li>Testing</li>
</ul>
<p>不同的过程都会由架构来指引并且对架构的设计和演化有影响</p>
<blockquote>
<p>Will architecture design allow creativity</p>
</blockquote>
<p>这个是开放性问题，我觉得需要回答的要点是：</p>
<ul>
<li>允许创新</li>
<li>但是更要尊重前人的经验</li>
<li>大部分情况下不需要全新的架构，需要在已有的基础上提高改进</li>
</ul>
<blockquote>
<p>Canonical elements of software architecture</p>
</blockquote>
<p>这题就是概念题了，不过之前接触了这么多次，应该有一些印象，主要最后的 configuration 可能比较容易忘</p>
<ul>
<li>Component: computation</li>
<li>Connector: communication / coordination</li>
<li>Configuration: topology and constraints</li>
</ul>
<blockquote>
<p>Architectural styles vs Architectural patterns</p>
</blockquote>
<p>这是我一直比较迷糊的概念，会着重解释一下。</p>
<ul>
<li>Architectural styles: Codify key constraints and architectural elements (components, connectors, configurations) found effective used in a family of software systems over a given time period<ul>
<li>Client/Server, P2P, Object Oriented, Layered, Data-Flow, Pipe and Filter, Blackboard, Rule Based</li>
</ul>
</li>
<li>Architectural patterns: A set of architectural design decisions that are applicable to a recurring design problem, and parameterized to account for different software development contexts in which that problem appears.<ul>
<li>3-tier (Stage-Logic-Display), MVC, Sense Compute Control</li>
</ul>
</li>
</ul>
<p>Compared to styles, architectural patterns are at a coarser level of granularity (design decisions versus actual architectural elements) and are inherently more domain specific</p>
<blockquote>
<p>Methods of evaluating design methods like styles and patterns</p>
</blockquote>
<p>Vocabulary, structural patterns, computational model, invariants, common examples, disadvantages, specializations</p>
<blockquote>
<p>Methods of design</p>
</blockquote>
<p>Greenfield design (entirely fresh start, no baggage)</p>
<p>Analogy searching, Brainstorming, Literature searching, Morphological Charts, Removing Mental Blocks, Insight from requirements/implementation</p>
<blockquote>
<p>Software Connectors</p>
</blockquote>
<p>4 main roles: Communication, Conversion, Facilitation, Coordination</p>
<p>8 main types: Event, Stream, Procedure Call, Arbitrator, Data Access, Distributor, Linkage, Adaptor</p>
<blockquote>
<p>Benefits of first-class connectors</p>
</blockquote>
<p>Software evolution, separation of concerns, modularity, pluggability</p>
<blockquote>
<p>Architectural Modeling</p>
</blockquote>
<p>An architectural model is an artifact that captures some or all of the design decisions that comprise a system’s architecture</p>
<p>Architectural modeling is the reification and documentation of those design decisions</p>
<p>Important things to “get right”: Consistency, Accuracy/Precision, Ambiguity</p>
<p>How to choose what to model? Cost/Benefit Decision</p>
<p>What do we model? Structure (Architectural element), static/dynamic behaviors, functional/non-functional aspects, Views/Viewpoints</p>
<p>How do we evaluate modeling techniques? Scope/Purpose, Basic Elements, Style, Static/Dynamic Aspects, Dynamic Modeling, Non-functional aspects, ambiguity, accuracy/precision, viewpoints, view consistency</p>
<p>Modeling approaches: Generic, early ADLs, style-specific and domain-specific languages, extensible ADLs</p>
<blockquote>
<p>Service Oriented Architecture</p>
</blockquote>
<ul>
<li>Triangular Operational Model</li>
<li>SOA Standard Stack</li>
<li>SOA on Bilateral View</li>
<li>SOA Solution Lifecycle</li>
<li>Enterprise Service Bus</li>
<li>SOA Reference Architecture –  Software as a Service</li>
</ul>
<blockquote>
<p>ATAM</p>
</blockquote>
<ul>
<li>Nine steps</li>
<li>Review what you do in the group homework</li>
<li>Link architectural styles with utility tree, and analyze risks and provide justifications</li>
</ul>
<blockquote>
<p>People, Roles and Teams</p>
</blockquote>
<p>Desired skills</p>
<ul>
<li>Software development expertise •  Domain expertise</li>
<li>Communicator</li>
<li>Strategist</li>
<li>Consultant</li>
<li>Leader</li>
<li>Technologist</li>
<li>Cost estimator</li>
<li>Cheerleader</li>
<li>Politician</li>
<li>Salesperson</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一部分是根据老师给出的复习提纲总结的部分相关内容，但是由于架构这个东西太抽象，所以只能尽力去理解一下了。</p>]]>
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第七周 - 假行僧]]></title>
    <link href="http://wdxtub.com/2016/02/27/fake-sadhu/"/>
    <id>http://wdxtub.com/2016/02/27/fake-sadhu/</id>
    <published>2016-02-28T01:41:16.000Z</published>
    <updated>2016-02-28T02:50:32.000Z</updated>
    <content type="html"><![CDATA[<p>我要从南走到北，我还要从白走到黑，我要人们都看到我，却不知道我是谁。</p>
<a id="more"></a>
<hr>
<blockquote>
<p>深秋，夕阳，酒馆。偌大的厅堂，除了三三两两坐在角落窃窃私语的人，有这么一个人，坐在酒馆正中。衣衫褴褛，大义凛然，手里拿着一壶酒，一饮而尽。</p>
<p>起身，回头，默念。去吧，朋友，你的灵魂与我同在。</p>
</blockquote>
<p>不知道为什么，无论是暗黑破坏神中的武僧，还是英雄联盟中的盲僧，又或是金庸笔下的虚竹，古龙笔下的无花，都着实出彩，也倍受大家喜爱。</p>
<p>对我来说，僧人的形象是两面的，既有悲天悯人苦海慈航，也有明心见性不二法门，一为外，一为内。再加一点，恐怕要数『酒肉穿肠过』这般洒脱。僧人讲究修行讲究开悟，这两个事情都需要漫长的积累和隐忍，还得心无杂念，想法太多，往往也就看不清自己。一个人心里光是太急切想去做一件事，就难免会做错了。</p>
<p>武功本就是入世的，只要你肯用心，无论做什么事的时候，都一样可以锻炼你的武功。武学的精义只有四个字——专心、苦练。其实这四个字也同样适于世上的每一件事。无论你做什么，若要想出人头地，就只有专心、苦练。</p>
<p>前些天和爸爸妈妈打电话，一直被教导『去做自己喜欢的事情』。首先得要知道自己喜欢什么，然后再努力去做，这恐怕就是所谓『成功』的秘笈了。这些天有师弟师妹来咨询相关经验，其实我倒是觉得，很多事情不必弄得一清二楚才敢去做，要相信自己能兵来将挡水来土掩。如果硬要给些什么经验，一句话也能说清楚：</p>
<blockquote>
<p>不要感动自己，要成为自己</p>
</blockquote>
<p>还有就是作业重要，考试重要，但是朋友和伙伴比这些都重要。所谓友情不是嘴上说说而已，更是应该在朋友需要的时候，出现在你最该出现的地方——朋友身边。这些才是最值得去做的事情。</p>
<p>往西岸跑了这么多趟，虽然没有实际去工作体验过，但是也借着面试的机会，近距离观察了小公司大公司。最终得到的结论就是：不合适，不喜欢。拿到 offer 当然开心，毕竟也是一种肯定，不过还是得像之前拒绝其他 offer 一样，甩下一句『大丈夫居于天地间，岂能久居人下』了。</p>
<p>假设我有十成功力，那么写代码可能只是其中的两成，虽然说这两成对于程序员日常工作已经绰绰有余了，可是我更想在一个我能恣意发挥的地方，向所有人展示我能做的，而不只是在屏幕前完成一个又一个需求，改好一个又一个 bug。</p>
<p>当然，人各有志，无论什么选择，只要是自己喜欢的，作为朋友，我定当全力支持。</p>
<p>你把我当朋友，我不能让你丢人。我有这双脚，我有这双腿，我有这千山和万水。我要这所有的所有，但不要恨和悔。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我要从南走到北，我还要从白走到黑，我要人们都看到我，却不知道我是谁。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="独立" scheme="http://wdxtub.com/tags/%E7%8B%AC%E7%AB%8B/"/>
    
      <category term="自我" scheme="http://wdxtub.com/tags/%E8%87%AA%E6%88%91/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 19 课 People, Role, Teams]]></title>
    <link href="http://wdxtub.com/2016/02/27/sad-19/"/>
    <id>http://wdxtub.com/2016/02/27/sad-19/</id>
    <published>2016-02-27T20:01:42.000Z</published>
    <updated>2016-02-27T23:52:35.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们来讲讲人在整个系统开发过程中所发挥的重要作用，或者再简单一点，就是成为一个架构师，到底需要什么特质以及在团队中扮演什么角色。<br><a id="more"></a></p>
<hr>
<p>注：跳过了课本中我觉得部分『过时』或者『维基』上都有的常识性内容，这一章其实是本书的最后一章，但是课程其实才刚刚过半，后面的内容应该会和课程结合更紧密，我也会结合一些互联网公司的具体架构实践，来详细介绍背后的道理。</p>
<p>一个架构师需要什么技能呢？至少有以下几点：</p>
<ul>
<li>Software development expertise</li>
<li>Domain expertise</li>
<li>Communicator</li>
<li>Strategist</li>
<li>Consultant</li>
<li>Leader</li>
<li>Technologist</li>
<li>Cost estimator</li>
<li>Cheerleader</li>
<li>Politician</li>
<li>Salesperson</li>
</ul>
<p>具体的能力需求，根据不同的项目和不同的领域，也会有细微的不同，下面按照不同的角色，来进行响应的介绍</p>
<h2 id="u4F5C_u4E3A_u8F6F_u4EF6_u5F00_u53D1_u4E13_u5BB6"><a href="#u4F5C_u4E3A_u8F6F_u4EF6_u5F00_u53D1_u4E13_u5BB6" class="headerlink" title="作为软件开发专家"></a>作为软件开发专家</h2><ul>
<li>必须理解软件开发的细微差别<ul>
<li>准则</li>
<li>方法和技术</li>
<li>方法论</li>
<li>工具</li>
</ul>
</li>
<li>不一定要是世界级的软件开发者</li>
<li>应该理解不同架构选择的后果<ul>
<li>不要活在象牙塔中</li>
<li>理解架构选择会限制实现的方式</li>
<li>有些具体的实现技术也会限制架构选择</li>
</ul>
</li>
</ul>
<h2 id="u4F5C_u4E3A_u9886_u57DF_u4E13_u5BB6"><a href="#u4F5C_u4E3A_u9886_u57DF_u4E13_u5BB6" class="headerlink" title="作为领域专家"></a>作为领域专家</h2><ul>
<li>只有软件工程方面的经验是不够的</li>
<li>理解问题领域的细微差别<ul>
<li>成熟度</li>
<li>稳定性</li>
<li>系统用户档案 </li>
</ul>
</li>
<li>可能会极大影响架构选择<ul>
<li>分布</li>
<li>规模</li>
<li>可进化性</li>
</ul>
</li>
<li>需要为问题空间建模</li>
</ul>
<h2 id="u4F5C_u4E3A_u4EA4_u6D41_u8005"><a href="#u4F5C_u4E3A_u4EA4_u6D41_u8005" class="headerlink" title="作为交流者"></a>作为交流者</h2><ul>
<li>至少一半的时间应该花在沟通上</li>
<li>听取权益相关者的意见</li>
<li>解释架构</li>
<li>协商折中实现</li>
<li>需要良好的沟通技能<ul>
<li>写作</li>
<li>说话</li>
<li>展示 </li>
</ul>
</li>
</ul>
<h2 id="u4F5C_u4E3A_u7B56_u7565_u5BB6"><a href="#u4F5C_u4E3A_u7B56_u7565_u5BB6" class="headerlink" title="作为策略家"></a>作为策略家</h2><ul>
<li>开发优雅的架构是不够的<ul>
<li>技术只是一小部分</li>
<li>架构必须放到更大的场景中也适用</li>
</ul>
</li>
<li>架构必须满足公司的<ul>
<li>商业策略</li>
<li>商业实践</li>
<li>计划周期</li>
</ul>
</li>
<li>也需要考虑对手的<ul>
<li>产品</li>
<li>策略</li>
<li>开发过程</li>
</ul>
</li>
</ul>
<h2 id="u4F5C_u4E3A_u54A8_u8BE2_u5E08"><a href="#u4F5C_u4E3A_u54A8_u8BE2_u5E08" class="headerlink" title="作为咨询师"></a>作为咨询师</h2><ul>
<li>开发人员是首要的『客户』</li>
<li>对于开发人员来说<ul>
<li>目标和架构师不同</li>
<li>甚至可能不关心架构本身，而是</li>
<li>满足功能、质量和调度需求</li>
<li>所负责的子系统</li>
</ul>
</li>
<li>必须说服开发者<ul>
<li>理解和关注架构</li>
<li>对架构相关的改动进行文档记录</li>
</ul>
</li>
</ul>
<h2 id="u4F5C_u4E3A_u9886_u5BFC"><a href="#u4F5C_u4E3A_u9886_u5BFC" class="headerlink" title="作为领导"></a>作为领导</h2><ul>
<li>必须是技术领导者<ul>
<li>基于学识和成就</li>
<li>根据想法、专业经验、学识来下达命令</li>
<li>不要依赖于『等级权力』</li>
</ul>
</li>
<li>保证大家遵守设计决定、指引和规则</li>
<li>为了保证产品质量，需要引入<ul>
<li>新的想法，解决方案和技术</li>
<li>带领新人</li>
</ul>
</li>
<li>做关键决定</li>
<li>帮助完成实现</li>
</ul>
<h2 id="u4F5C_u4E3A_u6280_u672F_u4EBA_u5458"><a href="#u4F5C_u4E3A_u6280_u672F_u4EBA_u5458" class="headerlink" title="作为技术人员"></a>作为技术人员</h2><ul>
<li>理解软件开发的方法</li>
<li>理解基本的技术，如<ul>
<li>操作系统</li>
<li>网络</li>
<li>中间件</li>
<li>安全</li>
<li>数据库</li>
<li>图形用户界面</li>
</ul>
</li>
<li>跟随技术潮流（不是盲从）</li>
<li>在下面领域是专家<ul>
<li>系统建模</li>
<li>架构平衡分析</li>
<li>把架构方案和系统需求结合在一起</li>
</ul>
</li>
</ul>
<h2 id="u4F5C_u4E3A_u5F00_u9500_u8BC4_u4F30_u8005"><a href="#u4F5C_u4E3A_u5F00_u9500_u8BC4_u4F30_u8005" class="headerlink" title="作为开销评估者"></a>作为开销评估者</h2><ul>
<li>理解不同架构选择的在经济上的影响<ul>
<li>Green-field vs. Brown-field development</li>
<li>Cost of COTS adoption</li>
<li>Cost of development for reuse</li>
<li>Company’s financial stability &amp; position in marketpalce</li>
</ul>
</li>
<li>技术上最优的方案可能在经济上不一定是最优的</li>
<li>简单快速的开销评估通常已经足够 </li>
</ul>
<h2 id="u4F5C_u4E3A_u5566_u5566_u961F_u961F_u957F"><a href="#u4F5C_u4E3A_u5566_u5566_u961F_u961F_u957F" class="headerlink" title="作为啦啦队队长"></a>作为啦啦队队长</h2><ul>
<li>在长期、大型的复杂项目中很有用<ul>
<li>不同的开发小组负责不同的子项目</li>
<li>管理人员可能会忘记总体的项目目标</li>
<li>顾客可能没办法接受漫长的等待</li>
</ul>
</li>
<li>必须<ul>
<li>在必要的细节基础上维护高层视野</li>
<li>说服不同的权益相关者关于架构的<ul>
<li>Beauty</li>
<li>Utility</li>
<li>Adaptability</li>
<li>Technological impact</li>
<li>Financial impact</li>
</ul>
</li>
<li>让大家情绪高涨</li>
</ul>
</li>
</ul>
<h2 id="u4F5C_u4E3A_u653F_u6CBB_u5BB6"><a href="#u4F5C_u4E3A_u653F_u6CBB_u5BB6" class="headerlink" title="作为政治家"></a>作为政治家</h2><ul>
<li>必须找到组织中的关键人物</li>
<li>必须持续<ul>
<li>倾听</li>
<li>维持网络</li>
<li>善于表达</li>
<li>兜售愿景</li>
<li>从多个角度思考问题</li>
</ul>
</li>
</ul>
<h2 id="u4F5C_u4E3A_u9500_u552E_u4EBA_u5458"><a href="#u4F5C_u4E3A_u9500_u552E_u4EBA_u5458" class="headerlink" title="作为销售人员"></a>作为销售人员</h2><p>兜售</p>
<ul>
<li>总体愿景</li>
<li>技术解决方案</li>
<li>架构的关键属性</li>
<li>系统的关键属性</li>
<li>开销计划</li>
<li>保证架构的实现</li>
</ul>
<h2 id="u5173_u4E8E_u67B6_u6784_u5C0F_u7EC4"><a href="#u5173_u4E8E_u67B6_u6784_u5C0F_u7EC4" class="headerlink" title="关于架构小组"></a>关于架构小组</h2><ul>
<li>由架构师组成</li>
<li>通常有不同的层级</li>
<li>随着进展进展人数会变动</li>
<li>架构师可能会成为<ul>
<li>子系统的开发组长</li>
<li>调去其他的项目</li>
</ul>
</li>
<li>定义软件架构</li>
<li>维护架构</li>
<li>评估技术风险</li>
<li>协调不同小组</li>
<li>辅助项目管理</li>
<li>辅助产品定义</li>
<li>确定主要设计的主要元素</li>
<li>确定系统的组织或架构</li>
<li>确定主要元素的交互方式</li>
<li>与系统工程师和开发小组合作</li>
</ul>
<h2 id="u67B6_u6784_u5C0F_u7EC4_u53EF_u80FD_u7684_u98CE_u9669"><a href="#u67B6_u6784_u5C0F_u7EC4_u53EF_u80FD_u7684_u98CE_u9669" class="headerlink" title="架构小组可能的风险"></a>架构小组可能的风险</h2><ul>
<li>技能短板<ul>
<li>缺乏软件开发经验</li>
<li>缺乏领域相关经验</li>
</ul>
</li>
<li>缺乏权威</li>
<li>活在象牙塔中</li>
<li>混淆不同的工具、技术和方法</li>
<li>拖延</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们来讲讲人在整个系统开发过程中所发挥的重要作用，或者再简单一点，就是成为一个架构师，到底需要什么特质以及在团队中扮演什么角色。<br>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 18 课 Deployment and Mobility]]></title>
    <link href="http://wdxtub.com/2016/02/26/sad-18/"/>
    <id>http://wdxtub.com/2016/02/26/sad-18/</id>
    <published>2016-02-26T21:06:57.000Z</published>
    <updated>2016-02-27T19:58:49.000Z</updated>
    <content type="html"><![CDATA[<p>当软件开发接近尾声，部署和灵活性就成为了重要的考量，这一课我们简要了解一下大概的流程和步骤，具体可能要工作之后实际接触生产环境才有更多领悟。</p>
<a id="more"></a>
<hr>
<p>部署指的是把软件放到硬件主机上的过程，改变部署的方式称为迁移或者重新拿部署，这属于系统灵活性的范畴，即灵活性可以看做是部署的超集。但是因为部署和灵活性涉及到诸多可控不可控因素，所以还是有很多挑战的，如：</p>
<ul>
<li>可能有不同的处理器</li>
<li>不同的处理器在不同的设备中</li>
<li>不同的软件组件需要不同的硬件配置</li>
<li>系统的生命周期可能会维持数十年</li>
<li>软件系统在不断进化（需要重新部署）</li>
<li>灵活的代码使得重新部署的时候不会花太多功夫</li>
</ul>
<h2 id="u8F6F_u4EF6_u67B6_u6784_u4E0E_u90E8_u7F72"><a href="#u8F6F_u4EF6_u67B6_u6784_u4E0E_u90E8_u7F72" class="headerlink" title="软件架构与部署"></a>软件架构与部署</h2><p>一个系统可能需要部署到不同的主机或站点上，它们会提供下面的资源（可以是独占或者共享的）：</p>
<ul>
<li>硬件</li>
<li>网络</li>
<li>外围设备</li>
<li>系统软件</li>
<li>应用软件</li>
<li>数据源</li>
</ul>
<p>具体的部署活动包括；</p>
<ul>
<li>Planning</li>
<li>Modeling</li>
<li>Analysis</li>
<li>Implementation</li>
</ul>
<p>下面分别用图片来介绍：</p>
<p><img src="/images/14566028050423.jpg" alt="Deployment Planning"></p>
<p><img src="/images/14566030361624.jpg" alt="Deployment Modeling"></p>
<p><img src="/images/14566030595938.jpg" alt="Deployment Analysis"></p>
<p><img src="/images/14566030856276.jpg" alt="Software Deployment Life Cycle"></p>
<p>这一部分感觉讲得太宽泛了，以后应该会出另一个系列详细说明</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>当软件开发接近尾声，部署和灵活性就成为了重要的考量，这一课我们简要了解一下大概的流程和步骤，具体可能要工作之后实际接触生产环境才有更多领悟。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 17 课 Security and Trust]]></title>
    <link href="http://wdxtub.com/2016/02/26/sad-17/"/>
    <id>http://wdxtub.com/2016/02/26/sad-17/</id>
    <published>2016-02-26T21:06:50.000Z</published>
    <updated>2016-02-27T19:14:57.000Z</updated>
    <content type="html"><![CDATA[<p>安全和信任，同样也是系统设计中不可以获取的一部分，这节课我们来了解一下常见的解决方案和应用场景。</p>
<a id="more"></a>
<hr>
<p>所谓安全，其实就是保证系统的集成性、可用性以及保密性。一些常见的原则有：</p>
<ul>
<li>最小特权：每个组件只有其所需的特权</li>
<li>默认失败保护：如果没有权限，那么就拒绝访问</li>
<li>Economy of Mechanism：采用简单的安全机制</li>
<li>Complete Mediation：确保允许每次访问</li>
<li>设计：安全不应该依赖秘密</li>
<li>特权隔离：引入安全组以避免特权冲突</li>
<li>最小公共机件：关键资源只在小部分机件中共享</li>
<li>心理接受度：使安全机制可用</li>
<li>深度防御：有多层安全措施</li>
</ul>
<h2 id="u8BBF_u95EE_u63A7_u5236_u6A21_u578B"><a href="#u8BBF_u95EE_u63A7_u5236_u6A21_u578B" class="headerlink" title="访问控制模型"></a>访问控制模型</h2><p>这个模型用来控制对于某个资源的访问是否能被允许。动态访问控制是针对不同的请求者，有不同的权限控制。强制访问控制则是基于不同的规则的。</p>
<p><img src="/images/14565991139571.jpg" alt="动态访问控制的例子"></p>
<p><img src="/images/14565991916403.jpg" alt="强制访问控制的例子"></p>
<h2 id="u8FDE_u63A5_u5668_u4E3A_u4E2D_u5FC3_u7684_u8BBF_u95EE_u63A7_u5236"><a href="#u8FDE_u63A5_u5668_u4E3A_u4E2D_u5FC3_u7684_u8BBF_u95EE_u63A7_u5236" class="headerlink" title="连接器为中心的访问控制"></a>连接器为中心的访问控制</h2><ul>
<li>决定连接的组件执行哪些操作</li>
<li>在连接器中决定组件是否有足够权限</li>
<li>在不安全的组件间提供安全交互方式</li>
<li>在架构访问检查中传播特权</li>
<li>参与决定架构连接</li>
<li>根据已有的策略来转发消息</li>
</ul>
<h2 id="u53BB_u4E2D_u5FC3_u5316"><a href="#u53BB_u4E2D_u5FC3_u5316" class="headerlink" title="去中心化"></a>去中心化</h2><ul>
<li>没有统一的中央调度</li>
<li>独立节点进行自治</li>
<li>可能会有恶意节点</li>
<li>需要有机制来保证不受恶意节点攻击</li>
</ul>
<p>但是仍旧可能会有以下威胁：</p>
<ul>
<li>Impersonation：可以假扮其他人</li>
<li>Fraudulent Actions：不完成操作就停止执行</li>
<li>Misrepresenting Trust：可以广播虚假消息（如某个节点不可信）</li>
<li>Collusion：共同广播虚假消息（如某个节点不可信）</li>
<li>Addition of Unknowns</li>
</ul>
<h2 id="u4FE1_u4EFB_u7BA1_u7406"><a href="#u4FE1_u4EFB_u7BA1_u7406" class="headerlink" title="信任管理"></a>信任管理</h2><p>主要有两种机制</p>
<ol>
<li>Credential and Policy-based</li>
<li>Reputation-based</li>
</ol>
<p>具体的机制</p>
<ol>
<li>选择合适的基于声望的信任模型</li>
<li>准确描述信任模型</li>
<li>把这个模型应用到软件架构上(Software architectural style fro trust management, PACE)</li>
<li>最后我们的架构会包含<ul>
<li>封装了信任模型的组件</li>
<li>其他处理威胁的信任技术</li>
</ul>
</li>
</ol>
<p>针对前面提到的集中威胁，对应的方法是：</p>
<p><img src="/images/14565999331971.jpg" alt=""></p>
<p><img src="/images/14566003997636.jpg" alt="PACE Components"></p>
<p>总体来说，安全是一个很大的话题，不过我个人对这个领域兴趣不是特别大，更多可能只是使用现有的权限控制应用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>安全和信任，同样也是系统设计中不可以获取的一部分，这节课我们来了解一下常见的解决方案和应用场景。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 16 课 Non-Functional Property]]></title>
    <link href="http://wdxtub.com/2016/02/26/sad-16/"/>
    <id>http://wdxtub.com/2016/02/26/sad-16/</id>
    <published>2016-02-26T21:06:46.000Z</published>
    <updated>2016-02-27T01:09:34.000Z</updated>
    <content type="html"><![CDATA[<p>虽然非功能属性不会直接体现在具体的实现上，但仍然会对如何实现各种功能产生巨大的影响，这节课我们就来具体了解一下。</p>
<a id="more"></a>
<hr>
<p>非功能属性指的是那些比较『虚』的，但是对整个系统又有举足轻重影响的概念，比如：</p>
<ul>
<li>Efficiency</li>
<li>Complexity</li>
<li>Scalability</li>
<li>Heterogeneity</li>
<li>Adaptability</li>
<li>Dependability</li>
</ul>
<p>产品设计之初，都是根据其功能属性来决定的，但是确定合适的功能并不简单，市场需求、竞争对手等各种条件的限制。可是系统的最终成败，还是由非功能属性决定的，比方说反应速度、稳定性等等</p>
<h2 id="u6548_u7387_Efficiency_u3002"><a href="#u6548_u7387_Efficiency_u3002" class="headerlink" title="效率 Efficiency。"></a>效率 Efficiency。</h2><p>效率，简单来说，就是用最小的代价做最多的事情，我们要强调的是，对效率的追求，是从设计架构时开始的！</p>
<p>对于组件来说</p>
<ul>
<li>做『小』的组件</li>
<li>保持组件的接口简单和紧凑</li>
<li>为同一个功能提供多个接口</li>
<li>隔离数据组件和运算组件</li>
<li>隔离数据和元数据</li>
</ul>
<p>对于连接器来说</p>
<ul>
<li>仔细选择连接器</li>
<li>小心运用广播机制的</li>
<li>可能的话多利用异步机制来交互</li>
<li>Use location/distribution transparency judiciously（翻译不能）</li>
</ul>
<p>对于架构来说</p>
<ul>
<li>经常交互的组件应该更紧密</li>
<li>仔细选择连接器</li>
<li>考虑不同架构对效率的影响</li>
</ul>
<h2 id="u590D_u6742_u5EA6_Complexity"><a href="#u590D_u6742_u5EA6_Complexity" class="headerlink" title="复杂度 Complexity"></a>复杂度 Complexity</h2><p>复杂度，简单来说，就是整个系统在完成指定功能的前提下，有多简洁多清晰。</p>
<p>对于组件来说</p>
<ul>
<li>不同的特性放到不同的组件中</li>
<li>组件只负责功能本身</li>
<li>负责处理的组件应该不受数据格式变化的影响</li>
<li>组件应该能够轻松结合起来</li>
</ul>
<p>对于连接器来说</p>
<ul>
<li>显式处理连接器</li>
<li>连接器只负责交互</li>
<li>不同的特性放到不同的连接器中</li>
</ul>
<p>对于架构来说</p>
<ul>
<li>去掉不必要的依赖</li>
<li>显式管理所有的依赖</li>
<li>运用层级继承结构</li>
</ul>
<h2 id="u4F38_u7F29_u6027_Scalability"><a href="#u4F38_u7F29_u6027_Scalability" class="headerlink" title="伸缩性 Scalability"></a>伸缩性 Scalability</h2><p>伸缩性，简单来说，就是在不同平台，用不同数量的机器运行时，需不需要改动很多。</p>
<p>对于组件来说</p>
<ul>
<li>每个组件有单一且清晰定义的目的</li>
<li>每个组件有单一且容易理解的接口</li>
<li>组件不应该负责交互</li>
<li>避免不必要的多样性</li>
<li>需要的时候复制数据</li>
</ul>
<p>对于连接器来说</p>
<ul>
<li>使用显式连接器</li>
<li>每个连接器有清晰定义的责任</li>
<li>选择满足要求的最简单的连接器</li>
<li>注意直接/间接依赖</li>
<li>避免在连接器中放功能相关的代码</li>
</ul>
<p>对于架构来说</p>
<ul>
<li>避免系统瓶颈</li>
<li>利用并行处理能力</li>
<li>数据源靠近数据消费者</li>
<li>使用合适的架构风格</li>
<li>Try to make distribution transparent</li>
</ul>
<h2 id="u9002_u5E94_u6027_Adaptablity"><a href="#u9002_u5E94_u6027_Adaptablity" class="headerlink" title="适应性 Adaptablity"></a>适应性 Adaptablity</h2><p>适应性，简单来说，就是在面对环境和需求变更时，是否需要改动很多。</p>
<p>对于组件来说</p>
<ul>
<li>每个组件有单一且清晰定义的目的</li>
<li>最小化组件间的相互依赖</li>
<li>组件不应该负责交互</li>
<li>处理和数据隔离</li>
<li>数据和元数据隔离</li>
</ul>
<p>对连接器来说</p>
<ul>
<li>每个连接器有清晰定义的责任</li>
<li>让连接器足够灵活</li>
<li>支持连接器组合</li>
</ul>
<p>对于架构来说</p>
<ul>
<li>使用显示连接器</li>
<li>使用合适的架构风格</li>
<li>Try to make distribution transparent</li>
</ul>
<h2 id="u53EF_u9760_u6027_Dependability"><a href="#u53EF_u9760_u6027_Dependability" class="headerlink" title="可靠性 Dependability"></a>可靠性 Dependability</h2><p>可靠性，简单来说，就是下面这几个词：Reliability, Availability, Robustness, Fault-tolerant, Survivability, Safety</p>
<p>对于组件来说</p>
<ul>
<li>仔细控制外部组件的依赖</li>
<li>令组件支持 reflection</li>
<li>组件包含异常处理机制</li>
<li>Specify the components’ key state invariants</li>
</ul>
<p>对于连接器来说</p>
<ul>
<li>严格控制组件的依赖</li>
<li>保证组件的合理交互</li>
</ul>
<p>对于架构来说</p>
<ul>
<li>避免单点失败</li>
<li>关键的功能和数据要有备份机制</li>
<li>支持系统监控</li>
<li>支持动态适应</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然非功能属性不会直接体现在具体的实现上，但仍然会对如何实现各种功能产生巨大的影响，这节课我们就来具体了解一下。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 15 课 Applied Architectures]]></title>
    <link href="http://wdxtub.com/2016/02/26/sad-15/"/>
    <id>http://wdxtub.com/2016/02/26/sad-15/</id>
    <published>2016-02-26T21:06:41.000Z</published>
    <updated>2016-02-27T00:09:39.000Z</updated>
    <content type="html"><![CDATA[<p>上节课我们了解了具体分析不同架构的方法，这节课我们主要来看看，如何应用不同的架构。</p>
<a id="more"></a>
<hr>
<h2 id="u5206_u5E03_u5F0F/_u7F51_u7EDC_u67B6_u6784"><a href="#u5206_u5E03_u5F0F/_u7F51_u7EDC_u67B6_u6784" class="headerlink" title="分布式/网络架构"></a>分布式/网络架构</h2><p>类似『没有摩擦力』的小滑块，分布式架构是『乐观』建立在如下『完美』假设之上的，很多时候都难以满足：</p>
<ul>
<li>网络是可靠的</li>
<li>延迟是没有的</li>
<li>带宽是无限的</li>
<li>网络是安全的</li>
<li>拓扑结构是不变的</li>
<li>只有一个管理员</li>
<li>传输数据是不要钱的</li>
<li>网络是多种多样的</li>
</ul>
<p>虽然我们知道这些假设都是『美好的愿望』，不过我们还是借此建立起了一个庞大的分布式系统，也就是—— WWW（万维网）。作为一个分布式、去中心化的超媒体，整个 Web 的架构和代码是完全分离的，或者说，其实没有任何的代码去实现这个架构。我们有的，只是对于这个架构中不同组件的不同实现（比如说不同的浏览器）。</p>
<p>从架构的角度来看，就会发现互联网可能是这个世界上最成功的应用，更神器的是，居然没有任何代码去实现所谓『架构』！</p>
<p>所以我们知道，架构并不一定是一个有形的需要实现的东西，可能本身只是一种思想一种约定，不同的组件组合起来，就成为了架构。</p>
<h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p>我们总是能看到 RESTful API 这个词，但是到底是个什么意思？不妨从最基本的规则开始</p>
<ol>
<li>最关键的一步是把信息抽象成为以 URL 命名的资源。只要是能被命名的信息，就可以是一个资源</li>
<li>资源的表示方法是一系列字节，加上自描述的 metadata，具体的表示形式可以由不同的 REST 组件协调确定</li>
<li>所有的交互都是上下文无关的，每次交互都包含所需所有信息，不依赖于之前的请求</li>
<li>每个组件只执行预定义好的方法，处理完成之后把资源传递给其他组件</li>
<li>使用幂等操作和表达形式来支持缓存和重用</li>
<li>The presence of intermediaries is promoted. Filtering or redirection intermediaries may also use both the metadata and the representations within requests or responses to augment, restrict, or modify requests and responses in a manner that is transparent to both the user agent and the origin server.(不知道怎么翻译)</li>
</ol>
<p>下面是一个例子：</p>
<p><img src="/images/14565259010138.jpg" alt="REST 的一个实例"></p>
<p>在 REST 中的数据元素包含下面的内容：</p>
<ul>
<li>Resource</li>
<li>Resource ID</li>
<li>Representation: Data + metadata</li>
<li>Representation metadata</li>
<li>Resource metadata</li>
<li>Control data</li>
</ul>
<p>而具体的连接器有以下例子：</p>
<ul>
<li>client: libwww, libwww-perl</li>
<li>server: libwww, Apache API, NASPI</li>
<li>cache: brower cache, Akamai cache network</li>
<li>resolver: bind (DNS lookup library)</li>
<li>tunnel: SOCKS, SSL after HTTP CONNECT</li>
</ul>
<p>最后是组件的例子</p>
<ul>
<li>User agent: brower</li>
<li>Origin server: Apache Server, Microsoft IIS</li>
<li>Proxy: Selected by client</li>
<li>Gateway: Squid, CGI, Reverse proxy(Controlled by server)</li>
</ul>
<h2 id="u53BB_u4E2D_u5FC3_u5316_u67B6_u6784"><a href="#u53BB_u4E2D_u5FC3_u5316_u67B6_u6784" class="headerlink" title="去中心化架构"></a>去中心化架构</h2><p>所谓去中心化架构，实际上可以看成是某种意义上的『自治』与『分权』，网络中的不同组件可以有不同的行为，计算的过程也是分布式的。就好像我们现实生活中的合作一样。</p>
<p>比较有代表性了两个架构，就是我们下面要说的点对点和 web 服务。</p>
<h3 id="u70B9_u5BF9_u70B9"><a href="#u70B9_u5BF9_u70B9" class="headerlink" title="点对点"></a>点对点</h3><p>去中心化的资源发现与共享，如 Napster 与 Gnutell，Skype 与 BitTorrent，也就是说没有一个所谓的『主服务器』来存储各种信息，每一台机子既可以看做是『客户端』，也可以认为是『服务端』。</p>
<ul>
<li>每个组件是相互独立的，有其自己的状态与控制线程。</li>
<li>连接器：通常是自定义的网络协议</li>
<li>数据元素：网络消息</li>
<li>拓扑结构：动态随机有重复连接的网络</li>
</ul>
<p>这种结构通过控制流和资源分布支持去中心化计算。即使有节点出现问题，也不会受到很大影响。</p>
<p>后面的内容比较常规（因为课本比较老 PS 老师年纪不大怎么也这么老派），大部分内容维基上的内容都比较详细了，这里不赘述，具体可以参考：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1" target="_blank" rel="external">Web服务</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6" target="_blank" rel="external">机器人学</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%A3%9B%E8%A1%8C%E6%A8%A1%E6%93%AC%E5%99%A8" target="_blank" rel="external">飞行模拟器</a></li>
</ul>
<h2 id="u5982_u4F55_u5904_u7406_u590D_u6742_u6027"><a href="#u5982_u4F55_u5904_u7406_u590D_u6742_u6027" class="headerlink" title="如何处理复杂性"></a>如何处理复杂性</h2><p>虽然前面没有介绍飞行模拟器，但是因为需要比较现实的『模拟』，所以可以想到整个系统肯定是比较复杂的。于是我们怎么样能通过设计来减小复杂度呢？</p>
<ul>
<li>首先可以采用结构化建模的方法，基于面向对象设计来处理子系统和组件，目标是提高可维护性，集成性与可拓展性。</li>
<li>软件部分，预先给不同的功能集合分簇，限制不合理的数据流与控制流，尽量减少数据类型。</li>
<li>最后，每个组件保证封装性，计算不带副作用，不同组件之间要有交流和同步。</li>
</ul>
<p>总结起来有以下四条</p>
<ol>
<li>好的架构是成功的一半</li>
<li>好的架构源于对问题领域的深入理解</li>
<li>好的架构可能是若干简单架构的结合</li>
<li>开发新架构需要话很大力气，也要很小心。不过通常来说都不需要这么做。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>上节课我们了解了具体分析不同架构的方法，这节课我们主要来看看，如何应用不同的架构。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 课程项目 1 搭建高性能数据获取网络服务]]></title>
    <link href="http://wdxtub.com/2016/02/25/cc-p1/"/>
    <id>http://wdxtub.com/2016/02/25/cc-p1/</id>
    <published>2016-02-26T00:35:05.000Z</published>
    <updated>2016-02-26T17:49:26.000Z</updated>
    <content type="html"><![CDATA[<p>从这次作业开始，就要小组作业和个人作业并行了。这次的项目主要是在云上分析 Twitter 的相关内容，与以前 GB 级数据不一样，这次我们要处理 TB 级的数据，还是很刺激的。另，这是小组作业，在此先感谢我的队友 @leiyu 和 @shushanc</p>
<a id="more"></a>
<hr>
<p>主要任务是：Twitter Analytics on the Cloud</p>
<h2 id="u4EFB_u52A1_u76EE_u6807"><a href="#u4EFB_u52A1_u76EE_u6807" class="headerlink" title="任务目标"></a>任务目标</h2><ol>
<li>在一定预算限制下利用所学知识搭建一个性能高可靠性又好的 web 服务</li>
<li>设计、开发、部署和优化服务器以处理比较高的负载（大约每秒上万次请求）</li>
<li>在一个大数据集上（约 1TB）实现 Extract Transform and Load (ETL) 并载入到 MySQL  和 HBase 中</li>
<li>设计 MySQL 和 HBase 的 schema 并优化配置来提高性能</li>
<li>探索寻找基于云的 web 服务中潜在瓶颈的方法，并提高性能</li>
</ol>
<p>我们需要搭建并优化一个有两个组件的 web 服务，前端负责处理请求，后端负责查询数据，架构如图：</p>
<p><img src="/images/14564545973314.jpg" alt="系统架构"></p>
<ol>
<li>前端：能够接收和响应查询请求的 web 服务<ul>
<li>用过通过指定网址发送 HTTP GET 请求来访问 web 服务。不同的请求有不同的地址，后面跟有不同的参数</li>
<li>要返回适当的响应，并且一定要按照指定的格式</li>
<li>Web 服务需要在持续若干小时的测试中正常运行</li>
<li>Web 服务不能拒绝请求，应该能够承受高负载</li>
</ul>
</li>
<li>后端：保存用来查询的数据文件<ul>
<li>需要评估 SQL(MySQL) 和 NoSQL(HBase)</li>
<li>比较不同数据集不同查询类型的性能表现，然后由此来决定如何实现后端</li>
</ul>
</li>
<li>Web 服务应该在不超过预算的情况下达到指定的吞吐量</li>
<li>钱花得越少越好</li>
<li>前端和后端均使用 M 系列的实例，批量处理的时候注意使用竞价实例（总之就是要省钱）</li>
</ol>
<blockquote>
<p>数据集</p>
</blockquote>
<ul>
<li>数据集地址为：<code>s3://cmucc-datasets/twitter/s16/</code></li>
<li>大小超过 1 TB，还会有重复和损坏的记录</li>
<li><a href="http://en.wikipedia.org/wiki/JSON" target="_blank" rel="external">JSON</a> 格式，每行表示一个 tweet，具体看<a href="https://dev.twitter.com/docs/platform-objects/tweets" target="_blank" rel="external">Twitter API</a>.</li>
<li>字符编码是 unicode，建议使用下面的库<ul>
<li>simple json/gson(Java)</li>
<li>标准库中的 json module(python)</li>
</ul>
</li>
</ul>
<blockquote>
<p>进度安排及制品</p>
</blockquote>
<p>项目分三个阶段，每个阶段完成不同的任务，每个阶段完成之后都需要提交制品：</p>
<ol>
<li>性能数据</li>
<li>开销分析</li>
<li>源代码</li>
<li>问答题的答案</li>
<li>阶段报告，包括设计选择和制品描述 </li>
</ol>
<h3 id="u5E38_u89C1_u95EE_u9898"><a href="#u5E38_u89C1_u95EE_u9898" class="headerlink" title="常见问题"></a>常见问题</h3><blockquote>
<p>如何提交测试请求？</p>
</blockquote>
<p>提交 web 服务的地址即可开始测试，提供不同时间长度的测试，可以有针对性进行选择，比方说如果只是为了检测服务能否正常运行，那么可能几分钟的测试就够了；如果想要看看长时间能否工作，就需要长时间的测试。</p>
<blockquote>
<p>到底测试什么？</p>
</blockquote>
<p>简单来说，每次提交测试请求之后，系统会产生特定的请求并发送到之前填写的地址，会检测性能和正确性。</p>
<blockquote>
<p>为什么提交不了请求了？</p>
</blockquote>
<p>为了省钱，每个队伍同时只能用一个测试在跑（或者在排队）</p>
<p>还可以取消当前的测试请求并重新提交</p>
<blockquote>
<p>如何计算分数？</p>
</blockquote>
<p>主要考察下面几点</p>
<ul>
<li>吞吐量：测试期间平均 RPS</li>
<li>延迟：平均每个请求的延迟</li>
<li>错误率：不返回 2XX 都是错误</li>
<li>正确率：检测是否返回正确的内容，注意仔细检查格式</li>
</ul>
<p>具体计算公式为：</p>
<ul>
<li>有效吞吐量 = 吞吐量 <em> (100 - 错误率 / 100) </em> (正确率 / 100)</li>
<li>原始分 = 有效吞吐量 / 目标吞吐量</li>
</ul>
<p>注意，错误率与正确率都会极大影响最后的分数</p>
<h2 id="u4EFB_u52A1_u6982_u89C8"><a href="#u4EFB_u52A1_u6982_u89C8" class="headerlink" title="任务概览"></a>任务概览</h2><h3 id="u524D_u7AEF"><a href="#u524D_u7AEF" class="headerlink" title="前端"></a>前端</h3><p>接收 RESTful 请求并返回响应，不限制所使用的 web 框架，但是需要至少使用两种，并比较他们的异同，最好使用竞价实例，省钱。</p>
<p>最好考虑使用 auto-scaling，因为测试的过程中会有波动。设计前端的时候要考虑到开销，并且写好测试脚本，不然每次都要部署一次很麻烦。</p>
<p>不同的 web 框架的性能也很不一样，如果一开始就选择了比较慢的框架，就相当于选择了 hard 模式，所以开始之前不妨看看主流框架的对比，详情参阅 <a href="https://www.techempower.com/benchmarks/" target="_blank" rel="external">Techempower</a></p>
<p>还有一个需要考虑的问题是，选择的前端框架最好有支持 MySQL 和  HBase 的 API，不然可能后面会很麻烦。在报告中注意写清楚为什么选择用某个框架。</p>
<h3 id="ETL"><a href="#ETL" class="headerlink" title="ETL"></a>ETL</h3><p>这部分的工作，需要使用 extract, transform and load (ETL) 把 Twitter 的数据集载入到数据仓库中。先从 S3 中获取大约 200 million tweets，然后把数据存储到目标数据库中，具体的操作取决于数据库设计。最好使用竞价实例，不然很可能会超支。</p>
<p>我们需要使用 AWS 精心设计 ETL 过程，选择合适的实例数量来完成这个工作，完成这个工作后，最好把数据库备份起来，不然每次都要做一次非常浪费钱，使用 EMR 的话，可以用下面这条命令把 HBase 备份到 S3 中</p>
<p><code>aws emr create-hbase-backup --cluster-id j-3AEXXXXXX16F2 --dir s3://mybucket/backups/j-3AEXXXXXX16F2 --consistent</code></p>
<p>详情请参阅<a href="http://docs.aws.amazon.com/ElasticMapReduce/latest/DeveloperGuide/emr-hbase-backup-restore.html" target="_blank" rel="external">这里</a></p>
<p>最好先用小数据集（比如说 200MB）来测试 ETL，不然每次失误的代价就太大了。载入数据库之后最好测试不同的请求类型，确保无误之后再开始后面的工作。</p>
<p>一定要仔细设计数据库的 schema，并据此好好设计 ETL，并确保 ETL 正确工作。因为每次都需要 10-30 个小时，如果需要做几次的话，很痛苦（虽然难以避免，很多时候可能在开发中会修改设计）</p>
<p>早点开始，多多利用并行，比较推荐使用 map reduce 来完成这个工作</p>
<h3 id="u540E_u7AEF"><a href="#u540E_u7AEF" class="headerlink" title="后端"></a>后端</h3><p>实际上就是所有数据存放的地方，前端会连接到后端来进行查询，最后返回对应结果。</p>
<p>这里我们会使用 MySQL 和 HBase，记得阅读提供的资料，可以快速上手。因为预算问题，还是多使用竞价实例。</p>
<p>在导入整个数据集之前，一定要用小数据集做一些测试，并确保后端数据库能返回正确的内容。</p>
<p>详情参考 <a href="http://dev.mysql.com/doc/" target="_blank" rel="external">MySQL</a> 和 <a href="https://hbase.apache.org/" target="_blank" rel="external">HBase</a></p>
<h3 id="u76F8_u5173_u8D44_u6E90_u4E0E_u53C2_u8003_u8D44_u6599"><a href="#u76F8_u5173_u8D44_u6E90_u4E0E_u53C2_u8003_u8D44_u6599" class="headerlink" title="相关资源与参考资料"></a>相关资源与参考资料</h3><p>Resources</p>
<ol>
<li><a href="https://www.techempower.com/benchmarks/" target="_blank" rel="external">Benchmarks of web servers</a></li>
<li><a href="http://www.percona.com/blog/2010/05/04/goal-driven-performance-optimization-white-paper-available/" target="_blank" rel="external">Schwartz, B., and P. Zaitsev. “A brief introduction to goal-driven performance optimization.” White paper, Percona (2010).</a></li>
<li><a href="http://www.percona.com/resources/mysql-webinars/practical-mysql-performance-optimization" target="_blank" rel="external">Practical MySQL Performance Optimization</a></li>
<li><a href="http://refcardz.dzone.com/refcardz/hbase" target="_blank" rel="external">HBase Cheat Sheet</a></li>
</ol>
<p>Architecting web servers</p>
<ol>
<li><a href="http://vts.uni-ulm.de/docs/2012/8082/vts_8082_11772.pdf" target="_blank" rel="external">Erb, Benjamin. “Concurrent programming for scalable web architectures.” Informatiktage. 2012.</a></li>
<li><a href="https://www.ece.cmu.edu/~ece845/docs/pariag-2007.pdf" target="_blank" rel="external">Pariag, David, et al. “Comparing the performance of web server architectures.” ACM SIGOPS Operating Systems Review. Vol. 41. No. 3. ACM, 2007.</a></li>
<li><a href="http://mmcgrana.github.io/2010/07/threaded-vs-evented-servers.html" target="_blank" rel="external">McGranaghan, Mark. “Threaded vs Evented Servers”</a></li>
<li><a href="https://www.dre.vanderbilt.edu/~schmidt/PDF/globalinternet.pdf" target="_blank" rel="external">Hu, James C., Irfan Pyarali, and Douglas C. Schmidt. “Measuring the impact of event dispatching and concurrency models on web server performance over high-speed networks.” Global Telecommunications Conference, 1997. GLOBECOM’97., IEEE. Vol. 3. IEEE, 1997.</a></li>
</ol>
<p>Clustering web servers</p>
<ol>
<li><a href="http://digitalcommons.unl.edu/cgi/viewcontent.cgi?article=1083&amp;context=csearticles" target="_blank" rel="external">Schroeder, Trevor, Steve Goddard, and Byrov Ramamurthy. “Scalable web server clustering technologies.” Network, IEEE 14.3 (2000): 38-45.</a></li>
<li><a href="http://www.ics.uci.edu/~cs230/reading/DLB.pdf" target="_blank" rel="external">Cardellini, Valeria, Michele Colajanni, and S. Yu Philip. “Dynamic load balancing on web-server systems.” IEEE Internet computing 3.3 (1999): 28-39.</a></li>
<li><a href="http://uu.diva-portal.org/smash/get/diva2:443102/FULLTEXT01.pdf" target="_blank" rel="external">Paudyal, Umesh. “Scalable web application using node.js and couchdb.” (2011).</a></li>
</ol>
<p>Optimizing a Multi-tier System</p>
<ol>
<li><a href="http://www.linuxjournal.com/article/7451" target="_blank" rel="external">Fitzpatrick, Brad. “Distributed caching with memcached.” Linux journal 2004.124 (2004): 5.</a></li>
<li><a href="http://www.linuxjournal.com/content/speed-your-web-site-varnish" target="_blank" rel="external">Graziano, Pablo. “Speed up your web site with Varnish.” Linux Journal 2013.227 (2013): 4.</a></li>
<li><a href="http://www.linuxjournal.com/magazine/nginx-high-performance-web-server-and-reverse-proxy" target="_blank" rel="external">Reese, Will. “Nginx: the high-performance web server and reverse proxy.” Linux Journal 2008.173 (2008): 2.</a></li>
</ol>
<p>Scalable and Performant Data Stores</p>
<ol>
<li><a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" target="_blank" rel="external">DeCandia, Giuseppe, et al. “Dynamo: amazon’s highly available key-value store.” ACM SIGOPS Operating Systems Review. Vol. 41. No. 6. ACM, 2007.</a></li>
<li><a href="http://www.cattell.net/datastores/Datastores.pdf" target="_blank" rel="external">Cattell, Rick. “Scalable SQL and NoSQL data stores.” ACM SIGMOD Record 39.4 (2011): 12-27.</a></li>
</ol>
<p>Web Server Performance Measurement</p>
<ol>
<li><a href="http://www.oocities.org/webserverperformance/webmodel.pdf" target="_blank" rel="external">Slothouber, Louis P. “A model of web server performance.” Proceedings of the 5th International World wide web Conference. 1996.</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.61.3268&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">Banga, Gaurav, and Peter Druschel. “Measuring the Capacity of a Web Server.” USENIX Symposium on Internet Technologies and Systems. 1997.</a></li>
<li><a href="https://www.mnot.net/blog/2011/05/18/http_benchmark_rules" target="_blank" rel="external">Nottingham, Mark. “On HTTP Load Testing”</a></li>
</ol>
<h2 id="u57FA_u672C_u8981_u6C42"><a href="#u57FA_u672C_u8981_u6C42" class="headerlink" title="基本要求"></a>基本要求</h2><ul>
<li>给所有的实例打上 <code>15619project:phase1</code> 的标签</li>
<li>另外，HBase 实例需要打上 <code>15619backend:hbase</code> 标签；MySQL 实例需要打上 <code>15619backend:mysql</code> 标签</li>
<li>ETL 部分可以选择任何类型的实例</li>
<li>前端和后端只能只用 M 系列不超过 large 的实例（large 也是可以用的）</li>
<li>可以选择任何免费的镜像，这次需要自己搭建整个系统</li>
<li>Web 服务的所有开销加起来不能超过每小时 <code>$0.85</code>（包括 EC2 实例，存储，EMR 和 ELB，不包括网络和磁盘 IO）</li>
<li>这个阶段每组有 <code>$40</code> 的预算</li>
</ul>
<p>虽然这一部分只占 10%，但是打下的基础很重要，尽可能多学多了解一些。</p>
<p><img src="/images/14564602178732.jpg" alt="任务要求"></p>
<p><img src="/images/14564603584769.jpg" alt="惩罚措施"></p>
<p>我们也提供了一个 <a href="http://q1-1848733628.us-east-1.elb.amazonaws.com/" target="_blank" rel="external">reference server</a> 方便大家检查结果的正确性，强烈建议在开始导入到数据库之前用 reference server 测试好。也可以利用这个服务器来检测可能出现的编码问题。</p>
<p>这一阶段我们要处理两类请求，从存储系统中获取数据（这一部分我们需要设计和控制），web service 需要能够连接到两个不同的后端存储系统(MySQL 和 HBase)，前端需要通过端口 80 接收 HTTP GET 请求。</p>
<p>这次的项目中，我们会设计并开发一个高并行的 web 服务器，可以连接到两种不同类型的数据库。在整个过程中，应该能够了解到不同后端实现的优势和劣势。</p>
<p>最后需要撰写报告，模板在 <a href="https://docs.google.com/document/d/1VOjU9JRAZG49PSrKnJtMOjSj5e1Ugbv_cQj7Mc_krd0/edit?usp=sharing" target="_blank" rel="external">这里</a></p>
<p>报告中需要包括 web 框架的如下信息：</p>
<ul>
<li>达到的 RPS</li>
<li>资源利用(CPU, Memory)</li>
<li>编程难度</li>
<li>两个框架的异同</li>
<li>适用的不同场景和优劣分析</li>
<li>为什么选择这些 web 框架</li>
</ul>
<h2 id="Query_1__28Heartbeat_and_Authentication_29"><a href="#Query_1__28Heartbeat_and_Authentication_29" class="headerlink" title="Query 1 (Heartbeat and Authentication)"></a>Query 1 (Heartbeat and Authentication)</h2><blockquote>
<p>目标吞吐量：25000 rps</p>
</blockquote>
<p>这部分的请求会询问 web 服务的状态，前端只需要返回 team id, AWS id, 时间戳以及一段加密的信息。这种机制通常称为心跳机制，但是也可以用来测试前端处理请求的能力。</p>
<p>q1 中的每个请求都包含 key <code>Y</code> 和一段由 key <code>Z</code> 加密的文本，<code>Z</code> 是 <code>X</code> 和 <code>Y</code> 的最大公约数（这里 <code>X</code> 是私钥）。这里我们使用 mythical Phaistos Disc Cipher (PDC) 来加密和解密</p>
<p>PDC 是为长度为完全平方数(4,9,16,25…)的大写英文字母(A-Z)组成的信息所设计的加密方式。我们需要自己进行解密的工作，也就是给定 key 和密文，获取原始的文本</p>
<p>PDC 的过程有三个步骤：KeyGen, Caesarify 和 Spiralize.</p>
<ol>
<li>KeyGen 阶段：随机选择一个大整数 <code>Y</code>，计算 <code>Y</code> 和我们的密钥 <code>X</code> 的最大公约数，记为 <code>Z</code> </li>
<li>Caesarify 阶段：利用 <code>Z</code> 生成一个 minikey <code>K = 1 + Z % 25</code>。我们把消息 <code>M</code> 中的每个字符都『偏移』<code>K</code> 个值，生成中间文本 <code>I</code></li>
<li>Spiralize 阶段：把消息选择写成正方形矩阵（参考下面的例子），然后再一行一行读出来，重排之后的消息就是密文<code>C</code>.</li>
</ol>
<p><img src="/images/14564607523532.jpg" alt="Spiral Matrix Example"></p>
<p>密文是：1,2,3,4,12,13,14,5,11,16,15,6,10,9,8,7（因为这里是数字，所以加上逗号方便区分）</p>
<p>Phaistos Disc Cipher encryption 的例子</p>
<p><img src="/images/14564607621256.jpg" alt="Phaistos Disc Cipher"></p>
<p>我们需要做的是解密，也就是给定密文 <code>C</code> 和 key <code>Y</code>，需要利用私钥 <code>X</code> 生成 <code>Z</code>，然后用 <code>Z</code> 来还原消息</p>
<blockquote>
<p>请求格式</p>
</blockquote>
<p><code>GET /q1?key=&lt;large_number&gt;&amp;message=&lt;uppercase_ciphertext_message_C&gt;</code></p>
<p>样例</p>
<p><code>GET /q1?key=4024123659485622445001958636275419709073611535463684596712464059093821&amp;message=URYEXYBJB</code></p>
<blockquote>
<p>响应格式（美东时间 EST）</p>
</blockquote>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEAMID,TEAM_AWS_ACCOUNT_ID\<span class="keyword">n</span></span><br><span class="line">yyyy-MM-dd HH:mm:ss\<span class="keyword">n</span></span><br><span class="line">[The decrypted message <span class="keyword">M</span>]\<span class="keyword">n</span></span><br></pre></td></tr></table></figure>
<p>样例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TeamCoolCloud,<span class="number">1234</span>-<span class="number">0000</span>-<span class="number">0001</span></span><br><span class="line"><span class="number">2004</span>-<span class="number">08</span>-<span class="number">15</span> <span class="number">16</span>:<span class="number">23</span>:<span class="number">42</span></span><br><span class="line">HELLOWORK</span><br></pre></td></tr></table></figure>
<p>这一部分我们只需要处理前端的问题，暂时不用考虑后端。</p>
<h2 id="Query_2__28Text_Cleaning_and_Analysis_29"><a href="#Query_2__28Text_Cleaning_and_Analysis_29" class="headerlink" title="Query 2 (Text Cleaning and Analysis)"></a>Query 2 (Text Cleaning and Analysis)</h2><p>目标吞吐量: 10000 rps</p>
<p>不允许使用任何已有的缓存应用 (Redis, Memcached, etc.) 或除了 MySQL 和 HBase 之外的数据库。但是可以自己写缓存应用。</p>
<p>在 ETL 阶段可以使用任何类型的实例，比如 <code>c family (Compute Optimized)</code> 和 <code>r family (Memory Optimized)</code>，不必只局限于 <code>m family (General Purpose)</code></p>
<p>MySQL 可以参考官方的优化文档，如果需要的话也可以使用其他版本的 MySQL</p>
<p>HBase: 可以选择用 EMR 来设置 HBase，或者自己搭建，不过自己搭建就要装 zookeeper 之类的，可以自行研究一下。</p>
<p>这里我们会对 Twitter 数据集进行分析，地址是 <code>s3://cmucc-datasets/twitter/s16/part-00XXX</code>，XXX 从 000 到 661。</p>
<p>会查询某个用户用指定的 hashtag 发的 tweet，主要考察如何设计一个高效的后端来处理大量的请求。</p>
<p>我们会提供 user id 和 hashtag（具体参考<a href="https://support.twitter.com/articles/49309?lang=en" target="_blank" rel="external">这里</a>），需要返回该用户所有带此 hashtag 的 tweet，具体格式如下：</p>
<ul>
<li>tweet 的 sentiment density</li>
<li>tweet 的发布时间</li>
<li>tweet id</li>
<li>审查修改过的的 tweet 内容，这里有很多可能出问题的地方，比如 emoji 表情、反斜杠、其他语言的字符等等，都需要小心处理</li>
</ul>
<p>Here is how you can obtain this information:</p>
<ol>
<li>利用 tweet 的内容来计算 sentiment density</li>
<li>tweet id 可以从 <code>id</code> 或 <code>id_str</code> 里获取</li>
<li>时间可以从 <code>created_at</code> 里获取</li>
<li>Tweet 的内容可以从 <code>text</code> 里获取，应该在计算完 sentiment density 再进行内容审查</li>
<li>hashtag(s) 可以从 <code>entities</code> 里获取，如果同一个 hashtag 在一条 tweet 中出现多次，只应该返回那条 tweet 一次</li>
</ol>
<p>注意事项：</p>
<ul>
<li>需要过滤掉重复的 Tweets（有相同的 id），返回响应的时候一条 tweet 只应该出现一次</li>
<li>满足下面条件的 tweet 也应该被过滤掉<ul>
<li><code>id</code> 和 <code>id_str</code> 为空或者没有这两个域</li>
<li><code>created_at</code>、<code>text</code> 或 <code>entities</code> 为空或者直接没有这几个域</li>
<li>无法被解析为 JSON 对象的记录</li>
</ul>
</li>
<li>Hashtag matching 需要百分百匹配（每个字节都一致），例如 “Naive”, “naive” 和 “naïve” 是不匹配的</li>
</ul>
<h3 id="u60C5_u611F_u5BC6_u5EA6"><a href="#u60C5_u611F_u5BC6_u5EA6" class="headerlink" title="情感密度"></a>情感密度</h3><p>按照下面四个步骤来计算 Sentiment Density</p>
<ol>
<li>文本切分：把推文分隔成一个一个词，注意，这里堆单词的定义是：one or more consecutive alphanumeric characters ([a-zA-Z0-9]+) separated by non-alphanumeric character(s) ([^a-zA-Z0-9])</li>
<li>计算情感得分：简单来说，就是有一个小写字母的英文单词情感词典，只要推文中的某个词在这个词典里，就加上这个词的情感得分（初始分为零），情感词典来自 <a href="http://www2.imm.dtu.dk/pubdb/views/publication_details.php?id=6010" target="_blank" rel="external">AFINN</a> 数据集，在<a href="https://cmucc-datasets.s3.amazonaws.com/15619/f15/afinn.txt" target="_blank" rel="external">这里</a>下载 <ul>
<li>例如：”I love Cloud Computing” 这句话的得分是 3，因为 love 这个单词在情感词典中，且分值为 3</li>
</ul>
</li>
<li>计算有效词数量：也就是过滤掉 stop words。所谓 Effective Word Count(EWC) 可以这样计算 EWC = 总单词数目 - 停止词的数目<ul>
<li>例如：”I love Cloud Computing” 的 EWC 是 3，因为 “I” 是一个停止词</li>
</ul>
</li>
<li>计算 Sentiment Density：如果 EWC 是 0，那么 Sentiment Density 就是 0，如果 EWC 不为 0，那么计算公式是 Sentiment Score / EWC</li>
</ol>
<p>所有的计算结果都四舍五入保留三位小数 (1 -&gt; 1.000, 1.1-&gt;1.100, 1.0005 -&gt; 1.001, 1.9999 -&gt; 2.000, -1 -&gt; -1.000, -1.1-&gt; -1.100, -1.0005 -&gt; -1.001, -1.9999 -&gt; -2.000, etc.)</p>
<p>一个完整的例子：</p>
<p>“I love Cloud Computing” 的 Sentiment Density 为 1.000, 因为它的 Sentimental Score(3) 除以 EWC(3) 是 1.000.</p>
<h3 id="u6587_u672C_u5BA1_u67E5"><a href="#u6587_u672C_u5BA1_u67E5" class="headerlink" title="文本审查"></a>文本审查</h3><p>简单来说就是有敏感词，列表是经过 <a href="http://en.wikipedia.org/wiki/ROT13" target="_blank" rel="external">ROT13ed</a> 处理的。例如，假如一个敏感词是 <code>15619ppgrfg</code> 那么原文就是 <code>15619cctest</code>。具体的敏感词列表在<a href="https://cmucc-datasets.s3.amazonaws.com/15619/f15/banned.txt" target="_blank" rel="external">这里</a>下载</p>
<p>一定要先计算情感值然后再进行文本审查，遇到敏感词，把除第一个和最后一个单词都替换成星号(<code>*</code>).</p>
<p>例如，假设 cloud 是敏感词，如果原文是</p>
<p><code>I love Cloud compz... cloud TAs are the best... Yinz shld tell yr frnz: TAKE CLOUD COMPUTING NEXT SEMESTER!!! Awesome. It&#39;s cloudy tonight.</code></p>
<p>那么返回的时候，应该是这样：</p>
<p><code>I love C***d compz... c***d TAs are the best... Yinz shld tell yr frnz: TAKE C***D COMPUTING NEXT SEMESTER!!! Awesome. It&#39;s cloudy tonight.</code></p>
<p>可以选择在 ETL 过程中完成所有的运算（MapReduce 的时间更长，花费也就更高），或者在每次返回请求的时候运算（如果你写的代码足够快的话）</p>
<p>ETL 的过程中需要处理很多 corner case，可能会出现很多不清晰的地方，所以<a href="https://cmucc-datasets.s3.amazonaws.com/twitter/ref/part-00000-reference" target="_blank" rel="external">这里</a>提供了一个参考文件（小数据集），是第一个数据集(<code>s3://cmucc-datasets/twitter/s16/part-00000</code>) ETL之后的结果，每一行对应输入文件的的一行，每一列以 <code>\t</code> 分隔，具体如下；</p>
<ul>
<li>第 1 列：tweet id.</li>
<li>第 2 列：user id.</li>
<li>第 3 列：tweet date.</li>
<li>第 4 列：sentiment density.</li>
<li>第 5 列：审查后的 tweet 内容，去掉了某些字符，如 newline (\n), tab (\t) etc</li>
<li>第 6 列：hashtags（可能为空）</li>
</ul>
<p>注意处理好各种可能的奇奇怪怪的情况，注意处理好各种可能的奇奇怪怪的情况，注意处理好各种可能的奇奇怪怪的情况。</p>
<blockquote>
<p>请求格式</p>
</blockquote>
<p><code>GET /q2?userid=uid&amp;hashtag=hashtag</code></p>
<p>样例</p>
<p><code>GET /q2?userid=2324314004&amp;hashtag=LinkedIn</code></p>
<blockquote>
<p>响应格式（如果有对应的推文）</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">TEAMID</span>,<span class="tag">TEAM_AWS_ACCOUNT_ID</span>\<span class="tag">n</span></span><br><span class="line"><span class="tag">Sentiment_density1</span><span class="pseudo">:Tweet_time1</span><span class="pseudo">:Tweet_id1</span><span class="pseudo">:Cencored_text1</span>\<span class="tag">n</span></span><br><span class="line"><span class="tag">Sentiment_density2</span><span class="pseudo">:Tweet_time2</span><span class="pseudo">:Tweet_id2</span><span class="pseudo">:Cencored_text2</span>\<span class="tag">n</span></span><br><span class="line"><span class="tag">Sentiment_density3</span><span class="pseudo">:Tweet_time3</span><span class="pseudo">:Tweet_id3</span><span class="pseudo">:Cencored_text3</span>\<span class="tag">n</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>样例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TeamSecret,<span class="number">1123</span>-<span class="number">5813</span>-<span class="number">2134</span></span><br><span class="line"><span class="number">0.308</span>:<span class="number">2014</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">11</span>-<span class="number">42</span>-<span class="number">18</span>:<span class="number">456034778891169793</span>:RT @AlexanderCrepin: How To Find The Best <span class="preprocessor">#LinkedIn Groups To Join - - #personalbranding #jobhunt - - http:<span class="comment">//t.co/ixH5dOf88E</span></span></span><br><span class="line"><span class="number">0.267</span>:<span class="number">2014</span>-<span class="number">06</span>-<span class="number">01</span> <span class="number">19</span>-<span class="number">34</span>-<span class="number">25</span>:<span class="number">473185820636356608</span>:RT @tonyrestell: How To Build Relationships And Win Interviews Through <span class="preprocessor">#LinkedIn http:<span class="comment">//t.co/ELZgPnp4gY #jobhunt tips from @mocksource</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>响应格式（如果没有对应的推文）</p>
</blockquote>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TEAMID,TEAM_AWS_ACCOUNT_ID<span class="string">\n</span></span><br><span class="line"><span class="string">\n</span></span><br></pre></td></tr></table></figure>
<p>一些细节</p>
<ul>
<li><code>Tweet_time</code> 的时间格式是 format:yyyy-MM-dd HH-mm-ss (UTC time, 24-hour clock)</li>
<li>\n 应该被替换成换行符 ‘\n’ 而不是原来的两个符号 ‘\’ + ‘n’.</li>
<li>排序规则<ul>
<li>首先看 <code>Sentimental_density</code>，降序</li>
<li>如果前面数值相同，那么看 <code>Tweet_time</code>，时间按照升序排列</li>
<li>如果还相同，看 <code>Tweet_id</code>，id 按照升序排列，小的在前面</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>从这次作业开始，就要小组作业和个人作业并行了。这次的项目主要是在云上分析 Twitter 的相关内容，与以前 GB 级数据不一样，这次我们要处理 TB 级的数据，还是很刺激的。另，这是小组作业，在此先感谢我的队友 @leiyu 和 @shushanc</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="数据" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="服务" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 9 课 递归]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-9/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-9/</id>
    <published>2016-02-24T16:51:34.000Z</published>
    <updated>2016-02-26T00:08:31.000Z</updated>
    <content type="html"><![CDATA[<p>递归之所以成为大家比较头疼的问题，主要还是其思维模式和我们惯常思考问题的方式不大一致，这里简要写下一些关于递归的碎碎念，希望能有所帮助。</p>
<a id="more"></a>
<hr>
<p>我们一直在写程序，但是拿什么来证明程序本身的正确性呢？调试、测试用例、检查输出等等方法都没有办法保证百分百的正确性（黑天鹅效应）。</p>
<p>那怎么办呢？我们结合常见的编程模式来说明</p>
<ul>
<li>Imperative Programming: Java 中常见的编程模式，大部分时间大部分人都是在按这种方式编程</li>
<li>Applicative Programming: 也就是比较出名的『函数式编程』，这里不具体展开，详情参阅<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80" target="_blank" rel="external">这里</a></li>
</ul>
<p>其中函数式编程因为每个函数没有副作用，所以在概念上是比较好证明正确性的。接下来看看递归。</p>
<p>通用的模式是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">recursive_fn(params)&#123;</span><br><span class="line">    <span class="keyword">if</span> (...) <span class="keyword">return</span> some_value;</span><br><span class="line">    <span class="keyword">else</span> ... recursive_fn(new_params)..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种模式是尾递归 tail recursion</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tail_recursive_fn(params)&#123;</span><br><span class="line">    <span class="keyword">if</span> (...) <span class="keyword">return</span> some_value;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> tail_recursive_fn(new_params)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常来说，尾递归会更有效率一些，并且也更容易证明正确性。</p>
<p>另外一个比较常用的方法是回溯法，通用模式是：</p>
<ul>
<li>Test if current position satisfies goal</li>
<li>If not, mark current position as visited and make a recursive call to search procedure on neighboring points</li>
<li>Exhaustive search, terminates as soon as goal is found</li>
</ul>
<p>具体可以参阅我的『编程起跑线系列』</p>
<p>最后说一下递归的好处：</p>
<ul>
<li>实现起来比较简洁</li>
<li>尾递归对栈空间也需求较少</li>
</ul>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>花了比较短的时间把这门课过了一次，总体来说不算特别全面，课件也是东拼西凑勉强合格，除了比较多的作业之外，感觉还是挺一般的。不过话说回来，除了名声在外的几门课，很多课程的教学质量也是堪忧的，唉。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>递归之所以成为大家比较头疼的问题，主要还是其思维模式和我们惯常思考问题的方式不大一致，这里简要写下一些关于递归的碎碎念，希望能有所帮助。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 8 课 有限状态机]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-8/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-8/</id>
    <published>2016-02-24T16:49:42.000Z</published>
    <updated>2016-02-25T23:26:43.000Z</updated>
    <content type="html"><![CDATA[<p>《模仿游戏》的大热让图灵为更多人所知，不过电影中更多说的是图灵破解密码，却对图灵的另一个伟大设想——图灵机所言甚少。图灵机可以看作是某种有限状态机，虽然这个名词听起来比较陌生，但也许这是计算机学科中最重要的概念之一。</p>
<a id="more"></a>
<hr>
<p>最先知道有限状态机，是在本科学习编译原理的时候，实话说，这类概念其实是很难理解的，不过第一次看不懂也不要紧，指不定哪天就悟道了。</p>
<p>我们先来看看常见的集中语言类别及其对应的计算模型：</p>
<p><img src="/images/14564350412980.jpg" alt=""></p>
<h2 id="u57FA_u7840_u6982_u5FF5"><a href="#u57FA_u7840_u6982_u5FF5" class="headerlink" title="基础概念"></a>基础概念</h2><p>我们从最基本的概念说起，为之后进入更加抽象的概念打一些基础。</p>
<p>$\Sigma$: 一个有限的符号集合称为字母表。在 $\Sigma$(字母表)中的每个符号我们称为字母，通常用小写表示，如 a, b, c, …</p>
<p>一个单词 w 是一个字符串，字符串中的字符都来自于 $\Sigma$，$|w|$ 表示单词 w 的长度，一个空的字符串不包含任何字母，并且用 $\varepsilon$ 表示。</p>
<p>一门语言 L 是一个由 $\Sigma$ 中的单词组成的集合，给定字母表 $\Sigma$，所有可能的字符串记为 $\Sigma^<em>$。例如，如果 $\Sigma={a}$，那么 $\Sigma^</em> = {\varepsilon, a, aa, aaa, \dots}$</p>
<p>给定字母表 $\Sigma$，所有可能的长度为 i 的字符串记为 $\Sigma^i$。例如，如果 $\Sigma={a,b}$，那么 $L = \Sigma^2 = {ab, ba, aa, bb}$</p>
<p>然后我们定义一些基本操作</p>
<ul>
<li>Concatenation: putting two strings together。如 $x=aa;y=bb;xy=aabb$</li>
<li>Power: concatenating multiple copies of a letter or word。如 $a^n=a·a^{n-1};a^1 = a; a^2 = a·a$，若 $x=ab;x^3=ababab$</li>
<li>Kleene Star: zero or more copies of a letter or word。如 $a^<em>={\varepsilon, a, aa, aaa, \dots}$, $x=ab;x^</em>={\varepsilon, ab, abab, ababab, \dots }$</li>
</ul>
<h2 id="Finite-state_automaton"><a href="#Finite-state_automaton" class="headerlink" title="Finite-state automaton"></a>Finite-state automaton</h2><p>接下来的定义部分为了避免翻译不准确带来的歧义，这里都使用英文原文。</p>
<p>A <strong>finite-state automaton comprises the following elements:</strong></p>
<ul>
<li>A sequence of <strong>input symbols</strong> (the input “tape”)</li>
<li>The <strong>current location in the input</strong>, which indicates the current input symbol (the read “head”)</li>
<li>The <strong>current state of the machine</strong> (denoted q0, q1,…, qn)</li>
<li>A <strong>transition function</strong> which inputs the current state and the current input, and outputs a new (next) state</li>
</ul>
<p>在计算过程中</p>
<ul>
<li>FSA 在初始状态开始（通常称为 q0）</li>
<li>每一步，状态转移方程会接受当前的输入符号和当前的状态，并且更新到一个新的状态，指针指向下一个符号</li>
<li>在 FSA 到达输入的末尾时，计算过程结束</li>
</ul>
<p>一个或多个状态可以被标记为最终状态，只有计算停止在这些状态时，才认为是计算成功。更多的细节及符号形式请参考<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA" target="_blank" rel="external">这里</a></p>
<h3 id="Regular_Languages"><a href="#Regular_Languages" class="headerlink" title="Regular Languages"></a>Regular Languages</h3><p><img src="/images/14564392411172.jpg" alt=""></p>
<h3 id="NDFSA__u4E0E_DFSA"><a href="#NDFSA__u4E0E_DFSA" class="headerlink" title="NDFSA 与 DFSA"></a>NDFSA 与 DFSA</h3><p>实话说这部分不是特别看得懂，所以只能给出参考链接了</p>
<ul>
<li>NDFSA - <a href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA" target="_blank" rel="external">非确定有限状态自动机</a></li>
<li>DFSA - <a href="https://zh.wikipedia.org/wiki/%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA" target="_blank" rel="external">确定有限状态自动机</a></li>
</ul>
<h2 id="Pushdown_Automaton__u4E0B_u63A8_u81EA_u52A8_u673A"><a href="#Pushdown_Automaton__u4E0B_u63A8_u81EA_u52A8_u673A" class="headerlink" title="Pushdown Automaton 下推自动机"></a>Pushdown Automaton 下推自动机</h2><p>下推自动机比有限状态自动机复杂：除了有限状态组成部分外，还包括一个长度不受限制的栈；下推自动机的状态迁移不但要参考有限状态部分，也要参照栈当前的状态；状态迁移不但包括有限状态的变迁，还包括一个栈的出栈或入栈过程。</p>
<p>具体的解释仍然是比较抽象，这里也没办法展开了，详情参考<a href="https://zh.wikipedia.org/wiki/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA" target="_blank" rel="external">这里</a></p>
<h2 id="Turing_Machines__u56FE_u7075_u673A"><a href="#Turing_Machines__u56FE_u7075_u673A" class="headerlink" title="Turing Machines 图灵机"></a>Turing Machines 图灵机</h2><p>接下来的定义部分为了避免翻译不准确带来的歧义，这里都使用英文原文。</p>
<ul>
<li>The basic model of a Turing machine has a finite control, an input tage that is divided into cells, and a tape head that scans one celll of the tape at a time</li>
<li>The tage has a left most cell but is infinite to the right</li>
<li>Each cell of the tape may hold exactly one of a finite number of tape symbols</li>
<li>Initially, the n leftmost cells, for some finite n &gt;= 0, hold the input, which is a string of symbols chosen from a subset of the tape symbols called the input symbols</li>
<li>The remaining infinity of cells each hold the blank, which is a special symbol that is not an input symbol</li>
</ul>
<p>如下图所示：</p>
<p><img src="/images/14564420943465.jpg" alt=""></p>
<p>具体的解释还是参考<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA" target="_blank" rel="external">维基</a></p>
<h2 id="NP"><a href="#NP" class="headerlink" title="NP"></a>NP</h2><p>最后是更加理论化的一个概念，非定常多项式（英语：non-deterministic polynomial，缩写NP）时间复杂性类，或称非确定性多项式时间复杂性类，包含了可以在多项式时间内，对一个判定性算法问题的实例，一个给定的解是否正确的算法问题。</p>
<p>具体请参考<a href="https://zh.wikipedia.org/wiki/NP_(%E8%A4%87%E9%9B%9C%E5%BA%A6" target="_blank" rel="external">维基</a>)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《模仿游戏》的大热让图灵为更多人所知，不过电影中更多说的是图灵破解密码，却对图灵的另一个伟大设想——图灵机所言甚少。图灵机可以看作是某种有限状态机，虽然这个名词听起来比较陌生，但也许这是计算机学科中最重要的概念之一。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 7 课 数据压缩]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-7/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-7/</id>
    <published>2016-02-24T16:48:25.000Z</published>
    <updated>2016-02-25T21:08:14.000Z</updated>
    <content type="html"><![CDATA[<p>这一部分主要介绍一下两种常见的压缩算法：霍夫曼编码和 LZW，因为我对这个领域研究不算太多，所以更多可能给出一些参考链接，和我对算法思想的理解。</p>
<a id="more"></a>
<hr>
<p>数据压缩是一门非常『应用』的技术，目的是为了提高信息的『密度』，用最小的容量存储最多有意义的数据。记得之前还看过类似『世界压缩大赛』的作品，十多 K 的程序就可以不重复弄出非常浮夸的过场动画。</p>
<p>既然是信息的『密度』，就需要有一个度量来衡量『信息』本身，这就是我们所说的『熵』了（霍夫曼编码就是熵的应用）。</p>
<p>总体来看，可以分为无损压缩和有损压缩，有损压缩适用与图片、声音、视频等领域，在许多字节顺序不允许出错的应用中，都只能使用无损压缩。</p>
<p>无损压缩的两个具体思路，一是通过字典进行映射，二是通过熵来进行『密度』的提升。这节课要说的 LZW 属于字典类压缩，霍夫曼编码属于熵压缩。</p>
<p>具体的细节可以参考：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/LZW" target="_blank" rel="external">LZW</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81" target="_blank" rel="external">霍夫曼编码</a></li>
</ul>
<p>这里不班门弄斧了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一部分主要介绍一下两种常见的压缩算法：霍夫曼编码和 LZW，因为我对这个领域研究不算太多，所以更多可能给出一些参考链接，和我对算法思想的理解。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 6 课 搜索]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-6/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-6/</id>
    <published>2016-02-24T16:46:54.000Z</published>
    <updated>2016-02-25T20:42:30.000Z</updated>
    <content type="html"><![CDATA[<p>排序和搜索可能是互联网中应用最广泛的算法，大到搜索引擎，小到帖子排序，都离不开算法的帮助。这一课我们会简要了解一下各个常见算法，具体实现还是参考给出的链接，这里主要提算法背后的思想。</p>
<a id="more"></a>
<hr>
<p>搜索其实是一个比较宽泛的概念，两个比较大的范畴是：</p>
<ul>
<li>在静态数据库中搜索，如找到某个已索引的网页或找到磁盘上的某个文件</li>
<li>评估一个动态的假设集合，如象棋中搜索下一步或语音识别</li>
</ul>
<p>这里我们主要讨论第一种情形。</p>
<h2 id="u987A_u5E8F_u67E5_u627E"><a href="#u987A_u5E8F_u67E5_u627E" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>这是最简单粗暴的搜索方式了，比方说从数组的第一个元素一直搜索到最后一个元素。</p>
<ul>
<li>Best case: O(1)</li>
<li>Worst case: O(N)</li>
<li>Average case: O(N)</li>
</ul>
<h2 id="u4E8C_u5206_u67E5_u627E"><a href="#u4E8C_u5206_u67E5_u627E" class="headerlink" title="二分查找"></a>二分查找</h2><p>当数据是完全有序的时候，就可以进行二分查找。实现简单，通常也『足够快』不过一定要小心处理 boundary cases，是一个典型的 divide-and-conquer 算法</p>
<p>注意完全正确的二分并不好写，一定要注意可能出错的地方，具体可以参加<a href="https://zh.wikipedia.org/wiki/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95" target="_blank" rel="external">这里</a></p>
<h2 id="u54C8_u5E0C"><a href="#u54C8_u5E0C" class="headerlink" title="哈希"></a>哈希</h2><p>前面提到的两个算法，最快的二分平均时间也要 O(logN)，有没有办法更快呢？</p>
<p>有！使用哈希，可以把时间复杂度降到 O(1)。</p>
<p>最重要的就是哈希函数的选择，以及如果哈希冲突的时候如何解决。一个比较常见的方式是，如果发生了冲突，那么在随机移动若干个位置，具体的值由另一个哈希函数决定。</p>
<p>其他一些常见的哈希：</p>
<ul>
<li>Double Hashing</li>
<li>O-A Hashing</li>
<li>Chained Hashing</li>
</ul>
<p>哈希与二叉树的对比：</p>
<ul>
<li>通常来说更倾向于哈希，因为更快</li>
<li>二叉树是纯动态的，不需要任何相关信息</li>
<li>二叉搜索树保证了 worst case，哈希函数可能会很糟糕</li>
<li>二叉搜索树支持更多操作，如排序</li>
</ul>
<p>另外一个变种是 Radix-Search，类似于与 Trie Tree，这里也不展开了</p>
<h2 id="Bubble_Sort__u5192_u6CE1_u6392_u5E8F"><a href="#Bubble_Sort__u5192_u6CE1_u6392_u5E8F" class="headerlink" title="Bubble Sort 冒泡排序"></a>Bubble Sort 冒泡排序</h2><p>冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p>
<p>步骤：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(arry)</span>:</span></span><br><span class="line">    n = len(arry)                   <span class="comment">#获得数组的长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n-i):</span><br><span class="line">            <span class="keyword">if</span>  arry[j-<span class="number">1</span>] &gt; arry[j] :       <span class="comment">#如果前者比后者大</span></span><br><span class="line">                arry[j-<span class="number">1</span>],arry[j] = arry[j],arry[j-<span class="number">1</span>]      <span class="comment">#则交换两者</span></span><br><span class="line">    <span class="keyword">return</span> arry</span><br></pre></td></tr></table></figure>
<p>针对上述代码还有两种优化方案。</p>
<p>优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。</span></span><br><span class="line"><span class="comment">#用一个标记记录这个状态即可。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort2</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        flag = <span class="number">1</span>                    <span class="comment">#标记</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n-i):</span><br><span class="line">            <span class="keyword">if</span>  ary[j-<span class="number">1</span>] &gt; ary[j] :</span><br><span class="line">                ary[j-<span class="number">1</span>],ary[j] = ary[j],ary[j-<span class="number">1</span>]</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> flag :                   <span class="comment">#全排好序了，直接跳出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<p>优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序了。</span></span><br><span class="line"><span class="comment"># 因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort3</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    k = n                           <span class="comment">#k为循环的范围，初始值n</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,k):        <span class="comment">#只遍历到最后交换的位置即可</span></span><br><span class="line">            <span class="keyword">if</span>  ary[j-<span class="number">1</span>] &gt; ary[j] :</span><br><span class="line">                ary[j-<span class="number">1</span>],ary[j] = ary[j],ary[j-<span class="number">1</span>]</span><br><span class="line">                k = j               <span class="comment">#记录最后交换的位置</span></span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> flag :</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="Selection_Sort__u9009_u62E9_u6392_u5E8F"><a href="#Selection_Sort__u9009_u62E9_u6392_u5E8F" class="headerlink" title="Selection Sort 选择排序"></a>Selection Sort 选择排序</h2><p>选择排序无疑是最简单直观的排序。它的工作原理如下。</p>
<p>步骤：</p>
<ol>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>以此类推，直到所有元素均排序完毕。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">        min = i                             <span class="comment">#最小元素下标标记</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> ary[j] &lt; ary[min] :</span><br><span class="line">                min = j                     <span class="comment">#找到最小值的下标</span></span><br><span class="line">        ary[min],ary[i] = ary[i],ary[min]   <span class="comment">#交换两者</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="Insertion_Sort__u63D2_u5165_u6392_u5E8F"><a href="#Insertion_Sort__u63D2_u5165_u6392_u5E8F" class="headerlink" title="Insertion Sort 插入排序"></a>Insertion Sort 插入排序</h2><p>插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>步骤：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        <span class="keyword">if</span> ary[i] &lt; ary[i-<span class="number">1</span>]:</span><br><span class="line">            temp = ary[i]</span><br><span class="line">            index = i           <span class="comment">#待插入的下标</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):  <span class="comment">#从i-1 循环到 0 (包括0)</span></span><br><span class="line">                <span class="keyword">if</span> ary[j] &gt; temp :</span><br><span class="line">                    ary[j+<span class="number">1</span>] = ary[j]</span><br><span class="line">                    index = j   <span class="comment">#记录待插入下标</span></span><br><span class="line">                <span class="keyword">else</span> :</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            ary[index] = temp</span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="Shell_Sort__u5E0C_u5C14_u6392_u5E8F"><a href="#Shell_Sort__u5E0C_u5C14_u6392_u5E8F" class="headerlink" title="Shell Sort 希尔排序"></a>Shell Sort 希尔排序</h2><p>希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。</p>
<p>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。</p>
<p>例如，假设有这样一组数<code>[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]</code>，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<pre><code>13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
</code></pre><p>然后我们对每列进行排序：</p>
<pre><code>10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45
</code></pre><p>将上述四行数字，依序接在一起时我们得到：<code>[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]</code>。这时10已经移至正确位置了，然后再以3为步长进行排序：</p>
<pre><code>10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
</code></pre><p>排序之后变为：</p>
<pre><code>10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
</code></pre><p>最后以1步长进行排序（此时就是简单的插入排序了）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    gap = round(n/<span class="number">2</span>)       <span class="comment">#初始步长 , 用round四舍五入取整</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap,n):        <span class="comment">#每一列进行插入排序 , 从gap 到 n-1</span></span><br><span class="line">            temp = ary[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> ( j &gt;= gap <span class="keyword">and</span> ary[j-gap] &gt; temp ):    <span class="comment">#插入排序</span></span><br><span class="line">                ary[j] = ary[j-gap]</span><br><span class="line">                j = j - gap</span><br><span class="line">            ary[j] = temp</span><br><span class="line">        gap = round(gap/<span class="number">2</span>)                     <span class="comment">#重新设置步长</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<p>上面源码的步长的选择是从n/2开始，每次再减半，直至为0。步长的选择直接决定了希尔排序的复杂度</p>
<h2 id="Merge_Sort__u5F52_u5E76_u6392_u5E8F"><a href="#Merge_Sort__u5F52_u5E76_u6392_u5E8F" class="headerlink" title="Merge Sort 归并排序"></a>Merge Sort 归并排序</h2><p>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p>
<p>先考虑合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p>
<p>再考虑递归分解，基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(ary) &lt;= <span class="number">1</span> : <span class="keyword">return</span> ary</span><br><span class="line">    num = int(len(ary)/<span class="number">2</span>)       <span class="comment">#二分分解</span></span><br><span class="line">    left = merge_sort(ary[:num])</span><br><span class="line">    right = merge_sort(ary[num:])</span><br><span class="line">    <span class="keyword">return</span> merge(left,right)    <span class="comment">#合并数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left,right)</span>:</span></span><br><span class="line">    <span class="string">'''合并操作，</span><br><span class="line">    将两个有序数组left[]和right[]合并成一个大的有序数组'''</span></span><br><span class="line">    l,r = <span class="number">0</span>,<span class="number">0</span>           <span class="comment">#left与right数组的下标指针</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> l &lt; len(left) <span class="keyword">and</span> r &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[l] &lt; right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">    result += left[l:]</span><br><span class="line">    result += right[r:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="Quick_Sort__u5FEB_u901F_u6392_u5E8F"><a href="#Quick_Sort__u5FEB_u901F_u6392_u5E8F" class="headerlink" title="Quick Sort 快速排序"></a>Quick Sort 快速排序</h2><p>快速排序通常明显比同为Ο(n log n)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。</p>
<p>步骤：</p>
<ol>
<li>从数列中挑出一个元素作为基准数。</li>
<li>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。</li>
<li>再对左右区间递归执行第二步，直至各区间只有一个数。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> qsort(ary,<span class="number">0</span>,len(ary)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(ary,left,right)</span>:</span></span><br><span class="line">    <span class="comment">#快排函数，ary为待排序数组，left为待排序的左边界，right为右边界</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right : <span class="keyword">return</span> ary</span><br><span class="line">    key = ary[left]     <span class="comment">#取最左边的为基准数</span></span><br><span class="line">    lp = left           <span class="comment">#左指针</span></span><br><span class="line">    rp = right          <span class="comment">#右指针</span></span><br><span class="line">    <span class="keyword">while</span> lp &lt; rp :</span><br><span class="line">        <span class="keyword">while</span> ary[rp] &gt;= key <span class="keyword">and</span> lp &lt; rp :</span><br><span class="line">            rp -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> ary[lp] &lt;= key <span class="keyword">and</span> lp &lt; rp :</span><br><span class="line">            lp += <span class="number">1</span></span><br><span class="line">        ary[lp],ary[rp] = ary[rp],ary[lp]</span><br><span class="line">    ary[left],ary[lp] = ary[lp],ary[left]</span><br><span class="line">    qsort(ary,left,lp-<span class="number">1</span>)</span><br><span class="line">    qsort(ary,rp+<span class="number">1</span>,right)</span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="Heap_Sort__u5806_u6392_u5E8F"><a href="#Heap_Sort__u5806_u6392_u5E8F" class="headerlink" title="Heap Sort 堆排序"></a>Heap Sort 堆排序</h2><p>堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 。</p>
<p><strong>二叉堆具有以下性质：</strong></p>
<ol>
<li>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</li>
<li>每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</li>
</ol>
<p><strong>步骤：</strong></p>
<ol>
<li>构造最大堆（<code>Build_Max_Heap</code>）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</li>
<li>堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0…n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0…n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</li>
<li>最大堆调整（<code>Max_Heapify</code>）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(ary)</span> :</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    first = int(n/<span class="number">2</span>-<span class="number">1</span>)       <span class="comment">#最后一个非叶子节点</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(first,-<span class="number">1</span>,-<span class="number">1</span>) :     <span class="comment">#构造大根堆</span></span><br><span class="line">        max_heapify(ary,start,n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> range(n-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):           <span class="comment">#堆排，将大根堆转换成有序数组</span></span><br><span class="line">        ary[end],ary[<span class="number">0</span>] = ary[<span class="number">0</span>],ary[end]</span><br><span class="line">        max_heapify(ary,<span class="number">0</span>,end-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ary</span><br><span class="line"></span><br><span class="line"><span class="comment">#最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点</span></span><br><span class="line"><span class="comment">#start为当前需要调整最大堆的位置，end为调整边界</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_heapify</span><span class="params">(ary,start,end)</span>:</span></span><br><span class="line">    root = start</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span> :</span><br><span class="line">        child = root*<span class="number">2</span> +<span class="number">1</span>               <span class="comment">#调整节点的子节点</span></span><br><span class="line">        <span class="keyword">if</span> child &gt; end : <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> child+<span class="number">1</span> &lt;= end <span class="keyword">and</span> ary[child] &lt; ary[child+<span class="number">1</span>] :</span><br><span class="line">            child = child+<span class="number">1</span>             <span class="comment">#取较大的子节点</span></span><br><span class="line">        <span class="keyword">if</span> ary[root] &lt; ary[child] :     <span class="comment">#较大的子节点成为父节点</span></span><br><span class="line">            ary[root],ary[child] = ary[child],ary[root]     <span class="comment">#交换</span></span><br><span class="line">            root = child</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="u6307_u6807_u5BF9_u6BD4"><a href="#u6307_u6807_u5BF9_u6BD4" class="headerlink" title="指标对比"></a>指标对比</h2><table>
<thead>
<tr>
<th style="text-align:center">排序方法</th>
<th style="text-align:center">平均情况</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">辅助空间</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">O(nlogn)~O(n2)</td>
<td style="text-align:center">O(n1.3)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(logn)~O(n)</td>
<td style="text-align:center">不稳定</td>
</tr>
</tbody>
</table>
<h2 id="Bucket_Sort__u6876_u6392_u5E8F"><a href="#Bucket_Sort__u6876_u6392_u5E8F" class="headerlink" title="Bucket Sort 桶排序"></a>Bucket Sort 桶排序</h2><p>桶排序和归并排序有那么点点类似，也使用了归并的思想。大致步骤如下：</p>
<ol>
<li>设置一个定量的数组当作空桶。</li>
<li>Divide - 从待排序数组中取出元素，将元素按照一定的规则塞进对应的桶子去。</li>
<li>对每个非空桶进行排序，通常可在塞元素入桶时进行插入排序。</li>
<li>Conquer - 从非空桶把元素再放回原来的数组中。”</li>
</ol>
<h2 id="Counting_Sort__u8BA1_u6570_u6392_u5E8F"><a href="#Counting_Sort__u8BA1_u6570_u6392_u5E8F" class="headerlink" title="Counting Sort 计数排序"></a>Counting Sort 计数排序</h2><p>计数排序，顾名思义，就是对待排序数组按元素进行计数。使用前提是需要先知道待排序数组的元素范围，将这些一定范围的元素置于新数组中，新数组的大小为待排序数组中最大元素与最小元素的差值。</p>
<p>维基上总结的四个步骤如下：</p>
<ol>
<li>定新数组大小——找出待排序的数组中最大和最小的元素</li>
<li>统计次数——统计数组中每个值为i的元素出现的次数，存入新数组C的第i项</li>
<li>对统计次数逐个累加——对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>
<li>反向填充目标数组——将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>
<li>其中反向填充主要是为了避免重复元素落入新数组的同一索引处。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>排序和搜索可能是互联网中应用最广泛的算法，大到搜索引擎，小到帖子排序，都离不开算法的帮助。这一课我们会简要了解一下各个常见算法，具体实现还是参考给出的链接，这里主要提算法背后的思想。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 5 课 图]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-5/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-5/</id>
    <published>2016-02-24T16:45:48.000Z</published>
    <updated>2016-02-25T19:09:05.000Z</updated>
    <content type="html"><![CDATA[<p>前面我们介绍了几种不同类型的树，这一课我们在原来的基础上延伸一下，就能得到图的概念。相对于树，因为不同节点之间的关系更多，无论是表达形式或者是算法细节都会复杂不少，就更需要仔细揣摩。不过究其根本，实际上可以看做是不同矩阵间的信息检索，一定要注意细节。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u672C_u4ECB_u7ECD"><a href="#u57FA_u672C_u4ECB_u7ECD" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>图的话，从类别来看可以分为有向图与无向图，而最关键的操作，图的遍历，有深度优先（递归或者栈）和广度优先（队列）。</p>
<p>图由两类元素组成，一是节点(vertex)，二是边(edge)，下面是一个无向图的例子：</p>
<p><img src="/images/14564071906087.jpg" alt="无向图，边和节点都有对应标记"></p>
<p>无向图和有向图都是一个有限的节点集合加上一个有限的边集合，每条边连接两个节点。不同的地方在于，无向图中连接的顺序是无关紧要的，而有向图中连接的顺序是重要的，是从 source 到 target 的方向，下面是一个有向图的例子：</p>
<p><img src="/images/14564073738319.jpg" alt="有向图的例子，注意箭头的方向"></p>
<p>其他一些需要知道的术语：</p>
<ul>
<li>Loops: edges that connect a vertex to itself</li>
<li>Paths: sequences of vertices p0, p1, …, pm such that each adjacent pair of vertices are connected by an edge</li>
<li>Multiple Edges: two nodes may be connected by &gt;1 edge</li>
<li>Simple Graphs: have no loops and no multiple edges</li>
</ul>
<h2 id="u56FE_u7684_u8868_u793A"><a href="#u56FE_u7684_u8868_u793A" class="headerlink" title="图的表示"></a>图的表示</h2><p>这里介绍三种常见的方式，其实还有其他几种自定义的表示法，这里不拓展了</p>
<h3 id="u90BB_u63A5_u77E9_u9635_Adjacency_Matrix"><a href="#u90BB_u63A5_u77E9_u9635_Adjacency_Matrix" class="headerlink" title="邻接矩阵 Adjacency Matrix"></a>邻接矩阵 Adjacency Matrix</h3><p>用一个二维矩阵来表示点和点之间的连接关系，如果一个图有 N 个节点，那么这个矩阵就是 NxN 的，对于节点 I 和节点 J，如果有一条边连接他们，那么第 I 行第 J 列的值为 true，否则是 false（如果是无向图的话，第 J 行第 I 列的值需要保持一致，也就是说以对角线为轴对称），下面是一个有向图的例子：</p>
<p><img src="/images/14564128326067.jpg" alt="有向图的邻接矩阵"></p>
<h3 id="u8FB9_u5217_u8868_Edge_Lists"><a href="#u8FB9_u5217_u8868_Edge_Lists" class="headerlink" title="边列表 Edge Lists"></a>边列表 Edge Lists</h3><p>另外一种表达方式是每个节点有一个链表，表示它所连接的其他节点，如下图所示：</p>
<p><img src="/images/14564132564620.jpg" alt=""></p>
<h3 id="u8FB9_u96C6_Edge_Sets"><a href="#u8FB9_u96C6_Edge_Sets" class="headerlink" title="边集 Edge Sets"></a>边集 Edge Sets</h3><p>Edge Lists 中我们主要存储的是节点的信息，而在 Edge sets 中我们保存的是边的信息，包含每条边的 source 和 target。</p>
<h3 id="u6027_u80FD_u5206_u6790"><a href="#u6027_u80FD_u5206_u6790" class="headerlink" title="性能分析"></a>性能分析</h3><p>这里主要看一下最坏情况</p>
<ul>
<li>添加或删除边：<ul>
<li>adjacency matrix: O(1)</li>
<li>edge list: O(N)</li>
<li>edge set: O(logN) - 使用 B-Tree</li>
</ul>
</li>
<li>检查某条边是否存在：<ul>
<li>adjacency matrix: O(1)</li>
<li>edge list: O(N)</li>
<li>edge set: O(logN) - 使用 B-Tree 或 红黑树</li>
</ul>
</li>
<li>遍历某个节点的边：<ul>
<li>adjacency matrix: O(N)</li>
<li>edge list: O(E) - 其中 E 是边的数目</li>
<li>edge set: O(E) - 使用 B-Tree 或 红黑树</li>
</ul>
</li>
</ul>
<h2 id="u56FE_u7684_u5B9E_u73B0"><a href="#u56FE_u7684_u5B9E_u73B0" class="headerlink" title="图的实现"></a>图的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] edges;</span><br><span class="line">    <span class="keyword">private</span> Object[] labels;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span> <span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        labels = <span class="keyword">new</span> Object[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span> <span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        edges[s][t] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getLabel</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> labels[v];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[s][t];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] neighbors(<span class="keyword">int</span> v) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">int</span>[] answer;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; labels.length; i++&#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v][i]) count++;</span><br><span class="line">        &#125;    </span><br><span class="line">        answer = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; labels.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v][i]) answer[count++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        edges[s][t] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLabel</span><span class="params">(<span class="keyword">int</span> v, Object n)</span></span>&#123;</span><br><span class="line">        labels[v] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> labels.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u56FE_u7684_u904D_u5386"><a href="#u56FE_u7684_u904D_u5386" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>这个是图问题中比较常见的，一般来说，是从一个特定的节点开始，找到所有可能到达的节点。图和树的区别在于，我们可能会遇到环，所以就需要一种方法来处理这种情况。</p>
<p>我们可以用一个另外的数组来记录一个节点是否被访问过。</p>
<ul>
<li>深度搜索 - Stack</li>
<li>广度搜索 - Queue</li>
</ul>
<p>这一部分比较基础，大家可以自己找一个例子来边输出边测试，这里不再赘述。</p>
<h2 id="u6700_u77ED_u8DEF_u5F84"><a href="#u6700_u77ED_u8DEF_u5F84" class="headerlink" title="最短路径"></a>最短路径</h2><p>最短路径一般应用在有权有向图，如下所示：</p>
<p><img src="/images/14564267263106.jpg" alt=""></p>
<p>我们要找的是路径最短的，但不一定是经过的边最少的，所以 BFS 在这里就不适用了。</p>
<p>我们可以使用 <a href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95" target="_blank" rel="external">Dijkstra’s 算法</a>来处理，wiki 中有比较详细的说明，这里不再赘述。</p>
<p>对于比较稀疏的图，我们用堆来表示图会更好；反之，用邻接矩阵比较好。</p>
<p>另外一个利用动态规划的解法是 <a href="https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95" target="_blank" rel="external">Floyd Warshall 算法</a></p>
<p>索引中的各类算法也可以对应了解一下：</p>
<p><img src="/images/14564271316392.jpg" alt=""></p>
<h2 id="u6700_u5C0F_u751F_u6210_u6811_Minimum_Spanning_Tree__28MST_29"><a href="#u6700_u5C0F_u751F_u6210_u6811_Minimum_Spanning_Tree__28MST_29" class="headerlink" title="最小生成树 Minimum Spanning Tree (MST)"></a>最小生成树 Minimum Spanning Tree (MST)</h2><p>我们一般用 <a href="https://zh.wikipedia.org/wiki/%E6%99%AE%E6%9E%97%E5%A7%86%E7%AE%97%E6%B3%95" target="_blank" rel="external">Prim’s 算法</a>，来寻找最小生成树，是一个贪心算法</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面我们介绍了几种不同类型的树，这一课我们在原来的基础上延伸一下，就能得到图的概念。相对于树，因为不同节点之间的关系更多，无论是表达形式或者是算法细节都会复杂不少，就更需要仔细揣摩。不过究其根本，实际上可以看做是不同矩阵间的信息检索，一定要注意细节。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 4 课 树]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-4/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-4/</id>
    <published>2016-02-24T16:44:36.000Z</published>
    <updated>2016-02-25T13:11:50.000Z</updated>
    <content type="html"><![CDATA[<p>从这一讲开始，慢慢就有点难度了，树的每个节点虽然看起来比较简单，但是不同结点以不同规则进行组合就使得难度指数级增长，后面的红黑树因为涉及到结点的调整，一定要按照前面提到的 5 个步骤来过一次，才能清晰理解。</p>
<a id="more"></a>
<hr>
<h2 id="u6811_u7684_u5E94_u7528"><a href="#u6811_u7684_u5E94_u7528" class="headerlink" title="树的应用"></a>树的应用</h2><p>这次我们换个方式，先从不同的应用角度来了解一下树的用途。</p>
<p><strong>表示数学表达式</strong></p>
<p>我们可以用下面的树来表示 <code>b + a * b</code></p>
<p><img src="/images/14563638168396.jpg" alt=""></p>
<p><strong>XML Document Object Model</strong></p>
<p>XML 实际上也是一个树结构：</p>
<p><img src="/images/14563638734277.jpg" alt=""></p>
<p><strong>表示迁移路径的概率</strong></p>
<p>下图可以认为，从 S 出发，有 p 的概率到 Su，有 1-p 的概率到 Sd</p>
<p><img src="/images/14563639875028.jpg" alt=""></p>
<h2 id="u6811_u7684_u5B9A_u4E49"><a href="#u6811_u7684_u5B9A_u4E49" class="headerlink" title="树的定义"></a>树的定义</h2><p>下面介绍几种不同类型的树</p>
<h3 id="Free_tree"><a href="#Free_tree" class="headerlink" title="Free tree"></a>Free tree</h3><p>指的是相互连接的无环无向图</p>
<p><img src="/images/14563645014537.jpg" alt="Free Tree"></p>
<p>假设 G = (V, E) 是一个无向图，那么下面的语句是等价的：</p>
<ol>
<li>G 是一个 free tree</li>
<li>G 中的任意两个节点间都有唯一的一条路径</li>
<li>G 是连通的的，但是如果去掉任何一条边，G 就不连通了</li>
<li>G 是连通的，并且 $|E|=|V|-1$</li>
<li>G 是无环的，并且 $|E|=|V|-1$</li>
<li>G 是无环的，但是加入任何一条新的边，就会变成有环的</li>
</ol>
<h3 id="Forest__u68EE_u6797"><a href="#Forest__u68EE_u6797" class="headerlink" title="Forest 森林"></a>Forest 森林</h3><p>同样是无环无向图，但不是所有的节点都是连通的</p>
<p><img src="/images/14563646007700.jpg" alt="Forest"></p>
<p>下图中包含一个环，所以不能算是森林：</p>
<p><img src="/images/14563646456272.jpg" alt="包含环的例子"></p>
<h3 id="Rooted_Tree"><a href="#Rooted_Tree" class="headerlink" title="Rooted Tree"></a>Rooted Tree</h3><p>有根的树也是一棵 free tree，但是其中一个节点和其他不同，称为根，下图中的 7 号节点就是根：</p>
<p><img src="/images/14563698058000.jpg" alt=""></p>
<p>有根树中有一些概念需要理解清楚，这里只列举出来不再赘述：ancestor, descendant, proper ancestor, proper descendant, parent, child, siblings, external node(leaf), internal node。</p>
<p>一个节点的孩子数量称之为节点的度(degree)，从根到某节点的要经过的边的数量就是该节点的深度，最大的深度称为树的高度，如下图所示：</p>
<p><img src="/images/14563702807914.jpg" alt=""></p>
<p>根树有几个特例，也非常常用，需要理解清楚，这里列举如下：</p>
<ul>
<li>Binary tree</li>
<li>Full binary tree: each node is either a leaf or has degree exactly 2</li>
<li>Complete k-ary tree: a k-ary tree in which all leaves have the same depth and all internal nodes have degree k</li>
<li>Binary search tree: 一个节点的左右子节点和节点本身满足一定的大小关系</li>
</ul>
<p><img src="/images/14563707343954.jpg" alt="Complete Binary Tree"></p>
<h3 id="Catalan_Numbers"><a href="#Catalan_Numbers" class="headerlink" title="Catalan Numbers"></a>Catalan Numbers</h3><p>先来看公式</p>
<p><img src="/images/14563710814940.jpg" alt=""></p>
<p>然后我们就发现，Catalan 数对应的是有 n 节点的二叉树的数量（根据左右子树的位置可以有不同的结构）</p>
<h2 id="u6811_u7684_u904D_u5386"><a href="#u6811_u7684_u904D_u5386" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>这一部分也是非常重要的内容，基本来说各类考点都在这里，不但需要对概念的清晰理解，还需要利用递归来解决问题（虽然不用递归也可以），主要有下面这四类：</p>
<ol>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层次遍历</li>
</ol>
<p>具体的概念可以在 wiki 上查看，注意一下层次遍历可能需要一些特殊处理即可。</p>
<h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h2><p>如果我们想要表示一个 complete binary tree 的话，其实可以用数组来完成，这种结构其实也可以看成是一个堆。堆的话需要理解的不算特别多，注意下最大堆最小堆，以及对应的操作即可。另外前面提到的优先队列也可以认为是堆，不过这个不展开了。</p>
<p>这一部分我们着重来看看 B-Tree，这是一类搜索树，在给定 n 个节点的条件下，尽可能减少树的高度，相对于原来的二叉搜索树，B-Tree 做了两个调整：</p>
<ol>
<li>节点可以有多于两个子节点</li>
<li>节点中可以保存多个元素</li>
</ol>
<p>因为需要保存不定数量的元素，所以一般用 set 来实现（这种情况下不允许有重复的元素，重复的情况这里暂时不考虑）。稍微提一下，许多数据库都是用 B-Tree 实现的。</p>
<p>所有的 B-Tree 都有一个非常重要的常数 MINIMUM，决定了每个节点中需要保存多少元素，具体的规则如下：</p>
<ol>
<li>根节点有 0 或 1 个元素，其他的节点至少需要保存 MINIMUM 个元素</li>
<li>一个节点中最多可以保存 <code>2*MINIMUM</code> 个元素</li>
<li>一个节点中保存的元素是有序的，从最小到最大</li>
<li>假设一个非叶节点中存有 N 个元素，那么它会有 N+1 个子树</li>
<li>对于任何一个非叶节点：<ul>
<li>第 I 个元素比其第 I 个子树的所有元素都要大</li>
<li>第 I 个元素比其第 I+1 个子树的所有元素都要小</li>
<li><img src="/images/14563744343036.jpg" alt=""></li>
</ul>
</li>
<li>每个叶节点都有相同的深度，也就是说 B-Tree 总是平衡的</li>
</ol>
<p>下图是一个例子，其中 MINIMUM = 1，注意，根节点的每个子节点也是一颗 B-Tree</p>
<p><img src="/images/14563745325794.jpg" alt="B-Tree 的例子"></p>
<p>对应的数据结构是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntBalancedSet</span></span>&#123;</span><br><span class="line">    <span class="comment">// constants</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MINIMUM = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MAXIMUM = <span class="number">2</span> * MINIMUM;</span><br><span class="line">    <span class="comment">// info about root node</span></span><br><span class="line">    <span class="keyword">int</span> dataCount;</span><br><span class="line">    <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[MAXIMUM + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> childCount;</span><br><span class="line">    <span class="comment">// info about children</span></span><br><span class="line">    IntBalancedSet[] subset = <span class="keyword">new</span> IntBalancedSet[MAXIMUM+<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<p><img src="/images/14563980237017.jpg" alt=""></p>
<p>利用 B-Tree 进行搜索的方法如下：</p>
<ul>
<li>找到这样一个 set，满足 <code>data[I] &gt;= target</code> 且 I 尽可能小，如果找不到，则 <code>I = dataCount</code></li>
<li>如果 <code>data[I] == target</code> 返回 true，如果不等于且没有子节点，返回 false</li>
<li>如果不等于但是有子节点，则返回 <code>subset[I].contains(target)</code></li>
</ul>
<p><img src="/images/14563990361014.jpg" alt="利用 B-Tree 进行搜索的例子"></p>
<p>一般来说，结构比较复杂的数据结构，进行修改都会比较麻烦（因为结构中内在的约束太多，变动的话需要满足所有约束），在 B-Tree 中添加和删除节点是比较复杂的操作。这里讲详细一些，用一个具体的例子来做说明（MINIMUM=1）</p>
<p>删除操作的伪代码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">Delete</span>(<span class="keyword">T</span>, X, <span class="keyword">success</span>)</span><br><span class="line">    // 从树 <span class="keyword">T</span> 中删除 <span class="keyword">key</span> 为 X 的节点，如果没有对应节点，则操作失败</span><br><span class="line">    // 操作结果可以从 <span class="keyword">success</span> 变量中获悉</span><br><span class="line">    </span><br><span class="line">    // 先找到 <span class="keyword">key</span> 为 X 的节点的位置</span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">I</span> <span class="keyword">is</span> <span class="keyword">present</span> <span class="keyword">THEN</span></span><br><span class="line">        swap item <span class="keyword">I</span> <span class="keyword">into</span> leaf <span class="keyword">L</span> which contains the inorder successor <span class="keyword">of</span> <span class="keyword">I</span></span><br><span class="line">        // 从 leaf <span class="keyword">L</span> 开始删除操作</span><br><span class="line">        <span class="keyword">IF</span> <span class="keyword">L</span> has <span class="keyword">no</span> items <span class="keyword">THEN</span> Fix(<span class="keyword">L</span>)</span><br><span class="line">        <span class="keyword">success</span> := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        <span class="keyword">success</span> := <span class="literal">false</span></span></span><br></pre></td></tr></table></figure>
<p>然后是其中的 Fix 函数，用来处理没有子节点的节点，保证符合 B-Tree 的基本性质</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Fix(N)</span><br><span class="line">    // N 是一个没有子节点的节点</span><br><span class="line">    // 如果 N 是一个 internal node，那么它有一个子节点</span><br><span class="line">    </span><br><span class="line">    Let P be the parent of N. If N is the root, <span class="operator"><span class="keyword">delete</span> it <span class="keyword">and</span> <span class="keyword">return</span>.</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">some</span> sibling <span class="keyword">of</span> <span class="keyword">N</span> has two items <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">distribute</span> items among <span class="keyword">N</span>, the sibling, <span class="keyword">and</span> <span class="keyword">P</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">IF</span> <span class="keyword">N</span> <span class="keyword">is</span> internal <span class="keyword">THEN</span></span><br><span class="line">            <span class="keyword">move</span> the appropriate <span class="keyword">child</span> <span class="keyword">from</span> the sibling <span class="keyword">to</span> <span class="keyword">N</span></span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        // 如果其兄弟没有两个子节点，就必须要进行融合</span><br><span class="line">        <span class="keyword">Choose</span> an adjancent sibling S <span class="keyword">of</span> <span class="keyword">N</span></span><br><span class="line">        </span><br><span class="line">        Bring the appropriate item down <span class="keyword">from</span> <span class="keyword">P</span> <span class="keyword">into</span> S</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">IF</span> <span class="keyword">N</span> <span class="keyword">is</span> internal <span class="keyword">THEN</span></span><br><span class="line">            <span class="keyword">Move</span> <span class="keyword">N</span><span class="string">'s child to S</span><br><span class="line">        </span><br><span class="line">        Delete node N</span><br><span class="line">        </span><br><span class="line">        IF P is now without an item THEN Fix(P)</span></span></span><br></pre></td></tr></table></figure>
<p>然后我们看看插入操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">Insert</span>(<span class="keyword">T</span>, newitem)</span><br><span class="line">    // 把 newitem 插入到树 <span class="keyword">T</span> 中</span><br><span class="line">    Let X be the <span class="keyword">search</span> <span class="keyword">key</span> <span class="keyword">of</span> <span class="keyword">new</span> item</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">Locate</span> the leaf <span class="keyword">L</span> <span class="keyword">in</span> which X belongs</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">Add</span> newitem <span class="keyword">to</span> <span class="keyword">L</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">L</span> <span class="keyword">now</span> has three items <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">Split</span>(<span class="keyword">L</span>)</span></span><br></pre></td></tr></table></figure>
<p>继续来看看这里的 Split 函数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Split(N)</span><br><span class="line">    // 分割那些有 3 个子节点的节点。注意如果 N 是 internal 的，它可以有 4 个孩子</span><br><span class="line">    Let P be the parent of N</span><br><span class="line">        // 如果 N 是根，那么创建一个新节点 P</span><br><span class="line">        </span><br><span class="line">    <span class="operator"><span class="keyword">Replace</span> node <span class="keyword">N</span> <span class="keyword">by</span> two nodes, N1 <span class="keyword">and</span> N2</span><br><span class="line">    </span><br><span class="line">    Give N1 the item <span class="keyword">in</span> <span class="keyword">N</span> <span class="keyword">with</span> the smallest <span class="keyword">search</span> <span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line">    Give N2 the item <span class="keyword">in</span> <span class="keyword">N</span> <span class="keyword">with</span> the largest <span class="keyword">search</span> <span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">N</span> <span class="keyword">is</span> an iternal node <span class="keyword">THEN</span></span><br><span class="line">        N1 becomes the <span class="keyword">parent</span> <span class="keyword">of</span> <span class="keyword">N</span><span class="string">'s two leftmost children</span><br><span class="line">        N2 becomes the parent of N'</span>s two rightmost children</span><br><span class="line">    </span><br><span class="line">    Send up <span class="keyword">to</span> <span class="keyword">P</span> the item <span class="keyword">in</span> <span class="keyword">N</span> <span class="keyword">with</span> the middle <span class="keyword">search</span> <span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">P</span> <span class="keyword">now</span> has <span class="number">3</span> items <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">Split</span>(<span class="keyword">P</span>)</span></span><br></pre></td></tr></table></figure>
<p>我们给定如下一颗 B-Tree</p>
<p><img src="/images/14564007797015.jpg" alt=""></p>
<p>插入 39 之后（插入总是在叶节点）为</p>
<p><img src="/images/14564008049100.jpg" alt="插入 39 之后"></p>
<p>再插入 38，会发现有一个节点有多于 2 个子节点，需要 split</p>
<p><img src="/images/14564008689598.jpg" alt="插入 38，split 之前"></p>
<p>可以看到我们通过 split 操作把 39 提上去了（注意对照前面的 split 函数的伪代码来进行操作和理解）：</p>
<p><img src="/images/14564009041532.jpg" alt="插入 38，split 之后"></p>
<p>我们再插入 37 与 36，这会导致树高改变，需要进行更多操作，过程如下：</p>
<p><img src="/images/14564011447526.jpg" alt="插入 37 与 36"></p>
<p>插入之后我们发现又出现了非法的节点，依照 split 规则更新之后，上层的节点再次非法，这里属于有四个子节点的情况，左右分开，把中间的 37 移上一层，就成为最后一个形态。</p>
<p>我们再多插入一些，比如 34，35，36，整个过程如下：</p>
<p><img src="/images/14564014630573.jpg" alt=""></p>
<p>最后就得到</p>
<p><img src="/images/14564015026747.jpg" alt=""></p>
<p>注意，因为向下传播的关系，高度是从顶层开始增长的。</p>
<p>然后我们来看看删除操作，还是用刚才的例子，给定：</p>
<p><img src="/images/14564016695179.jpg" alt=""></p>
<p>这次我们删除 50，因为是根节点，所以需要找一个节点放到原来根的位置，并且需要把 70 下移以满足条件</p>
<p><img src="/images/14564016869839.jpg" alt="删除 50"></p>
<p>我们再删除 100 试试看：</p>
<p><img src="/images/14564018498766.jpg" alt=""></p>
<p>同样对照前面的 Fix 函数进行操作即可。然后我们再删除 60，这里需要涉及的变动就会比较多，如下：</p>
<p><img src="/images/14564020922018.jpg" alt=""></p>
<p>然后我们再删除 70 看看，就会变成这样：</p>
<p><img src="/images/14564021367330.jpg" alt="删除 70"></p>
<p>最后再删除 80，又会进行一次融合</p>
<p><img src="/images/14564021619408.jpg" alt="删除 80"></p>
<p>删除操作总是从 leaf 开始的，把要删除的节点和其 inorder successor 换位置。具体的操作如果还不明白，可以找一些视频来看看，这里不赘述了。</p>
<h2 id="u7EA2_u9ED1_u6811_Red_Black_Tree"><a href="#u7EA2_u9ED1_u6811_Red_Black_Tree" class="headerlink" title="红黑树 Red Black Tree"></a>红黑树 Red Black Tree</h2><p>这里只给出基本性质的说明，具体的细节可以查看<a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="external">这里</a></p>
<p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ol>
<p><img src="/images/14564058100039.jpg" alt="红黑树的例子"></p>
<p>这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。</p>
<p>还是那句话对于约束较多的数据结构，进行插入和删除都是比较复杂的操作，最好通过例子掌握整个过程。</p>
<p>最后提一下复杂度，因为树的分叉设计，所以基本来说复杂度都是 log 的，但是需要注意，在最坏情况下，复杂度很可能是 O(n)，</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从这一讲开始，慢慢就有点难度了，树的每个节点虽然看起来比较简单，但是不同结点以不同规则进行组合就使得难度指数级增长，后面的红黑树因为涉及到结点的调整，一定要按照前面提到的 5 个步骤来过一次，才能清晰理解。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 3 课 链表、栈和队列]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-3/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-3/</id>
    <published>2016-02-24T15:58:50.000Z</published>
    <updated>2016-02-25T04:32:38.000Z</updated>
    <content type="html"><![CDATA[<p>链表、栈和队列是非常基本的数据结构，万丈高楼平地起，即使简单，也要认真对待。</p>
<a id="more"></a>
<hr>
<h2 id="u94FE_u8868"><a href="#u94FE_u8868" class="headerlink" title="链表"></a>链表</h2><p>链表是非常基础和常用的一个数据结构，尤其是在解析器(parser)、游戏和搜索算法中。而且很多时候会用来实现下面的 ADT(Abstract Data Type)：</p>
<ul>
<li>堆栈 Stack</li>
<li>集合 Set</li>
<li>哈希表 Hash Table</li>
</ul>
<p>我们来重温一下实现某个数据结构要做的五个事情：</p>
<ol>
<li>Understand it Abstractly</li>
<li>Write a Specification</li>
<li>Write Applications</li>
<li>Select, Design, Implement</li>
<li>Analyze the Implementation</li>
</ol>
<p>接下来我们以链表为例子，具体来过一遍前三个步骤，后面两个步骤属于实现的细节和实现之后的分析，这里暂时不涉及。</p>
<h3 id="1-Understand_it_Abstractly"><a href="#1-Understand_it_Abstractly" class="headerlink" title="1.Understand it Abstractly"></a>1.Understand it Abstractly</h3><p>因为链表比较简单，所以一幅图就可以解释清楚：</p>
<p><img src="/images/14563356077459.jpg" alt="黄色部分是数据，绿色部分是指针"></p>
<h3 id="2-Specification"><a href="#2-Specification" class="headerlink" title="2.Specification"></a>2.Specification</h3><p>明确的规格说明包括：</p>
<ul>
<li>构造器，公有方法和属性的说明</li>
<li>每个方法包含前条件/后条件</li>
<li>说明应该与实现无关</li>
</ul>
<p>这里用一个 <code>IntNode</code> 为例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;     <span class="comment">// data</span></span><br><span class="line">    <span class="keyword">private</span> IntNode link; <span class="comment">// pointer</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntNode</span><span class="params">(<span class="keyword">int</span> initialData, IntNode initialLink)</span></span>&#123;</span><br><span class="line">        data = initialData;</span><br><span class="line">        link = initialLink;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IntNode <span class="title">getLink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> link;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> newdata)</span></span>&#123;</span><br><span class="line">        data = newdata;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLink</span><span class="params">(IntNode newlink)</span></span>&#123;</span><br><span class="line">        link = newlink;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Application"><a href="#3-Application" class="headerlink" title="3.Application"></a>3.Application</h3><p>根据前面的规格说明，具体来使用我们创建的数据结构。这里我们不直接把变量声明为公有，而是通过 getter 和 setter 来进行访问，等于是把变量名称和这个变量本身进行了解耦，即使改变了变量名，只要函数接口不变，对外的行为仍旧是不变的</p>
<h3 id="u94FE_u8868_u5C0F_u7ED3"><a href="#u94FE_u8868_u5C0F_u7ED3" class="headerlink" title="链表小结"></a>链表小结</h3><p>需要掌握的链表操作：</p>
<ul>
<li>插入</li>
<li>删除</li>
<li>检查是否有环</li>
<li>保证程序的健壮性（主要是头为空的时候）</li>
</ul>
<p>其他比较特别的操作：</p>
<ul>
<li>合并 N 个链表</li>
<li>反转链表</li>
<li>截取链表的一部分</li>
<li>寻找链表的 1/N</li>
</ul>
<h2 id="u6808_u4E0E_u961F_u5217"><a href="#u6808_u4E0E_u961F_u5217" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>栈和队列是比较典型的 ADT，所谓 ADT，就是实际上内存中没有类似的数据结构对应，具体的操作是人为增加的设定，是为 Abstract，但是同时它们也被当做数据类型来用，是为 Data Type，于是就成为 ADT。</p>
<p>因为比较简单的缘故，这里大概说一下要点：</p>
<h3 id="u6808"><a href="#u6808" class="headerlink" title="栈"></a>栈</h3><p>性质</p>
<ul>
<li>后入先出</li>
<li>Last-In / First-Out</li>
</ul>
<p>支持的操作：</p>
<ul>
<li>push - 入栈</li>
<li>peek - 查看栈顶</li>
<li>pop - 弹出栈顶元素</li>
</ul>
<p>常见应用</p>
<ul>
<li>程序执行 - 函数调用和返回实际上就是入栈出栈的内容，详情见我的『深入理解计算机系统』系列</li>
<li>解析 - Parsing</li>
<li>计算 postfix 表达式的值 - 例如 <code>4 + 3</code> 可以写成 <code>4 3 +</code></li>
</ul>
<p>需要注意的问题</p>
<ul>
<li>在栈为空的时候执行 pop，会导致 underflow</li>
</ul>
<p>实现方式</p>
<ul>
<li>数组实现 - 需要一个变量来标记栈顶位置</li>
<li>链表实现 - 插入元素时对表头操作需要注意</li>
</ul>
<p>常见题目</p>
<ul>
<li>括号匹配</li>
<li>翻转字符串</li>
<li>模拟递归（N 皇后问题）</li>
</ul>
<h3 id="u961F_u5217"><a href="#u961F_u5217" class="headerlink" title="队列"></a>队列</h3><p>性质</p>
<ul>
<li>先入先出</li>
<li>First-In / First-Out</li>
</ul>
<p>支持的操作：</p>
<ul>
<li>Enqueue - 入队列</li>
<li>Dequeue - 出队列</li>
</ul>
<p>常见应用</p>
<ul>
<li>Round-robin 调度机制 - 处理器处理进程或服务器处理请求（负载均衡）</li>
<li>输入/输出 处理</li>
<li>网络中 packet 的排队处理</li>
</ul>
<p>实现方式</p>
<ul>
<li>数组实现 - 需要一个变量来标记队列头及队列尾的位置</li>
<li>链表实现 - 需要保存表尾，处理表头的时候注意操作顺序</li>
</ul>
<p>与栈的组合</p>
<ul>
<li>利用一个栈和一个队列可以用来判断回文串</li>
</ul>
<p>队列的进阶使用</p>
<ul>
<li>优先队列<ul>
<li>插入队列的元素有一定的顺序要求</li>
<li>每次插入实际上是某种意义上搜索和排序的过程</li>
<li>可以用数组来模拟实现</li>
<li>可以看作是『最大堆』或『最小堆』</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>链表、栈和队列是非常基本的数据结构，万丈高楼平地起，即使简单，也要认真对待。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 2 课 基础知识]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-2/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-2/</id>
    <published>2016-02-24T15:35:52.000Z</published>
    <updated>2016-02-24T16:42:20.000Z</updated>
    <content type="html"><![CDATA[<p>这一课我们不会涉及具体的数据结构或算法，而是先了解一些分析数据结构和算法的基本知识，如前条件/后条件，时间空间复杂度分析。</p>
<a id="more"></a>
<hr>
<h2 id="u524D_u6761_u4EF6/_u540E_u6761_u4EF6"><a href="#u524D_u6761_u4EF6/_u540E_u6761_u4EF6" class="headerlink" title="前条件/后条件"></a>前条件/后条件</h2><p>建议在写具体的函数之前，都要先想好（写好）前条件和后条件，这样可以确定问题的边界。</p>
<ul>
<li>前条件：在函数调用之前一定为真的条件</li>
<li>后条件：在函数执行完之后为真的条件</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Precondition: x &gt;= 0</span></span><br><span class="line"><span class="comment">// Postcondition: The square root of x has</span></span><br><span class="line"><span class="comment">// been written to the standard output</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Big_O"><a href="#Big_O" class="headerlink" title="Big O"></a>Big O</h2><p>在具体介绍之前，先来一些基本的数学公式复习</p>
 $$log_b(x_1·x_2)=log_bx_1+log_bx_2$$ 
 $$log_b(\frac{x_1}{x_2})=log_bx_1-log_bx_2$$ 
 $$log_b(x^c)=c·log_bx$$ 
<p>事实上除了我们常用的 Big O，还有另外两种表示的方法：Big Omega($Big- \Omega$) 和 Big Theta($Big - \theta$)</p>
<p>这里只介绍它们的差别，具体的定义可以自行查看。</p>
<p>Big-O 实际上只表示上限，比如说，我们知道 $17n^2\in O(n^2)$，但是同时我们也可以说 $17n^2\in O(n^37)$ 和 $17n^2\in O(2^n)$</p>
<p>Big omega 则是表示下限，例如 $f(n) = n$，那么下面两个式子都成立 $f(n) \in O(n^2)$ 与 $n^2 \in \Omega(n)$</p>
<p>总结一下：</p>
<p><img src="/images/14563304975385.jpg" alt=""></p>
<p>而 Big theta(Big $\theta$) 则是前面两个的交集：</p>
<p>$$\theta(f)=O(f) \cap \Omega(f)$$</p>
<p>举例来说，函数 $f(n) = 4n$，则</p>
<p>$$f(n)\in O(n)$$</p>
<p>$$f(n) \in \Omega(n)$$</p>
<p>所以</p>
<p>$$f(n)\in \theta(n)$$</p>
<p>简单来说就是</p>
<ol>
<li>Big O 是一个算法最坏情况的度量</li>
<li>Big Omega 是一个算法最好情况的度量</li>
<li>Big Theta 表达了一个算法的区间，给定了一个函数的渐近的逼近(asymptotically tight bound)</li>
</ol>
<p>但是一般来说用 Big O 也就足够了</p>
<h2 id="u9762_u5411_u5BF9_u8C61_u7F16_u7A0B"><a href="#u9762_u5411_u5BF9_u8C61_u7F16_u7A0B" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><blockquote>
<p>Class = Data + Methods</p>
</blockquote>
<p>具体要说的话，内容就太多了，需要深入理解『继承』『多态』和『封装』，也不是一篇日志能说清楚的，所以就大概有一个印象，慢慢领悟吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一课我们不会涉及具体的数据结构或算法，而是先了解一些分析数据结构和算法的基本知识，如前条件/后条件，时间空间复杂度分析。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 1 课 总览]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-1/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-1/</id>
    <published>2016-02-24T14:59:07.000Z</published>
    <updated>2016-02-24T15:23:24.000Z</updated>
    <content type="html"><![CDATA[<p>数据结构与算法是编程中基础中的基础，重要的不是具体某个结构或者算法本身，而是通过理解数据结构和算法在解决问题中发挥的作用，掌握如何用计算机解决问题的方法，进而练就一套自己观察问题，思考问题，解决问题的招式。</p>
<a id="more"></a>
<hr>
<p>网上相关的资料其实蛮多的，之所以打算『重复造轮子』，一是之前的<a href="http://wdxtub.com/2016/01/22/programmer-startline-1/">编程起跑线系列</a>有很多具体的算法思想没有详细说明，二是借着课程的体系重新梳理一下自己的思路。所以整个系列可能会给出大量的参考链接，用于说明基本的概念，而对于数据结构和算法背后的思想，则是我想要着重讨论的。</p>
<p>这门课的编程语言是 Java（CMU 感觉啥课都是 Java），学习目标是：</p>
<ol>
<li>根据特定问题设计或选择合适的算法</li>
<li>根据特定问题设计或选择合适的数据结构</li>
<li>在程序中使用：stacks, queues, linked lists, trees, graphs, 以及 hash tables. </li>
<li>能够用 Big O, Big Omega, 和 Big Theta 分析程序的性能</li>
<li>理解 worse case, best case, average case</li>
<li>理解程序正确性和性能的差异</li>
<li>理解 NP-completeness 理论</li>
<li>能够区分出哪里问题是可以通过计算解决的，哪些不是</li>
</ol>
<p>参考书目：</p>
<ul>
<li>《Data Structures &amp; Other Objects Using Java》 Michael Main, Fourth Edition (Addison-Wesley Longman, ISBN-13 978-0132576246)</li>
<li>《Introduction to Algorithms》Corman, et al., 1990, MIT Press, ISBN 0262031418</li>
</ul>
<p>总体来看是比较中规中矩的一门课，老师给出的课件也是比较凌乱，我会按照自己的理解重新进行组织。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>数据结构与算法是编程中基础中的基础，重要的不是具体某个结构或者算法本身，而是通过理解数据结构和算法在解决问题中发挥的作用，掌握如何用计算机解决问题的方法，进而练就一套自己观察问题，思考问题，解决问题的招式。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="信息处理" scheme="http://wdxtub.com/tags/%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[英语口语中的『噪声』]]></title>
    <link href="http://wdxtub.com/2016/02/23/pronunciation-stress/"/>
    <id>http://wdxtub.com/2016/02/23/pronunciation-stress/</id>
    <published>2016-02-24T02:33:28.000Z</published>
    <updated>2016-02-24T04:05:39.000Z</updated>
    <content type="html"><![CDATA[<p>一个人觉得自己不再需要改变的时候，最大的改变就已经发生了——他变成了没有未来的人。</p>
<a id="more"></a>
<hr>
<p>这个学期给一门研究生课程当助教，宾夕法尼亚州有这么一条法律，英语不是母语的同学当助教的话，必须要达到一定的沟通交流水平，否则学校要被罚款。具体到 CMU，就意味着我需要通过一门叫 ITA 的测试（之前的<a href="http://wdxtub.com/2016/02/19/ita-test/">日志</a>也有提及）。因为是专门负责英语教学的部门，我的英语虽然能应付日常交际，但是细化到讲课上，就有些捉襟见肘了，所以必须进行一些课程培训。</p>
<p>昨天完成了个人作业，已经感觉有了很大收获（见<a href="http://wdxtub.com/2016/02/22/how-to-speak/">这里</a>），今天去上了关于发音的培训课（主要是重音），更是感觉醍醐灌顶，小班教学，寓教于乐，原本担心两个小时太长的我，到最后还觉得时间过得太快，想让老师多讲一会儿。</p>
<p>所以在这篇日志中，讲讲如何快速掌握英语口语中的『重音』。掌握了重音，就可以最大程度减少表达中的『噪声』，让自己的表达更容易被听懂。</p>
<h2 id="u91CD_u97F3_u4E0E_u8BED_u8C03_28stress_and_intonation_29"><a href="#u91CD_u97F3_u4E0E_u8BED_u8C03_28stress_and_intonation_29" class="headerlink" title="重音与语调(stress and intonation)"></a>重音与语调(stress and intonation)</h2><p>以汉语为母语的我们，长期浸淫在汉语环境中（汉语属于 monotone），无论从生理还是心理上都难以完全转换到英语模式。但是我们真的需要说得跟以英语为母语的人一样吗？并不需要！我们需要的是让的表达更加清晰，更容易理解，至于带一点点口音其实无伤大雅，甚至有时候还能成为个人特色（生活大爆炸中的 Raj）。</p>
<p>如果说完整的表达是 100 分的话，那么口音其实只占 25 分，剩下的 75 分是重音与语调。但是奇怪的是，大多数英语学习者都忽略了这 75 分，有种舍本逐末的感觉。</p>
<p>举个例子，15(fifteen) 和 50(fifty) 是我们很容易说不清的，问题不在于我们发音不够准，而是我们重音不对。正确的读法应该是：</p>
<p>15 - fifTEEN, 50 - FIFty（大写的部分表示重音），通过重音的变换，别人可以轻松地明白我们在说 15 还是 50。</p>
<p>有重音，相对来说，肯定也有轻读的，甚至我们可以吞掉某些音节，看下面两个例子：</p>
<blockquote>
<p>Give a man a horse he can ride</p>
</blockquote>
<p>这里的 can，实际的发音类似 kon，尾音甚至可以省略</p>
<blockquote>
<p>His rank and wealth, his strenth and health</p>
</blockquote>
<p>这里的 and，实际的发音就剩下 n，大家可以自己读一下试一试。</p>
<p>再举一个对比：</p>
<blockquote>
<p>I can || go. 与 I || can’t || go. (这里 || 表示停顿)</p>
</blockquote>
<p>第一个句子，go 需要重音，第二个句子，can’t 需要重音。说了这么多，到底要怎么重音呢？有下面三个基本原则：</p>
<ol>
<li><strong>Louder</strong> (more air = more volume)</li>
<li><strong>Longer</strong> (s-t-r-e-t-c-h out the word, especially the vowel)</li>
<li><strong>Pause</strong> (before or after the stress to make it stand out)</li>
</ol>
<h2 id="u54EA_u4E9B_u8BCD_u9700_u8981_u91CD_u97F3"><a href="#u54EA_u4E9B_u8BCD_u9700_u8981_u91CD_u97F3" class="headerlink" title="哪些词需要重音"></a>哪些词需要重音</h2><p>重音本身是和说话的意思紧密相关的，所以大原则就是，要利用重音突出表达某个意思，也就是说，哪个词的信息量大，哪个词就需要重音。</p>
<p>总体来看可以这样划分：</p>
<ul>
<li>Content words are stressed: Nouns, verbs, adjectives and adverbs, question words, demonstratives(these, those, etc), negatives</li>
<li>Function words are not stressed: Prepositions, pronouns, articles, verb “to be”, conjunctions(and, but), auxiliaries(do, should, can)</li>
</ul>
<p>对于每个单词，其实也有重音，规则还是一样：louder, longer, pause。对于类似 AI, DNA 这种缩写，每个单词都需要重音。</p>
<p>对于复合名词，每个单词都需要重音，但是前面的可以再重一点，比如 “quantum || mechanics”</p>
<h2 id="u5229_u7528_u91CD_u97F3_u6765_u5F3A_u8C03_u4FE1_u606F"><a href="#u5229_u7528_u91CD_u97F3_u6765_u5F3A_u8C03_u4FE1_u606F" class="headerlink" title="利用重音来强调信息"></a>利用重音来强调信息</h2><p>对一个句子不同单词重音，可以有不同的强调效果，比如</p>
<ul>
<li>Did John study Chemical Engineering last semester? (normal yes/no question stress)</li>
<li>Did John study Chemical Engineering || <strong>last</strong> || semester? (no, three semesters ago)</li>
<li>Did John study || <strong>Chemical</strong> || Engineering last semester? (no, electrical)</li>
<li>Did John || <strong>study</strong> || Chemical Engineering last semester? (no, he taught)</li>
<li>Did || <strong>John</strong> || study Chemical Engineering last semester? (no, Bob did)</li>
</ul>
<p>另一种情形，是利用重音来区别比较近似的两个词，如：</p>
<ul>
<li>Did you study MICRO or MACROeconomics?</li>
<li>Did you say INput or OUTput?</li>
<li>Did you say SUPER or SEMIconductor?</li>
<li>Are we talking about FISion or FUSion?</li>
<li>Are you working with HARDware or SOFTware?</li>
<li>Was the result a POSITIVE or a NEGATIVE integer?</li>
<li>Is the curve conVEX or conCAVE?</li>
<li>Is that elastic or INelastic?</li>
<li>Did you say reFLECtion or reFRACtion</li>
</ul>
<p>这里大写表示要重音的部分，仔细感受一下。</p>
<p>最后一个情况是需要纠正别人的话，那么对于纠正的地方就需要重音，比方说：</p>
<ul>
<li>Boston is a state -&gt; No, it’s a || <strong>city</strong>.</li>
<li>Tokyo is in Korea -&gt; No, it’s in || <strong>Japan</strong>.</li>
</ul>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>给我震动最大的，不是精心准备的上课材料，不是精细到位的指导，而是去思考如何做好一件事情，并用最好的方式传达出去感染更多的人。这种教育模式是我在国内很少见到的（也就我爸妈教我的时候是这样），有这样的老师，学生又如何能不『尊师重道』呢？</p>
<p>信噪比是一个很重要的思路，生活中的方方面面都可以从这个角度来切入，思考并改进已有的方法。</p>
<p>最后说一个很有意思的看问题的角度，在强调语调和重音的作用时，老师让我们试着去模仿英语为母语的人如何说中文，通过仔细揣摩个中不同，就会发现他们即使说中文也带着说英文时的重音和语调，我们听起来就觉得有点怪（虽然意思可以明白），反之亦然。</p>
<p>这种通过反向模仿来进行思考和比较的思路，其实还可以应用在很多方面，这堂课哪怕我只听了这么一句话，这两个小时也值了，更何况整堂课干货满满毫无尿点呢！</p>
<p>还有很长的路要走，我要加油。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个人觉得自己不再需要改变的时候，最大的改变就已经发生了——他变成了没有未来的人。</p>]]>
    
    </summary>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
  </entry>
  
</feed>
