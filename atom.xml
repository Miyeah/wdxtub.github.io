<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-03-10T16:35:35.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[【潜龙谍影系列】故事、剧情与历史]]></title>
    <link href="http://wdxtub.com/2016/03/10/mgs/"/>
    <id>http://wdxtub.com/2016/03/10/mgs/</id>
    <published>2016-03-10T14:07:09.000Z</published>
    <updated>2016-03-10T16:35:35.000Z</updated>
    <content type="html"><![CDATA[<p>如果说这个世界上有第二个系列像 EVA 一样让我如痴如醉的话，那么肯定是 MGS 系列。在玩『潜龙谍影5：幻痛』的时候，每一段磁带（包含大量重要剧情信息）都认真听过之后，对于整个系列的剧情有了大概的认知。这篇文章会比较长，综合了网上的各种资料和我自己的理解，希望能给大家带来一个比较完整的阅读体验。</p>
<a id="more"></a>
<hr>
<h2 id="u5386_u53F2_u80CC_u666F"><a href="#u5386_u53F2_u80CC_u666F" class="headerlink" title="历史背景"></a>历史背景</h2><h3 id="1960__u5E74_u4E4B_u524D"><a href="#1960__u5E74_u4E4B_u524D" class="headerlink" title="1960 年之前"></a>1960 年之前</h3><p>1918 年同盟国（德国、奥匈、土耳其、保加利亚）和协约国（英国、法国、俄国、意大利）进行的世界大战，简称一战，约有6500万人参战，1000万人丧生，2000万人受伤。1918年，这场战争以协约国的胜利告终。</p>
<p>同年，弗拉基米尔·列宁在俄国建立了秘密情报机构格勒乌（GRU）。</p>
<p><img src="/images/14576194971120.jpg" alt=""></p>
<p>一战之后，美国、苏联、中国三大国最富有、最有权力的人——他们被称为智者议会（ Wisemen’s Committee），建立了秘密组织：哲学家（ThePhilosophers）。这些人拥有广泛的社会触角和近乎无限的资源，哲学家组织希望借助他们庞大的资源影响世界局势，让类似一战的大规模全球冲突不再重演。在成立后，哲学家的势力迅速增长，很快成为他们各自的国家政府背后的绝对权力。</p>
<p><strong>引领者出生 1922 年</strong></p>
<p><img src="/images/14576196418920.jpg" alt="引领者，又称 The Boss"></p>
<p>哲学家组织高级成员，智者议会成员的女儿引领者（TheBoss）出生。这个女子会成为美国乃至世界历史中的一位幕后的关键人物。</p>
<p><strong>第二次世界大战开始 1939 年</strong></p>
<p>1939年9月1日，德国集中强大兵力，对波兰发动“闪电战”，第二次世界大战全面爆发。</p>
<p>在二战期间，哲学家的成员收集了大量资源、金钱，总金额超过1000亿美元（大概相当于今天的1万6000亿美元左右）,意在发展新型战争手段：如核武器、眼镜蛇部队等，以终结战争。这笔巨额资产被称为“哲学家的遗产”（the Philosophers’ Legacy），而各国的哲学家组织则达成协议，在击败轴心国后，把这笔巨款返还各国。唯一取得这笔巨款的方式是一套微型胶片——胶片里储存着这些资金在各个银行的交易记录。然而，二战结束后，哲学家的遗产——即微型胶卷却被负责为哲学家洗钱的苏联军官鲍里斯·沃尔金（Boris Volgin）窃取。</p>
<p><img src="/images/14576198651470.jpg" alt="第二次世界大战"></p>
<p><strong>卡廷惨案</strong></p>
<p>第二次世界大战期间苏联秘密警察机关在苏共中央的批准下，于1940年4月至5月间对被俘的波兰战俘、知识分子、警察及其他公务员进行的大屠杀,共杀死2.2万人。因为4421人在卡廷森林被处决，故名卡廷事件。</p>
<p>窃取哲学家遗产的鲍里斯·沃尔金的儿子，时任苏联内务部内卫部队军官的叶夫根尼·鲍里索维奇·沃尔金（Yevgeny Borisovitch Volgin）上校参与了这场惨案。他的惯用手法是，将囚徒的眼罩掀开，再殴打致死。沃尔金还参与过1953年的东德反乱镇压和1956年的匈牙利动乱镇压，其本人曾不无得意地表示，他“处理”过超过10万人。</p>
<p>鲍里斯·沃尔金去世后，哲学家的遗产被其子叶夫根尼·鲍里索维奇·沃尔金继承。</p>
<p><img src="/images/14576200196071.jpg" alt="卡廷惨案"></p>
<p><strong>曼哈顿计划启动·眼镜蛇部队成军 1942 年</strong></p>
<p>二战期间，引领者创建了秘密特殊部队眼镜蛇部队。这支部队集合了联合国军最优秀的士兵，并由引领者亲自编成和训练。眼镜蛇部队所负责的任务一般绝对保密，在死前，该部队成员会用身上装备的小型炸弹进行自爆，以避免泄露秘密。在部队中，代号为苦痛者（The Pain）、恐惧者（The Fear）、末日者（The End）、狂怒者（The Fury）、悲哀者（The Sorrow）几位成员对引领者怀有特殊的情感，后来再次集结到她的身边。引领者本人则代号“欢乐”（The Joy），意为在战场上寻找到无上的欢乐。</p>
<p>同年，开发原子弹的工程曼哈顿计划在美国启动。</p>
<p><img src="/images/14576201575441.jpg" alt="曼哈顿计划"></p>
<p><strong>盟军进行诺曼底登陆行动 1944 年</strong></p>
<p>20世纪最大的登陆战役，盟军调集288万部队，横渡英吉利海峡，让英美军队重返欧洲战场。</p>
<p>由于眼镜蛇部队破坏了德军的V2导弹，在诺曼底登陆中发生了重要作用。引领者和悲哀者者的孩子山猫（Ocelot）在也在这场登陆战役中诞生，并在引领者的腹部留下一道蛇形的疤痕。</p>
<p><img src="/images/14576202257805.jpg" alt="诺曼底登陆"></p>
<p><strong>三一弹试爆，日本遭受原子弹轰炸&amp;修依·艾默里出生 1945 年</strong></p>
<p>第一颗原子弹——三一弹在美国试爆成功。同年，美国在日本投下两颗原子弹——小男孩、胖子。</p>
<p>同年，修依·艾默里克出生。他的父亲参与过曼哈顿计划，他则出生就双腿残疾。后来，他成为一名双足步行兵器的开发者。</p>
<p><strong>CIA成立·眼镜蛇部队解散 1947 年</strong></p>
<p>美国中央情报局（CIA）成立。同年，在二战中功勋卓著的部队“眼镜蛇”，在哲学家组织因为争夺哲学家遗产导致的紧张分裂态势下解散。</p>
<p><strong>朝鲜战争爆发·引领者与大首领相遇 1950 年</strong></p>
<p>1950年6月25日，朝鲜进攻韩国，朝鲜战争爆发。以美国为首的联合国军在当年9月15日从仁川登陆，帮助韩国进行反攻。10月25日，中国人民志愿军赴朝，与朝鲜并肩作战。</p>
<p>一个15岁的少年约翰（John）参与了朝鲜战争，而他将成为美国历史上最优秀的战士：大首领（Big Boss）。同样在这一年，约翰结识了传奇英雄引领者，并向引领者学习战斗、谍报、生存等多种技能超过10年以上，二人的关系和羁绊已经超越简单的师徒。二人一起创立了CQC近身格斗术。</p>
<p><strong>美国进行内华达州核爆实验·引领者暴露于大量核辐射 1951 年</strong></p>
<p>1950年，美国总统杜鲁门签署命令，宣布在内华达州的内利斯空军靶场建立内华达国家安全区。</p>
<p>1951年1月27日，内华达国家安全区在弗伦奇曼平底进行了第一次核试验，爆炸当量相当于1000吨TNT。</p>
<p>1951年11月1日，引领者参与内华达州核爆实验，暴露在大量核辐射下，失去了生育的能力。</p>
<p><img src="/images/14576205637151.jpg" alt="内华达州核爆实验"></p>
<p><strong>美国试爆第一枚氢弹·大首领暴露于大量辐射 1954 年</strong></p>
<p>美国在比基尼环礁上试爆了第一枚氢弹。约翰，即后来的大首领也被牵扯其中。他当时的朋友都因核辐射染上白血病、甲状腺癌等致命疾病，或直接死于辐射，但大首领并没有染上这类病症。尽管如此，大首领还是和他的导师引领者一样，在核辐射下失去了自然生殖的能力。</p>
<p><img src="/images/14576205854028.jpg" alt="试爆第一枚氢弹"></p>
<h3 id="1961__u5E74_-_1970__u5E74"><a href="#1961__u5E74_-_1970__u5E74" class="headerlink" title="1961 年 - 1970 年"></a>1961 年 - 1970 年</h3><p><strong>美政府实行“水星计划”·奇爱博士结识引领者 1961 年</strong></p>
<p>美国在1959年开始载人航天计划“水星计划”。尽管官方历史记载美国航天第一任是1961年5月5日进入太空的艾伦·B·谢泼德，但事实上，第一位进入太空的美国人是引领者，她在“水星计划”中扮演了重要角色，并在1961年4月进入太空，1961年4月12日返回地球。再入大气层时，引领者被宇宙辐射和再入大气层产生的热量严重灼伤，进入了长达6个月的严重昏迷。在太空俯瞰地球的震撼景象，让引领者深信世界应该团结一心，而非分阵营对立。</p>
<p>在水星计划中，引领者结识了水星计划科研人员奇爱博士，奇爱博士对引领者产生了深深的感情。</p>
<p><strong>古巴导弹危机 1962 年</strong></p>
<p>1962年，苏联在古巴秘密部署导弹，并被美国发现。肯尼迪总统大为震怒，宣布封锁古巴，要求苏联撤回已经部署的导弹设施。1962年，10月24日，美国出动90艘军舰，封锁了古巴海峡，所有导弹部队均处于高度戒备状态，全球性的核战争一触即发。最终，赫鲁晓夫同意撤回部署在古巴的导弹设施。</p>
<p>而事实上，赫鲁晓夫同意妥协的不为人知的重要原因，在于肯尼迪同意将逃往至美国的武器开发专家斯特潘诺维奇·索科洛夫遣返至苏联。被遣返回苏联后，这位武器专家被直接送到秘密设计局OKB-754。</p>
<p><img src="/images/14576208423544.jpg" alt="古巴导弹危机"></p>
<p><strong>肯尼迪遇刺身亡·小岛秀夫出生1963</strong></p>
<p>美国总统肯尼迪遇刺，其原因在于哲学家组织不满肯尼迪在猪湾事件中的表现，将其刺杀。</p>
<p>同年，日本人小岛秀夫出生。有传言他与哲学家、引领者、大首领均有神秘的关系，有人甚至认为这个出生晚于哲学家建立的日本人其实是一切的幕后黑手。实际联系至今亦不明朗，尚需进一步调查确认。（这个中二程度不轻啊）</p>
<p><img src="/images/14576209221127.jpg" alt="肯尼迪遇刺身亡"></p>
<p><strong>贞洁行动失败 1964 年 8 月 24 日</strong></p>
<p>美国政府则派出FOX部队——零少校（Major Zero）和引领者建立的CIA秘密行动小组，希望将遣返回美国的武器专家斯特潘诺维奇·索科洛夫再次营救回美国，这次任务的代号即为“贞洁行动”（Virtuous Mission）。约翰（John）,任务代号裸蛇（Naked Snake），FOX部队的第一个探员，被派往苏联丛林带回索科洛夫。</p>
<p>任务进行到一半，原本应是任务支援的引领者却向苏联变节，阻止了整个行动。引领者集结了眼镜蛇部队的一帮原成员，伙同苏联军官，哲学家遗产的拥有者沃尔金，将裸蛇打下吊桥，带走了索科洛夫。引领者将一枚微型核弹头作为见面礼送给了沃尔金，沃尔金则在苏联领土用这枚核弹打击了秘密设计局OKB-754。这枚美国核弹在苏联的引爆，导致美国的非法入侵被苏联指责，核大战危机再次一触即发。当然，贞洁行动也以失败告终。</p>
<p>在贞洁行动中，裸蛇完成了历史首次HALO降落——从高空跳下，并在低空打开降落伞。</p>
<p><img src="/images/14576210570962.jpg" alt="Metal Gear Solid 3 Snake Eater"></p>
<p>这段故事就是『潜龙谍影3：食蛇者』的剧情，于 2004年11月(PS2)/2011年11月(PS3，360版HD)/2012年6月(PSV版HD) 发售。可以看做是游戏系列里最先的一作。</p>
<p><strong>代号食蛇者行动·苏联军官沃尔金意外遭受雷击 1964 年 8 月 30 日</strong></p>
<p>为了抹杀变节者引领者,食蛇者行动展开。裸蛇乘坐单人驾驶式飞机，再次侵入苏联境内。在任务中，他得到了伊娃（Eva）的帮助，她表面上是一个前美国国安局间谍，其实是哲学家和某大国的双重间谍，裸蛇也遭遇了年轻的俄国格勒乌军官左轮山猫，与他数次交手，并在他的枪下失去了右眼，戴上眼罩。在重重的困难之中，裸蛇一一击败了前眼镜蛇部队的成员，并击毁了核搭载战车峡谷虎（Shagohod）。在追逐裸蛇的过程中，沃尔金遭雷劈，疑似死亡。</p>
<p><img src="/images/14576212112140.jpg" alt="代号食蛇者行动"></p>
<p><strong>代号食蛇者行动·引领者在苏联境内逝世</strong></p>
<p>在食蛇者行动的最后，引领者和大首领在一片花海之中展开命定的师徒之战。引领者吐露了自己的梦想，希望世界不要在冷战的阴云下割裂，而应该再次团结一心。大首领只有10分钟击败自己的导师，在时间结束之时，他们的所在地会遭到轰炸。大首领最终打败了自己的导师，在生命的最后时刻，引领者把记载着爱国者遗产交易记录的微缩胶片交给了大首领，并要求大首领杀死自己。枪响，白色的花海一片血红。</p>
<p><img src="/images/14576212725582.jpg" alt="Boss VS Big Boss"></p>
<p><strong>美国总统授予战斗英雄约翰大首领称号 1969 年</strong></p>
<p>由于成功击杀了引领者，裸蛇约翰被美国总统授予大首领的荣誉称号。但随后，他也了解到关于食蛇者行动的真相。引领者其实秘密为美国政府工作。沃尔金从他父亲手中继承了哲学家的遗产，而引领者变节的目的是接近沃尔金，拿回哲学家的遗产，但因为沃尔金意料之外地发射核弹，她的任务变了:她需要死在裸蛇手里，永远作为一个叛徒为世人所知，从而给愤怒的苏联一个交代，引领者也接受了这一任务的变化，最终死在自己门徒手中，并把哲学家遗产交给了美国。裸蛇对美国政府幻想破灭，他拒绝承认大首领的称号，并退出了FOX部队。引领者交给大首领的哲学家遗产只有一半，这一半遗产落入CIA之手，然而CIA的中央情报总监并未上报，只是留在自己的手中。</p>
<p><strong>阿帕网诞生 1969 年</strong></p>
<p>美国高级研究计划署组建了计算机网络：高级研究计划代理网络（Advanced Research Projects Agency Network），简称阿帕网。在阿帕网基础上，现代的互联网逐渐发展而来。信息串流和分享方式的革命给“爱国者”AI后来利用信息统治世界提供了技术基础。</p>
<p>事实上，后来的“爱国者”组织的创始人之一希金特也参与了阿帕网的开发，并在此后不久升任美国国防部高级研究计划局（DARPA）的局长。</p>
<p><img src="/images/14576214023876.jpg" alt="阿帕网"></p>
<p><strong>“爱国者”诞生 1970 年</strong></p>
<p>山猫刺杀了CIA的中央情报总监，取得了哲学家遗产。在哲学家遗产的基础上，大首领、零上校、左轮山猫，和两位参加了食蛇者行动的FOX前成员：空降护理和希金特建立了“爱国者”（The Patriots）组织。爱国者组织实际上是哲学家美国分布的重组。其建立目的是为了实现引领者关于世界大同的梦想。零把这个梦想解读为“没有边界的世界（World Without Borders）”，在一个规则下团结起整个世界。所以零大肆宣扬大首领的传奇，作为一种宣传控制的手段。斯内克相信零是为了自己的利益歪曲了引领者的心愿。</p>
<p><img src="/images/14576214873702.jpg" alt="The Patriots"></p>
<p><strong>黑历史之中的猎狐犬小队成立 1969~1970 年</strong></p>
<p>有着Big Boss称号的Snake早已从FOX小队中退役，开始过着训练新兵的生活。可是突然一天Snake等全部和FOX小队有关系的人员都被逮捕。原来FOX小队的指挥官Gene叛变了，Gene意图建立Army’s Heaven——这个只属于军人的国家，以打破世界的军事平衡。Big Boss在追击Gene的途中将很多人纳为了自己的同伴，比如NULL，Elisa和Johnthan等，同时这些人成立了猎狐犬小队，开始对FOX部队进行反击。最终BB干掉了MetalGear之后打倒了Gene。Gene在死前将手头上的所有资金设备全部交给了BB，并且声称BB以后一定会用到这笔资源。</p>
<p><img src="/images/14576215645424.jpg" alt="Metal Gear Solid : Portable Ops Plus"></p>
<p>这段故事就是 Metal Gear Solid : Portable Ops Plus 中的剧情，于 2006年12月/2007年9月(加强版) 在 PSP 平台发售。</p>
<h3 id="1971__u5E74_-_1980__u5E74"><a href="#1971__u5E74_-_1980__u5E74" class="headerlink" title="1971 年 - 1980 年"></a>1971 年 - 1980 年</h3><p><strong>美政府启动“魔童计划” 1971 年</strong></p>
<p>美国政府开始进行魔童计划（Les Enfants Terribles，法语，糟糕的，可怕的孩子，来自50年代同名电影）。该计划意图制造出传奇战士大首领的克隆体。该计划的幕后资助人是零，克拉克博士带头进行。零的意图不仅是要造出最强的战士，更是要保证如果和大首领分道扬镳，可以制造出另一个可以加以利用的偶像。克拉克博士参与过贞洁行动和食蛇者行动，当时代号空降护理（Para-Medic）。</p>
<p><img src="/images/14576216937761.jpg" alt="魔童计划"></p>
<p><strong>双蛇诞生 1972 年</strong></p>
<p>伊娃作为代孕母亲，魔童计划的成果——双蛇诞生。继承较优秀显性基因的孩子，就来被叫做利奎德·斯内克（Liquid Snake，液体蛇），而继承较劣质隐性基因的孩子，就是后来的索立德·斯内克（Solid Snake，固体蛇）。后来，继承了完美而平衡的基因的第三个克隆体，索利达斯·斯内克（Solidus Snake）诞生，即日后的美国总统乔治·希尔斯（George Sears）。</p>
<p>魔童计划并没有事先知会大首领，大首领为零私下进行这一计划感到愤怒。由于和零不可弥合的理念分歧，同年，大首领离开爱国者，与零分道扬镳。</p>
<p><img src="/images/14576217571827.jpg" alt="双蛇诞生"></p>
<p><strong>和平行者事件·AI核武器“和平行者”被毁 1974 年</strong></p>
<p>某一天，自称是和平大学教授的盖尔维兹与他的学生帕兹（Paz）来到无界之师的驻地，请求大首领前往哥斯达黎加调查一支神秘的武装部队，并许以一个人造浮岛基地，但是遭到了拒绝。最终由于一卷录有引领者声音的录音带，大首领答应了真实身份是为克格勃工作的盖尔维兹。</p>
<p>大首领之后在哥斯达黎加当地游击队桑地诺民族解放阵线（FSLN）的帮助下，发现神秘部队受美国中情局（CIA）指挥，将由AI控制的核武器运入哥斯达黎加。其中有一台搭载了引领者的AI——和平行者，也正是录音带中声音的来源。而这一切都是CIA中美洲站长冦尔德曼（Coldman）为了夺回自己在CIA中的地位，而计划另美苏再次陷入核危机之中。在冦尔德曼死在盖尔维兹（真名扎德尔诺夫）枪下之前，启动了和平行者的核弹发射指令。大首领在与和平行者一番激战之后，引领者的AI控制和平行者自己沉入湖中，再次给了世界一个和平的机会。</p>
<p><img src="/images/14576218515576.jpg" alt="Metal Gear Solid: Peace Walker"></p>
<p>这段故事就是 Metal Gear Solid: Peace Walker 的剧情，于 2010年4月(PSP)/2011年11月(PS3,360版HD) 发售。</p>
<p><strong>和平行者事件·三重间谍帕兹坠海失踪</strong></p>
<p>帕兹的真实身份是一名Cipher（零）的间谍。在“和平行者事件”后，回到无界之师的她开始了真正的任务。在试图破坏Metal Gear ZEKE的动力部时被奇科目击，不得已提前行动。帕兹表明Cipher希望大首领重新回到“爱国者”组织并以向美国东部发射核弹相威胁，但遭到拒绝，只能驾驶Metal Gear ZEKE与大首领开战，后被大首领击败，坠入太平洋中。</p>
<p><img src="/images/14576219542113.jpg" alt="帕兹 Paz"></p>
<p><strong>和平行者事件·雇佣兵团无界之师崛起</strong></p>
<p>通过“和平行者事件”，无界之师获得了“母基地”（Mother Base）作为基地，又说得了不少CIA与苏联的佣兵与人才，无论是兵力还是装备，都已经匹敌一个小国的军事实力，并且开始对外派遣佣兵，已可以称为民间军事企业。从和平行者上回收核弹头并自行开发了Metal Gear ZEKE后，无界之师已经成为“世界第七个核武器保有国”。</p>
<p>在击败帕兹，并再次粉碎Cipher的企图后，大首领发布了无界之师崛起宣言：“我们没有国家，没有信仰，没有意识形态。哪里需要我们我们就去哪里，不为国家，不为政府，我们为自己而战。我们战斗不需要理由，仅仅因为有人需要我们。我们会是那些无助者们的威慑力！我们是没有国界的士兵，我们的目标由我们所处的时代所决定！”</p>
<p><img src="/images/14576220334771.jpg" alt="无界之师"></p>
<p><strong>《自私的基因》发表·海上雇佣兵基地“母基地”被毁 1975 年</strong></p>
<p>修依坚持无界之师（MSF）应该向全世界证明自己的干净清白，于是MSF决定接受相关检查。在检查之夜，米勒和斯内克得到消息，帕兹活下来了，被关在欧米茄（OMEGA）营地——一个美国设在古巴的秘密据点。同时，小男孩奇科也被关在那里。帕兹和奇科都知道合金装备ZEKE，大首领必须在他们泄露信息前救回他们。</p>
<p>大首领侵入基地成功解救二人，返回时却发现母基地被攻击了，攻击者是谜之组织XOF，被神秘的疤面男子Skull Face(骷髅脸)领导。在一片混乱中大首领找到米勒，二人乘直升机逃走，母基地则毁于一片火海。但同时乘机的帕兹体内还有一枚炸弹。在帕兹跳下飞机的一刻，炸弹爆炸，大首领陷入长达9年的昏迷。（这也是 Ground Zero 原爆点的剧情，引发后面的毒蛇，山猫另其以为自己就是 Big Boss）</p>
<p>同年，美国科学作家理查德·道金斯发表著名文章《自私的基因》，首次使用模因（meme）一词，指“在诸如语言、观念、信仰、行为方式等的传递过程中与基因（gene）在生物进化过程中所起的作用相类似的那个东西。”后爱国者的“民智选择计划”和该理念有莫大关系。</p>
<p><img src="/images/14576222758289.jpg" alt="Metal Gear SOLID V: GROUNDZEROES"></p>
<p>去救出 Paz 和 Chico 的故事就是 Metal Gear SOLID V: GROUNDZEROES 的剧情，于 2014年3月20日(PS3,PS4,XBOX360,XBOXONE)，2014年12月18日(PC) 发售。</p>
<p><strong>两伊战争爆发&amp;哈尔·艾默里克出生 1980 年</strong></p>
<p>两伊战争，又称第一次波斯湾战争爆发。同年，苏联入侵阿富汗，新冷战爆发。</p>
<p>弗兰克·耶格在罗得西亚内战中，收养了成为孤儿的内奥米（Naomi）。</p>
<p><img src="/images/14576224704845.jpg" alt="两伊战争爆发"></p>
<h3 id="1981__u5E74_-_1990__u5E74"><a href="#1981__u5E74_-_1990__u5E74" class="headerlink" title="1981 年 - 1990 年"></a>1981 年 - 1990 年</h3><p><strong>1984~198X 年《潜龙谍影V：幻痛》绝密档案</strong></p>
<p>零少校为了保护大首领的安全，把大首领转移到塞浦路斯的一家医院治疗，并把大首领身边的医疗兵整形为大首领的模样，作为大首领的替身以保护大首领，代号毒蛇（Venom Snake），最后还委托山猫秘密保护大首领。大首领先于他的替身苏醒，并保护他的替身在骷髅脸的追杀下逃离医院。表达大首领苏醒的暗号即为“V has come to”。之后，大首领去建设他的军事国家，真正的“世外天堂”。毒蛇则在米勒和山猫的支持下经营壮大名为“钻石狗”的雇佣兵军队。</p>
<p>大首领的替身完成了对骷髅脸的复仇。骷髅脸研发了能携带核武器的新型合金装备：类人猿（Sahelanthropus），意图借此进入危险的核平衡。同时他强令密语者研制了一种声带寄生虫，它们寄生入人体后，如果暴露在一种特定的声音下，就会大量繁殖，杀死宿主的肺部。这种特定声音，就是某种特定的语言，即这种寄生虫能杀死说特定语言的宿主，以达到清除这种语言的目的。骷髅脸阴谋计划利用这种寄生虫杀死所有英语使用者，消灭世界通用语，让世界归于混乱和“自由”。大首领的幻影击败了骷髅脸，粉碎了他的阴谋。在过程中，大首领的幻影也遭遇了童年的魔童计划产物：利奎德·斯内克（就是白曼巴，Eli）和原本奉命杀死“大首领”，最后为了却救了他的命的狙击手“安静”（静静，Quiet）。</p>
<p>静静是Cipher安插到毒蛇身边的卧底，在医院的刺杀行动中她全身烧伤，在寄生虫疗法的帮助下幸存。她身上携带着英语种类的寄生虫，作为后备方案，把寄生虫传播到钻石狗部队和全世界。但静静怀抱着对毒蛇的特殊感情，一直闭口不言。直到静静被苏联军队抓取，毒蛇为了救她而陷入生命危险后，静静才迫不得已开口，指引直升机方向营救毒蛇。这导致了寄生虫在静静体内的爆发繁殖，静静也在开口后选择了离开。</p>
<p>而利奎德·斯内克（就是白曼巴，Eli）也在少年心理螳螂的帮助下，带着类人猿和少年士兵最终离开了钻石狗，并继续秉持着向“父亲”：大首领复仇的欲念。</p>
<p>这部分的故事就是 Metal Gear Solid V: Phantom Pain 的剧情，于 2015 年 9 月 2 日发售（PS4, XBOX ONE, PC）</p>
<p><img src="/images/14576228532142.jpg" alt="Metal Gear Solid V: Phantom Pain"></p>
<p><strong>佣兵国家“世外天堂”建立 198X 年</strong></p>
<p>80年代后期，具体年份未明，大首领利用雇佣兵时代积攒的财富扩张他的武装力量，并在南美建立了一个独立的国家：“世外天堂（Outer Heaven）”。在这个国家内，大首领建立了一个巨大的堡垒，作为他的雇佣兵公司的基地。世外天堂是大首领个人信念的产物，它一度成为了幻想破灭的士兵们的避难所，他们在世外天堂不必被当做政府的爪牙利用，也不会被社会抛弃。为了增强世外天堂的军事力量，大首领准备了TX-55型合金装备（TX-55 Metal Gear），一台两足战车，能在世界上任何一个地方直接发射核弹。</p>
<p><img src="/images/14576229516518.jpg" alt="世外天堂"></p>
<p><strong>利比里亚内战爆发·雷电参加利比里亚内战 1989 年</strong></p>
<p>1989年，利比里亚全国爱国阵线打回国内，利比里亚战争由此爆发。</p>
<p>杰克，代号雷电（Raiden）作为少年士兵参与了这场战争。索利达斯·斯内克杀死雷电的双亲后，作为教父收养了雷电，而雷电则一直被他当做战士训练培养，在战争中杀人无数，被称为“白恶魔”和“开膛手杰克”。</p>
<h3 id="1991__u5E74_-_2000__u5E74"><a href="#1991__u5E74_-_2000__u5E74" class="headerlink" title="1991 年 - 2000 年"></a>1991 年 - 2000 年</h3><p><strong>海湾战争爆发，苏联解体·索立德·斯内克加入猎狐犬部队 1991 年</strong></p>
<p>美国为首的多国部队于1991年1月17日对伊拉克开展的战争，目的是恢复科威特的领土。索立德·斯内克和利奎德·斯内克作为特种部队的成员都参加了这场战争。</p>
<p>在这场战争中，美军向士兵注射研究大首领时得到的“战斗基因”，引发了群体性的副作用。士兵们感觉肌肉疼痛、长期疲乏、失眠、丧失记忆、头晕、情绪低落、身体消瘦以及性功能减退，这些症状被统称为“海湾战争综合症”，被媒体广泛报道，但公众并不知道真正的原因。</p>
<p>同年，索立德·斯内克加入了猎狐犬部队。戈尔巴乔夫卸任苏共中央总书记一职，苏联正式宣告解体，冷战结束。</p>
<p><img src="/images/14576232053406.jpg" alt="海湾战争"></p>
<p><strong>索立德·斯内克突袭世外天堂 1995 年</strong></p>
<p>美国得知了世外天堂的存在，也得知了军事基地里有秘密大规模杀伤性武器TX-55型合金装备。此时大首领还是猎狐犬部队的指挥官，他和世外天堂的关系还不为人知。美政府决定让大首领和他的猎狐犬部队去解决危机。大首领派出了自己的儿子，索立德·斯内克(Solid 斯内克,固体蛇，那时还不知道自己是大首领的克隆儿子)去完成这个任务，但给了他一系列错误线索，让他进入一系列陷阱，不过SS都一一克服。斯内克救出了之前执行任务失败被困的灰狐，并最终打败了大首领。之后，北约对世外天堂进行了地毯式轰炸。大首领在爆炸中幸存，召集了麾下部队的幸存者，准备卷土重来。</p>
<p><img src="/images/14576232862358.jpg" alt="Metal Gear"></p>
<p>这部分的故事就是初代作品 Metal Gear 的剧情，于 1987年(MSX2/FC) 发售。</p>
<p><strong>克隆羊多利诞生·能源科学家马弗博士被绑架杀害 1999 年</strong></p>
<p>面对燃油极速消耗的世界性难题，基奥·马弗（Kio Marv)博士提出了一个解决方案：OILIX，一种综合燃料资源，可以解决潜在的全球危机。也因为此，他被一支叫桑给巴尔岛(Zanzibar Land)的武装力量绑架。罗伊·坎贝尔, 猎狐犬部队的现任头领，再次把已经退休的索立德·斯内克送上战场,营救博士。</p>
<p>在任务过程中，斯内克发现了很多冲击性的事实:灰狐已经成为了他的敌人，大首领还活着，此外——还有另外一台合金装备。马弗博士已经被折磨致死，OILIX的方程式落入灰狐之手。索立德·斯内克打败了灰狐和大首领。离开后，索立德·斯内克隐居在阿拉斯加。爱国者收回了大首领的遗体，利用纳米机器让大首领进入昏迷，其遗体一直被零上校保存。</p>
<p>同年，公众所知的第一个生物克隆体——克隆羊多利诞生</p>
<p><img src="/images/14576233891657.jpg" alt="Metal Gear：SOLID SNAKE"></p>
<p>这部分故事就是 Metal Gear：SOLID SNAKE 的剧情，于 1990年(MSX2平台) 发售。可以看做是 Solid Snake 与 Big Boss 的决战</p>
<h3 id="2001__u5E74_-_2010__u5E74"><a href="#2001__u5E74_-_2010__u5E74" class="headerlink" title="2001 年 - 2010 年"></a>2001 年 - 2010 年</h3><p><strong>911事件爆发 2001 年</strong></p>
<p>2001年9月11日上午，两架被恐怖分子劫持的民航客机分别撞向美国纽约世界贸易中心一号楼和世界贸易中心二号楼，两座建筑在遭到攻击后相继倒塌，世界贸易中心其余5座建筑物也受震而坍塌损毁；9时许，另一架被劫持的客机撞向位于美国华盛顿的美国国防部五角大楼，五角大楼局部结构损坏并坍塌。</p>
<p><img src="/images/14576235050107.jpg" alt="911事件"></p>
<p><strong>影子摩西岛事件·猎狐犬发动叛乱 2005 年</strong></p>
<p>时间已经到了20世纪，SS已在阿拉斯加隐居很久。</p>
<p>猎狐犬部队在影子摩西岛发动了叛乱，其时猎狐犬的指挥官是大首领的另一个克隆体——利奎德·斯内克。影子摩西岛存放着核武器和合金装备霸王（METAL GEAR REX）。利奎德·斯内克，左轮山猫，和其他猎狐犬部队的队友要求政府交出大首领的遗体和10亿美金，不然就要发射核弹。利奎德·斯内克的目的在于，通过大首领的遗体治疗手下基因士兵的怪病，并在影子摩西岛重现大首领的“世外天堂”。</p>
<p><img src="/images/14576235752201.jpg" alt="Metal Gear SOLID"></p>
<p>这一部分故事就是 Metal Gear SOLID 的剧情，是 Solid Snake 身世的首次揭开，也是 Metal Gear SOLID 系列的第一部作品，于 1998年(PS)/1999年(PS平台加强版)/2000(PC平台) 发售。</p>
<p><strong>影子摩西岛事件·索立德·斯内克孤身潜入影子摩西岛</strong></p>
<p>罗伊·坎贝尔再次把再次退休的索立德·斯内克拽上战场，去解救影子摩西岛的一些重要人物，然而，任务过程中，这些人全都死于死狐（FOXDIE）病毒引发的心脏病突发，而病毒是内奥米（Naomi）博士在任务前秘密注射进斯内克体内的。斯内克得知灰狐不仅没死，还被改造成了机械忍者。灰狐斩掉了左轮山猫的一只手。斯内克也在任务中遇到了坎贝尔上校的女儿梅丽尔（Meryl），和霸王的设计者哈尔·艾默里奇（修依博士的儿子），他们帮助了斯内克完成任务。</p>
<p><strong>影子摩西岛事件·利奎德·斯内克死于死狐病毒</strong></p>
<p>击败猎狐犬部队的几位成员后，索立德·斯内克得以面对他的兄弟利奎德·斯内克和合金装备“霸王”（Metal Gear Rex）。灰狐牺牲自己，给索立德·斯内克足够的时间摧毁了霸王。最终，索立德·斯内克和利奎德·斯内克近身决战，击败利奎德后，索立德·斯内克和梅丽尔一起逃出生天。利奎德不依不挠继续追逐，但最终还是死于死狐病毒。</p>
<p>而这一切的幕后黑手是时任的美国总统，这一切都是美国政府的阴谋，让斯内克带着死狐病毒进入基地，以杀死利奎德·斯内克等人。</p>
<p>当时的美国总统就是索利达斯·斯内克，总统时用名乔治·希尔斯。同年，他卸任美国总统一职。</p>
<p><strong>“慈善组织”建立 2006 年</strong></p>
<p>影子摩西岛事件之后，索立德·斯内克和奥塔肯建立了名为“慈善组织”的反合金装备非政府组织。这一组织尝试揭露关于影子摩西岛和“霸王”的真相，并呼吁世界停止建造合金装备。</p>
<p><img src="/images/14576238123776.jpg" alt="“慈善组织”建立 "></p>
<p><strong>曼哈顿油轮沉没事件 2007 年</strong></p>
<p>曼哈顿油轮事件，简称油轮事件。美国海军开发了两栖反合金装备武器“海魔鬼”（Metal Gear Ray），用一艘伪装的油轮途径纽约港运送。索立德·斯内克潜入了这艘游轮，试图拍照向世人揭露“海魔鬼”的存在和真相，呼吁停止建造合金装备。在他潜入的同时，格鲁科维奇上校也带领一队俄国士兵，准备夺去海魔鬼。正当斯内克拍摄过照片准备离开时，左轮山猫现身，杀死了格鲁科维奇上校，奉爱国者之命开走了海魔鬼，油轮被海魔鬼撕裂沉没。爱国者将这一切罪责均栽赃在索立德·斯内克身上。</p>
<p><img src="/images/14576239967912.jpg" alt="Metal Gear SOLID 2: SONS OF LIBERTY"></p>
<p>这部分故事就是 Metal Gear SOLID 2: SONS OF LIBERTY 的剧情，也是雷电首次登场，于 2001年11月(PS2)/2011年11月(PS3，360版HD)/2012年6月(PSV版HD) 发售。</p>
<p><strong>巨壳占据事件·“自由之子”劫持美国总统 2009 年</strong></p>
<p>油轮在纽约港沉没后引发了大量环境污染，美国海军趁此机会，在这里建立了建造了建造“玄武”（Arsenal Gear）的设施——巨壳（Big Shell）。玄武是一艘可潜水的巨大堡垒，为了爱国者的信息控制目的而建。一伙自称“自由之子”的恐怖分子劫持了巨壳，并控制了正在检查巨壳的美国总统詹姆斯·约翰逊。“自由之子”由美国前总统乔治·希尔斯，即索利达斯·斯内克带领，目的是获取“玄武”，并由此获取“爱国者”成员的名单。雷电（Raiden）作为一位没有任何经验的新兵，潜入巨壳营救美国总统。</p>
<p><img src="/images/14576241344850.jpg" alt="这部分同样是 Metal Gear SOLID 2: SONS OF LIBERTY 的剧情"></p>
<p><strong>巨壳占据事件&amp;美国前总统乔治·希尔斯去世</strong></p>
<p>雷电出色地一路战胜了“自由之子”的各个成员，并发现了关于巨壳建造“玄武”的真相。“玄武”守护着爱国者精心建造的大型AI：GW。事实上，在大首领离开后，零对一切失去信任，相信下一代不会明白他的意志，便建造了AI来继续爱国者的统治。爱国者的AI共分为5大部分，中枢JD，和4个分管AI：GW、AL、TR和TJ，它们统治着世界一切经济、信息、军事的运行。左轮山猫伪装成被利奎德·斯内克的右手操纵的样子，将玄武导引向曼哈顿，引发了一场大碰撞。在那里，雷电和索利达斯·斯内克决斗，并取得了胜利。</p>
<p><strong>巨壳占据事件·民智选择计划宣告成功</strong></p>
<p>雷电潜入巨壳的一切，其实都在爱国者的控制之下。爱国者试图用GW建立一个通过情报信息控制来控制人类意志的系统，目标是实现“民智选择”（称为3S计划），为达成社会思想上的健全化而进行选择。雷电潜入巨壳其实是对“影子摩西岛事件”的重演，为了测试GW能否在极限状态下发挥作用，控制雷电的行为。而随着雷电杀死索利达斯·斯内克，民智选择计划也宣告成功。在巨壳事件之后，GW这一AI就被爱国者废弃，并在后来被左轮山猫（液体山猫）重组利用。</p>
<p><strong>美国开始积极使用PMC 2010 年</strong></p>
<p>PMC是民间军事雇用企业的简称，指经营军事业务的法人企业。以玄武撞击曼哈顿事件为契机，美国开始积极使用PMC。由此，PMC在战争中的作用逐渐重要，并引发了一种新的经济模式：战争经济。到2014年，世界已形成5大PMC公司，美国2家，英国1家，法国1家，俄罗斯1家。而这些公司，都属于山猫控制的“世外天堂”。</p>
<h3 id="2011__u5E74_u81F3_u4ECA"><a href="#2011__u5E74_u81F3_u4ECA" class="headerlink" title="2011 年至今"></a>2011 年至今</h3><p><strong>“爱国者之枪”事件&amp;索立德·斯内克刺杀左轮失败2014</strong></p>
<p>为了阻止世界在战争经济中越陷越深，罗伊·坎贝尔再次请斯内克出山，刺杀领导PMC的，貌似已经被利奎德·斯内克彻底侵占意识的左轮山猫（现在被称为利奎德·山猫）。而诞生于魔童计划的斯内克，寿命被设定的极其短暂，此时已经急速衰老，呈现老人的模样，被称为老蛇（Old Snake)。在中东，斯内克和梅丽尔的小队一起行动，找到了山猫，但山猫启动了某种设备，所有体内有纳米机器士兵都陷入癫狂，斯内克本人也无奈倒地，并没有成功地刺杀他。</p>
<p><img src="/images/14576244368025.jpg" alt="Metal Gear Solid 4: Guns of the Patriots"></p>
<p>这部分故事就是 Metal Gear Solid 4: Guns of the Patriots 的剧情，也是 Solid Snake 的最后一个任务，于 2008年6月(PS3) 发售</p>
<p><strong>“爱国者之枪”事件·爱国者AI系统覆灭</strong></p>
<p>之后斯内克来到欧洲，找到了引他来此的伊娃，以及大首领的遗体。然而左轮的军队也追上了伊娃和斯内克，在和左轮部队的追逐战斗中伊娃死去，斯内克重伤，大首领的遗体则焚毁。左轮利用大首领的基因骗过了爱国者的AI网络，夺去了控制全世界武器枪械的“爱国者之子”系统。逃往影子摩西岛偷取了合金装备霸王的核弹头，去毁灭爱国者的中枢AI：JD。在最后的努力中，斯内克和他的战友们进入了左轮的海上基地：“玄武”级战舰，那里承载着被左轮重新利用的GW系统，左轮的阴谋是毁灭JD后，用GW取代JD，从而控制全世界。斯内克破坏了左轮的行动，向GW上传了活狐病毒。“活狐”以GW为跳板，摧毁了所有爱国者AI，世界被从爱国者的统治下解放出来。</p>
<p><strong>大首领死于死狐病毒</strong></p>
<p>SS在任务中遇到了很多熟人，包括给自己植入病毒的Namoi，Roy的女儿Meryl，爱国者的真相，还有在危机时刻舍生救自己的雷电(已被改造为半机械忍者形态)。</p>
<p>在这里简单说一下雷电吧，雷电在结束2代的剧情之后选择和女友Rose一起生活，但是由于雷电作为一个士兵，他无法适应这样和平又幸福的生活，而且他又害怕伤害到Rose，郁闷的雷电只好每日酗酒，再加上Rose说我们的儿子流产了，Rose改嫁Roy离开了雷电，雷电承受不了打击于是重返战场。实际上他们的儿并没有流产，因为雷电引起了爱国者的注意，在他身边不会安全。果然之后爱国者将回到战场的雷电抓了起来同时将它改造成了机械忍者。不甘被爱国者控制的雷电找到机会逃离了爱国者的控制，在路上遇到了Big mama(其实就是MGS3的Eva)，加入了他们的反爱国者组织。</p>
<p>一切结束后，斯内克去拜访引领者的坟墓。当爱国者AI离线后，大首领就从长年的昏迷中醒来。事实上，在欧洲被焚毁的尸体属于索利达斯·斯内克，而左轮被山猫的手侵占意志只是一出戏，目的是不让爱国者发现他真正的目的：唤醒大首领，找出零的位置。在引领者的墓前，大首领切断了垂垂老矣失去意识的零的生命维持设备，一场百年战争就此终结。随后，他和他的儿子——索立德·斯内克度过了一段难得的平静时光。因为和斯内克的接触，大首领感染了死狐病毒，并最终因此结束了生命。</p>
<p><strong>近未来·《合金装备崛起：复仇》时代</strong></p>
<p>其实《崛起》的时间轴是算在正专里面的，但是这是一部彻彻底底的以雷电为主角的动作游戏，所以还是单独挑出来说一下比较好。本作由小岛工作室和合金工作室合作开发，实际上一开始只有小岛工作室在开发，打算这次做一个还是以潜行为核心，但是会更注重战斗场面的游戏;但是之后白金工作室加入把本作核心放在了动作上，虽然变成一个彻头彻尾的动作游戏，但是游戏没有给MGS系列丢人。</p>
<p>主角雷电依然保持着MGS4中的机械忍者形象，而且这一次，玩家要操控他拿起手上的刀，将世界从战争危急中解救出来。游戏中会出现Sunny等一些老人物，同时也会对雷电这个人物做更多的。喜欢帅哥雷电同时又热爱高速爽快战斗的话，本作一定不能错过。
　　</p>
<h2 id="u4F5C_u54C1_u5217_u8868"><a href="#u4F5C_u54C1_u5217_u8868" class="headerlink" title="作品列表"></a>作品列表</h2><p>这里按照剧情时间顺序来介绍，而非作品的序号</p>
<p>《合金装备索利德3：食蛇者》→《合金装备索利德：掌上行动》→《合金装备索利德：和平行者》→《合金装备索利德5：原爆点》→《合金装备索利德5：幻痛》→《合金装备》→《合金装备2 ：索利德斯内克》→《合金装备索利德》→《合金装备索利德2：自由之子》→《合金装备索利德4：爱国者之枪》→《合金装备崛起：复仇》</p>
<ul>
<li>SS: Solid Snake</li>
<li>BB: Big Boss</li>
<li>MG: Metal Gear</li>
</ul>
<p><img src="/images/14576193203131.jpg" alt="系列作品年表"></p>
<p><img src="/images/14576193670265.jpg" alt="作品中的 Snake"></p>
<h3 id="Metal_Gear_SOLID_3_3A_Snake_Eater"><a href="#Metal_Gear_SOLID_3_3A_Snake_Eater" class="headerlink" title="Metal Gear SOLID 3: Snake Eater"></a>Metal Gear SOLID 3: Snake Eater</h3><p>发售日：2004年11月(PS2)/2011年11月(PS3，360版HD)/2012年6月(PSV版HD)</p>
<p>《合金装备》系列剧情的原点——故事的时间在1964年，主人公是一名美国特殊部队Fox Unit的成员，行动代号Naked Snake(裸蛇)。游戏的开场，Snake接到了一个任务——去营救被困在苏联的科学家，这名科学家的发明有着可以引发第三次世界大战的力量。在任务途中，Snake突然被自己的恩师The Boss背叛，Snake被打下山崖，任务自然以失败告终。九死一生的Snake在不久之后接到了新的任务，目的是再次拯救那位科学家，同时干掉背叛国家的The Boss。</p>
<p>最终，Snake与自己的恩师The Boss展开了决战并亲手杀掉了她。在最后我们才知道，The Boss是美国派去苏联的卧底，她的目的是拿到苏联的那份“哲学家的遗产”，但是当时的苏联将军 Volgin(沃尔金)将The Boss带来的核弹头直接在苏联境内发射了(核弹头是美方为了表示诚意以便The Boss成功潜入内部而准备的礼物。)，苏联上层不知情认为是美方所做，美国没有办法只好把锅都甩给TheBoss，决定要将她当作叛徒处理。所以就让Snake去解决掉她。所以The Boss至死都没有背叛过自己的祖国。The Boss在弥留之际说自己希望世界是一个整体而不是东方和西方。之后Snake因为干掉了TheBoss，为国家做出了贡献，被授予Big Boss的称号。</p>
<p>游戏的最后一幕就是成为了Big Boss的Snake在The Boss的无名之墓上敬礼并且留下了眼泪。这一幕在MGS系列乃至整个游戏界中都相当著名。</p>
<p>本作有令人耳目一新的“生存系统”，同时也是游戏的核心系统。玩家可以看到角色的身体状况，吃刚捕获的动物作为充饥的粮食(食物会随着PS2的系统时间的推移而腐化)，玩家需要凭借着自己的实力在森林之中找到食物，而且在中弹之后还需要手动进行包扎止血。游戏还真实的表现出CQC(近身搏斗)技巧，就像是真的潜入作战一样。</p>
<p>而且游戏不仅将“野外生存”这一主题有力地体现出来，游戏中的各种设定也十分有趣。直到现在，可以调整时间来让The End老死的设定依然让玩家津津乐道。</p>
<h3 id="Metal_Gear_SOLID_3A_Portable_Ops_Plus"><a href="#Metal_Gear_SOLID_3A_Portable_Ops_Plus" class="headerlink" title="Metal Gear SOLID: Portable Ops Plus"></a>Metal Gear SOLID: Portable Ops Plus</h3><p>发售时间：2006年12月(PSP)/2007年9月(加强版)</p>
<p>距离3代的故事已经过去了6年。有着Big Boss称号的Snake早已从FOX小队中退役，开始过着训练新兵的生活。可是突然一天Snake等全部和FOX小队有关系的人员都被逮捕。原来FOX小队的指挥官Gene叛变了，Gene意图建立Army’s Heaven——这个只属于军人的国家，以打破世界的军事平衡。Big Boss在追击Gene的途中将很多人纳为了自己的同伴，比如NULL，Elisa和Johnthan等，同时这些人成立了猎狐犬小队，开始对FOX部队进行反击。最终BB干掉了Metal Gear之后打倒了Gene。Gene在死前将手头上的所有资金设备全部交给了BB，并且声称BB以后一定会用到这笔资源。</p>
<p>作为PSP上第一款MGS作品，掌上行动已经很努力的将《合金装备》的精髓玩法带给了大家，而且大胆尝试了很多新的要素比如联机模式，招募伙伴。但是由于是第一次登陆掌机，各方面还不成熟，所以本作的实际游玩体验会打一些折扣，但是并不怎么影响掌上行动的素质，Fami也给出了39分的高分。虽然小岛没有把本作放在正传列表中，但是BB在故事中遇到的人和事其实都对之后的事件埋下了一些伏笔，所以说这款黑历史之中的《掌上行动》还是值得一玩的。</p>
<h3 id="Metal_Gear_SOLID_3A_Peace_Walker"><a href="#Metal_Gear_SOLID_3A_Peace_Walker" class="headerlink" title="Metal Gear SOLID: Peace Walker"></a>Metal Gear SOLID: Peace Walker</h3><p>发售时间：2010年4月(PSP)/2011年11月(PS3,360版HD)</p>
<p>不逊色于主机作品的掌机续作——这次故事发生在1974年，这时冷战时期也进入到了末期，形势看似和平，但是在哥斯达黎加，却遭受到了不明军队的袭击，可这里有着和平宪法的保护无法出动任何部队反击。这时在哥斯达黎加和平大学的女学生Paz和她的教授Galevz选择了请求“无国界军队”帮助，而这个部队正是由Big Boss所指挥。而且教授还给Big Boss了一份酷似The Boss声音的录音带，这让Big Boss没有理由拒绝这份委托。然而随着故事的进行，阴谋逐渐浮出水面，代号为Peace Walker的二足步行兵器(MG)已经开发完成并且加上了The Boss的AI，而Paz竟然是“CIPHER”的间谍，而且要毁灭BB全部的军队，最后经过一番苦战终于打败了Paz，Paz也坠入了大海。</p>
<p>FAMI通的满分作品，也是PSP平台非常少见的满分。在吸取了前作《掌上行动》的缺点之后，这次《和平行者》在画面，剧情和游戏性上堪称集大成之作。游戏保留了之前的漫画过场，联机与招募同伴的要素，而且在剧情上为了承上启下大下功夫，可以算是MGS的转折点。同时场景也丰富了很多，再加上成熟的动作与有趣的联动要素（比如和猎人的联动会让蛇叔和轰龙对决）使得本作算是PSP 平台不可多得的佳作。</p>
<h3 id="Metal_Gear_SOLID_V_3A_Ground_Zeros"><a href="#Metal_Gear_SOLID_V_3A_Ground_Zeros" class="headerlink" title="Metal Gear SOLID V: Ground Zeros"></a>Metal Gear SOLID V: Ground Zeros</h3><p>发售日：2014年3月20日(PS3,PS4,XBOX360,XBOXONE)，2014年12月18日(PC)</p>
<p>次世代的第一款MGS——故事发生在上一作《和平行者》事件结束的一段时间之后，依旧在无国界军队执行任务的Big Boss突然收到了消息称Paz没有死，而且偷偷去营救她的Chico也被一个组织抓住了，于是BB必须前去营救他们。但是同时，Huey单方面的同意了一个世界核组织对基地的检查，这就直接引出了开篇的一幕，一个称作Skull Face(骷髅脸)的角色率领了一个叫做XOF(FOX小队的对立面)小队，抓走Paz和Chico，随后他们撕下自己的XOF徽章伪装成世界核组织前去“检查”BB的基地。之后虽然BB成功的解救出了Paz和Chico但是却发现自己的基地已经被毁灭了，Paz也称自己体内还有炸弹于是自己跳下飞机爆炸，BB受重伤昏迷，无国界军队被XOF小队几乎全灭。等到BB苏醒之后，他要去复仇，找到毁灭自己基地的人究竟是谁，Huey等人为什么要背叛自己，只有接下来的《幻痛》能告诉我们真相了。</p>
<p>作为次世代的第一款MGS，《原爆点》只能算是一个《合金装备索利德5》的序章，但是本作的画面等细节方面非常出众，而且也包含了很多额外任务与彩蛋，为了迎接之后的《幻痛》，《原爆点》没有理由不去将它通关一次。</p>
<h3 id="Metal_Gear_SOLID_V_3A_Phantom_Pain"><a href="#Metal_Gear_SOLID_V_3A_Phantom_Pain" class="headerlink" title="Metal Gear SOLID V: Phantom Pain"></a>Metal Gear SOLID V: Phantom Pain</h3><p>故事发生在1984年，此时的游戏中和现实一样也在进行着阿富汗战争。尽管游戏大体和现实相同，但是玩家可以发现游戏内的武器和科技要远远比现实中的冷战时期先进。不光是“合金装备”本身，其他军事技术诸如外骨骼、双足机甲、光学隐形、全息影像都被各国谍报机关所使用着。其他科学技术诸如纳米技术、克隆、人工智能也进入了实用化的阶段。玩家还可以在游戏中发现一些陌生却又熟悉的枪械，例如类似AK74突击步枪的SVG-76突击步枪。而性能相对于现实有些夸张、但却让老玩家怀念的“富尔顿地对空回收系统”也重回作品并在游戏内扮演着举足轻重的角色。</p>
<p>同时，游戏还包含制作人小岛秀夫惯有的幽默气息。比如主角Big Boss可以使用的装备中有被称为“终极隐蔽科技”的道具纸箱子。玩家可以藏在纸箱子里进行移动，并突然钻出纸箱子用消音麻醉手枪击倒敌人。</p>
<p>在一手建立的佣兵组织“无界之师”（Militaires Sans Frontières）于《原爆点》结尾被摧毁后，主角大首领（Big Boss）也陷入了长达九年的昏迷。醒来后，世界发生了翻天覆地的变化，而他重新建立了佣兵组织“钻石狗”（Diamond Dogs）。在名为“毒蛇”（Venom Snake）的代号下，他重新卷入了位于阿富汗的苏联入侵行动中，目的是寻找要为袭击“无界之师”事件而负责的罪人。为了达成复仇，他重新召集了他的劲敌“山猫”（Ocelot）并与一批忠诚的战士们相遇，谱写新的历程。他与米勒（Kazuhira Miller）在复仇的过程中发现了名为“密码”（Cipher）的组织正在开发一款甚至可以超越合金装备的武器，而Big Boss的任务也迅速转变为消灭新的威胁。</p>
<p>毒蛇是本作的主角，玩家主要扮演他来进行任务。通常被称为“大首领”（Big Boss），而“毒蛇”（Venom Snake）是他行动的代号，被视为传奇。他本是“无国界之军”的一名医疗兵，在母基地遭受袭击，PAZ体内的第二颗炸弹爆炸（详情请看后面的PAZ介绍），他挡在了Big Boss前面（这就是为什么Venom Snake身体内有那么多人体碎片而BIGBOSS没有），之后陷入了长达九年的昏迷。苏醒后代替下落不明的大首领（naked snake）组建“钻石狗”，并成为领袖。率部深入阿富汗和非洲，在阿富汗战争中寻找摧毁了“无界之师”要塞的罪人并予以复仇。</p>
<h3 id="Metal_Gear"><a href="#Metal_Gear" class="headerlink" title="Metal Gear"></a>Metal Gear</h3><p>发售日：1987年(MSX2/FC)</p>
<p>包受争议的初代作品——剧情是在1995年左右，Big Boss已经建立了猎狐犬组织，这时突然得知在南非，出现了一个叫做“Outer Heaven”(世外天堂)的要塞国家，并且有消息传出这个国家在生产大杀器——Metal Gear 。于是Big Boss派出手下的一名新兵前去侦查这个国家并且营救之前去侦查结果失去联系的Grey Fox，这个人就是我们之后系列的主角Solid Snake。但是当SS不断深入之后发现Big Boss给自己的通信越来越奇怪，时常将自己引到陷阱之中。原来这个世外天堂的建立者就是自己的上司Big Boss。最终SS摧毁了整个基地，粉碎了Big Boss的野心。</p>
<p><img src="/images/14576254881646.jpg" alt="Metal Gear"></p>
<p>作为全系列的第一部作品，游戏本身的素质堪称上乘，潜入式的玩法在当时给人耳目一新的感觉，但由于MSX2平台只在日本地区发售的原因，本作并未在全球范围内引起热潮放在那个时代本身素质还算过得去，丰富的道具和有趣的游戏模式也算能让人玩的下去，但是这作而由于当时KONAMI错误的市场估计，所以之后在美国并未发行MSX2的初代合金装备(很大一部分原因是因为MSX2主机根本没有在日本以外的地区发售。)，更加糟糕的是，KONAMI在没有令小岛秀夫参与制作的情况下，单方面让美国分部在NES上发行所谓的FC版，而美国的小组则自作主张将游戏内容进行改编，反而使得游戏丧失了原版的精髓，最终BOSS也由Metal Gear变为了庸俗的所谓“控制MG的电脑”。小岛秀夫已经认定FC版的合金装备并非正统，甚至认为就是一款彻头彻尾的垃圾作品。所以本作的争议很大，这也直接导致小岛要出一个为自己正名的续作。</p>
<h3 id="Metal_Gear_2_3A_Solid_Snake"><a href="#Metal_Gear_2_3A_Solid_Snake" class="headerlink" title="Metal Gear 2: Solid Snake"></a>Metal Gear 2: Solid Snake</h3><p>发售日：1990年(MSX2平台)</p>
<p>Solid Snake与Big Boss的决战——故事发生在上作的4年后，Zanzibarland(桑给巴尔岛)上的一个军事政府突然突击了各国的核武器安放库，由于核平等条约的束缚，这个国家反倒成为了唯一可以使用核武器的国家，对世界造成了巨大威胁。这时解决了Outer Heaven危机的SS临危受命，前往这个小岛解救被绑架的Marv博士，这位博士发现了一个可以精炼石油的微生物，所以他对这个小岛统治全球的计划是关键性的人物，SS需要把世界从危急之中解救出来。</p>
<p><img src="/images/14576255533327.jpg" alt="Metal Gear 2：SOLID SNAKE"></p>
<p>在任务的最后，我们会遇到我们的熟人Big Boss，最终决战自然是以Big Boss战败收尾，而Big Boss也结束了他传奇的一生。SS也到阿拉斯加隐居起来，不再参与战事。值得一提的本作实际是只有日版，美版自己做了一款叫做《斯内克的复仇》的游戏，模式是类似于魂斗罗的横版射击，小岛自然无法认同这部被“糟蹋”的作品，再加上本作由于MSX2只有日版，所以《斯内克的复仇》压根没有在日本发售。</p>
<p><img src="/images/14576256407693.jpg" alt="Metal Gear 2：SOLID SNAKE"></p>
<h3 id="Metal_Gear_SOLID"><a href="#Metal_Gear_SOLID" class="headerlink" title="Metal Gear SOLID"></a>Metal Gear SOLID</h3><p>发售日：1998年(PS)/1999年(PS平台加强版)/2000(PC平台)</p>
<p>Solid Snake身世的首次揭开——时间已经到了20世纪，SS已在阿拉斯加隐居很久，但是突然有个部队占领了一个阿拉斯加的军事基地，并且抢到了正在做演习的Metal Gear Rex，而这个部队正是SS之前所在的猎狐犬小队，这次叛变也就被成为“影子摩西岛事件”。猎狐犬小队仗着自己拥有可以发射核武器的Metal Gear，向美国索要大量金钱，更重要的是他们还要Big Boss的遗体。当时在掌上行动中出现的ROY上校亲自请求SS出马，拯救被猎狐犬绑架的人质，解决这次危机。但是在SS在执行任务的途中，他发现自己要拯救的人质在看到他之后都会莫名其妙的突发心脏病死亡，而且还遇到了不少关系到SS命运的家伙，比如Ocelot(山猫，在与SS决斗的时候被NULL砍掉了一个手臂)，Meryl(ROY上校的侄女，不过实际上是女儿)，NULL(掌上行动时的忍者，也就是灰狐gray fox)，Otacon(MG Rex的设计师)。</p>
<p>最终我们遇到了实施整个事件的头目，他就是Liquid Snake。这个和SS拥有一样长相的人告诉了SS他们的身世：其实他们都是一个叫做魔童计划(Les Enfants Terribles/恐るべき子供达计划) 的产物，这个计划就是利用Big Boss的基因，制造出很多像BB一样伟大的战士，两个人都是克隆体，其实是兄弟。</p>
<p>但是Liquid说自己是继承了的是劣质基因，SS继承了优质基因，由于痛恨自己的基因不足必须干掉SS，而且还要超过Big Boss——重建世外天堂。不过最终Liquid还是败在了SS的手下，但是在最后时刻SS在一场汽车追逐战中翻了车，动弹不得，Liquid拿着枪走了过来却在准备开枪之时突然心脏病突发死亡。SS总归还是完美完成了任务。</p>
<p>实际上，Liquid率领的猎狐犬小队叛乱并不是他一个人的计划，而是在山猫和美国总统Solidus Snake的怂恿下进行的。而Solidus Snake则是BB的完美克隆体。而任务中的那些突发心脏病死亡的人其实是受到SS身上一种叫做死狐病毒(fox die)的影响，这种病毒可以直接引起一些特定基因的人死亡。这个病毒是一个叫Naomi的医学家在SS不知情的情况下为它注射的，Naomi是Gray Fox的妹妹，他知道以为自己的哥哥是被SS所杀所以想利用这个病毒杀掉SS复仇，但是由于期间和SS接触久了之后发现其实自己的哥哥并不恨SS，自己也知道SS当时也不迫不得已，但是由于已经注射了病毒，只好将死狐病毒的发作时间改成了随机发作(实际上一直到4代中才有些发作的体现。)</p>
<p>最后讽刺的是Liquid Snake实际上是优质基因的继承者，他的实力完全是在SS之上，但是最后的失败也正式MGS1想告诉玩家的主题——永远不要被命运或者基因所束缚。</p>
<p>《MGS1》开创3D潜入的先河，同时也率先引领了电影化叙事的潮流，而且剧情全部都是即时演算，这在当时大量依靠文字或者图片叙事的游戏之中，MGS这种表现手法实在让人眼前一亮。而且距离上一作距离8年之久，这样一个回归是非常令人震撼的，成功的为MGS在这个时代的平台树立起自己的招牌。</p>
<h3 id="Metal_Gear_SOLID_2_3A_Sons_Of_Liberty"><a href="#Metal_Gear_SOLID_2_3A_Sons_Of_Liberty" class="headerlink" title="Metal Gear SOLID 2: Sons Of Liberty"></a>Metal Gear SOLID 2: Sons Of Liberty</h3><p>发售日：2001年11月(PS2)/2011年11月(PS3，360版HD)/2012年6月(PSV版HD)</p>
<p>新主角雷电的初次登场——MGS2的故事大致可以分成前轮篇和Big Shell篇。</p>
<p><strong>油轮篇</strong></p>
<p>发生在MGS1结束后的2年，山猫夺取了MG的数据并且在黑市上兜售，这导致很多国家都可以制造出MG这种危险兵器。SS便和Otacon一起成立了一个反MG的组织——Philanthropy(慈善事业)，两人开始四处摧毁被制造出来的MG。突然他们得到消息，称纽约附近的油轮上有新型的两栖用MG，于是SS立即前去准备破坏它。但是在到达油轮底层之后发现了其实这一切都是山猫在捣鬼，他假装和其他国家的军官合作但最终的目的是为了夺取新型MG。当SS和山猫对峙的时候山猫右臂抽搐然后仿佛换了个人似的说：“好久不见了，兄弟。”原来当初山猫被砍掉右臂之后又移植了Liquid Snake的胳膊，所以Liquid Snake有时就会控制山猫的心智。之后山猫恢复了意识，驾驶MG破坏了游轮后逃走，并且在网上大肆散布SS在游轮上的照片，让大众将SS视作了恐怖分子，同时油轮篇的故事到这里为止了。<br>　　<br><strong>Big Shell篇</strong></p>
<p>雷电在执行这次任务之前也仅仅是一个新兵菜鸟。而这一次他的任务就是去海洋设施拯救人质(《MGS》非常喜欢用解救人质开头)。还记得之前油轮篇的油轮吗?山猫在将它破坏之后石油散落在大海之中，于是建立了一个海洋净化设施Big Shell，而这里明显不单单是一个环保设施。果然，雷电在执行任务的途中遇到了SS和Otacon等人，同时也知道了这个设施其实下面隐藏着一台由爱国者控制的超级数字战舰，而这一切都是由前任美国总统Solidus Snake，现在的恐怖组织头目所策划的，他自称Sons of Liberty(自由之子)，还绑架了即将当选的下任总统，而且Solidus Snake也是雷电的养父，是他将小时候的雷电从战场中捡了回来。<br>　　<br>当剧情进行到全部人员都汇集到超级战舰之上的时候，山猫终于说出了自己的目的：原来这一切都是爱国者计划好的，故事中的一切的事件都与影子摩西事件一模一样，都是为了重现当年的事件（详细可以查看S3计划）。随后山猫进入了Metal Gear Ray的驾驶舱，跳进了大海，SS也随即跳入海中，战舰上只留雷电和Solidus Snake两人。最终战舰撞向了美国纽约，最后在国家纪念堂前才停了下来。</p>
<p>这时Solidus Snake 也说明了自己做这一切的目的：他做的这一切都是为了摆脱爱国者的控制，现在爱国者过于强大了，我们全部的行为都会受到爱国者的保护，但是这样一来我们自己能为后代留下什么遗产?!一般人类还可以通过基因流传，而他和SS等克隆人没有生育的能力，他们最终只会被历史遗忘，他要做的就是永远的被历史所铭记，要战胜爱国者，解放人类，成为“自由之子”。之后雷电接到通信，通信中说明了爱国者现在的状态：爱国者现在其实是一个为了生命数字化而制造的超级电脑，如今人类身上都植入了纳米机器人用来治病或者强化身体，而爱国者正是通过这个机器人收集人类的信息，于是为了人类的未来，他会主动过滤掉一些无用的信息，从而慢慢控制人类的思想，感情。而这整个的事件，不过就是爱国者的试验罢了。<br>　　<br>最终，雷电和Solidus Snake的决战在所难免，雷电靠自己高超的剑术击败了Solidus Snake，Solidus Snake掉下房顶死亡。最终雷电打算加入SS寻找爱国者的所在，但是SS却说还有更重要的事在等着你，原来自己的女友Rose早已在后面等他。</p>
<p>跨入PS2时代的《MGS2》带不仅仅在画面上有了突破，更是正式加入了第一人称的射击视角(其实在MGS1代完全版中，只要你通关一遍即可开启第一人称视角。)，而且本作还有很多有趣的故事，比如用雷电裸奔的剧情，现在也时常会被玩家拿出来开玩笑。<br>　　<br>值得一提的是小岛在游戏发售之前没有任何一次提到过会换主角，宣传视频也一直就是蛇叔，但是当玩家拿到手上玩到雷电的时候，小岛承认是自己骗了大家，希望大家能自己感受到换主角那种惊喜。这款游戏还有一个小插曲，2001年在游戏宣传的时候提到过最后战舰冲向纽约破坏了一群建筑的剧情，其中就是纽约世贸大楼，但是就在之后9.11发生了，为了避免这一个敏感问题小岛只好直接剪掉了那一段动画，剧情也就变成了战舰冲向纽约之后直接切入最终战的样子。</p>
<h3 id="Metal_Gear_SOLID_4_3A_Guns_of_the_Patriots"><a href="#Metal_Gear_SOLID_4_3A_Guns_of_the_Patriots" class="headerlink" title="Metal Gear SOLID 4: Guns of the Patriots"></a>Metal Gear SOLID 4: Guns of the Patriots</h3><p>发售日：2008年6月(PS3)</p>
<p>老蛇的最后一个任务——故事发生在2014年，在这期间，上次驾驶MG逃走的山猫成立了全球级别的专业的佣兵部队PMC，同时将称为“SOP”(爱国者之子)系统的纳米机器人全部植入PMC之中，包括人和武器，而这个系统目的就是控制士兵情绪，达成降低战争成本的目的。而且山猫这时已经被称为Liquid Ocelot，拥有大量MG，这一切都需要让这位已经略显老态的传奇战士再次出马了。</p>
<p><img src="/images/14576260972014.jpg" alt="Metal Gear Solid 4: Guns of the Patriots"></p>
<p>SS在任务中遇到了很多熟人，包括给自己植入病毒的Namoi，Roy的女儿Meryl，爱国者的真相，还有在危机时刻舍生救自己的雷电。当然，最后我们面对的还是我们的老朋友——山猫。从山猫口中，我们得知其实Liquid并没有控制自己，或者说之前的双重人格都是山猫为了破坏爱国者而演出来的。因为爱国者早已控制了几乎整个世界，所以想骗过爱国者给它植入病毒那就必须先骗过自己，于是通过药物和心理暗示让自己成为Liquid。最终目的达到了，他成功的给爱国者的AI植入了FOXLIVE病毒使爱国者全部崩溃，解放了整个世界。但是最终，我们和山猫那持续了几十年的恩怨，也要在今天划上一个句号。</p>
<p>打败了山猫之后，SS来到了The Boss的墓地，拿出手枪准备了结自己，但在这个时候，我们看到了通过手术复活的Big Boss和已经成为植物人的Zero(爱国者的建立者，BB之前的同伴)，BB对SS说：“我们之前为了The Boss的理想做了那么多事，如今我们时代已经过去了，你一定要活下去。我从来没有把你当作儿子来看待，我一直看作你是一个伟大的战士，我认为即使当时是你面对着The Boss ，你也能扣下扳机。”，之后他拔掉了Zero的氧气管，走进SS自己主动感染他的死狐病毒。SS在帮BB点完一根雪茄之后，选择了坚强活下去，最终和Otacon一起出门旅游，蛇叔的传奇一生也到此为止了。</p>
<p>本作在科学的支持下蛇叔可以使用光学迷彩从而做到像变色龙一样的隐藏在周围的环境之中，带给玩家全新的体验。不过这次最强大的地方就是小岛把这部老蛇的最终作狠狠的玩了一把情怀，特别是当剧情进行到重回影子摩西岛，看到MGS1的故事地点在PS3上再现的时候，系类玩家都会为之感动。而且在最终和山猫决战时，好几个阶段的UI也是从1到4逐渐的变化，不得不说小岛这次真的是把情怀牌打到了极致。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.gamersky.com/handbook/201511/680245.shtml" target="_blank" rel="external">《合金装备》系列历史剧情 合金装备全系列历史剧情揭秘</a></li>
<li><a href="http://www.gamersky.com/handbook/201508/657226.shtml" target="_blank" rel="external">《合金装备》全系列回顾 合金装备全系列剧情回顾及人物介绍</a></li>
<li><a href="/"></a></li>
<li></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果说这个世界上有第二个系列像 EVA 一样让我如痴如醉的话，那么肯定是 MGS 系列。在玩『潜龙谍影5：幻痛』的时候，每一段磁带（包含大量重要剧情信息）都认真听过之后，对于整个系列的剧情有了大概的认知。这篇文章会比较长，综合了网上的各种资料和我自己的理解，希望能给大家带来一个比较完整的阅读体验。</p>]]>
    
    </summary>
    
      <category term="BigBOSS" scheme="http://wdxtub.com/tags/BigBOSS/"/>
    
      <category term="Quiet" scheme="http://wdxtub.com/tags/Quiet/"/>
    
      <category term="Snake" scheme="http://wdxtub.com/tags/Snake/"/>
    
      <category term="合金装备" scheme="http://wdxtub.com/tags/%E5%90%88%E9%87%91%E8%A3%85%E5%A4%87/"/>
    
      <category term="幻痛" scheme="http://wdxtub.com/tags/%E5%B9%BB%E7%97%9B/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 Twitter 语料分析 5 ETL 导入数据]]></title>
    <link href="http://wdxtub.com/2016/03/09/cc-p5/"/>
    <id>http://wdxtub.com/2016/03/09/cc-p5/</id>
    <published>2016-03-10T03:33:12.000Z</published>
    <updated>2016-03-10T04:00:37.000Z</updated>
    <content type="html"><![CDATA[<p>这一次我们需要利用 Map Reduce 处理大约 1T 的 Twitter 数据，并导入到对应的数据库中，这一部分因为奇奇怪怪的情况很多，所以一定要注意。</p>
<a id="more"></a>
<hr>
<h2 id="u6570_u636E_u5904_u7406"><a href="#u6570_u636E_u5904_u7406" class="headerlink" title="数据处理"></a>数据处理</h2><p><a href="http://s3.amazonaws.com/cmucc-datasets/twitter/s16/part-00000" target="_blank" rel="external">http://s3.amazonaws.com/cmucc-datasets/twitter/s16/part-00000</a></p>
<p>head -n 100 part-00000 &gt; data100<br>head -n 1000 part-00000 &gt; data1K<br>head -n 10000 part-00000 &gt; data10K</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/AmazonS3.html" target="_blank" rel="external">Amazon Simple Storage Service (Amazon S3)</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一次我们需要利用 Map Reduce 处理大约 1T 的 Twitter 数据，并导入到对应的数据库中，这一部分因为奇奇怪怪的情况很多，所以一定要注意。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="EMR" scheme="http://wdxtub.com/tags/EMR/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="服务" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 Twitter 语料分析 4 Heartbeat 与 Authetication]]></title>
    <link href="http://wdxtub.com/2016/03/08/cc-p4/"/>
    <id>http://wdxtub.com/2016/03/08/cc-p4/</id>
    <published>2016-03-09T01:44:19.000Z</published>
    <updated>2016-03-09T04:37:59.000Z</updated>
    <content type="html"><![CDATA[<p>前面两课我们已经配置好了基本的环境，之后的任务都会在前面的基础上完成。因为主要会使用 undertow，所以我们制作了自己的镜像，用于对比的 vertx 则仍旧会以手动的方式进行配置。</p>
<a id="more"></a>
<hr>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>因为没有制作对应的镜像，所以需要重新配置一次，不过这次为了性能考虑，直接开启一个 <code>m4.large</code>，注意需要打上 <code>15619project:phase1</code> 标签。正常开启（记得要用小组的帐号）之后我们用<a href="http://wdxtub.com/2016/03/01/cc-p3/">Vert.x 配置部署</a>的步骤配置好基本的环境并检测运行，确认无误后可以继续。</p>
<p>这一部分的任务比较简单：每个请求都包含 key <code>Y</code> 和一段由 key <code>Z</code> 加密的文本，我们进行解密之后返回指定格式的内容（具体可以参考<a href="http://wdxtub.com/2016/02/25/cc-p1/#Query_1__28Heartbeat_and_Authentication_29">这里</a>）</p>
<h2 id="u9879_u76EE_u65E5_u5FD7"><a href="#u9879_u76EE_u65E5_u5FD7" class="headerlink" title="项目日志"></a>项目日志</h2><p>大概说一下步骤以及需要注意的地方：</p>
<p>要弄清楚 vert.x 如何处理诸如 <code>address/q1?key=40845969093821&amp;message=URYEXYBJB</code> 的请求，并在代码中获取到这两个参数：</p>
<p><img src="/images/14574935033615.jpg" alt="获取参数"></p>
<p>然后需要生成一个时间戳，并按照<a href="http://wdxtub.com/2016/02/25/cc-p1/#Query_1__28Heartbeat_and_Authentication_29">这里</a> 介绍的解密步骤还原出具体信息。</p>
<p>我们组把这部分功能代码封装成了一个类，使用的时候只需要传入 key 和 message 即可，而不用操心具体的算法问题（其实就类似于一个面试的算法题）。</p>
<p>然后我们按照具体的返回格式返回即可，类似下图</p>
<p><img src="/images/14574936621579.jpg" alt="返回结果"></p>
<p>这里有一点需要注意，每次会发送两次 GET 请求（其中一次是请求 favicon 的），要注意做一下错误处理，不然会报错，这还挺奇怪的，我用 safari 就没事，但是用 chrome 就不行，chrome 第二次请求就不带参数了，但是 safari 会带。</p>
<p>后来这个问题改成 80 端口即可，不过需要先 <code>sudo su</code> 才能监听。</p>
<p>因为这部分只是用来对比评测，所以没有进一步优化，大概能跑到 2W RPS 左右，而且是纯单线程，延迟会比较大，不过之后主要会在 undertow 上做，所以这里就不进一步优化了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面两课我们已经配置好了基本的环境，之后的任务都会在前面的基础上完成。因为主要会使用 undertow，所以我们制作了自己的镜像，用于对比的 vertx 则仍旧会以手动的方式进行配置。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Vertx" scheme="http://wdxtub.com/tags/Vertx/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="服务" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 习题课 5 Shelllab]]></title>
    <link href="http://wdxtub.com/2016/03/08/csapp-lab5/"/>
    <id>http://wdxtub.com/2016/03/08/csapp-lab5/</id>
    <published>2016-03-08T18:47:44.000Z</published>
    <updated>2016-03-10T00:41:08.000Z</updated>
    <content type="html"><![CDATA[<p>这次的作业，我们需要自己完成一个简单的 shell 程序，通过具体的实现，我们可以更加深入地计算机运行的机制（尤其是 Exceptional Control Flow 和进程）。</p>
<a id="more"></a>
<hr>
<p>在具体开始这次的试验之前，最好先复习一下基本概念（具体的细节可以参考前面的几课），这里放在文末的附录中。</p>
<p>这次的任务不简单！但是老师提供了很多辅助函数，确定先读懂已有代码再开始（注意代码风格），需要仔细查看的 man pages：</p>
<ul>
<li><code>sigemptyset()</code></li>
<li><code>sigaddset()</code></li>
<li><code>sigprocmask()</code></li>
<li><code>sigsuspend()</code></li>
<li><code>waitpid()</code></li>
<li><code>open()</code></li>
<li><code>dup2()</code></li>
<li><code>setpgid()</code></li>
<li><code>kill()</code></li>
</ul>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>先把文件上传到学校的机器中 <code>scp tshlab-handout.tar dawang@shark.ics.cs.cmu.edu:~/513</code>，然后登录上去 <code>ssh -X dawang@shark.ics.cs.cmu.edu</code>，登录成功后解压 <code>tar xvf tshlab-handout.tar</code></p>
<p>因为我比较习惯在本地写代码，所以把文件复制回来：</p>
<ul>
<li>服务器至本地<ul>
<li><code>scp -r dawang@shark.ics.cs.cmu.edu:~/513/tshlab-handout/* ./</code></li>
</ul>
</li>
<li>本地至服务器<ul>
<li><code>scp ./tsh.c dawang@shark.ics.cs.cmu.edu:~/513/tshlab-handout/</code></li>
</ul>
</li>
</ul>
<p>然后需要在 <code>tsh.c</code> 中填写 Andrew ID，这个文件中已经包含了一个基本的 shell 程序，但是还有很多东西没有完成，我们的任务是补全下列空函数：</p>
<ul>
<li><code>void eval(char *cmdline)</code>：解析命令与执行，约 300 行</li>
<li><code>void sigchld_handler(int sig)</code>：捕获 SIGCHLD 信号</li>
<li><code>void sigtstp_handler(int sig)</code>：捕获 SIGTSTP(ctrl-z) 信号</li>
<li><code>void sigint_handler(int sig)</code>：捕获 SIGINT(ctrl-c) 信号</li>
</ul>
<p>测试的时候先 <code>make</code> 然后 <code>./tsh</code> 即可，不过一开始好像没办法退出</p>
<h2 id="Shell__u7B80_u4ECB"><a href="#Shell__u7B80_u4ECB" class="headerlink" title="Shell 简介"></a>Shell 简介</h2><p>简单来说，shell 有两种执行模式：</p>
<ol>
<li>如果用户输入的命令是内置命令，那么 shell 会直接在当前进程执行（例如 <code>jobs</code>）</li>
<li>如果用户输入的是一个可执行程序的路径，那么 shell 会 fork 出一个新进程，并且在这个子进程中执行该程序（例如 <code>/bin/ls -l -d</code>）</li>
</ol>
<p>第二种情况中，每个子进程称为一个 job（当然也可以不止一个，通过管道机制，不过我们这里的实现不需要考虑管道）</p>
<p>如果命令以 <code>&amp;</code> 结束，那么这个 job 会在后台执行（比如 <code>/bin/ls -l -d &amp;</code>），也就是说 shell 本身不会等待 job 执行完成，直接可以继续输入其他命令；而在其他情况下，则是在前台运行，shell 会等待 job 完成，用户才可以继续输入命令。也就是说同一个时间只可能有一个前台任务，但是后台任务可以有任意多个。</p>
<p>程序的入口是 <code>int main(int argc, char *argv[])</code>，对于 <code>/bin/ls -l -d</code> 来说，我们有：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">argc</span> == <span class="number">3</span></span><br><span class="line"><span class="built_in">argv</span>[<span class="number">0</span>] == <span class="string">''</span>/bin/<span class="keyword">ls</span><span class="string">''</span></span><br><span class="line"><span class="built_in">argv</span>[<span class="number">1</span>] == <span class="string">''</span>-<span class="keyword">l</span><span class="string">''</span></span><br><span class="line"><span class="built_in">argv</span>[<span class="number">2</span>] == <span class="string">''</span>-<span class="keyword">d</span><span class="string">''</span></span><br></pre></td></tr></table></figure>
<p>另外两个需要支持功能是：</p>
<ul>
<li>job control：允许用户更改进程的前台/后台状态以及京城的状态(running, stopped, or terminated)<ul>
<li>ctrl-c 会触发 SIGINT 信号并发送给每个前台进程，默认的动作是终止该进程</li>
<li>ctrl-z 会触发 SIGTSTP 信号并发送给每个前台进程，默认的动作是挂起该进程，直到再收到 SIGCONT 信号才继续</li>
<li><code>jobs</code> 命令会列出正在执行和被挂起的后台任务</li>
<li><code>bg job</code> 命令可以让一个被挂起的后台任务继续执行</li>
<li><code>fg job</code> 命令可以让一个被挂起的前台任务继续执行</li>
</ul>
</li>
<li>I/O redirection：重定向输入输出<ul>
<li><code>tsh&gt; /bin/ls &gt; foo</code></li>
<li><code>tsh&gt; /bin/cat &lt; foo</code></li>
</ul>
</li>
</ul>
<h2 id="u4EFB_u52A1_u76EE_u6807"><a href="#u4EFB_u52A1_u76EE_u6807" class="headerlink" title="任务目标"></a>任务目标</h2><p>我们正在使用的 shell 其实包含很多复杂的功能，不过我们自己写的 shell 就简单很多，这里总结一下具体的实现规格：</p>
<ul>
<li>每一行会输出一个 <code>tsh&gt;</code>，然后等待用户输入</li>
<li>用户的输入包括 <code>name</code> 加上零个或多个参数，这些参数之间用一个或多个空格分隔。如果 <code>name</code> 是内置命令，那么直接执行，否则需要新建一个子进程，并在子进程中完成具体的工作</li>
<li>不需要支持管道，但是需要支持输入输出重定向，如 <code>tsh&gt; /bin/cat &lt; foo &gt; bar</code>（必须支持在同一行重定向输入以及输出）<ul>
<li>也需要支持内置命令的重定向，如 <code>tsh&gt; jobs &gt; foo</code> </li>
</ul>
</li>
<li>输入 <code>ctrl-c</code> 或 <code>ctrl-z</code> 会给当前的前台进程（包括其子进程）发送 SIGINT(SIGTSTP) 信号，如果没有前台任务，那么这俩信号没有任何效果</li>
<li>如果输入的命令以 <code>&amp;</code> 结尾，那么就要以后台任务的方式执行，否则按照前台执行</li>
<li>每个 job 都有其进程 ID(PID) 和 job ID(JID)，都是由 tsh 指定的正整数，JID 以 <code>%</code> 开头（如 <code>%5</code> 表示 JID 为 5，而 <code>5</code> 则表示 PID 为 5），这部分已提供了辅助函数</li>
<li>支持的内置命令有<ul>
<li><code>quit</code> 退出 shell</li>
<li><code>jobs</code> 列出所有的后台任务</li>
<li><code>bg job</code> 给后台 <code>job</code> 发送 SIGCONT 信号来继续执行该任务，具体的 <code>job</code> 数值可以是 PID 或 JID</li>
<li><code>fg job</code> 给前台 <code>job</code> 发送 SIGCONT 信号来继续执行该任务，具体的 <code>job</code> 数值可以是 PID 或 JID</li>
</ul>
</li>
<li>tsh 应该回收所有的僵尸进程，如果任何 job 因为接收了没有 catch 的信号而终止，tsh 应该识别出这个时间并且打印出 JID 和相关信号的信息</li>
</ul>
<h2 id="u6D4B_u8BD5_u65B9_u6CD5"><a href="#u6D4B_u8BD5_u65B9_u6CD5" class="headerlink" title="测试方法"></a>测试方法</h2><p>最简单（也是首先应该做的）是直接运行 tsh，然后输入命令试试看。如果需要参考，可以试试 <code>tshref</code> 这个程序。确定无误之后可以进行完整测试。</p>
<p>这里我们用 trace 文件来测试，具体使用命令 <code>./runtrace</code> 来测试，具体用法如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">./runtrace -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试某个特性</span></span><br><span class="line">./runtrace <span class="operator">-f</span> trace05.txt <span class="operator">-s</span> ./tsh</span><br></pre></td></tr></table></figure>
<p>如果想要进行完整的测试，可以使用 <code>./sdriver</code>，具体用法如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">./sdriver -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般来说可以直接使用默认设置测试</span></span><br><span class="line">./sdriver</span><br></pre></td></tr></table></figure>
<p>只需要提交 <code>tsh.c</code> 即可，系统会自动评分，具体每个文件在测试的内容是：</p>
<p><img src="/images/14575490108688.jpg" alt="trace 文件内容"></p>
<h2 id="u63D0_u793A"><a href="#u63D0_u793A" class="headerlink" title="提示"></a>提示</h2><ul>
<li>不要使用 <code>sleep()</code> 来同步</li>
<li>不要使用忙等待 <code>while(1);</code></li>
<li>使用 <code>sigsuspend</code> 来同步</li>
<li>竞争条件</li>
<li>僵尸进程回收（注意竞争条件以及正确处理信号）</li>
<li>等待前台任务（仔细思考怎么样才是好的方式）</li>
<li>不要假定进程的执行顺序</li>
<li>子进程挂掉的时候应该在一个限定时间内被回收</li>
<li>不要在多个地方调用 <code>waitpid</code>，很容易造成竞争条件，也会造成程序过分复杂</li>
<li>不要使用任何系统调用来管理 terminal group</li>
<li><code>waitpid</code>, <code>kill</code>, <code>fork</code>, <code>execve</code>, <code>setpgid</code>, <code>sigprocmask</code> 和 <code>sigsuspend</code> 都非常有用，<code>waitpid</code> 中的 WUNTRACED 和 WNOHANG 选项也是如此。</li>
<li>遇到不清晰的用 <code>man</code> 来查看细节</li>
<li>实现 signal handler 的时候注意给全部的前台进程组发送 SIGINT 和 SIGTSTP 信号</li>
<li>在 <code>kill</code> 函数中使用 <code>-pid</code> 的格式作为参数</li>
<li>在 shell 等待前台工作完成时，需要决定在 <code>eval</code> 及 <code>sigchold handler</code> 具体的分配，这里有一定技巧</li>
<li>在函数 <code>eval</code> 中，在 fork 出子进程之前，必须使用 <code>sigprocmask</code> 来阻塞 SIGCHLD, SIGINT 和 SIGTSTP 信号，完成之后再取消阻塞。调用 <code>addjob</code> 的时候也需要如此。注意，因为子进程也继承了之前的各种状态，所以在子进程中调用 <code>exec</code> 执行新程序的时候注意需要取消阻塞，同样也需要恢复默认的 handler（shell 本身已经忽略了这些信号），具体可以看书本的 8.5.6 节</li>
<li>不要使用 <code>top</code>, <code>less</code>, <code>vi</code>, <code>emacs</code> 之类的复杂程序，使用简单的文本程序如：<code>/bin/cat</code>, <code>/bin/ls</code>, <code>/bin/ps</code>, <code>/bin/echo</code></li>
<li>因为毕竟不是真正的 shell，所以在 fork 之后，execve 之前，子进程需要调用 <code>setpgid(0, 0)</code>，这样就把子进程放到一个新的进程组里。这样就保证我们的 shell 前台进程组中唯一的进程，当按下 ctrl-c 时，应该捕获 SIGINT 信号并发送给对应的前台进程组中。</li>
</ul>
<p>同样提供一个 <code>tshref</code> 参考程序来作为比对输出（除了进程 id 之外其他需要一模一样），具体是通过 <code>runtrace</code> 文件来测试，每个 trace 文件会测试一个特性</p>
<h2 id="u89E3_u9898_u653B_u7565"><a href="#u89E3_u9898_u653B_u7565" class="headerlink" title="解题攻略"></a>解题攻略</h2><p>最开始当时是要先读懂代码，尤其是整个程序到底在干什么，如果有仔细看我前面的介绍和课本的话，应该比较轻松能找到对应（毕竟这是一个简化的版本），所以这里废话不多说，直接开始完成基础工作。我们先来看看如何改动 <code>eval</code> 这个函数。</p>
<p>在这个函数中，我们会先解析命令（具体的解析已经有工具函数），然后得到一系列 token，结构如下</p>
<p><img src="/images/14575497659305.jpg" alt="token 的结构"></p>
<p>目前来说，对我们最有用的是这里面的枚举类型，我们可以先用这个来判断是否是内置函数，据此来决定走哪条分支。我们先把最基本的退出功能做了，这样就不会出现一旦开始就没办法结束的情况，具体方法也很简单，直接 <code>exit(0);</code> 即可，我们测试一下，发现已经可以正确退出了：</p>
<p><img src="/images/14575502436640.jpg" alt="退出程序"></p>
<p>接着我们来实现 <code>jobs</code> 这个命令，因为已经提供了 <code>listjobs</code> 这个函数，所以我们直接围绕着这个函数来做文章即可。留意到 token 结构体中有 <code>infile</code> 和 <code>outfile</code> 两项，这个就是用来重定向的判断（我们不需要担心解析的问题，可以直接用）。同样，我们来判断一下有没有 <code>outfile</code>，对应进行处理即可。注意输出的时候如果不需要重定向，那么就输出到 stdout，如果需要重定向，就输出到对应的 file descriptor 中（打开文件的时候需要设定 flag，具体可以 <code>man open</code> 进行查看）。</p>
<p>接着我们来实现 FG 和 BG 这两个命令，我们需要注意的地方有两个，一个是先根据判断传入的是 JID 还是 PID，然后发送信号之后需要等待进程完成（这里注意使用 <code>sigsuspend</code>）。</p>
<p>这里需要注意 <code>.</code> 和 <code>-&gt;</code> 这两个操作符的不同，简单来说，就是如果左边是一个指向结构体的指针，那么就要用 <code>-&gt;</code>；如果是一个结构体，那么就要用 <code>.</code>。</p>
<p>这些做完之后我们可以先来简单测试一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./runtrace <span class="operator">-f</span> trace00.txt <span class="operator">-s</span> ./tsh</span><br><span class="line">./runtrace <span class="operator">-f</span> trace00.txt <span class="operator">-s</span> ./tshref</span><br><span class="line">./runtrace <span class="operator">-f</span> trace01.txt <span class="operator">-s</span> ./tsh</span><br><span class="line">./runtrace <span class="operator">-f</span> trace01.txt <span class="operator">-s</span> ./tshref</span><br></pre></td></tr></table></figure>
<p><img src="/images/14575550290784.jpg" alt="测试结果"></p>
<p>看到和参考程序输出至少是一致的，我们就可以继续了。</p>
<p>接着我们需要来处理非内置命令的情况，参考课件中的代码，先把需要用到的 mask 之类的弄好，并且我们暂时不考虑重定向的问题。然后需要把对应的 signal handler 补充完整。</p>
<p>这之后我们可以来跑一次测试 <code>./sdriver</code>，最后的得分是 60/100，第一个错误出现在 trace08.txt 这个文件中，查表得知是发送 fatal SIGINT 给前台进程。我自己用 <code>./runtrace -f trace08.txt -s ./tsh</code> 测试了几次，发现有时候可以正确输出，有时候则会超时，说明是处理进程同步的时候出了问题。经过检查发现，阻塞信号的时候需要阻塞全部信号（之前我只阻塞了 SIGCHLD 会出问题），再测试的话，发现已经有了 80/100 分。</p>
<p>继续看看哪里出了问题，在输出的日志中寻找最先出错的地方，发现是 trace22.txt，功能是 I/O redirection(input)，这就对了，毕竟我们还没写这个功能。</p>
<p>我们现在就来写一下。不过在此之前，回答一下前面的问题，前面提到过：</p>
<blockquote>
<p>在 shell 等待前台工作完成时，需要决定在 <code>eval</code> 及 <code>sigchold handler</code> 具体的分配，这里有一定技巧</p>
</blockquote>
<p>那么技巧是什么呢？其实很简单，就是都在 eval 里做，handler 尽量短小精悍。</p>
<p>好，我们继续来做输入输出重定向，同样分为内置函数与其他两个类型，内置函数唯一需要输出的是 <code>jobs</code> 这个函数，不过我们之前已经处理过，这里暂且不管（出问题再说）。所以把主要精力集中在非内置的函数上。具体应该在 <code>setpgid(0,0)</code> 这句之后，且应该在 <code>execve</code> 之前。具体的操作也比较简单，就是打开文件（只读），然后利用 <code>dups</code> 重定向到 STDIN 中即可。对于输出的情况也是类似的，这里不赘述。唯一需要注意的一点是打开文件时候的 flag，设置错误会导致没办法正确重定向。</p>
<p>改完错误之后发现 trace15.txt 又出错了，而且经过测试发现死锁的问题还在，而且是内置函数的问题（果然一开始有小问题），后来发现是搞错了一个变量（但是仍旧有小概率会出现死锁，不过提交的时候似乎一切正常）</p>
<p>最后需要注意的是有些测试会直接修改源代码，所以每次都需要重新解压（还是蛮讨厌的）。总体来说只要理解了整个过程就不算太难，使用 <code>csapp.h</code> 的时候可能需要把代码复制到 <code>tsh.c</code> 中。</p>
<h2 id="u9644_u5F551_3A__u4E2D_u6587_man__u6587_u6863"><a href="#u9644_u5F551_3A__u4E2D_u6587_man__u6587_u6863" class="headerlink" title="附录1: 中文 man 文档"></a>附录1: 中文 man 文档</h2><p>如果觉得看英文太累（虽然建议看英文），可以使用中文的 man 文档，具体的使用步骤如下：</p>
<p>在<a href="http://manpages-zh.googlecode.com/files/manpages-zh-1.5.1.tar.gz" target="_blank" rel="external">这里</a>下载安装包，然后通过如下命令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf manpages-zh-<span class="number">1.5</span>.<span class="number">1</span>.tar.gz</span><br><span class="line"><span class="built_in">cd</span> manpages-zh-<span class="number">1.5</span>.<span class="number">1</span></span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/zhman --disable-zhtw</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>在 Mac 上会乱码，所以需要安装 groff，具体命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install homebrew/dupes/groff</span><br></pre></td></tr></table></figure>
<p>然后打开 <code>/etc/man.conf</code>，把 <code>NROFF</code> 的那一行改为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NROFF preconv <span class="operator">-e</span> UTF8 | /usr/<span class="built_in">local</span>/bin/nroff -Tutf8 -mandoc -c</span><br></pre></td></tr></table></figure>
<p>最后我么加一个别名，方便使用（根据自己使用的 shell 来针对改，bash 的话是 ~/.bashrc，zsh 的话是 ~/.zshrc），在文件中加入这么一句：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias cman='<span class="keyword">man</span> -<span class="keyword">M</span> /usr/<span class="keyword">local</span>/zhman/share/<span class="keyword">man</span>/zh_CN'</span><br></pre></td></tr></table></figure>
<p>然后 <code>source .zshrc</code> 启用，我们就可以通过 <code>cman</code> 命令来查看了，比如说输入 <code>cman kill</code>，就可以看到</p>
<p><img src="/images/14575529137049.jpg" alt="效果"></p>
<p>大功告成。</p>
<h2 id="u9644_u5F552_3A__u57FA_u7840_u77E5_u8BC6"><a href="#u9644_u5F552_3A__u57FA_u7840_u77E5_u8BC6" class="headerlink" title="附录2: 基础知识"></a>附录2: 基础知识</h2><p>开始之前需要理解的内容</p>
<h3 id="u5F02_u6B65_u5F02_u5E38_28_u4E2D_u65AD_29"><a href="#u5F02_u6B65_u5F02_u5E38_28_u4E2D_u65AD_29" class="headerlink" title="异步异常(中断)"></a>异步异常(中断)</h3><p><img src="/images/14574791971112.jpg" alt="Asynchronous Exceptions(Interrupts)"></p>
<h3 id="u540C_u6B65_u5F02_u5E38"><a href="#u540C_u6B65_u5F02_u5E38" class="headerlink" title="同步异常"></a>同步异常</h3><p><img src="/images/14574792452633.jpg" alt="Synchronous Exceptions"></p>
<h3 id="u8FDB_u7A0B"><a href="#u8FDB_u7A0B" class="headerlink" title="进程"></a>进程</h3><p><img src="/images/14574793369863.jpg" alt="Definition"></p>
<p><img src="/images/14574793444040.jpg" alt="Four basic States"></p>
<p><img src="/images/14574793738605.jpg" alt="Control States"></p>
<p>fork 函数详细介绍：</p>
<p><img src="/images/14574794567977.jpg" alt="fork"></p>
<p><img src="/images/14574794700303.jpg" alt="fork"></p>
<p>exec 函数详细介绍</p>
<p><img src="/images/14574794860146.jpg" alt="exec"></p>
<p>exit 函数详细介绍</p>
<p><img src="/images/14574795006407.jpg" alt=""></p>
<p>wait 函数详细介绍</p>
<p><img src="/images/14574795185122.jpg" alt=""></p>
<h3 id="u7B80_u5355_u7684_u8FDB_u7A0B_u4F8B_u5B50"><a href="#u7B80_u5355_u7684_u8FDB_u7A0B_u4F8B_u5B50" class="headerlink" title="简单的进程例子"></a>简单的进程例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (child_pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 这部分只有子进程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Child!\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 父进程通过下面这句等待子进程完成，才继续执行</span></span><br><span class="line">    waitpid(child_pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Parent!\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个使用 execvc 的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"><span class="keyword">char</span>* argv[] = &#123;<span class="string">"/bin/ls"</span>, <span class="string">"-l"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="keyword">char</span>* env[] = &#123;..., <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (child_pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 这部分只有子进程执行</span></span><br><span class="line">    execve(<span class="string">"/bin/ls"</span>, argv, env);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为已经被取代，所以 execve 之后的语句将不会被执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 父进程通过下面这句等待子进程完成，才继续执行</span></span><br><span class="line">    waitpid(child_pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 等待子进程结束之后继续执行父线程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Parent!\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u4FE1_u53F7"><a href="#u4FE1_u53F7" class="headerlink" title="信号"></a>信号</h3><p><img src="/images/14574798651564.jpg" alt="Three possible ways to react"></p>
<p><img src="/images/14574798879407.jpg" alt="Ohter Reaction Options"></p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.yurendu.com/read/install-man-command-chinese-help-documentation-on-mac-and-linux.html" target="_blank" rel="external">Mac/Linux 安装man命令的中文帮助文档</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这次的作业，我们需要自己完成一个简单的 shell 程序，通过具体的实现，我们可以更加深入地计算机运行的机制（尤其是 Exceptional Control Flow 和进程）。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Shelllab" scheme="http://wdxtub.com/tags/Shelllab/"/>
    
      <category term="习题课" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98%E8%AF%BE/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 15 课 System Level I/O]]></title>
    <link href="http://wdxtub.com/2016/03/06/csapp-15/"/>
    <id>http://wdxtub.com/2016/03/06/csapp-15/</id>
    <published>2016-03-06T12:47:39.000Z</published>
    <updated>2016-03-08T18:45:12.000Z</updated>
    <content type="html"><![CDATA[<p>了解完了 Exceptional Control Flow，我们再来看看系统级 IO 的相关内容，完成这一课之后，就可以开始写我们自己的 shell 程序了。</p>
<a id="more"></a>
<hr>
<h2 id="Unix_I/O"><a href="#Unix_I/O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p>在 Linux 中，文件实际上可以看做是字节的序列。更有意思的是，所有的 I/O 设备也是用文件来表示的，比如：</p>
<ul>
<li><code>./dev/sda2</code> (<code>/usr</code> disk partition)</li>
<li><code>/dev/tty2</code> (terminal)</li>
</ul>
<p>甚至连内核也是用文件来表示的：</p>
<ul>
<li><code>/boot/vmlinuz-3.13.0-55-generic</code> (kernel image)</li>
<li><code>/proc</code> (kernel data structures)</li>
</ul>
<p>因为 I/O 设备也是文件，所以内核可以利用称为 Unix I/O 的简单接口来处理输入输出，比如：</p>
<p><img src="/images/14574522789531.jpg" alt="Unix I/O Overview"></p>
<p>为了区别不同文件的类型，会有一个 <code>type</code> 来进行区别：</p>
<ul>
<li>普通文件：包含任意数据</li>
<li>目录：相关一组文件的索引</li>
<li>Socket：和另一台机器上的进程通信的类型</li>
</ul>
<p>其实还有一些比较特别的类型，但是这里提一下，不深入了解：</p>
<ul>
<li>Named pipes(FIFOs)</li>
<li>Symbolic links</li>
<li>Character and block devices</li>
</ul>
<h3 id="Regular_File"><a href="#Regular_File" class="headerlink" title="Regular File"></a>Regular File</h3><p>普通的文件包含任意数据，应用一般来说需要区分出 text files 和 binary files。文本文件只包含 ASCII 或 Unicode 字符。除此之外的都是 binary files(object files, JPEG images, etc)。对于内核来说其实并不能区分出个中的区别。</p>
<p>文本文件就是一系列的文本行，每行以 <code>\n</code> 结尾，新的一行是 <code>0xa</code>，和 ASCII 码中的 line feed 字符(LF) 一样。不同系统用用判断一行结束的符号不同(End of line, EOL)，如：</p>
<ul>
<li>Linux &amp; Mac OS: <code>\n</code>(0xa)<ul>
<li>line feed(LF) </li>
</ul>
</li>
<li>Windows &amp; Internet protocols: <code>\r\n</code> (0xd 0xa)<ul>
<li>Carriage return(CR) followed by line feed(LF)</li>
</ul>
</li>
</ul>
<h3 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a>目录</h3><p>目录包含一个 link 数组，并且每个目录至少包含两条记录：</p>
<ul>
<li><code>.</code>(dot) 当前目录</li>
<li><code>..</code>(dot dot) 上一层目录</li>
</ul>
<p>用来操作目录的命令主要有 <code>mkdir</code>, <code>ls</code>, <code>rmdir</code></p>
<p>目录是以树装结构组织的，跟目录是 <code>/</code>(slash)</p>
<p><img src="/images/14574529458797.jpg" alt="Directory Hierarchy"></p>
<p>内核会为每个进程保存 current working directory (cwd)，可以用 <code>cd</code> 命令来进行更改。</p>
<p>我们通过路径名来确定文件的位置，一般分为绝对路径和相对路径。</p>
<h3 id="u64CD_u4F5C_u6587_u4EF6"><a href="#u64CD_u4F5C_u6587_u4EF6" class="headerlink" title="操作文件"></a>操作文件</h3><p>接下来我们了解一下基本的文件操作。</p>
<p>在使用文件之前需要通知内核打开该文件：</p>
<p><img src="/images/14574530910656.jpg" alt="Opening Files"></p>
<p>返回值是一个小的整型称为 file descriptor（如果这个值等于 -1 则说明发生了错误）。每个由 Linux sheel 创建的进程都会默认打开三个文件：</p>
<ul>
<li>0: standard input(stdin)</li>
<li>1: standard output(stdout)</li>
<li>2: standar error(stderr)</li>
</ul>
<p>使用完毕之后同样需要通知内核关闭文件：</p>
<p><img src="/images/14574532174613.jpg" alt="Closing Files"></p>
<p>如果在此关闭已经关闭了的文件，会出大问题。所以一定要检查返回值，哪怕是 <code>close()</code> 函数（如上面的例子所示）</p>
<p>在打开和关闭之间就是读取文件，实际上就是把文件中对应的字节复制到内存中，并更新文件指针：</p>
<p><img src="/images/14574533193683.jpg" alt="Reading Files"></p>
<p>返回值是读取的字节数量，是一个 <code>ssize_t</code> 类型（其实就是一个 signed integer），如果 <code>nbytes &lt; 0</code> 那么表示出错。<code>nbytes &lt; sizeof(buf)</code> 这种情况(short counts) 是可能发生的，而且并不是错误。</p>
<p>写入文件是把内存中的数据复制到文件中，并更新文件指针：</p>
<p><img src="/images/14574534505640.jpg" alt="Wrting Files"></p>
<p>返回值是写入的字节数量，如果 <code>nbytes &lt; 0</code> 那么表示出错。<code>nbytes &lt; sizeof(buf)</code> 这种情况(short counts) 是可能发生的，而且并不是错误。</p>
<p>综合上面的操作，我们可以来看看 Unix I/O 的例子：</p>
<p><img src="/images/14574535145592.jpg" alt="Copying stdin to stdout, one byte at a time"></p>
<p>前面提到的 short count 会在下面的情形下发生：</p>
<ul>
<li>在读取的时候遇到 EOF(end-of-file)</li>
<li>从终端中读取文本行</li>
<li>读取和写入网络 sockets</li>
</ul>
<p>但是在下面的情况下不会发生</p>
<ul>
<li>从磁盘文件中读取（除 EOF 外）</li>
<li>写入到磁盘文件中</li>
</ul>
<p>最好总是允许 short count，这样就可以避免处理这么多不同的情况。</p>
<h2 id="Robust_I/O"><a href="#Robust_I/O" class="headerlink" title="Robust I/O"></a>Robust I/O</h2><p>RIO 实际上就是一个包装，用来在不同的应用中提供强壮的 IO 接口，主要有一下两类：</p>
<p><img src="/images/14574544870012.jpg" alt="The RIO Package"></p>
<p>可以从<a href="http://csapp.cs.cmu.edu/3e/code.html" target="_blank" rel="external">这里</a> 中下载（<code>src/csapp.c</code> 和  <code>include/csapp.h</code>）</p>
<p>无缓存的输入输出和 Unix 的 <code>read</code> 和 <code>write</code> 接口一致，如果要通过 network sockets 来传输数据，就非常拥有了：</p>
<p><img src="/images/14574546347971.jpg" alt="Unbuffered ROI Input and Output"></p>
<p>具体的实现是：</p>
<p><img src="/images/14574547191767.jpg" alt="Implementation of `rio_readn`"></p>
<p>有缓存的输入在从文件中读取数据的时候通过内置的内存缓冲区提高效率：</p>
<p><img src="/images/14574547952581.jpg" alt="Buffered RIO Input Functions"></p>
<p><img src="/images/14574548277481.jpg" alt=""></p>
<p>具体的实现如下：</p>
<p><img src="/images/14574548545398.jpg" alt="Buffered I/O: Implementation"></p>
<p>对应的结构体是：</p>
<p><img src="/images/14574549507104.jpg" alt=""></p>
<p>这是一个对应的例子：</p>
<p><img src="/images/14574549871674.jpg" alt="Copying the lines of a text file from standar input to standard output"></p>
<h2 id="Metadata_2C_Sharing__26amp_3B_Redirection"><a href="#Metadata_2C_Sharing__26amp_3B_Redirection" class="headerlink" title="Metadata, Sharing &amp; Redirection"></a>Metadata, Sharing &amp; Redirection</h2><p>元数据是用来描述数据的数据，由内核维护，可以通过 <code>stat</code> 和 <code>fstat</code> 函数来访问，其结构是：</p>
<p><img src="/images/14574550707059.jpg" alt="File Metadata"></p>
<p>对应的访问例子：</p>
<p><img src="/images/14574551947810.jpg" alt="Example of Accessing File Metadata"></p>
<p>了解了具体的结构之后，我们来看看内核是如何表示打开的文件的。其实过程很简单，每个进程都有自己的 Descriptor table，然后 Descriptor 1 指向终端，Descriptor 4 指向磁盘文件，如下图所示：</p>
<p><img src="/images/14574553689850.jpg" alt="How the Unix Kernel Represents Open Files"></p>
<p>两个不同的 descriptors 通过两个不同的 open file 记录来共享同一个磁盘文件（对应指向同一个 v-noe table）。</p>
<p>这里有一个需要说明的情况，就是使用 <code>fork</code>。子进程实际上是会继承父进程打开的文件，在调用 <code>fork</code> 之前，我们假设情况是这样的：</p>
<p><img src="/images/14574555865284.jpg" alt="Before fork call"></p>
<p>在 fork 之后，子进程实际上和父进程的指向是一样的，这里需要注意的是会把 <code>refcnt</code> 加上 1（也就是引用计数加 1）</p>
<p><img src="/images/14574556597788.jpg" alt="After fork"></p>
<p>了解了这个，我们我们就可以知道所谓的重定向是怎么实现的了。其实很简单，只要调用 <code>dup2(oldfd, newfd)</code> 函数即可。具体如下：</p>
<p><img src="/images/14574609050965.jpg" alt="I/O Redirection"></p>
<p>Step #1: open file to which stdout should be redirected(happends in child executing shell code, before <code>exec</code>)</p>
<p><img src="/images/14574609981392.jpg" alt="Step #1: open file to which stdout should be redirected"></p>
<p>Step #2: call <code>dup2(4,1)</code> -&gt; cause fd=1(stdout) to refer to disk file pointed at fd=4</p>
<p><img src="/images/14574613741105.jpg" alt="Step #2: call `dup2(4,1)`"></p>
<h2 id="Standar_I/O"><a href="#Standar_I/O" class="headerlink" title="Standar I/O"></a>Standar I/O</h2><p>C 标准库中包含一系列高层的标准 IO 函数，一些具体的函数：</p>
<p><img src="/images/14574614463046.jpg" alt="Examples of standard I/O functions"></p>
<p>标准 IO 会用流的形式打开文件，所谓流(stream)实际上是 file descriptor 和 buffer 在内存中的抽象。C 程序一般以三个流开始，如下所示：</p>
<p><img src="/images/14574615606437.jpg" alt="Standard I/O Streams"></p>
<p>接下来我们详细了解一下为什么需要使用缓冲区，程序经常会一次读入或者写入一个字符，比如 <code>getc</code>, <code>putc</code>, <code>ungetc</code>，同时也会一次读入或者写入一行，比如 <code>gets</code>, <code>fgets</code>。如果用 Unix I/O 的方式来进行调用，是非常昂贵的，比如说 <code>read</code> 和 <code>write</code> 因为需要内核调用，需要大于 10000 个时钟周期。</p>
<p>解决的办法就是利用 <code>read</code> 函数一次读取一块数据，然后再由高层的接口，一次从缓冲区读取一个字符（当缓冲区用完的时候需要重新填充），例如：</p>
<p><img src="/images/14574622326310.jpg" alt="Buffering in Standard I/O"></p>
<p>具体来看看这个例子：</p>
<p><img src="/images/14574622882078.jpg" alt="Standard I/O Buffering in Action"></p>
<p>注意右边的输出，实际上只写入了一次，一次六个字符，而不是程序中写的六次（这里好好感受下）</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>前面介绍了几种不同的 IO，它们的层级如下所示：</p>
<p><img src="/images/14574624849987.jpg" alt="Unix I/O vs. Standard I/O vs. RIO"></p>
<p>Unix I/O 的优劣：</p>
<p><img src="/images/14574625259926.jpg" alt="Pros and Cons of Unix I/O"></p>
<p>Standard I/O 的优劣：</p>
<p><img src="/images/14574625620916.jpg" alt="Pros and Cons of Standard I/O"></p>
<p>具体的选择建议为：</p>
<p><img src="/images/14574626154586.jpg" alt="Choosing I/O Functions"></p>
<p>最后是处理 binary files 的守则：</p>
<p><img src="/images/14574626867246.jpg" alt="Working with Binary Files"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解完了 Exceptional Control Flow，我们再来看看系统级 IO 的相关内容，完成这一课之后，就可以开始写我们自己的 shell 程序了。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="IO" scheme="http://wdxtub.com/tags/IO/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 14 课 Signals and Nonlocal Jumps]]></title>
    <link href="http://wdxtub.com/2016/03/06/csapp-14/"/>
    <id>http://wdxtub.com/2016/03/06/csapp-14/</id>
    <published>2016-03-06T12:47:36.000Z</published>
    <updated>2016-03-07T21:53:55.000Z</updated>
    <content type="html"><![CDATA[<p>了解完了异常与进程，异常处理中另外两个很重要的部分是信号和非局部跳转，也就是我们这节课要介绍的内容。</p>
<a id="more"></a>
<hr>
<p>Linux 的进程树，可以通过 <code>pstree</code> 命令查看，如下：</p>
<p><img src="/images/14573806185809.jpg" alt="Linux Process Hierarchy"></p>
<p>我们以 shell 为例子，来看看整个过程是如何实现的：</p>
<p><img src="/images/14573806718703.jpg" alt="Shell: Execution is a sequence of read/evaluate steps"></p>
<p><img src="/images/14573807472000.jpg" alt="Simple Shell eval Function"></p>
<p>如果只有前台进程的话，我们的 shell 可以在前台工作完成之后进行回收。但是后台进程则会在终止之后成为僵尸进程，不会被回收并且造成内存泄露。</p>
<p>这怎么办呢？同样可以利用 Exceptional control flow，当后台进程完成时，内核会中断常规执行并通知我们，具体的通知机制就是『信号』(signal)。</p>
<h2 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h2><blockquote>
<p>A signal is a small message that notifies a process that an event of some type has occurred in the system</p>
</blockquote>
<p>这样看来，其实是类似于 exception 和 interrupt 的，是由内核（在其他进程的请求下）向当前进程发出的。信号的类型由 1-30 的整数定义，信号所能携带的信息极少，一是对应的编号，二就是信号到达这个事实。下面是几个比较常用的信号的编号及简介：</p>
<p><img src="/images/14573811635888.jpg" alt=""></p>
<blockquote>
<p>Kernel sends a signal to a destination process by updating some state in the context of the destination process</p>
</blockquote>
<p>在下面两个场景中，内核会发送信号：</p>
<ul>
<li>内核检测到了如除以零(SIGFPE)或子进程终止(SIGCHLD)的系统事件</li>
<li>另一个进程调用了 <code>kill</code> 指令来请求内核发送信号给指定的进程</li>
</ul>
<blockquote>
<p>A destination process receives a signal when it is forced by the kernel to react in some way to the delivery of the signal</p>
</blockquote>
<p>一个进程在接收到了信号之后，可以有几种不同的操作：</p>
<ul>
<li><strong>忽略</strong>这个型号</li>
<li><strong>终止</strong>进程</li>
<li><strong>捕获</strong>信号，通过执行 signal handler 完成（类似于异步中断中的 exception handler）</li>
</ul>
<p>具体的过程如下：</p>
<p><img src="/images/14573814877982.jpg" alt=""></p>
<blockquote>
<p>A signal is pending if sent but not yet received</p>
</blockquote>
<p>同类型的信号至多只会有一个 pending signal，一定要注意这个特性，因为内部实现机制不可能提供较复杂的数据结构，所以信号的接收并不是一个队列。(If a process has a pending signal of type k, then subsequent signals of type k that are sent to that process are discarded)</p>
<p>一个 pending signal 至多只能被收到一次。</p>
<blockquote>
<p>A process can block the receipt of certain signals</p>
</blockquote>
<p>被阻塞的信号仍然可以发送，但是知道不阻塞之后才能被接收</p>
<p>内核用 pending 位向量 和 blocked 位向量来维护每个进程的信号相关状态</p>
<ul>
<li>pending: represents the set of pending signals<ul>
<li>Kernel sets bit k in <strong>pending</strong> when a signal of type k is delivered</li>
<li>Kernel clears bit k in <strong>pending</strong> when a signal of type k is received </li>
</ul>
</li>
<li>blocked: represent the set of blocked signals<ul>
<li>Can be set and cleared by using <code>sigprocmask</code> 函数</li>
<li>Also referred to as the <strong>signal mask</strong></li>
</ul>
</li>
</ul>
<p><strong>进程组</strong></p>
<p>每个进程都只属于一个进程组，如下图所示：</p>
<p><img src="/images/14573820359900.jpg" alt=""></p>
<p>我们可以据此指定一个进程组或者一个单独的进程，如：</p>
<p><img src="/images/14573821103841.jpg" alt="Sending Signals with `/bin/kill` Program"></p>
<p>这里可以看到，第一个命令只会杀掉编号为 24818 的进程，但是第二个命令，因为有两个进程都属于进程组 24817，所以会杀掉进程组中的每个进程。</p>
<p>键盘同样可以让内核向每个前台进程发送 SIGINT(SIGTSTP) 信号</p>
<ul>
<li>SIGINT - default action is to terminate each process</li>
<li>SIGTSTP - default action is to stop(suspend) each process</li>
</ul>
<p><img src="/images/14573823408948.jpg" alt="Example of ctrl-c and ctrl-z"></p>
<p>我们可以可以通过 <code>kill</code> 函数来发送信号：</p>
<p><img src="/images/14573824038965.jpg" alt="Sending Signals with kill Function"></p>
<h2 id="u63A5_u6536_u4FE1_u53F7"><a href="#u63A5_u6536_u4FE1_u53F7" class="headerlink" title="接收信号"></a>接收信号</h2><p>所有的上下文切换都是通过调用某个 exception handler 完成的，内核会计算对易于某个进程 p 的 pnb 值：<code>pnb = pending &amp; ~blocked</code></p>
<ul>
<li>如果 <code>pnb == 0</code><ul>
<li>那么就把控制交给进程 p 的逻辑流中的下一条指令</li>
</ul>
</li>
<li>否则<ul>
<li>选择 <code>pnb</code> 中最小的非零位 k，并强制进程 p 接收信号 k</li>
<li>接收到信号之后，进程 p 会执行对应的动作</li>
<li>对 <code>pnb</code> 中所有的非零位进行这个操作</li>
<li>最后把控制交给进程 p 的逻辑流中的下一条指令</li>
</ul>
</li>
</ul>
<p><strong>默认动作</strong></p>
<p>每个信号类型都有一个预定义的『默认动作』，可能是以下的情况：</p>
<ul>
<li>终止进程</li>
<li>终止进程并 dump core</li>
<li>停止进程，收到 <code>SIGCONT</code> 信号之后重启</li>
<li>忽略信号</li>
</ul>
<p><code>signal</code> 函数可以修改默认的动作：<code>handler_t *signal(int signum, handler_t *handler)</code>，具体来说：</p>
<p><img src="/images/14573845678378.jpg" alt="Different values for handler"></p>
<p>我们再通过具体的代码来感受下：</p>
<p><img src="/images/14573846209836.jpg" alt="Signal Handling Example"></p>
<p>可以这么理解 signal handler：</p>
<blockquote>
<p>A signal handler is a separate logical flow(not process) that runs concurrently with the main program</p>
</blockquote>
<p>如下图所示：</p>
<p><img src="/images/14573846875850.jpg" alt="Signals Handlers as Concurrent Flows"></p>
<p><img src="/images/14573847143072.jpg" alt="Another View of Signal Handlers as Concurrent Flows"></p>
<p>还是有一个需要注意的是，handler 也可以被其他的 handler 中断，控制流如下图所示：</p>
<p><img src="/images/14573848399013.jpg" alt="Nested Signal Handlers"></p>
<h2 id="u963B_u585E/_u4E0D_u963B_u585E_u4FE1_u53F7"><a href="#u963B_u585E/_u4E0D_u963B_u585E_u4FE1_u53F7" class="headerlink" title="阻塞/不阻塞信号"></a>阻塞/不阻塞信号</h2><p>隐式的机制是，内核会阻塞与当前在处理的信号同类型的其他 pending signal，也就是说，一个 SIGINT handler 是不能被另一个 SIGINT 信号中断的。</p>
<p>如果想要显式阻塞，就需要使用 <code>sigprocmask</code> 函数了，以及其他一些辅助函数：</p>
<ul>
<li><code>sigemptyset</code> - Create empty set</li>
<li><code>sigfillset</code> - Add every signal number to set</li>
<li><code>sigaddset</code> - Add signal number to set</li>
<li><code>sigdelset</code> - Delete signal number from set</li>
</ul>
<p>我们可以用下面折断代码来临时阻塞特定的信号：</p>
<p><img src="/images/14573850645959.jpg" alt="Temporarily Blocking Signals"></p>
<h2 id="u5B89_u5168_u5730_u5904_u7406_u4FE1_u53F7"><a href="#u5B89_u5168_u5730_u5904_u7406_u4FE1_u53F7" class="headerlink" title="安全地处理信号"></a>安全地处理信号</h2><blockquote>
<p>Handlers are tricky because they are concurrent with main program and share the same global data structures</p>
</blockquote>
<p>尤其要注意因为并行访问可能导致的数据损坏的问题，这里提供一些基本的指南（后面的课程会详细介绍）</p>
<p><img src="/images/14573852332585.jpg" alt="Guidelines for Writing Safe Handlers"></p>
<p>另外一个需要注意的问题是 Async-Signal-Safety。</p>
<blockquote>
<p>Function is async-signal-safe if either reentrant(all variables sotred on stack frame) or non-interruptible by signals</p>
</blockquote>
<p>Posix 标准指定了 117 个 async-signal-safe 的函数（可以通过 <code>man 7 signal</code> 查看）</p>
<p><img src="/images/14573853746526.jpg" alt="许多常用的函数都不是 async-signal-safe 的"></p>
<p>因为输出函数不是 async-signal-safe 的，所以最好使用课本中提供的 <code>csapp.c</code> 中的相关 handler</p>
<ul>
<li><code>ssize_t sio_puts(char s[])</code> - Put string</li>
<li><code>ssize_t sio_putl(long v)</code> - Put long</li>
<li><code>void sio_error(char s[])</code> - Put msg &amp; exit</li>
</ul>
<p><img src="/images/14573854667518.jpg" alt=""></p>
<p>正确的信号处理方法：</p>
<ul>
<li>You can’t use signals to count events, such as children terminating</li>
<li>Must wait for all terminated child processes.</li>
</ul>
<p><img src="/images/14573856728934.jpg" alt="Put `wait` in a loop to reap all terminated children"></p>
<p>还有一个问题，不同 Unix 版本有不同的 signal handling semantics，我们给出的解决方案是使用 <code>sigaction</code>，如下：</p>
<p><img src="/images/14573860066787.jpg" alt="Portable Signal Handling"></p>
<h2 id="u907F_u514D_u8FDB_u7A0B_u7ADE_u4E89"><a href="#u907F_u514D_u8FDB_u7A0B_u7ADE_u4E89" class="headerlink" title="避免进程竞争"></a>避免进程竞争</h2><p>我们之前的 shell 代码会出现微妙的同步错误，因为我们假设父进程会在子进程之前执行，代码如下：</p>
<p><img src="/images/14573866195444.jpg" alt=""></p>
<p><img src="/images/14573866343912.jpg" alt=""></p>
<p>我们需要在循环中添加同步条件，确保父进程和子进程的顺序（注意比较）</p>
<p><img src="/images/14573867961969.jpg" alt="Corrected Shell Program without Race"></p>
<h2 id="u663E_u5F0F_u7B49_u5F85_u4FE1_u53F7"><a href="#u663E_u5F0F_u7B49_u5F85_u4FE1_u53F7" class="headerlink" title="显式等待信号"></a>显式等待信号</h2><p>我们也可以用类似与等待前台任务执行的方式来等待子进程，方法如下：</p>
<p><img src="/images/14573869619954.jpg" alt="Handlers for program explicitly waiting for SIGCHLD to arrive"></p>
<p><img src="/images/14573869910604.jpg" alt="Handlers for program explicitly waiting for SIGCHLD to arrive"></p>
<p>这里的代码是正确的，但是我们注意 <code>while(!pid)</code> 这一句，通过忙等待的方式实现同步，非常浪费资源，而其他方式看起来也不行：</p>
<p><img src="/images/14573870533166.jpg" alt="Other options"></p>
<p>怎么办呢？我们的解决办法是 <code>sigsuspend</code>，函数为：</p>
<p><code>int sigsuspend(const sigset_t *mask)</code></p>
<p>等同于 atomic 版本的：</p>
<p><img src="/images/14573871178306.jpg" alt=""></p>
<p>所以代码如下：</p>
<p><img src="/images/14573871346551.jpg" alt="Wating for Signals with sigsuspend"></p>
<h2 id="Nonlocal_Jump"><a href="#Nonlocal_Jump" class="headerlink" title="Nonlocal Jump"></a>Nonlocal Jump</h2><p>这一部分比较简单，主要是使用 <code>setjmp</code> 与 <code>longjmp</code></p>
<p><img src="/images/14573872756594.jpg" alt="NoNonlocal Jumps: setjmp/longjmp"></p>
<p><img src="/images/14573873026532.jpg" alt="NoNonlocal Jumps: setjmp/longjmp"></p>
<p>我们可以利用这种方式，来跳转到其他的栈帧中，比方说在嵌套函数中，我们可以利用这个快速返回栈底的函数：</p>
<p><img src="/images/14573874602644.jpg" alt=""></p>
<p>但是也有限制，必须在栈中（也就是还没完成）才可以进行跳转，下面的例子中，因为 P2 已经返回，所以不能跳转了：</p>
<p><img src="/images/14573875130970.jpg" alt=""></p>
<p>最后是一个非常清晰的例子：</p>
<p><img src="/images/14573875598038.jpg" alt="A Program that restarts itself when ctrl-c"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这两个基本说完了 exceptional control flow 的全部内容，可能会稍微有点难以理解，我会在后面的习题课中尽可能详细说明。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解完了异常与进程，异常处理中另外两个很重要的部分是信号和非局部跳转，也就是我们这节课要介绍的内容。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="异常" scheme="http://wdxtub.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 13 课 Exceptions and Processes]]></title>
    <link href="http://wdxtub.com/2016/03/06/csapp-13/"/>
    <id>http://wdxtub.com/2016/03/06/csapp-13/</id>
    <published>2016-03-06T12:47:32.000Z</published>
    <updated>2016-03-06T23:16:54.000Z</updated>
    <content type="html"><![CDATA[<p>了解完了链接，我们来看看在程序出错的时候会发生什么事情，这一课我们主要来了解异常与进程。</p>
<a id="more"></a>
<hr>
<p>从开机到关机，CPU 做的工作其实很简单，就是不断读取并执行指令，每次执行一条，整个指令执行的序列，称为 CPU 的控制流。到目前为止，我们已经学过了两种改变控制流的方式：</p>
<ul>
<li>跳转和分支</li>
<li>调用和返回</li>
</ul>
<p>这对应于 program state 的改变。但是这实际上仅仅局限于程序的控制，没有办法去应对更加复杂的情况，比方说 system state 变化的时候：</p>
<ul>
<li>数据从磁盘或者网络适配器到达</li>
<li>指令除以了零</li>
<li>用户按下 ctrl+c</li>
<li>系统的计时器到时间</li>
</ul>
<p>所以我们这里会介绍另一种机制，称为 exceptional control flow。</p>
<h2 id="Exceptional_Control_Flow"><a href="#Exceptional_Control_Flow" class="headerlink" title="Exceptional Control Flow"></a>Exceptional Control Flow</h2><p>Exceptional Control Flow 存在于系统的每个层级：</p>
<p><img src="/images/14572937620861.jpg" alt=""></p>
<p>本节课我们先介绍前两种，下节课介绍后面两种。</p>
<h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><p>An <strong>exception</strong> is a transfer of control to the OS kernel in response to some event (i.e., change in processor state)</p>
<ul>
<li>Kernel 是操作系统常驻内存的一部分</li>
<li>Event: Divide by 0, arithmetic overflow, page fault, I/O request completes, typing ctrl-c</li>
</ul>
<p>具体的过程可以用下图表示：</p>
<p><img src="/images/14572946534326.jpg" alt="Exception 流程"></p>
<p>系统会通过 Exception Table 来确定跳转的位置，每种事件都有对应的唯一的异常编号，发生对应异常时就会调用对应的异常处理代码：</p>
<p><img src="/images/14572947301161.jpg" alt="Exception Table"></p>
<h3 id="Asynchronous_Exceptions__28Interrupts_29"><a href="#Asynchronous_Exceptions__28Interrupts_29" class="headerlink" title="Asynchronous Exceptions (Interrupts)"></a>Asynchronous Exceptions (Interrupts)</h3><p>异步异常称之为中断，是有处理器外面发生的事情引起的，这种情况下：</p>
<ul>
<li>需要设置处理器的 interrupt pin</li>
<li>处理完成后会返回之前控制流中的『下一条』指令</li>
</ul>
<p><img src="/images/14572948483518.jpg" alt="中断的两个例子"></p>
<h3 id="Synchronous_Exceptions"><a href="#Synchronous_Exceptions" class="headerlink" title="Synchronous Exceptions"></a>Synchronous Exceptions</h3><p>同步异常是因为执行某条指令所导致的事件，分为 Traps, Faults 和 Aborts 三种情况：</p>
<p><img src="/images/14572949405706.jpg" alt="同步异常的三种类型"></p>
<p>这里需要注意三种不同类型的处理方式，比方说 Traps 和终端一样，会返回执行『下一条』指令；而 Faults 会重新执行之前触发事件的指令；Aborts 则是直接退出当前的程序。</p>
<p><strong>System Call Example</strong></p>
<p>这里我们来了解一下系统调用 System Calls，系统调用看起来像是函数调用，但其实是走异常控制流的，在 x86-64 系统中，每个系统调用都有一个唯一的 ID，如：</p>
<p><img src="/images/14572951617051.jpg" alt=""></p>
<p>而具体的的调用过程如下所示：</p>
<p><img src="/images/14572951831475.jpg" alt=""></p>
<p><strong>Fault Example</strong></p>
<p>这里卫门以 Page Fault 为例，来说明 Fault 的机制。Page Fault 发生的条件是：</p>
<ul>
<li>用户写入内存位置</li>
<li>但该位置目前还不在内存中</li>
</ul>
<p>比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    a[<span class="number">500</span>] = <span class="number">13</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么系统会通过 Page Fault 把对应的部分载入到内存中，然后重新执行赋值语句：</p>
<p><img src="/images/14572953320001.jpg" alt=""></p>
<p>但是如果代码改为这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    a[<span class="number">5000</span>] = <span class="number">13</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是引用非法地址的时候，整个流程就会变成：</p>
<p><img src="/images/14572953822399.jpg" alt=""></p>
<p>具体来说会像用户进程发送 <code>SIGSEGV</code> 信号，用户进程会以 segmentation fault 的标记退出。</p>
<p>从上面我们就可以看到异常是非常底层的机制。</p>
<h2 id="Process__u8FDB_u7A0B"><a href="#Process__u8FDB_u7A0B" class="headerlink" title="Process 进程"></a>Process 进程</h2><blockquote>
<p>A process is an instance of a running program</p>
</blockquote>
<p>进程是计算机可续中最为重要的思想之一，注意，和 “program” 或 “processor” 都不一样。</p>
<p><img src="/images/14572960158600.jpg" alt="进程示意图"></p>
<p>进程给每个应用提供了两个非常关键的抽象：</p>
<p><img src="/images/14572959919795.jpg" alt="两个关键抽象"></p>
<p>计算机会同时运行多个进程，比如说不同的前台应用，或者后台任务，比方说在 Mac 下输入 <code>top</code>，可以看到如下的进程信息：</p>
<p><img src="/images/14572961362662.jpg" alt="我的电脑当前的状态"></p>
<p>具体的多线程模型如下所示：</p>
<p><img src="/images/14572962685162.jpg" alt="多线程模型（单核）"></p>
<ul>
<li>CPU 交替执行不同的进程</li>
<li>虚拟内存系统会负责管理地址空间</li>
<li>没有执行的进程的寄存器值会被保存在内存中</li>
</ul>
<p><img src="/images/14572963666951.jpg" alt="切换到另一个进程执行，会载入原先的寄存器值(context switch)"></p>
<p>而现代处理器一般有多个核心，所以可以真正同时执行多个进程：</p>
<p><img src="/images/14572964493864.jpg" alt="现代处理器执行模型"></p>
<p>进程之间，也分并行与串行的关系：</p>
<ul>
<li>Two processes run <strong>concurrently</strong> if their flows overlap in time</li>
<li>Otherwise, they are <strong>sequential</strong></li>
</ul>
<p>比方说下图中：</p>
<p><img src="/images/14572965827499.jpg" alt=""></p>
<ul>
<li>Concurrent: A&amp;B, A&amp;C</li>
<li>Sequential: B&amp;C</li>
</ul>
<p>不过在用户看来，执行的感觉是这样的：</p>
<p><img src="/images/14572966466237.jpg" alt=""></p>
<h3 id="Context_Switching"><a href="#Context_Switching" class="headerlink" title="Context Switching"></a>Context Switching</h3><p>具体切换进程时，kernel 会负责具体的调度。</p>
<blockquote>
<p>The kernel is not a separate process, but rather runs as part of some existing process</p>
</blockquote>
<p>控制流通过上下文切换的方式从一个进程到另一个进程，如下图所示：</p>
<p><img src="/images/14572967455790.jpg" alt="上下文切换 Context Switching"></p>
<h2 id="Process_Control__u8FDB_u7A0B_u63A7_u5236"><a href="#Process_Control__u8FDB_u7A0B_u63A7_u5236" class="headerlink" title="Process Control 进程控制"></a>Process Control 进程控制</h2><h3 id="System_Call_Error_Handling"><a href="#System_Call_Error_Handling" class="headerlink" title="System Call Error Handling"></a>System Call Error Handling</h3><p>在遇到错误的时候，Linux 系统级函数通常会返回 -1 并且设置 <code>errno</code> 这个全局变量来表示错误的原因。使用的时候记住两个规则：</p>
<ol>
<li>You must check the return status of every system-level function</li>
<li>Only exception is the handful of functions that return void</li>
</ol>
<p>例如，对于 <code>fork()</code> 函数，我们应该这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"fork error: %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果觉得这样写太麻烦，可以利用一个辅助函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unix_error</span><span class="params">(<span class="keyword">char</span> *msg)</span> <span class="comment">/* Unix-style error */</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: %s\n"</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的片段可以写为</span></span><br><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">"fork error"</span>);</span><br></pre></td></tr></table></figure>
<p>我们甚至可以更进一步，把整个 <code>fork()</code> 包装起来，就可以自带错误处理，比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> Fork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">"Fork error"</span>);</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的时候直接使用 <code>pid = Fork();</code> 即可（注意这里是大写的 F）</p>
<h3 id="u83B7_u53D6_u8FDB_u7A0B_u4FE1_u606F"><a href="#u83B7_u53D6_u8FDB_u7A0B_u4FE1_u606F" class="headerlink" title="获取进程信息"></a>获取进程信息</h3><ul>
<li><code>pid_t getpid(void)</code> - 返回当前进程的 PID</li>
<li><code>pid_t getppid(void)</code> - 返回当前进程的父进程的 PID</li>
</ul>
<p>我们可以认为，进程有三个状态：</p>
<ul>
<li>Running<ul>
<li>正在被执行、正在等待执行或者最终将会被执行</li>
</ul>
</li>
<li>Stopped<ul>
<li>执行被挂起，在进一步通知前不会计划执行</li>
</ul>
</li>
<li>Terminated<ul>
<li>进程被永久停止</li>
</ul>
</li>
</ul>
<p><strong>终止进程</strong></p>
<p>在下面三种情况时，进程会被终止：</p>
<ol>
<li>接收到一个终止信号</li>
<li>返回到 <code>main</code> </li>
<li>调用了 <code>exit</code> 函数</li>
</ol>
<p><img src="/images/14573038632263.jpg" alt="exit is called once but never returns"></p>
<p><strong>创建进程</strong></p>
<p>调用 <code>fork</code> 来创造新进程</p>
<p><img src="/images/14573039229956.jpg" alt="fork is interesting becasue it is called once but returns twice"></p>
<p>下面我们来看一个简单的例子：</p>
<p><img src="/images/14573039725814.jpg" alt=""></p>
<p>有以下几点需要注意：</p>
<ul>
<li>调用一次，但是会有两个返回值</li>
<li>并行执行，不能预计父进程和子进程的执行顺序</li>
<li>拥有自己独立的地址空间（也就是变量都是独立的），除此之外其他都相同</li>
<li>在父进程和子进程中 <code>stdout</code> 是一样的</li>
</ul>
<h3 id="u8FDB_u7A0B_u56FE"><a href="#u8FDB_u7A0B_u56FE" class="headerlink" title="进程图"></a>进程图</h3><p>进程图是一个很好的帮助我们理解进程执行的工具：</p>
<ul>
<li>每个节点代表一条执行的语句</li>
<li>a -&gt; b 表示 a 在 b 前面执行</li>
<li>边可以用当前变量的值来标记</li>
<li><code>printf</code> 节点可以用输出来进行标记</li>
<li>每个图由一个入度为 0 的节点作为起始</li>
</ul>
<p>对于进程图来说，只要满足拓扑排序，就是可能的输出。我们还是用刚才的例子：</p>
<p><img src="/images/14573044246995.jpg" alt=""></p>
<p>我们再来看三个稍微复制一点的例子：</p>
<p><img src="/images/14573045555520.jpg" alt="Two consecutive forks"></p>
<p><img src="/images/14573045862749.jpg" alt="Nested forks in parent"></p>
<p><img src="/images/14573046274270.jpg" alt="Nested forks in children"></p>
<h3 id="Reaping_Child_Processes"><a href="#Reaping_Child_Processes" class="headerlink" title="Reaping Child Processes"></a>Reaping Child Processes</h3><p>即使进程已经终止，也还在消耗系统资源，我们称之为『僵尸』。为了『打僵尸』，就可以采用『收割』(Reaping) 的方法。父进程利用 <code>wait</code> 或 <code>waitpid</code> 回收已终止的子进程，然后给系统提供相关信息，kernel 就会把 zombie child process 给删除。</p>
<p>如果父进程不『收割』的话，通常来说会被 <code>init</code> 进程(pid == 1)回收，所以一般不必显式回收。但是在长期运行的进程中，就需要显式回收（例如 shell 和 server）。下面是几个僵尸进程的例子：</p>
<p><img src="/images/14573049855888.jpg" alt="这里，子进程可以成功被回收"></p>
<p><img src="/images/14573050208627.jpg" alt="这里，因为子进程没有调用 `exit`，所以需要显式回收"></p>
<p><strong>wait: Synchronizing with Children</strong></p>
<p>父进程通过调用 <code>wait</code> 函数来『收割』子进程</p>
<p><img src="/images/14573055666401.jpg" alt=""></p>
<p>下面是一个具体的例子，同样用进程图来描述：</p>
<p><img src="/images/14573056037360.jpg" alt="wait: Synchronizing with Children"></p>
<p><img src="/images/14573056447947.jpg" alt="If multiple children completed, will take in arbitrary order. Can use macros WIFEXITED and WEXITSTATUS to get information about exit status"></p>
<p><strong>waitpid: Waiting for a Specific Process</strong></p>
<p>直接看例子：</p>
<p><img src="/images/14573057138513.jpg" alt=""></p>
<p><strong>execve: Loading and Running Programs</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span></span><br></pre></td></tr></table></figure>
<p>具体的行为是：</p>
<p><img src="/images/14573057856048.jpg" alt=""></p>
<p>为了理解 <code>execve</code> 的行为，我们要先理解程序在栈中的布局：</p>
<p><img src="/images/14573058581756.jpg" alt="栈的结构"></p>
<p>一个具体的例子：</p>
<p><img src="/images/14573058863617.jpg" alt="execve 例子"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Exceptions<ul>
<li>Events that require nonstandard control flow</li>
<li>Generated externally (interrupts) or internally (traps and faults)</li>
</ul>
</li>
<li>Processes<ul>
<li>At any given time, system has multiple active processes</li>
<li>Only one can execute at a time on a single core, though</li>
<li>Each process appears to have total control of processor + private memory space</li>
</ul>
</li>
<li>Spawning processes<ul>
<li>Call <code>fork</code></li>
<li>One call, two returns</li>
</ul>
</li>
<li>Process completion<ul>
<li>Call <code>exit</code></li>
<li>One call </li>
</ul>
</li>
<li>Reaping and waiting for processes<ul>
<li>Call <code>wait</code> or <code>waitpid</code></li>
</ul>
</li>
<li>Loading and running programs<ul>
<li>Call <code>execve</code></li>
<li>One call, (normally) no return</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解完了链接，我们来看看在程序出错的时候会发生什么事情，这一课我们主要来了解异常与进程。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="异常" scheme="http://wdxtub.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 12 课 Linking]]></title>
    <link href="http://wdxtub.com/2016/03/06/csapp-12/"/>
    <id>http://wdxtub.com/2016/03/06/csapp-12/</id>
    <published>2016-03-06T12:47:27.000Z</published>
    <updated>2016-03-06T18:48:49.000Z</updated>
    <content type="html"><![CDATA[<p>这一课我们要接触一个新概念：Linking，简单来说就是计算机如何让不同的代码协同工作的方式。</p>
<a id="more"></a>
<hr>
<p>我们先来看一个例子，假设有这么两个代码文件</p>
<p><img src="/images/14572758203003.jpg" alt=""></p>
<p>我们用下面的命令来编译执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; gcc -Og -o prog main.c sum.c</span><br><span class="line">linux&gt; ./prog</span><br></pre></td></tr></table></figure>
<p>编译器实际上会分别编译不同的源代码，生成 <code>.o</code> 文件，具体把这些文件链接在一起的是 Linker 链接器，整个过程如下图所示：</p>
<p><img src="/images/14572760766987.jpg" alt=""></p>
<blockquote>
<p>为什么要使用链接器？</p>
</blockquote>
<p>有如下两个原因。</p>
<ul>
<li>模块化角度考虑。我们可以把程序分散到不同的小的源代码中，而不是一个巨大的类中。这样带来的好处是可以复用常见的功能/库，比方说 Math library, standard C library.</li>
<li>效率角度考虑。改动代码时只需要重新编译改动的文件，其他不受影响。而常用的函数和功能可以封装成库，提供给程序进行调用（节省空间）</li>
</ul>
<blockquote>
<p>链接器做了什么？</p>
</blockquote>
<p>主要负责做两件事情</p>
<p><strong>第一步：Symbol resolution</strong></p>
<p>我们在代码中会声明变量及函数，之后会调用变量及函数，所有的符号声明都会被保存在符号表(symbol table)中，而符号表会保存在由汇编器生成的 object 文件中（也就是 <code>.o</code> 文件）。符号表实际上是一个结构体数组，每一个元素包含名称、大小和符号的位置。</p>
<p>在 symbol resolution 阶段，链接器会给每个符号应用一个唯一的符号定义，用作寻找对应符号的标志。</p>
<p><strong>第二步：Relocation</strong></p>
<p>这一步所做的工作是把原先分开的代码和数据片段汇总成一个文件，会把原先在 <code>.o</code> 文件中的相对位置转换成在可执行程序的绝对位置，并且据此更新对应的引用符号（才能找到新的位置）</p>
<p>在具体来看这两步做了啥之前，先要理解下面几个概念。</p>
<h2 id="u4E09_u79CD_Object_Files"><a href="#u4E09_u79CD_Object_Files" class="headerlink" title="三种 Object Files"></a>三种 Object Files</h2><p>所谓的 Object File 实际上是一个统称，具体来说有以下三种形式：</p>
<ul>
<li>Relocatable object file (<code>.o</code> file)<ul>
<li>每个 <code>.o</code> 文件都是由对应的 <code>.c</code> 文件生成，包含代码和数据，可以用来组合成 executable object file</li>
</ul>
</li>
<li>Executable object file (<code>a.out</code> file)<ul>
<li>包含代码和数据，可以直接被复制到内存中执行</li>
</ul>
</li>
<li>Shared object file (<code>.so</code> file)<ul>
<li>在 windows 中被称为 Dynamic Link Libraries(DLLs)，是一类特别的 relocatable object file，能够被载入内存并动态链接（载入时或运行时）</li>
</ul>
</li>
</ul>
<h2 id="Executable_and_Linkable_Format_28ELF_29"><a href="#Executable_and_Linkable_Format_28ELF_29" class="headerlink" title="Executable and Linkable Format(ELF)"></a>Executable and Linkable Format(ELF)</h2><p>上面提到的三种 obejct file 有统一的格式，即 Executable and Linkable Format(ELF)，因为，我们把它们统称为 ELF binaries，具体的文件格式如下</p>
<p><img src="/images/14572780724226.jpg" alt="ELF 文件格式"></p>
<p>下面分别介绍一下各个部分：</p>
<ul>
<li>ELF header<ul>
<li>包含 word size, byte ordering, file type (.o, exec, .so), machine type, etc</li>
</ul>
</li>
<li>Segment header table<ul>
<li>包含 page size, virtual addresses memory segments(sections), segment sizes</li>
</ul>
</li>
<li>.text section<ul>
<li>代码部分</li>
</ul>
</li>
<li>.rodata section<ul>
<li>只读数据部分，例如 jump tables</li>
</ul>
</li>
<li>.data section<ul>
<li>初始化的全局变量</li>
</ul>
</li>
<li>.bss section<ul>
<li>未初始化的全局变量</li>
<li>“Block Started by Symbol”</li>
<li>“Better Save Space”</li>
<li>有 section header 但实际上不占空间</li>
</ul>
</li>
<li>.symtab section<ul>
<li>包含 symbol table, procudure 和 static variable names 以及 section names 和 location</li>
</ul>
</li>
<li>.rel.txt section<ul>
<li>Relocation info for .text section</li>
<li>Addresses of instructions that will need to be modified in the executable</li>
<li>Instructions for modifying</li>
</ul>
</li>
<li>.rel.data section<ul>
<li>Relocation info for .data section</li>
<li>Addresses of pointer data that will need to be modified in the merged executable </li>
</ul>
</li>
<li>.debug section<ul>
<li>包含 symbolic debugging (<code>gcc -g</code>) 的信息 </li>
</ul>
</li>
<li>Section header table<ul>
<li>Offsets and sizes of each section</li>
</ul>
</li>
</ul>
<h2 id="Linker_Symbols"><a href="#Linker_Symbols" class="headerlink" title="Linker Symbols"></a>Linker Symbols</h2><p>而链接器实际上会处理三种不同的符号，对应于代码中不同写法的部分：</p>
<ul>
<li>Global symbols<ul>
<li>在当前模块中定义，且可以被其他代码引用的符号，例如非静态 C 函数和非静态全局变量</li>
</ul>
</li>
<li>External symbols<ul>
<li>同样是全局符号，但是是在其他模块（也就是其他的源代码）中定义的，但是可以在当前模块中引用</li>
</ul>
</li>
<li>Local symbols<ul>
<li>在当前模块中定义，只能被当前模块引用的符号，例如静态函数和静态全局变量</li>
<li>注意，Local linker symbol 并不是 local program variables</li>
</ul>
</li>
</ul>
<p>现在我们可以回过头来看看链接器具体做的工作了：</p>
<h2 id="u7B2C_u4E00_u6B65_uFF1ASymbol_resolution"><a href="#u7B2C_u4E00_u6B65_uFF1ASymbol_resolution" class="headerlink" title="第一步：Symbol resolution"></a>第一步：Symbol resolution</h2><p><img src="/images/14572791281425.jpg" alt="Symbol resolution"></p>
<p>我们可以看到，链接器只知道非静态的全局变量/函数，而对于局部变量一无所知。</p>
<p>然后我们来看看局部非静态变量和局部静态变量的区别</p>
<ul>
<li>局部非静态变量会保存在栈中</li>
<li>局部静态变量会保存在 <code>.bss</code> 或 <code>.data</code> 中</li>
</ul>
<p>例如：</p>
<p><img src="/images/14572793537491.jpg" alt=""></p>
<p>如果两个不同的源代码中使用了相同的全局变量名称，链接器会如何处理呢？</p>
<p>首先我们需要知道的是，不同的符号是有强弱之分的：</p>
<ul>
<li>Strong: procedures and initialized globals</li>
<li>Weak: uninitialized globals</li>
</ul>
<p>比如：</p>
<p><img src="/images/14572854731828.jpg" alt=""></p>
<p>在这个基础上，有如下规则：</p>
<p><img src="/images/14572855304555.jpg" alt=""></p>
<p>因为这个特性，可能会因为变量重名导致非常奇怪的现象，比如下面的情况：</p>
<p><img src="/images/14572855800167.jpg" alt=""></p>
<p>因此我们可以得到一条很重要的编程建议：</p>
<blockquote>
<p>如果可能，尽量避免使用全局变量</p>
</blockquote>
<p>如果一定要用的话，注意下面几点：</p>
<ul>
<li>使用静态变量</li>
<li>定义全局变量的时候初始化</li>
<li>注意使用 <code>extern</code> 关键字</li>
</ul>
<h2 id="u7B2C_u4E8C_u6B65_uFF1ARelocation"><a href="#u7B2C_u4E8C_u6B65_uFF1ARelocation" class="headerlink" title="第二步：Relocation"></a>第二步：Relocation</h2><p>大概的过程，通过下图就可以看得比较清楚，就是把不同的 relocatable object files 拼成 executable object file 的过程</p>
<p><img src="/images/14572863145911.jpg" alt=""></p>
<p>但具体是怎么做到的呢，还是刚才那个例子：</p>
<p><img src="/images/14572863618645.jpg" alt=""></p>
<p>对应的 relocatable object file 反编译出来 <code>objdump -r -d main.o</code> 可以看到汇编代码为：</p>
<p><img src="/images/14572864112503.jpg" alt=""></p>
<p>这里我们可以看到，编译器用 relocation entry 来标记不同的调用（注意看对应的代码后面四组数字都是零，就是留出位置让链接器在链接的时候填上对应的实际内存地址）</p>
<p>在完成链接之后我们得到 <code>prog</code> 这个程序，同样反编译 <code>objdump -dx prog</code> 可以看到：</p>
<p><img src="/images/14572865303343.jpg" alt=""></p>
<p>对应的地址已经被填上去了，这里注意用的是相对的位置，比方说 0x4004de 中的 05 00 00 00 的意思实际上是说要在下一句的基础上加上 0x5，也就是 0x4004e8，即 sum 函数的开始位置。</p>
<p>具体载入内存的时候，大概是这样的：</p>
<p><img src="/images/14572866787544.jpg" alt=""></p>
<p>这里需要注意左边的部分地址从上往下，右边则是从下往上，这里所有的程序都会从 0x400000 开始。</p>
<h2 id="u6253_u5305_u5E38_u7528_u7A0B_u5E8F"><a href="#u6253_u5305_u5E38_u7528_u7A0B_u5E8F" class="headerlink" title="打包常用程序"></a>打包常用程序</h2><p>基本上每个程序都会用到某些特定的函数，比如：Math, IO, memory management, string manipulation 等等，我们能用什么方法把它们结合到程序中呢，有以下两个思路：</p>
<ul>
<li>思路 1：把所有的函数放到一个源文件中，程序员每次把这一整个大块头链接到自己的程序中，这种做法从时间和空间上来说都比较低效</li>
<li>思路 2：不同的函数放到不同的源文件中，由程序员显式链接所需要的函数，这种做法效率更高，但是相当于是给程序员增加负担了</li>
</ul>
<h3 id="Static_Libraries"><a href="#Static_Libraries" class="headerlink" title="Static Libraries"></a>Static Libraries</h3><p>比较老式的做法就是所谓的静态库(Static Libraries, <code>.a</code> archive files)</p>
<ul>
<li>Concatenate related relocatable object files into a single file with an index (called an archive)</li>
<li>Enhance linker so that it tries to resolve unresolved external references by looking for the symbols in one or more archives</li>
<li>If an archive member file resolves reference, link it into the executable</li>
</ul>
<p>具体的过程如下：</p>
<p><img src="/images/14572879938673.jpg" alt=""></p>
<p>这里注意，Archiver 支持增量更新，如果有函数变动，只需要重新编译改动的部分。</p>
<p>下面是两个常用的库：C standard library 与 C math library</p>
<p><img src="/images/14572880658935.jpg" alt=""></p>
<p>接下来我们看一个具体的例子，通过静态库来连接：</p>
<p><img src="/images/14572880967573.jpg" alt=""></p>
<p>具体过程如下：</p>
<p><img src="/images/14572881242795.jpg" alt=""></p>
<p>具体的链接方式是：</p>
<p><img src="/images/14572882030642.jpg" alt=""></p>
<p>但是这样会带来一个问题：写编译命令的时候，顺序是很重要的！我们看下面这个例子</p>
<p><img src="/images/14572882337934.jpg" alt=""></p>
<p>第一条命令中，在编译链接的时候，如果在 libtest.o 中发现了外部引用，就会在 -lmine 中查找，但是如果反过来，在第二条语句中 libtest.o 后面没有东西，就会出现找不到引用的错误。所以建议就是要把静态库都放到后面去。</p>
<h3 id="Shared_Libraries"><a href="#Shared_Libraries" class="headerlink" title="Shared Libraries"></a>Shared Libraries</h3><p>现代的方法则是使用共享库，避免了在文件中静态库的大量重复。</p>
<p>动态链接可以在首次载入的时候执行(load-time linking)，这是 Linux 的标准做法，会由动态链接器 <code>ld-linux.so</code> 完成，Standard C library(libc.so) 通常是动态链接的。</p>
<p><img src="/images/14572885863404.jpg" alt="Dynamic Linking at Load-time"></p>
<p>动态链接也可以在程序开始执行的时候完成(run-time linking)，在 Linux 中使用 <code>dlopen()</code> 接口来完成（会使用函数指针，如下面的例子所示），通常用于分布式软件，高性能服务器上。而且共享库也可以在多个进程间共享，这在后面学习到虚拟内存的时候会介绍。</p>
<p><img src="/images/14572886125265.jpg" alt=""></p>
<p><img src="/images/14572886257737.jpg" alt="Dynamic Linking at Run-time"></p>
<p>总结一下：</p>
<ul>
<li>链接使得我们可以用多个 object files 构造我们的程序</li>
<li>链接可以发生在程序的不同阶段<ul>
<li>编译期间(when a program is compiled)</li>
<li>载入期间(when a program is loaded into memory)</li>
<li>运行期间(while program is executing)</li>
</ul>
</li>
<li>理解链接可以帮助我们避免遇到奇怪的错误</li>
</ul>
<h2 id="Case_Study_3A_Library_Interpositioning"><a href="#Case_Study_3A_Library_Interpositioning" class="headerlink" title="Case Study: Library Interpositioning"></a>Case Study: Library Interpositioning</h2><p>这是一个非常有意思的技术，我们可以通过这个技术让程序运行任意我们想要的代码，比方说我们的程序中使用了 <code>malloc</code>，我们可以通过 library interpositioning 让程序执行我们自定义的 <code>malloc</code> 而不是标准库中的 <code>malloc</code>。</p>
<p>因为这相当于是某种链接技术，所以同样可以在不同的时候发生，如：</p>
<ul>
<li>编译时：When the source code is compiled</li>
<li>链接时：When the relocatable object files are statically linked to form an executable object file</li>
<li>载入/运行时：When an executable object file is loaded into memory, dynamically linked, and then executed.</li>
</ul>
<p>这个技术可以应用在</p>
<ul>
<li>安全方面<ul>
<li>Confinement (sandboxing)</li>
<li>Behind the scenes encryption</li>
</ul>
</li>
<li>调试方面<ul>
<li>可以找到隐藏比较深的 bug</li>
</ul>
</li>
<li>监控和查看性能<ul>
<li>统计函数调用的次数</li>
<li>检测内存泄露</li>
<li>生成地址记录</li>
</ul>
</li>
</ul>
<p>我们用一个具体的例子来说明，先来看看程序，非常简单，只有几行：</p>
<p><img src="/images/14572895007610.jpg" alt=""></p>
<p>我们要做的事情也很简单，先申请一片内存空间，然后再释放掉。但是我们的目标是在不修改源代码的前提下，追踪分配地址的位置，要怎么办呢？</p>
<p>有三种方式，分别在编译、链接和运行时对 <code>malloc</code> 和 <code>free</code> 函数进行 interpositioning。</p>
<h3 id="Compile-time_Interpositioning"><a href="#Compile-time_Interpositioning" class="headerlink" title="Compile-time Interpositioning"></a>Compile-time Interpositioning</h3><p>我们写出另外两个函数，它们唯一做的事情就是输出地址，相当于把原来的函数做了个『包装』：</p>
<p><img src="/images/14572896784067.jpg" alt=""></p>
<p>然后在 <code>malloc.h</code> 利用宏进行改变：</p>
<p><img src="/images/14572897247442.jpg" alt=""></p>
<p>最后我们可以通过 <code>-I.</code> 这个选项来使得程序会调用我们自己写的函数，可以看到执行的时候会打印出地址</p>
<p><img src="/images/14572897797778.jpg" alt=""></p>
<h3 id="Link-time_Interpositioning"><a href="#Link-time_Interpositioning" class="headerlink" title="Link-time Interpositioning"></a>Link-time Interpositioning</h3><p>我们同样需要把两个函数包装一下：</p>
<p><img src="/images/14572898402918.jpg" alt=""></p>
<p>然后注意所用的命令：</p>
<p><img src="/images/14572898614846.jpg" alt=""></p>
<p>这里 <code>-Wl</code> 会告诉链接器，把每个逗号替换成空格。</p>
<p><code>--wrap,malloc</code> 这个参数会进行特殊方式的引用</p>
<ul>
<li>对 <code>malloc</code> 的引用会被解析为 <code>__wrap_malloc</code></li>
<li>对 <code>__real_malloc</code> 的引用会被解析为 <code>malloc</code></li>
</ul>
<h3 id="Load/Run-time_Interpositioning"><a href="#Load/Run-time_Interpositioning" class="headerlink" title="Load/Run-time Interpositioning"></a>Load/Run-time Interpositioning</h3><p>我们同样是对两个函数进行包装：</p>
<p><img src="/images/14572900345456.jpg" alt=""></p>
<p><img src="/images/14572900442044.jpg" alt=""></p>
<p>然后使用以下命令：</p>
<p><img src="/images/14572900675087.jpg" alt=""></p>
<p>这里的 <code>LD_PRELOAD</code> 环境变量会告诉动态链接器先在 <code>mymalloc.so</code> 中寻找所需的引用，就完成了 interpositioning 的效果。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一课我们要接触一个新概念：Linking，简单来说就是计算机如何让不同的代码协同工作的方式。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="链接" scheme="http://wdxtub.com/tags/%E9%93%BE%E6%8E%A5/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Programming iOS9 学习笔记 12 - Controls and Other Views]]></title>
    <link href="http://wdxtub.com/2016/03/06/programming-ios9-translation-12/"/>
    <id>http://wdxtub.com/2016/03/06/programming-ios9-translation-12/</id>
    <published>2016-03-06T12:39:13.000Z</published>
    <updated>2016-03-06T12:46:33.000Z</updated>
    <content type="html"><![CDATA[<p>这一章主要包含前面没有提到过的 <code>UIView</code> 的子类（由 UIKit 提供）</p>
<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<p>这一章主要包含前面没有提到过的 <code>UIView</code> 的子类（由 UIKit 提供）</p>]]>
    
    </summary>
    
      <category term="Control" scheme="http://wdxtub.com/tags/Control/"/>
    
      <category term="iOS9" scheme="http://wdxtub.com/tags/iOS9/"/>
    
      <category term="学习" scheme="http://wdxtub.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://wdxtub.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Programming iOS9 学习笔记 11 - Web Views]]></title>
    <link href="http://wdxtub.com/2016/03/06/programming-ios9-translation-11/"/>
    <id>http://wdxtub.com/2016/03/06/programming-ios9-translation-11/</id>
    <published>2016-03-06T11:12:42.000Z</published>
    <updated>2016-03-06T12:38:58.000Z</updated>
    <content type="html"><![CDATA[<p>Web view 实际是一个浏览器，知道如何从网络上获取资源，比如说渲染 HTML/CSS/JavaScript。不仅可以用于展示网络内容，而且还有一个强大的，可以用来布局、显示动画和多媒体的引擎。</p>
<a id="more"></a>
<hr>
<p>Web view 甚至还知道如何去显示 PDF/RTF/DOC/Pages 文件。</p>
<p><img src="/images/14572631505893.jpg" alt=""></p>
<p>Web view 中的资源加载是异步的，有一个另外的线程来完成这个工作，也就是说加载的时候用户仍然可以进行各种操作和访问。</p>
<p><img src="/images/14572632324008.jpg" alt=""></p>
<p>在 iOS 9 中，实际上有三类 web view 对象：</p>
<p><img src="/images/14572632568030.jpg" alt=""></p>
<p>这里主要讨论 <code>WKWebView</code> 和 <code>SFSafariViewController</code>。</p>
<p><img src="/images/14572633254117.jpg" alt=""></p>
<h2 id="WKWebView"><a href="#WKWebView" class="headerlink" title="WKWebView"></a>WKWebView</h2><p><code>WKWebView</code> 是 WebKit 框架的一部分，使用之前需要 <code>import WebKit</code> 并且在代码中创建 web view，比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> config = <span class="type">WKWebViewConfiguration</span>()</span><br><span class="line"><span class="comment">// .... 各种配置</span></span><br><span class="line"><span class="keyword">let</span> wv = <span class="type">WKWebView</span>(frame: <span class="type">CGRectZero</span>, configuration:config)</span><br></pre></td></tr></table></figure>
<p>当然也可以直接使用默认配置初始化，之后再进行修改，如</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wv = <span class="type">WKWebView</span>(frame: <span class="type">CGRectZero</span>)</span><br><span class="line"><span class="comment">// ... 各种配置</span></span><br></pre></td></tr></table></figure>
<p>无论用哪种方法，最好在开始载入之前就完成配置，因为不同的配置可能会导致渲染得到的页面不一样，比较常见的配置有：</p>
<p><img src="/images/14572640710901.jpg" alt=""></p>
<p><img src="/images/14572640995408.jpg" alt=""></p>
<p>也可以创建自定义的内容放到界面上，如：</p>
<p><img src="/images/14572641374200.jpg" alt=""></p>
<p><code>WKWebView</code> 并不是一个 scroll view，但是拥有一个 scroll view。</p>
<p>有下面四种方式可以让 <code>WKWebView</code> 显示内容：</p>
<p><img src="/images/14572642956567.jpg" alt=""></p>
<p><img src="/images/14572643064428.jpg" alt=""></p>
<p>以上四个方法都会返回 <code>WKNavigation</code> 对象</p>
<p>我们可以通过 <code>WKWebView</code> 的属性来跟踪其状态，比如：</p>
<ul>
<li><code>loading</code></li>
<li><code>estimatedProgress</code></li>
<li><code>URL</code></li>
<li><code>title</code></li>
</ul>
<p>我们可以通过这些属性来做一些操作，比如说在载入的时候在页面中间放一个进度指示器，并且在载入完成之后隐藏。具体代码如下</p>
<p><img src="/images/14572644352049.jpg" alt=""></p>
<p>我们可以通过 <code>backForwardList</code> 来进行前进和后退的操作，这是一个 <code>WKBackForwardList</code> 并且有以下属性</p>
<ul>
<li><code>currentItem</code></li>
<li><code>backItem</code></li>
<li><code>forwardItem</code></li>
<li><code>itemAtIndex</code></li>
</ul>
<p>列表中的每个项目都是 <code>WKBackForwardItem</code>，包含 <code>URL</code> 和 <code>title</code>。然后就可以调用 <code>goBack</code>, <code>goForward</code> 和 <code>goToBackForwardListItem:</code> 方法来进行导航。当然，也可以通过设定 <code>canGoBack</code> 和 <code>canGoForward</code> 来控制是否能够后退前进。</p>
<p>还有一个可以设置的属性 <code>allowsBackForwardNavigationGestures</code>，用来控制是否能够以手势返回，默认是 false，如果设置为 true，则在滑动边缘的时候能够返回。</p>
<p>通过设置 <code>WKWebView</code> 的 <code>navigationDelegate</code> 可以控制具体的导航行为，例如：</p>
<p><img src="/images/14572672880968.jpg" alt=""></p>
<p><img src="/images/14572672999616.jpg" alt=""></p>
<p>然后还有一些代理方法会通知目前的状态：</p>
<p><img src="/images/14572673546176.jpg" alt=""></p>
<p>如果想要给 <code>WKWebView</code> 中的网页发消息，可以调用 <code>evaluateJavaScript:completionHandler:</code> 方法，例子如下；</p>
<p><img src="/images/14572674300371.jpg" alt=""></p>
<p><img src="/images/14572674428385.jpg" alt=""></p>
<p>当然也可以反向来进行操作，比方说把页面的某些元素与按钮绑定，这里不深入。</p>
<p>最后需要注意的是，<code>WKWebView</code> 是不能在 nib 中初始化的（控件里的是 <code>UIWebView</code>）。并且在 iOS8 中，指向本地文件的链接无法在 <code>WKWebView</code> 中使用（iOS9 中已修复，但是考虑兼容性，只能使用 UIWebView）</p>
<p>另外一个问题是 <code>WKWebView</code> 不会自动参与到任何视图控制器的状态中（也就是无法保存和恢复），如果是显示本地内容的话可以人为进行保存恢复，这里不赘述</p>
<h2 id="Safari_View_Controller"><a href="#Safari_View_Controller" class="headerlink" title="Safari View Controller"></a>Safari View Controller</h2><p>简单来说，就是在你的应用中开一个单独的 safari 线程（提供比较完整的功能）。根据苹果的建议，如果是要显示内部的 HTML 内容，用 <code>WKWebView</code>，如果是访问网络，用 Safari view controller，这样可以省去很多麻烦。</p>
<p>使用需要 <code>import SafariServices</code>，如</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> svc = <span class="type">SFSafariViewController</span>(<span class="type">URL</span>: url)</span><br><span class="line"><span class="keyword">self</span>.presentViewController(svc, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/14572679027545.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Web view 实际是一个浏览器，知道如何从网络上获取资源，比如说渲染 HTML/CSS/JavaScript。不仅可以用于展示网络内容，而且还有一个强大的，可以用来布局、显示动画和多媒体的引擎。</p>]]>
    
    </summary>
    
      <category term="Webview" scheme="http://wdxtub.com/tags/Webview/"/>
    
      <category term="iOS9" scheme="http://wdxtub.com/tags/iOS9/"/>
    
      <category term="学习" scheme="http://wdxtub.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://wdxtub.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的软实力]]></title>
    <link href="http://wdxtub.com/2016/03/05/my-soft-skill/"/>
    <id>http://wdxtub.com/2016/03/05/my-soft-skill/</id>
    <published>2016-03-06T02:04:55.000Z</published>
    <updated>2016-03-06T11:15:44.000Z</updated>
    <content type="html"><![CDATA[<p>上一篇文章，<a href="http://wdxtub.com/2016/03/04/na-job-soft-skill/">北美找工作软实力指南</a>中提到了给自己定位的分析与思考方法，这里以自己为例子，来看看如何更好地找到自己并展示自己。</p>
<a id="more"></a>
<hr>
<p>自己比较适合游走在技术、管理与沟通之间的工作，所以就以这个为基准，作为这次思考的开始。</p>
<h2 id="u76EE_u6807"><a href="#u76EE_u6807" class="headerlink" title="目标"></a>目标</h2><p>我想找的工作职位是：项目经理（需要懂技术与管理，还需要与客户或者其他小组沟通协调，和微软的 Program Manager 的职责比较接近，而非传统那样只负责管理）。</p>
<p>选择这个职位作为走上社会的第一步，是经过深思熟虑的。我的性格、做事风格、技能、经历和喜好都非常适合这个职位，具体会在后面详细说明。</p>
<p><strong>短期职业目标</strong></p>
<p>我的短期职业目标是通过这份工作尽可能快得通过接触社会上各种类型的人来完成从学生到社会人这个身份的转换，并在具体实践中找到自己的方向。所以希望能不止局限于特定的工作，而是像『救火队员』一样，到最需要、最能学到东西、最能成长的地方，哪怕苦一点累一点，压力大一点也不怕。</p>
<p><strong>长期职业目标</strong></p>
<p>我的长期职业目标是通过接触不同领域，不同层次的项目和人群，建立其对技术、商业乃至于社会的整体框架，并利用自己的思考与行动力，带领志同道合的伙伴一起努力，为后辈创造一个更好的未来。我知道现在中国社会有太多太多的丑陋和需要改进的地方，我想通过自己的努力，从独当一面开始，真正能做一些影响到更多人的事情。简单来说就是想让世界 “Hear My Voice”</p>
<h2 id="u6280_u80FD"><a href="#u6280_u80FD" class="headerlink" title="技能"></a>技能</h2><p>对应于我的短期与长期的职业目标，我的以下技能是非常合适的：</p>
<h3 id="u6280_u80FD_u4E00_uFF1A_u9605_u8BFB"><a href="#u6280_u80FD_u4E00_uFF1A_u9605_u8BFB" class="headerlink" title="技能一：阅读"></a>技能一：阅读</h3><p>阅读能力的提升使得我能更快更好地把新知识融会贯通到已有的知识体系与认知架构中，我觉得这对于一个项目经理来说是很重要的。不谋万世者不足以谋一时，通过广泛涉猎建立起来的大局观与开放性思考问题的方式，相信对于完成这个职位所需要的工作有很大帮助。</p>
<p>从大四起，我有目的开始培养自己阅读的能力。书籍作为最重要且最有价值的信息来源，在这个碎片化的时代很容易被忽视。随着阅读量的增加，慢慢也有了一些影响力，成为了『多看特约书评人』，也积累了一些粉丝。</p>
<p><img src="/images/duokan-read.jpeg" alt="我在多看阅读中的一些数据"></p>
<p><a href="http://www.douban.com/people/wdx/" target="_blank" rel="external">这里</a>是我的豆瓣读书主页，也可以从中大概了解我的阅读兴趣。因为对这个世界好奇，所以基本上各个领域的书都有所涉猎，知识面比较广，每隔一段时间也会进行整理和反思。毫不夸张的说，阅读是我这几年快速成长的基础，具体可以参加下面几篇思考的日志：</p>
<ul>
<li><a href="http://wdxtub.com/2015/05/25/5000-hours/">写在五千小时</a></li>
<li><a href="http://wdxtub.com/2014/10/22/4000-hours/">写在四千小时</a></li>
<li><a href="http://wdxtub.com/2014/05/20/3000-hours/">写在三千小时</a></li>
<li><a href="http://wdxtub.com/2014/01/20/2000-hours/">写在两千小时</a></li>
<li><a href="http://wdxtub.com/2013/08/21/1000-hours/">写在一千小时</a></li>
</ul>
<h3 id="u6280_u80FD_u4E8C_uFF1A_u5199_u4F5C"><a href="#u6280_u80FD_u4E8C_uFF1A_u5199_u4F5C" class="headerlink" title="技能二：写作"></a>技能二：写作</h3><p>管理和沟通除了面对面交流之外，更重要的一部分是通过文字，因为文字可以跨域时空限制，清晰有逻辑的表述不但能够梳理思路，更能避免基本的思维误区。并且在不断的写作中，也通过和读者的沟通交流极大地提高自己跟不同行业的人介绍自己工作的能力，尤其是利用『比喻』的能力。我总是会利用比喻来尽可能让他人理解我要介绍的东西或者我的思维方式，这是我的最大收获。因为项目经理很多时候还需要进行协调沟通的工作，我的这个技能是很好的助力。</p>
<p>从高中开始就会在网上写写东西，起初都是没多少意义的流水账，开始有针对性阅读之后，就以书评的形式来组织自己的文章，从最简单的书摘，到慢慢有自己的见解，再到现在能够批判性去看待的观点，以及研究作者的思维方式，一步一步都让我得到了很多乐趣。</p>
<p>因为坚持时间比较长，<a href="http://wdxtub.lofter.com/" target="_blank" rel="external">我的博客</a>也慢慢积累了十万多粉丝，也认识了一批热爱文字，喜欢用笔尖思考的朋友，更重要的是使我能以他人的视角去看待问题。也曾受到 LOFTER 官方的推荐和转载，曾经（后来这个功能取消了）是『读书』分类下排在前十的『资深博客』。现在也会开始系列写作，把自己的想法组织成完整的观点，搭建一个整体框架来进行写作，比如下面的『人造系列』</p>
<ol>
<li><a href="http://wdxtub.com/2015/08/26/heroes-are-not-born/">人造英雄</a></li>
<li><a href="http://wdxtub.lofter.com/post/1a7a1d_5def559" target="_blank" rel="external">人造极简</a></li>
<li><a href="http://wdxtub.com/2015/02/06/manmade-peace/">人造定凝</a></li>
<li><a href="http://wdxtub.com/2015/01/31/manmade-speed/">人造速度</a></li>
<li><a href="http://wdxtub.com/2015/01/13/manmade-loss/">人造缺憾</a></li>
<li><a href="http://wdxtub.com/2015/01/05/manmade-startup/">人造创业</a></li>
<li><a href="http://wdxtub.com/2015/01/01/manmade-confidence/">人造自信</a></li>
<li><a href="http://wdxtub.com/2014/09/15/manmade-regret/">人造后悔</a></li>
</ol>
<h3 id="u6280_u80FD_u4E09_uFF1A_u601D_u8003"><a href="#u6280_u80FD_u4E09_uFF1A_u601D_u8003" class="headerlink" title="技能三：思考"></a>技能三：思考</h3><p>在前两个技能的基础上，以及非常幸运能获得高人点拨，慢慢也建立起自己的思考能力，从发现问题、观察问题、解决问题最后到寻找问题背后的核心，虽然现在还在努力练习，但是能感觉到自己走在正确的道路上。我觉得对于项目经理来说，思考是最重要的能力，因为很多时候需要从具体的细节中抽离出来，去寻找能把事情做得更好的方法，而思考就是找到这个宝藏的钥匙。希望能够在具体的工作中，不断应用和磨练自己的思考能力，站得更高，看得更远。</p>
<p>比方说最近看的《YC 创业课》与《穷查理宝典》，虽然仍旧未能完全领悟，但是也尽力从中汲取营养，<a href="http://wdxtub.com/2016/01/12/startup-and-investment/">《创业与投资》</a>这篇日志便是我的思考。</p>
<p>再比如我会以生活中的小事为引子深入思考，得到不一样的收获，把看似风马牛不相及的两个事情连接起来，<a href="http://wdxtub.com/2015/12/13/language-and-buybuybuy/">《学语言与买东西》</a>就是我从朋友的小举动中得到『无论是学语言还是买东西，如果从更高更长远的角度来看，都会得出和想当然完全不同的结论，年轻人应该努力去更高的地方看得更远，以发展的眼光看待问题。不管是什么事情，如果能从粒度和深度上细细考量，就会有不一样的答案』这样的结论。</p>
<h3 id="u6280_u80FD_u56DB_uFF1A_u6C9F_u901A"><a href="#u6280_u80FD_u56DB_uFF1A_u6C9F_u901A" class="headerlink" title="技能四：沟通"></a>技能四：沟通</h3><p>自己和其他同学相比最突出的可能就是沟通能力，我会尽力去争取机会做一些大家可能不会想到要去做的事来锻炼自己的沟通能力。我觉得这是作为项目经理非常重要的技能，双方互相理解的程度越高，事情就能办的越好。</p>
<p>我觉得自己给教授拜访朋友全程当口译的经历是一个非常好的锻炼，整个三天的双语互译给我带来了很大的震动，详情可以看<a href="http://wdxtub.com/2015/04/06/two-side/">《二向箔》</a>这篇日志，有几点结论我觉得还挺有意思的：</p>
<ol>
<li>从生活中学到的东西，才是最能运用到生活中去的。不要觉得说自己是学生，就下意识去逃避接触社会。如果担心自己表现得太糟糕，看书，能从别人的经验中学习。观察，总结，验证，慢慢去增长自己的阅历，渐渐开始有自己的理解和想法，这才是学习之道。</li>
<li>不同文化间的交流沟通，其实有点类似于自然界的生殖隔离，我给起了个名字叫文化隔离。具体指的是因为交流双方的文化不同，所处的位置，所站的立场不同，大部分沟通其实都停留在非常低层次的意义上(也就是事实类信息-吃了什么，最近怎么样)，而如果想要有更高层次的沟通，条件则严苛很多。一是对话双方至少要能达到较高的思想境界，二是作为中间人的口译着需要对于两种文化都有较深刻的认识。</li>
<li>比文化隔离低一些层次的隔离是教育隔离。不同于东西方差异，这种隔离更倾向于出现在同一个国家的人群中，因为受教育程度的不同，或者说受到的教育不同，使得不同人对身边世界的认知有着极大的差异，倘若对话双方都无法跳出原有思维进行更高层次的思考，恐怕盲人摸象，无言以对了。</li>
<li>文化隔离和教育隔离并不是不能解决的，至少只要双方达到标准，或者有一个合适的桥梁，就能够很大程度消除这种隔离。最为严重的一种隔离是心智隔离，一旦对话双方有心智隔离，这样的对话几乎很难有任何有意义的产出。心智隔离的产生是一个长期的过程，大量的阅读、思考和写作会有一定程度的帮助，但是从我的角度看来，一旦出现心智隔离，那么也许放弃治疗是最好的选择。</li>
</ol>
<h3 id="u6280_u80FD_u4E94_uFF1A_u7F16_u7A0B"><a href="#u6280_u80FD_u4E94_uFF1A_u7F16_u7A0B" class="headerlink" title="技能五：编程"></a>技能五：编程</h3><p>因为项目经理还需要参与技术，有扎实的技术背景，尤其是了解不同技术内在的本质及原理是非常重要的。在 CMU 学习的课程上至最火热的云计算与计算机视觉，下至汇编 C 语言与基本的硬件原理，再加上机器学习的相关知识以及软件架构的的具体应用，我对整个计算机学科有了更加深入和全面的的认识，我觉得这对于一个项目经理来说是非常重要的，尤其是在理解客户需求，转换成具体的功能上时，经过长期系统训练所得到的『直觉』会很有帮助。</p>
<p>最近我也在努力把正在学和已经学习的知识以课程笔记的形式分享出来，一是加深自己的理解，二是让更多的人能接触到高质量的中文资源。包括：</p>
<ul>
<li>云计算</li>
<li>深入理解计算系统(CSAPP)</li>
<li>软件架构与设计</li>
<li>并发编程</li>
<li>计算机学科基础知识</li>
<li>计算机相关工具指南</li>
<li>数据结构与算法</li>
<li>等等</li>
</ul>
<p>具体的列表可以参加<a href="http://wdxtub.com/about/">这里</a>，相信通过这种方式，不但自己的学习更扎实，也能把知识分享出去。我觉得这种开放和共赢的心态，对于一个项目经理也是非常重要的。</p>
<p>我也整理出了自己的历年来比较完整的项目作为<a href="http://wdxtub.com/portfolio/">作品集</a>，会比简历中说明得更加清晰。</p>
<h2 id="u7231_u597D"><a href="#u7231_u597D" class="headerlink" title="爱好"></a>爱好</h2><p>日常生活中我的兴趣爱好从某种程度来说也有助于我胜任项目经理这个职位。</p>
<ul>
<li>旅行<ul>
<li>去过除大西部外的大部分省份，在不同的环境中学习如何跟各行各业的人打交道</li>
<li>知道在什么情况下应该跟什么人怎么样说话</li>
</ul>
</li>
<li>运动<ul>
<li>日常长跑，在寻找与突破自己的生理极限中，更加深入理解自己</li>
<li>不断磨练自己的意志力，即使遇到困难也要尽力把事情坚持下去</li>
</ul>
</li>
</ul>
<h2 id="u957F_u5904"><a href="#u957F_u5904" class="headerlink" title="长处"></a>长处</h2><p>除了前面提到的技能，我还有下面一些特质让我能够胜任各项工作</p>
<ul>
<li>坚持<ul>
<li>遇到困难不会轻易放弃，而是从不同的失败中利用排除法摸索出正确的道路</li>
<li>即使犯了错误也能很快从打击中恢复，屡败屡战，朝抵抗力最大的路径走</li>
</ul>
</li>
<li>不好面子<ul>
<li>意识到自己弄错了会立刻承认，不会觉得丢面子，把事情做好才是最重要的</li>
<li>不会好大喜功，更愿意让真正做出贡献的人得到超出其预期的所得</li>
</ul>
</li>
<li>乐于分享<ul>
<li>希望能有更多高质量的中文资源被创造出来（也是为什么坚持写博客的原因）</li>
<li>共同进步，水涨船高，自己的水平是身边五个人的平均水平</li>
</ul>
</li>
</ul>
<h2 id="u77ED_u5904"><a href="#u77ED_u5904" class="headerlink" title="短处"></a>短处</h2><p>当然，也有一些日常工作学习逐渐累积下来的缺点</p>
<ul>
<li>有时过分相信自己的直觉<ul>
<li>应该从直觉开始，用数据和证据来验证自己的想法，而不是故意『凑』结论</li>
</ul>
</li>
<li>有时会比较固执<ul>
<li>应该更多接触不同的思维模型，尝试从不同角度去理解可能看起来『不太靠谱』的想法，并以此为基础共同讨论出最合理的方案</li>
</ul>
</li>
</ul>
<h2 id="u5199_u5728_u6700_u540E"><a href="#u5199_u5728_u6700_u540E" class="headerlink" title="写在最后"></a>写在最后</h2><p>以上就是我的职业规划和自己为什么想做，为什么能胜任项目经理这一职位的想法，可能有点啰嗦，但的确是希望能尽可能展示自己，希望能有机会进行进一步的沟通交流。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇文章，<a href="http://wdxtub.com/2016/03/04/na-job-soft-skill/">北美找工作软实力指南</a>中提到了给自己定位的分析与思考方法，这里以自己为例子，来看看如何更好地找到自己并展示自己。</p>]]>
    
    </summary>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="自我" scheme="http://wdxtub.com/tags/%E8%87%AA%E6%88%91/"/>
    
      <category term="软实力" scheme="http://wdxtub.com/tags/%E8%BD%AF%E5%AE%9E%E5%8A%9B/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo 主题 Maupassant 换图标教程]]></title>
    <link href="http://wdxtub.com/2016/03/05/maupassant-icon-config/"/>
    <id>http://wdxtub.com/2016/03/05/maupassant-icon-config/</id>
    <published>2016-03-05T17:08:20.000Z</published>
    <updated>2016-03-05T20:40:37.000Z</updated>
    <content type="html"><![CDATA[<p>折腾主题恐怕是搭建独立博客最痛并快乐的事情了。尤其是对我这种前端菜鸟来说，很多东西明明知道对应资源文件在哪里，却愣是不知道从何下手。今天我们说说，如何给 Hexo 主题 maupassant 换上自己喜欢的图标。</p>
<a id="more"></a>
<hr>
<p>使用 Hexo 以来，换过不少主题，不想用太『大众』的，『小众』的却往往文档不全想改也不知道从何下手。寻寻觅觅，总算找到了一个心仪的 —— <a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="external">Maupassant</a>（这里我用的是 tufu9441 个人定制的版本，也有两百多个 star 了，赞）。只因介绍中的一句话：</p>
<blockquote>
<p>大道至简</p>
</blockquote>
<p>整个博客非常简洁干净，虽然还有一些我觉得不是很满意的地方，不过暂时来说是小问题，我可以一边学一边改。目前来说，整体效果是这样的：</p>
<p><img src="/images/14572005603940.jpg" alt="整体效果"></p>
<p>接下来就是重点了，不同栏目的的图标（就是技术、生活、作品等）是我一直想定制的，其实文档里也给出了具体的方法和资源地址，可惜我不懂前端，看着也还是不会。隔一段时间总要试一试，屡败屡战，终于没有苦劳也有疲劳，算是弄清楚的怎么换图标。</p>
<p>其实思路也不难，就是先生成对应的图标，然后想办法在网页中显示出来，但是这着实让我摸索了一段时间。</p>
<p>第一步，到 <a href="https://icomoon.io/" target="_blank" rel="external">IcoMoon</a> 的网站中，点击右上角的 <a href="https://icomoon.io/app/#/select" target="_blank" rel="external">IcoMoon App</a>，然后就可以来到下面的图标选择页面：</p>
<p><img src="/images/14572008612929.jpg" alt="图标选择页面"></p>
<p>选择你喜欢的图标，然后点击右边的 Generate Font（我之前就一直以为是左边的 SVG 什么的，所以死活不成功），就会出现一个给你改名字的机会（这也就是对应生成的索引信息）</p>
<p><img src="/images/14572011524694.jpg" alt=""></p>
<p>然后再点击下载，正常情况下就可以了，下载之后就会得到这样一个文件夹：</p>
<p><img src="/images/14572009951366.jpg" alt=""></p>
<p>我们来比较一下 maupassant 主题的结构：</p>
<p><img src="/images/14572010529465.jpg" alt=""></p>
<p>发现了！都有 fonts 这个文件夹！里面的文件还一样，所以二话不说，赶紧复制粘贴过去，然后对应修改主题的配置文件（注意 icon 为前缀的图标名称）</p>
<p><img src="/images/14572012141830.jpg" alt=""></p>
<p>结果发现并没有用，甚至原来可以的都显示不出来了，但是发生了一个奇怪的现象，有一个图标能显示，但是错乱了位置，于是我猜想，肯定是哪里需要索引这些文件。再看看下载得到的 icomoon 文件夹中有一个 style.css，发现里面有这么一段：</p>
<p><img src="/images/14572013574673.jpg" alt="下载得到的 style.css"></p>
<p>于是一顿搜索，在 maupassant 主题的 style.scss 文件中也找到了类似的行，于是直接把整段复制过去。再部署，就可以看到效果啦！</p>
<p><img src="/images/14572015499052.jpg" alt=""></p>
<p>万万没想到原来这么简单，也要感谢这次尝试失败后的『灵机一动』，也因此找到了正确的用法。最后说一下选择这些图标的原因吧：</p>
<ul>
<li>首页：小房子的图标，基本是通用惯例了</li>
<li>技术：插电的图标，提醒自己要不断充电</li>
<li>生活：吃豆人的图标，提醒自己生活就是吃一个豆子再吃另一个，有些豆子会给自己不一样的力量</li>
<li>作品：无限的图标，激励自己要不停创造完整的作品</li>
<li>归档：软盘的图标，复古风，有保存的意思，也向上古和中古时代的程序员致敬</li>
<li>订阅：RSS 的图标，也算是惯例了</li>
</ul>
<p>希望以后能把自己的博客改得越来越好，虽然自己依然在纷繁的前端技术中找不到方向。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>折腾主题恐怕是搭建独立博客最痛并快乐的事情了。尤其是对我这种前端菜鸟来说，很多东西明明知道对应资源文件在哪里，却愣是不知道从何下手。今天我们说说，如何给 Hexo 主题 maupassant 换上自己喜欢的图标。</p>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://wdxtub.com/tags/Hexo/"/>
    
      <category term="icomoon" scheme="http://wdxtub.com/tags/icomoon/"/>
    
      <category term="主题" scheme="http://wdxtub.com/tags/%E4%B8%BB%E9%A2%98/"/>
    
      <category term="图标" scheme="http://wdxtub.com/tags/%E5%9B%BE%E6%A0%87/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Programming iOS9 学习笔记 10 - Text]]></title>
    <link href="http://wdxtub.com/2016/03/05/programming-ios9-translation-10/"/>
    <id>http://wdxtub.com/2016/03/05/programming-ios9-translation-10/</id>
    <published>2016-03-05T12:07:13.000Z</published>
    <updated>2016-03-05T14:34:48.000Z</updated>
    <content type="html"><![CDATA[<p>几乎所有的应用都需要显示文字，iOS 以简单的方式提供了强大且复杂的文字显示功能，很多时候我们只需要指定文字内容即可，这一章我们来看看 Text 的相关内容。</p>
<a id="more"></a>
<hr>
<p>Text 形式主要有两种：<code>NSString</code> 和 <code>NSAttributedString</code>，后者可以设定不同的风格，比如字符、段落、行距等等。具体显示只需要在 graphics context 上绘制，或者交给知道如何去绘制的对象：</p>
<p><img src="/images/14571810008511.jpg" alt=""></p>
<p>所有的文本绘制依赖于底层的 C API(<code>Core Text</code>)，不过现在 iOS 提供 <code>Text Kit</code> 使我们可以很方便的来进行操作。另一个绘制文字的方法是使用 web view，比方说 PDF, RTF, DOC 什么的。</p>
<h2 id="Fonts_and_Font_Descriptors"><a href="#Fonts_and_Font_Descriptors" class="headerlink" title="Fonts and Font Descriptors"></a>Fonts and Font Descriptors</h2><p>描述字体的方式有两种</p>
<ol>
<li><code>UIFont</code>：用于 <code>NSString</code> 或 UIKit 对象</li>
<li><code>CTFont</code>：用于 Core Text</li>
</ol>
<p>iOS 7 之前这俩居然协同起来不大方便，比方说要做一些变换，先要从 <code>UIFont</code> 换成 <code>CTFont</code>，然后在手动切换回来，不过现在已经没有这个问题了。另外一个比较重要的是 <code>CTFOntDescriptor</code>，在做 font transformation 的时候很有用。</p>
<p>字体是非常简单的对象，在初始化的时候可以指定名称和大小 <code>init(name:size:)</code>。下面的方法可以得到所有已安装字体的名字：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIFont</span>.familyNames().<span class="built_in">map</span> &#123;<span class="type">UIFont</span>.fontNamesForFamilyName($<span class="number">0</span>)&#125;</span><br><span class="line">    .forEach &#123;(n:[<span class="type">String</span>]) <span class="keyword">in</span> n.forEach &#123;<span class="built_in">print</span>($<span class="number">0</span>)&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>系统字体可以通过 <code>systemFontOfSize:weight:</code> 来访问，weight 具体就是一个 <code>CGFloats</code>，如下：</p>
<p><img src="/images/14571820299805.jpg" alt=""></p>
<p><img src="/images/14571820506614.jpg" alt=""></p>
<h3 id="u52A8_u6001_u5B57_u4F53_u7C7B_u578B"><a href="#u52A8_u6001_u5B57_u4F53_u7C7B_u578B" class="headerlink" title="动态字体类型"></a>动态字体类型</h3><p>使用动态字体，用户可以在设置中更改字体的大小，对于不同的字体，我们不需要指定具体的大小，而是调用 <code>UIFont</code> 的 <code>preferredFontForTextStyle:</code>，可能的参数有：</p>
<p><img src="/images/14571823862991.jpg" alt=""></p>
<p><img src="/images/14571824014617.jpg" alt=""></p>
<p>为了能够根据用户的设置改变字体大小，需要注册 <code>UIContentSizeCategoryDidChangeNotification</code>，另外在字体大小变化的时候可能需要界面的改动，这时候 autolayout 就很有用了。下面是一个具体的例子，我们根据用户的设置来改变字体大小：</p>
<p><img src="/images/14571825459558.jpg" alt=""></p>
<p><img src="/images/14571825561811.jpg" alt=""></p>
<p>从 iOS 8 开始，<code>UITableView</code> 会依照设定自动更新而不用做这么多额外的工作</p>
<h3 id="u6DFB_u52A0_u5B57_u4F53"><a href="#u6DFB_u52A0_u5B57_u4F53" class="headerlink" title="添加字体"></a>添加字体</h3><p>有两种方法可以添加字体：</p>
<p><img src="/images/14571827009066.jpg" alt=""></p>
<p>如果要实时下载的话，需要 <code>import CoreText</code> 并且调用 <code>CTFontDescriptorMatchFontDescriptorsWithProgressHandler</code>（应该被放到后台线程），下面是一个具体的例子：</p>
<p><img src="/images/14571828209821.jpg" alt=""></p>
<p>这里注意，<code>print</code> 不是线程安全的，所以我们使用 <code>NSLog</code>。</p>
<p>Font Descriptors 部分内容比较基础，不懂时可以看看官方文档，这里略过</p>
<h2 id="Attributed_Strings"><a href="#Attributed_Strings" class="headerlink" title="Attributed Strings"></a>Attributed Strings</h2><p><img src="/images/14571829592932.jpg" alt=""></p>
<p>一个 <code>NSAttributedString</code> 包含 <code>NSString</code> 和对应的属性，比较重要的有：</p>
<p><img src="/images/14571830030382.jpg" alt=""></p>
<p><img src="/images/14571830182091.jpg" alt=""></p>
<p><img src="/images/14571830302896.jpg" alt=""></p>
<p><img src="/images/14571830444900.jpg" alt=""></p>
<p>构造 <code>NSAttributedString</code> 时，如果整个字符串的 attributes 相同的话可以使用 <code>init(string:attributes:)</code>，不然的话就使用 <code>NSMutableAttributedString</code>，这个类中我们可以具体设置不同 attributes 的范围。如果是段落属性的话则用 <code>NSParagraphStyle</code>。这俩都自带默认值，所以我们只需要设置关心的 attributes 就好。</p>
<p>我们来看一个具体的例子：</p>
<p><img src="/images/14571833506635.jpg" alt=""></p>
<p>如果我们想要让整一段居中的话，可以用如下的代码（注意 <code>firstLineHeadIndent</code> 需要单独设置）</p>
<p><img src="/images/14571834084982.jpg" alt=""></p>
<p><img src="/images/14571834298856.jpg" alt=""></p>
<p>再来一个例子，如果我们想让第一个字符变大的话，可以这么做：</p>
<p><img src="/images/14571834716206.jpg" alt=""></p>
<p>效果如下：</p>
<p><img src="/images/14571834811712.jpg" alt=""></p>
<p>但是可以看到第三行中缩进去了一块，我们可以用下面的代码来让它更好看一些：</p>
<p><img src="/images/14571835497442.jpg" alt=""></p>
<p>效果如下：</p>
<p><img src="/images/14571835610156.jpg" alt=""></p>
<p>最后是把两个效果合并起来的样子：</p>
<p><img src="/images/14571836150901.jpg" alt=""></p>
<p><strong>Tab stops</strong></p>
<p>有的时候我们还需要使用制表符，那么可以使用 <code>NSTextTab</code>，下面之际上例子（可以看到是按照小数点对齐的）：</p>
<p><img src="/images/14571839916429.jpg" alt=""></p>
<p><strong>Text attachments</strong></p>
<p>实际上就是内联的图像，使用图片数据来初始化 <code>NSTextAttachment</code> 即可，再来看一个例子：</p>
<p><img src="/images/14571840929748.jpg" alt=""></p>
<p>效果如下</p>
<p><img src="/images/14571841032318.jpg" alt=""></p>
<p><strong>从文件导入</strong></p>
<p>我们也可以直接从诸如 RTF 文件中直接导入格式，就不用在代码里设置这么麻烦了，比如：</p>
<p><img src="/images/14571844313983.jpg" alt=""></p>
<h3 id="Modifying_and_Querying_an_Attributed_String"><a href="#Modifying_and_Querying_an_Attributed_String" class="headerlink" title="Modifying and Querying an Attributed String"></a>Modifying and Querying an Attributed String</h3><p>基本的字符串操作也是支持的，也可以根据需要自定义每个字符的属性</p>
<p><img src="/images/14571845719969.jpg" alt=""></p>
<p>当然，我们也可以不用内置的控件，直接绘制文字，如：</p>
<p><img src="/images/14571846456322.jpg" alt=""></p>
<p>在这个例子中，直接把文字绘制到了图片的 context 中。同理，我们也可以直接在 UIView 的 <code>drawRect:</code> 方法中绘制，如：</p>
<p><img src="/images/14571847058762.jpg" alt=""></p>
<p>我们也可以用类似 <code>boundingRectWithSize:options:context:</code> 这样的方法来测量具体的大小，这里注意 <code>.UsesLineFragmentOrigin</code> 的设置，不然得到的值会非常小，获取到的高度可能带有小数部分，注意向上取整。</p>
<h2 id="Labels"><a href="#Labels" class="headerlink" title="Labels"></a>Labels</h2><p>对于 UILabel，<code>numberOfLines</code> 属性非常重要（配合上 line breaking 和 resizing），Line breaking 的一些规则如下：</p>
<p><img src="/images/14571849774329.jpg" alt=""></p>
<p><img src="/images/14571850016896.jpg" alt=""></p>
<p>要让 label 的文字自动适应长宽调整的大小的话，在代码中设置 <code>sizeToFit</code> 即可。</p>
<h2 id="Text_Fields"><a href="#Text_Fields" class="headerlink" title="Text Fields"></a>Text Fields</h2><p>这部分的内容比较基础，倒是跟文本框相关的另一个问题比较重要，就是怎么处理键盘。比方说可能遮挡内容，或者输入完成后如何让键盘消失。</p>
<p>但其实机制还是很简单的：</p>
<p><img src="/images/14571854772650.jpg" alt=""></p>
<p>所以实际上只要修改 first responder 的状况即可：</p>
<p><img src="/images/14571855137876.jpg" alt=""></p>
<p>奇怪的是，我们其实没办法很方便知道哪个 view 是 first responder。倒是有一个 <code>isFirstResponder</code> 方法来检测，不过这就意味着我们需要遍历所有 view 才能确定。一个方法是事先保存好谁是 first responder，一般在 text field 的 <code>textFieldDidBeginEditing:</code> 中设置。</p>
<p>如果想让用户在输入完成后按回车去掉键盘的话，可以重写 text field 的代理方法，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">textFieldShouldReturn</span><span class="params">(tf: UITextField)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    tf.resignFirstResponder()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Keyborad_Covers_Text_Field"><a href="#Keyborad_Covers_Text_Field" class="headerlink" title="Keyborad Covers Text Field"></a>Keyborad Covers Text Field</h3><p>处理键盘遮挡的时候，以下的通知会很有用：</p>
<p><img src="/images/14571860606126.jpg" alt=""></p>
<p>在 iPad 上因为键盘还可以分离，所以会有另外两个通知</p>
<p><img src="/images/14571861165823.jpg" alt=""></p>
<p>通知中的 <code>userInfo</code> 字典包含各类信息，如：</p>
<p><img src="/images/14571861447808.jpg" alt=""></p>
<p>具体来说，可以根据不同的界面风格，来选择如何处理遮挡问题，我们可以</p>
<ol>
<li>Sliding the interface，也就是整个界面往上飞</li>
<li>直接改变 frame 的大小</li>
</ol>
<p>具体的代码这里略过，注意保证应用中的处理方式比较一致即可</p>
<h3 id="Configuring_the_Keyborad"><a href="#Configuring_the_Keyborad" class="headerlink" title="Configuring the Keyborad"></a>Configuring the Keyborad</h3><p>可以定制键盘，加入一些额外的功能</p>
<p><img src="/images/14571864352162.jpg" alt=""></p>
<p>具体的做法是在键盘上添加一个 <code>inputAccessoryView</code>，然后就可以在之中做不同的操作了：</p>
<p><img src="/images/14571864705916.jpg" alt=""></p>
<p>比方说，有些键盘类型没有返回按键，这时候我们就需要自己来了。</p>
<p>iOS9 中，我们可以添加 bar button（<code>inputAssistantItem</code>，针对 iPad），比方说我们可以用如下代码添加一个照相机的按钮：</p>
<p><img src="/images/14571865845732.jpg" alt=""></p>
<h3 id="Text_Field_Delegate_and_Control_Event_Messages"><a href="#Text_Field_Delegate_and_Control_Event_Messages" class="headerlink" title="Text Field Delegate and Control Event Messages"></a>Text Field Delegate and Control Event Messages</h3><p>这里我们大概了解下相关的代理方法：</p>
<p><img src="/images/14571866342387.jpg" alt=""></p>
<p>比方说，我们可以只让用户输入小写字母，如下：</p>
<p><img src="/images/14571866536210.jpg" alt=""></p>
<p><img src="/images/14571866843681.jpg" alt=""></p>
<p>我们同样也可以在不同的时候给 text field 加上不同的 target-action 操作</p>
<p><img src="/images/14571867374814.jpg" alt=""></p>
<p>比方说，可以用下面的技巧，不写代码（或者很少代码）来让键盘自动消失：</p>
<p><img src="/images/14571868075239.jpg" alt=""></p>
<p>用户双击或者长按 text field 的时候，会出现菜单，比较常见的操作有：</p>
<p><img src="/images/14571869442936.jpg" alt=""></p>
<p>我们也可以自定义不同的菜单，加上对应的操作，具体这里不赘述</p>
<h2 id="Text_Views"><a href="#Text_Views" class="headerlink" title="Text Views"></a>Text Views</h2><p>Text View 和 text field 很类似，是一个 scroll view 的子类，但不是一个 control：</p>
<p><img src="/images/14571871067875.jpg" alt=""></p>
<p><img src="/images/14571871132224.jpg" alt=""></p>
<p>text view 的代理方法和通知同样和 text field 很类似：</p>
<p><img src="/images/14571871588928.jpg" alt=""></p>
<p>但是也有一些不同：</p>
<p><img src="/images/14571871701897.jpg" alt=""></p>
<p><img src="/images/14571871838313.jpg" alt=""></p>
<h2 id="Text_Kit"><a href="#Text_Kit" class="headerlink" title="Text Kit"></a>Text Kit</h2><p>在 <code>UITextView</code> 中可以直接访问 Text Kit 引擎，如：</p>
<p><img src="/images/14571879660310.jpg" alt=""></p>
<p>具体包括：</p>
<p><img src="/images/14571879856074.jpg" alt=""></p>
<p>具体有很多技巧，可以做出很浮夸的效果，以后专门写一篇，这里不深入了。</p>
<p>其实不需要 Text view 也可以使用 Text Kit，同样是直接绘制的方式。这部分内容还是需要更多的实践，后面会出实例教程的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>几乎所有的应用都需要显示文字，iOS 以简单的方式提供了强大且复杂的文字显示功能，很多时候我们只需要指定文字内容即可，这一章我们来看看 Text 的相关内容。</p>]]>
    
    </summary>
    
      <category term="Text" scheme="http://wdxtub.com/tags/Text/"/>
    
      <category term="iOS9" scheme="http://wdxtub.com/tags/iOS9/"/>
    
      <category term="学习" scheme="http://wdxtub.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://wdxtub.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[北美找工作软实力指南]]></title>
    <link href="http://wdxtub.com/2016/03/04/na-job-soft-skill/"/>
    <id>http://wdxtub.com/2016/03/04/na-job-soft-skill/</id>
    <published>2016-03-04T22:34:02.000Z</published>
    <updated>2016-03-05T02:22:39.000Z</updated>
    <content type="html"><![CDATA[<p>在北美找工作，除了基本的『硬实力』外，很多文化相关的『软实力』可能也起到了至关重要甚至是决定性的作用，这里总结了我在 CMU 研讨班学到的相关知识，希望能给还在努力『揾食』的同学们一些帮助。</p>
<a id="more"></a>
<hr>
<h2 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文的主要内容，来自于 ICC(Intercultural Communication Center) 关于找工作面试的讲义以及老师在研讨班上的讲解。上一次的学习记录在 <a href="http://wdxtub.com/2016/02/23/pronunciation-stress/">英语口语中的『噪声』</a> 一文中。</p>
<p>开始之前，一定要先摆正心态，之所以把这一点特别拿出来说明，因为我深知我们的文化中包含着的对『野路子草根逆袭』的『倾向』（比如说，对太平天国的『评价』）。但是至少在找工作这件事情上，有没有受过培训，有没有去刻意练习，身经百战的面试官肯定是能一眼看出来的。这里说的培训，主要指的是，在从学校过渡到社会的过程中，有没有针对性去进行职业态度的培训。从衣着仪态，到礼节谈吐，最后到对自己的认知，都是题中之义。当然，不可否认有些人天赋异禀，不需要太多训练就可以自然切换到『职业』模式，但是对于更多的人来说，参加不同的研讨班，有针对性地打磨自己的各项『软实力』，从依赖直觉（可能是天赋，也可能是幻想出来的）逐渐变成依赖技能，才是稳扎稳打的选择。</p>
<p>美国的学生从高中起就会开始做性格评估以寻找自己可能适合的工作，并且在找工作找实习的时候会花大量的时间上培训班，进行刻意练习。我们作为『外国人』，本身在语言和文化适应性上就差了一截，更应该花时间去认真打造自己的软实力，善于利用各种专业资源（研讨班，职业发展中心等等）来快速提高自己。闭门造车后『一鸣惊人』需要的天资和努力远超大部分人想象，还是不断在实践中提高自己比较靠谱（或者直接可以说，软实力闭门造车没用，因为最终还是需要根据实际来调整）。</p>
<p>另外，其实不存在某个『准备好了』的时间点，做任何事情（不只是找工作），我们都应该好好评估自己之前的经验，试着让下一次比上一次更好，用发展的眼光看问题，也许才是找到最终答案的『捷径』。</p>
<p>举个例子，CMU 定期有各种各样的培训班，细致到找工作的每一个环节，比如：</p>
<ul>
<li>推荐信是什么，应该怎么写</li>
<li>面试应该穿什么</li>
<li>面试过程中的仪态应该怎么样</li>
<li>作为打开话题的 Small Talk 应该怎么说</li>
<li>怎么样自我介绍</li>
<li>在边吃饭边面试的场景中，应该如何表现</li>
<li>如何利用所谓的『关系』</li>
<li>如何回答某些『常规』问题</li>
</ul>
<p>这些东西如果要自己模式，恐怕要花费大量的时间和精力，为什么不利用好学校的资源，去『武装』一下自己呢？（很多同学眼里只有刷题却不去准备自己的软实力，就属于看起来感动自己的勤奋却没多少功效的战术勤奋战略偷懒）</p>
<p>虽然很多东西无法『训练』出来，毕竟江山易改本性难移，但是我们至少可以变得更有『职业素养』一些。</p>
<h2 id="u95EE_u95EE_u81EA_u5DF1"><a href="#u95EE_u95EE_u81EA_u5DF1" class="headerlink" title="问问自己"></a>问问自己</h2><ul>
<li>What expectations/concerns do you have about job interviewing in the US?</li>
<li>Think about the kind of job you might look for. Be <strong>specific</strong>: job title, company, location, type, etc</li>
<li>Highlight your skills in relation to the job listed above</li>
<li>What are your strengths in relation to this job</li>
<li>What are your weaknesses</li>
<li>What are your <strong>short-term</strong> career goals</li>
<li>What are your <strong>long-term</strong> career goals</li>
</ul>
<p>这些问题其实一点都不好回答，无论是『找到自己』还是『认识自己』都是非常艰难的，但是不去找，就肯定找不到。</p>
<p>不过还是可以给出一点我自己的经验，多去试试，不知道自己想要什么，那么就不如排除法，看看自己不喜欢什么（这个一般比较容易感觉出来），慢慢就能找到方向了。</p>
<h2 id="u8F6F_u5B9E_u529B_u8981_u70B9"><a href="#u8F6F_u5B9E_u529B_u8981_u70B9" class="headerlink" title="软实力要点"></a>软实力要点</h2><ul>
<li>Highlight your skills and experience (not the time to be modest - you have to “sell yourself”)</li>
<li>Demonstrate cultrually appropriate trait, e.g. assertiveness, awareness of strengths and goals</li>
<li>Use “small talk” to show your social and cultural expertise</li>
<li>Communicate with non-verbal aspects of the interview: dress, handshakes, eye-contact, posture</li>
<li>Make use of the “networking” connections that are acceptable in the United States</li>
<li>Respond to the kinds of questions asked in US interviews</li>
</ul>
<p>下面是具体的要点叙述，篇幅所限不展开了（硬广：如果需要具体情况具体分析，欢迎来请我吃饭）</p>
<h3 id="Self_Promotion"><a href="#Self_Promotion" class="headerlink" title="Self Promotion"></a>Self Promotion</h3><ul>
<li>Assertiveness</li>
<li>Confidence in openly discussing goals and accomplishments</li>
<li>Follow-up(thank you notes, phone inquiries)</li>
<li>Appropriate dress</li>
</ul>
<p>不止要说自己的优点，还要用具体的事例证明，学会讲故事（不会讲故事的创业公司都死了）</p>
<p>如果可能，thank you note，一是表示态度，二是补充信息，充分展示自己</p>
<h3 id="Directness_in_Communication"><a href="#Directness_in_Communication" class="headerlink" title="Directness in Communication"></a>Directness in Communication</h3><ul>
<li>Open and direct responses to questions</li>
<li>Eye contact, relaxed posture and appropirate non-verbal behavior</li>
</ul>
<p>有啥说啥，明确说出来，比方说口音，或者语速，直接自己听不清楚，请求说清晰一点或慢一点</p>
<h3 id="Self-Disclosure"><a href="#Self-Disclosure" class="headerlink" title="Self-Disclosure"></a>Self-Disclosure</h3><ul>
<li>Personal descriptions of experiences, hobbies, strengths and weaknesses</li>
<li>Related answer to personality (e.g., leadership style, problem solving abilities)</li>
</ul>
<p>可以说兴趣爱好，但是要说明这些兴趣爱好给你带来了什么，对具体的工作有什么帮助。</p>
<p>想想产品发布会时候的用词和感觉。</p>
<p>是否了解自己，通过缺点和优点两个不同的视角来观察。</p>
<h3 id="Career_goals"><a href="#Career_goals" class="headerlink" title="Career goals"></a>Career goals</h3><ul>
<li>Demonstrating knowledge of self, career goals, and how they relate to this job</li>
<li>Discussion of long-range career plans</li>
</ul>
<p>什么都想做，就什么都做不好。</p>
<p>真的需要好好想这个问题</p>
<h3 id="Informality_of_Interview_Process"><a href="#Informality_of_Interview_Process" class="headerlink" title="Informality of Interview Process"></a>Informality of Interview Process</h3><ul>
<li>Congenial interviewing environment that encorages openness, some joking and exchange of information</li>
</ul>
<p>具体的语境切换，俗称『阅读空气』</p>
<h3 id="Individual_Equality"><a href="#Individual_Equality" class="headerlink" title="Individual Equality"></a>Individual Equality</h3><ul>
<li>Race, sex, age should not affect relationship</li>
</ul>
<p>我的建议是，最好彼此都抽离成一个无性别无年龄无人种的『综合个体』来进行交流</p>
<h3 id="Preparation_about_Organization"><a href="#Preparation_about_Organization" class="headerlink" title="Preparation about Organization"></a>Preparation about Organization</h3><ul>
<li>Obtain as much information as possible about job and organization</li>
<li>Demonstrate awareness in letters and in interview</li>
</ul>
<p>看起来要专业，形式影响心态，不要太随便，心态上认真。比如说即使是电话面试，事先准备好仪容仪表也是一个很好的热身。</p>
<h2 id="u5E38_u89C1_u95EE_u9898_u53CA_u89E3_u7B54"><a href="#u5E38_u89C1_u95EE_u9898_u53CA_u89E3_u7B54" class="headerlink" title="常见问题及解答"></a>常见问题及解答</h2><p>下面是面试中经常会出现的问题，准备好对应的故事来『证明』自己，尤其是后面几条 yes/no 的问题，千万不能说个答案（虽然通常肯定要答 yes）然后开始『谜之沉默』，要抓住机会展示自己。</p>
<p>留意下面问题中面试官可能想要听到的你的特质：</p>
<ul>
<li>Tell me about yourself</li>
<li>What are your major strengths</li>
<li>What are your major weakness</li>
<li>What are your short-range objectives</li>
<li>What are your career objectives</li>
<li>What was the last book you read?</li>
<li>If you could start again, what would you do differently? (Note: you cannot say “nothing”)</li>
<li>What interests you most about the position we have? What interests you least?</li>
<li>Why weren’t your grades better? or why haven’t you obtained a job so far? (Note: do not be defensive; this may be a test of your ability to handle pressure or to analyze your own situation)</li>
<li>What if you were in charge of this (company, research group, department)? Why should we hire you?</li>
</ul>
<p>注意拓展这些 yes/no 问题：</p>
<ul>
<li>Can you work under pressure</li>
<li>Are you a leader</li>
<li>Are you creative</li>
<li>Can you work as a member of a team</li>
</ul>
<p>所有的问题，可以记住关键词，但是整个叙述过程一定要自然，不要背课文。这里举一个例子，比如说面试官问 “Can you work under pressure?”，可以这么回答：</p>
<p>我可以承受压力，你知道在 CMU 期末考试压力非常大（可以具体渲染下如何压力大），但是我还是分配好了时间并得到高分，我觉得这是一个能抗压的表现。</p>
<p>其他的都可以按照这个思路回答。</p>
<h3 id="Small_Talk"><a href="#Small_Talk" class="headerlink" title="Small Talk"></a>Small Talk</h3><p>就是日常开启话题的闲聊，展示基本的社交能力，要注意像乒乓球，有来有回，不要出现『这话我没法接』的情况，具体怎么聊天，又是另一个话题，有空我再说。</p>
<ul>
<li>随口吹水的话题<ul>
<li>天气、居住城市、墙上的作品或者照片、共同兴趣、体育、旅行</li>
</ul>
</li>
<li>绝对不要提的话题<ul>
<li>年龄、宗教、政治、钱、婚姻状况</li>
</ul>
</li>
</ul>
<h2 id="u6700_u540E_u8BF4_u4E24_u53E5"><a href="#u6700_u540E_u8BF4_u4E24_u53E5" class="headerlink" title="最后说两句"></a>最后说两句</h2><p>其实上面任何一个小点都可以展开成一个很大的话题，这里简单举几个例子：</p>
<ul>
<li>仪容仪表<ul>
<li>男生，领带最好不要是红色(aggressive)，蓝色是比较安全的选择（体现团队合作）</li>
<li>女生，千万不要喷香水</li>
<li>穿正装不要穿白袜子</li>
<li>具体可以看看最近美国大选不同竞选人是怎么穿着，以及如何搭配他们对应的竞选风格的</li>
<li>一本书《Dress for Success》</li>
</ul>
</li>
<li>握手要坚定用点力，不过目的不是捏爆别人的手</li>
<li>上面提到的要求很多是有文化冲突的，也就是在美国大家习惯这样，可能在中国是另一套；我们需要意识到这种差别，但是千万不要矫枉过正，尽可能还是要按照自己舒服的方式来表现</li>
<li>守时！有些同学迟到半个小时，老师直接跟他们说 “too late to join”，我觉得这种惩罚方式很好，既然约定好了，就不要浪费大家的时间，或者把自己的话当放屁</li>
</ul>
<p>最后祝愿大家都能找到心仪的工作，贴一段我之前周记里写的话作为结束：</p>
<blockquote>
<p>找工作与其说是找一份工作，不如说是找到自己适合什么工作，化简一下就是找到自己。在不断的测试中了解自己擅长什么，喜欢什么，想要什么，这个很关键。具体到刷题之类的东西，其实是个人努力，有一个基准线在那里，过了就好。我想做什么工作，你能提供什么职位，这两个有多匹配，能不能接受，能接受咱们继续，不行就好聚好散。选择工作就是选择环境，不要被各种乱七八糟的光环亮瞎了双眼，还是那句话，要有自己的判断和选择，不能『随大流』。</p>
</blockquote>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.howtodothings.com/how-to-make-small-talk-during-a-job-interview" target="_blank" rel="external">How To Make Small Talk During a Job Interview</a></li>
<li><a href="https://www.youtube.com/watch?v=OTx_oXdHSis" target="_blank" rel="external">You Look Terrible: How NOT to Dress for a Job Interview</a></li>
<li><a href="https://www.cmu.edu/icc/index.shtml" target="_blank" rel="external">ICC 网站</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在北美找工作，除了基本的『硬实力』外，很多文化相关的『软实力』可能也起到了至关重要甚至是决定性的作用，这里总结了我在 CMU 研讨班学到的相关知识，希望能给还在努力『揾食』的同学们一些帮助。</p>]]>
    
    </summary>
    
      <category term="交际" scheme="http://wdxtub.com/tags/%E4%BA%A4%E9%99%85/"/>
    
      <category term="找工作" scheme="http://wdxtub.com/tags/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="文化" scheme="http://wdxtub.com/tags/%E6%96%87%E5%8C%96/"/>
    
      <category term="英语" scheme="http://wdxtub.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第八周 - 请走人行道]]></title>
    <link href="http://wdxtub.com/2016/03/04/walkway/"/>
    <id>http://wdxtub.com/2016/03/04/walkway/</id>
    <published>2016-03-04T13:13:24.000Z</published>
    <updated>2016-03-04T14:11:24.000Z</updated>
    <content type="html"><![CDATA[<p>不懂什么是骄傲，不懂什么是个性，不懂什么才算胡闹。</p>
<a id="more"></a>
<hr>
<p>腥风血雨的考试周总算是安然度过，虽然还有几百个坑要填，但是至少在接下来了两个月里有比较稳定的时间推进自己的计划了。少不了更高负荷的工作，不过做自己喜欢且想做的事情，本就没有苦与累。</p>
<p>最近的伙食标准比油价还低，基本都是做一顿吃两天，弄点肉加上豆子玉米胡萝卜，呼噜噜就是一大锅，有空的时候炒个青菜，这样每次煮个饭，往饭上一盖一浇，完事儿！时间久了，室友就吐槽『我都问吐了你还没吃吐嘛』。本来想回敬一波鸡汤，不过最后还是决定，只要她们不吐在我锅里，咱们就还是阳关道和独木桥。</p>
<p>不过这样吃有个好处，因为同样的肉往往要吃一个星期，现在对随着时间推移的肉质衰减以及不同部位的口感有了完全不同的认识。不过仔细想想这也有坏处，以后在学校吃快餐肯定得一边想着这是剩了几天的肉一边往肚子里塞了。另外一个收获是不同部位的差别真的跟价钱上反映出来的一致，一开始也许只能大概感觉出不同，但是一直吃吃吃，就真的能吃出个门道。</p>
<p>美国这边的肉（尤其是猪肉）大多带有奇怪的腥臭味（至少我家附近的超市里卖的是这样），区别就是贵的味道小一些，突出表现就是要么需要做之前焯一下，要么就煮的时候需要滤出血渣雪沫（不然味道不好）。抛开这个不说，切肉的时候，不同的纹理，不同的肥瘦，不同的切法都会影响最终的口感。总体来说，还是里脊部分（或者其他同等位置）的肉无论纹理还是口感最好（排骨不在比较之列，带骨头现在比较少吃了）。不过因为纹理结构比较深，最好提前腌制一下，这样更入味。</p>
<p>基础好的肉，口感衰减得比较慢，估计是因为内在结构更加紧密一些；基础差的肉，很快就散架了（可以想象肉松都是什么肉做的）。这个故事告诉我们，如果我们一定要做一块肉，那么要好好锻炼，成为有嚼劲紧实的肌肉，不要做松松垮垮的肥肉（但是五花肉也很好吃，纠结）。</p>
<p>最近身边的同学都进入了找工作找实习的白热化阶段，虽然我现在无论怎么样都有点『站着说话不腰疼』的感觉，不过还是觉得越是在意的事情，越应该淡定。在学校里要获得肯定，更多是一个单边操作，好好学习，好好考试，好好做研究，好好发论文，自然水涨船高。但是工作中不是养，变成了双边关系，很多老师未曾教过的东西，反而成为了关键。</p>
<p>找工作与其说是找一份工作，不如说是找到自己适合什么工作，化简一下就是找到自己。在不断的测试中了解自己擅长什么，喜欢什么，想要什么，这个很关键。具体到刷题之类的东西，其实是个人努力，有一个基准线在那里，过了就好。我想做什么工作，你能提供什么职位，这两个有多匹配，能不能接受，能接受咱们继续，不行就好聚好散。遇到的面试官很多，真正能让我看出有『智慧』的凤毛麟角（挑一道现成的面试题谁不会呢？），很多时候也影响了我对这家公司的看法。选择工作就是选择环境，不要被各种乱七八糟的光环亮瞎了双眼，还是那句话，要有自己的判断和选择，不能『随大流』。</p>
<p>前些天快到学校的时候，脑子里蹦出了『Form』 这个词，没想到特别合适的中文词汇（也许『形成』或者『塑造』合适？）。回忆过去，从小学到初中，从初中到高中，从高中到大学，从大学到研究生，虽然可能当时感觉不到太多的变化，但是按照历史课本的说法，总有那么一个标志性事件，把一条线段一分为二。在这个时间点之前，可以看做是发散的自我逐渐汇聚形成新自我的过程，而在这个时间点之后，是把自己重新散开等待下一个自我形成的过程。新的自我是怎么样的，就是『Form』的过程了。找到几个关键的核心，然后创造出新的『原子』和『分子』，最后形成全新的自己。不破不立，长肌肉是这样，成长同样也是这样。</p>
<p>既然如此，就不要害怕未知，不要害怕迷茫，每次都选择正确的事做很难，不如直接做自己喜欢做的事情（压根不需要选择了），坚持，直到它成为正确的事情。</p>
<p>世界很大无数奥妙，我要寻找我要奔跑，冲进那自由天地，什么事我都要做到。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>不懂什么是骄傲，不懂什么是个性，不懂什么才算胡闹。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="春假" scheme="http://wdxtub.com/tags/%E6%98%A5%E5%81%87/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 反思课 2 并发编程的策略与思考]]></title>
    <link href="http://wdxtub.com/2016/03/03/cc-rethink-2/"/>
    <id>http://wdxtub.com/2016/03/03/cc-rethink-2/</id>
    <published>2016-03-03T12:28:38.000Z</published>
    <updated>2016-03-03T15:03:41.000Z</updated>
    <content type="html"><![CDATA[<p>学习是一个不断改进方法论的过程，<a href="http://wdxtub.com/2016/02/29/cc-15/">第 15 课</a>中，因为自己缺乏对并发编程的基本认识，走了很多弯路。吃一堑长一智，本文着重讲三点：一是为什么我会犯错，二是对并发编程的一些思考，三是结合 Java 语言来探索相关细节。（感谢节瓜 @jiexing 的耐心指导）</p>
<a id="more"></a>
<hr>
<h2 id="u5E94_u7528_u573A_u666F"><a href="#u5E94_u7528_u573A_u666F" class="headerlink" title="应用场景"></a>应用场景</h2><p>因为涉及到具体的问题，所以先大概说明一下应用场景，方便之后的叙述。事情大概是这样的：</p>
<ul>
<li>后端有三台数据库服务器</li>
<li>需要支持两种不同的存储策略（复制机制与分区机制，详情参考<a href="http://wdxtub.com/2016/02/29/cc-15/">这里</a>）</li>
<li>由前端来接收和处理请求（不使用任何缓存）</li>
<li>请求有两种：GET（从数据库读取数据）与 PUT（向数据库写入数据）</li>
<li>数据的格式是键值对</li>
<li>保证数据的强一致性</li>
<li>按照请求的顺序返回响应（按照时间戳来排序）</li>
</ul>
<p>难点在于，每来一个请求，服务器都会新开一个线程来进行处理，多个线程的访问需要保证数据一致性及顺序，如果没有真正理解场景本身，很容易陷入无谓的复杂度，写出冗长却不完备的代码。</p>
<h2 id="u6211_u9519_u4E86"><a href="#u6211_u9519_u4E86" class="headerlink" title="我错了"></a>我错了</h2><p>写代码之前，我花了很多时间，试图找到一个合理的满足一致性和顺序的机制。根据文档的提示，用锁来保证一致性，用优先队列来保证顺序，万万没想到这就是一切复杂度的开端，最后我折腾出来的机制大概是这样的：</p>
<ul>
<li>每个 key 有自己的锁和优先队列</li>
<li>每来一个请求，把它加入到对应 key 的优先队列中</li>
<li>然后开一个线程，取出优先队列的队头进行处理</li>
<li>具体线程之间的同步由锁完成（在停止尝试之前已经变得很复杂，这里不详细展开，总的来说我试图利用三个状态手动控制线程的执行）</li>
<li>因为不同的线程可能需要访问同一个数据结构（这里我用 HashMap 来存储），也要考虑线程同步的问题，于是我决定依赖于『线程安全』的数据结构自动处理好访问冲突</li>
</ul>
<p>看起来还行，但是实际测试的时候既不能保证强一致性也没办法按顺序，甚至还引入了新的问题，这是为什么呢？我总结的原因如下：</p>
<ul>
<li>每次接收请求，新开的线程不一定执行这个请求对应的内容，而是执行队列头，让新线程做太复杂的工作</li>
<li>为了保证逻辑一致性被迫设计状态判断的机制，但是没办法穷举出所有的可能</li>
<li>控制线程时利用自动数据结构+手动逻辑控制，并没有得到半自动冲锋枪突突突的效果，而是乱成了一锅粥</li>
</ul>
<p>后来在瓜瓜的指引下找到了简单且有效的方法，关键点在于：</p>
<ul>
<li>要自动就全自动，要手动就全手动，不要依赖于自己并不完全理解的容器或者数据结构，因为很可能会和自己预期的表现不一样</li>
<li>每个线程应该就处理好传入的请求，而不是可能执行另外的请求（我之前的机制这种情况是可能出现的）</li>
<li>不要想当然去『控制』线程以达到最优性能，很多串行编程的思维在这里并不适用。</li>
</ul>
<p>从这样的思路拓展开去，就可以意识到自己之前的思路有多么『想当然』了。</p>
<h2 id="u4E00_u4E9B_u601D_u8003"><a href="#u4E00_u4E9B_u601D_u8003" class="headerlink" title="一些思考"></a>一些思考</h2><blockquote>
<p>Intuition is frequently wrong - be data intensive. [《Real-World Concurrency》 from ACM-Queue]</p>
</blockquote>
<p>如果要给云计算这门课一个关键词，当属 tradeoff。所谓权衡的艺术，从不同的角度来看，有不同的表现：</p>
<ul>
<li>从实现的角度，尽量以最小的代码换取最大的性能</li>
<li>从架构的角度，尽量以简洁的架构满足需求，减少复杂性</li>
<li>从经济的角度，尽力以最小的花费提供最好的服务质量</li>
</ul>
<p>同样的，对于并发编程，也是如此。</p>
<blockquote>
<p>Multi-threading is easy. Correct synchronization is hard</p>
</blockquote>
<p>最难的当属思维的转换，很多比较复杂的算法（或者说依赖比较多的算法），在并行环境中往往表现不好，比如说动态规划问题，原本是重复利用子问题的解，但是在多线程的条件下，子问题都不知道飞哪里去了；反而是分治算法，因为子问题独立，反而更适合并行。</p>
<p>而提到并发编程，就不得不提 OpenMP 了，这个学期当助教，我主要负责这一部分的内容，所以也算是有一些理解。OpenMP 的思路是利用尽可能少的代价，把串行代码弄成并行的，核心的机制是共享内存，然后利用线程执行不同的子问题，可能只需要几条 OpenMP 预编译指令，就可以带来明显的性能提升效果。</p>
<p>但是仔细想想，这种改进真的很大吗？在串行代码开发中，程序控制有一个清晰的流程。我们知道数据被访问和更改的方式，并了解其中的依赖关系。究其根本，OpenMP 依赖数据资源的锁定，和串行编程的思路是一样的，只是利用多核进行了简单的并行处理（相当于多叫几个人完成同一个工作，而不是大家做不同的工作）。如果使用不慎，除了带来性能问题之外，还可能造成数据不一致的问题。</p>
<p>而真正的并行程序中，有多个状态会同时发生和改变，依赖关系也会发生变化。必须思考如何同时执行多个指令，以及这些指令会对你的数据结构、变量、算法及其它一切产生什么影响。</p>
<p>总结一下：</p>
<ul>
<li>单线程逻辑设计的思路<ul>
<li>所有数据结构的生存期，以及对这些数据结构的访问都在同一个线程，不存在竞争条件，耗时的操作都给其他线程（IO线程、定时器线程，数据库线程等）做，做完之后向事件队列（多线程安全的队列，其他线程是生产者，逻辑线程是消费者）发送事件</li>
</ul>
</li>
<li>多线程逻辑设计的思路<ul>
<li>所有数据结构的生存期，以及对这些数据结构的访问不一定在同一个线程。需要考虑数据结构的竞争条件。网络事件、定时器事件唤醒工作线程（比方说 <code>notifyAll</code>）执行所有工作，一般不需要交换到其他线程</li>
</ul>
</li>
</ul>
<p>我们可以看出，最关键的就是如何访问数据的问题！线程执行和访问数据的时间没有确定的顺序。操作系统负责对线程进行调度，而它对于数据访问模式一无所知。并行程序中唯一的顺序是我们利用同步方法明确创建的（前面我把这部分工作交给自己并不熟悉的并行库来做，导致出问题）。最重要的是要牢牢记住所有并发线程，这样才能够创建更简单更有约束性的结构来限制并发情况。还有一个需要记得的点是，可能最优化的串行算法并不是好的并行算法。</p>
<p>最后的最后，并发编程真的是一门『纸上得来终觉浅』的艺术，最佳途径就是实践，实践，再实践。</p>
<h2 id="u4E00_u4E9B_u5BF9_u7B56"><a href="#u4E00_u4E9B_u5BF9_u7B56" class="headerlink" title="一些对策"></a>一些对策</h2><p>这里结合了 CMU 18645 How to Write Fast Code 课程上的一些思路，虽然对于具体场景不算特别适用，不过总体原则放到哪里都能用。</p>
<p>先说说优化并行部分的三个层面：</p>
<ul>
<li>逻辑层面：减少数据共享<ul>
<li>这一部分需要注意 false sharing 的问题，不然反而会造成大量的缓存浪费</li>
<li>解决方法也不算太难：线程本地存储 + 内存对齐，不过需要根据不同的机器不同处理</li>
</ul>
</li>
<li>编码层面：减少锁粒度<ul>
<li>同一个模块中，对不总是同时访问的数据，使用不同的锁（固定加锁顺序，防止死锁）</li>
<li>使用锁（临界区）来保护数据，而不是操作</li>
<li>将可能耗时的操作移到临界区外面（特别是 IO）</li>
<li>避免在临界区中调用未知代码 </li>
<li>谨慎使用读写锁，实现复杂，效率低下</li>
</ul>
</li>
<li>工具层面：使用轻量同步机制<ul>
<li>有些需要深入到内核态进行同步，对于基本的操作来说其实没必要这么兴师动众</li>
</ul>
</li>
</ul>
<p>换一个视角，可以总结出如下四条原则：</p>
<ol>
<li>单一职责：分离并发相关代码和其他代码（并发相关代码有自己的开发、修改和调优生命周期）</li>
<li>限制数据作用域：两个线程修改共享对象的同一字段时可能会相互干扰，导致不可预期的行为，解决方案之一是构造临界区，但是必须限制临界区的数量</li>
<li>使用数据副本：数据副本是避免共享数据的好方法，复制出来的对象只是以只读的方式对待</li>
<li>线程应尽可能独立：让线程存在于自己的世界中，不与其他线程共享数据。Servlet 就是以单实例多线程的方式工作，和每个请求相关的数据都是通过 Servlet 子类的 service 方法（或者是 doGet 或 doPost 方法）的参数传入的。只要 Servlet 中的代码只使用局部变量，Servlet 就不会导致同步问题</li>
</ol>
<p>在搜索资料的时候发现一个不错的提纲，不过因为刚接触，很多概念理解得不算特别清楚这里列出来，作为一个索引，感兴趣的同学可以按图索骥去深入了解下（参考资料中第二项）：</p>
<ul>
<li>资源并发访问的策略<ul>
<li>悲观策略<ul>
<li>lock based concurrency(theory)</li>
<li>java.util.concurrent (framework)</li>
<li>锁还是不锁，这是个问题， 锁多还是锁少，也是个问题(practice)</li>
</ul>
</li>
<li>乐观策略<ul>
<li>lock free concurrency(theory) : CAS</li>
<li>disruptor (framework)</li>
<li>并发度高，还是并发度低的时候使用，这是个问题(practice)</li>
</ul>
</li>
</ul>
</li>
<li>我拆我拆我拆拆拆（逻辑上拆分任务）<ul>
<li>task-based concurrency (theory)<ul>
<li>Runnable | Callable(model)</li>
<li>Executor | ExecutorService(framework)</li>
</ul>
</li>
<li>data-based concurrency(theory)<ul>
<li>Actor (model)</li>
<li>Akka(framework)</li>
</ul>
</li>
</ul>
</li>
<li>从单机到分布式<ul>
<li>divide and conquer<ul>
<li>map reduce pattern</li>
<li>master-worker pattern</li>
</ul>
</li>
<li>swarm framework(move computation instead of data)</li>
</ul>
</li>
<li>从软件到硬件<ul>
<li>GPU<ul>
<li>CUDA, jcuda, scuda</li>
<li>floating point computation, e.g. image reader and processing</li>
</ul>
</li>
<li>PPU<ul>
<li>物理计算</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>看了这么多，唯一的感受就是</p>
<blockquote>
<p>路漫漫其修远兮，吾将上下而求索。</p>
</blockquote>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.jianshu.com/p/053943a425c3" target="_blank" rel="external">Java并发编程的总结与思考</a></li>
<li><a href="http://afoo.me/posts/2013-03-12-concurrency_theory_frameworks_and_practices.html" target="_blank" rel="external">并发编程： 理论，框架与实践</a></li>
<li><a href="http://blog.csdn.net/lantian0802/article/details/19285937" target="_blank" rel="external">java并发编程学习总结（基础篇）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>学习是一个不断改进方法论的过程，<a href="http://wdxtub.com/2016/02/29/cc-15/">第 15 课</a>中，因为自己缺乏对并发编程的基本认识，走了很多弯路。吃一堑长一智，本文着重讲三点：一是为什么我会犯错，二是对并发编程的一些思考，三是结合 Java 语言来探索相关细节。（感谢节瓜 @jiexing 的耐心指导）</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="多线程" scheme="http://wdxtub.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 Twitter 语料分析 3 Vert.x 配置部署]]></title>
    <link href="http://wdxtub.com/2016/03/01/cc-p3/"/>
    <id>http://wdxtub.com/2016/03/01/cc-p3/</id>
    <published>2016-03-01T20:42:05.000Z</published>
    <updated>2016-03-02T00:19:44.000Z</updated>
    <content type="html"><![CDATA[<p>我们需要比较两个不同的 web 框架的性能，于是也选择了当下比较热门的 Vert.x 框架来做比较，网上的中文资源还是比较少的，这里同样记录一下如何在 EC2 上搭建和部署 Vert.x。</p>
<a id="more"></a>
<hr>
<h2 id="u73AF_u5883_u914D_u7F6E"><a href="#u73AF_u5883_u914D_u7F6E" class="headerlink" title="环境配置"></a>环境配置</h2><p>先启动一个标准的 Ubuntu 镜像（因为有 apt-get 安装软件比较方便）</p>
<p>我们需要安装 java 和 maven，并配置好对应的路径，具体参考下面的命令，这里和之前不同的是需要安装 Java 8，以及 maven 3：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 java,maven</span></span><br><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java8-installer</span><br><span class="line">sudo add-apt-repository <span class="string">"deb http://ppa.launchpad.net/natecarlson/maven3/ubuntu precise main"</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install maven3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认 jdk</span></span><br><span class="line">sudo update-alternatives --config java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 Java Home 编辑 ~/.bashrc</span></span><br><span class="line">JAVA_HOME=/usr/</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span></span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>同样用 maven 来创建项目，这次我们直接手动现在本地建立如下所示的文件层级：</p>
<p><img src="/images/14568662369892.jpg" alt="项目目录"></p>
<p>然后我们修改 <code>pom.xml</code> 文件，具体如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">project</span> <span class="attribute">xmlns</span>=<span class="value">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://maven.apache.org/POM/4.0.0</span><br><span class="line">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="title">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>housailei.vertx<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>vertx-server<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="title">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>io.vertx<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>vertx-core<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="title">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="title">source</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="title">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">execution</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="title">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="title">phase</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="title">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="title">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">transformers</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="title">transformer</span></span><br><span class="line">                    <span class="attribute">implementation</span>=<span class="value">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">manifestEntries</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="title">Main-Class</span>&gt;</span>io.vertx.core.Starter<span class="tag">&lt;/<span class="title">Main-Class</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="title">Main-Verticle</span>&gt;</span>housailei.vertx.App<span class="tag">&lt;/<span class="title">Main-Verticle</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="title">manifestEntries</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="title">transformer</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">transformers</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">artifactSet</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">outputFile</span>&gt;</span>$&#123;project.build.directory&#125;/$&#123;project.artifactId&#125;-$&#123;project.version&#125;-fat.jar<span class="tag">&lt;/<span class="title">outputFile</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们在 <code>src/main/java/housailei/vertx/</code> 下创建一个 <code>App.java</code> 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> housailei.vertx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.core.AbstractVerticle;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; fut)</span> </span>&#123;</span><br><span class="line">    vertx</span><br><span class="line">        .createHttpServer()</span><br><span class="line">        .requestHandler(r -&gt; &#123;</span><br><span class="line">          r.response().end(<span class="string">"&lt;h1&gt;Hello from my first "</span> +</span><br><span class="line">              <span class="string">"Vert.x 3 application! config by dawang&lt;/h1&gt;"</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .listen(<span class="number">8080</span>, result -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">            fut.complete();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fut.fail(result.cause());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们把代码上传回服务器上：<code>scp -i ../group.pem -r ./* ubuntu@dns.amazonaws.com:~/vertx-server/</code></p>
<p>执行的话稍微麻烦一点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn3 clean package</span><br><span class="line">java -jar target/vertx-server-<span class="number">1.0</span>-SNAPSHOT-fat.jar</span><br></pre></td></tr></table></figure>
<p>正常运行如下图所示：</p>
<p><img src="/images/14568725986794.jpg" alt="正常运行截图"></p>
<h2 id="u5B9E_u73B0_REST"><a href="#u5B9E_u73B0_REST" class="headerlink" title="实现 REST"></a>实现 REST</h2><p>前面的代码虽然可以工作，我们没办法设定不同的 api，也没办法做更进一步的处理，所以我们现在来更进一步，实现一个 RESTful 的简易 API。</p>
<p>我们先要在 <code>pom.xml</code> 文件中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>io.vertx<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>vertx-web<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后对应修改 <code>start</code> 方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; fut)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create a router object.</span></span><br><span class="line">   Router router = Router.router(vertx);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bind "/" to our hello message - so we are still compatible.</span></span><br><span class="line">   router.route(<span class="string">"/"</span>).handler(routingContext -&gt; &#123;</span><br><span class="line">   HttpServerResponse response = routingContext.response();</span><br><span class="line">   response</span><br><span class="line">      .putHeader(<span class="string">"content-type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">      .end(<span class="string">"&lt;h1&gt;Hello from my first "</span> +</span><br><span class="line">         <span class="string">"Vert.x 3 application! config by dawang&lt;/h1&gt;"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create the HTTP server and pass the "accept" method to the request handler.</span></span><br><span class="line">   vertx.createHttpServer().requestHandler(router::accept)</span><br><span class="line">       .listen(</span><br><span class="line">       <span class="comment">// Retrieve the port from the configuration,</span></span><br><span class="line">       <span class="comment">// default to 8080.</span></span><br><span class="line">       config().getInteger(<span class="string">"http.port"</span>, <span class="number">8080</span>), result -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">               fut.complete();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               fut.fail(result.cause());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在开始start方法里创建了一个 <code>Router</code> 对象。router 是 Vert.x Web 的基础，负责分发 HTTP 请求到 handler（处理器），在Vert.x Web中还有两个很重要的概念。</p>
<ul>
<li>Route - 定义请求的分发</li>
<li>Handler - 这是实际处理请求并且返回结果的地方。Handlers可以被链接起来使用。</li>
</ul>
<p>如果明白了这3个概念（Router、Routes、Handlers），就能明白 Vert.x Web 了。</p>
<p>重新运行一次，可以看到结果如下：</p>
<p><img src="/images/14568771965878.jpg" alt="再次配置成功"></p>
<p>然后我们多定义几个接口，并对应不同的方法来实现，同样是在 <code>start</code> 方法中，添加两条 router 规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">"/api/hou"</span>).handler(<span class="keyword">this</span>::HouHandler);</span><br><span class="line">router.get(<span class="string">"/api/sai"</span>).handler(<span class="keyword">this</span>::SaiHandler);</span><br></pre></td></tr></table></figure>
<p>然后创建对应的方法（就不用都写在一个函数里了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HouHandler</span><span class="params">(RoutingContext routingContext)</span></span>&#123;</span><br><span class="line">   routingContext.response()</span><br><span class="line">       .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json; charset=utf-8"</span>)</span><br><span class="line">       .end(<span class="string">"This is Hou HOu HOU!!! API!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SaiHandler</span><span class="params">(RoutingContext routingContext)</span></span>&#123;</span><br><span class="line">   routingContext.response()</span><br><span class="line">       .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json; charset=utf-8"</span>)</span><br><span class="line">       .end(<span class="string">"This is Sai SAi SAI!!! API!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再测试一下，可以看到 api 已经启用了：</p>
<p><img src="/images/14568776771132.jpg" alt="Hou Content"></p>
<p><img src="/images/14568776972444.jpg" alt="Sai Content"></p>
<p>有了这些，我们就可以自己来进行操作了，虽然可能代码丑一些，不过易上手，容易改。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://vertx.io/docs/" target="_blank" rel="external">官方文档</a></li>
<li><a href="http://vertx.io/docs/vertx-core/java/" target="_blank" rel="external">Vertx Core 手册</a></li>
<li><a href="http://vertx.io/docs/apidocs/" target="_blank" rel="external">Vertx Core API 文档</a></li>
<li><a href="http://vertx.io/docs/vertx-web/java/" target="_blank" rel="external">Vertx Web 手册</a></li>
<li><a href="http://vertx.io/docs/apidocs/" target="_blank" rel="external">Vertx Web API 文档</a></li>
</ul>
<p>非常有用的新手入门教程</p>
<ul>
<li><a href="http://vertx.io/blog/my-first-vert-x-3-application/index.html" target="_blank" rel="external">My first Vert.x 3 Application</a></li>
<li><a href="http://vertx.io/blog/vert-x-application-configuration/" target="_blank" rel="external">Vert.x Application Configuration</a></li>
<li><a href="http://vertx.io/blog/some-rest-with-vert-x/" target="_blank" rel="external">Some Rest with Vert.x</a></li>
<li><a href="http://vertx.io/blog/unit-and-integration-tests/" target="_blank" rel="external">Unit and Integration Tests</a></li>
<li><a href="https://github.com/quanke/vertx3_study_demo" target="_blank" rel="external">中文机器翻译版本</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们需要比较两个不同的 web 框架的性能，于是也选择了当下比较热门的 Vert.x 框架来做比较，网上的中文资源还是比较少的，这里同样记录一下如何在 EC2 上搭建和部署 Vert.x。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Vertx" scheme="http://wdxtub.com/tags/Vertx/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="服务" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 Twitter 语料分析 2 Undertow 配置部署]]></title>
    <link href="http://wdxtub.com/2016/03/01/cc-p2/"/>
    <id>http://wdxtub.com/2016/03/01/cc-p2/</id>
    <published>2016-03-01T14:41:11.000Z</published>
    <updated>2016-03-01T21:04:27.000Z</updated>
    <content type="html"><![CDATA[<p>因为项目有一定的性能要求，所以我们选择 Undertow 这个微框架来降低框架本身带来的性能影响，但是因为比较小众，所以网上很多资料都不全，这里记录下具体在 EC2 上如何配置和部署 Undertow。</p>
<a id="more"></a>
<hr>
<h2 id="u73AF_u5883_u914D_u7F6E"><a href="#u73AF_u5883_u914D_u7F6E" class="headerlink" title="环境配置"></a>环境配置</h2><p>先启动一个标准的 Ubuntu 镜像（因为有 apt-get 安装软件比较方便）</p>
<p>我们需要安装 java 和 maven，并配置好对应的路径，具体参考下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 java,maven</span></span><br><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java7-installer</span><br><span class="line">sudo apt-get install maven2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认 jdk</span></span><br><span class="line">sudo update-alternatives --config java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 Java Home 编辑 ~/.bashrc</span></span><br><span class="line">JAVA_HOME=/usr/</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span></span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure>
<p>如果一切正常的话，使用 <code>java -version</code> 可以看到：</p>
<p><img src="/images/14568475090854.jpg" alt="java -version"></p>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>我们创建一个项目来搭建服务器，因为 undertow 是使用 maven 来管理包和依赖的，所以我们也直接用 maven 来创建项目</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建项目，注意设置包名和项目名称</span></span><br><span class="line">mvn archetype:generate -DgroupId=housailei.undertow -DartifactId=p1_front -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=<span class="literal">false</span> -DartifactId=undertow-server</span><br></pre></td></tr></table></figure>
<p>为了编辑方便，我们把项目复制到本地</p>
<p><code>scp -i group.pem -r ubuntu@dns.amazonaws.com:~/undertow-server/* ./</code></p>
<p> 编辑完成可以用下面的命令上传回去（注意所在文件夹，我这里新建了一个文件夹用来存放源代码，密钥放在上一层）</p>
<p><code>scp -i ../group.pem -r ./* ubuntu@dns.compute-1.amazonaws.com:~/undertow-server/</code></p>
<p><img src="/images/14568478192103.jpg" alt="目录层级"></p>
<p>我们需要对 <code>App.java</code> 和 <code>pom.xml</code> 做一些修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> housailei.undertow;</span><br><span class="line"><span class="keyword">import</span> io.undertow.Undertow;</span><br><span class="line"><span class="keyword">import</span> io.undertow.server.*;</span><br><span class="line"><span class="keyword">import</span> io.undertow.util.Headers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// 设置成 0.0.0.0 开放访问以便测试</span></span><br><span class="line">        Undertow server = Undertow.builder().addHttpListener(<span class="number">8080</span>, <span class="string">"0.0.0.0"</span>)</span><br><span class="line">            .setHandler(<span class="keyword">new</span> HttpHandler() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> HttpServerExchange exchange)</span></span><br><span class="line">                       <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,</span><br><span class="line">                           <span class="string">"text/plain"</span>);</span><br><span class="line">               exchange.getResponseSender().send(<span class="string">"Hello World! This is wdxtub."</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;).build();</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 pom 文件的修改主要就是加上各类依赖，已经添加构建插件，我们这里选用了最新的 undertow，具体需要添加以下两个部分：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>io.undertow<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>undertow-core<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.3.18.Final<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>io.undertow<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>undertow-servlet<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.3.18.Final<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>和 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">build</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>exec-maven-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">execution</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="title">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">goal</span>&gt;</span>java<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="title">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">mainClass</span>&gt;</span>housailei.undertow.App<span class="tag">&lt;/<span class="title">mainClass</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后上传回 EC2 实例，就可以用以下代码执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile &amp;&amp; mvn <span class="built_in">exec</span>:java</span><br></pre></td></tr></table></figure>
<p>服务器正常开启之后，我们就可以在浏览器中访问了：</p>
<p><img src="/images/14568488280327.jpg" alt="访问网站"></p>
<h2 id="u6DFB_u52A0_Servlet"><a href="#u6DFB_u52A0_Servlet" class="headerlink" title="添加 Servlet"></a>添加 Servlet</h2><p>现在我们的服务器基本除了展示个页面没办法做任何事情，我们需要能让服务器运行 servlet 才行（最新版本的 undertow 会有一些小问题，会具体标记出来）</p>
<p>我们先写两个简单的 servlet，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个 servlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span>&#123;</span><br><span class="line">        message = <span class="string">"Hou HOu HOU!!!! Servlet!!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(<span class="string">"&lt;h1&gt;"</span> + message + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个 servlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaiServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span>&#123;</span><br><span class="line">        message = <span class="string">"Sai SAi SAI!!!! Servlet!!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(<span class="string">"&lt;h1&gt;"</span> + message + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改 <code>App.java</code> 把这两个 servlet 载入进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYAPP = <span class="string">"/hsl"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 官方例子中使用的 addServlets 方法不可用</span></span><br><span class="line">            <span class="comment">// 这里我用了 addServlet 方法</span></span><br><span class="line">            DeploymentInfo servletBuilder = Servlets.deployment()</span><br><span class="line">                .setClassLoader(App.class.getClassLoader())</span><br><span class="line">                .setContextPath(MYAPP)</span><br><span class="line">                .setDeploymentName(<span class="string">"test.war"</span>)</span><br><span class="line">                .addServlet(</span><br><span class="line">                        Servlets.servlet(<span class="string">"HouServlet"</span>, HouServlet.class)</span><br><span class="line">                                .addMapping(<span class="string">"/hou"</span>))</span><br><span class="line">                .addServlet(</span><br><span class="line">                        Servlets.servlet(<span class="string">"SaiServlet"</span>, SaiServlet.class)</span><br><span class="line">                                .addMapping(<span class="string">"/sai"</span>));</span><br><span class="line"></span><br><span class="line">            DeploymentManager manager = Servlets.defaultContainer().addDeployment(servletBuilder);</span><br><span class="line">            manager.deploy();</span><br><span class="line"></span><br><span class="line">            HttpHandler servletHandler = manager.start();</span><br><span class="line">            PathHandler path = Handlers</span><br><span class="line">                .path(Handlers.redirect(MYAPP))</span><br><span class="line">                .addPrefixPath(MYAPP, servletHandler);</span><br><span class="line"></span><br><span class="line">            Undertow server = Undertow.builder()</span><br><span class="line">                .addHttpListener(<span class="number">8080</span>, <span class="string">"0.0.0.0"</span>)</span><br><span class="line">                .setHandler(path)</span><br><span class="line">                .build();</span><br><span class="line">            server.start();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着还是传到服务器上并 <code>mvn compile &amp;&amp; mvn exec:java</code>，就可以看到结果</p>
<p><img src="/images/14568573432825.jpg" alt="SaiServlet 结果"></p>
<p><img src="/images/14568573815710.jpg" alt="HouServlet 结果"></p>
<p>之后的任务就可以在 Servlet 的 <code>doGet</code> 方法中对应写代码完成了。</p>
<p>后面应该会写一些脚本把配置的工作自动化，因为每次新建 EC2 都得重新配置还是挺麻烦的。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://undertow.io/undertow-docs/undertow-docs-1.3.0/index.html#introduction" target="_blank" rel="external">官方文档</a></li>
<li><a href="http://undertow.io/javadoc/1.3.x/index.html" target="_blank" rel="external">官方 JavaDoc</a></li>
<li><a href="https://github.com/undertow-io/undertow/tree/master/examples/src/main/java/io/undertow/examples" target="_blank" rel="external">官方样例代码</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为项目有一定的性能要求，所以我们选择 Undertow 这个微框架来降低框架本身带来的性能影响，但是因为比较小众，所以网上很多资料都不全，这里记录下具体在 EC2 上如何配置和部署 Undertow。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Undertow" scheme="http://wdxtub.com/tags/Undertow/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="服务" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 第 15 课 分区和复制]]></title>
    <link href="http://wdxtub.com/2016/02/29/cc-15/"/>
    <id>http://wdxtub.com/2016/02/29/cc-15/</id>
    <published>2016-02-29T12:01:54.000Z</published>
    <updated>2016-03-03T04:45:39.000Z</updated>
    <content type="html"><![CDATA[<p>之前我们做的是计算能力的伸缩拓展，这次我们也要对数据库做类似的事情，并且通过具体的场景，来了解键值对存储的应用特点。特别鸣谢瓜瓜 @jiexing 的点拨，不然我就卡在自己脑洞里出不来了。</p>
<a id="more"></a>
<hr>
<h2 id="u5B66_u4E60_u76EE_u6807"><a href="#u5B66_u4E60_u76EE_u6807" class="headerlink" title="学习目标"></a>学习目标</h2><ol>
<li>了解分布式键值对存储的设计空间和动机</li>
<li>比较在键值对存储中使用复制和分区的异同及优劣</li>
<li>利用复制或分区机制来拓展分布式键值对存储</li>
<li>了解并实现一致性哈希算法，并借此说明其在分布式键值对存储中的分区起到的作用</li>
<li>把复制和分区技术应用到现实场景中</li>
</ol>
<p>一致性哈希算法的要求很简单：</p>
<blockquote>
<p>在任何时候，对于同一个 key，要返回同一个 value</p>
</blockquote>
<p>理论上的要求很简洁，但具体实现的时候就会有需要细节了，比方说如何平均分配不同的 key，如果处理错误的状况等等。</p>
<h2 id="u80CC_u666F_u77E5_u8BC6"><a href="#u80CC_u666F_u77E5_u8BC6" class="headerlink" title="背景知识"></a>背景知识</h2><p>随着互联网、电子商务和社交媒体的快速发展，很多公司都不得不面对日益增长的数据量。如何存储、处理和分析这些数据越来越成为巨大的挑战。因为数据量已经远超一台机器可以承载的范围，我们需要分布式可拓展的存储系统。这里我们会专注于分布式键值对存储系统（也是 NoSQL 存储系统）。键值对存储系统支持两个基本操作：</p>
<ol>
<li><code>PUT</code> 请求，把一条记录放到数据库中</li>
<li><code>GET</code> 请求，从数据库中获取指定数据</li>
</ol>
<p>分布式键值对存储包含多个节点（可能不在一个地方），一个比较常见的做法是利用最近的服务器来处理对应请求以减少延迟。</p>
<p>说到数据库的扩展性，我们可以通过下面的视频来进行基本的了解</p>
<p><a href="https://www.youtube.com/watch?v=opYWHWG-vVg" target="_blank" rel="external">Video 1: Database Scaling</a></p>
<p>下面是视频中的要点：</p>
<ul>
<li>Vertical Scaling：提高硬件和软件配置（CPU, Memory, Disk, Network）<ul>
<li>优势：迁移简单，使用已有的软件</li>
<li>限制：硬件成本快速增长，可能最强大的硬件也不够用</li>
</ul>
</li>
<li>Horizontal Scaling：从一台数据库服务器扩展为数据库服务器集群，有下面两种机制来进行<ul>
<li>Replication 复制：每台数据库服务器都有同样的数据，读数据的时候没有问题，写数据的时候需要考虑数据同步的问题。对读数据性能要求较高的应用可以采用这种机制。</li>
<li>Sharding 分区：每台数据库服务器保存部分的数据库文件，需要决定什么时候访问哪台服务器，需要一个分区表。具体的分隔可以以行来分(Horizontal Partitioning)或者以列来分(Vertical Partitioning)。对写数据性能要求较高的应用可以采用这种机制。</li>
</ul>
</li>
</ul>
<p>这两个机制各有侧重点，这里简要介绍一下。</p>
<h3 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h3><p>对于复制机制来说，每次更新数据，都需要把改动『广播』到所有的节点上以保证数据一致性，如果系统的容错性要求很高，那么复制机制可能是比较好的选择，下图是一个例子：</p>
<p><img src="/images/14567497209474.jpg" alt="有 3 个复制节点的数据库"></p>
<p>在复制的情况下，主要的优化机制是提供不同级别的一致性保证。在一个数据库节点的某条记录被修改时，其他数据库中对应的记录是不可访问的，直到三个数据库的数据完全同步之后才可以，如下：</p>
<p><img src="/images/14567498771413.jpg" alt="强一致性保证"></p>
<p>并且，操作的不同顺序也会以时间戳的方式进行记录和排序，为了保证强一致性，需要保证任何时候从任何复制节点读取的数据都是一样的，具体的规则如下表所示</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">强一致性</td>
<td style="text-align:center">任何时候从任何复制节点中相同的 key 对应相同的 value</td>
</tr>
<tr>
<td style="text-align:center">严格排序</td>
<td style="text-align:center">按时间顺序处理请求</td>
</tr>
<tr>
<td style="text-align:center">原子操作</td>
<td style="text-align:center">所有的操作都应该是原子的，不能同时更新</td>
</tr>
<tr>
<td style="text-align:center">访问控制</td>
<td style="text-align:center">一个 key 在被更新时其他节点中的对应 key 不能访问</td>
</tr>
</tbody>
</table>
<h3 id="Sharding"><a href="#Sharding" class="headerlink" title="Sharding"></a>Sharding</h3><p>对于分区机制来说，可以直接用下图来描述与复制机制的区别（比较简单这里不详细介绍）</p>
<p><img src="/images/14567501863377.jpg" alt="三种方式的对比"></p>
<h2 id="u80CC_u666F_u8BBE_u5B9A"><a href="#u80CC_u666F_u8BBE_u5B9A" class="headerlink" title="背景设定"></a>背景设定</h2><p>简单来说就是要做一个支持 <code>PUT</code> 和 <code>GET</code> 的分布式键值对存储系统，保存以下两种数据：</p>
<ol>
<li>销售记录：保存支付密码等关键交易信息，一定要非常安全，不能轻易丢失。用户也会频繁访问购买历史，所以会有很多 <code>GET</code> 的操作，于是会采用复制机制</li>
<li>匿名日志：包含页面访问及歌曲收听记录等匿名日志，只会在用户行为分析的时候使用，并且对于安全性的要求没那么高，反而是会有很多 <code>PUT</code> 的操作，所以会利用分区机制。</li>
</ol>
<p>整个系统的设计如下：</p>
<p><img src="/images/14567578576946.jpg" alt=""></p>
<p>每个 datastore 已经帮我们配置好了，所以不必修改，我们需要做的就是折腾好 <code>Coordinator</code> 部分，也就是接收请求并转发给合适的 datastore</p>
<h2 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h2><p>具体的实现包含两个部分，分别对应前面提到的两种不同的需求。具体的需求如下</p>
<ul>
<li>并发执行<ul>
<li>利用多线程来并行处理不同的请求，已经提供了框架代码</li>
</ul>
</li>
<li>确定的行为<ul>
<li>不会出现竞争条件，利用各种保证并行安全的技术来实现</li>
</ul>
</li>
<li>非阻塞 <code>PUT</code> 操作<ul>
<li>具体参考下面的图示</li>
</ul>
</li>
<li>严格排序<ul>
<li>根据请求到来的顺序处理请求，已有的代码是包含时间戳的</li>
</ul>
</li>
<li>无缓存 Coordinator<ul>
<li>在处理请求的过程中临时保存请求是可以的，但是不能有持久的缓存</li>
</ul>
</li>
<li>动态策略<ul>
<li>Coordinator 应该支持后端的变动</li>
</ul>
</li>
</ul>
<p><img src="/images/14567593452426.jpg" alt="错误！阻塞了请求"></p>
<p><img src="/images/14567593813304.jpg" alt="正确！非阻塞机制"></p>
<h2 id="u4EFB_u52A1_u7B80_u4ECB"><a href="#u4EFB_u52A1_u7B80_u4ECB" class="headerlink" title="任务简介"></a>任务简介</h2><ul>
<li>打上标签：<code>Project: 3.2</code></li>
<li>Datastore: <code>ami-83ba8ae9</code>, <code>t1.micro</code></li>
<li>Coordinator:  <code>ami-17a4947d</code>, <code>t1.micro</code></li>
<li>Client:  <code>ami-a05d60ca</code>, <code>m1.small</code></li>
</ul>
<p>具体步骤</p>
<ol>
<li>开启 3 个 datastore 实例，注意允许 8080 端口的访问</li>
<li>在浏览器中访问 <code>http://[DATASTORE-DNS]:8080/test</code> 来测试 datastore 是否正常运行</li>
<li>开启 1 个 coordinator 实例，在 <code>/home/ubuntu/Project3_2/vertx/bin/</code> 可以看到一个 <code>Coordinator.java</code> 文件，我们主要会在这里完成代码 </li>
<li>使用命令 <code>./vertx run Coordinator.java</code> 来启动 coordinator</li>
<li>第一部分工作我们需要拓展 <code>Coordinator.java</code> 来完成复制机制</li>
<li>第二部分工作我们需要完成分区机制</li>
</ol>
<p>访问接口</p>
<ul>
<li><code>http://[Coordinator-DNS]:8080/storage?storage=TYPE_OF_STORAGE</code><ul>
<li>指定需要支持的存储类型（复制与分区），用来设置具体不同的模式</li>
</ul>
</li>
<li><code>http://[Coordinator-DNS]:8080/put?key=KEY&amp;value=VALUE</code><ul>
<li>接收键值对并保存在 datastore 实例中</li>
</ul>
</li>
<li><code>http://[Coordinator-DNS]:8080/get?key=KEY&amp;loc=LOCATION</code><ul>
<li>接收需要查询的 key，并包含指定的获取位置（1/2/3 为对应的序号），在分区机制中，如果指定的实例没有对应的 value，那么返回 0，如果没有指定获取位置，那么就根据哈希的结果从对应的实例中获取</li>
</ul>
</li>
<li>不同线程可以同时访问这些 API</li>
</ul>
<p>我们还提供了一个辅助类 <code>KeyValueLib</code>，可以在 <code>Coordinator.java</code> 中访问：</p>
<ul>
<li><code>KeyValueLib.PUT(String datastoreDNS, String key, String value)</code><ul>
<li>把键值对保存到对应的实例中</li>
</ul>
</li>
<li><code>KeyValueLib.GET(String datastoreDNS, String key)</code><ul>
<li>从指定的实例中得到对应 key 的 value</li>
</ul>
</li>
</ul>
<p>在设计 Coordinator 时，可以认为：</p>
<ul>
<li>GET 操作的延时是可以忽略的</li>
<li>可以认为 datastore 实例不会出现崩溃的状况，一旦 <code>KeyValueLib.PUT</code> 方法执行完成，那么对应的实例上的操作也完成，所以需要的同步机制不会太复杂。提示：不需要实现 <a href="http://en.wikipedia.org/wiki/Two-phase_commit_protocol" target="_blank" rel="external">Two-Phase Commit (2PC)</a> 机制</li>
</ul>
<h2 id="u7EBF_u7A0B_u540C_u6B65_u7B56_u7565"><a href="#u7EBF_u7A0B_u540C_u6B65_u7B56_u7565" class="headerlink" title="线程同步策略"></a>线程同步策略</h2><p>整个项目中最重要的是两个事情：数据一致性与严格顺序。严格顺序比较好完成，利用时间戳做评测标准使用优先队列来处理即可，因为需要保证非阻塞，所以针对复制机制，大概的流程如下（这个思路是不对的，或者说增加了无谓的复杂度，具体会另开一个反思课说明）：</p>
<ol>
<li>每个 key 都应该有自己的优先队列，来缓存可能需要等待的请求，并借此保证顺序（队列的操作应该是线程安全的，需要上锁）</li>
<li>每来一个请求，就会根据请求类型的不同在不同的 <code>handle</code> 方法中处理</li>
<li>每个 key 都应该有自己的锁，这样不会影响到其他 key 的访问，这里使用 <code>HashMap</code> 来存储</li>
<li>每次来一个请求，都需要先加入对应 key 的队列</li>
<li>在新开的线程，如果写操作正在进行，从队列中取出第一个请求进行操作，读取的话就上读锁，写入的话就上写锁</li>
<li>如果是写入的话，需要同步到其他两台机器</li>
<li>如果是读取的话，因为读锁是允许并发的，所以不需要为三个不同的数据库设计保存不同的锁，没有指定那个数据库的话，就随便访问一个即可</li>
<li>如果获取的时候没有对应的 key，返回 0</li>
</ol>
<p>针对分区机制，大概的流程如下（这个思路是不对的，或者说增加了无谓的复杂度，具体会另开一个反思课说明）：</p>
<ol>
<li>每个请求需要根据 key 来进行哈希，确定所在的数据库编号</li>
<li>每来一个请求，就会根据请求类型的不同在不同的 <code>handle</code> 方法中处理</li>
<li>每次来一个请求，都需要先加入对应 key 的队列</li>
<li>每个 key 都应该有自己的锁，这样不会影响到其他 key 的访问，这里使用 <code>HashMap</code> 来存储</li>
<li>在新开的线程，如果写操作正在进行，从队列中取出第一个请求进行操作，读取的话就上读锁，写入的话就上写锁</li>
<li>每个 key 都应该有自己的优先队列，来缓存可能需要等待的请求，并借此保证顺序（队列的操作应该是线程安全的，需要上锁）</li>
<li>获取的时候，如果指定的实例没有对应的 value（也就是和哈希出来的数据库编号不一致），那么返回 0</li>
<li>如果获取的时候没有对应的 key，返回 0</li>
</ol>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue里面存储的对象必须是实现Comparable接口。队列通过这个接口的compare方法确定对象的priority。</p>
<p>规则是：当前和其他对象比较，如果compare方法返回负数，那么在队列里面的优先级就比较高。</p>
<p>PriorityBlockingQueue队列添加新元素时候不是将全部元素进行顺序排列，而是从某个指定位置开始将新元素与之比较，一直比到队列头，这样既能保证队列头一定是优先级最高的元素，又能减少排序带来的性能消耗。每取一个头元素时候，都会对剩余的元素做一次调整，这样就能保证每次队列头的元素都是优先级最高的元素。</p>
<p>下面是 Thinking in Java 中的一个例子 - 使用PriorityBlockingQueue进行任务按优先级同步执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;   </span><br><span class="line"><span class="keyword">import</span> java.util.List;   </span><br><span class="line"><span class="keyword">import</span> java.util.Queue;   </span><br><span class="line"><span class="keyword">import</span> java.util.Random;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.PriorityBlockingQueue;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrioritizedTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Comparable</span>&lt;<span class="title">PrioritizedTask</span>&gt;   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = counter++;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> priority;   </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> List&lt;PrioritizedTask&gt; sequence = <span class="keyword">new</span> ArrayList&lt;PrioritizedTask&gt;();   </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrioritizedTask</span><span class="params">(<span class="keyword">int</span> priority)</span>    </span><br><span class="line">    </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.priority = priority;   </span><br><span class="line">        sequence.add(<span class="keyword">this</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">       </span><br><span class="line">    <span class="annotation">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PrioritizedTask o)</span> </span>&#123;   </span><br><span class="line">        <span class="comment">//复写此方法进行任务执行优先级排序   </span></span><br><span class="line"><span class="comment">//      return priority &lt; o.priority ? 1 :   </span></span><br><span class="line"><span class="comment">//          (priority &gt; o.priority ? -1 : 0);   </span></span><br><span class="line">        <span class="keyword">if</span>(priority &lt; o.priority)   </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;   </span><br><span class="line">        &#125;<span class="keyword">else</span>   </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span>(priority &gt; o.priority)   </span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;   </span><br><span class="line">            &#125;<span class="keyword">else</span>   </span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">   </span><br><span class="line">    <span class="annotation">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="comment">//执行任务代码..   </span></span><br><span class="line">        <span class="keyword">try</span> &#123;   </span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">250</span>));   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;   </span><br><span class="line">               </span><br><span class="line">        &#125;   </span><br><span class="line">        System.out.println(<span class="keyword">this</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">       </span><br><span class="line">    <span class="annotation">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%1$-3d]"</span>, priority) + <span class="string">" Task id : "</span> + id;   </span><br><span class="line">    &#125;   </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">summary</span><span class="params">()</span>   </span><br><span class="line">    </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"( Task id : "</span> + id + <span class="string">" _priority : "</span> + priority + <span class="string">")"</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">       </span><br><span class="line">    <span class="comment">/**  </span><br><span class="line">     * 结束所有任务  </span><br><span class="line">     */</span>   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EndSentinel</span> <span class="keyword">extends</span> <span class="title">PrioritizedTask</span>   </span><br><span class="line">    </span>&#123;   </span><br><span class="line">        <span class="keyword">private</span> ExecutorService exec;   </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EndSentinel</span><span class="params">(ExecutorService e)</span> </span>&#123;   </span><br><span class="line">            <span class="keyword">super</span>(Integer.MAX_VALUE);   </span><br><span class="line">            exec = e;   </span><br><span class="line">        &#125;   </span><br><span class="line">           </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>   </span><br><span class="line">        </span>&#123;   </span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;   </span><br><span class="line">            <span class="keyword">for</span>(PrioritizedTask pt : sequence)   </span><br><span class="line">            &#123;   </span><br><span class="line">                System.out.print(pt.summary());   </span><br><span class="line">                <span class="keyword">if</span>(++count % <span class="number">5</span> == <span class="number">0</span>)   </span><br><span class="line">                &#123;   </span><br><span class="line">                    System.out.println();   </span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">            System.out.println();   </span><br><span class="line">            System.out.println(<span class="keyword">this</span> + <span class="string">"Calling shutdownNow()"</span>);   </span><br><span class="line">            exec.shutdownNow();   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line">   </span><br><span class="line"><span class="comment">/**  </span><br><span class="line"> * 制造一系列任务,分配任务优先级  </span><br><span class="line"> */</span>   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrioritizedTaskProducer</span> <span class="keyword">implements</span> <span class="title">Runnable</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);   </span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Runnable&gt; queue;   </span><br><span class="line">    <span class="keyword">private</span> ExecutorService exec;   </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrioritizedTaskProducer</span><span class="params">(Queue&lt;Runnable&gt; q, ExecutorService e)</span>    </span><br><span class="line">    </span>&#123;   </span><br><span class="line">        queue = q;   </span><br><span class="line">        exec = e;   </span><br><span class="line">    &#125;   </span><br><span class="line">       </span><br><span class="line">    <span class="annotation">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">           </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)   </span><br><span class="line">        &#123;   </span><br><span class="line">            queue.add(<span class="keyword">new</span> PrioritizedTask(rand.nextInt(<span class="number">10</span>)));   </span><br><span class="line">            Thread.yield();   </span><br><span class="line">        &#125;   </span><br><span class="line">           </span><br><span class="line">        <span class="keyword">try</span> &#123;   </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;   </span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">250</span>);   </span><br><span class="line">                queue.add(<span class="keyword">new</span> PrioritizedTask(<span class="number">10</span>));   </span><br><span class="line">            &#125;   </span><br><span class="line">               </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)   </span><br><span class="line">            &#123;   </span><br><span class="line">                queue.add(<span class="keyword">new</span> PrioritizedTask(i));   </span><br><span class="line">            &#125;   </span><br><span class="line">               </span><br><span class="line">            queue.add(<span class="keyword">new</span> PrioritizedTask.EndSentinel(exec));   </span><br><span class="line">               </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;   </span><br><span class="line">               </span><br><span class="line">        &#125;   </span><br><span class="line">           </span><br><span class="line">        System.out.println(<span class="string">"Finished PrioritizedTaskProducer"</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="comment">/**  </span><br><span class="line"> * 使用PriorityBlockingQueue进行任务按优先级同步执行  </span><br><span class="line"> */</span>   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrioritizedTaskConsumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> PriorityBlockingQueue&lt;Runnable&gt; q;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrioritizedTaskConsumer</span><span class="params">(PriorityBlockingQueue&lt;Runnable&gt; q)</span>   </span><br><span class="line">    </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.q = q;   </span><br><span class="line">    &#125;   </span><br><span class="line">   </span><br><span class="line">    <span class="annotation">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">try</span>    </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted())    </span><br><span class="line">            &#123;   </span><br><span class="line">                q.take().run();   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)    </span><br><span class="line">        &#123;   </span><br><span class="line">        &#125;   </span><br><span class="line">        System.out.println(<span class="string">"Finished PrioritizedTaskConsumer"</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">       </span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueueDemo</span> </span>&#123;   </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span>   </span><br><span class="line">    </span>&#123;   </span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();   </span><br><span class="line">        PriorityBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> PriorityBlockingQueue&lt;Runnable&gt;();   </span><br><span class="line">           </span><br><span class="line">        exec.execute(<span class="keyword">new</span> PrioritizedTaskProducer(queue, exec));   </span><br><span class="line">        <span class="keyword">try</span> &#123;   </span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">250</span>);   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;   </span><br><span class="line">        &#125;   </span><br><span class="line">        exec.execute(<span class="keyword">new</span> PrioritizedTaskConsumer(queue));   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u8BFB_u5199_u9501_ReadWriteLock"><a href="#u8BFB_u5199_u9501_ReadWriteLock" class="headerlink" title="读写锁 ReadWriteLock"></a>读写锁 ReadWriteLock</h3><p>读写锁分为读锁和写锁，多个读锁之间是不需要互斥的(读操作不会改变数据，如果上了锁，反而会影响效率)，写锁和写锁之间需要互斥，也就是说，如果只是读数据，就可以多个线程同时读，但是如果你要写数据，就必须互斥，使得同一时刻只有一个线程在操作。在同一线程中，持有读锁后，不能直接调用写锁的lock方法 ，否则会造成死锁。</p>
<p>一个简单的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadWrite</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 共享数据，只能一个线程写数据，可以多个线程读数据 */</span></span><br><span class="line">	<span class="keyword">private</span> Object data = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">/* 创建一个读写锁 */</span></span><br><span class="line">	ReadWriteLock rwlock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 读数据，可以多个线程同时读， 所以上读锁即可</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">/* 上读锁 */</span></span><br><span class="line">		rwlock.readLock().lock();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" 准备读数据!"</span>);</span><br><span class="line">			<span class="comment">/* 休眠 */</span></span><br><span class="line">			Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"读出的数据为 :"</span> + data);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			rwlock.readLock().unlock();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 写数据，多个线程不能同时写 所以必须上写锁</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 上写锁 */</span></span><br><span class="line">		rwlock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" 准备写数据!"</span>);</span><br><span class="line">			<span class="comment">/* 休眠 */</span></span><br><span class="line">			Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" 写入的数据: "</span> + data);</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			rwlock.writeLock().unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/* 创建ReadWrite对象 */</span></span><br><span class="line">		<span class="keyword">final</span> ReadWrite readWrite = <span class="keyword">new</span> ReadWrite();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 创建并启动3个读线程 */</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="annotation">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					readWrite.get();</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">/*创建3个写线程*/</span></span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;	</span><br><span class="line">				<span class="annotation">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="comment">/*随机写入一个数*/</span></span><br><span class="line">					readWrite.put(<span class="keyword">new</span> Random().nextInt(<span class="number">8</span>));				</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5F3A_u4E00_u81F4_u590D_u5236_u673A_u5236"><a href="#u5F3A_u4E00_u81F4_u590D_u5236_u673A_u5236" class="headerlink" title="强一致复制机制"></a>强一致复制机制</h2><p>在分布式应用中，一致性是非常重要的，这里我们简要介绍一下</p>
<p><img src="/images/14567642451622.jpg" alt="一个银行系统的数据存储"></p>
<p>如果没有保证强一致性，那么上图中所示的场景可能就会出问题，如果同时取出 <code>$50</code>，那么可能最后的结果是两边都变成 <code>$950</code>，而不是正确的 <code>$900</code>，所以正确的做法是只能让一边完成操作，然后当数据库同步完成后，另一个操作才可以执行。</p>
<p>根据这个要求，我们的 Coordinator 还需要满足如下的强一致性需求：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">强一致性</td>
<td style="text-align:center">任何时候从任何复制节点中相同的 key 对应相同的 value</td>
</tr>
<tr>
<td style="text-align:center">严格排序</td>
<td style="text-align:center">对应 key 相同的操作，按时间顺序处理请求</td>
</tr>
<tr>
<td style="text-align:center">原子操作</td>
<td style="text-align:center">所有的操作都应该是原子的，不能同时更新</td>
</tr>
<tr>
<td style="text-align:center">访问控制</td>
<td style="text-align:center">一个 key 在被更新时其他节点中的对应 key 不能访问</td>
</tr>
</tbody>
</table>
<blockquote>
<p>提示</p>
</blockquote>
<ol>
<li>如果对并行编程不熟悉，需要复习多线程，线程安全和保证执行顺序的策略等相关内容</li>
<li>需要在给 PUT 排序的时候执行显式同步。注意可能引起的<a href="http://stackoverflow.com/questions/34510/what-is-a-race-condition" target="_blank" rel="external">竞争条件</a></li>
<li>有若干种方法来处理锁与竞争条件，可以参考<a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html" target="_blank" rel="external">这里</a>以及<a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html" target="_blank" rel="external">同步</a>的详细信息</li>
<li>使用时间戳来进行排序，<a href="https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html" target="_blank" rel="external">优先队列</a>会很有用</li>
<li>需要重设 datastore 时，可以访问 <code>http://[Datastore-DNS]:8080/flush</code></li>
<li>刚连上远程实例的时候会有比较大的延迟，请耐心等待，不要 <code>ctrl+c</code>，不然会出问题</li>
<li>早点开始，并行编程可能会比想象中要麻烦得多</li>
</ol>
<blockquote>
<p>提交方式</p>
</blockquote>
<ol>
<li>启动一个 <code>m1.small</code>(<code>ami-a05d60ca</code>) 客户端实例</li>
<li>进入 <code>/home/ubuntu/Project3_2/</code>，包含 <code>storage_checker</code>, <code>config.prop</code>, <code>submitter</code> 和 <code>references</code></li>
<li>可以用 <code>storage_checker</code> 来检测正确性，但是使用之前需要先填写 <code>config.prop</code>（注意里面 datastore 的顺序要和 <code>Coordinator.java</code> 中的保持一致）</li>
<li>填写完成后可以使用 <code>./storage_checker.sh replication</code> 来进行测试。</li>
</ol>
<h2 id="u5E73_u5747_u5206_u914D_u5206_u533A_u673A_u5236"><a href="#u5E73_u5747_u5206_u914D_u5206_u533A_u673A_u5236" class="headerlink" title="平均分配分区机制"></a>平均分配分区机制</h2><p>在分区机制中最重要的就是哈希函数，使用哈希的话，不可避免会出现<a href="https://en.wikipedia.org/wiki/Collision_(computer_science" target="_blank" rel="external">冲突</a> )的情况，所以评价一个哈希函数好不好，主要看能否使用这个哈希函数把输入尽可能平均分摊到不同的 key 中。</p>
<p>举个例子，假设我们的输入是 1-6 六个数字，有如下两个哈希函数</p>
<ul>
<li>函数 A<ul>
<li>1,2,3: -&gt; 0</li>
<li>4,5,6: -&gt; 1</li>
</ul>
</li>
<li>函数 B<ul>
<li>1,2,3,4,5: -&gt; 0</li>
<li>6        : -&gt; 1</li>
</ul>
</li>
</ul>
<p>因为函数 A 使得分布更平均，于是在这个场景中，函数 A 更好。在这个项目中，哈希函数用来决定数据应该存放在哪个数据库实例中，所以我们的目标是设计一个尽可能平均分配请求的哈希函数</p>
<p>具体的需求如下：</p>
<ul>
<li>一致性分区<ul>
<li>对于给定的 key，只会被分配到同一个实例上，同一个 key 只能存在与一个实例中</li>
</ul>
</li>
<li>一致性哈希<ul>
<li>对于给定的输入，每次哈希得到的值是一致的</li>
</ul>
</li>
<li>独立数据中心锁<ul>
<li>对于一个实例的请求不会令其他实例上锁</li>
</ul>
</li>
<li>非阻塞 PUT 操作<ul>
<li>对于一个实例的请求阻塞其他请求</li>
</ul>
</li>
<li>严格顺序<ul>
<li>要保持请求的顺序</li>
</ul>
</li>
</ul>
<p>其他需要注意的地方</p>
<ul>
<li>key “a” 必须放在 datastore 1 中</li>
<li>key “b” 必须放在 datastore 2 中</li>
<li>key “c” 必须放在 datastore 3 中</li>
<li>其他的 key 应该尽可能平均分配</li>
<li>不允许使用 <code>.hashCode()</code> 方法</li>
</ul>
<blockquote>
<p>提示</p>
</blockquote>
<ol>
<li>上一节的提示也适用于这一节</li>
<li>可以通过数学方法来得到哈希函数，也可以记录下 key 的分布对应来设计</li>
<li>当一致性模式改变的时候，注意清空你使用的数据结构</li>
<li>早点开始</li>
</ol>
<blockquote>
<p>提交方式</p>
</blockquote>
<ol>
<li>可以用 <code>storage_checker</code> 来检测正确性，使用之前需要先填写 <code>config.prop</code>（注意里面 datastore 的顺序要和 <code>Coordinator.java</code> 中的保持一致），然后使用 <code>./storage_checker.sh sharding</code> 来测试</li>
<li>测试完成之后，需要把 <code>Coordinator.java</code> 移动到客户端实例的 <code>/home/ubuntu/</code> 文件夹中，对应填写 <code>references</code></li>
<li>用 <code>./submitter.sh</code> 进行提交</li>
<li>TA 会人工给代码打分，尤其是可能的竞争条件，还要注意代码风格</li>
</ol>
<h2 id="u64CD_u4F5C_u65E5_u5FD7"><a href="#u64CD_u4F5C_u65E5_u5FD7" class="headerlink" title="操作日志"></a>操作日志</h2><ul>
<li>申请 EC2 实例：<code>ami-17a4947d</code>(<code>t1.micro</code>)，注意打开所有端口。</li>
<li>把要修改的文件复制到本地 <code>scp -i demo.pem ubuntu@dns.compute-1.amazonaws.com:~/Project3_2/vertx/bin/Coordinator.java ./</code></li>
<li>修改完成后传回服务器 <code>scp -i demo.pem ./Coordinator.java ubuntu@dns.compute-1.amazonaws.com:~/Project3_2/vertx/bin/</code></li>
<li>使用命令 <code>./vertx run Coordinator.java</code> 来启动 coordinator（也可以用来检查语法错误）</li>
<li>启动三个 datastore： <code>ami-83ba8ae9</code>(<code>t1.micro</code>)，注意打开所有端口</li>
<li>启动一个 <code>m1.small</code>(<code>ami-a05d60ca</code>) 客户端实例</li>
<li>分别把地址写到 <code>Coordinator.java</code> 和 <code>config.prop</code> 中</li>
<li>把 <code>config.prop</code> 复制到本地 <code>scp -i demo.pem ubuntu@dns.compute-1.amazonaws.com:~/config.prop ./</code></li>
<li>添加完之后复制回去 <code>scp -i demo.pem ./config.prop ubuntu@dns.compute-1.amazonaws.com:~/</code></li>
<li>使用 <code>./storage_checker.sh replication</code> 来进行测试</li>
<li>完成第一部分后，使用 <code>./storage_checker.sh sharding</code> 来测试第二部分</li>
<li>填写 <code>references</code> 以及把 <code>Coordinator.java</code> 上传到客户端实例 <code>scp -i demo.pem ./Coordinator.java ubuntu@dns.compute-1.amazonaws.com:~/</code></li>
<li>然后就提交 <code>./submitter.sh</code></li>
</ul>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://blog.csdn.net/lzm1340458776/article/details/27964243" target="_blank" rel="external">Java多线程中读写锁ReadWriteLock的使用</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html" target="_blank" rel="external">Class PriorityBlockingQueue<e></e></a></li>
<li><a href="http://www.cnblogs.com/techyc/p/3272321.html" target="_blank" rel="external">Java的wait(), notify()和notifyAll()使用小结</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前我们做的是计算能力的伸缩拓展，这次我们也要对数据库做类似的事情，并且通过具体的场景，来了解键值对存储的应用特点。特别鸣谢瓜瓜 @jiexing 的点拨，不然我就卡在自己脑洞里出不来了。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="数据库" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 期中考试复习]]></title>
    <link href="http://wdxtub.com/2016/02/28/csapp-midterm-review/"/>
    <id>http://wdxtub.com/2016/02/28/csapp-midterm-review/</id>
    <published>2016-02-28T13:08:37.000Z</published>
    <updated>2016-03-01T14:10:17.000Z</updated>
    <content type="html"><![CDATA[<p>这一次我们主要来回顾一下重要的知识点，以及讲解一些往年试题中容易混淆的概念。</p>
<a id="more"></a>
<hr>
<h2 id="u77E5_u8BC6_u70B9_u68B3_u7406"><a href="#u77E5_u8BC6_u70B9_u68B3_u7406" class="headerlink" title="知识点梳理"></a>知识点梳理</h2><p>范围是第 1-3 章和第 6 章，下面是部分知识点（每个其实都包含不少内容，建议再看一次我前面写过的系列，这里还是会挑一些重点来写以下）</p>
<ul>
<li>十六进制表示</li>
<li>数据类型的字节表示</li>
<li>C 语言中的位操作、逻辑操作、左移右移操作</li>
<li>整型的表示方法及运算方式</li>
<li>浮点数的表示方法及运算方式</li>
<li>理解汇编：访问数据，算术和逻辑运算，控制，过程调用，数组的内存空间分配和访问，结构体/联合体的表示，数据对齐</li>
<li>理解指针，栈帧以及常见的攻击方式</li>
<li>内存相关话题：Locality, Memory Hierarchy, Cache Memories</li>
</ul>
<h3 id="u5E03_u5C14_u8FD0_u7B97"><a href="#u5E03_u5C14_u8FD0_u7B97" class="headerlink" title="布尔运算"></a>布尔运算</h3><p>集合 A</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01101001</span> &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="number">76543210</span></span><br></pre></td></tr></table></figure>
<p>集合 B</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01010101</span> &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="number">76543210</span></span><br></pre></td></tr></table></figure>
<p>那么不同的布尔运算就代表：</p>
<ul>
<li><code>&amp;</code> 交集 Intersection <code>01000001</code> {0, 6}</li>
<li><code>|</code> 并集 Union <code>01111101</code> {0, 2, 3, 4, 5, 6}</li>
<li><code>^</code> 差集 Symmetric difference <code>00111100</code> {2, 3, 4, 5}</li>
<li><code>~</code> 补集 Complement <code>10101010</code> {1, 3, 5, 7}</li>
</ul>
<p>以上这四种运算 C 语言都支持，只要是『数值型』即可：<code>long</code>, <code>int</code>, <code>short</code>, <code>char</code>, <code>unsigned</code>。每个参数都会被看做是位向量。</p>
<h3 id="u6574_u578B_u7684_u8868_u793A"><a href="#u6574_u578B_u7684_u8868_u793A" class="headerlink" title="整型的表示"></a>整型的表示</h3><p>针对有符号数和无符号数，有两种不同的形式，这里的 w 表示 word size：</p>
<ul>
<li>无符号数：$B2U(X)=\sum_{i=0}^{w-1}x_i·2^i$</li>
<li>有符号数： $B2T(X)=-x_{w-1}·2^{w-1}+\sum_{i=0}^{w-2}x_i·2^i$ </li>
</ul>
<p>为了方便讲解，下面定义几个常量，这里 w 是 word size：</p>
<ul>
<li>UMin = 0 即 000…0</li>
<li>UMax = $2^w-1$ 即 111…1</li>
</ul>
<p>Two’s Complement 值</p>
<ul>
<li>TMin = $-2^{w-1}$ 即 100…0</li>
<li>TMax = $2^{w-1}-1$ 即 011…1</li>
</ul>
<p>其他值</p>
<ul>
<li>Minus 1 即 111…1</li>
</ul>
<p>观察可以得知两个很重要的特性</p>
<ul>
<li>|TMin| = TMax + 1 (范围并不是对称的)</li>
<li>UMax = 2*TMax + 1</li>
</ul>
<p>有符号数和无符号数在非负数的编码是一样的，每一个数字的编码是唯一的，这两者可以互换：</p>
<ul>
<li>$U2B(x)=B2U^{-1}(x)$</li>
<li>$T2B(x)=B2T^{-1}(x)$</li>
</ul>
<p><img src="/images/csapp2.jpg" alt="2&#39;s Complement vs Unsigned"></p>
<h3 id="u62D3_u5C55_u548C_u88C1_u526A"><a href="#u62D3_u5C55_u548C_u88C1_u526A" class="headerlink" title="拓展和裁剪"></a>拓展和裁剪</h3><p>有的时候我们需要扩展一个变量的位数，比如说从 32 位扩展到 64 位。更通用一点的话，给定一个 w 位的有符号整数 x，要把它转换成 w+k 位的整数（保持值不变），只需要在左边添加 k 个与符号位相同的数值即可，如下图：</p>
<p><img src="/images/csapp3.jpg" alt="从 32 位拓展到 64 位"></p>
<ul>
<li>扩展（例如从 <code>short int</code> 到 <code>int</code>）<ul>
<li>无符号数：加 0</li>
<li>有符号数：加符号位</li>
<li>都可以得到预期的结果</li>
</ul>
</li>
<li>缩短（例如 <code>unsigned</code> 到 <code>unsigned short</code>）<ul>
<li>均会截取</li>
<li>无符号数：mod 操作</li>
<li>有符号数：近似 mod 操作</li>
<li>对于小的数字可以得到预期的结果</li>
</ul>
</li>
</ul>
<h3 id="u6EA2_u51FA_u95EE_u9898"><a href="#u6EA2_u51FA_u95EE_u9898" class="headerlink" title="溢出问题"></a>溢出问题</h3><p>无符号加法和有符号加法有不同的溢出方式：</p>
<p><img src="/images/csapp5.jpg" alt="无符号加法的溢出"></p>
<p><img src="/images/csapp7.jpg" alt="有符号加法的两种溢出"></p>
<h3 id="u6D6E_u70B9_u6570"><a href="#u6D6E_u70B9_u6570" class="headerlink" title="浮点数"></a>浮点数</h3><p>二进制浮点数的表示，其实和我们日常生活中常见的十进制的方式是一致的，都是相当于每一位的系数，乘以每一位的数值，然后把结果加起来，如下图所示：</p>
<p><img src="/images/csapp13.jpg" alt="浮点数表示"></p>
<p>所以我们其实可以用一个统一的公式来表达：</p>
<p>$$ \sum_{k=-j}^ib_k\times 2^k $$</p>
<p>例如</p>
<p>$$ 5\frac{3}{4}=101.11_2 \;,\; 2\frac{7}{8}=10.111_2 \;,\; 1\frac{7}{16}=1.0111_2 $$</p>
<p>细心的同学就会发现，这种表达方式其实是比较明显的限制的，比如说，只有形为 $\frac{x}{2^k}$ 的小数部分可以被精确表示，其他的数字会变成循环的小数，例如：$\frac{1}{3}=0.0101010101[01]…_2$。</p>
<p>除此之外，另一个问题在于，如果给定了 w 个比特，能够表达的数字其实是有限的。</p>
<h3 id="IEEE__u6D6E_u70B9_u6570"><a href="#IEEE__u6D6E_u70B9_u6570" class="headerlink" title="IEEE 浮点数"></a>IEEE 浮点数</h3><p>我们用下面的公式来表达浮点数：</p>
<p>$$(-1)^s \; M \; 2^E$$</p>
<p>其中 s 是符号位，决定正负；M 通常是一个值在 [1.0, 2.0) 的小数；E 是次方数。具体编码的时候是这样的：</p>
<p><img src="/images/csapp14.jpg" alt="浮点数的格式"></p>
<p>其中 s 对应着符号位，exp 对应着 E（注意，不一定等于 E，因为位数限制表达能力有限），frac 对应着 M（注意，不一定等于 M，因为位数限制表达能力有限）。</p>
<p>不同的位数就代表了不同的表示能力，也就是单精度，双精度，扩展精度的来源，具体的位数表示如下：</p>
<p><img src="/images/csapp15.jpg" alt="单精度、双精度、拓展精度"></p>
<p>注意区别 normalized 和 denormalized 的区别</p>
<p>舍入到最近的偶数比较特别，中心思想是：舍入之后最右边的值要是偶数，从下面一个例子就可以明白：</p>
<p><img src="/images/csapp24.jpg" alt="舍入到最近的偶数"></p>
<p>对于二进制数也是类似的</p>
<p><img src="/images/csapp25.jpg" alt="二进制数舍入到最近的偶数"></p>
<h3 id="u6D6E_u70B9_u6570_u4E58_u6CD5"><a href="#u6D6E_u70B9_u6570_u4E58_u6CD5" class="headerlink" title="浮点数乘法"></a>浮点数乘法</h3><p>$$(-1)^{s1}\; M1 \; 2^{E1} \times (-1)^{s2}\; M2 \; 2^{E2}$$</p>
<p>结果是 $(-1)^{s}\; M \; 2^{E}$，其中 s= s1 ^ s2, M = M1 * M2, E = E1 + E2</p>
<ul>
<li>如果 M 大于等于 2，那么把 M 右移，并增加 E 的值。</li>
<li>如果 E 超出了可以表示的范围，溢出</li>
<li>把 M 舍入到 frac 的精度</li>
</ul>
<p>基本性质</p>
<ul>
<li>相乘可能产生 infinity 或者 NaN</li>
<li>满足交换率</li>
<li>不满足结合律（因为舍入会造成精度损失）</li>
<li>乘以 1 等于原来的数</li>
<li>不满足分配率 <code>1e20*(1e20-1e20)=0.0</code> 但 <code>1e20*1e20-1e20*1e20=NaN</code></li>
<li>除了 infinity 和 NaN，满足单调性，即 $a\ge b \to a\times c \ge a\times b$</li>
</ul>
<h3 id="u6D6E_u70B9_u6570_u52A0_u6CD5"><a href="#u6D6E_u70B9_u6570_u52A0_u6CD5" class="headerlink" title="浮点数加法"></a>浮点数加法</h3><p>$$(-1)^{s1}\; M1 \; 2^{E1} + (-1)^{s2}\; M2 \; 2^{E2}$$，这里假设 E1 &gt; E2</p>
<p><img src="/images/csapp26.jpg" alt="浮点数加法"></p>
<p>结果是 $(-1)^{s}\; M \; 2^{E}$，其中 s= s1 ^ s2, M = M1 + M2, E = E1</p>
<ul>
<li>如果 M 大于等于 2，那么把 M 右移，并增加 E 的值</li>
<li>如果 M 小于 1，把 M 左移 k 位，E 减少 k</li>
<li>如果 E 超出了可以表示的范围，溢出</li>
<li>把 M 舍入到 frac 的精度</li>
</ul>
<p>基本性质</p>
<ul>
<li>相加可能产生 infinity 或者 NaN</li>
<li>满足交换率</li>
<li>不满足结合律（因为舍入会造成精度损失，如 <code>3.14+1e10)-1e10=0</code>，但 <code>3.14+(1e10-1e10)=3.14</code>）</li>
<li>加上 0 等于原来的数</li>
<li>除了 infinity 和 NaN，每个元素都有对应的倒数</li>
<li>除了 infinity 和 NaN，满足单调性，即 $a\ge b \to a+c \ge a+b$</li>
</ul>
<h3 id="u79FB_u52A8_u6570_u636E_u4E0E_u5BFB_u5740"><a href="#u79FB_u52A8_u6570_u636E_u4E0E_u5BFB_u5740" class="headerlink" title="移动数据与寻址"></a>移动数据与寻址</h3><p>操作数主要有三种类型，一种是立即数，也就是直接给的一个数字，第二种是寄存器，第三种是内存</p>
<p><img src="/images/14531723678160.jpg" alt=""></p>
<p>普通模式，(R)，相当于 <code>Mem[Reg[R]]</code>，也就是说寄存器 R 指定内存地址，类似于 C 语言中的指针，语法为：<code>movq (%rcx), %rax</code> 也就是说以 %rcx 寄存器中存储的地址去内存里找对应的数据，存到寄存器 %rax 中</p>
<p>移位模式，D(R)，相当于 <code>Mem[Reg[R]+D]</code>，寄存器 R 给出起始的内存地址，然后 D 是偏移量，语法为：<code>movq 8(%rbp),%rdx</code> 也就是说以 %rbp 寄存器中存储的地址再加上 8 个偏移量去内存里找对应的数据，存到寄存器 %rdx 中</p>
<p><img src="/images/14531733075157.jpg" alt=""></p>
<p>举个例子：%rdx 的存着的地址是 0xf000；%rcx 的存着的地址是 0x0100，那么有：</p>
<p><img src="/images/14531733728296.jpg" alt=""></p>
<h3 id="u6761_u4EF6_u7801_u4E0E_u4EE3_u7801_u63A7_u5236"><a href="#u6761_u4EF6_u7801_u4E0E_u4EE3_u7801_u63A7_u5236" class="headerlink" title="条件码与代码控制"></a>条件码与代码控制</h3><p>最后的四个寄存器（CF, ZF, SF, OF）就是用来辅助程序的流程控制的，意思是：</p>
<ul>
<li>CF: Carry Flag (for unsigned)</li>
<li>ZF: Zero Flag</li>
<li>SF: Sign Flag (for signed)</li>
<li>OF: Overflow Flag (for signed)</li>
</ul>
<p>可以看到以上这四个寄存器，表示四种不同的状态，举个例子，假如我们有一条诸如 <code>t = a + b</code> 的语句，汇编之后假设用的是 <code>addq Src, Dest</code>，那么根据这个操作结果的不同，会相应设置上面提到的四个寄存器，而因为这个是执行类似操作时顺带尽心设置的，称为隐式设置，例如：</p>
<ul>
<li>如果两个数相加，在最高位还需要进位（也就是溢出了），那么 CF 寄存器就会被设置</li>
<li>如果 t 等于 0，那么 ZF 寄存器会被设置</li>
<li>如果 t 小于 0，那么 SF 寄存器会被设置</li>
<li>如果 2’s complement 溢出，那么 OF 寄存器会被设置为 1（溢出的情况是 <code>(a&gt;0 &amp;&amp; b &gt; 0 &amp;&amp; t &lt;0) || (a&lt;0 &amp;&amp; b&lt;0 &amp;&amp; t&gt;=0)</code>）</li>
</ul>
<p>这就发现了，其实这四个条件代码，是用来标记上一条命令的结果的各种可能的，是自动会进行设置的。注意，使用 <code>leaq</code> 指令的话不会进行设置。</p>
<h3 id="u6808_u5E27"><a href="#u6808_u5E27" class="headerlink" title="栈帧"></a>栈帧</h3><p>在 x86-64/Linux 中，栈帧的结构是固定的，当前的要执行的栈中包括：</p>
<ul>
<li>Argument Build: 需要使用的参数</li>
<li>如果不能保存在寄存器中，会把一些本地变量放在这里</li>
<li>已保存的寄存器上下文</li>
<li>老的栈帧的指针（可选）</li>
</ul>
<p>而调用者的栈帧则包括：</p>
<ul>
<li>返回地址（因为 <code>call</code> 指令被压入栈的）</li>
<li>调用所需的参数</li>
</ul>
<p>具体如下图所示：</p>
<p><img src="/images/14533846615880.jpg" alt="栈帧的例子"></p>
<h3 id="u5B58_u50A8_u76F8_u5173"><a href="#u5B58_u50A8_u76F8_u5173" class="headerlink" title="存储相关"></a>存储相关</h3><p>总的访问时间  Taccess =  寻址时间 Tavg seek + 旋转时间 Tavg rotation + 传输时间 Tavg transfer</p>
<ul>
<li>寻址时间 Tavg seek 因为物理规律的限制，一般是 3-9 ms</li>
<li>旋转延迟 Tavg rotation 取决于硬盘具体的转速，一般来说是 7200 RPM</li>
<li>传输时间 Tavg tranfer 就是需要读取的 sector 数目</li>
</ul>
<p>举个例子，假设转速是 7200 RPM，平均寻址时间 9ms，平均每个 track 的 sector 数目是 400，那么我们有：</p>
<ul>
<li>Tavg rotation = 1/2 x (60 secs / 7200 RPM) x 1000 ms/sec = 4 ms</li>
<li>Tavg transfer = 60 / 7200 RPM x 1/400 secs/track x 1000 ms/sec = 0.02 ms</li>
<li>Taccess = 9 ms + 4 ms + 0.02 ms</li>
</ul>
<p>从这里可以看出，主要决定访问时间的是寻址时间和旋转延迟；读取一个 sector 的第一个 bit 是非常耗时的，之后的都几乎可以忽略不计；硬盘比 SRAM 慢 40,000 倍，比 DRAM 慢 2500 倍。</p>
<h3 id="Locality__u4E0E_Memory_Heirarchy"><a href="#Locality__u4E0E_Memory_Heirarchy" class="headerlink" title="Locality 与 Memory Heirarchy"></a>Locality 与 Memory Heirarchy</h3><p>Locality 的思路很简单，就是如果一个数据最近被访问过，很可能还会被再次访问：</p>
<ul>
<li>Temporal locality: Recently referenced items are likely to be referenced again in the near future</li>
<li>Spatial locality: Items with nearby addresses tend to be referenced close together in time</li>
</ul>
<p>一种介质的速度越快，就会越贵，同时也消耗更多的电量，所以一般容量比较小。而 CPU 和内存之间的速度差距越来越大，所以好的程序都会尽可能利用 locality。根据这些特性，也就引申出了一个安排存储的方式，称为 memory hierarchy。</p>
<p><img src="/images/14555647586566.jpg" alt="Memory Heirarchy"></p>
<p>这里就涉及到一个技术：缓存。缓存可以看作是把大且缓慢的设备中的数据的一部分拿出来存储到其中的更快的存储设备。在 memory hierarchy 金字塔中，每一层都可以看作是下一层的缓存。利用 locality，程序会更倾向于访问第 k 层的数据，而非第 k+1 层，这样就减少了访问时间。</p>
<p><img src="/images/14555654345569.jpg" alt="访问时间比较"></p>
<h3 id="Cache_Miss"><a href="#Cache_Miss" class="headerlink" title="Cache Miss"></a>Cache Miss</h3><p>Cache miss 有三种：</p>
<ul>
<li>Cold(compulsory) Miss: CPU 第一次访问相应 cache 块，cache 中肯定没有该 cache 块，这是不可避免的</li>
<li>Confilict Miss: 在直接相联或组相联的 cache 中，不同的 cache 块由于 index 相同相互替换，引起的失效叫做冲突失效<ul>
<li>假设这里有 32KB 直接相联的 cache</li>
<li>如果有两个 8KB 的数据需要来回访问，但是这两个数组都映射到相同的地址，cache 大小足够存储全部的数据，但是因为相同地址发生了冲突需要来回替换，发生的失效则全都是冲突失效（第一次访问失效依旧是强制性失效），这时 cache 并没有存满</li>
</ul>
</li>
<li>Capacity Miss: 有限的 cache 容量导致 cache 放不下而被替换出 cache 块，被替换出去的 cache 块再被访问，引起的失效叫做容量失效<ul>
<li>假设这里有 32KB 直接相联的 cache</li>
<li>如果有一个 64KB 的数组需要重复访问，数组的大小远远大于 cache 大小，没办法全部放入 cache。第一次访问数组发生的失效全都是强制性失效。之后再访问数组，再发生的失效则全都是容量失效，这时 cache 已经存满，容量不足以存储全部数据</li>
</ul>
</li>
</ul>
<h3 id="Cache_Memories"><a href="#Cache_Memories" class="headerlink" title="Cache Memories"></a>Cache Memories</h3><p>通常来说，是按照如下图所示的方式来组织的，一定要注意 S/E/B 具体在说什么：</p>
<p><img src="/images/14555690389309.jpg" alt=""></p>
<p>实际上可以理解为三种层级关系，对应不同的索引，这样分层的好处在于，通过层级关系简化搜索需要的时间，并且和字节的排布也是一一对应的（之后介绍缓存的时候就体现得更加明显）。</p>
<p>具体的例子请参考<a href="http://wdxtub.com/2016/02/15/csapp-12/">深入理解计算机系统 第 12 课 Cache Memories</a></p>
<h3 id="Memory_Mountain"><a href="#Memory_Mountain" class="headerlink" title="Memory Mountain"></a>Memory Mountain</h3><p><img src="/images/14556314890158.jpg" alt=""></p>
<p>注意，这是根据 Core i7 得出来的图，不同的处理器可能因为不同的设计和架构而有所区别，但是可以通过不同的颜色和层次，看出不同 size 和 stride 对性能的影响。山脚是我们应该尽量避免的，山顶是我们力求达到的，也就是说，尽量一次访问一个 stride，一次读入的数据大小也不宜太大，最好和 L1 缓存数值上吻合。</p>
<h2 id="u5F80_u5E74_u8BD5_u9898_u8BB2_u89E3"><a href="#u5F80_u5E74_u8BD5_u9898_u8BB2_u89E3" class="headerlink" title="往年试题讲解"></a>往年试题讲解</h2><h3 id="u9009_u62E9_u9898_u77E5_u8BC6_u70B9"><a href="#u9009_u62E9_u9898_u77E5_u8BC6_u70B9" class="headerlink" title="选择题知识点"></a>选择题知识点</h3><ul>
<li><code>test</code> 指令和 <code>and</code> 指令一样，只设置 flag 不改变结果</li>
<li>在一个 32 位的 Linux 系统中，<code>long</code> 的大小为 <code>4 bytes</code></li>
<li>在一个 64 位的 Linux 系统中，并不是所有的参数都在栈上传递</li>
<li><code>mov</code> 和 <code>lea</code> 指令的不同在于 <code>mov</code> 会 dereferences an address，也就是说 <code>mov</code> 是取值，<code>lea</code> 是地址</li>
<li>先调用函数，然后压入 <code>%ebp</code></li>
<li>一个 8 位浮点数（1 sign, 3 exp, 4 frac），则 0 111 1111 表示 NaN</li>
<li>每次执行完一条语句，<code>%rsp</code> 的值减 8 </li>
<li>二维数组在内存中以 row-major 方式存储</li>
<li><code>%rdi</code> 保存着函数调用的第一个参数</li>
</ul>
<h3 id="u6D6E_u70B9_u6570_u7F16_u7801"><a href="#u6D6E_u70B9_u6570_u7F16_u7801" class="headerlink" title="浮点数编码"></a>浮点数编码</h3><p>这里我们考虑两种 6 位数的 IEEE 浮点数格式</p>
<ul>
<li>格式 A<ul>
<li>1 个符号位 s</li>
<li>k = 3 个 exponent bits，bias 为 $2^{k-1} - 1 = 3$</li>
<li>n = 2 个 fraction bits</li>
</ul>
</li>
<li>格式 B<ul>
<li>1 个符号位 s</li>
<li>k = 2 个 exponent bits，bias 为 $2^{k-1} - 1 = 1$</li>
<li>n = 3 个 fraction bits</li>
</ul>
</li>
</ul>
<p>注意</p>
<ul>
<li>对应于 denormalized 的情况，E = 1 - bias</li>
<li>对应于 normalized 的情况，E = exp - bias</li>
</ul>
<p>需要填写下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">Value</th>
<th style="text-align:center">Format A Bits</th>
<th style="text-align:center">Format B Bits</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Zero</td>
<td style="text-align:center">0 000 00</td>
<td style="text-align:center">0 00 000</td>
</tr>
<tr>
<td style="text-align:center">One</td>
<td style="text-align:center">0 011 00</td>
<td style="text-align:center">0 01 000</td>
</tr>
<tr>
<td style="text-align:center">$\frac{1}{2}$</td>
<td style="text-align:center">0 010 00</td>
<td style="text-align:center">0 00 100</td>
</tr>
<tr>
<td style="text-align:center">$\frac{11}{8}$</td>
<td style="text-align:center">0 011 10</td>
<td style="text-align:center">0 01 011</td>
</tr>
</tbody>
</table>
<p>我们来对应看一下具体要怎么填。</p>
<p>首先需要知道的是 IEEE 浮点数的具体格式，是 s | exp | frac。接下来要知道什么时候是 denormalized，什么时候是 normalized，简单来说就是如果 exp 全为 0 或全为 1 时，属于 denormalized，其他时候属于 normalized。</p>
<p>对应浮点数的公式</p>
<p>$$(-1)^s \; M \; 2^E$$</p>
<p>我们知道如果要表示 1，那么 E 应该等于 0，M 部分应该为 1（M 的形式应该是是 1.xxxxx，其中 xxx 是 frac 的部分，于是 frac 应该为 0）。这里 E 因为属于 normalized 的情况，所以 E = exp - bias，而 E 需要等于 0，所以 exp = bias，针对不同的格式，就可以找到对应的答案（格式 A 中 bias = 3，所以 exp 部分是 011；格式 B 中 bias = 1，所以 exp 部分是 01；frac 部分均为 0）</p>
<p>然后我们来看看如何表示 0.5，根据公式，E 应该等于 -1，那么对于格式 A，E = exp - bias，所以 exp = -1 + 3 = 2，exp 部分就是 010。但是对于格式 B 就有点不同，因为这时候是属于 denormalized 的，这时 E = 1 - bias = 0，我们需要对 frac 部分做出处理，在这种情况下(M 的形式是 0.xxx)，frac 的第一位就表示 0.5，所以最终的结果如上表所示。</p>
<p>最后我们来看看 $\frac{11}{8}$ 要如何表示，实际上就是 1 加上 $\frac{3}{8}$，因为前面已经表示过 1，所以只要在 frac 部分做做文章即可，这次我们先来看格式 B，根据浮点数的定义，我们很快就可以知道 frac 应该为 011，完成！对于格式 A，因为 frac 只有 2 位，那么就需要进行舍入（到最近的偶数），也就是 <code>011 -&gt; 01 + 01 -&gt; 10</code>，所以最终的结果如上表所示。</p>
<h3 id="u6C47_u7F16_u7A0B_u5E8F_u9605_u8BFB"><a href="#u6C47_u7F16_u7A0B_u5E8F_u9605_u8BFB" class="headerlink" title="汇编程序阅读"></a>汇编程序阅读</h3><p>假设有这么一段汇编程序</p>
<p><img src="/images/14566917311963.jpg" alt=""></p>
<p>根据上面的信息，补充完整下面对应的程序代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">transform</span><span class="params">(<span class="keyword">unsigned</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b, m;</span><br><span class="line">    <span class="keyword">for</span> (m = __; _____; _____)&#123;</span><br><span class="line">        b = ____;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            ______;</span><br><span class="line">        &#125;</span><br><span class="line">        ______;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们应该熟悉，这里 <code>%eax</code> 中存放的变量是 <code>m</code>，<code>%edx</code> 中存放的变量是 <code>n</code>。在 &lt;+6&gt; 这一行把 <code>0x0</code> 放到了 <code>%eax</code> 中，所以循环的初始条件是 <code>m=0</code>，然后 &lt;+11&gt; 这一句实际是判断 <code>%edx</code> 是否为 0，如果为 0，则跳转到 &lt;+28&gt;，所以终止条件是 <code>n != 0</code>。接着就是循环体里的内容，&lt;+15&gt; 用 <code>%dl</code> 和 <code>0x1</code> 做 <code>&amp;</code> 操作，在汇编中结果会保存到对应的 flag 中，在代码中我们就保存到了 <code>b</code> 中，如果 <code>b == 0</code>，那么就跳转到 &lt;+24&gt;，进行移位操作，也就是循环操作为 <code>n &gt;&gt;= 1</code>，否则先要执行 &lt;+20&gt;，这一句实际上就是 <code>m = m + m + 1</code>，综上所述，就可以得到最终答案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">transform</span><span class="params">(<span class="keyword">unsigned</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b, m;</span><br><span class="line">    <span class="keyword">for</span> (m = <span class="number">0</span>; n != <span class="number">0</span>; m &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        b = n &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = m + m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u7ED3_u6784_u4F53_u7684_u5185_u5B58_u6392_u5217"><a href="#u7ED3_u6784_u4F53_u7684_u5185_u5B58_u6392_u5217" class="headerlink" title="结构体的内存排列"></a>结构体的内存排列</h3><p>假设我们有下面这个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">long</span> b;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">    <span class="keyword">char</span> d[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> *e;</span><br><span class="line">    <span class="keyword">short</span> *f;</span><br><span class="line">&#125; foo;</span><br></pre></td></tr></table></figure>
<p>请给出具体的内存排列顺序。</p>
<p>首先我们需要知道每个数据类型所占据的字节数目，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 2 字节：short</span></span><br><span class="line">    <span class="comment">// 16 字节：long double</span></span><br><span class="line">    <span class="keyword">char</span> a;    <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="keyword">long</span> b;    <span class="comment">// 8 字节（其他 8 字节的有 double, 指针）</span></span><br><span class="line">    <span class="keyword">float</span> c;   <span class="comment">// 4 字节（其他 4 字节的有 int）</span></span><br><span class="line">    <span class="keyword">char</span> d[<span class="number">3</span>]; <span class="comment">// 1 x 3 字节</span></span><br><span class="line">    <span class="keyword">int</span> *e;    <span class="comment">// 8 字节</span></span><br><span class="line">    <span class="keyword">short</span> *f;  <span class="comment">// 8 字节</span></span><br><span class="line">&#125; foo;</span><br></pre></td></tr></table></figure>
<p>所以具体的排列为（用 x 表示 padding 的字节）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span> x x x x x x x <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span></span><br><span class="line">c c c c d d d x e e e e e e e e</span><br><span class="line">f f f f f f f f</span><br></pre></td></tr></table></figure>
<p> 如果想要紧凑一点，其实可以进行对其，把 a, c, d 组合一下，如</p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span> d d d c c c c <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span></span><br><span class="line">e e e e e e e e f f f f f f f f</span><br></pre></td></tr></table></figure>
<p>这样就省了 8 个字节出来</p>
<h3 id="u7ED3_u6784_u4F53_u7684_u8BBF_u95EE"><a href="#u7ED3_u6784_u4F53_u7684_u8BBF_u95EE" class="headerlink" title="结构体的访问"></a>结构体的访问</h3><p>给出下面的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> confuse &#123;</span><br><span class="line">    <span class="keyword">char</span> systems;</span><br><span class="line">    <span class="keyword">long</span> theory;</span><br><span class="line">    <span class="keyword">struct</span> applications &#123;</span><br><span class="line">        <span class="keyword">char</span> web[<span class="number">3</span>];</span><br><span class="line">    &#125; database;</span><br><span class="line">    <span class="keyword">int</span> *languages;</span><br><span class="line">    <span class="keyword">struct</span> confuse *math;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题是，右边的汇编程序分别对应哪个函数：</p>
<p><img src="/images/14566942080505.jpg" alt=""></p>
<p>根据上一题，我们可以先画出具体的内存排列，用变量的首字母作为缩写，用 x 表示 padding：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s x x x x x x x t t t t t t t t</span><br><span class="line">w w w x x x x x <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span></span><br><span class="line"><span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="literal">m</span></span><br></pre></td></tr></table></figure>
<p>然后根据偏移量来数对应的变量即可，其中要注意的是十六进制转十进制的运算。比较简单，最后的对应为：</p>
<ul>
<li>A - phd</li>
<li>B - bachelors</li>
<li>C = masters</li>
</ul>
<h3 id="Switch__u8BED_u53E5"><a href="#Switch__u8BED_u53E5" class="headerlink" title="Switch 语句"></a>Switch 语句</h3><p>我们先来看跳转表：</p>
<p><img src="/images/14566960252571.jpg" alt="跳转表"></p>
<p>接着是汇编程序</p>
<p><img src="/images/14566960458022.jpg" alt=""></p>
<p>我们要做的是补充完整下面的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">4</span>;   </span><br><span class="line">    <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            _____;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            _____;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            result = ____;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            _____;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            _____;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            _____;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编程序中负责跳转的是 <code>0x40047b    jmpq  *0x400598(, %rdi, 8)</code>，其中 <code>%rdi</code> 就是变量 <code>a</code> 的值，仔细观察跳转表和程序，可以发现一些规律：</p>
<ul>
<li>a 等于 0 或 1 的时候，做的事情是一样的，并且直到执行完 a 等于 2 的语句才会返回</li>
<li>a 等于 5 时是一套独立的指令</li>
<li>a 等于 3 和 7 时，做的事情类似，并且最后都会执行默认的命令</li>
<li>switch 语句中有些有 break，有些没有</li>
</ul>
<p>有了这些线索，就可以『翻译』对应的汇编代码了，答案如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">4</span>;   </span><br><span class="line">    <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            result = c - <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            result = c * <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            result = <span class="number">0x15213</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            c = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            b = b &amp; c;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = b + <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u6808_u7684_u5E94_u7528"><a href="#u6808_u7684_u5E94_u7528" class="headerlink" title="栈的应用"></a>栈的应用</h3><p>这一题主要考察函数调用时候压栈出栈以及栈指针和返回地址的理解，C 代码和对应的汇编代码为：</p>
<p><img src="/images/14567011035267.jpg" alt=""></p>
<p>我们需要画出栈中的数据存放表示，具体的函数是 <code>foo(3, 4, 5)</code>，注意要标志出 <code>%ebp</code> 的值</p>
<p>在调用 <code>foo</code> 函数时 <code>%ebp</code> 的值为 <code>0xffffd858</code>，调用 <code>foo</code> 的函数的返回地址是 <code>0x080483c9</code></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stack      The diagram starts with theaddresss   arguments for foo()</span><br><span class="line">           +-----------------------------------+0xffffd850 |<span class="string">                5                  </span>|           +-----------------------------------+0xffffd84c |<span class="string">                4                  </span>|           +-----------------------------------+0xffffd848 |<span class="string">                3                  </span>|           +-----------------------------------+0xffffd844 |<span class="string">      return addr 0x080483c9       </span>|           +-----------------------------------+0xffffd840 |<span class="string">        old ebp 0xffffd858         </span>|           +-----------------------------------+0xffffd83c |<span class="string">                3                  </span>|           +-----------------------------------+0xffffd838 |<span class="string">                4                  </span>|           +-----------------------------------+0xffffd834 |<span class="string">      return addr 0x08048397       </span>|           +-----------------------------------+0xffffd830 |<span class="string">        old ebp 0xffffd858         </span>|           +-----------------------------------+</span><br></pre></td></tr></table></figure>
<p>我们来看看这题要怎么做。首先，老师还是很贴心的给出了第一个参数在栈中的位置，不过开始之前还是先要弄明白我们到底需要在栈中放什么东西。首先是函数的参数（倒着放，这样第一个参数才能先弹出来），然后是返回值地址和旧的 <code>%ebp</code> 指针，这俩是为了告诉指令该去哪，以及栈要去哪的。</p>
<p>所以答案就呼之欲出了，前三个简单，543 一路下来即可；接下来是返回地址，也就是题目给出的初始条件；再下来是题目给出的初始 ebp；接着是调用 <code>bar</code> 函数的栈排列，也还是参数，但是这里题目是换了顺序的，所以先 3 后 4；然后是返回值地址，找到汇编代码中 call 的下一句，就是它了；最后一句可有可无，不过为了清晰 ebp 的做用，还是写上，应该指向旧的 ebp 地址，也就是 <code>0xffffd840</code>，至此，题目完成。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一次我们主要来回顾一下重要的知识点，以及讲解一些往年试题中容易混淆的概念。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="复习" scheme="http://wdxtub.com/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
