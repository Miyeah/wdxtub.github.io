<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-03-04T14:11:24.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[第八周 - 请走人行道]]></title>
    <link href="http://wdxtub.com/2016/03/04/walkway/"/>
    <id>http://wdxtub.com/2016/03/04/walkway/</id>
    <published>2016-03-04T13:13:24.000Z</published>
    <updated>2016-03-04T14:11:24.000Z</updated>
    <content type="html"><![CDATA[<p>不懂什么是骄傲，不懂什么是个性，不懂什么才算胡闹。</p>
<a id="more"></a>
<hr>
<p>腥风血雨的考试周总算是安然度过，虽然还有几百个坑要填，但是至少在接下来了两个月里有比较稳定的时间推进自己的计划了。少不了更高负荷的工作，不过做自己喜欢且想做的事情，本就没有苦与累。</p>
<p>最近的伙食标准比油价还低，基本都是做一顿吃两天，弄点肉加上豆子玉米胡萝卜，呼噜噜就是一大锅，有空的时候炒个青菜，这样每次煮个饭，往饭上一盖一浇，完事儿！时间久了，室友就吐槽『我都问吐了你还没吃吐嘛』。本来想回敬一波鸡汤，不过最后还是决定，只要她们不吐在我锅里，咱们就还是阳关道和独木桥。</p>
<p>不过这样吃有个好处，因为同样的肉往往要吃一个星期，现在对随着时间推移的肉质衰减以及不同部位的口感有了完全不同的认识。不过仔细想想这也有坏处，以后在学校吃快餐肯定得一边想着这是剩了几天的肉一边往肚子里塞了。另外一个收获是不同部位的差别真的跟价钱上反映出来的一致，一开始也许只能大概感觉出不同，但是一直吃吃吃，就真的能吃出个门道。</p>
<p>美国这边的肉（尤其是猪肉）大多带有奇怪的腥臭味（至少我家附近的超市里卖的是这样），区别就是贵的味道小一些，突出表现就是要么需要做之前焯一下，要么就煮的时候需要滤出血渣雪沫（不然味道不好）。抛开这个不说，切肉的时候，不同的纹理，不同的肥瘦，不同的切法都会影响最终的口感。总体来说，还是里脊部分（或者其他同等位置）的肉无论纹理还是口感最好（排骨不在比较之列，带骨头现在比较少吃了）。不过因为纹理结构比较深，最好提前腌制一下，这样更入味。</p>
<p>基础好的肉，口感衰减得比较慢，估计是因为内在结构更加紧密一些；基础差的肉，很快就散架了（可以想象肉松都是什么肉做的）。这个故事告诉我们，如果我们一定要做一块肉，那么要好好锻炼，成为有嚼劲紧实的肌肉，不要做松松垮垮的肥肉（但是五花肉也很好吃，纠结）。</p>
<p>最近身边的同学都进入了找工作找实习的白热化阶段，虽然我现在无论怎么样都有点『站着说话不腰疼』的感觉，不过还是觉得越是在意的事情，越应该淡定。在学校里要获得肯定，更多是一个单边操作，好好学习，好好考试，好好做研究，好好发论文，自然水涨船高。但是工作中不是养，变成了双边关系，很多老师未曾教过的东西，反而成为了关键。</p>
<p>找工作与其说是找一份工作，不如说是找到自己适合什么工作，化简一下就是找到自己。在不断的测试中了解自己擅长什么，喜欢什么，想要什么，这个很关键。具体到刷题之类的东西，其实是个人努力，有一个基准线在那里，过了就好。我想做什么工作，你能提供什么职位，这两个有多匹配，能不能接受，能接受咱们继续，不行就好聚好散。遇到的面试官很多，真正能让我看出有『智慧』的凤毛麟角（挑一道现成的面试题谁不会呢？），很多时候也影响了我对这家公司的看法。选择工作就是选择环境，不要被各种乱七八糟的光环亮瞎了双眼，还是那句话，要有自己的判断和选择，不能『随大流』。</p>
<p>前些天快到学校的时候，脑子里蹦出了『Form』 这个词，没想到特别合适的中文词汇（也许『形成』或者『塑造』合适？）。回忆过去，从小学到初中，从初中到高中，从高中到大学，从大学到研究生，虽然可能当时感觉不到太多的变化，但是按照历史课本的说法，总有那么一个标志性事件，把一条线段一分为二。在这个时间点之前，可以看做是发散的自我逐渐汇聚形成新自我的过程，而在这个时间点之后，是把自己重新散开等待下一个自我形成的过程。新的自我是怎么样的，就是『Form』的过程了。找到几个关键的核心，然后创造出新的『原子』和『分子』，最后形成全新的自己。不破不立，长肌肉是这样，成长同样也是这样。</p>
<p>既然如此，就不要害怕未知，不要害怕迷茫，每次都选择正确的事做很难，不如直接做自己喜欢做的事情（压根不需要选择了），坚持，直到它成为正确的事情。</p>
<p>世界很大无数奥妙，我要寻找我要奔跑，冲进那自由天地，什么事我都要做到。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>不懂什么是骄傲，不懂什么是个性，不懂什么才算胡闹。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="春假" scheme="http://wdxtub.com/tags/%E6%98%A5%E5%81%87/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 反思课 2 并发编程的策略与思考]]></title>
    <link href="http://wdxtub.com/2016/03/03/cc-rethink-2/"/>
    <id>http://wdxtub.com/2016/03/03/cc-rethink-2/</id>
    <published>2016-03-03T12:28:38.000Z</published>
    <updated>2016-03-03T15:03:41.000Z</updated>
    <content type="html"><![CDATA[<p>学习是一个不断改进方法论的过程，<a href="http://wdxtub.com/2016/02/29/cc-15/">第 15 课</a>中，因为自己缺乏对并发编程的基本认识，走了很多弯路。吃一堑长一智，本文着重讲三点：一是为什么我会犯错，二是对并发编程的一些思考，三是结合 Java 语言来探索相关细节。（感谢节瓜 @jiexing 的耐心指导）</p>
<a id="more"></a>
<hr>
<h2 id="u5E94_u7528_u573A_u666F"><a href="#u5E94_u7528_u573A_u666F" class="headerlink" title="应用场景"></a>应用场景</h2><p>因为涉及到具体的问题，所以先大概说明一下应用场景，方便之后的叙述。事情大概是这样的：</p>
<ul>
<li>后端有三台数据库服务器</li>
<li>需要支持两种不同的存储策略（复制机制与分区机制，详情参考<a href="http://wdxtub.com/2016/02/29/cc-15/">这里</a>）</li>
<li>由前端来接收和处理请求（不使用任何缓存）</li>
<li>请求有两种：GET（从数据库读取数据）与 PUT（向数据库写入数据）</li>
<li>数据的格式是键值对</li>
<li>保证数据的强一致性</li>
<li>按照请求的顺序返回响应（按照时间戳来排序）</li>
</ul>
<p>难点在于，每来一个请求，服务器都会新开一个线程来进行处理，多个线程的访问需要保证数据一致性及顺序，如果没有真正理解场景本身，很容易陷入无谓的复杂度，写出冗长却不完备的代码。</p>
<h2 id="u6211_u9519_u4E86"><a href="#u6211_u9519_u4E86" class="headerlink" title="我错了"></a>我错了</h2><p>写代码之前，我花了很多时间，试图找到一个合理的满足一致性和顺序的机制。根据文档的提示，用锁来保证一致性，用优先队列来保证顺序，万万没想到这就是一切复杂度的开端，最后我折腾出来的机制大概是这样的：</p>
<ul>
<li>每个 key 有自己的锁和优先队列</li>
<li>每来一个请求，把它加入到对应 key 的优先队列中</li>
<li>然后开一个线程，取出优先队列的队头进行处理</li>
<li>具体线程之间的同步由锁完成（在停止尝试之前已经变得很复杂，这里不详细展开，总的来说我试图利用三个状态手动控制线程的执行）</li>
<li>因为不同的线程可能需要访问同一个数据结构（这里我用 HashMap 来存储），也要考虑线程同步的问题，于是我决定依赖于『线程安全』的数据结构自动处理好访问冲突</li>
</ul>
<p>看起来还行，但是实际测试的时候既不能保证强一致性也没办法按顺序，甚至还引入了新的问题，这是为什么呢？我总结的原因如下：</p>
<ul>
<li>每次接收请求，新开的线程不一定执行这个请求对应的内容，而是执行队列头，让新线程做太复杂的工作</li>
<li>为了保证逻辑一致性被迫设计状态判断的机制，但是没办法穷举出所有的可能</li>
<li>控制线程时利用自动数据结构+手动逻辑控制，并没有得到半自动冲锋枪突突突的效果，而是乱成了一锅粥</li>
</ul>
<p>后来在瓜瓜的指引下找到了简单且有效的方法，关键点在于：</p>
<ul>
<li>要自动就全自动，要手动就全手动，不要依赖于自己并不完全理解的容器或者数据结构，因为很可能会和自己预期的表现不一样</li>
<li>每个线程应该就处理好传入的请求，而不是可能执行另外的请求（我之前的机制这种情况是可能出现的）</li>
<li>不要想当然去『控制』线程以达到最优性能，很多串行编程的思维在这里并不适用。</li>
</ul>
<p>从这样的思路拓展开去，就可以意识到自己之前的思路有多么『想当然』了。</p>
<h2 id="u4E00_u4E9B_u601D_u8003"><a href="#u4E00_u4E9B_u601D_u8003" class="headerlink" title="一些思考"></a>一些思考</h2><blockquote>
<p>Intuition is frequently wrong - be data intensive. [《Real-World Concurrency》 from ACM-Queue]</p>
</blockquote>
<p>如果要给云计算这门课一个关键词，当属 tradeoff。所谓权衡的艺术，从不同的角度来看，有不同的表现：</p>
<ul>
<li>从实现的角度，尽量以最小的代码换取最大的性能</li>
<li>从架构的角度，尽量以简洁的架构满足需求，减少复杂性</li>
<li>从经济的角度，尽力以最小的花费提供最好的服务质量</li>
</ul>
<p>同样的，对于并发编程，也是如此。</p>
<blockquote>
<p>Multi-threading is easy. Correct synchronization is hard</p>
</blockquote>
<p>最难的当属思维的转换，很多比较复杂的算法（或者说依赖比较多的算法），在并行环境中往往表现不好，比如说动态规划问题，原本是重复利用子问题的解，但是在多线程的条件下，子问题都不知道飞哪里去了；反而是分治算法，因为子问题独立，反而更适合并行。</p>
<p>而提到并发编程，就不得不提 OpenMP 了，这个学期当助教，我主要负责这一部分的内容，所以也算是有一些理解。OpenMP 的思路是利用尽可能少的代价，把串行代码弄成并行的，核心的机制是共享内存，然后利用线程执行不同的子问题，可能只需要几条 OpenMP 预编译指令，就可以带来明显的性能提升效果。</p>
<p>但是仔细想想，这种改进真的很大吗？在串行代码开发中，程序控制有一个清晰的流程。我们知道数据被访问和更改的方式，并了解其中的依赖关系。究其根本，OpenMP 依赖数据资源的锁定，和串行编程的思路是一样的，只是利用多核进行了简单的并行处理（相当于多叫几个人完成同一个工作，而不是大家做不同的工作）。如果使用不慎，除了带来性能问题之外，还可能造成数据不一致的问题。</p>
<p>而真正的并行程序中，有多个状态会同时发生和改变，依赖关系也会发生变化。必须思考如何同时执行多个指令，以及这些指令会对你的数据结构、变量、算法及其它一切产生什么影响。</p>
<p>总结一下：</p>
<ul>
<li>单线程逻辑设计的思路<ul>
<li>所有数据结构的生存期，以及对这些数据结构的访问都在同一个线程，不存在竞争条件，耗时的操作都给其他线程（IO线程、定时器线程，数据库线程等）做，做完之后向事件队列（多线程安全的队列，其他线程是生产者，逻辑线程是消费者）发送事件</li>
</ul>
</li>
<li>多线程逻辑设计的思路<ul>
<li>所有数据结构的生存期，以及对这些数据结构的访问不一定在同一个线程。需要考虑数据结构的竞争条件。网络事件、定时器事件唤醒工作线程（比方说 <code>notifyAll</code>）执行所有工作，一般不需要交换到其他线程</li>
</ul>
</li>
</ul>
<p>我们可以看出，最关键的就是如何访问数据的问题！线程执行和访问数据的时间没有确定的顺序。操作系统负责对线程进行调度，而它对于数据访问模式一无所知。并行程序中唯一的顺序是我们利用同步方法明确创建的（前面我把这部分工作交给自己并不熟悉的并行库来做，导致出问题）。最重要的是要牢牢记住所有并发线程，这样才能够创建更简单更有约束性的结构来限制并发情况。还有一个需要记得的点是，可能最优化的串行算法并不是好的并行算法。</p>
<p>最后的最后，并发编程真的是一门『纸上得来终觉浅』的艺术，最佳途径就是实践，实践，再实践。</p>
<h2 id="u4E00_u4E9B_u5BF9_u7B56"><a href="#u4E00_u4E9B_u5BF9_u7B56" class="headerlink" title="一些对策"></a>一些对策</h2><p>这里结合了 CMU 18645 How to Write Fast Code 课程上的一些思路，虽然对于具体场景不算特别适用，不过总体原则放到哪里都能用。</p>
<p>先说说优化并行部分的三个层面：</p>
<ul>
<li>逻辑层面：减少数据共享<ul>
<li>这一部分需要注意 false sharing 的问题，不然反而会造成大量的缓存浪费</li>
<li>解决方法也不算太难：线程本地存储 + 内存对齐，不过需要根据不同的机器不同处理</li>
</ul>
</li>
<li>编码层面：减少锁粒度<ul>
<li>同一个模块中，对不总是同时访问的数据，使用不同的锁（固定加锁顺序，防止死锁）</li>
<li>使用锁（临界区）来保护数据，而不是操作</li>
<li>将可能耗时的操作移到临界区外面（特别是 IO）</li>
<li>避免在临界区中调用未知代码 </li>
<li>谨慎使用读写锁，实现复杂，效率低下</li>
</ul>
</li>
<li>工具层面：使用轻量同步机制<ul>
<li>有些需要深入到内核态进行同步，对于基本的操作来说其实没必要这么兴师动众</li>
</ul>
</li>
</ul>
<p>换一个视角，可以总结出如下四条原则：</p>
<ol>
<li>单一职责：分离并发相关代码和其他代码（并发相关代码有自己的开发、修改和调优生命周期）</li>
<li>限制数据作用域：两个线程修改共享对象的同一字段时可能会相互干扰，导致不可预期的行为，解决方案之一是构造临界区，但是必须限制临界区的数量</li>
<li>使用数据副本：数据副本是避免共享数据的好方法，复制出来的对象只是以只读的方式对待</li>
<li>线程应尽可能独立：让线程存在于自己的世界中，不与其他线程共享数据。Servlet 就是以单实例多线程的方式工作，和每个请求相关的数据都是通过 Servlet 子类的 service 方法（或者是 doGet 或 doPost 方法）的参数传入的。只要 Servlet 中的代码只使用局部变量，Servlet 就不会导致同步问题</li>
</ol>
<p>在搜索资料的时候发现一个不错的提纲，不过因为刚接触，很多概念理解得不算特别清楚这里列出来，作为一个索引，感兴趣的同学可以按图索骥去深入了解下（参考资料中第二项）：</p>
<ul>
<li>资源并发访问的策略<ul>
<li>悲观策略<ul>
<li>lock based concurrency(theory)</li>
<li>java.util.concurrent (framework)</li>
<li>锁还是不锁，这是个问题， 锁多还是锁少，也是个问题(practice)</li>
</ul>
</li>
<li>乐观策略<ul>
<li>lock free concurrency(theory) : CAS</li>
<li>disruptor (framework)</li>
<li>并发度高，还是并发度低的时候使用，这是个问题(practice)</li>
</ul>
</li>
</ul>
</li>
<li>我拆我拆我拆拆拆（逻辑上拆分任务）<ul>
<li>task-based concurrency (theory)<ul>
<li>Runnable | Callable(model)</li>
<li>Executor | ExecutorService(framework)</li>
</ul>
</li>
<li>data-based concurrency(theory)<ul>
<li>Actor (model)</li>
<li>Akka(framework)</li>
</ul>
</li>
</ul>
</li>
<li>从单机到分布式<ul>
<li>divide and conquer<ul>
<li>map reduce pattern</li>
<li>master-worker pattern</li>
</ul>
</li>
<li>swarm framework(move computation instead of data)</li>
</ul>
</li>
<li>从软件到硬件<ul>
<li>GPU<ul>
<li>CUDA, jcuda, scuda</li>
<li>floating point computation, e.g. image reader and processing</li>
</ul>
</li>
<li>PPU<ul>
<li>物理计算</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>看了这么多，唯一的感受就是</p>
<blockquote>
<p>路漫漫其修远兮，吾将上下而求索。</p>
</blockquote>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.jianshu.com/p/053943a425c3" target="_blank" rel="external">Java并发编程的总结与思考</a></li>
<li><a href="http://afoo.me/posts/2013-03-12-concurrency_theory_frameworks_and_practices.html" target="_blank" rel="external">并发编程： 理论，框架与实践</a></li>
<li><a href="http://blog.csdn.net/lantian0802/article/details/19285937" target="_blank" rel="external">java并发编程学习总结（基础篇）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>学习是一个不断改进方法论的过程，<a href="http://wdxtub.com/2016/02/29/cc-15/">第 15 课</a>中，因为自己缺乏对并发编程的基本认识，走了很多弯路。吃一堑长一智，本文着重讲三点：一是为什么我会犯错，二是对并发编程的一些思考，三是结合 Java 语言来探索相关细节。（感谢节瓜 @jiexing 的耐心指导）</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="多线程" scheme="http://wdxtub.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 Twitter 语料分析 3 Vert.x 配置部署]]></title>
    <link href="http://wdxtub.com/2016/03/01/cc-p3/"/>
    <id>http://wdxtub.com/2016/03/01/cc-p3/</id>
    <published>2016-03-01T20:42:05.000Z</published>
    <updated>2016-03-02T00:19:44.000Z</updated>
    <content type="html"><![CDATA[<p>我们需要比较两个不同的 web 框架的性能，于是也选择了当下比较热门的 Vert.x 框架来做比较，网上的中文资源还是比较少的，这里同样记录一下如何在 EC2 上搭建和部署 Vert.x。</p>
<a id="more"></a>
<hr>
<h2 id="u73AF_u5883_u914D_u7F6E"><a href="#u73AF_u5883_u914D_u7F6E" class="headerlink" title="环境配置"></a>环境配置</h2><p>先启动一个标准的 Ubuntu 镜像（因为有 apt-get 安装软件比较方便）</p>
<p>我们需要安装 java 和 maven，并配置好对应的路径，具体参考下面的命令，这里和之前不同的是需要安装 Java 8，以及 maven 3：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 java,maven</span></span><br><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java8-installer</span><br><span class="line">sudo add-apt-repository <span class="string">"deb http://ppa.launchpad.net/natecarlson/maven3/ubuntu precise main"</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install maven3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认 jdk</span></span><br><span class="line">sudo update-alternatives --config java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 Java Home 编辑 ~/.bashrc</span></span><br><span class="line">JAVA_HOME=/usr/</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span></span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>同样用 maven 来创建项目，这次我们直接手动现在本地建立如下所示的文件层级：</p>
<p><img src="/images/14568662369892.jpg" alt="项目目录"></p>
<p>然后我们修改 <code>pom.xml</code> 文件，具体如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">project</span> <span class="attribute">xmlns</span>=<span class="value">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://maven.apache.org/POM/4.0.0</span><br><span class="line">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="title">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>housailei.vertx<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>vertx-server<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="title">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>io.vertx<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>vertx-core<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="title">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="title">source</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="title">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">execution</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="title">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="title">phase</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="title">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="title">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">transformers</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="title">transformer</span></span><br><span class="line">                    <span class="attribute">implementation</span>=<span class="value">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">manifestEntries</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="title">Main-Class</span>&gt;</span>io.vertx.core.Starter<span class="tag">&lt;/<span class="title">Main-Class</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="title">Main-Verticle</span>&gt;</span>housailei.vertx.App<span class="tag">&lt;/<span class="title">Main-Verticle</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="title">manifestEntries</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="title">transformer</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">transformers</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">artifactSet</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">outputFile</span>&gt;</span>$&#123;project.build.directory&#125;/$&#123;project.artifactId&#125;-$&#123;project.version&#125;-fat.jar<span class="tag">&lt;/<span class="title">outputFile</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们在 <code>src/main/java/housailei/vertx/</code> 下创建一个 <code>App.java</code> 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> housailei.vertx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.core.AbstractVerticle;</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; fut)</span> </span>&#123;</span><br><span class="line">    vertx</span><br><span class="line">        .createHttpServer()</span><br><span class="line">        .requestHandler(r -&gt; &#123;</span><br><span class="line">          r.response().end(<span class="string">"&lt;h1&gt;Hello from my first "</span> +</span><br><span class="line">              <span class="string">"Vert.x 3 application! config by dawang&lt;/h1&gt;"</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .listen(<span class="number">8080</span>, result -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">            fut.complete();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fut.fail(result.cause());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们把代码上传回服务器上：<code>scp -i ../group.pem -r ./* ubuntu@dns.amazonaws.com:~/vertx-server/</code></p>
<p>执行的话稍微麻烦一点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn3 clean package</span><br><span class="line">java -jar target/vertx-server-<span class="number">1.0</span>-SNAPSHOT-fat.jar</span><br></pre></td></tr></table></figure>
<p>正常运行如下图所示：</p>
<p><img src="/images/14568725986794.jpg" alt="正常运行截图"></p>
<h2 id="u5B9E_u73B0_REST"><a href="#u5B9E_u73B0_REST" class="headerlink" title="实现 REST"></a>实现 REST</h2><p>前面的代码虽然可以工作，我们没办法设定不同的 api，也没办法做更进一步的处理，所以我们现在来更进一步，实现一个 RESTful 的简易 API。</p>
<p>我们先要在 <code>pom.xml</code> 文件中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>io.vertx<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>vertx-web<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后对应修改 <code>start</code> 方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Future&lt;Void&gt; fut)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create a router object.</span></span><br><span class="line">   Router router = Router.router(vertx);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bind "/" to our hello message - so we are still compatible.</span></span><br><span class="line">   router.route(<span class="string">"/"</span>).handler(routingContext -&gt; &#123;</span><br><span class="line">   HttpServerResponse response = routingContext.response();</span><br><span class="line">   response</span><br><span class="line">      .putHeader(<span class="string">"content-type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">      .end(<span class="string">"&lt;h1&gt;Hello from my first "</span> +</span><br><span class="line">         <span class="string">"Vert.x 3 application! config by dawang&lt;/h1&gt;"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create the HTTP server and pass the "accept" method to the request handler.</span></span><br><span class="line">   vertx.createHttpServer().requestHandler(router::accept)</span><br><span class="line">       .listen(</span><br><span class="line">       <span class="comment">// Retrieve the port from the configuration,</span></span><br><span class="line">       <span class="comment">// default to 8080.</span></span><br><span class="line">       config().getInteger(<span class="string">"http.port"</span>, <span class="number">8080</span>), result -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">               fut.complete();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               fut.fail(result.cause());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在开始start方法里创建了一个 <code>Router</code> 对象。router 是 Vert.x Web 的基础，负责分发 HTTP 请求到 handler（处理器），在Vert.x Web中还有两个很重要的概念。</p>
<ul>
<li>Route - 定义请求的分发</li>
<li>Handler - 这是实际处理请求并且返回结果的地方。Handlers可以被链接起来使用。</li>
</ul>
<p>如果明白了这3个概念（Router、Routes、Handlers），就能明白 Vert.x Web 了。</p>
<p>重新运行一次，可以看到结果如下：</p>
<p><img src="/images/14568771965878.jpg" alt="再次配置成功"></p>
<p>然后我们多定义几个接口，并对应不同的方法来实现，同样是在 <code>start</code> 方法中，添加两条 router 规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">"/api/hou"</span>).handler(<span class="keyword">this</span>::HouHandler);</span><br><span class="line">router.get(<span class="string">"/api/sai"</span>).handler(<span class="keyword">this</span>::SaiHandler);</span><br></pre></td></tr></table></figure>
<p>然后创建对应的方法（就不用都写在一个函数里了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HouHandler</span><span class="params">(RoutingContext routingContext)</span></span>&#123;</span><br><span class="line">   routingContext.response()</span><br><span class="line">       .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json; charset=utf-8"</span>)</span><br><span class="line">       .end(<span class="string">"This is Hou HOu HOU!!! API!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SaiHandler</span><span class="params">(RoutingContext routingContext)</span></span>&#123;</span><br><span class="line">   routingContext.response()</span><br><span class="line">       .putHeader(<span class="string">"content-type"</span>, <span class="string">"application/json; charset=utf-8"</span>)</span><br><span class="line">       .end(<span class="string">"This is Sai SAi SAI!!! API!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再测试一下，可以看到 api 已经启用了：</p>
<p><img src="/images/14568776771132.jpg" alt="Hou Content"></p>
<p><img src="/images/14568776972444.jpg" alt="Sai Content"></p>
<p>有了这些，我们就可以自己来进行操作了，虽然可能代码丑一些，不过易上手，容易改。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://vertx.io/docs/" target="_blank" rel="external">官方文档</a></li>
<li><a href="http://vertx.io/docs/vertx-core/java/" target="_blank" rel="external">Vertx Core 手册</a></li>
<li><a href="http://vertx.io/docs/apidocs/" target="_blank" rel="external">Vertx Core API 文档</a></li>
<li><a href="http://vertx.io/docs/vertx-web/java/" target="_blank" rel="external">Vertx Web 手册</a></li>
<li><a href="http://vertx.io/docs/apidocs/" target="_blank" rel="external">Vertx Web API 文档</a></li>
</ul>
<p>非常有用的新手入门教程</p>
<ul>
<li><a href="http://vertx.io/blog/my-first-vert-x-3-application/index.html" target="_blank" rel="external">My first Vert.x 3 Application</a></li>
<li><a href="http://vertx.io/blog/vert-x-application-configuration/" target="_blank" rel="external">Vert.x Application Configuration</a></li>
<li><a href="http://vertx.io/blog/some-rest-with-vert-x/" target="_blank" rel="external">Some Rest with Vert.x</a></li>
<li><a href="http://vertx.io/blog/unit-and-integration-tests/" target="_blank" rel="external">Unit and Integration Tests</a></li>
<li><a href="https://github.com/quanke/vertx3_study_demo" target="_blank" rel="external">中文机器翻译版本</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们需要比较两个不同的 web 框架的性能，于是也选择了当下比较热门的 Vert.x 框架来做比较，网上的中文资源还是比较少的，这里同样记录一下如何在 EC2 上搭建和部署 Vert.x。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Vertx" scheme="http://wdxtub.com/tags/Vertx/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="服务" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 Twitter 语料分析 2 Undertow 配置部署]]></title>
    <link href="http://wdxtub.com/2016/03/01/cc-p2/"/>
    <id>http://wdxtub.com/2016/03/01/cc-p2/</id>
    <published>2016-03-01T14:41:11.000Z</published>
    <updated>2016-03-01T21:04:27.000Z</updated>
    <content type="html"><![CDATA[<p>因为项目有一定的性能要求，所以我们选择 Undertow 这个微框架来降低框架本身带来的性能影响，但是因为比较小众，所以网上很多资料都不全，这里记录下具体在 EC2 上如何配置和部署 Undertow。</p>
<a id="more"></a>
<hr>
<h2 id="u73AF_u5883_u914D_u7F6E"><a href="#u73AF_u5883_u914D_u7F6E" class="headerlink" title="环境配置"></a>环境配置</h2><p>先启动一个标准的 Ubuntu 镜像（因为有 apt-get 安装软件比较方便）</p>
<p>我们需要安装 java 和 maven，并配置好对应的路径，具体参考下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 java,maven</span></span><br><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java7-installer</span><br><span class="line">sudo apt-get install maven2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认 jdk</span></span><br><span class="line">sudo update-alternatives --config java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 Java Home 编辑 ~/.bashrc</span></span><br><span class="line">JAVA_HOME=/usr/</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span></span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure>
<p>如果一切正常的话，使用 <code>java -version</code> 可以看到：</p>
<p><img src="/images/14568475090854.jpg" alt="java -version"></p>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>我们创建一个项目来搭建服务器，因为 undertow 是使用 maven 来管理包和依赖的，所以我们也直接用 maven 来创建项目</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建项目，注意设置包名和项目名称</span></span><br><span class="line">mvn archetype:generate -DgroupId=housailei.undertow -DartifactId=p1_front -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=<span class="literal">false</span> -DartifactId=undertow-server</span><br></pre></td></tr></table></figure>
<p>为了编辑方便，我们把项目复制到本地</p>
<p><code>scp -i group.pem -r ubuntu@dns.amazonaws.com:~/undertow-server/* ./</code></p>
<p> 编辑完成可以用下面的命令上传回去（注意所在文件夹，我这里新建了一个文件夹用来存放源代码，密钥放在上一层）</p>
<p><code>scp -i ../group.pem -r ./* ubuntu@dns.compute-1.amazonaws.com:~/undertow-server/</code></p>
<p><img src="/images/14568478192103.jpg" alt="目录层级"></p>
<p>我们需要对 <code>App.java</code> 和 <code>pom.xml</code> 做一些修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> housailei.undertow;</span><br><span class="line"><span class="keyword">import</span> io.undertow.Undertow;</span><br><span class="line"><span class="keyword">import</span> io.undertow.server.*;</span><br><span class="line"><span class="keyword">import</span> io.undertow.util.Headers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// 设置成 0.0.0.0 开放访问以便测试</span></span><br><span class="line">        Undertow server = Undertow.builder().addHttpListener(<span class="number">8080</span>, <span class="string">"0.0.0.0"</span>)</span><br><span class="line">            .setHandler(<span class="keyword">new</span> HttpHandler() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> HttpServerExchange exchange)</span></span><br><span class="line">                       <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,</span><br><span class="line">                           <span class="string">"text/plain"</span>);</span><br><span class="line">               exchange.getResponseSender().send(<span class="string">"Hello World! This is wdxtub."</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;).build();</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 pom 文件的修改主要就是加上各类依赖，已经添加构建插件，我们这里选用了最新的 undertow，具体需要添加以下两个部分：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>io.undertow<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>undertow-core<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.3.18.Final<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>io.undertow<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>undertow-servlet<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.3.18.Final<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>和 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">build</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>exec-maven-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">execution</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="title">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">goal</span>&gt;</span>java<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="title">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">mainClass</span>&gt;</span>housailei.undertow.App<span class="tag">&lt;/<span class="title">mainClass</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后上传回 EC2 实例，就可以用以下代码执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile &amp;&amp; mvn <span class="built_in">exec</span>:java</span><br></pre></td></tr></table></figure>
<p>服务器正常开启之后，我们就可以在浏览器中访问了：</p>
<p><img src="/images/14568488280327.jpg" alt="访问网站"></p>
<h2 id="u6DFB_u52A0_Servlet"><a href="#u6DFB_u52A0_Servlet" class="headerlink" title="添加 Servlet"></a>添加 Servlet</h2><p>现在我们的服务器基本除了展示个页面没办法做任何事情，我们需要能让服务器运行 servlet 才行（最新版本的 undertow 会有一些小问题，会具体标记出来）</p>
<p>我们先写两个简单的 servlet，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个 servlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span>&#123;</span><br><span class="line">        message = <span class="string">"Hou HOu HOU!!!! Servlet!!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(<span class="string">"&lt;h1&gt;"</span> + message + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个 servlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaiServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span>&#123;</span><br><span class="line">        message = <span class="string">"Sai SAi SAI!!!! Servlet!!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(<span class="string">"&lt;h1&gt;"</span> + message + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改 <code>App.java</code> 把这两个 servlet 载入进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYAPP = <span class="string">"/hsl"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 官方例子中使用的 addServlets 方法不可用</span></span><br><span class="line">            <span class="comment">// 这里我用了 addServlet 方法</span></span><br><span class="line">            DeploymentInfo servletBuilder = Servlets.deployment()</span><br><span class="line">                .setClassLoader(App.class.getClassLoader())</span><br><span class="line">                .setContextPath(MYAPP)</span><br><span class="line">                .setDeploymentName(<span class="string">"test.war"</span>)</span><br><span class="line">                .addServlet(</span><br><span class="line">                        Servlets.servlet(<span class="string">"HouServlet"</span>, HouServlet.class)</span><br><span class="line">                                .addMapping(<span class="string">"/hou"</span>))</span><br><span class="line">                .addServlet(</span><br><span class="line">                        Servlets.servlet(<span class="string">"SaiServlet"</span>, SaiServlet.class)</span><br><span class="line">                                .addMapping(<span class="string">"/sai"</span>));</span><br><span class="line"></span><br><span class="line">            DeploymentManager manager = Servlets.defaultContainer().addDeployment(servletBuilder);</span><br><span class="line">            manager.deploy();</span><br><span class="line"></span><br><span class="line">            HttpHandler servletHandler = manager.start();</span><br><span class="line">            PathHandler path = Handlers</span><br><span class="line">                .path(Handlers.redirect(MYAPP))</span><br><span class="line">                .addPrefixPath(MYAPP, servletHandler);</span><br><span class="line"></span><br><span class="line">            Undertow server = Undertow.builder()</span><br><span class="line">                .addHttpListener(<span class="number">8080</span>, <span class="string">"0.0.0.0"</span>)</span><br><span class="line">                .setHandler(path)</span><br><span class="line">                .build();</span><br><span class="line">            server.start();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着还是传到服务器上并 <code>mvn compile &amp;&amp; mvn exec:java</code>，就可以看到结果</p>
<p><img src="/images/14568573432825.jpg" alt="SaiServlet 结果"></p>
<p><img src="/images/14568573815710.jpg" alt="HouServlet 结果"></p>
<p>之后的任务就可以在 Servlet 的 <code>doGet</code> 方法中对应写代码完成了。</p>
<p>后面应该会写一些脚本把配置的工作自动化，因为每次新建 EC2 都得重新配置还是挺麻烦的。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://undertow.io/undertow-docs/undertow-docs-1.3.0/index.html#introduction" target="_blank" rel="external">官方文档</a></li>
<li><a href="http://undertow.io/javadoc/1.3.x/index.html" target="_blank" rel="external">官方 JavaDoc</a></li>
<li><a href="https://github.com/undertow-io/undertow/tree/master/examples/src/main/java/io/undertow/examples" target="_blank" rel="external">官方样例代码</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为项目有一定的性能要求，所以我们选择 Undertow 这个微框架来降低框架本身带来的性能影响，但是因为比较小众，所以网上很多资料都不全，这里记录下具体在 EC2 上如何配置和部署 Undertow。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Undertow" scheme="http://wdxtub.com/tags/Undertow/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="服务" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 第 15 课 分区和复制]]></title>
    <link href="http://wdxtub.com/2016/02/29/cc-15/"/>
    <id>http://wdxtub.com/2016/02/29/cc-15/</id>
    <published>2016-02-29T12:01:54.000Z</published>
    <updated>2016-03-03T04:45:39.000Z</updated>
    <content type="html"><![CDATA[<p>之前我们做的是计算能力的伸缩拓展，这次我们也要对数据库做类似的事情，并且通过具体的场景，来了解键值对存储的应用特点。特别鸣谢瓜瓜 @jiexing 的点拨，不然我就卡在自己脑洞里出不来了。</p>
<a id="more"></a>
<hr>
<h2 id="u5B66_u4E60_u76EE_u6807"><a href="#u5B66_u4E60_u76EE_u6807" class="headerlink" title="学习目标"></a>学习目标</h2><ol>
<li>了解分布式键值对存储的设计空间和动机</li>
<li>比较在键值对存储中使用复制和分区的异同及优劣</li>
<li>利用复制或分区机制来拓展分布式键值对存储</li>
<li>了解并实现一致性哈希算法，并借此说明其在分布式键值对存储中的分区起到的作用</li>
<li>把复制和分区技术应用到现实场景中</li>
</ol>
<p>一致性哈希算法的要求很简单：</p>
<blockquote>
<p>在任何时候，对于同一个 key，要返回同一个 value</p>
</blockquote>
<p>理论上的要求很简洁，但具体实现的时候就会有需要细节了，比方说如何平均分配不同的 key，如果处理错误的状况等等。</p>
<h2 id="u80CC_u666F_u77E5_u8BC6"><a href="#u80CC_u666F_u77E5_u8BC6" class="headerlink" title="背景知识"></a>背景知识</h2><p>随着互联网、电子商务和社交媒体的快速发展，很多公司都不得不面对日益增长的数据量。如何存储、处理和分析这些数据越来越成为巨大的挑战。因为数据量已经远超一台机器可以承载的范围，我们需要分布式可拓展的存储系统。这里我们会专注于分布式键值对存储系统（也是 NoSQL 存储系统）。键值对存储系统支持两个基本操作：</p>
<ol>
<li><code>PUT</code> 请求，把一条记录放到数据库中</li>
<li><code>GET</code> 请求，从数据库中获取指定数据</li>
</ol>
<p>分布式键值对存储包含多个节点（可能不在一个地方），一个比较常见的做法是利用最近的服务器来处理对应请求以减少延迟。</p>
<p>说到数据库的扩展性，我们可以通过下面的视频来进行基本的了解</p>
<p><a href="https://www.youtube.com/watch?v=opYWHWG-vVg" target="_blank" rel="external">Video 1: Database Scaling</a></p>
<p>下面是视频中的要点：</p>
<ul>
<li>Vertical Scaling：提高硬件和软件配置（CPU, Memory, Disk, Network）<ul>
<li>优势：迁移简单，使用已有的软件</li>
<li>限制：硬件成本快速增长，可能最强大的硬件也不够用</li>
</ul>
</li>
<li>Horizontal Scaling：从一台数据库服务器扩展为数据库服务器集群，有下面两种机制来进行<ul>
<li>Replication 复制：每台数据库服务器都有同样的数据，读数据的时候没有问题，写数据的时候需要考虑数据同步的问题。对读数据性能要求较高的应用可以采用这种机制。</li>
<li>Sharding 分区：每台数据库服务器保存部分的数据库文件，需要决定什么时候访问哪台服务器，需要一个分区表。具体的分隔可以以行来分(Horizontal Partitioning)或者以列来分(Vertical Partitioning)。对写数据性能要求较高的应用可以采用这种机制。</li>
</ul>
</li>
</ul>
<p>这两个机制各有侧重点，这里简要介绍一下。</p>
<h3 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h3><p>对于复制机制来说，每次更新数据，都需要把改动『广播』到所有的节点上以保证数据一致性，如果系统的容错性要求很高，那么复制机制可能是比较好的选择，下图是一个例子：</p>
<p><img src="/images/14567497209474.jpg" alt="有 3 个复制节点的数据库"></p>
<p>在复制的情况下，主要的优化机制是提供不同级别的一致性保证。在一个数据库节点的某条记录被修改时，其他数据库中对应的记录是不可访问的，直到三个数据库的数据完全同步之后才可以，如下：</p>
<p><img src="/images/14567498771413.jpg" alt="强一致性保证"></p>
<p>并且，操作的不同顺序也会以时间戳的方式进行记录和排序，为了保证强一致性，需要保证任何时候从任何复制节点读取的数据都是一样的，具体的规则如下表所示</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">强一致性</td>
<td style="text-align:center">任何时候从任何复制节点中相同的 key 对应相同的 value</td>
</tr>
<tr>
<td style="text-align:center">严格排序</td>
<td style="text-align:center">按时间顺序处理请求</td>
</tr>
<tr>
<td style="text-align:center">原子操作</td>
<td style="text-align:center">所有的操作都应该是原子的，不能同时更新</td>
</tr>
<tr>
<td style="text-align:center">访问控制</td>
<td style="text-align:center">一个 key 在被更新时其他节点中的对应 key 不能访问</td>
</tr>
</tbody>
</table>
<h3 id="Sharding"><a href="#Sharding" class="headerlink" title="Sharding"></a>Sharding</h3><p>对于分区机制来说，可以直接用下图来描述与复制机制的区别（比较简单这里不详细介绍）</p>
<p><img src="/images/14567501863377.jpg" alt="三种方式的对比"></p>
<h2 id="u80CC_u666F_u8BBE_u5B9A"><a href="#u80CC_u666F_u8BBE_u5B9A" class="headerlink" title="背景设定"></a>背景设定</h2><p>简单来说就是要做一个支持 <code>PUT</code> 和 <code>GET</code> 的分布式键值对存储系统，保存以下两种数据：</p>
<ol>
<li>销售记录：保存支付密码等关键交易信息，一定要非常安全，不能轻易丢失。用户也会频繁访问购买历史，所以会有很多 <code>GET</code> 的操作，于是会采用复制机制</li>
<li>匿名日志：包含页面访问及歌曲收听记录等匿名日志，只会在用户行为分析的时候使用，并且对于安全性的要求没那么高，反而是会有很多 <code>PUT</code> 的操作，所以会利用分区机制。</li>
</ol>
<p>整个系统的设计如下：</p>
<p><img src="/images/14567578576946.jpg" alt=""></p>
<p>每个 datastore 已经帮我们配置好了，所以不必修改，我们需要做的就是折腾好 <code>Coordinator</code> 部分，也就是接收请求并转发给合适的 datastore</p>
<h2 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h2><p>具体的实现包含两个部分，分别对应前面提到的两种不同的需求。具体的需求如下</p>
<ul>
<li>并发执行<ul>
<li>利用多线程来并行处理不同的请求，已经提供了框架代码</li>
</ul>
</li>
<li>确定的行为<ul>
<li>不会出现竞争条件，利用各种保证并行安全的技术来实现</li>
</ul>
</li>
<li>非阻塞 <code>PUT</code> 操作<ul>
<li>具体参考下面的图示</li>
</ul>
</li>
<li>严格排序<ul>
<li>根据请求到来的顺序处理请求，已有的代码是包含时间戳的</li>
</ul>
</li>
<li>无缓存 Coordinator<ul>
<li>在处理请求的过程中临时保存请求是可以的，但是不能有持久的缓存</li>
</ul>
</li>
<li>动态策略<ul>
<li>Coordinator 应该支持后端的变动</li>
</ul>
</li>
</ul>
<p><img src="/images/14567593452426.jpg" alt="错误！阻塞了请求"></p>
<p><img src="/images/14567593813304.jpg" alt="正确！非阻塞机制"></p>
<h2 id="u4EFB_u52A1_u7B80_u4ECB"><a href="#u4EFB_u52A1_u7B80_u4ECB" class="headerlink" title="任务简介"></a>任务简介</h2><ul>
<li>打上标签：<code>Project: 3.2</code></li>
<li>Datastore: <code>ami-83ba8ae9</code>, <code>t1.micro</code></li>
<li>Coordinator:  <code>ami-17a4947d</code>, <code>t1.micro</code></li>
<li>Client:  <code>ami-a05d60ca</code>, <code>m1.small</code></li>
</ul>
<p>具体步骤</p>
<ol>
<li>开启 3 个 datastore 实例，注意允许 8080 端口的访问</li>
<li>在浏览器中访问 <code>http://[DATASTORE-DNS]:8080/test</code> 来测试 datastore 是否正常运行</li>
<li>开启 1 个 coordinator 实例，在 <code>/home/ubuntu/Project3_2/vertx/bin/</code> 可以看到一个 <code>Coordinator.java</code> 文件，我们主要会在这里完成代码 </li>
<li>使用命令 <code>./vertx run Coordinator.java</code> 来启动 coordinator</li>
<li>第一部分工作我们需要拓展 <code>Coordinator.java</code> 来完成复制机制</li>
<li>第二部分工作我们需要完成分区机制</li>
</ol>
<p>访问接口</p>
<ul>
<li><code>http://[Coordinator-DNS]:8080/storage?storage=TYPE_OF_STORAGE</code><ul>
<li>指定需要支持的存储类型（复制与分区），用来设置具体不同的模式</li>
</ul>
</li>
<li><code>http://[Coordinator-DNS]:8080/put?key=KEY&amp;value=VALUE</code><ul>
<li>接收键值对并保存在 datastore 实例中</li>
</ul>
</li>
<li><code>http://[Coordinator-DNS]:8080/get?key=KEY&amp;loc=LOCATION</code><ul>
<li>接收需要查询的 key，并包含指定的获取位置（1/2/3 为对应的序号），在分区机制中，如果指定的实例没有对应的 value，那么返回 0，如果没有指定获取位置，那么就根据哈希的结果从对应的实例中获取</li>
</ul>
</li>
<li>不同线程可以同时访问这些 API</li>
</ul>
<p>我们还提供了一个辅助类 <code>KeyValueLib</code>，可以在 <code>Coordinator.java</code> 中访问：</p>
<ul>
<li><code>KeyValueLib.PUT(String datastoreDNS, String key, String value)</code><ul>
<li>把键值对保存到对应的实例中</li>
</ul>
</li>
<li><code>KeyValueLib.GET(String datastoreDNS, String key)</code><ul>
<li>从指定的实例中得到对应 key 的 value</li>
</ul>
</li>
</ul>
<p>在设计 Coordinator 时，可以认为：</p>
<ul>
<li>GET 操作的延时是可以忽略的</li>
<li>可以认为 datastore 实例不会出现崩溃的状况，一旦 <code>KeyValueLib.PUT</code> 方法执行完成，那么对应的实例上的操作也完成，所以需要的同步机制不会太复杂。提示：不需要实现 <a href="http://en.wikipedia.org/wiki/Two-phase_commit_protocol" target="_blank" rel="external">Two-Phase Commit (2PC)</a> 机制</li>
</ul>
<h2 id="u7EBF_u7A0B_u540C_u6B65_u7B56_u7565"><a href="#u7EBF_u7A0B_u540C_u6B65_u7B56_u7565" class="headerlink" title="线程同步策略"></a>线程同步策略</h2><p>整个项目中最重要的是两个事情：数据一致性与严格顺序。严格顺序比较好完成，利用时间戳做评测标准使用优先队列来处理即可，因为需要保证非阻塞，所以针对复制机制，大概的流程如下（这个思路是不对的，或者说增加了无谓的复杂度，具体会另开一个反思课说明）：</p>
<ol>
<li>每个 key 都应该有自己的优先队列，来缓存可能需要等待的请求，并借此保证顺序（队列的操作应该是线程安全的，需要上锁）</li>
<li>每来一个请求，就会根据请求类型的不同在不同的 <code>handle</code> 方法中处理</li>
<li>每个 key 都应该有自己的锁，这样不会影响到其他 key 的访问，这里使用 <code>HashMap</code> 来存储</li>
<li>每次来一个请求，都需要先加入对应 key 的队列</li>
<li>在新开的线程，如果写操作正在进行，从队列中取出第一个请求进行操作，读取的话就上读锁，写入的话就上写锁</li>
<li>如果是写入的话，需要同步到其他两台机器</li>
<li>如果是读取的话，因为读锁是允许并发的，所以不需要为三个不同的数据库设计保存不同的锁，没有指定那个数据库的话，就随便访问一个即可</li>
<li>如果获取的时候没有对应的 key，返回 0</li>
</ol>
<p>针对分区机制，大概的流程如下（这个思路是不对的，或者说增加了无谓的复杂度，具体会另开一个反思课说明）：</p>
<ol>
<li>每个请求需要根据 key 来进行哈希，确定所在的数据库编号</li>
<li>每来一个请求，就会根据请求类型的不同在不同的 <code>handle</code> 方法中处理</li>
<li>每次来一个请求，都需要先加入对应 key 的队列</li>
<li>每个 key 都应该有自己的锁，这样不会影响到其他 key 的访问，这里使用 <code>HashMap</code> 来存储</li>
<li>在新开的线程，如果写操作正在进行，从队列中取出第一个请求进行操作，读取的话就上读锁，写入的话就上写锁</li>
<li>每个 key 都应该有自己的优先队列，来缓存可能需要等待的请求，并借此保证顺序（队列的操作应该是线程安全的，需要上锁）</li>
<li>获取的时候，如果指定的实例没有对应的 value（也就是和哈希出来的数据库编号不一致），那么返回 0</li>
<li>如果获取的时候没有对应的 key，返回 0</li>
</ol>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue里面存储的对象必须是实现Comparable接口。队列通过这个接口的compare方法确定对象的priority。</p>
<p>规则是：当前和其他对象比较，如果compare方法返回负数，那么在队列里面的优先级就比较高。</p>
<p>PriorityBlockingQueue队列添加新元素时候不是将全部元素进行顺序排列，而是从某个指定位置开始将新元素与之比较，一直比到队列头，这样既能保证队列头一定是优先级最高的元素，又能减少排序带来的性能消耗。每取一个头元素时候，都会对剩余的元素做一次调整，这样就能保证每次队列头的元素都是优先级最高的元素。</p>
<p>下面是 Thinking in Java 中的一个例子 - 使用PriorityBlockingQueue进行任务按优先级同步执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;   </span><br><span class="line"><span class="keyword">import</span> java.util.List;   </span><br><span class="line"><span class="keyword">import</span> java.util.Queue;   </span><br><span class="line"><span class="keyword">import</span> java.util.Random;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.PriorityBlockingQueue;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrioritizedTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Comparable</span>&lt;<span class="title">PrioritizedTask</span>&gt;   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = counter++;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> priority;   </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> List&lt;PrioritizedTask&gt; sequence = <span class="keyword">new</span> ArrayList&lt;PrioritizedTask&gt;();   </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrioritizedTask</span><span class="params">(<span class="keyword">int</span> priority)</span>    </span><br><span class="line">    </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.priority = priority;   </span><br><span class="line">        sequence.add(<span class="keyword">this</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">       </span><br><span class="line">    <span class="annotation">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PrioritizedTask o)</span> </span>&#123;   </span><br><span class="line">        <span class="comment">//复写此方法进行任务执行优先级排序   </span></span><br><span class="line"><span class="comment">//      return priority &lt; o.priority ? 1 :   </span></span><br><span class="line"><span class="comment">//          (priority &gt; o.priority ? -1 : 0);   </span></span><br><span class="line">        <span class="keyword">if</span>(priority &lt; o.priority)   </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;   </span><br><span class="line">        &#125;<span class="keyword">else</span>   </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span>(priority &gt; o.priority)   </span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;   </span><br><span class="line">            &#125;<span class="keyword">else</span>   </span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">   </span><br><span class="line">    <span class="annotation">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="comment">//执行任务代码..   </span></span><br><span class="line">        <span class="keyword">try</span> &#123;   </span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">250</span>));   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;   </span><br><span class="line">               </span><br><span class="line">        &#125;   </span><br><span class="line">        System.out.println(<span class="keyword">this</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">       </span><br><span class="line">    <span class="annotation">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%1$-3d]"</span>, priority) + <span class="string">" Task id : "</span> + id;   </span><br><span class="line">    &#125;   </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">summary</span><span class="params">()</span>   </span><br><span class="line">    </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"( Task id : "</span> + id + <span class="string">" _priority : "</span> + priority + <span class="string">")"</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">       </span><br><span class="line">    <span class="comment">/**  </span><br><span class="line">     * 结束所有任务  </span><br><span class="line">     */</span>   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EndSentinel</span> <span class="keyword">extends</span> <span class="title">PrioritizedTask</span>   </span><br><span class="line">    </span>&#123;   </span><br><span class="line">        <span class="keyword">private</span> ExecutorService exec;   </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EndSentinel</span><span class="params">(ExecutorService e)</span> </span>&#123;   </span><br><span class="line">            <span class="keyword">super</span>(Integer.MAX_VALUE);   </span><br><span class="line">            exec = e;   </span><br><span class="line">        &#125;   </span><br><span class="line">           </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>   </span><br><span class="line">        </span>&#123;   </span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;   </span><br><span class="line">            <span class="keyword">for</span>(PrioritizedTask pt : sequence)   </span><br><span class="line">            &#123;   </span><br><span class="line">                System.out.print(pt.summary());   </span><br><span class="line">                <span class="keyword">if</span>(++count % <span class="number">5</span> == <span class="number">0</span>)   </span><br><span class="line">                &#123;   </span><br><span class="line">                    System.out.println();   </span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">            System.out.println();   </span><br><span class="line">            System.out.println(<span class="keyword">this</span> + <span class="string">"Calling shutdownNow()"</span>);   </span><br><span class="line">            exec.shutdownNow();   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line">   </span><br><span class="line"><span class="comment">/**  </span><br><span class="line"> * 制造一系列任务,分配任务优先级  </span><br><span class="line"> */</span>   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrioritizedTaskProducer</span> <span class="keyword">implements</span> <span class="title">Runnable</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);   </span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Runnable&gt; queue;   </span><br><span class="line">    <span class="keyword">private</span> ExecutorService exec;   </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrioritizedTaskProducer</span><span class="params">(Queue&lt;Runnable&gt; q, ExecutorService e)</span>    </span><br><span class="line">    </span>&#123;   </span><br><span class="line">        queue = q;   </span><br><span class="line">        exec = e;   </span><br><span class="line">    &#125;   </span><br><span class="line">       </span><br><span class="line">    <span class="annotation">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">           </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)   </span><br><span class="line">        &#123;   </span><br><span class="line">            queue.add(<span class="keyword">new</span> PrioritizedTask(rand.nextInt(<span class="number">10</span>)));   </span><br><span class="line">            Thread.yield();   </span><br><span class="line">        &#125;   </span><br><span class="line">           </span><br><span class="line">        <span class="keyword">try</span> &#123;   </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;   </span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">250</span>);   </span><br><span class="line">                queue.add(<span class="keyword">new</span> PrioritizedTask(<span class="number">10</span>));   </span><br><span class="line">            &#125;   </span><br><span class="line">               </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)   </span><br><span class="line">            &#123;   </span><br><span class="line">                queue.add(<span class="keyword">new</span> PrioritizedTask(i));   </span><br><span class="line">            &#125;   </span><br><span class="line">               </span><br><span class="line">            queue.add(<span class="keyword">new</span> PrioritizedTask.EndSentinel(exec));   </span><br><span class="line">               </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;   </span><br><span class="line">               </span><br><span class="line">        &#125;   </span><br><span class="line">           </span><br><span class="line">        System.out.println(<span class="string">"Finished PrioritizedTaskProducer"</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="comment">/**  </span><br><span class="line"> * 使用PriorityBlockingQueue进行任务按优先级同步执行  </span><br><span class="line"> */</span>   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrioritizedTaskConsumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> PriorityBlockingQueue&lt;Runnable&gt; q;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrioritizedTaskConsumer</span><span class="params">(PriorityBlockingQueue&lt;Runnable&gt; q)</span>   </span><br><span class="line">    </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.q = q;   </span><br><span class="line">    &#125;   </span><br><span class="line">   </span><br><span class="line">    <span class="annotation">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">try</span>    </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted())    </span><br><span class="line">            &#123;   </span><br><span class="line">                q.take().run();   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)    </span><br><span class="line">        &#123;   </span><br><span class="line">        &#125;   </span><br><span class="line">        System.out.println(<span class="string">"Finished PrioritizedTaskConsumer"</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">       </span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueueDemo</span> </span>&#123;   </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span>   </span><br><span class="line">    </span>&#123;   </span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();   </span><br><span class="line">        PriorityBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> PriorityBlockingQueue&lt;Runnable&gt;();   </span><br><span class="line">           </span><br><span class="line">        exec.execute(<span class="keyword">new</span> PrioritizedTaskProducer(queue, exec));   </span><br><span class="line">        <span class="keyword">try</span> &#123;   </span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">250</span>);   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;   </span><br><span class="line">        &#125;   </span><br><span class="line">        exec.execute(<span class="keyword">new</span> PrioritizedTaskConsumer(queue));   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u8BFB_u5199_u9501_ReadWriteLock"><a href="#u8BFB_u5199_u9501_ReadWriteLock" class="headerlink" title="读写锁 ReadWriteLock"></a>读写锁 ReadWriteLock</h3><p>读写锁分为读锁和写锁，多个读锁之间是不需要互斥的(读操作不会改变数据，如果上了锁，反而会影响效率)，写锁和写锁之间需要互斥，也就是说，如果只是读数据，就可以多个线程同时读，但是如果你要写数据，就必须互斥，使得同一时刻只有一个线程在操作。在同一线程中，持有读锁后，不能直接调用写锁的lock方法 ，否则会造成死锁。</p>
<p>一个简单的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadWrite</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 共享数据，只能一个线程写数据，可以多个线程读数据 */</span></span><br><span class="line">	<span class="keyword">private</span> Object data = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">/* 创建一个读写锁 */</span></span><br><span class="line">	ReadWriteLock rwlock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 读数据，可以多个线程同时读， 所以上读锁即可</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">/* 上读锁 */</span></span><br><span class="line">		rwlock.readLock().lock();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" 准备读数据!"</span>);</span><br><span class="line">			<span class="comment">/* 休眠 */</span></span><br><span class="line">			Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"读出的数据为 :"</span> + data);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			rwlock.readLock().unlock();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 写数据，多个线程不能同时写 所以必须上写锁</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 上写锁 */</span></span><br><span class="line">		rwlock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" 准备写数据!"</span>);</span><br><span class="line">			<span class="comment">/* 休眠 */</span></span><br><span class="line">			Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" 写入的数据: "</span> + data);</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			rwlock.writeLock().unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/* 创建ReadWrite对象 */</span></span><br><span class="line">		<span class="keyword">final</span> ReadWrite readWrite = <span class="keyword">new</span> ReadWrite();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 创建并启动3个读线程 */</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="annotation">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					readWrite.get();</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">/*创建3个写线程*/</span></span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;	</span><br><span class="line">				<span class="annotation">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="comment">/*随机写入一个数*/</span></span><br><span class="line">					readWrite.put(<span class="keyword">new</span> Random().nextInt(<span class="number">8</span>));				</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5F3A_u4E00_u81F4_u590D_u5236_u673A_u5236"><a href="#u5F3A_u4E00_u81F4_u590D_u5236_u673A_u5236" class="headerlink" title="强一致复制机制"></a>强一致复制机制</h2><p>在分布式应用中，一致性是非常重要的，这里我们简要介绍一下</p>
<p><img src="/images/14567642451622.jpg" alt="一个银行系统的数据存储"></p>
<p>如果没有保证强一致性，那么上图中所示的场景可能就会出问题，如果同时取出 <code>$50</code>，那么可能最后的结果是两边都变成 <code>$950</code>，而不是正确的 <code>$900</code>，所以正确的做法是只能让一边完成操作，然后当数据库同步完成后，另一个操作才可以执行。</p>
<p>根据这个要求，我们的 Coordinator 还需要满足如下的强一致性需求：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">强一致性</td>
<td style="text-align:center">任何时候从任何复制节点中相同的 key 对应相同的 value</td>
</tr>
<tr>
<td style="text-align:center">严格排序</td>
<td style="text-align:center">对应 key 相同的操作，按时间顺序处理请求</td>
</tr>
<tr>
<td style="text-align:center">原子操作</td>
<td style="text-align:center">所有的操作都应该是原子的，不能同时更新</td>
</tr>
<tr>
<td style="text-align:center">访问控制</td>
<td style="text-align:center">一个 key 在被更新时其他节点中的对应 key 不能访问</td>
</tr>
</tbody>
</table>
<blockquote>
<p>提示</p>
</blockquote>
<ol>
<li>如果对并行编程不熟悉，需要复习多线程，线程安全和保证执行顺序的策略等相关内容</li>
<li>需要在给 PUT 排序的时候执行显式同步。注意可能引起的<a href="http://stackoverflow.com/questions/34510/what-is-a-race-condition" target="_blank" rel="external">竞争条件</a></li>
<li>有若干种方法来处理锁与竞争条件，可以参考<a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html" target="_blank" rel="external">这里</a>以及<a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html" target="_blank" rel="external">同步</a>的详细信息</li>
<li>使用时间戳来进行排序，<a href="https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html" target="_blank" rel="external">优先队列</a>会很有用</li>
<li>需要重设 datastore 时，可以访问 <code>http://[Datastore-DNS]:8080/flush</code></li>
<li>刚连上远程实例的时候会有比较大的延迟，请耐心等待，不要 <code>ctrl+c</code>，不然会出问题</li>
<li>早点开始，并行编程可能会比想象中要麻烦得多</li>
</ol>
<blockquote>
<p>提交方式</p>
</blockquote>
<ol>
<li>启动一个 <code>m1.small</code>(<code>ami-a05d60ca</code>) 客户端实例</li>
<li>进入 <code>/home/ubuntu/Project3_2/</code>，包含 <code>storage_checker</code>, <code>config.prop</code>, <code>submitter</code> 和 <code>references</code></li>
<li>可以用 <code>storage_checker</code> 来检测正确性，但是使用之前需要先填写 <code>config.prop</code>（注意里面 datastore 的顺序要和 <code>Coordinator.java</code> 中的保持一致）</li>
<li>填写完成后可以使用 <code>./storage_checker.sh replication</code> 来进行测试。</li>
</ol>
<h2 id="u5E73_u5747_u5206_u914D_u5206_u533A_u673A_u5236"><a href="#u5E73_u5747_u5206_u914D_u5206_u533A_u673A_u5236" class="headerlink" title="平均分配分区机制"></a>平均分配分区机制</h2><p>在分区机制中最重要的就是哈希函数，使用哈希的话，不可避免会出现<a href="https://en.wikipedia.org/wiki/Collision_(computer_science" target="_blank" rel="external">冲突</a> )的情况，所以评价一个哈希函数好不好，主要看能否使用这个哈希函数把输入尽可能平均分摊到不同的 key 中。</p>
<p>举个例子，假设我们的输入是 1-6 六个数字，有如下两个哈希函数</p>
<ul>
<li>函数 A<ul>
<li>1,2,3: -&gt; 0</li>
<li>4,5,6: -&gt; 1</li>
</ul>
</li>
<li>函数 B<ul>
<li>1,2,3,4,5: -&gt; 0</li>
<li>6        : -&gt; 1</li>
</ul>
</li>
</ul>
<p>因为函数 A 使得分布更平均，于是在这个场景中，函数 A 更好。在这个项目中，哈希函数用来决定数据应该存放在哪个数据库实例中，所以我们的目标是设计一个尽可能平均分配请求的哈希函数</p>
<p>具体的需求如下：</p>
<ul>
<li>一致性分区<ul>
<li>对于给定的 key，只会被分配到同一个实例上，同一个 key 只能存在与一个实例中</li>
</ul>
</li>
<li>一致性哈希<ul>
<li>对于给定的输入，每次哈希得到的值是一致的</li>
</ul>
</li>
<li>独立数据中心锁<ul>
<li>对于一个实例的请求不会令其他实例上锁</li>
</ul>
</li>
<li>非阻塞 PUT 操作<ul>
<li>对于一个实例的请求阻塞其他请求</li>
</ul>
</li>
<li>严格顺序<ul>
<li>要保持请求的顺序</li>
</ul>
</li>
</ul>
<p>其他需要注意的地方</p>
<ul>
<li>key “a” 必须放在 datastore 1 中</li>
<li>key “b” 必须放在 datastore 2 中</li>
<li>key “c” 必须放在 datastore 3 中</li>
<li>其他的 key 应该尽可能平均分配</li>
<li>不允许使用 <code>.hashCode()</code> 方法</li>
</ul>
<blockquote>
<p>提示</p>
</blockquote>
<ol>
<li>上一节的提示也适用于这一节</li>
<li>可以通过数学方法来得到哈希函数，也可以记录下 key 的分布对应来设计</li>
<li>当一致性模式改变的时候，注意清空你使用的数据结构</li>
<li>早点开始</li>
</ol>
<blockquote>
<p>提交方式</p>
</blockquote>
<ol>
<li>可以用 <code>storage_checker</code> 来检测正确性，使用之前需要先填写 <code>config.prop</code>（注意里面 datastore 的顺序要和 <code>Coordinator.java</code> 中的保持一致），然后使用 <code>./storage_checker.sh sharding</code> 来测试</li>
<li>测试完成之后，需要把 <code>Coordinator.java</code> 移动到客户端实例的 <code>/home/ubuntu/</code> 文件夹中，对应填写 <code>references</code></li>
<li>用 <code>./submitter.sh</code> 进行提交</li>
<li>TA 会人工给代码打分，尤其是可能的竞争条件，还要注意代码风格</li>
</ol>
<h2 id="u64CD_u4F5C_u65E5_u5FD7"><a href="#u64CD_u4F5C_u65E5_u5FD7" class="headerlink" title="操作日志"></a>操作日志</h2><ul>
<li>申请 EC2 实例：<code>ami-17a4947d</code>(<code>t1.micro</code>)，注意打开所有端口。</li>
<li>把要修改的文件复制到本地 <code>scp -i demo.pem ubuntu@dns.compute-1.amazonaws.com:~/Project3_2/vertx/bin/Coordinator.java ./</code></li>
<li>修改完成后传回服务器 <code>scp -i demo.pem ./Coordinator.java ubuntu@dns.compute-1.amazonaws.com:~/Project3_2/vertx/bin/</code></li>
<li>使用命令 <code>./vertx run Coordinator.java</code> 来启动 coordinator（也可以用来检查语法错误）</li>
<li>启动三个 datastore： <code>ami-83ba8ae9</code>(<code>t1.micro</code>)，注意打开所有端口</li>
<li>启动一个 <code>m1.small</code>(<code>ami-a05d60ca</code>) 客户端实例</li>
<li>分别把地址写到 <code>Coordinator.java</code> 和 <code>config.prop</code> 中</li>
<li>把 <code>config.prop</code> 复制到本地 <code>scp -i demo.pem ubuntu@dns.compute-1.amazonaws.com:~/config.prop ./</code></li>
<li>添加完之后复制回去 <code>scp -i demo.pem ./config.prop ubuntu@dns.compute-1.amazonaws.com:~/</code></li>
<li>使用 <code>./storage_checker.sh replication</code> 来进行测试</li>
<li>完成第一部分后，使用 <code>./storage_checker.sh sharding</code> 来测试第二部分</li>
<li>填写 <code>references</code> 以及把 <code>Coordinator.java</code> 上传到客户端实例 <code>scp -i demo.pem ./Coordinator.java ubuntu@dns.compute-1.amazonaws.com:~/</code></li>
<li>然后就提交 <code>./submitter.sh</code></li>
</ul>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://blog.csdn.net/lzm1340458776/article/details/27964243" target="_blank" rel="external">Java多线程中读写锁ReadWriteLock的使用</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html" target="_blank" rel="external">Class PriorityBlockingQueue<e></e></a></li>
<li><a href="http://www.cnblogs.com/techyc/p/3272321.html" target="_blank" rel="external">Java的wait(), notify()和notifyAll()使用小结</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前我们做的是计算能力的伸缩拓展，这次我们也要对数据库做类似的事情，并且通过具体的场景，来了解键值对存储的应用特点。特别鸣谢瓜瓜 @jiexing 的点拨，不然我就卡在自己脑洞里出不来了。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="数据库" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 期中考试复习]]></title>
    <link href="http://wdxtub.com/2016/02/28/csapp-midterm-review/"/>
    <id>http://wdxtub.com/2016/02/28/csapp-midterm-review/</id>
    <published>2016-02-28T13:08:37.000Z</published>
    <updated>2016-03-01T14:10:17.000Z</updated>
    <content type="html"><![CDATA[<p>这一次我们主要来回顾一下重要的知识点，以及讲解一些往年试题中容易混淆的概念。</p>
<a id="more"></a>
<hr>
<h2 id="u77E5_u8BC6_u70B9_u68B3_u7406"><a href="#u77E5_u8BC6_u70B9_u68B3_u7406" class="headerlink" title="知识点梳理"></a>知识点梳理</h2><p>范围是第 1-3 章和第 6 章，下面是部分知识点（每个其实都包含不少内容，建议再看一次我前面写过的系列，这里还是会挑一些重点来写以下）</p>
<ul>
<li>十六进制表示</li>
<li>数据类型的字节表示</li>
<li>C 语言中的位操作、逻辑操作、左移右移操作</li>
<li>整型的表示方法及运算方式</li>
<li>浮点数的表示方法及运算方式</li>
<li>理解汇编：访问数据，算术和逻辑运算，控制，过程调用，数组的内存空间分配和访问，结构体/联合体的表示，数据对齐</li>
<li>理解指针，栈帧以及常见的攻击方式</li>
<li>内存相关话题：Locality, Memory Hierarchy, Cache Memories</li>
</ul>
<h3 id="u5E03_u5C14_u8FD0_u7B97"><a href="#u5E03_u5C14_u8FD0_u7B97" class="headerlink" title="布尔运算"></a>布尔运算</h3><p>集合 A</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01101001</span> &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="number">76543210</span></span><br></pre></td></tr></table></figure>
<p>集合 B</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01010101</span> &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="number">76543210</span></span><br></pre></td></tr></table></figure>
<p>那么不同的布尔运算就代表：</p>
<ul>
<li><code>&amp;</code> 交集 Intersection <code>01000001</code> {0, 6}</li>
<li><code>|</code> 并集 Union <code>01111101</code> {0, 2, 3, 4, 5, 6}</li>
<li><code>^</code> 差集 Symmetric difference <code>00111100</code> {2, 3, 4, 5}</li>
<li><code>~</code> 补集 Complement <code>10101010</code> {1, 3, 5, 7}</li>
</ul>
<p>以上这四种运算 C 语言都支持，只要是『数值型』即可：<code>long</code>, <code>int</code>, <code>short</code>, <code>char</code>, <code>unsigned</code>。每个参数都会被看做是位向量。</p>
<h3 id="u6574_u578B_u7684_u8868_u793A"><a href="#u6574_u578B_u7684_u8868_u793A" class="headerlink" title="整型的表示"></a>整型的表示</h3><p>针对有符号数和无符号数，有两种不同的形式，这里的 w 表示 word size：</p>
<ul>
<li>无符号数：$B2U(X)=\sum_{i=0}^{w-1}x_i·2^i$</li>
<li>有符号数： $B2T(X)=-x_{w-1}·2^{w-1}+\sum_{i=0}^{w-2}x_i·2^i$ </li>
</ul>
<p>为了方便讲解，下面定义几个常量，这里 w 是 word size：</p>
<ul>
<li>UMin = 0 即 000…0</li>
<li>UMax = $2^w-1$ 即 111…1</li>
</ul>
<p>Two’s Complement 值</p>
<ul>
<li>TMin = $-2^{w-1}$ 即 100…0</li>
<li>TMax = $2^{w-1}-1$ 即 011…1</li>
</ul>
<p>其他值</p>
<ul>
<li>Minus 1 即 111…1</li>
</ul>
<p>观察可以得知两个很重要的特性</p>
<ul>
<li>|TMin| = TMax + 1 (范围并不是对称的)</li>
<li>UMax = 2*TMax + 1</li>
</ul>
<p>有符号数和无符号数在非负数的编码是一样的，每一个数字的编码是唯一的，这两者可以互换：</p>
<ul>
<li>$U2B(x)=B2U^{-1}(x)$</li>
<li>$T2B(x)=B2T^{-1}(x)$</li>
</ul>
<p><img src="/images/csapp2.jpg" alt="2&#39;s Complement vs Unsigned"></p>
<h3 id="u62D3_u5C55_u548C_u88C1_u526A"><a href="#u62D3_u5C55_u548C_u88C1_u526A" class="headerlink" title="拓展和裁剪"></a>拓展和裁剪</h3><p>有的时候我们需要扩展一个变量的位数，比如说从 32 位扩展到 64 位。更通用一点的话，给定一个 w 位的有符号整数 x，要把它转换成 w+k 位的整数（保持值不变），只需要在左边添加 k 个与符号位相同的数值即可，如下图：</p>
<p><img src="/images/csapp3.jpg" alt="从 32 位拓展到 64 位"></p>
<ul>
<li>扩展（例如从 <code>short int</code> 到 <code>int</code>）<ul>
<li>无符号数：加 0</li>
<li>有符号数：加符号位</li>
<li>都可以得到预期的结果</li>
</ul>
</li>
<li>缩短（例如 <code>unsigned</code> 到 <code>unsigned short</code>）<ul>
<li>均会截取</li>
<li>无符号数：mod 操作</li>
<li>有符号数：近似 mod 操作</li>
<li>对于小的数字可以得到预期的结果</li>
</ul>
</li>
</ul>
<h3 id="u6EA2_u51FA_u95EE_u9898"><a href="#u6EA2_u51FA_u95EE_u9898" class="headerlink" title="溢出问题"></a>溢出问题</h3><p>无符号加法和有符号加法有不同的溢出方式：</p>
<p><img src="/images/csapp5.jpg" alt="无符号加法的溢出"></p>
<p><img src="/images/csapp7.jpg" alt="有符号加法的两种溢出"></p>
<h3 id="u6D6E_u70B9_u6570"><a href="#u6D6E_u70B9_u6570" class="headerlink" title="浮点数"></a>浮点数</h3><p>二进制浮点数的表示，其实和我们日常生活中常见的十进制的方式是一致的，都是相当于每一位的系数，乘以每一位的数值，然后把结果加起来，如下图所示：</p>
<p><img src="/images/csapp13.jpg" alt="浮点数表示"></p>
<p>所以我们其实可以用一个统一的公式来表达：</p>
<p>$$ \sum_{k=-j}^ib_k\times 2^k $$</p>
<p>例如</p>
<p>$$ 5\frac{3}{4}=101.11_2 \;,\; 2\frac{7}{8}=10.111_2 \;,\; 1\frac{7}{16}=1.0111_2 $$</p>
<p>细心的同学就会发现，这种表达方式其实是比较明显的限制的，比如说，只有形为 $\frac{x}{2^k}$ 的小数部分可以被精确表示，其他的数字会变成循环的小数，例如：$\frac{1}{3}=0.0101010101[01]…_2$。</p>
<p>除此之外，另一个问题在于，如果给定了 w 个比特，能够表达的数字其实是有限的。</p>
<h3 id="IEEE__u6D6E_u70B9_u6570"><a href="#IEEE__u6D6E_u70B9_u6570" class="headerlink" title="IEEE 浮点数"></a>IEEE 浮点数</h3><p>我们用下面的公式来表达浮点数：</p>
<p>$$(-1)^s \; M \; 2^E$$</p>
<p>其中 s 是符号位，决定正负；M 通常是一个值在 [1.0, 2.0) 的小数；E 是次方数。具体编码的时候是这样的：</p>
<p><img src="/images/csapp14.jpg" alt="浮点数的格式"></p>
<p>其中 s 对应着符号位，exp 对应着 E（注意，不一定等于 E，因为位数限制表达能力有限），frac 对应着 M（注意，不一定等于 M，因为位数限制表达能力有限）。</p>
<p>不同的位数就代表了不同的表示能力，也就是单精度，双精度，扩展精度的来源，具体的位数表示如下：</p>
<p><img src="/images/csapp15.jpg" alt="单精度、双精度、拓展精度"></p>
<p>注意区别 normalized 和 denormalized 的区别</p>
<p>舍入到最近的偶数比较特别，中心思想是：舍入之后最右边的值要是偶数，从下面一个例子就可以明白：</p>
<p><img src="/images/csapp24.jpg" alt="舍入到最近的偶数"></p>
<p>对于二进制数也是类似的</p>
<p><img src="/images/csapp25.jpg" alt="二进制数舍入到最近的偶数"></p>
<h3 id="u6D6E_u70B9_u6570_u4E58_u6CD5"><a href="#u6D6E_u70B9_u6570_u4E58_u6CD5" class="headerlink" title="浮点数乘法"></a>浮点数乘法</h3><p>$$(-1)^{s1}\; M1 \; 2^{E1} \times (-1)^{s2}\; M2 \; 2^{E2}$$</p>
<p>结果是 $(-1)^{s}\; M \; 2^{E}$，其中 s= s1 ^ s2, M = M1 * M2, E = E1 + E2</p>
<ul>
<li>如果 M 大于等于 2，那么把 M 右移，并增加 E 的值。</li>
<li>如果 E 超出了可以表示的范围，溢出</li>
<li>把 M 舍入到 frac 的精度</li>
</ul>
<p>基本性质</p>
<ul>
<li>相乘可能产生 infinity 或者 NaN</li>
<li>满足交换率</li>
<li>不满足结合律（因为舍入会造成精度损失）</li>
<li>乘以 1 等于原来的数</li>
<li>不满足分配率 <code>1e20*(1e20-1e20)=0.0</code> 但 <code>1e20*1e20-1e20*1e20=NaN</code></li>
<li>除了 infinity 和 NaN，满足单调性，即 $a\ge b \to a\times c \ge a\times b$</li>
</ul>
<h3 id="u6D6E_u70B9_u6570_u52A0_u6CD5"><a href="#u6D6E_u70B9_u6570_u52A0_u6CD5" class="headerlink" title="浮点数加法"></a>浮点数加法</h3><p>$$(-1)^{s1}\; M1 \; 2^{E1} + (-1)^{s2}\; M2 \; 2^{E2}$$，这里假设 E1 &gt; E2</p>
<p><img src="/images/csapp26.jpg" alt="浮点数加法"></p>
<p>结果是 $(-1)^{s}\; M \; 2^{E}$，其中 s= s1 ^ s2, M = M1 + M2, E = E1</p>
<ul>
<li>如果 M 大于等于 2，那么把 M 右移，并增加 E 的值</li>
<li>如果 M 小于 1，把 M 左移 k 位，E 减少 k</li>
<li>如果 E 超出了可以表示的范围，溢出</li>
<li>把 M 舍入到 frac 的精度</li>
</ul>
<p>基本性质</p>
<ul>
<li>相加可能产生 infinity 或者 NaN</li>
<li>满足交换率</li>
<li>不满足结合律（因为舍入会造成精度损失，如 <code>3.14+1e10)-1e10=0</code>，但 <code>3.14+(1e10-1e10)=3.14</code>）</li>
<li>加上 0 等于原来的数</li>
<li>除了 infinity 和 NaN，每个元素都有对应的倒数</li>
<li>除了 infinity 和 NaN，满足单调性，即 $a\ge b \to a+c \ge a+b$</li>
</ul>
<h3 id="u79FB_u52A8_u6570_u636E_u4E0E_u5BFB_u5740"><a href="#u79FB_u52A8_u6570_u636E_u4E0E_u5BFB_u5740" class="headerlink" title="移动数据与寻址"></a>移动数据与寻址</h3><p>操作数主要有三种类型，一种是立即数，也就是直接给的一个数字，第二种是寄存器，第三种是内存</p>
<p><img src="/images/14531723678160.jpg" alt=""></p>
<p>普通模式，(R)，相当于 <code>Mem[Reg[R]]</code>，也就是说寄存器 R 指定内存地址，类似于 C 语言中的指针，语法为：<code>movq (%rcx), %rax</code> 也就是说以 %rcx 寄存器中存储的地址去内存里找对应的数据，存到寄存器 %rax 中</p>
<p>移位模式，D(R)，相当于 <code>Mem[Reg[R]+D]</code>，寄存器 R 给出起始的内存地址，然后 D 是偏移量，语法为：<code>movq 8(%rbp),%rdx</code> 也就是说以 %rbp 寄存器中存储的地址再加上 8 个偏移量去内存里找对应的数据，存到寄存器 %rdx 中</p>
<p><img src="/images/14531733075157.jpg" alt=""></p>
<p>举个例子：%rdx 的存着的地址是 0xf000；%rcx 的存着的地址是 0x0100，那么有：</p>
<p><img src="/images/14531733728296.jpg" alt=""></p>
<h3 id="u6761_u4EF6_u7801_u4E0E_u4EE3_u7801_u63A7_u5236"><a href="#u6761_u4EF6_u7801_u4E0E_u4EE3_u7801_u63A7_u5236" class="headerlink" title="条件码与代码控制"></a>条件码与代码控制</h3><p>最后的四个寄存器（CF, ZF, SF, OF）就是用来辅助程序的流程控制的，意思是：</p>
<ul>
<li>CF: Carry Flag (for unsigned)</li>
<li>ZF: Zero Flag</li>
<li>SF: Sign Flag (for signed)</li>
<li>OF: Overflow Flag (for signed)</li>
</ul>
<p>可以看到以上这四个寄存器，表示四种不同的状态，举个例子，假如我们有一条诸如 <code>t = a + b</code> 的语句，汇编之后假设用的是 <code>addq Src, Dest</code>，那么根据这个操作结果的不同，会相应设置上面提到的四个寄存器，而因为这个是执行类似操作时顺带尽心设置的，称为隐式设置，例如：</p>
<ul>
<li>如果两个数相加，在最高位还需要进位（也就是溢出了），那么 CF 寄存器就会被设置</li>
<li>如果 t 等于 0，那么 ZF 寄存器会被设置</li>
<li>如果 t 小于 0，那么 SF 寄存器会被设置</li>
<li>如果 2’s complement 溢出，那么 OF 寄存器会被设置为 1（溢出的情况是 <code>(a&gt;0 &amp;&amp; b &gt; 0 &amp;&amp; t &lt;0) || (a&lt;0 &amp;&amp; b&lt;0 &amp;&amp; t&gt;=0)</code>）</li>
</ul>
<p>这就发现了，其实这四个条件代码，是用来标记上一条命令的结果的各种可能的，是自动会进行设置的。注意，使用 <code>leaq</code> 指令的话不会进行设置。</p>
<h3 id="u6808_u5E27"><a href="#u6808_u5E27" class="headerlink" title="栈帧"></a>栈帧</h3><p>在 x86-64/Linux 中，栈帧的结构是固定的，当前的要执行的栈中包括：</p>
<ul>
<li>Argument Build: 需要使用的参数</li>
<li>如果不能保存在寄存器中，会把一些本地变量放在这里</li>
<li>已保存的寄存器上下文</li>
<li>老的栈帧的指针（可选）</li>
</ul>
<p>而调用者的栈帧则包括：</p>
<ul>
<li>返回地址（因为 <code>call</code> 指令被压入栈的）</li>
<li>调用所需的参数</li>
</ul>
<p>具体如下图所示：</p>
<p><img src="/images/14533846615880.jpg" alt="栈帧的例子"></p>
<h3 id="u5B58_u50A8_u76F8_u5173"><a href="#u5B58_u50A8_u76F8_u5173" class="headerlink" title="存储相关"></a>存储相关</h3><p>总的访问时间  Taccess =  寻址时间 Tavg seek + 旋转时间 Tavg rotation + 传输时间 Tavg transfer</p>
<ul>
<li>寻址时间 Tavg seek 因为物理规律的限制，一般是 3-9 ms</li>
<li>旋转延迟 Tavg rotation 取决于硬盘具体的转速，一般来说是 7200 RPM</li>
<li>传输时间 Tavg tranfer 就是需要读取的 sector 数目</li>
</ul>
<p>举个例子，假设转速是 7200 RPM，平均寻址时间 9ms，平均每个 track 的 sector 数目是 400，那么我们有：</p>
<ul>
<li>Tavg rotation = 1/2 x (60 secs / 7200 RPM) x 1000 ms/sec = 4 ms</li>
<li>Tavg transfer = 60 / 7200 RPM x 1/400 secs/track x 1000 ms/sec = 0.02 ms</li>
<li>Taccess = 9 ms + 4 ms + 0.02 ms</li>
</ul>
<p>从这里可以看出，主要决定访问时间的是寻址时间和旋转延迟；读取一个 sector 的第一个 bit 是非常耗时的，之后的都几乎可以忽略不计；硬盘比 SRAM 慢 40,000 倍，比 DRAM 慢 2500 倍。</p>
<h3 id="Locality__u4E0E_Memory_Heirarchy"><a href="#Locality__u4E0E_Memory_Heirarchy" class="headerlink" title="Locality 与 Memory Heirarchy"></a>Locality 与 Memory Heirarchy</h3><p>Locality 的思路很简单，就是如果一个数据最近被访问过，很可能还会被再次访问：</p>
<ul>
<li>Temporal locality: Recently referenced items are likely to be referenced again in the near future</li>
<li>Spatial locality: Items with nearby addresses tend to be referenced close together in time</li>
</ul>
<p>一种介质的速度越快，就会越贵，同时也消耗更多的电量，所以一般容量比较小。而 CPU 和内存之间的速度差距越来越大，所以好的程序都会尽可能利用 locality。根据这些特性，也就引申出了一个安排存储的方式，称为 memory hierarchy。</p>
<p><img src="/images/14555647586566.jpg" alt="Memory Heirarchy"></p>
<p>这里就涉及到一个技术：缓存。缓存可以看作是把大且缓慢的设备中的数据的一部分拿出来存储到其中的更快的存储设备。在 memory hierarchy 金字塔中，每一层都可以看作是下一层的缓存。利用 locality，程序会更倾向于访问第 k 层的数据，而非第 k+1 层，这样就减少了访问时间。</p>
<p><img src="/images/14555654345569.jpg" alt="访问时间比较"></p>
<h3 id="Cache_Miss"><a href="#Cache_Miss" class="headerlink" title="Cache Miss"></a>Cache Miss</h3><p>Cache miss 有三种：</p>
<ul>
<li>Cold(compulsory) Miss: CPU 第一次访问相应 cache 块，cache 中肯定没有该 cache 块，这是不可避免的</li>
<li>Confilict Miss: 在直接相联或组相联的 cache 中，不同的 cache 块由于 index 相同相互替换，引起的失效叫做冲突失效<ul>
<li>假设这里有 32KB 直接相联的 cache</li>
<li>如果有两个 8KB 的数据需要来回访问，但是这两个数组都映射到相同的地址，cache 大小足够存储全部的数据，但是因为相同地址发生了冲突需要来回替换，发生的失效则全都是冲突失效（第一次访问失效依旧是强制性失效），这时 cache 并没有存满</li>
</ul>
</li>
<li>Capacity Miss: 有限的 cache 容量导致 cache 放不下而被替换出 cache 块，被替换出去的 cache 块再被访问，引起的失效叫做容量失效<ul>
<li>假设这里有 32KB 直接相联的 cache</li>
<li>如果有一个 64KB 的数组需要重复访问，数组的大小远远大于 cache 大小，没办法全部放入 cache。第一次访问数组发生的失效全都是强制性失效。之后再访问数组，再发生的失效则全都是容量失效，这时 cache 已经存满，容量不足以存储全部数据</li>
</ul>
</li>
</ul>
<h3 id="Cache_Memories"><a href="#Cache_Memories" class="headerlink" title="Cache Memories"></a>Cache Memories</h3><p>通常来说，是按照如下图所示的方式来组织的，一定要注意 S/E/B 具体在说什么：</p>
<p><img src="/images/14555690389309.jpg" alt=""></p>
<p>实际上可以理解为三种层级关系，对应不同的索引，这样分层的好处在于，通过层级关系简化搜索需要的时间，并且和字节的排布也是一一对应的（之后介绍缓存的时候就体现得更加明显）。</p>
<p>具体的例子请参考<a href="http://wdxtub.com/2016/02/15/csapp-12/">深入理解计算机系统 第 12 课 Cache Memories</a></p>
<h3 id="Memory_Mountain"><a href="#Memory_Mountain" class="headerlink" title="Memory Mountain"></a>Memory Mountain</h3><p><img src="/images/14556314890158.jpg" alt=""></p>
<p>注意，这是根据 Core i7 得出来的图，不同的处理器可能因为不同的设计和架构而有所区别，但是可以通过不同的颜色和层次，看出不同 size 和 stride 对性能的影响。山脚是我们应该尽量避免的，山顶是我们力求达到的，也就是说，尽量一次访问一个 stride，一次读入的数据大小也不宜太大，最好和 L1 缓存数值上吻合。</p>
<h2 id="u5F80_u5E74_u8BD5_u9898_u8BB2_u89E3"><a href="#u5F80_u5E74_u8BD5_u9898_u8BB2_u89E3" class="headerlink" title="往年试题讲解"></a>往年试题讲解</h2><h3 id="u9009_u62E9_u9898_u77E5_u8BC6_u70B9"><a href="#u9009_u62E9_u9898_u77E5_u8BC6_u70B9" class="headerlink" title="选择题知识点"></a>选择题知识点</h3><ul>
<li><code>test</code> 指令和 <code>and</code> 指令一样，只设置 flag 不改变结果</li>
<li>在一个 32 位的 Linux 系统中，<code>long</code> 的大小为 <code>4 bytes</code></li>
<li>在一个 64 位的 Linux 系统中，并不是所有的参数都在栈上传递</li>
<li><code>mov</code> 和 <code>lea</code> 指令的不同在于 <code>mov</code> 会 dereferences an address，也就是说 <code>mov</code> 是取值，<code>lea</code> 是地址</li>
<li>先调用函数，然后压入 <code>%ebp</code></li>
<li>一个 8 位浮点数（1 sign, 3 exp, 4 frac），则 0 111 1111 表示 NaN</li>
<li>每次执行完一条语句，<code>%rsp</code> 的值减 8 </li>
<li>二维数组在内存中以 row-major 方式存储</li>
<li><code>%rdi</code> 保存着函数调用的第一个参数</li>
</ul>
<h3 id="u6D6E_u70B9_u6570_u7F16_u7801"><a href="#u6D6E_u70B9_u6570_u7F16_u7801" class="headerlink" title="浮点数编码"></a>浮点数编码</h3><p>这里我们考虑两种 6 位数的 IEEE 浮点数格式</p>
<ul>
<li>格式 A<ul>
<li>1 个符号位 s</li>
<li>k = 3 个 exponent bits，bias 为 $2^{k-1} - 1 = 3$</li>
<li>n = 2 个 fraction bits</li>
</ul>
</li>
<li>格式 B<ul>
<li>1 个符号位 s</li>
<li>k = 2 个 exponent bits，bias 为 $2^{k-1} - 1 = 1$</li>
<li>n = 3 个 fraction bits</li>
</ul>
</li>
</ul>
<p>注意</p>
<ul>
<li>对应于 denormalized 的情况，E = 1 - bias</li>
<li>对应于 normalized 的情况，E = exp - bias</li>
</ul>
<p>需要填写下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">Value</th>
<th style="text-align:center">Format A Bits</th>
<th style="text-align:center">Format B Bits</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Zero</td>
<td style="text-align:center">0 000 00</td>
<td style="text-align:center">0 00 000</td>
</tr>
<tr>
<td style="text-align:center">One</td>
<td style="text-align:center">0 011 00</td>
<td style="text-align:center">0 01 000</td>
</tr>
<tr>
<td style="text-align:center">$\frac{1}{2}$</td>
<td style="text-align:center">0 010 00</td>
<td style="text-align:center">0 00 100</td>
</tr>
<tr>
<td style="text-align:center">$\frac{11}{8}$</td>
<td style="text-align:center">0 011 10</td>
<td style="text-align:center">0 01 011</td>
</tr>
</tbody>
</table>
<p>我们来对应看一下具体要怎么填。</p>
<p>首先需要知道的是 IEEE 浮点数的具体格式，是 s | exp | frac。接下来要知道什么时候是 denormalized，什么时候是 normalized，简单来说就是如果 exp 全为 0 或全为 1 时，属于 denormalized，其他时候属于 normalized。</p>
<p>对应浮点数的公式</p>
<p>$$(-1)^s \; M \; 2^E$$</p>
<p>我们知道如果要表示 1，那么 E 应该等于 0，M 部分应该为 1（M 的形式应该是是 1.xxxxx，其中 xxx 是 frac 的部分，于是 frac 应该为 0）。这里 E 因为属于 normalized 的情况，所以 E = exp - bias，而 E 需要等于 0，所以 exp = bias，针对不同的格式，就可以找到对应的答案（格式 A 中 bias = 3，所以 exp 部分是 011；格式 B 中 bias = 1，所以 exp 部分是 01；frac 部分均为 0）</p>
<p>然后我们来看看如何表示 0.5，根据公式，E 应该等于 -1，那么对于格式 A，E = exp - bias，所以 exp = -1 + 3 = 2，exp 部分就是 010。但是对于格式 B 就有点不同，因为这时候是属于 denormalized 的，这时 E = 1 - bias = 0，我们需要对 frac 部分做出处理，在这种情况下(M 的形式是 0.xxx)，frac 的第一位就表示 0.5，所以最终的结果如上表所示。</p>
<p>最后我们来看看 $\frac{11}{8}$ 要如何表示，实际上就是 1 加上 $\frac{3}{8}$，因为前面已经表示过 1，所以只要在 frac 部分做做文章即可，这次我们先来看格式 B，根据浮点数的定义，我们很快就可以知道 frac 应该为 011，完成！对于格式 A，因为 frac 只有 2 位，那么就需要进行舍入（到最近的偶数），也就是 <code>011 -&gt; 01 + 01 -&gt; 10</code>，所以最终的结果如上表所示。</p>
<h3 id="u6C47_u7F16_u7A0B_u5E8F_u9605_u8BFB"><a href="#u6C47_u7F16_u7A0B_u5E8F_u9605_u8BFB" class="headerlink" title="汇编程序阅读"></a>汇编程序阅读</h3><p>假设有这么一段汇编程序</p>
<p><img src="/images/14566917311963.jpg" alt=""></p>
<p>根据上面的信息，补充完整下面对应的程序代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">transform</span><span class="params">(<span class="keyword">unsigned</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b, m;</span><br><span class="line">    <span class="keyword">for</span> (m = __; _____; _____)&#123;</span><br><span class="line">        b = ____;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            ______;</span><br><span class="line">        &#125;</span><br><span class="line">        ______;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们应该熟悉，这里 <code>%eax</code> 中存放的变量是 <code>m</code>，<code>%edx</code> 中存放的变量是 <code>n</code>。在 &lt;+6&gt; 这一行把 <code>0x0</code> 放到了 <code>%eax</code> 中，所以循环的初始条件是 <code>m=0</code>，然后 &lt;+11&gt; 这一句实际是判断 <code>%edx</code> 是否为 0，如果为 0，则跳转到 &lt;+28&gt;，所以终止条件是 <code>n != 0</code>。接着就是循环体里的内容，&lt;+15&gt; 用 <code>%dl</code> 和 <code>0x1</code> 做 <code>&amp;</code> 操作，在汇编中结果会保存到对应的 flag 中，在代码中我们就保存到了 <code>b</code> 中，如果 <code>b == 0</code>，那么就跳转到 &lt;+24&gt;，进行移位操作，也就是循环操作为 <code>n &gt;&gt;= 1</code>，否则先要执行 &lt;+20&gt;，这一句实际上就是 <code>m = m + m + 1</code>，综上所述，就可以得到最终答案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">transform</span><span class="params">(<span class="keyword">unsigned</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b, m;</span><br><span class="line">    <span class="keyword">for</span> (m = <span class="number">0</span>; n != <span class="number">0</span>; m &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        b = n &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = m + m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u7ED3_u6784_u4F53_u7684_u5185_u5B58_u6392_u5217"><a href="#u7ED3_u6784_u4F53_u7684_u5185_u5B58_u6392_u5217" class="headerlink" title="结构体的内存排列"></a>结构体的内存排列</h3><p>假设我们有下面这个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">long</span> b;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">    <span class="keyword">char</span> d[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> *e;</span><br><span class="line">    <span class="keyword">short</span> *f;</span><br><span class="line">&#125; foo;</span><br></pre></td></tr></table></figure>
<p>请给出具体的内存排列顺序。</p>
<p>首先我们需要知道每个数据类型所占据的字节数目，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 2 字节：short</span></span><br><span class="line">    <span class="comment">// 16 字节：long double</span></span><br><span class="line">    <span class="keyword">char</span> a;    <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="keyword">long</span> b;    <span class="comment">// 8 字节（其他 8 字节的有 double, 指针）</span></span><br><span class="line">    <span class="keyword">float</span> c;   <span class="comment">// 4 字节（其他 4 字节的有 int）</span></span><br><span class="line">    <span class="keyword">char</span> d[<span class="number">3</span>]; <span class="comment">// 1 x 3 字节</span></span><br><span class="line">    <span class="keyword">int</span> *e;    <span class="comment">// 8 字节</span></span><br><span class="line">    <span class="keyword">short</span> *f;  <span class="comment">// 8 字节</span></span><br><span class="line">&#125; foo;</span><br></pre></td></tr></table></figure>
<p>所以具体的排列为（用 x 表示 padding 的字节）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span> x x x x x x x <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span></span><br><span class="line">c c c c d d d x e e e e e e e e</span><br><span class="line">f f f f f f f f</span><br></pre></td></tr></table></figure>
<p> 如果想要紧凑一点，其实可以进行对其，把 a, c, d 组合一下，如</p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span> d d d c c c c <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span> <span class="tag">b</span></span><br><span class="line">e e e e e e e e f f f f f f f f</span><br></pre></td></tr></table></figure>
<p>这样就省了 8 个字节出来</p>
<h3 id="u7ED3_u6784_u4F53_u7684_u8BBF_u95EE"><a href="#u7ED3_u6784_u4F53_u7684_u8BBF_u95EE" class="headerlink" title="结构体的访问"></a>结构体的访问</h3><p>给出下面的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> confuse &#123;</span><br><span class="line">    <span class="keyword">char</span> systems;</span><br><span class="line">    <span class="keyword">long</span> theory;</span><br><span class="line">    <span class="keyword">struct</span> applications &#123;</span><br><span class="line">        <span class="keyword">char</span> web[<span class="number">3</span>];</span><br><span class="line">    &#125; database;</span><br><span class="line">    <span class="keyword">int</span> *languages;</span><br><span class="line">    <span class="keyword">struct</span> confuse *math;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题是，右边的汇编程序分别对应哪个函数：</p>
<p><img src="/images/14566942080505.jpg" alt=""></p>
<p>根据上一题，我们可以先画出具体的内存排列，用变量的首字母作为缩写，用 x 表示 padding：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s x x x x x x x t t t t t t t t</span><br><span class="line">w w w x x x x x <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span> <span class="keyword">l</span></span><br><span class="line"><span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="keyword">m</span> <span class="literal">m</span></span><br></pre></td></tr></table></figure>
<p>然后根据偏移量来数对应的变量即可，其中要注意的是十六进制转十进制的运算。比较简单，最后的对应为：</p>
<ul>
<li>A - phd</li>
<li>B - bachelors</li>
<li>C = masters</li>
</ul>
<h3 id="Switch__u8BED_u53E5"><a href="#Switch__u8BED_u53E5" class="headerlink" title="Switch 语句"></a>Switch 语句</h3><p>我们先来看跳转表：</p>
<p><img src="/images/14566960252571.jpg" alt="跳转表"></p>
<p>接着是汇编程序</p>
<p><img src="/images/14566960458022.jpg" alt=""></p>
<p>我们要做的是补充完整下面的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">4</span>;   </span><br><span class="line">    <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            _____;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            _____;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            result = ____;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            _____;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            _____;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            _____;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编程序中负责跳转的是 <code>0x40047b    jmpq  *0x400598(, %rdi, 8)</code>，其中 <code>%rdi</code> 就是变量 <code>a</code> 的值，仔细观察跳转表和程序，可以发现一些规律：</p>
<ul>
<li>a 等于 0 或 1 的时候，做的事情是一样的，并且直到执行完 a 等于 2 的语句才会返回</li>
<li>a 等于 5 时是一套独立的指令</li>
<li>a 等于 3 和 7 时，做的事情类似，并且最后都会执行默认的命令</li>
<li>switch 语句中有些有 break，有些没有</li>
</ul>
<p>有了这些线索，就可以『翻译』对应的汇编代码了，答案如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">4</span>;   </span><br><span class="line">    <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            result = c - <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            result = c * <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            result = <span class="number">0x15213</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            c = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            b = b &amp; c;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = b + <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u6808_u7684_u5E94_u7528"><a href="#u6808_u7684_u5E94_u7528" class="headerlink" title="栈的应用"></a>栈的应用</h3><p>这一题主要考察函数调用时候压栈出栈以及栈指针和返回地址的理解，C 代码和对应的汇编代码为：</p>
<p><img src="/images/14567011035267.jpg" alt=""></p>
<p>我们需要画出栈中的数据存放表示，具体的函数是 <code>foo(3, 4, 5)</code>，注意要标志出 <code>%ebp</code> 的值</p>
<p>在调用 <code>foo</code> 函数时 <code>%ebp</code> 的值为 <code>0xffffd858</code>，调用 <code>foo</code> 的函数的返回地址是 <code>0x080483c9</code></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stack      The diagram starts with theaddresss   arguments for foo()</span><br><span class="line">           +-----------------------------------+0xffffd850 |<span class="string">                5                  </span>|           +-----------------------------------+0xffffd84c |<span class="string">                4                  </span>|           +-----------------------------------+0xffffd848 |<span class="string">                3                  </span>|           +-----------------------------------+0xffffd844 |<span class="string">      return addr 0x080483c9       </span>|           +-----------------------------------+0xffffd840 |<span class="string">        old ebp 0xffffd858         </span>|           +-----------------------------------+0xffffd83c |<span class="string">                3                  </span>|           +-----------------------------------+0xffffd838 |<span class="string">                4                  </span>|           +-----------------------------------+0xffffd834 |<span class="string">      return addr 0x08048397       </span>|           +-----------------------------------+0xffffd830 |<span class="string">        old ebp 0xffffd858         </span>|           +-----------------------------------+</span><br></pre></td></tr></table></figure>
<p>我们来看看这题要怎么做。首先，老师还是很贴心的给出了第一个参数在栈中的位置，不过开始之前还是先要弄明白我们到底需要在栈中放什么东西。首先是函数的参数（倒着放，这样第一个参数才能先弹出来），然后是返回值地址和旧的 <code>%ebp</code> 指针，这俩是为了告诉指令该去哪，以及栈要去哪的。</p>
<p>所以答案就呼之欲出了，前三个简单，543 一路下来即可；接下来是返回地址，也就是题目给出的初始条件；再下来是题目给出的初始 ebp；接着是调用 <code>bar</code> 函数的栈排列，也还是参数，但是这里题目是换了顺序的，所以先 3 后 4；然后是返回值地址，找到汇编代码中 call 的下一句，就是它了；最后一句可有可无，不过为了清晰 ebp 的做用，还是写上，应该指向旧的 ebp 地址，也就是 <code>0xffffd840</code>，至此，题目完成。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一次我们主要来回顾一下重要的知识点，以及讲解一些往年试题中容易混淆的概念。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="复习" scheme="http://wdxtub.com/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 期中考试复习]]></title>
    <link href="http://wdxtub.com/2016/02/27/sad-midterm-review/"/>
    <id>http://wdxtub.com/2016/02/27/sad-midterm-review/</id>
    <published>2016-02-28T03:10:51.000Z</published>
    <updated>2016-03-03T17:26:41.000Z</updated>
    <content type="html"><![CDATA[<p>这一部分是根据老师给出的复习提纲总结的部分相关内容，但是由于架构这个东西太抽象，所以只能尽力去理解一下了。</p>
<a id="more"></a>
<hr>
<p>一想到要背这么多东西我就头疼，尽量利用已有知识理解之后串起来。</p>
<blockquote>
<p>Why software architecture is important?</p>
</blockquote>
<p>自己的一些思考，之所以重要是因为：</p>
<ul>
<li>软件架构影响到传统软件开发的每一个环节</li>
<li>清晰的软件架构是项目正常推进的指引</li>
<li>方便重用与修改</li>
<li>易于分析和测试</li>
</ul>
<blockquote>
<p>Various view points</p>
</blockquote>
<p>这里应该就是<a href="http://wdxtub.com/2016/01/31/sad-r3/">习题课 3 从不同视角描述系统</a>的内容，几个视角是：</p>
<ul>
<li>Function View: 各个模块图，包括接口和依赖</li>
<li>Information View: 展示 schema，数据模型和数据流，用状态机图来描述系统的信息模型</li>
<li>Concurrency View: 软件的组件需要在哪里部署和运行</li>
<li>Deployment View: 主要的软件包是什么</li>
<li>Development View: 在不同地方运行时，系统是如何运行的。你会如何保证数据一致性？</li>
</ul>
<blockquote>
<p>What does it mean by architecture through software lifecycle?</p>
</blockquote>
<p>这个题目在问什么我都有点迷糊，是不是说软件架构在软件的生命周期中的作用？还是其他什么的，大概分下面几个阶段：</p>
<ul>
<li>Requirements</li>
<li>Design </li>
<li>Coding</li>
<li>Testing</li>
</ul>
<p>不同的过程都会由架构来指引并且对架构的设计和演化有影响</p>
<blockquote>
<p>Will architecture design allow creativity</p>
</blockquote>
<p>这个是开放性问题，我觉得需要回答的要点是：</p>
<ul>
<li>允许创新</li>
<li>但是更要尊重前人的经验</li>
<li>大部分情况下不需要全新的架构，需要在已有的基础上提高改进</li>
</ul>
<blockquote>
<p>Canonical elements of software architecture</p>
</blockquote>
<p>这题就是概念题了，不过之前接触了这么多次，应该有一些印象，主要最后的 configuration 可能比较容易忘</p>
<ul>
<li>Component: computation</li>
<li>Connector: communication / coordination</li>
<li>Configuration: topology and constraints</li>
</ul>
<blockquote>
<p>Architectural styles vs Architectural patterns</p>
</blockquote>
<p>这是我一直比较迷糊的概念，会着重解释一下。</p>
<ul>
<li>Architectural styles<ul>
<li>Codify key constraints and architectural elements (components, connectors, configurations) found effective used in a family of software systems over a given time period</li>
<li>Client/Server, P2P, Object Oriented, Layered, Data-Flow, Pipe and Filter, Blackboard, Rule Based</li>
</ul>
</li>
<li>Architectural patterns<ul>
<li>A set of architectural design decisions that are applicable to a recurring design problem, and parameterized to account for different software development contexts in which that problem appears.</li>
<li>3-tier (Stage-Logic-Display), MVC, Sense Compute Control</li>
</ul>
</li>
</ul>
<p>Compared to styles, architectural patterns are at a coarser level of granularity (design decisions versus actual architectural elements) and are inherently more domain specific</p>
<p>简单来说就是 style 会有更多的细节，涉及到具体的数据、对象、管道、客户端、服务器端什么的。pattern 的话就比较虚一点，具体的界限感觉也没有多么清晰，自圆其说即可</p>
<blockquote>
<p>Methods of evaluating design methods like styles and patterns</p>
</blockquote>
<ul>
<li>Vocabulary,</li>
<li>structural patterns</li>
<li>computational model</li>
<li>invariants</li>
<li>common examples</li>
<li>disadvantages</li>
<li>specializations</li>
</ul>
<p>我估计记不住，总体来说就是从概念，定义，模型，优势，劣势等说明，注意逻辑。</p>
<blockquote>
<p>Methods of design</p>
</blockquote>
<p>Greenfield design (entirely fresh start, no baggage)</p>
<ul>
<li>Analogy searching</li>
<li>Brainstorming</li>
<li>Literature searching</li>
<li>Morphological Charts</li>
<li>Removing Mental Blocks</li>
<li>Insight from requirements/implementation</li>
</ul>
<p>按照自己写作业的思路来回答即可</p>
<blockquote>
<p>Software Connectors</p>
</blockquote>
<p>4 main roles: Communication, Conversion, Facilitation, Coordination</p>
<p>8 main types: Event, Stream, Procedure Call, Arbitrator, Data Access, Distributor, Linkage, Adaptor</p>
<p>这个我真心背不下来，随缘</p>
<blockquote>
<p>Benefits of first-class connectors</p>
</blockquote>
<ul>
<li>Software evolution</li>
<li>separation of concerns</li>
<li>modularity</li>
<li>pluggability</li>
</ul>
<p>显式连接器其实是解耦的好方法，带来的好处自然就是更灵活，但是可能会有性能影响</p>
<blockquote>
<p>Architectural Modeling</p>
</blockquote>
<p>An architectural model is an artifact that captures some or all of the design decisions that comprise a system’s architecture</p>
<p>Architectural modeling is the reification and documentation of those design decisions</p>
<p>Important things to “get right”: Consistency, Accuracy/Precision, Ambiguity</p>
<p>How to choose what to model? Cost/Benefit Decision</p>
<p>What do we model? Structure (Architectural element), static/dynamic behaviors, functional/non-functional aspects, Views/Viewpoints</p>
<p>How do we evaluate modeling techniques? Scope/Purpose, Basic Elements, Style, Static/Dynamic Aspects, Dynamic Modeling, Non-functional aspects, ambiguity, accuracy/precision, viewpoints, view consistency</p>
<p>Modeling approaches: Generic, early ADLs, style-specific and domain-specific languages, extensible ADLs</p>
<blockquote>
<p>Service Oriented Architecture</p>
</blockquote>
<ul>
<li>Triangular Operational Model</li>
<li>SOA Standard Stack</li>
<li>SOA on Bilateral View</li>
<li>SOA Solution Lifecycle</li>
<li>Enterprise Service Bus</li>
<li>SOA Reference Architecture –  Software as a Service</li>
</ul>
<blockquote>
<p>ATAM</p>
</blockquote>
<ul>
<li>Nine steps</li>
<li>Review what you do in the group homework</li>
<li>Link architectural styles with utility tree, and analyze risks and provide justifications</li>
</ul>
<blockquote>
<p>People, Roles and Teams</p>
</blockquote>
<p>Desired skills</p>
<ul>
<li>Software development expertise</li>
<li>Domain expertise</li>
<li>Communicator</li>
<li>Strategist</li>
<li>Consultant</li>
<li>Leader</li>
<li>Technologist</li>
<li>Cost estimator</li>
<li>Cheerleader</li>
<li>Politician</li>
<li>Salesperson</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一部分是根据老师给出的复习提纲总结的部分相关内容，但是由于架构这个东西太抽象，所以只能尽力去理解一下了。</p>]]>
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第七周 - 假行僧]]></title>
    <link href="http://wdxtub.com/2016/02/27/fake-sadhu/"/>
    <id>http://wdxtub.com/2016/02/27/fake-sadhu/</id>
    <published>2016-02-28T01:41:16.000Z</published>
    <updated>2016-02-28T02:50:32.000Z</updated>
    <content type="html"><![CDATA[<p>我要从南走到北，我还要从白走到黑，我要人们都看到我，却不知道我是谁。</p>
<a id="more"></a>
<hr>
<blockquote>
<p>深秋，夕阳，酒馆。偌大的厅堂，除了三三两两坐在角落窃窃私语的人，有这么一个人，坐在酒馆正中。衣衫褴褛，大义凛然，手里拿着一壶酒，一饮而尽。</p>
<p>起身，回头，默念。去吧，朋友，你的灵魂与我同在。</p>
</blockquote>
<p>不知道为什么，无论是暗黑破坏神中的武僧，还是英雄联盟中的盲僧，又或是金庸笔下的虚竹，古龙笔下的无花，都着实出彩，也倍受大家喜爱。</p>
<p>对我来说，僧人的形象是两面的，既有悲天悯人苦海慈航，也有明心见性不二法门，一为外，一为内。再加一点，恐怕要数『酒肉穿肠过』这般洒脱。僧人讲究修行讲究开悟，这两个事情都需要漫长的积累和隐忍，还得心无杂念，想法太多，往往也就看不清自己。一个人心里光是太急切想去做一件事，就难免会做错了。</p>
<p>武功本就是入世的，只要你肯用心，无论做什么事的时候，都一样可以锻炼你的武功。武学的精义只有四个字——专心、苦练。其实这四个字也同样适于世上的每一件事。无论你做什么，若要想出人头地，就只有专心、苦练。</p>
<p>前些天和爸爸妈妈打电话，一直被教导『去做自己喜欢的事情』。首先得要知道自己喜欢什么，然后再努力去做，这恐怕就是所谓『成功』的秘笈了。这些天有师弟师妹来咨询相关经验，其实我倒是觉得，很多事情不必弄得一清二楚才敢去做，要相信自己能兵来将挡水来土掩。如果硬要给些什么经验，一句话也能说清楚：</p>
<blockquote>
<p>不要感动自己，要成为自己</p>
</blockquote>
<p>还有就是作业重要，考试重要，但是朋友和伙伴比这些都重要。所谓友情不是嘴上说说而已，更是应该在朋友需要的时候，出现在你最该出现的地方——朋友身边。这些才是最值得去做的事情。</p>
<p>往西岸跑了这么多趟，虽然没有实际去工作体验过，但是也借着面试的机会，近距离观察了小公司大公司。最终得到的结论就是：不合适，不喜欢。拿到 offer 当然开心，毕竟也是一种肯定，不过还是得像之前拒绝其他 offer 一样，甩下一句『大丈夫居于天地间，岂能久居人下』了。</p>
<p>假设我有十成功力，那么写代码可能只是其中的两成，虽然说这两成对于程序员日常工作已经绰绰有余了，可是我更想在一个我能恣意发挥的地方，向所有人展示我能做的，而不只是在屏幕前完成一个又一个需求，改好一个又一个 bug。</p>
<p>当然，人各有志，无论什么选择，只要是自己喜欢的，作为朋友，我定当全力支持。</p>
<p>你把我当朋友，我不能让你丢人。我有这双脚，我有这双腿，我有这千山和万水。我要这所有的所有，但不要恨和悔。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我要从南走到北，我还要从白走到黑，我要人们都看到我，却不知道我是谁。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="独立" scheme="http://wdxtub.com/tags/%E7%8B%AC%E7%AB%8B/"/>
    
      <category term="自我" scheme="http://wdxtub.com/tags/%E8%87%AA%E6%88%91/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 19 课 People, Role, Teams]]></title>
    <link href="http://wdxtub.com/2016/02/27/sad-19/"/>
    <id>http://wdxtub.com/2016/02/27/sad-19/</id>
    <published>2016-02-27T20:01:42.000Z</published>
    <updated>2016-02-27T23:52:35.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们来讲讲人在整个系统开发过程中所发挥的重要作用，或者再简单一点，就是成为一个架构师，到底需要什么特质以及在团队中扮演什么角色。<br><a id="more"></a></p>
<hr>
<p>注：跳过了课本中我觉得部分『过时』或者『维基』上都有的常识性内容，这一章其实是本书的最后一章，但是课程其实才刚刚过半，后面的内容应该会和课程结合更紧密，我也会结合一些互联网公司的具体架构实践，来详细介绍背后的道理。</p>
<p>一个架构师需要什么技能呢？至少有以下几点：</p>
<ul>
<li>Software development expertise</li>
<li>Domain expertise</li>
<li>Communicator</li>
<li>Strategist</li>
<li>Consultant</li>
<li>Leader</li>
<li>Technologist</li>
<li>Cost estimator</li>
<li>Cheerleader</li>
<li>Politician</li>
<li>Salesperson</li>
</ul>
<p>具体的能力需求，根据不同的项目和不同的领域，也会有细微的不同，下面按照不同的角色，来进行响应的介绍</p>
<h2 id="u4F5C_u4E3A_u8F6F_u4EF6_u5F00_u53D1_u4E13_u5BB6"><a href="#u4F5C_u4E3A_u8F6F_u4EF6_u5F00_u53D1_u4E13_u5BB6" class="headerlink" title="作为软件开发专家"></a>作为软件开发专家</h2><ul>
<li>必须理解软件开发的细微差别<ul>
<li>准则</li>
<li>方法和技术</li>
<li>方法论</li>
<li>工具</li>
</ul>
</li>
<li>不一定要是世界级的软件开发者</li>
<li>应该理解不同架构选择的后果<ul>
<li>不要活在象牙塔中</li>
<li>理解架构选择会限制实现的方式</li>
<li>有些具体的实现技术也会限制架构选择</li>
</ul>
</li>
</ul>
<h2 id="u4F5C_u4E3A_u9886_u57DF_u4E13_u5BB6"><a href="#u4F5C_u4E3A_u9886_u57DF_u4E13_u5BB6" class="headerlink" title="作为领域专家"></a>作为领域专家</h2><ul>
<li>只有软件工程方面的经验是不够的</li>
<li>理解问题领域的细微差别<ul>
<li>成熟度</li>
<li>稳定性</li>
<li>系统用户档案 </li>
</ul>
</li>
<li>可能会极大影响架构选择<ul>
<li>分布</li>
<li>规模</li>
<li>可进化性</li>
</ul>
</li>
<li>需要为问题空间建模</li>
</ul>
<h2 id="u4F5C_u4E3A_u4EA4_u6D41_u8005"><a href="#u4F5C_u4E3A_u4EA4_u6D41_u8005" class="headerlink" title="作为交流者"></a>作为交流者</h2><ul>
<li>至少一半的时间应该花在沟通上</li>
<li>听取权益相关者的意见</li>
<li>解释架构</li>
<li>协商折中实现</li>
<li>需要良好的沟通技能<ul>
<li>写作</li>
<li>说话</li>
<li>展示 </li>
</ul>
</li>
</ul>
<h2 id="u4F5C_u4E3A_u7B56_u7565_u5BB6"><a href="#u4F5C_u4E3A_u7B56_u7565_u5BB6" class="headerlink" title="作为策略家"></a>作为策略家</h2><ul>
<li>开发优雅的架构是不够的<ul>
<li>技术只是一小部分</li>
<li>架构必须放到更大的场景中也适用</li>
</ul>
</li>
<li>架构必须满足公司的<ul>
<li>商业策略</li>
<li>商业实践</li>
<li>计划周期</li>
</ul>
</li>
<li>也需要考虑对手的<ul>
<li>产品</li>
<li>策略</li>
<li>开发过程</li>
</ul>
</li>
</ul>
<h2 id="u4F5C_u4E3A_u54A8_u8BE2_u5E08"><a href="#u4F5C_u4E3A_u54A8_u8BE2_u5E08" class="headerlink" title="作为咨询师"></a>作为咨询师</h2><ul>
<li>开发人员是首要的『客户』</li>
<li>对于开发人员来说<ul>
<li>目标和架构师不同</li>
<li>甚至可能不关心架构本身，而是</li>
<li>满足功能、质量和调度需求</li>
<li>所负责的子系统</li>
</ul>
</li>
<li>必须说服开发者<ul>
<li>理解和关注架构</li>
<li>对架构相关的改动进行文档记录</li>
</ul>
</li>
</ul>
<h2 id="u4F5C_u4E3A_u9886_u5BFC"><a href="#u4F5C_u4E3A_u9886_u5BFC" class="headerlink" title="作为领导"></a>作为领导</h2><ul>
<li>必须是技术领导者<ul>
<li>基于学识和成就</li>
<li>根据想法、专业经验、学识来下达命令</li>
<li>不要依赖于『等级权力』</li>
</ul>
</li>
<li>保证大家遵守设计决定、指引和规则</li>
<li>为了保证产品质量，需要引入<ul>
<li>新的想法，解决方案和技术</li>
<li>带领新人</li>
</ul>
</li>
<li>做关键决定</li>
<li>帮助完成实现</li>
</ul>
<h2 id="u4F5C_u4E3A_u6280_u672F_u4EBA_u5458"><a href="#u4F5C_u4E3A_u6280_u672F_u4EBA_u5458" class="headerlink" title="作为技术人员"></a>作为技术人员</h2><ul>
<li>理解软件开发的方法</li>
<li>理解基本的技术，如<ul>
<li>操作系统</li>
<li>网络</li>
<li>中间件</li>
<li>安全</li>
<li>数据库</li>
<li>图形用户界面</li>
</ul>
</li>
<li>跟随技术潮流（不是盲从）</li>
<li>在下面领域是专家<ul>
<li>系统建模</li>
<li>架构平衡分析</li>
<li>把架构方案和系统需求结合在一起</li>
</ul>
</li>
</ul>
<h2 id="u4F5C_u4E3A_u5F00_u9500_u8BC4_u4F30_u8005"><a href="#u4F5C_u4E3A_u5F00_u9500_u8BC4_u4F30_u8005" class="headerlink" title="作为开销评估者"></a>作为开销评估者</h2><ul>
<li>理解不同架构选择的在经济上的影响<ul>
<li>Green-field vs. Brown-field development</li>
<li>Cost of COTS adoption</li>
<li>Cost of development for reuse</li>
<li>Company’s financial stability &amp; position in marketpalce</li>
</ul>
</li>
<li>技术上最优的方案可能在经济上不一定是最优的</li>
<li>简单快速的开销评估通常已经足够 </li>
</ul>
<h2 id="u4F5C_u4E3A_u5566_u5566_u961F_u961F_u957F"><a href="#u4F5C_u4E3A_u5566_u5566_u961F_u961F_u957F" class="headerlink" title="作为啦啦队队长"></a>作为啦啦队队长</h2><ul>
<li>在长期、大型的复杂项目中很有用<ul>
<li>不同的开发小组负责不同的子项目</li>
<li>管理人员可能会忘记总体的项目目标</li>
<li>顾客可能没办法接受漫长的等待</li>
</ul>
</li>
<li>必须<ul>
<li>在必要的细节基础上维护高层视野</li>
<li>说服不同的权益相关者关于架构的<ul>
<li>Beauty</li>
<li>Utility</li>
<li>Adaptability</li>
<li>Technological impact</li>
<li>Financial impact</li>
</ul>
</li>
<li>让大家情绪高涨</li>
</ul>
</li>
</ul>
<h2 id="u4F5C_u4E3A_u653F_u6CBB_u5BB6"><a href="#u4F5C_u4E3A_u653F_u6CBB_u5BB6" class="headerlink" title="作为政治家"></a>作为政治家</h2><ul>
<li>必须找到组织中的关键人物</li>
<li>必须持续<ul>
<li>倾听</li>
<li>维持网络</li>
<li>善于表达</li>
<li>兜售愿景</li>
<li>从多个角度思考问题</li>
</ul>
</li>
</ul>
<h2 id="u4F5C_u4E3A_u9500_u552E_u4EBA_u5458"><a href="#u4F5C_u4E3A_u9500_u552E_u4EBA_u5458" class="headerlink" title="作为销售人员"></a>作为销售人员</h2><p>兜售</p>
<ul>
<li>总体愿景</li>
<li>技术解决方案</li>
<li>架构的关键属性</li>
<li>系统的关键属性</li>
<li>开销计划</li>
<li>保证架构的实现</li>
</ul>
<h2 id="u5173_u4E8E_u67B6_u6784_u5C0F_u7EC4"><a href="#u5173_u4E8E_u67B6_u6784_u5C0F_u7EC4" class="headerlink" title="关于架构小组"></a>关于架构小组</h2><ul>
<li>由架构师组成</li>
<li>通常有不同的层级</li>
<li>随着进展进展人数会变动</li>
<li>架构师可能会成为<ul>
<li>子系统的开发组长</li>
<li>调去其他的项目</li>
</ul>
</li>
<li>定义软件架构</li>
<li>维护架构</li>
<li>评估技术风险</li>
<li>协调不同小组</li>
<li>辅助项目管理</li>
<li>辅助产品定义</li>
<li>确定主要设计的主要元素</li>
<li>确定系统的组织或架构</li>
<li>确定主要元素的交互方式</li>
<li>与系统工程师和开发小组合作</li>
</ul>
<h2 id="u67B6_u6784_u5C0F_u7EC4_u53EF_u80FD_u7684_u98CE_u9669"><a href="#u67B6_u6784_u5C0F_u7EC4_u53EF_u80FD_u7684_u98CE_u9669" class="headerlink" title="架构小组可能的风险"></a>架构小组可能的风险</h2><ul>
<li>技能短板<ul>
<li>缺乏软件开发经验</li>
<li>缺乏领域相关经验</li>
</ul>
</li>
<li>缺乏权威</li>
<li>活在象牙塔中</li>
<li>混淆不同的工具、技术和方法</li>
<li>拖延</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们来讲讲人在整个系统开发过程中所发挥的重要作用，或者再简单一点，就是成为一个架构师，到底需要什么特质以及在团队中扮演什么角色。<br>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 18 课 Deployment and Mobility]]></title>
    <link href="http://wdxtub.com/2016/02/26/sad-18/"/>
    <id>http://wdxtub.com/2016/02/26/sad-18/</id>
    <published>2016-02-26T21:06:57.000Z</published>
    <updated>2016-02-27T19:58:49.000Z</updated>
    <content type="html"><![CDATA[<p>当软件开发接近尾声，部署和灵活性就成为了重要的考量，这一课我们简要了解一下大概的流程和步骤，具体可能要工作之后实际接触生产环境才有更多领悟。</p>
<a id="more"></a>
<hr>
<p>部署指的是把软件放到硬件主机上的过程，改变部署的方式称为迁移或者重新拿部署，这属于系统灵活性的范畴，即灵活性可以看做是部署的超集。但是因为部署和灵活性涉及到诸多可控不可控因素，所以还是有很多挑战的，如：</p>
<ul>
<li>可能有不同的处理器</li>
<li>不同的处理器在不同的设备中</li>
<li>不同的软件组件需要不同的硬件配置</li>
<li>系统的生命周期可能会维持数十年</li>
<li>软件系统在不断进化（需要重新部署）</li>
<li>灵活的代码使得重新部署的时候不会花太多功夫</li>
</ul>
<h2 id="u8F6F_u4EF6_u67B6_u6784_u4E0E_u90E8_u7F72"><a href="#u8F6F_u4EF6_u67B6_u6784_u4E0E_u90E8_u7F72" class="headerlink" title="软件架构与部署"></a>软件架构与部署</h2><p>一个系统可能需要部署到不同的主机或站点上，它们会提供下面的资源（可以是独占或者共享的）：</p>
<ul>
<li>硬件</li>
<li>网络</li>
<li>外围设备</li>
<li>系统软件</li>
<li>应用软件</li>
<li>数据源</li>
</ul>
<p>具体的部署活动包括；</p>
<ul>
<li>Planning</li>
<li>Modeling</li>
<li>Analysis</li>
<li>Implementation</li>
</ul>
<p>下面分别用图片来介绍：</p>
<p><img src="/images/14566028050423.jpg" alt="Deployment Planning"></p>
<p><img src="/images/14566030361624.jpg" alt="Deployment Modeling"></p>
<p><img src="/images/14566030595938.jpg" alt="Deployment Analysis"></p>
<p><img src="/images/14566030856276.jpg" alt="Software Deployment Life Cycle"></p>
<p>这一部分感觉讲得太宽泛了，以后应该会出另一个系列详细说明</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>当软件开发接近尾声，部署和灵活性就成为了重要的考量，这一课我们简要了解一下大概的流程和步骤，具体可能要工作之后实际接触生产环境才有更多领悟。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 17 课 Security and Trust]]></title>
    <link href="http://wdxtub.com/2016/02/26/sad-17/"/>
    <id>http://wdxtub.com/2016/02/26/sad-17/</id>
    <published>2016-02-26T21:06:50.000Z</published>
    <updated>2016-02-27T19:14:57.000Z</updated>
    <content type="html"><![CDATA[<p>安全和信任，同样也是系统设计中不可以获取的一部分，这节课我们来了解一下常见的解决方案和应用场景。</p>
<a id="more"></a>
<hr>
<p>所谓安全，其实就是保证系统的集成性、可用性以及保密性。一些常见的原则有：</p>
<ul>
<li>最小特权：每个组件只有其所需的特权</li>
<li>默认失败保护：如果没有权限，那么就拒绝访问</li>
<li>Economy of Mechanism：采用简单的安全机制</li>
<li>Complete Mediation：确保允许每次访问</li>
<li>设计：安全不应该依赖秘密</li>
<li>特权隔离：引入安全组以避免特权冲突</li>
<li>最小公共机件：关键资源只在小部分机件中共享</li>
<li>心理接受度：使安全机制可用</li>
<li>深度防御：有多层安全措施</li>
</ul>
<h2 id="u8BBF_u95EE_u63A7_u5236_u6A21_u578B"><a href="#u8BBF_u95EE_u63A7_u5236_u6A21_u578B" class="headerlink" title="访问控制模型"></a>访问控制模型</h2><p>这个模型用来控制对于某个资源的访问是否能被允许。动态访问控制是针对不同的请求者，有不同的权限控制。强制访问控制则是基于不同的规则的。</p>
<p><img src="/images/14565991139571.jpg" alt="动态访问控制的例子"></p>
<p><img src="/images/14565991916403.jpg" alt="强制访问控制的例子"></p>
<h2 id="u8FDE_u63A5_u5668_u4E3A_u4E2D_u5FC3_u7684_u8BBF_u95EE_u63A7_u5236"><a href="#u8FDE_u63A5_u5668_u4E3A_u4E2D_u5FC3_u7684_u8BBF_u95EE_u63A7_u5236" class="headerlink" title="连接器为中心的访问控制"></a>连接器为中心的访问控制</h2><ul>
<li>决定连接的组件执行哪些操作</li>
<li>在连接器中决定组件是否有足够权限</li>
<li>在不安全的组件间提供安全交互方式</li>
<li>在架构访问检查中传播特权</li>
<li>参与决定架构连接</li>
<li>根据已有的策略来转发消息</li>
</ul>
<h2 id="u53BB_u4E2D_u5FC3_u5316"><a href="#u53BB_u4E2D_u5FC3_u5316" class="headerlink" title="去中心化"></a>去中心化</h2><ul>
<li>没有统一的中央调度</li>
<li>独立节点进行自治</li>
<li>可能会有恶意节点</li>
<li>需要有机制来保证不受恶意节点攻击</li>
</ul>
<p>但是仍旧可能会有以下威胁：</p>
<ul>
<li>Impersonation：可以假扮其他人</li>
<li>Fraudulent Actions：不完成操作就停止执行</li>
<li>Misrepresenting Trust：可以广播虚假消息（如某个节点不可信）</li>
<li>Collusion：共同广播虚假消息（如某个节点不可信）</li>
<li>Addition of Unknowns</li>
</ul>
<h2 id="u4FE1_u4EFB_u7BA1_u7406"><a href="#u4FE1_u4EFB_u7BA1_u7406" class="headerlink" title="信任管理"></a>信任管理</h2><p>主要有两种机制</p>
<ol>
<li>Credential and Policy-based</li>
<li>Reputation-based</li>
</ol>
<p>具体的机制</p>
<ol>
<li>选择合适的基于声望的信任模型</li>
<li>准确描述信任模型</li>
<li>把这个模型应用到软件架构上(Software architectural style fro trust management, PACE)</li>
<li>最后我们的架构会包含<ul>
<li>封装了信任模型的组件</li>
<li>其他处理威胁的信任技术</li>
</ul>
</li>
</ol>
<p>针对前面提到的集中威胁，对应的方法是：</p>
<p><img src="/images/14565999331971.jpg" alt=""></p>
<p><img src="/images/14566003997636.jpg" alt="PACE Components"></p>
<p>总体来说，安全是一个很大的话题，不过我个人对这个领域兴趣不是特别大，更多可能只是使用现有的权限控制应用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>安全和信任，同样也是系统设计中不可以获取的一部分，这节课我们来了解一下常见的解决方案和应用场景。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 16 课 Non-Functional Property]]></title>
    <link href="http://wdxtub.com/2016/02/26/sad-16/"/>
    <id>http://wdxtub.com/2016/02/26/sad-16/</id>
    <published>2016-02-26T21:06:46.000Z</published>
    <updated>2016-02-27T01:09:34.000Z</updated>
    <content type="html"><![CDATA[<p>虽然非功能属性不会直接体现在具体的实现上，但仍然会对如何实现各种功能产生巨大的影响，这节课我们就来具体了解一下。</p>
<a id="more"></a>
<hr>
<p>非功能属性指的是那些比较『虚』的，但是对整个系统又有举足轻重影响的概念，比如：</p>
<ul>
<li>Efficiency</li>
<li>Complexity</li>
<li>Scalability</li>
<li>Heterogeneity</li>
<li>Adaptability</li>
<li>Dependability</li>
</ul>
<p>产品设计之初，都是根据其功能属性来决定的，但是确定合适的功能并不简单，市场需求、竞争对手等各种条件的限制。可是系统的最终成败，还是由非功能属性决定的，比方说反应速度、稳定性等等</p>
<h2 id="u6548_u7387_Efficiency_u3002"><a href="#u6548_u7387_Efficiency_u3002" class="headerlink" title="效率 Efficiency。"></a>效率 Efficiency。</h2><p>效率，简单来说，就是用最小的代价做最多的事情，我们要强调的是，对效率的追求，是从设计架构时开始的！</p>
<p>对于组件来说</p>
<ul>
<li>做『小』的组件</li>
<li>保持组件的接口简单和紧凑</li>
<li>为同一个功能提供多个接口</li>
<li>隔离数据组件和运算组件</li>
<li>隔离数据和元数据</li>
</ul>
<p>对于连接器来说</p>
<ul>
<li>仔细选择连接器</li>
<li>小心运用广播机制的</li>
<li>可能的话多利用异步机制来交互</li>
<li>Use location/distribution transparency judiciously（翻译不能）</li>
</ul>
<p>对于架构来说</p>
<ul>
<li>经常交互的组件应该更紧密</li>
<li>仔细选择连接器</li>
<li>考虑不同架构对效率的影响</li>
</ul>
<h2 id="u590D_u6742_u5EA6_Complexity"><a href="#u590D_u6742_u5EA6_Complexity" class="headerlink" title="复杂度 Complexity"></a>复杂度 Complexity</h2><p>复杂度，简单来说，就是整个系统在完成指定功能的前提下，有多简洁多清晰。</p>
<p>对于组件来说</p>
<ul>
<li>不同的特性放到不同的组件中</li>
<li>组件只负责功能本身</li>
<li>负责处理的组件应该不受数据格式变化的影响</li>
<li>组件应该能够轻松结合起来</li>
</ul>
<p>对于连接器来说</p>
<ul>
<li>显式处理连接器</li>
<li>连接器只负责交互</li>
<li>不同的特性放到不同的连接器中</li>
</ul>
<p>对于架构来说</p>
<ul>
<li>去掉不必要的依赖</li>
<li>显式管理所有的依赖</li>
<li>运用层级继承结构</li>
</ul>
<h2 id="u4F38_u7F29_u6027_Scalability"><a href="#u4F38_u7F29_u6027_Scalability" class="headerlink" title="伸缩性 Scalability"></a>伸缩性 Scalability</h2><p>伸缩性，简单来说，就是在不同平台，用不同数量的机器运行时，需不需要改动很多。</p>
<p>对于组件来说</p>
<ul>
<li>每个组件有单一且清晰定义的目的</li>
<li>每个组件有单一且容易理解的接口</li>
<li>组件不应该负责交互</li>
<li>避免不必要的多样性</li>
<li>需要的时候复制数据</li>
</ul>
<p>对于连接器来说</p>
<ul>
<li>使用显式连接器</li>
<li>每个连接器有清晰定义的责任</li>
<li>选择满足要求的最简单的连接器</li>
<li>注意直接/间接依赖</li>
<li>避免在连接器中放功能相关的代码</li>
</ul>
<p>对于架构来说</p>
<ul>
<li>避免系统瓶颈</li>
<li>利用并行处理能力</li>
<li>数据源靠近数据消费者</li>
<li>使用合适的架构风格</li>
<li>Try to make distribution transparent</li>
</ul>
<h2 id="u9002_u5E94_u6027_Adaptablity"><a href="#u9002_u5E94_u6027_Adaptablity" class="headerlink" title="适应性 Adaptablity"></a>适应性 Adaptablity</h2><p>适应性，简单来说，就是在面对环境和需求变更时，是否需要改动很多。</p>
<p>对于组件来说</p>
<ul>
<li>每个组件有单一且清晰定义的目的</li>
<li>最小化组件间的相互依赖</li>
<li>组件不应该负责交互</li>
<li>处理和数据隔离</li>
<li>数据和元数据隔离</li>
</ul>
<p>对连接器来说</p>
<ul>
<li>每个连接器有清晰定义的责任</li>
<li>让连接器足够灵活</li>
<li>支持连接器组合</li>
</ul>
<p>对于架构来说</p>
<ul>
<li>使用显示连接器</li>
<li>使用合适的架构风格</li>
<li>Try to make distribution transparent</li>
</ul>
<h2 id="u53EF_u9760_u6027_Dependability"><a href="#u53EF_u9760_u6027_Dependability" class="headerlink" title="可靠性 Dependability"></a>可靠性 Dependability</h2><p>可靠性，简单来说，就是下面这几个词：Reliability, Availability, Robustness, Fault-tolerant, Survivability, Safety</p>
<p>对于组件来说</p>
<ul>
<li>仔细控制外部组件的依赖</li>
<li>令组件支持 reflection</li>
<li>组件包含异常处理机制</li>
<li>Specify the components’ key state invariants</li>
</ul>
<p>对于连接器来说</p>
<ul>
<li>严格控制组件的依赖</li>
<li>保证组件的合理交互</li>
</ul>
<p>对于架构来说</p>
<ul>
<li>避免单点失败</li>
<li>关键的功能和数据要有备份机制</li>
<li>支持系统监控</li>
<li>支持动态适应</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然非功能属性不会直接体现在具体的实现上，但仍然会对如何实现各种功能产生巨大的影响，这节课我们就来具体了解一下。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 15 课 Applied Architectures]]></title>
    <link href="http://wdxtub.com/2016/02/26/sad-15/"/>
    <id>http://wdxtub.com/2016/02/26/sad-15/</id>
    <published>2016-02-26T21:06:41.000Z</published>
    <updated>2016-02-27T00:09:39.000Z</updated>
    <content type="html"><![CDATA[<p>上节课我们了解了具体分析不同架构的方法，这节课我们主要来看看，如何应用不同的架构。</p>
<a id="more"></a>
<hr>
<h2 id="u5206_u5E03_u5F0F/_u7F51_u7EDC_u67B6_u6784"><a href="#u5206_u5E03_u5F0F/_u7F51_u7EDC_u67B6_u6784" class="headerlink" title="分布式/网络架构"></a>分布式/网络架构</h2><p>类似『没有摩擦力』的小滑块，分布式架构是『乐观』建立在如下『完美』假设之上的，很多时候都难以满足：</p>
<ul>
<li>网络是可靠的</li>
<li>延迟是没有的</li>
<li>带宽是无限的</li>
<li>网络是安全的</li>
<li>拓扑结构是不变的</li>
<li>只有一个管理员</li>
<li>传输数据是不要钱的</li>
<li>网络是多种多样的</li>
</ul>
<p>虽然我们知道这些假设都是『美好的愿望』，不过我们还是借此建立起了一个庞大的分布式系统，也就是—— WWW（万维网）。作为一个分布式、去中心化的超媒体，整个 Web 的架构和代码是完全分离的，或者说，其实没有任何的代码去实现这个架构。我们有的，只是对于这个架构中不同组件的不同实现（比如说不同的浏览器）。</p>
<p>从架构的角度来看，就会发现互联网可能是这个世界上最成功的应用，更神器的是，居然没有任何代码去实现所谓『架构』！</p>
<p>所以我们知道，架构并不一定是一个有形的需要实现的东西，可能本身只是一种思想一种约定，不同的组件组合起来，就成为了架构。</p>
<h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p>我们总是能看到 RESTful API 这个词，但是到底是个什么意思？不妨从最基本的规则开始</p>
<ol>
<li>最关键的一步是把信息抽象成为以 URL 命名的资源。只要是能被命名的信息，就可以是一个资源</li>
<li>资源的表示方法是一系列字节，加上自描述的 metadata，具体的表示形式可以由不同的 REST 组件协调确定</li>
<li>所有的交互都是上下文无关的，每次交互都包含所需所有信息，不依赖于之前的请求</li>
<li>每个组件只执行预定义好的方法，处理完成之后把资源传递给其他组件</li>
<li>使用幂等操作和表达形式来支持缓存和重用</li>
<li>The presence of intermediaries is promoted. Filtering or redirection intermediaries may also use both the metadata and the representations within requests or responses to augment, restrict, or modify requests and responses in a manner that is transparent to both the user agent and the origin server.(不知道怎么翻译)</li>
</ol>
<p>下面是一个例子：</p>
<p><img src="/images/14565259010138.jpg" alt="REST 的一个实例"></p>
<p>在 REST 中的数据元素包含下面的内容：</p>
<ul>
<li>Resource</li>
<li>Resource ID</li>
<li>Representation: Data + metadata</li>
<li>Representation metadata</li>
<li>Resource metadata</li>
<li>Control data</li>
</ul>
<p>而具体的连接器有以下例子：</p>
<ul>
<li>client: libwww, libwww-perl</li>
<li>server: libwww, Apache API, NASPI</li>
<li>cache: brower cache, Akamai cache network</li>
<li>resolver: bind (DNS lookup library)</li>
<li>tunnel: SOCKS, SSL after HTTP CONNECT</li>
</ul>
<p>最后是组件的例子</p>
<ul>
<li>User agent: brower</li>
<li>Origin server: Apache Server, Microsoft IIS</li>
<li>Proxy: Selected by client</li>
<li>Gateway: Squid, CGI, Reverse proxy(Controlled by server)</li>
</ul>
<h2 id="u53BB_u4E2D_u5FC3_u5316_u67B6_u6784"><a href="#u53BB_u4E2D_u5FC3_u5316_u67B6_u6784" class="headerlink" title="去中心化架构"></a>去中心化架构</h2><p>所谓去中心化架构，实际上可以看成是某种意义上的『自治』与『分权』，网络中的不同组件可以有不同的行为，计算的过程也是分布式的。就好像我们现实生活中的合作一样。</p>
<p>比较有代表性了两个架构，就是我们下面要说的点对点和 web 服务。</p>
<h3 id="u70B9_u5BF9_u70B9"><a href="#u70B9_u5BF9_u70B9" class="headerlink" title="点对点"></a>点对点</h3><p>去中心化的资源发现与共享，如 Napster 与 Gnutell，Skype 与 BitTorrent，也就是说没有一个所谓的『主服务器』来存储各种信息，每一台机子既可以看做是『客户端』，也可以认为是『服务端』。</p>
<ul>
<li>每个组件是相互独立的，有其自己的状态与控制线程。</li>
<li>连接器：通常是自定义的网络协议</li>
<li>数据元素：网络消息</li>
<li>拓扑结构：动态随机有重复连接的网络</li>
</ul>
<p>这种结构通过控制流和资源分布支持去中心化计算。即使有节点出现问题，也不会受到很大影响。</p>
<p>后面的内容比较常规（因为课本比较老 PS 老师年纪不大怎么也这么老派），大部分内容维基上的内容都比较详细了，这里不赘述，具体可以参考：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1" target="_blank" rel="external">Web服务</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6" target="_blank" rel="external">机器人学</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%A3%9B%E8%A1%8C%E6%A8%A1%E6%93%AC%E5%99%A8" target="_blank" rel="external">飞行模拟器</a></li>
</ul>
<h2 id="u5982_u4F55_u5904_u7406_u590D_u6742_u6027"><a href="#u5982_u4F55_u5904_u7406_u590D_u6742_u6027" class="headerlink" title="如何处理复杂性"></a>如何处理复杂性</h2><p>虽然前面没有介绍飞行模拟器，但是因为需要比较现实的『模拟』，所以可以想到整个系统肯定是比较复杂的。于是我们怎么样能通过设计来减小复杂度呢？</p>
<ul>
<li>首先可以采用结构化建模的方法，基于面向对象设计来处理子系统和组件，目标是提高可维护性，集成性与可拓展性。</li>
<li>软件部分，预先给不同的功能集合分簇，限制不合理的数据流与控制流，尽量减少数据类型。</li>
<li>最后，每个组件保证封装性，计算不带副作用，不同组件之间要有交流和同步。</li>
</ul>
<p>总结起来有以下四条</p>
<ol>
<li>好的架构是成功的一半</li>
<li>好的架构源于对问题领域的深入理解</li>
<li>好的架构可能是若干简单架构的结合</li>
<li>开发新架构需要话很大力气，也要很小心。不过通常来说都不需要这么做。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>上节课我们了解了具体分析不同架构的方法，这节课我们主要来看看，如何应用不同的架构。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 Twitter 语料分析 1 项目简介]]></title>
    <link href="http://wdxtub.com/2016/02/25/cc-p1/"/>
    <id>http://wdxtub.com/2016/02/25/cc-p1/</id>
    <published>2016-02-26T00:35:05.000Z</published>
    <updated>2016-03-01T19:09:33.000Z</updated>
    <content type="html"><![CDATA[<p>项目名称：Twitter Analytics on the Cloud</p>
<p>从这次作业开始，就要小组作业和个人作业并行了。这次的项目主要是在云上分析 Twitter 的相关内容，与以前 GB 级数据不一样，这次我们要处理 TB 级的数据，还是很刺激的。另，这是小组作业，在此先感谢我的队友 @leiyu 和 @shushanc</p>
<a id="more"></a>
<hr>
<h2 id="u4EFB_u52A1_u76EE_u6807"><a href="#u4EFB_u52A1_u76EE_u6807" class="headerlink" title="任务目标"></a>任务目标</h2><ol>
<li>在一定预算限制下利用所学知识搭建一个性能高可靠性又好的 web 服务</li>
<li>设计、开发、部署和优化服务器以处理比较高的负载（大约每秒上万次请求）</li>
<li>在一个大数据集上（约 1TB）实现 Extract Transform and Load (ETL) 并载入到 MySQL  和 HBase 中</li>
<li>设计 MySQL 和 HBase 的 schema 并优化配置来提高性能</li>
<li>探索寻找基于云的 web 服务中潜在瓶颈的方法，并提高性能</li>
</ol>
<p>我们需要搭建并优化一个有两个组件的 web 服务，前端负责处理请求，后端负责查询数据，架构如图：</p>
<p><img src="/images/14564545973314.jpg" alt="系统架构"></p>
<ol>
<li>前端：能够接收和响应查询请求的 web 服务<ul>
<li>用过通过指定网址发送 HTTP GET 请求来访问 web 服务。不同的请求有不同的地址，后面跟有不同的参数</li>
<li>要返回适当的响应，并且一定要按照指定的格式</li>
<li>Web 服务需要在持续若干小时的测试中正常运行</li>
<li>Web 服务不能拒绝请求，应该能够承受高负载</li>
</ul>
</li>
<li>后端：保存用来查询的数据文件<ul>
<li>需要评估 SQL(MySQL) 和 NoSQL(HBase)</li>
<li>比较不同数据集不同查询类型的性能表现，然后由此来决定如何实现后端</li>
</ul>
</li>
<li>Web 服务应该在不超过预算的情况下达到指定的吞吐量</li>
<li>钱花得越少越好</li>
<li>前端和后端均使用 M 系列的实例，批量处理的时候注意使用竞价实例（总之就是要省钱）</li>
</ol>
<blockquote>
<p>数据集</p>
</blockquote>
<ul>
<li>数据集地址为：<code>s3://cmucc-datasets/twitter/s16/</code></li>
<li>大小超过 1 TB，还会有重复和损坏的记录</li>
<li><a href="http://en.wikipedia.org/wiki/JSON" target="_blank" rel="external">JSON</a> 格式，每行表示一个 tweet，具体看<a href="https://dev.twitter.com/docs/platform-objects/tweets" target="_blank" rel="external">Twitter API</a>.</li>
<li>字符编码是 unicode，建议使用下面的库<ul>
<li>simple json/gson(Java)</li>
<li>标准库中的 json module(python)</li>
</ul>
</li>
</ul>
<blockquote>
<p>进度安排及制品</p>
</blockquote>
<p>项目分三个阶段，每个阶段完成不同的任务，每个阶段完成之后都需要提交制品：</p>
<ol>
<li>性能数据</li>
<li>开销分析</li>
<li>源代码</li>
<li>问答题的答案</li>
<li>阶段报告，包括设计选择和制品描述 </li>
</ol>
<h3 id="u5E38_u89C1_u95EE_u9898"><a href="#u5E38_u89C1_u95EE_u9898" class="headerlink" title="常见问题"></a>常见问题</h3><blockquote>
<p>如何提交测试请求？</p>
</blockquote>
<p>提交 web 服务的地址即可开始测试，提供不同时间长度的测试，可以有针对性进行选择，比方说如果只是为了检测服务能否正常运行，那么可能几分钟的测试就够了；如果想要看看长时间能否工作，就需要长时间的测试。</p>
<blockquote>
<p>到底测试什么？</p>
</blockquote>
<p>简单来说，每次提交测试请求之后，系统会产生特定的请求并发送到之前填写的地址，会检测性能和正确性。</p>
<blockquote>
<p>为什么提交不了请求了？</p>
</blockquote>
<p>为了省钱，每个队伍同时只能用一个测试在跑（或者在排队）</p>
<p>还可以取消当前的测试请求并重新提交</p>
<blockquote>
<p>如何计算分数？</p>
</blockquote>
<p>主要考察下面几点</p>
<ul>
<li>吞吐量：测试期间平均 RPS</li>
<li>延迟：平均每个请求的延迟</li>
<li>错误率：不返回 2XX 都是错误</li>
<li>正确率：检测是否返回正确的内容，注意仔细检查格式</li>
</ul>
<p>具体计算公式为：</p>
<ul>
<li>有效吞吐量 = 吞吐量 <em> (100 - 错误率 / 100) </em> (正确率 / 100)</li>
<li>原始分 = 有效吞吐量 / 目标吞吐量</li>
</ul>
<p>注意，错误率与正确率都会极大影响最后的分数</p>
<h2 id="u4EFB_u52A1_u6982_u89C8"><a href="#u4EFB_u52A1_u6982_u89C8" class="headerlink" title="任务概览"></a>任务概览</h2><h3 id="u524D_u7AEF"><a href="#u524D_u7AEF" class="headerlink" title="前端"></a>前端</h3><p>接收 RESTful 请求并返回响应，不限制所使用的 web 框架，但是需要至少使用两种，并比较他们的异同，最好使用竞价实例，省钱。</p>
<p>最好考虑使用 auto-scaling，因为测试的过程中会有波动。设计前端的时候要考虑到开销，并且写好测试脚本，不然每次都要部署一次很麻烦。</p>
<p>不同的 web 框架的性能也很不一样，如果一开始就选择了比较慢的框架，就相当于选择了 hard 模式，所以开始之前不妨看看主流框架的对比，详情参阅 <a href="https://www.techempower.com/benchmarks/" target="_blank" rel="external">Techempower</a></p>
<p>还有一个需要考虑的问题是，选择的前端框架最好有支持 MySQL 和  HBase 的 API，不然可能后面会很麻烦。在报告中注意写清楚为什么选择用某个框架。</p>
<p><strong>选择思路</strong></p>
<p>打开前面给出的 <a href="https://www.techempower.com/benchmarks/" target="_blank" rel="external">Techempower</a> 网站，可以看到不同框架在不同机器上进行不同测试的成绩，因为我们是在 AWS 上进行部署，所以主要看 EC2 的测试结果（最新的结果是 Round 11 - 2015.11.23 的测试结果）</p>
<p>分为六种测试：</p>
<ol>
<li>JSON 序列化</li>
<li>单次查询</li>
<li>多次查询</li>
<li>Fortunes 测试（其实就是随机从数据库中返回一句话）</li>
<li>数据更新</li>
<li>纯文本</li>
</ol>
<p>因为之前的课程一直都是在用 Java 写，所以就直接只在 Java 框架中选择了，其他的一些过滤条件是：</p>
<ul>
<li>应用操作系统: Linux</li>
<li>语言: Java</li>
<li>数据库: MongoDB, MySQL</li>
<li>数据库操作系统: Linux</li>
</ul>
<p>这样过滤一下，其实选择就少很多了，我们看看不同框架在这六个测试中的表现（只选取性能较好的一部分）：</p>
<p><img src="/images/14567964930323.jpg" alt="JSON serialization"></p>
<p><img src="/images/14567965454003.jpg" alt="Single query"></p>
<p><img src="/images/14567965837212.jpg" alt="Multiple queries"></p>
<p><img src="/images/14567966154182.jpg" alt="Fortunes"></p>
<p><img src="/images/14567966534438.jpg" alt="Data updates"></p>
<p><img src="/images/14567966771945.jpg" alt="Plaintext"></p>
<p>综合一下来看，性能比较好的是：</p>
<ul>
<li>sabina</li>
<li>jetty</li>
<li>undertow</li>
<li>gemini</li>
</ul>
<p>因为我们需要分别对 MySQL 和 HBase 进行操作，所以最好需要有对应的接口（不用自己写太多工具代码，不过其实 Java 都可以方便调用对应的连接器，所以还好），不过在此之前，因为这几个我都没听过，所以大概了解一下。</p>
<ul>
<li><a href="http://there4.co/sabina/" target="_blank" rel="external">Sabina</a>: A Sinatra inspired micro web framework for quickly creating web applications in Java with minimal effort<ul>
<li>性能不错，但是因为是 Java 8 的框架，而且不算太热门（意味着除了问题难以得到社区支持），所以不考虑</li>
</ul>
</li>
<li><a href="http://www.eclipse.org/jetty/" target="_blank" rel="external">Jetty</a>:<br>A Web server and javax.servlet container, plus support for HTTP/2, WebSocket, OSGi, JMX, JNDI, JAAS and many other integrations<ul>
<li>HBase 在产品中还包含了 Jetty，在 HBase 启动时采用嵌入式的方式来启动 Jetty（刚好了）</li>
<li>其实和 tomcat 很类似（从文件的组织方式也可以看出来）</li>
</ul>
</li>
<li><a href="http://undertow.io/" target="_blank" rel="external">undertow</a>: A flexible performant web server written in java, providing both blocking and non-blocking API’s based on NIO<ul>
<li>轻量级，比较简单和灵活</li>
<li>感觉很适合，至少没有 tomcat 一样一上来就一堆不知道干嘛的文件和文件夹</li>
</ul>
</li>
<li><a href="http://www.eclipse.org/gemini/" target="_blank" rel="external">gemini</a><ul>
<li>企业级应用，感觉太重量级了，暂时不考虑 </li>
</ul>
</li>
</ul>
<p>根据以上分析，决定采用 <a href="http://undertow.io/" target="_blank" rel="external">undertow</a> 作为主要的开发框架。</p>
<p>因为还需要再选择一个框架作为对比（只需要对比一次性能），为了熟悉框架，打算采用 vert.x 来进行测试。</p>
<h3 id="ETL"><a href="#ETL" class="headerlink" title="ETL"></a>ETL</h3><p>这部分的工作，需要使用 extract, transform and load (ETL) 把 Twitter 的数据集载入到数据仓库中。先从 S3 中获取大约 200 million tweets，然后把数据存储到目标数据库中，具体的操作取决于数据库设计。最好使用竞价实例，不然很可能会超支。</p>
<p>我们需要使用 AWS 精心设计 ETL 过程，选择合适的实例数量来完成这个工作，完成这个工作后，最好把数据库备份起来，不然每次都要做一次非常浪费钱，使用 EMR 的话，可以用下面这条命令把 HBase 备份到 S3 中</p>
<p><code>aws emr create-hbase-backup --cluster-id j-3AEXXXXXX16F2 --dir s3://mybucket/backups/j-3AEXXXXXX16F2 --consistent</code></p>
<p>详情请参阅<a href="http://docs.aws.amazon.com/ElasticMapReduce/latest/DeveloperGuide/emr-hbase-backup-restore.html" target="_blank" rel="external">这里</a></p>
<p>最好先用小数据集（比如说 200MB）来测试 ETL，不然每次失误的代价就太大了。载入数据库之后最好测试不同的请求类型，确保无误之后再开始后面的工作。</p>
<p>一定要仔细设计数据库的 schema，并据此好好设计 ETL，并确保 ETL 正确工作。因为每次都需要 10-30 个小时，如果需要做几次的话，很痛苦（虽然难以避免，很多时候可能在开发中会修改设计）</p>
<p>早点开始，多多利用并行，比较推荐使用 map reduce 来完成这个工作</p>
<h3 id="u540E_u7AEF"><a href="#u540E_u7AEF" class="headerlink" title="后端"></a>后端</h3><p>实际上就是所有数据存放的地方，前端会连接到后端来进行查询，最后返回对应结果。</p>
<p>这里我们会使用 MySQL 和 HBase，记得阅读提供的资料，可以快速上手。因为预算问题，还是多使用竞价实例。</p>
<p>在导入整个数据集之前，一定要用小数据集做一些测试，并确保后端数据库能返回正确的内容。</p>
<p>详情参考 <a href="http://dev.mysql.com/doc/" target="_blank" rel="external">MySQL</a> 和 <a href="https://hbase.apache.org/" target="_blank" rel="external">HBase</a></p>
<h3 id="u76F8_u5173_u8D44_u6E90_u4E0E_u53C2_u8003_u8D44_u6599"><a href="#u76F8_u5173_u8D44_u6E90_u4E0E_u53C2_u8003_u8D44_u6599" class="headerlink" title="相关资源与参考资料"></a>相关资源与参考资料</h3><p>Resources</p>
<ol>
<li><a href="https://www.techempower.com/benchmarks/" target="_blank" rel="external">Benchmarks of web servers</a></li>
<li><a href="http://www.percona.com/blog/2010/05/04/goal-driven-performance-optimization-white-paper-available/" target="_blank" rel="external">Schwartz, B., and P. Zaitsev. “A brief introduction to goal-driven performance optimization.” White paper, Percona (2010).</a></li>
<li><a href="http://www.percona.com/resources/mysql-webinars/practical-mysql-performance-optimization" target="_blank" rel="external">Practical MySQL Performance Optimization</a></li>
<li><a href="http://refcardz.dzone.com/refcardz/hbase" target="_blank" rel="external">HBase Cheat Sheet</a></li>
</ol>
<p>Architecting web servers</p>
<ol>
<li><a href="http://vts.uni-ulm.de/docs/2012/8082/vts_8082_11772.pdf" target="_blank" rel="external">Erb, Benjamin. “Concurrent programming for scalable web architectures.” Informatiktage. 2012.</a></li>
<li><a href="https://www.ece.cmu.edu/~ece845/docs/pariag-2007.pdf" target="_blank" rel="external">Pariag, David, et al. “Comparing the performance of web server architectures.” ACM SIGOPS Operating Systems Review. Vol. 41. No. 3. ACM, 2007.</a></li>
<li><a href="http://mmcgrana.github.io/2010/07/threaded-vs-evented-servers.html" target="_blank" rel="external">McGranaghan, Mark. “Threaded vs Evented Servers”</a></li>
<li><a href="https://www.dre.vanderbilt.edu/~schmidt/PDF/globalinternet.pdf" target="_blank" rel="external">Hu, James C., Irfan Pyarali, and Douglas C. Schmidt. “Measuring the impact of event dispatching and concurrency models on web server performance over high-speed networks.” Global Telecommunications Conference, 1997. GLOBECOM’97., IEEE. Vol. 3. IEEE, 1997.</a></li>
</ol>
<p>Clustering web servers</p>
<ol>
<li><a href="http://digitalcommons.unl.edu/cgi/viewcontent.cgi?article=1083&amp;context=csearticles" target="_blank" rel="external">Schroeder, Trevor, Steve Goddard, and Byrov Ramamurthy. “Scalable web server clustering technologies.” Network, IEEE 14.3 (2000): 38-45.</a></li>
<li><a href="http://www.ics.uci.edu/~cs230/reading/DLB.pdf" target="_blank" rel="external">Cardellini, Valeria, Michele Colajanni, and S. Yu Philip. “Dynamic load balancing on web-server systems.” IEEE Internet computing 3.3 (1999): 28-39.</a></li>
<li><a href="http://uu.diva-portal.org/smash/get/diva2:443102/FULLTEXT01.pdf" target="_blank" rel="external">Paudyal, Umesh. “Scalable web application using node.js and couchdb.” (2011).</a></li>
</ol>
<p>Optimizing a Multi-tier System</p>
<ol>
<li><a href="http://www.linuxjournal.com/article/7451" target="_blank" rel="external">Fitzpatrick, Brad. “Distributed caching with memcached.” Linux journal 2004.124 (2004): 5.</a></li>
<li><a href="http://www.linuxjournal.com/content/speed-your-web-site-varnish" target="_blank" rel="external">Graziano, Pablo. “Speed up your web site with Varnish.” Linux Journal 2013.227 (2013): 4.</a></li>
<li><a href="http://www.linuxjournal.com/magazine/nginx-high-performance-web-server-and-reverse-proxy" target="_blank" rel="external">Reese, Will. “Nginx: the high-performance web server and reverse proxy.” Linux Journal 2008.173 (2008): 2.</a></li>
</ol>
<p>Scalable and Performant Data Stores</p>
<ol>
<li><a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" target="_blank" rel="external">DeCandia, Giuseppe, et al. “Dynamo: amazon’s highly available key-value store.” ACM SIGOPS Operating Systems Review. Vol. 41. No. 6. ACM, 2007.</a></li>
<li><a href="http://www.cattell.net/datastores/Datastores.pdf" target="_blank" rel="external">Cattell, Rick. “Scalable SQL and NoSQL data stores.” ACM SIGMOD Record 39.4 (2011): 12-27.</a></li>
</ol>
<p>Web Server Performance Measurement</p>
<ol>
<li><a href="http://www.oocities.org/webserverperformance/webmodel.pdf" target="_blank" rel="external">Slothouber, Louis P. “A model of web server performance.” Proceedings of the 5th International World wide web Conference. 1996.</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.61.3268&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">Banga, Gaurav, and Peter Druschel. “Measuring the Capacity of a Web Server.” USENIX Symposium on Internet Technologies and Systems. 1997.</a></li>
<li><a href="https://www.mnot.net/blog/2011/05/18/http_benchmark_rules" target="_blank" rel="external">Nottingham, Mark. “On HTTP Load Testing”</a></li>
</ol>
<h2 id="u57FA_u672C_u8981_u6C42"><a href="#u57FA_u672C_u8981_u6C42" class="headerlink" title="基本要求"></a>基本要求</h2><ul>
<li>给所有的实例打上 <code>15619project:phase1</code> 的标签</li>
<li>另外，HBase 实例需要打上 <code>15619backend:hbase</code> 标签；MySQL 实例需要打上 <code>15619backend:mysql</code> 标签</li>
<li>ETL 部分可以选择任何类型的实例</li>
<li>前端和后端只能只用 M 系列不超过 large 的实例（large 也是可以用的）</li>
<li>可以选择任何免费的镜像，这次需要自己搭建整个系统</li>
<li>Web 服务的所有开销加起来不能超过每小时 <code>$0.85</code>（包括 EC2 实例，存储，EMR 和 ELB，不包括网络和磁盘 IO）</li>
<li>这个阶段每组有 <code>$40</code> 的预算</li>
</ul>
<p>虽然这一部分只占 10%，但是打下的基础很重要，尽可能多学多了解一些。</p>
<p><img src="/images/14564602178732.jpg" alt="任务要求"></p>
<p><img src="/images/14564603584769.jpg" alt="惩罚措施"></p>
<p>我们也提供了一个 <a href="http://q1-1848733628.us-east-1.elb.amazonaws.com/" target="_blank" rel="external">reference server</a> 方便大家检查结果的正确性，强烈建议在开始导入到数据库之前用 reference server 测试好。也可以利用这个服务器来检测可能出现的编码问题。</p>
<p>这一阶段我们要处理两类请求，从存储系统中获取数据（这一部分我们需要设计和控制），web service 需要能够连接到两个不同的后端存储系统(MySQL 和 HBase)，前端需要通过端口 80 接收 HTTP GET 请求。</p>
<p>这次的项目中，我们会设计并开发一个高并行的 web 服务器，可以连接到两种不同类型的数据库。在整个过程中，应该能够了解到不同后端实现的优势和劣势。</p>
<p>最后需要撰写报告，模板在 <a href="https://docs.google.com/document/d/1VOjU9JRAZG49PSrKnJtMOjSj5e1Ugbv_cQj7Mc_krd0/edit?usp=sharing" target="_blank" rel="external">这里</a></p>
<p>报告中需要包括 web 框架的如下信息：</p>
<ul>
<li>达到的 RPS</li>
<li>资源利用(CPU, Memory)</li>
<li>编程难度</li>
<li>两个框架的异同</li>
<li>适用的不同场景和优劣分析</li>
<li>为什么选择这些 web 框架</li>
</ul>
<h2 id="Query_1__28Heartbeat_and_Authentication_29"><a href="#Query_1__28Heartbeat_and_Authentication_29" class="headerlink" title="Query 1 (Heartbeat and Authentication)"></a>Query 1 (Heartbeat and Authentication)</h2><blockquote>
<p>目标吞吐量：25000 rps</p>
</blockquote>
<p>这部分的请求会询问 web 服务的状态，前端只需要返回 team id, AWS id, 时间戳以及一段加密的信息。这种机制通常称为心跳机制，但是也可以用来测试前端处理请求的能力。</p>
<p>q1 中的每个请求都包含 key <code>Y</code> 和一段由 key <code>Z</code> 加密的文本，<code>Z</code> 是 <code>X</code> 和 <code>Y</code> 的最大公约数（这里 <code>X</code> 是私钥）。这里我们使用 mythical Phaistos Disc Cipher (PDC) 来加密和解密</p>
<p>PDC 是为长度为完全平方数(4,9,16,25…)的大写英文字母(A-Z)组成的信息所设计的加密方式。我们需要自己进行解密的工作，也就是给定 key 和密文，获取原始的文本</p>
<p>PDC 的过程有三个步骤：KeyGen, Caesarify 和 Spiralize.</p>
<ol>
<li>KeyGen 阶段：随机选择一个大整数 <code>Y</code>，计算 <code>Y</code> 和我们的密钥 <code>X</code> 的最大公约数，记为 <code>Z</code> </li>
<li>Caesarify 阶段：利用 <code>Z</code> 生成一个 minikey <code>K = 1 + Z % 25</code>。我们把消息 <code>M</code> 中的每个字符都『偏移』<code>K</code> 个值，生成中间文本 <code>I</code></li>
<li>Spiralize 阶段：把消息选择写成正方形矩阵（参考下面的例子），然后再一行一行读出来，重排之后的消息就是密文<code>C</code>.</li>
</ol>
<p><img src="/images/14564607523532.jpg" alt="Spiral Matrix Example"></p>
<p>密文是：1,2,3,4,12,13,14,5,11,16,15,6,10,9,8,7（因为这里是数字，所以加上逗号方便区分）</p>
<p>Phaistos Disc Cipher encryption 的例子</p>
<p><img src="/images/14564607621256.jpg" alt="Phaistos Disc Cipher"></p>
<p>我们需要做的是解密，也就是给定密文 <code>C</code> 和 key <code>Y</code>，需要利用私钥 <code>X</code> 生成 <code>Z</code>，然后用 <code>Z</code> 来还原消息</p>
<blockquote>
<p>请求格式</p>
</blockquote>
<p><code>GET /q1?key=&lt;large_number&gt;&amp;message=&lt;uppercase_ciphertext_message_C&gt;</code></p>
<p>样例</p>
<p><code>GET /q1?key=4024123659485622445001958636275419709073611535463684596712464059093821&amp;message=URYEXYBJB</code></p>
<blockquote>
<p>响应格式（美东时间 EST）</p>
</blockquote>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEAMID,TEAM_AWS_ACCOUNT_ID\<span class="keyword">n</span></span><br><span class="line">yyyy-MM-dd HH:mm:ss\<span class="keyword">n</span></span><br><span class="line">[The decrypted message <span class="keyword">M</span>]\<span class="keyword">n</span></span><br></pre></td></tr></table></figure>
<p>样例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TeamCoolCloud,<span class="number">1234</span>-<span class="number">0000</span>-<span class="number">0001</span></span><br><span class="line"><span class="number">2004</span>-<span class="number">08</span>-<span class="number">15</span> <span class="number">16</span>:<span class="number">23</span>:<span class="number">42</span></span><br><span class="line">HELLOWORK</span><br></pre></td></tr></table></figure>
<p>这一部分我们只需要处理前端的问题，暂时不用考虑后端。</p>
<h2 id="Query_2__28Text_Cleaning_and_Analysis_29"><a href="#Query_2__28Text_Cleaning_and_Analysis_29" class="headerlink" title="Query 2 (Text Cleaning and Analysis)"></a>Query 2 (Text Cleaning and Analysis)</h2><p>目标吞吐量: 10000 rps</p>
<p>不允许使用任何已有的缓存应用 (Redis, Memcached, etc.) 或除了 MySQL 和 HBase 之外的数据库。但是可以自己写缓存应用。</p>
<p>在 ETL 阶段可以使用任何类型的实例，比如 <code>c family (Compute Optimized)</code> 和 <code>r family (Memory Optimized)</code>，不必只局限于 <code>m family (General Purpose)</code></p>
<p>MySQL 可以参考官方的优化文档，如果需要的话也可以使用其他版本的 MySQL</p>
<p>HBase: 可以选择用 EMR 来设置 HBase，或者自己搭建，不过自己搭建就要装 zookeeper 之类的，可以自行研究一下。</p>
<p>这里我们会对 Twitter 数据集进行分析，地址是 <code>s3://cmucc-datasets/twitter/s16/part-00XXX</code>，XXX 从 000 到 661。</p>
<p>会查询某个用户用指定的 hashtag 发的 tweet，主要考察如何设计一个高效的后端来处理大量的请求。</p>
<p>我们会提供 user id 和 hashtag（具体参考<a href="https://support.twitter.com/articles/49309?lang=en" target="_blank" rel="external">这里</a>），需要返回该用户所有带此 hashtag 的 tweet，具体格式如下：</p>
<ul>
<li>tweet 的 sentiment density</li>
<li>tweet 的发布时间</li>
<li>tweet id</li>
<li>审查修改过的的 tweet 内容，这里有很多可能出问题的地方，比如 emoji 表情、反斜杠、其他语言的字符等等，都需要小心处理</li>
</ul>
<p>Here is how you can obtain this information:</p>
<ol>
<li>利用 tweet 的内容来计算 sentiment density</li>
<li>tweet id 可以从 <code>id</code> 或 <code>id_str</code> 里获取</li>
<li>时间可以从 <code>created_at</code> 里获取</li>
<li>Tweet 的内容可以从 <code>text</code> 里获取，应该在计算完 sentiment density 再进行内容审查</li>
<li>hashtag(s) 可以从 <code>entities</code> 里获取，如果同一个 hashtag 在一条 tweet 中出现多次，只应该返回那条 tweet 一次</li>
</ol>
<p>注意事项：</p>
<ul>
<li>需要过滤掉重复的 Tweets（有相同的 id），返回响应的时候一条 tweet 只应该出现一次</li>
<li>满足下面条件的 tweet 也应该被过滤掉<ul>
<li><code>id</code> 和 <code>id_str</code> 为空或者没有这两个域</li>
<li><code>created_at</code>、<code>text</code> 或 <code>entities</code> 为空或者直接没有这几个域</li>
<li>无法被解析为 JSON 对象的记录</li>
</ul>
</li>
<li>Hashtag matching 需要百分百匹配（每个字节都一致），例如 “Naive”, “naive” 和 “naïve” 是不匹配的</li>
</ul>
<h3 id="u60C5_u611F_u5BC6_u5EA6"><a href="#u60C5_u611F_u5BC6_u5EA6" class="headerlink" title="情感密度"></a>情感密度</h3><p>按照下面四个步骤来计算 Sentiment Density</p>
<ol>
<li>文本切分：把推文分隔成一个一个词，注意，这里堆单词的定义是：one or more consecutive alphanumeric characters ([a-zA-Z0-9]+) separated by non-alphanumeric character(s) ([^a-zA-Z0-9])</li>
<li>计算情感得分：简单来说，就是有一个小写字母的英文单词情感词典，只要推文中的某个词在这个词典里，就加上这个词的情感得分（初始分为零），情感词典来自 <a href="http://www2.imm.dtu.dk/pubdb/views/publication_details.php?id=6010" target="_blank" rel="external">AFINN</a> 数据集，在<a href="https://cmucc-datasets.s3.amazonaws.com/15619/f15/afinn.txt" target="_blank" rel="external">这里</a>下载 <ul>
<li>例如：”I love Cloud Computing” 这句话的得分是 3，因为 love 这个单词在情感词典中，且分值为 3</li>
</ul>
</li>
<li>计算有效词数量：也就是过滤掉 stop words。所谓 Effective Word Count(EWC) 可以这样计算 EWC = 总单词数目 - 停止词的数目<ul>
<li>例如：”I love Cloud Computing” 的 EWC 是 3，因为 “I” 是一个停止词</li>
</ul>
</li>
<li>计算 Sentiment Density：如果 EWC 是 0，那么 Sentiment Density 就是 0，如果 EWC 不为 0，那么计算公式是 Sentiment Score / EWC</li>
</ol>
<p>所有的计算结果都四舍五入保留三位小数 (1 -&gt; 1.000, 1.1-&gt;1.100, 1.0005 -&gt; 1.001, 1.9999 -&gt; 2.000, -1 -&gt; -1.000, -1.1-&gt; -1.100, -1.0005 -&gt; -1.001, -1.9999 -&gt; -2.000, etc.)</p>
<p>一个完整的例子：</p>
<p>“I love Cloud Computing” 的 Sentiment Density 为 1.000, 因为它的 Sentimental Score(3) 除以 EWC(3) 是 1.000.</p>
<h3 id="u6587_u672C_u5BA1_u67E5"><a href="#u6587_u672C_u5BA1_u67E5" class="headerlink" title="文本审查"></a>文本审查</h3><p>简单来说就是有敏感词，列表是经过 <a href="http://en.wikipedia.org/wiki/ROT13" target="_blank" rel="external">ROT13ed</a> 处理的。例如，假如一个敏感词是 <code>15619ppgrfg</code> 那么原文就是 <code>15619cctest</code>。具体的敏感词列表在<a href="https://cmucc-datasets.s3.amazonaws.com/15619/f15/banned.txt" target="_blank" rel="external">这里</a>下载</p>
<p>一定要先计算情感值然后再进行文本审查，遇到敏感词，把除第一个和最后一个单词都替换成星号(<code>*</code>).</p>
<p>例如，假设 cloud 是敏感词，如果原文是</p>
<p><code>I love Cloud compz... cloud TAs are the best... Yinz shld tell yr frnz: TAKE CLOUD COMPUTING NEXT SEMESTER!!! Awesome. It&#39;s cloudy tonight.</code></p>
<p>那么返回的时候，应该是这样：</p>
<p><code>I love C***d compz... c***d TAs are the best... Yinz shld tell yr frnz: TAKE C***D COMPUTING NEXT SEMESTER!!! Awesome. It&#39;s cloudy tonight.</code></p>
<p>可以选择在 ETL 过程中完成所有的运算（MapReduce 的时间更长，花费也就更高），或者在每次返回请求的时候运算（如果你写的代码足够快的话）</p>
<p>ETL 的过程中需要处理很多 corner case，可能会出现很多不清晰的地方，所以<a href="https://cmucc-datasets.s3.amazonaws.com/twitter/ref/part-00000-reference" target="_blank" rel="external">这里</a>提供了一个参考文件（小数据集），是第一个数据集(<code>s3://cmucc-datasets/twitter/s16/part-00000</code>) ETL之后的结果，每一行对应输入文件的的一行，每一列以 <code>\t</code> 分隔，具体如下；</p>
<ul>
<li>第 1 列：tweet id.</li>
<li>第 2 列：user id.</li>
<li>第 3 列：tweet date.</li>
<li>第 4 列：sentiment density.</li>
<li>第 5 列：审查后的 tweet 内容，去掉了某些字符，如 newline (\n), tab (\t) etc</li>
<li>第 6 列：hashtags（可能为空）</li>
</ul>
<p>注意处理好各种可能的奇奇怪怪的情况，注意处理好各种可能的奇奇怪怪的情况，注意处理好各种可能的奇奇怪怪的情况。</p>
<blockquote>
<p>请求格式</p>
</blockquote>
<p><code>GET /q2?userid=uid&amp;hashtag=hashtag</code></p>
<p>样例</p>
<p><code>GET /q2?userid=2324314004&amp;hashtag=LinkedIn</code></p>
<blockquote>
<p>响应格式（如果有对应的推文）</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">TEAMID</span>,<span class="tag">TEAM_AWS_ACCOUNT_ID</span>\<span class="tag">n</span></span><br><span class="line"><span class="tag">Sentiment_density1</span><span class="pseudo">:Tweet_time1</span><span class="pseudo">:Tweet_id1</span><span class="pseudo">:Cencored_text1</span>\<span class="tag">n</span></span><br><span class="line"><span class="tag">Sentiment_density2</span><span class="pseudo">:Tweet_time2</span><span class="pseudo">:Tweet_id2</span><span class="pseudo">:Cencored_text2</span>\<span class="tag">n</span></span><br><span class="line"><span class="tag">Sentiment_density3</span><span class="pseudo">:Tweet_time3</span><span class="pseudo">:Tweet_id3</span><span class="pseudo">:Cencored_text3</span>\<span class="tag">n</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>样例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TeamSecret,<span class="number">1123</span>-<span class="number">5813</span>-<span class="number">2134</span></span><br><span class="line"><span class="number">0.308</span>:<span class="number">2014</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">11</span>-<span class="number">42</span>-<span class="number">18</span>:<span class="number">456034778891169793</span>:RT @AlexanderCrepin: How To Find The Best <span class="preprocessor">#LinkedIn Groups To Join - - #personalbranding #jobhunt - - http:<span class="comment">//t.co/ixH5dOf88E</span></span></span><br><span class="line"><span class="number">0.267</span>:<span class="number">2014</span>-<span class="number">06</span>-<span class="number">01</span> <span class="number">19</span>-<span class="number">34</span>-<span class="number">25</span>:<span class="number">473185820636356608</span>:RT @tonyrestell: How To Build Relationships And Win Interviews Through <span class="preprocessor">#LinkedIn http:<span class="comment">//t.co/ELZgPnp4gY #jobhunt tips from @mocksource</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>响应格式（如果没有对应的推文）</p>
</blockquote>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TEAMID,TEAM_AWS_ACCOUNT_ID<span class="string">\n</span></span><br><span class="line"><span class="string">\n</span></span><br></pre></td></tr></table></figure>
<p>一些细节</p>
<ul>
<li><code>Tweet_time</code> 的时间格式是 format:yyyy-MM-dd HH-mm-ss (UTC time, 24-hour clock)</li>
<li>\n 应该被替换成换行符 ‘\n’ 而不是原来的两个符号 ‘\’ + ‘n’.</li>
<li>排序规则<ul>
<li>首先看 <code>Sentimental_density</code>，降序</li>
<li>如果前面数值相同，那么看 <code>Tweet_time</code>，时间按照升序排列</li>
<li>如果还相同，看 <code>Tweet_id</code>，id 按照升序排列，小的在前面</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>项目名称：Twitter Analytics on the Cloud</p>
<p>从这次作业开始，就要小组作业和个人作业并行了。这次的项目主要是在云上分析 Twitter 的相关内容，与以前 GB 级数据不一样，这次我们要处理 TB 级的数据，还是很刺激的。另，这是小组作业，在此先感谢我的队友 @leiyu 和 @shushanc</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="数据" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="服务" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 9 课 递归]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-9/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-9/</id>
    <published>2016-02-24T16:51:34.000Z</published>
    <updated>2016-02-26T00:08:31.000Z</updated>
    <content type="html"><![CDATA[<p>递归之所以成为大家比较头疼的问题，主要还是其思维模式和我们惯常思考问题的方式不大一致，这里简要写下一些关于递归的碎碎念，希望能有所帮助。</p>
<a id="more"></a>
<hr>
<p>我们一直在写程序，但是拿什么来证明程序本身的正确性呢？调试、测试用例、检查输出等等方法都没有办法保证百分百的正确性（黑天鹅效应）。</p>
<p>那怎么办呢？我们结合常见的编程模式来说明</p>
<ul>
<li>Imperative Programming: Java 中常见的编程模式，大部分时间大部分人都是在按这种方式编程</li>
<li>Applicative Programming: 也就是比较出名的『函数式编程』，这里不具体展开，详情参阅<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80" target="_blank" rel="external">这里</a></li>
</ul>
<p>其中函数式编程因为每个函数没有副作用，所以在概念上是比较好证明正确性的。接下来看看递归。</p>
<p>通用的模式是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">recursive_fn(params)&#123;</span><br><span class="line">    <span class="keyword">if</span> (...) <span class="keyword">return</span> some_value;</span><br><span class="line">    <span class="keyword">else</span> ... recursive_fn(new_params)..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种模式是尾递归 tail recursion</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tail_recursive_fn(params)&#123;</span><br><span class="line">    <span class="keyword">if</span> (...) <span class="keyword">return</span> some_value;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> tail_recursive_fn(new_params)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常来说，尾递归会更有效率一些，并且也更容易证明正确性。</p>
<p>另外一个比较常用的方法是回溯法，通用模式是：</p>
<ul>
<li>Test if current position satisfies goal</li>
<li>If not, mark current position as visited and make a recursive call to search procedure on neighboring points</li>
<li>Exhaustive search, terminates as soon as goal is found</li>
</ul>
<p>具体可以参阅我的『编程起跑线系列』</p>
<p>最后说一下递归的好处：</p>
<ul>
<li>实现起来比较简洁</li>
<li>尾递归对栈空间也需求较少</li>
</ul>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>花了比较短的时间把这门课过了一次，总体来说不算特别全面，课件也是东拼西凑勉强合格，除了比较多的作业之外，感觉还是挺一般的。不过话说回来，除了名声在外的几门课，很多课程的教学质量也是堪忧的，唉。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>递归之所以成为大家比较头疼的问题，主要还是其思维模式和我们惯常思考问题的方式不大一致，这里简要写下一些关于递归的碎碎念，希望能有所帮助。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 8 课 有限状态机]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-8/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-8/</id>
    <published>2016-02-24T16:49:42.000Z</published>
    <updated>2016-02-25T23:26:43.000Z</updated>
    <content type="html"><![CDATA[<p>《模仿游戏》的大热让图灵为更多人所知，不过电影中更多说的是图灵破解密码，却对图灵的另一个伟大设想——图灵机所言甚少。图灵机可以看作是某种有限状态机，虽然这个名词听起来比较陌生，但也许这是计算机学科中最重要的概念之一。</p>
<a id="more"></a>
<hr>
<p>最先知道有限状态机，是在本科学习编译原理的时候，实话说，这类概念其实是很难理解的，不过第一次看不懂也不要紧，指不定哪天就悟道了。</p>
<p>我们先来看看常见的集中语言类别及其对应的计算模型：</p>
<p><img src="/images/14564350412980.jpg" alt=""></p>
<h2 id="u57FA_u7840_u6982_u5FF5"><a href="#u57FA_u7840_u6982_u5FF5" class="headerlink" title="基础概念"></a>基础概念</h2><p>我们从最基本的概念说起，为之后进入更加抽象的概念打一些基础。</p>
<p>$\Sigma$: 一个有限的符号集合称为字母表。在 $\Sigma$(字母表)中的每个符号我们称为字母，通常用小写表示，如 a, b, c, …</p>
<p>一个单词 w 是一个字符串，字符串中的字符都来自于 $\Sigma$，$|w|$ 表示单词 w 的长度，一个空的字符串不包含任何字母，并且用 $\varepsilon$ 表示。</p>
<p>一门语言 L 是一个由 $\Sigma$ 中的单词组成的集合，给定字母表 $\Sigma$，所有可能的字符串记为 $\Sigma^<em>$。例如，如果 $\Sigma={a}$，那么 $\Sigma^</em> = {\varepsilon, a, aa, aaa, \dots}$</p>
<p>给定字母表 $\Sigma$，所有可能的长度为 i 的字符串记为 $\Sigma^i$。例如，如果 $\Sigma={a,b}$，那么 $L = \Sigma^2 = {ab, ba, aa, bb}$</p>
<p>然后我们定义一些基本操作</p>
<ul>
<li>Concatenation: putting two strings together。如 $x=aa;y=bb;xy=aabb$</li>
<li>Power: concatenating multiple copies of a letter or word。如 $a^n=a·a^{n-1};a^1 = a; a^2 = a·a$，若 $x=ab;x^3=ababab$</li>
<li>Kleene Star: zero or more copies of a letter or word。如 $a^<em>={\varepsilon, a, aa, aaa, \dots}$, $x=ab;x^</em>={\varepsilon, ab, abab, ababab, \dots }$</li>
</ul>
<h2 id="Finite-state_automaton"><a href="#Finite-state_automaton" class="headerlink" title="Finite-state automaton"></a>Finite-state automaton</h2><p>接下来的定义部分为了避免翻译不准确带来的歧义，这里都使用英文原文。</p>
<p>A <strong>finite-state automaton comprises the following elements:</strong></p>
<ul>
<li>A sequence of <strong>input symbols</strong> (the input “tape”)</li>
<li>The <strong>current location in the input</strong>, which indicates the current input symbol (the read “head”)</li>
<li>The <strong>current state of the machine</strong> (denoted q0, q1,…, qn)</li>
<li>A <strong>transition function</strong> which inputs the current state and the current input, and outputs a new (next) state</li>
</ul>
<p>在计算过程中</p>
<ul>
<li>FSA 在初始状态开始（通常称为 q0）</li>
<li>每一步，状态转移方程会接受当前的输入符号和当前的状态，并且更新到一个新的状态，指针指向下一个符号</li>
<li>在 FSA 到达输入的末尾时，计算过程结束</li>
</ul>
<p>一个或多个状态可以被标记为最终状态，只有计算停止在这些状态时，才认为是计算成功。更多的细节及符号形式请参考<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA" target="_blank" rel="external">这里</a></p>
<h3 id="Regular_Languages"><a href="#Regular_Languages" class="headerlink" title="Regular Languages"></a>Regular Languages</h3><p><img src="/images/14564392411172.jpg" alt=""></p>
<h3 id="NDFSA__u4E0E_DFSA"><a href="#NDFSA__u4E0E_DFSA" class="headerlink" title="NDFSA 与 DFSA"></a>NDFSA 与 DFSA</h3><p>实话说这部分不是特别看得懂，所以只能给出参考链接了</p>
<ul>
<li>NDFSA - <a href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA" target="_blank" rel="external">非确定有限状态自动机</a></li>
<li>DFSA - <a href="https://zh.wikipedia.org/wiki/%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA" target="_blank" rel="external">确定有限状态自动机</a></li>
</ul>
<h2 id="Pushdown_Automaton__u4E0B_u63A8_u81EA_u52A8_u673A"><a href="#Pushdown_Automaton__u4E0B_u63A8_u81EA_u52A8_u673A" class="headerlink" title="Pushdown Automaton 下推自动机"></a>Pushdown Automaton 下推自动机</h2><p>下推自动机比有限状态自动机复杂：除了有限状态组成部分外，还包括一个长度不受限制的栈；下推自动机的状态迁移不但要参考有限状态部分，也要参照栈当前的状态；状态迁移不但包括有限状态的变迁，还包括一个栈的出栈或入栈过程。</p>
<p>具体的解释仍然是比较抽象，这里也没办法展开了，详情参考<a href="https://zh.wikipedia.org/wiki/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA" target="_blank" rel="external">这里</a></p>
<h2 id="Turing_Machines__u56FE_u7075_u673A"><a href="#Turing_Machines__u56FE_u7075_u673A" class="headerlink" title="Turing Machines 图灵机"></a>Turing Machines 图灵机</h2><p>接下来的定义部分为了避免翻译不准确带来的歧义，这里都使用英文原文。</p>
<ul>
<li>The basic model of a Turing machine has a finite control, an input tage that is divided into cells, and a tape head that scans one celll of the tape at a time</li>
<li>The tage has a left most cell but is infinite to the right</li>
<li>Each cell of the tape may hold exactly one of a finite number of tape symbols</li>
<li>Initially, the n leftmost cells, for some finite n &gt;= 0, hold the input, which is a string of symbols chosen from a subset of the tape symbols called the input symbols</li>
<li>The remaining infinity of cells each hold the blank, which is a special symbol that is not an input symbol</li>
</ul>
<p>如下图所示：</p>
<p><img src="/images/14564420943465.jpg" alt=""></p>
<p>具体的解释还是参考<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA" target="_blank" rel="external">维基</a></p>
<h2 id="NP"><a href="#NP" class="headerlink" title="NP"></a>NP</h2><p>最后是更加理论化的一个概念，非定常多项式（英语：non-deterministic polynomial，缩写NP）时间复杂性类，或称非确定性多项式时间复杂性类，包含了可以在多项式时间内，对一个判定性算法问题的实例，一个给定的解是否正确的算法问题。</p>
<p>具体请参考<a href="https://zh.wikipedia.org/wiki/NP_(%E8%A4%87%E9%9B%9C%E5%BA%A6" target="_blank" rel="external">维基</a>)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《模仿游戏》的大热让图灵为更多人所知，不过电影中更多说的是图灵破解密码，却对图灵的另一个伟大设想——图灵机所言甚少。图灵机可以看作是某种有限状态机，虽然这个名词听起来比较陌生，但也许这是计算机学科中最重要的概念之一。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 7 课 数据压缩]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-7/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-7/</id>
    <published>2016-02-24T16:48:25.000Z</published>
    <updated>2016-02-25T21:08:14.000Z</updated>
    <content type="html"><![CDATA[<p>这一部分主要介绍一下两种常见的压缩算法：霍夫曼编码和 LZW，因为我对这个领域研究不算太多，所以更多可能给出一些参考链接，和我对算法思想的理解。</p>
<a id="more"></a>
<hr>
<p>数据压缩是一门非常『应用』的技术，目的是为了提高信息的『密度』，用最小的容量存储最多有意义的数据。记得之前还看过类似『世界压缩大赛』的作品，十多 K 的程序就可以不重复弄出非常浮夸的过场动画。</p>
<p>既然是信息的『密度』，就需要有一个度量来衡量『信息』本身，这就是我们所说的『熵』了（霍夫曼编码就是熵的应用）。</p>
<p>总体来看，可以分为无损压缩和有损压缩，有损压缩适用与图片、声音、视频等领域，在许多字节顺序不允许出错的应用中，都只能使用无损压缩。</p>
<p>无损压缩的两个具体思路，一是通过字典进行映射，二是通过熵来进行『密度』的提升。这节课要说的 LZW 属于字典类压缩，霍夫曼编码属于熵压缩。</p>
<p>具体的细节可以参考：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/LZW" target="_blank" rel="external">LZW</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81" target="_blank" rel="external">霍夫曼编码</a></li>
</ul>
<p>这里不班门弄斧了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一部分主要介绍一下两种常见的压缩算法：霍夫曼编码和 LZW，因为我对这个领域研究不算太多，所以更多可能给出一些参考链接，和我对算法思想的理解。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 6 课 搜索]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-6/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-6/</id>
    <published>2016-02-24T16:46:54.000Z</published>
    <updated>2016-02-25T20:42:30.000Z</updated>
    <content type="html"><![CDATA[<p>排序和搜索可能是互联网中应用最广泛的算法，大到搜索引擎，小到帖子排序，都离不开算法的帮助。这一课我们会简要了解一下各个常见算法，具体实现还是参考给出的链接，这里主要提算法背后的思想。</p>
<a id="more"></a>
<hr>
<p>搜索其实是一个比较宽泛的概念，两个比较大的范畴是：</p>
<ul>
<li>在静态数据库中搜索，如找到某个已索引的网页或找到磁盘上的某个文件</li>
<li>评估一个动态的假设集合，如象棋中搜索下一步或语音识别</li>
</ul>
<p>这里我们主要讨论第一种情形。</p>
<h2 id="u987A_u5E8F_u67E5_u627E"><a href="#u987A_u5E8F_u67E5_u627E" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>这是最简单粗暴的搜索方式了，比方说从数组的第一个元素一直搜索到最后一个元素。</p>
<ul>
<li>Best case: O(1)</li>
<li>Worst case: O(N)</li>
<li>Average case: O(N)</li>
</ul>
<h2 id="u4E8C_u5206_u67E5_u627E"><a href="#u4E8C_u5206_u67E5_u627E" class="headerlink" title="二分查找"></a>二分查找</h2><p>当数据是完全有序的时候，就可以进行二分查找。实现简单，通常也『足够快』不过一定要小心处理 boundary cases，是一个典型的 divide-and-conquer 算法</p>
<p>注意完全正确的二分并不好写，一定要注意可能出错的地方，具体可以参加<a href="https://zh.wikipedia.org/wiki/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95" target="_blank" rel="external">这里</a></p>
<h2 id="u54C8_u5E0C"><a href="#u54C8_u5E0C" class="headerlink" title="哈希"></a>哈希</h2><p>前面提到的两个算法，最快的二分平均时间也要 O(logN)，有没有办法更快呢？</p>
<p>有！使用哈希，可以把时间复杂度降到 O(1)。</p>
<p>最重要的就是哈希函数的选择，以及如果哈希冲突的时候如何解决。一个比较常见的方式是，如果发生了冲突，那么在随机移动若干个位置，具体的值由另一个哈希函数决定。</p>
<p>其他一些常见的哈希：</p>
<ul>
<li>Double Hashing</li>
<li>O-A Hashing</li>
<li>Chained Hashing</li>
</ul>
<p>哈希与二叉树的对比：</p>
<ul>
<li>通常来说更倾向于哈希，因为更快</li>
<li>二叉树是纯动态的，不需要任何相关信息</li>
<li>二叉搜索树保证了 worst case，哈希函数可能会很糟糕</li>
<li>二叉搜索树支持更多操作，如排序</li>
</ul>
<p>另外一个变种是 Radix-Search，类似于与 Trie Tree，这里也不展开了</p>
<h2 id="Bubble_Sort__u5192_u6CE1_u6392_u5E8F"><a href="#Bubble_Sort__u5192_u6CE1_u6392_u5E8F" class="headerlink" title="Bubble Sort 冒泡排序"></a>Bubble Sort 冒泡排序</h2><p>冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p>
<p>步骤：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(arry)</span>:</span></span><br><span class="line">    n = len(arry)                   <span class="comment">#获得数组的长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n-i):</span><br><span class="line">            <span class="keyword">if</span>  arry[j-<span class="number">1</span>] &gt; arry[j] :       <span class="comment">#如果前者比后者大</span></span><br><span class="line">                arry[j-<span class="number">1</span>],arry[j] = arry[j],arry[j-<span class="number">1</span>]      <span class="comment">#则交换两者</span></span><br><span class="line">    <span class="keyword">return</span> arry</span><br></pre></td></tr></table></figure>
<p>针对上述代码还有两种优化方案。</p>
<p>优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。</span></span><br><span class="line"><span class="comment">#用一个标记记录这个状态即可。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort2</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        flag = <span class="number">1</span>                    <span class="comment">#标记</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n-i):</span><br><span class="line">            <span class="keyword">if</span>  ary[j-<span class="number">1</span>] &gt; ary[j] :</span><br><span class="line">                ary[j-<span class="number">1</span>],ary[j] = ary[j],ary[j-<span class="number">1</span>]</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> flag :                   <span class="comment">#全排好序了，直接跳出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<p>优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序了。</span></span><br><span class="line"><span class="comment"># 因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort3</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    k = n                           <span class="comment">#k为循环的范围，初始值n</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,k):        <span class="comment">#只遍历到最后交换的位置即可</span></span><br><span class="line">            <span class="keyword">if</span>  ary[j-<span class="number">1</span>] &gt; ary[j] :</span><br><span class="line">                ary[j-<span class="number">1</span>],ary[j] = ary[j],ary[j-<span class="number">1</span>]</span><br><span class="line">                k = j               <span class="comment">#记录最后交换的位置</span></span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> flag :</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="Selection_Sort__u9009_u62E9_u6392_u5E8F"><a href="#Selection_Sort__u9009_u62E9_u6392_u5E8F" class="headerlink" title="Selection Sort 选择排序"></a>Selection Sort 选择排序</h2><p>选择排序无疑是最简单直观的排序。它的工作原理如下。</p>
<p>步骤：</p>
<ol>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>以此类推，直到所有元素均排序完毕。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">        min = i                             <span class="comment">#最小元素下标标记</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> ary[j] &lt; ary[min] :</span><br><span class="line">                min = j                     <span class="comment">#找到最小值的下标</span></span><br><span class="line">        ary[min],ary[i] = ary[i],ary[min]   <span class="comment">#交换两者</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="Insertion_Sort__u63D2_u5165_u6392_u5E8F"><a href="#Insertion_Sort__u63D2_u5165_u6392_u5E8F" class="headerlink" title="Insertion Sort 插入排序"></a>Insertion Sort 插入排序</h2><p>插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>步骤：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        <span class="keyword">if</span> ary[i] &lt; ary[i-<span class="number">1</span>]:</span><br><span class="line">            temp = ary[i]</span><br><span class="line">            index = i           <span class="comment">#待插入的下标</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):  <span class="comment">#从i-1 循环到 0 (包括0)</span></span><br><span class="line">                <span class="keyword">if</span> ary[j] &gt; temp :</span><br><span class="line">                    ary[j+<span class="number">1</span>] = ary[j]</span><br><span class="line">                    index = j   <span class="comment">#记录待插入下标</span></span><br><span class="line">                <span class="keyword">else</span> :</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            ary[index] = temp</span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="Shell_Sort__u5E0C_u5C14_u6392_u5E8F"><a href="#Shell_Sort__u5E0C_u5C14_u6392_u5E8F" class="headerlink" title="Shell Sort 希尔排序"></a>Shell Sort 希尔排序</h2><p>希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。</p>
<p>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。</p>
<p>例如，假设有这样一组数<code>[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]</code>，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<pre><code>13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
</code></pre><p>然后我们对每列进行排序：</p>
<pre><code>10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45
</code></pre><p>将上述四行数字，依序接在一起时我们得到：<code>[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]</code>。这时10已经移至正确位置了，然后再以3为步长进行排序：</p>
<pre><code>10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
</code></pre><p>排序之后变为：</p>
<pre><code>10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
</code></pre><p>最后以1步长进行排序（此时就是简单的插入排序了）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    gap = round(n/<span class="number">2</span>)       <span class="comment">#初始步长 , 用round四舍五入取整</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap,n):        <span class="comment">#每一列进行插入排序 , 从gap 到 n-1</span></span><br><span class="line">            temp = ary[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> ( j &gt;= gap <span class="keyword">and</span> ary[j-gap] &gt; temp ):    <span class="comment">#插入排序</span></span><br><span class="line">                ary[j] = ary[j-gap]</span><br><span class="line">                j = j - gap</span><br><span class="line">            ary[j] = temp</span><br><span class="line">        gap = round(gap/<span class="number">2</span>)                     <span class="comment">#重新设置步长</span></span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<p>上面源码的步长的选择是从n/2开始，每次再减半，直至为0。步长的选择直接决定了希尔排序的复杂度</p>
<h2 id="Merge_Sort__u5F52_u5E76_u6392_u5E8F"><a href="#Merge_Sort__u5F52_u5E76_u6392_u5E8F" class="headerlink" title="Merge Sort 归并排序"></a>Merge Sort 归并排序</h2><p>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p>
<p>先考虑合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p>
<p>再考虑递归分解，基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(ary) &lt;= <span class="number">1</span> : <span class="keyword">return</span> ary</span><br><span class="line">    num = int(len(ary)/<span class="number">2</span>)       <span class="comment">#二分分解</span></span><br><span class="line">    left = merge_sort(ary[:num])</span><br><span class="line">    right = merge_sort(ary[num:])</span><br><span class="line">    <span class="keyword">return</span> merge(left,right)    <span class="comment">#合并数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left,right)</span>:</span></span><br><span class="line">    <span class="string">'''合并操作，</span><br><span class="line">    将两个有序数组left[]和right[]合并成一个大的有序数组'''</span></span><br><span class="line">    l,r = <span class="number">0</span>,<span class="number">0</span>           <span class="comment">#left与right数组的下标指针</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> l &lt; len(left) <span class="keyword">and</span> r &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[l] &lt; right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">    result += left[l:]</span><br><span class="line">    result += right[r:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="Quick_Sort__u5FEB_u901F_u6392_u5E8F"><a href="#Quick_Sort__u5FEB_u901F_u6392_u5E8F" class="headerlink" title="Quick Sort 快速排序"></a>Quick Sort 快速排序</h2><p>快速排序通常明显比同为Ο(n log n)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。</p>
<p>步骤：</p>
<ol>
<li>从数列中挑出一个元素作为基准数。</li>
<li>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。</li>
<li>再对左右区间递归执行第二步，直至各区间只有一个数。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(ary)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> qsort(ary,<span class="number">0</span>,len(ary)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(ary,left,right)</span>:</span></span><br><span class="line">    <span class="comment">#快排函数，ary为待排序数组，left为待排序的左边界，right为右边界</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right : <span class="keyword">return</span> ary</span><br><span class="line">    key = ary[left]     <span class="comment">#取最左边的为基准数</span></span><br><span class="line">    lp = left           <span class="comment">#左指针</span></span><br><span class="line">    rp = right          <span class="comment">#右指针</span></span><br><span class="line">    <span class="keyword">while</span> lp &lt; rp :</span><br><span class="line">        <span class="keyword">while</span> ary[rp] &gt;= key <span class="keyword">and</span> lp &lt; rp :</span><br><span class="line">            rp -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> ary[lp] &lt;= key <span class="keyword">and</span> lp &lt; rp :</span><br><span class="line">            lp += <span class="number">1</span></span><br><span class="line">        ary[lp],ary[rp] = ary[rp],ary[lp]</span><br><span class="line">    ary[left],ary[lp] = ary[lp],ary[left]</span><br><span class="line">    qsort(ary,left,lp-<span class="number">1</span>)</span><br><span class="line">    qsort(ary,rp+<span class="number">1</span>,right)</span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h2 id="Heap_Sort__u5806_u6392_u5E8F"><a href="#Heap_Sort__u5806_u6392_u5E8F" class="headerlink" title="Heap Sort 堆排序"></a>Heap Sort 堆排序</h2><p>堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 。</p>
<p><strong>二叉堆具有以下性质：</strong></p>
<ol>
<li>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</li>
<li>每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</li>
</ol>
<p><strong>步骤：</strong></p>
<ol>
<li>构造最大堆（<code>Build_Max_Heap</code>）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</li>
<li>堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0…n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0…n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</li>
<li>最大堆调整（<code>Max_Heapify</code>）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(ary)</span> :</span></span><br><span class="line">    n = len(ary)</span><br><span class="line">    first = int(n/<span class="number">2</span>-<span class="number">1</span>)       <span class="comment">#最后一个非叶子节点</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(first,-<span class="number">1</span>,-<span class="number">1</span>) :     <span class="comment">#构造大根堆</span></span><br><span class="line">        max_heapify(ary,start,n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> range(n-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):           <span class="comment">#堆排，将大根堆转换成有序数组</span></span><br><span class="line">        ary[end],ary[<span class="number">0</span>] = ary[<span class="number">0</span>],ary[end]</span><br><span class="line">        max_heapify(ary,<span class="number">0</span>,end-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ary</span><br><span class="line"></span><br><span class="line"><span class="comment">#最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点</span></span><br><span class="line"><span class="comment">#start为当前需要调整最大堆的位置，end为调整边界</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_heapify</span><span class="params">(ary,start,end)</span>:</span></span><br><span class="line">    root = start</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span> :</span><br><span class="line">        child = root*<span class="number">2</span> +<span class="number">1</span>               <span class="comment">#调整节点的子节点</span></span><br><span class="line">        <span class="keyword">if</span> child &gt; end : <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> child+<span class="number">1</span> &lt;= end <span class="keyword">and</span> ary[child] &lt; ary[child+<span class="number">1</span>] :</span><br><span class="line">            child = child+<span class="number">1</span>             <span class="comment">#取较大的子节点</span></span><br><span class="line">        <span class="keyword">if</span> ary[root] &lt; ary[child] :     <span class="comment">#较大的子节点成为父节点</span></span><br><span class="line">            ary[root],ary[child] = ary[child],ary[root]     <span class="comment">#交换</span></span><br><span class="line">            root = child</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="u6307_u6807_u5BF9_u6BD4"><a href="#u6307_u6807_u5BF9_u6BD4" class="headerlink" title="指标对比"></a>指标对比</h2><table>
<thead>
<tr>
<th style="text-align:center">排序方法</th>
<th style="text-align:center">平均情况</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">辅助空间</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">O(nlogn)~O(n2)</td>
<td style="text-align:center">O(n1.3)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(logn)~O(n)</td>
<td style="text-align:center">不稳定</td>
</tr>
</tbody>
</table>
<h2 id="Bucket_Sort__u6876_u6392_u5E8F"><a href="#Bucket_Sort__u6876_u6392_u5E8F" class="headerlink" title="Bucket Sort 桶排序"></a>Bucket Sort 桶排序</h2><p>桶排序和归并排序有那么点点类似，也使用了归并的思想。大致步骤如下：</p>
<ol>
<li>设置一个定量的数组当作空桶。</li>
<li>Divide - 从待排序数组中取出元素，将元素按照一定的规则塞进对应的桶子去。</li>
<li>对每个非空桶进行排序，通常可在塞元素入桶时进行插入排序。</li>
<li>Conquer - 从非空桶把元素再放回原来的数组中。”</li>
</ol>
<h2 id="Counting_Sort__u8BA1_u6570_u6392_u5E8F"><a href="#Counting_Sort__u8BA1_u6570_u6392_u5E8F" class="headerlink" title="Counting Sort 计数排序"></a>Counting Sort 计数排序</h2><p>计数排序，顾名思义，就是对待排序数组按元素进行计数。使用前提是需要先知道待排序数组的元素范围，将这些一定范围的元素置于新数组中，新数组的大小为待排序数组中最大元素与最小元素的差值。</p>
<p>维基上总结的四个步骤如下：</p>
<ol>
<li>定新数组大小——找出待排序的数组中最大和最小的元素</li>
<li>统计次数——统计数组中每个值为i的元素出现的次数，存入新数组C的第i项</li>
<li>对统计次数逐个累加——对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>
<li>反向填充目标数组——将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>
<li>其中反向填充主要是为了避免重复元素落入新数组的同一索引处。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>排序和搜索可能是互联网中应用最广泛的算法，大到搜索引擎，小到帖子排序，都离不开算法的帮助。这一课我们会简要了解一下各个常见算法，具体实现还是参考给出的链接，这里主要提算法背后的思想。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 5 课 图]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-5/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-5/</id>
    <published>2016-02-24T16:45:48.000Z</published>
    <updated>2016-02-25T19:09:05.000Z</updated>
    <content type="html"><![CDATA[<p>前面我们介绍了几种不同类型的树，这一课我们在原来的基础上延伸一下，就能得到图的概念。相对于树，因为不同节点之间的关系更多，无论是表达形式或者是算法细节都会复杂不少，就更需要仔细揣摩。不过究其根本，实际上可以看做是不同矩阵间的信息检索，一定要注意细节。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u672C_u4ECB_u7ECD"><a href="#u57FA_u672C_u4ECB_u7ECD" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>图的话，从类别来看可以分为有向图与无向图，而最关键的操作，图的遍历，有深度优先（递归或者栈）和广度优先（队列）。</p>
<p>图由两类元素组成，一是节点(vertex)，二是边(edge)，下面是一个无向图的例子：</p>
<p><img src="/images/14564071906087.jpg" alt="无向图，边和节点都有对应标记"></p>
<p>无向图和有向图都是一个有限的节点集合加上一个有限的边集合，每条边连接两个节点。不同的地方在于，无向图中连接的顺序是无关紧要的，而有向图中连接的顺序是重要的，是从 source 到 target 的方向，下面是一个有向图的例子：</p>
<p><img src="/images/14564073738319.jpg" alt="有向图的例子，注意箭头的方向"></p>
<p>其他一些需要知道的术语：</p>
<ul>
<li>Loops: edges that connect a vertex to itself</li>
<li>Paths: sequences of vertices p0, p1, …, pm such that each adjacent pair of vertices are connected by an edge</li>
<li>Multiple Edges: two nodes may be connected by &gt;1 edge</li>
<li>Simple Graphs: have no loops and no multiple edges</li>
</ul>
<h2 id="u56FE_u7684_u8868_u793A"><a href="#u56FE_u7684_u8868_u793A" class="headerlink" title="图的表示"></a>图的表示</h2><p>这里介绍三种常见的方式，其实还有其他几种自定义的表示法，这里不拓展了</p>
<h3 id="u90BB_u63A5_u77E9_u9635_Adjacency_Matrix"><a href="#u90BB_u63A5_u77E9_u9635_Adjacency_Matrix" class="headerlink" title="邻接矩阵 Adjacency Matrix"></a>邻接矩阵 Adjacency Matrix</h3><p>用一个二维矩阵来表示点和点之间的连接关系，如果一个图有 N 个节点，那么这个矩阵就是 NxN 的，对于节点 I 和节点 J，如果有一条边连接他们，那么第 I 行第 J 列的值为 true，否则是 false（如果是无向图的话，第 J 行第 I 列的值需要保持一致，也就是说以对角线为轴对称），下面是一个有向图的例子：</p>
<p><img src="/images/14564128326067.jpg" alt="有向图的邻接矩阵"></p>
<h3 id="u8FB9_u5217_u8868_Edge_Lists"><a href="#u8FB9_u5217_u8868_Edge_Lists" class="headerlink" title="边列表 Edge Lists"></a>边列表 Edge Lists</h3><p>另外一种表达方式是每个节点有一个链表，表示它所连接的其他节点，如下图所示：</p>
<p><img src="/images/14564132564620.jpg" alt=""></p>
<h3 id="u8FB9_u96C6_Edge_Sets"><a href="#u8FB9_u96C6_Edge_Sets" class="headerlink" title="边集 Edge Sets"></a>边集 Edge Sets</h3><p>Edge Lists 中我们主要存储的是节点的信息，而在 Edge sets 中我们保存的是边的信息，包含每条边的 source 和 target。</p>
<h3 id="u6027_u80FD_u5206_u6790"><a href="#u6027_u80FD_u5206_u6790" class="headerlink" title="性能分析"></a>性能分析</h3><p>这里主要看一下最坏情况</p>
<ul>
<li>添加或删除边：<ul>
<li>adjacency matrix: O(1)</li>
<li>edge list: O(N)</li>
<li>edge set: O(logN) - 使用 B-Tree</li>
</ul>
</li>
<li>检查某条边是否存在：<ul>
<li>adjacency matrix: O(1)</li>
<li>edge list: O(N)</li>
<li>edge set: O(logN) - 使用 B-Tree 或 红黑树</li>
</ul>
</li>
<li>遍历某个节点的边：<ul>
<li>adjacency matrix: O(N)</li>
<li>edge list: O(E) - 其中 E 是边的数目</li>
<li>edge set: O(E) - 使用 B-Tree 或 红黑树</li>
</ul>
</li>
</ul>
<h2 id="u56FE_u7684_u5B9E_u73B0"><a href="#u56FE_u7684_u5B9E_u73B0" class="headerlink" title="图的实现"></a>图的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] edges;</span><br><span class="line">    <span class="keyword">private</span> Object[] labels;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span> <span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        labels = <span class="keyword">new</span> Object[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span> <span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        edges[s][t] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getLabel</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> labels[v];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[s][t];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] neighbors(<span class="keyword">int</span> v) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">int</span>[] answer;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; labels.length; i++&#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v][i]) count++;</span><br><span class="line">        &#125;    </span><br><span class="line">        answer = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; labels.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v][i]) answer[count++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        edges[s][t] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLabel</span><span class="params">(<span class="keyword">int</span> v, Object n)</span></span>&#123;</span><br><span class="line">        labels[v] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> labels.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u56FE_u7684_u904D_u5386"><a href="#u56FE_u7684_u904D_u5386" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>这个是图问题中比较常见的，一般来说，是从一个特定的节点开始，找到所有可能到达的节点。图和树的区别在于，我们可能会遇到环，所以就需要一种方法来处理这种情况。</p>
<p>我们可以用一个另外的数组来记录一个节点是否被访问过。</p>
<ul>
<li>深度搜索 - Stack</li>
<li>广度搜索 - Queue</li>
</ul>
<p>这一部分比较基础，大家可以自己找一个例子来边输出边测试，这里不再赘述。</p>
<h2 id="u6700_u77ED_u8DEF_u5F84"><a href="#u6700_u77ED_u8DEF_u5F84" class="headerlink" title="最短路径"></a>最短路径</h2><p>最短路径一般应用在有权有向图，如下所示：</p>
<p><img src="/images/14564267263106.jpg" alt=""></p>
<p>我们要找的是路径最短的，但不一定是经过的边最少的，所以 BFS 在这里就不适用了。</p>
<p>我们可以使用 <a href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95" target="_blank" rel="external">Dijkstra’s 算法</a>来处理，wiki 中有比较详细的说明，这里不再赘述。</p>
<p>对于比较稀疏的图，我们用堆来表示图会更好；反之，用邻接矩阵比较好。</p>
<p>另外一个利用动态规划的解法是 <a href="https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95" target="_blank" rel="external">Floyd Warshall 算法</a></p>
<p>索引中的各类算法也可以对应了解一下：</p>
<p><img src="/images/14564271316392.jpg" alt=""></p>
<h2 id="u6700_u5C0F_u751F_u6210_u6811_Minimum_Spanning_Tree__28MST_29"><a href="#u6700_u5C0F_u751F_u6210_u6811_Minimum_Spanning_Tree__28MST_29" class="headerlink" title="最小生成树 Minimum Spanning Tree (MST)"></a>最小生成树 Minimum Spanning Tree (MST)</h2><p>我们一般用 <a href="https://zh.wikipedia.org/wiki/%E6%99%AE%E6%9E%97%E5%A7%86%E7%AE%97%E6%B3%95" target="_blank" rel="external">Prim’s 算法</a>，来寻找最小生成树，是一个贪心算法</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面我们介绍了几种不同类型的树，这一课我们在原来的基础上延伸一下，就能得到图的概念。相对于树，因为不同节点之间的关系更多，无论是表达形式或者是算法细节都会复杂不少，就更需要仔细揣摩。不过究其根本，实际上可以看做是不同矩阵间的信息检索，一定要注意细节。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 4 课 树]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-4/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-4/</id>
    <published>2016-02-24T16:44:36.000Z</published>
    <updated>2016-02-25T13:11:50.000Z</updated>
    <content type="html"><![CDATA[<p>从这一讲开始，慢慢就有点难度了，树的每个节点虽然看起来比较简单，但是不同结点以不同规则进行组合就使得难度指数级增长，后面的红黑树因为涉及到结点的调整，一定要按照前面提到的 5 个步骤来过一次，才能清晰理解。</p>
<a id="more"></a>
<hr>
<h2 id="u6811_u7684_u5E94_u7528"><a href="#u6811_u7684_u5E94_u7528" class="headerlink" title="树的应用"></a>树的应用</h2><p>这次我们换个方式，先从不同的应用角度来了解一下树的用途。</p>
<p><strong>表示数学表达式</strong></p>
<p>我们可以用下面的树来表示 <code>b + a * b</code></p>
<p><img src="/images/14563638168396.jpg" alt=""></p>
<p><strong>XML Document Object Model</strong></p>
<p>XML 实际上也是一个树结构：</p>
<p><img src="/images/14563638734277.jpg" alt=""></p>
<p><strong>表示迁移路径的概率</strong></p>
<p>下图可以认为，从 S 出发，有 p 的概率到 Su，有 1-p 的概率到 Sd</p>
<p><img src="/images/14563639875028.jpg" alt=""></p>
<h2 id="u6811_u7684_u5B9A_u4E49"><a href="#u6811_u7684_u5B9A_u4E49" class="headerlink" title="树的定义"></a>树的定义</h2><p>下面介绍几种不同类型的树</p>
<h3 id="Free_tree"><a href="#Free_tree" class="headerlink" title="Free tree"></a>Free tree</h3><p>指的是相互连接的无环无向图</p>
<p><img src="/images/14563645014537.jpg" alt="Free Tree"></p>
<p>假设 G = (V, E) 是一个无向图，那么下面的语句是等价的：</p>
<ol>
<li>G 是一个 free tree</li>
<li>G 中的任意两个节点间都有唯一的一条路径</li>
<li>G 是连通的的，但是如果去掉任何一条边，G 就不连通了</li>
<li>G 是连通的，并且 $|E|=|V|-1$</li>
<li>G 是无环的，并且 $|E|=|V|-1$</li>
<li>G 是无环的，但是加入任何一条新的边，就会变成有环的</li>
</ol>
<h3 id="Forest__u68EE_u6797"><a href="#Forest__u68EE_u6797" class="headerlink" title="Forest 森林"></a>Forest 森林</h3><p>同样是无环无向图，但不是所有的节点都是连通的</p>
<p><img src="/images/14563646007700.jpg" alt="Forest"></p>
<p>下图中包含一个环，所以不能算是森林：</p>
<p><img src="/images/14563646456272.jpg" alt="包含环的例子"></p>
<h3 id="Rooted_Tree"><a href="#Rooted_Tree" class="headerlink" title="Rooted Tree"></a>Rooted Tree</h3><p>有根的树也是一棵 free tree，但是其中一个节点和其他不同，称为根，下图中的 7 号节点就是根：</p>
<p><img src="/images/14563698058000.jpg" alt=""></p>
<p>有根树中有一些概念需要理解清楚，这里只列举出来不再赘述：ancestor, descendant, proper ancestor, proper descendant, parent, child, siblings, external node(leaf), internal node。</p>
<p>一个节点的孩子数量称之为节点的度(degree)，从根到某节点的要经过的边的数量就是该节点的深度，最大的深度称为树的高度，如下图所示：</p>
<p><img src="/images/14563702807914.jpg" alt=""></p>
<p>根树有几个特例，也非常常用，需要理解清楚，这里列举如下：</p>
<ul>
<li>Binary tree</li>
<li>Full binary tree: each node is either a leaf or has degree exactly 2</li>
<li>Complete k-ary tree: a k-ary tree in which all leaves have the same depth and all internal nodes have degree k</li>
<li>Binary search tree: 一个节点的左右子节点和节点本身满足一定的大小关系</li>
</ul>
<p><img src="/images/14563707343954.jpg" alt="Complete Binary Tree"></p>
<h3 id="Catalan_Numbers"><a href="#Catalan_Numbers" class="headerlink" title="Catalan Numbers"></a>Catalan Numbers</h3><p>先来看公式</p>
<p><img src="/images/14563710814940.jpg" alt=""></p>
<p>然后我们就发现，Catalan 数对应的是有 n 节点的二叉树的数量（根据左右子树的位置可以有不同的结构）</p>
<h2 id="u6811_u7684_u904D_u5386"><a href="#u6811_u7684_u904D_u5386" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>这一部分也是非常重要的内容，基本来说各类考点都在这里，不但需要对概念的清晰理解，还需要利用递归来解决问题（虽然不用递归也可以），主要有下面这四类：</p>
<ol>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层次遍历</li>
</ol>
<p>具体的概念可以在 wiki 上查看，注意一下层次遍历可能需要一些特殊处理即可。</p>
<h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h2><p>如果我们想要表示一个 complete binary tree 的话，其实可以用数组来完成，这种结构其实也可以看成是一个堆。堆的话需要理解的不算特别多，注意下最大堆最小堆，以及对应的操作即可。另外前面提到的优先队列也可以认为是堆，不过这个不展开了。</p>
<p>这一部分我们着重来看看 B-Tree，这是一类搜索树，在给定 n 个节点的条件下，尽可能减少树的高度，相对于原来的二叉搜索树，B-Tree 做了两个调整：</p>
<ol>
<li>节点可以有多于两个子节点</li>
<li>节点中可以保存多个元素</li>
</ol>
<p>因为需要保存不定数量的元素，所以一般用 set 来实现（这种情况下不允许有重复的元素，重复的情况这里暂时不考虑）。稍微提一下，许多数据库都是用 B-Tree 实现的。</p>
<p>所有的 B-Tree 都有一个非常重要的常数 MINIMUM，决定了每个节点中需要保存多少元素，具体的规则如下：</p>
<ol>
<li>根节点有 0 或 1 个元素，其他的节点至少需要保存 MINIMUM 个元素</li>
<li>一个节点中最多可以保存 <code>2*MINIMUM</code> 个元素</li>
<li>一个节点中保存的元素是有序的，从最小到最大</li>
<li>假设一个非叶节点中存有 N 个元素，那么它会有 N+1 个子树</li>
<li>对于任何一个非叶节点：<ul>
<li>第 I 个元素比其第 I 个子树的所有元素都要大</li>
<li>第 I 个元素比其第 I+1 个子树的所有元素都要小</li>
<li><img src="/images/14563744343036.jpg" alt=""></li>
</ul>
</li>
<li>每个叶节点都有相同的深度，也就是说 B-Tree 总是平衡的</li>
</ol>
<p>下图是一个例子，其中 MINIMUM = 1，注意，根节点的每个子节点也是一颗 B-Tree</p>
<p><img src="/images/14563745325794.jpg" alt="B-Tree 的例子"></p>
<p>对应的数据结构是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntBalancedSet</span></span>&#123;</span><br><span class="line">    <span class="comment">// constants</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MINIMUM = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MAXIMUM = <span class="number">2</span> * MINIMUM;</span><br><span class="line">    <span class="comment">// info about root node</span></span><br><span class="line">    <span class="keyword">int</span> dataCount;</span><br><span class="line">    <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[MAXIMUM + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> childCount;</span><br><span class="line">    <span class="comment">// info about children</span></span><br><span class="line">    IntBalancedSet[] subset = <span class="keyword">new</span> IntBalancedSet[MAXIMUM+<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<p><img src="/images/14563980237017.jpg" alt=""></p>
<p>利用 B-Tree 进行搜索的方法如下：</p>
<ul>
<li>找到这样一个 set，满足 <code>data[I] &gt;= target</code> 且 I 尽可能小，如果找不到，则 <code>I = dataCount</code></li>
<li>如果 <code>data[I] == target</code> 返回 true，如果不等于且没有子节点，返回 false</li>
<li>如果不等于但是有子节点，则返回 <code>subset[I].contains(target)</code></li>
</ul>
<p><img src="/images/14563990361014.jpg" alt="利用 B-Tree 进行搜索的例子"></p>
<p>一般来说，结构比较复杂的数据结构，进行修改都会比较麻烦（因为结构中内在的约束太多，变动的话需要满足所有约束），在 B-Tree 中添加和删除节点是比较复杂的操作。这里讲详细一些，用一个具体的例子来做说明（MINIMUM=1）</p>
<p>删除操作的伪代码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">Delete</span>(<span class="keyword">T</span>, X, <span class="keyword">success</span>)</span><br><span class="line">    // 从树 <span class="keyword">T</span> 中删除 <span class="keyword">key</span> 为 X 的节点，如果没有对应节点，则操作失败</span><br><span class="line">    // 操作结果可以从 <span class="keyword">success</span> 变量中获悉</span><br><span class="line">    </span><br><span class="line">    // 先找到 <span class="keyword">key</span> 为 X 的节点的位置</span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">I</span> <span class="keyword">is</span> <span class="keyword">present</span> <span class="keyword">THEN</span></span><br><span class="line">        swap item <span class="keyword">I</span> <span class="keyword">into</span> leaf <span class="keyword">L</span> which contains the inorder successor <span class="keyword">of</span> <span class="keyword">I</span></span><br><span class="line">        // 从 leaf <span class="keyword">L</span> 开始删除操作</span><br><span class="line">        <span class="keyword">IF</span> <span class="keyword">L</span> has <span class="keyword">no</span> items <span class="keyword">THEN</span> Fix(<span class="keyword">L</span>)</span><br><span class="line">        <span class="keyword">success</span> := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        <span class="keyword">success</span> := <span class="literal">false</span></span></span><br></pre></td></tr></table></figure>
<p>然后是其中的 Fix 函数，用来处理没有子节点的节点，保证符合 B-Tree 的基本性质</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Fix(N)</span><br><span class="line">    // N 是一个没有子节点的节点</span><br><span class="line">    // 如果 N 是一个 internal node，那么它有一个子节点</span><br><span class="line">    </span><br><span class="line">    Let P be the parent of N. If N is the root, <span class="operator"><span class="keyword">delete</span> it <span class="keyword">and</span> <span class="keyword">return</span>.</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">some</span> sibling <span class="keyword">of</span> <span class="keyword">N</span> has two items <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">distribute</span> items among <span class="keyword">N</span>, the sibling, <span class="keyword">and</span> <span class="keyword">P</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">IF</span> <span class="keyword">N</span> <span class="keyword">is</span> internal <span class="keyword">THEN</span></span><br><span class="line">            <span class="keyword">move</span> the appropriate <span class="keyword">child</span> <span class="keyword">from</span> the sibling <span class="keyword">to</span> <span class="keyword">N</span></span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        // 如果其兄弟没有两个子节点，就必须要进行融合</span><br><span class="line">        <span class="keyword">Choose</span> an adjancent sibling S <span class="keyword">of</span> <span class="keyword">N</span></span><br><span class="line">        </span><br><span class="line">        Bring the appropriate item down <span class="keyword">from</span> <span class="keyword">P</span> <span class="keyword">into</span> S</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">IF</span> <span class="keyword">N</span> <span class="keyword">is</span> internal <span class="keyword">THEN</span></span><br><span class="line">            <span class="keyword">Move</span> <span class="keyword">N</span><span class="string">'s child to S</span><br><span class="line">        </span><br><span class="line">        Delete node N</span><br><span class="line">        </span><br><span class="line">        IF P is now without an item THEN Fix(P)</span></span></span><br></pre></td></tr></table></figure>
<p>然后我们看看插入操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">Insert</span>(<span class="keyword">T</span>, newitem)</span><br><span class="line">    // 把 newitem 插入到树 <span class="keyword">T</span> 中</span><br><span class="line">    Let X be the <span class="keyword">search</span> <span class="keyword">key</span> <span class="keyword">of</span> <span class="keyword">new</span> item</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">Locate</span> the leaf <span class="keyword">L</span> <span class="keyword">in</span> which X belongs</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">Add</span> newitem <span class="keyword">to</span> <span class="keyword">L</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">L</span> <span class="keyword">now</span> has three items <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">Split</span>(<span class="keyword">L</span>)</span></span><br></pre></td></tr></table></figure>
<p>继续来看看这里的 Split 函数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Split(N)</span><br><span class="line">    // 分割那些有 3 个子节点的节点。注意如果 N 是 internal 的，它可以有 4 个孩子</span><br><span class="line">    Let P be the parent of N</span><br><span class="line">        // 如果 N 是根，那么创建一个新节点 P</span><br><span class="line">        </span><br><span class="line">    <span class="operator"><span class="keyword">Replace</span> node <span class="keyword">N</span> <span class="keyword">by</span> two nodes, N1 <span class="keyword">and</span> N2</span><br><span class="line">    </span><br><span class="line">    Give N1 the item <span class="keyword">in</span> <span class="keyword">N</span> <span class="keyword">with</span> the smallest <span class="keyword">search</span> <span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line">    Give N2 the item <span class="keyword">in</span> <span class="keyword">N</span> <span class="keyword">with</span> the largest <span class="keyword">search</span> <span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">N</span> <span class="keyword">is</span> an iternal node <span class="keyword">THEN</span></span><br><span class="line">        N1 becomes the <span class="keyword">parent</span> <span class="keyword">of</span> <span class="keyword">N</span><span class="string">'s two leftmost children</span><br><span class="line">        N2 becomes the parent of N'</span>s two rightmost children</span><br><span class="line">    </span><br><span class="line">    Send up <span class="keyword">to</span> <span class="keyword">P</span> the item <span class="keyword">in</span> <span class="keyword">N</span> <span class="keyword">with</span> the middle <span class="keyword">search</span> <span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">P</span> <span class="keyword">now</span> has <span class="number">3</span> items <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">Split</span>(<span class="keyword">P</span>)</span></span><br></pre></td></tr></table></figure>
<p>我们给定如下一颗 B-Tree</p>
<p><img src="/images/14564007797015.jpg" alt=""></p>
<p>插入 39 之后（插入总是在叶节点）为</p>
<p><img src="/images/14564008049100.jpg" alt="插入 39 之后"></p>
<p>再插入 38，会发现有一个节点有多于 2 个子节点，需要 split</p>
<p><img src="/images/14564008689598.jpg" alt="插入 38，split 之前"></p>
<p>可以看到我们通过 split 操作把 39 提上去了（注意对照前面的 split 函数的伪代码来进行操作和理解）：</p>
<p><img src="/images/14564009041532.jpg" alt="插入 38，split 之后"></p>
<p>我们再插入 37 与 36，这会导致树高改变，需要进行更多操作，过程如下：</p>
<p><img src="/images/14564011447526.jpg" alt="插入 37 与 36"></p>
<p>插入之后我们发现又出现了非法的节点，依照 split 规则更新之后，上层的节点再次非法，这里属于有四个子节点的情况，左右分开，把中间的 37 移上一层，就成为最后一个形态。</p>
<p>我们再多插入一些，比如 34，35，36，整个过程如下：</p>
<p><img src="/images/14564014630573.jpg" alt=""></p>
<p>最后就得到</p>
<p><img src="/images/14564015026747.jpg" alt=""></p>
<p>注意，因为向下传播的关系，高度是从顶层开始增长的。</p>
<p>然后我们来看看删除操作，还是用刚才的例子，给定：</p>
<p><img src="/images/14564016695179.jpg" alt=""></p>
<p>这次我们删除 50，因为是根节点，所以需要找一个节点放到原来根的位置，并且需要把 70 下移以满足条件</p>
<p><img src="/images/14564016869839.jpg" alt="删除 50"></p>
<p>我们再删除 100 试试看：</p>
<p><img src="/images/14564018498766.jpg" alt=""></p>
<p>同样对照前面的 Fix 函数进行操作即可。然后我们再删除 60，这里需要涉及的变动就会比较多，如下：</p>
<p><img src="/images/14564020922018.jpg" alt=""></p>
<p>然后我们再删除 70 看看，就会变成这样：</p>
<p><img src="/images/14564021367330.jpg" alt="删除 70"></p>
<p>最后再删除 80，又会进行一次融合</p>
<p><img src="/images/14564021619408.jpg" alt="删除 80"></p>
<p>删除操作总是从 leaf 开始的，把要删除的节点和其 inorder successor 换位置。具体的操作如果还不明白，可以找一些视频来看看，这里不赘述了。</p>
<h2 id="u7EA2_u9ED1_u6811_Red_Black_Tree"><a href="#u7EA2_u9ED1_u6811_Red_Black_Tree" class="headerlink" title="红黑树 Red Black Tree"></a>红黑树 Red Black Tree</h2><p>这里只给出基本性质的说明，具体的细节可以查看<a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="external">这里</a></p>
<p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ol>
<p><img src="/images/14564058100039.jpg" alt="红黑树的例子"></p>
<p>这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。</p>
<p>还是那句话对于约束较多的数据结构，进行插入和删除都是比较复杂的操作，最好通过例子掌握整个过程。</p>
<p>最后提一下复杂度，因为树的分叉设计，所以基本来说复杂度都是 log 的，但是需要注意，在最坏情况下，复杂度很可能是 O(n)，</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从这一讲开始，慢慢就有点难度了，树的每个节点虽然看起来比较简单，但是不同结点以不同规则进行组合就使得难度指数级增长，后面的红黑树因为涉及到结点的调整，一定要按照前面提到的 5 个步骤来过一次，才能清晰理解。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
