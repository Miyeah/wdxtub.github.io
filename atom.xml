<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-03-25T00:07:50.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[简易 Shell 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/shell-guide/"/>
    <id>http://wdxtub.com/2016/03/24/shell-guide/</id>
    <published>2016-03-25T00:06:21.000Z</published>
    <updated>2016-03-25T00:07:50.000Z</updated>
    <content type="html"><![CDATA[<p>Shell 可以说是程序员最好的帮手了，这里简单记录一些常用的技巧，包括 shell 脚本与常用的命令。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u672C_u64CD_u4F5C"><a href="#u57FA_u672C_u64CD_u4F5C" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>脚本的第一行叫 shebang，用来告知系统如何执行该脚本 <code>#!/bin/bash</code></li>
<li>输出内容 <code>echo &quot;Hello world!&quot;</code></li>
<li>每一句指令用换行或分号隔开</li>
<li>声明一个变量(不能有空格) <code>VARIABLE=&quot;Some string&quot;</code></li>
<li>使用变量 <code>echo $VARIABLE</code>, <code>echo &quot;$VARIABLE&quot;</code>, <code>echo &#39;$VARIABLE&#39;</code></li>
<li>当赋值和 export 时，或者以其他方式使用变量时，变量名前不加 $</li>
<li>如果要使用变量的值，则要加 $</li>
<li>带你引号不会展开变量</li>
<li>在变量内部进行字符串替换 <code>echo ${VARIABLE/Some/A}</code> 会把 VARIABLE 中首次出现的 Some 替换成 A</li>
<li>内置变量 <code>$?</code>, <code>$$</code>, <code>$#</code>, <code>$@</code></li>
</ul>
<p>例子</p>
<pre><code>echo &quot;Last program return value: $?&quot;
echo &quot;Script&apos;s PID: $$&quot;
echo &quot;Number of arguments: $#&quot;
echo &quot;Scripts arguments: $@&quot;
echo &quot;Scripts arguments separated in different variables: $1 $2&quot;
</code></pre><ul>
<li>读取输入 <code>read NAME</code> 不需要声明新变量</li>
</ul>
<h2 id="u6761_u4EF6_u6D41_u7A0B"><a href="#u6761_u4EF6_u6D41_u7A0B" class="headerlink" title="条件流程"></a>条件流程</h2><p>通常的 IF</p>
<pre><code>if [ $NAME -ne $USER ]
then
    echo &quot;Your name is your username&quot;
else
    echo &quot;Your name isn&apos;t your username&quot;
fi
</code></pre><p>Bash 的 case 语句与 Java 和 C++ 中的 switch 语句类似:</p>
<pre><code>case &quot;$VARIABLE&quot; in
    # 列出需要匹配的字符串
    0) echo &quot;There is a zero.&quot;;;
    1) echo &quot;There is a one.&quot;;;
    *) echo &quot;It is not null.&quot;;;
esac
</code></pre><h2 id="u8868_u8FBE_u5F0F"><a href="#u8868_u8FBE_u5F0F" class="headerlink" title="表达式"></a>表达式</h2><ul>
<li>格式 <code>echo $(( 10 + 5 ))</code></li>
</ul>
<h2 id="u4E0A_u4E0B_u6587_u4F9D_u8D56"><a href="#u4E0A_u4E0B_u6587_u4F9D_u8D56" class="headerlink" title="上下文依赖"></a>上下文依赖</h2><ul>
<li>bash 运行时依赖上下文</li>
<li><code>ls</code> 列出当前目录</li>
<li><code>ls -l</code> 列出文件和目录的详细信息，指令可以带有选项</li>
<li>前一个指令的输出可以当做后一个指令的输入。<code>grep</code> 用来匹配字符串</li>
<li>用下面的指令列出当前目录下所有的 txt 文件 <code>ls -l | grep &quot;\.txt&quot;</code></li>
<li>重定向可以到输出，输入和错误输出。 &gt; 会覆盖已存在的文件，&gt;&gt; 会以累加的方式输出文件中</li>
</ul>
<p>例如</p>
<pre><code>python hello.py &lt; &quot;input.in&quot;
python hello.py &gt; &quot;output.out&quot;
python hellp.py &gt;&gt; &quot;error.err&quot;
</code></pre><ul>
<li>一个指令可用 <code>$()</code> 嵌套在另一个指令内部，如 <code>echo &quot;There are $(ls | wc -l) items here.&quot;</code></li>
</ul>
<h2 id="u5176_u4ED6"><a href="#u5176_u4ED6" class="headerlink" title="其他"></a>其他</h2><p>循环遍历给定的参数序列:变量$VARIABLE 的值会被打印 3 次。注意 ` ` 和 $( ) 等价。seq 返回长度为 3 的数组。</p>
<pre><code>for VARIABLE in `seq 3`
do
    echo &quot;$VARIABLE&quot;
done
</code></pre><p>你也可以使用函数，定义函数：</p>
<pre><code>function foo ()
{
    echo &quot;Arguments work just like script arguments: $@&quot;
    echo &quot;And: $1 $2...&quot;
    echo &quot;This is a function&quot;
    return 0
}
</code></pre><p>更简单的方法</p>
<pre><code>bar ()
{
    echo &quot;Another way to declare functions!&quot;
    return 0
}
</code></pre><p>调用函数</p>
<pre><code>foo &quot;My name is&quot; $NAME
</code></pre><p>有很多有用的指令需要学习:</p>
<pre><code>tail -n 10 file.txt
</code></pre><p>打印 file.txt 的最后 10 行</p>
<pre><code>head -n 10 file.txt
</code></pre><p>打印 file.txt 的前 10 行</p>
<pre><code>sort file.txt
</code></pre><p>将 file.txt 按行排序</p>
<pre><code>uniq -d file.txt
</code></pre><p>报告或忽略重复的行，用选项 -d 打印重复的行</p>
<pre><code>cut -d &apos;,&apos; -f 1 file.txt
</code></pre><p>打印每行中 ‘,’ 之前内容</p>
<h2 id="u57FA_u7840"><a href="#u57FA_u7840" class="headerlink" title="基础"></a>基础</h2><ul>
<li>学习 Bash 的基础知识。具体来说，输入 <code>man bash</code> 并至少全文浏览一遍; 它很简单并且不长。其他的 shell 可能很好用，但 Bash 功能强大且几乎所有情况下都是可用的 （ <em>只</em>学习 zsh，fish 或其他的 shell 的话，在你自己的电脑上会显得很方便，但在很多情况下会限制你，比如当你需要在服务器上工作时）。</li>
<li>学习并掌握至少一个基于文本的编辑器。通常 Vim （<code>vi</code>） 会是你最好的选择，因为在终端里进行随机编辑 Vim 真的毫无敌手，哪怕是 Emacs、某大型 IDE 甚至时下非常流行的编辑器。</li>
<li>学会如何使用 <code>man</code> 命令去阅读文档。学会使用 <code>apropos</code> 去查找文档。了解有些命令并不对应可执行文件，而是Bash内置的，可以使用 <code>help</code> 和 <code>help -d</code> 命令获取帮助信息。</li>
<li>学会使用 <code>&gt;</code> 和 <code>&lt;</code> 来重定向输出和输入，学会使用 <code>|</code> 来重定向管道。明白 <code>&gt;</code> 会覆盖了输出文件而 <code>&gt;&gt;</code> 是在文件未添加。了解标准输出 stdout 和标准错误 stderr。</li>
<li>学会使用通配符 <code>*</code> （或许再算上 <code>?</code> 和 <code>[</code>…<code>]</code>） 和引用以及引用中 <code>&#39;</code> 和 <code>&quot;</code> 的区别。</li>
<li>熟悉 Bash 任务管理工具：<code>&amp;</code>，<strong>ctrl-z</strong>，<strong>ctrl-c</strong>，<code>jobs</code>，<code>fg</code>，<code>bg</code>，<code>kill</code> 等。</li>
<li>了解 <code>ssh</code>，以及学会通过使用 <code>ssh-agent</code>，<code>ssh-add</code> 等命令来实现基本的无密码认证。</li>
<li>学会基本的文件管理：<code>ls</code> 和 <code>ls -l</code> （了解 <code>ls -l</code> 中每一列代表的意义），<code>less</code>，<code>head</code>，<code>tail</code> 和 <code>tail -f</code> （甚至 <code>less +F</code>），<code>ln</code> 和 <code>ln -s</code> （了解硬链接与软链接的区别），<code>chown</code>，<code>chmod</code>，<code>du</code> （硬盘使用情况概述：<code>du -hs *</code>）。 关于文件系统的管理，学习 <code>df</code>，<code>mount</code>，<code>fdisk</code>，<code>mkfs</code>，<code>lsblk</code>。知道 inode 是什么（与 <code>ls -i</code> 和 <code>df -i</code> 等命令相关）。</li>
<li>学习基本的网络管理：<code>ip</code> 或 <code>ifconfig</code>，<code>dig</code>。</li>
<li>熟悉正则表达式，以及 <code>grep</code>／<code>egrep</code> 里不同参数的作用，例如 <code>-i</code>，<code>-o</code>，<code>-v</code>，<code>-A</code>，<code>-B</code> 和 <code>-C</code>，这些参数是值得学习并掌握的。</li>
<li>学会使用 <code>apt-get</code>，<code>yum</code>，<code>dnf</code> 或 <code>pacman</code> （取决于你使用的 Linux 发行版）来查找或安装软件包。并确保你的环境中有 <code>pip</code> 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 <code>pip</code> 来安装会很方便）。</li>
</ul>
<h2 id="u65E5_u5E38_u4F7F_u7528"><a href="#u65E5_u5E38_u4F7F_u7528" class="headerlink" title="日常使用"></a>日常使用</h2><ul>
<li>在 Bash 中，可以使用 <strong>Tab</strong> 自动补全参数，使用 <strong>ctrl-r</strong> 搜索命令行历史（在按下之后，键入便可以搜索，重复按下 <strong>ctrl-r</strong> 会在更多匹配中循环，按下 <strong>Enter</strong> 会执行找到的命令，按下右方向键会将结果放入当前行中，使你可以进行编辑）。</li>
<li>在 Bash 中，可以使用 <strong>ctrl-w</strong> 删除你键入的最后一个单词，使用 <strong>ctrl-u</strong> 删除整行，使用 <strong>alt-b</strong> 和 <strong>alt-f</strong> 以单词为单位移动光标，使用 <strong>ctrl-a</strong> 将光标移至行首，使用 <strong>ctrl-e</strong> 将光标移至行尾，使用 <strong>ctrl-k</strong> 删除光标至行尾的所有内容，使用 <strong>ctrl-l</strong> 清屏。键入 <code>man readline</code> 查看 Bash 中的默认快捷键，内容很多。例如 <strong>alt-.</strong> 循环地移向前一个参数，以及 <strong>alt-*</strong> 展开通配符。</li>
<li>你喜欢的话，可以键入 <code>set -o vi</code> 来使用 vi 风格的快捷键，而 <code>set -o emacs</code> 可以把它改回来。</li>
<li>为了方便地键入长命令，在设置你的编辑器后（例如 <code>export EDITOR=vim</code>），键入 <strong>ctrl-x</strong> <strong>ctrl-e</strong> 会打开一个编辑器来编辑当前命令。在 vi 模式下则键入 <strong>escape-v</strong> 实现相同的功能。</li>
<li>键入 <code>history</code> 查看命令行历史记录。其中有许多缩写，例如 <code>!$</code>（最后键入的参数）和 <code>!!</code>（最后键入的命令），尽管通常被 <strong>ctrl-r</strong> 和 <strong>alt-.</strong> 取代。</li>
<li>回到上一个工作路径：<code>cd -</code></li>
<li>如果你输入命令的时候改变了主意，按下 <strong>alt-#</strong> 来在行首添加 <code>#</code>，或者依次按下 <strong>ctrl-a</strong>， <strong>#</strong>， <strong>enter</strong>。这样做的话，之后你可以很方便的利用命令行历史回到你刚才输入到一半的命令。</li>
<li><p>使用 <code>xargs</code> （ 或 <code>parallel</code>）。他们非常给力。注意到你可以控制每行参数个数（<code>-L</code>）和最大并行数（<code>-P</code>）。如果你不确定它们是否会按你想的那样工作，先使用 <code>xargs echo</code> 查看一下。此外，使用 <code>-I{}</code> 会很方便。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">'*.py'</span> | xargs grep some_<span class="keyword">function</span></span><br><span class="line">cat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>pstree -p</code> 有助于展示进程树。</p>
</li>
<li>使用 <code>pgrep</code> 和 <code>pkill</code> 根据名字查找进程或发送信号（<code>-f</code> 参数通常有用）。</li>
<li>了解你可以发往进程的信号的种类。比如，使用 <code>kill -STOP [pid]</code> 停止一个进程。使用 <code>man 7 signal</code> 查看详细列表。</li>
<li>使用 <code>nohup</code> 或 <code>disown</code> 使一个后台进程持续运行。</li>
<li>使用 <code>netstat -lntp</code> 或 <code>ss -plat</code> 检查哪些进程在监听端口（默认是检查 TCP 端口; 使用参数 <code>-u</code> 检查 UDP 端口）。</li>
<li>有关打开套接字和文件，请参阅 <code>lsof</code>。</li>
<li>使用 <code>uptime</code> 或 <code>w</code> 来查看系统已经运行多长时间。</li>
<li>使用 <code>alias</code> 来创建常用命令的快捷形式。例如：<code>alias ll=&#39;ls -latr&#39;</code> 使你可以方便地执行<code>ls -latr</code>命令。</li>
<li><p>在 Bash 脚本中，使用 <code>set -x</code> 去调试输出，尽可能的使用严格模式，使用 <code>set -e</code> 令脚本在发生错误时退出而不是继续运行，使用 <code>set -u</code> 来检查是否使用了未赋值的变量，使用 <code>set -o pipefail</code> 严谨地对待错误（尽管问题可能很微妙）。当牵扯到很多脚本时，使用 <code>trap</code>。一个好的习惯是在脚本文件开头这样写，这会使它检测一些错误，并在错误发生时中断程序并输出信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -euo pipefail</span><br><span class="line"><span class="built_in">trap</span> <span class="string">"echo 'error: Script failed: see failed command above'"</span> ERR</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Bash 脚本中，子 shell（使用括号 <code>(...)</code>）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># do something in current dir</span></span><br><span class="line">(<span class="built_in">cd</span> /some/other/dir &amp;&amp; other-command)</span><br><span class="line"><span class="comment"># continue in original dir</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Bash 中，要注意其中有许多形式的扩展。检查变量是否存在：<code>${name:?error message}</code>。例如，当 Bash 脚本需要一个参数时，可以使用这样的代码 <code>input_file=${1:?usage: $0 input_file}</code>。数学表达式：<code>i=$(( (i + 1) % 5 ))</code>。序列：<code>{1..10}</code>。截断字符串：<code>${var%suffix}</code> 和 <code>${var#prefix}</code>。例如，假设 <code>var=foo.pdf</code>，那么 <code>echo ${var%.pdf}.txt</code> 将输出 <code>foo.txt</code>。</p>
</li>
<li><p>使用括号扩展（<code>{</code>…<code>}</code>）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 <code>mv foo.{txt,pdf} some-dir</code>（同时移动两个文件），<code>cp somefile{,.bak}</code>（会被扩展成 <code>cp somefile somefile.bak</code>）或者 <code>mkdir -p test-{a,b,c}/subtest-{1,2,3}</code>（会被扩展成所有可能的组合，并创建一个目录树）。</p>
</li>
<li><p>通过使用 <code>&lt;(some command)</code> 可以将输出视为文件。例如，对比本地文件 <code>/etc/hosts</code> 和一个远程文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)</span><br></pre></td></tr></table></figure>
</li>
<li><p>了解 Bash 中的“here documents”，例如 <code>cat &lt;&lt;EOF ...</code>。</p>
</li>
<li><p>在 Bash 中，同时重定向标准输出和标准错误，<code>some-command &gt;logfile 2&gt;&amp;1</code>。通常，为了保证命令不会在标准输入里残留一个打开了的文件句柄导致你当前所在的终端无法操作，添加 <code>&lt;/dev/null</code> 是一个好习惯。</p>
</li>
<li><p>使用 <code>man ascii</code> 查看具有十六进制和十进制值的ASCII表。<code>man unicode</code>，<code>man utf-8</code>，以及 <code>man latin1</code> 有助于你去了解通用的编码信息。</p>
</li>
<li><p>使用 <code>screen</code> 或 <a href="https://tmux.github.io/" target="_blank" rel="external"><code>tmux</code></a> 来使用多个屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。另一个轻量级的解决方案是 <code>dtach</code>。</p>
</li>
<li><p>ssh 中，了解如何使用 <code>-L</code> 或 <code>-D</code>（偶尔需要用 <code>-R</code>）去开启隧道是非常有用的，例如当你需要从一台远程服务器上访问 web。</p>
</li>
<li><p>对 ssh 设置做一些小优化可能是很有用的，例如这个 <code>~/.ssh/config</code> 文件包含了防止特定环境下断开连接、压缩数据、多通道等选项：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TCPKeepAlive=<span class="literal">yes</span></span><br><span class="line">ServerAliveInterval=<span class="number">15</span></span><br><span class="line">ServerAliveCountMax=<span class="number">6</span></span><br><span class="line">Compression=<span class="literal">yes</span></span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath <span class="regexp">/tmp/</span>%r@%<span class="attribute">h</span>:%p</span><br><span class="line">ControlPersist <span class="literal">yes</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>部分其他的关于 ssh 的选项是安全敏感且应当小心启用的。例如在可信任的网络中：<code>StrictHostKeyChecking=no</code>，<code>ForwardAgent=yes</code></p>
</li>
<li><p>考虑使用 <a href="https://mosh.mit.edu/" target="_blank" rel="external"><code>mosh</code></a> 作为 ssh 的替代品，它使用 UDP 协议。</p>
</li>
<li><p>获取文件的八进制格式权限，使用类似如下的代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> -c <span class="string">'%A %a %n'</span> /etc/timezone</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <a href="https://github.com/mooz/percol" target="_blank" rel="external"><code>percol</code></a> 或者 <a href="https://github.com/junegunn/fzf" target="_blank" rel="external"><code>fzf</code></a> 可以交互式地从另一个命令输出中选取值。</p>
</li>
<li><p>使用 <code>fpp</code>（<a href="https://github.com/facebook/PathPicker" target="_blank" rel="external">PathPicker</a>）可以与基于另一个命令(例如 <code>git</code>）输出的文件交互。</p>
</li>
<li><p>将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：<br><code>python -m SimpleHTTPServer 7777</code> （使用端口 7777 和 Python 2）或<code>python -m http.server 7777</code> （使用端口 7777 和 Python 3）。</p>
</li>
<li><p>以某种权限执行命令，使用<code>sudo</code>（root 权限）或<code>sudo -u</code>（其他用户）。使用<code>su</code>或者<code>sudo bash</code>来启动一个以对应用户权限运行的 shell。使用<code>su -</code>模拟其他用户的登录。</p>
</li>
</ul>
<h2 id="u6587_u4EF6_u53CA_u6570_u636E_u5904_u7406"><a href="#u6587_u4EF6_u53CA_u6570_u636E_u5904_u7406" class="headerlink" title="文件及数据处理"></a>文件及数据处理</h2><ul>
<li><p>在当前路径下通过文件名定位一个文件，<code>find . -iname &#39;*something*&#39;</code>（或类似的）。在所有路径下通过文件名查找文件，使用 <code>locate something</code> （但请记住 <code>updatedb</code> 可能没有对最近新建的文件建立索引）。</p>
</li>
<li><p>使用 <a href="https://github.com/ggreer/the_silver_searcher" target="_blank" rel="external"><code>ag</code></a> 在源代码或数据文件里检索（比 <code>grep -r</code> 更好）。</p>
</li>
<li><p>将 HTML 转为文本：<code>lynx -dump -stdin</code></p>
</li>
<li><p>Markdown，HTML，以及所有文档格式之间的转换，试试 <a href="http://pandoc.org/" target="_blank" rel="external"><code>pandoc</code></a>。</p>
</li>
<li><p>如果你不得不处理 XML，<code>xmlstarlet</code> 宝刀未老。</p>
</li>
<li><p>使用 <a href="http://stedolan.github.io/jq/" target="_blank" rel="external"><code>jq</code></a> 处理 JSON。</p>
</li>
<li><p>使用 <a href="https://github.com/0k/shyaml" target="_blank" rel="external"><code>shyaml</code></a> 处理 YAML。</p>
</li>
<li><p>Excel 或 CSV 文件的处理，<a href="https://github.com/onyxfish/csvkit" target="_blank" rel="external">csvkit</a> 提供了 <code>in2csv</code>，<code>csvcut</code>，<code>csvjoin</code>，<code>csvgrep</code> 等工具。</p>
</li>
<li><p>关于 Amazon S3，<a href="https://github.com/s3tools/s3cmd" target="_blank" rel="external"><code>s3cmd</code></a> 很方便而 <a href="https://github.com/bloomreach/s4cmd" target="_blank" rel="external"><code>s4cmd</code></a> 更快。Amazon 官方的 <a href="https://github.com/aws/aws-cli" target="_blank" rel="external"><code>aws</code></a> 以及  <a href="https://github.com/donnemartin/saws" target="_blank" rel="external"><code>saws</code></a> 是其他 AWS 相关工作的基础。</p>
</li>
<li><p>了解如何使用 <code>sort</code> 和 <code>uniq</code>，包括 uniq 的 <code>-u</code> 参数和 <code>-d</code> 参数，详见后文单行脚本节。另外可以了解一下 <code>comm</code>。</p>
</li>
<li><p>了解如何使用 <code>cut</code>，<code>paste</code> 和 <code>join</code> 来更改文件。很多人都会使用 <code>cut</code>，但几乎都不会使用 <code>join</code>。</p>
</li>
<li><p>了解如何运用 <code>wc</code> 去计算新行数（<code>-l</code>），字符数（<code>-m</code>），单词数（<code>-w</code>）以及字节数（<code>-c</code>）。</p>
</li>
<li><p>了解如何使用 <code>tee</code> 将标准输入复制到文件甚至标准输出，例如 <code>ls -al | tee file.txt</code>。</p>
</li>
<li><p>了解语言环境对许多命令行工具的微妙影响，包括排序的顺序和性能。大多数 Linux 的安装过程会将 <code>LANG</code> 或其他有关的变量设置为符合本地的设置。意识到当你改变语言环境时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降<em>许多倍</em>。某些情况下（例如集合运算）你可以放心的使用 <code>export LC_ALL=C</code> 来忽略掉国际化并使用基于字节的顺序。</p>
</li>
<li><p>了解 <code>awk</code> 和 <code>sed</code> 关于数据的简单处理的用法。例如，将文本文件中第三列的所有数字求和：<code>awk &#39;{ x += $3 } END { print x }&#39;</code>. 这可能比同等作用的 Python 代码快三倍且代码量少三倍。</p>
</li>
<li><p>替换一个或多个文件中出现的字符串：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pi.bak <span class="operator">-e</span> <span class="string">'s/old-string/new-string/g'</span> my-files-*.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <a href="https://github.com/jlevy/repren" target="_blank" rel="external"><code>repren</code></a> 来批量重命名，或是在多个文件中搜索替换。（有些时候 <code>rename</code> 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Full rename of filenames, directories, and contents foo -&gt; bar:</span></span><br><span class="line">repren --full --preserve-case --from foo --to bar .</span><br><span class="line"><span class="comment"># Recover backup files whatever.bak -&gt; whatever:</span></span><br><span class="line">repren --renames --from <span class="string">'(.*)\.bak'</span> --to <span class="string">'\1'</span> *.bak</span><br><span class="line"><span class="comment"># Same as above, using rename, if available:</span></span><br><span class="line">rename <span class="string">'s/\.bak$//'</span> *.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据 man 页面的描述，<code>rsync</code> 真的是一个快速且非常灵活的文件复制工具。它通常被用于机器间的同步，但在本地也同样有用。它同时也是删除大量文件的<a href="https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html" target="_blank" rel="external">最快方法</a>之一：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>shuf</code> 从一个文件中随机选取多行。</p>
</li>
<li><p>了解 <code>sort</code> 的参数。处理数字方面，使用 <code>-n</code> 或者 <code>-h</code> 来处理可读性数字（例如 <code>du -h</code> 的输出）。明白键的工作原理（<code>-t</code> 和 <code>-k</code>）。例如，注意到你需要 <code>-k1，1</code> 来仅按第一个域来排序，而 <code>-k1</code> 意味着按整行排序。稳定排序（<code>sort -s</code>）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 <code>sort -k1，1 | sort -s -k2，2</code>。</p>
</li>
<li><p>如果你想在 Bash 命令行中写 tab 制表符，按下 <strong>ctrl-v</strong> <strong>[Tab]</strong> 或键入 <code>$&#39;\t&#39;</code> （后者可能更好，因为你可以复制粘贴它）。</p>
</li>
<li><p>标准的源代码对比及合并工具是 <code>diff</code> 和 <code>patch</code>。使用 <code>diffstat</code> 查看变更总览数据。注意到 <code>diff -r</code> 对整个文件夹有效。使用 <code>diff -r tree1 tree2 | diffstat</code> 查看变更总览数据。</p>
</li>
<li><p>对于二进制文件，使用 <code>hd</code> 使其以十六进制显示以及使用 <code>bvi</code> 来编辑二进制。</p>
</li>
<li><p>同样对于二进制文件，<code>strings</code>（包括 <code>grep</code> 等等）允许你查找一些文本。</p>
</li>
<li><p>二进制文件对比（Delta 压缩），使用 <code>xdelta3</code>。</p>
</li>
<li><p>使用 <code>iconv</code> 更改文本编码。而更高级的用法，可以使用 <code>uconv</code>，它支持一些高级的 Unicode 功能。例如，这条命令将所有元音字母转为小写并移除了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uconv <span class="operator">-f</span> utf-<span class="number">8</span> -t utf-<span class="number">8</span> -x <span class="string">'::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; '</span> &lt; input.txt &gt; output.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>拆分文件，查看 <code>split</code>（按大小拆分）和 <code>csplit</code>（按模式拆分）。</p>
</li>
<li><p>用 <a href="http://www.fresse.org/dateutils/" target="_blank" rel="external"><code>dateutils</code></a> 中的 <code>dateadd</code>, <code>datediff</code>, <code>strptime</code> 等工具操作日期和时间表达式。</p>
</li>
<li><p>使用 <code>zless</code>，<code>zmore</code>，<code>zcat</code> 和 <code>zgrep</code> 对压缩过的文件进行操作。</p>
</li>
</ul>
<h2 id="u7CFB_u7EDF_u8C03_u8BD5"><a href="#u7CFB_u7EDF_u8C03_u8BD5" class="headerlink" title="系统调试"></a>系统调试</h2><ul>
<li><p><code>curl</code> 和 <code>curl -I</code> 可以便捷地被应用于 web 调试中，它们的好兄弟 <code>wget</code> 也可以，或者是更潮的 <a href="https://github.com/jakubroztocil/httpie" target="_blank" rel="external"><code>httpie</code></a>。</p>
</li>
<li><p>使用 <code>iostat</code>、<code>netstat</code>、<code>top</code> （<code>htop</code> 更佳）和 <code>dstat</code> 去获取硬盘、cpu 和网络的状态。熟练掌握这些工具可以使你快速的对系统的当前状态有一个大概的认识。</p>
</li>
<li><p>使用 <code>netstat</code> 和 <code>ss</code> 查看网络连接的细节。</p>
</li>
<li><p>若要对系统有一个深度的总体认识，使用 <a href="https://github.com/nicolargo/glances" target="_blank" rel="external"><code>glances</code></a>。它在一个终端窗口中向你提供一些系统级的数据。这对于快速的检查各个子系统非常有帮助。</p>
</li>
<li><p>若要了解内存状态，运行并理解 <code>free</code> 和 <code>vmstat</code> 的输出。尤其注意“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，因此它与空闲内存无关。</p>
</li>
<li><p>Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 <code>kill -3 &lt;pid&gt;</code> 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准输出/日志文件。JDK 中的 <code>jps</code>，<code>jstat</code>，<code>jstack</code>，<code>jmap</code> 很有用。<a href="https://github.com/aragozin/jvm-tools" target="_blank" rel="external">SJK tools</a> 更高级.</p>
</li>
<li><p>使用 <code>mtr</code> 去跟踪路由，用于确定网络问题。</p>
</li>
<li><p>用 <code>ncdu</code> 来查看磁盘使用情况，它比常用的命令，如 <code>du -sh *</code>，更节省时间。</p>
</li>
<li><p>查找正在使用带宽的套接字连接或进程，使用 <code>iftop</code> 或 <code>nethogs</code>。</p>
</li>
<li><p><code>ab</code> 工具（捆绑于 Apache）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 <code>siege</code>。</p>
</li>
<li><p><code>wireshark</code>，<code>tshark</code> 和 <code>ngrep</code> 可用于复杂的网络调试。</p>
</li>
<li><p>了解 <code>strace</code> 和 <code>ltrace</code>。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（<code>-c</code>）和附加到一个运行的进程参数 （<code>-p</code>）。</p>
</li>
<li><p>了解使用 <code>ldd</code> 来检查共享库。</p>
</li>
<li><p>了解如何运用 <code>gdb</code> 连接到一个运行着的进程并获取它的堆栈轨迹。</p>
</li>
<li><p>学会使用 <code>/proc</code>。它在调试正在出现的问题的时候有时会效果惊人。比如：<code>/proc/cpuinfo</code>，<code>/proc/meminfo</code>，<code>/proc/cmdline</code>，<code>/proc/xxx/cwd</code>，<code>/proc/xxx/exe</code>，<code>/proc/xxx/fd/</code>，<code>/proc/xxx/smaps</code>（这里的 <code>xxx</code> 表示进程的 id 或 pid）。</p>
</li>
<li><p>当调试一些之前出现的问题的时候，<code>sar</code> 非常有用。它展示了 cpu、内存以及网络等的历史数据。</p>
</li>
<li><p>关于更深层次的系统分析以及性能分析，看看 <code>stap</code>（<a href="https://sourceware.org/systemtap/wiki" target="_blank" rel="external">SystemTap</a>），<a href="http://en.wikipedia.org/wiki/Perf_(Linux" target="_blank" rel="external"><code>perf</code></a>)，以及<a href="https://github.com/draios/sysdig" target="_blank" rel="external"><code>sysdig</code></a>。</p>
</li>
<li><p>查看你当前使用的系统，使用 <code>uname</code> ， <code>uname -a</code> （Unix／kernel 信息） 或者 <code>lsb_release -a</code> （Linux 发行版信息）。</p>
</li>
<li><p>无论什么东西工作得很欢乐时试试 <code>dmesg</code>（可能是硬件或驱动问题）。</p>
</li>
</ul>
<h2 id="u5355_u884C_u811A_u672C"><a href="#u5355_u884C_u811A_u672C" class="headerlink" title="单行脚本"></a>单行脚本</h2><p>一些命令组合的例子：</p>
<ul>
<li><p>当你需要对文本文件做集合交、并、差运算时，结合使用 <code>sort</code>/<code>uniq</code> 很有帮助。假设 <code>a</code> 与 <code>b</code> 是两内容不同的文件。这种方式效率很高，并且在小文件和上G的文件上都能运用 （<code>sort</code> 不被内存大小约束，尽管在 <code>/tmp</code> 在一个小的根分区上时你可能需要 <code>-T</code> 参数），参阅前文中关于 <code>LC_ALL</code> 和 <code>sort</code> 的 <code>-u</code> 参数的部分。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat a b | sort | uniq &gt; c   <span class="comment"># c is a union b</span></span><br><span class="line">cat a b | sort | uniq <span class="operator">-d</span> &gt; c   <span class="comment"># c is a intersect b</span></span><br><span class="line">cat a b b | sort | uniq -u &gt; c   <span class="comment"># c is set difference a - b</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>grep . *</code>（每行都会附上文件名）或者 <code>head -100 *</code>（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 <code>/sys</code>、<code>/proc</code>、<code>/etc</code>）时特别好用。</p>
</li>
<li><p>计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123; x += $3 &#125; END &#123; print x &#125;'</span> myfile</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你想在文件树上查看大小/日期，这可能看起来像递归版的 <code>ls -l</code> 但比 <code>ls -lR</code> 更易于理解：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -ls</span><br></pre></td></tr></table></figure>
</li>
<li><p>假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 <code>acct_id</code> 参数在URI中。如果你想计算出每个 <code>acct_id</code> 值有多少次请求，使用如下代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | egrep -o <span class="string">'acct_id=[0-9]+'</span> | cut <span class="operator">-d</span>= <span class="operator">-f</span>2 | sort | uniq -c | sort -rn</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">taocl</span></span>() &#123;</span><br><span class="line">  curl <span class="operator">-s</span> https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |</span><br><span class="line">    pandoc <span class="operator">-f</span> markdown -t html |</span><br><span class="line">    xmlstarlet fo --html --dropdtd |</span><br><span class="line">    xmlstarlet sel -t -v <span class="string">"(html/body/ul/li[count(p)&gt;0])[<span class="variable">$RANDOM</span> mod last()+1]"</span> |</span><br><span class="line">    xmlstarlet unesc | fmt -<span class="number">80</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="u51B7_u95E8_u4F46_u6709_u7528"><a href="#u51B7_u95E8_u4F46_u6709_u7528" class="headerlink" title="冷门但有用"></a>冷门但有用</h2><ul>
<li><p><code>expr</code>：计算表达式或正则匹配</p>
</li>
<li><p><code>m4</code>：简单地宏处理器</p>
</li>
<li><p><code>yes</code>：多次打印字符串</p>
</li>
<li><p><code>cal</code>：漂亮的日历</p>
</li>
<li><p><code>env</code>：执行一个命令（脚本文件中很有用）</p>
</li>
<li><p><code>printenv</code>：打印环境变量（调试时或在使用脚本文件时很有用）</p>
</li>
<li><p><code>look</code>：查找以特定字符串开头的单词</p>
</li>
<li><p><code>cut</code>、<code>paste</code> 和 <code>join</code>：数据修改</p>
</li>
<li><p><code>fmt</code>：格式化文本段落</p>
</li>
<li><p><code>pr</code>：将文本格式化成页/列形式</p>
</li>
<li><p><code>fold</code>：包裹文本中的几行</p>
</li>
<li><p><code>column</code>：将文本格式化成多列或表格</p>
</li>
<li><p><code>expand</code> 和 <code>unexpand</code>：制表符与空格之间转换</p>
</li>
<li><p><code>nl</code>：添加行号</p>
</li>
<li><p><code>seq</code>：打印数字</p>
</li>
<li><p><code>bc</code>：计算器</p>
</li>
<li><p><code>factor</code>：分解因数</p>
</li>
<li><p><a href="https://gnupg.org/" target="_blank" rel="external"><code>gpg</code></a>：加密并签名文件</p>
</li>
<li><p><code>toe</code>：terminfo entries 列表</p>
</li>
<li><p><code>nc</code>：网络调试及数据传输</p>
</li>
<li><p><code>socat</code>：套接字代理，与 <code>netcat</code> 类似</p>
</li>
<li><p><a href="https://github.com/mattthias/slurm" target="_blank" rel="external"><code>slurm</code></a>：网络可视化</p>
</li>
<li><p><code>dd</code>：文件或设备间传输数据</p>
</li>
<li><p><code>file</code>：确定文件类型</p>
</li>
<li><p><code>tree</code>：以树的形式显示路径和文件，类似于递归的 <code>ls</code></p>
</li>
<li><p><code>stat</code>：文件信息</p>
</li>
<li><p><code>time</code>：执行命令，并计算执行时间</p>
</li>
<li><p><code>lockfile</code>：使文件只能通过 <code>rm -f</code> 移除</p>
</li>
<li><p><code>logrotate</code>: 切换、压缩以及发送日志文件</p>
</li>
<li><p><code>watch</code>：重复运行同一个命令，展示结果并高亮有更改的部分</p>
</li>
<li><p><code>tac</code>：反向输出文件</p>
</li>
<li><p><code>shuf</code>：文件中随机选取几行</p>
</li>
<li><p><code>comm</code>：一行一行的比较排序过的文件</p>
</li>
<li><p><code>pv</code>：监视通过管道的数据</p>
</li>
<li><p><code>hd</code>，<code>hexdump</code>，<code>xxd</code>，<code>biew</code> 和 <code>bvi</code>：保存或编辑二进制文件</p>
</li>
<li><p><code>strings</code>：从二进制文件中抽取文本</p>
</li>
<li><p><code>tr</code>：转换字母</p>
</li>
<li><p><code>iconv</code> 或 <code>uconv</code>：简易的文件编码</p>
</li>
<li><p><code>split</code> 和 <code>csplit</code>：分割文件</p>
</li>
<li><p><code>sponge</code>：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 <code>grep -v something some-file | sponge some-file</code></p>
</li>
<li><p><code>units</code>：将一种计量单位转换为另一种等效的计量单位（参阅 <code>/usr/share/units/definitions.units</code>）</p>
</li>
<li><p><code>apg</code>：随机生成密码</p>
</li>
<li><p><code>7z</code>：高比例的文件压缩</p>
</li>
<li><p><code>ldd</code>：动态库信息</p>
</li>
<li><p><code>nm</code>：提取 obj 文件中的符号</p>
</li>
<li><p><code>ab</code>：性能分析 web 服务器</p>
</li>
<li><p><code>strace</code>：系统调用调试</p>
</li>
<li><p><code>mtr</code>：更好的网络调试跟踪工具</p>
</li>
<li><p><code>cssh</code>：可视化的并发 shell</p>
</li>
<li><p><code>rsync</code>：通过 ssh 或本地文件系统同步文件和文件夹</p>
</li>
<li><p><code>wireshark</code> 和 <code>tshark</code>：抓包和网络调试工具</p>
</li>
<li><p><code>ngrep</code>：网络层的 grep</p>
</li>
<li><p><code>host</code> 和 <code>dig</code>：DNS 查找</p>
</li>
<li><p><code>lsof</code>：列出当前系统打开文件的工具以及查看端口信息</p>
</li>
<li><p><code>dstat</code>：系统状态查看</p>
</li>
<li><p><a href="https://github.com/nicolargo/glances" target="_blank" rel="external"><code>glances</code></a>：高层次的多子系统总览</p>
</li>
<li><p><code>iostat</code>：硬盘使用状态</p>
</li>
<li><p><code>mpstat</code>: CPU 使用状态</p>
</li>
<li><p><code>vmstat</code>: 内存使用状态</p>
</li>
<li><p><code>htop</code>：top 的加强版</p>
</li>
<li><p><code>last</code>：登入记录</p>
</li>
<li><p><code>w</code>：查看处于登录状态的用户</p>
</li>
<li><p><code>id</code>：用户/组 ID 信息</p>
</li>
<li><p><code>sar</code>：系统历史数据</p>
</li>
<li><p><code>iftop</code> 或 <code>nethogs</code>：套接字及进程的网络利用</p>
</li>
<li><p><code>ss</code>：套接字数据</p>
</li>
<li><p><code>dmesg</code>：引导及系统错误信息</p>
</li>
<li><p><code>sysctl</code>: 在内核运行时动态地查看和修改内核的运行参数</p>
</li>
<li><p><code>hdparm</code>：SATA/ATA 磁盘更改及性能分析</p>
</li>
<li><p><code>lsb_release</code>：Linux 发行版信息</p>
</li>
<li><p><code>lsblk</code>：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息</p>
</li>
<li><p><code>lshw</code>，<code>lscpu</code>，<code>lspci</code>，<code>lsusb</code> 和 <code>dmidecode</code>：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等</p>
</li>
<li><p><code>lsmod</code> 和 <code>modinfo</code>：列出内核模块，并显示其细节</p>
</li>
<li><p><code>fortune</code>，<code>ddate</code> 和 <code>sl</code>：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用”</p>
</li>
</ul>
<h2 id="u4EC5_u9650_MacOS_X__u7CFB_u7EDF"><a href="#u4EC5_u9650_MacOS_X__u7CFB_u7EDF" class="headerlink" title="仅限 MacOS X 系统"></a>仅限 MacOS X 系统</h2><p>以下是<em>仅限于</em> MacOS 系统的技巧</p>
<ul>
<li><p>用 <code>brew</code> （Homebrew）或者 <code>port</code> （MacPorts）进行包管理。这些可以用来在 Mac 系统上安装以上的大多数命令。</p>
</li>
<li><p>用 <code>pbcopy</code> 复制任何命令的输出到桌面应用，用 <code>pbpaste</code> 粘贴输入。</p>
</li>
<li><p>若要在 Mac OS 终端中将 Option 键视为 alt 键（例如在上面介绍的 <strong>alt-b</strong>, <strong>alt-f</strong> 等命令中用到），打开 偏好设置 -&gt; 描述文件 -&gt; 键盘 并勾选“使用 Option 键作为 Meta 键”。</p>
</li>
<li><p>用 <code>open</code> 或者 <code>open -a /Applications/Whatever.app</code> 使用桌面应用打开文件。</p>
</li>
<li><p>Spotlight： 用 <code>mdfind</code> 搜索文件，用 <code>mdls</code> 列出元数据（例如照片的 EXIF 信息）。</p>
</li>
<li><p>注意 MacOS 系统是基于 BSD UNIX 的，许多命令（例如 <code>ps</code>，<code>ls</code>，<code>tail</code>，<code>awk</code>，<code>sed</code>）都和 Linux 中有些微的不同，这些极大的被 System V-style Unix 和 GNU 工具影响。你可以通过标题为 “BSD General Commands Manual” 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 <code>gawk</code> 和 <code>gsed</code> 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 <code>perl</code> ）或者经过仔细的测试。</p>
</li>
<li><p>用 <code>sw_vers</code> 获取 MacOS 的版本信息。</p>
</li>
</ul>
<h2 id="u66F4_u591A_u8D44_u6E90"><a href="#u66F4_u591A_u8D44_u6E90" class="headerlink" title="更多资源"></a>更多资源</h2><ul>
<li><a href="https://github.com/alebcay/awesome-shell" target="_blank" rel="external">awesome-shell</a>：一份精心组织的命令行工具及资源的列表。</li>
<li><a href="https://github.com/herrbischoff/awesome-osx-command-line" target="_blank" rel="external">awesome-osx-command-line</a>：一份针对 Mac OS 命令行的更深入的指南。</li>
<li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/" target="_blank" rel="external">Strict mode</a>：为了编写更好的脚本文件。</li>
<li><a href="https://github.com/koalaman/shellcheck" target="_blank" rel="external">shellcheck</a>：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。</li>
<li><a href="http://www.dwheeler.com/essays/filenames-in-shell.html" target="_blank" rel="external">Filenames and Pathnames in Shell</a>：有关如何在 shell 脚本里正确处理文件名的细枝末节。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Shell 可以说是程序员最好的帮手了，这里简单记录一些常用的技巧，包括 shell 脚本与常用的命令。</p>]]>
    
    </summary>
    
      <category term="命令行" scheme="http://wdxtub.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="技巧" scheme="http://wdxtub.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SVN 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/svn-guide/"/>
    <id>http://wdxtub.com/2016/03/24/svn-guide/</id>
    <published>2016-03-24T20:34:47.000Z</published>
    <updated>2016-03-24T20:35:18.000Z</updated>
    <content type="html"><![CDATA[<p>国内不少云平台都只支持 SVN，所以还是需要了解基本的操作的。和 Git 的思路不大一样，SVN 等于是总-分结构，虽然可能不如 git 灵活，但是还是比较方便的。</p>
<a id="more"></a>
<hr>
<h2 id="u64CD_u4F5C_u6D41_u7A0B"><a href="#u64CD_u4F5C_u6D41_u7A0B" class="headerlink" title="操作流程"></a>操作流程</h2><p>常见的操作如下：</p>
<ul>
<li>checkout（检出）项目</li>
<li>增加文件或目录 — add(增加)，commit(提交)</li>
<li>修改文件或目录 — commit(提交)</li>
<li>删除文件或目录 — commit(提交)</li>
<li>更新文件或目录 — update(更新)</li>
</ul>
<p>其中，checkout只进行一次，以后使用update更新即可。update、commit、add操作根据需要会经常使用。</p>
<p>简单来说可以这样理解：</p>
<ul>
<li>项目中增加了文件或目录，需要先通知服务器要增加，所以首先要 add</li>
<li>然后如果要让服务器知道这些变动，就 commit，具体参加下面的命令</li>
<li>如果要从服务器获取最新的代码，就 update</li>
</ul>
<p>首先checkout出$appname的svn仓库。</p>
<pre><code>$ svn checkout https://svn.sinacloud.com/$appname
</code></pre><p>进入代码目录，创建一个新的子目录 <code>1</code> 作为版本1的代码目录。</p>
<pre><code>$ mkdir 1
</code></pre><p>进入版本1的代码目录，编辑代码并版本1的代码部署到线上。</p>
<pre><code>$ svn add .
$ svn commit -m &quot;make it better&quot;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>国内不少云平台都只支持 SVN，所以还是需要了解基本的操作的。和 Git 的思路不大一样，SVN 等于是总-分结构，虽然可能不如 git 灵活，但是还是比较方便的。</p>]]>
    
    </summary>
    
      <category term="版本控制" scheme="http://wdxtub.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim 基本操作]]></title>
    <link href="http://wdxtub.com/2016/03/24/vim-basic-op/"/>
    <id>http://wdxtub.com/2016/03/24/vim-basic-op/</id>
    <published>2016-03-24T20:23:06.000Z</published>
    <updated>2016-03-24T20:31:14.000Z</updated>
    <content type="html"><![CDATA[<p>虽然我还是喜欢图形化界面编辑器，但是有的时候登录到远程机器，不得不使用 vim 来编辑文件，这里记录下基本的操作。</p>
<a id="more"></a>
<hr>
<ul>
<li><code>i</code> 进入 Insert 模式</li>
<li><code>x</code> 删除当前光标所在的字符</li>
<li><code>:w</code> 存盘(后面可以跟文件名) </li>
<li><code>:q</code> 退出</li>
<li><code>:wq</code> 存盘并退出</li>
<li><code>dd</code> 删除当前行，并存到剪贴板里</li>
<li><code>p</code> 粘贴剪贴板</li>
<li><code>:help &lt;command&gt;</code> 要 :q 退出帮助</li>
</ul>
<p>如何浏览帮助呢？请牢记如下秘籍：</p>
<ul>
<li>移动: 使用光标键，或者用 h 向左，j 向下，k 向上，l 向右。</li>
<li>退出: 使用 :q<enter>。</enter></li>
<li>跳转到一个主题: 将光标置于标签 (例如 usr_01.txt) 上然后输入 CTRL-]。</li>
<li>跳回: 键入 CTRL-T。</li>
<li>翻页：键入 CTRL-F/B</li>
</ul>
<h2 id="u63D2_u5165_u6A21_u5F0F"><a href="#u63D2_u5165_u6A21_u5F0F" class="headerlink" title="插入模式"></a>插入模式</h2><ul>
<li><code>a</code> 在光标后插入</li>
<li><code>o</code> 在当前行后插入一个新行</li>
<li><code>O</code> 在当前行前插入一个新行</li>
<li><code>cw</code> 替换从光标所在位置后到一个单词结尾的字符</li>
</ul>
<h2 id="u79FB_u52A8_u5149_u6807"><a href="#u79FB_u52A8_u5149_u6807" class="headerlink" title="移动光标"></a>移动光标</h2><ul>
<li><code>0</code> 数字零，到行头</li>
<li><code>^</code> 到本行第一个不是blank字符的位置</li>
<li><code>$</code> 到本行行尾</li>
<li><code>g_</code> 到本行最后一个不是blank字符的位置。</li>
<li><code>/pattern</code> 搜索 pattern 的字符串(按n到下一个)</li>
<li><code>w b</code> 词移动</li>
</ul>
<h2 id="u62F7_u8D1D/_u7C98_u8D34"><a href="#u62F7_u8D1D/_u7C98_u8D34" class="headerlink" title="拷贝/粘贴"></a>拷贝/粘贴</h2><ul>
<li><code>p</code> 在当前位置之后粘贴</li>
<li><code>P</code> 在当前位置之前粘贴</li>
<li><code>yy</code> 拷贝当前行，相当于 ddP</li>
</ul>
<h2 id="u64A4_u9500/_u91CD_u505A"><a href="#u64A4_u9500/_u91CD_u505A" class="headerlink" title="撤销/重做"></a>撤销/重做</h2><ul>
<li><code>u</code> undo</li>
<li><code>&lt;C-r&gt;</code> redo</li>
</ul>
<h2 id="u6253_u5F00/_u4FDD_u5B58/_u9000_u51FA/_u6539_u53D8_u6587_u4EF6_28Buffer_29"><a href="#u6253_u5F00/_u4FDD_u5B58/_u9000_u51FA/_u6539_u53D8_u6587_u4EF6_28Buffer_29" class="headerlink" title="打开/保存/退出/改变文件(Buffer)"></a>打开/保存/退出/改变文件(Buffer)</h2><ul>
<li><code>:e &lt;path/to/file&gt;</code> 打开一个文件</li>
<li><code>:w</code> 存盘</li>
<li><code>:saveas &lt;path/to/file&gt;</code> 另存为 <code>&lt;path/to/file&gt;</code></li>
<li><code>:x</code>, <code>ZZ</code> 或 <code>:wq</code> 保存并退出</li>
<li><code>:q!</code> 退出不保存 </li>
<li><code>:qa!</code> 强行退出所有文件。</li>
<li><code>:bn</code> 和 <code>:bp</code> 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。</li>
</ul>
<h2 id="u6280_u5DE7"><a href="#u6280_u5DE7" class="headerlink" title="技巧"></a>技巧</h2><ol>
<li>打开 Vim之后，可以用 <code>:split filename</code>或 <code>:vsplit filename</code> 或 <code>new filename</code> 横向或纵向切割窗口，使用 <code>ctrl + w</code> 可以在个窗口之间跳转，使用 <code>ctrl + 方向键</code> 可以按照方向切换窗口。</li>
<li>用 Vim 打开一个文件，如果我们想实现所有文本行翻转，那么可以执行如下命令：<code>:g/^/m 0</code></li>
<li>在 Vim 中统计文本行数和当前光标的位置，可以使用 <code>ctrl + g</code>，统计字节数，可以使用 <code>g + ctrl + g</code></li>
<li>对文本进行简单排序：用 <code>shift v</code> 选中多行文本，输入 <code>:!sort</code>，看看效果如何</li>
<li>如果你想把当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么依次执行如下命令： 在当前目录下执行：</li>
</ol>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim</span><br><span class="line">:n <span class="keyword">*</span><span class="keyword">*</span>/<span class="keyword">*</span>.java</span><br><span class="line">:argdo %s/apache/eclipse/ge |<span class="string"> update</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然我还是喜欢图形化界面编辑器，但是有的时候登录到远程机器，不得不使用 vim 来编辑文件，这里记录下基本的操作。</p>]]>
    
    </summary>
    
      <category term="编辑器" scheme="http://wdxtub.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gradle 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/gradle-guide/"/>
    <id>http://wdxtub.com/2016/03/24/gradle-guide/</id>
    <published>2016-03-24T20:14:58.000Z</published>
    <updated>2016-03-24T20:18:40.000Z</updated>
    <content type="html"><![CDATA[<p>Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。它提供灵活的通用构建工具，就像ant。同时完美兼容Maven或Ivy仓库</p>
<a id="more"></a>
<hr>
<p>Gradle的特点：</p>
<ul>
<li>一个像Ant一样非常灵活的通用构建工具</li>
<li>一种可切换的，像Maven一样基于约定的构建框架，约定优于配置</li>
<li>强大的对于多工程构建的支持</li>
<li>完全支持现有的Maven和lvy仓库</li>
<li>支持传递性依赖管理，而不需要远程仓库或者是pom.xml和ivy.xml文件</li>
<li>非常适合构建Ant tasks和build</li>
<li>支持Groovy构建脚本</li>
<li>非常丰富的域模型来描述你的构建</li>
</ul>
<p>2009年7月20日发行第一个版本0.7，到现在已经发行了20个大版本，目前最新版本是2.3。从2.0版本开始，Gradle提供了C和C++的支持，使得Gradle的构建、测试和提交工作不仅限于基于JVM的系统。</p>
<p>从2012年6月发布1.0以来，Gradle一直以八周一个新版本的速率稳步升级，从1.0到2.0，Gradle也逐渐成熟。现在越来越多的Java开发者开始使用Gradle进行项目的自动化构建 </p>
<h2 id="u5B89_u88C5Gradle"><a href="#u5B89_u88C5Gradle" class="headerlink" title="安装Gradle"></a>安装Gradle</h2><p>安装一个 Java JDK 或者 JRE. 而且 Java 版本必须至少是 6 以上<br>从 Gradle网站<a href="http://www.gradle.org/downloads下载任意一个已经发布的版本，并解压到任意目录" target="_blank" rel="external">http://www.gradle.org/downloads下载任意一个已经发布的版本，并解压到任意目录</a></p>
<p>添加一个 GRADLE_HOME 环境变量来指明 Gradle 的安装路径<br>添加 GRADLE_HOME/bin 到您的 PATH 环境变量中</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux:</span><br><span class="line">export GRADLE_HOME=&#123;your gradle path&#125;</span><br><span class="line">export PATH=<span class="variable">$PATH</span>:GRADLE_HOME/bin</span><br></pre></td></tr></table></figure>
<h2 id="Gradle_u7684_u57FA_u672C_u7EC4_u6210"><a href="#Gradle_u7684_u57FA_u672C_u7EC4_u6210" class="headerlink" title="Gradle的基本组成"></a>Gradle的基本组成</h2><p>项目(Project) 和 任务(tasks)，Gradle 里的任何东西都是基于这两个基础概念。</p>
<ul>
<li>项目是指我们的构建产物（比如Jar包）或实施产物（将应用程序部署到生产环境）。</li>
<li>任务是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）。</li>
<li>每一个构建都是由一个或多个 projects 构成的，每一个 project 是由一个或多个 tasks 构成的，一个 task是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）</li>
</ul>
<p><img src="/images/14588506801339.jpg" alt=""></p>
<p>一个工程的Build，是由多个Project组成，而一个Project又是由task组成的</p>
<h2 id="Gradle_u6784_u5EFA_u7CFB_u7EDF_u7684_u7EC4_u6210"><a href="#Gradle_u6784_u5EFA_u7CFB_u7EDF_u7684_u7EC4_u6210" class="headerlink" title="Gradle构建系统的组成"></a>Gradle构建系统的组成</h2><p>任何一个构建系统都是由多个构建文件组成，如Ant是由build.xml组成，Maven是由pom.xml组成，Make是由makefile组成。这些构建脚本定义了一系列的规则来指定项目编译流程。</p>
<p>Gradle的构建系统是由以下几个文件组成</p>
<ul>
<li>build.gradle 我们称这个文件为一个构建脚本，这个脚本定义了一个模块和编译用的tasks，它一般是放在项目的模块中，也可以放在项目的根目录用来作为编译结构全局设置，它是必须的</li>
<li>settings.gradle 它描述了哪一个模块需要参与构建。每一个多模块的构建都必须在项目结构的根目录中加入这个设置文件，它也是必须的</li>
<li>gradle.properties 用来配置构建属性，这个不是必须的</li>
</ul>
<p>settings.gradle和gradle.properties的用法都十分简单，这里就不再多加说明，后面会给出示例，看示例就能明白其用法，现在主要对build.gradle的进行说明。</p>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>Gradle是基于Groovy语言的构建系统（这里并不会详细解释Groovy语法的使用，有需要请参考Groovy的官方文档 — <a href="http://groovy-lang.org/single-page-documentation.html" target="_blank" rel="external">Groovy语法</a>），所以在构建脚本中可以使用Groovy语言来执行一些任务。</p>
<p>下面编写一个简单的build.gradle文件，定义一个task来打印hello world，如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> hello &#123; <span class="comment">//先定义一个hello的task</span></span><br><span class="line">    <span class="keyword">doLast</span> &#123; <span class="comment">//实现doLast方法</span></span><br><span class="line">        <span class="keyword">println</span> <span class="string">'Hello world!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在终端中运行gradle hello命令来执行这个task,就会看到以下输入内容：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">gradle</span> <span class="tag">hello</span></span><br><span class="line"><span class="pseudo">:hello</span></span><br><span class="line"><span class="tag">Hello</span> <span class="tag">world</span>!</span><br></pre></td></tr></table></figure>
<p>对于hello这个task，还可以使用更简单的定义方式，如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> hello &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello world!'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;&lt;</code> 就等价于 doLast，doLast 是gradle提供访问task任务的一个API，类似的还有 doFirst，当一个task被执行的时候，可以通过 doFirst 和 doLast 向task中动态添加操作。doFirst 和 doLast 会在task本身被执行之后才会被执行。例如：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> hello &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Earth'</span></span><br><span class="line">&#125;</span><br><span class="line">hello.<span class="keyword">doFirst</span> &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Venus'</span></span><br><span class="line">&#125;</span><br><span class="line">hello.<span class="keyword">doFirst</span> &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Mercury'</span></span><br><span class="line">&#125;</span><br><span class="line">hello.<span class="keyword">doLast</span> &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Mars'</span></span><br><span class="line">&#125;</span><br><span class="line">hello &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello Jupiter'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入如下所示：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">Hello</span> Earth</span><br><span class="line">:hello</span><br><span class="line"><span class="label">Hello</span> Mercury</span><br><span class="line"><span class="label">Hello</span> Venus</span><br><span class="line"><span class="label">Hello</span> <span class="keyword">Mars</span><br><span class="line"></span><span class="label">Hello</span> Jupiter</span><br></pre></td></tr></table></figure>
<h2 id="Task_u4F9D_u8D56"><a href="#Task_u4F9D_u8D56" class="headerlink" title="Task依赖"></a>Task依赖</h2><p>上面示例展示了如何编写一个hello world的task，在Gradle中各个task并不是孤立的，它们可以是相互依赖的。要让一个task依赖另外一个task，只需要在task定义时加入 dependsOn: 说明即可，被依赖的task会优先依赖者被执行，例如：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> hello &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">'Hello world!'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">task</span> intro(dependsOn: hello) &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">"I'm Gradle"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行gradle intro命令后可以看到以下输出：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="blockquote">&gt; gradle intro</span></span><br><span class="line">Hello world!</span><br><span class="line">I'm Gradle</span><br></pre></td></tr></table></figure>
<h2 id="Gradle_u63D2_u4EF6"><a href="#Gradle_u63D2_u4EF6" class="headerlink" title="Gradle插件"></a>Gradle插件</h2><p>Gradle的设计理念是，所有有用的特性都由Gradle插件提供，例如编写一个Java项目时，需要使用到 Java 插件， 它会将许多任务自动的加入到你项目里。Gradle本身提供了一系列的标准插件，无需多余配置只需要在你的build.gradle文件中加入 <code>apply plugin: &#39;java&#39;</code></p>
<p>这样就可以引入许多task，只需要使用相应的task命令就可以进行项目构建。例如下列一些task:</p>
<ul>
<li>gradle build：编译整个项目，它会执行代码编译、代码检测和单元测试等</li>
<li>gradle assemble：编译并打包你的代码, 但是并不运行代码检测和单元测试</li>
<li>gradle clean：删除 build 生成的目录和所有生成的文件</li>
<li>gradle check：编译并测试你的代码。其它的插件会加入更多的检查步骤，如使用 checkstyle、pmd、findbugs</li>
</ul>
<p>Gradle各个task的关系图：</p>
<p><img src="/images/14588507104558.jpg" alt=""></p>
<p>从上图可以看出，我们通常在执行一个build命令时其实是将一些零散的命令批量执行了，我们也可以根据自己的需求执行其中某一个命令。</p>
<h2 id="u5916_u90E8_u4F9D_u8D56"><a href="#u5916_u90E8_u4F9D_u8D56" class="headerlink" title="外部依赖"></a>外部依赖</h2><p>通常, 一个 Java 项目将有许多外部的依赖, 既指向外部的 JAR 文件. 为了在项目里引用这些 JAR 文件, 你需要告诉 Gradle 去哪里找它们. 在 Gradle 中, JAR 文件位于一个仓库中，这里的仓库类似于 maven 的仓库。</p>
<p>首先，指定maven的仓库地址：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mavenCentral() 是Gradle内置的一个maven仓库地址，加入maven仓库后，就可以直接加入maven仓库中的外部依赖，如果这个外部依赖不存在，gradle会联网去maven仓库中自动下载它，并将它缓存到本地，下次再使用时会优先从本地缓存中查找该依赖。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">group</span>: <span class="string">'commons-collections'</span>, name: <span class="string">'commons-collections'</span>, version: <span class="string">'3.2'</span></span><br><span class="line">    <span class="comment">// 简化写法</span></span><br><span class="line">    <span class="comment">// compile 'commons-collections:commons-collections:3.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用一个外部依赖需要指定使用的group, name 和 version 属性，三者缺一不可。那从哪里得知JAR包的这三个属性呢？我们可以从mvnrepository中搜索到。</p>
<h2 id="u672C_u5730_u4F9D_u8D56"><a href="#u672C_u5730_u4F9D_u8D56" class="headerlink" title="本地依赖"></a>本地依赖</h2><p>Gradle也可以从本地目录中引入JAR包依赖，可以单一引入指定的某一JAR包，也可以引入某目录下所有的JAR包</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> files(<span class="string">'dir/file.jar'</span>)</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: <span class="string">'*.jar'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u9879_u76EE_u4F9D_u8D56"><a href="#u9879_u76EE_u4F9D_u8D56" class="headerlink" title="项目依赖"></a>项目依赖</h2><p>往往一个完整的项目由多个子项目构成。在Gradle中，使用文件settings.gradle定义当前项目的子项目。默认情况下，每个子项目的名称对应着当前操作系统目录下的一个子目录。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="symbol">'sub</span>-project1', <span class="symbol">'sub</span>-project2', <span class="symbol">'sub</span>-project3'</span><br></pre></td></tr></table></figure>
<p>如sub-project1依赖sub-project2，则在sub-project1的build.gradle中加入以下配置即可：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':sub-project2'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u4F9D_u8D56_u5173_u7CFB_u7BA1_u7406"><a href="#u4F9D_u8D56_u5173_u7CFB_u7BA1_u7406" class="headerlink" title="依赖关系管理"></a>依赖关系管理</h2><p>从宏观上说，依赖关系管理分为两个方面。首先，gradle需要知道你要构建或者运行的项目，以便找到它们。我们将这些导入的文件视为项目的依赖。第二，gradle需要构建或者打包你的项目产品。我们将这些导出的文件视为项目的发布。</p>
<p>例如在编译源码时项目需要Hibernate的某些jar包被加入到工程中，而在进行单元测试时还另需要Junit的某些jar被加入。这些被引入的jar包就是项目的依赖。Gradle允许对依赖进行相应的配置，通过不同的配置可以形成不同的依赖效果。例如：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'org.hibernate'</span>, <span class="string">name:</span> <span class="string">'hibernate-core'</span>, <span class="string">version:</span> <span class="string">'3.6.7.Final'</span></span><br><span class="line">    testCompile <span class="string">group:</span> <span class="string">'junit'</span>, <span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目编译时期，junit的jar包不会被引入，只有在单元测试时才会被引入。这样，就可以在不同的场景下加入相应的依赖关系，非常的灵活</p>
<p>Java 插件中定义了许多标准的配置，例如如下：</p>
<ul>
<li>compile: 用来编译项目源代码的依赖</li>
<li>runtime: 在运行时被生成的类使用的依赖。 默认的, 也包含了compile时的依赖。</li>
<li>testCompile: 编译测试代码的依赖。 默认的, 包含runtime时的依赖和compile时的依赖。</li>
<li>testRuntime: 运行测试所需要的依赖。 默认的, 包含上面三个依赖。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。它提供灵活的通用构建工具，就像ant。同时完美兼容Maven或Ivy仓库</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://wdxtub.com/tags/Android/"/>
    
      <category term="包管理" scheme="http://wdxtub.com/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sublime 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/sublime-guide/"/>
    <id>http://wdxtub.com/2016/03/24/sublime-guide/</id>
    <published>2016-03-24T20:08:06.000Z</published>
    <updated>2016-03-24T20:10:02.000Z</updated>
    <content type="html"><![CDATA[<p>Sublime 基本算是我的主力代码编辑器，这里简要介绍一些插件和技巧。</p>
<a id="more"></a>
<hr>
<h2 id="u63D2_u4EF6"><a href="#u63D2_u4EF6" class="headerlink" title="插件"></a>插件</h2><ol>
<li><a href="https://github.com/emmetio/emmet" target="_blank" rel="external">Emmet Git</a>，<a href="http://docs.emmet.io/" target="_blank" rel="external">Document</a>原名为：<code>Zencoding, 快速生成html,css</code>，默认扩展快捷为<code>tab</code>，如果<code>tab</code>按钮损坏，<code>ctrl+e</code>替换。 生成规则在：<code>Preferences -&gt; Browser packages -&gt; Emment -&gt; emment -&gt; snippets.json</code>中修改。<a href="http://www.iteye.com/news/27580" target="_blank" rel="external">@ Emmet 中文版文档</a></li>
<li><a href="https://github.com/titoBouzout/SideBarEnhancements" target="_blank" rel="external">Side Bar</a><code>增强的侧边栏</code></li>
<li><a href="https://github.com/spadgos/sublime-jsdocs" target="_blank" rel="external">Docblockr</a><code>增强js注释</code></li>
<li><a href="https://github.com/wbond/sublime_alignment" target="_blank" rel="external">Alignment</a><code>等号对齐</code>。在<code>Preferences -&gt; package settings -&gt; Alignment -&gt; Settings User</code>添加冒号对齐。<code>{ &quot;align_indent&quot;: false, &quot;alignment_chars&quot;: [&quot;=&quot;, &quot;:&quot;], &quot;alignment_space_chars&quot;: [&quot;=&quot;, &quot;:&quot;] }</code></li>
<li><a href="https://github.com/BoundInCode/AutoFileName" target="_blank" rel="external">AutoFileName</a>: <code>文件路径自动提示</code></li>
<li><a href="https://github.com/akira-cn/sublime-gbk" target="_blank" rel="external">gbk支持 GBK Encoding Support</a></li>
<li><a href="http://www.welefen.com/keymapmanager-add-check-plugins-keymap-conflict-feature.html" target="_blank" rel="external">检测快捷键冲突</a></li>
<li><a href="https://github.com/revolunet/sublimetext-markdown-preview" target="_blank" rel="external">markdown</a> <a href="http://www.tcreator.info/social/experience/markdown-to-pdf.html" target="_blank" rel="external">markdown 转为 pdf</a></li>
<li><a href="https://github.com/SublimeText/LineEndings" target="_blank" rel="external">LineEndings 设置换行符</a></li>
<li><a href="https://sublime.wbond.net/" target="_blank" rel="external">SublimeText插件列表</a></li>
<li><a href="https://github.com/rehorn/sublime-htmlbeautify" target="_blank" rel="external">html美化插件</a></li>
<li><a href="http://www.fantxi.com/blog/archives/sublime-template-engine-sublimetmpl/" target="_blank" rel="external">Sublime Text 新建文件的模版插件: SublimeTmpl</a></li>
<li><a href="http://www.cnblogs.com/liu-l/p/3902100.html" target="_blank" rel="external">前端自动化神器LiveReload配合浏览器和less/sass使用方法</a></li>
<li><a href="http://www.cnblogs.com/yili16438/p/3721896.html" target="_blank" rel="external">使用 Sublime Text 2 开发 Unity3D 项目</a></li>
<li><a href="http://www.cnblogs.com/lhb25/p/10-essential-sublime-text-plugins.html" target="_blank" rel="external">全栈开发必备的10款 Sublime Text 插件</a></li>
</ol>
<h2 id="u8BBE_u7F6E"><a href="#u8BBE_u7F6E" class="headerlink" title="设置"></a>设置</h2><ol>
<li>Font 推荐使用 <a href="http://code.google.com/p/uigroupcode/downloads/detail?name=YaHei.Consolas.1.12.zip&amp;can=2&amp;q=#makechanges" target="_blank" rel="external">YaHei.Consolas.1.12.ttf</a>，即为上图中所示字体。</li>
<li>Theme<ul>
<li>code style: 推荐使用这款<a href="http://code.google.com/p/uigroupcode/downloads/detail?name=Monokai.rar&amp;can=2&amp;q=#makechanges" target="_blank" rel="external">marktheme</a></li>
<li><a href="https://gist.github.com/1854721" target="_blank" rel="external">更换sidebar皮肤</a></li>
<li><a href="http://jamiewilson.io/predawn/" target="_blank" rel="external">分享一个sublime 主题 </a></li>
<li><a href="http://colorsublime.com/" target="_blank" rel="external">颜色配色</a></li>
</ul>
</li>
<li>Preferences -&gt; Settings - User</li>
<li><a href="http://baelabs.duapp.com/Sublime/indentation.html" target="_blank" rel="external">定制缩进</a></li>
<li><a href="http://baelabs.duapp.com/Sublime/spell_checking.html" target="_blank" rel="external">拼写检查</a></li>
<li><a href="http://baelabs.duapp.com/Sublime/distraction_free.html" target="_blank" rel="external">全屏模式，自由模式的定制</a></li>
<li><a href="http://www.cnblogs.com/jikey/archive/2013/03/12/2955230.html" target="_blank" rel="external">浏览器中预览</a></li>
<li><a href="http://baelabs.duapp.com/Sublime/settings.html" target="_blank" rel="external">其它配置</a></li>
</ol>
<h2 id="u7279_u6B8A_u64CD_u4F5C"><a href="#u7279_u6B8A_u64CD_u4F5C" class="headerlink" title="特殊操作"></a>特殊操作</h2><ol>
<li>按住 <code>ctrl</code> 键，鼠标单击就是多重选择。</li>
<li><a href="http://baelabs.duapp.com/Sublime/multiple_selection_with_the_keyboard.html" target="_blank" rel="external">键盘多重选择</a></li>
<li>根据选择文本自动添加 ‘, “”,(),[] 匹配。</li>
<li>搜索按钮的功能说明 (<a href="http://hi.baidu.com/chaoxinggsc/item/904a471aa937bc35f6625c42" target="_blank" rel="external">冷风贡献</a>)</li>
</ol>
<h2 id="u5FEB_u6377_u952E"><a href="#u5FEB_u6377_u952E" class="headerlink" title="快捷键"></a>快捷键</h2><ol>
<li>Ctrl+L             选择整行（按住-继续选择下行）</li>
<li>Ctrl+Shift+K(shhift+del)     删除整行，  ctrl + KK 从光标处删之行尾，Ctrl+K Backspace 从光标处删除至行首</li>
<li>Ctrl+Shift+D       复制光标所在整行，插入在该行之前</li>
<li>Ctrl+D             选词 （按住-继续选择下个相同的字符串，再按，可跳到相应的方法定义处</li>
<li>Ctrl+Shift+M       选择括号内的内容（按住-继续选择父括号）</li>
<li>Ctrl+/             注释整行（如已选择内容，同“Ctrl+Shift+/”效果）</li>
<li>Ctrl + alt + /     取消注释</li>
<li>Ctrl+Shift+UP      与上行互换  ctrl + shift + up: 列模式编辑</li>
<li>Ctrl + R           跳转当前页的目标方法</li>
<li>Ctrl+K + U        大写</li>
<li>Ctrl+K + L        小写</li>
<li>鼠标中间           列模式编辑</li>
<li>Ctrl+Shift+[]     代码折叠</li>
<li>ctrl+k ctrl+1:    折叠所有代码</li>
<li>Ctrl + K,B        打开侧边栏</li>
<li>ctrl + 回车：　　   光标后插入行，　Ctrl+Shift+Enter 光标前插入行</li>
<li>ctrl + m:         匹配括号</li>
<li>vim mode下        查找上一个下一个的快捷键是 是* #</li>
<li>ctrl +z, y:       撤销，恢复撤销</li>
<li>alt + .:          闭合当前标签</li>
<li>Ctrl+F2:          设置书签</li>
<li>F2:               下一个书签</li>
<li>Shift+F2:         上一个书签</li>
<li>ctrl + p:         即时的文件切换</li>
<li>ctrl + shift + a: 选择标签内的内容</li>
<li>ctrl + 单击：      多行随意位置添加光标</li>
<li>alt + F3( mac: ctrl + command + g): 选择页面中所有相同的词</li>
<li>ctrl + F3:        跳转到下一个选中的词</li>
<li>Ctrl+Shift+P Set Syntax:html : 设置文件类型</li>
<li>Shift + 右键:     连续多行光标选中 (by Gary Gauh)</li>
</ol>
<ul>
<li>非官方文档：<a href="https://sublime-text-unofficial-documentation.readthedocs.org/en/latest/" target="_blank" rel="external">Unofficial Document英文版</a></li>
<li><a href="http://baelabs.duapp.com/Sublime_unofficial/" target="_blank" rel="external">Unofficial Document中文版</a></li>
<li>sublime <a href="http://www.feelcss.com/sublime-text-2-settings.html" target="_blank" rel="external">配置详解</a></li>
<li>sublime <a href="http://baelabs.duapp.com/Sublime/" target="_blank" rel="external">其它文档</a></li>
</ul>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>如何删除安装的插件？</p>
<ol>
<li>ctr+shift+P,输入package</li>
<li>查找remove package</li>
<li>输入你要删除的package</li>
<li>回车，OK</li>
</ol>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/martomo/SublimeTextXdebug" target="_blank" rel="external">xdebug调试</a></li>
<li><a href="http://baelabs.duapp.com/Sublime%20text3" target="_blank" rel="external">sublimetext 3.0文档</a></li>
<li><a href="http://www.cnblogs.com/bananaplan/p/Sublime-Text-3-Powerful.html" target="_blank" rel="external">Sublime Text 3 绝对神器</a></li>
<li><a href="http://docs.sublimetext.tw/" target="_blank" rel="external">SublimeText手册-tw</a></li>
<li><a href="http://code-tech.diandian.com/post/2012-11-10/40041273125" target="_blank" rel="external">怎样从直接Github的repository安装Sublime Text插件</a></li>
<li><a href="http://code-tech.diandian.com/post/2012-11-14/40041132753" target="_blank" rel="external">Sublime text2的ThinkPHP插件</a></li>
<li><a href="http://code-tech.diandian.com/post/2012-11-21/40042403501" target="_blank" rel="external">sublime text 左侧菜单美化1</a></li>
<li><a href="http://zh.lucida.me/blog/sublime-text-complete-guide/" target="_blank" rel="external">Sublime Text 全程指南</a></li>
<li><a href="http://www.zhihu.com/question/24896283" target="_blank" rel="external">sublime 有哪些使用技巧</a></li>
<li><a href="http://www.html-js.com/article/The-frontend-tool-Megamix" target="_blank" rel="external">前端工程师手中的Sublime Text</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Sublime 基本算是我的主力代码编辑器，这里简要介绍一些插件和技巧。</p>]]>
    
    </summary>
    
      <category term="编辑器" scheme="http://wdxtub.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[VS Code 指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/visual-code-guide/"/>
    <id>http://wdxtub.com/2016/03/24/visual-code-guide/</id>
    <published>2016-03-24T20:03:14.000Z</published>
    <updated>2016-03-24T20:08:33.000Z</updated>
    <content type="html"><![CDATA[<p>Visual Studio 终于把触角伸到了全平台，在加入了插件功能之后，VSC 事实上已经对各种老牌新生编辑器造成了强大的压力，为了紧跟时代脚步，还是要熟悉和了解一下 VSC 的。</p>
<p>这里基本上是官方教程的总结和翻译。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u7840_u77E5_u8BC6"><a href="#u57FA_u7840_u77E5_u8BC6" class="headerlink" title="基础知识"></a>基础知识</h2><p>归根到底 VSC 是一个代码编辑器，所以和其他的代码编辑器一样，基本的该有的甚至不该有的功能，都有。下面会简要介绍一下</p>
<h3 id="u6587_u4EF6_u3001_u6587_u4EF6_u5939_u548C_u9879_u76EE"><a href="#u6587_u4EF6_u3001_u6587_u4EF6_u5939_u548C_u9879_u76EE" class="headerlink" title="文件、文件夹和项目"></a>文件、文件夹和项目</h3><p>随意打开一个文件或者文件夹，就可以进行编辑，如果文件夹里包含 <code>package.json</code>, <code>project.json</code>, <code>tsconfig.json</code> 或者其他 ASP.NET 5 的 sln 文件，VSC 可以自动读取项目结构并且高亮显示出来</p>
<h3 id="u57FA_u7840_u89C6_u56FE"><a href="#u57FA_u7840_u89C6_u56FE" class="headerlink" title="基础视图"></a>基础视图</h3><p>Editor, Side Bar, Status Bar 和 View Bar 这里基本的标配都有</p>
<blockquote>
<p>Tip: 可以用 command+B 来切换显示侧边栏</p>
</blockquote>
<h3 id="u591A_u680F_u7F16_u8F91"><a href="#u591A_u680F_u7F16_u8F91" class="headerlink" title="多栏编辑"></a>多栏编辑</h3><p>只需要记住一些快捷键即可</p>
<ul>
<li>command+\ 分成多栏</li>
<li>command+1/2/3 通过数字键选择当前激活的文件</li>
<li>可以自由调整和重新排序</li>
</ul>
<h3 id="u6587_u4EF6_u6D4F_u89C8_u5668"><a href="#u6587_u4EF6_u6D4F_u89C8_u5668" class="headerlink" title="文件浏览器"></a>文件浏览器</h3><p>文件浏览器中可以进行基本的文件操作，对着文件点击右键即可，甚至还可以直接在 terminal 中打开！</p>
<blockquote>
<p>Tip: command+p 可以通过文件名快速查找并打开文件</p>
</blockquote>
<p>默认来说，VSC 会排除显示一些文件夹(例如 <code>.git</code>)，当然也可以在 user setting 中配置 <code>files.exclude</code> 来自定义排除规则（是支持通配符的如<code>\*.meta</code>）</p>
<h3 id="u5DF2_u6253_u5F00_u6587_u4EF6"><a href="#u5DF2_u6253_u5F00_u6587_u4EF6" class="headerlink" title="已打开文件"></a>已打开文件</h3><p>已打开文件会在边栏的上方显示，如果需要自定义，可以设置下面一些属性：</p>
<ul>
<li><code>explorer.workingFiles.maxVisible</code></li>
<li><code>explorer.workingFiles.dynamicHeight</code></li>
</ul>
<h3 id="u8DE8_u6587_u4EF6_u641C_u7D22"><a href="#u8DE8_u6587_u4EF6_u641C_u7D22" class="headerlink" title="跨文件搜索"></a>跨文件搜索</h3><p>快捷键 shift+command+f，支持全文搜索，中文英文都可以！简直爆炸！而且还支持正则表达式！</p>
<p>如果需要更高级的搜索，可以使用 shift+command+j</p>
<p>下面列出基本的正则表示：</p>
<ul>
<li><code>*</code> to match one or more characters in a path segment</li>
<li><code>?</code> to match on one character in a path segment</li>
<li><code>**</code> to match any number of path segments ,including none</li>
<li><code>{}</code> to group conditions (e.g. <code>{**/*.html,**/*.txt}</code> matches all html and txt files)</li>
<li><code>[]</code> to declare a range of characters to match (e.g., example.[0-9] to match on example.0, example.1, …</li>
</ul>
<p>注意可以自定义搜索范围，在设置中设定</p>
<ul>
<li><code>files.exclude</code></li>
<li><code>search.exclude</code></li>
</ul>
<h3 id="u547D_u4EE4_u677F"><a href="#u547D_u4EE4_u677F" class="headerlink" title="命令板"></a>命令板</h3><p>按 F1 就可以调出 Command Palette，这里可以快速输入各种命令，一些基本技巧</p>
<ul>
<li>command+p: 通过文件名找文件</li>
<li>control+tab: 可以循环切换之前打开的文件</li>
<li>shift+command+o: 可以导航到文件中的指定符号</li>
<li>control+g: 导航到指定行</li>
</ul>
<p>在 Command Palette 中输入 <code>?</code> 可以显示当前可用的操作</p>
<h3 id="u6587_u4EF6_u7F16_u7801_u652F_u6301"><a href="#u6587_u4EF6_u7F16_u7801_u652F_u6301" class="headerlink" title="文件编码支持"></a>文件编码支持</h3><p>在 <code>files.encoding</code> 设置中设置具体的编码，可以在 右下角的状态栏中看到。点击状态栏中的编码可以用指定编码打开或者保存文件(还需要选择具体的编码格式)</p>
<h2 id="u7F16_u8F91_u529F_u80FD"><a href="#u7F16_u8F91_u529F_u80FD" class="headerlink" title="编辑功能"></a>编辑功能</h2><p>理论上来说，基本上该有的功能都有，这里只列出一些超赞的功能</p>
<h3 id="u62EC_u53F7_u5339_u914D"><a href="#u62EC_u53F7_u5339_u914D" class="headerlink" title="括号匹配"></a>括号匹配</h3><p>括号会自动高亮匹配，可以用 <code>shift+command+]</code> 来跳到匹配的括号位置</p>
<h3 id="u591A_u884C_u9009_u62E9"><a href="#u591A_u884C_u9009_u62E9" class="headerlink" title="多行选择"></a>多行选择</h3><p>利用 <code>alt+click</code> 来激活多行选择，每个光标都是独立的，另一个比较方便添加光标的方式是 <code>option+command+↓</code> 和 <code>option+command+↑</code>，这会在正下方或上方添加光标</p>
<p><code>command+D</code> 选择当前单词，或者是当前单词下一次出现的位置，<code>command+K command+D</code> 会选择单词最后一次出现的位置</p>
<p>其他一些添加光标的方式是</p>
<ul>
<li><code>shift+command+l</code>: 在单词下一次出现处添加光标</li>
<li><code>command+f2</code>: 在下一个单词前添加光标</li>
</ul>
<h3 id="u7F29_u8FDB/_u6269_u5C55_u9009_u62E9"><a href="#u7F29_u8FDB/_u6269_u5C55_u9009_u62E9" class="headerlink" title="缩进/扩展选择"></a>缩进/扩展选择</h3><p>选择缩进/扩展，快捷键 <code>control+shift+command+←</code> / <code>control+shift+command+→</code></p>
<p><img src="/images/14588498234616.jpg" alt=""></p>
<h3 id="u667A_u80FD_u63D0_u793A"><a href="#u667A_u80FD_u63D0_u793A" class="headerlink" title="智能提示"></a>智能提示</h3><p>对于 JavaScript, JSON, HTML, CSS, Less, Sass, C#, TypeScript 都有智能提示，也可以用 <code>control+space</code> 手动激活，用 <code>.</code>, <code>tab</code>, <code>Enter</code> 来选择</p>
<p>默认会在输入的时候进行智能提示，即所谓 24x7 IntelliSense，可以在 <code>editor.quickSuggestions</code> 和 <code>editor.suggestOnTriggerCharacters</code> 中进行设置</p>
<h3 id="u53C2_u6570_u63D0_u793A"><a href="#u53C2_u6570_u63D0_u793A" class="headerlink" title="参数提示"></a>参数提示</h3><p>在 JavaScript, TypeScript 和 C# 中，会自动提示函数的参数，可以用方向键进行导航</p>
<h3 id="u4EE3_u7801_u7247_u6BB5"><a href="#u4EE3_u7801_u7247_u6BB5" class="headerlink" title="代码片段"></a>代码片段</h3><p>可以在 <code>User Snippets</code> (<code>File | Preferences</code>) 中设定自己的 snippet</p>
<h3 id="u8DF3_u8F6C_u5230_u5B9A_u4E49"><a href="#u8DF3_u8F6C_u5230_u5B9A_u4E49" class="headerlink" title="跳转到定义"></a>跳转到定义</h3><p>如果语言支持的话，可以用 <code>F12</code> 来跳转到定义。如果按着 <code>ctrl</code> 并把指针放到一个符号上，会有一个简单的预览框。如果需要跳转到定义处可以使用 <code>ctrl+click</code>。如果需要在另外一侧的窗口打开定义，使用 <code>ctrol+alt+click</code></p>
<h2 id="u6269_u5C55"><a href="#u6269_u5C55" class="headerlink" title="扩展"></a>扩展</h2><p>支持扩展是使编辑器更加强大的方法，这里简要介绍一些目前我觉得比较有用的扩展</p>
<h3 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h3><p>安装方法非常简单，用 <code>F1</code> 打开 命令行，然后输入 <code>ext inst</code> 来进行操作</p>
<p><a href="https://marketplace.visualstudio.com/#VSCode" target="_blank" rel="external">MarketPlace</a></p>
<ul>
<li>Markdown Theme Kit</li>
<li>Markdown 预览 <code>command+k v</code></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Visual Studio 终于把触角伸到了全平台，在加入了插件功能之后，VSC 事实上已经对各种老牌新生编辑器造成了强大的压力，为了紧跟时代脚步，还是要熟悉和了解一下 VSC 的。</p>
<p>这里基本上是官方教程的总结和翻译。</p>]]>
    
    </summary>
    
      <category term="编辑器" scheme="http://wdxtub.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python 编程思想]]></title>
    <link href="http://wdxtub.com/2016/03/24/thinking-in-python/"/>
    <id>http://wdxtub.com/2016/03/24/thinking-in-python/</id>
    <published>2016-03-24T19:36:15.000Z</published>
    <updated>2016-03-24T19:52:07.000Z</updated>
    <content type="html"><![CDATA[<p>这里收集了一些深入 python 机制的内容。</p>
<a id="more"></a>
<hr>
<h2 id="u6D45_u8C08_Python__u7684_with__u8BED_u53E5"><a href="#u6D45_u8C08_Python__u7684_with__u8BED_u53E5" class="headerlink" title="浅谈 Python 的 with 语句"></a>浅谈 Python 的 with 语句</h2><p>with 语句是从 Python 2.5 开始引入的一种与异常处理相关的功能（2.5 版本中要通过 <code>from __future__ import with_statement</code> 导入后才可以使用），从 2.6 版本开始缺省可用（参考 What’s new in Python 2.6? 中 with 语句相关部分介绍）。with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。</p>
<h3 id="u672F_u8BED"><a href="#u672F_u8BED" class="headerlink" title="术语"></a>术语</h3><p>要使用 with 语句，首先要明白上下文管理器这一概念。有了上下文管理器，with 语句才能工作。</p>
<p>下面是一组与上下文管理器和with 语句有关的概念。</p>
<p>上下文管理协议（Context Management Protocol）：包含方法 <code>__enter__()</code> 和 <code>__exit__()</code>，支持该协议的对象要实现这两个方法。</p>
<p>上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了<br><code>__enter__()</code> 和 <code>__exit__()</code> 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。</p>
<p>运行时上下文（runtime context）：由上下文管理器创建，通过上下文管理器的 <code>__enter__()</code> 和 <code>__exit__()</code> 方法实现，<code>__enter__()</code> 方法在语句体执行之前进入运行时上下文，<code>__exit__()</code> 在语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。</p>
<p>上下文表达式（Context Expression）：with 语句中跟在关键字 with 之后的表达式，该表达式要返回一个上下文管理器对象。</p>
<p>语句体（with-body）：with 语句包裹起来的代码块，在执行语句体之前会调用上下文管<br>理器的 <code>__enter__()</code> 方法，执行完语句体之后会执行 <code>__exit__()</code> 方法。</p>
<h3 id="u57FA_u672C_u8BED_u6CD5_u548C_u5DE5_u4F5C_u539F_u7406"><a href="#u57FA_u672C_u8BED_u6CD5_u548C_u5DE5_u4F5C_u539F_u7406" class="headerlink" title="基本语法和工作原理"></a>基本语法和工作原理</h3><p>with 语句的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> context_expression [<span class="keyword">as</span> target(s)]:</span><br><span class="line">    <span class="keyword">with</span>-body</span><br></pre></td></tr></table></figure>
<p>这里 context_expression 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 target(s) ，如果指定了 as 子句的话，会将上下文管理器的 <code>__enter__()</code> 方法的返回值赋值给 target(s)。target(s) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）。</p>
<p>Python 对一些内建对象进行改进，加入了对上下文管理器的支持，可以用于 with 语句中，比如可以自动关闭文件、线程锁的自动获取和释放等。假设要对一个文件进行操作，使用 with 语句可以有如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">r'somefileName'</span>) <span class="keyword">as</span> somefile:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> somefile:</span><br><span class="line">        <span class="keyword">print</span> line</span><br><span class="line">        <span class="comment"># ...more code</span></span><br></pre></td></tr></table></figure>
<p>这里使用了 with 语句，不管在处理文件过程中是否发生异常，都能保证 with 语句执行完毕后已经关闭了打开的文件句柄。如果使用传统的 try/finally 范式，则要使用类似如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">somefile = open(<span class="string">r'somefileName'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> somefile:</span><br><span class="line">        <span class="keyword">print</span> line</span><br><span class="line">        <span class="comment"># ...more code</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    somefile.close()</span><br></pre></td></tr></table></figure>
<p>比较起来，使用 with 语句可以减少编码量。已经加入对上下文管理协议支持的还有模块 threading、decimal 等。</p>
<p>PEP 0343 对 with 语句的实现进行了描述。with 语句的执行过程类似如下代码块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">context_manager = context_expression</span><br><span class="line">exit = type(context_manager).__exit__  </span><br><span class="line">value = type(context_manager).__enter__(context_manager)</span><br><span class="line">exc = <span class="keyword">True</span>   <span class="comment"># True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        target = value  <span class="comment"># 如果使用了 as 子句</span></span><br><span class="line">        <span class="keyword">with</span>-body     <span class="comment"># 执行 with-body</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># 执行过程中有异常发生</span></span><br><span class="line">        exc = <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常</span></span><br><span class="line">        <span class="comment"># 由外层代码对异常进行处理</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exit(context_manager, *sys.exc_info()):</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出</span></span><br><span class="line">    <span class="comment"># 或者忽略异常退出</span></span><br><span class="line">    <span class="keyword">if</span> exc:</span><br><span class="line">        exit(context_manager, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line">    <span class="comment"># 缺省返回 None，None 在布尔上下文中看做是 False</span></span><br></pre></td></tr></table></figure>
<ol>
<li>执行 context_expression，生成上下文管理器 context_manager</li>
<li>调用上下文管理器的 <code>__enter__()</code> 方法；如果使用了 as 子句，则将 <code>__enter__()</code> 方法的返回值赋值给 as 子句中的 target(s)</li>
<li>执行语句体 with-body</li>
<li>不管是否执行过程中是否发生了异常，执行上下文管理器的 <code>__exit__()</code> 方法，<code>__exit__()</code> 方法负责执行“清理”工作，如释放资源等。如果执行过程中没有出现异常，或者语句体中执行了语句 break/continue/return，则以 None 作为参数调用 <code>__exit__(None, None, None)</code> ；如果执行过程中出现异常，则使用 sys.exc_info 得到的异常信息为参数调用 <code>__exit__(exc_type, exc_value, exc_traceback)</code></li>
<li>出现异常时，如果 <code>__exit__(type, value, traceback)</code> 返回 False，则会重新抛出异常，让with 之外的语句逻辑来处理异常，这也是通用做法；如果返回 True，则忽略异常，不再对异常进行处理</li>
</ol>
<h2 id="Python_u7A0B_u5E8F_u7684_u6267_u884C_u539F_u7406"><a href="#Python_u7A0B_u5E8F_u7684_u6267_u884C_u539F_u7406" class="headerlink" title="Python程序的执行原理"></a>Python程序的执行原理</h2><p>Python先把代码(.py文件)编译成字节码，交给字节码虚拟机，然后虚拟机一条一条执行字节码指令，从而完成程序的执行。</p>
<p>字节码在Python虚拟机程序里对应的是PyCodeObject对象。</p>
<p>.pyc文件是字节码在磁盘上的表现形式。</p>
<p>PyCodeObject对象的创建时机是模块加载的时候，即import。</p>
<p>Python test.py会对test.py进行编译成字节码并解释执行，但是不会生成test.pyc。</p>
<p>如果test.py加载了其他模块，如import util，Python会对util.py进行编译成字节码，生成util.pyc，然后对字节码解释执行。</p>
<p>如果想生成test.pyc，我们可以使用Python内置模块py_compile来编译。</p>
<p>加载模块时，如果同时存在.py和.pyc，Python会尝试使用.pyc，如果.pyc的编译时间早于.py的修改时间，则重新编译.py并更新.pyc。</p>
<p>Python代码的编译结果就是PyCodeObject对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    int co_argcount;        /* 位置参数个数 */</span><br><span class="line">    int co_nlocals;         /* 局部变量个数 */</span><br><span class="line">    int co_stacksize;       /* 栈大小 */</span><br><span class="line">    int co_flags;   </span><br><span class="line">    PyObject *co_code;      /* 字节码指令序列 */</span><br><span class="line">    PyObject *co_consts;    /* 所有常量集合 */</span><br><span class="line">    PyObject *co_names;     /* 所有符号名称集合 */</span><br><span class="line">    PyObject *co_varnames;  /* 局部变量名称集合 */</span><br><span class="line">    PyObject *co_freevars;  /* 闭包用的的变量名集合 */</span><br><span class="line">    PyObject *co_cellvars;  /* 内部嵌套函数引用的变量名集合 */</span><br><span class="line">    /* The rest doesn’t count <span class="keyword">for</span> hash/cmp */</span><br><span class="line">    PyObject *co_filename;  /* 代码所在文件名 */</span><br><span class="line">    PyObject *co_name;      /* 模块名|函数名|类名 */</span><br><span class="line">    int co_firstlineno;     /* 代码块在文件中的起始行号 */</span><br><span class="line">    PyObject *co_lnotab;    /* 字节码指令和行号的对应关系 */</span><br><span class="line">    void *co_zombieframe;   /* <span class="keyword">for</span> optimization only (see frameobject.c) */</span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>
<p>加载模块时，模块对应的PyCodeObject对象被写入.pyc文件，格式如下：</p>
<p><img src="/images/14588486364401.jpg" alt=""></p>
<h3 id="u5206_u6790_u5B57_u8282_u7801"><a href="#u5206_u6790_u5B57_u8282_u7801" class="headerlink" title="分析字节码"></a>分析字节码</h3><p>Python提供了内置函数compile可以编译Python代码和查看PyCodeObject对象，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = ”hello”</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> s</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure>
<p>在Python交互式shell里编译代码得到PyCodeObject对象:</p>
<p><img src="/images/14588486530973.jpg" alt=""></p>
<p>dir(co)已经列出co的各个域，想查看某个域直接在终端输出即可：</p>
<p><img src="/images/14588486595605.jpg" alt=""></p>
<p>test.py的PyCodeObject</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">co.co_argcount    0</span><br><span class="line">co.co_nlocals     0</span><br><span class="line">co.co_names       (‘s’, ’func’)</span><br><span class="line">co.co_varnames    (‘s’, ’func’)</span><br><span class="line">co.co_consts      (‘hello’, &lt;code object func at 0x2aaeeec57110, file ”test.py”, line 3&gt;, None)</span><br><span class="line">co.co_code        ’d<span class="command">\x</span>00<span class="command">\x</span>00Z<span class="command">\x</span>00<span class="command">\x</span>00d<span class="command">\x</span>01<span class="command">\x</span>00<span class="command">\x</span>84<span class="command">\x</span>00<span class="command">\x</span>00Z<span class="command">\x</span>01<span class="command">\x</span>00e<span class="command">\x</span>01<span class="command">\x</span>00<span class="command">\x</span>83<span class="command">\x</span>00<span class="command">\x</span>00<span class="command">\x</span>01d<span class="command">\x</span>02<span class="command">\x</span>00S’</span><br></pre></td></tr></table></figure>
<p>Python解释器会为函数也生成的字节码PyCodeObject对象，见上面的co_consts[1]</p>
<p>func的PyCodeObject</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_argcount</span>   0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_nlocals</span>    0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_names</span>      <span class="params">(‘s’,)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_varnames</span>   <span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_consts</span>     <span class="params">(None,)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span>.<span class="title">co_code</span>       ‘<span class="title">t</span>\<span class="title">x00</span>\<span class="title">x00GHd</span>\<span class="title">x00</span>\<span class="title">x00S</span>’</span></span><br></pre></td></tr></table></figure>
<h3 id="u6267_u884C_u5B57_u8282_u7801"><a href="#u6267_u884C_u5B57_u8282_u7801" class="headerlink" title="执行字节码"></a>执行字节码</h3><p>Python虚拟机的原理就是模拟可执行程序再X86机器上的运行，X86的运行时栈帧如下图：</p>
<p><img src="/images/14588486859304.jpg" alt=""></p>
<p>假如test.py用C语言来实现，会是下面这个样子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s = “hello”;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(“%s\n”, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python虚拟机的原理就是模拟上述行为。当发生函数调用时，创建新的栈帧，对应Python的实现就是PyFrameObject对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _frame &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    struct _frame *f_back;    /* 调用者的帧 */</span><br><span class="line">    PyCodeObject *f_code;     /* 帧对应的字节码对象 */</span><br><span class="line">    PyObject *f_builtins;     /* 内置名字空间 */</span><br><span class="line">    PyObject *f_globals;      /* 全局名字空间 */</span><br><span class="line">    PyObject *f_locals;       /* 本地名字空间 */</span><br><span class="line">    PyObject **f_valuestack;  /* 运行时栈底 */</span><br><span class="line">    PyObject **f_stacktop;    /* 运行时栈顶 */</span><br><span class="line">    …….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么对应Python的运行时栈就是这样子：</p>
<p><img src="/images/14588486997857.jpg" alt=""></p>
<p>执行test.py的字节码时，会先创建一个栈帧，以下用f表示当前栈帧，执行过程注释如下：</p>
<p>test.py的符号名集合和常量集合</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">co<span class="class">.co_names</span>   (‘s’, ’func’)</span><br><span class="line">co<span class="class">.co_consts</span>  (‘hello’, &lt;<span class="tag">code</span> <span class="tag">object</span> func at <span class="number">0</span>x2aaeeec57110, file ”test.py”, line <span class="number">3</span>&gt;, None)</span><br></pre></td></tr></table></figure>
<p>如果你想查看当前栈帧，Python提供了<code>sys._getframe()</code>方法可以获取当前栈帧，你只需要在代码里加入代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    frame = sys._getframe()</span><br><span class="line">    <span class="keyword">print</span> frame.f_locals</span><br><span class="line">    <span class="keyword">print</span> frame.f_globals</span><br><span class="line">    <span class="keyword">print</span> frame.f_back.f_locals</span><br><span class="line">    <span class="comment">#你可以打印frame的各个域</span></span><br><span class="line">    <span class="keyword">print</span> s</span><br></pre></td></tr></table></figure>
<h2 id="Python__u9ED1_u9B54_u6CD5"><a href="#Python__u9ED1_u9B54_u6CD5" class="headerlink" title="Python 黑魔法"></a>Python 黑魔法</h2><h3 id="Python__u591A_u7EE7_u627F"><a href="#Python__u591A_u7EE7_u627F" class="headerlink" title="Python 多继承"></a>Python 多继承</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class A(object):</span><br><span class="line">   ...:         def foo(self):</span><br><span class="line">   ...:                 print("class A")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [2]: class B(object):</span><br><span class="line">   ...:         def foo(self):</span><br><span class="line">   ...:                 print("class B")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [3]: class C(A, B):</span><br><span class="line">   ...:         pass</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [4]: C().foo()</span><br><span class="line">class A # 例子很好懂, C继承了A和B，从左到右,发现A有foo方法,返回了</span><br></pre></td></tr></table></figure>
<p>看起来都是很简单, 有次序的从底向上,从前向后找,找到就返回. 再看例子:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [5]: class A(object):</span><br><span class="line">   ...:        def foo(self):</span><br><span class="line">   ...:               print("class A")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [6]: class B(A):</span><br><span class="line">   ...:        pass</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [7]: class C(A):</span><br><span class="line">   ...:        def foo(self):</span><br><span class="line">   ...:               print("class C")</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [8]: class D(B,C):</span><br><span class="line">   ...:        pass</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [9]: D().foo()</span><br><span class="line">class C # ? 按道理, 顺序是 D-&gt;B-&gt;A,为什么找到了C哪去了</span><br></pre></td></tr></table></figure>
<p>这也就涉及了MRO(Method Resolution Order):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: D.__mro__</span><br><span class="line">Out[<span class="number">10</span>]: (__main__.D, __main__.B, __main__.C, __main__.A, object)</span><br></pre></td></tr></table></figure>
<p>简单的理解其实就是新式类是广度优先了， D-&gt;B, 但是发现C也是继承A，就先找C，最后再去找A</p>
<h3 id="u5217_u8868_u7684+_u548C+_3D_2C_append_u548Cextend"><a href="#u5217_u8868_u7684+_u548C+_3D_2C_append_u548Cextend" class="headerlink" title="列表的+和+=, append和extend"></a>列表的+和+=, append和extend</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: print(<span class="string">'ID:'</span>, id(a_list))</span><br><span class="line">(<span class="string">'ID:'</span>, <span class="number">4481323592</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: a_list += [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: print(<span class="string">'ID (+=):'</span>, id(a_list))</span><br><span class="line">(<span class="string">'ID (+=):'</span>, <span class="number">4481323592</span>) <span class="comment"># 使用+= 还是在原来的列表上操作</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: a_list = a_list + [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: print(<span class="string">'ID (list = list + ...):'</span>, id(a_list))</span><br><span class="line">(<span class="string">'ID (list = list + ...):'</span>, <span class="number">4481293056</span>) <span class="comment"># 简单的+其实已经改变了原有列表</span></span><br><span class="line">In [<span class="number">28</span>]: a_list = []</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: id(a_list)</span><br><span class="line">Out[<span class="number">29</span>]: <span class="number">4481326976</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: a_list.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: id(a_list)</span><br><span class="line">Out[<span class="number">31</span>]: <span class="number">4481326976</span> <span class="comment"># append 是在原有列表添加</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: a_list.extend([<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: id(a_list)</span><br><span class="line">Out[<span class="number">33</span>]: <span class="number">4481326976</span> <span class="comment"># extend 也是在原有列表上添加</span></span><br></pre></td></tr></table></figure>
<h3 id="datetime_u4E5F_u6709_u5E03_u5C14_u503C"><a href="#datetime_u4E5F_u6709_u5E03_u5C14_u503C" class="headerlink" title="datetime也有布尔值"></a>datetime也有布尔值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">34</span>]: <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: print(<span class="string">'"datetime.time(0,0,0)" (Midnight) -&gt;'</span>, bool(datetime.time(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)))</span><br><span class="line">(<span class="string">'"datetime.time(0,0,0)" (Midnight) -&gt;'</span>, <span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: print(<span class="string">'"datetime.time(1,0,0)" (1 am) -&gt;'</span>, bool(datetime.time(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)))</span><br><span class="line">(<span class="string">'"datetime.time(1,0,0)" (1 am) -&gt;'</span>, <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="u2019_3D_3D_u2019__u548C_is__u7684_u533A_u522B"><a href="#u2019_3D_3D_u2019__u548C_is__u7684_u533A_u522B" class="headerlink" title="’==’ 和 is 的区别"></a>’==’ 和 is 的区别</h3><p>我的理解是”is”是判断2个对象的身份, ==是判断2个对象的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">37</span>]: a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: print(<span class="string">'a is b'</span>, bool(a <span class="keyword">is</span> b))</span><br><span class="line">(<span class="string">'a is b'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: c = <span class="number">999</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: d = <span class="number">999</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: print(<span class="string">'c is d'</span>, bool(c <span class="keyword">is</span> d))</span><br><span class="line">(<span class="string">'c is d'</span>, <span class="keyword">False</span>) <span class="comment"># 原因是python的内存管理,缓存了-5 - 256的对象</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: print(<span class="string">'256 is 257-1'</span>, <span class="number">256</span> <span class="keyword">is</span> <span class="number">257</span>-<span class="number">1</span>)</span><br><span class="line">(<span class="string">'256 is 257-1'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: print(<span class="string">'257 is 258-1'</span>, <span class="number">257</span> <span class="keyword">is</span> <span class="number">258</span> - <span class="number">1</span>)</span><br><span class="line">(<span class="string">'257 is 258-1'</span>, <span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: print(<span class="string">'-5 is -6+1'</span>, -<span class="number">5</span> <span class="keyword">is</span> -<span class="number">6</span>+<span class="number">1</span>)</span><br><span class="line">(<span class="string">'-5 is -6+1'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: print(<span class="string">'-7 is -6-1'</span>, -<span class="number">7</span> <span class="keyword">is</span> -<span class="number">6</span>-<span class="number">1</span>)</span><br><span class="line">(<span class="string">'-7 is -6-1'</span>, <span class="keyword">False</span>)</span><br><span class="line">In [<span class="number">47</span>]: a = <span class="string">'hello world!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: b = <span class="string">'hello world!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: print(<span class="string">'a is b,'</span>, a <span class="keyword">is</span> b)</span><br><span class="line">(<span class="string">'a is b,'</span>, <span class="keyword">False</span>) <span class="comment"># 很明显 他们没有被缓存,这是2个字段串的对象</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: print(<span class="string">'a == b,'</span>, a == b)</span><br><span class="line">(<span class="string">'a == b,'</span>, <span class="keyword">True</span>) <span class="comment"># 但他们的值相同</span></span><br><span class="line"><span class="comment"># But, 有个特例</span></span><br><span class="line">In [<span class="number">51</span>]: a = float(<span class="string">'nan'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: print(<span class="string">'a is a,'</span>, a <span class="keyword">is</span> a)</span><br><span class="line">(<span class="string">'a is a,'</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: print(<span class="string">'a == a,'</span>, a == a)</span><br><span class="line">(<span class="string">'a == a,'</span>, <span class="keyword">False</span>) <span class="comment"># 亮瞎我眼睛了~</span></span><br></pre></td></tr></table></figure>
<h3 id="bool_u5176_u5B9E_u662Fint_u7684_u5B50_u7C7B"><a href="#bool_u5176_u5B9E_u662Fint_u7684_u5B50_u7C7B" class="headerlink" title="bool其实是int的子类"></a>bool其实是int的子类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">97</span>]: isinstance(<span class="keyword">True</span>, int)</span><br><span class="line">Out[<span class="number">97</span>]: <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: <span class="keyword">True</span> + <span class="keyword">True</span></span><br><span class="line">Out[<span class="number">98</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: <span class="number">3</span> * <span class="keyword">True</span> + <span class="keyword">True</span></span><br><span class="line">Out[<span class="number">99</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: <span class="number">3</span> * <span class="keyword">True</span> - <span class="keyword">False</span></span><br><span class="line">Out[<span class="number">100</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: <span class="keyword">True</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">Out[<span class="number">104</span>]: <span class="number">1024</span></span><br></pre></td></tr></table></figure>
<h3 id="u5143_u7EC4_u662F_u4E0D_u662F_u771F_u7684_u4E0D_u53EF_u53D8_3F"><a href="#u5143_u7EC4_u662F_u4E0D_u662F_u771F_u7684_u4E0D_u53EF_u53D8_3F" class="headerlink" title="元组是不是真的不可变?"></a>元组是不是真的不可变?</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [111]: tup = ([],)</span><br><span class="line"></span><br><span class="line">In [112]: tup[0] += [1]</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-112-d4f292cf35de&gt; in &lt;module&gt;()</span><br><span class="line">----&gt; 1 tup[0] += [1]</span><br><span class="line"></span><br><span class="line">TypeError: 'tuple' object does not support item assignment</span><br><span class="line"></span><br><span class="line">In [113]: tup</span><br><span class="line">Out[113]: ([1],) # 我靠 又是亮瞎我眼睛,明明抛了异常 还能修改?</span><br><span class="line"></span><br><span class="line">In [114]: tup = ([],)</span><br><span class="line"></span><br><span class="line">In [115]: tup[0].extend([1])</span><br><span class="line"></span><br><span class="line">In [116]: tup[0]</span><br><span class="line">Out[116]: [1] # 好吧,我有点看明白了, 虽然我不能直接操作元组，但是不能阻止我操作元组中可变的子对象(list)</span><br></pre></td></tr></table></figure>
<p>+= 是一个特例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">117</span>]: my_tup = (<span class="number">1</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: my_tup += (<span class="number">4</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: my_tup = my_tup + (<span class="number">5</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: my_tup</span><br><span class="line">Out[<span class="number">120</span>]: (<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment"># ? 嗯 不是不能操作元组嘛?</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: my_tup = (<span class="number">1</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: print(id(my_tup))</span><br><span class="line"><span class="number">4481317904</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: my_tup += (<span class="number">4</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: print(id(my_tup))</span><br><span class="line"><span class="number">4480606864</span> <span class="comment"># 操作的不是原来的元组 所以可以</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: my_tup = my_tup + (<span class="number">5</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">126</span>]: print(id(my_tup))</span><br><span class="line"><span class="number">4474234912</span></span><br></pre></td></tr></table></figure>
<h3 id="u5F02_u5E38_u5904_u7406_u52A0_else"><a href="#u5F02_u5E38_u5904_u7406_u52A0_else" class="headerlink" title="异常处理加 else"></a>异常处理加 else</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">150</span>]: <span class="keyword">try</span>:</span><br><span class="line">   .....:     print(<span class="string">'third element:'</span>, a_list[<span class="number">2</span>])</span><br><span class="line">   .....: <span class="keyword">except</span> IndexError:</span><br><span class="line">   .....:     print(<span class="string">'raised IndexError'</span>)</span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:     print(<span class="string">'no error in try-block'</span>) <span class="comment"># 只有在try里面没有异常的时候才会执行else里面的表达式</span></span><br><span class="line">   .....:</span><br><span class="line">raised IndexError <span class="comment"># 抛异常了 没完全完成</span></span><br><span class="line">In [<span class="number">153</span>]: i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">154</span>]: <span class="keyword">while</span> i &lt; <span class="number">2</span>:</span><br><span class="line">   .....:     print(i)</span><br><span class="line">   .....:     i += <span class="number">1</span></span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:     print(<span class="string">'in else'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> <span class="keyword">else</span> <span class="comment"># while也支持哦~</span></span><br><span class="line">In [<span class="number">155</span>]: i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: <span class="keyword">while</span> i &lt; <span class="number">2</span>:</span><br><span class="line">   .....:         print(i)</span><br><span class="line">   .....:         i += <span class="number">1</span></span><br><span class="line">   .....:         <span class="keyword">break</span></span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:         print(<span class="string">'completed while-loop'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span> <span class="comment"># 被break了 没有完全执行完 就不执行else里面的了</span></span><br><span class="line">In [<span class="number">158</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">   .....:         print(i)</span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:         print(<span class="string">'completed for-loop'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">completed <span class="keyword">for</span>-loop</span><br><span class="line"></span><br><span class="line">In [<span class="number">159</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">   .....:         print(i)</span><br><span class="line">   .....:         <span class="keyword">break</span></span><br><span class="line">   .....: <span class="keyword">else</span>:</span><br><span class="line">   .....:         print(<span class="string">'completed for-loop'</span>)</span><br><span class="line">   .....:</span><br><span class="line"><span class="number">0</span> <span class="comment"># 也是因为break了</span></span><br></pre></td></tr></table></figure>
<h2 id="u6DF1_u62F7_u8D1D_u4E0E_u6D45_u62F7_u8D1D"><a href="#u6DF1_u62F7_u8D1D_u4E0E_u6D45_u62F7_u8D1D" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><h3 id="u5BF9_u8C61_u8D4B_u503C"><a href="#u5BF9_u8C61_u8D4B_u503C" class="headerlink" title="对象赋值"></a>对象赋值</h3><p>Python中，对象的赋值，拷贝（深/浅拷贝）之间是有差异的，如果使用的时候不注意，就可能产生意外的结果。</p>
<p>直接看一段代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">will = [<span class="string">"Will"</span>, <span class="number">28</span>, [<span class="string">"Python"</span>, <span class="string">"C#"</span>, <span class="string">"JavaScript"</span>]]</span><br><span class="line">wilber = will</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">"Wilber"</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">"CSS"</span>)</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br></pre></td></tr></table></figure>
<p><img src="/media/14521096832549/tip1.png" alt="tip1"></p>
<p>下面来分析一下这段代码：</p>
<ul>
<li>首先，创建了一个名为will的变量，这个变量指向一个list对象，从第一张图中可以看到所有对象的地址（每次运行，结果可能不同）</li>
<li>然后，通过will变量对wilber变量进行赋值，那么wilber变量将指向will变量对应的对象（内存地址），也就是说”wilber is will”，”wilber[i] is will[i]”</li>
<li>可以理解为，Python中，对象的赋值都是进行对象引用（内存地址）传递</li>
</ul>
<p>第三张图中，由于will和wilber指向同一个对象，所以对will的任何修改都会体现在wilber上<br>这里需要注意的一点是，str是不可变类型，所以当修改的时候会替换旧的对象，产生一个新的地址39758496</p>
<p><img src="/images/14588487955418.jpg" alt=""></p>
<h3 id="u6D45_u62F7_u8D1D"><a href="#u6D45_u62F7_u8D1D" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>下面就来看看浅拷贝的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">will = [<span class="string">"Will"</span>, <span class="number">28</span>, [<span class="string">"Python"</span>, <span class="string">"C#"</span>, <span class="string">"JavaScript"</span>]]</span><br><span class="line">wilber = copy.copy(will)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">"Wilber"</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">"CSS"</span>)</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br></pre></td></tr></table></figure>
<p>代码结果为：</p>
<p><img src="/images/14588488054814.jpg" alt=""></p>
<p>分析一下这段代码：</p>
<ul>
<li>首先，依然使用一个will变量，指向一个list类型的对象</li>
<li>然后，通过copy模块里面的浅拷贝函数copy()，对will指向的对象进行浅拷贝，然后浅拷贝生成的新对象赋值给wilber变量<ul>
<li>浅拷贝会创建一个新的对象，这个例子中”wilber is not will”</li>
<li>但是，对于对象中的元素，浅拷贝就只会使用原始元素的引用（内存地址），也就是说”wilber[i] is will[i]”</li>
</ul>
</li>
<li>当对will进行修改的时候<ul>
<li>由于list的第一个元素是不可变类型，所以will对应的list的第一个元素会使用一个新的对象39758496</li>
<li>但是list的第三个元素是一个可变类型，修改操作不会产生新的对象，所以will的修改结果会相应的反应到wilber上</li>
</ul>
</li>
</ul>
<p><img src="/images/14588488145630.jpg" alt=""></p>
<p>总结一下，当我们使用下面的操作的时候，会产生浅拷贝的效果：</p>
<ul>
<li>使用切片[:]操作</li>
<li>使用工厂函数（如list/dir/set）</li>
<li>使用copy模块中的copy()函数</li>
</ul>
<h3 id="u6DF1_u62F7_u8D1D"><a href="#u6DF1_u62F7_u8D1D" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>最后来看看深拷贝：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">will = [<span class="string">"Will"</span>, <span class="number">28</span>, [<span class="string">"Python"</span>, <span class="string">"C#"</span>, <span class="string">"JavaScript"</span>]]</span><br><span class="line">wilber = copy.deepcopy(will)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">"Wilber"</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">"CSS"</span>)</span><br><span class="line"><span class="keyword">print</span> id(will)</span><br><span class="line"><span class="keyword">print</span> will</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</span><br><span class="line"><span class="keyword">print</span> id(wilber)</span><br><span class="line"><span class="keyword">print</span> wilber</span><br><span class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</span><br></pre></td></tr></table></figure>
<p>代码的结果为：</p>
<p><img src="/images/14588488380987.jpg" alt=""></p>
<p>分析一下这段代码：</p>
<ul>
<li>首先，同样使用一个will变量，指向一个list类型的对象</li>
<li>然后，通过copy模块里面的深拷贝函数deepcopy()，对will指向的对象进行深拷贝，然后深拷贝生成的新对象赋值给wilber变量<ul>
<li>跟浅拷贝类似，深拷贝也会创建一个新的对象，这个例子中”wilber is not will”</li>
<li>但是，对于对象中的元素，深拷贝都会重新生成一份（有特殊情况，下面会说明），而不是简单的使用原始元素的引用（内存地址）</li>
<li>例子中will的第三个元素指向39737304，而wilber的第三个元素是一个全新的对象39773088，也就是说，”wilber[2] is not will[2]”</li>
</ul>
</li>
<li>当对will进行修改的时候<ul>
<li>由于list的第一个元素是不可变类型，所以will对应的list的第一个元素会使用一个新的对象39758496</li>
<li>但是list的第三个元素是一个可变类型，修改操作不会产生新的对象，但是由于”wilber[2] is not will[2]”，所以will的修改不会影响wilber</li>
</ul>
</li>
</ul>
<p><img src="/images/14588488493152.jpg" alt=""></p>
<h3 id="u62F7_u8D1D_u7684_u7279_u6B8A_u60C5_u51B5"><a href="#u62F7_u8D1D_u7684_u7279_u6B8A_u60C5_u51B5" class="headerlink" title="拷贝的特殊情况"></a>拷贝的特殊情况</h3><p>其实，对于拷贝有一些特殊情况：</p>
<ul>
<li>对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有拷贝这一说<ul>
<li>也就是说，对于这些类型，”obj is copy.copy(obj)” 、”obj is copy.deepcopy(obj)”</li>
</ul>
</li>
<li>如果元组变量只包含原子类型对象，则不能深拷贝，看下面的例子</li>
</ul>
<p><img src="/images/14588488582446.jpg" alt=""></p>
<p>总结</p>
<p>本文介绍了对象的赋值和拷贝，以及它们之间的差异：</p>
<ul>
<li>Python中对象的赋值都是进行对象引用（内存地址）传递</li>
<li>使用copy.copy()，可以进行对象的浅拷贝，它复制了对象，但对于对象中的元素，依然使用原始的引用.</li>
<li>如果需要复制一个容器对象，以及它里面的所有元素（包含元素的子元素），可以使用copy.deepcopy()进行深拷贝</li>
<li>对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有被拷贝一说</li>
<li>如果元组变量只包含原子类型对象，则不能深拷贝，看下面的例子</li>
</ul>
<h2 id="Python__u4E2D_self__u7684_u542B_u4E49"><a href="#Python__u4E2D_self__u7684_u542B_u4E49" class="headerlink" title="Python 中 self 的含义"></a>Python 中 self 的含义</h2><p>刚开始学习Python的类写法的时候觉得很是麻烦，为什么定义时需要而调用时又不需要，为什么不能内部简化从而减少我们敲击键盘的次数？</p>
<h3 id="self_u4EE3_u8868_u7C7B_u7684_u5B9E_u4F8B_uFF0C_u800C_u975E_u7C7B_u3002"><a href="#self_u4EE3_u8868_u7C7B_u7684_u5B9E_u4F8B_uFF0C_u800C_u975E_u7C7B_u3002" class="headerlink" title="self代表类的实例，而非类。"></a>self代表类的实例，而非类。</h3><p>实例来说明</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line">        print(self.__class__)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Test object at <span class="number">0x000000000284E080</span>&gt;</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Test</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的例子中可以很明显的看出，self代表的是类的实例。而self.class则指向类。</p>
<h3 id="self_u4E0D_u5FC5_u975E_u5199_u6210self"><a href="#self_u4E0D_u5FC5_u975E_u5199_u6210self" class="headerlink" title="self不必非写成self"></a>self不必非写成self</h3><p>有很多童鞋是先学习别的语言然后学习Python的，所以总觉得self怪怪的，想写成this，可以吗？</p>
<p>当然可以，还是把上面的代码改写一下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(this)</span>:</span></span><br><span class="line">        print(this)</span><br><span class="line">        print(this.__class__)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure>
<p>改成this后，运行结果完全一样。</p>
<p>当然，最好还是尊重约定俗成的习惯，使用self。</p>
<h3 id="self_u53EF_u4EE5_u4E0D_u5199_u5417"><a href="#self_u53EF_u4EE5_u4E0D_u5199_u5417" class="headerlink" title="self可以不写吗"></a>self可以不写吗</h3><p>在Python的解释器内部，当我们调用t.prt()时，实际上Python解释成Test.prt(t)，也就是说把self替换成类的实例。</p>
<p>有兴趣的童鞋可以把上面的t.prt()一行改写一下，运行后的实际结果完全相同。</p>
<p>实际上已经部分说明了self在定义时不可以省略，如果非要试一下，那么请看下面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">()</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure>
<p>运行时提醒错误如下：prt在定义时没有参数，但是我们运行时强行传了一个参数。<br>由于上面解释过了t.prt()等同于Test.prt(t)，所以程序提醒我们多传了一个参数t。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"h.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    t.<span class="function"><span class="title">prt</span><span class="params">()</span></span></span><br><span class="line">TypeError: <span class="function"><span class="title">prt</span><span class="params">()</span></span> takes <span class="number">0</span> positional arguments but <span class="number">1</span> was given</span><br></pre></td></tr></table></figure>
<p>当然，如果我们的定义和调用时均不传类实例是可以的，这就是类方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">()</span>:</span></span><br><span class="line">        print(__class__)</span><br><span class="line">Test.prt()</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<pre><code>&lt;class &apos;__main__.Test&apos;&gt;
</code></pre><p>在继承时，传入的是哪个实例，就是那个传入的实例，而不是指定义了self的类的实例。<br>先看代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pprt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cprt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line">c = Child()</span><br><span class="line">c.cprt()</span><br><span class="line">c.pprt()</span><br><span class="line">p = Parent()</span><br><span class="line">p.pprt()</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__<span class="class">.Child</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A47080&gt;</span><br><span class="line">&lt;__main__<span class="class">.Child</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A47080&gt;</span><br><span class="line">&lt;__main__<span class="class">.Parent</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A47240&gt;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>运行c.cprt()时应该没有理解问题，指的是Child类的实例。</p>
<p>但是在运行c.pprt()时，等同于Child.pprt(c)，所以self指的依然是Child类的实例，由于self中没有定义pprt()方法，所以沿着继承树往上找，发现在父类Parent中定义了pprt()方法，所以就会成功调用。</p>
<p>在描述符类中，self指的是描述符类的实例</p>
<p>不太容易理解，先看实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desc</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, ins, cls)</span>:</span></span><br><span class="line">        print(<span class="string">'self in Desc: %s '</span> % self )</span><br><span class="line">        print(self, ins, cls)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    x = Desc()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'self in Test: %s'</span> % self)</span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br><span class="line">t.x</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self <span class="keyword">in</span> Test: &lt;__main__<span class="class">.Test</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A570B8&gt;</span><br><span class="line">self <span class="keyword">in</span> Desc: &lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000283E208&gt;</span><br><span class="line">&lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000283E208&gt; &lt;__main__<span class="class">.Test</span> <span class="tag">object</span> at <span class="number">0</span>x0000000002A570B8&gt; &lt;class <span class="string">'__main__.Test'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>大部分童鞋开始有疑问了，为什么在Desc类中定义的self不是应该是调用它的实例t吗？怎么变成了Desc类的实例了呢？</p>
<p>注意：此处需要睁大眼睛看清楚了，这里调用的是t.x，也就是说是Test类的实例t的属性x，由于实例t中并没有定义属性x，所以找到了类属性x，而该属性是描述符属性，为Desc类的实例而已，所以此处并没有顶用Test的任何方法。</p>
<p>那么我们如果直接通过类来调用属性x也可以得到相同的结果。</p>
<p>下面是把t.x改为Test.x运行的结果。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self <span class="keyword">in</span> Test: &lt;__main__<span class="class">.Test</span> <span class="tag">object</span> at <span class="number">0</span>x00000000022570B8&gt;</span><br><span class="line">self <span class="keyword">in</span> Desc: &lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000223E208&gt;</span><br><span class="line">&lt;__main__<span class="class">.Desc</span> <span class="tag">object</span> at <span class="number">0</span>x000000000223E208&gt; None &lt;class <span class="string">'__main__.Test'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>题外话：由于在很多时候描述符类中仍然需要知道调用该描述符的实例是谁，所以在描述符类中存在第二个参数ins，用来表示调用它的类实例，所以t.x时可以看到第三行中的运行结果中第二项为<main.test object="" at="" 0x0000000002a570b8="">。而采用Test.x进行调用时，由于没有实例，所以返回None。</main.test></p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>self在定义时需要定义，但是在调用时会自动传入。</li>
<li>self的名字并不是规定死的，但是最好还是按照约定是用self</li>
<li>self总是指调用时的类的实例。</li>
</ul>
<h2 id="Python_u7684_u5185_u5B58_u7BA1_u7406"><a href="#Python_u7684_u5185_u5B58_u7BA1_u7406" class="headerlink" title="Python的内存管理"></a>Python的内存管理</h2><p>以Python语言为例子，说明一门动态类型的、面向对象的语言的内存管理方式。</p>
<h3 id="u5BF9_u8C61_u7684_u5185_u5B58_u4F7F_u7528"><a href="#u5BF9_u8C61_u7684_u5185_u5B58_u4F7F_u7528" class="headerlink" title="对象的内存使用"></a>对象的内存使用</h3><p>赋值语句是语言最常见的功能了。但即使是最简单的赋值语句，也可以很有内涵。Python的赋值语句就很值得研究。</p>
<pre><code>a = 1
</code></pre><p>整数1为一个对象。而a是一个引用。利用赋值语句，引用a指向对象1。Python是动态类型的语言(参考动态类型)，对象与引用分离。Python像使用“筷子”那样，通过引用来接触和翻动真正的食物——对象。</p>
<p>为了探索对象在内存的存储，我们可以求助于Python的内置函数id()。它用于返回对象的身份(identity)。其实，这里所谓的身份，就是该对象的内存地址。</p>
<pre><code>a = 1
print(id(a))
print(hex(id(a)))
</code></pre><p>在我的计算机上，它们返回的是:</p>
<pre><code>11246696
’0xab9c68′
</code></pre><p>分别为内存地址的十进制和十六进制表示。</p>
<p>在Python中，整数和短小的字符，Python都会缓存这些对象，以便重复使用。当我们创建多个等于1的引用时，实际上是让所有这些引用指向同一个对象。</p>
<pre><code>a = 1
b = 1
print(id(a))
print(id(b))
</code></pre><p>上面程序返回</p>
<pre><code>11246696
11246696
</code></pre><p>可见a和b实际上是指向同一个对象的两个引用。</p>
<p>为了检验两个引用指向同一个对象，我们可以用is关键字。is用于判断两个引用所指的对象是否相同。</p>
<pre><code># True
a = 1
b = 1
print(a is b)

# True
a = &quot;good&quot;
b = &quot;good&quot;
print(a is b)

# False
a = &quot;very good morning&quot;
b = &quot;very good morning&quot;
print(a is b)

# False
a = []
b = []
print(a is b)
</code></pre><p>上面的注释为相应的运行结果。可以看到，由于Python缓存了整数和短字符串，因此每个对象只存有一份。比如，所有整数1的引用都指向同一对象。即使使用赋值语句，也只是创造了新的引用，而不是对象本身。长的字符串和其它对象可以有多个相同的对象，可以使用赋值语句创建出新的对象。</p>
<p>在Python中，每个对象都有存有指向该对象的引用总数，即引用计数(reference count)。</p>
<p>我们可以使用sys包中的getrefcount()，来查看某个对象的引用计数。需要注意的是，当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的多1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(getrefcount(a))</span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line">print(getrefcount(b))</span><br></pre></td></tr></table></figure>
<p>由于上述原因，两个getrefcount将返回2和3，而不是期望的1和2。</p>
<p>Python的一个容器对象(container)，比如表、词典等，可以包含多个对象。实际上，容器对象中包含的并不是元素对象本身，是指向各个元素对象的引用。</p>
<p>我们也可以自定义一个对象，并引用其它对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">from_obj</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, to_obj)</span>:</span></span><br><span class="line">        self.to_obj = to_obj</span><br><span class="line"></span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a = from_obj(b)</span><br><span class="line">print(id(a.to_obj))</span><br><span class="line">print(id(b))</span><br></pre></td></tr></table></figure>
<p>可以看到，a引用了对象b。</p>
<p>对象引用对象，是Python最基本的构成方式。即使是a = 1这一赋值方式，实际上是让词典的一个键值”a”的元素引用整数对象1。该词典对象用于记录所有的全局引用。该词典引用了整数对象1。我们可以通过内置函数globals()来查看该词典。</p>
<p>当一个对象A被另一个对象B引用时，A的引用计数将增加1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(getrefcount(a))</span><br><span class="line"></span><br><span class="line">b = [a, a]</span><br><span class="line">print(getrefcount(a))</span><br></pre></td></tr></table></figure>
<p>由于对象b引用了两次a，a的引用计数增加了2。</p>
<p>容器对象的引用可能构成很复杂的拓扑结构。我们可以用objgraph包来绘制其引用关系，比如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [x, dict(key1=x)]</span><br><span class="line">z = [y, (x, y)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> objgraph</span><br><span class="line">objgraph.show_refs([z], filename=<span class="string">'ref_topo.png'</span>)</span><br></pre></td></tr></table></figure>
<p>objgraph是Python的一个第三方包。安装之前需要安装xdot。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="keyword">install</span> xdot</span><br><span class="line">sudo pip <span class="keyword">install</span> objgraph</span><br></pre></td></tr></table></figure>
<p>两个对象可能相互引用，从而构成所谓的引用环(reference cycle)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">b = [a]</span><br><span class="line">a.append(b)</span><br></pre></td></tr></table></figure>
<p>即使是一个对象，只需要自己引用自己，也能构成引用环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">a.append(a)</span><br><span class="line">print(getrefcount(a))</span><br></pre></td></tr></table></figure>
<p>引用环会给垃圾回收机制带来很大的麻烦，我将在后面详细叙述这一点。</p>
<p>某个对象的引用计数可能减少。比如，可以使用del关键字删除某个引用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">print(getrefcount(b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line">print(getrefcount(b))</span><br></pre></td></tr></table></figure>
<p>del也可以用于删除容器元素中的元素，比如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> a[<span class="number">0</span>]</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>如果某个引用指向对象A，当这个引用被重新定向到某个其他对象B时，对象A的引用计数减少:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">print(getrefcount(b))</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">print(getrefcount(b))</span><br></pre></td></tr></table></figure>
<h3 id="u5783_u573E_u56DE_u6536"><a href="#u5783_u573E_u56DE_u6536" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>吃太多，总会变胖，Python也是这样。当Python中的对象越来越多，它们将占据越来越大的内存。不过你不用太担心Python的体形，它会乖巧的在适当的时候“减肥”，启动垃圾回收(garbage collection)，将没用的对象清除。在许多语言中都有垃圾回收机制，比如Java和Ruby。尽管最终目的都是塑造苗条的提醒，但不同语言的减肥方案有很大的差异。</p>
<p>从基本原理上，当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如某个新建对象，它被分配给某个引用，对象的引用计数变为1。如果引用被删除，对象的引用计数为0，那么该对象就可以被垃圾回收。比如下面的表:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> a</span><br></pre></td></tr></table></figure>
<p>del a后，已经没有任何引用指向之前建立的[1, 2, 3]这个表。用户不可能通过任何方式接触或者动用这个对象。这个对象如果继续待在内存里，就成了不健康的脂肪。当垃圾回收启动时，Python扫描到这个引用计数为0的对象，就将它所占据的内存清空。</p>
<p>然而，减肥是个昂贵而费力的事情。垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要总启动垃圾回收。所以，Python只会在特定条件下，自动启动垃圾回收。当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。</p>
<p>我们可以通过gc模块的get_threshold()方法，查看该阈值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">print(gc.get_threshold())</span><br></pre></td></tr></table></figure>
<p>返回(700, 10, 10)，后面的两个10是与分代回收相关的阈值，后面可以看到。700即是垃圾回收启动的阈值。可以通过gc中的set_threshold()方法重新设置。</p>
<p>我们也可以手动启动垃圾回收，即使用gc.collect()。</p>
<p>Python同时采用了分代(generation)回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。</p>
<p>小家伙要多检查</p>
<p>Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。</p>
<p>这两个次数即上面get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。</p>
<p>同样可以用set_threshold()来调整，比如对2代对象进行更频繁的扫描。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">gc.set_threshold(<span class="number">700</span>, <span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>引用环的存在会给上面的垃圾回收机制带来很大的困难。这些引用环可能构成无法使用，但引用计数不为0的一些对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">b = [a]</span><br><span class="line">a.append(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"><span class="keyword">del</span> b</span><br></pre></td></tr></table></figure>
<p>上面我们先创建了两个表对象，并引用对方，构成一个引用环。删除了a，b引用之后，这两个对象不可能再从程序中调用，就没有什么用处了。但是由于引用环的存在，这两个对象的引用计数都没有降到0，不会被垃圾回收。</p>
<p>为了回收这样的引用环，Python复制每个对象的引用计数，可以记为gc_ref。假设，每个对象i，该计数为gc_ref_i。Python会遍历所有的对象i。对于每个对象i引用的对象j，将相应的gc_ref_j减1。</p>
<p>在结束遍历后，gc_ref不为0的对象，和这些对象引用的对象，以及继续更下游引用的对象，需要被保留。而其它的对象则被垃圾回收。</p>
<h3 id="u603B_u7ED3-1"><a href="#u603B_u7ED3-1" class="headerlink" title="总结"></a>总结</h3><p>Python作为一种动态类型的语言，其对象和引用分离。这与曾经的面向过程语言有很大的区别。为了有效的释放内存，Python内置了垃圾回收的支持。Python采取了一种相对简单的垃圾回收机制，即引用计数，并因此需要解决孤立引用环的问题。Python与其它语言既有共通性，又有特别的地方。对该内存管理机制的理解，是提高Python性能的重要一步。</p>
<h2 id="u5B57_u5178_u63A8_u5BFC_28Dictionary_comprehensions_29_u548C_u96C6_u5408_u63A8_u5BFC_28Set_comprehensions_29"><a href="#u5B57_u5178_u63A8_u5BFC_28Dictionary_comprehensions_29_u548C_u96C6_u5408_u63A8_u5BFC_28Set_comprehensions_29" class="headerlink" title="字典推导(Dictionary comprehensions)和集合推导(Set comprehensions)"></a>字典推导(Dictionary comprehensions)和集合推导(Set comprehensions)</h2><p>大多数的Python程序员都知道且使用过列表推导(list comprehensions)。如果你对list comprehensions概念不是很熟悉——一个list comprehension就是一个更简短、简洁的创建一个list的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>some_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>another_list = [ x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> some_list ]</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>another_list</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>自从python 3.1 (甚至是Python 2.7)起，我们可以用同样的语法来创建集合和字典表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="comment"># Set Comprehensions</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>some_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>even_set = &#123; x <span class="keyword">for</span> x <span class="keyword">in</span> some_list <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>even_set</span><br><span class="line">set([<span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="comment"># Dict Comprehensions</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d = &#123; x: x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="number">1</span>: <span class="keyword">False</span>, <span class="number">2</span>: <span class="keyword">True</span>, <span class="number">3</span>: <span class="keyword">False</span>, <span class="number">4</span>: <span class="keyword">True</span>, <span class="number">5</span>: <span class="keyword">False</span>, <span class="number">6</span>: <span class="keyword">True</span>, <span class="number">7</span>: <span class="keyword">False</span>, <span class="number">8</span>: <span class="keyword">True</span>, <span class="number">9</span>: <span class="keyword">False</span>, <span class="number">10</span>: <span class="keyword">True</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个例子里，我们以some_list为基础，创建了一个具有不重复元素的集合，而且集合里只包含偶数。而在字典表的例子里，我们创建了一个key是不重复的1到10之间的整数，value是布尔型，用来指示key是否是偶数。</p>
<p>这里另外一个值得注意的事情是集合的字面量表示法。我们可以简单的用这种方法创建一个集合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>my_set</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>而不需要使用内置函数set()。</p>
<h2 id="Python_u8C03_u7528_u7CFB_u7EDF_u547D_u4EE4_u6216_u8005_u811A_u672C"><a href="#Python_u8C03_u7528_u7CFB_u7EDF_u547D_u4EE4_u6216_u8005_u811A_u672C" class="headerlink" title="Python调用系统命令或者脚本"></a>Python调用系统命令或者脚本</h2><p>使用 os.system() 调用系统命令 , 程序中无法获得到输出和返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>os.system(<span class="string">'ls -l /proc/cpuinfo'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>os.system(<span class="string">"ls -l /proc/cpuinfo"</span>)</span><br><span class="line">  -r--r--r-- <span class="number">1</span> root root <span class="number">0</span>  <span class="number">3</span>月 <span class="number">29</span> <span class="number">16</span>:<span class="number">53</span> /proc/cpuinfo</span><br><span class="line">  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>使用 os.popen() 调用系统命令, 程序中可以获得命令输出，但是不能得到执行的返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>out = os.popen(<span class="string">"ls -l /proc/cpuinfo"</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> out.read()</span><br><span class="line">  -r--r--r-- <span class="number">1</span> root root <span class="number">0</span>  <span class="number">3</span>月 <span class="number">29</span> <span class="number">16</span>:<span class="number">59</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure>
<p>使用 commands.getstatusoutput() 调用系统命令, 程序中可以获得命令输出和执行的返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> commands</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>commands.getstatusoutput(<span class="string">'ls /bin/ls'</span>)</span><br><span class="line">  (<span class="number">0</span>, <span class="string">'/bin/ls'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Python__u6355_u83B7_u7528_u6237_Ctrl+C__2CCtrl+D__u4E8B_u4EF6"><a href="#Python__u6355_u83B7_u7528_u6237_Ctrl+C__2CCtrl+D__u4E8B_u4EF6" class="headerlink" title="Python 捕获用户 Ctrl+C ,Ctrl+D 事件"></a>Python 捕获用户 Ctrl+C ,Ctrl+D 事件</h2><p>有些时候，需要在程序中捕获用户键盘事件，比如ctrl+c退出，这样可以更好的安全退出程序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    do_some_func()</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"User Press Ctrl+C,Exit"</span></span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"User Press Ctrl+D,Exit"</span></span><br></pre></td></tr></table></figure>
<h2 id="Python__u8BFB_u5199_u6587_u4EF6"><a href="#Python__u8BFB_u5199_u6587_u4EF6" class="headerlink" title="Python 读写文件"></a>Python 读写文件</h2><p>一次性读入文件到列表，速度较快，适用文件比较小的情况下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">track_file = <span class="string">"track_stock.conf"</span></span><br><span class="line">fd = open(track_file)</span><br><span class="line">content_list = fd.readlines()</span><br><span class="line">fd.close()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> content_list:</span><br><span class="line">    <span class="keyword">print</span> line</span><br></pre></td></tr></table></figure>
<p>逐行读入，速度较慢,适用没有足够内存读取整个文件(文件太大)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fd = open(file_path)</span><br><span class="line">fd.seek(<span class="number">0</span>)</span><br><span class="line">title = fd.readline()</span><br><span class="line">keyword = fd.readline()</span><br><span class="line">uuid = fd.readline()</span><br><span class="line">fd.close()</span><br></pre></td></tr></table></figure>
<p>写文件 write 与 writelines 的区别   </p>
<ul>
<li>Fd.write(str) : 把str写到文件中，write()并不会在str后加上一个换行符</li>
<li>Fd.writelines(content) : 把content的内容全部写到文件中,原样写入，不会在每行后面加上任何东西</li>
</ul>
<h2 id="u88C5_u9970_u5668"><a href="#u88C5_u9970_u5668" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器使一个函数或方法包装在另一个函数里头，可以在被包装的函数添加一些额外的功能，比如日志，还可以对参数、返回结果进行修改。装饰器有点类似Java中的AOP。下面这个例子是打印被装饰的函数里面的参数的装饰器，  </p>
<pre><code>&gt;&gt;&gt; def print_args(function):
&gt;&gt;&gt;     def wrapper(*args, **kwargs):
&gt;&gt;&gt;         print &apos;Arguments:&apos;, args, kwargs
&gt;&gt;&gt;         return function(*args, **kwargs)
&gt;&gt;&gt;     return wrapper

&gt;&gt;&gt; @print_args
&gt;&gt;&gt; def write(text):
&gt;&gt;&gt;     print text

&gt;&gt;&gt; write(&apos;foo&apos;)
Arguments: (&apos;foo&apos;,) {}
foo
</code></pre><p>@是语法糖，它等价于：  </p>
<pre><code>&gt;&gt;&gt; write = print_args(write)
&gt;&gt;&gt; write(&apos;foo&apos;)
arguments: (&apos;foo&apos;,) {}
foo
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这里收集了一些深入 python 机制的内容。</p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://wdxtub.com/tags/Python/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[个人知识管理指南]]></title>
    <link href="http://wdxtub.com/2016/03/24/self-knowledge-management/"/>
    <id>http://wdxtub.com/2016/03/24/self-knowledge-management/</id>
    <published>2016-03-24T14:14:42.000Z</published>
    <updated>2016-03-24T15:06:19.000Z</updated>
    <content type="html"><![CDATA[<p>经过一年时间打磨，我的个人知识管理体系终于成型，在这里跟大家分享一下。</p>
<a id="more"></a>
<hr>
<p>在这个碎片化的时代，如何『聚合』是有门道的，甚至可以认为是『刚需』。各类门户各类新闻聚合各类资讯文章层出不穷，但是问题在于，作为个人，如何真正把看到的『信息』转化为『知识』呢？</p>
<p>在我之前的文章<a href="http://wdxtub.lofter.com/post/1a7a1d_5d46742" target="_blank" rel="external">《信息极简之道》</a>中，粗略介绍了基于七个不同组件的信息管理工作流，经过大半年的改进，最终形成了<a href="http://wdxtub.com/2016/01/02/cloud-workflow/">《极简解构工作流》</a>中介绍的方法。</p>
<blockquote>
<p>这套工作流的核心，在于『流』，也就是说，所有的一切，都是为了让信息在尽可能少的依赖和限制下自由流动。无论是不同的设备，不同的应用还是不同的形式，信息都应该能以最简单最自然的方式进行流动。并且，我也不希望整套工作流过分依赖某个步骤或者某个应用。</p>
</blockquote>
<p>前面的文章主要说的是思路，这篇文章中会结合实际应用详细介绍具体的工作流程（当然也有一些更新）。</p>
<h2 id="u8BBE_u8BA1_u54F2_u5B66"><a href="#u8BBE_u8BA1_u54F2_u5B66" class="headerlink" title="设计哲学"></a>设计哲学</h2><p>设计哲学主要有四点：极简、GTD、Unix 以及沉淀</p>
<ul>
<li>极简：所用工具简单，适应性稳定性强，对环境的依赖少，关注信息本身，自动完成琐碎繁杂工作，与此同时保持高可拓展性</li>
<li>GTD：规则化任务处理，尽量减少任务选择和切换时的消耗，断舍离，不陷入任务堆积的恶性循环中</li>
<li>Unix：所有信息通过文本文件的方式进行流动，减少了不同步骤和模块间的耦合，每一个步骤和模块都可以根据自己的喜好进行定制</li>
<li>沉淀：提取主题，写系列博客，把知识组织并分享出去</li>
</ul>
<p>根据这样的设计哲学，具体的设计和功能有：</p>
<ul>
<li>文件同步：Dropbox / Box / 百度云 / 金山云盘 / …<ul>
<li>不同文件夹表示不同笔记的类别，不同的笔记保存在不同的文本文件中</li>
<li>采用跨平台的文件同步服务，可以在不同电脑、手机上方便访问自己的笔记</li>
</ul>
</li>
<li>文本编辑：MWeb / Sublime / Atom / Visual Studio Code / Vim / Emacs / …<ul>
<li>基于 Markdown 语法的记录方式，利用文本文件实现不同的逻辑标记</li>
<li>任何文本编辑器都可以，只是显示效果可能有所差别</li>
</ul>
</li>
<li>信息导入：主要是 Kindle <ul>
<li>因为通常在使用 Kindle 进行阅读的时候会记录大量书摘，利用自己编写的信息导入插件，可以方便导出 kindle 书摘（成为文本文件），并无缝对接到知识管理系统中</li>
</ul>
</li>
<li>博客：Hexo / WordPress / …<ul>
<li>博客主要是用于记录和沉淀，并且能够把自己的思考分享出去</li>
</ul>
</li>
<li>随处访问：Github / Web / 手机 / 电脑<ul>
<li>因为基于简单的文件同步机制，所以在不同的平台上，都可以集成各种服务。比如说用 Github 进行版本控制，利用支持云盘同步的 APP 即可在手机上随时查看，博客内容也只需浏览器就可以方便浏览</li>
</ul>
</li>
</ul>
<h2 id="u5E94_u7528_u63A8_u8350"><a href="#u5E94_u7528_u63A8_u8350" class="headerlink" title="应用推荐"></a>应用推荐</h2><p>下面是我用着觉得比较顺手应用，推荐给大家（部分需要付费）</p>
<h3 id="MWeb"><a href="#MWeb" class="headerlink" title="MWeb"></a><a href="http://www.mweb.im/" target="_blank" rel="external">MWeb</a></h3><p><img src="/images/14588310376887.jpg" alt=""></p>
<ul>
<li>平台：Mac</li>
<li>功能：文件夹/文件管理，跨文件检索，即时预览，快捷插入图片，一键生成网站</li>
<li>简介：非常强大美观，可以说一次满足所有愿望，还是国人开发者的作品，良心</li>
</ul>
<h3 id="1Writer"><a href="#1Writer" class="headerlink" title="1Writer"></a><a href="http://1writerapp.com/" target="_blank" rel="external">1Writer</a></h3><p><img src="/images/14588312196908.jpg" alt=""></p>
<ul>
<li>平台：iPhone / iPad</li>
<li>功能：Markdown 支持，Dropbox 同步，文件夹/文件管理，导出 PDF，各种分享方式</li>
<li>简介：当之无愧的最佳，具体可以参考 <a href="http://wdxtub.com/2015/12/08/md-editor-ios/">iOS 上 Markdown 编辑器简评</a></li>
</ul>
<h2 id="Draft"><a href="#Draft" class="headerlink" title="Draft"></a><a href="https://play.google.com/store/apps/details?id=com.mvilla.draft" target="_blank" rel="external">Draft</a></h2><p><img src="/images/14588315888356.jpg" alt=""></p>
<ul>
<li>平台：Android</li>
<li>功能：Markdown 支持，Dropbox 同步，文件夹/文件管理，导出 PDF，各种分享方式</li>
<li>简介：因为小插件的缘故，甚至比 iOS 平台上的体验都好得多</li>
</ul>
<h3 id="Kindle_Voyage"><a href="#Kindle_Voyage" class="headerlink" title="Kindle Voyage"></a>Kindle Voyage</h3><p><img src="/images/14588317350582.jpg" alt=""></p>
<p>没啥好说的，还没买赶紧买买买啊！</p>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a><a href="https://hexo.io/" target="_blank" rel="external">Hexo</a></h3><p><img src="/images/14588317944639.jpg" alt=""></p>
<p>静态网站生成器，可以和 Github 完美对接（免费搭建自己的独立博客），相比其他的平台简单很多，我的博客就是由 hexo 搭建的</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这套工作流基本和工具解耦，能够很方便地根据自己的需要进行配置</p>
<ul>
<li>打通了各个设备的界限。微信订阅号的文章可以统一发送到 Kindle 上，在Kindle 上阅读批注后可以统一导入到电脑中</li>
<li>对操作系统和软件没有要求。整个工作流哪怕在一台全新的电脑上都可以快速展开，文件和文件夹是现代操作系统都有，系统也会自带编辑器和查找功能。唯一的区别就是，自己的电脑可以根据喜好进行配置，但是即使没有这些配置，整个工作流依然可以进行（比方说手头上没有自己电脑的时候）</li>
<li>所有的信息可以通过网络进行访问，无论是 Github 还是 Dropbox 或者是其他的云盘服务，都可以在线查看，只要有网，无论是手机还是电脑，都可以随时访问全部的信息</li>
<li>所有的内容保存在云端，可以方便进行场景的切换，比方说可以在手机上查看和编辑笔记，会自动同步到电脑上，随时可以切换到电脑继续刚才的工作</li>
<li>自动备份冗余：版本控制，更新时间等等都由云端处理，无须自己费心</li>
</ul>
<p>相信大家在具体的实践和摸索中，能找到最适合自己的方式。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>经过一年时间打磨，我的个人知识管理体系终于成型，在这里跟大家分享一下。</p>]]>
    
    </summary>
    
      <category term="信息" scheme="http://wdxtub.com/tags/%E4%BF%A1%E6%81%AF/"/>
    
      <category term="效率" scheme="http://wdxtub.com/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="自由" scheme="http://wdxtub.com/tags/%E8%87%AA%E7%94%B1/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[架与构 1 缘起]]></title>
    <link href="http://wdxtub.com/2016/03/22/arch-build-1/"/>
    <id>http://wdxtub.com/2016/03/22/arch-build-1/</id>
    <published>2016-03-22T19:09:02.000Z</published>
    <updated>2016-03-22T19:58:37.000Z</updated>
    <content type="html"><![CDATA[<p>做架构师是我从刚开始接触计算机科学时的梦想，现在，是时候为了这个梦想而做一些沉淀了。这个系列会写不同的架构概念，写不同的实际系统分析，写自己的想法和思考。</p>
<a id="more"></a>
<hr>
<p>大二的时候，我走到老师的办公室，问了这样一个问题：</p>
<blockquote>
<p>我要怎么样成为一个游戏制作人，或者是一个架构师呢？</p>
</blockquote>
<p>老师当时的反应我还记得，他说这俩职位的差别还是挺大的（中间省略一万字）但是有一点是相同的，就是都要 think different。</p>
<p>这年头，传统意义上的『好』，不如『特别』。所谓『特别』，意味着去想去做别人没想过或者不敢做的事儿，而不是在大家都知道要做的事情上做得最好。</p>
<p>比如说写博客，我不是懂最多的，也不是做得最快的，但是我却是最先开始写课程相关博客的。虽然主要目的其实是强迫自己认真思考所学知识，但是能够给大家提供一点方便，做一个交流和讨论的平台，甚至让有些同学也开始写博客。我觉得这是特别好的事情，可能我自己做不到一百分，但是能让大家都学到八九十分，也许比自己的一百分更重要。</p>
<p>回到正题，这个系列到底要写什么呢？主要分两大部分，一个是架构相关的基本概念介绍（<a href="http://parlab.eecs.berkeley.edu/wiki/patterns/patterns" target="_blank" rel="external">来源</a>），另一个就是结合各大公司公开出来的资料来分析不同业务背后对应的不同架构（主要来源于『聊聊架构』微信公众号）。</p>
<p>具体涉及的知识点主要有：</p>
<p><img src="/images/14586760521793.jpg" alt=""></p>
<p>具体涉及的业务分析有：</p>
<ul>
<li>58 同城架构优化</li>
<li>Etsy 研发体系构建</li>
<li>豆瓣研发管理</li>
<li>蘑菇街运维体系</li>
<li>Qzone 架构设计</li>
<li>当当网架构优化</li>
<li>携程异步消息系统架构设计</li>
<li>支付宝红包高并发</li>
<li>eBay 微服务生态系统</li>
<li>Twitter 高性能分布式日志</li>
<li>LinkedIn 架构演进</li>
<li>Uber 架构重构经验</li>
<li>京东商品搜索系统架构设计</li>
<li>IFTTT 的数据架构</li>
<li>美团架构</li>
<li>Spotify 运维监控体系</li>
<li>酷狗大数据平台重构</li>
<li>魅族云同步架构</li>
<li>微博推荐系统架构</li>
<li>1 号店分布式搜索引擎架构</li>
<li>Airbnb 架构</li>
</ul>
<p>我个人是很希望能写好这个系列的，因为在不断的学习和思考的过程中，能够慢慢培养自己的架构思考模式。另外之所以把这个系列取名为『架与构』，是为了提醒自己设计和实现是不可分割的部分，『架』得再好，『构』不出来也没用。所谓『脚踏实地，仰望星空』，大概就是这个道理。</p>
<p>与诸君共勉。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>做架构师是我从刚开始接触计算机科学时的梦想，现在，是时候为了这个梦想而做一些沉淀了。这个系列会写不同的架构概念，写不同的实际系统分析，写自己的想法和思考。</p>]]>
    
    </summary>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 习题课 5 设计模式练习]]></title>
    <link href="http://wdxtub.com/2016/03/20/sad-r5/"/>
    <id>http://wdxtub.com/2016/03/20/sad-r5/</id>
    <published>2016-03-21T00:43:05.000Z</published>
    <updated>2016-03-21T01:44:11.000Z</updated>
    <content type="html"><![CDATA[<p>这次的作业就是对设计模式的练习和熟悉，直接来看情境吧。</p>
<a id="more"></a>
<hr>
<blockquote>
<p>Does the following code fragment implement the Factory Method design pattern? Explain why.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLReaderFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This method returns an instance of a class</span></span><br><span class="line">    <span class="comment">// that implements the XMLReader interface.</span></span><br><span class="line">    <span class="comment">// The specific class it creates and returns is</span></span><br><span class="line">    <span class="comment">// based on a system property.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> XMLReader <span class="title">createXMLReader</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">XMLReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentHandler</span><span class="params">(ContentHandler handler)</span>:</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(InputStream is)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码片段实现了工厂模式，注释中说明是根据系统属性来进行创建，所以无须传入参数，需要被生成的对象都需要实现 XMLReader 接口。</p>
<blockquote>
<p>Typically, there is a significant performance penalty for declaring a method synchronized. In general adding the keyword synchronized to a method slows the invocation of the method by a factor of 6. A common programming idiom used to avoid synchronization in the common case is double check locking. Can the double-check locking idiom be used with the singleton pattern to avoid synchronizing every time the static instance method is called? For example, is the following valid? Explain why.</p>
</blockquote>
<p>```java<br>public class Singleton {<br>    private Singleton() { }<br>    static private Singleton instance = null;<br>    static public Singleton instance() {<br>        // Double check locking idiom<br>        // The synchronization is done internally<br>        // rather than on the method. This avoids<br>        // the expense of synchronizing for the<br>        // common case.<br>/<em>12</em>/  if( instance == null ) {<br>            synchronized( Singleton.class ) {<br>                // Second check<br>                if( instance == null ) {<br>/<em>16</em>/               instance = new Singleton( );<br>                 }<br>            }<br>        }<br>/<em>20</em>/  return instance;<br>    }<br>}</p>
<p>在大部分情况下代码没有问题，不过为了保险起见，还是要加上 <code>volatile</code> 关键字，不然在下面的情况中就会出问题：</p>
<ol>
<li>线程A发现变量没有被初始化, 然后它获取锁并开始变量的初始化。</li>
<li>由于某些编程语言的语义，编译器生成的代码允许在线程A执行完变量的初始化之前，更新变量并将其指向部分初始化的对象。</li>
<li>线程B发现共享变量已经被初始化，并返回变量。由于线程B确信变量已被初始化，它没有获取锁。如果在A完成初始化之前共享变量对B可见（这是由于A没有完成初始化或者因为一些初始化的值还没有穿过B使用的内存(缓存一致性)），程序很可能会崩溃。</li>
</ol>
<p><a href="https://zh.wikipedia.org/wiki/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">这里</a>有一个很好的参考资料</p>
<blockquote>
<p>Consider the following scenario, please suggest a design pattern and implement it. The outcome should like this:</p>
</blockquote>
<p><img src="/images/14585221758261.jpg" alt=""></p>
<p>In Elizabeth’s day care center, the teacher helps the kids to build all kinds of toys to develop their creative skills. One of Elizabeth’s favorite activities is to make animals with play-dough.</p>
<p>A set of molds is the tool that Elizabeth always uses to create her favorite cool animals.</p>
<p>One mold tool set includes five parts, including the head, body, arm, leg, and tail. Whenever Elizabeth wants to build an animal, she will use one set of each tools to make a head, body , leg, arm, and tail for that animal, and then assembles them with glue to build an animal. There are many types of animal mold tool sets that the kids can choose from.</p>
<p>For example: if Elizabeth wants to make a monkey, then she will pick the set of monkey molds to start.</p>
<ul>
<li>Step 1. Make monkey head.</li>
<li>Step 2. Make monkey body.</li>
<li>Step 3. Make monkey leg.</li>
<li>Step 4. Make monkey arm.</li>
<li>Step 5. Make monkey tail.</li>
</ul>
<p>Once all the five parts are finished, then Elizabeth will glue them all together and decorate it to have a monkey done as a finished product. Most likely, she will give it to her mom as a gift when she picks her (she will not give her the monkey if the monkey is not decorated, since it will not be looking good at all then). When she wants to make a kitten, she follows the same steps with the set of Kitten molds.</p>
<p>这道题目非常简单粗暴，看描述就知道直接使用建造者模式即可，具体的介绍看<a href="http://www.runoob.com/design-pattern/builder-pattern.html" target="_blank" rel="external">这里</a></p>
<p>实现的话这里就不贴代码了，反正是不难的。</p>
<blockquote>
<p>You are working on software that interacts with a new hardware device and are anxious to test against the actual hardware. The hardware manufacture has a beta version of the driver they plan to release but is warning the interface of the device driver could change between now and the release date. The device driver is used throughout your code and you are concerned about writing code to an interface that is subject to change. What design pattern can be used to mitigate the risks involved? Describe what the risks are and how the design pattern mitigates these risks.</p>
</blockquote>
<p>这个其实也比较简单，直觉反应就是适配器模式，用来做不同接口的转换。</p>
<blockquote>
<p>In keeping with the holiday theme, use the Decorator design pattern to model a Christmas tree as a base component (the tree) and optional decorations or adornments such as bulbs, candy and garland. Initially it’s enough for your solution to model just the printing or display of the tree along with its adornments. You can also assume that each type of decoration is added all at once.</p>
</blockquote>
<p><img src="/images/14585236303062.jpg" alt=""></p>
<p>Show the class diagram for your solution and the runtime organization of objects for different configurations of adornments.</p>
<p>这里题目已经指名说要用装饰器模式，就按照<a href="http://www.runoob.com/design-pattern/decorator-pattern.html" target="_blank" rel="external">这里</a>的方法设计一下即可，我就不啰嗦了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这次的作业就是对设计模式的练习和熟悉，直接来看情境吧。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="习题" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 习题课 6 Malloclab]]></title>
    <link href="http://wdxtub.com/2016/03/20/csapp-lab6/"/>
    <id>http://wdxtub.com/2016/03/20/csapp-lab6/</id>
    <published>2016-03-20T21:10:37.000Z</published>
    <updated>2016-03-24T12:58:59.000Z</updated>
    <content type="html"><![CDATA[<p>在这个实验中，我们会实现自己的 <code>malloc</code>, <code>free</code>, <code>realloc</code>, <code>calloc</code> 函数，并借此深入理解堆中的内存分配机制。</p>
<a id="more"></a>
<hr>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>老套路</p>
<ul>
<li>上传文件 <code>scp malloclab-handout.tar dawang@shark.ics.cs.cmu.edu:~/513</code></li>
<li>登录 <code>ssh -X dawang@shark.ics.cs.cmu.edu</code></li>
<li>解压 <code>tar xvf malloclab-handout.tar</code></li>
</ul>
<p>因为我比较习惯在本地写代码，所以把文件复制回来：</p>
<ul>
<li>服务器至本地<ul>
<li><code>scp -r dawang@shark.ics.cs.cmu.edu:~/513/malloclab-handout/mm* ./</code></li>
</ul>
</li>
<li>本地至服务器<ul>
<li><code>scp ./mm.c dawang@shark.ics.cs.cmu.edu:~/513/malloclab-handout/</code></li>
</ul>
</li>
</ul>
<p>我们需要做的是完成在 <code>mm.c</code> 中的以下几个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(size_t size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, size_t size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(size_t nmemb, size_t size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_checkheap</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>mm-naive.c</code> 中有一个简单的实现，另外 <code>mm-textbook.c</code> 中实现了课本中提到的 implicit list allocator。具体的函数介绍如下：</p>
<ul>
<li><code>mm-init</code>：在这里执行所有的初始化操作，包括分配初始的堆区域。注意，必须在这里重新初始化所有的全局变量，并且不要调用 <code>mem.init</code> 函数。成功的话返回 0 ，否则返回 -1</li>
<li><code>malloc</code>：至少需要分配 <code>size</code> 这么大的空间（可能因为对齐的原因会更大一点，8 byte 对齐），不能超出堆的范围，也不能覆盖其他已分配的区域</li>
<li><code>free</code>：释放 <code>ptr</code> 指针指向的区域（这个区域必须是已分配的），<code>free(NULL)</code> 什么都不做</li>
<li><code>realloc</code>：重新分配，根据传入指针的不同，有不同的表现<ul>
<li><code>ptr</code> 为 NULL 时，等同于 <code>malloc(size)</code></li>
<li><code>size</code> 为 0 时，等同于 <code>free(ptr)</code>，需要返回 NULL</li>
<li><code>ptr</code> 不为 NULL 时，一定是指向一个已分配的空间的，就根据新的 size 的大小进行调整，并让 <code>ptr</code> 指向新的地址（如果是新地址的话），并且旧的区域应该被释放。另外需要注意的是，需要把原来 block 的值复制过去  </li>
</ul>
</li>
<li><code>calloc</code>：分配一个有 <code>nmemb</code> 个大小为 <code>size</code> 的数组，这个函数不评分，只要简单实现即可</li>
<li><code>mm_checkheap</code>：扫描堆并检查其状态，注意，只有在检测到错误时才输出内容并调用 <code>exit</code> 退出。<code>mm_heapchecker(__Line__);</code> 传入的参数是当前行数，方便大家找到错误位置。</li>
</ul>
<p><code>memlib.c</code> 模拟了内存系统，可以调用下面的方法来得到响应的信息：</p>
<ul>
<li><code>void *mem_sbrk(int incr)</code>：让堆扩展 <code>incr</code> 个字节，并返回新分配的地址的头指针</li>
<li><code>void *mem_heap_lo(void)</code>：返回指向堆的第一个字节的指针</li>
<li><code>void *mem_heap_hi(void)</code>：返回指向堆的最后一个字节的指针</li>
<li><code>size_t mem_heapsize(void)</code>：返回当前的堆大小</li>
<li><code>size_t mem_pagesize(void)</code>：返回系统的 page size</li>
</ul>
<p>head checker 需要做的工作有：</p>
<ul>
<li>检查堆(implicit list, explicit list, segregated list)<ul>
<li>Check epilogue and prologue blocks</li>
<li>Check each block’s address alignment</li>
<li>Check heap boundaries</li>
<li>Check each block’s header and footer: size(minimum size, slignment), previous/net allocate/free bit consistency, header and footer matching each other</li>
<li>Check coalescing: no two consecutive free blocks in the heap</li>
</ul>
</li>
<li>检查 free list(explicit list, segregated list)<ul>
<li>All next/previous pointer are consistent (is A’s next pointer points ot B, B’s previous pointer should point to A)</li>
<li>All free list pointers points between <code>mem_heap_lo()</code> and <code>mem_heap_hi()</code></li>
<li>Count free blocks by iterating through every block and traversing free list by pointers and see if they match</li>
<li>All blocks in each list bucket fall within bucket size range(segregated list) </li>
</ul>
</li>
</ul>
<p>需要注意的地方：</p>
<ul>
<li>不能改动 <code>mm.h</code>，但是可以在 <code>mm.c</code> 中添加 <code>static</code> 方法使代码更好理解</li>
<li><code>mm.c</code> 中不能定义任何全局 array, tree 或 list，但是可以定义全局 struct 和诸如 integer, float 和 pointer 等变量</li>
<li>返回的指针必须是 8-byte 对齐的</li>
<li>编译代码不能有警告</li>
<li>建议先实现 explcit free list</li>
<li>代码开头写注释说明思路，也要写上 ID 和名字</li>
</ul>
<h2 id="u63D0_u793A_u4E0E_u6D4B_u8BD5"><a href="#u63D0_u793A_u4E0E_u6D4B_u8BD5" class="headerlink" title="提示与测试"></a>提示与测试</h2><ul>
<li>因为是 64 位机器，所以指针的大小是 8 字节</li>
<li><code>sizeof(size_t) == 8</code></li>
<li><code>gprof</code> 工具可能会很有用</li>
<li>三种组织 free block 的方法：implicit free list, explicit free list, segregated free list</li>
<li>三种扫描 free block 的方法：first fit/next fit, blocks sorted by address with first fit, best fit</li>
<li>可以随机用上面的方法排列组合</li>
<li>可以根据 implicit free list（在 <code>mm-textbook.c</code> 中）来实现 explicit free list，然后实现 segregated list</li>
</ul>
<p>可以通过 <code>mdriver.c</code> 来进行测试，每个测试会跑 12 次，一次检测正确性，一次检测空间使用，十次测试性能，下面是具体的参数：</p>
<ul>
<li><code>-p</code>：完整测试</li>
<li><code>-t &lt;tracedir&gt;</code>：在自定义的文件夹中搜索测试文件</li>
<li><code>-f &lt;tracefile&gt;</code>：进行一个特定的测试</li>
<li><code>-c &lt;tracefile&gt;</code>：执行特定的测试 1 次，用来检测正确性很方便</li>
<li><code>-h</code>：输出命令行参数</li>
<li><code>-l</code>：用真实的 <code>malloc</code> 函数来测试，可以比较自己写的代码和系统代码的差距</li>
<li><code>-V</code>：输出各种信息</li>
<li><code>-v &lt;verbose level&gt;</code>：设置需要输出的日志等级</li>
<li><code>-d &lt;i&gt;</code>： 有 0,1,2 三个层级，检查的标准越来越严格</li>
<li><code>-D</code>：等于 <code>-d2</code></li>
<li><code>-s &lt;s&gt;</code>：超过 s 秒则认为是超时，默认是永远不会超时的</li>
</ul>
<p>主要的考察目标是空间使用率以及吞吐量（每秒钟执行的操作数目）</p>
<h2 id="u89E3_u9898_u601D_u8DEF"><a href="#u89E3_u9898_u601D_u8DEF" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目中给出了一个提示，说堆的大小不会超过 $2^32$ 字节，这个是什么意思呢？其实很简单，我们知道 64 位机器中指针的长度是 8 个字节（八八六十四），但是因为堆的大小是有上限的，理论上来说，只要 4 个字节就可以完成整个空间的寻址（只需要记录偏移量即可），这样一来，用来保存结构信息的部分只需要原来的一半，内存的有效使用率自然就上去了。（不过具体作业的时候因为我主要参考 <code>mm-textbook.c</code> 中的代码，就没有另外做 4 字节寻址的版本了）</p>
<p>如果有仔细看习题课视频的话，其实助教已经讲得非常清楚了，我的建议如下：</p>
<ul>
<li><code>mm-naive.c</code> 很短，一下就可以看完，用来热身</li>
<li><code>mm-textbook.c</code> 基本上包括各种所需的宏以及存储结构，一定要好好理解清楚</li>
<li>确定了具体保存信息的数据结构之后，一定要先完成 heap checker</li>
<li>遇到段错误的时候就需要利用 heap checker 找到具体问题所在了</li>
<li>最好画简单的示意图，对照着来编码，不然很容易乱</li>
<li>很多时候需要用到位操作，确保每个基本操作都没有错（如果用 <code>mm-textbook.c</code> 中的就不用担心这个）</li>
<li>列表的粒度越细，利用率就越高，但是最好的优化还是从数据结构入手</li>
</ul>
<p>最后要说的是不用自定义的数据结构应该很难做到 100 分，但是 90 分是没有问题的。</p>
<h2 id="u57FA_u7840_u77E5_u8BC6_u590D_u4E60"><a href="#u57FA_u7840_u77E5_u8BC6_u590D_u4E60" class="headerlink" title="基础知识复习"></a>基础知识复习</h2><h3 id="u5B8F_u4E0E_u5185_u8054_u51FD_u6570"><a href="#u5B8F_u4E0E_u5185_u8054_u51FD_u6570" class="headerlink" title="宏与内联函数"></a>宏与内联函数</h3><p>宏实际上是一个简单的『查找并替换』的过程，会在编译前完成。一般用来定义常量以及简单的操作（这里很容易出错，下面会说）。</p>
<p>定义常量比较简单：<code>#define NUM_ENTRIES 100</code> 即可。</p>
<p>定义简单操作则需要注意，比如 <code>#define twice(x) 2*x</code> 这样写就是会出问题的，如果在代码中调用 <code>twice(x+1)</code> 期望得到的结果应该是 <code>2x+2</code>，但是因为宏只是简单的替换，所以会变成 <code>2x+1</code>。解决办法是一定要用括号包裹住会被替换的值，比如之前的例子应该改写成 <code>#define twice(x) (2*(x))</code>。</p>
<p>使用宏，可以避免函数调用，也就少了很多跳转和对应的栈处理。对于 <code>malloc</code> 来说，可以通过宏快速访问 header 信息（例如 payload size, valid）</p>
<p>宏的缺点也同样明显，能够执行的操作不如函数那么强大，并且不会进行拼写和类型检查，很容易出错，出错了也不容易找到问题所在。</p>
<p>内联函数会在编译的时候被写入到代码中，同样因为不需要真实的函数调用，所以效率也很高。一般来说，比较小的函数都可以设置为内联。</p>
<p>两者之间的差别在于：</p>
<ul>
<li>宏在编译前处理</li>
<li>内联函数在编译时处理（带有类型检查）</li>
<li>宏不能有返回值</li>
<li>宏可能会带来一些副作用</li>
<li>很难调试宏</li>
</ul>
<p>具体到这次作业：</p>
<ul>
<li>两个都需要使用</li>
<li>宏适合做小的工作，比方说让代码更加容易理解</li>
<li>如果宏没有办法完成，先考虑使用内联函数</li>
</ul>
<h3 id="u6307_u9488_u590D_u4E60"><a href="#u6307_u9488_u590D_u4E60" class="headerlink" title="指针复习"></a>指针复习</h3><p>指针恐怕是 C 语言最难的一部分了，这里会尽量解释得清楚一些。</p>
<p>先来看看类型转换可能带来的问题：</p>
<ul>
<li>从 <code>&lt;type_a&gt;*</code> 转换到 <code>&lt;type_b&gt;*</code>（一个类型的指针转换为另一个类型的指针）<ul>
<li>值并不会改变</li>
<li>改变的是解析引用的行为，比方说原来是 int 指针，那么一次会读 4 个字节，现在转换成了 char 指针，一次就读 1 个字节（这里具体的字节数看是 32 位还是 64 位系统）</li>
</ul>
</li>
<li>从 <code>&lt;type_a&gt;*</code> 转换到 integer / unsigned int<ul>
<li>指针的值实际上就是 8 字节的数字</li>
<li>这是一个很值得利用的特性！</li>
<li>不过也很容易出错就是了</li>
</ul>
</li>
<li>从 integer / unsigned int 转换到 <code>&lt;type_a&gt;*</code><ul>
<li>这种情况基本不会使用，因为没人知道转换后的指针会指向什么地方</li>
</ul>
</li>
</ul>
<p>对于指针进行算术运算时，一定要注意跟指针本身的类型是有关的，比方说</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type_a* pointer = ...;</span><br><span class="line">(<span class="keyword">void</span> *) pointer1 = (<span class="keyword">void</span> *)(pointer + a);</span><br></pre></td></tr></table></figure>
<p>实际上进行的运算是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer1 = pointer + (a * sizeof(type_a))</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea (pointer, a, sizeof(type_a)), pointer1</span><br></pre></td></tr></table></figure>
<p>这里需要注意，如果一个指针的类型是 <code>void *</code>，那么是不能对其进行算术操作的，因为我们没办法确定其大小。</p>
<p>下面是具体的几个例子，一定要仔细理解：</p>
<p><img src="/images/14585171655720.jpg" alt="Pointer arithmetic"></p>
<p><img src="/images/14585171934388.jpg" alt="More pointer arithmetic"></p>
<p>我们不能够对空指针进行解引用，来看一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">*ptr1 = <span class="number">0xdeadbeef</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val1 = *ptr1;</span><br><span class="line"><span class="keyword">int</span> val2 = (<span class="keyword">int</span>) *((<span class="keyword">char</span> *) ptr1);</span><br></pre></td></tr></table></figure>
<p>那么 <code>val1</code> 和 <code>val2</code> 的值分别是什么呢？</p>
<p><code>val1</code> 的值比较简单，因为没有改动，所以就是 <code>0xdeadbeef</code>，不过 <code>val2</code> 的值就比较特别了，我们具体来看一看，首先指针 <code>ptr1</code> 被转换成了 <code>char</code> 指针，按照小端规则，指针指向的值变成了 <code>0xef</code>，解引用之后在转换成 <code>int</code> 类型，前面会补上 <code>ffffff</code>，最后就是 <code>0xffffffef</code></p>
<h3 id="Malloc"><a href="#Malloc" class="headerlink" title="Malloc"></a>Malloc</h3><p>需要知道的概念：</p>
<ul>
<li>malloc / calloc / realloc</li>
<li>free</li>
<li>sbrk</li>
<li>payload</li>
<li>framentation (internal vs. external)</li>
<li>colescing<ul>
<li>Bi-directional</li>
<li>Immediate vs. Deferred</li>
</ul>
</li>
</ul>
<p>在 paylaod 比 block size 小的时候就会产生内部碎片，比方说</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *m1 = <span class="built_in">malloc</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">void</span> *m2 = <span class="built_in">malloc</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>因为 m1 和 m2 都需要以 8 bytes 对齐，所以都会有 5 个 bytes 的内部碎片。</p>
<p>实现是需要考虑的问题有：</p>
<ul>
<li>怎么知道 block 在哪里</li>
<li>怎么知道 block 多大</li>
<li>怎么知道 block 是否 free</li>
<li>注意：不能缓存 malloc/free 调用，必须实时处理</li>
<li>注意：调用 free 的时候只传入一个指针，不会有表示 size 的参数</li>
<li>我们需要一个数据结构来存储关于 block 的相关信息</li>
</ul>
<p>这个数据结构需要做到：</p>
<ul>
<li>block 的位置，block 的大小，以及 block 是否 free</li>
<li>在 malloc/free 调用的时候，需要能够改变这个数据结构</li>
<li>需要通过这个数据结构找到下一个合适的 block</li>
<li>能够快速标记一个 block 是 free 还是 allocated</li>
<li>能够检测是否有足够空间</li>
</ul>
<p>具体怎么实现就需要自己思考了，唯一需要注意的是内存就是我们存放这些信息的地方。课堂上介绍过三种方式：</p>
<p><img src="/images/14585192291308.jpg" alt="Common types"></p>
<p>最好实现一个堆检查器，方便我们写程序，具体如下：</p>
<p><img src="/images/14585192921490.jpg" alt="Headp Checker"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这个实验中，我们会实现自己的 <code>malloc</code>, <code>free</code>, <code>realloc</code>, <code>calloc</code> 函数，并借此深入理解堆中的内存分配机制。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="MallocLab" scheme="http://wdxtub.com/tags/MallocLab/"/>
    
      <category term="习题课" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98%E8%AF%BE/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[How to Write Fast Code 第 4 课 并行架构]]></title>
    <link href="http://wdxtub.com/2016/03/20/fastcode-4/"/>
    <id>http://wdxtub.com/2016/03/20/fastcode-4/</id>
    <published>2016-03-20T15:02:43.000Z</published>
    <updated>2016-03-20T19:27:09.000Z</updated>
    <content type="html"><![CDATA[<p>前面我们了解了并行程序的基本概念和写法，这节课我们从更大的角度来思考，如何去设计一个并行架构。</p>
<a id="more"></a>
<hr>
<p>这节课会涉及大量架构和设计模式的内容，具体可以参考我另一门课程的笔记。</p>
<p>假如我们要设计一个自动语音识别系统，我们需要考虑的东西至少有：</p>
<ul>
<li>算法的实现</li>
<li>并行处理</li>
<li>软件架构</li>
<li>硬件架构</li>
</ul>
<blockquote>
<p>A parallel software pattern is genralizable solution to a class of recurring problems that occurs in the design of parallel software</p>
</blockquote>
<p>主要的设计目标有三个：</p>
<ul>
<li>Define a set of vocabularies to communicate</li>
<li>Present a set of expert techniques for beginners to learn</li>
<li>Allows experts to more quickly design complex systems</li>
</ul>
<p>大的组织架构如下：</p>
<p><img src="/images/14585015567179.jpg" alt="OPL: The Organization"></p>
<p>上图中可以看到，有两种模式：结构模式与计算模式</p>
<blockquote>
<p>Structual Patterns define the structure of the SW but not what is computed</p>
</blockquote>
<p><img src="/images/14585016310482.jpg" alt="Identifying the SW Structure"></p>
<p>一些例子：</p>
<ul>
<li>Pipe and Filter</li>
<li>Iterative Refinement</li>
<li>MapReduce</li>
<li>还有很多，具体参考 CMU 18653 的笔记</li>
</ul>
<blockquote>
<p>Computational patterns describe the key computation but not how they are implemented.</p>
</blockquote>
<p><img src="/images/14585017094760.jpg" alt="Identifying Key Computations"></p>
<p>一些例子：</p>
<ul>
<li>Linear Algebra</li>
<li>Spectral Methods</li>
<li>Dynamic Programming</li>
<li>还有很多，具体是偏领域相关的</li>
</ul>
<p>最后可以用一张图总结</p>
<p><img src="/images/14585019273135.jpg" alt="A Pattern Language for Parallel Programming"></p>
<p>不同的描述模式的语言有很多，这里使用的是 OPL，具体的网址在<a href="http://parlab.eecs.berkeley.edu/wiki/patterns/patterns" target="_blank" rel="external">这里</a></p>
<p>这部分知识对于理解整个架构的概念很有帮助，我会专门新开一个系列来介绍这里的内容。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面我们了解了并行程序的基本概念和写法，这节课我们从更大的角度来思考，如何去设计一个并行架构。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构设计" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[How to Write Fast Code 第 3 课 Manycore 编程]]></title>
    <link href="http://wdxtub.com/2016/03/20/fastcode-3/"/>
    <id>http://wdxtub.com/2016/03/20/fastcode-3/</id>
    <published>2016-03-20T15:02:37.000Z</published>
    <updated>2016-03-20T15:54:54.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们主要来了解一下基于 CUDA 平台的 GPU 编程。</p>
<a id="more"></a>
<hr>
<p>首先需要理解的概念就是，CPU 中的每个核都很强大，但是 GPU 中的每个核都比较弱。下面是一个很好的类比：</p>
<p><img src="/images/14584867243585.jpg" alt="Multicore and Manycore Differences"></p>
<p>换成更清晰的设计图，更能体现两者的不同：</p>
<p><img src="/images/14584867762217.jpg" alt="Fundamentally different design philosophy"></p>
<p>对于 CPU 来说，具体的优化是针对于减小若干线程的执行延迟的，包含复杂的指令控制和较大的缓存，每个核心能够以极高的速度执行单一线程。</p>
<p>对于 GPU 来说，目的是提高并行数量，主要目标是提高总体的吞吐量，而不是某个具体核心的性能。下面是一个简单的比较：</p>
<p><img src="/images/14584869755317.jpg" alt="Significant Architectural Difference"></p>
<p>什么时候适合使用 GPU 呢？</p>
<ul>
<li>极高的并行计算数量，比方说需要同时计算几千个节点的状态</li>
<li>计算时对内存带宽有极高的要求，因为 GPU 的内存更大更快，所以往往会有更好的性能</li>
</ul>
<h2 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h2><p>CUDA 的全程是 Compute Unified Device Architecture，是一个由 NVIDIA 开发的并行计算框架。整个计算的流程大概是：</p>
<p><img src="/images/14584873704074.jpg" alt=""></p>
<p>串行和简单的并行部分在 host 中完成，高度并行的代码在 GPU 的 kernel 中执行。</p>
<p>这里说一下，我们知道 GPU 本质工作还是计算图形相关的东西，所以其架构决定了每个内核只能执行非常有限的工作（例如着色器渲染器这类计算量大但是不复杂的工作），我们在利用 CUDA 编程的时候，实际上最终也还是类似于渲染画面之类的感觉，只是结果不是图像，而是具体的数据了。</p>
<h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p>关于 GPU 的架构，有一个很有趣的地方，就是对应的 memory hierarchy 和 CPU 是相反的，如：</p>
<p><img src="/images/14584875853095.jpg" alt="NVIDIA Fermi Architecture"></p>
<p>寄存器 &gt; L1 缓存 &gt; L2 缓存，这是为什么呢？是为了解决现在处理器的速度和内存的速度相差越来越大的问题：</p>
<p><img src="/images/14584876919855.jpg" alt="Inversion in Mem Hierarchy"></p>
<p>为了利用好这些缓存，Fermi 内核会维护 48 个 warp，每个 warp 是一个用于计算的 32 位 SIMD 向量。每个线程大约有 20 个寄存器，我们来算一下：</p>
<p>4(Bytes/register) x 20(Registers) x 32 (SIMD lanes) x 48 (Warps) = 128KB/core x 16 (core) = 2MB register files</p>
<p>这也就是为什么有 2MB 的寄存器大小了。</p>
<p>使用 warp 作为计算单位可以认为是为了简化 GPU 编程模型所做的设计（毕竟和 CPU 会有很大不同），前面我们也看到，不同的核心数目其实跟寄存器大小都是有关的，也就是说，GPU 编程仍然是一个非常硬件相关的工作：</p>
<p><img src="/images/14584880244271.jpg" alt="不同的硬件配置"></p>
<h2 id="Thread_Block"><a href="#Thread_Block" class="headerlink" title="Thread Block"></a>Thread Block</h2><p>为了配合不同的硬件，并行的工作实际上是以线程块的形式来组织的，下面的例子中，对于 2 个核心的 GPU，每次执行倆；对于 4 个核心的，每次执行四个：</p>
<p><img src="/images/14584881432861.jpg" alt="Thread Blocks"></p>
<p>然后我们来看看具体的数据是如何存储的。首先每个核心都有自己的存储，在同一个 SIMD lane 进行计算的核心可以通过内存读写来进行交流。</p>
<p><img src="/images/14584882728749.jpg" alt="Shared Memory/L1 Cache"></p>
<p> 对于 Fermi 架构的 GPU 来说，有两种不同的配置：</p>
<ul>
<li>48KB scratch pad (Shared Memory), 16KB L1 cache</li>
<li>16KB scratch pad (Shared Memory), 48KB L1 cache</li>
</ul>
<p>具体编程的部分这里不再一一赘述，只列出一些关键的要点，提醒大家注意：</p>
<ul>
<li>什么工作在 CPU 里做，什么工作在 GPU 里做？</li>
<li>如何高效使用共享内存？</li>
<li>如何给 GPU 指定具体的工作？</li>
<li>如何保证线程同步？</li>
<li>如何保证操作的原子性？</li>
</ul>
<p>具体的执行模型是：</p>
<p><img src="/images/14584884803363.jpg" alt="The CUDA Platform"></p>
<p>其中：</p>
<ul>
<li>NVCC 是编译器，会调用需要调用的各种程序</li>
<li>NVCC 会输出给 CPU 执行的 C 代码，还需要进一步编译</li>
<li>还会输出 PTX，是对象代码，直接在 GPU 上进行执行</li>
</ul>
<p>更多的内容可以参考官网的指引（比较有时效性）</p>
<h2 id="u6027_u80FD_u8003_u8651"><a href="#u6027_u80FD_u8003_u8651" class="headerlink" title="性能考虑"></a>性能考虑</h2><p>有三个考量，这里大概列出具体的思路，细节请大家自己探究：</p>
<ul>
<li>Maximizing Memory Throughput<ul>
<li>SoA vs AoS</li>
<li>Memory coalescing</li>
<li>Use of Shared memory</li>
<li>Memory bank conflict</li>
<li>Padding</li>
</ul>
</li>
<li>Maximizing Instruction Throughput<ul>
<li>尽量减少分支部分的代码</li>
<li>Loop unrolling </li>
</ul>
</li>
<li>Maximizing Scheduling Throughput<ul>
<li>对于数学运算，可以使用 GPU 相关的函数，如下图所示</li>
</ul>
</li>
</ul>
<p><img src="/images/14584888892692.jpg" alt="SoA vs AoS"></p>
<p>根据应用的不同设计，看看这两种结构到底哪种更加适合</p>
<p><img src="/images/14584890246660.jpg" alt="Device-only CUDA intrinsic functions"></p>
<p>这一部分的内容最重要的是实践，一定要通过不断尝试理解具体的概念，不然真的会发现自己完完全全是纸上谈兵！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们主要来了解一下基于 CUDA 平台的 GPU 编程。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="CUDA" scheme="http://wdxtub.com/tags/CUDA/"/>
    
      <category term="GPU" scheme="http://wdxtub.com/tags/GPU/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【辐射系列】历史、剧情与避难所]]></title>
    <link href="http://wdxtub.com/2016/03/20/fallout/"/>
    <id>http://wdxtub.com/2016/03/20/fallout/</id>
    <published>2016-03-20T14:49:48.000Z</published>
    <updated>2016-03-20T14:52:29.000Z</updated>
    <content type="html"><![CDATA[<p>军争之难者，以迂为直，以患为利。故迂其途，而诱之以利，后人发，先人至，此知迂直之计者也。</p>
<a id="more"></a>
<hr>
<h2 id="u5386_u53F2"><a href="#u5386_u53F2" class="headerlink" title="历史"></a>历史</h2><p>1947年：未被发明的晶体管改变了一切 1947年以前，《辐射》世界与你所了解的本时空历史完全相同。农业文明的建立，历次革命的爆发，第一次世界大战打响了结束了，第二次世界大战又被1945年8月落在日本的两颗原子弹所终结……时间线变故的第一个真实迹象出现在1947年，尽管它并不起眼，实际上当年的《辐射》宇宙中并未发生什么特别有趣的事件。而之所以把它认定为蝴蝶的翅膀，是因为人们没有像本时空里一样，在这一年发明出晶体管。 如果你不知道晶体管是什么，不知道晶体管为什么很重要，那么可以简单感受一下，此刻你能够阅读本文就要拜这些用途广泛的小元件所赐。它是现代电子工业的基础，使人们几乎能为所有东西开发出更小巧、更廉价的款式。晶体管让笔记本电脑的出现成为可能，它为微处理器的研发铺平了道路，否则你永远不可能把计算机装进口袋。 但是在《辐射》世界里，晶体管一直要等到2067年方才问世，这意味着社会结构翻天覆地的变化。因此《辐射》世界里的计算机体量才显得那么庞大，数据存储在磁带上，屏幕界面单调得不得了。说实在的，有人认为《辐射》世界看起来像被锁进了50年代的囚笼；没错，从技术上讲，它确实如此。</p>
<p>1961年：NASA不复存在，卡尔·贝尔成为进入太空第一人 巨大的技术差异出现之后，本时空与《辐射》世界未来几十年内的时间线走势仍然保持了大体一致；前者拥有体积更小的收音机，但这尚不足以对国际事务造成严重影响。“太空竞赛”开始后，临界时刻出现在1961年：当年5月5日，卡尔·贝尔搭乘“迪法恩斯7号”进入太空，在葬身归途之前成为第一个离开地球大气层的人类。</p>
<p>这事儿听起来好像是高中历史课本里早已被你遗忘的一件琐事，然而我可以明确地告诉你，它并不是，因为压根儿就不存在卡尔·贝尔这个人。实际上，第一个太空人是苏联宇航员尤里·加加林，他在1961年4月16日升空，但在《辐射》时间线上，不会再有这次发射了。此外，NASA与“阿波罗11号”（尼尔·阿姆斯特朗搭乘的第一艘载人登月飞行器）双双消失，取而代之的是美国宇航局（USSA）与“勇士11号”。美国仍然把人类送上了月球，但在此之前……</p>
<p>1969年：美国被划分为13个联邦 如果说晶体管的缺失与卡尔·贝尔的出现是时光轨道上无意义的轰鸣，那么美利坚合众国的联邦分区就像一辆高速列车般碾碎了我们熟知的历史。在冷战与赤化恐慌中，美国为确保自身免受东方阵营侵占采取了许多激烈措施，最终将国家分成13个不同的区划。 最初，这只是一套重组策略，划分国家以使各地区在资本主义光环笼罩下更好地发展，消弭共产主义的威胁。但是联邦政府能够支配的资源过于有限，各联邦为了自身利益迅速掀起内斗。为取得国家最高当局的特别关注，持续将近一个世纪的明争暗夺由此开始，并随着石油资源日趋枯竭而不断加剧。</p>
<p>2037年：“巧手先生”系列机器人投放市场 为避免机器人因外观与人类过于相似而落入“恐怖谷”，通用原子能国际公司（General Atomics International）发布了“巧手先生”（Mister Handy）系列机器人，它看起来像章鱼和童年时你幻想隐藏在床板下的怪物的组合体。巧手先生的火箭推进力量是普通人类的两倍，精悍的魅力抵得过4只壮汉，该系列成为美国与墨西哥地区销量最高的机器人管家品牌，得到了一般家庭的广泛接受。 巧手先生的风靡还催生了戈德弗雷（Godfrey）、沃兹沃斯（Wadsworth）与科兹沃斯（Codsworth）等各类型号。呃哼！（严肃脸）这些型号以核能驱动，可以自我修复，当不可预测的核事故发生时，可以充当最好的人类管家。</p>
<p>2044年：核子可乐的诞生、换味与流行 美国民众因为整天担心核弹会从天而降砸破自己的天花板，所以总感到焦躁不安，他们极其渴望一种荣耀、振奋的资本主义象征，好把忧虑一扫而空。于是在2044年，混合了12种不同水果口味的碳酸饮料——核子可乐诞生了。 而就在当年，因为发生了西番莲水果大饥荒（the Great Passion Fruit Famine），这一味关键的原料不得不被除去，核子可乐的风味产生了巨大变化。但是粉丝们很快就适应了新口味，核子可乐迅速成为全国最流行的碳酸饮料品牌。在未来25年中，核子可乐贩卖机铺遍了美国的每个街角，它的瓶盖成了人们习以为常的垃圾。</p>
<p>2051年：美国为保石油供应入侵墨西哥 近一百年前，美国石油供应第一次出现后继乏力，如今它终于采取了决定性（与争议性）的行动，放弃了替代能源，转而入侵墨西哥。多年来，美国一直对它的南方邻国施加压力，督促其提升石油产能以满足不断增长的需求。这一次，美国借着巩固墨西哥政权及防止污染扩散到美国土地的名义占领了墨西哥。 墨西哥无法抗衡美国的军事力量，最终只能放任自然资源被源源不断地榨取，输送到北部边境的彼端。人们相信，由此引发的粮食短缺最终影响了对美国的供应，导致丹佛与科罗拉多的暴乱，但这一猜测并未经证实。</p>
<p>2052~2053年：资源战争打响，美国全境开展隔离检疫 石油短缺最终引发全球恐慌，资源战争（the Resource Wars）打响了，不同国家为了剩余资源展开厮杀。欧洲联邦（“欧洲联盟”在命名投票中仅以微弱票数落后）因中东地区的供应量减少而对其展开全面入侵。恐怖分子间谍毁灭利用地区动荡的时机发动多轮局部小规模核打击，以色列特拉维夫市遭到毁灭。联合国无力控制动荡不安的局势最终解散，美国则开始蚕食中立国加拿大，没有人知道澳大利亚发生了什么。 时局动乱期间，中国特工潜入了一所位于胡佛水坝的军事实验室，窃取了挥发性生物制剂“极限115号”的样本。装有病毒的药瓶在丹佛的一个公共广场上被打碎，以“新死病”（the New Plague）为名的变异病毒开始传播。仅科罗拉多即有20万人死于此病。美国政府发起了一场全国范围的隔离检疫，并建议美国公民停止“冰淇淋社交”。</p>
<p>2054年：避难所科技公司为极端邪恶目的营建首批避难所 作为“避难所行动”（Operation: Safehouse）计划的一部分，政府委托避难所科技公司（Vault-Tec）建造122个被称为“避难所”的公共防辐射沉降物掩体，以备核打击发生时用来保护美国民众。建造目的是在长达900年的时间里维持人口繁衍，等待地面世界恢复。多数避难所均配备了昂贵的起居寓所、园圃与净水处理厂。随着核战争的威胁在大众观念里逐渐消散，一些避难所中关键的生命维持系统被舍弃了，腾出的空间被用来建造奢华的功能间，如钢琴酒吧和地下围猎保护区。 不幸的是，美国政府实际上并非博爱的慈善家，他们对平民的安危不感兴趣。相反，多数避难所其实都是精心设计的社会实验场所，上层人物（如美国政府成员与他们的后代，后世称其为“英克雷”）借此确定重回世界聚居的最佳行动步骤。结果——我们不妨举例来说——避难所的设计目的其实是把人们分隔为不同群落，有的让他们暴露在辐射中，有的则创造一个完全由孩子组成的社会，他们都被一个机器人保姆看管。所有的避难所都由监督者（Overseer）监控，并把结果数据传送至英克雷总部。</p>
<p>2059年：首例真正的人工智能诞生 尽管此前世界上有许多充满未来主义风格、能够占满一间小屋的超级电脑，但直到2059年，第一例真正的人工智能才降生世间。这台机器的确切天性已无法得知，因为其创造记录在之后几年内相继遗失，它可能是一种新型的ZAX系列学习计算机（能够实现自我意识，会在棋类比赛中作弊，尽管它完全没必要那么做）。而更进一步猜测，它甚至可能就是约翰·亨利·伊登（John Henry Eden），这台自主产生的ZAX计算机被编程用于存储美国历史的数据，它基于之前历任美国领导人的样本塑造了自己的人格与履历。之后，他还自封为美利坚合众国总统。 这一意外突破引发了改进人工智能的热潮，最终创造出用于日常使用的人形机器人与情感计算机助手。一些机器的拟人程度非常逼真，很难辨别它们是否是人类，甚至人形机器人自己也说不准。</p>
<p>2060年：欧洲内战爆发，中美两国逐步扩军 中东的石油资源枯竭后，因不能获得足够的燃料来满足需求，欧洲联邦解体了。残余民众集结军队组成民族国家，为联邦昔日的资源大打出手。 一个重要的世界性区域陷入了惨烈的内战，而苏联、南美、非洲、澳大利亚却对此作壁上观，中美两国继续无节制地开展军事活动。两国不断增长的石油需求使国际外交紧张局势不断加剧。</p>
<p>2063年：避难所疏散演练启动后遭遇“狼来了”困境 首批公共避难所竣工后，美国各地都掀起了常规疏散演练运动。尽管官方宣称这套安全预警措施合乎公众保护的目的，但在建的122个避难所只够容纳总人口中的一小部分。避难所安置的最佳候选人确定后，当事人会收到其已入选计划的秘密通知。 随着演练频率不断增加，参与紧急疏散的人数却越来越少。民众臆断空袭警报系统并无大用，只是用来通知一次又一次的演练，于是他们不再认真对待，把时间用到了其他事情上。</p>
<p>2065年：罗伯特·豪斯预见未来，并采取激进措施保护全球最重要的城市 内华达工业巨头家族的孤儿、企业家、技术天才，早在罗伯特·豪斯于2042年成立罗博科工业公司（RobCo Industries，即哔哔小子系列电子产品的制造商） 之前，他的人生成就清单已经足够丰富。没人想得到他居然还是个当代诺查丹玛斯。2065年，他经过大量计算确定地狱凶兽将在50年内挣脱束缚来到人间。 意识到一切都将毁灭，他想出了一个计划，要把自己钟爱的故乡拉斯维加斯从即将到来的末日中拯救出来：用尽一切财力买到最先进的国防科技来武装这座城市，并确保自己身处其中主导这项工作。豪斯的身体被冷冻起来，大脑则被接入一套安装在“幸运38酒店”（the Lucky 38 hotel）的巨型计算机网络。在那里，他可以控制整座城市的防御系统和庞大的安防机器人部队。万事俱备后，眼下只欠一块专门设计的铂金芯片，这块芯片可以使豪斯与安防操作系统自动升级，在未来几十年内正常运转。然而，芯片制作过程相当复杂，工程师们需要的时间比豪斯要求的多了一点点……所以结果并不如人意（芯片运输途中恰逢“超级大战”爆发）。</p>
<p>2066年：中国进入阿拉斯加主张石油资源所有权，中美战争爆发 为防止国内基础设施因燃料短缺而停运，中国付出了艰巨卓绝的努力，采取双管齐下的方式，一方面在太平洋寻找深海石油资源，一方面与美国政府举行谈判试图建立贸易关系。但是美国拒绝分享石油，并故意破坏了中国的海上开采作业。于是，中国对富油区阿拉斯加发起了全面进攻。 尽管美国在当地严密布防，然而中国还是占领了安克雷奇并控制了纵贯阿拉斯加管道，这条管道是美国获得国内石油供应的唯一途经（在德克萨斯资源枯竭之后）。为驱逐中国军队，美国政府为安克雷奇前线的所有士兵配备了看似笨拙但实则高效的能源装甲（T-45D）。然而复杂的连锁反应产生了，此前美国曾迫使加拿大提供补给并允许美军入境，不断被消耗的加拿大军队为尽快结束战争而攻击了纵贯阿拉斯加管道。</p>
<p>2072年：美国吞并加拿大 为了让加拿大明白“不适举动”的后果，美国组织了一场精心策划的军事行动，强制吞并了其北方邻国。在被美国宣示主权的新领土上，公民被剥夺了权利，全体抵抗者被集中处决。 美国的战争罪行画面被传送回国内，引发了骚动与叛乱。直到资源耗尽，全境几乎被完全占领，加拿大终于全盘接受美国的吞并要求，占领由此宣告终止。</p>
<p>2073年：英克雷建成波塞冬石油钻井平台预防核战争 蓄意破坏中国太平洋的开采作业，并宣布占据全世界最后一块未经染指的石油资源之后的第7年，美国政府委托燃料界巨头波塞冬石油公司（Poseidon Oil）建造一座最先进的钻井平台。表面上，美国在借此表现对石油资源的支配和（具有严重争议性的）宣示，但该平台同样也是英克雷的独立作战基地；他们可以在这里管理避难所，即便在核打击发生时依然能够保证生存。 虽然平台很适合作为防核辐射尘的避难所，但英克雷的最终目的是重回大陆聚居，或是在确认所有宜居环境全部毁灭后进入浩瀚的太空中寻找一颗新的行星进行殖民。为此，英克雷在2076年占领布卢姆菲尔德航天中心，夺取了“赫耳墨斯13号”航天飞机。但是他们无法正确操作飞船，所以放弃了计划的第二阶段。</p>
<p>2074年：美国地面部队在中国登陆，华裔美国人被送往集中营 尽管美国政府对民众保证，与中国之间的战争（以及所有资源损耗和反人类的罪行）完全出于自卫，它还是向中国大陆派出了大批部队，组织了戈壁沙漠和长江上的军事战役，最终美国军队深陷大陆战争，并且进一步加剧了国内资源消耗。但是，顶级T-51b能源装甲（外观好像很眼熟）的送达扭转了攻势，使美国军队获得继续在中国推进的动力，占领了南京与上海。 与此同步，所有居住在美国的华裔被送上前往西南部邦联（Southwest Commonwealth，包含南部加利福尼亚州和内华达州）著名“小扬子江”集中营的船只。除了一些骇人军事实验的细节，这一时期几乎没有保存下来的资料。</p>
<p>2077年：西部科技制成“超级变种人”病毒，美国军事濒临崩溃 英克雷影子政府命令国防承包商西部科技（West Tek）研发一种能够让美国士兵免疫任何传染物的生物制剂。这将有效地保护军队并治愈“新死病”，当然他们对前者的兴趣远大于后者。潘-免疫病毒粒子项目（the Pan-Immunity Virion Project）早期试验所产生动物样本的肌肉群与大脑活动得到大幅增强。由此，该项目目标被立即调整为创造超级士兵，项目被移送至加利福尼亚州的马里波萨秘密军事设施。 最终产生的病毒被命名为强制进化病毒（F.E.V.），并开始在军事人员身上进行常规试验。但是项目指令被泄漏给了保卫基地的士兵诱发了守卫部队兵变，研究人员被处决，部队宣布马里波萨脱离联邦（后续还引发以技术治国的钢铁兄弟会的诞生）。此时的两线作战已使美国政府疲于奔命，无法平息民众间的暴乱与示威，基地脱离并未引起它的重视。</p>
<p>2077年：“超级大战”（the Great War）终结人类文明 人们不知道是谁按下了引发战争的第一颗核弹的发射按钮（但已经存在一些非常有料的猜测）。一颗未做记号的核弹在射向一个非公开目标的途中被发现，引发了美国、中国与苏联的全面军事打击，他们同时发射了各自的核弹。历时两个小时的齐射释放出巨大的能量，改变了地球地理形态和构造板块运动，水资源被蒸发或者毒化，射入大气层的残骸彻底改造了行星气候。 人类社会几乎毁灭了，后世将这场浩劫称为“核火风暴”（a nuclear firestorm）。在美国，许多民众认为当天的空袭警报仅仅是另一场演练的通知而没有及时转移。避难所关闭时，只有极少数被选定的候选者进入，避难所之外的候选者在之后的乱局中死去，或因辐射而遭受可怕的变异。许多避难所的装备不足以应对惨烈的核灾变，在之后的几十年中崩溃了。人类文明逐渐消亡。</p>
<p>2161年：向前，故事开始 2161年，放逐者（the Vault Dweller，他的经历被记录在备受人们喜爱的传记《辐射》中）离开13号避难所，去寻找避难所中破损净水芯片的替换物。他和伙伴们在旅途中发现一处地狱版的人类文明，它依然存在于旧日辉煌的残骸之上。180年后，他们的孙辈获选者（the Chosen One，闻名于《辐射2》）走遍废土寻找伊甸园创造工具，并向英克雷的余孽施以正义的制裁。 社会开始再度成型，以一种残破和混乱的方式。2277年，独行者（the Lone Wanderer，《辐射3》）逃出101号避难所寻找父亲，为人类社会奉献了重建中最需要的东西。5年之后，信使（the Courier，《辐射：新维加斯》）得到罗伯特·豪斯的铂金芯片，他决定了美国西南部最后一个真正的人类都市的命运。或许也是在这一年，幸存者（the Sole Survivor）走出了111号避难所，承担起重建马萨诸塞州首府波士顿的使命（将于《辐射4》中呈现）。200年过去了，这座城市几乎已被夷平，出乎意料的是，人类依旧继续顽强地生存。</p>
<p>2162年：核子可乐仍然是美国最流行的饮品 虽然这段时间拿到的陈货都有些跑气，但请畅饮这一瓶满满的辐射吧。</p>
<h2 id="u540D_u8BCD_u89E3_u91CA"><a href="#u540D_u8BCD_u89E3_u91CA" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li>Vault Dweller = 放逐者【辐射1主角】</li>
<li>Chosen One = 获选者【辐射2主角】</li>
<li>Lone Wanderer = 独行者【辐射3主角】</li>
<li>Courier = 信使【辐射：新维加斯主角】</li>
<li>Vault-Tec = 避难所科技有限公司</li>
<li>Vault = 避难所</li>
<li>Overseer = 避难所监督</li>
<li>Ghouls = 盗尸者【僵尸】</li>
<li>Raiders = 匪帮</li>
<li>Fiends = 匪帮</li>
<li>NCR = New California Republic【新加州共和国】</li>
<li>FEV = Forced Evolutionary Virus【强制进化病毒】</li>
<li>BOS = Brotherhood Of Steel =钢铁兄弟会</li>
<li>Enclave = 英克雷军</li>
</ul>
<p>在《辐射》系列中，避难所【Vault】是一个非常特殊的设定。就命名而言，这些避难所似乎是用来拯救面临核战的人民，但事实上，避难所根本就不是被设计来解救美国人民的【The Vaults never meant to save anyone】。</p>
<p>在2077年，美国人口几乎有4亿，这需要将近四十万个像13号避难所那样规模的避难所才足够容纳。但那样的避难所只建造了122个。在这122个避难所之中，只有17所是在实验控制之内的，也就是说只有17所避难所是有条件让公众生存的，而其他的则是一系列的社会实验，被用来观察少数的被选中居民。</p>
<p>建造这些避难所真正的原因是看这些被挑选出来的人们如何面对孤独，以及他们在避难所打开之后如何重新开拓殖民地。这些避难所分别被设定为不同的条件，只有极少数处于正常的物理/社会状态。</p>
<p>《辐射》的游戏过程中，对避难所的探索是很重要的进程，基本上直接关系到游戏的关键发展甚至结局，更多优秀的支线剧情在这里获得展开，这也是《辐射》系列的魅力之一。</p>
<h2 id="NON_Vault-Tec_u3010_u65E0_u7F16_u53F7_u907F_u96BE_u6240_u3011_uFF1A"><a href="#NON_Vault-Tec_u3010_u65E0_u7F16_u53F7_u907F_u96BE_u6240_u3011_uFF1A" class="headerlink" title="NON Vault-Tec【无编号避难所】："></a>NON Vault-Tec【无编号避难所】：</h2><h3 id="L-A_Vault_u3010_u8F90_u5C041_u3011"><a href="#L-A_Vault_u3010_u8F90_u5C041_u3011" class="headerlink" title="L.A Vault【辐射1】"></a>L.A Vault【辐射1】</h3><p>本身是Vault-Tec的演示用避难所，并没有实验计划。在FO1中被埋藏在Cathedral下，是Master的居住地。2162年，Master及其军队在FO1中被放逐者摧毁，此地被废弃。</p>
<h3 id="Secret_Vault_u3010_u8F90_u5C04_uFF1A_u94A2_u94C1_u5144_u5F1F_u4F1A_u3011"><a href="#Secret_Vault_u3010_u8F90_u5C04_uFF1A_u94A2_u94C1_u5144_u5F1F_u4F1A_u3011" class="headerlink" title="Secret Vault【辐射：钢铁兄弟会】"></a>Secret Vault【辐射：钢铁兄弟会】</h3><p>秘密建造的避难所，不在122所避难所的编制计划内。居民是Vault-Tec的高层，其用途是开发新科技及研究FEV病毒【强制进化病毒】。</p>
<h3 id="Vault_Prototype_u3010_u8F90_u5C04_uFF1A_u94A2_u94C1_u5144_u5F1F_u4F1A_u3011"><a href="#Vault_Prototype_u3010_u8F90_u5C04_uFF1A_u94A2_u94C1_u5144_u5F1F_u4F1A_u3011" class="headerlink" title="Vault Prototype【辐射：钢铁兄弟会】"></a>Vault Prototype【辐射：钢铁兄弟会】</h3><p>德州钢铁兄弟会本部。此地似乎是Vault-Tec的技术储备地，在整个避难所计划中占据重要位置。在这里发现了一些重要的战前科技，如计算机、激光栅、武装机械人及全息设备等。这些科技设施被用来训练兄弟会新人。</p>
<h3 id="Unfinished_Vault__u2013_Fake_Vault_13_u3010_u8F90_u5C042_u3011"><a href="#Unfinished_Vault__u2013_Fake_Vault_13_u3010_u8F90_u5C042_u3011" class="headerlink" title="Unfinished Vault – Fake Vault 13【辐射2】"></a>Unfinished Vault – Fake Vault 13【辐射2】</h3><p>伪13号避难所是一个有着避难所施工痕迹的小山洞，但直到核战之前也未能完工。预定可容纳人数未知，但它绝不是最终的13号避难所。鉴于它并未出现在122座避难所的计划中，可以认为它也许是Vault-Tec的人员为自己修建的秘密避难所。需要注意的是，伪13号避难所的洞穴和真13号避难所看起来非常像。</p>
<h3 id="Securitron_Vault_u3010_u8F90_u5C04_uFF1A_u65B0_u7EF4_u52A0_u65AF_u3011"><a href="#Securitron_Vault_u3010_u8F90_u5C04_uFF1A_u65B0_u7EF4_u52A0_u65AF_u3011" class="headerlink" title="Securitron Vault【辐射：新维加斯】"></a>Securitron Vault【辐射：新维加斯】</h3><p>该避难所是Mr. House的私人避难所，用来控制他的机械人军团，位于Mojave Wasteland 上的旧气候监测站下。此地恰巧是凯撒军团大营所在地，军团成员试图通过钻探和爆破来进入它，但都没有成功。信使【FNV主角】可以用所获的白金筹码进入这里。</p>
<h2 id="Vault-Tec_u3010_u8BA1_u5212_u5185_u907F_u96BE_u6240_u3011"><a href="#Vault-Tec_u3010_u8BA1_u5212_u5185_u907F_u96BE_u6240_u3011" class="headerlink" title="Vault-Tec【计划内避难所】"></a>Vault-Tec【计划内避难所】</h2><h3 id="Vault_0_u3010_u8F90_u5C04_u6218_u7565_u7248_u3011"><a href="#Vault_0_u3010_u8F90_u5C04_u6218_u7565_u7248_u3011" class="headerlink" title="Vault 0【辐射战略版】"></a>Vault 0【辐射战略版】</h3><p>位于科罗拉多夏沿山。与庞大的避难所计划中其他避难所不同的是，这里被设计为可轻易容纳十万人的巨大地下空间。它的存在并不是为了进行人类实验，而是作为尖端科技力量的保留地。0号避难所中包括有停机坪、仓库与工厂，这些设施及其它设备将为未来的避难所成员和英克雷军服务。</p>
<p>另一项令人瞩目的内容，是0号避难所在低温条件下储存了美国战前许多天才的大脑。这些大脑与一座叫做“Calculator”的超级电脑相连，该电脑具备与其它所有避难所通信的能力，并通过超高的智能对核战幸存者和避难所居民进行教育和培养。应当注意的是，这一方式与英克雷的理念有着相当的分歧。</p>
<h3 id="Vault_3_u3010_u8F90_u5C04_uFF1A_u65B0_u7EF4_u52A0_u65AF_u3011"><a href="#Vault_3_u3010_u8F90_u5C04_uFF1A_u65B0_u7EF4_u52A0_u65AF_u3011" class="headerlink" title="Vault 3【辐射：新维加斯】"></a>Vault 3【辐射：新维加斯】</h3><p>3号避难所是一个受控制的避难所，计划于十年后开启并进行地面重建。但实际上该避难所的设定是永远关闭。然而，由于机械故障导致的洪水泄露，使3号避难所的居民不得不打开大门。</p>
<p>起初，他们通过和外界住民进行贸易来往度过了一段时间。生意很顺利，居民们也过得相当不错。然而，这也使游荡在废土上的Fiends【匪帮】盯上了他们。由于没有设立任何的安全措施，因此Fiends迅雷不及掩耳地扫荡了这里。在这场屠杀中，似乎没有任何居民生还。后来，它成为Fiends在Mojave Wasteland上的据点。</p>
<h3 id="Vault_6_u3010_u8F90_u5C04_uFF1A_u6781_u7AEF_u3011"><a href="#Vault_6_u3010_u8F90_u5C04_uFF1A_u6781_u7AEF_u3011" class="headerlink" title="Vault 6【辐射：极端】"></a>Vault 6【辐射：极端】</h3><p>避难所计划中的一个，设立于华盛顿的Mount St. Helens。由于游戏并未开发完成，因此它的设定从未被公布。</p>
<h3 id="Vault_8_u3010_u8F90_u5C042_u3011"><a href="#Vault_8_u3010_u8F90_u5C042_u3011" class="headerlink" title="Vault 8【辐射2】"></a>Vault 8【辐射2】</h3><p>位于西内华达，设计容量约100人。它是一个受控避难所，被设计为当收到外界的“污染清除”信号后打开，释放出人群以开拓地面殖民地。2091年，8号避难所正式开启，人们用G.E.C.K【伊甸园创造器】创造了肥沃的土地。这里最终发展为地下掩体市，亦是避难所计划中少数几个获得成功的社会实验之一。</p>
<p>在开启数年后，原本的避难所被改造为公民医疗中心【可能是废土上除英克雷军与钢铁兄弟会之外最好的】，动力源【虽然核电厂不能无限期支持这样一个大型居民点】，信息集结点【包括中央电脑与服务器】以及为城市提供储存用空间等等。</p>
<h3 id="Vault_11_u3010_u8F90_u5C04_uFF1A_u65B0_u7EF4_u52A0_u65AF_u3011"><a href="#Vault_11_u3010_u8F90_u5C04_uFF1A_u65B0_u7EF4_u52A0_u65AF_u3011" class="headerlink" title="Vault 11【辐射：新维加斯】"></a>Vault 11【辐射：新维加斯】</h3><p>被用作尝试特殊社会形态实验的一个避难所。该避难所的规则是：所有人都将被封闭在避难所中，并且在每一任Overseer【避难所监督】的任期结束时，必须有一个人进入监督办公室的地下密室中充当牺牲品【祭品】，否则避难所电脑将自动处决所有居民，但电脑并未强制要求牺牲者必须是Overseer。</p>
<p>从主控电脑中第一个知道该规则的是首任Overseer。当他将这一消息公诸于众的时候，每个人都感到恐惧、震惊和愤怒。作为回报，Overseer成为了第一个祭品。当他发现，用来打开牺牲室大门的密码是他老婆的名字时，他才知道他进入11号避难所的真正身份并不是避难所监督，而是第一个牺牲品，他走进地下通道的时候哭得像个孩子。不管怎样，规则不可违逆。从此以后，每一任的Overseer都将成为牺牲者，并通过民主选举的方式选出【当选者通常是被视为威胁或背叛了避难所住民的人】，直到最后。</p>
<p>随着选举的进行，11号避难所里被贴满了各种宣传海报。但与普通意义上的选举不同的是，每个被提名的候选人都展现出自己的愤怒和焦虑，他们竭力宣扬自己的清白，将火力引导至他人身上，彼此揭露罪行并设法证明别人更有资格去死。</p>
<p>选举过程中，利益集团逐渐形成了。几个不同的选举集团通过他们的人数【选票数量】优势来分享避难所中的控制权，统治、威慑和谋害其他的居民。在某年度的选举前，最强的团体“正义团”【The Justice Bloc】中的控制者与一个名叫凯瑟琳•斯通【Katherine Stone】的成员发生了纠纷。这些人威胁她，如果她不为“正义团”里的人提供性服务的话，就会选她的丈夫纳森•斯通【Nathan Stone】作为祭品。为了丈夫，凯瑟琳在无奈之下顺从了他们，但她依旧非常爱她的丈夫。在后来发现的一份审讯笔录中，当审讯者试图称呼凯瑟琳为“凯特”【Kate，Katherine的昵称】时，遭到她的回绝。她坚持只有她的丈夫斯通先生才能叫她凯特。</p>
<p>凯瑟琳以为这样就能让自己的丈夫逃离厄运，但出乎意料的是，“正义团”的这帮人依旧选了纳森•斯通作为祭品。或许是因为斯通先生的某些事犯了众怒，或者是所有人都试图保住自己的性命，总之，他即将走上死亡的道路。而不愿意和丈夫永别的凯瑟琳在别无退路的情况下，选择背水一战：她开始暗杀“正义团”的成员，并毫不在意被别人发现。避难所中的安保人员很快抓住了她，而她对自己的罪行供认不讳，更将作案动机、理由和计划和盘托出。令人惊讶的是，当被问及选民是否会因此而动摇时，她坚信自己会赢，原因就是11号避难所的选民们总是得作出一个选择来让自己“能够活下去”，当然，是跟这种充满罪恶的选举一起。</p>
<p>为了惩治凯瑟琳的罪行，她被选举为新任Overseer。利益集团认为这是结束这场风波的最好办法，但凯瑟琳再一次让他们吃惊了。她上任后第一件事就是颁布第745号监督令，取消一直以来的选举程序，并强制以后的Overseer必须由计算机摇号随机抽取。这样一来，“正义团”与其他依靠选举程序谋生的利益集团就将彻底失去依靠投票来威胁他人和控制避难所的权力。每个团体内的成员都害怕被选中，尽管如果他们被选中之后还可以利用Overseer的权力撤销这条法令，但由于长期以来避难所内的社会结构完全依靠选举程序构成，在失去共同目标后的动荡中，团体的组织很快就会分崩离析，而且夜长梦多，每个人都完全无法相信他人。</p>
<p>在彻底的恐惧下，“正义团”决定发动一起武装政变，逼迫凯瑟琳收回成命。冲突很快扩大，蔓延到整个避难所，比比皆是的沙包、壁垒和掩体将这里彻底变成了街垒战场。避难所中随处可见尸体与骷髅，没人知道这场激烈的战斗持续了多长时间，又有多少人死于非命。由于避难所大门是封死的，在战斗中没有人可能从这里逃出去。</p>
<p>那么，在Overseer办公室地下通道中的牺牲室【祭坛】中，究竟是什么景象呢？当Overseer向主控电脑输入密码之后，他的办公桌会缓缓升起，露出那条通道。与想象中不同的是，这条道路不仅不会令人毛骨悚然，反而充满了明亮的灯光。一旦进入通道，便会有语音提示欢迎牺牲者前来，并引导他走向牺牲室。牺牲室里放着一把椅子和一张桌子，而桌子上放置着一台投影仪。一旦牺牲者在椅子上坐下，投影仪便开始播放影片，并将房间的门自动上锁。</p>
<p>影片的内容是温馨而人性化的，伴随着娓娓动听的旁白，它在宽慰牺牲者：你也许还在愤怒或沮丧，但这已不重要；你的人生并非虚度，而是充满了值得纪念的回忆片段；为所有人而死，是你令人钦佩的勇气；下一个牺牲者将过得更好。当牺牲者沉浸在感伤与温暖的气氛中时，灯光被切断，影片戛然而止，室内陷入一片黑暗。</p>
<p>献祭在这时开始：房间两侧的墙壁自动开启，里面的安保机器人与自动机枪，在几秒钟时间内将强大的火力倾泻到正中就座的牺牲品身上。没有人能逃过激光和重机枪的火网，每年都不例外。机器人的脚下堆满了尸骨。</p>
<p>但是，如果有人解决了这些突如其来的杀手，就会发现在侧面还有一个小房间，这里放置着避难所的电脑主机，通过主机可以解除牺牲室的门锁。更重要的是，这里有另一份关于避难所规则的解决方案。在一份叫做“自动解决方案反馈”【Automated solution response】的文档中能够了解到：当避难所居民拒绝再定期派遣牺牲品时，牺牲献祭将会结束。避难所电脑会正式公布：根本没有人需要被牺牲，电脑也不会杀死所有人，作出拒绝牺牲的决定的人们将被称赞为“人性的光辉之举，人类的指路明灯”。与此同时，避难所大门也将被开启，居民可以离开这里去任何想去的地方，只是在此之前需要首先跟Overseer确认外界环境是否生存，并获得他的同意。</p>
<p>总之，避难所电脑主机的另一份记录中显示，当全体避难所居民作出了“拒绝派遣牺牲品”的决定时，他们总共只剩下5个人。这幸存的5个人在避难所门口留下了一份录音，他们发生了最后一次争执：其中1人试图说服其他4人离开这里并将最终结果告诉外界，但发现了最终试验目的并已经对人性罪恶心如死灰的4个人拒绝离开，并希望自杀。</p>
<p>录音带最后是四声枪响，再之后的事情就没人知道了。如果有其他人来到11号避难所的门口，会发现地上躺着四具骷髅和一把手枪。究竟是哪个幸存者离开了这里，踏入茫茫的废土？他的身世由来与最终命运，将成为永远的谜团。</p>
<p>11号避难所的任务设计师是来自Obisidian的Eric Fenstermaker<br>，他还写了维罗尼卡的对白文本。该任务的创作灵感来源可能是“米尔格拉姆服从实验”【即著名的“服从电击实验”】。</p>
<h3 id="Vault_12_u3010_u8F90_u5C041_u3011"><a href="#Vault_12_u3010_u8F90_u5C041_u3011" class="headerlink" title="Vault 12【辐射1】"></a>Vault 12【辐射1】</h3><p>位于加州Bakersfield，设计容纳人数1000人。为了研究辐射对被挑选出来的人们的影响，这个避难所的大门被设计为永不关闭。然而在战前，12号避难所却被宣传为“Bakersfield的地下大都会”。事实上，这里的设计确实非常舒适，看似能够为城市居民在战时提供前所未有的保障，这里的净水系统每天能够供应超过15000加仑的纯净饮用水。</p>
<p>2077年10月23日，当核战爆发后，由于其它避难所都已经被封闭，Bakersfield的居民们试图强行进入12号避难所寻求保护。由于没有隔离措施，所有人都遭到大剂量辐射，成为Ghoul【盗尸者】。2083年，在核战中幸存下来的Ghoul走出避难所，创建了Necropolis【大墓地】。2162年2月13日，放逐者在这里得到他需要的净水芯片，他的同伴IAN替他挡下一个超级变种人的扫射，不幸身亡。</p>
<h3 id="Vault_13_u3010_u8F90_u5C04/_u8F90_u5C042_u3011"><a href="#Vault_13_u3010_u8F90_u5C04/_u8F90_u5C042_u3011" class="headerlink" title="Vault 13【辐射/辐射2】"></a>Vault 13【辐射/辐射2】</h3><p>位于北加州。2063年8月动工，2069年3月完成。设计容纳人数1000人，计划封闭时间10年。实际上由于英克雷的避难所实验计划，这里与世隔绝长达近100年。事实上，英克雷曾计划把这里封闭200年，以研究长期孤独对人类的影响。</p>
<p>13号避难所初始预算4000亿美元，最终造价为6450亿美元。它配备了思考式超级电脑，主能源来自地热，备份能源是通用原子能核动力系统。避难所拥有完整的建筑设施，包括无土农场、地下河净水设备、可装备10人的防卫型武器，以及在封闭期间使用的沟通、社交和娱乐媒介。另外，13号避难所多配置了1个G.E.C.K，却没有备份的净水芯片。</p>
<p>2161年12月5日，由于唯一的净水芯片损坏，Overseer【避难所监督】将放逐者【辐射1主角】踢出避难所，命令他去寻找芯片，这个任务必须在2162年5月10日前完成。Overseer给放逐者标明了15号避难所的位置，并为他的冒险提供了一把枪和几粒子弹。</p>
<p>放逐者最终战胜了变种人的威胁，完成了任务，却被避难所告知“你是个英雄，但你还是要离开。”他和一些追随者离开避难所，走向漫漫荒原，并于2167年8月在加州北部建立了一个叫做Arroyo的小村庄。</p>
<p>2188年10月，放逐者有了一个女儿。2208年1月16日，在完成了对旅程的回忆后，放逐者消失了，从此再也没有出现。这给Arroyo部落留下了神秘的传说。在他们的后辈中，13号避难所被称作“HOLY 13”，包括放逐者留下的避难所制服与手枪都成为了神迹。2210年1月，放逐者的女儿成为Arroyo部落长老。</p>
<p>2241年7月25日，为了拯救村庄，获选者【辐射2主角】进入神殿开始试炼，并于7月27日通过试炼，穿上放逐者的制服离开村庄，前往13号避难所寻找G.E.C.K【这一任务必须在2254年前（13年内）完成】。</p>
<p>2242年5月15日，英克雷侵入13号避难所，激活它的中央电脑并宣布已经到了离开避难所的时候。当时的Overseer Martin Frobisher把避难所居民集合起来准备离开。5月16日，避难所大门开启，得到了英克雷士兵机枪弹雨的“欢迎”，这就是辐射2片头的那一幕【事后的调查显示是：一名士兵因“过度紧张”扣动了扳机】。总之，英克雷士兵杀死了3名“拒捕”的居民，并把所有人都带到了美国政府秘密所在地海神式导弹油井。根据对13号避难所记录的研究，英克雷制订了提前结束战争的计划。</p>
<p>2242年5月17日，英克雷将一队死亡爪放入13号避难所中以杀死所有调查那个避难所的人，借以隐藏英克雷军来过避难所的事实。其它死亡爪被派到13号避难所周围的沙漠中以确保没有任何生还者或证人。出人意料的是，这些死亡爪具备的高度智慧让他们作出了不同的选择：他们以包容的心态允许许多人在避难所中和他们共同生活。大约1个月之后，英克雷军首席战斗兵器Frank Horrigan【法兰克•荷瑞根】带队重返避难所，杀死了所有的死亡爪，只剩下离开避难所与获选者共同游历废土的Goris【革力士】。目睹惨景后，Goris发誓要为族人复仇。</p>
<p>2242年秋，获选者从三藩市乘坐油轮潜入秘密油井，救出了部落村民、避难所幸存者，杀死美国总统并引发核爆，辐射2结束。13号避难所的幸存者与Arroyo村民共同新建了村落，获选者成为了长老。</p>
<h3 id="Vault_15_u3010_u8F90_u5C04/_u8F90_u5C042_u3011"><a href="#Vault_15_u3010_u8F90_u5C04/_u8F90_u5C042_u3011" class="headerlink" title="Vault 15【辐射/辐射2】"></a>Vault 15【辐射/辐射2】</h3><p>与其他避难所一样，15号避难所是英克雷军宏大的社会实验计划场所之一。它是第一个被建成的避难所，也是唯一可靠、安全并堪称完美的避难所。15号避难所预期封闭50年，被塞入了大量超过设计总人口数目的居民，而且这些居民的文化与意识形态之间存在着极端剧烈的冲突。</p>
<p>有意识的社会实验最终造成了15号避难所的族群大分裂，一共产生了4个组织：Viper【毒蛇】、Jackals【豺狼】和Khans【可汗】。这三个组织最终成为了在废土上游荡的匪帮，而第四个组织则在避难所以西几英里的地方安营扎寨，并建立了名为Shady Sands的村庄。它就是New California Republic【新加州共和国】的前身。</p>
<p>随着三股势力年复一年的不断交战，15号避难所的设备逐渐年久失修。当放逐者【辐射1主角】到达这里试图寻找净水芯片时，它已经完全丧失了电力，还有塌方、水患等严重问题。</p>
<p>过了大概80年，在Shady Sands成为NCR之后，废土上的人开始迁移到15号避难所附近并逐渐形成了一个小棚户村。不久之后，一个名叫Darion的人和他的手下进入了避难所，并开始修复原有系统，以帮助居民获得食物、水与其他帮助。这使得居民们有足够的优势来拒绝NCR提出的合并请求，甚至都不让他们进入避难所。</p>
<p>然后，获选者【辐射2主角】来了。NCR总统Tandi【坦蒂】雇佣获选者潜伏到15号避难所的村子，其目的是至少让居民允许NCR进入避难所地下获取电脑部件以及其他支持NCR继续扩张的设施。当获选者完成了这个任务之后，他才发现Darion真正的目的……他们实际上是一帮自称为New Khans【新可汗】的匪帮，将避难所作为一个对付NCR和其他避难所居民的基地。同时，他所提供的食物和饮水也不是避难所生产的，而是从NCR和Vault City间的废土上劫掠来的。</p>
<p>具有讽刺意味的是，发誓要向NCR复仇的Darion死后，15号避难所的居民很快就接受了NCR的援助，并成为新共和国成长最快的一部分。</p>
<h3 id="Vault_17_u3010_u8F90_u5C04_uFF1A_u65B0_u7EF4_u52A0_u65AF_u3011"><a href="#Vault_17_u3010_u8F90_u5C04_uFF1A_u65B0_u7EF4_u52A0_u65AF_u3011" class="headerlink" title="Vault 17【辐射：新维加斯】"></a>Vault 17【辐射：新维加斯】</h3><p>17号避难所在避难所整体实验中的环节与目的不明，其地点也无从知晓。这是因为它的全体居民，包括Lillian Marie Bowen【辐射：新维加斯中的变种人老奶奶】都被Master的军队俘虏，并变异为超级变种人。</p>
<h3 id="Vault_19_u3010_u8F90_u5C04_uFF1A_u65B0_u7EF4_u52A0_u65AF_u3011"><a href="#Vault_19_u3010_u8F90_u5C04_uFF1A_u65B0_u7EF4_u52A0_u65AF_u3011" class="headerlink" title="Vault 19【辐射：新维加斯】"></a>Vault 19【辐射：新维加斯】</h3><p>19号避难所建筑在山谷之间，其主出入口是一个废弃停车场。在战后，它保存的完好的程度令人惊讶，除了与水和空气接触产生的正常损耗之外。</p>
<p>19号避难所承担的社会实验项目很特别，这从它的结构中也可以看出来：居民被人为划分为两种不同的色彩—红色与蓝色。他们之间采取物理隔离的形式，使用不同的钥匙开启大门，走不同的动线，彼此接触十分有限，甚至连Overseer都有两个，很奇怪的是红色与蓝色的Overseer办公室被设计为彼此相邻。唯一例外的是他们共用一个诊所。根据现状与留下的记录推测，由于避难所底层洞穴开始向空气循环系统中泄露硫磺，导致避难所居民在硫中毒后统统变成了躁狂症患者，并最终放弃了这里。</p>
<p>19号避难所实验的主要目的可能是为了模拟测试种族主义，或政治立场对立。避难所居民会感觉到自己的社会性被划分至明确的阵营【红色或蓝色】。实验目的是证明人类天生具有遗传性的竞争本能，并测试人类的社会性是否因主观判断产生倾向，比如说颜色。事实上，大部分避难所住民一开始就产生了相当的偏执和焦虑情绪，而硫中毒则加快了这一进程，医生诊所里的磁带和电脑记录表明，他们将一切已经发生和可能发生的负面事件全部归结为另一颜色居民的问题。潜意识讯息也可能是另一个因素。一份对儿童访谈的记录表明，这个孩子【以及其他孩子】能够听到一种声调极高的噪音【或声音】，但成年人却充耳不闻。</p>
<p>无论如何，19号避难所里失去了人类的踪迹，最后只剩下Fire Gecko【火蜥蜴】和Nightstalker【夜魔犬】。很多年之后，从NCRCF【新加州共和国惩戒机构】越狱逃出来的Powder Ganger【火药帮】成员发现了这里，并将之作为一个临时基地。Powder Ganger的两个头儿Philip Lem 和Samuel Cooke彼此猜忌交恶，都想要通过自己的成功除掉对方。具有讽刺意味的是，这两个人所住的房间就是原来Overseer的房间：红蓝相邻，同床异梦。</p>
<h3 id="Vault_21_u3010_u8F90_u5C04_uFF1A_u65B0_u7EF4_u52A0_u65AF_u3011"><a href="#Vault_21_u3010_u8F90_u5C04_uFF1A_u65B0_u7EF4_u52A0_u65AF_u3011" class="headerlink" title="Vault 21【辐射：新维加斯】"></a>Vault 21【辐射：新维加斯】</h3><p>21号避难所位于内华达的拉斯维加斯。它是一个非常特别的避难所：这里的规则是人人平等，采用完全对称布局，一切冲突和问题靠赌博来解决。倚赖运气来解决问题，创造了无政府状态的完美现实：在一个社会中人人真正平等，没人能比其他人能有更多的优势。</p>
<p>然而，就像所有的乌托邦那样，和平是无法持续太久的。在2271到2281年间，Robert House，这个the Strip的大头目发现了21号避难所的坐标。为了试图对抗被同化进他的帝国的命运，避难所居民一致同意以赌博来解决这个问题。以巨大的赌注为代价，House赢得了21号避难所，并把里面所有有用的电子器材和设备拆走，随后用混凝土填平了它，同时强迫居民重归废土和the Strip。然而，在Sarah Weintraub的坚持下，Mr.House最终允许她留在地上层，将避难所改造为一家酒店。它成为另一项收入来源。</p>
<p>无论如何，21号避难所是避难所计划中罕见的最终成功的避难所之一。</p>
<h3 id="Vault_22_u3010_u8F90_u5C04_uFF1A_u65B0_u7EF4_u52A0_u65AF_u3011"><a href="#Vault_22_u3010_u8F90_u5C04_uFF1A_u65B0_u7EF4_u52A0_u65AF_u3011" class="headerlink" title="Vault 22【辐射：新维加斯】"></a>Vault 22【辐射：新维加斯】</h3><p>又被称为“丛林避难所”或“森林避难所”，在2077年核战爆发之前就已完全建好并投入运行。它主要的使命是进行农业实验，涉及到转基因孢子、人工光线培植及其它。</p>
<p>然而，它始终是整个避难所计划中的一个环节。有害的植物孢子经过通风系统被扩散到整个避难所，最终感染了所有居民。22号避难所的居民成为了依附植物生存的“孢子人”，而巨型螳螂则在避难所的植物中出入，将这里变成了真正的“丛林避难所”。随后，避难所的门被打开，植物与螳螂蔓延到废土上，而与植物研究相关的科学数据只能静静地呆在电脑里，等待着有人来发现它。</p>
<h3 id="Vault_27_u3010_u8F90_u5C04_u5723_u7ECF_u3011"><a href="#Vault_27_u3010_u8F90_u5C04_u5723_u7ECF_u3011" class="headerlink" title="Vault 27【辐射圣经】"></a>Vault 27【辐射圣经】</h3><p>作为避难所实验的一部分，这里的人口数被故意超过其能容纳的限度。该避难所的设计人口数量是1000人，但有2倍的人数—2000人被指定进入这里。</p>
<p>27号避难所的位置至今未知。但可以想象，避难所设施无法提供充足的食物与饮水，以及传染性疾病可能因为人口过多而肆虐，因此该处避难所的崩溃将不可避免。此外，或许他们会提前打开避难所大门，或被告知必须离开避难所【这只是可能存在的情形】。</p>
<h3 id="Vault_29_u3010_u8F90_u5C04_u5723_u7ECF/_u8303_u5E03_u4F26_u3011"><a href="#Vault_29_u3010_u8F90_u5C04_u5723_u7ECF/_u8303_u5E03_u4F26_u3011" class="headerlink" title="Vault 29【辐射圣经/范布伦】"></a>Vault 29【辐射圣经/范布伦】</h3><p>作为避难所实验的一部分，这里被设定为只有未成年人进入。Harold于2090年从这个避难所出发。</p>
<p>该避难所由科学天才Derek Greenway设计。进入这个避难所的孩子的家长都被“不小心”送到其他的避难所或是处于卫生条件恶劣的情况下，毫无疑问，他们很快就都死了。Vault 29用一部ZAX超级电脑代替人工控制，电脑依靠机器人助手来治疗和抚养儿童，给予他们基础教育，待孩子成熟后逐步将他们释入一个可控环境。他们回到地面后，就能够自由地重建社会了。</p>
<p>某一次，Greenway向另一位科学家Diana阐释了他的29号避难所计划，以及当人脑连接到强大的电脑会发生什么事。出乎他意料的是，Diana对这一想法感到震惊。她表示，虽然这个想法很有趣，但是在道德层面上有很大问题。她建议废弃这一计划。Derek Greenway拒绝这么做，于是Diana就用她自己的方式来进行干涉。</p>
<p>当战争开始、文明陷入瓦解状态时，Diana设法获取了一个卫星天线的控制权，并将其对准29号避难所。随后，她给避难所的ZAX电脑发送了一系列安全码，并获取了控制权。在接下来的几年里，她能够看到孩子们的成长。Diana在避难所之上建造了Twin Mothers村落，并开创“自然女神”教派。每一年，她都命令一个工作机器人以外出查看环境的借口离开避难所。实际上，这些机器人是在为将来避难所居民的集体迁移着手准备。最后，Diana在重要地点安装了一系列投影机，准备播放她自己的照片。她准备扮演上帝。</p>
<p>到2253年，原本的避难所虽然早就已经停止了运作，但它对于Twin Mothers的人们而言，仍然是一个神迹。</p>
<h3 id="Vault_34_u3010_u8F90_u5C04_u5723_u7ECF/_u8F90_u5C04_uFF1A_u65B0_u7EF4_u52A0_u65AF_u3011"><a href="#Vault_34_u3010_u8F90_u5C04_u5723_u7ECF/_u8F90_u5C04_uFF1A_u65B0_u7EF4_u52A0_u65AF_u3011" class="headerlink" title="Vault 34【辐射圣经/辐射：新维加斯】"></a>Vault 34【辐射圣经/辐射：新维加斯】</h3><p>34号避难所处于Mojave Wasteland，这个避难所的军火库里存放了大量的武器、弹药，却根本没上锁【虽然某位Overseer的日志上说，在一次暴乱之后，他装了一把】。它也配备了大量的娱乐设施【比如一个全尺寸的游泳池】，其代价是牺牲生活空间。</p>
<p>痴迷于武器，现居住于Nellis Air Force Base【内利斯空军基地】的Boomers部落，是从34号避难所的迁出居民。值得一提的是，Boomers搬家的原因是厌恶“不能在避难所中随意使用武器”的规定。</p>
<p>直到2281年，避难所里还有人在居住，虽然他们此时已经变得和野生Ghoul【盗尸者】没什么区别，不过还有些许智力残存。在战斗中，他们偶尔会崩出像“疼”这样的单词来【当然在34号避难所之外也有类似的Ghoul，但他们是不是从这里出来的则不得而知】。同时，避难所还有几名正常的居民被一些废墟困在里面。</p>
<p>通过查阅34号避难所电脑终端可知，这里有一段时间人满为患，因此Overseer打算“修正”这种情况。由于如此显而易见的原因，避难所居民起义、暴乱，并试图占领军火库，酿成了一场前所未有的大战。在暴乱中，避难所的反应堆被打坏了，再加上一颗炸弹炸坏了游泳池，洪水带着足以使人致死的大剂量辐射，杀死了几乎所有的避难所居民。</p>
<h3 id="Vault_36_u3010_u8F90_u5C04_u5723_u7ECF_u3011"><a href="#Vault_36_u3010_u8F90_u5C04_u5723_u7ECF_u3011" class="headerlink" title="Vault 36【辐射圣经】"></a>Vault 36【辐射圣经】</h3><p>36号避难所的食物供应系统被设计为只能供应稀薄的流质食品。该避难所的位置未知。无法推测避难所是否已经崩溃，但很有可能缺乏营养的食物会使避难所居民体质衰弱、染上疾病，也可能会让他们走向死亡。另一种可能，是大规模的暴乱导致避难所崩溃，谁他妈愿意成天吃这种像稀屎的东西？食人也不是没可能。</p>
<h3 id="Vault_39_u3010_u8F90_u5C04_uFF1A_u94A2_u94C1_u5144_u5F1F_u4F1A2_u3011"><a href="#Vault_39_u3010_u8F90_u5C04_uFF1A_u94A2_u94C1_u5144_u5F1F_u4F1A2_u3011" class="headerlink" title="Vault 39【辐射：钢铁兄弟会2】"></a>Vault 39【辐射：钢铁兄弟会2】</h3><p>39号避难所坐落于德州，战前那里的名字是Abilene，而现在则被称为Lone Star【孤星】。</p>
<p>39号避难所的原始实验目的已经不可知。因为Reese使用了G.E.C.K，这里现在成为了一个由巨大变异植物和植物墙构成的丛林，对其他一切生命形式都抱有敌意。</p>
<h3 id="Vault_42_u3010_u8F90_u5C04_u5723_u7ECF_u3011"><a href="#Vault_42_u3010_u8F90_u5C04_u5723_u7ECF_u3011" class="headerlink" title="Vault 42【辐射圣经】"></a>Vault 42【辐射圣经】</h3><p>42号避难所的地点未知。这里的灯没有一盏超过40瓦。</p>
<p>该避难所的实验目的可能是为了研究不良的照明效果对避难所居民造成的抑郁和精神损害。但也应该考虑到可能发生其他问题，比如离开避难所时在日照条件下可能会出现弱视，或者是给一些需要良好光照的事情带来的困难，比如维修机器等等。</p>
<h3 id="Vault_43_u3010_u8F90_u5C043_u5B98_u65B9_u6F2B_u753B_u3011"><a href="#Vault_43_u3010_u8F90_u5C043_u5B98_u65B9_u6F2B_u753B_u3011" class="headerlink" title="Vault 43【辐射3官方漫画】"></a>Vault 43【辐射3官方漫画】</h3><p>只有20个男人，10个女人和1头黑豹进入了43号避难所。关于该避难所的其他情况尚不清楚，地点也未知。</p>
<p>43号避难所的居民可能因杀死黑豹而幸存下来，但也不排除有其他可能发生，诸如：黑豹杀死了避难所里的所有人，或大部分人【或许杀了不少】。最后一种情况最有可能。</p>
<h3 id="Vault_53_u3010_u8F90_u5C04_u5723_u7ECF_u3011"><a href="#Vault_53_u3010_u8F90_u5C04_u5723_u7ECF_u3011" class="headerlink" title="Vault 53【辐射圣经】"></a>Vault 53【辐射圣经】</h3><p>53号避难所里的设备被设计为每隔几个月就坏掉一些。不过这些故障都是可以被修好的，它的目的只是想给居民造成过度的压力。</p>
<p>该避难所的位置与命运都是未知，它很有可能因为疾病传染【医疗设备损坏】、辐射毒害【避难所大门失效或净水芯片损坏】或只是因为压力太大而走向崩溃。</p>
<p>也有理论认为，53号避难所可能最终会发展为一个拥有高度维修技能并欣欣向荣的地方。这样一来，它对于避难所计划来说就没什么价值可言，只能给入侵者留下许多值得掠夺的资源。</p>
<h3 id="Vault_55_u3010_u8F90_u5C04_u5723_u7ECF_u3011"><a href="#Vault_55_u3010_u8F90_u5C04_u5723_u7ECF_u3011" class="headerlink" title="Vault 55【辐射圣经】"></a>Vault 55【辐射圣经】</h3><p>55号避难所地点未知。它里面所有的娱乐媒介都被清光了。社会学家认为它在崩溃前所坚持的时间应该比56号避难所要长。</p>
<h3 id="Vault_56_u3010_u8F90_u5C04_u5723_u7ECF_u3011"><a href="#Vault_56_u3010_u8F90_u5C04_u5723_u7ECF_u3011" class="headerlink" title="Vault 56【辐射圣经】"></a>Vault 56【辐射圣经】</h3><p>56号避难所里除了一个非常蹩脚的喜剧演员主演的影片之外，没有一点娱乐媒介。社会学家们认为这个避难所将会先于55号避难所崩溃。</p>
<h3 id="Vault_68_u3010_u8F90_u5C04_u5723_u7ECF_u3011"><a href="#Vault_68_u3010_u8F90_u5C04_u5723_u7ECF_u3011" class="headerlink" title="Vault 68【辐射圣经】"></a>Vault 68【辐射圣经】</h3><p>68号避难所地点未知。进入这里的1000个居民中只有1名女性。</p>
<h3 id="Vault_69_u3010_u8F90_u5C04_u5723_u7ECF/_u5B98_u65B9_u6F2B_u753B/_u8303_u5E03_u4F26_u8BBE_u5B9A_u96C6_u3011"><a href="#Vault_69_u3010_u8F90_u5C04_u5723_u7ECF/_u5B98_u65B9_u6F2B_u753B/_u8303_u5E03_u4F26_u8BBE_u5B9A_u96C6_u3011" class="headerlink" title="Vault 69【辐射圣经/官方漫画/范布伦设定集】"></a>Vault 69【辐射圣经/官方漫画/范布伦设定集】</h3><p>69号避难所地点未知。进入这里的1000个居民中只有1名男性。在范布伦设定集中出现了该避难所的女性主题海报。</p>
<h3 id="Vault_70_u3010_u8F90_u5C04_u5723_u7ECF/_u8303_u5E03_u4F26_u3011"><a href="#Vault_70_u3010_u8F90_u5C04_u5723_u7ECF/_u8303_u5E03_u4F26_u3011" class="headerlink" title="Vault 70【辐射圣经/范布伦】"></a>Vault 70【辐射圣经/范布伦】</h3><p>70号避难所位于犹他州盐湖城。</p>
<p>2062年，大量摩门教徒一起进入70号避难所。该避难所被设定为所有发放连身衣裤制服的机器在6个月后损坏，而这种制服是避难所中的唯一服装。这对恪守清规戒律的摩门教徒来说不知道意味着什么。总之，70号避难所在2190年开启，居民们建立了New Jerusalem【新耶路撒冷】。</p>
<h3 id="Vault_74_u3010_u8F90_u5C043_u3011"><a href="#Vault_74_u3010_u8F90_u5C043_u3011" class="headerlink" title="Vault 74【辐射3】"></a>Vault 74【辐射3】</h3><p>74号避难所坐落于首都废土。它的规模很小，只有一个中庭、一个诊所和一个Overseer办公室，还有一个生活区，但唯一的入口被锁住了。</p>
<p>74号避难所最有可能的命运是：所有的居民都死了，而后来的Raiders【匪帮】洗劫了这里。</p>
<h3 id="Vault_76_u3010_u8F90_u5C043_u3011"><a href="#Vault_76_u3010_u8F90_u5C043_u3011" class="headerlink" title="Vault 76【辐射3】"></a>Vault 76【辐射3】</h3><p>76号避难所的资料出现在东部钢铁兄弟会总部Citadel的电脑里。它是17个受控避难所之一，这意味着它是完全按照居民意愿来运行的。</p>
<p>76号避难所设计人口数量为500人，计划封闭20年。值得令人注意的是这里留下的记录：当Vault-Tec官员Giles Wolstencroft【准确身份是首席执行总裁助理】检查避难所施工情况时，发生了外星人绑架事件。</p>
<h3 id="Vault_77_u3010_u8F90_u5C043_u5B98_u65B9_u6F2B_u753B_u3011"><a href="#Vault_77_u3010_u8F90_u5C043_u5B98_u65B9_u6F2B_u753B_u3011" class="headerlink" title="Vault 77【辐射3官方漫画】"></a>Vault 77【辐射3官方漫画】</h3><p>走进77号避难所的只有1个人和一箱玩偶，上面还打着“P13X联邦政府定向配给玩偶”的字样。该避难所的地点未知。</p>
<p>在最初的几个月里，77号住民经历了起始的恐慌和因与世隔绝而产生的抑郁。他并未在进入避难所后立刻打开玩具箱，而是在1年3个月零12提案之后才想起来打开箱子上的锁。</p>
<p>打开箱子之后，他对里面的1个Dog玩偶产生了很大兴趣，并将其命名为Reverend Hound【牧师】，同时还让它兼职Sheriff【警长】，另外还有1个King【国王】玩偶，1个Grandma【祖母】玩偶。</p>
<p>这些玩偶的出现让他有些事情去做，并保持了一段状态，直到他发现之前在玩具箱底没注意到的一个Vault Boy【没错，就是我们叫做哔哔小子的那个】玩偶为止。这个玩偶似乎有着自主意识，并能够直接跟77号住民对话，而这是其他玩偶所不能的。无法确定，这究竟是它真的能够表达它自己的邪恶意识，还是77号住民正在堕入疯狂的前兆。某个夜里，King“被杀害”了，而77号住民是最大的嫌犯，Vault Boy告诉他，应该在Dog – Sheriff到来之前赶紧逃命。</p>
<p>77号住民打开避难所大门，发现门口有一只巨大的辐射蝎，每只钳子上都举着一辆汽车。之后，他打算离开避难所，于是和一只巨蚁交上了朋友，并骑乘它走掉了。</p>
<p>后来的某个时候，77号住民在与一个无名Ghoul【可能来自Necropolis，因为他身上穿着原来的避难所制服】分享过一顿篝火晚餐之后，被Raiders【匪帮】捉住了，而Raiders尚未确定究竟是把他当成奴隶还是吃了他。</p>
<p>77号住民试图警告他们不要靠近他的Vault Boy玩偶，因为这玩偶是个疯狂的杀手。但很明显，根本没人拿他的话当真。这一夜稍晚时，他的威胁变成了现实，匪帮与奴贩的营地被夷为平地，只剩下77号住民站在大屠杀的修罗场中，手上的玩偶满是鲜血。</p>
<p>没有人知道77号住民后来变成什么样子，但有一点可以肯定：“避难所从不会拯救任何人。”</p>
<h3 id="Vault_87_u3010_u8F90_u5C043_u3011"><a href="#Vault_87_u3010_u8F90_u5C043_u3011" class="headerlink" title="Vault 87【辐射3】"></a>Vault 87【辐射3】</h3><p>87号避难所位于Capital Wasteland的西部边缘。在避难所实验计划中，87号避难所的居民被用作FEV【Forced Evolutionary Virus，强制进化病毒】的试验品。因此，这里成为了东海岸的Super Mutant【变种人】和Centaur【多脚兽】的已知唯一来源。</p>
<p>在2078年，87号避难所的居民被带入密室并强行接触FEV病毒。避难所Overseer与他的卫队并不知道这会产生什么后果，他们只是遵从Vault –Tec的命令。当首批避难所居民成功抵被转化为Super Mutant之后，他们就开始强迫他人发生变异，直到整个避难所里的人们不是死掉了就是变异了。</p>
<p>87号避难所的Super Mutant们对自己的新作品非常痴迷。由于他们都是通过接触病毒强制进化而非通过自然进程而来，因此他们开始在整个废土上绑架人类，并将他们带到避难所里进行变异。这种行为持续了差不多200年，直到他们的FEV病毒源头开始泄露。由于“绿皮肤”的短寿，现在变种人小组遍布整个废土，以求寻找到一个新的病毒源头。</p>
<h3 id="Vault_92_u3010_u8F90_u5C043_u3011"><a href="#Vault_92_u3010_u8F90_u5C043_u3011" class="headerlink" title="Vault 92【辐射3】"></a>Vault 92【辐射3】</h3><p>92号避难所坐落于Capital Wasteland西北。在核战期间，世界上最优秀的音乐家们被以“保护艺术人才”的名义邀请到92号避难所来。但实际上这里也是避难所实验中的一环，被用来测试白噪音对人的生理和心理影响，还包括植入潜意识信息的方面。</p>
<p>92号避难所的真正目的是通过“潜意识”的方式进行特别学习以创造“超级战士”。通过隐藏潜意识讯息的白噪音对避难所居民的影响，避难所Overseer希望以催眠的方式创造超级战士，这样的战士能够完全服从命令，战斗力也比普通的战士更强悍。避难所的医生开始时并不知道Overseer打算利用他们的工作来创造士兵，他认为Overseer不过是在研究居民的音乐才华罢了。</p>
<p>在起初，实验进展得很顺利，一切看起来都前景无限，直到最有价值的实验对象变得极端狂暴而不可控制。在警卫最终制服他之前，他把三个人撕成了碎块。放倒他用了23枪。医生对此感到恐惧，并不明白为什么一个人会变成这样【就像医生所关心的，那些建议都是单纯而无害的，比如抓抓头发、碰碰耳朵之类的，但这些可能就是触发催眠行为的信号】。稍后一份Overseer终端上的记录显示他是故意将潜意识植入实验对象，以引出一场血腥的爆发，借以观察命令是否能够被服从，能够造成多大的破坏，以及在避难所安保人员在杀死他之前能够承受什么样的打击。他对于试验品身中20多枪才死亡这一事件表现得尤其兴奋，并指出如果有这样的士兵构成一整支军队，那么它将是不可阻挡的。</p>
<p>这种狂暴很快就在其他的试验品身上表现出来。一台电脑终端上的某位居民—Zoe Hammerstein的日记说明：她因为白噪音而发疯了。日记显示出她的写作能力【包括拼写和语法】已经严重退化，虽然句子几乎无法理解，但她直到最后一刻还在乞求她的朋友帮她一把。</p>
<p>Overseer处理这种事态的方式只是做一些简单的工作【例如编写一些代码植入试验体以阻止他们的疯狂行径】。然而控制白噪音的专家Malleus教授很快对这一计划丧失了希望，并几次向Overseer Richard Rubin表态，要求他更加重视事态，甚至提出鉴于当前避难所居民的野蛮与血腥，应当考虑放弃避难所，不要等到大错铸成才悔之晚矣。然而，从Overseer的电脑终端呈现的证据上来看，Rubin最后杀掉了Malleus教授。</p>
<p>避难所中三分之一的人成为了情绪不稳的嗜血暴徒，并开始屠杀剩下的那些居民。一张标题为“回馈循环”的便条描述了92号避难所实验中，最后的幸存者们试图逃出生天的努力。这似乎可以解释为什么避难所的大门是打开的。“相对正常”的避难所住民企图阻止疯狂者的脚步，因此避难所中零星散布了一些地雷。其间发生了各种悲剧，例如Hild a Egglebrecht 和Parker Livingsteen这对年轻恋人反锁在录音室里殉情，这里曾经是他们夫唱妇随的甜蜜之所。这与Paker在便条上记载的内容相吻合。</p>
<p>关于避难所里后来出现的螃蟹人，其原因可能是由于淹没避难所底层的洪水。由于“疯狂事件”，底层有一堵墙被破坏了，而在那附近刚好有地下水。墙很快被修复了，并作了一些小的修补措施，但避难所总工程师Carl Maynard却在底层的一个终端上记录道：这种修理只是暂时的，必须讨论决定如何处理可能发生的更糟的情况。然而，由于发狂的居民越来越多，一切事情都被搁置了。墙壁最终被洪水冲垮，螃蟹人也因此进入了避难所。</p>
<h3 id="Vault_101_u3010_u8F90_u5C043_u3011"><a href="#Vault_101_u3010_u8F90_u5C043_u3011" class="headerlink" title="Vault 101【辐射3】"></a>Vault 101【辐射3】</h3><p>101避难所建立于华盛顿特区西北的山中，实际地理位置可能是Virginia北侧的Tysons Corner。101避难所的实验目的是测试Overseer的权威性，这里被设定为永远不会接收到“污染清除”的信号，使避难所无限期与世隔绝，虽然有限的遗传基因有可能会导致近亲繁殖。</p>
<p>101避难所的第二任Overseer决定挑选几个成年人协助他对孩子们隐瞒秘密，这个政策长年执行下去导致每下一代都有更多人了解到避难所的真相。此外，Overseer能够使用位于办公室下的秘密通道去沟通甚至访问外面的世界。然而，对于其他的意图和目的，避难所的居民被封锁在“我们生于此，我们长于此，我们死于此”的循环中。但是，随着独行者【辐射3主角】的逃离，实验进入了一个新的阶段。</p>
<p>从东部钢铁兄弟会总部终端上获得的信息来看，101避难所的早年记录并不完整。对其他文件的分析表明，101避难所应该是建立于2060年左右。</p>
<p>在23世纪中叶，一位新的Overseer成为了避难所的领袖，他是一个支持与外界沟通的人。2241年，Overseer派遣了一支以Anne Palmer为首的侦查分队前往废土。这次探险揭示了战后废土的真正自然状态，并与小城Megaton的人们建立了联系。在独行者之父到达避难所亦即2258年之前，这位Overseer在一次废土探险中消失了。他的继任者Alphonse Almodovar奉行严格的孤立主义，避难所成为了一个严刑峻法的警察管制社会。</p>
<p>在Alphonse刚刚成为Overseer时，James【辐射3主角之父】带着他的婴儿进入了避难所社会。James同意了Overseer的要求，受雇成为避难所的医师，并向他的孩子隐瞒了出身，以为自己和父亲都是生于避难所中。19年后，James突然从避难所中消失，这迫使独行者也要逃离避难所，在躲过保安队伍的杀意之后前往废土去寻找他/她的父亲。</p>
<p>在见过Megaton的Colin Moriarty之后，独行者了解到了自己的身世：他/她是在避难所外出生的，James的妻子因分娩而死，尔后James才将孩子带进了避难所。虽然在避难所中有几个人知道真相比如老太太Palmer，但他们都从未对独行者提起过。</p>
<p>与Megaton的其他人交谈之后，独行者发现过去20年中还有人离开过101避难所。Craterside Supply的店主Moira Brown回忆“大概10 – 12年前有个女孩逃了出来”，而Colin Moriarty则回忆说5年前有人从避难所跑出来。脱逃者对Moriarty说，避难所的居民都被洗脑了，只相信谎言。</p>
<p>实际上，Megaton这个小镇在某种意义上就是因为那些试图进入避难所的人们而建立的。避难所门外至今还有那些不得其门而入的人的尸骨，以及他们措辞严厉的标语牌【例如“我们快死了”“救救我们”“你们这些凶手”等等】。</p>
<p>需要指出的是，在任务“后院起火”【Trouble on the Homefront】中暗示大多数但不是全部避难所居民在参与实验。这可以解释为什么James带着年幼的独行者突然加入避难所没有引起太多居民的关注，而且也能够解释Overseer为何在没有外来者先例的情况下允许两个新来的人加入避难所。</p>
<h3 id="Vault_106_u3010_u8F90_u5C043_u3011"><a href="#Vault_106_u3010_u8F90_u5C043_u3011" class="headerlink" title="Vault 106【辐射3】"></a>Vault 106【辐射3】</h3><p>106号避难所关闭10天后，神经毒气通过空气过滤系统被排放到避难所当中。</p>
<p>到2277年，整个避难所已经被严重破坏，但里面仍然满是疯狂的幸存者。神经毒气依旧存在于空气过滤系统中，吸入它的人会突然眼前一蓝，并伴随着幻觉出现。避难所中的计算机终端资料显示，Overseer知道他的居民将面临着什么样的实验，但却让自己的警卫去告诉避难所中的每个人一切正常。在106避难所最后的日子里，它变成了一个类似于洞穴的地方，居民的残骸和各种物品四处散落。</p>
<h3 id="Vault_108_u3010_u8F90_u5C043_u3011"><a href="#Vault_108_u3010_u8F90_u5C043_u3011" class="headerlink" title="Vault 108【辐射3】"></a>Vault 108【辐射3】</h3><p>108号避难所门口的老鼠都是克隆产物，而108号避难所的生活区与克隆实验室里有一大群都叫Gary的克隆人。</p>
<p>从东部兄弟会总部的电脑终端资料中可知，108号避难所的研究目的是研究避难所中的领导力与权力争夺。大家都知道，这个避难所的Overseer得了一种罕见的癌症，寿命只有40个月，而他大权在握，一旦死去这里便群龙无首。避难所主动力源被设定为在240个月后损坏【也就是20年，但避难所计划封闭30年】，而且备份电源也故意被设计成无法满足避难所的需求。在此基础上，避难所得到了三倍的军火，却没有任何娱乐设施。</p>
<p>108号避难所可能是避难所计划中出现的前所未有的偏差。当克隆实验室给避难所带来几乎完全一样的居民时，无法知道Gary的克隆体该如何组织起来。问题是：他们该如何把自己从一群所有特征都完全一致的人中分辨出来，并获得领导权。</p>
<p>克隆实验室里有一片记录磁盘，简单地记述了108号避难所的来龙去脉。每搞出一个Gary的克隆体，它立刻就开始敌视非克隆体，并开始变得凶暴。在连续克隆了53个都毫无差别的Gary之后，因为避难所的观察室快要塞满了，他们开始考虑该怎么处理所有的克隆体。磁盘里的另一份记录显示，Gary 54号也是一样，而且还在一次测试过程中弄伤了Dr. Peterson。</p>
<p>记录里还说，他们打算销毁一些克隆体，以腾出房间来做“更多的测试”。接下来发生的事情就不清楚了，总之，唯一清楚的是108号避难所最后的幸存者就是这些Gary克隆人。</p>
<h3 id="Vault_112_u3010_u8F90_u5C043_u3011"><a href="#Vault_112_u3010_u8F90_u5C043_u3011" class="headerlink" title="Vault 112【辐射3】"></a>Vault 112【辐射3】</h3><p>112号避难所在2068年11月动工，完工于2074年6月。它是避难所计划中建造的最后一个部分，只能容纳85人。</p>
<p>112号避难所是应G.E.C.K的发明者Dr. Stanislaus Braun的要求建立的，他在避难所中安装了虚拟现实设备和生命循环系统，建造了一个虚拟现实的乌托邦。系统选择了几个人来进行一个“完美生活”的实验，设计了一个叫做Tranquility Lane【安宁巷】的地方。Braun在里面“扮演”一个叫作Betty的小女孩。</p>
<p>112号避难所的居民并不知道他们进入的实际上是虚拟现实试验。Braun拥有对系统的完全控制权，他们无法自主地离开。这些居民成为了Braun的玩物，在对虚拟世界厌倦了之后，Braun会“杀掉”他们每个人，在清除记忆后用程序将他们再复活。这很残忍，可几乎也是一种必然。</p>
<p>但无法否认的是，Braun毕竟是个大天才。为了得到他的帮助启动净水计划，独行者之父James在Rivet City【铆钉城】查到了112号避难所的位置，只身前往。但Braun不仅无意帮助James，反而将他也拖入虚拟现实世界中，并将他变成了一条狗，加以肆意折磨。</p>
<p>为了找到父亲，独行者也来到了112号避难所，并坐上生命循环舱，进入虚拟现实世界。如果想要走出这里，就必须满足Braun的要求，折磨、挑拨、虐杀Tranquility Lane里的所有人之后才能将父亲带走。但是除此之外，也有别的解决方法。</p>
<p>Tranquility Lane里有一座废弃的破房子，那是系统的隐藏终端所在。里面的物品摆放看似凌乱，却有一定的规律性。如果按一定顺序敲打房间内的物品，墙壁上就会浮现出这个世界的控制终端。在这里独行者可以启动“军队自毁程序”，由军方设计插入的这个程序会派出一队士兵，真正杀死虚拟现实世界中的所有人，Dr.Braun再也无法将他们复活。当独行者和父亲离开这里之后，Dr. Braun只能自己孤独地生活在这个世界中，直到永远。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>军争之难者，以迂为直，以患为利。故迂其途，而诱之以利，后人发，先人至，此知迂直之计者也。</p>]]>
    
    </summary>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="辐射" scheme="http://wdxtub.com/tags/%E8%BE%90%E5%B0%84/"/>
    
      <category term="避难所" scheme="http://wdxtub.com/tags/%E9%81%BF%E9%9A%BE%E6%89%80/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[足球游戏简史]]></title>
    <link href="http://wdxtub.com/2016/03/20/game-history-football/"/>
    <id>http://wdxtub.com/2016/03/20/game-history-football/</id>
    <published>2016-03-20T14:07:35.000Z</published>
    <updated>2016-03-20T14:31:41.000Z</updated>
    <content type="html"><![CDATA[<p>足球游戏经历了怎样的发展？玩家喜爱哪些类型？足球手游有哪两大分支？作为世界第一大运动的衍生品，足球游戏经历了怎样的发展？玩家喜爱哪些类型？未来又会如何进化？</p>
<a id="more"></a>
<hr>
<h2 id="u7AEF_u6E38_u65F6_u4EE3_uFF0CEA_u4E0EKCEO_u4E8C_u5341_u5E74_u7EB7_u4E89"><a href="#u7AEF_u6E38_u65F6_u4EE3_uFF0CEA_u4E0EKCEO_u4E8C_u5341_u5E74_u7EB7_u4E89" class="headerlink" title="端游时代，EA与KCEO二十年纷争"></a>端游时代，EA与KCEO二十年纷争</h2><p>自上世纪90年代开始人们对于足球游戏的争论，便停留在了“实况”还是“FIFA”上面。</p>
<p>首款FIFA于1993年圣诞节，在PC平台发布，由加拿大人制作，基于电脑开发的FIFA很快的抢占了美洲的PC市场。次年，一款名为：《实况世界足球完美十一人》开始在SFC平台发售，这款游戏由KCEO小组制作的游戏，也就是后来的WE和PES的前身，它的发售也正式吹响了两款游戏近20年纷争号角。</p>
<p>两款游戏的特点对比十分明显，FIFA在游戏节奏上更注重快与流畅，联赛内容上更真实，AI相对与实况更加简单，拥有国际足联的完美授权。实况足球节奏比较慢，设计上更侧重于战术的拿捏，注重对球员个体的设计。</p>
<p>FIFA与实况的斗争也是此消彼长。2006年发售的实况足球PES6在设计上，修正了射门感觉，防守设定也变得合理，犯规不再频繁，只要你肯琢磨，Tiki-taka都不再是问题。节奏感方面，除了刻意的战术犯规外，比赛几乎可以做到不中断，这一代版本在欧洲上市仅8天就卖出了300万份。而FIFA2013更是仅在短短四周就卖出了740万份。</p>
<p>在2004年到2008年，虽然实况足球稳步前进，在PS2等主机平台上表现出色，但是从PES2009后，实况足球全平台全方位的一落千丈。反观FIFA，FIFA在主机方面完全压制实况足球，并且从2011开始全平台统一引擎，加上FIFA的商业能力，次世代引擎爆发的威力，各种细节全方位针对实况足球的学习，逐渐融合了两家的优点。</p>
<p>总结来看，自实况足球PES6之后，EA已经远远将K社甩在了身后。</p>
<h2 id="u53E6_u4E00_u79CD_u6D3B_u8DC3_u65B9_u5F0F"><a href="#u53E6_u4E00_u79CD_u6D3B_u8DC3_u65B9_u5F0F" class="headerlink" title="另一种活跃方式"></a>另一种活跃方式</h2><p>实况足球与FIFA只能代表足球游戏中的体育竞技类，关于其他类型，比如说模拟经营类的足球经理，也被玩家津津乐道。</p>
<p>足球经理是完全不同于实况足球和FIFA的游戏，它表现的不是足球比赛时的竞技与对抗，更多的乐趣来源于模拟。模拟现代足球在比赛背后的庞大产业，这来源于足球这一世界地运动所涉及的国家文化，风土人情、历史发展，玩家要对这一切有足够的了解，才会精通于此类游戏。</p>
<p>另一方面，还有一部分世界观完全架空的足球游戏也受到一部分玩家的喜爱。比如说《热血足球》，《雷门十一人》，《街头足球》等游戏，这些游戏大多以卡通动漫的画风，通过现实中难以做的到足球招式来满足玩家对足球更高动作表现的幻想与追求。</p>
<h2 id="u624B_u6E38_u65F6_u4EE3_uFF0C_u8DB3_u7403_u6E38_u620F_u7684_u4E24_u5927_u5206_u652F"><a href="#u624B_u6E38_u65F6_u4EE3_uFF0C_u8DB3_u7403_u6E38_u620F_u7684_u4E24_u5927_u5206_u652F" class="headerlink" title="手游时代，足球游戏的两大分支"></a>手游时代，足球游戏的两大分支</h2><p>最初，功能机时代的足球游戏大多是模仿与移植主机平台的游戏玩法。随着智能机的兴起，移动终端上的足球游戏逐渐演化成两个分支。</p>
<p>第一类是重度操作类，其特点是真实性强，基本上将PC上和大型家用游戏机上的游戏场景，还原到了手机和移动终端设备上，渴望还原给球迷玩家主机平台上足球游戏真实的代入感。《FIFA2013》，《PES2012》都是这种类型的代表作品，这两款游戏都强调将主机平台上，足球游戏的节奏感展现在手机上，从画面，音效，操作上给玩家身临其境的感觉。当然，这类型游戏的缺点也很明显，由于终端的限制，目前还不能通过单纯的点击、滑动等操作完成足球游戏的重度复杂的动作，没有键盘或者手柄的支持，习惯主机平台的玩家始终会觉得操作感不好。另外，过于强调球赛时的还原度必定增大游戏包的容量，追求更好的游戏画质还是选择更轻量级的安装包，如何优化，也是值得开发商商榷的问题。</p>
<p>第二类是养成类足球手游，此类游戏摒弃了足球的操作元素，强调对于球队和球员的养成，让玩家容易上手，也较容易在游戏中获得的成就感。这类游戏的代表就是Gameloft的世界足球系列。这类游戏的另一个变种就是将足球与卡牌融合，目前国内市场中此种卡牌类足球游戏居多，虽然将RPG与体育游戏结合算是一种创新，但是现状是此类游戏在设计时过于强调模拟经营元素、缺乏玩家与玩家之间的社交化联系，对于真实足球世界的还原明显缺失，代入感较差，而游戏的核心玩法，大多数也只是数值的堆砌。</p>
<h2 id="u5BF9_u521B_u65B0_u9898_u6750_u8DB3_u7403_u6E38_u620F_u7684_u5C55_u671B"><a href="#u5BF9_u521B_u65B0_u9898_u6750_u8DB3_u7403_u6E38_u620F_u7684_u5C55_u671B" class="headerlink" title="对创新题材足球游戏的展望"></a>对创新题材足球游戏的展望</h2><p>去年下半年到今年，市场上出现了许多新兴的足球游戏。比如游族的《马上踢足球》、热酷的《决战2014》、中手游代理的日本游戏BFB和光涛的《足球梦之队》等等。这里以3D战斗卡牌《足球梦之队》为例，谈谈足球游戏在手游上的新变化。</p>
<p>首先在玩法上，这款游戏并没有让玩家扮演一个球员或是一个经理，而是在足球游戏中扮演一个教练。这其实是融合了传统手机游戏的两家之长，在游戏中玩家不仅要考虑足球比赛时如何操作能够赢得比赛，又要注意球队的养成与管理。这款游戏在球赛时的玩法表现更像是即时战略类游戏，玩家的操作点不再聚焦到每个球员，而是整个球队，这种更注重整体战术规划的体育类游戏目前还是比较少见的。而在球队管理模式上，则依然沿袭了卡牌RPG的模式。</p>
<p>另一大方面，是这款游戏的语音操控，策划希望完全模拟教练在球场上的身份，让玩家以喊的方式告诉你的“球员”该如何踢球。</p>
<p>语音操控更好地结合了手机设备的特征，但也是一个十分有争议的设计，排除识别准确性等不安定因素外，如何能更好的设计好语音操控的体验，而不是让玩家只是抱有新鲜感才去使用，这也是开发商将要面对的一个问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>足球游戏经历了怎样的发展？玩家喜爱哪些类型？足球手游有哪两大分支？作为世界第一大运动的衍生品，足球游戏经历了怎样的发展？玩家喜爱哪些类型？未来又会如何进化？</p>]]>
    
    </summary>
    
      <category term="历史" scheme="http://wdxtub.com/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="足球" scheme="http://wdxtub.com/tags/%E8%B6%B3%E7%90%83/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[游戏发展史 - Blizzard]]></title>
    <link href="http://wdxtub.com/2016/03/20/game-history-blizzard/"/>
    <id>http://wdxtub.com/2016/03/20/game-history-blizzard/</id>
    <published>2016-03-20T14:07:28.000Z</published>
    <updated>2016-03-20T14:29:38.000Z</updated>
    <content type="html"><![CDATA[<p>暴雪的大名已如雷贯耳，虽然现在也面临着一些困难，但是回顾往昔，光芒依旧耀眼。</p>
<a id="more"></a>
<hr>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>就读于加州大学洛杉矶分校的迈克·默汉曾经对同学这样恶作剧：当艾伦·艾德涵暂时离开电脑时，默汉迅速把艾伦的电脑密码改成了 JOE，毫不知情的艾伦回来输入密码，竟然成功登陆了。这时轮到默汉大吃一惊，艾德涵究竟是怎么做到的？于是他招认了自己的恶作剧，然后请教艾德涵是如何破解的，然而，后者的惊讶程度丝毫不亚于默汉，他不过是输入了自己的密码而已。默汉终于明白了其中关键：由于机缘巧合，艾德涵自己的密码也刚好是 JOE。此后两人成为挚友，他们关系之好，最终又成为商业上的合作伙伴，之后20年中他们的工作室制作了数十款精品游戏，不仅成为游戏史上最伟大的传奇之一，更晋升为行业巨头，屹立于整个娱乐产业。他们的公司如此受欢迎，甚至拥有自己的年度大会。且不论两人是否还把 JOE 作为密码，在产品制作的完美程度和持续的卓越方面，世界上几乎少有同行能够同暴雪娱乐并驾齐驱，这是毋庸置疑的。</p>
<p>毕业之际，艾伦·艾德涵觉得这是实现理想的最佳时机，他热衷玩游戏，为何不以制作游戏为业呢？但是他不甘心在大公司当低级程序员，而是想自己当老板，自己决定工作计划。艾德涵决定创立自己的公司，于是他联系迈克·默汉，邀请他入伙，同时还联系了另外一名同学弗兰克·皮尔斯。</p>
<p>【弗兰克·皮尔斯】我与艾伦通过熟人认识，当时很凑巧，因为我确实很想制作游戏，觉得是一项很酷的事业，却苦于不知道如何着手，而艾伦对于自己想做的事情有着明确计划和确切的愿景，他想做的事刚好也是我感兴趣的，因为我少走了很多弯路，我们能够相遇是很幸运的。</p>
<p>【迈克·默汉】公司成立的第一天我才和弗兰克首次见面，当时我正在说话，一个陌生人出现了，于是我闭住了嘴，然后就这么结识了。</p>
<p>1991年2月8日，三人在加州科斯塔梅萨建立了他们的工作室『硅与神经键Silicon&amp;Synapse』，艾德涵担任总裁，默汉担任副总裁，皮尔斯则是程序员。他们决心不紧要制作出伟大的游戏，更要在其过程中享受到乐趣。</p>
<p>【弗兰克·皮尔斯】其实当初我和迈克都不太相信自己的公司能够这么成功，但是艾伦充满激情，积极乐观，他一直以为，如果几个聪明的头脑集思广益，自然能找出最正确的做事方式，无论是制作游戏还是别的。艾伦做事的原则是从不懈怠，他坚信只要大家投入时间精力，就没有克服不了的难关。艾伦说过，制作游戏并非火箭科技那样高深，只要我们几个聪明人齐心协力，也能同顶级公司一决高下。</p>
<p>当年他们便崭露头角，在 Commodore64平台早期游戏《毁灭赛车》的启发下，1991年他们为超级任天堂这个新机种开发了《RPM 赛车》。『硅与神经键』如今成为第一家为超任开发游戏的美国工作室，这是个良好的开端。1992年略有不同，这一年他们没有开发原创游戏，而是把已经把发行的游戏移植到其他平台。例如他们把《指环王》移植到 Amiga 平台，《战斗国际象棋》移植到 Windows 等等。游戏移植并非什么激动人心的工作，但报酬不错。原创游戏的开发无疑还是他们的热情所在，同年，硅与神经键在许多平台上发行了《失落的维京人》，在略为老套的剧情中，三名维京人主角被邪恶的 Tomator 吸入太空船中，必须尽力逃脱。作为一款平台跳跃游戏，本作加入了独一无二的要素，玩家能在三名维京人中任意切换，利用每个角色独有的能力来解开谜题。这是一款单人操纵多角色的游戏，通过杰出的艺术设计和幽默感，硅与神经键独树一帜的个性和卓越的制作水平得到了首次体现，这些品质而后都成为了暴雪的代名词。</p>
<p>【弗兰克·皮尔斯】作为我们的第一款完全原创游戏，《失落的维京人》有着特殊意义，开发过程中我们都很开心，学到了很多游戏设计的经验以及让玩家通过重复完成动作来实现目标的重要性。《失落的维京人》受欢迎程度之高，在街上遇到熟人都会问今天你玩了吗？这个游戏优秀之处在于它以难以阐明的魅力牢牢吸引了大众，太酷了。</p>
<p>《失落的维京人》成为工作室早期作品的典型，并在1995年出品了续作。1993年《摇滚赛车》在超任和世嘉上推出，硅与神经键的名声渐响，同年他们获得《电子游戏》杂志办法的最佳软件开发商奖项。麻烦的是，工作室的名字不太到位，硅与神经键原本用来象征科技和创造力的结合，然而合作的商家中没有一个知道神经键是个啥，名字起得让人疑惑不解，这对新生企业不利。于是他们改名混沌工作室，希望借此被更多人熟知。此外还有更大的问题接踵而来：首先，尽管成员都是凭借兴趣爱好走到一起，工作氛围却一点都不轻松。</p>
<p>【弗兰克·皮尔斯】我记得在创立之初自己特别拼命，每天都超时工作，一直持续几周，与当时相比，现在的工作规划实在太轻松了，在来到硅与神经键之前我从事航空业，早晨7点就上班，转行到游戏业之后我习惯不改：早上7:00-7:30到公司，埋头工作10到12小时之多。</p>
<p>【迈克·默汉】7点上班对我来说是天方夜谭，但是我加夜班到很晚。</p>
<p>火上浇油的是，虽然取得一些成绩，他们在财务方面却很困难。尽管只有15名员工，创始人们却不得不透支之际的信用卡以支付工资，有时候甚至要啃老。当父母的资助也不再可行时，他们知道必须痛定思痛了。1994年，混沌工作室开始对两份并购提议作出正式考量，一份来自大发行商 Interplay公司，另一份来自教育软件开发商戴维斯及联营公司。起初，二选一的答案看似毫无悬念，新兴企业应当寻求行业巨鳄的庇护，然而再三考虑后，他们意识到要加入 Interplay 就得甘当一枚不起眼的螺丝钉，失去自主权，相反戴维斯及联营公司在游戏业初来乍到，因此在产品开发方面愿意给予工作室全面自主。面对两难抉择，他们最终在业界菜鸟一边压下了赌注，最终戴维斯公司以一千万美元并购了混沌工作室，这对于当时的他们无异于雪中送炭。</p>
<p>【迈克·默汉】戴维斯的这次并购极为关键，它加速了我们的成长。公众所不了解的是，直到这次并购之前我们的预算一直很紧张，当时办公室甚至没有局域网，大家需要轮流用电脑等等。我们希望挺过来之后，能够实现资金自主和自主发行产品。并购后再也不用担心发不出工资，还有了新的高速局域网，我们终于能真正专注到制作游戏上。</p>
<p>当一切趋于稳定，他们发现不能再用混沌这个名字，商标权已经归属另一家软件公司，他们必须再度改名。几乎选定为食人魔工作室后，又被戴维斯的大老板否决，最后艾德涵翻字典找到了七个备选词，长期讨论后敲定了一个既酷又得到管理层首肯的名字，就是暴雪娱乐。即使在发展之初，因为不愿把自己局限到一种媒体，暴雪公司一开始就选定『娱乐』而不是『游戏』这个词，他们从不缺乏雄心壮志。同年，改头换面的暴雪娱乐受到发行商 Sunsoft 委托，将漫画史上最重要的大事件《超人之死》改编成游戏，8月《超人浴火重生》在超任上发行。这是一款简单的横版过关游戏，不过主角可是超人。游戏终章里主角没有打败最终 boss，而是同归于尽，之后玩家控制剩下的四名超人之一重新游戏，只有在五名超人都通关后才能看到真正结局。《超人浴火重生》这款作品无愧于暴雪公司响当当的名号，创立仅三年，他们就被娱乐界最大的巨头之一点名为其制作游戏。九月，暴雪公司在超任和 DOS 平台吓发布了一款新的原创射击动作游戏《黑色荆棘》。为了使人物动作尽可能逼真，工作人员把弗兰克·皮尔斯的动作拍摄下来，再把录像转化为游戏画面，这一技术被称为 Photoscoping。《黑色荆棘》同样以特立独行的艺术风格和怪诞幽默著称，在逐步形成的暴雪风格上又跨出了一步。至此1994年重大事件不断，公司被并购后又更名，其发行的两款游戏，一款以家喻户晓的超人作为题材，另一款则是原创的《黑色荆棘》，小规模的发行商能做到这份上，无疑是硕果累累。事实上他们远未满足，还计划在圣诞节发布一款小作品——《魔兽争霸》为94年画上完美句号。</p>
<p>早在1992年，Westwood 工作室发行了《沙丘魔堡2》这款战略游戏，游戏要求玩家利用资源发展建筑，而后通过建筑生产单位来与敌人作战，本作特点如此鲜明，最终发展成全新的游戏类型，称为即时战略或 RTS。该作算是小有收获，但是直到1994年，还没有一款跟风作品出炉。暴雪公司却别出心裁，要另辟蹊径。</p>
<p>【迈克·默汉】《沙丘魔堡2》问世时我们觉得大为震撼，感觉这种游戏题材真是酷毙，沙丘2仅限单人，我们就想，即时战略中如果能多人对战岂不是碉堡了。当然，那时我们都局限在魔幻题材下，专注魔幻30年可是我们的成功秘诀啊。</p>
<p>考虑到即时战略游戏的复杂性不适合手柄，《魔兽争霸》成为暴雪公司第一款 PC 专属作品，这也是他们首款自主发行的游戏，同时利用戴维斯和联营公司已然发展成熟的销售网络。游戏中两个种族的平衡性近乎完美，这是因为双方本质上一样，除少许例外，每个种族的攻击力和血量都相等。尽管如此，游戏画面堪称美轮美奂，魔幻背景的情节也是引人入胜，此外更有局域网多人对战模式，也允许技术宅们采用 IP 直连。尽管有这些限制，游戏引发的狂热对战浪潮真正是前所未有，作为沙丘2之后仅有的一款即时战略游戏，市场前景无法估量。《魔兽争霸：兽与人》一上市便受到欢迎，销售业绩颇佳，虽然算不上里程碑式的成功，但上级公司戴维斯即联营公司已经为续作开了绿灯。暴雪公司如今算是走上了正轨，有足够的资金进一步发展并逐步拥有了粉丝群，更重要的是，他们有着完全的创造自主权，这一切，仅仅在四年内就已经做到了。《魔兽争霸》问世后，他们又信心续作能更上一层楼，其实结果让他们自己都吃惊。</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>从加州大学洛杉矶分校毕业后，三个好朋友决定放手一搏成立自己的游戏公司。『硅与神经键』在超任上出品的《RPM 赛车》获得成功，并成为第一家为该平台开发游戏的美国公司。在制作几部移植作品之后，他们继而推出了《失落的维京人》和《摇滚赛车》等原创作品。1994年，这家新兴企业经历了不少变动，包括被戴维斯及联营公司并购，以及更名为暴雪娱乐，除了平台动作游戏《黑色荆棘》外，暴雪还推出了《魔兽争霸：兽与人》，魔兽作为整个即时战略类型游戏的第二款作品，更引入了前所未有的多人游戏模式，该作在评论界广受好评，全球销量也不错，暴雪公司逐渐得以立足，《魔兽争霸》成为了公司自主发行的首款游戏。时值1995年，暴雪在计划开发数款续作的同时，也在着手扩展公司的发行业务，期间暴雪逐渐脱颖而出，成为行业的佼佼者。</p>
<p>1994年暴雪再度接受委托，制作一款 DC 漫画超级英雄题材的游戏，《正义超人大对决》把漫画书的偶像英雄们带进格斗世界，此时格斗游戏作为新的游戏类型很受欢迎。发行商 Acclaim 召集了数家开发商共同开发，其中暴雪负责超任版本的制作，世嘉版则由位于红木城的 Condor 娱乐工作室开发。尽管两个小组之前没有合作经验，暴雪的 CEO 艾伦·艾德涵在一次大会上同 Condor 的几名负责人偶然会过面。之后在1995年1月，暴雪公司接到了一个意料之外的电话，是 Condor 打来的，后者正在开发一款完全原创的新游戏，想要找发行商。他们找遍了所有的大发行商，甚至连小一些的发行商也找过，但都无功而返，发行商们都认为 Condor 一定是秀逗了：这家工作室毫无 PC 平台的经验，却妄想开发一款史诗题材的粘土动画式回合制动作 RPG。如今 Condor 小组饥不择食，转而向在大会上仅有一面之缘的暴雪求助。暴雪在这个项目上看到了一些与众不同的东西，他们认为将有机会出品一款前所未有的崭新佳作，最后他们同意签约，Condor也有幸成为第一家为发行商暴雪制作游戏的公司，这款游戏的名称暂定为《暗黑破坏神》。</p>
<p>在 Condor 权力着手开发的同时，暴雪的《失落维京人2》也推出了，三名勇敢的主角再次被 Tomator 外星人绑架，不过这次他们学会了用外星人的武器武装自己，甚至还有龙和狼人加入队伍。从游戏性来说角色数量和能力都增加了，不过3名角色的限制还在。2代虽然没有带来前作那样的轰动，却也受到了好评。此时暴雪正在开发另一款续作，这是一款各方面都超越前作的游戏。《魔兽争霸2：黑潮》于1995年12月出品，表面看来同初代极为相似，都是魔幻背景的即时战略游戏，有着相似度颇高的两个种族，然而通过对几百个细节的关注，续作真正将该模式提升到了完美的极致。</p>
<p>【弗兰克·皮尔斯】可以说，魔兽2是第一款真正体现出暴雪精益求精风格的作品，通过千锤百炼制作出一款精品。虽然之前的作品也并非泛泛之辈，但是此时我们才真正展现了才华。</p>
<p>【迈克·默汉】我同意，并且魔兽2可以说是各方面都更进一步，游戏人数增加，解析度提高，有海陆空三军。我们在魔兽上投入已经一年，因而小组很清楚自己在开发时应该要做什么。</p>
<p>在《魔兽2》的许多改进中，对 RTS 类型最具重要意义的是持续存在的战争迷雾。在之前的即时战略中，地图区域探索过之后就持续可见了，魔兽2则不同，只有当玩家的单位正位于一个区域时，才能看到该处的状况，侦查因而成为对战中的关键之一，该设计被战略类游戏广泛采用。在本作中，暴雪的幽默和个性发展成了一种标志性的特色，无论是史诗剧情，还是单位的回应方式都大放异彩。游戏中充满生机的世界观，加上独有的个性从此成为暴雪与众不同的标志。另外2待最显著的改进都在多人游戏方面，对战不仅仅局限于一对一，分组对战中每组可容纳多达4名玩家，由此引入了大规模混战以及惊人的战略复杂性。然而在连接方式上，仍然仅限于局域网或 IP 直连。不过年内早些时候，几名爱好者编写了外挂程序，使得游戏跨域局域网在互联网上对战成为可能，这个程序名叫 Kali。这款并非暴雪操刀的第三方程序为魔兽2推波助澜，使其获得了空前的成功。</p>
<p>【弗兰克·皮尔斯】魔兽争霸一代很酷很有乐趣，但是在玩家社群方面颇受限制。我认为凭借互联网发展起来的魔兽2玩家群体对我们至关重要，他们的忠诚是无价的。</p>
<p>此时还有一场对战正在如火如荼地进行，这就是暴雪公司和即时战略元祖 Westwood 之间的较量。仅在魔兽2发售前几个月他们推出了《命令与征服》，另一款制作精良的战略游戏大作。两款近似的大作接踵而至，使得 RTS 类型空前火热。当然两款游戏各有其重视的拥趸群，互联网上也掀起一场关于孰优孰劣的大论战。至今不变的只有一点，对于狂热的粉丝来说，萝卜白菜各有所爱这种事情真是让人难以接受啊。当然，多亏这些唇枪舌战，两款游戏更为引人注目了。在暴雪方面，魔兽2的销量继而暴涨，仅在4个月内就售出50万份，对于1995年的一家小工作室来说，这是惊人的成绩，最终该作的销量甚至超过了神器的100万份，在当时少有游戏能享受此殊荣，对于10个月的开发期来说，这算是挺不错了。</p>
<p>在魔兽2已经颇具人气后，暴雪决定趁热打铁出资料片，由于他们自己正忙于新项目抽不开身，便将《黑暗之门》的开发交给 Cyberlore 工作室，后者于1996年完成了制作。同时 Condor 正在不遗余力进行《暗黑破坏神》这款回合制粘土动画动作游戏的制作，并取得了不错的进度。然而，新的发行商暴雪坚持要让他们做出一些改动：首先，要求他们把粘土动画改为3D 动画，此时3D 正在迅速崛起成为未来的新标准，而粘土动画这种方式也太怪异了；此外暴雪还希望 Condor 将回合制改成即时。Condor 起初的反应是抗拒，因为目前为止的制作都是围绕回合制来进行的。</p>
<p>【弗兰克·皮尔斯】两个工作室之间的沟通有了障碍，当时同他们工作室的远距离交涉是个很大的挑战，我们自己还很稚嫩，在项目管理方面初来乍到，他们也是头一次涉足游戏制作业，总之加上地理上的距离，使得我们的合作颇具挑战性。最后他们同意制作一份技术掩饰，测试实际的游戏效果。</p>
<p>Condor 立即就意识到采用即时方式后，游戏变得更为引人入胜了，于是他们把即时方式彻底应用到游戏中。很快暴雪就意识到，Condor 的这个项目将会是个惊天动地的大作，他们不满足于仅仅做发行商了，他们要自己拥有《暗黑破坏神》。</p>
<p>【迈克·默汉】Condor 正在开发《暗黑破坏神》并且进展相当顺利，彼此合作也很愉快，我们想把他们吸收过来成为兄弟工作室，于是同联营公司即我们的母公司提出了这个想法，他们也很有兴趣，于是不久后 Condor 成为了暴雪北方。</p>
<p>在1996年E3上，该作品终于向公众展示了庐山真面目并引起了很大反响，这种新颖的游戏设计真的是前所未见。凭借魔兽2，暴雪已经成为世界上最炙手可热的开发商之一，在同年 E3上，暴雪公司还有两项重大事件要发表：首先是 Battle.net 这个免费的在线多人游戏服务平台将同《暗黑破坏神》捆绑提供，玩家们无需再从 Kali 等第三方软件处寻求帮助。暴雪开始提供自己精心打造的联网服务，以供玩家通过互联网进行随机多人游戏。其次发表的第二项内容就不怎么让人惊喜了，这就是『无聊的魔兽争霸科幻山寨版』，连名字也如出一辙——《星际争霸》。最先暴雪的展台上有3个屏幕用于《暗黑破坏神》，另外三个用于《星际争霸》，到了展会结束时，星际被缩减到只有一个屏幕了。星际同去年的魔兽2相比，画面上没什么进步，游戏方式也是平淡无奇，当暴雪北方正在着力制作一款前所未有的创新作品的同时，他们的南方兄弟小组却似乎在用旧创意炒冷饭。展会后，暴雪必须要决定《星际争霸》何去何从，游戏已经有了相当的开发进度，而得到的反响却只能说差强人意。</p>
<p>【迈克·默汉】那届 E3有很多开发中的即时战略游戏参展，全都令人耳目一新，我们回到公司后开始讨论 RTS 类型的现状以及发展方向，并且意识到应该在《星际争霸》上做到百尺竿头更进一步。</p>
<p>最后他们做出了艰难的决定，将目前的进度放弃从头开始制作，而不是勉强发布一款平庸作品。之后几年内《星际争霸》从人们视野中消失了。与此同时《暗黑破坏神》却充分吸引了公众的关注，大有不征服市场不罢休之势，然而为了确保品质，暴雪未能按计划在1995年圣诞假日发售游戏。</p>
<p>【弗兰克·皮尔斯】《暗黑破坏神》的收尾工作到了关键时期，暴雪南方的员工们也临时到北方分部协助工作，而 Battle.net 的开发则在暴雪南方这边进行，我们在 Battle.net 平台的开发和暗黑的开发之间协调，并为即将发售的游戏提供支持。实际上《星际争霸》小组的大部分成员也被我们指派去协助暗黑的开发。人们所不知道的是，在《暗黑破坏神》中加入 Battle.net 支持这个决定是在游戏快接近完成时才做出的，因为这个点子太新，在上面投入的时间也短。</p>
<p>整个 Battle.net 的开发只用了几个月，实际上游戏于12月26日开发完成，刚好比圣诞节晚了一天，最终，游戏于1997年1月2日发售并引起了巨大的轰动。《暗黑破坏神》中的 RPG 升级体系和动作要素相辅相成，无疑是最完美的游戏设计，通过史诗般的剧情来完美衬托游戏过程，构成了引人入胜的世界观，更别处心裁的是，每个玩家经历的游戏体验都不同。这全靠随机声称的地牢设计，使得玩家每次冒险时见到的地形、物品和怪物都不一样，暗黑由此获得了杰出的重复可玩性，对于设计一成不变的游戏来说，这是不可企及的。此外玩家还能同他人结伴进入地牢冒险，游戏支持多人合作模式，最多同时支持4名英雄联手对敌。遗憾的是，在合作模式中没有关闭互伤这一选项，杀死盟友这种事情时有发生，这导致不少玩家故意杀光盟友以博得一笑，多么的邪恶啊！</p>
<p>除去游戏本身优越的品质外，《暗黑破坏神》也是暴雪采用专门小组制作剧情动画的首款作品，后者的任务是制作高品质预渲染的过场动画，为暴雪的游戏增光添彩，使其在同行间脱颖而出。以今天的眼光看这些开场画面颇为过时了，但它们代表着暴雪公司另一个标志性特色的开端。以上这些结合在一起，为暴雪公司带来又一款里程碑式的成功作品。《暗黑破坏神》最终销量也超过了100万，这是暴雪在魔兽2之后紧接着第二次实现这一成绩，当时能达到这个销量的游戏寥寥无几。暴雪公司如今已跻身整个行业最杰出的开发商之列，他们的游戏无论在制作精美度、表现方式和个性上都难有人与之并驾齐驱。他们当前唯一的问题就是那款舅舅不疼姥姥不爱的『魔兽科幻版山寨』，改进游戏质量的尝试也已停滞。现在的问题是：《星际争霸》究竟能否脱胎换骨，成为不愧于暴雪大名的又一款佳作？</p>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>1997年末的暴雪正是鸿运当头，从三名怀着梦想的毕业生这一平凡的起点，发展到连续出品两款销量百万的游戏，公司获得了空前成功。《魔兽争霸2》作为即时战略游戏有着热衷于对战的庞大拥趸群，而《暗黑破坏神》中角色扮演和动作珠联璧合的形式堪称前所未有。《魔兽争霸2》由位于加州欧文的暴雪总部（暴雪南方）出品，而《暗黑破坏神》则由位于圣马特奥的首家分公司暴雪北方制作，凭借两款大作和两家颇具实力的公司，暴雪似乎已然屹立 PC 市场。然而问题来了，欧文团队当前的项目在首次测试中遭到失败，除了游戏背景设定在太空之外，这款新作其实与《魔兽争霸》八九不离十，甚至名字听起来也相当一致——《星际争霸》。1996年 E3上的玩家和评论家们对这款新作丝毫不感冒，不过凭借着麾下的两款超级大作，暴雪能够调用足够的人力物力重新来过。所以，当北方小组开始着手开发《暗黑破坏神2》的时候，南方小组则推倒了《星际争霸》的全部进度，从零开始设计。</p>
<p>《暗黑破坏神》广受欢迎，资料片也毫无悬念地推出了，不过如同魔兽的资料片《黑暗之门》，《地狱火》并非由暴雪自己操刀制作，而是外包给 Synergistic 软件公司并于1997年11月发行。暴雪北方手头有更为紧要的工作：出品一款完整的续作，此时离二代问世还有数年。而南方小组的《星际争霸》终于开始收尾，并在1998年3月面世，这款游戏的里里外外都被重新制作一遍，从而在外观、游戏体验和手感上都焕然一新。其本质仍然是一款围绕资源、建筑和单位的即时战略游戏，但却有着革命性的彻底改变：三大种族不再彼此雷同，而是每个都独一无二，一个种族的玩法要套用到另一种族就完全行不通，这使得任何一场赛事中的战略以指数级复杂化，根据对手种族的不同，玩家必须要采取不同的打法，此外《星际争霸》的故事叙述水平更是登峰造极。《魔兽争霸》的剧情引人入胜，但仅限在人物之间的过场部分由旁白来讲述，兽族和人族的剧情体验明显一分为二，并无关联。《星际争霸》与此相反，整个剧情一气呵成，从人族开始，接着是残暴的虫族，最后以高等外星文明神族收尾，故事通过形形色色的角色之间的互动来讲述，其中许多角色都可以在任务中实际操作，这些角色在任务过程中甚至还会继续交流。换言之，剧情叙述和游戏过程一起构成了天衣无缝的娱乐体验，没有任何一款即时战略游戏能够与之媲美。</p>
<p>【迈克·默汉】我们认为背景故事对于玩家的投入度相当重要，首先要让玩家觉得自己在游戏中的行为师出有名，但最重要的是，暴雪的核心价值是游戏性第一，游戏性就是一切东西的核心，从游戏性角度出发，如果一种设计比其他设计更有趣，我们就会尝试从剧情方面来迎合游戏性的需求。</p>
<p>此外还有一个卖点，就是所谓多人对战，《星际争霸》全面支持暴雪的 Battle.net 服务，用于多人对战，尽管理论上同《魔兽争霸2》相比没有太多改变，三个截然不同的种族再加上多姿多彩的战略深度，在多人游戏中得以发挥到极致。《星际争霸》让人真正废寝忘食，到了史无前例的地步，那么销量究竟如何呢？可以这么说《魔兽争霸2》和《暗黑破坏神》各发行一百万份实现了巨大的商业成功，《星际争霸》也卖出一百万份，而且仅仅是在韩国这一个国家里。在韩国，一百万的销售量已经占到其人口的百分之二，再算上全球其他市场的销量，《星际争霸》一跃成为有史以来最畅销的 PC 游戏之一。</p>
<p>专业游戏联盟如雨后春笋般诞生，《星际争霸》也成为运动赛事中的竞技项目，问世十年后仍经久不衰——对于瞬息万变的游戏业来说，十年就是永恒。在韩国《星际争霸》至今仍然是一项重大观赏性运动，与传统运动分庭抗礼。最后《星际争霸》的累计销量达到了惊人的1100万份。在此之前暴雪已经跻身世界最成功的游戏开发商之列，现在更是天下无敌，从剧情到手法，再到表现形式，他们重新定义了战略游戏，甚至整个游戏媒介本身，该游戏影响之深远，甚至在1999年5月，发现号航天飞机执行首次国际空间站对接任务时也携带了一份。暴雪本可以做一部平庸作品了事，但凭借着对完美的执着，《星际争霸》成为了永恒经典。当然其资料片也很快跟进，如暴雪早期其他游戏一样，前两款资料片由第三方制作，由 Aztec New Media 制作发行的《起义》讲述了同主线剧情平行发展的分支故事，三个种族各有一套战役；《反攻》由 Stardock 开发，其本质基本相同，也是每个种族一套新战役，两套资料片在评论界波澜不惊，发行量也不大，如今它们已经被遗忘，无法购买得到。</p>
<p>终于在1998年11月，《星际争霸》的最后一款资料片问世，并引起了前所未有的巨大轰动。《母巢之战》从每个方面对游戏做出了核心上的彻底改进，非但延续了剧情，还引导其进入了全新的领域，同时针对多人对战进行了全新设计和扩充。该资料片显然不是由第三方制作，而是由暴雪自己在 Sapphire 公司的协助下亲自操刀完成。《星际争霸》的资料片中，只有《母巢之战》至今还广为流传。其后很长一段时间内，星际系列都没有发行续作。</p>
<p>暴雪接二连三的辉煌令人头晕目眩，人们往往忽视了他们的失败作品。《魔兽争霸：氏族之王》计划成为一款关于萨尔个人经历的冒险游戏，讲述一名逃跑的兽族奴隶如何陈伟氏族之王的故事。不幸的是，尽管部分暴雪员工对该作抱有相当的热情，其他人却不以为然，他们认为该游戏不符合暴雪的黄金标准，而且在98年2D和冒险游戏已经倍受冷落，另一个障碍源于该作的开发商 Animation Magic 远在俄罗斯，造成暴雪和他们之间的沟通困难，更糟的是当这款游戏正准备发行时，LucasArts 抢先发布了《猴岛小英雄3》和《冥界狂想曲》，暴雪意识到这两款优秀作品真正将冒险类游戏发挥到了极致，远远超过《氏族之王》。这是相当严峻的，如果他们迎头而上，照原计划发行游戏，玩家们会感觉这只是暴雪的一部跟风之作。最后的消息是，在离预订完成时间只有3个月的时候，暴雪取消了这个项目，他们再度贯彻了要么不做，要么做到完美的准则。</p>
<p>1998年还有一项重大改变：最早提出成立工作室的共同创始人艾伦·艾德涵辞去了暴雪总裁一职，作为总裁他一直从事商务领域的工作，因为期望回归到游戏制作上来，于是他和另一位创始人迈克·默汉交换了职位，后者至今扔担任该职。1999年暴雪公司没有大的动作，没有发行作品，甚至《暗黑破坏神2》也只预订在圣诞假期旺季发行，其延迟发售无疑让拥趸失望，然而此时人们已经习惯了暴雪为持续改进作品而跳票的方式，9月他们宣布《魔兽争霸3》即将发表，该作集公司最擅长的两种游戏类型于一身：即时战略和角色扮演，即时对暴雪来说这也是很激进的。游戏有六个种族，游戏视角始终以主角的英雄单位作为核心，类似《暗黑破坏神》，其他单位根据英雄发出的指令动作，而不是由玩家直接操控。游戏将采用无缝衔接的场景，由角色之间的对话场景来代替载入画面，除了期待暴雪下一部完美大作之外，粉丝们别无他求，全盘接受。然而有个小问题：在公开宣布后，暴雪制作了游戏概念的内部试玩版——效果连他们自己都讨厌。着手实验了自己的想法后，他们在意识到它有多糟糕。于是在2000年的 E3上暴雪发表了爆炸性消息：他们已经在着手全面改变《魔兽争霸3》，在保持英雄单位重要性的同时，使其更加接近传统即时战略，这也遭到了反对，因为这代表又一次延期，同时给人一种暴雪拒绝创新，却返回到保守安全领域的感觉。</p>
<p>人们再次议论纷纷，暴雪的游戏虽然品质优良却缺乏根本的创新，然而仅在一个月后暴雪就挽回了名声：2000年6月《暗黑破坏神2》终于问世，在最后一年里，初代的制作组暴雪北方日复一日埋头苦干，只为实现让续作在所有方面都超越前作的初衷。《暗黑破坏神2》有着更丰富的剧情，更庞大的关卡，更多的职业，全新的技能和各式各样种类繁多的武器装备，如此多的游戏内容的制作使得小组成员几乎崩溃，但最后证明这是值得的。《暗黑破坏神2》是一款当之无愧的动作游戏经典，游戏主角在地狱烈焰中的英勇征战令人热血沸腾，游戏当然不是没有缺点的，同4年前的初代相比，画质并无飞跃，游戏首发的几周内 Battle.net 服务也经常崩溃。但游戏在直观、流畅的操作和令人废寝忘食的游戏性方面脱颖而出，以上都是瑕不掩瑜。《暗黑破坏神2》成为了暴雪迄今销售最快的游戏，问世仅一个月就卖出了一百万份，本作经常被誉为游戏史上最优秀的动作 RPG，毋庸置疑的说，暴雪公司现在已经是全世界最受推崇最成功的游戏开发商之一，他们发行的每一款作品都能轻松达到百万销量，并随即成为游戏业的经典作品。暴雪已然称霸了90年代，而新世纪00年代也将成为他们的囊中之物，此时距暴雪成立甚至还不到十年。</p>
<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>自90年代起的10年间，暴雪娱乐从起初的无名小卒发展为如今的 PC 游戏界大亨，早起的《魔兽争霸》和《暗黑破坏神》的成功，推动了其续作达到新的高峰，经历了艰难的起步后《星际争霸》创造的传奇达到了艺术的高度。自1995年起，每款单机游戏至少卖出了100万份，且逐年递增。暴雪在创造方向和财政上都享有自由，他们的所有想法都得以实现，把游戏做成他们理想中的那样大胆而多样化。但出于各种原因，2000年年初时公司经历了数次挫折且几名高管卸任，最终仅有两款《魔兽争霸》系列的游戏见到了黎明的曙光，这两款游戏跻身于史上最知名最具影响力和最成功的游戏行列当中。即使是在糟糕透顶的时候，暴雪响当当的名号仍然如雷贯耳。</p>
<p>1998年11月，在完成了资料片《星际争霸：母巢之战》后，暴雪在加州欧文地区的主团队氛围两拨，一拨队伍负责新一代实时策略游戏《魔兽争霸3》，而另一组筹备全新科幻角色扮演游戏《Nomad》，遗憾的是《Nomad》 还没来得及对外宣布就胎死腹中，这就意味着该小组必须另辟项目。此时公司的另一个工作室暴雪北方正红得发紫，在2000年发布了《暗黑破坏神2》后，他们又自行开发了资料片。这种自行开发资料片，而不交给第三方的做法前所未有，如今《母巢之战》起头，暴雪所有的资料片都由游戏的原班人马操刀制作。这种新的策略效果显著：2001年6月发布的《毁灭之王》获得了巨大成功，暴雪北方便趁热打铁着手开发《暗黑破坏神3》，与南部兄弟小组在冒险游戏《魔兽争霸冒险》和《Nomad》项目上屡屡受挫不同，暴雪北方似乎志得意满，他们绝对没有想到，暗黑2将会是他们出品的最后一个游戏。2001年9月，暴雪宣布了一款新作，它是《Nomad》制作小组的后续项目。</p>
<p>【弗兰克·皮尔斯】当时许多成员都在玩大型多人在线游戏，在《Nomad》项目毫无进展的时候，我们决定改变方向打造大型多人在线游戏。关于应该采用哪个系列来做网游，以及是创造一个全新世界好，还是尝试利用现有游戏系列的题材好，我们都做了讨论。当开始审视魔兽系列时，我们觉得找到正确的题材了。</p>
<p>这就是《魔兽世界》的起源，然而按照暴雪的一贯作风，游戏并无确切的发布日期，考虑到小组精益求精的制作态度，游戏很可能数年后才会与玩家见面。同时南方小组正在为其它魔兽系列游戏收尾，2002年7月问世的《魔兽世界3：混乱之治》在初期理念上作出了大幅度的变动，原定的6个种族缩减到了4个，倍受关注的英雄角色并非玩家扮演的主角，而是强化版的单位，也就是说，游戏是传统的即时战略，英雄角色仅用于增色添彩。不过它在某些方面还是领先的：其一，它是暴雪的第一款全3D 游戏，尽管对游戏性没有造成太大的影响；其二，工作室在预渲染过场动画领域更上一层楼，这使得小组能够将单调的剧情叙述变得前所未有的充实，而游戏角色们仍然是焦点，这也也成就了一款注重情节的策略游戏，前无古人。除剧本外，更有暴雪一贯在游戏性方面的完美平衡，以及每个种族的独一无二的设计，所有这些加在一起促成了一款精品，至今仍被认为是最佳策略游戏之一。与《魔兽争霸》前作一样，本作也成为了世界级专业游戏锦标赛的典范。资料片毫无悬念地接踵而至——即2003年的《冰封王座》，与《暗黑破坏神2》一样，资料片同样由原班人马操刀完成，在保有原汁原味的同时确保了同等的高质量。归功于长篇的新剧情以及多人模式添加的多个新单位，资料片几乎是一款全新游戏。</p>
<p>现今，暴雪旗下三个主要游戏系列都在开发新作品，暴雪北方在开发《暗黑破坏神3》，南方分部着手《星际争霸》的续作以及《魔兽世界》，第三个小组『虚无软件』则在研发全新的《星际争霸》系列作品。2002年启动，预计2003年发布的《星际争霸：幽灵》将成为家用机上的第三人称动作游戏。尽管从1995年后暴雪不再涉足家用机领域，但这款游戏却完美复合家用机的模式，在星际大背景剧情下，故事围绕人族的高级特种兵展开，玩家对此的反馈很不错。暴雪几年内发布了许多截图、预告片以及文章，但游戏本身却不见踪影。按老规矩暴雪将游戏改了又改，发布时间一延再延。此时对《幽灵》团队来说是屋漏偏逢连夜雨，2003年6月《暗黑》项目领导人离开了暴雪北方，这些人起初成立的『秃鹰工作室』被暴雪吸收到麾下，而暴雪本身又是其他集团的子公司，当感觉到自己已经不再参与重大决策且无法保障自身成员的收益和前景时，暴雪北方管理层提出了抗议，他们甚至以辞职威胁获取话语权，不幸的是，辞职得到了批准。</p>
<p>失去领导人后，《暗黑》团队遭受了无法弥补的损失。祸不单行的是，2004年1月暴雪原团队的领导人也辞职了。艾伦·艾德涵大学毕业后按照自己的想法建立了一个游戏公司，13年后他选择退出。长时间高压的工作打垮了他，如今他希望投身金融领域，他的职位由共同创始人迈克·默汉接替，因而公司并未发生巨变。同年，暴雪停止聘用『虚无软件』公司开发《星际争霸：幽灵》，该游戏至今搁浅无人过问。不过欧文地区团队仍然对《幽灵》信心十足，并且让『飞猿工作室』继续这个项目，『飞猿』最终被暴雪收购，更名为暴雪家用机分布，之后所有暴雪公司的游戏不再外包，全部内部制作，于是《幽灵》的制作得以继续，然后就没有然后了…..与此同时，暴雪自己的续作《星际争霸2》却遥遥无期。</p>
<p>员工陆续辞职，公司屡屡受挫，有人开始觉得暴雪的巅峰期已经结束。之后在2004年11月，即第一款《魔兽争霸》出品后10周年，《魔兽世界》终于问世。历经4年开发，本作是工作迄今为止规模最大，投资最多的项目，公司成败在此一举。不过暴雪对本作仍然满怀信心，并预期实体店的销量能在第一年达到40万。</p>
<p>【弗兰克·皮尔斯】按现在的标准，我们当时的预计销量极为保守。我们在北美的设备能够为40万到50万活跃用户提供支持，当时估计，如果能在北美发展这个数量的用户就谢天谢地了，然后在以此为基础将魔兽系列游戏发展壮大。</p>
<p>仅仅在第一个月内，他们就如愿以偿，大型多人在线游戏当时还在蹒跚学步阶段，数千玩家汇聚在一个庞大的虚拟世界中，这在当时可是小众游戏，在重点市场如欧洲等地区少有人问津。《魔兽世界》靠离经叛道成为一匹世界级黑马，上述偏见自然也消失殆尽。该游戏类型的优势之一是公司可以向玩家收取月费，从而抵消游戏的开发维护费用。然而当用户群高达数十万之多，就形成了一种盈利模式。在不到一年里，《魔兽世界》用户增加到了史无前例的400万，每名用户的月费加起来，使得本作成为获利最高的单款游戏。否定论者说暴雪在走下坡路，而《魔兽世界》做出了有力的回击，数年来本作的人气有增无减，原班人马制作的每款资料片都在发售后被抢购一空，创造了记录，用户人数从600万逐渐增长到现今的1200万。这首先说明游戏的销售量至少也有1200万，再考虑到有些玩家购买游戏后又停止了付费，实际销量应该更高。另一方面，如果把全球所有玩家的付费加个总和，意味着暴雪仅靠月费每年就能赚取10亿美元，在过去整个游戏史上这是闻所未闻的。</p>
<p>是什么让人们对它如此着迷？和其他暴雪游戏相同，本作并无任何真正意义上的全新内容，游戏紧贴已然成型的大型多人在线游戏模式，以魔幻角色扮演为题材，着重升级和装备搜集，然则同其他暴雪产品一样，游戏的方方面面都被加工到了完美境界，游戏十分直观友好，任何瑕疵都由负责平衡性的部门快速修正，美工华丽而亲切，战斗体验在大型多人在线游戏中被公认为最佳。当然《魔兽》的金字招牌自首发起就吸引了大批玩家，总体来说，对于打造了数款精品大作，屡屡超越大众期待的暴雪来说，《魔兽世界》是一个新奇迹，到达游戏业巅峰后，暴雪公司再度登峰造极，已经很难有其他公司与之并驾齐驱。凭借着《魔兽世界》带来的这笔意外之财，暴雪接下来的发展势不可挡。当然，他们还得接着运营《魔兽争霸》，这带来了一些问题。尽管他们的大型多人在线巨作获得空前成功，其他项目并为从中受益。</p>
<p>【弗兰克·皮尔斯】对《魔兽争霸》玩家社群的支持成为我们的优先工作，尤其在 WOW 发布初期。我甚至觉得如果 WOW没有获得意想不到的成功，《星际争霸2》的推出应该还能更早一些。</p>
<h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>2000到2005年间暴雪娱乐状况不佳，由于辞职不断和大量烂尾项目，暴雪娱乐似乎要跌下游戏霸主的宝座，但是这一切随着2004年11月《魔兽世界》的发行而改变，这个大型多人在线游戏一炮打响，成为有史以来最火爆的游戏。接下来的几年，该游戏的付费人数超过了1200万，如此可观的收益流在整个游戏界是史无前例的，意外的收获本该让暴雪能够率性而为，然而游戏的火爆度始料未及，暴雪不得不勉力扩员，确保在支持《魔兽世界》的同时还能顾及其它项目。暴雪手头已经有大量未完成的游戏，此时同魔兽系列无关的游戏统统问题不断，发行严重滞后，如今最大的问题在于，暴雪能否应付《魔兽世界》突如其来的成功？</p>
<p>尽管《魔兽世界》如此成功令人难以置信，暴雪其他的项目依然处于挣扎之中，例如暴雪北方小组制作的《暗黑破坏神3》就迟迟无法完工，虽有暗黑这面金字招牌，续作却难以与时俱进，开发团队始终想不出有趣的设计点子，更糟糕的是，按照2005年的标准，游戏画面已经颇为过时，加上暴雪北方管理人也在2003年辞职，使得《暗黑破坏神3》最终失去了方向，最后，位于加利福尼亚欧文的暴雪南方公司的执行者们不得不做出一个艰难的决定，在希望对开发团队加紧管理但却难以远距离操控的情况下，他们于2005年8月决定关闭暴雪北方，同时告知前员工们可以选择到欧文继续开发《暗黑破坏神3》。一部分人加入了南方公司，另一部分人选择离开，但不管是走是留，这一巨变对制作组的自身文化和创作独立性都造成了打击，导致了《暗黑破坏神3》项目流产，此后《暗黑破坏神3》的开发又回到原点。正如暴雪的一贯作风，《暗黑破坏神3》从大众的视野中消失了数年。但2005年也有好的消息，10月，首届暴雪嘉年华拉开了帷幕，这是由暴雪主办的大型粉丝集会。本届参加者可以第一时间试玩《魔兽世界》资料片和《星际争霸：幽灵》，后者是开发中的家用机动作游戏。拥趸们也有机会同游戏的开发者——他们的偶像们见面，这次的大会极为成功，在2006年平息一年后，从2007年起暴雪嘉年华正式成为每年一度的活动，其规模逐年增加也并非巧合，从2009年起暴雪甚至不再出席E3，从此暴雪不用再对游戏社群大力宣传招揽，而是由后者自觉地参与进来。</p>
<p>【弗兰克·皮尔斯】如今我们有其他的宣传场合，如暴雪嘉年华，期间我们向粉丝们展示一些尚未测试的游戏，让他们有机会体验试玩，我们同时有机会倾听玩家对该游戏的第一时间反馈。基于第一印象的反馈信息极为珍贵，这也是唯一的机会。</p>
<p>尽管《星际争霸：幽灵》在暴雪嘉年华上得以抛头露面，本作却再度遭到挫折。XBOX360于2005年11月发售后，暴雪清楚 PS3和 Wii 也将随之推出，暴雪不断跳票直到游戏完美方才发售的作风在 PC 上一帆风顺，然而在家用机平台上却遭到了意想不到的麻烦，这就是家用机的更新换代。为 PS2、GameCube 和初代 XBOX 主机开发的《星际争霸：幽灵》，在消耗了大量的时间和金钱后，突然沦为上一代主机的游戏，甚至离完成之日还远。2006 年3月新一轮的筛选开始了，暴雪宣布该作将无限期延迟。《幽灵》一直到现在还在推迟，其实等同于取消开发，现在已经没有人在开发《星际争霸：幽灵》，员工早已经分配到魔兽和暗黑团队了，这些小问题都丝毫不影响《魔兽世界》迅速崛起和称霸游戏界。2006年5月暴雪自豪地宣布将同好莱坞的传奇影像工作室合作打造魔兽题材电影，不久又宣布《蜘蛛侠》的导演山姆·雷米加入到该项目，之后根据暴雪的典型作风，此事淡出视线，至今仍不为人知。</p>
<p>几年过去，暴雪除了推出一个又一个魔兽资料片，再没有其它动作，然而2008年公司有了重大动向，即发行巨头 Activision和维旺迪游戏合并了，你问这与暴雪何干？1994年新兴的暴雪被戴维斯及联营公司所收购，后者被 CUC 国际收购，后者不久又和 HFS 集团合并成为 CENDANT 公司，CENDANT 被指控做假帐之后，又被卖给法国哈维斯下属的娱乐部门，后者同一年又被维旺迪收购，维旺迪 vivendi 与2007年12月宣布同游戏发行巨头 Activision 合并，获得多数控股权并成立合资公司，以上都听明白了吗？</p>
<p>2008年7月时交易完成，合资形成的超级公司在利润方面无疑是业界之最，一半 Activision 一半 vivendi 组成的合资企业并不叫做动视维旺迪，而是叫动视暴雪。暴雪坚持要把自己的名头打出去，实际上他们最初希望公司叫做暴雪动视，最后暴雪做出妥协，允许游戏界首屈一指的 Activision 把名字放在前面而自己屈居第二，这是暴雪崇高地位的不二佐证。在合资公司中暴雪享有前所未闻的自主权，作为独立工作室自主管理，做出计划后仅向动视做出例行通知，直到现在动视对此并无异议，因为暴雪在魔兽上的巨大成功使动视非常满意，今后的合作关系将怎样，我们只能拭目以待（暴雪独立了）。暴雪的自主权使得他们能够维持原有风格，不吝惜时间而努力将游戏做到最好，即时有《幽灵》的前车之鉴，其他两款倍受期待的作品；《星际争霸2》和《暗黑破坏神3》数年来依旧按部就班地进行开发。</p>
<p>【弗兰克·皮尔斯】这么说吧，即使我们拥有魔兽、星际和暗黑这些知名系列，如果你回顾我们最近10年左右的记录，你可以说我们只是一家魔兽公司，但所有这些系列对我们来说都很重要，对游戏迷也一样重要，最重要的是我们如何将优秀的游戏体验提供给玩家们，而且保持游戏背景世界观的原汁原味，我们希望忠实地实现这点。过去十年来，我们的重点都放在魔兽系列上，最大的挑战在于如何不偏不倚地把三个系列都照顾好，要知道在最近六七年来为了给《魔兽世界》提供持续支持我们付出了极大努力。</p>
<p>最终在2011年7月，《星际争霸2》在首作问世多年后推出，游戏有着庞大的非线性关卡结构，依靠过场动画衔接的动人情节，游戏中嵌入的冒险要素，改进后的战网服务，对 Mod 社群的强力支持，此外自然还有举世闻名的多人对战模式，12年的辉煌对于游戏界来说已经不仅仅是不朽神话了，凭借寿命超越想象的星际原作和暴雪响当当的名号，《星际争霸2：自由之翼》在发布的当天就销售了100万份，并在头一个月达到了300万份的销售额，同魔兽系列相比这只是一般般，但和其他游戏公司相比，这是惊人的销量。这次发行后《星际争霸2》的故事还远未结束，原版《星际争霸》被分为三部剧情，第一段针对人类，其他两段对应两个外星种族，对于2代来说，暴雪将剧情分割为三个独立的游戏，现在《自由之翼》只是在讲述人类部分的故事而已。《星际争霸2：虫群之心》预计2012年发布，而三部曲的最后一作《星际争霸2：虚空之遗》将为剧情划上完满的句号。三款组拼之间具体会有什么不同，又会提供什么新的特性来吸引玩家？暴雪会吊住大家的胃口，我们只好慢慢等待了。</p>
<p>除此之外《暗黑破坏神3》这款千呼万唤始出来的大作，在数次停牌和复牌之后终于接近制作的尾声，故事发生在《暗黑破坏神2：毁灭之王》的20年后，使得老玩家可以延续前情，而新玩家可以有崭新的开始，总体来说，游戏性和风格延续旧作，在俯视视角下身怀绝技的英雄凭借着一身极品装备，像割草般击杀大批敌人，数次迭代后，本作在画风上同暴雪其他游戏靠拢，暴雪还表示，近期的《战神》等动作游戏启发他们在《暗黑破坏神3》中加入更多的视觉冲击，引发动作 RPG 中动作要素的回归，同时他们宣称要更强调角色和剧情，实现动作 RPG 中角色扮演内容的复兴，《暗黑破坏神3》将在2011年下半年或2012年上市，这是仅有的一款暴雪向全球正式公布的游戏。</p>
<p>然而2010年11月30日，一份包含游戏发行目录的内部文件在互联网上泄密，其中提到了前所未知的游戏，包括计划在2013年发布一款代号《泰坦》的作品，据说泄密文件中还包含敏感的财政数据，之后暴雪中国的总经理被开除，一般认为这证明了本次泄密的真实性，的确《泰坦》现已被暴雪证实确有其事，这将是1995年以来暴雪首款不属于魔兽、星际或是暗黑系列的游戏。</p>
<p>【迈克·默汉】我们已经开始对一款新的多人在线网游进行开发，这并不是《魔兽世界》续作，它是一款崭新的游戏，我们尝试投入这六年在魔兽上得到的经验和教训，打造一款全新的游戏来推动 MMO 类型的发展。</p>
<p>除了这次泄密的消息，还有传言说暴雪的另一团队真在开发另一个新系列，如果属实，在近10年内除魔兽外并无建树的暴雪，将再一次开拓新的领域。现在已经知道的是，除了魔兽、星际、暗黑、泰坦各有一个开发小组外，还可能有另一对人马在从事新的游戏。如果皇天不负有心人，接下来数年间暴雪将持续发布不同系列下的游戏作品，从而再度成为一个以多款精品游戏而驰名的公司。</p>
<p>艹，也该是时候了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>暴雪的大名已如雷贯耳，虽然现在也面临着一些困难，但是回顾往昔，光芒依旧耀眼。</p>]]>
    
    </summary>
    
      <category term="Blizzard" scheme="http://wdxtub.com/tags/Blizzard/"/>
    
      <category term="历史" scheme="http://wdxtub.com/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[游戏发展史 - Interplay]]></title>
    <link href="http://wdxtub.com/2016/03/20/game-history-interplay/"/>
    <id>http://wdxtub.com/2016/03/20/game-history-interplay/</id>
    <published>2016-03-20T14:07:21.000Z</published>
    <updated>2016-03-20T14:25:36.000Z</updated>
    <content type="html"><![CDATA[<p>Interplay 对于新玩家而言已经过于陌生了，虽然早已不复往昔，但是给游戏业界留下的财富，仍旧不可估量。</p>
<a id="more"></a>
<hr>
<h2 id="u65B0_u661F_u5D1B_u8D77_Meteoric_Rise"><a href="#u65B0_u661F_u5D1B_u8D77_Meteoric_Rise" class="headerlink" title="新星崛起 Meteoric Rise"></a>新星崛起 Meteoric Rise</h2><p>布莱恩·法戈的高中生涯都在 Apple II 游戏的陪伴下度过，毕业后他想到，如果自己去设计游戏，做出来的作品搞不好比手头这些都好玩。于是1992年他以Saber 软件公司的名义制作了《恶魔熔炉》，当时孤立一人的他，花费了整整一半的预算，在电脑杂志《Softtalk》上刊登了一则广告。之后为了吸引零售商进货，他又冒充普通玩家打电话给商店，询问能否买到杂志上宣传的这款酷毙了的新游戏。</p>
<p>计谋奏效了，零售商们也开始从 Saber 软件公司订购这款游戏，他们完全没有想到的是：所谓 Saber 实际上是一人企业，而他就是冒名电话背后的始作俑者。凭着这款游戏，法戈得到了 Boom 集团的关注，后一年他被吸收到该集团为他们工作，然而，当 Boom 的一次董事会以大打出手作结时，法戈意识到是该另立门户了。于是他召集死党，在1983年城里了自己的公司。</p>
<p>当时的他们对未来毫无头绪，然而他们没有料想到，公司将要经历的一系列大起大落是如此充满戏剧性，在整个游戏史上也属罕见。这家公司从小工作室起家，发展成为一流发行商，最后却不幸破产。当年也全亏他们慧眼识英雄，才扶持了暴雪、Bioware 和 Treyarch 这些如今行业的巨头。且听我以吟游诗人的曲调，将 Interplay 娱乐公司的这段兴衰史娓娓道来。</p>
<p>起初的 Interplay 并没有什么大作为，仅仅从事一些现有游戏的跨平台移植工作，甚至还从一家军事分包商处接活。最后他们终于同Activision达成协议，从事原创游戏开发。1984年他们的首部作品，冒险游戏《Mindshadow》问世，该作一定程度上基于罗伯特·卢德伦的小说《谍影重重》。在游戏中失忆的主角必须收集线索，找回自己不为人知的过去。游戏获得了一定的成功，Interplay 在原创游戏开发方面也借此迈出了一步。仅一年后，Interplay 出品了第一款真正意义上的大作《遗忘故事第一张：吟游诗人传奇》（冰城传奇），这款角色扮演游戏大量借鉴了《巫术》系列，而后者在病危获得官方授权的情况下，完美地运用了龙与地下城（DND）的规则体系。相比之下《吟游诗人传奇》要精致的多：多色彩，游戏音效和背景音乐的加入，使得 DND 式的冒险历程更为引人入胜。</p>
<p>尽管游戏剧情比较单一，但是开场动画中由一名吟游诗人讲述故事，而后玩家亲身经历冒险的设计，仍令人耳目一新。如同之前的《巫术》，《吟游诗人传奇》中也采用了搜集装备加上练级这种令人欲罢不能的设计。此外，想你的发行商专业化的市场宣传也功不可没，这家初来乍到的新兴企业名为：Electronic Art，EA。尘埃落定后《吟游诗人传奇》一共卖出了30万份，按照1985年的标准这是很惊人的，Interplay 由此从无名小卒一跃成为行业大亨。他们的初衷是把《遗忘故事》做成一个系列，然而本作一炮打响的同时也带来了意料之外的问题，玩家们总是以《吟游诗人传奇》来称呼它。Interplay 原本计划再出两部续作，分别命名为《大法师传奇》和《盗贼传奇》，如今 EA 告诉 Interplay 说，不管他们原本计划如何，现在续作必须得叫做《吟游诗人传奇2》和《吟游诗人传奇3》。当《吟游诗人传奇》的续作陆续获得成功时，也证明了 EA 这家发行商绝非泛泛之辈。Interplay 如今是佳绩不断，如同80年代后期的大部分发行商一样，他们着力于每年推出好几部作品。1988年《吟游诗人传奇3》和《Neuromancer》，后者由威廉·吉布森的著名计算机科幻小说改编。不过 Interplay 在88年最为重量级的作品还要数《废土》，一款以核战后美国西南地区为背景的，充满着道德争议的 RPG 游戏。当时这种崭新的游戏理念前所未闻，玩家可任意探索庞大的游戏世界，而不受单线式流程设计的束缚；游戏有着丰富的剧情，多种多样的角色阵容；地牢采用重复进入时不会复位的设计，而是能够记忆玩家已经杀死了哪些怪物，解开了哪些谜题；但是最具革命性的一点是，与以往 RPG 不同，游戏中不再是善恶分明的黑白世界，玩家的选择往往位于道德的中间灰色地带，有时玩家面临的处境相当灰暗，触及到其他游戏所不敢涉足的禁区。</p>
<p>这是 Interplay 又一款成功大作，发行商仍然是 EA。此时，Interplay 终于决定不再听命于人，决定要自主发行，此时距公司最初成立仅过去短短五年。他们自己发行了《战斗国际象棋》——只是普通的国际象棋，但是加入了其他国际象棋不具备的要素——暴力。在这款国际象棋中，吃子的时候不是简单的吃，而是通过像素动画，将两枚棋子之间为争夺方格而展开的殊死决战充分表现一番，这项貌似无足轻重的小改变成功吸引了玩家，本作也获得了不错的销量。时值80年代末期90年代伊始，Interplay 意得志满，似乎达到了世界巅峰。在布莱恩·法戈和团队的努力之下，公司发展成为了 RPG 界的重量级开发商，自主发行也很成功，还有最后一道疆界需要征服，即成为其他游戏公司的发行商。看到 Activision 和 EA 从自己的游戏中获取大量利润提成，他们意识到这才是最盈利的方式。如今 Interplay 认为自己的机会来了，决定孤注一掷。当时游戏业还属于新生产业，Interplay 决定把筹码压在一些初出茅庐但颇具才华的新生小组上。</p>
<p>最早的一批中，三名自称 Silicon&amp;Synapse 的大学毕业生赫然在列，1991年 Interplay 发行了《RPM赛车》，这是超任平台上第一款由美国公司制作的游戏。这对于 Interplay 来说意义非凡，因为至今他们只在 PC 平台上有所建树，如果能成功跨越到主机平台上，他们就能一跃成为行业佼佼者。之后几年，Silicon&amp;Synapse 持续开发了《失落的维京人》《摇滚赛车》等主机作品。最终 Interplay 提出全面并购这家小公司，然后后者（现已更名为暴雪娱乐）志不在此，当时的 Interplay 并不知道这意味着多大的损失。此时 Interplay 作为开发商仍然硕果累累，1992年他们获得了将原版《星际迷航》改编成游戏的授权，这个消息当时没有引起什么关注，该剧集已经持续播放了几十年，而现在的孩子们都只知道新的《下一代》系列续集。然而《星际迷航——25周年纪念版》在商业销量和评论口碑方面都成为了第一款真正成功的《星际迷航》改编游戏。在之后的 CDROM 版中 Interplay 甚至将原班演员齐聚一堂为游戏角色配音，一个游戏能有这般待遇，挺不错了。</p>
<p>90年代里，Interplay 保留了扶持新兴公司的好传统。1995年他们发行了 Parallax 软件公司制作的《天旋地转》，当时它一般被视为《DOOM》的模仿作品，其实更应该说是启发了《DOOM》的一些游戏的后继作品，类似《银河飞将》。凭借六轴控制，逼真的画面和令人流连忘返的多人模式，《天旋地转》撑了一款小众崇拜作品。Parallax 而后分成 Outrage 和 Volition 两家公司，而后数年，Volition 都委托 Interplay进行游戏发行。他们的《自由空间》系列被认为是一直以来最优秀的太空模拟游戏之一。之后在1996年 Interplay 发行了两部机甲题材游戏，但并未激起很大的波澜。Interplay 内部制作的《铁血兵团》是公司涉足战略类型的首部作品，在 Westwood 工作室推出《命令与征服》后，该游戏类型一夜之间变得火爆。《铁血兵团》与前者有很多共同点，不同之处在于是回合制而非即时。尽管如此，游戏得到了评论界很高的赞誉，许多评论家都声称《铁血兵团》比《命令与征服》更优秀。遗憾的是，玩家们并不这么想，这从本作效良平平上也能看出。同年 Interplay 发行了机甲对战游戏《破碎钢铁》，该作也算不上成功。考虑到本作是由毫无娱乐行业经验的学生制作而成，倒也算不上惊讶。尽管如此，Interplay 同这几名毛头小子保持了良好的关系，后者自称为 Bioware。Interplay 当时没有料到，这几个加拿大小子最终会成为自己最关键的商业伙伴。</p>
<p>1997年的 Interplay 对另一家公司寄予厚望，希望能借助后者跻身顶尖发行商的行列。Shiny 娱乐公司凭借《蚯蚓战士》系列在全球市场获得了成功，衍生的玩具，T 恤和动画片也接踵而至，Shiny 当时正在开发新的《孤胆枪手》系列，其上也炒作也达到了白热化的程度。如果有什么游戏注定会成为经典大作，那么非《孤胆枪手》莫属。自然而然的，Interplay 不只满足于签订发行协议了，他们直接把整家公司买下。最终在几年的万众瞩目和媒体关注后，《孤胆枪手》终于问世，销量却很一般。虽不能说这是款失败作品，却无疑令人失望。而后 Interplay 再度寄希望于 Shiny 的《Wild 9》试图占领主机市场，结果却令他们再度失望。总而言之，看起来 Interplay 只能专注于 PC 市场，而后者的利润正在一点点被主机平台瓜分。尽管形势不利，Interplay 旗下仍然有几款拿得出手的好游戏。Stainless Games 的《死亡赛车》疯狂到了极致，将道德伦理都抛诸九霄云外，玩家通过冲撞行人，摧毁对手车辆获得分数，游戏中还大胆采用了比较原始的物理引擎，尽管如此，玩家们却为之狂热。</p>
<p>1997年还有一款大作值得一提，这是一款回归《废土》的新作，系列的所有权仍归 EA 所有，Interplay 只得从零开始设计一个新系列，《辐射》系列由此诞生。同《废土》一样，辐射是一款颠覆传统道德观的核战后题材 RPG，这次在游戏中，玩家也同样必须作出残酷的决定，而没有轻松的路线可选。幸亏有其中的黑色幽默，赋予整个游戏以后总末日狂欢的意味。艺术设计采用上世界50年代通俗小说的复古风，有着机器人，镭射枪和阴极线管。广阔的世界任玩家探索，升级系统设计既有深度又容易上手，众多角色也令人过目不忘。对于同时期游戏来说，本作的配音阵容也是空前强大，其中包括 Richard Dean Anderson，Keith David 和 Tony Shalhoub，Ron Perlman 则是旁白。如同远足《废土》一样，《辐射》也引起了巨大的轰动，然而在销量方面却无法同《最终幻想7》等大作抗衡，最终败于下风。这给人的感觉是无论 Interplay 再怎么努力突破，再怎么获得评论界的满口赞誉，他们的销量始终比不过竞争对手。而现在，长期不利经营的后果也开始呈现。</p>
<p>此时 Interplay 业务庞大，发行游戏的数量丝毫不亚于 Activision 或者 EA。游戏发行需要庞大的资金投入，但 Interplay 惨淡的销售业绩却难以提供有力的支持。在利润收入方面，PC 成功作品同主机平台成功作品完全无法相提并论，如果 Interplay 无法在主机上尽快打出一块招牌或者让更多的产品扭亏为盈，他们的前景恐怕很不乐观。事实证明，之后的发展比他们想象的要糟糕得多。</p>
<h2 id="u5DE8_u661F_u9668_u843D_Meteoric_Crash"><a href="#u5DE8_u661F_u9668_u843D_Meteoric_Crash" class="headerlink" title="巨星陨落 Meteoric Crash"></a>巨星陨落 Meteoric Crash</h2><p>成立15年的 Interplay 从一场白日梦起头，发展撑了业内举足轻重的发行商。在创立人布莱恩·法戈的领导下，公司出品的《吟游诗人传奇》《废土》等 RPG 都获得了相当的成功。他们趁热打铁，开始涉足游戏发行。首先他们自主发行了《战斗国际象棋》，而后不久便开始为其他公司发行游戏，其中就包括暴雪和 Bioware 的处女作。在1998年，Interplay 的发行量同 Activision 和 EA 等发行巨头已经旗鼓相当，而这两家公司都曾经为 Interplay 发行过游戏。</p>
<p>在外人看来，他们是被所有新兴企业羡慕的楷模，这群年轻人通过投身热爱的游戏事业打造了一个帝国。然而即使在令人炫目的成功下，Interplay的处境仍然岌岌可危，游戏发行是一项耗资巨大的业务，如果不能多发行几部销量火爆的大作，就根本毫无利润可言。遗憾的是，即使像 Interplay 自主制作的《辐射》等大销量作品也无法弥补公司赤字。尽管 Interplay 最为重量级的游戏系列接下来即将登场，无奈生不逢时，也未能挽回最终的败局。</p>
<p>赚到不少钱之后，法戈培养了艺术收藏这个爱好，并成为画家 Gil Bruvel 的崇拜者。当法戈知道 Bruvel 也涉足3D 电脑艺术时，他想到了一个主意：请 Bruvel 为一款点选式冒险游戏做美工，如果能融入文学，神话和宗教的话，新游戏将会有着更为成熟的基调。游戏将探讨原罪与救赎等深层话题，通识彻底颠覆传统。简而言之，这个游戏将作出大胆尝试，把游戏媒介从简单的『玩』上升到艺术高度，然而失败了。1998年出品的《光与暗：预言》是一款七拼八凑的游戏，矫揉造作的同时令人困惑不解，敢于吃螃蟹的少数玩家最后也冷落了它。评论界认为本作有一些闪光的设计，并对其推陈出新的大胆尝试表示赞赏。然而这些都无法掩饰剧情晦涩难懂，过程单调重复的硬伤。当销量不尽人意时，也就不足为奇了。在发行前，游戏就经手了两家制作组，Interplay 还专门邀请好莱坞明星配音，并为 Bruvel 的美工设计支付相当的报酬。换言之，公司在这个游戏上做了很大投入，无奈血本无归。本作可说是 Interplay 所面临困境的缩影，在高瞻远瞩，不遗余力拼搏的同时，缺乏有力的后援。Interplay 一心一意推动创新的努力并为得到应有的回报。</p>
<p>同年早些时候，他们发行了由新的开发商 Treyarch 制作的《剑下亡魂》，游戏采用较原始的动作控制技术，即鼠标控制主角握剑的手，移动鼠标即挥剑。可惜手感欠佳，这个重要的特性也沦为噱头，Interplay 寄希望于新意的尝试再次落空。</p>
<p>在这个多事之秋，Interplay 做出了上市的决定。如今回想起来，当时并非 IPO 的最佳时机，然而募股事务需要很长的时间准备，一旦启动便无退路。1998年6月，Interplay 正式公开招股，期望借此筹得一些迫切需要的资金。正如他们的游戏一样，招股的结果并未达到期望。最初他们希望能达到8到10美元的每股价格，事实却是当天闭市时的牌价只有6美元。了解到公司产品不卖座的情况，投资者们十分谨慎，这令 Interplay 大失所望。讽刺的是，仅数个月后 Interplay 发行的游戏便接连引起轰动，其中包括公司历史上最为成功的一款经典作品。</p>
<p>9月他们发行了黑岛工作室的《辐射2》，且问黑岛工作室是哪位？黑岛工作室即当初制作第一代《辐射》的原班小组，如今他们也有了自己的品牌。之后黑岛继而推出了一系列大作，其中大多数基于 DND 的世界观设定。至于《辐射2》，同前作相比并无太大改变，但增加了大量内容，也如同前作一样，本作只能说是勉强成功，但扔不足以扭转 Interplay 的不利局面。之后在1998年11月，Interplay 发行了 Bioware 的第二款游戏，后者的处女作《破碎钢铁》成绩不佳，在吸取经验教训后，他们继而推出了基于 DND 背景的第二款作品，期望能取得更好的销量。事实证明《博德之门》实际上成为了 Interplay 整个生涯中最重量级的系列。《破碎钢铁》的剧情较为空洞，而《博德之门》却是一款充斥着许多经典角色的亦真亦幻的史诗大作，其庞大的世界任玩家探索。游戏采用快节奏而充满乐趣的设计，同时又不失策略性。DND 爱好者们发现，这款游戏完全忠实于他们熟知的规则体系，堪称完美。随着消息在玩家中不胫而走，Interplay 忽然意识到这群加拿大小子创造了一款经典，然而事不随人愿，《博德之门》操作太复杂，无法在主机上实现，也就是说 Interplay 仍然无法进军利润最为丰厚的家用机市场。尽管《博德之门》有了这样的成绩，Interplay 的季度财政结算仍然是亏损，接下来情况还会变得更糟。</p>
<p>1999年《天旋地转3》和《自由空间2》遭到了预料之外的挫败，其原因或许是同期发售的这两款游戏过于相似。造化弄人的是，他们之后发行的由 Xatrix 制作的风格粗犷的犯罪游戏《黑街太保》刚好同哥伦比亚高校枪击案撞到一起，于是沃尔玛和百思买等大型零售商纷纷将其下架。当时 Interplay 有几个项目被取消，并正在进行公司重组，其结果就是他们字啊99年的亏损比去年更大了。之后数年我们又见到了几款成功作品，例如 Bioware 的《博德之门2》和《孤胆枪手2》，黑岛的《异域镇魂曲》和《冰风谷传奇》等，但总体而言，他们发行的大部分游戏都成绩平平。</p>
<p>最终是壮士断腕的时候了，1999年法国科技公司 Titus 互动从 Interplay 购买了大量股权，而后在2001年，他们又提高股份获取了控制权。如今 Titus 享有所有的决策权，并为 Interplay 提供一些资金，事情似乎有了转机，然而这其实就是终章的开始。Titus 公司的创始人和 CEO 埃尔韦·卡昂在 Titus 取得控制权后成为了 Interplay 的新总裁。上任之后，他首先关闭了发行部门，从此 Interplay 只从事游戏开发，由 Vivendi 负责发行。自此公司失去了曾经的行业重要地位，当然，考虑到他们之前作为发行商不断亏损，这算是一个正确的决策。然而卡昂和 Interplay 创始人布莱恩·法戈的关系，只能说是水火不容。2002年1月，接管仅几个月后，法戈离开了公司。公司的决策过程已经完全不让他参与，他完全不能接受在自己的公司里当个局外人。选择自我放逐后，他成立了新的工作室，其名字也十分贴切：InXile 娱乐（与『流亡』 in exile 同音）。</p>
<p>如今的 Interplay 已经切断了其最重要的历史渊源，随之而来的其他动荡也在意料之中。手头拮据的卡昂开始转让公司旗下的知识产权，并持续吃老本吃了好几年。首先在2002年4月，他以4700万美院的价格把《孤胆枪手》的制作组 Shiny 娱乐卖给了 Infogrames，同时转让的还有《黑客帝国》系列电影的游戏改编权。这不能算贱卖，但失去 Shiny 的损失也是无法挽回的。不幸的是，Interplay 随即受到曾经的得力伙伴 Bioware 的起诉，卡昂领导的 Interplay 不再从事游戏发行，因而尝试将 Bioware 游戏的发行权转授给他人，但并未征求后者意见。义愤填膺的 Bioware 采取了法律手段，与此同时 Bioware 同《天旋地转》的制作方 Parallax 共同起诉 Interplay，理由是拖欠版权费，安检最终庭外和解，且双方同意 Interplay 不再参与 Bioware 的下部作品《无冬之夜》。这些消息还不够坏吗？继而，因其市价不足1美元，Interplay 的股票在2002年10月被纳斯达克退市，2003年 Interplay 因合同违约被自己的发行商 Vivendi 起诉，在此期间，公司每个季度的财政仍然在亏损，最终，不可避免的事情发生了。2003年12月，Interplay 关闭了黑岛工作室——公司自己的制作部门，此时黑岛刚刚完成《博德之门：黑暗联盟2》的制作，正在展开《辐射》下一部续作的开发，其代号为 Van Buren，黑岛的一大批成员预见到了结局，已经纷纷离开另起炉灶，这就是黑曜石娱乐的由来。</p>
<p>『黑曜石』的成员们很快同 Bioware 取得联系，迅速开始合作开发一部续作，2004年的《星战共和国武士2》得以问世。如今的 Interplay作为游戏公司，既不制作游戏，也没有发行游戏，公司最后仅剩下几个游戏版权，包括《蚯蚓战士》《孤胆枪手》《博德之门》及《辐射》等等。作为 Interplay 最后的盈利手段只有将这些版权转让或授权出去，曾经的行业巨头已经跌到了谷底。</p>
<h2 id="u52AB_u540E_u4F59_u6CE2_Life_in_the_Crater"><a href="#u52AB_u540E_u4F59_u6CE2_Life_in_the_Crater" class="headerlink" title="劫后余波 Life in the Crater"></a>劫后余波 Life in the Crater</h2><p>Interplay 始于创始人布莱恩·法戈眼中自信的光芒，凭借着雄心壮志和早期几部成功作品，公司很快跻身游戏业强者之林，在自行开发的同时，也为其他公司发行游戏。然而在90年代后期，Interplay 的大势已去，尽管已经成 RPG 类型的翘楚，他们的游戏没有一款真正获得突破性的成功。更糟的是，自从家用机一跃成为最盈利的游戏平台以来，Interplay 一直无法跨越 PC 和家用机之间的鸿沟。从2000年开始，形势不断下滑，公司每个季度的财政结算持续亏损。法国公司 Titus 互动购买了 Interplay 的控制股权，其所有人卡昂也成为 Interplay 的新总裁。很快地，Interplay 的发行部门被关闭，法戈离开了公司，而卡昂开始变卖旗下的工作室和产权，最终在2003年末，Interplay 停止了游戏开发，从此他们既不再开发游戏，也不发行游戏，手头仅剩下数款游戏版权。在这种情况下，大多数游戏公司都会选择认输，然而在过去这十年间，Interplay 勉力支撑了过来并几乎回归公众焦点，最后却还是功亏一篑。</p>
<p>总之，形势相当不利，而后在2004年6月，加州政府的人员上门了，什么原因呢？原来 Interplay 已经几个星期没有给员工发工资了，而薪金保险的提供商也未能偿付，这是违反加州法律的。同时，不缴纳州税也是违反加州法律的，还有，不缴纳联邦税是违反联邦法的，猜猜 Interplay 还有什么没缴纳的？别忘了 Interplay 还欠着房东40万美元的租金。不过卡昂很快就在新的办公楼重新开工，并获得了加州的许可，不过还有个小问题，卡昂的另一家公司 Titus（即 Interplay 的母公司）碰巧破产了，并且也没有钱为员工结算工资。卡昂的所作所为并没有给人信息或让人觉得他是能够力挽狂澜的救星，在2004年到2007年这段时间 Interplay 都默默无闻，偶尔会出现消息说采用 Interplay 版权的游戏将问世，而后又沉寂下去。在最难以预料的情况下，救星降临了。</p>
<p>角色扮演游戏大厂 Bethesda 突发奇想要出品一款《辐射》游戏，鉴于两家公司的规模悬殊，他们不满足于租用版权，而是要直接买断。2007年 Bethesda 以600万美元的价格买下了这个有着十年历史的系列，双方同时约定，卡昂获得授权制作一款辐射网游，前提是自行筹资，并在规定时间内启动开发。重复一遍，Bethesda 依法『授权Interplay』制作一款辐射网游！根据卡昂的弟弟 Eric 所说，该网友的开发权价值不菲，假如 Inerplay 没有得到授权，转让费就会高达5000万美元，而非600万。Bethesda 继而推出《辐射3》并获得了巨大成功，堪称历史上最成功的 RPG之一。他们最终将《辐射》品牌成功移植到了主机上，实现了 Interplay 的夙愿。突如其来的，《辐射》又再度成为了炙手可热的游戏系列，这正是 Interplay 所需要的，他们的辐射网游也将随之一步登天。然而在2009年9月，Bethesda 一纸诉状将 Interplay 告上法庭，根据合同 Interplay 必须在规定时间内着手网游的开发，如今时间已经超过。此外，趁着新的辐射热，Interplay 又将九班《辐射》游戏再度打包发售，鉴于系列的版权已经易主给 Bethesda，后者声称这是违法的。这场版权争夺战持续了许久，在法庭争端最激烈时，Bethesda 声称当他们授权 Interplay 开发『辐射网游』时，本意是『一款叫做《辐射》的网游』，换言之，同《辐射》系列有关的一切都禁止在游戏中采用：包括武器、角色、场景和著名的 Pip-Boy。根据 Bethesda 的说法，授权范围甚至不包括经典的辐射徽标，Interplay 所能做的，只是制作一款网游并取名为《辐射》。Interplay 无疑提出了抗议，他们认为『辐射网游』的授权本质上就等同于他们可以采用其中的情节、世界背景和一切要素，他们同时还声称网游的开发已经在进行了，当然，实际的开发成果谁也没见过。在此基础上，Interplay 进而提出犹豫 Bethesda 的违约行为，《辐射》系列的版权应当归还给他们。总而言之 Interplay 的处境十分不堪，2001年6月，公司的手头现金仅有3000美元，其债务却高达300万美元，他们通知投资方可能需要裁员。考虑到他们仅有11名员工，这可不是件小事情。即使他们在同 Bethesda 的反诉讼中胜出，也只能取得开发辐射游戏的授权，却不具备实施所需的资金。当然，他们至今还有手握《蚯蚓战士》和《博德之门》的版权，如果能授权或转让出去，应该能获得一些资金，这种商业模式真够诡异的。</p>
<p>无论当今遭遇如何，Interplay 为整个游戏业界留下的财富仍然有目共睹。暴雪如今是动视暴雪的持股方（虽然现在又分离了），他们的《魔兽争霸》《星际争霸》和《暗黑破坏神》都是有史以来最成功的游戏系列，初出茅庐的他们得到过 Interplay 的扶持。Bioware 如今负责 EA 的整个 RPG 部门，他们制作的一些游戏受到评论界有史以来的最高赞誉，初出茅庐的他们得到过 Interplay 的支持。Treyarch 继而开发了《使命召唤》系列，其中最新的《黑色行动》荣登美国历史上最卖座游戏的宝座，初出茅庐的他们也得到过Interplay 的扶持。由《辐射》原班人马组成的黑曜石娱乐，最终以《辐射：新维加斯》回归到了他们所热爱的游戏系列，他们自己说，假如黑岛没有关闭，那么《新维加斯》的故事就是他们当年在续作中想要表现的。至于 Interplay 创始人布莱恩·法戈新成立的 InXile 公司，则刚刚发行了他们的最新游戏《猎杀：恶魔熔炉》，引领着我们回归到那个最初的起点。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Interplay 对于新玩家而言已经过于陌生了，虽然早已不复往昔，但是给游戏业界留下的财富，仍旧不可估量。</p>]]>
    
    </summary>
    
      <category term="Interplay" scheme="http://wdxtub.com/tags/Interplay/"/>
    
      <category term="历史" scheme="http://wdxtub.com/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[游戏发展史 - Bioware]]></title>
    <link href="http://wdxtub.com/2016/03/20/game-history-bioware/"/>
    <id>http://wdxtub.com/2016/03/20/game-history-bioware/</id>
    <published>2016-03-20T14:07:15.000Z</published>
    <updated>2016-03-20T14:21:25.000Z</updated>
    <content type="html"><![CDATA[<p>一个公司能够成为欧美 RPG 玩家心目中『经典』的代言，不得不说是有两把刷子的。</p>
<a id="more"></a>
<hr>
<h2 id="u542F_u7A0B_Setting_Out"><a href="#u542F_u7A0B_Setting_Out" class="headerlink" title="启程 Setting Out"></a>启程 Setting Out</h2><p>1995年，电子游戏已经不再只是孩子的玩具，即使是医生也可能成为玩家。就在这一年，三名医学院毕业生决定在投身医药行业之前做出自己的游戏。就是这样， Ray Muzyka, Greg Zeschuk和Augustine Yip在Zeschuk的地下室创建了自己的公司。谁能想到这样一个组合最后能成为RPG巨匠？他们的名字代表着精品——Bioware.</p>
<p>公司制作的第一款游戏叫做《超钢战神》，这是1996年的一款为MS-DOS平台执着的第一人称载具射击游戏。Bioware尝试提升游戏画面表现，将可变形地表作为一大卖点。游戏还有着复杂的背景故事，在那个年代多数射击游戏内容都只是枪枪枪，这种级别的游戏内涵着实不平常，这也成为了公司以后的立足之本。</p>
<p>《超钢战神》之后Muzyka和Zeschuk想要继续制作游戏，但作为创业伙伴的Augustine Yip决定投身医药行业，离开了公司。尽管如此Bioware还是继续制作了他们的下一款游戏《战场：无垠》并且开始寻找发行商。当interplay旗下的黑岛工作室看过游戏之后，他们并不想仅仅发行游戏，而是想将其打造为公司的标志品牌，并授权Bioware将《战场》做成一款官方D&amp;D规则游戏，结果就是1998年的《博德之门》。</p>
<p>故事发生在AD&amp;D第二版规则设定的“遗忘之地”，游戏保有一切RPG的特性，从移动、攻击到施法，一切结果都是通过计算获得的。Bioware明智地决定让这一过程对玩家不可见，如此一来，即便是从未看过AD&amp;D规则书的玩家也能很快上手，投身进“遗忘之地”之中。游戏是实时进行的，这在D&amp;D电子游戏里尚属首例，玩家可以在战斗开始前按下“暂停”，选择每个队友的进攻路线，再继续游戏观看战略实施。游戏还拥有当时的顶尖画质，充分利用了PC业界的新技术——专用独立显卡。不同于《暗黑破坏神》的杀杀杀&amp;刷刷刷，《博德之门》将重心放在了剧情上，引人入胜的史诗般任务至少花费数十小时，一个法师学徒为其师父报仇的故事都能谋杀玩家的大量时间。支线任务大多也和主线一样有趣，D&amp;D饭也能遇到很多设定中的著名角色并与之互动，对很多玩家来说是梦想成真。虽然画面在今天看来已经过时，但时至今日博德之门依旧是游戏史上剧情最佳的游戏之一。这还没完，游戏提供了多人模式，允许好友组队一起完成任务。这是首款能这么做的PC RPG，这使得游戏大受欢迎，因为核心玩家能在游戏中一路帮助他缺乏经验的朋友。所有这一切成就了1998年最卖座的游戏之一，成为一代RPG名作。</p>
<p>仅仅成立3年并推出两部作品，Bioware从医生的爱好成为了业界领导者，这一切都来得太快，没人知道他们能否将这股劲头保持下去。幸运的是，Bioware的成功之路才刚刚开始。</p>
<h2 id="u7EC4_u961F_Gaining_Allies"><a href="#u7EC4_u961F_Gaining_Allies" class="headerlink" title="组队 Gaining Allies"></a>组队 Gaining Allies</h2><p>三名医学院毕业生决定转行，他们建立了一个叫做Bioware的游戏公司。他们的第一款游戏《超钢战神》并没有在业界引起多大反响，而他们的第二部作品就是角色扮演名作《博德之门》，一夜之间便成为了炙手可热得工作室。Bioware想要继续制作这一系列，但同时又不想固定只做一种类型的游戏。刚好《博德之门》的发行方黑岛，说需要一个开发商制作Shiny小组的MDK续作。我们的RPG大师决定同时制作三款游戏：一款要比原作更庞大的续作，一款全新的RPG，一款他们从未涉足过的3D设计游戏。</p>
<p>和Shiny小组之前的作品一样，MDK是一款风格搞怪的欢乐向游戏。当得知将由《博德之门》小组制作游戏时，MDK粉丝们感到很不安，担心他们会把游戏做得太文艺。幸运的是，即使是医生也懂得欣赏拿枪的战狗，Bioware完全接受了MDK的搞怪风格，续作保持了前作的精彩和幽默。</p>
<p>疯狂科学家，会说话的狗，一代的倒霉蛋清洁工悉数回归，这一次三人都是可玩的角色。更妙的是三人的玩法完全不同，彰显了三人个性的不同。科学家注重解谜，战狗注重射击，清洁工则是在平台间跳来跳去。三种游戏方式都很精妙好玩，这令玩家喜出望外。2000年游戏发售时获得的评价颇高，很多人认为MDK2已经超越了前作，Bioware作品依旧保持了良好的口碑。事实证明他们不仅仅只会照着D&amp;D规则书做游戏。除此之外，MDK2也是公司初次涉足游戏机，DC版是与PC版同步开发的，这一经验对公司之后的作品十分重要。</p>
<p>好像是觉得2000年仅发布一部大作还不够，晚些时候，Bioware还发布了《博德之门2：安姆的阴影》。在1代取得成功之后，B社明白得付出很多努力才对得起1代建立起的名声。尽管有压力，并且很多组员忙于其他项目，发售后《博德之门2》依旧广受好评——更大，更好，比前作更漂亮。博德之门2相比于一代突破并不大，但是2代将1代已有的优点进一步完善近乎完美。游戏还有着出色得剧情以及数百小时的流程，被认为是史上最佳RPG之一。</p>
<p>如果《博德之门1》使Bioware成为了一个3A厂，《博德之门2》则巩固了这一地位。两个项目完成之后，公司还有一个项目尚未完成，依靠对质量和细节的关注，B社使《博德之门》成为了一个成功的品牌，他们也聪明地意识到Mod对销量带来的贡献。考虑到网游越来越受欢迎，公司决定将单人战役，多人体验和MOD工具三合一，让玩家自行选择喜欢的游戏方式。</p>
<p>5年的开发之后，最终《无冬之夜》于2002年发售，这又是一款设定在“遗忘之地”的D&amp;D游戏，包含大量任务和颇具深度的剧情，既可以单人游戏也可以多人合作。随《无冬之夜》一起发售的还有开发工具包，事实上就是Bioware编写游戏使用的同款工具包，最棒的是工具包支持多人游戏，也就是说可以很容易地做出多人mod。不出意料，网上很快就出现了各种类型的mod，从全新的战役，到无双割草，再到网游化mod，这一切只需要一款游戏的价格。再一次的，一款杰作诞生了。这已经使《无冬之夜》成为史上内容最丰富的游戏之一，但这对Bioware来说还不够，他们还将D&amp;D的一大特色带进了游戏里，《无冬之夜》包含了地下城主多人模式，地下城主（DM）可以在其他玩家进行任务时实时添加游戏内容，这成就了变幻莫测的游戏体验，DM可以随心所欲设计冒险任务。令人激动的，富有挑战性的，或者让人玩不下去，完全取决于个人喜好，就像经典的纸笔D&amp;D游戏玩法一样。</p>
<p>同时开发三款游戏，全都叫好又叫座，Bioware无疑称霸了美式RPG市场，同时也涉足了游戏机市场，似乎两位加拿大医生的事业已经到达巅峰。但当他们公布下一款作品时，Bioware向世人揭示了他们的梦想是星辰大海。</p>
<h2 id="u5347_u7EA7_Leveling_Up"><a href="#u5347_u7EA7_Leveling_Up" class="headerlink" title="升级 Leveling Up"></a>升级 Leveling Up</h2><p>2002年，加拿大开发商Bioware，从只能在创始人的地下室办公，一跃成为业界顶尖工作室。《博德之门》系列和MDK2大获成功后，《无冬之夜》同样也叫好又叫座。但其实早在这些游戏发售前，就有一个发行商与Bioware接洽，帮他们制作第一款RPG。于是乎Bioware和“卢卡斯艺术”共同宣布，《无冬之夜》后公司将开发《旧共和国武士》</p>
<p>“卢卡斯艺术”在1999年底便初次与Bioware接触，询问是否能制作一款基于星战EP2的游戏。随着谈判的深入，Bioware也可以选择将设定改到电影发生前的4000年，只要B社愿意。意识到这么做有更大的创作自由而不必拘泥于电影的剧情，Bioware选择将时间设定在很久很久很久以前。“卢卡斯艺术”想要他们制作一款家用机游戏，在审视了市场上现有的游戏机后，Bioware选择了即将发售的微软XBOX，因为他们认为XBOX的开发环境最好。另外这也使其成为XBOX上的首款RPG，再加上《星球大战》的名号，大卖是板上钉钉的事情，而他们押对宝了。</p>
<p>当游戏于2003年发售时，经过数次为了保证质量的延期，发售后不仅星战迷，连评论家也赞不绝口。Bioware在星战科幻背景下编写了一个原创故事，塑造了一个形象生动的角色。游戏在剧情与故事之间找到了平衡，这样一来玩家不仅能带入故事中，还能玩得很开心。</p>
<p>另外Knights of the Old Republic和B社之前作品的差异没有想象中那么大，回合战斗系统依旧基于第三版D&amp;D规则，但有了光剑、激光枪和原力，游戏带来的妥妥是史诗般的星战体验。游戏不仅在商业上获得巨大成功，还拿到了一堆“年度最佳游戏”奖，时至今日依旧是最好的星战游戏之一，要知道星战游戏多如牛毛。一款续作自然也是板上钉钉，但Bioware将开发转交给了另一个开发商，此举震惊了游戏界。比起成为另一家专职星战游戏的开发商，他们更愿意制作自己的原创游戏。</p>
<p>在发布了PC版之后，Bioware又开始同步开发多个项目。在制作了多年的授权项目之后，他们决定回归制作自己的游戏。2004年，B社公布了一个全新的奇幻RPG《龙腾世纪》，花了足足五年这款游戏方才面世。2005年他们发布了《翡翠帝国》，一款游戏机平台上的动作RPG，自B社处女座《超钢战神》发售9年后的首款非授权游戏。</p>
<p>终于完成从回合制到实时战斗的跳跃，B社将叙事与紧张的战斗相结合。游戏背景的灵感来自香港功夫片，和其他Bioware游戏一样，游戏有着众多角色和史诗般的任务，除了拥有会记录你行为的道德系统外，还可以选择发展几段恋情。《翡翠帝国》获得的媒体评价很高，但是玩家受众群没有B社想象的多。游戏销量按其他小组的水平来讲还算不错，但与《博德之门》和《旧共和国武士》相比，仅有Bioware的名字还不足以大卖。另外这款游戏也让B社意识到，游戏的开发成本在成倍增长。即使有之前的成功，他们也得更加商业化，才有自己保质保量地做出他们想要的游戏。</p>
<p>2005年Bioware与Pandemic工作室合并，这是另一家与“卢卡斯艺术”合作过的工作室。如今两家公司的资源整合到了一起，B社准备好了制作它的下一款杰作。他们意识到游戏类型的界限已经越来越模糊，Bioware的下一个项目将是一款RPG与射击游戏的混合体，令公司走进了高清时代。</p>
<h2 id="u5C5E_u6027_u63D0_u5347_Upgrading_Stats"><a href="#u5C5E_u6027_u63D0_u5347_Upgrading_Stats" class="headerlink" title="属性提升 Upgrading Stats"></a>属性提升 Upgrading Stats</h2><p>自2004年就有传言说Bioware在制作一款RPG与射击混合的游戏，但直到2005年10月他们才正式公布《质量效益》，《质量效益》被设定为一个科幻史诗三部曲。虽然他们曾经制作过MDK2，但《质量效益》是公司首次制作核心向射击游戏。一般来说射击游戏的剧情都很弱，B社想将它们擅长的高质量剧情与“虚幻3引擎”相结合，借此同时吸引RPG玩家和射击游戏玩家。和其他Bioware游戏一样，经过数次延期，终于在2007年11月登陆XBOX360。</p>
<p>《质量效益》完全改变了RPG处理对话的方式，不同于在角色头顶冒出对话框或者将画面拉到角色面前的做法，《质量效益》中的对话采用了多角度运镜手法。另外《质量效益》还打破了RPG中只有一方开口说话的传统，主角拥有全程语音，不论玩家选择的角色是男是女。除此之外，B社重新构建了道德衡量标准，并不仅仅是简单的正邪选择，所有的抉择都偏向道德的灰色地带，代表不同的处事信条，迫使玩家在做出选择时得动动脑子，相比市场上的其他游戏更具挑战性。</p>
<p>《质量效益》有着丰富的内容，充满细节的世界观，有血有肉的角色以及史诗般的任务。不幸的是，游戏在拥有出色表现力的同时，还有着频繁的贴图载入延迟问题，极大的破坏了玩家的代入感。为了赶上已经数次延期的发售日，最终导致多数支线任务都很鸡肋。与游戏故事氛围不相称的糟糕设计系统。另外不得不提一下电梯，原本设计目的是为了让游戏在漫长的载入过程中能与NPC队友进行互动，这却成为了游戏的显著缺点之一。最终瑕不掩瑜，质量效益广受玩家和媒体的赞誉，同时也是2007年圣诞购物季销量最高的游戏之一。</p>
<p>然而2008年1月，游戏因为性爱场面受到了媒体关注，专栏作家Kevin McCullough发布一篇博客信口雌黄，随后上了福克斯新闻并在节目中以“SEXBOX”为标题，声称游戏允许青少年玩家能在游戏中推倒一切，而且全程可操控，正面全裸高清无码。不幸的是，这一切全是胡扯，这款M级游戏仅包含两段非互动的朦胧性爱场面。此事证明很多人眼中游戏依旧是儿童的玩物，比起暴力，人们对色情话题更为敏感。这一切都没有影响游戏的销售，晚些时候PC版也顺利发售。</p>
<p>尽管又一款游戏大卖，Bioware明白如果想让成功延续，就得有更多的资源。于是乎，2008年，B社与Pandemic小组的合资公司被EA收购。9月份，公司出品了被EA收购后制作的首款游戏，游戏由世嘉发行，NDS平台游戏《索尼克编年史：黑暗兄弟会》。这是世嘉吉祥物的首款RPG，索尼克需要在朋友们的帮助下解开谜题使世界免遭毁灭，听起来很耳熟是么？</p>
<p>俗套的剧情加上略为无脑的玩法，对于Bioware来说有些异乎寻常。本作的媒体评价只能说是一般，然而本作也因为忠实于索尼克系列的世界观而受到好评，在近几年的索尼克游戏里亦算佳作。</p>
<p>2009年初，有了EA的资金支持，Bioware又一次同时开发多个项目，以至于在蒙特利尔建立了一个新的小组，专门帮忙处理人手不足的项目。同年6月，EA宣布Bioware与另一家RPG开发商“Mythic娱乐”合并，也就是说EA让B社全权主导Mythic。B社原工作室保持不变，Mythic直接由B社领导。换言之，EA的整个RPG部门均由这个加拿大开发商领导。</p>
<p>同月，B社发布了他们的第二款手持设备游戏，iOS平台的《质量效益：银河》。这是一款两小时流程的俯视角射击游戏，展现出Bioware将《质量效益》打造成一个多媒体品牌的渴望。</p>
<p>公司09年真正的大手笔是制作了五年的《龙腾世纪：起源》。自《无冬之夜》后B社再次回归奇幻题材，游戏允许玩家在开始主线前从6个起源故事中选择一个，当然你还是得招募队友帮助你阻止邪恶势力。与以往的B社游戏不同，龙腾世纪更加成人向，战斗过后角色满身是血，即便是好人战斗时也十分无情。不顾《质量效益》引发的争议，《龙腾世纪》也可以发生几段恋情，并且最后啪啪啪，包括同性之间的恋情。整个游戏包含数十小时的流程，尤其当玩家想体验所有六个起源故事时。游戏在PC，Xbox360和PS3上的销量还不错，但作为《博德之门》的精神续作并没有对业绩造成太大冲击。</p>
<p>接下来，Bioware与2010年1月发布了《质量效益2》，这是首款会根据前作存档改变剧情的游戏，换言之，你在1代做出的决定会直接影响到2代。职业大幅平衡，更好的战斗体验，画面提升加上更快的电梯，不仅保持了《质量效益》的好名声，还在此基础上进一步发扬光大。</p>
<p>与此同时Bioware还在制作另一款大作：《星球大战：旧共和国》。这是B社首次涉足网游领域，我们的单机巨人能否在网游界立足？本作号称是史上首款全程语音网游，包括多语言支持。有着《星球大战》的名号，公司意识到这个项目会变得非常巨大，需要一个工作室专门负责该项目，于是他们在德克萨斯州建立了Bioware奥斯汀分部，专职制作这款游戏。与此同时Bioware宣称他们还有尚未公布的游戏正在制作中，是续作还是全新的作品？</p>
<p>他们已经宣布《质量效益3》在制作中（资料为2010年数据）。尽管他们也在尝试射击游戏和网游，但有一点始终未变：他们坚信任何游戏类型都可以拥有一个好的剧情故事。多数工作室把重心优先放在玩法而将剧情放在次要地位的时候，B社证明了对于细节的追求，复杂的道德选择，有血有肉的人物塑造一样能使游戏大卖。优秀的艺术设计，颇具代入感的游戏玩法，Bioware建立了只出精品的良好声誉，不论制作的是何种题材类型的游戏。</p>
<p>15年来一直在改变业界，而一切的开端不过是几个医生的个人爱好。</p>
<p>（光口头说是不够的，如果你这么轻易就被说服，我反而会失望，你亲自去瞧瞧吧）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个公司能够成为欧美 RPG 玩家心目中『经典』的代言，不得不说是有两把刷子的。</p>]]>
    
    </summary>
    
      <category term="Bioware" scheme="http://wdxtub.com/tags/Bioware/"/>
    
      <category term="历史" scheme="http://wdxtub.com/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[游戏发展史 - Valve]]></title>
    <link href="http://wdxtub.com/2016/03/20/game-history-valve/"/>
    <id>http://wdxtub.com/2016/03/20/game-history-valve/</id>
    <published>2016-03-20T14:07:09.000Z</published>
    <updated>2016-03-20T14:10:24.000Z</updated>
    <content type="html"><![CDATA[<p>Valve 虽然从来是『有再一再二，没有再三再四』，但是不得不承认，无论是半条命还是 steam，都称得上『划时代』。</p>
<a id="more"></a>
<hr>
<h2 id="u540D_u4E0D_u89C1_u7ECF_u4F20_u7684_u82F1_u96C4_Unlikely_Heroes"><a href="#u540D_u4E0D_u89C1_u7ECF_u4F20_u7684_u82F1_u96C4_Unlikely_Heroes" class="headerlink" title="名不见经传的英雄 Unlikely Heroes"></a>名不见经传的英雄 Unlikely Heroes</h2><p>1996年，微软已经从一个小作坊成长为世界上最富有的公司之一，最早的一批员工都已经成为了百万富翁。其中两名老员工一直爱玩游戏，现在有了足够的资金做自己想做的事情，他们决定成立自己的公司。</p>
<p>不幸的是，他们对游戏开发毫无经验，只参与过操作系统以及功能性产品的编写，后来一个好友将他们介绍给了著名的id软件创始人——约翰·卡马克，卡马克说服他们应该拿到Quake引擎的许可并做一个游戏。他们同意了，并认为追寻梦想的时机已到。</p>
<p>加布·纽维尔和麦克·哈灵顿为新公司想了几个名字，包括果蝇、全息盒子以及犀牛疤痕(Rhino Scar)，但最后他们选定了一个很简单的名字阀门(VALVE)。</p>
<p>和卡马克见面后，纽维尔和哈灵顿创建了他们的公司，并在纽维尔的婚礼遮天正式注册成立。</p>
<p>【G胖 加布·纽维尔 Valve创始人】：我最初建立一家游戏公司的动机带有一定社会性，我很享受与一帮聪明人一起工作，创造能影响不同群体的游戏。1996年，我在想有哪些选择，在这个问题上我又很大的自由，环游世界，度个假什么的。我最喜欢Valve的一点就是这种特定的工作环境。</p>
<p>不同于Bungie仅靠一人慢慢白手起家，Valve想立马就开始制作高预算游戏，两个人是远远不够的，尤其这两人还从来没做过游戏。于是Valve便开始物色人才，他们的做法不同于当时业界的标准，不仅招募专业人士，还有MOD作者。他们意识到某些mod作者可能比专业人士更有天赋。伺候Valve便开始开辟新的疆土。</p>
<p>公司完全依靠两位创始人的资金运作，这样一来公司便承担得起一般小工作室承受不了的风险。然而仅有两个想追梦的人还远远不够，没有人看好他们，找到一个愿意发行他们作品的发行商几乎不可能。尤其当纽维尔和哈灵顿宣称游戏采用了极其复杂的技术时，发行商们不相信他们能兑现诺言，最后他们找上了“雪乐山在线”(SIERRA Online)，雪乐山刚好打算发行一款3D动作游戏，最好使用Quake引擎制作。Valve团队令他们印象深刻，有了足够的信心与其展开合作，即使失败了，仅仅一款游戏的合约也让雪乐山有退路。</p>
<p>年轻的Valve在1997年E3展上公开了他们的游戏——《半条命(Half Life)》。游戏展现出来的技术和氛围，使其很快成为了展会上的热点。他们做到了，<br>似乎这款游戏注定要大卖。但到了《半条命》本应发售的假日季时，Valve团队意识到产品还未完成，发售日不得不延期。但问题是，他们的发行商雪乐山已经开始广告攻势并视其为年度大作。当Valve宣布延期时，合作关系差点因此破裂。除此之外，他们决定重新审视游戏，在一年的研发时间里，团队摸索出很多尚未加入游戏中的新点子。于是Valve迈出了冒险的一步，推翻多数内容并回炉重做，以加入很多新点子。多数开发商都不会愿意推翻重做，但纽维尔和哈灵顿愿意不惜代价这么做。</p>
<p>【G胖】：每一个Valve迷都知道，Valve的游戏总延期，不是吗？在资源、质量和发售日这几个要素中，我们总是会优先选择延期发售来提高质量。我们的想法是延期总比遗臭万年要好。</p>
<p>随着回炉重做，游戏继续延期，从98年春延期到了98年夏，继续延期到了98年秋，又延期到了98年感恩节。11月时一个游戏Demo泄露到了网上引起轰动，《半条命》成为了年度热点游戏，此时游戏甚至未发售。</p>
<p>万众期待下《半条命》终于在1998年11月上市，市场反响良好。与传统利用过场动画的叙事方式（如毁灭公爵3D, Duke Nukem 3D）和压根不讲剧情（DOOM）不同，《半条命》始终以主角戈登·弗里曼的视点进行，另外故事都是实时呈现的，让玩家代入感倍增，而不只是一个旁观者。</p>
<p>通过脚本，有很多有趣的事件在玩家周围发生，从同事被怪物吃掉，到场景破坏。尤其是游戏的开场部分，大段对话后伴随着实验事故，给人感觉如同互动电影一般。另外游戏的画面与人物动作史无前例。所有者一切都超出了人们的预期。由两个无游戏开发经验的人组成的新公司做出了年度最佳游戏。《半条命》最终成为一个颇具传奇性的游戏系列，时至今日仍旧是销量最高的游戏之一，更何况1998年时的游戏市场规模远不能与今天相比。</p>
<p>随着游戏的成功，大家都想知道何时会有续作。他们会发现《半条命》的未来不仅由Valve创造，玩家自己也参与其中。</p>
<h2 id="u534A_u6761_u547D_u7684_u7B2C_u4E8C_u6625_Half-Life_u2019s_Afterlife"><a href="#u534A_u6761_u547D_u7684_u7B2C_u4E8C_u6625_Half-Life_u2019s_Afterlife" class="headerlink" title="半条命的第二春 Half-Life’s Afterlife"></a>半条命的第二春 Half-Life’s Afterlife</h2><p>《半条命》的空前成功中可以得出以下结论：</p>
<ol>
<li>Valve赢得了豪赌并由此发达</li>
<li>世界需要更多的《半条命》</li>
</ol>
<p>【G胖】：我和麦克都有操作系统及相关产品编程的背景，我们当时很确定失败不可避免，根本就没有理由相信我们会成功。总的来说从商业角度出发我们有些焦虑，问题不是之前的工作完成的如何，而是接下来该干什么。</p>
<p>Valve明白下一个项目需要花“一点”时间，在这段时期gearbox被给予开发资料片的任务——《针锋相对(Opposing Force)》。资料片足够成功，第二个资料片《蓝色沸点(Blue Shift)》【TODO 这里翻译可能有误】的制作也顺理成章。游戏发生的时间地点与原版完全一样，但以不同角色的角度讲述整个故事。《针锋相对》里扮演的是与戈登·弗里曼为敌的海军陆战队员，《蓝色沸点》则扮演的是基地保安巴尼，和原版一样都是以科学定律命名。《针锋相对》指的是牛顿第三定律，《蓝色沸点》值的是多普勒效应。尽管销量不错，但留给人们的印象并不深。制作MOD，即允许玩家深度挖掘游戏代码并改写成新游戏，这一做法被某些工作室接受，比如id软件，而其他多数开发商则不允许。Valve决定向mod社区打开阀门，因为本身公司的很多雇员也来自那里。</p>
<p>【G胖】：《半条命》的特征之一就是被mod社区广泛接受。麦克和我都有操作系统编程经验，在我们研发操作系统时总是在想我们所编写的程序间接创造的价值。你所编写的工具被用来从其他消费者那创造价值。一个好的工具对于一个大公司的价值与在澳大利亚开发《军团要塞》的两个孩子来说其实差别不大。</p>
<p>随着《半条命》大量源代码的开放，很快网上便充斥着各种MOD，其中少数几个素质几乎与原版比肩。《胜利之日(Day of Defeat)》是一款二战射击游戏；《团队要塞(Team Fortress)》是一款很受欢迎的Quake mod，应玩家要求制作了《半条命》版。</p>
<p>但《半条命》最受欢迎也是世上最成功的MOD是——《反恐精英(Counter-Strike)》。作为一款团队回合制多人射击游戏，几乎完全重写了原作。原作的多人模式就是全员无差别大乱斗，当时的FPS多人游戏基本都是如此。《反恐精英》于1996年6月进行了首次Beta测试，不到一年，mod团队就因为游戏太受欢迎被Valve收编。</p>
<p>Valve之后买下了之前提到了所有3个MOD，这3个MOD之后都成为了商业化品牌。开发商一般都不愿放出自己的源代码，担心会对自己的品牌构成威胁。Valve证明了与mode社区的开放关系其实能增加销量，毕竟想要玩DOD或者CS还得先购买《半条命》。</p>
<p>【G胖】：多多沟通、信任并与玩家社区合作，就能获得更好的娱乐体验，从长远来说你的生意也能因此获得更多利润。</p>
<p>与多数游戏刚发售时销量很高，随后便一路走低不同，《半条命》一直保持着稳定的销量，玩家也有越来越多的理由继续玩下去。不过除去这些项目，大多数人都更像知道Valve下一步打算做什么。这么多年Valve没有放出一点消息，于是流言四起。</p>
<p>直到2003年E3展《半条命》发售5年后，Valve终于再次出手，向世界展示了没人能像他们一样做出《半条命》</p>
<h2 id="u7EED_u4F5C_u98CE_u6CE2_The_Trouble_with_Sequels"><a href="#u7EED_u4F5C_u98CE_u6CE2_The_Trouble_with_Sequels" class="headerlink" title="续作风波 The Trouble with Sequels"></a>续作风波 The Trouble with Sequels</h2><p>2003年E3展上《半条命2》的公布，在玩家群里引起轰动。依靠第一部建立起来的声望，所有人的翘首以盼2003年9月发售日的到来。就在游戏即将发售的时候，意想不到的事发生了。Valve的服务器被黑了，游戏源代码、地图、皮肤被匿名黑客窃取，这是游戏史上最严重的黑客事件之一。失窃的代码足以构建数个可玩的场景，这个泄露版充满了BUG，而且多数时候都很无聊，总之不具备可玩性。更糟的是Valve一次宣布游戏不能在03年内发售。</p>
<p>【G胖】：我们已经花费数年开发《半条命2》，我们的压力很大，不仅是长时间的工作，还担心产品设计和技术上的风险。有的员工十分不安，我们制作数年的心血以一种完成度极低的形态在网上大量传播，这事令我十分痛苦。就像是一大帮人用女性角色与一个科学家XXOO的场面做新品推荐一样。有人走进我的办公室问我，公司是不是要停业了，我们是不是应该忘掉《半条命2》去做点别的，因为这个产品已经被泄露事件毁了。</p>
<p>Valve立即联系了FBI，对黑客是谁展开调查。但Valve与玩家社区也一直保持着良好的关系，决定利用这一条件帮助调查。加布·纽维尔在论坛公开确认了泄露事件，并请求在线社区帮忙找出黑客。G胖得到了压倒性的支持，在玩家回复中也逐渐弄清楚了泄露的代码是如何在网上传播开的。尽管FBI和玩家们都作出了努力，黑客的身份一直是个谜。直到黑客自己现身说法，解释了他如何黑进服务器，并向Valve索取一个职位。Axel Gembe描述了黑客行为的细节，他利用了微软Outlook的发件箱安全漏洞。并声称自己并不是一个坏人而且真心实意愿意为Valve工作。Valve欣然答应，并通知了联邦调查局为其设下圈套。不幸的是Gembe觉察到了圈套，决定不离开德国，最终他被德国警察逮捕。</p>
<p>可能是还觉得不够有戏剧性，Valve与发行商陷入了合同纠纷。在亚洲，人们更多的在网吧玩PC游戏，而非在家用电脑上，这就使得网吧成为了主要市场。发行商“威望迪环球(VIVEND UNIVERSAL)”宣称他们买断了网吧销售权，而Valve则坚持他们有权通过数字发行在网吧销售游戏。</p>
<p>卡发着意识到自己处于一个尴尬境地，那就是和帮他们卖游戏的人打官司。这个纠纷在游戏发售后依旧持续数月，最终庭外和解。经过一系列跳票，《半条命2》终于在2004年11月16日上市，历经6年制作，负面新闻不断，玩家们担心是否能达到前作的高度。</p>
<p>幸运的是，玩家的超高期待是值得的。</p>
<h2 id="u534A_u6761_u547D_u7684_u4E8C_u6B21_u65B9_Half_Times_Two"><a href="#u534A_u6761_u547D_u7684_u4E8C_u6B21_u65B9_Half_Times_Two" class="headerlink" title="半条命的二次方 Half Times Two"></a>半条命的二次方 Half Times Two</h2><p>《半条命2》于2004年11月16日上市，巧合的是，此时距离另一款备受期待的科幻射击游戏上市不过一周。这部作品的名字开头也是“HAL”——《光环2(HALO 2)》。尽管《光环2》属于年度大作之一，但即便是士官长也难掩戈登·弗里曼的光环。</p>
<p>《半条命2》在发售前就已经开辟了新的疆土，超强的source图像引擎已经被用于更新CS，在《半条命2》发售前便可以开玩。这一切由Steam带来，Steam由Valve研发并包含：数字版权管理、软件商店，之后还添加了玩家社区。Steam允许玩家在线购买游戏，并直接通过Valve服务器进行下载，服务器会检测游戏是否合法。</p>
<p>【G胖】：我们认为这对游戏开发商来说是个好机会，我们改变了游戏的发行和更新方式。我们开始寻找眼光独到的开发商帮助我们编写这个系统，让像我们这样的游戏开发商和软件开发者登陆这个平台，之前没人这么做过着实令人惊讶。一个本地的开发团队有意接手此项目，我们便开始了合作，让他们主导steam团队，最后这波人在两年内相继离职，所这可能并不是最明智的做法。</p>
<p>Seam甚至允许用户在游戏发售前预先下载游戏，当然在发售日之前你还是进不了游戏，但时间一到就能立刻开玩，不需要再进行额外的下载，这标志着游戏业向数字发行方向迈出的一大步。如此一来Valve便不用付钱给发行商，利润自然也大大提高。这一新的发行方式正逐渐改变游戏业界的面貌，Valve是这一变革的先行者。</p>
<p>《半条命2》的游戏本身也是一款杰作，在这款氛围独特的游戏里，双眼所及之处都充满了故事。Valve构建了一个活生生的世界，NPC有着很高的AI，从凶恶的敌人到惊恐的平民，NPC都有生动的面部表情和嘴唇同步，精彩的台词和专业的配音。</p>
<p>玩家将再次扮演戈登·弗里曼，这次弗里曼将在一个已经被外星人占领的世界中作战。除了著名的source图像引擎，《半条命2》还使用了当时最为先进和精确的物理引擎。这就使得HL2里能够设置几个物理谜题，作为激烈战斗之后的调剂，这也使重力枪有了用武之地。这把枪能够举起并投掷游戏中的任何物体，玩起来各种欢乐。Valve在游戏发售后添加了更多内容，购买《半条命2》的人已经免费获得了CS:S，之后还添加了《半条命2：死亡竞赛》以及一个技术演示《消失的海岸线》，V社果然很良心。《消失的海岸线》甚至还包含了开发者评论内容，这在业界是前无古人的。</p>
<p>和前作一样，《半条命2》易于制作MOD，在steam上既可以运行官方产品也能运行mod，多年后依然有大量MOD推出。其中最受欢迎的是Garry’smod，与其说是游戏，不如说是个物理沙盒。mod允许玩家利用游戏的物理系统建造出能想象出的任何东西，极大的提高了玩家的创造力。</p>
<p>所有这一切造就了HL2的巨大成功。游戏评论者们爱它，玩家们膜拜它，总之深受广大消费者的欢迎，Valve再次完成了不可能的任务。随后HL2还登陆了Xbox、Xbox360和PS3，PC游戏界的杰作终于登陆了游戏主机。和前作一样HL2也成为了史上最具影响力和销量最高的游戏之一。但是Valve不打算再等6年才发售下一部作品，公司再次突破桎梏，改变了他们制作游戏的方式。</p>
<h2 id="u6E38_u620F_u9769_u65B0_u8005_Game_Changer"><a href="#u6E38_u620F_u9769_u65B0_u8005_Game_Changer" class="headerlink" title="游戏革新者 Game Changer"></a>游戏革新者 Game Changer</h2><p>Valve并没有直接开始制作《半条命3》，而是为《半条命2》做几个资料片，这一点并没有什么稀奇的，但是在制作的过程中，Valve意识到可以借此机会实验改变游戏开发和消费者的游戏体验方式。一般来说一个小组制作流程数十小时的作品，售价一般为50-60美元，这些游戏制作非常花费时间，通常为2-3年或者像HL2这样花了6年。</p>
<p>但Valve就想为什么不直接用HL2的source引擎，只做小小的升级，在短时间内制作一个流程相对短的游戏，仅售20美元。最后的结果就是独立资料片，按Valve的说法叫章节化，巧妙地命名为《半条命2：第一章》（不需要本体即可独立运行）</p>
<p>【G胖】：总的来说我们不认为定价属于某种策略，你得给人们一些选择，在产品之间有比较。价格因素能吸引大量不同的消费者，从而提高收入。我们在《半条命2》上运用的章节化做法本身对游戏内容的主干没什么影响。</p>
<p>第一章紧接着原作的结局，可以看到结局之后发生了什么。采用和HL2相同的图像和物理引擎，游戏本身依旧发生在17号城市。研发团队能很快从概念设计进入到实施阶段，因为一切都是现成的。</p>
<p>在原作发售后仅仅一年半，《第一章》以20美元的超低价开卖，提供了一个6小时的单人战役，让戈登·弗里曼重返被在原作中被他毁坏的城市。游戏本身对故事进程的推进不大，敌人也和原作基本相同，与其说是独立作品，不如说是对原作的拓展。尽管如此，销量依然不错，毕竟玩家们未曾想到这么快就能开始新的冒险。</p>
<p>在《第一章》获得商业成功后，所有人都翘首等待《第二章》，但他们等到的却是《橙盒版(The Orange Box)》。《橙盒版》是五款游戏的合集，却仅售一款游戏的价格，包含已发售的《半条命2》和《第一章》，以及新游戏《第二章》《军团要塞2》，以及解密游戏《传送门(Portal)》。距离《第一章》发售过去近一年，这是谁都没有预料到的。Valve的这种行为是一场豪赌：捆绑销售的销量会比拆开单卖的销量更多吗？</p>
<p>【G胖】：我们有一款全新的游戏《传送门》，我们想试探一下市场，《橙盒版》提供了媒介。我们有《第二章》和《军团要塞2》这样备受期待的作品，给《传送门》一个推广的机会，与其他游戏捆绑让尽可能多的人玩到这款游戏。即使《传送门》失败了也没什么，这毕竟是一款解谜游戏，本身就是一个很小众的游戏类型。</p>
<p>捆绑销售大获成功，每人都能各取所需。这次也证明Valve可以发售多平台游戏，因为PC版与XBOX360版同步上市。不幸的是，V社发现PS3的开发环境很糟，所以PS3版是依靠第三方帮忙移植的。</p>
<p>《第二章》把玩家和忠实的伙伴Alyx带到了17号城市之外，探索新地点，遭遇新敌人。本作同样包含6个小时的战役，但内容和故事比第一章丰富许多。</p>
<p>《军团要塞2》走的是风格化欢乐向路线，成为一款卡通化，有多兵种选择的射击游戏。</p>
<p>《传送门》是10年间最具创新性的大作，第一人称射击解谜游戏，彻底改变你的空间思考方式。尽管游戏流程只有3小时，但引人入胜的玩法和谜题以及别出心裁的结尾曲已经使这款作品成为了圈内的传奇。</p>
<p>随着意料之中的《第二章》以及意料之外的《军团要塞2》和《传送门》的发售，每个人都在想《第三章》会和什么游戏捆绑。但Valve再次出人意料，将视线远离《半条命》，转向了一个全新的游戏，于2008年公开。一款让猎头蟹都显得如同乖狗狗一般的恐怖游戏。</p>
<h2 id="u6CBB_u7597_u611F_u67D3_uFF0C_u4E00_u6B21_u4E00_u9897_u5B50_u5F39_Beyond_the_Crowbar_u2026_And_Beyond"><a href="#u6CBB_u7597_u611F_u67D3_uFF0C_u4E00_u6B21_u4E00_u9897_u5B50_u5F39_Beyond_the_Crowbar_u2026_And_Beyond" class="headerlink" title="治疗感染，一次一颗子弹 Beyond the Crowbar… And Beyond"></a>治疗感染，一次一颗子弹 Beyond the Crowbar… And Beyond</h2><p>《求生之路》是一款僵尸射击游戏，但又与其他同类游戏有着明显的差异。游戏注重玩家间的团队合作，玩家将操控由4人组成的幸存者团队，单人游戏时其他队友由电脑操控。和《半条命》一样，游戏通过一段段突然发生的战斗营造出一种紧张氛围，令人毛骨悚然。为了达到这种效果，Valve创造了“导演”系统，一个会根据玩家行为i不端改变的系统。</p>
<p>举个例子，加入四个高玩一路碾压，“导演”会产生更少的弹药和医疗包，并产生更多的僵尸群，顺便把路上的灯也给关了。假如是一个菜鸟与三名电脑同伴，游戏会减少僵尸数量并提供更多的医疗包。如此一来，每次的游戏体验都不会完全一样，大大增极爱了重复可玩性。</p>
<p>考虑到僵尸在娱乐文化中的再次流行以及Valve的良好形象，游戏大卖完全在意料之中，V社还承诺会在DLC中添加更多内容。但Valve从不按常理出牌，Valve震惊了业界，他们宣布立即开始了《求生之路2》的开发，尽在1代一年后便发售。如此短的时间便推出续作是前所未有的，人们担心Valve会赶工发售游戏。</p>
<p>【G胖】：《求生之路1》发售之后，我们想开始做《求生之路2》并且快速完成，也许我们是太过在意这个。这样不是很酷吗？《半条命1》延期一年，《半条命2》也延期一年，《半条命2：第三章》影子都没有。我们长期因为延期饱受批评，认为我们的进度管理很糟糕。我们就想“其实我们可以在一年的时间里做出L4D2”。本以为人们的反应会是“Valve终于不延期了，实在太酷了”。而事实上有些人觉得这很不科学，他们不认为这是Valve的一大进步，而把这当做是V社“变了”的信号，觉得我们会砸了牌子。</p>
<p>更糟的是，《求生之路》粉丝和《半条命》粉丝都觉得遭到了背叛。《求生之路》玩家担心续作会挤掉1代DLC制作并且分化两代的玩家。一些不满的玩家开始建立群组号召抵制续作，不到一个月就有成千上万的玩家加入。与此同时，苦等《第三章》的玩家希望破灭，因为比起猎头蟹僵尸，V社似乎对病毒感染僵尸更有兴趣。</p>
<p>V社一向很关注玩家群体，G胖本人公开回应了玩家们的顾虑，声明1代还会继续推出DLC和升级补丁。事实上V社也已经发布了两个DLC，包含新的多人模式和一个新的剧情。</p>
<p>【G胖】：做完《求生之路2》后团队里没人说“好吧，我们在一年内做出L4D3吧”</p>
<p>尽管发生了抵制活动，L4D2的预定量依旧超过1代。然而作为一个以亲近玩家为荣的公司，《求生之路2》引发的论战可能是自HL2泄露事件以来最大的一次倒退。</p>
<p>【G胖】：我们并为预料到玩家会如此反应，我们完全理解玩家为何会有这些顾虑，我们应该解释一下，作为《求生之路2》发售前准备工作的一部分，不幸的是我们没有这么做，结果就是一帮人发起了抵制活动，我们的责任就是打消这些人的顾虑，我们得和他们对话，确保他们明白我们怎么想的，决策是如何做出的，安抚他们。这是Valve一直以来的传统哲学，让玩家们能继续支持《求生之路1》并创造价值。最后我们邀请两位抵制活动的发起人来到公司总部，问题是所有人都说他们并无恶意，我们提供机会让他们坐下来试玩，这招似乎很管用，让玩家社区觉得他们的想法得到了重视。通过Steam平台，我们可以看到抵制小组内拥有L4D1的玩家购买L4D2的比例其实比全球范围内的L4D1小组要高。也就是说我们很好的打消了顾虑，向他们表明了我们的计划，发售时玩家的情绪比刚公布时平静许多。</p>
<p>有件事多年以来一直没变，那就是V社不按常理出牌。从游戏研发到发布数字平台，V社一直在小心翼翼地审视自己和整个业界以寻找新的路子推陈出新。和其他行业一样，多数游戏小组一直做固定的系列或游戏类型，只做很小的创新以保证销量，但Valve总是不走寻常路，偶尔也会遇到一些麻烦，但每次都能将危机化解，游戏大卖，叫好又叫座，<br>这一切都归功于之前从未制作过游戏，但清楚的知道自己想要什么的两个人。</p>
<p>（正义之子面对有悖于常理的世界，会使其天翻地覆）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Valve 虽然从来是『有再一再二，没有再三再四』，但是不得不承认，无论是半条命还是 steam，都称得上『划时代』。</p>]]>
    
    </summary>
    
      <category term="Valve" scheme="http://wdxtub.com/tags/Valve/"/>
    
      <category term="历史" scheme="http://wdxtub.com/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iTerm2 指南]]></title>
    <link href="http://wdxtub.com/2016/03/20/iterm2-guide/"/>
    <id>http://wdxtub.com/2016/03/20/iterm2-guide/</id>
    <published>2016-03-20T13:36:10.000Z</published>
    <updated>2016-03-20T13:37:01.000Z</updated>
    <content type="html"><![CDATA[<p>这里是 iTerm2 的基本入门操作，熟悉之后可以大幅提高效率。</p>
<a id="more"></a>
<hr>
<h2 id="u5149_u6807_u63A7_u5236"><a href="#u5149_u6807_u63A7_u5236" class="headerlink" title="光标控制"></a>光标控制</h2><ul>
<li>ctrl + a: 到行首</li>
<li>ctrl + e: 行末</li>
<li>ctrl + f/b: 前进后退，相当于左右方向键，但是显然比移开手按方向键更快</li>
<li>ctrl + p: 上一条命令，相当于方向键上</li>
<li>ctrl + r: 搜索命令历史，这个大家都应该很熟悉了</li>
<li>ctrl + d: 删除当前字符</li>
<li>ctrl + h: 删除之前的字符</li>
<li>ctrl + w: 删除光标前的单词</li>
<li>ctrl + k: 删除到文本末尾</li>
<li>ctrl + t: 交换光标处文本</li>
<li>⌘ + —/+/0: 调整字体大小</li>
<li>⌘ + r:清屏，其实是滚到新的一屏，并没有清空。ctrl + l 也可以做到。</li>
</ul>
<h2 id="u7A97_u53E3_u64CD_u4F5C"><a href="#u7A97_u53E3_u64CD_u4F5C" class="headerlink" title="窗口操作"></a>窗口操作</h2><ul>
<li>新建窗口：shift + command + d（横向）command + d（竖向）</li>
<li>关闭窗口：shift + command + w</li>
<li>前一个窗口：command + `</li>
<li>后一个窗口：command + ~</li>
<li>进入窗口 1,2,3：option + command + 编号</li>
</ul>
<h2 id="u6807_u7B7E_u9875_u64CD_u4F5C"><a href="#u6807_u7B7E_u9875_u64CD_u4F5C" class="headerlink" title="标签页操作"></a>标签页操作</h2><ul>
<li>新建标签页: Command + T</li>
<li>关闭标签页: Command + W</li>
<li>前一个标签页: Command + 左方向键，Shift + Command + [</li>
<li>后一个标签页: Command + 右方向键，Shitf + Command + ]</li>
<li>进入标签页1，2，3…: Command + 标签页编号</li>
<li>Expose 标签页: Option + Command + E（将标签页打撒到全屏，并可以全局搜索所有的标签页）</li>
</ul>
<h2 id="u9762_u677F_u64CD_u4F5C"><a href="#u9762_u677F_u64CD_u4F5C" class="headerlink" title="面板操作"></a>面板操作</h2><ul>
<li>垂直分割: Command + D</li>
<li>水平分割: Shift + Command + D</li>
<li>前一个面板: Command + [</li>
<li>后一个面板: Command + ]</li>
<li>切换到上/下/左/右面板: Option + Command + 上下左右方向键</li>
</ul>
<h2 id="u5176_u4ED6_u529F_u80FD"><a href="#u5176_u4ED6_u529F_u80FD" class="headerlink" title="其他功能"></a>其他功能</h2><ul>
<li>支持自定义全局快捷键用于显示和隐藏iTerm2 Preference -&gt; Keys －&gt; Show/hide iTerm2 with a system-wide hotkey 打上勾之后</li>
<li>进入和退出全屏: Command + Enter</li>
<li>查看当前终端中光标的位置: Command + /</li>
<li>命令自动补全: Command + ;（很少用这个，还是感觉Zsh的补全更好用）</li>
<li>开启和关闭背景半透明: Command + u</li>
<li>清屏（重置当前终端）: Command + r</li>
</ul>
<h2 id="u6587_u672C_u9009_u53D6"><a href="#u6587_u672C_u9009_u53D6" class="headerlink" title="文本选取"></a>文本选取</h2><p>文本选取有使用鼠标和不使用鼠标两种方式。</p>
<p>使用鼠标</p>
<p>默认情况下，选取的文字会自动复制到剪切板，可以使用以下方式进行文本选取：</p>
<ul>
<li>常见的点击并拖拽方式</li>
<li>双击选取整个单词</li>
<li>三击选取整行</li>
<li>选取某一部分，按住Shift，再点击某处，可以选取整个矩形内的文本（类似Windows下按住Shift可以批量选取图标）</li>
<li>按住Command + Option，可以用鼠标画出一个矩形，用类似截图的方式选取文本 另外，还可以使用鼠标完成以下操作： 按住Command然后点击某个URL，会在浏览器中打开这个URL，点击某个文件夹，会在Finder里打开这个文件夹（再也不用open . 啦），点击某个文件名，会打开这个文件（文本文件支持MacVim，TextMate和BBEdit，如果后面跟随一个冒号和行号，文件会在行号处打开，其它格式的文件似乎不能调用默认程序打开） 选取文本之后，按住Command 同时拖动文本，可以将文本粘贴到目标位置（Drag and Drop） 鼠标中键粘贴（这个太感人了，一下子找回Linux的感觉了）</li>
</ul>
<p>不使用鼠标</p>
<p>(这种方式最多只能选取一行文本) 使用 Command + f，会呼出一个搜索框，可以在当前面板中进行搜索，输入想要选取的部分内容，输入过程中，按Tab可以将选取部分向右扩展，按Shift + Tab向左扩展，按回车转到下一个匹配位置。使用Tab或Shift+Tab扩展得到想要的内容之后，选取内容会自动复制到剪切板，再次按Command + f隐藏搜索框。</p>
<h2 id="u4F4D_u7F6E_u4E66_u7B7E"><a href="#u4F4D_u7F6E_u4E66_u7B7E" class="headerlink" title="位置书签"></a>位置书签</h2><p>在当前会话中按Command + Shift + m可以保存当前位置，之后可以按Command + Shift + j跳回这个位置。</p>
<h2 id="u7C98_u8D34_u5386_u53F2"><a href="#u7C98_u8D34_u5386_u53F2" class="headerlink" title="粘贴历史"></a>粘贴历史</h2><p>使用Command + Shift + h 可以呼出粘贴历史，支持模糊检索。还可以设置将粘贴历史保存在磁盘上（Preferences -&gt; General）</p>
<h2 id="u5373_u65F6_u56DE_u653E"><a href="#u5373_u65F6_u56DE_u653E" class="headerlink" title="即时回放"></a>即时回放</h2><p>使用Command + Opt + b 打开即时回放，按Esc退出。即时回放可以记录终端输出的状态，让你“穿越时间”查看终端内容。默认每个会话最多储存4MB的内容，可以在设置中更改（Preferences -&gt; Genernal -&gt; Instant Replay）。</p>
<h2 id="u7A97_u53E3_u72B6_u6001"><a href="#u7A97_u53E3_u72B6_u6001" class="headerlink" title="窗口状态"></a>窗口状态</h2><p>通过 Window -&gt; Save Window Arrangement 可以保存当前窗口状态的快照，包括打开的窗口，标签页和面板。通过 Window -&gt; Restore Window Arrangement 还原。还可以在 Preferences -&gt; General -&gt; Open saved window arrangement 中设置在启动iTerm2时自动恢复窗口状态</p>
<h2 id="u7279_u8272_u529F_u80FD"><a href="#u7279_u8272_u529F_u80FD" class="headerlink" title="特色功能"></a>特色功能</h2><ul>
<li>command+; 根据上下文呼出自动完成窗口，上下键选择</li>
<li>全屏 command+enter</li>
<li>光标去哪了？command+/</li>
<li>用鼠标选中某个路径或者某个词汇就自动复制</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里是 iTerm2 的基本入门操作，熟悉之后可以大幅提高效率。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://wdxtub.com/tags/Mac/"/>
    
      <category term="Shell" scheme="http://wdxtub.com/tags/Shell/"/>
    
      <category term="iTerm2" scheme="http://wdxtub.com/tags/iTerm2/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
