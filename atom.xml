<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-02-24T16:52:10.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 10 课 递归]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-10/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-10/</id>
    <published>2016-02-24T16:51:34.000Z</published>
    <updated>2016-02-24T16:52:10.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
<hr>
 公式 
]]>
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 9 课 有限状态机]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-9/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-9/</id>
    <published>2016-02-24T16:49:42.000Z</published>
    <updated>2016-02-24T16:50:16.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
<hr>
 公式 
]]>
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 8 课 数据压缩]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-8/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-8/</id>
    <published>2016-02-24T16:48:25.000Z</published>
    <updated>2016-02-24T16:48:58.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
<hr>
 公式 
]]>
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 7 课 图]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-7/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-7/</id>
    <published>2016-02-24T16:47:00.000Z</published>
    <updated>2016-02-24T16:48:05.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
<hr>
 公式 
]]>
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 6 课 搜索]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-6/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-6/</id>
    <published>2016-02-24T16:46:54.000Z</published>
    <updated>2016-02-25T19:10:27.000Z</updated>
    <content type="html"><![CDATA[<p>排序和搜索可能是互联网中应用最广泛的算法，大到搜索引擎，小到帖子排序，都离不开算法的帮助。这一课我们会简要了解一下各个常见算法，具体实现还是参考给出的链接，这里主要提算法背后的思想。</p>
<a id="more"></a>
<hr>
 公式 
]]></content>
    <summary type="html">
    <![CDATA[<p>排序和搜索可能是互联网中应用最广泛的算法，大到搜索引擎，小到帖子排序，都离不开算法的帮助。这一课我们会简要了解一下各个常见算法，具体实现还是参考给出的链接，这里主要提算法背后的思想。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 5 课 图]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-5/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-5/</id>
    <published>2016-02-24T16:45:48.000Z</published>
    <updated>2016-02-25T19:09:05.000Z</updated>
    <content type="html"><![CDATA[<p>前面我们介绍了几种不同类型的树，这一课我们在原来的基础上延伸一下，就能得到图的概念。相对于树，因为不同节点之间的关系更多，无论是表达形式或者是算法细节都会复杂不少，就更需要仔细揣摩。不过究其根本，实际上可以看做是不同矩阵间的信息检索，一定要注意细节。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u672C_u4ECB_u7ECD"><a href="#u57FA_u672C_u4ECB_u7ECD" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>图的话，从类别来看可以分为有向图与无向图，而最关键的操作，图的遍历，有深度优先（递归或者栈）和广度优先（队列）。</p>
<p>图由两类元素组成，一是节点(vertex)，二是边(edge)，下面是一个无向图的例子：</p>
<p><img src="/images/14564071906087.jpg" alt="无向图，边和节点都有对应标记"></p>
<p>无向图和有向图都是一个有限的节点集合加上一个有限的边集合，每条边连接两个节点。不同的地方在于，无向图中连接的顺序是无关紧要的，而有向图中连接的顺序是重要的，是从 source 到 target 的方向，下面是一个有向图的例子：</p>
<p><img src="/images/14564073738319.jpg" alt="有向图的例子，注意箭头的方向"></p>
<p>其他一些需要知道的术语：</p>
<ul>
<li>Loops: edges that connect a vertex to itself</li>
<li>Paths: sequences of vertices p0, p1, …, pm such that each adjacent pair of vertices are connected by an edge</li>
<li>Multiple Edges: two nodes may be connected by &gt;1 edge</li>
<li>Simple Graphs: have no loops and no multiple edges</li>
</ul>
<h2 id="u56FE_u7684_u8868_u793A"><a href="#u56FE_u7684_u8868_u793A" class="headerlink" title="图的表示"></a>图的表示</h2><p>这里介绍三种常见的方式，其实还有其他几种自定义的表示法，这里不拓展了</p>
<h3 id="u90BB_u63A5_u77E9_u9635_Adjacency_Matrix"><a href="#u90BB_u63A5_u77E9_u9635_Adjacency_Matrix" class="headerlink" title="邻接矩阵 Adjacency Matrix"></a>邻接矩阵 Adjacency Matrix</h3><p>用一个二维矩阵来表示点和点之间的连接关系，如果一个图有 N 个节点，那么这个矩阵就是 NxN 的，对于节点 I 和节点 J，如果有一条边连接他们，那么第 I 行第 J 列的值为 true，否则是 false（如果是无向图的话，第 J 行第 I 列的值需要保持一致，也就是说以对角线为轴对称），下面是一个有向图的例子：</p>
<p><img src="/images/14564128326067.jpg" alt="有向图的邻接矩阵"></p>
<h3 id="u8FB9_u5217_u8868_Edge_Lists"><a href="#u8FB9_u5217_u8868_Edge_Lists" class="headerlink" title="边列表 Edge Lists"></a>边列表 Edge Lists</h3><p>另外一种表达方式是每个节点有一个链表，表示它所连接的其他节点，如下图所示：</p>
<p><img src="/images/14564132564620.jpg" alt=""></p>
<h3 id="u8FB9_u96C6_Edge_Sets"><a href="#u8FB9_u96C6_Edge_Sets" class="headerlink" title="边集 Edge Sets"></a>边集 Edge Sets</h3><p>Edge Lists 中我们主要存储的是节点的信息，而在 Edge sets 中我们保存的是边的信息，包含每条边的 source 和 target。</p>
<h3 id="u6027_u80FD_u5206_u6790"><a href="#u6027_u80FD_u5206_u6790" class="headerlink" title="性能分析"></a>性能分析</h3><p>这里主要看一下最坏情况</p>
<ul>
<li>添加或删除边：<ul>
<li>adjacency matrix: O(1)</li>
<li>edge list: O(N)</li>
<li>edge set: O(logN) - 使用 B-Tree</li>
</ul>
</li>
<li>检查某条边是否存在：<ul>
<li>adjacency matrix: O(1)</li>
<li>edge list: O(N)</li>
<li>edge set: O(logN) - 使用 B-Tree 或 红黑树</li>
</ul>
</li>
<li>遍历某个节点的边：<ul>
<li>adjacency matrix: O(N)</li>
<li>edge list: O(E) - 其中 E 是边的数目</li>
<li>edge set: O(E) - 使用 B-Tree 或 红黑树</li>
</ul>
</li>
</ul>
<h2 id="u56FE_u7684_u5B9E_u73B0"><a href="#u56FE_u7684_u5B9E_u73B0" class="headerlink" title="图的实现"></a>图的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] edges;</span><br><span class="line">    <span class="keyword">private</span> Object[] labels;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span> <span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        labels = <span class="keyword">new</span> Object[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span> <span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        edges[s][t] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getLabel</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> labels[v];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[s][t];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] neighbors(<span class="keyword">int</span> v) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">int</span>[] answer;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; labels.length; i++&#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v][i]) count++;</span><br><span class="line">        &#125;    </span><br><span class="line">        answer = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; labels.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v][i]) answer[count++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        edges[s][t] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLabel</span><span class="params">(<span class="keyword">int</span> v, Object n)</span></span>&#123;</span><br><span class="line">        labels[v] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> labels.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u56FE_u7684_u904D_u5386"><a href="#u56FE_u7684_u904D_u5386" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>这个是图问题中比较常见的，一般来说，是从一个特定的节点开始，找到所有可能到达的节点。图和树的区别在于，我们可能会遇到环，所以就需要一种方法来处理这种情况。</p>
<p>我们可以用一个另外的数组来记录一个节点是否被访问过。</p>
<ul>
<li>深度搜索 - Stack</li>
<li>广度搜索 - Queue</li>
</ul>
<p>这一部分比较基础，大家可以自己找一个例子来边输出边测试，这里不再赘述。</p>
<h2 id="u6700_u77ED_u8DEF_u5F84"><a href="#u6700_u77ED_u8DEF_u5F84" class="headerlink" title="最短路径"></a>最短路径</h2><p>最短路径一般应用在有权有向图，如下所示：</p>
<p><img src="/images/14564267263106.jpg" alt=""></p>
<p>我们要找的是路径最短的，但不一定是经过的边最少的，所以 BFS 在这里就不适用了。</p>
<p>我们可以使用 <a href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95" target="_blank" rel="external">Dijkstra’s 算法</a>来处理，wiki 中有比较详细的说明，这里不再赘述。</p>
<p>对于比较稀疏的图，我们用堆来表示图会更好；反之，用邻接矩阵比较好。</p>
<p>另外一个利用动态规划的解法是 <a href="https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95" target="_blank" rel="external">Floyd Warshall 算法</a></p>
<p>索引中的各类算法也可以对应了解一下：</p>
<p><img src="/images/14564271316392.jpg" alt=""></p>
<h2 id="u6700_u5C0F_u751F_u6210_u6811_Minimum_Spanning_Tree__28MST_29"><a href="#u6700_u5C0F_u751F_u6210_u6811_Minimum_Spanning_Tree__28MST_29" class="headerlink" title="最小生成树 Minimum Spanning Tree (MST)"></a>最小生成树 Minimum Spanning Tree (MST)</h2><p>我们一般用 <a href="https://zh.wikipedia.org/wiki/%E6%99%AE%E6%9E%97%E5%A7%86%E7%AE%97%E6%B3%95" target="_blank" rel="external">Prim’s 算法</a>，来寻找最小生成树，是一个贪心算法</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面我们介绍了几种不同类型的树，这一课我们在原来的基础上延伸一下，就能得到图的概念。相对于树，因为不同节点之间的关系更多，无论是表达形式或者是算法细节都会复杂不少，就更需要仔细揣摩。不过究其根本，实际上可以看做是不同矩阵间的信息检索，一定要注意细节。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 4 课 树]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-4/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-4/</id>
    <published>2016-02-24T16:44:36.000Z</published>
    <updated>2016-02-25T13:11:50.000Z</updated>
    <content type="html"><![CDATA[<p>从这一讲开始，慢慢就有点难度了，树的每个节点虽然看起来比较简单，但是不同结点以不同规则进行组合就使得难度指数级增长，后面的红黑树因为涉及到结点的调整，一定要按照前面提到的 5 个步骤来过一次，才能清晰理解。</p>
<a id="more"></a>
<hr>
<h2 id="u6811_u7684_u5E94_u7528"><a href="#u6811_u7684_u5E94_u7528" class="headerlink" title="树的应用"></a>树的应用</h2><p>这次我们换个方式，先从不同的应用角度来了解一下树的用途。</p>
<p><strong>表示数学表达式</strong></p>
<p>我们可以用下面的树来表示 <code>b + a * b</code></p>
<p><img src="/images/14563638168396.jpg" alt=""></p>
<p><strong>XML Document Object Model</strong></p>
<p>XML 实际上也是一个树结构：</p>
<p><img src="/images/14563638734277.jpg" alt=""></p>
<p><strong>表示迁移路径的概率</strong></p>
<p>下图可以认为，从 S 出发，有 p 的概率到 Su，有 1-p 的概率到 Sd</p>
<p><img src="/images/14563639875028.jpg" alt=""></p>
<h2 id="u6811_u7684_u5B9A_u4E49"><a href="#u6811_u7684_u5B9A_u4E49" class="headerlink" title="树的定义"></a>树的定义</h2><p>下面介绍几种不同类型的树</p>
<h3 id="Free_tree"><a href="#Free_tree" class="headerlink" title="Free tree"></a>Free tree</h3><p>指的是相互连接的无环无向图</p>
<p><img src="/images/14563645014537.jpg" alt="Free Tree"></p>
<p>假设 G = (V, E) 是一个无向图，那么下面的语句是等价的：</p>
<ol>
<li>G 是一个 free tree</li>
<li>G 中的任意两个节点间都有唯一的一条路径</li>
<li>G 是连通的的，但是如果去掉任何一条边，G 就不连通了</li>
<li>G 是连通的，并且 $|E|=|V|-1$</li>
<li>G 是无环的，并且 $|E|=|V|-1$</li>
<li>G 是无环的，但是加入任何一条新的边，就会变成有环的</li>
</ol>
<h3 id="Forest__u68EE_u6797"><a href="#Forest__u68EE_u6797" class="headerlink" title="Forest 森林"></a>Forest 森林</h3><p>同样是无环无向图，但不是所有的节点都是连通的</p>
<p><img src="/images/14563646007700.jpg" alt="Forest"></p>
<p>下图中包含一个环，所以不能算是森林：</p>
<p><img src="/images/14563646456272.jpg" alt="包含环的例子"></p>
<h3 id="Rooted_Tree"><a href="#Rooted_Tree" class="headerlink" title="Rooted Tree"></a>Rooted Tree</h3><p>有根的树也是一棵 free tree，但是其中一个节点和其他不同，称为根，下图中的 7 号节点就是根：</p>
<p><img src="/images/14563698058000.jpg" alt=""></p>
<p>有根树中有一些概念需要理解清楚，这里只列举出来不再赘述：ancestor, descendant, proper ancestor, proper descendant, parent, child, siblings, external node(leaf), internal node。</p>
<p>一个节点的孩子数量称之为节点的度(degree)，从根到某节点的要经过的边的数量就是该节点的深度，最大的深度称为树的高度，如下图所示：</p>
<p><img src="/images/14563702807914.jpg" alt=""></p>
<p>根树有几个特例，也非常常用，需要理解清楚，这里列举如下：</p>
<ul>
<li>Binary tree</li>
<li>Full binary tree: each node is either a leaf or has degree exactly 2</li>
<li>Complete k-ary tree: a k-ary tree in which all leaves have the same depth and all internal nodes have degree k</li>
<li>Binary search tree: 一个节点的左右子节点和节点本身满足一定的大小关系</li>
</ul>
<p><img src="/images/14563707343954.jpg" alt="Complete Binary Tree"></p>
<h3 id="Catalan_Numbers"><a href="#Catalan_Numbers" class="headerlink" title="Catalan Numbers"></a>Catalan Numbers</h3><p>先来看公式</p>
<p><img src="/images/14563710814940.jpg" alt=""></p>
<p>然后我们就发现，Catalan 数对应的是有 n 节点的二叉树的数量（根据左右子树的位置可以有不同的结构）</p>
<h2 id="u6811_u7684_u904D_u5386"><a href="#u6811_u7684_u904D_u5386" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>这一部分也是非常重要的内容，基本来说各类考点都在这里，不但需要对概念的清晰理解，还需要利用递归来解决问题（虽然不用递归也可以），主要有下面这四类：</p>
<ol>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层次遍历</li>
</ol>
<p>具体的概念可以在 wiki 上查看，注意一下层次遍历可能需要一些特殊处理即可。</p>
<h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h2><p>如果我们想要表示一个 complete binary tree 的话，其实可以用数组来完成，这种结构其实也可以看成是一个堆。堆的话需要理解的不算特别多，注意下最大堆最小堆，以及对应的操作即可。另外前面提到的优先队列也可以认为是堆，不过这个不展开了。</p>
<p>这一部分我们着重来看看 B-Tree，这是一类搜索树，在给定 n 个节点的条件下，尽可能减少树的高度，相对于原来的二叉搜索树，B-Tree 做了两个调整：</p>
<ol>
<li>节点可以有多于两个子节点</li>
<li>节点中可以保存多个元素</li>
</ol>
<p>因为需要保存不定数量的元素，所以一般用 set 来实现（这种情况下不允许有重复的元素，重复的情况这里暂时不考虑）。稍微提一下，许多数据库都是用 B-Tree 实现的。</p>
<p>所有的 B-Tree 都有一个非常重要的常数 MINIMUM，决定了每个节点中需要保存多少元素，具体的规则如下：</p>
<ol>
<li>根节点有 0 或 1 个元素，其他的节点至少需要保存 MINIMUM 个元素</li>
<li>一个节点中最多可以保存 <code>2*MINIMUM</code> 个元素</li>
<li>一个节点中保存的元素是有序的，从最小到最大</li>
<li>假设一个非叶节点中存有 N 个元素，那么它会有 N+1 个子树</li>
<li>对于任何一个非叶节点：<ul>
<li>第 I 个元素比其第 I 个子树的所有元素都要大</li>
<li>第 I 个元素比其第 I+1 个子树的所有元素都要小</li>
<li><img src="/images/14563744343036.jpg" alt=""></li>
</ul>
</li>
<li>每个叶节点都有相同的深度，也就是说 B-Tree 总是平衡的</li>
</ol>
<p>下图是一个例子，其中 MINIMUM = 1，注意，根节点的每个子节点也是一颗 B-Tree</p>
<p><img src="/images/14563745325794.jpg" alt="B-Tree 的例子"></p>
<p>对应的数据结构是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntBalancedSet</span></span>&#123;</span><br><span class="line">    <span class="comment">// constants</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MINIMUM = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MAXIMUM = <span class="number">2</span> * MINIMUM;</span><br><span class="line">    <span class="comment">// info about root node</span></span><br><span class="line">    <span class="keyword">int</span> dataCount;</span><br><span class="line">    <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[MAXIMUM + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> childCount;</span><br><span class="line">    <span class="comment">// info about children</span></span><br><span class="line">    IntBalancedSet[] subset = <span class="keyword">new</span> IntBalancedSet[MAXIMUM+<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<p><img src="/images/14563980237017.jpg" alt=""></p>
<p>利用 B-Tree 进行搜索的方法如下：</p>
<ul>
<li>找到这样一个 set，满足 <code>data[I] &gt;= target</code> 且 I 尽可能小，如果找不到，则 <code>I = dataCount</code></li>
<li>如果 <code>data[I] == target</code> 返回 true，如果不等于且没有子节点，返回 false</li>
<li>如果不等于但是有子节点，则返回 <code>subset[I].contains(target)</code></li>
</ul>
<p><img src="/images/14563990361014.jpg" alt="利用 B-Tree 进行搜索的例子"></p>
<p>一般来说，结构比较复杂的数据结构，进行修改都会比较麻烦（因为结构中内在的约束太多，变动的话需要满足所有约束），在 B-Tree 中添加和删除节点是比较复杂的操作。这里讲详细一些，用一个具体的例子来做说明（MINIMUM=1）</p>
<p>删除操作的伪代码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">Delete</span>(<span class="keyword">T</span>, X, <span class="keyword">success</span>)</span><br><span class="line">    // 从树 <span class="keyword">T</span> 中删除 <span class="keyword">key</span> 为 X 的节点，如果没有对应节点，则操作失败</span><br><span class="line">    // 操作结果可以从 <span class="keyword">success</span> 变量中获悉</span><br><span class="line">    </span><br><span class="line">    // 先找到 <span class="keyword">key</span> 为 X 的节点的位置</span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">I</span> <span class="keyword">is</span> <span class="keyword">present</span> <span class="keyword">THEN</span></span><br><span class="line">        swap item <span class="keyword">I</span> <span class="keyword">into</span> leaf <span class="keyword">L</span> which contains the inorder successor <span class="keyword">of</span> <span class="keyword">I</span></span><br><span class="line">        // 从 leaf <span class="keyword">L</span> 开始删除操作</span><br><span class="line">        <span class="keyword">IF</span> <span class="keyword">L</span> has <span class="keyword">no</span> items <span class="keyword">THEN</span> Fix(<span class="keyword">L</span>)</span><br><span class="line">        <span class="keyword">success</span> := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        <span class="keyword">success</span> := <span class="literal">false</span></span></span><br></pre></td></tr></table></figure>
<p>然后是其中的 Fix 函数，用来处理没有子节点的节点，保证符合 B-Tree 的基本性质</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Fix(N)</span><br><span class="line">    // N 是一个没有子节点的节点</span><br><span class="line">    // 如果 N 是一个 internal node，那么它有一个子节点</span><br><span class="line">    </span><br><span class="line">    Let P be the parent of N. If N is the root, <span class="operator"><span class="keyword">delete</span> it <span class="keyword">and</span> <span class="keyword">return</span>.</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">some</span> sibling <span class="keyword">of</span> <span class="keyword">N</span> has two items <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">distribute</span> items among <span class="keyword">N</span>, the sibling, <span class="keyword">and</span> <span class="keyword">P</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">IF</span> <span class="keyword">N</span> <span class="keyword">is</span> internal <span class="keyword">THEN</span></span><br><span class="line">            <span class="keyword">move</span> the appropriate <span class="keyword">child</span> <span class="keyword">from</span> the sibling <span class="keyword">to</span> <span class="keyword">N</span></span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        // 如果其兄弟没有两个子节点，就必须要进行融合</span><br><span class="line">        <span class="keyword">Choose</span> an adjancent sibling S <span class="keyword">of</span> <span class="keyword">N</span></span><br><span class="line">        </span><br><span class="line">        Bring the appropriate item down <span class="keyword">from</span> <span class="keyword">P</span> <span class="keyword">into</span> S</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">IF</span> <span class="keyword">N</span> <span class="keyword">is</span> internal <span class="keyword">THEN</span></span><br><span class="line">            <span class="keyword">Move</span> <span class="keyword">N</span><span class="string">'s child to S</span><br><span class="line">        </span><br><span class="line">        Delete node N</span><br><span class="line">        </span><br><span class="line">        IF P is now without an item THEN Fix(P)</span></span></span><br></pre></td></tr></table></figure>
<p>然后我们看看插入操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">Insert</span>(<span class="keyword">T</span>, newitem)</span><br><span class="line">    // 把 newitem 插入到树 <span class="keyword">T</span> 中</span><br><span class="line">    Let X be the <span class="keyword">search</span> <span class="keyword">key</span> <span class="keyword">of</span> <span class="keyword">new</span> item</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">Locate</span> the leaf <span class="keyword">L</span> <span class="keyword">in</span> which X belongs</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">Add</span> newitem <span class="keyword">to</span> <span class="keyword">L</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">L</span> <span class="keyword">now</span> has three items <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">Split</span>(<span class="keyword">L</span>)</span></span><br></pre></td></tr></table></figure>
<p>继续来看看这里的 Split 函数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Split(N)</span><br><span class="line">    // 分割那些有 3 个子节点的节点。注意如果 N 是 internal 的，它可以有 4 个孩子</span><br><span class="line">    Let P be the parent of N</span><br><span class="line">        // 如果 N 是根，那么创建一个新节点 P</span><br><span class="line">        </span><br><span class="line">    <span class="operator"><span class="keyword">Replace</span> node <span class="keyword">N</span> <span class="keyword">by</span> two nodes, N1 <span class="keyword">and</span> N2</span><br><span class="line">    </span><br><span class="line">    Give N1 the item <span class="keyword">in</span> <span class="keyword">N</span> <span class="keyword">with</span> the smallest <span class="keyword">search</span> <span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line">    Give N2 the item <span class="keyword">in</span> <span class="keyword">N</span> <span class="keyword">with</span> the largest <span class="keyword">search</span> <span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">N</span> <span class="keyword">is</span> an iternal node <span class="keyword">THEN</span></span><br><span class="line">        N1 becomes the <span class="keyword">parent</span> <span class="keyword">of</span> <span class="keyword">N</span><span class="string">'s two leftmost children</span><br><span class="line">        N2 becomes the parent of N'</span>s two rightmost children</span><br><span class="line">    </span><br><span class="line">    Send up <span class="keyword">to</span> <span class="keyword">P</span> the item <span class="keyword">in</span> <span class="keyword">N</span> <span class="keyword">with</span> the middle <span class="keyword">search</span> <span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">IF</span> <span class="keyword">P</span> <span class="keyword">now</span> has <span class="number">3</span> items <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">Split</span>(<span class="keyword">P</span>)</span></span><br></pre></td></tr></table></figure>
<p>我们给定如下一颗 B-Tree</p>
<p><img src="/images/14564007797015.jpg" alt=""></p>
<p>插入 39 之后（插入总是在叶节点）为</p>
<p><img src="/images/14564008049100.jpg" alt="插入 39 之后"></p>
<p>再插入 38，会发现有一个节点有多于 2 个子节点，需要 split</p>
<p><img src="/images/14564008689598.jpg" alt="插入 38，split 之前"></p>
<p>可以看到我们通过 split 操作把 39 提上去了（注意对照前面的 split 函数的伪代码来进行操作和理解）：</p>
<p><img src="/images/14564009041532.jpg" alt="插入 38，split 之后"></p>
<p>我们再插入 37 与 36，这会导致树高改变，需要进行更多操作，过程如下：</p>
<p><img src="/images/14564011447526.jpg" alt="插入 37 与 36"></p>
<p>插入之后我们发现又出现了非法的节点，依照 split 规则更新之后，上层的节点再次非法，这里属于有四个子节点的情况，左右分开，把中间的 37 移上一层，就成为最后一个形态。</p>
<p>我们再多插入一些，比如 34，35，36，整个过程如下：</p>
<p><img src="/images/14564014630573.jpg" alt=""></p>
<p>最后就得到</p>
<p><img src="/images/14564015026747.jpg" alt=""></p>
<p>注意，因为向下传播的关系，高度是从顶层开始增长的。</p>
<p>然后我们来看看删除操作，还是用刚才的例子，给定：</p>
<p><img src="/images/14564016695179.jpg" alt=""></p>
<p>这次我们删除 50，因为是根节点，所以需要找一个节点放到原来根的位置，并且需要把 70 下移以满足条件</p>
<p><img src="/images/14564016869839.jpg" alt="删除 50"></p>
<p>我们再删除 100 试试看：</p>
<p><img src="/images/14564018498766.jpg" alt=""></p>
<p>同样对照前面的 Fix 函数进行操作即可。然后我们再删除 60，这里需要涉及的变动就会比较多，如下：</p>
<p><img src="/images/14564020922018.jpg" alt=""></p>
<p>然后我们再删除 70 看看，就会变成这样：</p>
<p><img src="/images/14564021367330.jpg" alt="删除 70"></p>
<p>最后再删除 80，又会进行一次融合</p>
<p><img src="/images/14564021619408.jpg" alt="删除 80"></p>
<p>删除操作总是从 leaf 开始的，把要删除的节点和其 inorder successor 换位置。具体的操作如果还不明白，可以找一些视频来看看，这里不赘述了。</p>
<h2 id="u7EA2_u9ED1_u6811_Red_Black_Tree"><a href="#u7EA2_u9ED1_u6811_Red_Black_Tree" class="headerlink" title="红黑树 Red Black Tree"></a>红黑树 Red Black Tree</h2><p>这里只给出基本性质的说明，具体的细节可以查看<a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="external">这里</a></p>
<p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ol>
<p><img src="/images/14564058100039.jpg" alt="红黑树的例子"></p>
<p>这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。</p>
<p>还是那句话对于约束较多的数据结构，进行插入和删除都是比较复杂的操作，最好通过例子掌握整个过程。</p>
<p>最后提一下复杂度，因为树的分叉设计，所以基本来说复杂度都是 log 的，但是需要注意，在最坏情况下，复杂度很可能是 O(n)，</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从这一讲开始，慢慢就有点难度了，树的每个节点虽然看起来比较简单，但是不同结点以不同规则进行组合就使得难度指数级增长，后面的红黑树因为涉及到结点的调整，一定要按照前面提到的 5 个步骤来过一次，才能清晰理解。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 3 课 链表、栈和队列]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-3/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-3/</id>
    <published>2016-02-24T15:58:50.000Z</published>
    <updated>2016-02-25T04:32:38.000Z</updated>
    <content type="html"><![CDATA[<p>链表、栈和队列是非常基本的数据结构，万丈高楼平地起，即使简单，也要认真对待。</p>
<a id="more"></a>
<hr>
<h2 id="u94FE_u8868"><a href="#u94FE_u8868" class="headerlink" title="链表"></a>链表</h2><p>链表是非常基础和常用的一个数据结构，尤其是在解析器(parser)、游戏和搜索算法中。而且很多时候会用来实现下面的 ADT(Abstract Data Type)：</p>
<ul>
<li>堆栈 Stack</li>
<li>集合 Set</li>
<li>哈希表 Hash Table</li>
</ul>
<p>我们来重温一下实现某个数据结构要做的五个事情：</p>
<ol>
<li>Understand it Abstractly</li>
<li>Write a Specification</li>
<li>Write Applications</li>
<li>Select, Design, Implement</li>
<li>Analyze the Implementation</li>
</ol>
<p>接下来我们以链表为例子，具体来过一遍前三个步骤，后面两个步骤属于实现的细节和实现之后的分析，这里暂时不涉及。</p>
<h3 id="1-Understand_it_Abstractly"><a href="#1-Understand_it_Abstractly" class="headerlink" title="1.Understand it Abstractly"></a>1.Understand it Abstractly</h3><p>因为链表比较简单，所以一幅图就可以解释清楚：</p>
<p><img src="/images/14563356077459.jpg" alt="黄色部分是数据，绿色部分是指针"></p>
<h3 id="2-Specification"><a href="#2-Specification" class="headerlink" title="2.Specification"></a>2.Specification</h3><p>明确的规格说明包括：</p>
<ul>
<li>构造器，公有方法和属性的说明</li>
<li>每个方法包含前条件/后条件</li>
<li>说明应该与实现无关</li>
</ul>
<p>这里用一个 <code>IntNode</code> 为例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;     <span class="comment">// data</span></span><br><span class="line">    <span class="keyword">private</span> IntNode link; <span class="comment">// pointer</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntNode</span><span class="params">(<span class="keyword">int</span> initialData, IntNode initialLink)</span></span>&#123;</span><br><span class="line">        data = initialData;</span><br><span class="line">        link = initialLink;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IntNode <span class="title">getLink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> link;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> newdata)</span></span>&#123;</span><br><span class="line">        data = newdata;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLink</span><span class="params">(IntNode newlink)</span></span>&#123;</span><br><span class="line">        link = newlink;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Application"><a href="#3-Application" class="headerlink" title="3.Application"></a>3.Application</h3><p>根据前面的规格说明，具体来使用我们创建的数据结构。这里我们不直接把变量声明为公有，而是通过 getter 和 setter 来进行访问，等于是把变量名称和这个变量本身进行了解耦，即使改变了变量名，只要函数接口不变，对外的行为仍旧是不变的</p>
<h3 id="u94FE_u8868_u5C0F_u7ED3"><a href="#u94FE_u8868_u5C0F_u7ED3" class="headerlink" title="链表小结"></a>链表小结</h3><p>需要掌握的链表操作：</p>
<ul>
<li>插入</li>
<li>删除</li>
<li>检查是否有环</li>
<li>保证程序的健壮性（主要是头为空的时候）</li>
</ul>
<p>其他比较特别的操作：</p>
<ul>
<li>合并 N 个链表</li>
<li>反转链表</li>
<li>截取链表的一部分</li>
<li>寻找链表的 1/N</li>
</ul>
<h2 id="u6808_u4E0E_u961F_u5217"><a href="#u6808_u4E0E_u961F_u5217" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>栈和队列是比较典型的 ADT，所谓 ADT，就是实际上内存中没有类似的数据结构对应，具体的操作是人为增加的设定，是为 Abstract，但是同时它们也被当做数据类型来用，是为 Data Type，于是就成为 ADT。</p>
<p>因为比较简单的缘故，这里大概说一下要点：</p>
<h3 id="u6808"><a href="#u6808" class="headerlink" title="栈"></a>栈</h3><p>性质</p>
<ul>
<li>后入先出</li>
<li>Last-In / First-Out</li>
</ul>
<p>支持的操作：</p>
<ul>
<li>push - 入栈</li>
<li>peek - 查看栈顶</li>
<li>pop - 弹出栈顶元素</li>
</ul>
<p>常见应用</p>
<ul>
<li>程序执行 - 函数调用和返回实际上就是入栈出栈的内容，详情见我的『深入理解计算机系统』系列</li>
<li>解析 - Parsing</li>
<li>计算 postfix 表达式的值 - 例如 <code>4 + 3</code> 可以写成 <code>4 3 +</code></li>
</ul>
<p>需要注意的问题</p>
<ul>
<li>在栈为空的时候执行 pop，会导致 underflow</li>
</ul>
<p>实现方式</p>
<ul>
<li>数组实现 - 需要一个变量来标记栈顶位置</li>
<li>链表实现 - 插入元素时对表头操作需要注意</li>
</ul>
<p>常见题目</p>
<ul>
<li>括号匹配</li>
<li>翻转字符串</li>
<li>模拟递归（N 皇后问题）</li>
</ul>
<h3 id="u961F_u5217"><a href="#u961F_u5217" class="headerlink" title="队列"></a>队列</h3><p>性质</p>
<ul>
<li>先入先出</li>
<li>First-In / First-Out</li>
</ul>
<p>支持的操作：</p>
<ul>
<li>Enqueue - 入队列</li>
<li>Dequeue - 出队列</li>
</ul>
<p>常见应用</p>
<ul>
<li>Round-robin 调度机制 - 处理器处理进程或服务器处理请求（负载均衡）</li>
<li>输入/输出 处理</li>
<li>网络中 packet 的排队处理</li>
</ul>
<p>实现方式</p>
<ul>
<li>数组实现 - 需要一个变量来标记队列头及队列尾的位置</li>
<li>链表实现 - 需要保存表尾，处理表头的时候注意操作顺序</li>
</ul>
<p>与栈的组合</p>
<ul>
<li>利用一个栈和一个队列可以用来判断回文串</li>
</ul>
<p>队列的进阶使用</p>
<ul>
<li>优先队列<ul>
<li>插入队列的元素有一定的顺序要求</li>
<li>每次插入实际上是某种意义上搜索和排序的过程</li>
<li>可以用数组来模拟实现</li>
<li>可以看作是『最大堆』或『最小堆』</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>链表、栈和队列是非常基本的数据结构，万丈高楼平地起，即使简单，也要认真对待。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 2 课 基础知识]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-2/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-2/</id>
    <published>2016-02-24T15:35:52.000Z</published>
    <updated>2016-02-24T16:42:20.000Z</updated>
    <content type="html"><![CDATA[<p>这一课我们不会涉及具体的数据结构或算法，而是先了解一些分析数据结构和算法的基本知识，如前条件/后条件，时间空间复杂度分析。</p>
<a id="more"></a>
<hr>
<h2 id="u524D_u6761_u4EF6/_u540E_u6761_u4EF6"><a href="#u524D_u6761_u4EF6/_u540E_u6761_u4EF6" class="headerlink" title="前条件/后条件"></a>前条件/后条件</h2><p>建议在写具体的函数之前，都要先想好（写好）前条件和后条件，这样可以确定问题的边界。</p>
<ul>
<li>前条件：在函数调用之前一定为真的条件</li>
<li>后条件：在函数执行完之后为真的条件</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Precondition: x &gt;= 0</span></span><br><span class="line"><span class="comment">// Postcondition: The square root of x has</span></span><br><span class="line"><span class="comment">// been written to the standard output</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Big_O"><a href="#Big_O" class="headerlink" title="Big O"></a>Big O</h2><p>在具体介绍之前，先来一些基本的数学公式复习</p>
 $$log_b(x_1·x_2)=log_bx_1+log_bx_2$$ 
 $$log_b(\frac{x_1}{x_2})=log_bx_1-log_bx_2$$ 
 $$log_b(x^c)=c·log_bx$$ 
<p>事实上除了我们常用的 Big O，还有另外两种表示的方法：Big Omega($Big- \Omega$) 和 Big Theta($Big - \theta$)</p>
<p>这里只介绍它们的差别，具体的定义可以自行查看。</p>
<p>Big-O 实际上只表示上限，比如说，我们知道 $17n^2\in O(n^2)$，但是同时我们也可以说 $17n^2\in O(n^37)$ 和 $17n^2\in O(2^n)$</p>
<p>Big omega 则是表示下限，例如 $f(n) = n$，那么下面两个式子都成立 $f(n) \in O(n^2)$ 与 $n^2 \in \Omega(n)$</p>
<p>总结一下：</p>
<p><img src="/images/14563304975385.jpg" alt=""></p>
<p>而 Big theta(Big $\theta$) 则是前面两个的交集：</p>
<p>$$\theta(f)=O(f) \cap \Omega(f)$$</p>
<p>举例来说，函数 $f(n) = 4n$，则</p>
<p>$$f(n)\in O(n)$$</p>
<p>$$f(n) \in \Omega(n)$$</p>
<p>所以</p>
<p>$$f(n)\in \theta(n)$$</p>
<p>简单来说就是</p>
<ol>
<li>Big O 是一个算法最坏情况的度量</li>
<li>Big Omega 是一个算法最好情况的度量</li>
<li>Big Theta 表达了一个算法的区间，给定了一个函数的渐近的逼近(asymptotically tight bound)</li>
</ol>
<p>但是一般来说用 Big O 也就足够了</p>
<h2 id="u9762_u5411_u5BF9_u8C61_u7F16_u7A0B"><a href="#u9762_u5411_u5BF9_u8C61_u7F16_u7A0B" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><blockquote>
<p>Class = Data + Methods</p>
</blockquote>
<p>具体要说的话，内容就太多了，需要深入理解『继承』『多态』和『封装』，也不是一篇日志能说清楚的，所以就大概有一个印象，慢慢领悟吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一课我们不会涉及具体的数据结构或算法，而是先了解一些分析数据结构和算法的基本知识，如前条件/后条件，时间空间复杂度分析。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法 第 1 课 总览]]></title>
    <link href="http://wdxtub.com/2016/02/24/dsa-1/"/>
    <id>http://wdxtub.com/2016/02/24/dsa-1/</id>
    <published>2016-02-24T14:59:07.000Z</published>
    <updated>2016-02-24T15:23:24.000Z</updated>
    <content type="html"><![CDATA[<p>数据结构与算法是编程中基础中的基础，重要的不是具体某个结构或者算法本身，而是通过理解数据结构和算法在解决问题中发挥的作用，掌握如何用计算机解决问题的方法，进而练就一套自己观察问题，思考问题，解决问题的招式。</p>
<a id="more"></a>
<hr>
<p>网上相关的资料其实蛮多的，之所以打算『重复造轮子』，一是之前的<a href="http://wdxtub.com/2016/01/22/programmer-startline-1/">编程起跑线系列</a>有很多具体的算法思想没有详细说明，二是借着课程的体系重新梳理一下自己的思路。所以整个系列可能会给出大量的参考链接，用于说明基本的概念，而对于数据结构和算法背后的思想，则是我想要着重讨论的。</p>
<p>这门课的编程语言是 Java（CMU 感觉啥课都是 Java），学习目标是：</p>
<ol>
<li>根据特定问题设计或选择合适的算法</li>
<li>根据特定问题设计或选择合适的数据结构</li>
<li>在程序中使用：stacks, queues, linked lists, trees, graphs, 以及 hash tables. </li>
<li>能够用 Big O, Big Omega, 和 Big Theta 分析程序的性能</li>
<li>理解 worse case, best case, average case</li>
<li>理解程序正确性和性能的差异</li>
<li>理解 NP-completeness 理论</li>
<li>能够区分出哪里问题是可以通过计算解决的，哪些不是</li>
</ol>
<p>参考书目：</p>
<ul>
<li>《Data Structures &amp; Other Objects Using Java》 Michael Main, Fourth Edition (Addison-Wesley Longman, ISBN-13 978-0132576246)</li>
<li>《Introduction to Algorithms》Corman, et al., 1990, MIT Press, ISBN 0262031418</li>
</ul>
<p>总体来看是比较中规中矩的一门课，老师给出的课件也是比较凌乱，我会按照自己的理解重新进行组织。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>数据结构与算法是编程中基础中的基础，重要的不是具体某个结构或者算法本身，而是通过理解数据结构和算法在解决问题中发挥的作用，掌握如何用计算机解决问题的方法，进而练就一套自己观察问题，思考问题，解决问题的招式。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="信息处理" scheme="http://wdxtub.com/tags/%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86/"/>
    
      <category term="数据结构" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wdxtub.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[英语口语中的『噪声』]]></title>
    <link href="http://wdxtub.com/2016/02/23/pronunciation-stress/"/>
    <id>http://wdxtub.com/2016/02/23/pronunciation-stress/</id>
    <published>2016-02-24T02:33:28.000Z</published>
    <updated>2016-02-24T04:05:39.000Z</updated>
    <content type="html"><![CDATA[<p>一个人觉得自己不再需要改变的时候，最大的改变就已经发生了——他变成了没有未来的人。</p>
<a id="more"></a>
<hr>
<p>这个学期给一门研究生课程当助教，宾夕法尼亚州有这么一条法律，英语不是母语的同学当助教的话，必须要达到一定的沟通交流水平，否则学校要被罚款。具体到 CMU，就意味着我需要通过一门叫 ITA 的测试（之前的<a href="http://wdxtub.com/2016/02/19/ita-test/">日志</a>也有提及）。因为是专门负责英语教学的部门，我的英语虽然能应付日常交际，但是细化到讲课上，就有些捉襟见肘了，所以必须进行一些课程培训。</p>
<p>昨天完成了个人作业，已经感觉有了很大收获（见<a href="http://wdxtub.com/2016/02/22/how-to-speak/">这里</a>），今天去上了关于发音的培训课（主要是重音），更是感觉醍醐灌顶，小班教学，寓教于乐，原本担心两个小时太长的我，到最后还觉得时间过得太快，想让老师多讲一会儿。</p>
<p>所以在这篇日志中，讲讲如何快速掌握英语口语中的『重音』。掌握了重音，就可以最大程度减少表达中的『噪声』，让自己的表达更容易被听懂。</p>
<h2 id="u91CD_u97F3_u4E0E_u8BED_u8C03_28stress_and_intonation_29"><a href="#u91CD_u97F3_u4E0E_u8BED_u8C03_28stress_and_intonation_29" class="headerlink" title="重音与语调(stress and intonation)"></a>重音与语调(stress and intonation)</h2><p>以汉语为母语的我们，长期浸淫在汉语环境中（汉语属于 monotone），无论从生理还是心理上都难以完全转换到英语模式。但是我们真的需要说得跟以英语为母语的人一样吗？并不需要！我们需要的是让的表达更加清晰，更容易理解，至于带一点点口音其实无伤大雅，甚至有时候还能成为个人特色（生活大爆炸中的 Raj）。</p>
<p>如果说完整的表达是 100 分的话，那么口音其实只占 25 分，剩下的 75 分是重音与语调。但是奇怪的是，大多数英语学习者都忽略了这 75 分，有种舍本逐末的感觉。</p>
<p>举个例子，15(fifteen) 和 50(fifty) 是我们很容易说不清的，问题不在于我们发音不够准，而是我们重音不对。正确的读法应该是：</p>
<p>15 - fifTEEN, 50 - FIFty（大写的部分表示重音），通过重音的变换，别人可以轻松地明白我们在说 15 还是 50。</p>
<p>有重音，相对来说，肯定也有轻读的，甚至我们可以吞掉某些音节，看下面两个例子：</p>
<blockquote>
<p>Give a man a horse he can ride</p>
</blockquote>
<p>这里的 can，实际的发音类似 kon，尾音甚至可以省略</p>
<blockquote>
<p>His rank and wealth, his strenth and health</p>
</blockquote>
<p>这里的 and，实际的发音就剩下 n，大家可以自己读一下试一试。</p>
<p>再举一个对比：</p>
<blockquote>
<p>I can || go. 与 I || can’t || go. (这里 || 表示停顿)</p>
</blockquote>
<p>第一个句子，go 需要重音，第二个句子，can’t 需要重音。说了这么多，到底要怎么重音呢？有下面三个基本原则：</p>
<ol>
<li><strong>Louder</strong> (more air = more volume)</li>
<li><strong>Longer</strong> (s-t-r-e-t-c-h out the word, especially the vowel)</li>
<li><strong>Pause</strong> (before or after the stress to make it stand out)</li>
</ol>
<h2 id="u54EA_u4E9B_u8BCD_u9700_u8981_u91CD_u97F3"><a href="#u54EA_u4E9B_u8BCD_u9700_u8981_u91CD_u97F3" class="headerlink" title="哪些词需要重音"></a>哪些词需要重音</h2><p>重音本身是和说话的意思紧密相关的，所以大原则就是，要利用重音突出表达某个意思，也就是说，哪个词的信息量大，哪个词就需要重音。</p>
<p>总体来看可以这样划分：</p>
<ul>
<li>Content words are stressed: Nouns, verbs, adjectives and adverbs, question words, demonstratives(these, those, etc), negatives</li>
<li>Function words are not stressed: Prepositions, pronouns, articles, verb “to be”, conjunctions(and, but), auxiliaries(do, should, can)</li>
</ul>
<p>对于每个单词，其实也有重音，规则还是一样：louder, longer, pause。对于类似 AI, DNA 这种缩写，每个单词都需要重音。</p>
<p>对于复合名词，每个单词都需要重音，但是前面的可以再重一点，比如 “quantum || mechanics”</p>
<h2 id="u5229_u7528_u91CD_u97F3_u6765_u5F3A_u8C03_u4FE1_u606F"><a href="#u5229_u7528_u91CD_u97F3_u6765_u5F3A_u8C03_u4FE1_u606F" class="headerlink" title="利用重音来强调信息"></a>利用重音来强调信息</h2><p>对一个句子不同单词重音，可以有不同的强调效果，比如</p>
<ul>
<li>Did John study Chemical Engineering last semester? (normal yes/no question stress)</li>
<li>Did John study Chemical Engineering || <strong>last</strong> || semester? (no, three semesters ago)</li>
<li>Did John study || <strong>Chemical</strong> || Engineering last semester? (no, electrical)</li>
<li>Did John || <strong>study</strong> || Chemical Engineering last semester? (no, he taught)</li>
<li>Did || <strong>John</strong> || study Chemical Engineering last semester? (no, Bob did)</li>
</ul>
<p>另一种情形，是利用重音来区别比较近似的两个词，如：</p>
<ul>
<li>Did you study MICRO or MACROeconomics?</li>
<li>Did you say INput or OUTput?</li>
<li>Did you say SUPER or SEMIconductor?</li>
<li>Are we talking about FISion or FUSion?</li>
<li>Are you working with HARDware or SOFTware?</li>
<li>Was the result a POSITIVE or a NEGATIVE integer?</li>
<li>Is the curve conVEX or conCAVE?</li>
<li>Is that elastic or INelastic?</li>
<li>Did you say reFLECtion or reFRACtion</li>
</ul>
<p>这里大写表示要重音的部分，仔细感受一下。</p>
<p>最后一个情况是需要纠正别人的话，那么对于纠正的地方就需要重音，比方说：</p>
<ul>
<li>Boston is a state -&gt; No, it’s a || <strong>city</strong>.</li>
<li>Tokyo is in Korea -&gt; No, it’s in || <strong>Japan</strong>.</li>
</ul>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>给我震动最大的，不是精心准备的上课材料，不是精细到位的指导，而是去思考如何做好一件事情，并用最好的方式传达出去感染更多的人。这种教育模式是我在国内很少见到的（也就我爸妈教我的时候是这样），有这样的老师，学生又如何能不『尊师重道』呢？</p>
<p>信噪比是一个很重要的思路，生活中的方方面面都可以从这个角度来切入，思考并改进已有的方法。</p>
<p>最后说一个很有意思的看问题的角度，在强调语调和重音的作用时，老师让我们试着去模仿英语为母语的人如何说中文，通过仔细揣摩个中不同，就会发现他们即使说中文也带着说英文时的重音和语调，我们听起来就觉得有点怪（虽然意思可以明白），反之亦然。</p>
<p>这种通过反向模仿来进行思考和比较的思路，其实还可以应用在很多方面，这堂课哪怕我只听了这么一句话，这两个小时也值了，更何况整堂课干货满满毫无尿点呢！</p>
<p>还有很长的路要走，我要加油。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个人觉得自己不再需要改变的时候，最大的改变就已经发生了——他变成了没有未来的人。</p>]]>
    
    </summary>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 第 14 课 文件 vs 数据库]]></title>
    <link href="http://wdxtub.com/2016/02/22/cc-14/"/>
    <id>http://wdxtub.com/2016/02/22/cc-14/</id>
    <published>2016-02-22T14:46:58.000Z</published>
    <updated>2016-02-24T02:35:04.000Z</updated>
    <content type="html"><![CDATA[<p>从这一课起，我们要开始使用数据库了。通过数据库和文件的性能对比以及 SQL 与 NoSQL 的对比，学会选择最合适的技术。</p>
<a id="more"></a>
<hr>
<h2 id="u5B66_u4E60_u76EE_u6807"><a href="#u5B66_u4E60_u76EE_u6807" class="headerlink" title="学习目标"></a>学习目标</h2><ol>
<li>了解使用文件来存储信息的优势和劣势</li>
<li>增加使用 <code>awk</code>, <code>grep</code> 等命令修改文件的经验</li>
<li>了解使用数据库来存储信息的优势和劣势</li>
<li>了解 MySQL (SQL) 和 HBase (NoSQL) 的不同</li>
<li>学会如何把数据载入到数据库中(MySQL, HBase)</li>
<li>学会使用 JDBC 连接 MySQL</li>
<li>学会使用 Java API 来操作 HBase</li>
<li>了解 vertical scaling 的在持久云存储（磁盘, 固态硬盘）的性能</li>
</ol>
<p>这次的作业主要用 Bash 和 Java(MySQL &amp; HBase) 在 AWS 平台上完成。</p>
<h2 id="u80CC_u666F_u77E5_u8BC6"><a href="#u80CC_u666F_u77E5_u8BC6" class="headerlink" title="背景知识"></a>背景知识</h2><p>近年来『数据』越来越被重视，这之中很重要的一环就是——如何存储这些数据。这一课中我们会接触常见的存储数据的方式，并学会在实际场景中根据需要选择合适的技术。</p>
<p>我们先会介绍<a href="https://en.wikipedia.org/wiki/Flat_file_database" target="_blank" rel="external">『文件』</a>以及『关系型数据库』</p>
<p>通常来说，我们用文件来保存非结构化的数据，用数据库来保存结构化的数据，我们来看看下面这个例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件中的一行</span></span><br><span class="line">Name: Carnegie, Course: Cloud Computing, Section: A, Year: <span class="number">2015</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库中的一行（有四列）</span></span><br><span class="line">Name           Course         Section     Year</span><br><span class="line">Carnegie    Cloud Computing      A        <span class="number">2015</span></span><br></pre></td></tr></table></figure>
<p>在数据库中，数据以表的形式存储，访问不同的元素比较简单，但是在文件中，就需要做一定的解析工作。文件和数据库各有所长，重要的还是具体问题具体分析，不能一概而论。</p>
<p>除了文件和传统的关系型数据库，NoSQL 数据库现在也越来越流行了。因为大数据面临的挑战，NoSQL 数据库在扩展性上比传统方法更好，但是却不得牺牲一些一致性和结构性来换取性能和可拓展性。</p>
<p>这节课我们同样会尝试在 HBase 上做一些操作。完成之后，应该能够对这三种方式有更加清晰的理解，以及能够根据实际使用场景来选择对应的方法。</p>
<h2 id="u80CC_u666F_u8BBE_u5B9A"><a href="#u80CC_u666F_u8BBE_u5B9A" class="headerlink" title="背景设定"></a>背景设定</h2><p>我们的目标是打造一个关于音乐和电影的社交网络，作为一个菜鸟，我拿到的第一个任务是分析音乐数据。在把服务部署到云上之前，公司希望我能评估一下用文件和用关系型数据库的性能比较。提供的数据文件如下：</p>
<p><img src="/images/14561603284363.jpg" alt=""></p>
<p>其中 <code>million_songs_metadata.csv</code> 包含所有歌曲的信息，<code>million_songs_sales_data.csv</code> 包含一段时间内每首歌的每日销量。具体的格式如下：</p>
<p><img src="/images/14561643038821.jpg" alt="Schema for file `million_songs_metadata.csv`"></p>
<p><img src="/images/14561643402177.jpg" alt="Schema for file `million_songs_sales_data.csv`"></p>
<p>最后注意要给所有用到的资源打上 <code>Project: 3.1</code> 的标签</p>
<h2 id="u6587_u4EF6_u64CD_u4F5C"><a href="#u6587_u4EF6_u64CD_u4F5C" class="headerlink" title="文件操作"></a>文件操作</h2><p>这一部分主要是使用 <code>grep</code> 和 <code>awk</code> 来进行一些简单的数据处理工作，关于这两个命令的使用，本来是打算专门写日志来说明的（然而一直没抽出时间），所以就尽量在这里介绍得清晰一点。</p>
<p>Grep 命令可以用来查找文件中出现的关键词或者某种固定的模式，如果我们要找到一个文件中包含 “The Beatles” 的记录，那么可以用以下命令：</p>
<p><code>grep -P &#39;The Beatles&#39; million_songs_metadata.csv</code></p>
<p>具体的查找过程可以有不同的参数进行设置，比方说下面的语句就会忽略大小写进行匹配：</p>
<p><code>grep -i -P &#39;The Beatles&#39; million_songs_metadata.csv</code></p>
<p>关于不同参数的意义，可以直接在命令行中输入 <code>man grep</code> 进行查看。</p>
<p>利用管道，我们可以统计具体的行数，比如：</p>
<p><code>grep -P &#39;The Beatles&#39; million_songs_metadata.csv | wc -l</code></p>
<p>用 grep 得到的结果，只要某一行出现了要找的内容，就算找到，但是如果我们想在指定的列中寻找特定的字符，就可以使用 awk 命令了。比方说，我们只想找出 <code>artist_name</code> 那一列中出现 “The Beatles” 的记录，就可以用下面的命令：</p>
<p><code>awk &#39; BEGIN {FS = &quot;,&quot;} ; {if ($7 ~ /The Beatles/) { print; }}&#39; million_songs_metadata.csv</code></p>
<p>这里 <code>$7</code> 表示是第 7 列，而 <code>FS = &quot;,&quot;</code> 表示分隔符是 <code>,</code></p>
<p>如果我们想要更复杂一点的逻辑，比如要找到 Michael Jacksn 80 年代的歌曲，就可以用这个命令：</p>
<p><code>awk &#39; BEGIN {FS = &quot;,&quot;} ; {if (tolower($7) ~ /michael jackson/ &amp;&amp; $11 &gt;= 1980 &amp;&amp; $11 &lt; 1990) { print; }}&#39; million_songs_metadata.csv</code></p>
<p>随着问题越来越复杂，可能很多时候都没有办法在一行内解决问题，不过在这一部分，我们还是尽量试试看用 grep 和 awk 解决问题。</p>
<p>做好准备之后可以开启一个 <code>ami-ca685ba0</code> 的 <code>t1.micro</code> 实例来完成下面的任务。</p>
<p>基本我们要做的就是把 <code>runner.sh</code> 补充完整，仔细读题，仔细读题，仔细读题（比如是否区别大小写）。</p>
<p>第五题可以写一个程序或者若干命令，以 <code>million_songs_metadata.csv</code> 和 <code>million_songs_sales_data.csv</code> 中相同 <code>track_id</code> 为标准，合并两个文件。生成一个 <code>million_songs_metadata_and_sales.csv</code> 数据集，其中第 1 列是 <code>track_id</code>，第 2 列是 <code>sales_date</code>，第 3 列是 <code>sales_count</code>，第 4 - 13 列是 <code>million_songs_metadata.csv</code> 的其他列。</p>
<p>完成问题之后，可以使用 <code>./runner.sh files</code> 来检查输出结果</p>
<p><strong>提示</strong></p>
<ol>
<li>搜索找到一个能够完成合并文件的 unix 命令</li>
<li>只能用命令行脚本完成</li>
<li>不要使用 Java 和 Python</li>
<li>没有特别声明，所有的匹配都是大小写敏感的</li>
<li>第六题中，一个歌手可能有多个 <code>artist_names</code>，但是只会有一个唯一的 <code>artist_id</code>，应该根据 <code>artist_id</code> 来找到最大的销量，并返回所有 <code>artist_name</code></li>
<li>注意保存好 <code>runner.sh</code></li>
</ol>
<h3 id="u89E3_u9898_u653B_u7565"><a href="#u89E3_u9898_u653B_u7565" class="headerlink" title="解题攻略"></a>解题攻略</h3><p>首先先创建一个 <code>ami-ca685ba0</code> 的 <code>t1.micro</code> 实例。就绪之后 ssh 过去：<code>ssh -i demo.pem ubuntu@ec2-54-175-177-74.compute-1.amazonaws.com</code>，即可见到这次作业的相关文件：</p>
<p><img src="/images/14561733687303.jpg" alt=""></p>
<p>这部分我们只需要用 <code>runner.sh</code>，所以把它搞到本地 <code>scp -i demo.pem ubuntu@dns.compute-1.amazonaws.com:~/Project3_1/runner.sh ./</code></p>
<p>打开 <code>runner.sh</code> 文件，可以看到需要回答的问题是：</p>
<ol>
<li>在文件 <code>million_songs_metadata.csv</code> 中，有多少行包含 <code>Aerosmith</code>，大小写敏感</li>
<li>在文件 <code>million_songs_metadata.csv</code> 中，<code>artist_name</code> 包含 <code>Bob Marley</code> 的 <code>track_id</code> 有多少个，大小写敏感</li>
<li>在文件 <code>million_songs_metadata.csv</code> 中，第 7 列中包含 <code>The Beatles</code> 的有多少行，大小写敏感</li>
<li>写出与 SQL 命令 <code>SELECT AVG(duration) FROM songs</code> 等价的命令行命令</li>
<li>把两个 csv 文件合并为 <code>million_songs_metadata_and_sales.csv</code>，以相同 <code>track_id</code> 为标准</li>
<li>在文件 <code>million_songs_metadata_and_sales.csv</code> 中，找到销量最高的 artist，一个歌手可能有多个 <code>artist_names</code>，但是只会有一个唯一的 <code>artist_id</code>，应该根据 <code>artist_id</code> 来找到最大的销量，并返回所有 <code>artist_name</code></li>
</ol>
<p>写好之后传到服务器上：<code>scp -i demo.pem ./runner.sh ubuntu@dns.compute-1.amazonaws.com:~/Project3_1/</code></p>
<p>测试的话用 <code>./runner.sh files</code>，确定无误后使用 <code>./submitter -a dawang</code> 来进行提交，代码运行完成后输入提交密码即可。</p>
<h2 id="MySQL__u64CD_u4F5C"><a href="#MySQL__u64CD_u4F5C" class="headerlink" title="MySQL 操作"></a>MySQL 操作</h2><p>同样是使用 <code>ami-ca685ba0</code> 的 <code>t1.micro</code> 实例来完成这部分的内容</p>
<p>先通过<a href="https://youtu.be/x73HknyUGIM" target="_blank" rel="external">视频</a>来了解 MySQL 的基础知识</p>
<p>远程机器中已经安装配置好了 MySQL，使用下面的命令可以开启 MySQL 命令行客户端并且连接到数据库：</p>
<p><code>mysql -u root -pdb15319root song_db</code></p>
<p>上面的命令中，用户名是 <code>root</code> 密码是 <code>db15319root</code>，使用是数据名称是 <code>song_db</code></p>
<p>数据库的相关知识可以参考<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="external">这里</a>，就不在日志中赘述。</p>
<p>我们需要根据前面给出 schemas 来创建对应的表，作业文件中提供了 <code>~/Project3_1/create_tables.sql</code> 文件，可以从这里开始</p>
<blockquote>
<p>远程主机中的 MySQL 版本是 5.5，注意查看对应的文档</p>
</blockquote>
<p>创建好之后，可以使用下面的命令来查看表的 schema</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">DESCRIBE</span> songs;</span></span><br><span class="line"><span class="operator"><span class="keyword">DESCRIBE</span> sales;</span></span><br></pre></td></tr></table></figure>
<p>然后和前面给出的表格进行比较，看看是否一致。</p>
<p>所以我要做的是找到合适的命令，把 <code>million_songs_metadata.csv</code> 和 <code>million_songs_sales.csv</code> 导入到 MySQL 中。可以在 MySQL 命令行工具中使用 SQL 命令导入，也可以用 mysqlimport 工具来导入，记下所使用的命令即可。</p>
<p>想要验证是否导入成功的话，可以列出前十条记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> songs </span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure>
<p>SQL 的语法可以参考<a href="http://www.w3school.com.cn/sql/sql_syntax.asp" target="_blank" rel="external">这里</a>，下面选出一些简单的例子进行介绍。</p>
<p>比如说下面的命令就会从表中选出 <code>artist_name</code> 一列中包含 <code>The Beatles</code> 的表项：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> songs </span><br><span class="line"><span class="keyword">WHERE</span> artist_name </span><br><span class="line"></span><br><span class="line"><span class="keyword">LIKE</span> <span class="string">'%The Beatles%'</span>;</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>%</code> 表示任何字符出现任意次数，前面提到的寻找 <code>Michael Jackson</code> 的例子可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> songs </span><br><span class="line"><span class="keyword">WHERE</span> artist_name </span><br><span class="line"><span class="keyword">LIKE</span> <span class="string">'%michael jackson%'</span><span class="keyword">AND</span> <span class="keyword">year</span> &gt;= <span class="number">1980</span> <span class="keyword">AND</span> <span class="keyword">year</span> &lt; <span class="number">1990</span>;</span></span><br></pre></td></tr></table></figure>
<p>如果需要计算平均时间，就不需要使用 <code>awk</code> 命令那么复杂，可以直接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">duration</span>) <span class="keyword">FROM</span> songs;</span></span><br></pre></td></tr></table></figure>
<p>带索引的数据库可以极大提高查询的性能，在 MySQL 中，所有的主键都会自动成为索引。</p>
<p>Aggregate Functions 允许你在多个记录中执行运算并返回一个单一值，比较常用的有 <code>SUM</code>, <code>AVG</code>, <code>MAX</code>, <code>MIN</code> 和 <code>COUNT</code>. Aggregate functions 通常和 MySQL 的 GROUP BY 关键字一起使用来为不同的 subgroup 执行运算并返回对应结果。GROUP BY 非常有用，下面是一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> c1, c2, ... cn, aggregate_function(expression)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">WHERE</span> where_conditions</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2, ... cn;</span></span><br></pre></td></tr></table></figure>
<p>例如，要统计最近十天总销量排名，可以用下面的 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> sales_date, <span class="keyword">SUM</span>(sales_count) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sales_date</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sales_date <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure>
<p>MySQL 的 JOIN 关键字可以用来在两个或两个以上相关的表中进行查询。在 MySQL 中 <code>JOIN</code>, <code>CROSS JOIN</code> 和 <code>INNER JOIN</code> 是等价的，下面是一个例子：syntax:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#<span class="operator"><span class="keyword">select</span> <span class="keyword">statement</span></span><br><span class="line">    <span class="keyword">SELECT</span> c1,c2,....cn</span><br><span class="line">    <span class="keyword">FROM</span> join_table;</span></span><br><span class="line">#join_table</span><br><span class="line">    table1 [INNER|CROSS] JOIN table2 [join_condition]</span><br><span class="line">#join_condition:</span><br><span class="line">    ON conditional_expr</span><br><span class="line">  | USING (column_list)</span><br></pre></td></tr></table></figure>
<p><code>INNER JOIN</code> 会构造指定的表的笛卡尔乘积，也就是第一个表中的每一行通过 join condition 和第二个表中的每一行组合。因为我们的 songs 表中的所有 <code>track_ids</code> 在 sales 表中都有对应的记录，所以这里只用 <code>INNER JOIN</code> 即可。</p>
<p>例如，下面的 SQL 语句会返回销量最高的 10 首歌的名字：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> songs.title, <span class="keyword">SUM</span>(sales_count) <span class="keyword">AS</span> total_sale</span><br><span class="line"><span class="keyword">FROM</span> songs</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> sales <span class="keyword">ON</span> songs.track_id = sales.track_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sales.track_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> total_sale</span><br><span class="line"><span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于 OUTER JOIN</p>
</blockquote>
<p>和 INNER JOIN 不同的是可能会出现列的值为空的情况，根据提供不匹配的数据的表所在的位置，分为 LEFT 和 RIGHT JOINS。在 LEFT JOIN 中，会返回左边表中不匹配的记录，反之亦然。没有匹配的话，会把对应的列设为 NULL。如果想要保留不匹配的数据，这种方法就很有用了。</p>
<h3 id="JDBC__u548C_MySQL"><a href="#JDBC__u548C_MySQL" class="headerlink" title="JDBC 和 MySQL"></a>JDBC 和 MySQL</h3><p>Java Database Connectivity (JDBC) API 可以用来访问数据库，并且由于是一个跨平台的标准，在不同的平台上可以使用相同的代码。这一部分我们会使用 MySQL Connector/J。</p>
<p>第一步就是与数据建立连接，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">Connection conn = DriverManager.getConnection(URL, DB_USER, DB_PWD);</span><br></pre></td></tr></table></figure>
<p>第一行载入并初始化 MySQL 的 JDBC 驱动，然后我们就可以建立与数据库的连接（参数比较简单这里略过）</p>
<p>为了执行 SQL 操作以及获取执行完毕的结果，我们需要创建 Statement(用来执行 SQL 命令的对象)，并且在执行完成后得到一个 ResultSet 对象，下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line">ResultSet rs = stmt.executeQuery(<span class="string">"select count(*) as cnt from songs;"</span>);</span><br></pre></td></tr></table></figure>
<p>可以通过调用 <code>rs.next()</code> 来遍历结果：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (rs.<span class="keyword">next</span>()) &#123;</span><br><span class="line">    <span class="keyword">int</span> rowCount = rs.getInt(<span class="string">"cnt"</span>);</span><br><span class="line">    System.out.<span class="keyword">println</span>(<span class="string">"Total number of lines in songs is "</span> + rowCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完对应操作后，还需要关闭我们用到的 Statement 和 Connection，注意关闭 Statement 之后对应的 ResultSet 也会被关闭。</p>
<h3 id="u89E3_u9898_u653B_u7565-1"><a href="#u89E3_u9898_u653B_u7565-1" class="headerlink" title="解题攻略"></a>解题攻略</h3><p>和之前一样，我们要做的就是完成 7-11 题，需要修改 <code>MySQLTasks.java</code> 文件。仔细读题，仔细读题，仔细读题。</p>
<p>第 7-9 题我们需要为 songs 表创建索引。那么应该选择哪一列作为索引呢？</p>
<p>记录下使用的命令已经对应更新 <code>INDEX_NAME</code> 变量，建立索引需要花一点时间，不过可以换取比较大的性能提升，建立完索引后，使用下面的命令重启 mysql：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure>
<p>在第 9 题中，我们会使用和第 7 题一样的指令，就可以看到建立索引之后的性能提升。</p>
<p>开始写代码之前，可以先运行一下样例，了解 java 如何和 MySQL 交互。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac MySQLTasks<span class="class">.java</span></span><br><span class="line">java MySQLTasks demo</span><br></pre></td></tr></table></figure>
<p>会输出 songs 表中的行数（如果存在的话），做完之后可以用 <code>./runner.sh mysql</code> 来检查。</p>
<p><strong>Bonus</strong></p>
<p>如果完成 <code>MySQLTasks.java</code> 中的 <code>loadData</code> 函数，有 5 分的加分，可以通过下面代码进行测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac MySQLTasks.java</span><br><span class="line">java MySQLTasks load_data</span><br></pre></td></tr></table></figure>
<p><strong>一些提示</strong></p>
<ul>
<li>SQL 的 LIKE 操作符默认是大小写不敏感的</li>
<li>记得把所有的答案输出到同一行</li>
<li>下一部分也可以用同一个远程机器，终止之前保存好所有的代码</li>
</ul>
<p>文件更灵活，可以存放结构或非结构数据，并且容易实现和修改；数据库则稍微笨重一些。对于文件来说，安全只能通过文件权限来控制，但是数据库有更加完善的权限管理。对文件的访问没有办法并行，但是数据库访问则可以。其他的不同基本上可以认为数据库有一套完整的管理接口和语法，而文件的话都需要自己实现，下表是一个总结：</p>
<p><img src="/images/14561824166535.jpg" alt="文件 vs 数据库"></p>
<p>首先我们把对应的文件复制到本地：<code>scp -i demo.pem ubuntu@dns.compute-1.amazonaws.com:~/Project3_1/MySQLTasks.java ./</code></p>
<p>然后我们可以用给出的 <code>create_tables.sql</code> 来新建数据表，先进入 MySQL 的命令行：<code>mysql -u root -pdb15319root song_db</code></p>
<p>然后输入 <code>source ./create_tables.sql</code> 来执行新建表格的命令。接着可以用 <code>DESCRIBE songs;</code> 和 <code>DESCRIBE sales;</code> 来查看是否成功创建（注意一定要最后的分号），如图</p>
<p><img src="/images/14561876662637.jpg" alt="songs 表"><br><img src="/images/14561876858760.jpg" alt="sales 表"></p>
<p>然后需要找到合适的命令，把 <code>million_songs_metadata.csv</code> 和 <code>million_songs_sales.csv</code> 导入到 MySQL 中（这里推荐用 <code>mysqlimport</code> 来导入，另一个有点问题）。命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要先更改两个 scv 文件的名字，这样才能载入到对应的表中</span></span><br><span class="line">cp million_songs_metadata.csv songs.csv</span><br><span class="line">cp million_songs_sales_data.csv sales.csv</span><br><span class="line"><span class="comment"># 然后进行载入</span></span><br><span class="line">mysqlimport -u root -pdb15319root --local --fields-terminated-by=<span class="string">","</span> --lines-terminated-by=<span class="string">"\n"</span> song_db songs.csv</span><br><span class="line">mysqlimport -u root -pdb15319root --local --fields-terminated-by=<span class="string">","</span> --lines-terminated-by=<span class="string">"\n"</span> song_db sales.csv</span><br></pre></td></tr></table></figure>
<p>然后我们用下面的命令来看看是否成功（如果不成功，就重新用前面的脚本生成一次对应的表）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> songs <span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sales <span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure>
<p>大概应该看到</p>
<p><img src="/images/14561903279207.jpg" alt=""></p>
<p>然后就可以进入写 java 代码的阶段了，先大概看一下已有的代码，发现已经帮我们初始化过了，实际上只要在代码中填写对应的 SQL 语句即可。问题为（第 7-11 题）：</p>
<ol>
<li>(7)返回 duration 最长的歌的 trackid</li>
<li>(8)选择一列作为索引，并建立索引</li>
<li>(9)返回 duration 最长的歌的 trackid（和第 1 个题目相同，用来比较性能）</li>
<li>(10)写一条与 <code>grep -P &#39;The Beatles&#39; million_songs_metadata.csv | wc -l</code> 等价的 sql 语句，这里注意大小写的问题，提示：<code>BINARY</code>（感谢 @jiexing）</li>
<li>(11)哪个 artist 的歌曲数目是第三多的，返回其名字，如果有多个，任意一个都可以</li>
</ol>
<p>其实主要就是写出对应的 SQL 语句，执行起来都是一样的，前面也有给出例子。然后就可以上传回服务器：<code>scp -i demo.pem ./MySQLTasks.java ubuntu@dns.compute-1.amazonaws.com:~/Project3_1/</code></p>
<p>测试的话用 <code>./runner.sh mysql</code>，确定无误后使用 <code>./submitter -a dawang</code> 来进行提交，代码运行完成后输入提交密码即可。</p>
<h2 id="Vertical_Scaling__u5B58_u50A8"><a href="#Vertical_Scaling__u5B58_u50A8" class="headerlink" title="Vertical Scaling 存储"></a>Vertical Scaling 存储</h2><p>那么问题来了，我们的数据到底保存在哪里呢？当然是物理世界的硬盘上，但是我们之前好像都没有考虑到这个事情，事实上，不同的硬盘对性能也有极大的影响。</p>
<p>接下来的部分我们会了解一些 Linux 下的磁盘操作命令并且利用 AWS 提供的存储设备来进行 vertical scaling。并且用常见的 benchmarking 工具来进行测试，通过整个过程，应该就能了解为什么实际存储数据的设备也对性能有极大的影响。</p>
<p>因为大多数命令都需要 root 权限，所以开始之前 <code>sudo su</code> 一下是比较方便的选择。</p>
<p>这个<a href="https://youtu.be/8Bwg_wUVhkE" target="_blank" rel="external">视频</a>介绍如何在 EC2 实例中使用 EBS</p>
<ul>
<li>一般来说在创建 EC2 实例的时候会自动创建一个 EBS 并挂载到 EC2 实例上</li>
<li>先进入 EBS Volume 页面，Create Volume -&gt; 选择不同的大小 -&gt; 选择 Availablility Zone(要和 EC2 在同一个区域) -&gt; Create</li>
<li>点击 Action -&gt; Attach Volumn -&gt; 选择已有的实例 -&gt; 填写挂载点 <code>/dev/sdf</code></li>
<li>ssh 到机器上，输入命令 <code>sudo parted -l</code> 可以发现并没有成功挂载</li>
<li>我们在磁盘上新建一个文件系统：<code>sudo mkfs.ext4 /dev/xvdf</code></li>
<li>再次运行 <code>sudo parted -l</code>，发现一切正常</li>
<li>然后创建文件夹用来挂载 <code>sudo mkdir /mnt/ebs1</code></li>
<li>接着进行挂载 <code>sudo mount /dev/xvdf /mnt/ebs1</code></li>
<li>就可以访问对应文件夹了 <code>cd /mnt/ebs1/</code></li>
<li>最后可以用 <code>df -h</code> 来进行查看</li>
</ul>
<p>GNU <code>parted</code> 是用来创建、销毁、改变大小、检查状态、复制分区的命令，可以操作分区表（取代原来的 <code>fdisk</code>），并支持如 GUID Partition Table(GPT) 等的新特性。想要了解更多可以参考<a href="https://www.gnu.org/software/parted/manual/html_chapter/parted_1.html" target="_blank" rel="external">这里</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parted <span class="operator">-l</span></span><br><span class="line">/dev/xvda1 – this is the OS partition</span><br><span class="line">/dev/xvdb – this is the first Ephemeral (instance store) drive</span><br><span class="line">/dev/xvdc – this is the second Ephemeral (instance store) drive</span><br></pre></td></tr></table></figure>
<p>创建并格式化一个分区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">umount /dev/xvdX <span class="comment">#where “X” - is a,b,c..etc (You should use your device’s name)</span></span><br><span class="line">parted /dev/xvdX mklabel gpt</span><br><span class="line">parted /dev/xvdX mkpart db ext4 <span class="number">0</span>% <span class="number">10</span>G</span><br><span class="line">mkfs.ext4 /dev/xvdX1</span><br></pre></td></tr></table></figure>
<p>对于比较小的 volume，可以直接整个格式化，不用分区</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs<span class="class">.ext4</span> /dev/xvdX</span><br></pre></td></tr></table></figure>
<p>创建挂载点并挂载</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="regexp">/storage/m</span>ountpoint</span><br><span class="line">mount <span class="regexp">/dev/y</span>ourdevice <span class="regexp">/storage/m</span>ountpoint</span><br></pre></td></tr></table></figure>
<p>到底用不用挂载点可以自己决定，不过一般来说 Linux 会挂载到 <code>/mnt</code>（EC2 也是这么做的）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount</span><br></pre></td></tr></table></figure>
<p>不带任何参数的话会显示所有的挂载点，可以用来判断是否挂载成功。</p>
<h3 id="u89E3_u9898_u653B_u7565-2"><a href="#u89E3_u9898_u653B_u7565-2" class="headerlink" title="解题攻略"></a>解题攻略</h3><p>简单来说就是比较传统硬盘和固态硬盘的性能差别，测试的场景如下：</p>
<p><img src="/images/14561980518607.jpg" alt=""></p>
<p>Sysbench 是一个包含多个测试的评测。这里我们使用的评测程序和 sysbench 唯一不同的是可以选择 [SSD|Magnetic]。</p>
<p>根据下面的指示完成不同配置的测试，记录下不同的 RPS，把数字填写到对应的位置即可。</p>
<blockquote>
<p>提示：使用比较慢的硬件时，准备 10GB 的数据可能要花费很长时间，用最好的的机器（比如 large）来准备数据</p>
</blockquote>
<p><strong>准备测试数据</strong></p>
<p>步骤如下</p>
<ol>
<li>用 <code>ami-ca685ba0</code> 启动一个 <code>t1.micro</code> 或 <code>m3.large</code> 的实例</li>
<li>创建一个 20GB 的 EBS volume (磁盘或固态硬盘) 。确保和 EC2 实例在同一个区域</li>
<li>把 EBS volume 挂载到 EC2 实例上</li>
<li>SSH 到 EC2 实例，格式化并挂载 EBS volume</li>
<li>进入挂载文件夹</li>
<li>用下面的命令生成测试数据 <code>sudo /home/ubuntu/Project3_1/sysbench --test=fileio --file-total-size=10G prepare</code></li>
</ol>
<p>上面的命令会在 EBS volume 上生成 10GB 的测试数据，在接下来的步骤中都可以重复使用</p>
<p><strong>试验 1 (上表中 Scenarios 1 &amp; 2 )</strong></p>
<p>执行以下步骤：</p>
<ol>
<li>启动一个 <code>ami-ca685ba0</code> 的 <code>t1.micro</code> 实例</li>
<li>挂载上 EBS volume </li>
<li>确保挂载成功</li>
<li>执行下面的代码 3 次（中间不要间隔太长时间）<code>sudo /home/ubuntu/Project3_1/sysbench --test=fileio --file-total-size=10G --file-test-mode=rndrw --max-time=300 --max-requests=0 run</code></li>
<li>把结果写到 <code>runner.sh</code> 中</li>
<li>使用另外的磁盘类型进行测试</li>
</ol>
<blockquote>
<p>暂时不要删除 EBS volume，之后还有用</p>
</blockquote>
<p><strong>试验 2 (上表中 Scenarios 3 &amp; 4 )</strong></p>
<ol>
<li>启动一个 <code>ami-ca685ba0</code> 的 <code>m3.large</code> 实例</li>
<li>挂载上 EBS volume </li>
<li>确保挂载成功</li>
<li>执行下面的代码 3 次（中间不要间隔太长时间）<code>sudo /home/ubuntu/Project3_1/sysbench --test=fileio --file-total-size=10G --file-test-mode=rndrw --max-time=300 --max-requests=0 run</code></li>
<li>把结果写到 <code>runner.sh</code> 中</li>
<li>使用另外的磁盘类型进行测试</li>
</ol>
<p>测试的话用 <code>./runner.sh scaling</code>，确定无误后使用 <code>./submitter -a dawang</code> 来进行提交，代码运行完成后输入提交密码即可。</p>
<h2 id="HBase__u64CD_u4F5C"><a href="#HBase__u64CD_u4F5C" class="headerlink" title="HBase 操作"></a>HBase 操作</h2><p>Apache HBase 是一个开源版本的 Google BigTable 分布式存储系统，其特点是分布式，可拓展，高性能，为大数据而生，在 Hadoop Distributed File System (HDFS) 上工作。HBase 在不同的服务器上把文件保存为重复的块，HDFS 保证其扩展性和可靠性。</p>
<p>在 HBase 中，输入按照行列排列，如下图所示：</p>
<p><img src="/images/14562066176431.jpg" alt="HBase table 的典型架构"></p>
<p>HBase 中的每一行都有对应的 row key，类似于主键，必须是唯一的。HBase 会自动根据 row key 来排列数据，默认按照字节顺序排序。</p>
<p>如上图所示，每一行包括：<code>rowkey</code>, <code>column_family</code>, <code>column</code> 和 <code>timestamp</code>，所以整个的映射变成 <code>(rowkey, column family, column, timestamp) -&gt; value</code>。Rowkey 和 value 都是简单的字节，所以只要能序列化成字节的都可以保存在 cell 中。这些 cell 会按照字典序排列，这是一个非常重要的特性，使得 HBase 支持快速搜索。</p>
<p>HBase 中的每一列都有列名，还可以进一步组织成 column family。所有的 column family 成员拥有共同的前缀，如上图所示，列 Metadata:Type 和列 Metadata:Language 都是 Metadata column family 的成员，而列 Content:Data 则属于 Content family。默认来说用冒号来分隔 column family 的前缀，这个前缀必须由能够打印的字符组成，后面的部分可以是任何字节。</p>
<p><strong>HBase 操作</strong></p>
<p>HBase 有四个主要的操作：Get, Put, Scan, 和 Delete.</p>
<ul>
<li>Get 操作会返回指定行的所有 cell</li>
<li>Put 操作可以添加新的记录或者更新已有记录</li>
<li>Scan 操作会根据条件遍历多行记录</li>
<li>Delete 操作会移除一条记录</li>
</ul>
<p>Get 和 Scan 操作的返回都是排好序的，依据为 rowkey, column family, family 成员，和时间戳（也就是最新的值会在最前面）。默认来说，Get, Scan 和  Delete 操作都是在数据最新的版本上的（也可以指定其他版本的数据）。Delete 操作一般来说会删除整行，但是也可以删除指定的 cell。</p>
<p><strong>HBase 架构</strong></p>
<p>HBase 是以 HBase 节点集群来进行组织的，节点有两种类型：master 和 slave（也叫 RegionServers）</p>
<p><img src="/images/14562066977793.jpg" alt="HBase 集群架构"></p>
<p>HBase 会动态分配数据表，这样支持大量的并行访问。一个 HBase 表在太大时会被分成多个 Region，一个 HBase Region 是一个 HBase 表的子集，但是 rowkey 的范围是连续的。每个  RegionServer 可以保存多个 Regions，但是一个 Region 只会在一个 RegionServer 上。</p>
<p>虽然一个 Region 只会在一个 RegionServer 上，但是这不意味着该 Region 部分的数据只能存在于一个 RegionServer 上。事实上，因为 HDFS 的复制机制，每个 Region 都会在其他 RegionServer 上有几份一模一样的拷贝。想要了解更多？查看 <a href="http://hbase.apache.org/book.html" target="_blank" rel="external">HBase Reference Guide</a> 以及 <a href="https://blogs.apache.org/hbase/" target="_blank" rel="external">HBase 博客</a>.</p>
<p>HBase 使用 Apache ZooKeeper 来协调控制整个 HBase 集群。Apache ZooKeeper 需要做的事情有：选择 master 节点，寻找 -ROOT- catalog table 以及节点注册（当新的 RegionServer 加入的时候）。由 ZooKeeper 选择出来的 master 节点会处理诸如 region 分配，失败处理，负载均衡等任务。</p>
<p>HBase 使用 HDFS 作为存储，但是同样支持其他文件系统（本地文件系统，甚至 Amazon S3）。</p>
<p>这个 <a href="https://youtu.be/lUOFLa0DKdc" target="_blank" rel="external">HBase Demo</a> 视频会介绍 HBase 的基本使用，虽然视频中的 EMR 版本较旧，但是对我们这次的任务没有什么影响。</p>
<ul>
<li>Costs = Instance + EMR costs</li>
<li>进入 EMR 页面 -&gt; 创建集群 -&gt; 输入名字 -&gt; 开启关闭保护 </li>
<li>选择 S3 的 log bucket -&gt; 打上标签 -&gt; 去掉 pig 和 hive，改为 HBase </li>
<li>选择 spot -&gt; 指定 keypair -&gt; 需要等待一段时间开启</li>
<li>ssh 到 master public dns，注意这里用户名是 hadoop 而不是 ubuntu</li>
<li><code>hbase shell</code> -&gt; <code>&gt; help</code> 查看帮助 -&gt; <code>&gt; status</code> 查看状态</li>
<li><code>create &#39;users&#39;, &#39;info&#39;</code> 创建表格</li>
<li><code>describe &#39;users&#39;</code> 可以查看表格内容</li>
<li><code>put &#39;user&#39;, &#39;johndeo&#39;, &#39;info&#39;, &#39;regularUser&#39;</code> 插入一条记录</li>
<li><code>get &#39;users&#39;, &#39;johndoe&#39;</code> 获取一条记录</li>
<li><code>scan &#39;users&#39;</code> 遍历某个表并输出</li>
<li><code>count &#39;users&#39;</code> 统计表的行数</li>
</ul>
<blockquote>
<p>注意：EMR 很贵，最好使用 spot instance</p>
</blockquote>
<h3 id="u4F7F_u7528_EMR__u521B_u5EFA_HBase__u96C6_u7FA4"><a href="#u4F7F_u7528_EMR__u521B_u5EFA_HBase__u96C6_u7FA4" class="headerlink" title="使用 EMR 创建 HBase 集群"></a>使用 EMR 创建 HBase 集群</h3><p>我们将使用 EMR 创建 HBase 集群。HBase 使用 Hadoop Distributed File System (HDFS) 来存储数据。默认来说 AWS 会直接用 EC2 内置的存储给 HDFS 使用，下面是具体的使用步骤：</p>
<ol>
<li>启动 EMR 集群：1 master &amp; 1 core <ul>
<li>在创建页面中选择 “Go to advanced options”</li>
<li>确保所有的实例都是 m1.large</li>
<li>确保 EMR 集群和存放 <code>runner.sh</code> 的实例在同一个区域</li>
<li>选择 AMI version 3.11.0 (hadoop version 2).</li>
<li>移除所有的已有服务(Pig &amp; Hive)并选择安装 HBase version 0.94.</li>
<li>指定 key-pair 以便 SSH 到 master 实例，ssh 的时候注意用户名是 hadoop</li>
<li>不要忘记设置标签</li>
<li>开启 “termination protection” 和 “keep-alive”</li>
</ul>
</li>
<li>master 和 core 节点的安全组都允许所有流量，使用 Master public DNS 来进行连接</li>
<li>ssh 到 master 节点之后，运行 <code>hadoop dfsadmin -report</code> 检查 HDFS 的状态</li>
</ol>
<h3 id="u8F7D_u5165_u6570_u636E_u5230_HBase"><a href="#u8F7D_u5165_u6570_u636E_u5230_HBase" class="headerlink" title="载入数据到 HBase"></a>载入数据到 HBase</h3><p>HBase 支持多种数据导入方法，这里我们介绍 Bulk Load 方法。</p>
<p>最直接的载入办法可以是在 MapReduce job 中使用 <code>TableOutputFormat</code> 类，也可以使用client APIs，但是这可能不是最有效率，因为 API 不支持 bulk loading.</p>
<p>Bulk Importing 会越过 HBase API 直接写入到数据文件中(HFiles)。使用 bulk load 可以减少 CPU 和网络带宽的占用。<code>ImportTsv</code> 就可以完成这个任务，虽然原本是为 TSV (Tab Separated Value) 格式设计的，但是通过设置参数，同样支持 CSV 文件，步骤如下：</p>
<ol>
<li>把 TSV/CSV 格式的数据集上传到 HDFS (Hadoop Distributed File System)<ul>
<li>File System (FS) shell 支持基本的文件操作比如 <code>Local FS</code>, <code>HFTP FS</code>, <code>S3 FS</code> 等等，可以通过 <code>hadoop fs &lt;args&gt;</code> 来调用</li>
<li>从 S3 bucket 获取 <code>million_songs_metadata.csv</code> 文件<ul>
<li><code>mkdir P3_1</code></li>
<li><code>cd P3_1</code></li>
<li><code>wget https://s3.amazonaws.com/15319-p31/million_songs_metadata.csv</code></li>
</ul>
</li>
<li>把下载下来的文件保存到 HDFS 中以便导入，具体命令需要自己寻找</li>
<li>可以用 <code>hadoop fs -ls /path/containing/your/uploaded/file</code> 来检测是否上传成功</li>
</ul>
</li>
<li>打开 HBase shell (<code>HBase shell</code>)并新建一个名为 songdata 的表(使用 <code>create</code> 命令，后面跟 column family name 的名字)。建立成功之后使用 <code>exit</code> 命令退出</li>
<li>为 HBase 表准备好 HFiles。使用 <code>ImportTsv</code> 命令把文件 <code>million_songs_metadata.csv</code> 中的数据传到 HDFS 中，名为 <code>importtsv.bulk.outputHbase</code>。这些 StoreFiles 之后会被载入到 HBase 中。注意这里我们使用 <code>track_id</code> 作为 row key，其他的列会成为 column family name (这里使用 ‘data’)。要了解 <code>ImportTsv</code> 的更多信息，请参考 <a href="http://hbase.apache.org/0.94/book/ops_mgt.html#importtsv" target="_blank" rel="external">official reference</a>.</li>
<li>正常启动的话，我们可以看到 MapReduce 工作的进程</li>
<li>检查 Map 步骤的输出来验证结果。通常来说应该会与数据集中的数据数量相等。注意，对应的输出文件应该是不存在的（不然会导致任务失败）</li>
<li>前面所做的所有工作都只是为了把数据保存到 HBase 中，但是此时 HBase 的表仍旧是空的（还没有添加对应的记录）</li>
<li>需要使用 CompleteBulkLoad 工具来完成数据上传，参考官方文档来使用</li>
<li>现在可以验证数据是否成功上传，打开 HBase shell 然后用以下命令来查看 <code>scan &#39;songdata&#39;</code></li>
<li>用 Ctrl-C 结束输出</li>
</ol>
<p>当然，除了这个方法，也可以在 MapReduce job 中使用 <code>TableOutputFormat</code> 或者其他 HBase client API。</p>
<h3 id="HBase__u67E5_u8BE2"><a href="#HBase__u67E5_u8BE2" class="headerlink" title="HBase 查询"></a>HBase 查询</h3><p>与 MySQL 类似，HBase 提供了查询的工具。在 HBase 中，数据存在 column 中，多个 column 组成 column family。我们可以用下面的指令来进行查询：</p>
<p><code>scan ‘table_name’, {COLUMNS =&gt; [‘column1’, ‘column2’, …], FILTER =&gt; “(FILTER1) … (FILTER2)”}</code></p>
<p>我们来做一个和之前类似的查询，找到所有 <code>artist_name</code> 以 “The Beatles” 开头的记录（是一个前缀匹配，不是子串匹配），查询如下：</p>
<p><code>scan &#39;songdata&#39;, {COLUMNS =&gt; &#39;data:artist_name&#39;, FILTER =&gt; &quot;SingleColumnValueFilter(&#39;data&#39;, &#39;artist_name&#39;, = , &#39;regexstring:^The Beatles.*&#39;)&quot;}</code></p>
<p>这里的列名的格式是 <code>(column family name):(column qualifier name)</code>。并且返回的数据中只包含了 <code>artist_name</code> 的数据，如果我们想多看一些数据，在 COLUMNS 部分多加一些内容，如：</p>
<p><code>scan &#39;songdata&#39;, {COLUMNS =&gt; [&#39;data:artist_name&#39;, &#39;data:title&#39;], FILTER =&gt; &quot;SingleColumnValueFilter(&#39;data&#39;, &#39;artist_name&#39;, = , &#39;regexstring:^The Beatles.*&#39;)&quot;}</code></p>
<p>同样，我们也可以添加更多的 FILTER，用逻辑运算符 AND, OR, WHILE 等来进行组合。比如说，如果我们想在原来条件的基础上增加另一个条件：其 title 以 W 或者以 W 之后的字母开头，那么命令就可以这么写：</p>
<p><code>scan &#39;songdata&#39;, {COLUMNS =&gt; [&#39;data:artist_name&#39;, &#39;data:title&#39;], FILTER =&gt; &quot;SingleColumnValueFilter(&#39;data&#39;, &#39;artist_name&#39;, = , &#39;regexstring:^The Beatles.*&#39;) AND SingleColumnValueFilter(&#39;data&#39;, &#39;title&#39;, &gt;= , &#39;binaryprefix:W&#39;)&quot;}</code></p>
<p>另外提一点，在 FILTER 中使用了某一列，就需要在 COLUMNS 列表中也加入对应的列名，不然就会被忽略的，更多信息可以参阅<a href="http://www.cloudera.com/content/cloudera/en/documentation/core/latest/topics/admin_hbase_filtering.html" target="_blank" rel="external">这篇日志</a>.</p>
<h3 id="HBase_Java_API"><a href="#HBase_Java_API" class="headerlink" title="HBase Java API"></a>HBase Java API</h3><p>HBase 也有其 Java API，可以用来创建、查看、修改和删除表，同样也可以插入和查询。</p>
<p><strong>建立连接</strong></p>
<p>首先我们需要建立连接，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Configuration conf = HBaseConfiguration.create();</span><br><span class="line">conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, zookeeperAddress);</span><br><span class="line">conf.set(<span class="string">"hbase.zookeeper.property.clientport"</span>, <span class="string">"2181"</span>);</span><br><span class="line">HConnection conn = HConnectionManager.createConnection(conf);</span><br><span class="line">HTableInterface table = conn.getTable(tableName);</span><br></pre></td></tr></table></figure>
<p>前三行配置地址和端口，这里需要填写 master node 的 IP 地址。然后就可以创建 <code>HConnection</code> 并得到一个 <code>HTableInterface</code> 对象（用来处理特定 HBase 表）。</p>
<p>另一个创建 HBase table handler 的方法是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTable table = <span class="keyword">new</span> HTable(conf, tableName);</span><br></pre></td></tr></table></figure>
<p>不过在新版本中已经被弃用了（所以直接不写出来不就好了嘛）</p>
<p>最常见的操作是 Get 和 Scan，get 用来获取某一行，scan 用来对多行操作，一般来说 scan 比 get 慢。不过我们这里会使用 scan。</p>
<p>下面是一个简单的例子，我们打印出所有 <code>artist_name</code> 以 “The Beatles” 开头的记录。更多详细的使用方法请参考 <a href="https://hbase.apache.org/0.94/apidocs/" target="_blank" rel="external">HBase Java API 文档</a>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new Scan object. By calling the default constructor, the entire table will be scanned.</span></span><br><span class="line">Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Binary representation of the column family name</span></span><br><span class="line"><span class="keyword">byte</span>[] bColFamily = Bytes.toBytes(<span class="string">"data"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Binary representation of the column name.</span></span><br><span class="line"><span class="keyword">byte</span>[] bCol = Bytes.toBytes(<span class="string">"artist_name"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is used for regular expression matching. You should use different comparators based on specific requirements.</span></span><br><span class="line">RegexStringComparator comp = <span class="keyword">new</span> RegexStringComparator(<span class="string">"^The Beatles.*"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This defines the filtering rules of our Scan object.</span></span><br><span class="line">Filter filter = <span class="keyword">new</span> SingleColumnValueFilter(bColFamily, bCol, CompareFilter.CompareOp.EQUAL, comp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Associate the filtering rules to our Scan object.</span></span><br><span class="line">scan.setFilter(filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use this if your query will return multiple rows.</span></span><br><span class="line">scan.setBatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the scan result.</span></span><br><span class="line">ResultScanner rs = songsTable.getScanner(scan);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Each call of rs.next() will return one row.</span></span><br><span class="line"><span class="keyword">for</span> (Result r = rs.next(); r != <span class="keyword">null</span>; r = rs.next()) &#123;</span><br><span class="line">    <span class="comment">// r represents one row in the table. r.getValue returns the specific cell (determined by column family</span></span><br><span class="line">    <span class="comment">// and column name.</span></span><br><span class="line">    System.out.println(Bytes.toString(r.getValue(bColFamily, bCol)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cleanup</span></span><br><span class="line">rs.close();</span><br></pre></td></tr></table></figure>
<p>看看 <a href="http://hbase.apache.org/0.94/book/client.filter.html" target="_blank" rel="external">HBase tutorial on Client Request Filters</a> 对完成这部分的任务也很有帮助。</p>
<h3 id="u89E3_u9898_u653B_u7565-3"><a href="#u89E3_u9898_u653B_u7565-3" class="headerlink" title="解题攻略"></a>解题攻略</h3><p>这部分的任务就是完成 <code>runner.sh</code> 中的 17-21 题，需要改动的文件是 <code>HBaseTasks.java</code>。可以用下面的代码来运行 demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac HBaseTasks.java</span><br><span class="line">java HBaseTasks demo</span><br></pre></td></tr></table></figure>
<p>会打印出所有 <code>artist_name</code> 以 “The Beatles” 开头的记录（大小写敏感）</p>
<p>先把需要的文件 scp 到本地 <code>scp -i demo.pem ubuntu@ec2-54-209-165-121.compute-1.amazonaws.com:~/Project3_1/HBaseTasks.java ./</code></p>
<p>问题列表(17 题开始)：</p>
<ol>
<li>(17)找到以 “Total” 开头 “Water 结尾的歌名</li>
<li>(18)找到 “Kanye West” 的歌曲的歌名，名称以 “Apologies” 或 “Confessions” 开头，大小写敏感</li>
<li>(19)找到歌手名以 “Bob Marley” 为前缀的一首歌的歌名，长度大于 400，年份是 2000 年之后（包括 2000 年）</li>
<li>(20)找到歌手名包含 “Consequence” 的一首歌的歌名，歌名包含 “Family” 并且 <code>artist_hotttnesss</code> 要大于 1</li>
<li>(21)找到歌手名以 “Gwen Guthrie” 为前缀的一首歌的歌名，歌名包含 “Love” 但不包含 “Bitter” 或者 “Never”，年份为 1990</li>
</ol>
<p>然后按照前面的指引开一个 EMR，注意一定要开启 SSH，不然开了等于白开，开启之后连接上去 <code>ssh -i demo.pem hadoop@ec2-52-90-21-43.compute-1.amazonaws.com</code></p>
<p>然后用 <code>hadoop dfsadmin -report</code> 检查状态，不过说已经弃用这种命令写法了，如下：</p>
<p><img src="/images/14562658234752.jpg" alt=""></p>
<p>然后我们创建一个文件夹并下载对应的 csv 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir P3_1</span><br><span class="line"><span class="built_in">cd</span> P3_1</span><br><span class="line">wget https://s3.amazonaws.com/<span class="number">15319</span>-p31/million_songs_metadata.csv</span><br></pre></td></tr></table></figure>
<p>然后创建对应的 HDFS 目录，再把 csv 文件移过去：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir /dawang</span><br><span class="line">hadoop fs -mkdir /dawang/csv</span><br><span class="line">hadoop fs -put ./million_songs_metadata.csv /dawang/csv/</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">hadoop fs -ls /dawang/csv/</span><br></pre></td></tr></table></figure>
<p><img src="/images/14562663033381.jpg" alt="hadoop fs -ls 结果"></p>
<p>然后进入 HBase Shell 操作 <code>hbase shell</code></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">001</span>:<span class="number">0</span>&gt; create <span class="string">'songdata'</span>,<span class="string">'data'</span></span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">002</span>:<span class="number">0</span>&gt; list</span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">003</span>:<span class="number">0</span>&gt; describe <span class="string">'songdata'</span></span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">004</span>:<span class="number">0</span>&gt; exit</span><br></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<p><img src="/images/14562664950809.jpg" alt=""></p>
<p>然后就需要具体的导入了，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hbase org.apache.hadoop.hbase.mapreduce.ImportTsv -Dimporttsv.separator=<span class="string">","</span> -Dimporttsv.bulk.output=/hfile_p31 -Dimporttsv.columns=HBASE_ROW_KEY,data:title,data:song_id,data:release,data:artist_id,data:artist_mbid,data:artist_name,data:duration,data:artist_familiarity,data:artist_hotttnesss,data:year songdata /dawang/csv/million_songs_metadata.csv</span><br><span class="line"></span><br><span class="line">hbase org.apache.hadoop.hbase.mapreduce.LoadIncrementalHFiles /hfile_p31 songdata</span><br></pre></td></tr></table></figure>
<p>完成之后测试一下 <code>hbase shell</code>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">001</span>:<span class="number">0</span>&gt; scan <span class="string">'songdata'</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/14562672790636.jpg" alt="结果输出"></p>
<p>有很多需要注意的地方，尤其是比较字符串的时候，有些坑是一定要踩的（爆炸感谢 @jiexing）。</p>
<p>测试的话用 <code>./runner.sh hbase</code>，确定无误后使用 <code>./submitter -a dawang</code> 来进行提交，代码运行完成后输入提交密码即可。</p>
<p>一些需要注意的地方：</p>
<ol>
<li>Java 代码中需要填写 HBase 的 master node 的 dns</li>
<li>每题的答案在一行里输出</li>
<li>设置正确的日志级别来防止不必要的输出</li>
</ol>
<blockquote>
<p>SCAN 操作是 O(N) 的，GET 操作是 O(logN)，比较好的方式是，通过精心设计的数据库，用两次 GET 操作拿到起始和结束的 rowkey，这样就有极大的效率提高，详情参考<a href="https://blog.cloudera.com/blog/2013/04/how-scaling-really-works-in-apache-hbase/" target="_blank" rel="external">这里</a></p>
</blockquote>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.runoob.com/linux/linux-comm-join.html" target="_blank" rel="external">Linux join命令</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>从这一课起，我们要开始使用数据库了。通过数据库和文件的性能对比以及 SQL 与 NoSQL 的对比，学会选择最合适的技术。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="数据库" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="文件" scheme="http://wdxtub.com/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[How to Speak]]></title>
    <link href="http://wdxtub.com/2016/02/22/how-to-speak/"/>
    <id>http://wdxtub.com/2016/02/22/how-to-speak/</id>
    <published>2016-02-22T14:14:09.000Z</published>
    <updated>2016-02-22T14:27:35.000Z</updated>
    <content type="html"><![CDATA[<p>因为要当助教的缘故，需要进行语言培训，其中一部分就是如何做展示，这篇日志主要介绍相关的技巧，主要来源自 MIT 的 Patrick Winston 的『How to Speak』小课程。</p>
<a id="more"></a>
<hr>
<h2 id="u5982_u4F55_u5F00_u59CB"><a href="#u5982_u4F55_u5F00_u59CB" class="headerlink" title="如何开始"></a>如何开始</h2><ul>
<li>了解知识本身加上练习，可以弥补大部分天赋上的差距</li>
<li>不要用讲笑话来开头，因为听众其实还没有准备好 </li>
<li>可以用一个承诺来开头，比方说告诉听众，听完我的演讲你们会得到很多有用的东西，这能让听众意识到你要说的内容的价值，并更加认真去听</li>
<li>列出大纲，第一告诉大家演讲要开始了，第二用清晰的结构让听众意识到现在所处的位置</li>
</ul>
<h2 id="u56DB_u5927_u65B9_u6CD5"><a href="#u56DB_u5927_u65B9_u6CD5" class="headerlink" title="四大方法"></a>四大方法</h2><ul>
<li>Cycling：重复去说一个事情，一次一次又一次<ul>
<li>从心理学角度来看，重复有助于形成长期记忆</li>
<li>从概率角度来看，重复可以让之前走神没听到的听众听到</li>
</ul>
</li>
<li>Verbal punctuation：用明确的分隔词来界定架构（首先，其次，等等）<ul>
<li>能够让因为走神不知道听到哪里的人重新跟上节奏</li>
</ul>
</li>
<li>Near-Miss：在解释复杂概念的时候，用具体的类似的例子，来清晰界定概念的范围<ul>
<li>比如说要介绍正方形的话，可以顺带介绍长方形，并指出为什么长方形不是正方形，这样就有了明确的区分条件</li>
</ul>
</li>
<li>Ask Quesitions：用常见且易于回答的问题来引导听众<ul>
<li>一般来说等待 5 秒钟，虽然对于演讲者来说感觉很长，但其实对于回答问题的来说很短    </li>
<li>注意，目的不是刁难人，而是让大家跟上演讲的节奏</li>
</ul>
</li>
</ul>
<h2 id="u65F6_u95F4_u548C_u5730_u70B9"><a href="#u65F6_u95F4_u548C_u5730_u70B9" class="headerlink" title="时间和地点"></a>时间和地点</h2><ul>
<li>最佳时间是早上十点半，如果要在下午三点之后进行演讲，最好准备些吃的，帮助听众补充能量，集中精神</li>
<li>要足够明亮，如果灯光太暗的话，听众容易睡着</li>
<li>尽量要选择人能坐满的地方，空着的位置很影响效果</li>
</ul>
<h2 id="u4F7F_u7528_u9ED1_u677F"><a href="#u4F7F_u7528_u9ED1_u677F" class="headerlink" title="使用黑板"></a>使用黑板</h2><ul>
<li>除了语言系统，视觉系统也是我们学习理解新知识非常重要的输入，利用黑板可以增加视觉上的冲击，帮助听众更好地理解内容</li>
<li>可以在黑板上写写画画，可以列表用作大纲，更重要的是，不用担心手放在哪里了，可以指着黑板上具体的内容进行讲述，就很自然</li>
</ul>
<h2 id="u4F7F_u7528_u6295_u5F71_u4EEA"><a href="#u4F7F_u7528_u6295_u5F71_u4EEA" class="headerlink" title="使用投影仪"></a>使用投影仪</h2><ul>
<li>应该…<ul>
<li>具体列出每一部分的标题</li>
<li>使用不同的颜色</li>
</ul>
</li>
<li>不应该…<ul>
<li>纯粹读 PPT（听众认字儿）</li>
<li>站到一边（你才是演讲的中心，而不是 PPT，要让观众把注意力集中在你身上）</li>
<li>把指点棒甩来甩去，分散注意力，所以干脆直接用手就好</li>
<li>遮住部分内容然后再掀开，这会让部分观众不爽</li>
</ul>
</li>
</ul>
<h2 id="u9053_u5177"><a href="#u9053_u5177" class="headerlink" title="道具"></a>道具</h2><ul>
<li>使用道具来增加演示效果，但是注意不要喧宾夺主</li>
</ul>
<h2 id="u98CE_u683C"><a href="#u98CE_u683C" class="headerlink" title="风格"></a>风格</h2><ul>
<li>从成功的演讲者身上学到适合自己的方法，而不是照搬</li>
<li>可以考虑的：用自己的特质（个性化装束）以及讲故事来吸引听众</li>
</ul>
<h2 id="u5982_u4F55_u7ED3_u5C3E"><a href="#u5982_u4F55_u7ED3_u5C3E" class="headerlink" title="如何结尾"></a>如何结尾</h2><ul>
<li>不要长篇大论说谢谢</li>
<li>可以用玩笑来结尾</li>
<li>提醒听众开头所提到的承诺，点题</li>
<li>Salute the audience</li>
</ul>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://vimeo.com/101543862" target="_blank" rel="external">How to Speak: Lecture Tips from Patrick Winston</a></li>
<li><a href="http://sixminutes.dlugan.com/speaking-tips-patrick-henry-winston-speak/" target="_blank" rel="external">How to Speak: 7 Speaking Tips from Patrick Henry Winston</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为要当助教的缘故，需要进行语言培训，其中一部分就是如何做展示，这篇日志主要介绍相关的技巧，主要来源自 MIT 的 Patrick Winston 的『How to Speak』小课程。</p>]]>
    
    </summary>
    
      <category term="技巧" scheme="http://wdxtub.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="演讲" scheme="http://wdxtub.com/tags/%E6%BC%94%E8%AE%B2/"/>
    
      <category term="英语" scheme="http://wdxtub.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C 格致余论 2 - Category]]></title>
    <link href="http://wdxtub.com/2016/02/21/dive-in-objc-2/"/>
    <id>http://wdxtub.com/2016/02/21/dive-in-objc-2/</id>
    <published>2016-02-22T01:07:23.000Z</published>
    <updated>2016-02-22T03:02:14.000Z</updated>
    <content type="html"><![CDATA[<p>Objective-C 中的 Category 和 Swift 中的 Extension 还是挺类似的，但是仍有一些区别，所以具体了解一下，也是有必要的。</p>
<a id="more"></a>
<hr>
<p>一般来说，在 C++ 或者 Java 中，如果我们想改变一个已有类型的行为，可以继承之后重写或者添加对应的方法。不过在 Objective-C 中，可以不用继承，就直接添加新的方法或替换已有的方法。</p>
<p>当然，前一篇文章中提到过 <code>class_addMethod</code> 方法，不过还是用 category 更加规范和方便。这里需要注意，正常情况下，我们只能添加新的方法，却不能增加新的变量。</p>
<h2 id="u4EC0_u4E48_u65F6_u5019_u7528"><a href="#u4EC0_u4E48_u65F6_u5019_u7528" class="headerlink" title="什么时候用"></a>什么时候用</h2><p>一般来说，继承是最正规的做法，可以很方便地重用。但是也有一些情况，继承不大容易，这时候用 category 就比较合适了，比如：</p>
<ol>
<li>Foundation 对象</li>
<li>用工厂模式创造的对象</li>
<li>单例对象</li>
<li>在 app 中已经使用很多次的自定对象（继承的话很容易因为漏改而出错）</li>
</ol>
<p>下面我们分别介绍这几种情况</p>
<h3 id="Foundation__u5BF9_u8C61"><a href="#Foundation__u5BF9_u8C61" class="headerlink" title="Foundation 对象"></a>Foundation 对象</h3><p>Foundation 中的类，比如 <code>NSString</code>, <code>NSArray</code>, <code>NSDictionary</code> 除了可以通过 Objective-C 的接口调用外，其实也可以用另一个 C 的接口调用。例如 <code>NSString</code> 会对应到 Core Foundation 中的 <code>CFStringRef</code>。</p>
<p>所以在实际生成的时候，其实具体的类别是难以确定的，也就是说，我们继承了一个 <code>NSString</code> 类创建了一个 <code>MyString</code>， 新建实例的时候，其实并不能保证新建的就是一个 <code>MyString</code>，所以这种情况下，不是很适合用继承，而是 category 直接进行拓展比较合适。</p>
<h3 id="u5DE5_u5382_u6A21_u5F0F_u5BF9_u8C61"><a href="#u5DE5_u5382_u6A21_u5F0F_u5BF9_u8C61" class="headerlink" title="工厂模式对象"></a>工厂模式对象</h3><p>工厂模式本身的机制就是，不用关心具体的子类，只要传入所需要的类型，会自动生成我们需要的类。</p>
<p>就拿 <code>UIButton</code> 来说，即使我们继承了，在具体生成的时候，也不能保证得到我们继承后的子类，从这个角度来看，和上一个情境是类似的。</p>
<p>或者说，我们想要改变一个父类的行为，让所有的子类都增加新的方法，当时实际上我们没办法改动这个父类的时候，就应该采用 category。</p>
<p>这种因为具体生成什么类不确定的情况，会导致很多奇奇怪怪的问题，一定要小心使用，或者直接用 Swift，真心的。</p>
<h3 id="u5355_u4F8B_u5BF9_u8C61"><a href="#u5355_u4F8B_u5BF9_u8C61" class="headerlink" title="单例对象"></a>单例对象</h3><p>这也是非常出名的设计模式了，比如 <code>UIApplication</code>, <code>NSUserDefault</code>, <code>NSNotificationCenter</code> 等都是这种设计。因为单例实现机制的问题，使其本身很难被继承，我们先来看看如何声明一个单例。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (MyClass *)sharedInstance;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现部分</span></span><br><span class="line"><span class="keyword">static</span> MyClass *sharedInstance = <span class="literal">nil</span>;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">+ (MyClass *)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> sharedInstance ? sharedInstance : (sharedInstance = [[MyClass alloc] init]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>(注意，其实一般 Singleton 会使用 GCD 的 <code>dispatch_once</code> 实现，不过暂时为了理解简单，先用上面的写法)</p>
<p>假如我们继承 MyClass 之后却没有重写覆盖 sharedInstance 方法，首先可能还是会返回原来的对象，另外如果我们覆盖的话，那么可能就会漏过放在原来的实现中的一些操作（因为我们可能看不到源代码），产生与预期不符的结果。</p>
<h2 id="Category__u7684_u5199_u6CD5"><a href="#Category__u7684_u5199_u6CD5" class="headerlink" title="Category 的写法"></a>Category 的写法</h2><p>语法还是很简单的，只要记住括号里是 category 的名称即可，我们用给 NSString 添加一个 <code>strokeCompare:</code> 为例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> (<span class="title">CustomCompare</span>)</span></span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>)strokeCompare:(<span class="built_in">NSString</span> *)anotherString;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSString</span> (<span class="title">CustomCompare</span>)</span></span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>)strokeCompare:(<span class="built_in">NSString</span> *)anotherString </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLocale</span> *strokeSortingLocale = [[[<span class="built_in">NSLocale</span> alloc]</span><br><span class="line">                    initWithLocaleIdentifier:<span class="string">@"zh@collation=stroke"</span>]</span><br><span class="line">                    autorelease];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> compare:anotherString</span><br><span class="line">                 options:<span class="number">0</span></span><br><span class="line">                   range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, [<span class="keyword">self</span> length])</span><br><span class="line">                  locale:strokeSortingLocale];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>惯例的命名方式是 <code>NSString+CustomCompare.h</code> 和 <code>NSString+CustomCompare.m</code></p>
<p>除了添加新方法，以下情况也很适合用 category</p>
<ul>
<li>将一个很大的类切分成几个部分，代码组织更清晰，也更易于跨平台</li>
<li>替换原来的实现，实现方法的重写，但是这种方式比较危险，推荐不要使用</li>
</ul>
<h2 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h2><p>另一个类似的设计是 extensions，可以认为 extensions 是一个没有名字的 category，在 extensions 中定义的方法，需要放在原本的类的实现中，是类名后面跟一对空括号，下面是一个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span>()</span></span><br><span class="line">- (<span class="keyword">void</span>)doSomething;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">- (<span class="keyword">void</span>)doSomething</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p> 具体有什么用呢，比方说可以：</p>
<ul>
<li>拆分 header</li>
<li>管理私有方法</li>
</ul>
<p>Swift 中的做法就更加简单粗暴，直接用类名，加上不同的关键字即可，如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，extension 也可以用来扩展 protocol 和 struct，不过这里暂时先不展开。</p>
<h2 id="u589E_u52A0_u53D8_u91CF_u4E0E_u5C5E_u6027"><a href="#u589E_u52A0_u53D8_u91CF_u4E0E_u5C5E_u6027" class="headerlink" title="增加变量与属性"></a>增加变量与属性</h2><p>虽然前面提到不能增加变量或者属性，但是其实还是有办法的，既然我们是用 virtual table 来记录相关的方法，同样可以用另一个表格来记录相关的变量和方法嘛，这就是 Associated Objects。具体的使用方式如下：</p>
<p><img src="/images/14561097124357.jpg" alt=""></p>
<p>另外，虽然 category 不能增加成员变量，但是 extension 可以，甚至也可以直接在 <code>@implementation</code> 中加入。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.gitbook.com/book/zonble/kkbox-ios-dev/details" target="_blank" rel="external">KKBOX iOS/Mac OS X 基本开发教材</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html" target="_blank" rel="external">Customizing Existing Classes</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html" target="_blank" rel="external">Category</a></li>
<li><a href="http://nshipster.com/associated-objects/" target="_blank" rel="external">Associated Objects</a></li>
<li><a href="http://kingscocoa.com/tutorials/associated-objects/" target="_blank" rel="external">Objective-C Associated Objects</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/" target="_blank" rel="external">Objective-C Runtime Reference</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Objective-C 中的 Category 和 Swift 中的 Extension 还是挺类似的，但是仍有一些区别，所以具体了解一下，也是有必要的。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://wdxtub.com/tags/Mac/"/>
    
      <category term="Objective-C" scheme="http://wdxtub.com/tags/Objective-C/"/>
    
      <category term="category" scheme="http://wdxtub.com/tags/category/"/>
    
      <category term="iOS" scheme="http://wdxtub.com/tags/iOS/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iTerm2 Version3 动手玩]]></title>
    <link href="http://wdxtub.com/2016/02/21/iterm-v3-preview/"/>
    <id>http://wdxtub.com/2016/02/21/iterm-v3-preview/</id>
    <published>2016-02-21T13:53:13.000Z</published>
    <updated>2016-02-21T16:20:32.000Z</updated>
    <content type="html"><![CDATA[<p>经过 18 个月的等待，iTerm2 终于迎来了第三个主要版本！虽然现在还在最后的 Beta 测试，不过很多超强功能已经可以体验了。这篇文章就带大家大致浏览下新功能，以及非常强大的 Shell integration。</p>
<a id="more"></a>
<hr>
<h2 id="u4E3B_u8981_u65B0_u7279_u6027"><a href="#u4E3B_u8981_u65B0_u7279_u6027" class="headerlink" title="主要新特性"></a>主要新特性</h2><p>这一部分先概要介绍一下 3.0 中的主要改进（相当令人惊喜）</p>
<ul>
<li>全新的界面设计<ul>
<li>配合最新 OSX 的扁平设计风格，和系统的整体基调更搭，更好看</li>
</ul>
</li>
<li>Shell Integration<ul>
<li>基本上可以认为是 login script 的超级强化版本，可以做很多超有意思的事情：命令提示符、命令执行完成的通知、拖拽上传和下载文件等等，这一部分会在后面详细介绍</li>
</ul>
</li>
<li>自动切换 profile<ul>
<li>比方说在 ssh 到远程机器上，或者进入 root 权限，或者进入某些特定的文件夹都可以自动切换 profile（至少可以变个配色）</li>
</ul>
</li>
<li>Session 恢复<ul>
<li>简单来说就是不用 tmux 的 tmux</li>
</ul>
</li>
<li>内部显示图片<ul>
<li>可以使用 <code>imgcat</code> 脚本来在 iTerm2 中显示图片（甚至 GIF 都可以），这一部分会在后面详细介绍</li>
</ul>
</li>
<li>Badges<ul>
<li>这是一个全新的功能！可以在当前的命令行的右上角显示一些相关信息（比如当前的主机名称或者 git 分支名称），这一部分后面会详细介绍</li>
</ul>
</li>
<li>密码管理器<ul>
<li>内置的密码管理器可以保存密码到 Mac OS 的 keychain 中，甚至可以在需要输入密码的时候自动打开密码管理器</li>
</ul>
</li>
<li>撤销关闭（回到过去）<ul>
<li>假如不小心关闭了一个窗口，command + z 就可以重新打开它（记得要在 5 秒之内按）</li>
</ul>
</li>
<li>标签栏现在可以放在左边，即使有很多 tab 也不怕了</li>
<li>动态 Profiles，可以把 profiles 保存在 JSON 文件中</li>
<li>不会再找不到光标了，可以高亮当前行或者让其他颜色变暗，总而言之就是显眼</li>
<li>时间戳功能能够让我看到不同命令的执行时间以及错误在何时发生</li>
<li>捕获输出，基本上来说，可以用这个功能实现部分 IDE 的便捷操作了</li>
</ul>
<p>注：虽然我不用 Alfred，但是新版的 iTerm2 也提供了对应支持，具体请查看官网文档。</p>
<h2 id="u67E5_u770B_u56FE_u7247"><a href="#u67E5_u770B_u56FE_u7247" class="headerlink" title="查看图片"></a>查看图片</h2><p>非常简单，只要使用 <code>imgcat imagename</code> 就可以显示图片，例如：</p>
<p><img src="/images/14560666426444.jpg" alt=""></p>
<p>不过使用之前还是需要配置一下：</p>
<ol>
<li>下载两个对应插件 <a href="https://raw.github.com/gnachman/iTerm2/master/tests/imgls" target="_blank" rel="external">imgls</a> <a href="https://raw.github.com/gnachman/iTerm2/master/tests/imgcat" target="_blank" rel="external">imgcat</a></li>
<li>去掉后缀名，把文件拷贝到 <code>/usr/local/bin</code> 中，并修改权限 <code>chmod 755 /usr/local/bin/imgls /usr/local/bin/imgcat</code></li>
</ol>
<p>然后就可以使用啦，如上图所示。另外一种用法是 <code>cat avatar.jpg | imgcat</code>，也是同样的效果：</p>
<h2 id="Badges"><a href="#Badges" class="headerlink" title="Badges"></a>Badges</h2><p>简单来说就是显示当前终端的信息，如下所示</p>
<p><img src="/images/14560679607791.jpg" alt=""></p>
<p>具体的设置也很简单，如果要像我这样显示的话，在 <code>Preferences&gt;Profiles&gt;General&gt;Badge</code> 输入 <code>\(session.username)@\(session.hostname)</code> 即可（这个依赖于 Shell Integration 功能）</p>
<p>更详细的文档可以查阅<a href="https://iterm2.com/badges.html" target="_blank" rel="external">这里</a></p>
<h2 id="Shell_Integration"><a href="#Shell_Integration" class="headerlink" title="Shell Integration"></a>Shell Integration</h2><p>这个算是重头戏了，不过需要先安装一下（支持 tcsh, zsh, bash 和 fish）。我是直接在菜单栏里选择 <code>iTerm2 &gt; Install Shell Integration</code> 进行安装的，实际上就是执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://iterm2.com/misc/install_shell_integration.sh | bash</span><br></pre></td></tr></table></figure>
<p>具体详细的文档在<a href="https://iterm2.com/shell_integration.html" target="_blank" rel="external">这里</a>，本文只挑选一些当下对我很有用的功能</p>
<h3 id="u5386_u53F2_u547D_u4EE4"><a href="#u5386_u53F2_u547D_u4EE4" class="headerlink" title="历史命令"></a>历史命令</h3><p>有四种方式可以查看：</p>
<ol>
<li><code>Edit&gt;Open Command History</code> (快捷键 Shift-Cmd-;)</li>
<li>自动完成功能（快捷键 Cmd-;）</li>
<li>Toolbet 中可以显示（这个后面介绍）</li>
<li>代码提示功能（View&gt;开启 Command Completion）</li>
</ol>
<p><img src="/images/14560694592327.jpg" alt="历史命令查看"></p>
<h3 id="Toolbelt"><a href="#Toolbelt" class="headerlink" title="Toolbelt"></a>Toolbelt</h3><p>在菜单栏中可以进行选择，然后就会出现在侧边栏，功能很多，很好用：</p>
<p><img src="/images/14560695283473.jpg" alt=""></p>
<p>选择之后的效果大概是：</p>
<p><img src="/images/14560695539493.jpg" alt=""></p>
<h3 id="u5BC6_u7801_u7BA1_u7406_u5668"><a href="#u5BC6_u7801_u7BA1_u7406_u5668" class="headerlink" title="密码管理器"></a>密码管理器</h3><p>我们先设置一个 trigger，如下图所示：</p>
<p><img src="/images/14560715131681.jpg" alt=""></p>
<p>然后在需要输入密码的时候，密码管理器会自动弹出：</p>
<p><img src="/images/14560715581287.jpg" alt=""></p>
<p>选择对应的帐号密码然后点击 Enter Password，就可以免去输入密码的烦恼了。</p>
<hr>
<p>还有很多功能没有摸索出来，网上的资料也比较少，以后有机会再慢慢补充吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>经过 18 个月的等待，iTerm2 终于迎来了第三个主要版本！虽然现在还在最后的 Beta 测试，不过很多超强功能已经可以体验了。这篇文章就带大家大致浏览下新功能，以及非常强大的 Shell integration。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://wdxtub.com/tags/Mac/"/>
    
      <category term="iTerm2" scheme="http://wdxtub.com/tags/iTerm2/"/>
    
      <category term="终端" scheme="http://wdxtub.com/tags/%E7%BB%88%E7%AB%AF/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C 格致余论 1 - Selector]]></title>
    <link href="http://wdxtub.com/2016/02/20/dive-in-objc-1/"/>
    <id>http://wdxtub.com/2016/02/20/dive-in-objc-1/</id>
    <published>2016-02-21T03:50:09.000Z</published>
    <updated>2016-02-22T00:56:48.000Z</updated>
    <content type="html"><![CDATA[<p>Selector 作为 Objective-C 中一个非常重要的概念，虽然在 Swift 中几乎已经不见踪影，但是在某些混编的项目中仍旧起到举足轻重的作用，所以仍然有必要深入理解一下。</p>
<a id="more"></a>
<hr>
<h2 id="Selector__u662F_u4EC0_u4E48"><a href="#Selector__u662F_u4EC0_u4E48" class="headerlink" title="Selector 是什么"></a>Selector 是什么</h2><p>所谓对概念的掌握，一定是能够用简短的语言描述出核心含义。并且还要理解这个概念的应用场景和常见上下文，这才算是『掌握』。</p>
<p>在我的理解来看，所谓 selector，实际上是函数指针的一种实现形式，我们用一个 C string 来表示对象中的某个函数，所以就可以把这个函数作为参数，传到其他的方法中去进行调用。</p>
<p>为了理解 selector，就先要搞明白，Objective-C 中的 Object，或者说 Class，到底是什么。我们知道 C 语言中是没有『类』这个概念的，只有 struct，所以 Objective-C 的 Class 在编译时会变成 C struct，Class 中包含的方法也会转换成 C function。之后在运行的时候，runtime 会建立起从 Objective-C Method 到 C function 的映射（可以认为是一个 virtual table）。</p>
<p>举个例子，我们写了一个简单的类</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Wdx</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>编译之后会变成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> mode;</span><br><span class="line">&#125; Wdx;</span><br></pre></td></tr></table></figure>
<p>所以你会发现，其实用无论用 Objective-C 还是 C 的方式进行调用，都没有问题：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wdx *wdx = [[Wdx alloc] init];</span><br><span class="line">wdx-&gt;mode = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>具体发生了什么？其实也很简单。Runtime 会为每个类准备一个 virtual table，里面是一个个键值对，key 称为 selector，类型是 <code>SEL</code>，value 实际上是 C function 的函数指针，类型是 <code>IMP</code>。而这里的 <code>SEL</code> 类型实际上就是 C string，可以用下面语句来进行输出：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, (<span class="keyword">char</span> *)(<span class="keyword">@selector</span>(doSomething)));</span><br></pre></td></tr></table></figure>
<p>了解了这个之后，我们就会发现，实际上调用某个方法，至少有以下三种方式：</p>
<ol>
<li>直接通过对象进行调用：<code>[myObject doSomething];</code></li>
<li>通过 <code>performSelector:</code> 调用：<code>[myObject performSelector:@selector(doSomething)];</code><ul>
<li>这里 <code>performSelector</code> 是基类 <code>NSObject</code> 的方法</li>
</ul>
</li>
<li>使用 <code>objc_msgSend</code> 调用：<code>objc_msgSend(myObject, @selector(doSomething), NULL);</code></li>
</ol>
<p>这里一定要清楚的意识到，其实一个类中有什么方法，是在 runtime 里决定的，既然如此，肯定有某种方法动态添加方法（比如说 category 和 swift 中的 extension，不过这里不展开）</p>
<p>也是因为这个机制，所以编译的时候，即使编译器没有发现类中对应的方法，也只是会发出警告而已；甚至如果使用 <code>performSelector:</code> 的话，连警告的不会有，只有在运行的时候才会发生 unrecognized selector sent to instance 错误导致程序崩溃。</p>
<p>比方说，我们可以通过 <code>class_addMethod</code> 方法来动态给一个类添加方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> myMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个文件</span></span><br><span class="line"><span class="preprocessor"># import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">class_addMethod([MyClass class], <span class="keyword">@selector</span>(myMethod), (IMP)myMethodIMP, <span class="string">"v@:"</span>);</span><br></pre></td></tr></table></figure>
<p>接下来就可以这么用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass *myObejct = [[MyClass alloc] init];</span><br><span class="line">[myObject myMethod];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然，直接这么做 Xcode 会给出警告的，这里只是用来介绍基本原理，实际开发中除非确实需要，否则不要这么做</p>
</blockquote>
<h2 id="Selector__u7528_u5728_u54EA"><a href="#Selector__u7528_u5728_u54EA" class="headerlink" title="Selector 用在哪"></a>Selector 用在哪</h2><p>因为 selector 可以看做是函数的另一个名字，所以很多需要调用函数或者建立连接的地方，都可以用到，以下是一些具体的使用场景</p>
<h3 id="Target/Action__u6A21_u5F0F"><a href="#Target/Action__u6A21_u5F0F" class="headerlink" title="Target/Action 模式"></a>Target/Action 模式</h3><p>这个模式非常常用，比方说我们新建的一个按钮，通过把 controller 中对应的 IBAction 方法和它连接，整个过程就是一个 Target/Action 模式，这个 controller 是 Button 的 target，而对应执行的方法，就是 action。</p>
<p>所以现在我们知道，其实在 storyboard 中做得代码和界面元素的连接，实际上就是建立一个 Target/Action 模式。不过 UIKit，也就是 iOS 上的 Target/Action 会稍微复杂一些（因为可以一次建立多个），这里用 AppKit 做例子（一次建立一个），比方说我们想要让一个按钮有自定义的行为，可以这么做：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyButton</span> : <span class="title">NSView</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> target;</span><br><span class="line">    SEL action;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="keyword">IBOutlet</span> <span class="keyword">id</span> target;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) SEL action;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyButton</span></span></span><br><span class="line">- (<span class="keyword">void</span>)mouseDown:(<span class="built_in">NSEvent</span> *)e</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> mouseDown:e];</span><br><span class="line">    [target performSelector:action withObject:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@synthesize</span> target, action;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面代码的意思是，在鼠标按下的时候，执行之前指定的 action，所以整个绑定的过程用下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[(MyButton *)button setTarget:<span class="keyword">self</span>];</span><br><span class="line">[(MyButton *)button setAction:<span class="keyword">@selector</span>(clickAction:)];</span><br></pre></td></tr></table></figure>
<p>我们可以看到在 Objective-C 中是用字符串来作为不同方法的标识符，在 C 语言会直接传递指针，其他抽象层级更高的语言有不同的处理方式，比如说把一段代码当做字符串传递，然后使用的时候去 evaluate，也可以把函数本身看做对象，直接像传递对象一样使用（也就是匿名函数），Objective-C 中的匿名函数实际上就是 block，不过这里不展开。</p>
<h3 id="u68C0_u67E5_method__u662F_u5426_u5B58_u5728"><a href="#u68C0_u67E5_method__u662F_u5426_u5B58_u5728" class="headerlink" title="检查 method 是否存在"></a>检查 method 是否存在</h3><p>这里一般用来配合向下兼容，比方说我们的代码需要调用一个新版本 iOS 才有的 API，那么最好先检查下对应方法是否存在，如果不存在，则做一些额外的处理，不然程序在较低版本的 iOS 就会崩溃，具体的检测方法也很简单，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> scale = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">if</span> ([[<span class="built_in">UIScreen</span> mainScreen] respondsToSelector:<span class="keyword">@selector</span>(scale)])&#123;</span><br><span class="line">    scale = [<span class="built_in">UIScreen</span>]<span class="variable">.scale</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过一般来说，在其他语言里，try catch 的方法是最常用的处理 method 是否存在的方式，不过因为 Objective-C 不算原生支持垃圾回收，try catch 可能会导致比较严重的内存泄露。好在 iOS 通过 runtime 提供了 ARC(Automatic Reference Conter) 来管理内存。</p>
<p>传统 Objective-C 使用 auto-release 的机制来释放内存（然而并不算太『自动』），会把要释放的内存放到下一轮 runloop 进行释放，这也是为什么不建议使用 try catch，因为实际上 try catch 是程序流中的非可控跳转，跳出了原来的 runloop，就会导致原来应该释放的内存没有释放。</p>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>另一个常见的用法是延迟调用某个方法，我们可以使用 <code>NSObject</code> 中的 <code>performSelector:withObject:afterDelay:</code> 在一定的延迟后调用某个方法，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(doSomething) withObject:<span class="literal">nil</span> afterDelay:<span class="number">1.0</span>];</span><br></pre></td></tr></table></figure>
<p>甚至还可以在方法执行之前取消方法的执行，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:<span class="keyword">self</span>];</span><br></pre></td></tr></table></figure>
<p>具体的实现方法可以是通过 <code>NSTimer</code>，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># timer 要做的事情</span></span><br><span class="line">- (<span class="keyword">void</span>)doSomething:(<span class="built_in">NSTimer</span> *)timer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Do Something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过 <code>doSomething:</code> 的 selector 来建立 timer：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span></span><br><span class="line">                          target:someObject</span><br><span class="line">                          selector:<span class="keyword">@selector</span>(doSomething:)</span><br><span class="line">                          userInfo:<span class="literal">nil</span></span><br><span class="line">                          repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<p>也可以通过 <code>NSInvocation</code> 来进行调用，实际上是把 target, action 和参数这三个东西包装成一个对象，然后进行调用，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMethodSignature</span> *sig = [MyClass instanceMethodSignatureForSelector: </span><br><span class="line">                           <span class="keyword">@selector</span>(doSomething:)];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:sig];</span><br><span class="line">[invocation setTarget:someObject];</span><br><span class="line">[invocation setSelector:<span class="keyword">@selector</span>(doSomething:)];</span><br><span class="line">[invocation setArgument:&amp;anArgument atIndex:<span class="number">2</span>];</span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span></span><br><span class="line">                          invocation:invocation</span><br><span class="line">                          repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<p>注意设置参数位置的时候要从 2 开始，参数 0 是 self, 参数 1 是 selector。</p>
<h3 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h3><p>通知的机制其实也依赖于 selector，相当于指定一个回调函数在接收到通知的时候执行对应的操作，这部分后面会专门介绍，这里就不过分展开了。</p>
<h3 id="u5728_u7EBF_u7A0B_u4E2D_u6267_u884C_u65B9_u6CD5"><a href="#u5728_u7EBF_u7A0B_u4E2D_u6267_u884C_u65B9_u6CD5" class="headerlink" title="在线程中执行方法"></a>在线程中执行方法</h3><p><code>NSObject</code> 实际上还有很多多线程执行的方法，如：</p>
<p><img src="/images/14560963965355.jpg" alt=""></p>
<p>一般来说，如果一个操作需要的时间比较多，应该放到不同线程去执行</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(doSomething) withObject:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>注意在线程中需要建立 auto-release pool，执行完毕之后通过 <code>performSelectorOnMainThread:withObjectwaitUntilDone:</code> 通知主线程，如</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSomething</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">        <span class="comment">// 在这里执行需要时间比较久的工作</span></span><br><span class="line">        [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(doAnotherThing)</span><br><span class="line">                                          withObject:<span class="literal">nil</span></span><br><span class="line">                                          waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u6570_u7EC4_u6392_u5E8F"><a href="#u6570_u7EC4_u6392_u5E8F" class="headerlink" title="数组排序"></a>数组排序</h3><p>我们实际上也可以把一个 comparator 传给排序函数，<code>NSString</code>, <code>NSDate</code>, <code>NSNumber</code>, <code>NSIndexPath</code> 都有 <code>compare:</code> 方法，可以用来进行排序，比较有用的方法是 <code>localizedCompare:</code>，会自动根据当前语言来排序。</p>
<p>这里简单列出两个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *sortedArray = [anArray sortedArrayUsingSelector:<span class="keyword">@selector</span>(localizedCompare:)];</span><br></pre></td></tr></table></figure>
<p>也可以利用 selector 让数组中的每个元素都做一次指定的操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[anArray makeObjectsPerformSelector:<span class="keyword">@selector</span>(doSomething)];</span><br></pre></td></tr></table></figure>
<h3 id="u4EE3_u66FF_if_else_/_switch"><a href="#u4EE3_u66FF_if_else_/_switch" class="headerlink" title="代替 if else / switch"></a>代替 if else / switch</h3><p>因为 selector 其实就是 C string，所以可以放在数组或者字典中备用，因为如此可以用来做条件选择来代替 if else 或者 switch，比如下面这个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(condition) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        [object doSomething];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        [object doAnotherThing];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以改写为</span></span><br><span class="line">[object performSelector:<span class="built_in">NSSelectorFromString</span>(@[<span class="string">@"doSomething"</span>, <span class="string">@"doAnotherThing"</span>][condition])];</span><br></pre></td></tr></table></figure>
<h3 id="u8C03_u7528_u79C1_u6709_API_08"><a href="#u8C03_u7528_u79C1_u6709_API_08" class="headerlink" title="调用私有 API"></a>调用私有 API</h3><p>这里的私有 API，值得就是官方文档里没有说明，但是实际上可以通过 <code>performSelector:</code> 来调用的内部方法，不过如果打算上架的话，是不能使用的，可以平时用来测试或了解系统本身的运作机制。</p>
<h2 id="u6CE8_u610F_u4E8B_u9879"><a href="#u6CE8_u610F_u4E8B_u9879" class="headerlink" title="注意事项"></a>注意事项</h2><p>使用 selector 时也有一些需要注意的地方，比方说我们使用 <code>super</code> 来调用父类的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">super</span> doSomething];</span><br></pre></td></tr></table></figure>
<p>会执行父类的 doSomething 方法，而如果是用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">super</span> performSelector:<span class="keyword">@selector</span>(doSomething)];</span><br></pre></td></tr></table></figure>
<p>实际的效果等同于 <code>[self doSomething]</code></p>
<h2 id="u4F18_u52BF_u4E0E_u9650_u5236"><a href="#u4F18_u52BF_u4E0E_u9650_u5236" class="headerlink" title="优势与限制"></a>优势与限制</h2><p>Selector 的机制本身有其便捷性，但是反过来，也造成了一定的限制。</p>
<p>在 Objective-C 中，一个对象的方法都会保存在 virtual table 中，而因为这个表是在 runtime 决定的，所以其实是非常动态的，比如说不用继承就可以增加方法，或者是直接交换不同的 selector 的指向（也就是 method swizzling）。</p>
<p>但是因为一个 selector 能且仅能对应一个方法，所以不会有 C++, Java, C# 中的重载功能，这也是为什么 Objective-C 的函数名称普遍比较长，毕竟不能根据参数列表来具体判断要执行的函数，只能在起名字上下功夫了。如果有同一个名称的方法，那么新的会覆盖旧的。</p>
<p>在 Objective-C 中，我们调用某个方法，实际上是在 virtual table 中找寻对应这个 selector 的方法，而 C++ 或 Java 则是直接指定执行 vitual table 中的某个方法。问题就来了，每次函数调用都要查表，那效率肯定不会很高，这也是为什么之前 Objective-C 一直不流行的原因。</p>
<p>不过这样做也有好处，实际上 Objective-C 没有所谓固定版本的 runtime，只要 selector 不变，通过查表一样可以找到，新系统不用保留旧系统的库，避免了 C++ 等语言中 <a href="https://zh.wikipedia.org/zh/DLL地獄" target="_blank" rel="external">dll 地狱</a>的问题</p>
<p>而最新的 Swift 中，实际上苹果放弃了这个做法，选择了和 C++, Java 类似的设计，这也是为什么 Swift 的性能反而会更好一些的原因，不过这样一样，就需要包含对应版本的 swift runtime 了，这也是为什么 swift 会出现更多因为版本不一致而导致的兼容问题的原因。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.gitbook.com/book/zonble/kkbox-ios-dev/details" target="_blank" rel="external">KKBOX iOS/Mac OS X 基本开发教材</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html" target="_blank" rel="external">Programming with Objective-C</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">Objective-C Runtime Programming Guide</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/DevPedia-CocoaCore/Selector.html" target="_blank" rel="external">Cocoa Core Competencies - Selector</a></li>
<li><a href="http://cocoasamurai.blogspot.tw/2010/01/understanding-objective-c-runtime.html" target="_blank" rel="external">Understanding the Objective-C Runtime</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Selector 作为 Objective-C 中一个非常重要的概念，虽然在 Swift 中几乎已经不见踪影，但是在某些混编的项目中仍旧起到举足轻重的作用，所以仍然有必要深入理解一下。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://wdxtub.com/tags/Mac/"/>
    
      <category term="Objective-C" scheme="http://wdxtub.com/tags/Objective-C/"/>
    
      <category term="iOS" scheme="http://wdxtub.com/tags/iOS/"/>
    
      <category term="selector" scheme="http://wdxtub.com/tags/selector/"/>
    
      <category term="理解" scheme="http://wdxtub.com/tags/%E7%90%86%E8%A7%A3/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PS4 游戏简评]]></title>
    <link href="http://wdxtub.com/2016/02/20/ps4-game-short-review/"/>
    <id>http://wdxtub.com/2016/02/20/ps4-game-short-review/</id>
    <published>2016-02-20T21:23:49.000Z</published>
    <updated>2016-02-20T23:37:29.000Z</updated>
    <content type="html"><![CDATA[<p>这个系列主要是记录一下自己玩过的众多 PS4 游戏，因为时间和篇幅所限，每个游戏可能只会用几句话简单评测，当然，某些我觉得值得单独拉出来评测的，还是会专门进行介绍的。</p>
<a id="more"></a>
<hr>
<h2 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h2><ul>
<li>入选标准纯主观</li>
<li>按自然顺序排列（就是瞎排，没有类别和时间顺序）</li>
<li>评测标准纯主观，具体评测角度看心情</li>
<li>一分钱广告费没有拿，没有利益相关</li>
<li>部分内容可能因为记忆偏差或者游戏更新而不一致，不要在意这些细节</li>
<li>先写列表，然后慢慢补充</li>
<li>想到了再多加几条显得既随性又专业</li>
</ul>
<h2 id="Amplitude"><a href="#Amplitude" class="headerlink" title="Amplitude"></a>Amplitude</h2><p>音乐游戏，除了按键之外，还需要利用方向键切换不同的音轨，总体来说非常不错。</p>
<ul>
<li>大小：2.5 GB</li>
<li>开发商：Harmonix Music Systems, Inc</li>
<li>价格：$19.99</li>
<li>发售日：2016.1.5</li>
</ul>
<p><img src="/images/14560053059106.jpg" alt=""></p>
<p>不过键位设计很奇怪，一共三个按键，分别是 L1, R1, R2，因为 R1 和 R2 的键程不一样，所以按起来怪怪的，还是有点不习惯。切换音轨需要大量的提前量预判，而且很容易在最后一个 miss，一 miss 整个 section 的分数都没有，无他，唯手熟耳。</p>
<p>画面比较科幻，看久了眼睛疼，而且音乐偏电子音乐，我不算特别喜欢。不过作为难得的音乐节拍游戏，还是值得一玩的，多人合作的话应该挺刺激。</p>
<h2 id="ARSLAN_3A_The_WARRIORS_OF_LEGEND"><a href="#ARSLAN_3A_The_WARRIORS_OF_LEGEND" class="headerlink" title="ARSLAN: The WARRIORS OF LEGEND"></a>ARSLAN: The WARRIORS OF LEGEND</h2><p>光荣开始换着花样出割草游戏了，不过这次的动画画风还是不错的。</p>
<ul>
<li>大小：15.5 GB</li>
<li>开发商：Tecmo KOEI America</li>
<li>价格：$59.99</li>
<li>发售日：2016.2.9</li>
</ul>
<p><img src="/images/14560059636741.jpg" alt=""></p>
<p>整体玩起来也没啥特别大的区别，连招还有效果都比较趋同。换句话说，我还不如玩真三呢，至少还有点代入感。这么换个模型就出来骗 60 刀，光荣也是很黑啊。不是很推荐购入，当然铁粉另说。</p>
<h2 id="Blacklight_3A_Retribution"><a href="#Blacklight_3A_Retribution" class="headerlink" title="Blacklight: Retribution"></a>Blacklight: Retribution</h2><p>标准的美式在线多人射击对战游戏，重点在于免费，不过也使得玩家的技术差距比较大，新手很容易直接被打哭（教程也不是特别友好）</p>
<ul>
<li>大小：4.6 GB</li>
<li>开发商：Hardsuit Labs</li>
<li>价格：FREE</li>
<li>发售日：2013.11.15</li>
</ul>
<p><img src="/images/14560071072422.jpg" alt=""></p>
<p>13 年的老游戏了，比较简单粗暴的对战射击，估计是预计玩家都有基本的经验了，所以学习曲线非常陡峭，而且因为是免费游戏，没啥门槛，所以很容易出现挂机的，非常影响体验。不过我一直对射击对战类游戏非常苦手，还是比较喜欢合作或者剧情向的。</p>
<h2 id="RAINBOW_MOON"><a href="#RAINBOW_MOON" class="headerlink" title="RAINBOW MOON"></a>RAINBOW MOON</h2><p>丑到哭的回合制 RPG，我玩了五分钟就表示阵亡坚持不下去，真的是太复古了。</p>
<ul>
<li>大小：1.6 GB</li>
<li>开发商：EastAsiaSoft</li>
<li>价格：$14.99</li>
<li>发售日：2016.2.16</li>
</ul>
<p><img src="/images/14560076052824.jpg" alt=""></p>
<p>战棋走格子 + 回合制 RPG，人设丑出新高度，字体和界面的整体感觉也很奇怪，让人不大舒服。总而言之，不推荐。</p>
<h2 id="Gems_of_War"><a href="#Gems_of_War" class="headerlink" title="Gems of War"></a>Gems of War</h2><p>三消 + 卡牌 + 回合 = Gems of War，个人感觉有点不伦不类。</p>
<ul>
<li>大小：1.6 GB</li>
<li>开发商：505 Games</li>
<li>价格：FREE</li>
<li>发售日：2015.11.13</li>
</ul>
<p><img src="/images/14560078541208.jpg" alt=""></p>
<p>不同颜色代表不同的能力，然后通过消除三个或以上对应元素来进行攻击或者属性增强。就我的感觉来说，要么直接神魔之塔不要太多策略，要么直接炉石传说好好收集卡牌，结合起来不是不可以，但是回合制就有点怪怪了。一次消除四个元素有额外的一轮操作并且还有附加效果，不过因为是回合制，基本上如果对手会玩，是很难有机会四个的。</p>
<p>另外，手柄玩这类点击类游戏，其实不是特别顺手。不过总体来说算是不错的休闲游戏</p>
<h2 id="GUNS_UP_21"><a href="#GUNS_UP_21" class="headerlink" title="GUNS UP!"></a>GUNS UP!</h2><p>索尼自己出的休闲即使策略小游戏，画风可爱，操作也很简单明了，不算给第一方丢脸。</p>
<ul>
<li>大小：867 MB</li>
<li>开发商：Sony Computer Entertainment America</li>
<li>价格：FREE</li>
<li>发售日：2015.12.5</li>
</ul>
<p><img src="/images/14560083740117.jpg" alt=""></p>
<p>简单来说就是控制进攻方或者防守方，用简单的操作完成指定任务，游戏模式还是很丰富的，整体的艺术风格也很和谐，虽然是战场，但是更多的是欢乐。基本上玩家要做的就是选择生产什么兵种，以及确定轰炸地点之类的技能，算是塔防类型的变体。</p>
<p>反正免费，干嘛不玩一玩呢？另外难得容量没超过 1G 但是画面也不错，我就好奇其他的『小游戏』到底放了啥在游戏里面。</p>
<h2 id="Tearaway_Unfolded"><a href="#Tearaway_Unfolded" class="headerlink" title="Tearaway Unfolded"></a>Tearaway Unfolded</h2><p>索尼大法继小小大星球用布娃娃之后，这次直接用纸片弄出了一个新世界，而且还是全 3D 的！百分百值得入手！</p>
<ul>
<li>大小：6.8 MB</li>
<li>开发商：Sony Computer Entertainment America</li>
<li>价格：$19.99</li>
<li>发售日：2015.9.8</li>
</ul>
<p><img src="/images/14560111893739.jpg" alt=""></p>
<p>无论是对手柄各种功能的应用（触摸板，声音，动作），还是整个游戏自由开放且独树一帜的艺术风格，都远远甩开 XBOX ONE 第一方游戏几条街，更可怕的是，这还只是一个不到 20 刀的『小品』游戏。</p>
<p>从小小大星球开始索尼就有点接过任天堂衣钵的感觉，本作一出，任你马里奥再强，耐不住索尼大法一波又一波艺术+创意的攻势。</p>
<p>会专门为本作写一篇测评，不然没办法表达『索尼大法好』这一题中之义。</p>
<h2 id="Bloodborne"><a href="#Bloodborne" class="headerlink" title="Bloodborne"></a>Bloodborne</h2><h2 id="DEAD_OR_ALIVE_5_Last_Round"><a href="#DEAD_OR_ALIVE_5_Last_Round" class="headerlink" title="DEAD OR ALIVE 5 Last Round"></a>DEAD OR ALIVE 5 Last Round</h2><h2 id="Destiny"><a href="#Destiny" class="headerlink" title="Destiny"></a>Destiny</h2><h2 id="Dying_Light"><a href="#Dying_Light" class="headerlink" title="Dying Light"></a>Dying Light</h2><h2 id="Fallout_4"><a href="#Fallout_4" class="headerlink" title="Fallout 4"></a>Fallout 4</h2><h2 id="FIFA_16"><a href="#FIFA_16" class="headerlink" title="FIFA 16"></a>FIFA 16</h2><h2 id="Flower"><a href="#Flower" class="headerlink" title="Flower"></a>Flower</h2><h2 id="Indivisible_Prototype"><a href="#Indivisible_Prototype" class="headerlink" title="Indivisible Prototype"></a>Indivisible Prototype</h2><h2 id="Journey"><a href="#Journey" class="headerlink" title="Journey"></a>Journey</h2><h2 id="LEGO_MARVEL_u2019s_Avengers"><a href="#LEGO_MARVEL_u2019s_Avengers" class="headerlink" title="LEGO MARVEL’s Avengers"></a>LEGO MARVEL’s Avengers</h2><h2 id="Life_Is_Strange"><a href="#Life_Is_Strange" class="headerlink" title="Life Is Strange"></a>Life Is Strange</h2><h2 id="Little_Big_Planet_3"><a href="#Little_Big_Planet_3" class="headerlink" title="Little Big Planet 3"></a>Little Big Planet 3</h2><h2 id="Loadout"><a href="#Loadout" class="headerlink" title="Loadout"></a>Loadout</h2><h2 id="METAL_GEAR_SOLID_V_3A_THE_PHANTOM_PAIN"><a href="#METAL_GEAR_SOLID_V_3A_THE_PHANTOM_PAIN" class="headerlink" title="METAL GEAR SOLID V: THE PHANTOM PAIN"></a>METAL GEAR SOLID V: THE PHANTOM PAIN</h2><h2 id="NARUTO_SHIPPUDEN_3A_Ultimate_Ninja_STORM_4"><a href="#NARUTO_SHIPPUDEN_3A_Ultimate_Ninja_STORM_4" class="headerlink" title="NARUTO SHIPPUDEN: Ultimate Ninja STORM 4"></a>NARUTO SHIPPUDEN: Ultimate Ninja STORM 4</h2><h2 id="NBA_LIVE_16"><a href="#NBA_LIVE_16" class="headerlink" title="NBA LIVE 16"></a>NBA LIVE 16</h2><h2 id="RESIDENT_EVIL_REVELATIONS_2"><a href="#RESIDENT_EVIL_REVELATIONS_2" class="headerlink" title="RESIDENT EVIL REVELATIONS 2"></a>RESIDENT EVIL REVELATIONS 2</h2><h2 id="The_Crew"><a href="#The_Crew" class="headerlink" title="The Crew"></a>The Crew</h2><h2 id="Toukiden_3A_Kiwami"><a href="#Toukiden_3A_Kiwami" class="headerlink" title="Toukiden: Kiwami"></a>Toukiden: Kiwami</h2><h2 id="Uncharted_3A_The_Nathan_Drake_Collection"><a href="#Uncharted_3A_The_Nathan_Drake_Collection" class="headerlink" title="Uncharted: The Nathan Drake Collection"></a>Uncharted: The Nathan Drake Collection</h2><h2 id="Warframe"><a href="#Warframe" class="headerlink" title="Warframe"></a>Warframe</h2><h2 id="Farcry_4"><a href="#Farcry_4" class="headerlink" title="Farcry 4"></a>Farcry 4</h2><h2 id="The_Last_of_US"><a href="#The_Last_of_US" class="headerlink" title="The Last of US"></a>The Last of US</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>这个系列主要是记录一下自己玩过的众多 PS4 游戏，因为时间和篇幅所限，每个游戏可能只会用几句话简单评测，当然，某些我觉得值得单独拉出来评测的，还是会专门进行介绍的。</p>]]>
    
    </summary>
    
      <category term="PS4" scheme="http://wdxtub.com/tags/PS4/"/>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="评测" scheme="http://wdxtub.com/tags/%E8%AF%84%E6%B5%8B/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第六周 - 曾经的你]]></title>
    <link href="http://wdxtub.com/2016/02/19/used-to-be/"/>
    <id>http://wdxtub.com/2016/02/19/used-to-be/</id>
    <published>2016-02-20T03:13:43.000Z</published>
    <updated>2016-02-20T04:08:29.000Z</updated>
    <content type="html"><![CDATA[<p>曾梦想仗剑走天涯，看一看世界的繁华。走在勇往直前的路上，有难过也有精彩。</p>
<a id="more"></a>
<hr>
<p>阿来写过一本书，叫《尘埃落定》，说的是一个傻子少爷，用其特有的观察世界的角度，穿透愚蠢与欲望，一针见血刺出事物的本质，也见证了土司制度的衰亡。这一周，我也算是『随性』而『傻』地做出了『尘埃落定』的决定：买好回国机票，切断所有后路，大踏步继续往前。</p>
<p>一直觉得，年轻人不要用所谓『大家觉得好』的路，去麻痹和替代自己对未来的思考。喜欢什么，讨厌什么，擅长什么，拙于什么，都应该在不同的体验中增进对自己的了解。对我来说，没有家庭的负担，甚至也没有太多儿女情长的羁绊，所以更希望去做自己真正想要去做的事情。</p>
<p>回顾自己一路走来的旅程，更多的决定是随性的，或者说是冥冥之中已经决定的，从论文的题目，到学业的选择，从租房的变动，到工作的确定，都是和自己的兴趣爱好有关。一直以来都是那种一旦有个念头就打不起精神做其他事情的人，恐怕全情投入背水一战才是最好的选择。</p>
<p>前段时间有些迷茫，毕竟身处大环境中，很容易被身边人的焦虑所『感染』，开始去追逐『大家觉得好』的事情，用『大家觉得对』的评判标准来衡量自己。后来想清楚了才意识到，既然一直以来我选择的就是不同的路，不同的标准，那么唯一的标尺，就是这件事情我喜不喜欢，我愿不愿意去做，而不是那些『别人觉得好大家都应该去做』的事情。</p>
<p>即使有这么一条路，宽敞平坦，直达所谓『终点』，我也并不愿意走。目的地不明确，又可能是坎坷的路，我反而愿意去试试，毕竟，每一步都是经过自己的判断迈出的，走出去才无怨无悔。而且话说回来，到底那条路更艰难，不去试试怎么知道呢？同样是做火影忍者游戏，玩家很短时间就能意识到谁是用心开发谁是为了赚钱，生活学习工作也是这个道理：不要隐藏自己，努力去做自己真正想做的事情。</p>
<p>随着对课程的适应，基本上进入了比较轻松的阶段，开学前计划的各类事项也在逐步启动。重启翻译计划后，因为对计算机体系的深入理解，很多概念的理解也更加深入了。另外一个好消息是，随着时间的推移，自己的技术博客也逐渐有了一些有价值的互动了，这是我一直想要看到的。既然知道了很多东西中文世界里没人写过，那么我愿意吃点苦流点汗，去做这第一个人（这周的几篇日志应该都是其他地方没有的）。</p>
<p>身处变革的时代，在中国这样一个『启蒙时代』一切未定型的国家，经济政治社会环境道德文化都有太多太多需要改进的地方，有太多太多让年轻人大展宏图的机会，为什么不趁着年轻去闯一闯呢？假如生活终将归于平静，为什么不在万籁俱寂前发出自己的声音呢？</p>
<blockquote>
<p>正义之子面对有悖于常理的世界，会使其天翻地覆</p>
</blockquote>
<p>让我们干了这杯酒，好男儿胸怀像大海。总想起身边走在路上的朋友，有多少正在醒来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>曾梦想仗剑走天涯，看一看世界的繁华。走在勇往直前的路上，有难过也有精彩。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="坚持" scheme="http://wdxtub.com/tags/%E5%9D%9A%E6%8C%81/"/>
    
      <category term="转弯" scheme="http://wdxtub.com/tags/%E8%BD%AC%E5%BC%AF/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ITA Testing 相关资料]]></title>
    <link href="http://wdxtub.com/2016/02/19/ita-test/"/>
    <id>http://wdxtub.com/2016/02/19/ita-test/</id>
    <published>2016-02-19T15:06:41.000Z</published>
    <updated>2016-02-19T15:58:35.000Z</updated>
    <content type="html"><![CDATA[<p>这门语言考试是在 CMU 做助教必须要通过的，虽然『据说』比较轻松，但是还是认真准备一下，算是通过研究考试的方式加深对于语言本身的认识。</p>
<a id="more"></a>
<hr>
<p>简单来说，就是所有母语不是英语的助教，都需要通过这么一个测试。主要考察口语交流能力，整个过程有 4 到 5 个评审，测试包含两部分：</p>
<ol>
<li>交流部分，需要讨论自己的学术背景和兴趣</li>
<li>具体选择一个话题来进行正式的解释（大约五分钟），评审会根据内容来问一些问题。</li>
</ol>
<p>主要考察发音、语法、流畅度以及如何去定义一个学术概念，并且解释清楚术语和定义，以及举出相关例子来进行阐述和说明。注意这里的要求不会特别高，所以不用担心，也不会评价专业领域的知识和教学技巧。</p>
<p>会有四个评价等级：</p>
<p>Pass, Restricted I, Restricted II, Not Qualified</p>
<p>这里只贴出前两个等级（毕竟后面两个比较惨）</p>
<p><img src="/images/14558964554346.jpg" alt=""></p>
<p>还有一些具体的技巧，我觉得不仅可以用在 ITA 测试上，对于日常的交流也很有帮助。列举如下：</p>
<ul>
<li>了解你的听众，他们对各个领域有基本的相关知识，但是可能对特定领域没有很深的认识，所以一定要考虑到听众的接收程度</li>
<li>解释清楚那些可能对于普通人来说难以理解的技术名词，不要依赖公式和『科学黑话』</li>
<li>做助教很多时候需要面对没有准备的问题，就是需要测试在这种情况下我们的表现</li>
<li>如果评审给出的主题不合适，需要说清楚为什么不合适，并且找到一个合适的话题，总体来说就是一个交流的过程</li>
<li>因为只有五分钟的时间，所以可能评审会打断你的解释，所以把每一句话当做最后一句话，尽力解释清楚</li>
<li>语速不要太快，注意说话的节奏</li>
<li>和听众多多交流，确保他们听懂</li>
<li>可能的话使用黑板，视觉也是学习很重要的输入</li>
<li>注意使用过渡语言来让听众明白整个介绍的逻辑组织形式</li>
<li>不要紧张，不要紧张，不要紧张</li>
</ul>
<p>基本上是一个考察『硬实力』的测试，正常发挥应该就没有多少问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这门语言考试是在 CMU 做助教必须要通过的，虽然『据说』比较轻松，但是还是认真准备一下，算是通过研究考试的方式加深对于语言本身的认识。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="助教" scheme="http://wdxtub.com/tags/%E5%8A%A9%E6%95%99/"/>
    
      <category term="测试" scheme="http://wdxtub.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac 技巧指南]]></title>
    <link href="http://wdxtub.com/2016/02/18/mac-tips/"/>
    <id>http://wdxtub.com/2016/02/18/mac-tips/</id>
    <published>2016-02-19T03:05:09.000Z</published>
    <updated>2016-02-19T03:33:37.000Z</updated>
    <content type="html"><![CDATA[<p>这里主要整理一些一直以来使用 Mac 的技巧以及构建高效开发学习环境的指南。主要是按照个人的使用习惯，所以所用的工具和软件都比较偏写代码一些。</p>
<a id="more"></a>
<hr>
<h2 id="u6280_u5DE7_u7BC7"><a href="#u6280_u5DE7_u7BC7" class="headerlink" title="技巧篇"></a>技巧篇</h2><p>遇到一些疑难杂症，可以试试看。</p>
<h3 id="u5207_u6362_shell"><a href="#u5207_u6362_shell" class="headerlink" title="切换 shell"></a>切换 shell</h3><p>nano 编辑器中</p>
<ul>
<li>ctrl 表示 ^</li>
<li>F3保存，F2退出</li>
</ul>
<p>具体步骤</p>
<ol>
<li><code>sudo nano /etc/shells</code></li>
<li>把 <code>/usr/local/bin/fish</code> 添加进去（这里以添加 fish shell 为例子）</li>
<li><code>chsh -s /usr/local/bin/fish</code> （平时切换只需要用这句即可）</li>
</ol>
<h3 id="u6279_u91CF_u5220_u9664_u6307_u5B9A_u7C7B_u578B_u7684_u6587_u4EF6"><a href="#u6279_u91CF_u5220_u9664_u6307_u5B9A_u7C7B_u578B_u7684_u6587_u4EF6" class="headerlink" title="批量删除指定类型的文件"></a>批量删除指定类型的文件</h3><p>可以使用这条命令</p>
<p><code>find . -name &quot;.Ulysses-Group.plist&quot; -exec rm -Rf {} \;</code></p>
<h3 id="u6E05_u9664_u4E0D_u5FC5_u8981_u7684_u670D_u52A1"><a href="#u6E05_u9664_u4E0D_u5FC5_u8981_u7684_u670D_u52A1" class="headerlink" title="清除不必要的服务"></a>清除不必要的服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">launchctl list 查看服务列表</span><br><span class="line">launchctl remove xxxx 删除xxxxx服务的自启动</span><br></pre></td></tr></table></figure>
<h3 id="u5173_u95ED_Rootless"><a href="#u5173_u95ED_Rootless" class="headerlink" title="关闭 Rootless"></a>关闭 Rootless</h3><p>Rootless 是 OSX 10.11 中为了增强安全性而增加的特性，不过对于开发者来说，不能访问根目录下的某些文件夹实在是很恼人的事情。下面是关闭的方法：</p>
<ul>
<li>开机按住 Command＋R，进入恢复模式，打开 terminal，键入：</li>
<li><code>csrutil disable</code></li>
<li>回车，重新启动即可。</li>
<li>要恢复 rootless ，只需将 disable 改为 enable</li>
</ul>
<h3 id="u91CD_u5EFA_Mail__u7D22_u5F15"><a href="#u91CD_u5EFA_Mail__u7D22_u5F15" class="headerlink" title="重建 Mail 索引"></a>重建 Mail 索引</h3><p>当邮箱出现问题时，您可能会看到提醒信息说“邮件”需要通过重新索引邮件来修复邮箱。在其他时候，您可能想要自己重新索引邮件，例如，使用“主题”、“收件人”或“发件人”搜索邮箱时未返回正确结果时。</p>
<ul>
<li>如果“邮件”已打开，请退出它。</li>
<li>在“User/资源库/Mail/V3/MailData”中，删除任何以“Envelope Index”开头的文件，如 Envelope Index 或 Envelope Index-shm。</li>
<li>默认情况下，您的“资源库”个人文件夹处于隐藏状态。若要显示它，请选取 Finder &gt;“前往文件夹”，然后输入“~/资源库”。</li>
<li>打开“邮件”。</li>
<li>“邮件”将创建新 Envelope Index 文件。此过程可能需要几分钟，取决于“邮件”要重新索引的邮件数量。</li>
</ul>
<h3 id="u6E05_u9664_PRAM"><a href="#u6E05_u9664_PRAM" class="headerlink" title="清除 PRAM"></a>清除 PRAM</h3><p>(只适用于英特尔的苹果电脑)</p>
<p>这个方法不是根本的解决方法，但是可以除去一些不必要的开机设置。因而也节省了时间。方法是：重启你的电脑，同时按下 command + option + p + r 直到听到 3 到 4 声启动铃响之后松手。</p>
<h3 id="u6E05_u9664PMU"><a href="#u6E05_u9664PMU" class="headerlink" title="清除PMU"></a>清除PMU</h3><p>(iMac不适用)</p>
<p>对于Macbook, Macbook Pro用户，方法是：</p>
<ol>
<li>确保Macbook关闭.</li>
<li>去掉电源适配器和电池.</li>
<li>按下电源开关并保持5 秒钟，放开.</li>
<li>接上电源适配器和电池.</li>
<li>打开电源开关.</li>
</ol>
<h3 id="u663E_u793A/_u9690_u85CF__u9690_u85CF_u6587_u4EF6"><a href="#u663E_u793A/_u9690_u85CF__u9690_u85CF_u6587_u4EF6" class="headerlink" title="显示/隐藏 隐藏文件"></a>显示/隐藏 隐藏文件</h3><p>使用下面的命令即可分别测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool <span class="literal">true</span></span><br><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="u8FD8_u539F_F1-F12"><a href="#u8FD8_u539F_F1-F12" class="headerlink" title="还原 F1-F12"></a>还原 F1-F12</h3><p>默认情况下，F1-F12 都是特殊功能，比如调节屏幕亮度。而当你需要键入 F1-F12 时（比如在使用 IntelliJ IDEA 的快捷键时），需要同时按住 Fn。这对于开发人员来说是非常不方便的。</p>
<p>把 F1-F12 改成标准功能键：选择 <code>System Preferences</code> &gt; <code>Keyboard</code>，在<code>Keyboard</code>标签页中选中<code>Use all F1, F2, etc. keys as standard function keys</code>。</p>
<h3 id="u5229_u7528_u8BED_u97F3_u529F_u80FD"><a href="#u5229_u7528_u8BED_u97F3_u529F_u80FD" class="headerlink" title="利用语音功能"></a>利用语音功能</h3><p>OS X 自带了语音功能，可以用<code>say</code>命令让 Mac 开口说话：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">say hello</span><br></pre></td></tr></table></figure>
<p>可以和<code>&amp;&amp;</code>或者<code>;</code>配合使用来提示你某任务已经完成：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew update &amp;&amp; brew upgrade &amp;&amp; brew cleanup ; say mission complete</span><br></pre></td></tr></table></figure>
<p>通过命令行来听取发音还是有点麻烦。其实我们几乎可以在任何地方选中单词，然后使用快捷键 <code>⌥+ESC</code> 发音。仅仅需要这样设置一下：选择 <code>System Preferences</code> &gt; <code>Dictation &amp; Speech</code>，在<code>Text to Speech</code>标签页中选中<code>Speak selected text when the key is pressed</code>。</p>
<h3 id="u5728_Finder__u7A97_u53E3_u663E_u793A_u66F4_u591A_u4FE1_u606F"><a href="#u5728_Finder__u7A97_u53E3_u663E_u793A_u66F4_u591A_u4FE1_u606F" class="headerlink" title="在 Finder 窗口显示更多信息"></a>在 Finder 窗口显示更多信息</h3><p>打开任意 Finder 窗口。前往并打开「显示」－「显示路径栏」、「显示」－「显示状态栏」和「显示」－「显示预览」三项。</p>
<p>路径栏通常是从磁盘分区开始的，没改过名字的就叫做「Macintosh HD」，接下来是「用户」，可是路径信息的这两个项目几乎没什么作用，我们需要看的一般都是从个人账户开始后面的路径。下面我们就来尝试删除这两个路径选项：</p>
<p>打开终端，输入以下命令：</p>
<pre><code>defaults write com.apple.finder PathBarRootAtHome -bool TRUE;killall Finder
</code></pre><p>回车后 Finder 会重启一下，改变即可见。</p>
<p>恢复默认：打开终端，输入如下代码并回车就可以恢复原样：</p>
<pre><code>defaults delete com.apple.finder PathBarRootAtHome;killall Finder
</code></pre><h3 id="u8BA9_u6587_u4EF6_u6269_u5C55_u540D_u59CB_u7EC8_u663E_u793A"><a href="#u8BA9_u6587_u4EF6_u6269_u5C55_u540D_u59CB_u7EC8_u663E_u793A" class="headerlink" title="让文件扩展名始终显示"></a>让文件扩展名始终显示</h3><p>当你看到一个文件但是不知道它的格式的时候，会不会困惑？每次都要去简介页面查看文件是 .jpg 还是 .png 是不是很繁琐？哦，还有 CMD－i 快捷键？但是这些都比默认就显示来得慢。</p>
<p>打开 Finder 偏好设置，选中「高级」标签，然后在「始终显示文件扩展名」前面打勾即可。</p>
<h3 id="u4F7F_Finder__u9ED8_u8BA4_u663E_u793A_u81EA_u5B9A_u4E49_u76EE_u5F55"><a href="#u4F7F_Finder__u9ED8_u8BA4_u663E_u793A_u81EA_u5B9A_u4E49_u76EE_u5F55" class="headerlink" title="使 Finder 默认显示自定义目录"></a>使 Finder 默认显示自定义目录</h3><p>「我的所有文件」是一个非常实用的功能。但是这对于那些需要按照目录来显示文件的用户来说，每次都需要进行一次额外的操作才能打开用户目录或者其他文件夹。让我们取消默认显示「我的所有文件」功能：</p>
<p>打开 Finder 偏好设置，选中「通用」标签，然后在「开启新 Finder 窗口时打开」项下选择你喜欢的目录即可。</p>
<h3 id="u5728_u4FA7_u8FB9_u680F_u663E_u793A_u7528_u6237_u76EE_u5F55"><a href="#u5728_u4FA7_u8FB9_u680F_u663E_u793A_u7528_u6237_u76EE_u5F55" class="headerlink" title="在侧边栏显示用户目录"></a>在侧边栏显示用户目录</h3><p>在 Mac 系统中，绝大多数用户文件，例如音乐、照片等都存储在用户目录下，所以在 Finder 侧边栏一直显示用户目录的内容是一个好主意。设置起来同样很简单：</p>
<p>打开 Finder 偏好设置，选中「边栏」标签，然后记得勾选你的用户名。</p>
<h3 id="u5728_Finder__u6807_u9898_u680F_u663E_u793A_u5B8C_u6574_u8DEF_u5F84"><a href="#u5728_Finder__u6807_u9898_u680F_u663E_u793A_u5B8C_u6574_u8DEF_u5F84" class="headerlink" title="在 Finder 标题栏显示完整路径"></a>在 Finder 标题栏显示完整路径</h3><p>众所周知 Finder 是不显示路径的，你进入某个文件夹只会显示当前文件夹的名字而已。虽然你可以通过上文中的方法将路径栏调出来，但是这样也增加了 Finder 窗口的高度，对小屏幕机器尤为不利。那么，让我们更进一步，将 Finder 的完整路径显示在标题栏如何？</p>
<p>打开终端，输入以下命令并回车：</p>
<pre><code>defaults write com.apple.finder _FXShowPosixPathInTitle -bool YES
</code></pre><p>然后把 Finder 窗口关了再打开，你会发现路径栏变样子了：</p>
<p>其实呢，对着路径最左边的小图标点右键，就能快速访问路径中的任意一层：</p>
<p>恢复</p>
<pre><code>defaults write com.apple.finder _FXShowPosixPathInTitle -bool NO
</code></pre><h3 id="u59CB_u7EC8_u663E_u793A_u7528_u6237_u300C_u8D44_u6599_u5E93_u300D"><a href="#u59CB_u7EC8_u663E_u793A_u7528_u6237_u300C_u8D44_u6599_u5E93_u300D" class="headerlink" title="始终显示用户「资料库」"></a>始终显示用户「资料库」</h3><p>用户资料库是用来储存配置文件、缓存和用户数据的目录（路径：~/Library/），由于 OS X 设置了系统文件保护，资料库在 Finder 中被设置为默认不显示。然而，通过终端执行一个简单的命令，就可以让它始终显示了。</p>
<p>打开终端，运行以下命令：</p>
<pre><code>chflags nohidden ~/Library/
</code></pre><p>回车即可。</p>
<h3 id="u663E_u793A_u6587_u4EF6_uFF08_u5939_uFF09_u7684_u4FE1_u606F"><a href="#u663E_u793A_u6587_u4EF6_uFF08_u5939_uFF09_u7684_u4FE1_u606F" class="headerlink" title="显示文件（夹）的信息"></a>显示文件（夹）的信息</h3><p>Finder 可以告诉你一些关于文件和文件夹的非常实用的信息，比如选中的文件夹内有多少个文件、照片的分辨率（这个笔者最喜欢）等等。对于笔者这种重度截图党来说，这几乎是一个「必选」的设置。</p>
<p>在桌面点击鼠标右键，选择「查看显示选项」，选中「显示项目简介」项，现在看看，你的文件、文件夹有什么变化？</p>
<h2 id="u5E94_u7528_u8F6F_u4EF6"><a href="#u5E94_u7528_u8F6F_u4EF6" class="headerlink" title="应用软件"></a>应用软件</h2><p>付费软件：</p>
<ul>
<li>1Password：密码管理；</li>
<li>BetterZip2：解压缩；</li>
<li>Parallels Desktop：虚拟机</li>
<li>CleanMyMac 3：垃圾清理</li>
</ul>
<p>免费软件：</p>
<ul>
<li>Alferd：提高效率的神器</li>
<li>MPlayerX：视频播放器，播放各种格式视频</li>
<li>iTerm2：命令行终端</li>
<li>SiteSucker：网站备份工具</li>
<li>LICEcap：截取GIF动态图</li>
<li>ImageAlpha(Pngyu)：png图片压缩</li>
</ul>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>现在 OS X 都不会自带 JDK 了，所以进行 Java 开发的话，需要下载 JDK。在 brew-cask 之前，我们需要从 <a href="https://developer.apple.com/downloads/" target="_blank" rel="external">https://developer.apple.com/downloads/</a> 或者 Oracle 网站上下载。还有更麻烦的－－卸载 JDK 和升级 JDK。</p>
<p>JDK 安装文件是 pkg 格式，卸载和<code>.app</code>不一样，且没有自动卸载方式。</p>
<p>而 brew-cask 提供了自动安装和卸载功能，能够自动从官网上下载并安装 JDK 8。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install java</span><br></pre></td></tr></table></figure>
<p>如果你需要安装 JDK 7 或者 JDK 6，可以使用<code>homebrew-cask-versions</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap caskroom/versions</span><br><span class="line">brew cask install java6</span><br></pre></td></tr></table></figure>
<p>在 OS X 上，你可以同时安装多个版本的 JDK。你可以通过命令<code>/usr/libexec/java_home -V</code>来查看安装了哪几个 JDK。</p>
<p>那问题来了，当你运行<code>java</code>或者 Java 程序时使用的是哪个 JDK 呢？在 OS X 下，<code>java</code>也就是<code>/usr/bin/java</code>在默认情况下指向的是已经安装的最新版本。但是你可以设置环境变量<code>JAVA_HOME</code>来更改其指向：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version <span class="string">"1.8.0_60"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build <span class="number">1.8</span>.<span class="number">0</span>_60-b27)</span><br><span class="line">Java HotSpot(TM) <span class="number">64</span>-Bit Server VM (build <span class="number">25.60</span>-b23, mixed mode)</span><br><span class="line">$ JAVA_HOME=/Library/Java/JavaVirtualMachines/<span class="number">1.6</span>.<span class="number">0</span>.jdk/Contents/Home java -version</span><br><span class="line">java version <span class="string">"1.6.0_65"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build <span class="number">1.6</span>.<span class="number">0</span>_65-b14-<span class="number">466.1</span>-<span class="number">11</span>M4716)</span><br><span class="line">Java HotSpot(TM) <span class="number">64</span>-Bit Server VM (build <span class="number">20.65</span>-b04-<span class="number">466.1</span>, mixed mode)</span><br></pre></td></tr></table></figure>
<p>其中<code>JAVA_HOME=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home</code>可以用<code>JAVA_HOME=`/usr/libexec/java_home -v 1.6` </code>这种更加通用的方式代替。</p>
<h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h3><p>Mac OS X是基于Unix的操作系统，可以安装大部分为Unix/Linux开发的软件。然而，如果只是以使用为目的，对每个软件都进行手工编译不是很方便，也不利于管理已安装的软件，于是出现了类似于Linux中APT、Yum等类似的软件包管理系统，其中最著名的有MacPorts、Fink、Homebrew等。</p>
<p>Homebrew 尽可能地利用系统自带的各种库，使得软件包的编译时间大为缩短；同时由于几乎不会造成冗余，软件包的管理也清晰、灵活了许多。Homebrew的另一个特点是使用Ruby定义软件包安装配置（叫做formula），定制非常简单。</p>
<p>Homebrew的安装非常简单，在终端程序中输入以下命令即可。</p>
<pre><code>ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&quot;
</code></pre><p>由于Homebrew的安装地址可能变化，请到官方网站查看最新的安装方法。</p>
<p>Homebrew的可执行命令是brew，其基本使用方法如下（以wget为例）。</p>
<ul>
<li>查找软件包 <code>brew search wget</code></li>
<li>安装软件包 <code>brew install wget</code></li>
<li>列出已安装的软件包 <code>brew list</code></li>
<li>删除软件包 <code>brew remove wget</code></li>
<li>查看软件包信息 <code>brew info wget</code></li>
<li>列出软件包的依赖关系 <code>brew deps wget</code></li>
<li>更新 <code>brew update</code></li>
<li>列出过时的软件包（已安装但不是最新版本）<code>brew outdated</code></li>
<li>更新过时的软件包（全部或指定）<code>brew upgrade</code> 或 <code>brew upgrade wget</code></li>
</ul>
<h3 id="Homebrew_Cask"><a href="#Homebrew_Cask" class="headerlink" title="Homebrew Cask"></a><a href="http://caskroom.io" target="_blank" rel="external">Homebrew Cask</a></h3><p>brew-cask 允许你使用命令行安装 OS X 应用。比如你可以这样安装 Chrome：<code>brew cask install google-chrome</code>。还有 Evernote、Skype、Sublime Text、VirtualBox 等都可以用 brew-cask 安装。</p>
<p>brew-cask 是社区驱动的，如果你发现 brew-cask 上的应用不是最新版本，或者缺少你某个应用，你可以自己提交 pull request。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install caskroom/cask/brew-cask</span><br></pre></td></tr></table></figure>
<p>应用也可以通过 App Store 安装，而且有些应用只能通过 App Store 安装，比如 Xcode 等一些 Apple 的应用。App Store 没有对应的命令行工具，还需要 Apple ID。倒是更新起来很方便。</p>
<p>几乎所有常用的应用都可以通过 brew-cask 安装，所以你要安装新的应用时，建议用 brew-cask 安装。如果你不知道应用在 brew-cask 中的 ID，可以先用<code>brew cask search</code>命令搜索。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/macdao/ocds-guide-to-setting-up-mac" target="_blank" rel="external">如何配置一个高效的 Mac 工作环境</a></li>
<li><a href="http://lapwinglabs.com/blog/hacker-guide-to-setting-up-your-mac" target="_blank" rel="external">Hacker’s Guide to Setting up Your Mac</a></li>
<li><a href="https://mattstauffer.co/blog/setting-up-a-new-os-x-development-machine-part-1-core-files-and-custom-shell" target="_blank" rel="external">Setting up a new (OS X) development machine</a></li>
<li><a href="http://www.xialeizhou.com/?p=71" target="_blank" rel="external">高效 MacBook 工作环境配置</a></li>
<li><a href="http://www.zhihu.com/question/20873070" target="_blank" rel="external">程序员如何优雅地使用 Mac？</a></li>
<li><a href="http://sspai.com/27403" target="_blank" rel="external">少数派1</a></li>
<li><a href="http://sspai.com/28385" target="_blank" rel="external">少数派2</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里主要整理一些一直以来使用 Mac 的技巧以及构建高效开发学习环境的指南。主要是按照个人的使用习惯，所以所用的工具和软件都比较偏写代码一些。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://wdxtub.com/tags/Mac/"/>
    
      <category term="技巧" scheme="http://wdxtub.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="疑难杂症" scheme="http://wdxtub.com/tags/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
      <category term="高效" scheme="http://wdxtub.com/tags/%E9%AB%98%E6%95%88/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
