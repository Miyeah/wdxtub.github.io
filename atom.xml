<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-03-20T13:00:27.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[SQL 指南]]></title>
    <link href="http://wdxtub.com/2016/03/20/sql-guide/"/>
    <id>http://wdxtub.com/2016/03/20/sql-guide/</id>
    <published>2016-03-20T12:59:34.000Z</published>
    <updated>2016-03-20T13:00:27.000Z</updated>
    <content type="html"><![CDATA[<p>这里记录一下对于 SQL 基本操作的理解和优化。</p>
<a id="more"></a>
<hr>
<h2 id="SQL__u662F_u4E00_u79CD_u58F0_u660E_u5F0F_u8BED_u8A00"><a href="#SQL__u662F_u4E00_u79CD_u58F0_u660E_u5F0F_u8BED_u8A00" class="headerlink" title="SQL 是一种声明式语言"></a>SQL 是一种声明式语言</h2><p>首先要把这个概念记在脑中：“声明”。 SQL 语言是为计算机声明了一个你想从原始数据中获得什么样的结果的一个范例，而不是告诉计算机如何能够得到结果。这是不是很棒？</p>
<p>（译者注：简单地说，SQL 语言声明的是结果集的属性，计算机会根据 SQL 所声明的内容来从数据库中挑选出符合声明的数据，而不是像传统编程思维去指示计算机如何操作。）</p>
<pre><code>SELECT first_name, last_name FROM employees WHERE salary &gt; 100000
</code></pre><p>上面的例子很容易理解，我们不关心这些雇员记录从哪里来，我们所需要的只是那些高薪者的数据（译者注： salary&gt;100000 ）。</p>
<p>我们从哪儿学习到这些？</p>
<p>如果 SQL 语言这么简单，那么是什么让人们“闻 SQL 色变”？主要的原因是：我们潜意识中的是按照命令式编程的思维方式思考问题的。就好像这样：“电脑，先执行这一步，再执行那一步，但是在那之前先检查一下是否满足条件 A 和条件 B ”。例如，用变量传参、使用循环语句、迭代、调用函数等等，都是这种命令式编程的思维惯式。</p>
<h2 id="SQL__u7684_u8BED_u6CD5_u5E76_u4E0D_u6309_u7167_u8BED_u6CD5_u987A_u5E8F_u6267_u884C"><a href="#SQL__u7684_u8BED_u6CD5_u5E76_u4E0D_u6309_u7167_u8BED_u6CD5_u987A_u5E8F_u6267_u884C" class="headerlink" title="SQL 的语法并不按照语法顺序执行"></a>SQL 的语法并不按照语法顺序执行</h2><p>SQL 语句有一个让大部分人都感到困惑的特性，就是：SQL 语句的执行顺序跟其语句的语法顺序并不一致。SQL 语句的语法顺序是：</p>
<ul>
<li>SELECT[DISTINCT]</li>
<li>FROM</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>UNION</li>
<li>ORDER BY</li>
</ul>
<p>为了方便理解，上面并没有把所有的 SQL 语法结构都列出来，但是已经足以说明 SQL 语句的语法顺序和其执行顺序完全不一样，就以上述语句为例，其执行顺序为：</p>
<ul>
<li>FROM</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>SELECT</li>
<li>DISTINCT</li>
<li>UNION</li>
<li>ORDER BY</li>
</ul>
<p>关于 SQL 语句的执行顺序，有三个值得我们注意的地方：</p>
<p>1、 FROM 才是 SQL 语句执行的第一步，并非 SELECT 。数据库在执行 SQL 语句的第一步是将数据从硬盘加载到数据缓冲区中，以便对这些数据进行操作。（译者注：原文为“The first thing that happens is loading data from the disk into memory, in order to operate on such data.”，但是并非如此，以 Oracle 等常用数据库为例，数据是从硬盘中抽取到数据缓冲区中进行操作。）</p>
<p>2、 SELECT 是在大部分语句执行了之后才执行的，严格的说是在 FROM 和 GROUP BY 之后执行的。理解这一点是非常重要的，这就是你不能在 WHERE 中使用在 SELECT 中设定别名的字段作为判断条件的原因。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> A.x + A.y <span class="keyword">AS</span> z</span><br><span class="line"><span class="keyword">FROM</span> A</span><br><span class="line"><span class="keyword">WHERE</span> z = <span class="number">10</span></span></span><br></pre></td></tr></table></figure>
<p>z 在此处不可用，因为SELECT是最后执行的语句！<br>如果你想重用别名z，你有两个选择。要么就重新写一遍 z 所代表的表达式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> A.x + A.y <span class="keyword">AS</span> z</span><br><span class="line"><span class="keyword">FROM</span> A</span><br><span class="line"><span class="keyword">WHERE</span> (A.x + A.y) = <span class="number">10</span></span></span><br></pre></td></tr></table></figure>
<p>或者求助于衍生表、通用数据表达式或者视图，以避免别名重用。请看下文中的例子。</p>
<p>3、 无论在语法上还是在执行顺序上， UNION 总是排在在 ORDER BY 之前。很多人认为每个 UNION 段都能使用 ORDER BY 排序，但是根据 SQL 语言标准和各个数据库 SQL 的执行差异来看，这并不是真的。尽管某些数据库允许 SQL 语句对子查询（subqueries）或者派生表（derived tables）进行排序，但是这并不说明这个排序在 UNION 操作过后仍保持排序后的顺序。</p>
<p>注意：并非所有的数据库对 SQL 语句使用相同的解析方式。如 MySQL、PostgreSQL和 SQLite 中就不会按照上面第二点中所说的方式执行。</p>
<p>我们学到了什么？</p>
<p>既然并不是所有的数据库都按照上述方式执行 SQL 预计，那我们的收获是什么？我们的收获是永远要记得： SQL 语句的语法顺序和其执行顺序并不一致，这样我们就能避免一般性的错误。如果你能记住 SQL 语句语法顺序和执行顺序的差异，你就能很容易的理解一些很常见的 SQL 问题。</p>
<p>当然，如果一种语言被设计成语法顺序直接反应其语句的执行顺序，那么这种语言对程序员是十分友好的，这种编程语言层面的设计理念已经被微软应用到了 LINQ 语言中。</p>
<h2 id="SQL__u8BED_u8A00_u7684_u6838_u5FC3_u662F_u5BF9_u8868_u7684_u5F15_u7528_uFF08table_references_uFF09"><a href="#SQL__u8BED_u8A00_u7684_u6838_u5FC3_u662F_u5BF9_u8868_u7684_u5F15_u7528_uFF08table_references_uFF09" class="headerlink" title="SQL 语言的核心是对表的引用（table references）"></a>SQL 语言的核心是对表的引用（table references）</h2><p>由于 SQL 语句语法顺序和执行顺序的不同，很多同学会认为SELECT 中的字段信息是 SQL 语句的核心。其实真正的核心在于对表的引用。</p>
<p>根据 SQL 标准，FROM 语句被定义为：</p>
<pre><code>&lt;from clause&gt; ::= FROM &lt;table reference&gt; [ { &lt;comma&gt; &lt;table reference&gt; }... ]
</code></pre><p>FROM 语句的“输出”是一张联合表，来自于所有引用的表在某一维度上的联合。我们们慢慢来分析：</p>
<pre><code>FROM a, b
</code></pre><p>上面这句 FROM 语句的输出是一张联合表，联合了表 a 和表 b 。如果 a 表有三个字段， b 表有 5 个字段，那么这个“输出表”就有 8 （ =5+3）个字段。</p>
<p>这个联合表里的数据是 <code>a*b</code>，即 a 和 b 的笛卡尔积。换句话说，也就是 a 表中的每一条数据都要跟 b 表中的每一条数据配对。如果 a 表有3 条数据， b 表有 5 条数据，那么联合表就会有 <code>15（=5*3）</code>条数据。</p>
<p>FROM 输出的结果被 WHERE 语句筛选后要经过 GROUP BY 语句处理，从而形成新的输出结果。我们后面还会再讨论这方面问题。</p>
<p>如果我们从集合论（关系代数）的角度来看，一张数据库的表就是一组数据元的关系，而每个 SQL 语句会改变一种或数种关系，从而产生出新的数据元的关系（即产生新的表）。</p>
<p>我们学到了什么？</p>
<p>思考问题的时候从表的角度来思考问题提，这样很容易理解数据如何在 SQL 语句的“流水线”上进行了什么样的变动。</p>
<h2 id="u7075_u6D3B_u5F15_u7528_u8868_u80FD_u4F7F_SQL__u8BED_u53E5_u53D8_u5F97_u66F4_u5F3A_u5927"><a href="#u7075_u6D3B_u5F15_u7528_u8868_u80FD_u4F7F_SQL__u8BED_u53E5_u53D8_u5F97_u66F4_u5F3A_u5927" class="headerlink" title="灵活引用表能使 SQL 语句变得更强大"></a>灵活引用表能使 SQL 语句变得更强大</h2><p>灵活引用表能使 SQL 语句变得更强大。一个简单的例子就是 JOIN 的使用。严格的说 JOIN 语句并非是 SELECT 中的一部分，而是一种特殊的表引用语句。 SQL 语言标准中表的连接定义如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">table</span> <span class="attribute">reference</span>&gt;</span> ::=</span><br><span class="line">    <span class="tag">&lt;<span class="title">table</span> <span class="attribute">name</span>&gt;</span></span><br><span class="line">  | <span class="tag">&lt;<span class="title">derived</span> <span class="attribute">table</span>&gt;</span></span><br><span class="line">  | <span class="tag">&lt;<span class="title">joined</span> <span class="attribute">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就拿之前的例子来说：</p>
<pre><code>FROM a, b
</code></pre><p>a 可能输如下表的连接：</p>
<pre><code>a1 JOIN a2 ON a1.id = a2.id
</code></pre><p>将它放到之前的例子中就变成了：</p>
<pre><code>FROM a1 JOIN a2 ON a1.id = a2.id, b
</code></pre><p>尽管将一个连接表用逗号跟另一张表联合在一起并不是常用作法，但是你的确可以这么做。结果就是，最终输出的表就有了 a1+a2+b 个字段了。</p>
<p>（译者注：原文这里用词为 degree ，译为维度。如果把一张表视图化，我们可以想象每一张表都是由横纵两个维度组成的，横向维度即我们所说的字段或者列，英文为columns；纵向维度即代表了每条数据，英文为 record ，根据上下文，作者这里所指的应该是字段数。）</p>
<p>在 SQL 语句中派生表的应用甚至比表连接更加强大，下面我们就要讲到表连接。</p>
<p>我们学到了什么？</p>
<p>思考问题时，要从表引用的角度出发，这样就很容易理解数据是怎样被 SQL 语句处理的，并且能够帮助你理解那些复杂的表引用是做什么的。</p>
<p>更重要的是，要理解 JOIN 是构建连接表的关键词，并不是 SELECT 语句的一部分。有一些数据库允许在 INSERT 、 UPDATE 、 DELETE 中使用 JOIN 。</p>
<h2 id="SQL__u8BED_u53E5_u4E2D_u63A8_u8350_u4F7F_u7528_u8868_u8FDE_u63A5"><a href="#SQL__u8BED_u53E5_u4E2D_u63A8_u8350_u4F7F_u7528_u8868_u8FDE_u63A5" class="headerlink" title="SQL 语句中推荐使用表连接"></a>SQL 语句中推荐使用表连接</h2><p>我们先看看刚刚这句话：</p>
<pre><code>FROM a, b
</code></pre><p>高级 SQL 程序员也许学会给你忠告：尽量不要使用逗号来代替 JOIN 进行表的连接，这样会提高你的 SQL 语句的可读性，并且可以避免一些错误。</p>
<p>利用逗号来简化 SQL 语句有时候会造成思维上的混乱，想一下下面的语句：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM <span class="tag">a</span>, <span class="tag">b</span>, c, d, e, f, g, h</span><br><span class="line">WHERE <span class="tag">a</span><span class="class">.a1</span> = <span class="tag">b</span><span class="class">.bx</span></span><br><span class="line">AND <span class="tag">a</span><span class="class">.a2</span> = c<span class="class">.c1</span></span><br><span class="line">AND d<span class="class">.d1</span> = <span class="tag">b</span><span class="class">.bc</span></span><br><span class="line">-- etc...</span><br></pre></td></tr></table></figure>
<p>我们不难看出使用 JOIN 语句的好处在于：</p>
<ul>
<li>安全。 JOIN 和要连接的表离得非常近，这样就能避免错误。</li>
<li>更多连接的方式，JOIN 语句能去区分出来外连接和内连接等。</li>
</ul>
<p>我们学到了什么？</p>
<p>记着要尽量使用 JOIN 进行表的连接，永远不要在 FROM 后面使用逗号连接表。</p>
<h2 id="SQL__u8BED_u53E5_u4E2D_u4E0D_u540C_u7684_u8FDE_u63A5_u64CD_u4F5C"><a href="#SQL__u8BED_u53E5_u4E2D_u4E0D_u540C_u7684_u8FDE_u63A5_u64CD_u4F5C" class="headerlink" title="SQL 语句中不同的连接操作"></a>SQL 语句中不同的连接操作</h2><p>SQL 语句中，表连接的方式从根本上分为五种：</p>
<ul>
<li>EQUI JOIN</li>
<li>SEMI JOIN</li>
<li>ANTI JOIN</li>
<li>CROSS JOIN</li>
<li>DIVISION</li>
</ul>
<h3 id="EQUI_JOIN"><a href="#EQUI_JOIN" class="headerlink" title="EQUI JOIN"></a>EQUI JOIN</h3><p>这是一种最普通的 JOIN 操作，它包含两种连接方式：</p>
<ul>
<li>INNER JOIN（或者是 JOIN ）</li>
<li>OUTER JOIN（包括： LEFT 、 RIGHT、 FULL OUTER JOIN）</li>
</ul>
<p>用例子最容易说明其中区别：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">- <span class="constant">This</span> table reference contains authors <span class="keyword">and</span> their books.</span><br><span class="line"></span>-<span class="ruby">- <span class="constant">There</span> is one record <span class="keyword">for</span> each book <span class="keyword">and</span> its author.</span><br><span class="line"></span>-<span class="ruby">- authors without books are <span class="constant">NOT</span> included</span><br><span class="line"></span>author JOIN book ON author.id = book.author_id</span><br><span class="line"></span><br><span class="line">-<span class="ruby">- <span class="constant">This</span> table reference contains authors <span class="keyword">and</span> their books</span><br><span class="line"></span>-<span class="ruby">- <span class="constant">There</span> is one record <span class="keyword">for</span> each book <span class="keyword">and</span> its author.</span><br><span class="line"></span>-<span class="ruby">- ... <span class="constant">OR</span> there is an <span class="string">"empty"</span> record <span class="keyword">for</span> authors without books</span><br><span class="line"></span>-<span class="ruby">- (<span class="string">"empty"</span> meaning that all book columns are <span class="constant">NULL</span>)</span><br><span class="line"></span>author LEFT OUTER JOIN book ON author.id = book.author_id</span><br></pre></td></tr></table></figure>
<h3 id="SEMI_JOIN"><a href="#SEMI_JOIN" class="headerlink" title="SEMI JOIN"></a>SEMI JOIN</h3><p>这种连接关系在 SQL 中有两种表现方式：使用 IN，或者使用 EXISTS。“ SEMI ”在拉丁文中是“半”的意思。这种连接方式是只连接目标表的一部分。这是什么意思呢？再想一下上面关于作者和书名的连接。我们想象一下这样的情况：我们不需要作者 / 书名这样的组合，只是需要那些在书名表中的书的作者信息。那我们就能这么写：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- <span class="keyword">Using</span> <span class="keyword">IN</span></span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> author.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> book.author_id <span class="keyword">FROM</span> book)</span><br><span class="line"></span><br><span class="line">-- <span class="keyword">Using</span> EXISTS</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> EXISTS (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> book.author_id = author.id)</span><br></pre></td></tr></table></figure>
<p>尽管没有严格的规定说明你何时应该使用 IN ，何时应该使用 EXISTS ，但是这些事情你还是应该知道的：</p>
<ul>
<li>IN 比 EXISTS 的可读性更好</li>
<li>EXISTS 比IN 的表达性更好（更适合复杂的语句）</li>
<li>二者之间性能没有差异（但对于某些数据库来说性能差异会非常大）</li>
</ul>
<p>因为使用 INNER JOIN 也能得到书名表中书所对应的作者信息，所以很多初学者机会认为可以通过 DISTINCT 进行去重，然后将 SEMI JOIN 语句写成这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Find only those authors who also have books</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> first_name, last_name</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">JOIN</span> book <span class="keyword">ON</span> author.<span class="keyword">id</span> = book.author_id</span></span><br></pre></td></tr></table></figure>
<p>这是一种很糟糕的写法，原因如下：</p>
<ul>
<li>SQL 语句性能低下：因为去重操作（ DISTINCT ）需要数据库重复从硬盘中读取数据到内存中。（译者注： DISTINCT 的确是一种很耗费资源的操作，但是每种数据库对于 DISTINCT 的操作方式可能不同）。</li>
<li>这么写并非完全正确：尽管也许现在这么写不会出现问题，但是随着 SQL 语句变得越来越复杂，你想要去重得到正确的结果就变得十分困难。</li>
</ul>
<h3 id="ANTI_JOIN"><a href="#ANTI_JOIN" class="headerlink" title="ANTI JOIN"></a>ANTI JOIN</h3><p>这种连接的关系跟 SEMI JOIN 刚好相反。在 IN 或者 EXISTS 前加一个 NOT 关键字就能使用这种连接。举个例子来说，我们列出书名表里没有书的作者：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- <span class="keyword">Using</span> <span class="keyword">IN</span></span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> author.id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> book.author_id <span class="keyword">FROM</span> book)</span><br><span class="line"></span><br><span class="line">-- <span class="keyword">Using</span> EXISTS</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> EXISTS (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> book.author_id = author.id)</span><br></pre></td></tr></table></figure>
<p>关于性能、可读性、表达性等特性也完全可以参考 SEMI JOIN。</p>
<h3 id="CROSS_JOIN"><a href="#CROSS_JOIN" class="headerlink" title="CROSS JOIN"></a>CROSS JOIN</h3><p>这个连接过程就是两个连接的表的乘积：即将第一张表的每一条数据分别对应第二张表的每条数据。我们之前见过，这就是逗号在 FROM 语句中的用法。在实际的应用中，很少有地方能用到 CROSS JOIN，但是一旦用上了，你就可以用这样的 SQL语句表达：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- Combine <span class="keyword">every</span> author with <span class="keyword">every</span> book</span><br><span class="line">author CROSS <span class="keyword">JOIN</span> book</span><br></pre></td></tr></table></figure>
<h3 id="DIVISION"><a href="#DIVISION" class="headerlink" title="DIVISION"></a>DIVISION</h3><p>DIVISION 的确是一个怪胎。简而言之，如果 JOIN 是一个乘法运算，那么 DIVISION 就是 JOIN 的逆过程。DIVISION 的关系很难用 SQL 表达出来，介于这是一个新手指南，解释 DIVISION 已经超出了我们的目的。</p>
<p>我们学到了什么？</p>
<p>学到了很多！让我们在脑海中再回想一下。 SQL 是对表的引用， JOIN 则是一种引用表的复杂方式。但是 SQL 语言的表达方式和实际我们所需要的逻辑关系之间是有区别的，并非所有的逻辑关系都能找到对应的 JOIN 操作，所以这就要我们在平时多积累和学习关系逻辑，这样你就能在以后编写 SQL 语句中选择适当的 JOIN 操作了。</p>
<h2 id="SQL__u4E2D_u5982_u540C_u53D8_u91CF_u7684_u6D3E_u751F_u8868"><a href="#SQL__u4E2D_u5982_u540C_u53D8_u91CF_u7684_u6D3E_u751F_u8868" class="headerlink" title="SQL 中如同变量的派生表"></a>SQL 中如同变量的派生表</h2><p>在这之前，我们学习到过 SQL 是一种声明性的语言，并且 SQL 语句中不能包含变量。但是你能写出类似于变量的语句，这些就叫做派生表：</p>
<p>说白了，所谓的派生表就是在括号之中的子查询：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- A derived table</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> author)</span><br></pre></td></tr></table></figure>
<p>需要注意的是有些时候我们可以给派生表定义一个相关名（即我们所说的别名）。</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- A derived table <span class="keyword">with</span> an <span class="keyword">alias</span></span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> author) a</span><br></pre></td></tr></table></figure>
<p>派生表可以有效的避免由于 SQL 逻辑而产生的问题。举例来说：如果你想重用一个用 SELECT 和 WHERE 语句查询出的结果，这样写就可以（以 Oracle 为例）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Get authors' first and last names, and their age in days</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> first_name, last_name, age</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> first_name, last_name, <span class="keyword">current_date</span> - date_of_birth age</span><br><span class="line">  <span class="keyword">FROM</span> author</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- If the age is greater than 10000 days</span></span><br><span class="line"><span class="keyword">WHERE</span> age &gt; <span class="number">10000</span></span></span><br></pre></td></tr></table></figure>
<p>需要我们注意的是：在有些数据库，以及 SQL ： 1990 标准中，派生表被归为下一级——通用表语句（ common table experssion）。这就允许你在一个 SELECT 语句中对派生表多次重用。上面的例子就（几乎）等价于下面的语句：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> a <span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> first_name, last_name, current_date - date_of_birth age</span><br><span class="line">  <span class="keyword">FROM</span> author</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> a</span><br><span class="line"><span class="keyword">WHERE</span> age &gt; <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>当然了，你也可以给“ a ”创建一个单独的视图，这样你就可以在更广泛的范围内重用这个派生表了。更多信息可以阅读下面的文章（<a href="http://en.wikipedia.org/wiki/View_%28SQL%29）。" target="_blank" rel="external">http://en.wikipedia.org/wiki/View_%28SQL%29）。</a></p>
<p>我们学到了什么？</p>
<p>我们反复强调，大体上来说 SQL 语句就是对表的引用，而并非对字段的引用。要好好利用这一点，不要害怕使用派生表或者其他更复杂的语句。</p>
<h2 id="SQL__u8BED_u53E5_u4E2D_GROUP_BY__u662F_u5BF9_u8868_u7684_u5F15_u7528_u8FDB_u884C_u7684_u64CD_u4F5C"><a href="#SQL__u8BED_u53E5_u4E2D_GROUP_BY__u662F_u5BF9_u8868_u7684_u5F15_u7528_u8FDB_u884C_u7684_u64CD_u4F5C" class="headerlink" title="SQL 语句中 GROUP BY 是对表的引用进行的操作"></a>SQL 语句中 GROUP BY 是对表的引用进行的操作</h2><p>让我们再回想一下之前的 FROM 语句：</p>
<pre><code>FROM a, b
</code></pre><p>现在，我们将 GROUP BY 应用到上面的语句中：</p>
<pre><code>GROUP BY A.x, A.y, B.z
</code></pre><p>上面语句的结果就是产生出了一个包含三个字段的新的表的引用。我们来仔细理解一下这句话：当你应用 GROUP BY 的时候， SELECT 后没有使用聚合函数的列，都要出现在 GROUP BY 后面。（译者注：原文大意为“当你是用 GROUP BY 的时候，你能够对其进行下一级逻辑操作的列会减少，包括在 SELECT 中的列”）。</p>
<p>需要注意的是：其他字段能够使用聚合函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT A<span class="class">.x</span>, A<span class="class">.y</span>, <span class="function"><span class="title">SUM</span><span class="params">(A.z)</span></span></span><br><span class="line">FROM A</span><br><span class="line">GROUP BY A<span class="class">.x</span>, A.y</span><br></pre></td></tr></table></figure>
<p>还有一点值得留意的是： MySQL 并不坚持这个标准，这的确是令人很困惑的地方。（译者注：这并不是说 MySQL 没有 GROUP BY 的功能）但是不要被 MySQL 所迷惑。 GROUP BY 改变了对表引用的方式。你可以像这样既在 SELECT 中引用某一字段，也在 GROUP BY 中对其进行分组。</p>
<p>我们学到了什么？</p>
<p>GROUP BY，再次强调一次，是在表的引用上进行了操作，将其转换为一种新的引用方式。</p>
<h2 id="SQL__u8BED_u53E5_u4E2D_u7684_SELECT__u5B9E_u8D28_u4E0A_u662F_u5BF9_u5173_u7CFB_u7684_u6620_u5C04"><a href="#SQL__u8BED_u53E5_u4E2D_u7684_SELECT__u5B9E_u8D28_u4E0A_u662F_u5BF9_u5173_u7CFB_u7684_u6620_u5C04" class="headerlink" title="SQL 语句中的 SELECT 实质上是对关系的映射"></a>SQL 语句中的 SELECT 实质上是对关系的映射</h2><p>我个人比较喜欢“映射”这个词，尤其是把它用在关系代数上。（译者注：原文用词为 projection ，该词有两层含义，第一种含义是预测、规划、设计，第二种意思是投射、映射，经过反复推敲，我觉得这里用映射能够更直观的表达出 SELECT 的作用）。一旦你建立起来了表的引用，经过修改、变形，你能够一步一步的将其映射到另一个模型中。 SELECT 语句就像一个“投影仪”，我们可以将其理解成一个将源表中的数据按照一定的逻辑转换成目标表数据的函数。</p>
<p>通过 SELECT语句，你能对每一个字段进行操作，通过复杂的表达式生成所需要的数据。</p>
<p>SELECT 语句有很多特殊的规则，至少你应该熟悉以下几条：</p>
<ul>
<li>你仅能够使用那些能通过表引用而得来的字段；</li>
<li>如果你有 GROUP BY 语句，你只能够使用 GROUP BY 语句后面的字段或者聚合函数；</li>
<li>当你的语句中没有 GROUP BY 的时候，可以使用开窗函数代替聚合函数；</li>
<li>当你的语句中没有 GROUP BY 的时候，你不能同时使用聚合函数和其它函数；</li>
<li>有一些方法可以将普通函数封装在聚合函数中；</li>
<li>……</li>
</ul>
<p>一些更复杂的规则多到足够写出另一篇文章了。比如：为何你不能在一个没有 GROUP BY 的 SELECT 语句中同时使用普通函数和聚合函数？（上面的第 4 条）</p>
<p>原因如下：</p>
<ul>
<li>凭直觉，这种做法从逻辑上就讲不通。</li>
<li>如果直觉不能够说服你，那么语法肯定能。 SQL : 1999 标准引入了 GROUPING SETS，SQL： 2003 标准引入了 group sets : GROUP BY() 。无论什么时候，只要你的语句中出现了聚合函数，而且并没有明确的 GROUP BY 语句，这时一个不明确的、空的 GROUPING SET 就会被应用到这段 SQL 中。因此，原始的逻辑顺序的规则就被打破了，映射（即 SELECT ）关系首先会影响到逻辑关系，其次就是语法关系。（译者注：这段话原文就比较艰涩，可以简单理解如下：在既有聚合函数又有普通函数的 SQL 语句中，如果没有 GROUP BY 进行分组，SQL 语句默认视整张表为一个分组，当聚合函数对某一字段进行聚合统计的时候，引用的表中的每一条 record 就失去了意义，全部的数据都聚合为一个统计值，你此时对每一条 record 使用其它函数是没有意义的）。</li>
</ul>
<p>糊涂了？是的，我也是。我们再回过头来看点浅显的东西吧。</p>
<p>我们学到了什么？</p>
<p>SELECT 语句可能是 SQL 语句中最难的部分了，尽管他看上去很简单。其他语句的作用其实就是对表的不同形式的引用。而 SELECT 语句则把这些引用整合在了一起，通过逻辑规则将源表映射到目标表，而且这个过程是可逆的，我们可以清楚的知道目标表的数据是怎么来的。</p>
<p>想要学习好 SQL 语言，就要在使用 SELECT 语句之前弄懂其他的语句，虽然 SELECT 是语法结构中的第一个关键词，但它应该是我们最后一个掌握的。</p>
<h2 id="SQL__u8BED_u53E5_u4E2D_u7684_u51E0_u4E2A_u7B80_u5355_u7684_u5173_u952E_u8BCD_uFF1A_DISTINCT__uFF0C_UNION__uFF0C_ORDER_BY__u548C_OFFSET"><a href="#SQL__u8BED_u53E5_u4E2D_u7684_u51E0_u4E2A_u7B80_u5355_u7684_u5173_u952E_u8BCD_uFF1A_DISTINCT__uFF0C_UNION__uFF0C_ORDER_BY__u548C_OFFSET" class="headerlink" title="SQL 语句中的几个简单的关键词： DISTINCT ， UNION ， ORDER BY 和 OFFSET"></a>SQL 语句中的几个简单的关键词： DISTINCT ， UNION ， ORDER BY 和 OFFSET</h2><p>在学习完复杂的 SELECT 之后，我们再来看点简单的东西：</p>
<ul>
<li>集合运算（ DISTINCT 和 UNION ）</li>
<li>排序运算（ ORDER BY，OFFSET…FETCH）</li>
<li>集合运算（ set operation）：</li>
</ul>
<p>集合运算主要操作在于集合上，事实上指的就是对表的一种操作。从概念上来说，他们很好理解：</p>
<ul>
<li>DISTINCT 在映射之后对数据进行去重</li>
<li>UNION 将两个子查询拼接起来并去重</li>
<li>UNION ALL 将两个子查询拼接起来但不去重</li>
<li>EXCEPT 将第二个字查询中的结果从第一个子查询中去掉</li>
<li>INTERSECT 保留两个子查询中都有的结果并去重</li>
</ul>
<p>排序运算（ ordering operation）：</p>
<p>排序运算跟逻辑关系无关。这是一个 SQL 特有的功能。排序运算不仅在 SQL 语句的最后，而且在 SQL 语句运行的过程中也是最后执行的。使用 ORDER BY 和 OFFSET…FETCH 是保证数据能够按照顺序排列的最有效的方式。其他所有的排序方式都有一定随机性，尽管它们得到的排序结果是可重现的。</p>
<p>OFFSET…SET是一个没有统一确定语法的语句，不同的数据库有不同的表达方式，如 MySQL 和 PostgreSQL 的 LIMIT…OFFSET、SQL Server 和 Sybase 的 TOP…START AT 等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里记录一下对于 SQL 基本操作的理解和优化。</p>]]>
    
    </summary>
    
      <category term="SQL" scheme="http://wdxtub.com/tags/SQL/"/>
    
      <category term="数据库" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CUDA 简明指南]]></title>
    <link href="http://wdxtub.com/2016/03/20/cuda-note/"/>
    <id>http://wdxtub.com/2016/03/20/cuda-note/</id>
    <published>2016-03-20T12:05:36.000Z</published>
    <updated>2016-03-20T12:07:36.000Z</updated>
    <content type="html"><![CDATA[<p>For CMU 18-645 How to write fast code. Learn CUDA in an hour!</p>
<a id="more"></a>
<hr>
<h2 id="CUDA_u67B6_u6784"><a href="#CUDA_u67B6_u6784" class="headerlink" title="CUDA架构"></a>CUDA架构</h2><p>在 CUDA 的架构下,一个程序分为两个部份:host 端和 device 端。Host 端是指在 CPU 上执行 的部份,而 device 端则是在显示芯片上执行的部份。Device 端的程序又称为 “kernel(核心)”。 通常 host 端程序会将数据准备好后,复制到显卡的内存中,再由显示芯片执行 device 端程序,完 成后再由 host 端程序将结果从显卡的内存中取回。</p>
<p>在 CUDA 架构下,显示芯片执行时的最小单位是 thread(线程)。数个 thread 可以组成一个 block(块)。一个 block 中的 thread 能存取同一块共享的内存,而且可以快速进行同步的动作。</p>
<p>每一个 block 所能包含的 thread 数目是有限的。不过,执行相同程序的 block,可以组成 grid(格子)。不同 block 中的 thread 无法存取同一个共享的内存,因此无法直接互通或进行同步。因此, 不同 block 中的 thread 能合作的程度是比较低的。不过,利用这个模式,可以让程序不用担心显示芯片实际上能同时执行的 thread 数目限制。例如,一个具有很少量执行单元的显示芯片,可能会 把各个 block 中的 thread 顺序执行,而非同时执行。不同的 grid 则可以执行不同的程序(即 kernel)。</p>
<p>每个 thread 都有自己的一份 register 和 local memory 的空间。同一个 block 中的每个 thread 则有共享的一份 share memory。此外,所有的 thread(包括不同 block 的 thread)都共享一份 global memory、constant memory、和 texture memory。不同的 grid 则有各自的 global memory、 constant memory 和 texture memory。</p>
<h2 id="u6267_u884C_u6A21_u5F0F"><a href="#u6267_u884C_u6A21_u5F0F" class="headerlink" title="执行模式"></a>执行模式</h2><p>由于显示芯片大量并行计算的特性,它处理一些问题的方式,和一般 CPU 是不同的。主要的特点包括:</p>
<ol>
<li>内存存取 latency 的问题:CPU 通常使用 cache 来减少存取主内存的次数,以避免内存 latency 影响到执行效率。显示芯片则多半没有 cache(或很小),而利用并行化执行的方式来隐藏内存的 latency(即,当第一个 thread 需要等待内存读取结果时,则开始执行第二 个 thread,依此类推)。</li>
<li>分支指令的问题:CPU 通常利用分支预测等方式来减少分支指令造成的 pipeline bubble。显示芯片则多半使用类似处理内存 latency 的方式。不过,通常显示芯片处理分支的效率会比较差</li>
</ol>
<p>最适合利用 CUDA 处理的问题,是可以大量并行化的问题,才能有效隐藏内存的 latency, 并有效利用显示芯片上的大量执行单元。使用 CUDA 时,同时有上千个 thread 在执行是很正常的。 因此,如果不能大量并行化的问题,使用 CUDA 就没办法达到最好的效率了。</p>
<h2 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>streaming processor, sp: 最基本的处理单元，最后具体的指令和任务都是在 sp 上处理的。GPU 进行并行计算，也就是很多个 sp 同时做处理</li>
<li>streaming multiprocessor, sm: 多个 sp 加上存储资源组成一个 sm</li>
<li>warp: GPU 执行程序时的调度单位，目前 CUDA 的 warp 大小为32，同在一个 warp 的线程，以不同数据资源执行相同的指令。</li>
<li>thread, block, grid: 利用 CUDA 进行编程时，一个 grid 分为多个 block，一个 block 分为多个 thread (From a programmer’s perspective)</li>
</ul>
<h3 id="Some_Restrictions_First"><a href="#Some_Restrictions_First" class="headerlink" title="Some Restrictions First"></a>Some Restrictions First</h3><ul>
<li>All threads in a grid execute the same kernel function</li>
<li>A grid is organized as a 2D array of blocks(gridDim.X and gridDim.y)</li>
<li>Each block is organized as 3D array of threads(blockDim.x, blockDim.y, and blockDim.z)</li>
<li>Once a kernel is launched, its dimensions cannot change.</li>
<li>All blocks in a grid have the same dimension</li>
<li>The total size of a block is limited to 512 threads(? I’m not sure?)</li>
<li>Once assigned to an SM, the block must execute in its entirey by the SM.</li>
<li>Thread ID is unique within a block</li>
<li>Using block ID and thread ID we can make unique ID for each thread per kernel</li>
<li>Threads assigned to execution resources on a block-by-block basis</li>
<li>CUDA runtime automatically reduces number of blocks assigned to each SM</li>
<li>until resource usage is under limit.</li>
</ul>
<h3 id="SM_-Streaming_multi-processors_with_multiple_processing_cores"><a href="#SM_-Streaming_multi-processors_with_multiple_processing_cores" class="headerlink" title="SM -Streaming multi-processors with multiple processing cores"></a>SM -Streaming multi-processors with multiple processing cores</h3><ul>
<li>Each SM contains 32 processing cores</li>
<li>Execute in a Single Instruction Multiple Thread (SIMT) fashion</li>
<li>Up to 16 SMs on a card cor a maximum of 512 compute cores</li>
</ul>
<h3 id="Warps"><a href="#Warps" class="headerlink" title="Warps"></a>Warps</h3><ul>
<li>Once a block is assigned to an SM, it is divided into units called warps.</li>
<li>Thread IDs within a warp are consecutive and increasing</li>
<li>Warp 0 starts with Thread ID 0</li>
<li>Warp is unit of thread scheduling in SMs</li>
<li>Partitioning is always the same</li>
<li>DO NOT rely on any ordering between warps</li>
<li>Each warp is executed in a SIMD fashion (all threads within a warp must execute the same instruction at any given time)</li>
<li>Problem: branch divergence</li>
</ul>
<h3 id="Latency_Tolerance"><a href="#Latency_Tolerance" class="headerlink" title="Latency Tolerance"></a>Latency Tolerance</h3><ul>
<li>When an instruction executed by the threads in a warp must wait for the result of a previously initiated long-latency operation, the warp is not selected for execution -&gt; lantency hiding</li>
<li>Priority mechanism used to schedule ready warps</li>
<li>Scheduling does not introduce idle time -&gt; zero-overhead thread scheduling</li>
<li>Scheduling is used for tolerating long-latency operations, such as:</li>
<li>piplined floating-point arithmetic</li>
<li>branch instructions</li>
</ul>
<p>The only safe way to synchronize threads in different blocks is to terminate the kernel and start a new kernel for the acitivities after the synchronization point.</p>
<h2 id="u4EE3_u7801_u76F8_u5173"><a href="#u4EE3_u7801_u76F8_u5173" class="headerlink" title="代码相关"></a>代码相关</h2><ul>
<li>通过 cudaGetDeviceProperties 函数可以取得许多数据，除了装置支持的 CUDA 版本之外, 还有装置的名称、内存的大小、最大的 thread 数目、执行单元的频率等等</li>
<li>需要包含头文件<code>&lt;cuda_runtime.h&gt;</code></li>
<li>编译直接可以<code>nvcc xxx.cu</code></li>
<li>nvcc 是 CUDA 的 compile 工具,它会将 .cu 檔拆解出在 GPU 上执行的部份,及在 host 上执 行的部份,并呼叫适当的程序进行 compile 动作。在 GPU 执行的部份会透过 NVIDIA 提供的 compiler 编译成中介码,而 host 执行的部份则会透过系统上的 C++ compiler 编译(在 Windows 上使用 Visual C++ 而在 Linux 上使用 gcc)</li>
<li>cudaMalloc 和 cudaMemcpy 的用法和一般的 malloc 及 memcpy 类似,不过 cudaMemcpy 则多出一个参数,指示复制内存的方向。从主内存复制到显卡内存,所以使用 cudaMemcpyHostToDevice。如果是从显卡内存到主内存,则使用 cudaMemcpyDeviceToHost。</li>
<li>在 CUDA 中，在函数前面加上 <code>__global__</code> 表示这个函数是要在显示芯片上执行的。</li>
<li>在显卡上执行的程序有一些限制，例如它不能有返回值</li>
<li>让 CUDA 执行函数的语法<ul>
<li><code>function&lt;&lt;&lt;# block, # thread, shared memory size&gt;&gt;&gt;(para....)</code></li>
</ul>
</li>
<li>在 CUDA 中,一般的数据复制到的显卡内存的部份,称为 global memory。这些内存是没有 cache 的,而且,存取 global memory 所需要的时间(即 latency)是非常长的,通常是数百个 cycles。由于我们的程序只有一 个 thread,所以每次它读取 global memory 的内容,就要等到实际读取到数据、累加到 sum 之后, 才能进行下一步。</li>
<li>由于 global memory 并没有 cache,所以要避开巨大的 latency 的方法,就是要利用大量的 threads。假设现在有大量的 threads 在同时执行,那么当一个 thread 读取内存,开始等待结果的 时候,GPU 就可以立刻切换到下一个 thread,并读取下一个内存位置。因此,理想上当 thread 的 数目够多的时候,就可以完全把 global memory 的巨大 latency 隐藏起来了。</li>
<li>显卡上的内存是 DRAM,因此最有效率的存取方式,是以连续的方式存取。前面的程序,虽然看起 来是连续存取内存位置(每个 thread 对一块连续的数字计算平方和),但是我们要考虑到实际上 thread 的执行方式。前面提过,当一个 thread 在等待内存的数据时,GPU 会切换到下一个 thread。 也就是说,实际上执行的顺序是类似 thread0 -&gt; thread1 -&gt; thread2。因此,在同一个 thread 中连续存取内存,在实际执行时反而不是连续了。要让实际执行结果是连续 的存取,我们应该要让 thread 0 读取第一个数字,thread 1 读取第二个数字…依此类推。</li>
<li>在 CUDA 中,thread 是可以分组的,也就是 block。一个 block 中的 thread,具有一个共享的 shared memory,也可以进行同步工作。不同 block 之间的 thread 则不行。在我们的程序中,其 实不太需要进行 thread 的同步动作,因此我们可以使用多个 block 来进一步增加 thread 的数目</li>
<li>利用 <code>__shared__</code> 声明的变量表示这是 shared memory,是一个 block 中每个 thread 都共享的 内存。它会使用在 GPU 上的内存,所以存取的速度相当快,不需要担心 latency 的问题。</li>
<li>`__syncthreads()`` 是一个 CUDA 的内部函数,表示 block 中所有的 thread 都要同步到这个点,才能继续执行。</li>
</ul>
<h2 id="u7ECF_u9A8C_u6280_u5DE7"><a href="#u7ECF_u9A8C_u6280_u5DE7" class="headerlink" title="经验技巧"></a>经验技巧</h2><ul>
<li>利用 <code>threadIdx.x</code> 来分 thread 执行，考虑好邻接性。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>For CMU 18-645 How to write fast code. Learn CUDA in an hour!</p>]]>
    
    </summary>
    
      <category term="CUDA" scheme="http://wdxtub.com/tags/CUDA/"/>
    
      <category term="教程" scheme="http://wdxtub.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 学习笔记]]></title>
    <link href="http://wdxtub.com/2016/03/20/java-note/"/>
    <id>http://wdxtub.com/2016/03/20/java-note/</id>
    <published>2016-03-20T12:00:19.000Z</published>
    <updated>2016-03-20T12:55:05.000Z</updated>
    <content type="html"><![CDATA[<p>这里是我学习 Java 黄皮书时记录整理的笔记，时间比较久远，不保证时效性。</p>
<a id="more"></a>
<hr>
<h2 id="Java_u7A0B_u5E8F_u8BBE_u8BA1_u6982_u8FF0"><a href="#Java_u7A0B_u5E8F_u8BBE_u8BA1_u6982_u8FF0" class="headerlink" title="Java程序设计概述"></a>Java程序设计概述</h2><p>简要地介绍一下Java语言的发展历史。</p>
<p>Java并不只是一种语言，Java是一个完整的平台，有一个庞大的库，其中包含了很多可重用的代码和一个提供诸如安全性、跨操作系统的可一直性以及自动垃圾收集等服务的执行环境。</p>
<p>感兴趣的话可以参见<a href="http://java.sun.com/docs/white/langenv/" target="_blank" rel="external">这里</a></p>
<p><strong>简单性</strong></p>
<p>人们希望构建一个无需社脑的专业训练就可以进行编程的系统，并且要符合当今的标准惯例。Java提出了C++中许多很少使用、难以理解、易混淆的特性。在目前看来，这些特性带来的麻烦远远多于其带来的好处。</p>
<p><code>Java语法是C++语法的一个纯净”版本</code>。没有头文件、指针运算、结构、联合、操作符重载、虚基类等等。</p>
<p>简单的另一个方面是小。Java的目标之一是支持开发能够在小型机器上独立运行的软件。</p>
<p><strong>面向对象</strong></p>
<p>面向对象设计是一种程序设计技术。它将重点放在数据(即对象)和对象的接口上。具体来说，就是关注的是要做出什么，而不是用什么做出来。在本质上，Java的面向对象能力与C++是一样的。</p>
<p>Java与C++的主要不同点在于<code>多继承</code>，在Java中，取而代之的是简单的接口概念，以及Java的<code>元类(metaclass)</code>模型。</p>
<p><strong>网络技能</strong></p>
<p>Java又一个拓展的例程库，用于处理像HTTP和FTP这类的TCP/IP协议。Java应用程序能够通过URL打开和访问网络上的对象，其边界程度就好像访问本地文件一样。</p>
<p><strong>健壮性</strong></p>
<p>Java的设计目标之一在于使得Java编写的程序具有多方面的可靠性。Java和C++的最大不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能性。</p>
<p>Java编译器能够检测许多在其他语言中仅在运行时刻才能够检测出来的问题。</p>
<p><strong>安全性</strong></p>
<p>一开始Java就设计成能够防范各种袭击，其中包括</p>
<ol>
<li>运行时堆栈溢出。如，蠕虫等病毒常用的袭击手段。</li>
<li>在子集的处理空间之外破坏内存</li>
<li>未经授权读写文件。</li>
</ol>
<p><strong>体系结构中立</strong></p>
<p>编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码，只要有Java运行时系统，就可以在许多处理器上运行。Java编译器通过生成与特定的计算机体系结构无关的字节码指令来实现这一特性。精心设计的字节码不仅可以很容易地在任何机器上解释执行，而且还可以迅速地翻译成本地机器的代码。</p>
<p>解释字节码肯定会比全速地运行机器指令慢很多，但是虚拟机有一个选项，可以将使用最贫乏的字节码序列翻译成机器码，这一过程被称为即时编译。这一策略已经证明十分有效。</p>
<p><strong>可移植性</strong></p>
<p>与C和C++不同，Java规范中没有依赖具体实现”的地方，数据类型具有固定的大小，这消除了代码移植时令人头痛的主要问题。</p>
<p><strong>解释型</strong></p>
<p>Java解释器可已在任何移植了解释器的机器上执行Java字节码。由于链接是一个增值而简便的过程，所以开发过程也变得更加快捷</p>
<p><strong>高性能</strong></p>
<p>尽管对解释后的字节码性能已经比较满意，但在有些场合下却需要更加高效的性能。字节码可以(在运行时刻)快速地翻译成运行这个应用程序的特定CPU的机器码。</p>
<p><strong>多线程</strong></p>
<p>多线程可以带来更好的交互响应和实时行为。在不同的机器上，只是调用多线程的代码完全相同；Java把多线程的实现交给了底层的操作系统或线程库来完成。多线程编译的简单性是Java称为颇具魅力的服务器端开发语言的主要原因之一。</p>
<p><strong>动态性</strong></p>
<p>Java与C或C++相比更加具有动态性。它能够适应不断发展的环境。库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。在Java中找出运行时类型信息十分简单。</p>
<p><strong>Java Applet与Internet</strong></p>
<p>这里的想法很简单：用户从Internet下载Java字节码，并在子集的机器上运行。在网页中运行Java程序称为applet。为了使用applet，需要启用Java的Web浏览器执行字节码。由于Sun公司负责发放Java源代码的许可证，并坚持不允许对语言和基本类库的结构做出任何修改，因此，Java的applet应该可以运星在任何启用Java的浏览器上，并且无论何时访问包含applet的网页，都会得到程序的最终版本。</p>
<p>现在，当需要在浏览器中显示动态效果时，大多数网页都直接使用JavaScript或Flash。</p>
<h3 id="Java_u53D1_u5C55_u7B80_u53F2"><a href="#Java_u53D1_u5C55_u7B80_u53F2" class="headerlink" title="Java发展简史"></a>Java发展简史</h3><ul>
<li>1991年，由Patrick Naughton及其伙伴James Gosling带领的Sun公司的工程师小组想要设计一种小型的计算机语言，主要用于像有限电视转换盒这种设备。这种语言的关键是不能与任何特定的体系结构捆绑在一起，这个项目被命名为Green”。</li>
<li>代码短小、紧凑且与平台无关，这些要求促使开发团队联想起很早以前的一种模型，某些Pascal的实现曾经在早期的PC上尝试过这种模型。</li>
<li>不过，Sun公司的人都具有UNIX的应用背景。因此，所开发的语言以C++为基础，而不是Pascal。Gosling把这种语言称为Oak”。Sun公司的人后来发现Oak是一种已有的计算机语言的名字，于是将其改名为Java。</li>
<li>1992年，Green项目发布了它的第一个产品，称之为 <code>*7</code>，具有非常智能的远程控制，但是Sun公司对生产这个产品没有兴趣。</li>
<li>Green项目(这时换了一个新名字──Fist Person”公司)整个1993年和1994年上半年都在苦苦寻求其技术的买家。但是，一个也没有。1994年First Person公司解散了。</li>
<li>1994年中期，Java语言的开发者意识到它们能够建立一个最酷的浏览器。在1995年5月23日的SunWorld展示后，引发了人们延续至今的对Java的狂热追逐。</li>
<li>1996年初，Sun发布了Java的第1个版本。Java1.1弥补了其中的大多部分明显的缺陷。</li>
<li>1998年，Sun发布了Java1.2，后改名为Java2标准版软件开发工具箱1.2版”。</li>
<li>除了标准版之外，还有两个其他的版本，一个是用于手机等嵌入式设备的微型版”，另一个是用于服务器端处理的企业版”。</li>
<li>标准版的1.3和1.4版本对最初的Java 2版本做出了某些改进，拓展了标准类库，提高系统性能。</li>
<li>5.0版是自1.1版依赖第一个对Java语言做出重大改进的版本。</li>
<li>版本6(没有后缀.0)与2006年末发布。这个版本没有对语言方面再进行改进，而是改进了其他性能，并增强了类库。</li>
</ul>
<h3 id="u5173_u4E8EJava_u7684_u5E38_u89C1_u8BEF_u89E3"><a href="#u5173_u4E8EJava_u7684_u5E38_u89C1_u8BEF_u89E3" class="headerlink" title="关于Java的常见误解"></a>关于Java的常见误解</h3><blockquote>
<p>Java是HTML的拓展。</p>
</blockquote>
<p>Java是一种程序设计语言；HTML是一种描述网页结构的方式。</p>
<blockquote>
<p>使用XML，就不需要Java。</p>
</blockquote>
<p>Java是一种程序设计语言；XML是一种描述数据的方式。可以使用任何一种程序设计语言处理XML数据。</p>
<blockquote>
<p>Java是一种非常容易学习的程序设计语言。</p>
</blockquote>
<p>像Java这种功能强大的语言大都不太容易学习。</p>
<blockquote>
<p>Java将成为适用于所有平台的通用性编程语言。</p>
</blockquote>
<p>很多在桌面计算机上已经工作良好的应用程序，通常是用C或C++编写的，用Java重写一次似乎对于用户来说没有什么特别的好处。</p>
<blockquote>
<p>Java只不过是另外一种程序设计语言。</p>
</blockquote>
<p>程序设计语言的成功更多地取决于其支撑系统的能力，而不是优美的语法。Java的成功源于其类库能够让人们轻松地完成原本有一定难度的事情</p>
<blockquote>
<p>现在有了C#，Java过时了。</p>
</blockquote>
<p>C#借鉴了Java许多好的思想，例如：清晰的语言结构、虚拟机和垃圾收集器。最重要的是安全性和平台无关性。但是从求职广告判定，Java仍然是大多数开发者选择的语言。</p>
<blockquote>
<p>Java有专利，应该避免使用。</p>
</blockquote>
<p>Sun声称Java未来的版本将在General Public License下可用。Linux使用的是同一个开放源代码许可。开放源代码会使Java的生存期延长很多年。</p>
<blockquote>
<p>Java是解释型的，因此对于关键的应用程序速度太慢了。</p>
</blockquote>
<p>Java所写的代码某些程度上其运行速度与C++相差无几。Java有一些C++没有的额外开销。但是，硬件的发展很快的。</p>
<blockquote>
<p>所有的Java程序都是在网页中运行的。</p>
</blockquote>
<p>所有的Java applet都在网页浏览器中运行的。然而，大多数Java程序是运行在Web浏览器之外的独立应用程序。</p>
<blockquote>
<p>Java程序是主要的安全风险。</p>
</blockquote>
<p>相当可笑，不解释。</p>
<blockquote>
<p>JavaScript是Java的简易版。</p>
</blockquote>
<p>JavaScript是一种在网页中使用的脚本语言。JavaScript的语言类似Java，除此之外，两者无任何关系。额，名字有点像。更多可查阅<a href="http://www.apl.jhu.edu/~hall/java/FAQs-and-Tutorials.html" target="_blank" rel="external">Java FAQ(Java Frequently Question)</a></p>
<h2 id="Java_u57FA_u672C_u7684_u7A0B_u5E8F_u8BBE_u8BA1_u7ED3_u6784"><a href="#Java_u57FA_u672C_u7684_u7A0B_u5E8F_u8BBE_u8BA1_u7ED3_u6784" class="headerlink" title="Java基本的程序设计结构"></a>Java基本的程序设计结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstSample</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(Hello! I’m wdxtub”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是一个最简单的Java应用程序，但是所有的Java应用程序都具有这种结构。</p>
<p>Java对<code>大小写敏感</code>。关键字<code>public</code>称为<code>访问修饰符(access modifier)</code>，用于控制程序的其他部分对这段代码的访问级别。</p>
<p><code>类</code>是构建所有Java应用程序和applet的构建块。Java应用程序中的全部内容都必须放置在类中。关键字class后面紧跟类名。Java中定义类名的规则很宽松。名字必须以<code>字母开头</code>，后面可以跟字母和数字的任意组合。长度基本上没有限制。但是不能使用Java的保留字。</p>
<p>源代码的文件名必须与公有类的名字相同，并用<code>.java</code>作为扩展名。</p>
<p>运行编译程序时，Java 虚拟机将从指定类中的<code>main</code>方法开始执行，并且<code>main</code>方法必须声明为<code>public</code>。</p>
<p>注释有三种方法：</p>
<ol>
<li><code>//</code> 单行的注释，内容从 <code>//</code> 开始到本行结尾</li>
<li><code>/*...*/</code> 长篇的注释</li>
<li><code>/**...*/</code> 用于自动生成文档</li>
</ol>
<p>Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。Java中一共有8种基本类型(primitive type)。其中4种整型，2种浮点类型，1种char型，1种boolean类型。</p>
<p>整型表示没有小数部分的数值，可以是复数。分别为<code>int(4字节)</code>，<code>short(2字节)</code>，<code>long(8字节)</code>，<code>byte(1字节)</code>。由于Java程序必须保证在所有机器都能得到相同的运行结果，所以每一种数据类型的取值范围必须固定。</p>
<p>浮点类型用于表示有小数部分的数值。分别是<code>float(4字节，有效位数6～7位)</code>，<code>double(8字节，有效位数15位)</code>。</p>
<p><code>double</code>表示这种类型的数值精度是<code>float</code>的两倍。绝大部分程序都采用<code>double</code>类型。<code>float</code>类型的数值有一个后缀F，没有<code>后缀F</code>的浮点数值默认为<code>double</code>类型。</p>
<p>三个特殊的浮点数值：</p>
<ul>
<li>正无穷大</li>
<li>负无穷大</li>
<li>NaN(不是一个数字，Not a Number)</li>
</ul>
<p><code>char</code>类型用于表示单个字符。通常用来表示字符常量。</p>
<p><strong>我们强烈建议不要在程序中使用char类型，除非确实需要对UTF-16代码单元进行操作。最好将需要处理的字符串用抽象数据类型表示。</strong></p>
<p><code>boolean(布尔)</code>类型有两个值：<code>false</code>和<code>true</code>，用来判定逻辑条件。整型和布尔值之间不能进行相互转换。</p>
<p>每一个变量属于一种类型(type)。声明变量时，变量所属的类型位于变量名之前，每个声明以分号结束。</p>
<p>可以在一行中声明多个变量，不过不提倡使用这种风格。逐一声明每一个变量可以提高程序的可读性。</p>
<p>声明一个变量之后，必须用赋值语句对变量进行显式的初始化，千万不要使用未被初始化的变量。可以将声明放在代码中的任何地方，变量的声明应尽可能地靠近变量第一次使用的地方。</p>
<p>利用关键字final声明常量，表示这个变量只能被赋值一次。一旦被赋值后就不能再更改了。习惯上，常量名使用大写。</p>
<p>若希望某个常量可以在一个类中的多个方法中使用，通常将这些常量称为类常量，使用static final设置。</p>
<p>类常量的定义位于main方法的外部，所以在同一个类的其他方法中也可以使用这个常量。</p>
<h3 id="u8FD0_u7B97_u7B26"><a href="#u8FD0_u7B97_u7B26" class="headerlink" title="运算符"></a>运算符</h3><p>Java程序设计语言承认了最优性能与理想结果之间存在的冲突，并给予了改进。在默认情况下，虚拟机设计者允许中间结果采用拓展的精度。但对于strictfp关键字标记的方法必须使用严格的浮点计算来产生理想的结果。</p>
<p>自增运算符与自减运算符 前缀方式<code>先进行加一或减一</code>的运算，后缀方式则使用变量原来的值。建议不要在其他表达式的内部使用++，使人迷惑，产生bug。</p>
<p>关系运算符与boolean运算符，其中<code>==</code>，<code>!=</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code>，<code>||</code>，<code>&amp;&amp;</code>均与C++一致。</p>
<p>位运算符</p>
<ul>
<li><code>&amp;</code>(与)，<code>|</code>(或)，<code>^</code>(异或)，<code>-</code>(非)</li>
<li><code>&gt;&gt;</code>和<code>&lt;&lt;</code>运算符进行右移或左移操作，屏蔽某些位。</li>
<li><code>&gt;&gt;&gt;</code>运算符用0填充高位；<code>&gt;&gt;</code>运算符用符号填充高位，没有<code>&lt;&lt;&lt;</code>运算符。</li>
</ul>
<p>在Math类中，包含各种的数学函数。若得到一个完全可预测的结果比运行速度更重要的话，就应该使用StrictMath类。</p>
<p>整型转换为float或double型很有可能损失精度。</p>
<p>在圆括号中给出想要转换的目标类型，后面紧跟待转换的变量名，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">9.998</span>;</span><br><span class="line"><span class="keyword">int</span> nx = (<span class="keyword">int</span>)x;</span><br></pre></td></tr></table></figure>
<p>若想进行四舍五入计算，使用 <code>Math.round</code> 方法。</p>
<p>括号与运算符级别与正常情况下一致。少数结合性是从右向左的。</p>
<p>枚举类型包括有限个命名的值。</p>
<p>如 <code>enum Size{SMALL,MEDIUM,LARGE,EXTRA_LARGE}</code>。</p>
<p>Java字符串就是Unicode字符序列。</p>
<p>String类的substring方法可以从一个较大的字符串提取一个子串，容易计算子串长度，语句：<code>s.substring(a,b)</code>，长度即为<code>b-a</code>。</p>
<p>允许使用<code>+</code>号连接(拼接)两个字符串。</p>
<p><code>String</code>类没有提供用于修改字符串的方法，所以在Java文档中将String类对象称为<code>不可变字符串</code>。</p>
<p>不可变字符又一个优点：编译器可以让<code>字符串共享</code>。Java的设计者认为共享带来的高效率远远胜过于提取。</p>
<p>使用<code>equals</code>方法检测两个字符串是否相等。<code>s.equals(t)</code>，若 <code>s</code> 与 <code>t</code> 相等，则返回<code>true</code>，否则返回<code>false</code>。<code>s</code> 和 <code>t</code> 可以是字符串变量也可以是字符串常量，如<code>”Hello”.equals(greeting)</code>。</p>
<p>如果向不区分大小写，使用<code>equalsIgnoreCase</code>方法。一定不能使用 <code>==</code> 运算符检测两个字符串是否相等！这个运算符只能够确定两个字符是否放置在同一个位置上。</p>
<p>大多数的常用Unicode字符使用一个代码单元就可以表示，而辅助字符则需要一对代码来表示。</p>
<p><code>s.charAt(n)</code>将返回位置 <code>n</code> 的代码单元，<code>n</code>介于<code>0～s.length()-1</code>之间。对于那些一对代码单元表示的字符，就会出现问题。而<code>codePointAt</code>可以解决这个问题。</p>
<p>Java中的String类包含了50多个方法并且绝大多数都很有用。</p>
<p><strong>java.lang.string</strong></p>
<ul>
<li><code>char charAt( int index )</code><ul>
<li>返回给定位置的代码单元。除非对底层的代码单元感兴趣，否则不需要调用这个方法。</li>
</ul>
</li>
<li><code>int codePointAt( int index )</code><ul>
<li>返回从给定位置开始或结束的代码点。</li>
</ul>
</li>
<li><code>int offsetByCodePoints( int startIndex, int cpCount )</code><ul>
<li>返回从 startIndex 代码点开始，位移 cpCount 后的代码点索引。</li>
</ul>
</li>
<li><code>int compareTo( String other )</code><ul>
<li>按照字典顺序，如果字符串位于other之前，返回一个负数；位于other之后，返回一个正数；如果两个字符串相等，返回0。</li>
</ul>
</li>
<li><code>boolean endsWith( String suffix )</code><ul>
<li>如果字符串以suffix结尾，返回true。</li>
</ul>
</li>
<li><code>boolean equals( Object other )</code><ul>
<li>如果字符串以other相等，返回true。</li>
</ul>
</li>
<li><code>boolean equalsIgnoreCase( String other )</code><ul>
<li>如果字符串与other相等(忽略大小写)，返回true。</li>
</ul>
</li>
<li><code>int indexOf( String str )</code></li>
<li><code>int indexOf( String, int fromIndex )</code></li>
<li><code>int indexOf( int cp )</code></li>
<li><code>int indexOf( int cp, int fromIndex )</code><ul>
<li>返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromIndex开始计算。如果在原始串中不存在str，返回-1。</li>
</ul>
</li>
<li><code>int lastIndexOf( String str )</code></li>
<li><code>int lastIndexOf( String str, int  fromIndex )</code></li>
<li><code>int lastIndexOf( int cp )</code></li>
<li><code>int lastIndexOf( int cp, int fromIndex )</code><ul>
<li>返回与字符串str或代码点cp匹配的最后一个子串的开始位置。这个位置从原始串尾端或fromIndex开始计算。</li>
</ul>
</li>
<li><code>int length()</code><ul>
<li>返回字符串的长度。</li>
</ul>
</li>
<li><code>int codePointCount( int startIndex, int endIndex)</code><ul>
<li>返回startIndex和endIndex-1之间的代码点数量。没有配成对的代用字符将计入代码点。</li>
</ul>
</li>
<li><code>String replace(CharSequence oldString, CharSequence newString)</code><ul>
<li>返回一个新字符串。这个字符串用newString代替原始字符串中的所有oldString。可以用String或StringBuilder对象作为CharSequence参数。</li>
</ul>
</li>
<li><code>boolean startsWith( String prefix )</code><ul>
<li>如果字符串以prefix字符串开始，返回true。</li>
</ul>
</li>
<li><code>String substring( int beginIndex )</code></li>
<li><code>String substring( int beginIndex, int  endIndex )</code><ul>
<li>返回一个新字符串。这个字符串包含原始字符串中从beginIndex到串尾或endIndex-1的所有代码点。</li>
</ul>
</li>
<li><code>String toLowerCase()</code><ul>
<li>返回一个新字符串，这个字符串将原始字符串中的所有大写字母改成了小写字母。</li>
</ul>
</li>
<li><code>String toUpperCase()</code><ul>
<li>返回一个新字符串，这个字符串将原始字符串中的所有小写字母改成了大写字母。</li>
</ul>
</li>
<li><code>String trim()</code><ul>
<li>返回一个新字符串。这个字符串将山除了原始字符串头部和尾部的空格。</li>
</ul>
</li>
</ul>
<p>如果需要用许多小段的字符串构建一个字符串，那么应该按照下列步骤进行。首先，构建一个空的字符串构建器：</p>
<p><code>StringBuilder builder = new StringBuilder();</code></p>
<p>当每次需要添加一部分内容时，就调用append方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">builder.append(ch); <span class="comment">// appends a single character</span></span><br><span class="line">builder.append(str);    <span class="comment">// appends a string</span></span><br></pre></td></tr></table></figure>
<p><strong>java.lang.StringBuilder</strong></p>
<ul>
<li><code>StringBuilder()</code><ul>
<li>构造一个空的字符串构建器。</li>
</ul>
</li>
<li><code>int length()</code><ul>
<li>返回构建器或缓冲器中的代码单元数量。</li>
</ul>
</li>
<li><code>StringBuilder append( String str )</code><ul>
<li>追加一个字符串并返回this。</li>
</ul>
</li>
<li><code>StringBuilder append( char c )</code><ul>
<li>追加一个代码单元并返回this。</li>
</ul>
</li>
<li><code>StringBuilder appendCodePoint( int cp )</code><ul>
<li>追加一个代码点，并将其转换为一个或两个代码单元并返回this。</li>
</ul>
</li>
<li><code>void setCharAt( int i,char c )</code><ul>
<li>将第 i 个代码单元设置为 c。</li>
</ul>
</li>
<li><code>StringBuilder insert( int offset,String str )</code><ul>
<li>在offset位置插入一个字符串并返回this。</li>
</ul>
</li>
<li><code>StringBuilder insert( int offset,Char c )</code><ul>
<li>在offset位置插入一个代码单元并返回this。</li>
</ul>
</li>
<li><code>StringBuilder delete( int startIndex,int endIndex )</code><ul>
<li>删除偏移量从startIndex到-endIndex-1的代码单元并返回this。</li>
</ul>
</li>
<li><code>String toString()</code><ul>
<li>返回一个与构建器或缓冲器内容相同的字符串。</li>
</ul>
</li>
</ul>
<h3 id="u8F93_u5165_u8F93_u51FA"><a href="#u8F93_u5165_u8F93_u51FA" class="headerlink" title="输入输出"></a>输入输出</h3><p>要想通过控制台进行输入，首先需要构造一个<code>Scanner</code>对象，并与标准输入流”<code>System.in</code>关联。</p>
<pre><code>Scanner in = new Scanner(System.in);
</code></pre><p>现在就可以使用<code>Scanner</code>类的各种方法实现输入操作。例如可以用<code>nextLine</code>方法将输入一行(包括输入行中有空格的情况)，若想读取一个单词(以空格作为分隔符)，就调用next方法；想读取一个整数，就调用<code>nextInt</code>方法；想读取一个浮点数，就调用<code>nextDouble</code>方法。</p>
<pre><code>String name = in.nextLine();
String firstName = in.next();
int age = in.nextInt();
double salary = in.nextDouble();
</code></pre><p>最后在程序最开始加上 <code>import java.util.*;</code></p>
<p>当使用的类不是定义在基本<code>java.lang</code>包中时，一定要使用<code>import</code>指示将相应的包加载进来。</p>
<p><strong>java.util.Scanner</strong></p>
<ul>
<li><code>Scanner( InputStream in)</code><ul>
<li>用给定的输入流创建一个Scanner对象。</li>
</ul>
</li>
<li><code>String nextLine()</code><ul>
<li>读取输入的下一行内容。</li>
</ul>
</li>
<li><code>String next()</code><ul>
<li>读取输入的下一个单词(以空格作为分隔符)</li>
</ul>
</li>
<li><code>int nextInt()</code></li>
<li><code>double nextDouble()</code><ul>
<li>读取并转换下一个表示整数或浮点数的字符序列。</li>
</ul>
</li>
<li><code>boolean hasNext()</code><ul>
<li>检测输入中是否还有其他单词。</li>
</ul>
</li>
<li><code>boolean hasNextInt()</code></li>
<li><code>boolean hasNextDouble()</code><ul>
<li>检测是否还有表示整数或浮点数的下一个字符序列。</li>
</ul>
</li>
<li><code>Scanner( File f )</code><ul>
<li>构造一个从给定文件读取数据的Scanner。</li>
</ul>
</li>
<li><code>Scanner( String data)</code><ul>
<li>构造一个从给定字符串读取数据的Scanner。</li>
</ul>
</li>
</ul>
<p><strong>java.util.System</strong></p>
<ul>
<li><code>static Console console()</code><ul>
<li>如果有可能进行交互操作，就通过控制台窗口为交互的用户返回一个Console对象，否则返回null。</li>
</ul>
</li>
</ul>
<p><strong>java.io.Console</strong></p>
<ul>
<li><code>static char[] readPassword( String prompt, Object...args )</code></li>
<li><code>static String readLine( String prompt, Object...args)</code><ul>
<li>显示字符串prompt并且读取用户输入，直到输入行结束。args参数可以用来提供输入格式。</li>
</ul>
</li>
</ul>
<p>格式化输出沿用了C语言库函数中的printf方法，另外还可以给出控制格式化输出的各种标志</p>
<p>可以采用一个格式化的字符串指出要被格式化的参数索引。紧跟在%后面，并以$终止。还可以选择使用&lt;标志。它指示前面格式说明中的参数将再次使用。</p>
<p>文件输入与输出。要想对文件进行读取，就需要一个用<code>File</code>对象构造一个<code>Scanner</code>对象，例如：<code>Scanner in = new Scanner(new File(myfile.txt”));</code></p>
<p>如果文件名中包含反斜杠符号，就要记住在每个反斜杠之前再价一个额外的反斜杠：<code>c:\\mydirectory\\myfile.txt”</code>。</p>
<p>要想写入文件，就需要构造一个<code>PrintWriter</code>对象。在构造器中，主需要提供文件名：<code>PrintWriter out = new PrintWriter(myfile.txt”);</code></p>
<p>可以向输出到<code>System.out</code>一样使用<code>print</code>、<code>pinrtln</code>以及<code>printf</code>命令。</p>
<p><strong>java.io.PrintWriter</strong></p>
<ul>
<li><code>PrintWriter( File f)</code><ul>
<li>构造一个将数据写入给定文件的PrintWriter。</li>
</ul>
</li>
<li><code>PrintWriter( String fileName )</code><ul>
<li>构造一个将数据写入文件的PrintWriter。文件名由参数指定。</li>
</ul>
</li>
</ul>
<p><strong>java.io.File</strong></p>
<ul>
<li><code>File( String fileName )</code></li>
</ul>
<p>用给定的文件名，构造一个描述文件的File对象。注意这个文件当前不必存在。</p>
<p>有可能出发多个<code>case</code>分支。如果在<code>case</code>分支语句的末尾没有<code>break</code>语句，那么就会接着执行下一个<code>case</code>分支语句。这种情况相当危险，常常会引发错误。为此，尽量不要使用<code>switch</code>语句。</p>
<p>当在<code>switch</code>语句中使用枚举常量时，不必在每个标签中指明枚举名，可以由<code>switch</code>的表达式确定。例如：</p>
<pre><code>Size sz = {SMALL,LARGE,...}
switch (sz){
    case SMALL: // no need to use Size.SMALL
    ...
    break;
}
</code></pre><p>无限制地使用goto语句确实是导致错误的根源，但偶尔地使用goto跳出循环是有益处的，Java中增加了一条带标签的break以支持这种跳出。</p>
<p>请注意，标签必须放在希望跳出的最外层循环之前，必须紧跟一个冒号。如下所示：</p>
<pre><code>int n;
read_data:
while(...){ // this loop statement is tagged with the label
    ...
    for(...){ // this inner loop is not labeled
        if(...) break read_data; // break out of read_data loop
    }
}
// this statement is executed immediately after the labeled break

if(....){.....}
</code></pre><p>即可以直接跳出所标记的循环，继续执行下面的语句。</p>
<p>带标签的continue将跳到与标签匹配的循环首部。</p>
<h3 id="u5927_u6570_u503C"><a href="#u5927_u6570_u503C" class="headerlink" title="大数值"></a>大数值</h3><p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用<code>java.math</code>包中的两个很有用的类：<code>BigInterger</code>(任意精度的整数运算)和<code>BigDecimal</code>(任意精度的浮点数运算)。</p>
<p>使用静态的<code>valueOf</code>方法可以将普通的数值转换为大数值：</p>
<pre><code>BigInterger a = BigInteger.valueOf(100);
</code></pre><p>但是不能使用算数运算符，有专门的运算方法。</p>
<p><strong>java.math.BigInterger</strong></p>
<ul>
<li><code>BigInteger add( BigInteger other )</code></li>
<li><code>BigInteger subtract( BigInteger other)</code></li>
<li><code>BigInteger multiply( BigInteger other)</code></li>
<li><code>BigInteger divide( BigInteger other)</code></li>
<li><code>BigInteger mod( BigInteger other)</code><ul>
<li>返回这个大整数和另一个大整数other的和、差、积、商和余数。</li>
</ul>
</li>
<li><code>int compareTo( BigInteger other )</code><ul>
<li>如果这个大整数和另一个大整数other相等，返回0；如果这个大整数小于另一个大整数，返回负数；大于的话，返回正数。</li>
</ul>
</li>
<li><code>static BigInteger valueOf(long x)</code><ul>
<li>返回值等于x的大整数。</li>
</ul>
</li>
</ul>
<p><strong>java.math.BiDecimal</strong></p>
<ul>
<li><code>BigDecimal add( BigDecimal other )</code></li>
<li><code>BigDecimal subtract( BigDecimal other)</code></li>
<li><code>BigDecimal multiply( BigDecimal other)</code></li>
<li><code>BigDecimal divide( BigDecimal other, RoundingMode mode)</code><ul>
<li>返回这个大实数和另一个大实数other的和、差、积、商和余数。要想计算商，必须给出舍入方式(rounding mode)。RoundingMode.HALF_UP是四舍五入方式，其他的舍入方式参见API文档。</li>
</ul>
</li>
<li><code>int compareTo( BigDecimal other )</code><ul>
<li>如果这个大实数和另一个大实数other相等，返回0；如果这个大实数小于另一个大实数，返回负数；大于的话，返回正数。</li>
</ul>
</li>
<li><code>static BigDecimal valueOf( long x)</code></li>
<li><code>static BigDecimal valueOf( long x, int scale)</code><ul>
<li>返回值等于x或x/10scale的一个大实数。</li>
</ul>
</li>
</ul>
<h3 id="u6570_u7EC4"><a href="#u6570_u7EC4" class="headerlink" title="数组"></a>数组</h3><p>应该使用<code>new</code>运算符创建数组：<code>int[] a = new int[100];</code></p>
<p>要想获得数组中的元素个数，可以使用<code>array.length</code>。</p>
<p>一旦创建了数组，就不能再改变它的大小。如果经常需要在运行过程中拓展数组的大小，就应该使用另一种数据结构─数组列表(array list)。</p>
<p>Java SE 5.0增加了一种功能很强的循环结构，可以用来一次处理数组中的每个元素(其他类型的元素集合亦可)而不必为指定下标值而分心。</p>
<p>语句格式为：<code>for( variable : collection ) statement</code>    例如：</p>
<pre><code>for( int element : a )
    System.out.println( element );
</code></pre><p>就可以打印数组a的每一个元素。</p>
<p>有个更加简单的方式打印数组中的所有值，即利用Arrays类的toString方法。调用<code>Arrays.toString(a)</code>，返回一个包含数组元素的字符串，这些元素被放置在括号内，并用逗号分隔。</p>
<p>提供一种创建数组对象并同时赋予初始值的简化书写形式，如：</p>
<pre><code>int[] smallPrimes = { 2, 3, 5, 6};
</code></pre><p>使用这种语句时就不用调用<code>new</code>。</p>
<p>还可以初始化一个匿名的数组：<code>new int[]{ 11, 12, 14, 15};</code> 这种表示法将创建一个新数组并利用括号中提供的值进行初始化，数组的大小就是初始值的个数。使用这种语法形式可已在不创建新变量的情况下重新初始化一个数组。例如：<code>smallPrimes = new int[]{ 11, 12, 14, 15};</code></p>
<p>允许将一个数组变量拷贝给另一个数组变量。这是，两个变量就引用同一个数组：<code>int[] luckyNumbers = smallPrimes;</code></p>
<p>如果希望将一个数组的所有值拷贝到一个新的数组中，就要使用<code>Arrays</code>类的<code>copyOf</code>方法：<code>int[] copiedLuckyNumbers = Arrays.copyOf( luckyNumbers, luckyNumbers.length );</code></p>
<p>第二个参数是新数组的长度。这个方法通常用来增加数组的大小：<code>luckyNumbers = Arrays.copyOf( luckyNumbers, 2 * luckyNumbers.length);</code></p>
<p>如果数组元素是数值型，那么多余的元素将被赋值为<code>0</code>；如果数组元素是是布尔型，则将赋值为<code>false</code>。如果长度小于原始数组的长度，则只拷贝最前面的数据元素。</p>
<p>在Java SE 6之前，用<code>System</code>类的<code>arraycopy</code>方法将一个数组的元素拷贝到另一个数组中。调用这个方法的格式为：</p>
<pre><code>System.arraycopy( from, fromIndex, to, toIndex, count);
</code></pre><p>数组<code>to</code>必须有足够的空间存放拷贝的元素。意思为，从<code>from</code>数组的下标为<code>fromIndex</code>元素开始，拷贝<code>count</code>个元素到<code>to</code>数组，从<code>to</code>数组的下标为<code>toIndex</code>的元素开始变成被拷贝过来的元素。</p>
<p>可以使用Arrays类中的sort方法对数值型数组进行排序：</p>
<pre><code>int[] a = new int[1000];
...
</code></pre><p><code>Arrays.sort(a);</code> 这个方法使用了优化的快速排序算法，效率是比较高的。</p>
<p><strong>java.util.Arrays</strong></p>
<ul>
<li><code>static String toString( type[] a )</code><ul>
<li>返回包含a中数据元素的字符串，这些数据元素被放在括号内，并用逗号分隔。</li>
</ul>
</li>
<li><code>static type copyOf( type[] a, int length )</code></li>
<li><code>static type copyOf( type[] a, int start, int end )</code><ul>
<li>返回与a类型相同的一个数组，其长度为length或者 end-start，数组元素为a的值。</li>
</ul>
</li>
<li><code>static void sort( type[] a )</code><ul>
<li>采用优化的快速排序算法对数组进行排序。</li>
</ul>
</li>
<li><code>static int binarySearch( type[] a, type v)</code></li>
<li><code>static int binarySearch( type[] a, int start, int end, type v )</code><ul>
<li>采用二分搜索法查找值v。如果查找成功，则返回相应的下标值；否则，返回一个负数值r。-r-1是为保持a有序v应插入的位置。</li>
</ul>
</li>
<li><code>static void fill( type[] a, type v )</code><ul>
<li>将数组的所有数据元素值设置为v。</li>
</ul>
</li>
<li><code>static boolean equals( type[] a, type[] b)</code><ul>
<li>如果两个数组大小相同，并且下标相同的元素都对应相等，返回true。</li>
</ul>
</li>
<li><code>static int hashCode( type[] a )</code><ul>
<li>计算数组a的散列码。可以是int、long、short、char、byte、boolean、float或double的数组。</li>
</ul>
</li>
</ul>
<p><strong>java.lang.System</strong></p>
<ul>
<li><code>static void arraycopy( Object from, int fromIndex, Object to, int toIndex, int count )</code><ul>
<li>将第一个数组中的元素拷贝到第二个数组中。</li>
</ul>
</li>
</ul>
<p>多维数组使用<code>new</code>进行初始化：<code>balances = new double[NSIZE][MSIZE];</code></p>
<p>或者是：<code>int[][] magicSquare = { {16, 3, 2, 13},{5, 10, 11,8} };</code></p>
<p>一旦数组被初始化，就可以利用两个方括号访问每个元素。</p>
<p><code>for each</code>循环语句不能自动处理二维数组的每一个元素。它是按照行，也就是一维数组处理的。要想访问二维数组a的所有元素，需要使用两个嵌套的循环：</p>
<pre><code>for( double[] row: a )
    for( double value : row )
        do something with value
</code></pre><p>想要快速打印一个二维数组的数据元素列表，可以调用：<code>System.out.println( Arrays.deepToString(a));</code></p>
<h2 id="u5BF9_u8C61_u4E0E_u7C7B"><a href="#u5BF9_u8C61_u4E0E_u7C7B" class="headerlink" title="对象与类"></a>对象与类</h2><p>数据被放在第一位，然后再考虑操作数据的算法。</p>
<p><code>类(class)</code>是构造对象的模板或蓝图。由类<code>构造(construct)</code>对象的过程称为创建类的<code>实例(instance)</code>。</p>
<p><code>封装(encapsulation，有时称为数据隐藏)</code>是与对象功能有关的一个重要概念。对象中的数据称为<code>实例域(instance fields)</code>，操纵数据的过程称为<code>方法(method)</code>。对于每个特定的类实例(对象)都有一组特定的实例域值。这些值的集合就是这个对象的当前<code>状态(state)</code>。无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。</p>
<p>封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。</p>
<p>在对于一个已有的类扩展时，这个扩展后的新类具有所拓展的类的全部属性和方法。在新类中，只需要提供哪些仅适用于这个类的新方法和数据域就可以了。</p>
<p>要想使用OOP，一定要清楚对象的三个主要特性：</p>
<ol>
<li>对象的行为(behavior)──可以对对象施加哪些操作，或可以对对象施加哪些方法？</li>
<li>对象的状态(state)──当施加那些方法时，对象如何响应？</li>
<li>对象标识(identity)──如何辨别具有相同行为与状态的不同对象？</li>
</ol>
<p>此外，每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变，但这种改变不会是自发的。</p>
<p>对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份(identity)。需要注意，作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。对象的这些关键特性在彼此之间相互影响着。</p>
<p>识别类的简单规则是在分析问题的过程中寻找名词，而方法对应动词。在创建类的时候，哪些名词和动词是重要的完全取决于个人的开发经验。</p>
<p>在类之间最常见的关系有</p>
<ul>
<li>依赖(uses-a)</li>
<li>聚合(has-a)</li>
<li>继承(is-a)</li>
</ul>
<p><code>依赖(dependence)</code>，是一种最明显的、最常见的关系。如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。应该尽可能将相互依赖的类减至最少，即类之间的耦合度最小。</p>
<p><code>聚合(aggregation)</code>，是一种具体且易于理解的关系。集合意味着类A的对象包含类B的对象。</p>
<p><code>继承(inheritance)</code>，是一种表示特殊与一般的关系。一般而言，如果类A扩展类B，类A不但包含从类B继承的方法，还会拥有一些额外的功能。</p>
<p>要想使用对象，就必须首先构造对象，并指定其初状态。然后，对对象施加方法。在Java程序设计语言中，使用<code>构造器(constructor)</code>构造新实例。</p>
<p>构造器的名字应与类名相同，并且使用<code>new</code>操作符进行构造；也可以将这个对象传递给一个方法；另外<code>Date</code>类中有一个<code>toString</code>方法，返回日期的字符串描述，如下</p>
<pre><code>new Date(); // 被初始化为当前的日期和时间
System.out.println(new Date());
String s = new Date().toString();
</code></pre><p>如果希望构造的对象可以多次使用，就要把对象放在一个变量中：</p>
<pre><code>Date birthday = new Date();
</code></pre><p>可以让一个变量引用一个已存在的变量：<code>Date deadline = birthday;</code>则这两个变量引用同一个对象。</p>
<p>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用。可以显式地将对象变量设置为<code>null</code>，表明这个对象变量目前没有任何引用对象：<code>deadline = null;</code>变量不会自动初始化为<code>null</code>，而必须通过调用<code>new</code>或将它们设置为<code>null</code>进行初始化。</p>
<p>Date类只提供了少量的方法用来比较两个时间点。例如<code>before</code>和<code>after</code>方法分别表示一个时间点是否早于另一个时间点，或者晚于另一个时间点。</p>
<pre><code>if( today.before(birthday) )
    System.out.println(Still time to shop for a gift.”);
</code></pre><p><code>GregorianCalendar</code>类所包含的方法比<code>Date</code>类多得多，并且封装了实例域。</p>
<p>对实例域作出修改的方法被称为<code>更改器方法(mutator method)</code>，仅访问实例域而不进行修改的方法称为<code>访问器方法(accessor method)</code>。</p>
<p>通常的习惯是在访问器方法前面加上前缀<code>get</code>，在更改器方法前面加上前缀<code>set</code>。</p>
<p><strong>java.util.GregorianCalendar</strong></p>
<ul>
<li><code>GregorianCalendar()</code><ul>
<li>构造一个日历对象，用来表示默认地区、默认时区的当前时间。</li>
</ul>
</li>
<li><code>GregorianCalendar( int year, int month, int day )</code></li>
<li><code>GregorianCalendar( int year, int month, int day, int hour, int minutes, int seconds )</code><ul>
<li>用给定的日期和时间构造一个Gregorian日历对象。</li>
</ul>
</li>
<li><code>int get( int field )</code><ul>
<li>返回给定区域的值</li>
</ul>
</li>
<li><code>void set( int field, int value )</code></li>
<li><code>void set( int year, int month, int day )</code></li>
<li><code>void set( int year, int month, int day, int hour, int minutes, int seconds )</code><ul>
<li>将日期域和时间域设置为新值。</li>
</ul>
</li>
<li><code>void add( int field, int amount)</code><ul>
<li>对给定的时间域增加指定数量的时间。</li>
</ul>
</li>
<li><code>int getFistDayOfWeek()</code><ul>
<li>获得当前用户所在地区，一个星期中的第一天。</li>
</ul>
</li>
<li><code>void setTime( Date time )</code><ul>
<li>将日历设置为指定的时间点。</li>
</ul>
</li>
<li><code>Date getTime()</code><ul>
<li>获得这个日历对象当前值所表达的时间点</li>
</ul>
</li>
</ul>
<p><strong>java.text.DateFormatSymbols</strong></p>
<ul>
<li><code>String[] getShortWeekdays()</code></li>
<li><code>String[] getShortMonths()</code></li>
<li><code>String[] getWeekdays()</code></li>
<li><code>String[] getMonths()</code><ul>
<li>获得当前地区的星期几或月份的名称。利用Calendar的星期和月份常量作为数组索引值。</li>
</ul>
</li>
</ul>
<h3 id="u7528_u6237_u81EA_u5B9A_u4E49_u7C7B"><a href="#u7528_u6237_u81EA_u5B9A_u4E49_u7C7B" class="headerlink" title="用户自定义类"></a>用户自定义类</h3><p>复杂应用程序需要各种<code>主力类(workhorse class)</code>。通常这些类没有main方法，而却有自定义的实例域和实例方法。要想创建一个完整的程序，应该将若干类组合在一起，其中只有一个类有main方法。</p>
<p>在Java的类中最简单的类定义形式为：</p>
<pre><code>class ClassName{
    constructor1
    constructor2
    …
    Method1
    Method2
    …
    Field1
    Field2
…
}
</code></pre><p>文件名必须与<code>public</code>类的名字相匹配。在一个文件中，只能有一个公有类，但可以有任意数目的非公有类。</p>
<p>如果习惯于将每一个类存在一个单独的源文件中，将可以有两种编译源程序的方法。</p>
<p>一种是使用通配符调用编译器，即<code>*</code>代表不定的字符串。另一种是只对含有公有类的文件进行<code>javac</code>操作，如果在这里使用了某个类，那么会自动搜索这个类的源文件，进行编译。</p>
<p>可以认为Java编译器内置了<code>make</code>功能。</p>
<p>关键字<code>public</code>意味着任何类的任何方法都可以调用这些方法。关键字<code>private</code>确保只有该类自身的方法能够访问这些实例域，而其他类的方法不能够读取这些域。</p>
<p>构造器与类同名，将实例域初始化为所希望的状态。构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。</p>
<p>方法用于操作对象以及存取它们的实例域。例如，方法：</p>
<pre><code>public void raiseSalary( double byPercent ){
    double raise = salary * byPercent / 100;
    salary += raise;
}
</code></pre><p>将调用这个方法的对象的<code>salary</code>实例域设置为新值，看看下面这个调用：<code>number007.raiseSalary(5);</code> 它的结果将<code>number007.salary</code>域的值增加5%。<code>raiseSalary</code>方法有两个参数。第一个参数被称为<code>隐式(implicit)</code>参数，是出现在方法名前的类对象。第二个参数位于方法名后面括号中的数值，这是一个<code>显式(explicit)</code>参数。<br>在每个方法中，关键字<code>this</code>表示隐式参数。如果需要的话，可以用下列方式编写<code>raiseSalary</code>方法：</p>
<pre><code>public void raiseSalary( double by Percent ){
    double raise = this.salary * byPercent / 100;
    this.salary += raise;
}
</code></pre><p>有些程序员更偏爱这样的风格，因为这样可以将实例域与局部变量明显区分开来。</p>
<p>封装应提供下面三项内容：</p>
<ol>
<li>一个私有的数据域</li>
<li>一个公有的域访问器</li>
<li>一个公有的域更改器方法</li>
</ol>
<p>这样做有如下的好处：</p>
<ul>
<li>可以改变内部实现，除了该类的方法之外，不会影响其他代码。</li>
<li>更改器方法可以执行错误检查，然而直接对域进行赋值将不会进行这些处理。</li>
</ul>
<p>一个方法可以访问所属类的所有对象的私有数据，而不仅限于访问隐式参数的私有特性。C++也有同样的原则。</p>
<p>尽管绝大多数方法都被设计为公有的，但在某些特殊情况下，也可能设计为私有的。</p>
<p>可以将实例域定义为<code>final</code>。构建对象时必须初始化这样的域。也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。</p>
<p><code>final</code>修饰符大都应用于<code>基本数据(primitive)</code>类型域，或<code>不可变类(immutable)</code>的域。对于可变的类，使用<code>final</code>修饰符可能会造成混乱。</p>
<h3 id="u9759_u6001_u57DF_u4E0E_u9759_u6001_u65B9_u6CD5"><a href="#u9759_u6001_u57DF_u4E0E_u9759_u6001_u65B9_u6CD5" class="headerlink" title="静态域与静态方法"></a>静态域与静态方法</h3><p>如果将域定义为<code>static</code>，每个类中只有一个这样的域。它属于类，而不属于任何独立的对象。</p>
<p>静态变量使用得比较少，但静态常量却使用得比较多。例如，在<code>Math</code>类中定义一个静态常量：<code>public static final double PI = 3.1415926;</code>在程序中，可以用<code>Math.PI</code>的形式获得这个常量。</p>
<p>另一个多次使用的静态常量是<code>System.out</code>。</p>
<p>静态方法是一种不能向对象实施操作的方法。例如，Math类的pow方法就是一个静态方法。表达式<code>Math.pow(x,a);</code>计算<code>X^a</code>。在运算时，不使用任何<code>Math</code>的对象，即没有隐式的参数。因为静态方法不能操作对象，所以不能在静态方法中访问实例域。但是，静态方法可以访问自身类中的静态域。</p>
<p>静态方法的一种常见用途。相当于创建实例对象的new。即把创建对象的过程抽象封装出来，可以创建不同名字和返回类型的对象，并且使程序的扩展性和安全性更强。</p>
<p><code>main</code>方法部队任何对象进行操作。事实上，在启动程序时还没有任何一个对象。静态的main方法将执行并创建程序所需要的对象。</p>
<h3 id="u65B9_u6CD5_u53C2_u6570"><a href="#u65B9_u6CD5_u53C2_u6570" class="headerlink" title="方法参数"></a>方法参数</h3><p>Java程序设计语言总是采用值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。</p>
<p>把对象引用作为参数可以改变对象参数状态，因为方法得到的是对象引用的拷贝，对象引用和它的拷贝引用的是同一个对象，所以在对其拷贝进行了更改之后，原来的对象引用也会发生变化。</p>
<p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用进行的是值传递，传递的值是一个拷贝的对象引用并且和原来的对象引用指向的是同一个对象，也因为如此，对这个拷贝的对象引用进行修改，也会对原来的对象产生影响。</p>
<h3 id="u5BF9_u8C61_u6784_u9020"><a href="#u5BF9_u8C61_u6784_u9020" class="headerlink" title="对象构造"></a>对象构造</h3><p>如果多个方法有相同的名字、不同的参数，便产生了重载。编译器通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来判断选择对应的方法。如果编译器找不到匹配的参数，或者找出多个可能的匹配，就会产生编译时错误(此过程称为重载解析(overloading resolution))。</p>
<p>如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值：数值为0、布尔值为false、对象引用为null。这是很不好的习惯。</p>
<p>如果在编写一个类时没有编写构造器，那么系统就会提供一个默认构造器。这个默认构造器将所有的实例域设置为默认值。</p>
<p>如果类中提供了至少一个构造器，但是没有提供默认的构造器，则在构造对象时如果没有提供构造函数参数就会被视为不合法。</p>
<p>由于类的构造器方法可以重载，所以可以采用多种形式设置类的实例域的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值。这是一种很好的设计习惯。</p>
<p>可以在类定义中，直接将一个值赋给任何域。当一个类的所有构造器都希望把相同的值赋给某个特定的实例域时，这种方式特别有用。</p>
<p>初始值不一定是常量。可以调用方法对域进行初始化。</p>
<p>编写很小的构造器时，常常用单个字符命名：</p>
<pre><code>public Employee( String n, double s){
    name = n;
    salary = s;
}
</code></pre><p>这样的话，就只有阅读代码才能了解参数n和s的含义，所以可以用aName和aSalary来代替，这样就可以一眼看出参数的含义。</p>
<p>还有一种常用的技巧，原理如下：参数变量用同样的名字将实例域屏蔽起来，再利用this隐式参数(即被构造的对象)访问实例域：</p>
<pre><code>public Employee( String name, double salary){
    this.name = name;
    this.salary = salary;
}
</code></pre><p>关键字<code>this</code>引用方法的隐式参数。然而这个关键字还有另外一个含义。</p>
<p>如果构造器的第一个语句形如this(…)，这个构造器将调用同一个类的另一个构造器，例子如下：</p>
<pre><code>public Employee(double s){
    // calls Employee( String, double )
    this( Employee #” + nextId, s);
    nextId++;
}
</code></pre><p>当调用new Employee(6000)时，会调用Employee(String,double)构造器。采用这种方式使用this关键字非常有用，这样对公共的构造器代码部分只编写一次即可。</p>
<p>除了在构造器中设置值和在声明中赋值，Java还有第三种机制，称为<code>初始化块(initialization block)</code>。在一个类的声明中可以包含多个代码块。只要构造类的对象，这些块就会被执行。例如：</p>
<pre><code>class Employee{
    public Employee( String n, double s ){
        name = n;
        salary = s;
    }

    public Employee(){
        name = ”;
        salary = 0;
    }
    ........
    private static int nextId;
    private int id;
    private String name;
    private double salary;
    ........
    // object initialization block
    {
        id = nextId;
        nextId++;
    }
}
</code></pre><p>在这个例子中，无论使用哪个构造器构造对象，id域都在对象初始化块(最后的一段)中被初始化。首先运行初始化块，然后才运行构造器的主体部分。这种机制不是必须的，也不常见。建议将初始化块放在域定义之后。</p>
<p><strong>java.util.Random</strong></p>
<ul>
<li><code>Random()</code><ul>
<li>构造一个新的随机数生成器。</li>
</ul>
</li>
<li><code>int nextInt( int n )</code><ul>
<li>返回一个0~n-1之间的随机数。</li>
</ul>
</li>
</ul>
<p>有些面向对象的程序设计语言，特别是C++，有显式的析构器方法，其中反之一些当对象不在使用时需要执行的清理代码。在析构器中，最常见的操作是回收分配格对象的存储空间。由于Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器。</p>
<p>当然，某些对象使用了内存之外的其他资源，例如，文件或使用了系统资源的另一个句柄。在这种情况下，当资源不再需要时，将其回收和再利用将显得十分重要。</p>
<p>可以为任何一个类添加finalize方法。finalize方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能够调用。</p>
<p>如果某个资源需要在使用后立即被关闭，那么就需要人工来管理。可以应用一个类似<code>dispose</code>或<code>close</code>的方法完成相应的清理操作。如果一个类使用了这样的方法，使用完毕一定要记得调用它。</p>
<h3 id="u5305"><a href="#u5305" class="headerlink" title="包"></a>包</h3><p>Java允许使用包(package)将类组织起来。借助于包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。</p>
<p>标准的Java类库分布在多个包中，包括<code>java.lang</code>、<code>java.util</code>、<code>java.net</code>等。标准的Java包具有一个层次结构，所有标准的Java包都在java和javax包层次中。</p>
<p>使用包的主要原因是确保类名的唯一性。Sun公司建议将公司的因特网域名以逆序的形式作为包名，并且不同的项目使用不同的子包。若域名为www.wdx.cn，则包的名字就叫做 cn.wdx。</p>
<p>从编译器的角度来看，嵌套的包之间没有任何关系，每一个都拥有独立的类集合。</p>
<p>一个类可以使用所属包中的所有类，以及其他包中的公有类(public class)。可以使用两种方式访问包中的公有类。第一种就是每个类名前添加完整包名。另一种是使用import语句，可以用import语句导入一个特定的类或者整个包。import语句应位于源文件的顶部(但位于package语句后面)。</p>
<p>还可以使用<code>星号(*)</code>导入一个包：<code>import java.util.*</code></p>
<p>若两个不同包中有相同的类名，则可以添加特定的<code>import</code>语句来解决：<code>import java.util.Date;</code>若有冲突的类名都要用，则在每个类名的前面加上完整的包名。</p>
<p>从Java SE 5.0开始，import语句可以导入静态方法和静态域的功能。例如：<code>import static java.lang.System.*;</code>就可以使用<code>System</code>类的静态方法和静态域，而不必加类名前缀：</p>
<pre><code>out.println(GoodBye!My friend!”);  // i.e,System.out
exit(0);    // i.e., System.exit
</code></pre><p>静态导入的两个最实际的应用：</p>
<ol>
<li>算数函数：如果对Math类使用静态导入，就可以采用更加自然的方式使用静态导入：<code>sqrt( pow( x, 2 ) + pow( y, 2 ))</code></li>
<li>笨重的常量：如果需要使用大量带有冗长名字的常量，就应该使用静态导入，例如<code>calendar</code>类。</li>
</ol>
<p>要想将一个类放入包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前：<code>package cn.wdx;</code></p>
<p>如果没有在源文件中放置package语句，这个源文件中的类就被放置在一个默认包中(default package)。默认包是一个没有名字的包。</p>
<p>标记为<code>public</code>的部分可以被任意的类使用；标记为<code>private</code>的部分只能被定义它们的类使用。如果没有指定<code>public</code>或<code>private</code>，这个部分(类、方法或变量)可以被同一个包中的所有方法访问。</p>
<p>可以通过<code>包密封(package sealing)</code>机制来解决将各种包混杂在一起的问题。如果将一个包密封起来，就不能再向这个包添加类了。</p>
<p>类文件也可以存储在<code>JAR(Java归档)</code>文件中，JAR文件使用ZIP格式组织文件和子目录。<br>为了能使类能够被多个程序共享，需要做到下面几点：</p>
<ul>
<li>把类放到一个目录中。</li>
<li>将JAR文件放在一个目录中</li>
<li>设置类路径(class path)。类路径是所有包含类文件的路径的集合。</li>
</ul>
<p>如果在源代码中添加以专用的界定符/**开始的注释，那么可以很容易地生成一个看上去具有专业水准的文档。</p>
<p>javadoc实用程序(utility)从下面几个特性中抽取信息：</p>
<ul>
<li>包</li>
<li>公有类与接口</li>
<li>公有的和受保护的方法</li>
<li>公有的和受保护的域</li>
</ul>
<p>应该为上面几部分编写注释。注释应该放置在所描述的特性的前面。注释以<code>/**</code>开始，并以<code>*/</code>结束。</p>
<p>每个<code>/**...*/</code>文档注释在标记之后紧跟着自由格式文本(free-form text)。标记由@开始，如<code>@author</code>或<code>@param</code>。</p>
<p>自由格式文本的第一句应该是一个概要性的句子。<code>javadoc</code>实用程序自动地将这些句子抽取出来形成概要页。</p>
<p>在自由格式文本中，可以使用HTML修饰符，例如，用于强调的<code>&lt;em&gt;...&lt;/em&gt;</code>、用于设置等宽打字机”字体的<code>&lt;code&gt;...&lt;/code&gt;</code>、用于着重强调的<code>&lt;strong&gt;...&lt;/strong&gt;</code>以及包含图像的<code>&lt;img...&gt;</code>等。不过一定不要使用<code>&lt;h1&gt;</code>或<code>&lt;hr&gt;</code>，因为它们会与文档的格式产生冲突。</p>
<p>类注释必须放在import语句之后，类定义之前。例子如下：</p>
<pre><code>/**
 * A &lt;code&gt;Card&lt;/code&gt; object represents a playing card,such
 * as Queen of Hearts”. A card has a suit (Diamond, Heart,
 * Spade or Club) and a value ( 1 = Ace, 2....10,11 = Jack,
 * 12 = Queen, 13 = King).
 */
public class Card{
    .....
}
</code></pre><p>每一个方法在注释是必须放在所描述的方法之前。除了通用标记之外，还可以使用下面的标记：</p>
<pre><code>@param variable description
</code></pre><p>这个标记将对当前方法的<code>param(参数)</code>部分添加一个条目。这个描述可以占据多行，并可以使用HTML标记。一个方法的所有<code>@param</code>标记必须放在一起。</p>
<pre><code>@return description
</code></pre><p>这个标记将对当前方法添加<code>return(返回)</code>部分。这个描述可以跨越多行，并可以使用HTML标记。</p>
<pre><code>@throws class description
</code></pre><p>这个标记将添加一个注释，用于表示这个方法有可能抛出异常。</p>
<p>只需要对公有域(通常指的是静态常量)建立文档。例如：</p>
<pre><code>/**
 *  The Hearts” card suit
 */
public static final int HEARTS = 1;
</code></pre><p>用于类文档的注释</p>
<pre><code>@author name
</code></pre><p>这个标记将产生一个author”(作者)条目。可以使用多个@author标记，每个标记对应一个作者。</p>
<pre><code>@version text
</code></pre><p>这个标记将产生一个version”(版本)条目。这里的text可以是对当前版本的任何描述。<br>用于所有文档的注释</p>
<pre><code>@since text
</code></pre><p>这个标记将产生一个since”(始于)条目。这里的text可以是对引入特性的版本描述，例如<code>@since version 1.3.3</code>。</p>
<pre><code>@deprecated text
</code></pre><p>这个标记将对类、方法或变量添加一个不再使用的注释。text中给出了取代的建议。</p>
<pre><code>@see reference
</code></pre><p>这个标记将在see also”部分增加一个超级链接。它可以用于类中，也可以用于方法中。这里的reference可以选择下列情形之一：</p>
<ul>
<li>第一种情况最常见，只要提供类、方法或变量的名字，<code>javadoc</code>就在文档中插入一个超链接。例如，<code>@see cn.wdx.HelloWorld#text()</code> 就会建立一个链接到<code>cn.wdx.HelloWorld</code>类的<code>text</code>方法的超链接。注意要用#”分隔类名与方法名，或类名与变量名。</li>
<li>如果在<code>@see</code>标记后面有一个<code>&lt;</code>字符，就需要指定一个超链接。如果在<code>@see</code>标记后面有一个双引号字符，文本就会显示在<code>see also</code>部分。</li>
<li>可以为一个特性添加多个<code>@see</code>标记，但必须将它们放在一起。</li>
</ul>
<p>想要产生包注释，就需要在每一个包目录中添加一个单独的文件，可以有如下两个选择：</p>
<ol>
<li>提供一个以package.html命名的HTML文件。在标记<code>&lt;BODY&gt;...&lt;/BODY&gt;</code>之间的所有文本都会被抽取出来。</li>
<li>提供一个以<code>package-info.java</code>命名的Java文件。这个文件必须包含一个初始的以<code>/**和*/</code>界定的<code>Javadoc</code>注释，跟随在一个包语句之后。它不应该包含更多的代码或注释。</li>
</ol>
<p>还可以为所有的源文件提供一个概述性的注释。</p>
<p>这个注释被放置在一个名为<code>overview.html</code>的文件中，这个文件位于包含所有源文件的父目录中。标记<code>&lt;BODY&gt;...&lt;/BODY&gt;</code>之间的所有文本都会被抽取出来。</p>
<h3 id="u7C7B_u7684_u8BBE_u8BA1_u6280_u5DE7"><a href="#u7C7B_u7684_u8BBE_u8BA1_u6280_u5DE7" class="headerlink" title="类的设计技巧"></a>类的设计技巧</h3><ul>
<li>一定将数据设计为私有</li>
<li>一定要对数据初始化</li>
<li>不要在类中使用过多的基本数据类型。</li>
<li>不是所有的域都需要独立的域访问器和域更改器。</li>
<li>使用标准格式进行类的定义。</li>
</ul>
<p>采用下列顺序书写类的内容：</p>
<ul>
<li>公有访问特性部分</li>
<li>包作用域访问特性部分</li>
<li>私有访问特性部分</li>
</ul>
<p>在每一部分中应该按照下列顺序列出</p>
<ul>
<li>实例方法</li>
<li>静态方法</li>
<li>实例域</li>
<li>静态域</li>
</ul>
<p>将职责过多的类进行分解</p>
<p>类名和方法名要能够体现它们的职责</p>
<h2 id="u7EE7_u627F"><a href="#u7EE7_u627F" class="headerlink" title="继承"></a>继承</h2><h3 id="u7C7B_u3001_u8D85_u7C7B_u548C_u5B50_u7C7B"><a href="#u7C7B_u3001_u8D85_u7C7B_u548C_u5B50_u7C7B" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h3><p>is-a”关系是继承的一个明显特征，关键字extends表示继承。例如：</p>
<pre><code>class Manager extends Employee{
    .... // Manager类继承了Employee类
}
</code></pre><p>关键字<code>extends</code>表明正在构造的新类派生于一个已存在的类。已存在的类被称为<code>超类(superclass)</code>、<code>基类(base class)</code>或<code>父类(parent class)</code>；新类被称为<code>子类(subclass)</code>、<code>派生类(derived class)</code>或<code>孩子类(child class)</code>。超类和子类是Java程序员最常用的两个术语。</p>
<p>在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。因此在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。</p>
<p>若超类中的某些方法对于子类中并不适用，就需要提供一个新的方法来<code>覆盖(override)</code>超类中的这个方法。但如果在这个新的方法中需要调用超类中的同名方法的时候，可以用<code>super</code>来调用，例如：</p>
<pre><code>public double getSalary(){
    double baseSalary = super.getSalary();
    return baseSalary + bonus;
}
</code></pre><p>在子类中可以增加域、增加方法或覆盖超类的方法，然而绝不能删除继承的任何域和方法。<br>super在构造器中用来调用超类的构造器，例如：</p>
<pre><code>public Manager( String n, double s, int year ){
    super( n, s, year );
    bonus = 0;
}
</code></pre><p>如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则Java编译器将报告错误。</p>
<p>继承并不仅限于一个层次，由一个公共超类派生出来的所有类的集合被称为<code>继承层次(inheritance hierarchy)</code>。在继承层次中，从某个特定的类到其祖先的路径被称为该类的<code>继承链(inheritance chain)</code>。</p>
<p>通常，一个祖先类可以拥有多个子孙继承链。Java不支持多继承。</p>
<p>有一个用来判断是否应该设计为继承关系的简单规则，这就是<code>is-a</code>规则，它表明子类的每个对象也是超类的对象。</p>
<p><code>is-a</code>规则的另一种表述方式是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象置换。</p>
<p>在Java程序设计语言中，对象变量是多态的。一个超类变量既可以引用一个超类对象，也可以引用一个此超类的任何一个子类的对象。然而，不能将一个超类的引用赋给子类变量。</p>
<p>弄清调用对象方法的执行过程十分重要。下面是调用过程的描述：</p>
<p>编译器查看对象的声明类型和方法名。假设调用<code>x.f(param)</code>，且隐式参数<code>x</code>声明为C类的对象。编译器将会一一列举所有<code>C</code>类中名为<code>f</code>的方法和其他超类中访问属性为<code>public</code>且名为<code>f</code>的方法。</p>
<p>至此，编译器已获得所有可能被调用的候选方法。</p>
<p>接下来，编译器查看调用方法时提供的参数类型。如果在所有名为<code>f</code>的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为<code>重载解析(overloading resolution)</code>。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。</p>
<p>至此，编译器已获得需要调用的方法名字和参数类型。</p>
<p>如果是<code>private</code>方法、<code>static</code>方法、<code>final</code>方法或者构造器，那么编译器可以准确地知道应该调用哪个方法，这种调用方式称为静态绑定(static binding)。与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。</p>
<p>当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与<code>x</code>所引用对象的实际类型最合适的那个类的方法。</p>
<p>每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表(method table)，与C++中的VTABLE类似，其中列出了所有方法的签名和实际调用的方法。实际调用时查找此表即可。</p>
<p>动态绑定有一个非常重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展。</p>
<p>不允许扩展的类被称为<code>final</code>类。如果在定义类的时候使用了<code>final</code>修饰符就表明这个类是final类。可以阻止人们定义其子类，如：</p>
<pre><code>final class Executive extends Manager{...}
</code></pre><p>类中的方法也可以被声明为final如果这样做，子类就不能覆盖这个方法(<code>final</code>类中的所有方法自动成为<code>final</code>方法)。如：<code>public final int getValue()</code></p>
<p>将方法或类声明为final的意义在于：确保它们不会在子类中改变语义。</p>
<p>对象引用的转换语法与数值表达式的类型转换类似，仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。</p>
<p>在进行类型转换之前，先查看以下是否能够成功地转换。可以简单地使用instanceof运算符实现，如：</p>
<pre><code>if( staff[1] instanceof Manager){
    boss = (Manager) staff[1];
    ......
}
</code></pre><p>综上所述，有两个原则：</p>
<ol>
<li>只能在继承层次内进行类型转换。</li>
<li>在超类传唤成子类之前，应该使用<code>instanceof</code>检查。</li>
</ol>
<p>一般情况下，应该尽量少用类型转换和<code>instanceof</code>运算符。</p>
<p>如果自下而上仰视类的继承层次结构，位于上层的类更具有通用性，甚至可能更加抽象。从某种角度看，祖先类更加通用，人们只将它作为派生其他类的基类，而不作为想使用的特定实例类。</p>
<p>使用<code>abstract</code>关键字来声明抽象类。</p>
<pre><code>public abstract String getDescription();
// no implementation required
</code></pre><p>为了提高程序的清晰读，包含一个或多个抽象方法的类本身必须被声明为抽象的。除了抽象方法之外，抽象类还可以包含具体数据和具体方法。</p>
<p>抽象方法充当占位的角色，它们的具体实现在子类中。扩展抽象类可以有两种选择。一种是在子类中定义部分抽象方法或抽象方法也不定义，这样就必须将子类也标记为抽象类；另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。</p>
<p>类即使不含抽象方法，也可以将类声明为抽象类。</p>
<p>抽象类不能被实例化，即不能创建抽象类的对象。但是可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。</p>
<ul>
<li>仅对本类可见──private。</li>
<li>对所有类可见──public。</li>
<li>对本包和所有子类可见──protected。</li>
<li>对本包可见──默认。</li>
</ul>
<p>Java中的protected概念要比C++中的安全性差。</p>
<h3 id="Object__u6240_u6709_u7C7B_u7684_u8D85_u7C7B"><a href="#Object__u6240_u6709_u7C7B_u7684_u8D85_u7C7B" class="headerlink" title="Object 所有类的超类"></a>Object 所有类的超类</h3><p><code>Object</code>类是Java中所有类的最终祖先，在Java中每个类都是由它扩展而来的。如果没有明确地指出超类，<code>Object</code>就被认为是这个类的超类。</p>
<p>可以使用<code>Object</code>类型的变量引用任何类型的对象。当然，<code>Object</code>类型的变量只能用于作为各种值的通用持有者。要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的类型转换。</p>
<p>在Java中，只有<code>基本类型(primitive types)</code>不是对象。</p>
<p><code>Object</code>类中的<code>equals</code>方法用于检测一个对象是否等于另一个对象。在<code>Object</code>类中，这个方法将判断两个对象是否具有相同的引用。</p>
<p>Java语言规范要求equals方法具有下面的特性：</p>
<ul>
<li>自反性：对于任何非空引用<code>x</code>，<code>x.equals(x)</code>应该返回<code>true</code>。</li>
<li>对称性：对于任何引用<code>x</code>和<code>y</code>，当且仅当<code>y.equals(x)</code>返回<code>true</code>，<code>x.equals(y)</code>也应该返回<code>true</code>。</li>
<li>传递性：对于任何引用<code>x</code>、<code>y</code>和<code>z</code>，如果<code>x.equals(y)</code>返回<code>true</code>，<code>y.equals(z)</code>返回<code>true</code>，<code>x.equals(z)</code>也应该返回<code>true</code>。</li>
<li>一致性：如果<code>x</code>和<code>y</code>引用的对象没有发生变化，反复调用<code>x.equals(y)</code>应该返回同样的结果。</li>
<li>对于任意非空引用<code>x</code>，<code>x.equals(null)</code>应该返回<code>false</code>。</li>
</ul>
<p>可以从两个截然不同的情况看待getClass的使用：</p>
<ol>
<li>如果子类能够拥有子集的相等概念，则对称性需求将强制采用getClass进行检测。</li>
<li>如果由超类决定相等的概念，那么就可以使用instanceof进行检测，这样就可以在不同子类对象之间进行相等的比较。</li>
</ol>
<p>下面给出编写一个完美的equals方法的建议：</p>
<ul>
<li>显式参数命名为<code>otherObject</code>，稍后需要将它转换称另一个叫做<code>other</code>的变量。</li>
<li>检测<code>this</code>与<code>otherObject</code>是否引用同一个对象：<code>if( this == otherObject ) return true;</code></li>
<li>检测<code>otherObject</code>是否为<code>null</code>，如果为<code>null</code>，返回<code>false</code>。<code>if( otherObject == null ) return false;</code></li>
<li>比较<code>this</code>与<code>otherObject</code>是否属于同一个类。</li>
<li>如果<code>equals</code>语义在每个子类中有所改变，就使用<code>getClass</code>检测：<code>if (getClass() != otherObject.getClass()) return false;</code></li>
<li>如果所有的子类拥有统一的语义，就使用<code>instanceof</code>检测：<code>if( ! ( otherObject instanceof ClassName )) return false;</code></li>
<li>将<code>otherObject</code>转换相应的类型变量：<code>ClassName other = ( ClassName )otherObject;</code></li>
</ul>
<p>现在开始对所有需要比较的域进行比较。使用 <code>==</code> 比较基本类型域，使用<code>equals</code>比较对象域。如果所有都匹配，就返回<code>true</code>，否则返回<code>false</code></p>
<pre><code>return field1 == other.field1
    &amp;&amp; field2.equals(other.field2)
    &amp;&amp; ...;
</code></pre><p>如果在子类中重新定义<code>equals</code>，就要在其中包含调用<code>super.equals(other)</code>。</p>
<p><code>散列码(hash code)</code>是由对象导出的一个整型值，是没有规律的。可以用做来判断对象是否相等。</p>
<p><strong>java.lang.Object</strong></p>
<ul>
<li><code>int hashCode()</code><ul>
<li>返回对象的散列码。散列码可以是任意的整数，包括正数或负数。两个相等的对象要求返回相等的散列码。</li>
</ul>
</li>
<li><code>Class getClass()</code><ul>
<li>返回包含对象信息的类对象。Java提供了类运行时的描述，被封装在Class类中。</li>
</ul>
</li>
<li><code>boolean equals( Object otherObject )</code><ul>
<li>比较两个对象是否相等，如果两个对象指向同一块存储区域，方法放回true；否则方法返回false。在自定义类中，应该覆盖这个方法。</li>
</ul>
</li>
<li><code>String toString()</code><ul>
<li>返回描述该对象值的字符串。在自定义类中，应该覆盖这个方法。</li>
</ul>
</li>
<li><code>Object clone()</code><ul>
<li>创建一个对象的副本。Java运行时系统将为新实例分配存储空间，并将当前的对象复制到这块存储区域中。</li>
</ul>
</li>
</ul>
<p><strong>java.lang.Class</strong></p>
<ul>
<li><code>String getName()</code><ul>
<li>返回这个类的名字。</li>
</ul>
</li>
<li><code>Class getSuperclass()</code><ul>
<li>以Class对象的形式返回这个类的超类信息。</li>
</ul>
</li>
</ul>
<p>在<code>Object</code>中还有一个重要的方法，就是<code>toString</code>方法，它用于返回表示对象值的字符串。绝大多数的<code>toString</code>方法都遵循这样的格式：类的名字，随后是一对方括号括起来的域值。</p>
<p>如果<code>x</code>是任意一个对象，并调用<code>System.out.println(x)</code>; 就会直接调用<code>x.toString()</code>，并打印输出得到的字符串。</p>
<h3 id="u6CDB_u578B_u6570_u7EC4_u5217_u8868"><a href="#u6CDB_u578B_u6570_u7EC4_u5217_u8868" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h3><p>在Java SE 5.0中，<code>ArrayList</code>是一个采用<code>类型参数(type parameter)</code>的<code>泛型类(generic class)</code>。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面。下面声明和构造一个保存<code>Employee</code>对象的数组列表：</p>
<pre><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;();
</code></pre><p>使用<code>add</code>方法可以将元素添加到数组列表中。如果调用<code>add</code>且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。</p>
<p>如果已经清楚或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用<code>ensureCapacity</code>方法：</p>
<pre><code>staff.ensureCapacity(100);
</code></pre><p>这个方法调用将分配一个包含100个对象的内部数组。然后调用100次add，而不用重新分配空间。</p>
<p><strong>java.util.ArrayList<t></t></strong></p>
<ul>
<li><code>ArrayList&lt;T&gt;</code><ul>
<li>构造一个空数组列表</li>
</ul>
</li>
<li><code>ArrayList&lt;T&gt;(int initialCapacity)</code><ul>
<li>用指定容量initialCapacity构造一个空数组列表</li>
</ul>
</li>
<li><code>boolean add(T obj)</code><ul>
<li>在数组列表的尾端添加一个元素obj。永远返回true。</li>
</ul>
</li>
<li><code>int size()</code><ul>
<li>返回存储在数组列表中的当前元素数量。(这个值将小于或等于数组列表的容量)</li>
</ul>
</li>
<li><code>void ensureCapacity(int capacity)</code><ul>
<li>确保数组列表在不重新分配存储空间的情况下就能够保存给定数量的元素。</li>
</ul>
</li>
<li><code>void trimToSize()</code><ul>
<li>将数组列表的存储容量削减到当前尺寸。</li>
</ul>
</li>
<li><code>void set( int index, T obj )</code><ul>
<li>设置数组列表指定位置的元素值，此操作将覆盖这个位置的原有内容。</li>
</ul>
</li>
<li><code>T get( int index )</code><ul>
<li>获得指定位置的元素值。</li>
</ul>
</li>
<li><code>void add( int index, T obj )</code><ul>
<li>向后移动元素，以便插入元素。</li>
</ul>
</li>
<li><code>T remove( int index )</code><ul>
<li>删除一个元素并将后面的元素向前移动。被删除的元素由返回值返回。</li>
</ul>
</li>
</ul>
<p>数组列表自动扩展容量的便利增加了访问元素语法的复杂程度。使用<code>get</code>和<code>set</code>方法实现访问或改变数组元素的操作。例如：</p>
<pre><code>staff.set(i,harry);
Employee e = staff.get(i);
</code></pre><p>使用<code>add</code>方法为数组添加新元素，而不要使用<code>set</code>方法，它只能替换数组中已经存在的元素内容。</p>
<p>也可以使用<code>for each</code>循环对数组列表遍历：</p>
<pre><code>for(Employee e : staff)
    do something with e
</code></pre><p>请注意下面的变化：</p>
<ul>
<li>不必指出数组的大小。</li>
<li>使用<code>add</code>将任意多的元素添加到数组中。</li>
<li>使用<code>size()</code>替代<code>length</code>计算元素的数目。</li>
<li>使用<code>a.get(i)</code>替代<code>a[i]</code>访问元素。</li>
</ul>
<h3 id="u5BF9_u8C61_u5305_u88C5_u5668_u4E0E_u81EA_u52A8_u6253_u5305"><a href="#u5BF9_u8C61_u5305_u88C5_u5668_u4E0E_u81EA_u52A8_u6253_u5305" class="headerlink" title="对象包装器与自动打包"></a>对象包装器与自动打包</h3><p>有时，需要将int这样的基本类型转换为对象。所有的基本类型都有一个与之对应的类。例如，Integer类对应基本类型int。通常，这些类称为包装器(wrapper)。对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。对象包装器类还是final，因此不能定义它们的子类。</p>
<p>假设想定义一个整型数组列表。而尖括号中的类型参数不允许是基本类型，也就是说，不允许写成<code>ArrayList&lt;int&gt;</code>。这里就用到了<code>Integer</code>对象包装器类。我们可以声明一个<code>Integer</code>对象的数组列表。</p>
<pre><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
</code></pre><p>Java SE 5.0的另一个改进之处是更加便于添加或获得数组元素。</p>
<p><code>list.add(3);</code> 将自动变成 <code>list.add(new Integer(3));</code></p>
<p>这种变换被称为<code>自动打包(autoboxing)</code>。</p>
<p>相反的，当将一个<code>Integer</code>对象赋给一个<code>int</code>值时，会自动地拆包。包含在包装器中的内容不会改变。不能使用这些使用这些包装器类创建修改数值参数的方法。如果想要修改参数值的方法，就要使用<code>持有者(holder)</code>类型。</p>
<p>最后强调以下，打包和拆包是<strong>编译器</strong>认可的，而不是虚拟机。</p>
<p><strong>java.lang.Integer</strong></p>
<ul>
<li><code>int intValue()</code><ul>
<li>以int的形式返回Integer对象的值。</li>
</ul>
</li>
<li><code>static String toString( int i )</code><ul>
<li>以一个新String对象的形式返回给定数值 i 的十进制表示。</li>
</ul>
</li>
<li><code>static String toString( int i, int radix )</code><ul>
<li>返回数值 i 的基于给定radix参数进制的表示。</li>
</ul>
</li>
<li><code>static int parseInt( String s )</code></li>
<li><code>static int parseInt( String s, int radix )</code><ul>
<li>返回字符串 s 表示的整型数值，给定字符串表示的十进制的整数，或者是radix参数进制的整数。</li>
</ul>
</li>
<li><code>static Integer valueOf( String s )</code></li>
<li><code>static Integer valueOf( String s, int radix )</code><ul>
<li>返回用 s 表示的整型数值进行初始化后的一个新Integer对象，给定字符串表示的是十进制的整数，或者是radix参数进制的整数。</li>
</ul>
</li>
</ul>
<p><strong>java.text.NumberFormat</strong></p>
<ul>
<li><code>Number parse( String s )</code><ul>
<li>返回数字值，假设给定的String表示了一个数值。</li>
</ul>
</li>
</ul>
<h3 id="u53C2_u6570_u6570_u91CF_u53EF_u53D8_u7684_u65B9_u6CD5"><a href="#u53C2_u6570_u6570_u91CF_u53EF_u53D8_u7684_u65B9_u6CD5" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h3><p>可以用省略号…表明这个方法可以接收任意数量的对象。例如</p>
<pre><code>public static double max( double... values){
    double largest = Double.MIN_VALUE;
    for( double v : values) if (v &gt; largest ) largest = v;
    return largest;
}
</code></pre><h3 id="u679A_u4E3E_u7C7B"><a href="#u679A_u4E3E_u7C7B" class="headerlink" title="枚举类"></a>枚举类</h3><pre><code>public enum Size{ SMALL, MEDIUM, LARGE, EXTRA_LARGE };
</code></pre><p>实际上，这个声明定义的类型是一个类，它刚好有4个实例，在此尽量不要构造新对象。如果需要的话，可以在枚举类型中添加一些构造器、方法和域。当然构造器只是在构造枚举常量的时候被调用。</p>
<p>每个枚举类型都有一个静态的<code>values</code>方法，它将返回一个包含全部枚举值的数组。</p>
<p><strong>java.lang.Enum<e></e></strong></p>
<ul>
<li><code>static Enum valueOf( Class enumClass, String name )</code><ul>
<li>返回指定名字、给定类的枚举常量。</li>
</ul>
</li>
<li><code>String toString()</code><ul>
<li>返回枚举常量名。</li>
</ul>
</li>
<li><code>int ordinal()</code><ul>
<li>返回枚举常量在enum声明中的位置，位置从 0 开始计数。</li>
</ul>
</li>
<li><code>int compareTo(E other)</code><ul>
<li>如果枚举常量出现在other之前，则返回一个负值；如果this == other，则返回 0；否则，返回正值。枚举常量的出现次序在enum声明中给出。</li>
</ul>
</li>
</ul>
<h3 id="u53CD_u5C04"><a href="#u53CD_u5C04" class="headerlink" title="反射"></a>反射</h3><p><code>反射库(reflection library)</code>提供了一个非常丰富且精心设计的工具集，以便能编写能够动态操纵Java代码的程序。使用反射，Java可以支持Visual Basic用户习惯使用的工具。特别是在设计或运行中添加新类时，能够快速地应用开发工具动态地查询新添加类的能力。</p>
<p>能够分析类能力的程序被称为反射(reflective)。反射机制的功能极其强大。可以用反射机制：</p>
<ul>
<li>在运行中分析类的能力。</li>
<li>在运行中查看对象，例如，编写一个toString方法供所有类使用。</li>
<li>实现数组的操作代码。</li>
<li>利用Method对象，这个对象很像C++中的函数指针。</li>
<li>反射是一种功能强大且复杂的机制。使用它的主要对象是工具构造者。</li>
</ul>
<h2 id="u9644_u5F551_Cpp_u6CE8_u91CA"><a href="#u9644_u5F551_Cpp_u6CE8_u91CA" class="headerlink" title="附录1 Cpp注释"></a>附录1 Cpp注释</h2><blockquote>
<p>Java的类与C++的类</p>
</blockquote>
<p>Java中的所有函数都属于某个类的方法(标准术语称其为方法，而不是成员函数)。因此，Java中的所有函数都必须有一个外壳类并且<code>main</code>方法必须是静态的。如果<code>main</code>方法正确退出，那么Java应用程序的退出代码为0，如果想要在终止程序的时候返回其他代码，那就需要调用<code>System.exit</code>方法。</p>
<blockquote>
<p>Java的整型与C++的整型</p>
</blockquote>
<ul>
<li>在C和C++中，int表示的整型与目标机器相关。Java没有任何无符号类型(unsigned type)。</li>
<li>boolean值的不同</li>
<li>在C++中，数值或指针可以代替boolean值。0相当于false，非0值相当于true。在Java中就不行。</li>
</ul>
<blockquote>
<p>变量的声明与定义</p>
</blockquote>
<p>C和C++中变量的声明与定义是不同的。在Java中，不区分变量的声明与定义。</p>
<blockquote>
<p>const</p>
</blockquote>
<p><code>const</code>是Java的保留关键字，但目前并未使用，必须用<code>final</code>定义常量。</p>
<blockquote>
<p>移位操作</p>
</blockquote>
<p>在C和C++中无法确定 <code>&gt;&gt;</code> 操作执行的是算数移位(扩展符号位)，还是逻辑移位(高位填0)。实际上在C和C++中，<code>&gt;&gt;</code> 运算符实际上是只为非负数定义的。Java消除了这种含糊性。</p>
<blockquote>
<p>boolean的强制类型转换</p>
</blockquote>
<p>不要在boolean类型与任何数值类型之间进行强制类型转换，这样可能防止发生错误。</p>
<blockquote>
<p>逗号运算符？</p>
</blockquote>
<p>与C和C++不同，Java不使用逗号运算符，不过可以在for语句中用逗号隔开表达式列表。</p>
<blockquote>
<p>Java中的字符串</p>
</blockquote>
<p>与C++不同，Java字符串更加像char*指针，自动的垃圾回收也可以避免内存泄露。</p>
<blockquote>
<p>流程结构</p>
</blockquote>
<p>Java的控制流程功能结构与C和C++的控制流程结构一样，只有很少的例外情况。没有goto语句，但break语句可以带标签，可以利用它实现从内层循环跳出的目的。还有一种变形的for循环，类似于C#中的foreach循环。</p>
<blockquote>
<p>嵌套的块</p>
</blockquote>
<p>在C++中，可以在嵌套的块中重定义一个变量。在内层定义的变量会覆盖在外层定义的变量。这样，有可能导致程序设计错误，因此在Java中不允许这样做。</p>
<blockquote>
<p>运算符重载</p>
</blockquote>
<p>与C++不同，Java没有提供运算符重载功能。Java语言的设计者确实为字符串的连接重载了+运算符，但是没有重载其他运算符，也没有给Java程序员自己重载运算符的权利。</p>
<blockquote>
<p>Java数组与C++数组</p>
</blockquote>
<p>Java数组与C++数组在堆栈上有很大不同，但基本上与分配在堆(heap)上的数组指针一样。Java中的[]运算符被预定义为检查数组边界，而且没有指针运算，不能通过数组名加1来得到数组的下一个元素。</p>
<blockquote>
<p>Java对象变量</p>
</blockquote>
<p>在C++中没有空引用，并且引用不能被赋值。我们可以将Java的对象看作C++的对象指针。在Java中指针问题不再困扰。如果使用一个没有初始化的指针，系统就会产生一个运行时错误，而不是随机的结果。垃圾收集器会处理内存管理问题。</p>
<blockquote>
<p>更改器和访问器</p>
</blockquote>
<p>在C++中，带有const后缀的方法是访问器方法；默认为更改器方法。Java中，访问器方法与更改器方法语法上没有明显的区别。</p>
<blockquote>
<p>Java的构造器</p>
</blockquote>
<p>Java构造器的工作方式与C++一样。但是，要记住所有的Java对象都是在堆中构造的，构造器总是伴随着new操作符一起使用。C++程序员最容易犯得作物就是忘记new操作符。</p>
<blockquote>
<p>Java的内部定义</p>
</blockquote>
<p>在C++中，通常在类的外面定义方法，如果在类的内部定义方法，这个方法就自动成为内联方法。在Java中，所有的方法都必须在类的内部定义，但并不表示它们是内联方法。</p>
<blockquote>
<p>static的不同含义</p>
</blockquote>
<p>Java中的静态域与静态方法在功能上与C++相同。但是语法却有不同。C中static有三种含义：</p>
<ul>
<li>表示退出一个块后依然存在的局部变量。</li>
<li>不能被其他文件访问的全局变量和函数。</li>
<li>属于类且不属于类对象的变量和函数。这个含义与Java相同。</li>
</ul>
<blockquote>
<p>值调用和引用调用</p>
</blockquote>
<p>C++有值调用和引用调用，用<code>&amp;</code>符号标记，可以实现修改它们的引用参数的目的。而Java则不行，Java只有值调用。</p>
<blockquote>
<p>初始化</p>
</blockquote>
<p>在C++中，不能直接初始化实例域。所有的域必须在构造器中设置。但是，有一个特殊的初始化器列表语法。C++使用这种特殊的语法来调用域构造器。在Java中没有这种必要，因为对象没有子对象，只有指向其他对象的指针。</p>
<blockquote>
<p>构造器</p>
</blockquote>
<p>在Java中，this引用等价于C++的this指针。但是，在C++中，一个构造器不能调用另一个构造器。在C++中，必须将抽取初的公共初始代码编写成一个独立的方法。</p>
<blockquote>
<p><code>#include与import</code></p>
</blockquote>
<p>这两者并没有共同之处。在C++中，必须使用#include将外部特性的声明加载近来，因为C++编译器无法查看任何文件的内部，除了正在编译的文件以及在头文件中明确包含的文件。Java编译器可以查看其他文件的内部。</p>
<p>在Java中，通过显式地给出包名，就可以不使用import；而在C++中，无法避免使用#include。</p>
<p>在C++中，与包机制类似的是命名空间(namespace)。在Java中，package与import语句类似C++中的namespace和using指令(directive)。</p>
<blockquote>
<p>Java的继承和C++的继承</p>
</blockquote>
<p>Java与C++定义继承类的方式十分相似。Java用关键字extends代替了C++的冒号(:)。在Java中，所有的继承都是公有继承，而没有C++中的私有继承和保护继承。</p>
<blockquote>
<p>调用超类及虚拟方法</p>
</blockquote>
<p>在Java中使用关键字super调用超类的方法，而在C++中则采用超类名加上::操作符的形式。</p>
<p>在Java中，不需要将方法声明为虚拟方法。动态绑定是默认的处理方式。如果不希望让一个方法具有虚拟特性，可以将它标记为final。</p>
<blockquote>
<p>根类</p>
</blockquote>
<p>C++中没有类似Java中Object的根类，不过每个指针都可以转换成<code>void*</code>。</p>
<h2 id="u9644_u5F552_Java_u6CE8_u91CA_u4E0E_u8B66_u544A"><a href="#u9644_u5F552_Java_u6CE8_u91CA_u4E0E_u8B66_u544A" class="headerlink" title="附录2 Java注释与警告"></a>附录2 Java注释与警告</h2><ul>
<li><code>System.out</code>中的<code>println</code>方法输出后自动换行，而<code>print</code>方法不换行。</li>
<li><code>/*...*/</code>注释不能嵌套。</li>
<li>Java有一个能够表示任意精度的算数包，通常称为大数值”(big number)，并不是一种新的类型，而是一个Java对象。</li>
<li>在JDK5.0中，可以使用十六进制表示浮点数值，使用p表示指数，尾数采用十六进制，指数采用十进制。指数的基数是2。</li>
<li>浮点数值不适用于禁止出现舍入误差的金融计算中。</li>
<li><code>&amp;</code> 和 <code>|</code> 运算符应用于布尔值，得到的结果也是布尔值，不按短路”方式计算。</li>
<li>如果试图将一个数值从一种类型强制转换为另一种类型，而又超出了目标类型的表示范围，就会成为一个完全不同的值。</li>
</ul>
<p>因为输入是可见的，所有Scanner类不适用于从控制台读取密码。Java SE 6特别引入了Console类实现这个目的。要想读取一个密码，可以采用下列代码</p>
<pre><code>Console cons = System.console();
String username = cons.readLine(User name: ”);
char[] passwd = cons.readPassword(Password: ”);
</code></pre><p>为了安全起见，返回的密码存放在一维字符数组中，而不是字符串中。在对密码进行处理后，应该马上用一个填充值覆盖数组元素。采用Console对象处理输入不如采用Scanner对象方便。</p>
<ul>
<li>可以构造一个带有字符串参数的Scanner，但这个Scanner将字符串解释为数据，而不是文件名。</li>
<li>在循环中，检测两个浮点数是否相等需要格外小心。</li>
<li>可以使用下面两种形式声明数组：<code>int[] a;</code> 或 <code>int a[];</code> 大多数Java应用程序员喜欢第一种。</li>
<li>在Java中允许数组长度为0。数组长度为0与null不同。</li>
<li>类的方法在前面，域在后面这种风格有易于促使人们更加关注接口的概念，削减对实现的注意。</li>
<li>不要在构造器中定义与实例域重名的局部变量。</li>
<li>注意不要编写返回引用可变对象的访问器方法，这样会破坏封装性！如果需要返回一个可变对象的引用，应该首先对它进行克隆(clone)。</li>
<li>在绝大多数的面型对象程序设计语言中，静态域被称为类域。术语<code>static</code>只是沿用了C++的叫法，并无实际意义。</li>
<li>可以使用对象调用静态方法。不过这种方式很容易造成混淆，建议使用类名来调用静态方法。</li>
<li>每一个类可以有一个<code>main</code>方法。这是一个常用于对类进行单元测试的技巧。</li>
<li>Java允许重载任何方法。因此，要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的签名(signature)。返回类型不是方法签名的一部分。</li>
<li>如果文档中有到其他文件的链接，例如，图像文件(用户界面的组建的图表或图像等)，就应该将这些文件放到子目录<code>doc-files</code>中。<code>javadoc</code>实用程序将从源目录拷贝这些目录中及其中的文件到文档目录中。在联接种需要使用<code>doc-files</code>目录，例如：<code>&lt;img src=doc-files/uml.png” alt = UML diagram”&gt;</code>。</li>
<li>注释时没必要在每一行开始用星号<code>*</code>，大部分IDE会自动添加星号<code>*</code>。</li>
<li>关键字<code>this</code>有两个用途：一是引用隐式参数，二是调用该类其他的构造器。同样，<code>super</code>关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。</li>
<li>在覆盖一个方法时，子类方法不能低于超类方法的可见性。特别是，如果超类方法是<code>public</code>，子类方法一定要声明为<code>public</code>。</li>
<li>域也可以被声明为<code>final</code>，一旦如此，构造对象之后就不允许修改其值了。不过如果将一个类声明为<code>final</code>，只有其中的方法自动称为<code>final</code>，而不包括域。</li>
<li>强烈建议为自定义的每一个类增加<code>toString</code>方法。这样做不仅自己受益，而且所有使用这个类的程序员也会受益匪浅。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里是我学习 Java 黄皮书时记录整理的笔记，时间比较久远，不保证时效性。</p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://wdxtub.com/tags/Java/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cpp 学习笔记]]></title>
    <link href="http://wdxtub.com/2016/03/20/cpp-note/"/>
    <id>http://wdxtub.com/2016/03/20/cpp-note/</id>
    <published>2016-03-20T12:00:11.000Z</published>
    <updated>2016-03-20T12:49:03.000Z</updated>
    <content type="html"><![CDATA[<p>这里是我学习《Thinking in C++》时记录整理的笔记，时间比较久远，不保证时效性。</p>
<a id="more"></a>
<hr>
<h2 id="u7B2C1_u7AE0__u5BF9_u8C61_u5BFC_u8A00"><a href="#u7B2C1_u7AE0__u5BF9_u8C61_u5BFC_u8A00" class="headerlink" title="第1章 对象导言"></a>第1章 对象导言</h2><p>本章将介绍面向对象程序设计(OOP)的基本概念，包括OOP开发方法的概述。</p>
<p>所有的程序语言都提供抽象。可以说，人们能解决的问题的复杂性直接与抽象的类型和质量有关。汇编语言时对底层机器的小幅度抽象。其后的许多所谓“命令式”语言(例如Fortran、Basic和C)都是对汇编语言的抽象。OPP允许程序员用问题本市的术语来描述问题，而不是用要运行解决方案的计算机的术语来描述问题。每个对象看上去像一台小计算机，它有状态，有可执行的运算。这似乎是现实世界中对象的很好类比，它们都有特性和行为。</p>
<p>面向对象语言的五个基本特性：</p>
<ol>
<li>万物皆对象。</li>
<li>程序就是一组对象，对象之间通过发送消息互相通知做什么。</li>
<li>每个对象都有它子集的由其他对象构成的存储区。</li>
<li>每个对象都有一个类型。</li>
<li>一个特定类型的所有对象都能接收相同的消息。</li>
</ol>
<p>创建抽象数据类型是面向对象程序设计的基本思想。抽象数据类型几乎能完全像内部类型一样工作。</p>
<p>类描述了一组有相同特性(数据元素)和相同行为(功能)的对象，因此类实际上就是数据类型。面向对象程序设计的难题之一，是在问题空间中的元素和解空间中的对象之间建立一对一的映射。</p>
<p>必须有一种方法能向对象作出请求，使得它能做某些事情。可以向对象发出的请求是由它的<code>接口(interface)</code>定义的，而接口由类型确定。接口规定我们能向特定的对象发出什么请求。然后，必须有代码满足这种请求，再加上隐藏的数据，就组成了<code>实现(implementation)</code>。</p>
<p>C++语言使用了三个明确的关键字来设置类中的边界：<code>public</code>、<code>private</code>和<code>protected</code>。<code>public</code>意味着随后的定义对所有人都可用。相反，<code>private</code>关键字则意味着，除了该类型的创建者和该类型的内部成员函数之外，任何人都不能访问这些定义。继承的类可以访问<code>protected</code>成员，但不能访问<code>private</code>成员。</p>
<p>代码重用是面向对象程序设计语言的最大优点之一。可以用任何数量和类型的其他对象组成新类，通过组合得到新类所希望的功能。因为这是由已经存在的类组成新类，所以称为<code>组合(composition)</code>【或者更通常称为<code>聚合(aggregation)</code>】。组合常常被称为<code>has-a(有)</code>关系。</p>
<p>当创建新类时，程序员应当首先考虑组合，因为它更简单和更灵活。如果采用组合的方法，设计将变得清晰。</p>
<p>克服许多困难去创造一个类，并随后强制性地创造一个有类似功能地全新地类，似乎很愚蠢。如果能选取已存在地类、克隆它，然后对这个克隆增加和修改，则是再好不过地事。这是<code>继承(inheritance)</code>带来地好处，缺点是，如果原来的类(称为基类、超类或父类)被修改，则这个修改过的“克隆”(称为派生类、继承类或子类)也会表现出这些改变。</p>
<p>当我们从已经存在的类型来继承时，我们就创造了一个新类型。这个新类性不仅包含那个已经存在的类型的所有成员，还复制了这个基类的接口，这意味着这个派生类与这个基类是相同类型的。</p>
<p>有两种方法能使新派生类区别于原始基类。第一种相当直接，简单地向派生类添加全新的函数。这些新函数不是基类接口的一部分。着意味着，这个基类不能做我们希望它做的事情，所以必须添加函数。</p>
<p>虽然继承有时意味着向接口添加新函数，但这未必真的需要。是新类有别于基类的第二个和更重要的方法是，改变已经存在的基类函数的行为，这称为<code>重载(overriding)</code>这个函数。为了重载函数，可以简单地再派生类中创建新定义。相当于说：“我正再使用同一个接口函数，但是我希望它为我做不同的事情。”</p>
<p>只重载基类(并且不添加基类中没有的新成员函数)的继承意味着派生类和基类是完全相同的类型，因为它们有相同的接口。结果是，我们可以用派生类的对象代替基类的对象。因此这被认为是<code>纯代替(pure substitution)</code>，常常被称为<code>代替原则(substitution principle)</code>。这种情况下，我们常把基类和派生类直接的关系看作是一个<code>is-a(是)</code>关系。</p>
<p>有时需要向一个派生类型添加新的接口元素，这样就扩展了接口并创建了新类型。这个新类型仍然可以代替这个基类，但这个代替不是完美的，因为这些新函数不能从基类访问，这可以描述为“is-like-a(像)”关系。</p>
<p>如果试图把派生类型的对象看做是比它们自身更一般的基本类型(圆形看做形体，自行车看做车辆)，这里就有一个问题：如果一个函数告诉一个一般的形体去绘制它子集，或者告诉一个一般的车辆去行驶，则编译器再编译时就不能确切地知道应当执行哪段代码。同样地问题是，消息发送时，程序员并不想知道将执行哪段代码。编译器不能确切地知道执行哪段代码，那么它应该怎么办呢？</p>
<p>在面向对象的程序设计中，答案非常新奇：编译器并不做传统意义上的函数调用。非OOP编译器产生的函数调用会导致与被调用代码的<code>早捆绑(early binding)</code>，其意思是：编译器会对特定的函数名产生调用，而连接器将这个调用解析为要执行代码的绝对地址。</p>
<p>在OOP中，知道程序运行时，编译器才能确定执行代码的地址，所以，当消息被发送给一般对象时，需要采用其他的方案。为了解决这一问题，面向对象语言采用<code>晚捆绑(late binding)</code>的思想。当给对象发送消息时，在程序运行时才去确定被调用的代码。编译器保证这个被调用的函数存在，并执行参数和返回值的类型检查【其中不采用这种处理方式的语言称为<code>弱类型(weakly typed)</code>语言】，但是它并不知道将执行的确切代码。</p>
<p>为了执行晚捆绑，C++编译器在真正调用的地方插入一段特殊的二进制代码。通过使用存放在对象自身中的信息，这段代码在运行时计算被调用函数函数体的地址(详见第15章)。这样每个对象就能根据这段二进制代码的内容有不同的行为。当一个对象接收到消息时，它根据这个消息判断应当做什么。</p>
<p>我们可以用关键字<code>virtual</code>声明他希望某个函数有晚捆绑的灵活性。在C++中，必须记住添加<code>virtual</code>关键字，因为根据规定，默认情况下成员函数不能动态捆绑。<code>virtual</code>函数(虚函数)可用来表示出在相同家族中的类具有不同的行为。这些不同是产生多态行为的原因。<br>我们把处理派生类型就如同处理其基类型的过程称为<code>向上类型转换(upcasting)</code>。编译器和运行系统可以处理这些细节，我们只需要知道它会这样做和知道如何用它设计程序就行了。如果一个成员函数是<code>virtual</code>的，则当我们给一个对象发送消息时，这个对象将做正确的事情，即使是在有向上类型转换的情况下。</p>
<p>对象的数据存放在何处？如何控制对象的生命期？不同的设计语言有不同的处理方式。C++才去的方法是把效率控制作为最重要的问题，所以它为程序员提供了一个选择。为了最大化运行速度，通过将对象存放在栈中或静态存储区域中，存储和生命期可以在编写程序时确定。栈是内存中的一个区域，可以直接由微处理器在程序执行期间存放数据。在栈中的变量有时称<code>自动变量(automatic variable)</code>或<code>局部变量(scoped variable)</code>。静态存储区简单说是内存的一个固定块，在程序开始执行以前分配。使用栈或静态存储区，可以快速分配和释放，但是我们因此也牺牲了灵活性。</p>
<p>第二种方法是在称为<code>堆(heap)</code>的区域动态创建对象。用这种方法，可以直到运行时还不知道需要多少个对象，它们的生命期是什么和他们的准确数据类型是什么。这些决定是在程序运行之中作出的。如果需要心的对象，直接使用<code>new</code>关键字让它在堆上生成。当使用结束时，用关键字<code>delete</code>释放。</p>
<p>另一个问题是对象的生命期。如果在栈上或在静态存储上创建一个对象，编译器决定这个对象持续多长时间并能自动销毁它。然后，如果在堆上创建它，编译器则不知道它的生命期。在C++中，程序员必须编程决定何时销毁此对象。作为一个替换，运行环境可以提供一个称为<code>垃圾收集器(garbage collector)</code>的功能。当然，使用垃圾收集器编写程序是非常方便的，但是它需要所有应用软件能承受垃圾收集器的存在及垃圾收集的系统开销。</p>
<p>从程序设计语言出现开始，错误处理就是最重要的问题之一。因为设计一个好的错误处理方案非常困难，许多语言忽略这个问题，将这个问题转交给库的设计者，而库的设计者往往采取不彻底的措施，即可以在许多情况下起作用，但很容易被绕考，通常是被忽略。</p>
<p><code>异常处理(exception handling)</code>将错误处理直接与程序设计语言甚至有时是操作系统联系起来。异常是一个对象，它在出错的地方被抛出，并且被一段用以处理特定类型错误的<code>异常处理代码(exception handler)</code>所接收。异常处理似乎是另一个并行的执行路径，在出错的时候被调用。由于它使用一个单独的执行路径，它并不需要干涉正常的执行代码。因为不需经常检查错误，代码可以很简洁。另外，异常并不同于一个由函数返回的错误值或标记，后两者可以被忽略，而异常不能被忽略，必须保证它们在某些点上进行处理。最后，异常提供了一个从错误状态中进行可靠恢复的方法。除了从这个程序中退出以外，我们常常还可以作出正确的设置，并且回复程序执行，这有助于产生更健壮的系统。</p>
<p><code>方法(method)</code>［通常称为方法论(methodology)］是一系列的过程和探索，用以降低程序设计问题的复杂性。</p>
<p>经历开发过程时，最重要的问题是：不要迷路。如果不定因素不止一个，在没有创建一个能工作的原型之前，不要计划它将用多长时间和花费多少，这里的自由度太大了。</p>
<p>应当牢记我们正在努力寻找的是什么：</p>
<ul>
<li>什么是对象(如何将项目分成多个组成部分？)</li>
<li>它们的接口是什么？(需要向每个对象发送什么信息？)</li>
<li>整个过程可以分5个阶段完成，阶段0只是使用一些结构的初始约定。</li>
</ul>
<p>我们必须首先决定在此过程中应当有哪些步骤。无论建造什么系统，不管如何复杂，都有其基本的目的，有其要处理的业务，有所满足的基本需要。通过各种观察，我们将最终找出它的核心，通常简单而又直接。</p>
<p>这个相当重要，因为它设定了项目的基调，这是一种任务陈述。我们不必一开始就让它正确，但是要不停地努力使其越来越正确。</p>
<p>这一阶段我们有必要把注意力始终放在核心问提上：确定这个系统要做什么。为此，最有价值的工具是一组所谓的<code>用例(use case)</code>。用例之明了系统中的关键特性，它们将展现我们使用的一些节本的类。它们实际上是对类似于下列问题的描述性回答：</p>
<ul>
<li>“谁将使用这个系统？”</li>
<li>“执行者用这个系统做什么？”</li>
<li>“执行者如何用这个系统工作？”</li>
<li>“如果其他人也做这件事，或者同一个执行者有不同的目标，该怎么办？(揭示变化)”</li>
<li>“当使用这个系统时，会发生什么问题？(揭示异常)”</li>
</ul>
<p>只要符合用户的使用感受，系统实际上如何实现并不重要。</p>
<p>在这一阶段，我们必须作出设计，描述这些类和它们如何交互。确定类和交互的出色技术就是：<strong>类职责协同(Class-Responsibility-Collaboration，CRC)卡片</strong>。</p>
<p>这个技术非常简单：只要有一组小空白卡片，在上面书写。每张卡片描述一个类，所写的内容有：</p>
<ul>
<li>类的名字。体现类行为的本质，一目了然的作用。</li>
<li>类的职责。它应当做什么。通常，它可以仅由成员函数的名字陈述。</li>
<li>类的协同：它与其他类有哪些交互？如果一张小卡片上放不下类所需要的信息，那么这个类就太复杂了(或者是考虑过细了，或者应当创建多个类)。理想的类应该一目了然。</li>
</ul>
<p>对象开发准则：</p>
<ul>
<li>让特定问题生成一个类，然后在解决其他问题期间让这个类生长和成熟。</li>
<li>记住，发现所需要的类(和它们的接口)，是设计系统的主要内容。如果已经有了那些类，这个项目就不困难了。</li>
<li>不要强迫自己在一开始就知道每一件事情，应当不断学习。</li>
<li>开始编程，让一部分能够运行，这样就可以证明或否定已生成的设计。不要害怕过程型大杂烩式的代码──类的隔离性可以控制它们。坏的类不会破坏好的类。</li>
<li>尽量保持简单。具有明显用途的不太清楚的对象比很复杂的接口好。从小的和简单的类开始，当我们对它有了较好的理解时再拓展这个类接口，但是很难从一个类中删去元素。</li>
</ul>
<p>这是从粗线条设计向便宜和执行可执行代码体的最初转换阶段，特别是，它将证明或者否定我们的体系结构。这不是一遍的过程，而是反复地建立系统的一系列步骤的开始。</p>
<p>一旦代码框架运行起来，我们增加的每一组特征本身就是一个小项目。在一次<code>迭代(iteration)</code>期间，我们增加一组特征，一次迭代是一个相当短的开发时期。</p>
<p>理想情况下，每次迭代为一到三个星期，在这个期间的最后，我们得到一个集成的、测试过的、比前一周期有更多功能的系统。</p>
<p>通过这些过程，我们可以更早地揭露和解决严重问题，客户有足够的机会改变它们的意见，程序员会更满意，能更精确地掌握项目。</p>
<p>这是开发周期中，传统上称为“维护”的一个阶段。我们不可能第一次就使软件正确，所以应当为学习、返工和修改留有余地。</p>
<p>“使软件正确”的意思不只是使程序按照要求和用例工作，还意味着我们理解代码的内部结构，并且认识到它能很好地协同工作，没有拙笨的语法和过大的对象，也没有难看的暴露的代码。</p>
<p>提出一个漂亮的方案感觉上更接近于艺术，而不是技术。精致总是有回报的，这不是一种虚浮的追求。它不仅给除了一个容易建造和调试的程序，而且容易理解和维护，这就是其经济价值的体现。</p>
<p>XP既是程序设计工作的哲学，又是做程序设计的一组原则。有两个原则最重要：“先写测试”和“结对编程”。</p>
<p>先写测试有两个及其重要的作用：</p>
<ul>
<li>它强制类的接口有清楚的定义。</li>
<li>能在每次编连软件时运行这些测试。</li>
</ul>
<p><code>结对编程(pair programming)</code>反对深植于我们心中的个人主义，一个人编写代码时另一个人在思考。思考者的头脑中保持总体概念，不仅是手头问题这一段，而且还有XP指导方针。这种结对方式，使事情顺畅、有章可循。</p>
<h2 id="u7B2C2_u7AE0__u5BF9_u8C61_u7684_u521B_u5EFA_u4E0E_u4F7F_u7528"><a href="#u7B2C2_u7AE0__u5BF9_u8C61_u7684_u521B_u5EFA_u4E0E_u4F7F_u7528" class="headerlink" title="第2章 对象的创建与使用"></a>第2章 对象的创建与使用</h2><h3 id="u8BED_u8A00_u7684_u7FFB_u8BD1_u8FC7_u7A0B"><a href="#u8BED_u8A00_u7684_u7FFB_u8BD1_u8FC7_u7A0B" class="headerlink" title="语言的翻译过程"></a>语言的翻译过程</h3><p>任何一种计算机语言都要从某种人们理解的形式(源代码)转化成计算机能执行的形式(机器指令)。通常，翻译器分为两类：<code>解释器(interpreter)</code>和<code>编译器(compiler)</code>。</p>
<p><strong>解释器(interpreter)</strong></p>
<p>将源代码转化成一些动作并立即执行这些动作。使用解释器有许多好处。从写代码到执行代码的转换几乎能立即完成，并且源代码总是显存，所以一旦出现错误，解释器能很容易地指出。另外的优点是较好的交互性和适于快速程序开发。</p>
<p>做大项目时候就有某些局限性。要求一次输入整个源代码，一旦出现错误，就很难调试。</p>
<p><strong>编译器(compiler)</strong></p>
<p>编译器直接把源代码转化成汇编语言或机器指令。某些语言可以分别编译各段程序，最后使用<code>连接器(linker)</code>把各段程序连接成一个完整的可执行程序。这个过程称为<code>分段编译(separate compilation)</code>。</p>
<p>某些语言(特别是C/C++)编译时，首先要对源代码执行预处理。<code>预处理器(preprocessor)</code>是一个简单的程序，用程序员(利用预处理器指令)定义好的模式代替源代码中的模式。</p>
<p>编译一般分两遍进行。首先，对预处理过的代码进行语法分析。编译器把源代码分解成小的单元并把它们按树形结构组织起来。有时候会在编译的第一遍和第二遍之间使用<code>全局优化器(global optimizer)</code>来生成更短、更快的代码。</p>
<p>编译的第二遍由<code>代码生成器(code generator)</code>遍历语法分析树，把树的每个节点转化成汇编语言或机器代码。</p>
<p><code>类型检查(type checking)</code>是编译器在第一遍中完成的。类型检查是检查函数参数是否正确使用，以防止许多程序设计错误。由于类型检查是在编译阶段而不是程序运行阶段进行的，所以称之为<code>静态类型检查(static type checking)</code>。在C++里可以不使用静态类型检查。我们可以自己做动态类型检查──这只需要写一些代码。</p>
<h2 id="u7B2C3_u7AE0_C++_u4E2D_u7684C"><a href="#u7B2C3_u7AE0_C++_u4E2D_u7684C" class="headerlink" title="第3章 C++中的C"></a>第3章 C++中的C</h2><p>全局变量是在所有函数体的外部定义的，程序的所有部分(甚至其他文件中的代码)都可以使用。全局变量不受作用域的影响，总是可用的(也就是说，全局变量的生命期一直到程序的结束)。如果在一个文件中存在全局变量，那么这个文件可以使用这个数据。</p>
<p>局部变量出现在一个作用域内，它们是局限于一个函数的。局部变量经常被称为<code>自动变量(automatic variable)</code>，因为它们在进入作用域时自动生成，离开作用域时自动消失。<br>寄存器变量是一种局部变量，最好避免使用关键字<code>register</code>。</p>
<p>关键字<code>static</code>有一些独特的意义。通常，函数中定义的局部变量在函数作用域结束时小时。当再次调用这个函数时，会重新创建该变量的存储空间，其值会被重新初始化。如果想使局部变量的值在程序的整个生命期里仍然存在，就可以定义函数的局部变量为<code>static</code>，并给它一个初始值。初始化只在函数第一次调用时执行，函数调用之间变量的值保持不变。用这种方式，函数可以“记住”函数调用之间的一些信息片段。</p>
<p><code>static</code>变量的优点是在函数范围之外它是不可用的，所以它不可能被轻易地改变。这会使错误局部化。</p>
<p><code>static</code>的第二层意思和前面的含义相关，即“在某个作用域外不可访问”。当应用<code>static</code>于函数名和所有函数外部的变量时，它的意思是“在文件的外部不可以使用这个名字”。函数名或变量是局部于文件的；我们说它具有<code>文件作用域(file scope)</code>。即使在另一个文件用<code>extern</code>声明，连接器也不会找到它。</p>
<p><code>extern</code>关键字告诉编译器存在着一个变量和函数，即使编译器在当前编译的文件中没有看到它，这个变量或函数可能在另一个文件中或者在当前文件的后面定义。</p>
<p><strong>连接(linkage)</strong></p>
<p>连接用连接器所见的方式描述存储空间。连结方式有两种：<code>内部连接(internal linkage)</code>和<code>外部连接(external linkage)</code>。内部连接意味着只对正被编译的文件创建存储空间。用内部连接，别的文件可以使用相同的标识符或全局变量，连接器不会发现冲突──也就是为每一个标识符创建单独的存储空间。在C和C++中，内部连接是由关键字static指定的。</p>
<p>外部连接意味着所有被编译过的文件创建一片单独的存储空间。一旦创建存储空间，连接器必须解决所有对这片存储空间的引用。</p>
<p>所有的运算符都会从它们的操作数中产生一个值。除了赋值、自增、自减运算符之外，运算符所产生的值不会修改操作数。修改操作数被称为<code>副作用(side effect)</code>。一般使用修改操作数的运算就是为了产生这种副作用。</p>
<p>可以作为一个运算符用于分隔表达式。在这种情况下，它只产生最后一个表达式的值。在逗号分隔的列表中，其余的表达式的计算只完成它们的副作用。</p>
<p>通常，除了作为一个分隔符，逗号最好不作他用，因为人们不习惯把它看作是运算符。</p>
<h2 id="u7B2C4_u7AE0__u6570_u636E_u62BD_u8C61"><a href="#u7B2C4_u7AE0__u6570_u636E_u62BD_u8C61" class="headerlink" title="第4章 数据抽象"></a>第4章 数据抽象</h2><p>库只是他人已经写好的一些代码，按照某种方式包装在一起。通常，最小的包是带有拓展名(如lib)的文件和向编译器声明库中有什么的一个或多个头文件。在跨越多种体系结构的平台(例如Linux和Unix)上，通常，提供库的最明智的方法是使用源代码，这样它就能在心的目标机上被重新配置和编译。</p>
<p>所以，库大概是改进生产效率的最重要的方法。C++的主要设计目标之一就是使库使用起来更加容易。</p>
<p>在C++中，对象就是变量，它的最纯正的定义是“一块存储区”(更明确的说法是，“对象必须有惟一的标识”，在C++中是一个惟一的地址)。它是一块空间，在这里能存放数据，而且还隐含着对这些数据进行处理的操作。</p>
<p>将数据连同函数捆绑在一起的能力可以用于创建新的数据类型。这常常被称为封装(encapsulation)。称为抽象数据类型(abstract data type)，也许这是因为它能允许从问题空间抽象概念到解空间。对抽象数据类型[有时称为用户定义类型(user-defined type)]的类型检查就像对内建类型的类型检查一样严格。</p>
<p>头文件是我们和我们的库的用户之间的合约。这份合约描述了我们的数据结构，为函数调用贵点了参数和返回值。</p>
<p>通过要求我们在使用结构和函数之前声明所有这些结构和函数，在定义成员函数之前声明这些成员函数，编译器强制履行这个合约。</p>
<p>放到头文件中的基本原则是“只限于声明”，即只限于对编译器的信息，不涉及通过生成代码或创建变量而分配存储的任何信息。</p>
<p>对于包含结构的每个头文件，应当首先检查这个头文件是否已经包含在特定的cpp文件中，如：</p>
<pre><code>#ifndef HEADER_FLAG
#define HEADER_FLAG
// Type declaration here...
#endif // HEADER_FLAG
</code></pre><p>防止多次包含的这些预处理器语句常常称为包含守卫(include guard)。</p>
<h2 id="u7B2C5_u7AE0__u9690_u85CF_u5B9E_u73B0"><a href="#u7B2C5_u7AE0__u9690_u85CF_u5B9E_u73B0" class="headerlink" title="第5章 隐藏实现"></a>第5章 隐藏实现</h2><p>在任何关系中，设立相关各方面都遵从的边界是很重要的。需要控制对结构成员的访问有两个理由：一是让客户程序员远离一些它们不需要使用的工具，这些工具对数据类型内部的处理来说是必需的，但对客户程序员解决特定问题的接口却不是必须的。另一个理由是允许库的设计者改变struct的内部实现，而不必担心会对客户程序员产生影响。</p>
<p>引进了三个<code>访问说明符(access specifier)</code>：<code>public</code>、<code>private</code>和<code>protected</code>。无论什么时候使用访问说明符，后面必须加一个冒号。</p>
<ul>
<li><code>public</code>意味着在其后声明的所有成员可以被所有的人访问。</li>
<li><code>private</code>关键字则意味着，除了该类型的创建者和类的内部成员函数之外，任何人都不能访问。</li>
<li><code>protected</code>与<code>private</code>基本相似，只有一点不同：继承的结构可以访问<code>protected</code>成员，但不能访问<code>private</code>成员。</li>
</ul>
<p>如果想允许显示地不属于当前结构的一个成员函数访问当前结构中的数据，可以在该结构内部声明这个函数为<code>friend(友元)</code>。注意，一个<code>friend</code>必须在一个结构内声明，这一点很重要。</p>
<p>嵌套的结构并不能自动获得访问private成员的权限。要获得访问私有成员的权限，必须存手特定的规则：首先声明(而不定义)一个嵌套的结构，然后声明它是全局范围使用的一个<code>friend</code>，最后定义这个结构。结构的定义必须与<code>friend</code>声明分开，否则编译器将不把它看做成员。</p>
<p>C++不是完全的面向对象语言，而只是一个混合产品。增加friend关键字就是为了用来解决一些实际问题。这也说明了这种语言是不纯的。毕竟C++语言的设计目的是使用，而不是追求理想的抽象。</p>
<p>访问说明符是结构的一部分，它们并不影响从这个结构创建的对象。程序开始运行之前，所有的访问说明信息都消失了。访问说明信息通常是在编译期间消失的。</p>
<p>一般说来，在程序员编写程序时，依赖特定实现的任何东西都是不合适的。如确有必要，这些特定实现部分应封装在一个结构之内，这样当环境改变时，只需修改一个地方就行了。</p>
<p>访问控制通常是指<code>实现细节的隐藏(implementation hiding)</code>。将函数包含到一个结构内(常称为封装)来产生一种带数据和操作的数据类型，由访问控制在该数据类型之内确定边界。</p>
<p>然后在C++中的<code>class</code>逐渐变成了一个非必要的关键字。它和<code>struct</code>的每个方面都是一样的，除了class中的成员默认为<code>private</code>，而<code>struct</code>中的成员默认为<code>public</code>。</p>
<p>C++中的访问控制允许将实现部分与接口部分分开，但实现部分的隐藏是不完全的。编译器仍然必须知道一个对象所有部分的声明。但C++要尽可能多地在编译期间作静态类型检查。这意味着尽早捕获错误，也意味着程序具有更高的效率。然后包含似有实现部分会带来两个影响：一是既是客户程序员不能轻易地访问私有实现部分，但可以看到它；二是造成一些不必要的重复编译。</p>
<p>有些项目不可让最终客户程序员看到其实现部分，就有必要把一个变一号的实际结构放在实现文件中，而不是让其暴露在头文件中。</p>
<p>在我们的编译环境中，当一个文件被修改，或它所依赖的头文件被修改时，项目管理员需要重复编译该文件。这意味着程序员无论何时修改了一个类，无论修改的是公共的接口部分，还是私有成员的声明部分，他都必须再次编译包含头文件的所有文件。这就是通常所说的<code>易碎的基类问题(fragile base-class problem)</code>。对于一个大的项目而言，在开发初期这可能非常难以处理，因为内部实现部分可能需要经常改动。如果这个项目非常大，用于编译的时间过多可能妨碍项目的快速转型。</p>
<p>解决这个问题的技术有时称为<code>句柄类(handle class)</code>或称为<code>Cheshire cat</code>。有关实现的任何东西都消失了，只剩一个单指针“smile”。该指针指向一个结构，该结构的定义与其所有的成员函数的定义一同出现在实现文件中。这样，只要接口部分不改变，头文件就不需变动，而实现部分可以按需要任意更改，完成后只需要对实现文件进行重新编译，然后重新连接到项目中。</p>
<h3 id="u7B2C6_u7AE0__u521D_u59CB_u5316_u4E0E_u6E05_u9664"><a href="#u7B2C6_u7AE0__u521D_u59CB_u5316_u4E0E_u6E05_u9664" class="headerlink" title="第6章 初始化与清除"></a>第6章 初始化与清除</h3><p>C++中，初始化和清楚的概念是简化库的使用的关键所在，并可以减少那些在客户程序员忘记去完成这些操作时会引起的细微错误。</p>
<p>类的设计者可以通过提供一个叫做构造函数(constructor)的特殊函数来保证每个对象都被初始化。如果一个类有构造函数，编译器在创建对象时就自动调用这一函数。构造函数的名字与类的名字一样。这样的函数在初始化时会被自动调用。</p>
<p>构造函数和析构函数是两个非常特殊的函数：它们没有返回值。</p>
<p>在程序中创建和消除一个对象的行为非常特殊，就像出生和死亡，而且总是由编译器来调用这些函数以确保它们被执行。如果它们有返回值，要么编译器必须知道如何处理返回值，要么就只能由客户程序员子集来显式的调用构造函数与析构函数，这样一来，安全性就被破坏了。</p>
<p>在一个库中，对于一个曾经用过的对象，如果不做处理，对象就永远不会消失。在C++中，清除就像初始化一样重要，它通过析构函数来保证清除的执行。</p>
<p>析构函数的语言与构造函数一样，用类的名字作为函数名。然而析构函数前面加上一个代字号(～)，以和构造函数区别。</p>
<p>当对象超出它的作用域时，编译器将自动调用析构函数。</p>
<p>在C++中，应该在尽可能靠近变量的使用点处定义变量，并在定义时就初始化。这是出于安全性的考虑，通过减少变量在块中的生命周期，就可以减少该变量在块的其他地方被误用的机会。</p>
<p>集合(aggregate)就是多个事物聚集在一起。这个定义包括混合类型的集合。</p>
<p><code>默认构造函数(default constructor)</code>就是不带任何参数的构造函数。一旦有了一个构造函数，编译器就会确保不关在什么情况下它总是会被调用。</p>
<p>尽管编译器会创建一个默认的构造函数，但是编译器合成的构造函数的行为很少是我们期望的。我们应该把这个特征看成是一个安全网，但尽量少用它。一般说来，应该明确地定义子集的构造函数，而不让编译器来完成。</p>
<h2 id="u7B2C7_u7AE0__u51FD_u6570_u91CD_u8F7D_u4E0E_u9ED8_u8BA4_u53C2_u6570"><a href="#u7B2C7_u7AE0__u51FD_u6570_u91CD_u8F7D_u4E0E_u9ED8_u8BA4_u53C2_u6570" class="headerlink" title="第7章 函数重载与默认参数"></a>第7章 函数重载与默认参数</h2><p>能使名字方便使用，是任何程序设计语言的一个重要特征。</p>
<p>尽管函数重载对构造函数来说是必须的，但是它仍然是一个通用的方便手段，并可以与任意函数一起使用。另外，函数重载意味着，我们有两个库，它们都有同名的函数，只要它们的参数列表不同就不会发生冲突。</p>
<p>可以对不同的函数用同样的名字，只要求函数的参数不同，编译器会修饰这些名字、范围和参数来产生内部名以供它和连接器使用。</p>
<p>仅仅依靠返回值来重载函数实在过于微妙，所以在C++中禁止这样做。</p>
<p>对名字修饰还可以带来一个额外的好处。在C中，如果用户错误地声明了一个函数，或者更糟糕地，一个函数还没声明就调用了，而编译器则按照函数被调用的方式去推断函数的声明。若这样的推断不正确，那么就会变成一个很难发现的错误。</p>
<p>在C++中，所有的恶函数在被使用前都必须事先声明，因此出现上述情况的机会大大减少了。名字修饰会给我们提供一个安全网，这也就是人们常说的<code>类型安全连接(type-safe linkage)</code>。</p>
<p><code>默认参数(default argument)</code>是在函数声明时就已给定的一个值，如果在调用函数时没有指定这一参数的值，编译器就会自动地插上这个值。</p>
<p>在使用默认参数时必须记住两条规则。第一，只有参数列表的后部参数才是可默认的，也就是说，不可以在一个默认参数后面又跟一个非默认的参数。第二，一旦在一个函数调用中开始使用默认参数，那么这个参数后面的所有参数都必须是默认的。</p>
<p>默认参数只能放在函数声明中，通常在一个头文件中。编译器必须在使用该函数之前知道默认值。有时人们为了阅读方便在函数定义处放上你一些默认的注释值。</p>
<h2 id="u7B2C8_u7AE0__u5E38_u91CF"><a href="#u7B2C8_u7AE0__u5E38_u91CF" class="headerlink" title="第8章 常量"></a>第8章 常量</h2><p>常量概念(由关键字const表示)是为了使程序员能够在变和不变之间画一条界线。这在C++程序设计项目中提供了安全性和可控性。</p>
<p>可以使指针成为<code>const</code>。当处理<code>const</code>指针时，编译器仍将努力避免存储分配并进行常量折叠。如果程序员以后想在程序代码中改变<code>const</code>这种指针的使用，编译器将给出通知。这大大增加了安全性。</p>
<p>当使用带有指针的<code>const</code>时，有两种选择：<code>const</code>修饰指针正指向的对象，或者<code>const</code>修饰在指针里存储的地址。</p>
<p>定义指针的技巧是在标识符的开始处读它并从里向外读。<code>const</code>修饰“最靠近”它的那个。如：<code>const int* u;</code> 可以读成：u是一个指针，它指向一个<code>const int</code>。</p>
<p>使指针本身称为一个<code>const</code>指针，必须把<code>const</code>标明的部分放在<em>的右边。如：`int d = 1; int </em> const w = &d;<code>可以读成</code>w<code>是一个</code>const<code>指针指向一个</code>int`。</p>
<p>因为指针本事现在是<code>const</code>指针，编译器要求给它一个初始值，这个值在指针生命期内不变。然而要干煸它所指向的值是可以的：<code>*w = 2;</code></p>
<p>当然也可以把一个<code>const</code>指针指向一个<code>const</code>对象。</p>
<p>如果可能的话，一行只定义一个指针，并尽可能在定义时初始化。</p>
<p>可以把一个非<code>const</code>对象的地址赋给一个<code>const</code>指针，因为也许有时不想改变某些可以改变的东西。然后不能把一个<code>const</code>对象的地址赋给一个非<code>const</code>指针，因为这样做可能通过被赋值的指针改变这个对象的值。</p>
<p>如果函数是按值传递，则可用指定参数是<code>const</code>的。这里参数不能被改变。所以它其实是函数创建者的工具，而不是函数调用者的工具。</p>
<p>为了不使调用者很小，在函数内部用<code>const</code>限定参数优于在参数表里用<code>const</code>限定参数。可以用一个指针来实现，但更好的语法形式是“引用”。简而言之，引用相一个被自动间接引用的常量指针，它的作用是成为对象的别名。为建立一个引用，在定义里使用<code>&amp;</code>。</p>
<p>如果一个函数的返回值是一个常量(const)，这就约定了函数框架里的原变量不会被修改。另外，因为这是按值返回的，所以这个变量被制成副本，舍得初值不会被返回值所修改。</p>
<p>对于内部类型来说，按值返回的是否是一个const，是无关紧要的，所以按值返回一个内部类型时，应该去掉const，从而不使客户程序员混淆。</p>
<p>当处理用户定义的类型时，按值返回常量是很重要的。如果一个函数按值返回一个类对象为const时，那么这个函数的返回值不能是一个左值(不能被赋值或修改)。</p>
<p>如果传递或返回一个地址(一个指针或一个引用)，客户程序员去取地址并修改其初值是可能的。如果使这个指针或者引用成为const，就会阻止这类事的发生，这是非常重要的事情，事实上，无论什么时候传递一个地址给一个函数，都应该尽可能用const修饰它。如果不这样做，就不能以const指针参数的方式使用这个函数。</p>
<p>常数表达式使用常量的地方之一是在类里。典型的例子是在一个类里建立一个数组，并用const代替#define设置数组大小。数组大小一直隐藏在类里，这样，如果用size表示数组大小，就可以把size这个名字用在另一个类里而不发生冲突。</p>
<p>读者可能认为合乎逻辑的选择是把一个const放在类里。但这样不会产生预期的效果。在一个类里，const又部分恢复到它在C语言中的含义。它在每个类对象里分配存储并代表一个值，这个值一旦被初始化以后就不能改变。在一个类里使用const意味着“在这个对象生命期内，它是一个常量”。然而，对这个常量来讲，每个不同的对象可以含有一个不同的值。</p>
<p>这样，在一个类里建立一个普通的(非static的)const时，不能给它初值。这个初始化工作比须在构造函数里进行，当然，要在构造函数的某个特别的地方进行。因为const必须在建立它的地方被初始化，所以在构造函数的主体里，const必定已被初始化了。否则，就只有等待，直到在构造函数主体以后的某个地方给它初始化，这意味着过一会儿才给const初始化。当然，无法防止在构造函数主体的不同地方改变const的值。</p>
<p><strong>构造函数初始化列表</strong></p>
<p>在构造函数里有个专门初始化的地方，这就是<code>构造函数初始化列表(constructor initializer list)</code>，起初用在机成立。构造函数初始化列表是一个出现在函数参数表和冒号后，但在构造函数主体开头的花括号前的“函数调用列表”。这提醒人们，表里的初始化发生在构造函数的任何代码执行之前。这是初始化所有<code>const</code>的地方，若<code>size</code>是<code>Fred</code>类的一个<code>const</code>成员的话，其正确形式是：</p>
<pre><code>Fred::Fred(int sz) : size(sz){}
</code></pre><p>把一个内部类型风装载一个类里以保证用构造函数初始化，这是很有用的。</p>
<p>若要让类有编译期间的常量成员，就要求使用另外一个关键字<code>static</code>。在这种情况下，关键字<code>static</code>意味着“不管类的对象被创建多少次，都只有一个实例”。因此，一个内部类型的<code>static const</code>可以看作一个编译期间的常量。</p>
<p>必须在<code>static const</code>定义的地方对它进行初始化。</p>
<p>如果声明一个成员函数为<code>const</code>(修饰符<code>const</code>放在函数参数表的后面)，则等于告诉编译器该成员函数可以为一个<code>const</code>对象所调用。一个没有被明确声明为<code>const</code>的成员函数被堪称是将要修改数据成员的函数，而且编译器不允许它为一个<code>const</code>对象所调用。</p>
<p>关键字<code>const</code>必须同样的方式重复出现在定义里，否则编译器把它看成一个不同的函数！<br>一个<code>const</code>成员函数调用<code>const</code>和非<code>const</code>对象是安全的，因此，可以把它看做成员函数的最一般形式。不修改数据成员的任何函数都应该把它们声明为<code>const</code>，这样它可以和<code>const</code>对象一起使用。</p>
<p><code>volatile</code>的语法与<code>const</code>是一样的，但是<code>volatile</code>的意思是“在编译器认识的范围外，这个数据可以被改变”。不知何故，环境正在改变数据(可能通过多任务、多线程或者中断处理)，所以，<code>volatile</code>告诉编译器不要擅自作出有关该数据的任何假定，优化期间尤其如此。</p>
<h2 id="u7B2C9_u7AE0__u5185_u8054_u51FD_u6570"><a href="#u7B2C9_u7AE0__u5185_u8054_u51FD_u6570" class="headerlink" title="第9章 内联函数"></a>第9章 内联函数</h2><p>C++从C中集成的一个重要特征是效率。加入C++的效率显著地低于C的效率，那么就会有很大一批程序员不去使用它。</p>
<p>为了既保持预处理器宏的效率又增加安全性、而且还能像一般成员函数一样可以在类里访问自如，C++引入了内联函数(inline function)</p>
<p>预处理器宏存在问题的关键是我们可能认为预处理器的行为和编译器的行为一样。</p>
<p>在解决C++中宏访问private类成员的问题过程中，所有和预处理器宏有关的问题也随之排除了。这是通过使宏被编译器控制来实现的。在C++中，宏的概念是作为内联函数(inline function)来实现的，而内联函数无论从哪一方面上说都是真正的函数。</p>
<p>任何在类中定义的函数自动成为内联函数，但也可以在非类的函数前面加上inline关键字使之称为内联函数。但为了使之有效，必须使函数体和声明结合在一起，否则，编译器将它作为普通函数对待。</p>
<p>一般应该把内联定义放在头文件里。当编译器看到这个定义时，它把函数类型(函数名+返回值)和函数体放到符号表里。当使用函数时，编译器检查以确保调用是正确的且返回值被正确使用，然后将函数调用替换为函数体，因而消除了开销。内联代码的确占用空间，但假如函数较小，这实际上比为了一个普通函数调用而产生的代码(参数压栈和执行CALL)占用的空间还小。</p>
<p>类内部的内联函数节省了在外部定义成员函数的额外步骤，所以我们一定想在类声明内每一处都使用内联函数。但应记住，使用内联函数的目的是减少函数调用的开销。但是，假如函数较大，由于需要在调用函数的每一处重复复制代码，这样将使代码膨胀，在速度方面获得的好处就会减少。</p>
<p>在类中内联函数的最重要的使用之一是用做<code>访问函数(access function)</code>。这是一个小函数，它容许读或修改对象状态──即一个或几个内部变量。即最通常所说的<code>set</code>与<code>get</code>方法(修改器和访问器)。</p>
<p>对于函数，编译器在它的符号表里放入函数类型(即包括名字和参数类型的函数原型及函数的返回类型)。另外，当编译器看到内联函数和对内联函数体的分析没有发现错误时，就将对应于函数体的代码也放入符号表。代码是以源程序形式存放还是以编译过的汇编指令形式存放取决于编译器。</p>
<p>当调用一个内联函数时，编译器首先确保调用正确，即所有的参数类型必须满足：要么与函数参数表中的参数类型一样，要么编译器能够将其转换为正确类型，并且返回值在目标表达式里应该是正确类型或可改变为正确类型。</p>
<p>有两种编译器不能执行内联的情况。在这些情况下，它就像对非内联函数一样，根据内联函数定义和为函数建立存储空间，简单地将其转换为函数的普通形式。</p>
<p>加入函数太复杂，编译器将不能执行内联。这取决于特定的编译器，但对大多数编译器这时都回放弃内联方式，因为这时内联可能不能提高任何效率。一般地，任何种类的循环都被认为太复杂。</p>
<p>内联仅是编译器的一个建议，编译器不会被强迫内联任何代码。一个好的编译器将会内联小的、简单的函数，同时明智地忽略那些太复杂的内联。这将给我们想要的结果──具有宏效率的函数调用的真正语义学。</p>
<p>当一个内联函数在类中向前引用一个还没有声明的函数时，是可以正常工作的，因为C++语言规定：只有在类声明结束后，其中的内联函数才会被计算。</p>
<h2 id="u7B2C10_u7AE0__u540D_u5B57_u63A7_u5236"><a href="#u7B2C10_u7AE0__u540D_u5B57_u63A7_u5236" class="headerlink" title="第10章 名字控制"></a>第10章 名字控制</h2><p>创建名字是程序设计过程中一项最基本的活动，当一个项目很大时，它会不可避免地包含大量的名字。</p>
<p>关于static的所有使用最基本的概念是指“位置不变的某个东西”，不管这里是指在内存中的物理位置还是指在文件中的可见性。</p>
<p>在C和C++中，static都有两种基本的含义，并且这两种含义经常是相互冲突的：</p>
<ul>
<li>在固定的地址上进行存储分配，也就是说对象是在一个特殊的静态数据区(static data area)上创建的，而不是每次函数调用时在堆栈上产生的。这也是静态存储的概念。</li>
<li>对一个特定的编译单位来说是局部的。这样，static控制名字的可见性(visibility)，所以这个名字在这个单元或类外是不可见的。这也描述了连接的概念，它决定连接器将看到哪些名字。</li>
</ul>
<p>通常，在函数体内定义一个局部变量时，编译器在每次函数调用时使堆栈的指针下移到一个适当的位置，为这些局部变量非配内存。如果这个变量又一个初始化表达式，那么每当程序运行到此处，初始化就被执行。</p>
<p>然而，有时想在两次函数调用之间保留一个变量的值，可以通过定义一个全局变量来实现，但这样一来，这个变量就不仅仅只受到这个函数的控制。C和C++都允许在函数内部定义一个static对象，这个对象将存储在静态数据区中，而不是在堆栈中。这个对象只在第一次调用是初始化一次，以后它将在两次函数调用之间保持它的值。</p>
<p>一般情况下，在<code>文件作用域(file scope)</code>内的所有名字(即不嵌套在类或函数中的名字)对程序中的所有翻译单元来说都是可见的。这就是所谓的<code>外部连接(external linkage)</code>，因为在连接时这个名字对连接器来说是可见的，对单独的翻译单元来说，它是外部的。全局变量和普通函数都有外部连接。</p>
<p>在文件作用域内，一个被明确声明为static的对象或函数的名字对翻译单元来说是局部于该单元的。这些名字有<code>内部连接(internal linkage)</code>。</p>
<p>内部连接的一个好处是这个名字可以放在一个头文件中</p>
<h2 id="u7B2C11_u7AE0__u5F15_u7528_u548C_u62F7_u8D1D_u6784_u9020_u51FD_u6570"><a href="#u7B2C11_u7AE0__u5F15_u7528_u548C_u62F7_u8D1D_u6784_u9020_u51FD_u6570" class="headerlink" title="第11章 引用和拷贝构造函数"></a>第11章 引用和拷贝构造函数</h2><p>C不允许随便地把一个类型的指针赋给另一个类型，但允许通过<code>void*</code>来实现。由于C的这种功能允许把任何一种类型看做别的类型处理，这就在类型系统中流下了一个大的漏洞。C++不允许这样做，如果真想把某种类型当作别的类型处理，则必须显示地使用类型转换。</p>
<p>引用(reference)(&amp;)就像能自动地被编译器间接引用的常量型指针。它常用于函数的参数表中和函数的返回值，但也可以独立使用。</p>
<p>使用引用时有一定的规则：</p>
<ul>
<li>当引用被创建时，它必须被初始化(指针则可以在任何时候被初始化)。</li>
<li>一旦一个引用被初始化为指向一个对象，它就不能改变为另一个对象的引用(指针则可以在任何时候指向另一个对象)。</li>
<li>不可能有NULL引用。必须确保引用是和一块合法的存储单元关联。</li>
</ul>
<p>最经常看见引用的地方是在函数参数和返回值中。当引用被用做函数参数时，在函数内任何对引用的更改将对函数外的参数产生改变。当然，可以通过传递一个指针来做相同的事情，但引用具有更清晰的语法。</p>
<p>如果从函数中返回一个引用，必须像从函数中返回一个指针来一样对待。当函数返回时，无论引用关连的是什么都应该存在，否则，将不知道指向哪一个内存。</p>
<p>若想要改变指针本身而不是它所指向的内容，函数参数变成指针的引用，用不着取得指针的地址。</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
void increment(int*&amp; i){i++}
int main(){
    int *i = 0;
    cout &lt;&lt; “i = ” &lt;&lt; i &lt;&lt; endl;
    increment(i);
    cout &lt;&lt; “i = ” &lt;&lt; i &lt;&lt; endl;
}
</code></pre><p>当给函数传递参数时，人们习惯上是通过常量引用来传递。这种简单习惯可以大大提高效率：传值方式需要调用构造函数和析构函数，然而，如果不想改变参数，则可以通过常量引用传递，它仅需要将地址压栈。</p>
<p>拷贝构造函数是一个更令人混淆的概念，常被称为<code>X(X&amp;)(“X引用的X”)</code>，在函数调用时，这个构造函数是控制通过传值方式传递和返回用户定义类型的根本所在。这是很重要的。</p>
<p>在C和C++中，参数是从右向左进栈的，然后调用函数，调用代码负责清理栈中的参数。但是要注意，通过按值传递方式传递参数时，编译器简单地将参数拷贝压栈──编译器知道拷贝有多大，并知道如何对参数压栈，对它们正确拷贝。</p>
<p>当编译器为函数调用产生代码时，它首先把所有的参数压栈，然后调用函数。在函数内部，产生代码，向下移动栈指针为函数局部变量提供存储单元。</p>
<h2 id="u7B2C13_u7AE0__u52A8_u6001_u5BF9_u8C61_u521B_u5EFA"><a href="#u7B2C13_u7AE0__u52A8_u6001_u5BF9_u8C61_u521B_u5EFA" class="headerlink" title="第13章 动态对象创建"></a>第13章 动态对象创建</h2><p>有时我们能知道程序中对象的确切数量、类型和生命期。但情况不总是这样。为了解决这个普遍的编程问题，在运行时可以创建和销毁对象是最基本的要求。C提供了<code>动态内存分配(dynamic memory allocation)</code>函数<code>malloc()</code>和<code>free()</code>，这些函数在运行时从堆(也称自由内存)中分配存储单元。</p>
<p>然而，在C++中这些函数将不能很好的运行。因为构造函数不允许我们向它传递内存地址来进行初始化。</p>
<p>C++是如何保证正确的初始化和清理，有允许我们在堆上动态创建对象呢？</p>
<p>答案是，使动态对象称为语言的核心。malloc和free是库函数，因此不在编译器控制范围之内。然而，如果我们有一个完成动态内存分配及初始化组合动作的运算符和另一个完成清理及释放内存组合动作的运算符，编译器仍可以保证所有对象的构造函数和析构函数会被调用。</p>
<p>当创建一个C++对象，会发生两件事：</p>
<ul>
<li>为对象分配内存。</li>
<li>调用构造函数来初始化那个内存。</li>
</ul>
<p>到目前为止，因该确保步骤2一定发生。C++强迫这样做是因为未初始化的对象是程序出错的主要原因。对象在那里和如何创建无关紧要──构造函数总是需要被调用。</p>
<p>然而，步骤1可以用几种方式或在可选择的时间发生：</p>
<ul>
<li>在静态存储区域，存储空间在程序开始之前就可以分配。这个存储空间在整个程序运行期间都存在。</li>
<li>无论何时到达一个特殊的执行点(左大括号)时，存储单元都可以在栈上被创建。除了执行点(右大括号)，这个存储单元自动被释放。这些栈分配运算内置于处理器的指令集中，非常有效。然而，在写程序时，必须知道需要多少个存储单元，以便编译器生成正确的指令。</li>
</ul>
<p>存储单元也可以从一块称为堆(也被称为自由存储单元)的地方分配。这被称为动态内存分配。在运行时调用程序分配这些内存。这意味着可以在任何时候决定分配内存及分配多少内存。当然也需负责决定何时释放内存。这块内存的生存期由我们选择决定──而不受范围决定。</p>
<p>为了在运行时动态分配内存，如<code>malloc()</code>和<code>free()</code>。这些函数是有效的但较原始的，需要编程人员理解和小心使用。例如，必须对分配的空间进行显式地类型转换，还需要自行调用初始化的函数(构造函数并不能被显式地调用)。这很容易出错。所以，C程序设计者常常在静态内存区域使用虚拟内存机制分配很大的变量数组以避免使用动态内存分配。为了在C++中使得一般的程序员可以安全使用库函数而不费力，所以C的动态内存方法是不可接受的。</p>
<p>C++中的解决方案是把船舰一个对象所需的所有动作都结合在一个称为new的运算符里。当用new(new的表达式)创建一个对象时，它就在堆里为对象分配内存并为这块内存调用构造函数。等价于调用malloc()函数并调用构造函数。返回一个指向该对象的this指针。</p>
<pre><code>MyType *fp = new MyType;
</code></pre><p>默认的new还进行检查以确信在传递地址给构造函数之前内存分配是成功的，所以不必显式地确定调用是否成功。</p>
<p>我们可以看到，在堆里创建对象的过程变得简单了──只是一个简单的表达式，它带有内置的长度计算、类型转换和安全检查。这样在堆里创建一个对象何在栈里创建一个对象一样容易。</p>
<p><code>delete</code>表达式首先调用析构函数，然后释放内存(常调用free())。正如<code>new</code>表达式返回一个指向对象的指针一样，<code>delete</code>表达式需要一个对象的地址。</p>
<pre><code>delete fp；
</code></pre><p><code>delete</code>只用于删除由<code>new</code>创建的对象。</p>
<p>当在堆栈里自动创建对象时，对象的大小和它们的生存期被准确地内置在生成的代码里，这是因为编译器知道确切的类型、数量和范围。而在堆里创建的对象还包括另外的时间和空间的开销。以下是一个典型情况：</p>
<p>调用<code>malloc()</code>，即从堆里搜索一块足够大的内存来满足请求，可以通过检查按某种方式排列的映射或目录来实现，这样的映射或目录用以显示内存的使用情况。这个过程很快但可能要试探几次，所以它可能是不确定的──即每次运行<code>malloc()</code>并不是花费了相同的时间。</p>
<p>在栈或堆上创建一个对象数组是同样容易的。但这里有一个限制条件：由于不带参数的构造函数必须被每一个对象调用，所以除了在栈上整体初始化外还必须有一个默认的构造函数。</p>
<pre><code>MyType *fp = new MyType[100];
MyType *fp2 = new MyType;
</code></pre><p>我们知道其实fp和fp2是数组的起始地址。</p>
<pre><code>delete fp2; // OK
delete fp; // Not the desired effect
</code></pre><p>对于<code>fp</code>来说，另外99个析构函数没有调用，正确应该这样：</p>
<pre><code>delete []fp；
</code></pre><p>空的方括号告诉编译器产生代码，该代码的任务是将从数组创建时存放在某处的对象数量取回，并为数组的所有对象调用析构函数。</p>
<p>上面定义的fp可以被修改指向任何类型，但这对于一个数组的起始地址来说没有什么意义。一般来讲，把它定义为常量会更好些，因为这样任何修改指针的企图都会被认为出错。</p>
<p>使得指针指向的int不能修改(指针可以修改)：</p>
<pre><code>int const* q = new int[10];   or
const int* q = new int[10];
</code></pre><p>使得指针不能被修改(数组可以修改)：</p>
<pre><code>int * const q = new int[10];
</code></pre><p>当<code>operator new()</code>找不到组够大的连续内存块来安排对象时，一个称为<code>new-handler</code>的特殊函数将会被调用。首先，检查指向函数的指针，如果指针非0，那么它指向的函数将被调用。</p>
<p><code>new-handler</code>的默认动作是产生一个<code>异常(throw an exception)</code>。</p>
<h2 id="u7B2C14_u7AE0__u7EE7_u627F_u548C_u7EC4_u5408"><a href="#u7B2C14_u7AE0__u7EE7_u627F_u548C_u7EC4_u5408" class="headerlink" title="第14章 继承和组合"></a>第14章 继承和组合</h2><p>C++中最重要的特征之一是代码重用。但是如果希望更进一步，就不能仅仅用拷贝代码和修改代码的方法，而是要做更多的工作。</p>
<p>关键技巧是使用这些类，但不修改已存在的代码。第一种方法很直接：我们简单地在心类中创建已存在类的对象。因为新类是由已存在的类的对象组合而成，所以这种方法称为<code>组合(composition)</code>。</p>
<p>第二种方法要复杂些。我们创建一个新类作为一个已存在类的类型。我们不修改已存在的类，而是采取这个已存在类的形式，并将代码加入其中。这种巧妙方法称为<code>继承(inheritance)</code>，其中大量的工作是由编译器完成。继承是面向对象程序设计的基石。</p>
<p>在语法上和行为上，组合和继承大部分是相似的。</p>
<p>组合语法 直接把子对象放入新对象的组成中即可。</p>
<p>访问嵌入对象(称为子对象)的成员的成员函数只需再一次的成员选择。更常见的是把嵌入的对象设为私有，因此它们将称为内部实现的一部分(这意味着如果我们原因，可以改变这个实现)。新类的公有接口函数包括了对嵌入对象的使用，但没有必要模仿这个对象的接口。</p>
<p>当继承时，我们会发现“这个新类很像原来的类”。我们规定，在代码中和原来一样给出该类的名字，但在类的左括号的前面，加一个冒号和基类的名字(对于多重继承，要给出多个基类名，它们之间用逗号分开)。当昨晚这些时，将会自动地得到基类中的所用数据成员和成员函数。</p>
<pre><code>class Y：public X{//......}
</code></pre><p>我们可以看到<code>Y</code>对<code>X</code>进行了继承，这意味着Y将包含X中的所有数据成员和成员函数。所有<code>X</code>中的私有成员在<code>Y</code>中仍然是私有的，因为<code>Y</code>对<code>X</code>进行了继承并不意味着<code>Y</code>可以不遵守保护机制。</p>
<p>这里基类前面是<code>public</code>。由于在继承时，基类中所有的成员都是被预设为私有的，所以如果基类的前面没有<code>public</code>，这意味着基类的所有公有成员将在派生类中变为私有的。这显然不是所希望的，我们希望基类中的所有公有成员在派生类中仍是公有的，这可以在继承时通过使用关键字<code>public</code>来实现。</p>
<p>倘若<code>X</code>和<code>Y</code>类中均有一个<code>set()</code>函数，那么将会使用Y中重新定义的版本。这也就是说，如果不想使用某个继承而来的函数，我们可以改变它的内容。然而，当我们重新定义了一个函数之后，仍可能想调用基类的函数，为了调用基类<code>X</code>的<code>set()</code>函数，必须使用作用域运算符来显示地表明基类名。</p>
<p>在C++中保证正确的初始化是多么重要，这一点在组合和继承中也是一样。当创建一个对象时，编译器确保调用了所有子对象的构造函数。</p>
<p>但是，如果子对象没有默认构造函数或如果想改变构造函数的某个默认参数，就会出现问题，因为这个新类的构造函数没有权利访问这个子对象的私有数据成员，所以不能直接对它们初始化。</p>
<p>解决的方法很简单：对于子函数调用构造函数，C++为此提供了专门的语法，即构造函数的初始化表达式表。构造函数的初始化表达式的形式模仿继承活动。</p>
<p>对于继承，我们把基类至于冒号和这个类体的左括号之间。而在构造函数的初始化表达式中，可以将对子对象构造函数的调用语句放在构造函数参数表和冒号之后，在函数体的左括号之前。对于从Bar继承来的类MyType，如果Bar的构造函数只有一个int型参数，则可以表示为：</p>
<pre><code>MyType::MyType(int i) : Bar(i) { // ...
</code></pre><p>对于组合，也可以对成员对象使用同样语法，只是所给出的不是类名，而是对象的名字。如果在初始化表达式表中有多个构造函数的调用，应当用逗号加以隔开：</p>
<pre><code>MyType2::MyType(int i) : Bar(i), m(i+1) { // ...
</code></pre><p>这是类<code>MyType2</code>构造函数的开头，该类是从<code>Bar</code>继承来的，并且包含一个称为<code>m</code>的成员对象。请注意，虽然可以在这个构造函数的初始化表达式表中看到基类的类型，但只能看到成员对象的标识符。</p>
<p>构造函数的初始化表达式表允许我们显式地调用成员对象的构造函数。它的主要思想是，在进入新类的构造函数体之前调用所有其他的构造函数。这样，对于子对象的成员函数所做的任何调用都总是转到了这个被初始化的对象中。即使编译器可以隐藏地调用默认的构造函数，但在没有对所有的成员对象和基类对象的构造函数进行调用之前，就没有办法进入该构造函数体。这是C++的一个强化的机制，它确保了，如果没有调用对象的构造函数，就别想向下进行。</p>
<p>对于哪些没有构造函数的内部类型嵌入对象，这一切会怎么样？</p>
<p>为了使语法一致，可以把内部类型看做这样一种类型，它只有一个取单个参数的构造函数，而这个参数与正在初始化的变量类型相同。于是可以这么写：</p>
<pre><code>class X {
    int i;
    float f;
    char c;
    char* s;
public:
    X() : i(7), f(1.4), c(‘x’), s(“howdy”) {}
};
</code></pre><p>这些“伪构造函数调用”操作可以进行简单的赋值。这种方法很方便，并且具有良好的编码风格。甚至在类之外创建内部类型的变量是，也可以使用伪构造函数语法。</p>
<p>这使得内部类型的操作有点类似于对象，但是这些并不是真正的构造函数。特别地，如果没有显式的进行伪构造函数调用，初始化是不会执行的。</p>
<p>还可以把组合和继承放在一起使用。</p>
<p><strong>自动析构函数调用</strong></p>
<p>虽然常常需要在初始化表达式表中显式构造函数调用，但并不需要做显式的析构函数调用，因为对于任何类型只有一个析构函数，并且它并不取任何参数。然而，编译器仍要保证所有的析构函数被调用，这意味着，在整个层次中的所有析构函数中，从派生类最底层的析构函数开始调用，一直到根层。</p>
<p>构造是从类层次的最根处开始，而在每一层，首先会调用基类构造函数，然后调用成员对象构造函数。调用析构函数则严格按照构造函数相反的次序──这是很重要的，因为要考虑潜在的相关性(对于派生类中的构造函数和析构函数，必须假设基类子对象仍然可供使用并且已经被构造了──或者还未被消除)。</p>
<p>另一个有趣现象是，对于成员对象，构造函数调用的次序完全不受构造函数的初始化表达式表中的次序影响。该次序是由成员对象在类中声明的次序所决定的。</p>
<p>如果继承一个类并且对它的成员函数重新进行定义，可能会出现两种情况：</p>
<ul>
<li>第一种是正如在基类中所进行的定义一样，在派生类的定义中明确地定义操作和返回类型。这称之为对普通成员函数的重定义(redefining)，而如果基类的成员函数是虚函数的情况，又可称之为重写(overriding)。</li>
<li>任何时候重新定义了基类中的一个重载函数，在新类之中所有其他版本则被自动地隐藏了。</li>
</ul>
<p>如果通过修改基类中一个成员函数的操作与/或返回类型来改变了基类的接口，我们就没有使用继承通常所提供的功能，而是按另一种方式来重用了该类。这并不一定意味着做错了，只是由于继承的最终目标是为了实现<code>多态性(polymorphism)</code>。</p>
<p>不是所有的函数都能自动地从基类继承到派生类中的。构造函数和析构函数用来处理对象的创建和析构操作，但它们只知道对它们的特定层次上的的对象做些什么。所以，在该类以下各个层次中的所有构造函数和析构函数都必须被调用，也就是说，构造函数和析构函数不能被继承，必须为每一个特定的派生类分别创建。</p>
<p>另外，<code>operator=</code>也不能被继承，因为它完成类似于构造函数的活动。</p>
<p>静态(static)成员函数与非静态成员函数的共同点：</p>
<ul>
<li>它们均可被继承到派生类中。</li>
<li>如果我们重新定义了一个静态成员，所有在基类中的其他重载函数会被隐藏。</li>
<li>如果我们改变了基类中一个函数的特征，所有使用该函数名字的基类版本都将会被隐藏。然而，<code>静态(static)</code>成员函数不可以是<code>虚函数(virtual)</code>。</li>
</ul>
<p>组合通常是在希望新类内部具有已存在类的功能时使用，而不是希望已存在类作为它的接口。这就是说，嵌入一个对象用以实现新类的功能，而新类的用户看到的是新定义的接口而不是来自老类的接口。为此，在新类的内部嵌入已存在的<code>private</code>对象。</p>
<p>有时，又希望允许类用户直接访问新类的组成，这就让成员对象是<code>public</code>。由于成员对象使用自己的访问控制，所以是安全的，而当用户了结了我们所做的组装工作时，会更容易理解接口。</p>
<p><code>is-a</code>关系用继承表达，<code>has-a</code>关系用组合表达。</p>
<p>如果由一个已存在的类创建一个新类，并且希望这个类的每件东西都进来，就称为<code>子类型化(subtyping)</code>。这个新类与已存在的类有着严格相同的接口(希望增加任何我们想要加入的其他成员函数)，所以能在已经用过这个已存在的类的任何地方使用这个新类，这就是必须使用继承的地方。</p>
<p>通过在基类表中去掉<code>public</code>或通过显式地声明<code>private</code>，可以私有地继承基类。当私有继承时，我们是“照此实现”；也就是说，创建的新类具有基类的所有数据和功能，但这些功能是隐藏的，所以它只是部分的内部实现。该类的用户访问不到这些内部功能，并且一个对象不能被看做是这个基类的实例。</p>
<p>为了完整性，private继承被包含在该语言中。但是通常希望使用组合而不是private继承。</p>
<p>私有继承时，基类的所有public成员都变成了private。如果希望其中的任何一个是可视的，只要用派生类的public部分声明它们的名字即可</p>
<pre><code>using Pet::eat;
</code></pre><p>其中<code>Pet</code>是私有继承的类，这样就可以使用<code>Pet</code>类中的<code>eat</code>成员函数。</p>
<p>这样，如果想要隐藏基类的部分功能，则private继承是有用的。注意给出一个重载函数的名字将使基类中的所有它的重载版本公有化。</p>
<p>在使用private继承取代组合之前，应当仔细考虑，当与运行时类型标识相连时，私有继承特别复杂。</p>
<p>实际项目中，有时希望某些东西隐藏起来，但仍允许其派生类的成员访问，此时可用protected。它的意思是：“就这个类的用户而言，它是private的，但它可被从这个类继承来的任何类使用”。</p>
<p>最好让数据成员是<code>private</code>，因为我们应该保留改变内部实现的权利。然后才能通过<code>protected</code>成员函数控制对该类的继承者的访问。</p>
<p>保护继承的派生类意味着对其他类来说是“照此实现”，但它是对于派生类和友元是<code>is-a</code>。它是不常用的，它的存在只是为了语言的完备性。</p>
<p>除了赋值运算符以外，其余的运算符可以自动地继承到派生类中。</p>
<p>直到我们已经很好地学会程序设计并完全理解这个语言时，我们才能试着去用多重继承。不管我们如何认为我们必须用多重继承，我们总是能通过单继承完成。</p>
<p>多重继承引起很多含糊的可能性。</p>
<p>继承和组合的优点之一是它支持渐增式开发(incremental development)，它允许在已存在的代码中引进代码，而不会给原来的代码带来错误。</p>
<p>认识到程序开发就像人的学习过程一样，是一个渐增的过程，这是很重要的。我们能做尽可能多的分析，但当开始一个项目时，我们仍不可能知道所有的答案。</p>
<p>记住，继承首先是表示一种关系，即“新类属于老类的类型(a type of)”。我们的程序不应当关心怎样怎样摆布位，而应当关心如何创建和处理各类型的对象，以便用问题空间的术语表示模型。</p>
<p>继承最重要的方面不是它为新类提供了成员函数，而是它是基类与新类之间的关系，这种关系可被描述为：“新类属于原有类的类型”。</p>
<p>这个描述不仅仅是一种想象的解释继承的方法──它直接由编译器支持。将新类的引用或指针转变成基类的引用或指针的活动被称为<code>向上类型转换(upcasting)</code>。</p>
<p>为什么要“向上类型转换” 这个术语的引入是有其历史原因的，而且它也与类继承图的传统画法有关：在顶部是根，向下生长。</p>
<p>向上类型转换总是安全的。因为是从更专门的类型到更一般的类型──对于这个类接口可能出现的唯一事情是它失去成员函数，而不是获得它们。这就是编译器允许向上类型转换而不需要显式地说明或做其他标记的原因。</p>
<p>必须记住无论何时我们在创建了子集的拷贝构造函数时，都要正确地调用基类拷贝构造函数(正如编译器所作的)。</p>
<h2 id="u7B2C15_u7AE0__u591A_u6001_u6027_u548C_u865A_u51FD_u6570"><a href="#u7B2C15_u7AE0__u591A_u6001_u6027_u548C_u865A_u51FD_u6570" class="headerlink" title="第15章 多态性和虚函数"></a>第15章 多态性和虚函数</h2><p>多态性(在C++中通过虚函数来实现)是面向对象程序设计语言中数据抽象和继承之外的第三个基本特性。</p>
<p><code>多态性(polymorphism)</code>提供了接口与具体实现之间的另一层隔离，从而将<code>what</code>与<code>how</code>分离开来。多态性改善了代码的组织性和可读性，同时也使创建的程序具有可拓展性。</p>
<p><code>封装(encapsulation)</code>通过组合特性和行为来生成心的数据类型。访问控制通过使细节数据设为private，将接口从具体实现中分离开来。</p>
<p>C程序员可以用三步演变为C++程序员。</p>
<ol>
<li>第一步：简单地把C++作为一个“更好的C”。</li>
<li>第二步：进入“基于对象”的C++。</li>
<li>第三步：了解和使用虚函数，这是理解面向对象程序设计的转折点。不用虚函数，就等于还不懂得面向对象程序设计(OOP)，虚函数增强了类型概念，而不只是在结构内部隐蔽地封装代码。</li>
</ol>
<p>取一个对象的地址(指针或引用)，并将其作为基类的地址来处理，这被称为向上类型转换(upcasting)，因为继承树的绘制方式是以基类为顶点的。</p>
<p>把函数体与函数调用相联系称为捆绑(binding)。当捆绑在程序运行之前(由编译器和连接器)完成时，这称为早捆绑(early binding)。C编译只有一种函数调用方式，就是早捆绑。晚捆绑(late binding)意味着捆绑根据对象的类型，发生在运行时。晚捆绑又称为动态捆绑(dynamic binding)或运行时捆绑(runtime binding)。对于一种编译语言，编译器并不知道实际的对象类型，但它插入能找到和调用正确函数体的代码。</p>
<p>对于特定的函数，为了引起晚捆绑，C++要求在基类中声明这个函数时使用<code>virtual</code>关键字。晚捆绑只对<code>virtual</code>函数起作用，而且只在使用含有<code>virtual</code>函数的基类的地址时发生，尽管它们也可以在更早的基类中定义。</p>
<p>为了创建一个像<code>virtual</code>这样的成员函数，可以简单地在声明这个函数时使用<code>virtual</code>关键字。仅仅在声明的时候需要使用关键字virtual，定义时并不需要。如果一个函数在基类中被声明为<code>virtual</code>，那么在所有的派生类中它都是<code>virtual</code>的。在派生类中<code>virtual</code>函数的重定义通常称为<code>重写(overriding)</code>。</p>
<p>注意，仅需要在基类中声明一个函数为virtual。调用所有匹配基类声明行为的派生类函数都将使用虚机制。</p>
<p>在一个设计风格良好的OOP程序中，大多数甚至所有的函数都可以沿用基类的某个模型，只需与基类接口通信。这样的程序是可拓展的(extensible)，因为可以通过从公共基类继承新数据类型而增加新功能。操作基类接口的函数完全不需要改变就可以适合于这些新类。</p>
<p>关键字<code>virtual</code>告诉编译器它不应当执行早捆绑，相反，它应当自动安装对于实现晚捆绑必需的所有机制。</p>
<p>为了达到这个目的，典型的编译器对每个包含虚函数的类创建一个<code>表(VTABLE)</code>。在<code>VTABLE</code>中，编译器放置特定类的虚函数的地址。在每个带有虚函数的类中，编译器秘密地防止一个指针，称为<code>vpointer(缩写为VPTR)</code>，指向这个对象<code>VTABLE</code>。当通过基类指针做虚函数调用时(也就是做多台调用时)，编译器静态地插入能取得这个<code>VPTR</code>并在<code>VTABLE</code>表中查找函数地址的代码，这样就能调用正确的函数并引起晚捆绑的发生。</p>
<p>为每个类设置<code>VTABLE</code>，初始化<code>VPTR</code>、为虚函数调用插入代码，所有这些都是自动发生的。利用虚函数，即使在编译器还不知道这个对象的特定类型的情况下，也能调用这个对象中正确的函数。</p>
<p>如果有一个或多个虚函数，编译器都只在这个结构中插入一个单个指针(VPTR)，指向一个存放函数地址的表。我们只需要一个表，因为所有虚函数地址都包含在这个但个表里。</p>
<p>C++并不是对于绝对地址的一个简单的CALL，而是为设置虚函数调用需要两条以上的复杂的汇编指令。这既需要代码空间，又需要执行时间。</p>
<p>一些面向对象的语言已经接受了这种途径，即晚捆绑对于面向对象程序设计是性质所固有的，所以应当总是出现，它不应当是可选的，而且用户并不一定需要知道它。这是在创造语言的设计时决定的，而这种特殊的方法对于许多语言是适合的(smalltalk、Java和Python)。</p>
<p><code>virtual</code>关键字可以改变程序的效率。当设计类时，我们不应当为效率问题担心。如果使用多态，就处处使用虚函数。当试图加速代码时，只需寻找可以不使用虚函数的函数。</p>
<p>有些证据表明，C++中的规模和速度改进效果是在C的规模和速度的10%之内，并且常常更接近。能够得到更小的规模和更高速度的原因是C++可以有比C更快的方法设计程序，而且设计的程序更小。</p>
<p>在设计时，常常希望基类仅仅作为其派生类的一个接口。这就是说，仅想对基类进行向上类型转换，使用它的接口，而不希望用户实际地创建一个基类对象。就可以在基类中加入至少一个纯虚函数(pure virtual function)，来使基类成为抽象(abstract)类。纯虚函数使用关键字virtual，并且在其后面加上= 0。如果试着生成一个抽象类的对象，编译器会制止他。</p>
<p>当继承一个抽象类时，必须实现所有的纯虚函数，否则继承出的类也将是一个抽象类。创建一个纯叙述函数允许在接口中放置成员函数，而不一定要提供一段可能对这个函数毫无意义的代码。同时纯虚函数要求继承出的类对它提供一个定义。</p>
<p>建立公共接口的唯一原因是它能对于每个不同的子类有不同的表示。它建立一个基本的格式，用来确定什么是对于所有派生类是公共的──除此之外，别无用途。当仅希望通过一个公共接口来操纵一组类，且这个公共接口不需要实现(或者不需要完全实现)时，可以创建一个抽象类。语法为：</p>
<pre><code>virtual void f() = 0;
</code></pre><p>这样做，等于告诉编译器在VTABLE中为函数保留一个位置，但在这个特定位置中不放地址。只要有一个函数在类中被声明为纯虚函数，则VTABLE就是不完全的。</p>
<p>如果一个类的VTABLE是不完全的，当试图创建这个类的对象时，编译器就发出一个出错信息。这样，编译器就保证了抽象类的纯洁性，就不会被误用了。</p>
<p>一个类若全是纯虚函数，就称为纯抽象类(pure abstract class)。纯序函数是非常有用的，因为它们使得类有明显的抽象性，并告诉用户和编译器打算如何使用。</p>
<p>注意，纯虚函数禁止对抽象类的函数以传值方式调用。这也是防止对象切片(object slicing)的一种方法。通过抽象类，可以保证在向上类型转换期间总是使用指针或引用。</p>
<p>当实现继承和重新定义一些虚函数时，编译器对新类创建一个新的VTABLE表，并且插入新函数的地址，对于没有重新定义的虚函数使用基类函数的地址。无论如何，对于可被创建的每个对象(即它的类不含有纯虚函数)，在VTABLE中纵有一个函数地址的全集，所以绝对不能对不在其中的地址进行调用(否则结果将是灾难性的)。</p>
<p>若在派生(derived)类中继承或增加新的虚函数，那么通过基类的指针是无法进行调用的。</p>
<p>如果知道保存在一般容器中的所有对象的确切类型，会使我们的设计工作在最佳状态(或者没有选择)。这就是运行时类型辨认(Run-Time Type Identification,RTTI)问题。RTTI是有关向下类型转换基类指针到派生类指针的问题。向上类型转换是自动发生的，不需强制，因为它是绝对安全的。向下类型转换是不安全的，因为这里没有关于实际类型的编译时信息，所以必须准确地知道这个类实际是什么类型。如果把它转换称错误的类型，就会出现麻烦。</p>
<p>当多态地处理对象时，传地址与传值有明显的不同。如果对一个对象进行向上类型转换，而不使用地址或引用，这个对象将会被“切片”，直到剩下来的是适合于目的的子对象。确切地来说，派生类对象会被切片成一个基类对象。</p>
<p>对象切片实际上是当它拷贝到一个新的对象时，去掉原来对象的一部分，而不是像使用指针或引用那样简单地改变地址和内容。因此，不常使用对象向上类型转换，事实上，通常要提防或防止这种操作。</p>
<p>重新定义一个基类中的重载函数将会隐藏所有该函数的其他基类版本。而当对虚函数进行这些操作的时候，情况会有点不同。</p>
<p>编译器不允许我们改变重新定义过的虚函数的返回值(如果不是虚函数，则是允许的)。这是一个非常重要的限制，因为编译器必须保证我们能够多态地通过基类调用函数，若返回值不同，那么就会产生问题。</p>
<p>如果重新定义了基类中的一个重载成员函数，则在派生类中其他的重载函数将会被隐藏。例如，基类中有f(int)和f(string)这样的重载函数，如果我在派生类中重新定义了f(int)，那么对于这个派生类来说，f(string)就被隐藏了，不可用了。</p>
<p>通常，我们不能在重新定义过程中修改虚函数的返回类型，但是也有特例，如果返回一个指向基类的指针或引用，则该函数的重新定义版本可以从基类返回的内容中返回一个指向派生类的指针或引用。</p>
<p>当创建一个报含有虚函数的对象时，必须初始化它的VPTR以指向相应的VTABLE。这必须在对虚函数进行任何调用之前完成。编译器在构造函数开头部分秘密地插入能初始化VPTR的代码。</p>
<p>当寻找效率漏洞时，我们必须明白，编译器正在插入隐藏代码到我们构造函数中。这些隐藏代码不仅必须初始化VPTR，而且还必须检查this的值(以免operator new返回零)和调用基类构造函数。放在一起，这些代码可以影响我们认为是一个小内联函数的调用。特别是，构造函数的规模会抵消函数调用代价的减少。如果做大量的内联构造函数调用，代码长度就会增长，而在速度上没有任何好处。</p>
<p>当然，也许并不会立即把所有这些小构造函数都变成非内联，因为它们更容易写为内联构造函数。但是，当我们正在调整我们的代码时，务必去掉这些内联构造函数。</p>
<p>所有基类构造函数总是在继承类构造函数中被调用。派生类只访问它自己的成员，而不访问基类的成员。只有基类构造函数能正确地初始化它自己的成员。如果不在构造函数初始化表达式表中显式地调用基类构造函数，他就调用默认构造函数。如果没有默认构造函数，编译器将报告错误。</p>
<p>构造函数调用的顺序是重要的。当继承时，必须知道基类的全部成员并能访问基类的任何<code>public</code>和<code>protected</code>成员。在通常的成员函数中，构造已经发生，所以这个对象的所有部分的成员都已经建立。然而，在构造函数中，必须想办法保证所有成员都已经建立。保证它的惟一方法是让基类构造函数首先被调用。</p>
<p>只要可能，我们应当在构造函数初始化表达式表中初始化所有的成员对象。只要遵从这个做法，我们就能保证初始化所有基类成员和当前对象的成员对象。</p>
<p>对于在构造函数中调用一个虚函数的情况，被调用的只是这个函数的本地版本。也就是说，虚机制在构造函数中不工作。</p>
<p>构造函数的工作是生成一个对象。在任何构造函数中，可能只是部分形成对象──我们只能知道基类已被初始化，但并不能知道哪个类是从这个基类继承来的。然而，虚函数在继承层次上是“向前”和“向外”进行调用。它可以调用在派生类中的函数。如果我们在构造函数中也这样做，那么我们所调用的函数可能操作还没有被初始化的成员。这将导致灾难的发生。</p>
<p>当一个构造函数被调用时，它做的首要事情之一就是初始化它的<code>VPTR</code>。然而，它只能知道它属于“当前”类──即构造函数所在类。于是它完全忽视这个对象是否是基于其他类的。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码──既不是为基类，也不是为它的派生类。<code>VPTR</code>的状态是由被最后调用的构造函数确定的。</p>
<p>当这一系列构造函数调用正发生时，每个构造函数都已经设置<code>VPTR</code>指向子集的<code>VTABLE</code>。如果函数调用使用虚机制，它将只产生通过它自己的<code>VTABLE</code>的调用，而不是最后派生的<code>VTABLE</code>。</p>
<p>总之，在构造函数中调用虚函数都不能得到预期的结果。</p>
<p>构造函数是不能为虚函数的。但析构函数能够且常常必须是虚的。</p>
<p>构造函数有一项特殊工作，即一块一块地组合成一个对象。它首先调用基类构造函数，然后调用在继承顺序中的更晚派生的构造函数。类似地，析构函数也有一项特殊工作，即它必须拆卸属于某层次类的对象。析构函数自最晚派生的类开始，并向上到基类。</p>
<p>如果通过指向某个对象基类的指针操纵这个对象(也就是通过它的一般接口操纵这对象)，当我们想在<code>delete</code>在栈中已经用<code>new</code>创建的对象的指针时，就会出现这个问题。如果这个指针是指向基类的，在<code>delete</code>期间，编译器只能知道调用这个析构函数的基类版本，幸运的是，析构函数可以是虚函数。</p>
<p>不把析构函数设为虚函数是一个隐匿的错误，因为它常常不会对程序有直接的影响，但是会不知不觉引入存储器泄露(关闭程序时内存未释放)。同样，这样的析构操作还有可能掩盖发生的问题。</p>
<p>尽管纯虚析构函数在标准C++中是合法的，但在使用的时候有一个额外的限制：必须为纯虚析构函数提供一个函数体。纯虚析构函数和非纯虚虚构函数之间的唯一不同之处在于纯虚析构函数使得基类是抽象类，所以不能创建一个基类的对象(如果基类的任何其他函数是纯虚函数，也是具有同样的效果)。</p>
<p>当从某个含有虚析构函数的类中继承出一个类，情况变得有点复杂。不像其他的纯虚函数，我们不要求在派生类中提供纯虚函数的定义。</p>
<p>一般来说，如果在派生类中基类的纯虚函数(和所有其他纯虚函数)没有重新定义，则派生类将会成为抽象类。但是这里编译器将会自动地为每个类生成一个析构函数定义，基类的析构函数被重写(重新定义)，因此编译器会提供定义并且派生类实际上不会成为抽象类。</p>
<p>当我们的类仅含有一个纯虚函数时，就会发现这个唯一的差别：析构函数。这里析构函数的纯虚性的唯一效果是阻止基类的实例化。如果有其他的纯虚函数，则它们会阻止基类的实例化。</p>
<p>作为一个准则，任何时候我们的类中都要有一个虚函数，我们应当立即增加一个虚析构函数(即使它什么也不做)。这样，我们保证在后面不会出现问题。</p>
<p>在析构期间，有一些我们可能不希望马上发生的情况。如果正在一个普通的成员函数中，并且调用一个虚函数，则会使用晚捆绑机制来调用这个函数。而对于析构函数，这样不行，不论是虚的还是非虚的。在析构函数中，只有成员函数的“本地”版本被调用；虚机制被忽略。</p>
<p>负责动态对象创建(使用<code>new</code>)的对象进行<code>delete</code>调用的称之为“所有者”。在使用容器时的问题是，它们需要足够的灵活性用来接收不同类型的对象。为了做到这一点，容器使用<code>void</code>指针，因此它们并不知道所包容对象的类型。删除一个<code>void</code>指针并不调用析构函数，所以容器并不负责清除它的对象。</p>
<p>一种方法要求我们要为想在容器中容纳的每一种类型都派生出新类。</p>
<p>问题是我们希望容器可以容纳更多的类型，但我们不想使用void指针。另外一种解决方法是使用多态性，它通过强制容器内的所有对象从同一个基类继承而来。也就是说，容器容纳了具有同一基类的对象，并随后调用虚函数──特别地，我们可以调用虚析构函数来解决所有权问题。</p>
<p>这种解决方法使用<code>单根继承(singly-rooted hierarchy)</code>或<code>基于对象的继承(object-based hierarchy)</code>。事实上，除了C++，每种面向对象的语言都强制使用这样的体系──当创建一个类时，都会直接或间接地从一个公共基类中继承出它，这个基类是由该语言的创建者生成的。C++中认为，强制地使用这个公共基类会引起太多的开销，所有便没有使用它。</p>
<p>就像对成员函数那样，我们可以使用virtual运算符。然而，因为我们可能对两个不知道类型的对象进行操作，所以实现virtual运算符通常会很复杂。这通常用于处理数学部分。</p>
<p>C++提供了一个特殊的称为<code>dynamic_cast</code>的<code>显式类型转换(explicit cast)</code>，它就是一种<code>安全类型向下类型转换(type-safe downcast)</code>的操作。当使用<code>dynamic_cast</code>来试着向下类型转换一个特定的类型，仅当类型转换是正确的并且是成功的时，返回值会是一个指向所需类型的指针，否则它将会返回0来表示这并不是正确的类型。<br>当使用<code>dynamic_cast</code>时，必须对一个真正多态的层次进行操作──它含有虚函数──这因为<code>dynamic_cast</code>使用了存储在<code>VTABLE</code>中的信息来判断实际的类型，所以运行时需要一点额外的开销。</p>
<h2 id="u7B2C16_u7AE0__u6A21_u677F_u4ECB_u7ECD"><a href="#u7B2C16_u7AE0__u6A21_u677F_u4ECB_u7ECD" class="headerlink" title="第16章 模板介绍"></a>第16章 模板介绍</h2><p>继承和组合提供了重用对象代码的方法，而C++的模板特征提供了重用源代码的方法。</p>
<p>在一般程序设计问题中，程序员在编写程序时并不知道将来需要创建多少个对象。C++中有更好的解决方法：用new创建所需要的对象，将其指针放入容器中，待实际实用时将其取出并进行处理。用这种方法，所创建的只是确实需要的对象。通常，在启动程序时没有可用的初始化条件。new允许等待，直到在环境中相关事件发生后，再实际地创建这个对象。</p>
<p>有三种源代码重用的方法：</p>
<ul>
<li>C方法：应该摒弃，由于它表现繁琐、易发生错误、缺乏美感，是非常低效的技术。</li>
<li>Smalltalk方法：通过继承来实现代码重用，既简单又直观。每个容器类包含通用的基类Object的项目。这是一种单纯的技巧，因为Smalltalk类层次上的任何类都源于Object的派生，任何容器可容纳任何类(包括容器本身)。这种基于通用的基类(常称为Object，在Java中也有类似情况)的单树形层次类型称为“基于对象的层次结构”。</li>
</ul>
<p>尽管具有多重继承的基于对象的层次结构在概念上是直观的，但是在实践上较为困难。</p>
<p>模板对源代码进行重用，而不是通过继承和组合重用目标代码。容器不再存放称为Object的通用基类，而是存放一个未指明的参数。当用户使用模板时，参数由编译器来替换。</p>
<p>C++中，模板实现了参数化类型(parameterized type)的概念。模板方法的另一个优点是，使对继承不熟悉、不适应的新程序员也能正确地使用密封的容器类。</p>
<p>template这个关键字会告诉编译器，随后的类定义将操作一个或更多未指明的类型。当由这个模板产生实际类代码时，必须指定这些类型以使编译器能够替换它们。</p>
<pre><code>template&lt;class T&gt;
class Array{
    enum{ size = 100 };
    T A[size];
public:
    T&amp; operator[](int index){....}
};
int main(){
    Array&lt;int&gt; ia;
    Array&lt;double&gt; da;
    ...
}
</code></pre><p>这里T是替换参数，它代表一个类型名称。在容器类中，它将出现在那些原本由某以特定类型出现的地方。</p>
<p>有时我们希望有非内联成员函数的定义。这时编译器需要在成员函数定义之前看到<code>template</code>声明。</p>
<pre><code>template&lt;class T&gt;
class Array{
    enum{ size = 100 };
    T A[size];
public:
    T&amp; operator[](int index);
};
template&lt;class T&gt;
T&amp; Array&lt;T&gt;::operator[] (int index) {...}
</code></pre><p>注意在引用模板的类名的地方，必须伴游该模板的参数列表。可以想象，在内部，使用模板参数列表中的参数修饰类名，以便为每一个模板实例产生唯一的类名标识符。</p>
<p>在template&lt;…&gt;之后的任何东西都意味着编译器在当时不为它分配存储空间，而是一直处于等待状态直到被一个模板示例告知。在编译器和连接器中有机制能去掉同一模板的多重定义。所以为了使用方便，几乎总是在头文件中放置全部的模板声明和定义。</p>
<p>可以认为模板为C++提供了一种弱类型(weak typing)机制，C++通常是强类型语言。</p>
<p>模板参数并不局限于类定义的类型，可以使用编译器内置类型。这些参数值在编译期间编程模板的特定示例的常量。我们甚至可以对这些参数使用默认值。</p>
<pre><code>template&lt;class T, int size = 100&gt;
class Array{
    T array[size];
public:
    int length() const { return size; }
};
</code></pre><p>这里的<code>size</code>决不存放在类中，但对它的使用就如同是成员函数中的数据成员。</p>
<p>如果某个类有一个指向<code>Array</code>的指针，而不是指向类型<code>Array</code>的嵌入对象。该指针在构造函数中不被初始化，而是推迟到第一次访问时。这称为<code>懒惰初始化(lazy initialization)</code>。如果创造大量的对象，但不访问每一个对象，为了节省存储，可以使用懒惰初始化技术。</p>
<p>以值包含对象的容器通常无需担心所有权问题，因为它们清晰地拥有它们所包含的对象。但是，如果容器内包含指向对象的指针(这种情况在C++中相当普遍，有其在多态的情况下)，而这些指针很可能用于程序的其他地方，那么删除该指针指向的对象会导致在程序的其他地方的指针对已销毁的对象进行引用。为了避免上述情况，在设计和使用容器时必须考虑所有权问题。</p>
<p>处理所有权问题的最好方法是由客户程序员来选择。这常常通过构造函数的一个参数来完成，它默认地指明所有权。</p>
<p>如果我们没有模板，那么在一个一般的容器内创建对象的一个拷贝是一个复杂的问题。使用模板，事情噢那个就相对简单了，只要说我们存放对象而不是指针就行了。</p>
<p><code>迭代器(iterator)</code>是一个对象，它在其他对象的容器上遍历，每此选择它们中的一个，不需要提供对这个容器的实现的直接访问。迭代器提供了一种访问元素的标准方法，无论容器是否提供了直接访问元素的方法。迭代器常常与容器类联合使用，而且迭代器在标准C++容器的设计和使用中是一个基本概念。迭代器也是一种<code>设计模式(design pattern)</code>。</p>
<p>迭代器通常模仿大多数指针的运算。然而，不同的是，迭代器的设计更安全，所以数组越界的可能性更小。</p>
<p>习惯上，用构造函数来创建迭代器，并把它与一个容器对象联系，并且在它的生命期中，不把它与不同的容器联系。</p>
<h2 id="u7B2C19_u7AE0__u6DF1_u5165_u7406_u89E3_u6A21_u677F"><a href="#u7B2C19_u7AE0__u6DF1_u5165_u7406_u89E3_u6A21_u677F" class="headerlink" title="第19章 深入理解模板"></a>第19章 深入理解模板</h2><p>C++模板应用的便利性远远超出了它只是一种<code>T类型容器”(containers of T)</code>的范畴。尽管其最初的设计动机是为了能产生类型安全的通用容器，但在现在C++中，模板也用来生成自定义代码，这些代码通过编译时的程序设计构造来优化程序的执行。</p>
<p>模板有两类：函数模板和类模板。二者都是由它们的参数来完全地描绘模板的特性。每个模板参数描述了下述内容之一：</p>
<ul>
<li>类型(或者是系统固有类型或者是用户自定义类型)。</li>
<li>编译时常数值(例如，整数、指针和某些静态实体的引用，通常是作为无类型参数的引用)。</li>
</ul>
<p>其他模板。</p>
<p>一个无类型模板参数必须是一个编译时所知的整数值。</p>
<pre><code>template&lt;class T, size_t N&gt;
</code></pre><p>在类模板中，可以为模板参数提供默认(缺省)参数，但是在函数模板中却不行。作为默认的模板参数，它们只能被定义一次，编译器会知道第一次的模板声明或定义。一旦引入了一个默认参数，所有它之后的模板参数也必须具有默认值。</p>
<h1 id="C++__u6280_u5DE7"><a href="#C++__u6280_u5DE7" class="headerlink" title="C++ 技巧"></a>C++ 技巧</h1><p>变量定义指定了变量的类型和标识符，也可以为对象提供初始值。定义时制定了初始值的对象被成为是<code>已初始化的（initialized）</code>。C++支持两种初始化变量的形式：<code>复制初始化（copy－initialization）</code>和<code>直接初始化（direct－initialization）</code>。复制初始化语法用等号，直接初始化则是把初始化式放在括号中</p>
<pre><code>int ival（1024）； //direct-initialization
int ival = 1024；    //copy-initialization
</code></pre><p>C++中初始化和赋值是两种不同的操作，请注意。并且直接初始化语法更灵活而且效率更高。</p>
<hr>
<p>定义如何进行初始化的成员函数称为<code>构造函数（constructor）</code>。和其他函数一样，构造函数能接受多个参数。一个类可以定义几个构造函数，每个构造函数必须接受不同数目或者不同类型的参数。</p>
<hr>
<p>内置类型（如int）变量是否自动初始化取决于变量定义的位置。在函数体外定义的变量都初始化为0，在函数体里定义的内置类型变量不进行自动初始化。除了用作赋值操作符的左操作数，未初始化变量用作任何其他用途都是没有定义的。未初始化变量引起的错误难以发现，永远不要依赖未定义行为。</p>
<hr>
<p>建议每个内置类型的对象都要初始化。虽然这样做并不总是必需的，但是会更加容易和安全，除非你确定忽略初始化式不会带来风险。</p>
<hr>
<p>如果定义某个类的变量时没有提供初始化式，这个类也可以定义初始化时的操作。它是通过定义一个特殊的构造函数即<code>默认构造函数（default constructor）</code>来实现的。如果没有提供初始化式，那么就会使用默认构造函数。不管变量在哪里定义，默认构造函数都会被使用。</p>
<hr>
<p><code>变量的定义（definition）</code>用于为变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量有且仅有一个定义。<code>声明（declaration）</code>用于项程序表明变量的类型和名字。定义也是声明；当定义变量时我们声明了它的类型和名字。可以通过使用<code>extern</code>关键字声明变量而不定义它。不定义变量的声明包括对象名。对象类型和对象类型前的关键字<code>extern</code>。</p>
<hr>
<p>在C++语言中，变量必须且仅能定义一次，而且在使用变量之前必须定义或者声明变量。</p>
<hr>
<p>用来区分名字的不同意义的上下文称为<code>作用域（scope）</code>。作用域是程序的一段区域。一个名称可以和不同作用域中的不同实体相关联。C++语言中，大多数作用域是用花括号来界定的。一般来说，名字从其声明点开始直到其声明所在的作用域结束处都是可见的。</p>
<hr>
<p>定义在所有函数外部的名字具有<code>全局作用域（global scope）</code>，可以在程序中的任何地方访问。定义在<code>main</code>函数的作用域，则在整个<code>main</code>函数中可以使用，具有<code>局部作用域（local scope）</code>。而在某个语句中定义的（例如for语句中），则只能在语句中使用，具有<code>语句作用域（statement scope）</code>。</p>
<hr>
<p>C++中作用域可嵌套，若先定义了全局变量s1，而又在main中定义了局部变量s1，那么，局部变量s1就会屏蔽全局变量s1。要注意的是，像上面这样的定义方法很可能让他人大惑不解，同名总是不好的，建议局部变量最好使用不同的名字。</p>
<hr>
<p>一般来说，变量的定义或声明可以放在程序中能摆放语句的任何位置。变量在使用前必须先声明或定义。通常把一个对象定义在它首次使用的地方是一个很好的办法。</p>
<hr>
<p>定义一个变量代表某一常数的方法仍然有一个严重的问题。此变量是可以被修改的。<code>const</code>限定符提供了一个解决办法，它把一个对象转换成一个常量。如下：</p>
<pre><code>const int bufsize ＝ 512；
</code></pre><p>此时变量<code>bufsize</code>是不可修改的，任何修改<code>bufsize</code>的尝试都会导致编译错误。因为常量在定义后就不能被修改，所以定义时必须初始化。</p>
<hr>
<p><code>const</code>对象默认为文件的局部变量，此变量只存在于那个文件中，不能被其他文件访问。非<code>const</code>变量默认为<code>extern</code>。要使<code>const</code>变量能够在其他文件中访问，必须显式地指定它为<code>extern</code>。</p>
<hr>
<p><code>引用（reference）</code>就是对象的另一个名字。在实际程序中，引用主要用作函数的形式参数。引用式一种<code>复合类型（compound type）</code>，通过在变量名前添加<code>&amp;</code>符号来定义。复合类型是指用其他类型定义的类型。在引用的情况下，每一种引用类型都“关联到”某一其他类型。不能定义引用类型的引用，但可以定义其他任何类型的引用。引用必须用与该引用同类型的对象初始化：</p>
<pre><code>int ival ＝ 1024；
int &amp;refVal = ival; //ok: refVal refers to ival
int &amp;refVal2;       //error: a reference must be initialized
int &amp;refVal3 = 10;  //error: initializer must be an object
</code></pre><hr>
<p>引用只是它绑定的对象的另一个名字，作用在引用上的所有操作事实上都是作用在该引用绑定的对象上。当引用初始化后，只要该引用存在，它就保持绑定到初始化时指向的对象。不可能将引用绑定到另一个对象。</p>
<hr>
<p>const引用是指向const对象的引用</p>
<pre><code>const int ival ＝ 1024；
const int &amp;refVal = ival;   //ok: both reference and object are const
int &amp;ref2 = ival;       //error: nonconst reference of a const object
</code></pre><p>可以读取但是不能修改refVal，任何对refVal的赋值都是不合法的。同理，用ival初始化ref2也是不合法的：ref2是普通的非const引用（nonconst reference）。</p>
<hr>
<p>const引用可以初始化为不同类型的对象或者初始化为右值，如字面值常量：</p>
<pre><code>int i = 42;
// legal for const references only
const &amp;r = 42;
const &amp;r2 = r + i;
</code></pre><p>同样的初始化对于非const引用却是不合法的，而且会导致编译时错误。这里稍微解释一下</p>
<pre><code>double dval = 3.14;
const int &amp;ri = dval;
</code></pre><p>编译器会把这些代码转换成如以下形式的编码：</p>
<pre><code>int temp = dval;     // create temporary int from the double
const int &amp;ri = temp;   // bind ri to that temporary
</code></pre><p>如果<code>ri</code>不是<code>const</code>，那么可以给<code>ri</code>赋一个新值。这样做不会修改dval，而是修改了temp。期望对ri的赋值会修改dval的程序员会发现dval并没有被修改。仅允许const引用绑定到需要临时使用的值完全避免了这个问题，因为const引用是只读的。</p>
<hr>
<p>typedef可以用来定义类型的同义词：</p>
<pre><code>typedef double wages;   // wages is a synonym for double
typedef int exam_score; // exam_score is a synonym for int
</code></pre><p>typedef名字可以用作类型说明符：</p>
<pre><code>wages hourly,  weekly;  // double hourly, weekly;
</code></pre><hr>
<p>typedef通常被用于以下三种目的：为了隐藏特定类型的实现，强调使用类型的目的；简化复杂的类型定义，使其更易理解；允许一种类型用于多个目的，同时使得每次使用该类型的目的明确。</p>
<hr>
<p>枚举的定义包括关键字 enum，其后是一个可选的枚举类型名，和一个用花括号括起来、用逗号分开的枚举成员（enumerator）列表。</p>
<pre><code>// input is 0, output is 1, and append is 2
enum open_mode {input, output, append};
</code></pre><p> 默认地，第一个枚举成员赋值为0，后面地每个枚举成员赋的值比前面的大1。</p>
<pre><code>//shape is 1, sphere is 2, cylinder is 3, polygon is 4
enum Forms {shape = 1, sphere, cylinder, polygon};
</code></pre><p>枚举成员值可以是不唯一的。每个enum都定义一种唯一的类型。</p>
<hr>
<p>每个类都定义了一个接口（interface）和一个实现（implementation）。接口由使用该类的代码需要执行的操作组成。实现一般包括该类所需要的数据。实现还包括定义该类需要的但又不供一般性使用的函数。定义类时，通常先定义该类的接口，即该类所提供的操作，可以决定该类完成其功能所需要的数据，以及是否需要定义一些函数来支持该类的实现。</p>
<hr>
<p>类定义以关键字class开始，其后是该类的名字标识符。类体位于花括号里面。花括号后面必须要跟一个分号。类体可以为空，类体定义了组成该类型的数据和操作。这些操作和数据是类的一部分，也称为类的成员（member）。操作称为成员函数，而数据则称为数据成员（data member）。</p>
<hr>
<p>用class和struct关键字定义类的唯一差别在于默认访问级别：默认情况下，struct的成员为public，而class的成员为private。</p>
<hr>
<p>因为头文件包含在多个源文件中，所以不应该含有变量或函数的定义。如果const变量不是用常量表达式初始化，那么它就不应该在头文件定义。相反，和其他的变量一样，该const变量应该在一个源文件中定义并初始化。应在头文件中为它添加extern声明，以使其能被多个文件共享。</p>
<hr>
<p>使得头文件安全的通用做法，是使用预处理器定义头文件保护符（header guard）。</p>
<pre><code>#ifndef someheader.h
#define someheader.h
#endif
</code></pre><p>头文件应该含有保护符，即使这些头文件不会被其他头文件包含。编写头文件保护符并不困难，而且如果头文件被包含多次，它可以避免难以理解的编译错误。</p>
<hr>
<p>C++提供了更简洁的方式来使用命名空间成员。这里介绍一种最安全的机制：using声明。形式为：using namespace：：name；</p>
<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
using std::cin;
using std::cout;
int main()
{
.......
}
</code></pre><hr>
<p>一个using声明一次只能作用于一个命名空间成员。每个名字都需要一个using声明。</p>
<hr>
<p>标准库string类型支持长度可变的字符串。一般的声明格式如下：</p>
<pre><code>#include &lt;string&gt;
using std::string;
</code></pre><p>string标准库支持几个构造函数，如下：</p>
<pre><code>string s1；              默认构造函数，s1为空串
string s2（s1）；          将s2初始化为s1的一个副本
string s3（“value”）；     将s3初始化为一个字符串字面值副本
string s4（n，‘c’）；       将s4初始化为字符‘c’的n个副本
</code></pre><p>因为历史原因以及为了与C语言兼容，字符串字面值与标准库string类型不是同一种类型，编程时一定要注意区别。</p>
<hr>
<p>string类型的输入操作符：读取并忽略开头所有的空白字符（如空格，换行符，制表符）；读取字符直至再次遇到空白字符，读取中止。</p>
<hr>
<p>读入未知数目的string对象</p>
<pre><code>while(cin &gt;&gt; word)
    cout &lt;&lt; word &lt;&lt; endl;
</code></pre><hr>
<p>用getline读取整行文本，该函数接受两个参数：一个输入流对象和一个string对象。getline函数从输入流的下一行读取，并保存读取的内容到string中，但不包括换行符。</p>
<pre><code>string line;
while (getline(cin, line))
    cout &lt;&lt; line &lt;&lt; endl;
</code></pre><p>因为line不含换行符，如果需要逐行输出则需要自行添加。</p>
<hr>
<p>VC 6和Xcode中对于getline的使用都存在bug。具体的表现是VC6里要输入两次回车才能输出，而Xcode的出错则是释放了未分配的指针。具体的解决方案如下</p>
<p>VC6：</p>
<p>X:\Program Files\Microsoft Visual Studio\VC98\Include\string(注意是string文件，不是string.h)找到165行，下面的代码从163行开始</p>
<pre><code>else if (_Tr::eq((_E)_C, _D)) //163行
{_Chg = true;
//  _I.rdbuf()-&gt;snextc(); // 把这一行注释掉,添加下一行.
_I.rdbuf()-&gt;sbumpc(); //添加
break;}
</code></pre><p>Xcode：有两种方案，其实差不多，第一种是在代码最前面加上</p>
<pre><code>#define _GLIBCXX_FULLY_DYNAMIC_STRING 1 
#undef _GLIBCXX_DEBUG 
#undef _GLIBCXX_DEBUG_PEDANTIC
</code></pre><p>第二种如下：</p>
<p>The solution is to double-click on the target to open its Info window, go to the Build tab, and scroll down to the “GCC 4.2 - Preprocessing” section. In this section is a setting named “Preprocessor Macros” that by default has two entries, “_GLIBCXX_DEBUG=1” and “_GLIBCXX_DEBUG_PEDANTIC=1”. Remove these entries.</p>
<hr>
<p>string的size和empty操作。可以通过size操作获取。</p>
<pre><code>int main(){
    string st(“The expense of spirit\n”);
    cout &lt;&lt;  “The size of ” &lt;&lt;  st &lt;&lt;  “is ” &lt;&lt;  st.size() &lt;&lt; endl;
    return 0;}
</code></pre><p>empty成员函数将返回bool值，如果string对象为空则返回ture，否则返回false。</p>
<hr>
<p>size操作返回的是string::size_type类型的值。string类类型和许多其他库类型都定义了一些配套类型（companion type）。通过这些配套类型，库类型的使用就能与机器无关（machine－independent）。size_type就是这些配套类型的一种。定义为与unsigned型具有相同的含义，而且可以保证足够大能够存储任意string对象的长度。为了使用类型定义的size_type类型，程序员必须加上作用域操作符来说明所使用的size_type类型是由string类定义的。即std::size_type类型。不要把size的返回值赋给int变量！</p>
<hr>
<p>对string对象来说，可以把一个string对象赋值给另一个string对象。string对象的加法被定义为（concatenation）。如下</p>
<pre><code>string s1(“hello, ”);
string s2(“world\n”);
string s3 = s1 + s2;        // s3 is hello, world\n
</code></pre><p>如果要把s2直接追加到s1的末尾，就用＋＝</p>
<pre><code>s1 += s2;
</code></pre><hr>
<p>当进行string对象和字符串字面值混合连接操作时，＋操作符的左右操作数必须至少有一个是string类型的：</p>
<pre><code>string s4 = “hello” + “, ”;     // error: no string operand
string s5 = s1 + “, ” + “world ”;   // ok: each + has string operand
string s6 = “hello” + “,” + s2; // error: can’t add string literals
</code></pre><p>顺序是从左到右的，所以s5中的s1先和第二个加，还是string类型，然后和第二个加；而s6中的第一个和第二个相加就不满足条件了。</p>
<hr>
<p>string类型通过下标操作符（ [] ）来访问string对象中的单个字符。下标操作符需要取一个size_type类型的值，来标明要访问字符的位置。着下标中的值通常被称为“下标”或“索引（index）”。string对象的下标从0开始而s[s.size()-1]就是最后一个字符。</p>
<hr>
<p>vector是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。我们把vector称为容器，是 因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型的。在使用vector之前，必须包含相应的头文件。声明如下</p>
<pre><code>#include &lt;vector&gt;
using std::vector;
</code></pre><hr>
<p>vector是一个类模板（class template）。使用模板可以编写一个类定义或函数定义，而用于多个不同的数据类型。声明从类模板生产的某种类型的对象，需要提供附加信息，信息的种类取决于模板。以vector为例，必须说明vector保存何种对象的类型，通过将类型放在类模板名称后面的尖括号中来指定类型：</p>
<pre><code>vector&lt;int&gt; ivec;               // ivec holds objects of type int
vector&lt;Sales_item&gt; Sales_vec        // holds Sale_itmes
</code></pre><p>和其他变量定义一样，定义vector对象要指定类型和一个变量的列表。上面的第一个定义，类型是vector<int>，该类型即是含有若干int类型对象的vector，变量名为ivec。</int></p>
<hr>
<p>vector不是一种数据类型，而只是一个类模板，可用来定义多种数据类型。vector类型的每一种都指定了其保存元素的类型。因此，vector<int>和vector<string>都是数据类型。</string></int></p>
<hr>
<p>vector对象的初始化方式</p>
<pre><code>vector&lt;T&gt;  v1；          vector保存类型为T的对象，默认构造函数v1为空
vector&lt;T&gt;  v2；          v2是v1的一个副本
vector&lt;T&gt;  v3（n，i）；     v3包含n个值为i的元素
vector&lt;T&gt;  v4（n）；       v4含有值初始化的元素的n个副本
</code></pre><hr>
<p>vector对象（以及其他标准库容器对象）的重要属性就在于可以在运行时高效地添加元素。因为vector增长地效率高，在元素值已知的情况下，最好是动态地添加元素。</p>
<hr>
<p>vector对象的size</p>
<p>empty和size操作类似于string类型的相关操作。成员函数size返回相应vector类定义的size_type值。使用size_type类型时，必须指出该类型时在哪里定义的。vector类型总是包括vector的元素类型：</p>
<pre><code>vector&lt;int&gt;::size_type      // ok
vector::size_type           // error
</code></pre><hr>
<p>向vector添加元素。push_back()操作接受一个元素值，并将它作为一个新的元素添加到vector对象的后面。</p>
<pre><code>// read words from the standard input and store them as elements in vector
string word;
vector&lt;string&gt; text;                // empty vector
while(cin &gt;&gt; word){
    text.push_back(word);       // append word to text
}
</code></pre><hr>
<p>vector中的对象是没有命名的壳以按vector中对象的位置来访问它们。通常使用下标操作符来获取元素。vector元素的位置从0开始。</p>
<hr>
<p>必须是已存在的元素才能用下标操作符进行索引。通过下标操作进行赋值时，不会添加任何元素。如果想要插入新元素，写法如下：</p>
<pre><code>for (vector&lt;int&gt;::size_type ix = 0; ix != 10; ++ix)  //这样的话就保证了索引和实际一致
    ivec.push_back(ix);
</code></pre><hr>
<p>除了使用下标来访问vector对象的元素外，标准库还提供了另外一种访问元素的方式：使用迭代器（iterator），迭代器时一种检查容器内元素并遍历元素的数据类型。标准库为每一种标准容器（包括vector）定义了一种迭代器类型。迭代器类型提供了比下标操作更通用化的方法：所有的标准库容器都定义了相应的迭代器类型，而只有少数的容器支持下标操作。因此，现代C++程序更倾向于使用迭代器而不是下标来访问容器元素。</p>
<hr>
<p>容器的iterator类型，定义如下（以vector为例）</p>
<pre><code>vector&lt;int&gt;::iterator iter；
</code></pre><p>每种容器都定义了一对名为begin和end的函数，用于返回迭代器。如果容器中有元素的话，由begin返回的迭代器指向第一个元素：</p>
<pre><code>vector&lt;int&gt;::iterator iter ＝ ivec.begin();
</code></pre><p>上述语句把iter初始化为ivec[0]。由end操作返回的迭代器指向vector的“末端元素的下一个”。通常称为超出末端迭代器（off－the －end iterator），只是起一个哨兵（sentinel）的作用，表示我们已经处理完了vector中的所有元素。</p>
<hr>
<p>迭代器可以使用解引用操作符（*操作符）来访问迭代器所指向的元素</p>
<pre><code>*iter ＝ 0；  //即把iter当前指向的元素赋值为0
</code></pre><p>迭代器使用自增操作符向前移动迭代器指向容器中的下一个元素。</p>
<p>由于end操作返回的迭代器不指向任何元素，因此不能对它进行解引用或自增操作。</p>
<hr>
<p>用 == 或者 != 操作符来比较两个迭代器，如果两个迭代器对象指向同一个元素，则它们相等，否则就不相等。</p>
<hr>
<p>应用迭代器来编写的初始化为0的循环</p>
<pre><code>for(vector&lt;int&gt;::iterator iter = ivec.begin(); iter != ivec.end(); ++iter )
    *iter = 0;
</code></pre><hr>
<p>若定义为const_iterator类型，就只能用于读取容器内元素，但不能改变其值。而如果时const的iterator对象，那么这个迭代器就不能改变，这样基本就无用的。下面是一个const_iterator的例子：</p>
<pre><code>for(vector&lt;string&gt;::const_iterator iter = text.begin(); iter != text.end(); ++iter)
    cout &lt;&lt;  *iter &lt;&lt; endl;
</code></pre><hr>
<p>迭代器的算术操作（iterator arithmetic）：iter ＋ n与 iter － n。iter1 － iter2 用来计算两个迭代器对象的距离，该距离时名为difference_type的signed类型的值。例如求最靠近正中的元素，可用以下代码：</p>
<pre><code>vector&lt;int&gt;::iterator mid = vi.begin() + vi.size()/2;
</code></pre><p>任何改变vector长度的操作都会使已存在的迭代器失效。例如，在调用push_back后，就不能再信赖指向vector的迭代器的值了。</p>
<hr>
<p>标准库bitset类型可以用来处理二进制位的有序集，可以使用bitset处理，声明如下：</p>
<pre><code>#include &lt;bitset&gt;
using std::bitset;
</code></pre><hr>
<p>类似于vector，bitset类是一种类模板；而与vector不一样的是bitset类型对象的区别仅在其长度而不在其类型。定义bitset时，要明确bitset含有多少位，要在尖括号内给出它的长度值：</p>
<pre><code>bitset&lt;32&gt; bitvec;  // 32 bits, all zero
</code></pre><p>长度值必须定义为整型字面值常量或者是已用常量值初始化的整型的const对象。bitset中的位是没有命名的，程序员只能按位置访问。位集合的位置编号从0开始，以0位开始的位串是低阶位（low-order bit），以31位结束的位串是高阶位（high-order bit)。</p>
<hr>
<p>用unsigned值初始化bitset对象时，该值将转化为二进制的位模式。而bitset对象中的位集作为这种位模式的副本。如果bitset类型长度大于unsigned long值的二进制位数，则其余的高阶位将置为0；如果小于，则只使用unsigned值中的低阶位，其余的被丢弃。</p>
<hr>
<p>用string对象初始化bitset对象时，string对象直接表示为位模式。从string对象读入位集的顺序时从右向左：</p>
<pre><code>string strval(“111000”);
bitset&lt;32&gt; bitvec4(strval);
</code></pre><p>那么这时bitvec4的表示为：0000000000···000111（共32位）</p>
<pre><code>string str（“1111111000000011001101”）；
bitset&lt;32&gt; bitvec5(str, 5, 4);      //从str[5]开始的4个位。即1100
bitset&lt;32&gt; bitvec6（str，str.size()-4）    //取最后的四位。即1101
</code></pre><hr>
<p>现代C++程序应尽量使用vector和迭代器类型，而避免使用低级的数组和指针。设计良好的程序只有在强调速度时才在类实现的内部使用数组和指针。指针和数组容易产生不可预料的错误。其中一部分是概念上的问题：指针用于低级操作，容易产生与繁琐细节相关的（bookkeeping）错误。其他错误则源于使用指针的语法规则，特别是声明指针的语法。许多有用的程序都可不使用数组或指针实现，现代C++采用vector类型和迭代器取代一般的数组、采用string类型取代C风格字符串。</p>
<hr>
<p>如果可能的话，除非所指向的对象已经存在，否则不要先定义指针，这样可以避免定义一个未初始化的指针。如果必须分开定义指针和其所指向的对象，则将指针初始化未0。因为编译器可检测出0值的指针，程序可判断该指针并未指向一个对象。</p>
<hr>
<p>C++提供了一种特殊的指针类型 <code>void*</code>，它可以保存任何类型对象的地址。<code>void*</code>表明改指针与一地址值相关，但不清楚存储在此地址上的对象的类型。<code>void*</code>指针只支持几种有限的操作：与另一个指针进行比较；向函数传递<code>void*</code>指针或从函数返回<code>void*</code>指针；给另一个<code>void*</code>指针赋值。不允许使用<code>void*</code>指针操纵它所指向的对象。</p>
<hr>
<p>如果对左操作数进行解引用，则修改的是指针所指对象的值；如果没有使用解引用操作，则修改的是指针本身的值。</p>
<hr>
<p>如果指针指向const对象，则不允许用指针来改变其所指的const值。为了保证这个特性，C++语言强制要求指向const对象的指针也必须具有const特性：</p>
<pre><code>const double *cptr ;        // cptr may point to a double that is const
</code></pre><p>这里cptr是一个指向double类型const对象的指针，const限定了cptr指针所指向的对象类型，而并非cptr本身。也就是说cptr本身并不是const（这里推荐从右向左读以上语句，就可以理解为cptr指向一个const的double类型）。在定义的时候不需要初始化，也可以对其重新赋值，但不能通过cptr修改其所指向对象的值；把你个const对象的地址赋给一个普通的、非const对象的指针也会导致编译时的错误；不能使用<code>void*</code>指针保存const对象的地址，而必须使用<code>const void*</code>类型的指针保存const对象的地址；允许把const对象的地址赋给指向const对象的指针。</p>
<hr>
<p>不能使用指向const对象的指针修改基础对象，然后如果该指针指向的是一个非const对象，可用其他方法修改其所指的对象。</p>
<pre><code>const double *cptr;
dval = 3.14159;     // dval is not const
*cptr = 3.14159;        // error: cptr is a pointer to const
double *ptr = &amp;dval;        // ok: ptr points at non-const double
*ptr = 2.72;            // ok: ptr is plain pointer
cout &lt;&lt; *cptr;          // ok: prints 2.72
</code></pre><hr>
<p>从本质上说，由于没有方法分辨cptr所指的对象是否为const，系统会把它所有对象都视为const。如果指向const的指针所指的对象并非const，则可直接给该对象赋值或间接地利用普通地非const指针修改其值：毕竟这个值不是const。就是说不能保证指向const地指针所指对象的值一定不能修改。</p>
<hr>
<p>C++还提供了const指针——本身的值不能修改。任何企图给const指针赋值的行为（即使是赋同样的值）都会导致编译时的错误。定义方式如下：</p>
<pre><code>const double pi ＝ 3.14159；
const double *const pi_ptr = &amp; pi;
// pi_ptr is const and points to a const object
</code></pre><hr>
<p>C风格字符串（C-style character string）是以空字符null结束的字符数组。尽管C++支持C风格字符串，但不应该在C++程序中使用这个类型。C风格字符串常常带来许多错误，是导致大量安全问题的根源。</p>
<hr>
<p>可以这么样利用循环测试C风格字符串：</p>
<pre><code>const char *cp = “some value”;
while (*cp){
++cp；//注意一定是C风格字符串，因为这样才能保证结尾是null，否则不能结束
}
</code></pre><hr>
<p>用关系操作符（&gt; &lt; ==）来比较C风格字符串时，比较的时指针上存放的地址值，而不是它们所指向的字符串。</p>
<hr>
<p>调用者必须确保目标字符串具有足够的大小，但是却有潜在的严重错误。如果必须使用C风格字符串，strncat和strncpy比strcat和strcpy函数更安全。诀窍就是可以适当地控制复制字符地个数。特别是在复制和串联字符串时，一定要时刻记住算上结束符null。所以尽可能使用标准库类型string，不但安全性增强了，效率也提高了。</p>
<hr>
<p>数组类型的变量有三个重要的限制：数组长度固定不变，在编译时必须直到其长度，数组只有在定义它的块语句内存在。每一个程序在执行时都占用一块可用的内存空间，用于存放动态分配的对象，此内存空间称为程序的自由存储区（free store）或堆（heap）。C语言程序使用一对标准库函数malloc和free在自由存储区中分配存储空间，而C++语言则使用new和delete表达式实现相同的功能。</p>
<hr>
<p>允许动态分配空数组（编译的时候并不知道数组的长度）。可以用以下代码实现</p>
<pre><code>size_t n = get_size()   // get_size returns of elements needed
int* p = new int[n];
for(int* q = p; q !=p+n; ++q)
.........(可见ex3.17-3.21)
</code></pre><p>有趣的是，即使get_size返回的是0，代码依然可以正确执行。C++虽然不允许定义长度为0的数组变量，但明确指出，调用new动态创建长度为0的数组是合法的，返回有效的非零指针。</p>
<hr>
<p>动态分配的内存最后必须进行释放。C++为指针提供了delete []表达式释放指针所指向的数组空间。如 delete [ ] pia；就回收了pia指向的数组。如果遗漏了空方括号对，就无法告诉编译器该指针指向的是数组，将导致程序在运行时出错。</p>
<hr>
<p>使用数组初始化vector对象，必须指出用于初始化式的第一个元素以及数组最后一个元素的下一位置的地址：</p>
<pre><code>const size_t arr_size = 6;
int int_arr[arr_size] = {0,1,2,3,4,5};
// ivec has 6 elements: each a copy of the corresponding element in int_arr
vector&lt;int&gt; ivec(int_arr, int_arr + arr_size);
</code></pre><p>传递给ivec的两个指针标出了vector初值的范围。第二个指针指向被复制的最后一个元素之后的地址空间。</p>
<hr>
<p>用typedef简化指向多维数组的指针</p>
<pre><code>typedef int int_array[4];
int_array *ip = ia;
for (int_array *p = ia; p != ia + 3; ++p)
    for(int *q = *p; q != *p + 4; ++q)
        cout &lt;&lt; *q &lt;&lt; endl;
</code></pre><hr>
<p>逻辑与和逻辑或操作符总是先计算其左操作数，然后再计算其右操作数。只有仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解其右操作数。我们称这种求值策略为“短路求值（short-circuit evaluation）”。这么就引出了一个很有价值的用法：如果某边界条件使expr2的计算变得危险，那么显然expr1的计算结果为false。（expr1 &amp;&amp;(||)expr2）</p>
<hr>
<p>不应该串接使用关系操作符，虽然是左结合，但是由于其返回bool类型的结果，如果多个关系操作符串接起来使用，结果往往出乎意料。</p>
<hr>
<p>val本身是bool类型，或者val具有可转换为bool类型的数据类型。如果val是bool类型，那么if（val == true ）等价于 if（val）。</p>
<p>若val不是bool值，val和true的比较等效于 if （val == 1）</p>
<hr>
<p>位操作符使用整型的操作数。位操作符将其整型操作数视为二进制位的集合，为每一位提供检验和设置的功能（也可用于bitset类型）。位操作符操纵的整数的类型可以是有符号的也可以是没有符号的。如果操作数为负数，具体的处理情况就要依照机器的情况来判定，所以保险起见，用unsigned整型操作数。</p>
<hr>
<p>一般而言，标准库提供的bitset操作更直接，更容易阅读和书写、正确使用的可能性更高。而且，bitset对象的大小不受unsigned数的位数限制。通常来说，bitset优于整形术句的低级直接位操作。</p>
<hr>
<p>在赋值操作上加圆括号是必需的，因为赋值操作符的优先级低于不等操作符。</p>
<hr>
<p>对于for循环来说，例如：for（语句1；条件；增殖）这样的，先执行语句1，再判断是否满足条件，满足的话执行完循环体，再进行增殖，这里使用++i与i++的效果是一样的。但是只有再必要时才使用后置操作符（i++），因为前置操作需要做的工作更少。只需加1后返回加1后的结果即可。而后置操作符则必须先保存操作数原来的值，以便返回未加1之前的值作为操作的结果。对于int型对象和指针，编译器可优化掉这项额外工作。但是对于更多的复杂迭代器类型，这种额外工作可能花费更大的代价。因此，养成使用前置操作这个好习惯，就不必担心性能差异的问题。</p>
<hr>
<p>sizeof操作符的作用是返回一个对象或类型名的长度，返回值的类型为size_t，长度的单位是字节。sizeof表达式的结果是编译时常量。</p>
<hr>
<p>对char类型或值为char类型的表达式做sizeof操作保证得1。</p>
<p>对引用类型做sizeof操作将返回存放此引用类型对象所需的内存空间大小。</p>
<p>对指针做sizeof操作将返回存放指针所需的内存大小；注意，如果要获取该指针所指向的对象的大小，则必须对该指针进行解引用。</p>
<p>对数组做sizeof操作等效于将对其元素类型做sizeof的结果乘上数组元素的个数。所以用sizeof数组的结果除以sizeof其元素类型的结果，即可求得数组元素的个数。</p>
<hr>
<p>逗号表达式是一组由逗号分隔的表达式，这些表达式从左向右计算。逗号表达式的结果是其最右边表达式的值。</p>
<hr>
<p>含有两个或更多操作符的表达式称为复合表达式（compound expression）。在复合表达式中，操作数和操作符的结合方式决定了整个表达式的值。表达式的结果会因为操作符和操作数的分组结合方式的不同而不同。操作数的分组结合方式决定了整个表达式的值。表达式的结果会因为操作符和操作数的分组结合方式的不同而不同。优先级规定的是操作数的结合方式，但并没有说明操作数的计算顺序。在大多数情况下，操作数一般以最方便的次序求解。</p>
<hr>
<p>以下两个指导原则有助于处理复合表达式：</p>
<p>（1）如果有怀疑，则在表达式上按程序逻辑要求使用圆括号强制操作数的组合。</p>
<p>（2）如果要修改才做数的值，则不要在同一个语句的其他地方使用该操作数。如果必须使用改变的值，则把该表达式分割成两个独立语句：在一个语句中改变操作数的值，再在下一个语句使用它。</p>
<p>一个表达式里，不要在两个或更多的子表达式中对同一对象做自增或自减操作。</p>
<hr>
<p>定义变量时，必须指定其数据类型和名字。而动态创建对象时，只需指定其数据类型，而不必为该对象命名。取而代之的是，new表达式返回指向新创建对象的指针，我们通过该指针来访问此对象：</p>
<pre><code>int *pi = new int;  //pi points to dynamically allocated, unnamed, uninitialized int
</code></pre><p>这个new表达式在自由存储区中分配创建了一个整型对象，并返回此对象的地址，并用该地值初始化指针pi。</p>
<hr>
<p>动态创建的对象可用初始化变量的方式实现初始化：</p>
<pre><code>int *pi = new int(1024);        // object to which pi points is 1024
string *ps = new string(10, ‘9’);   // *ps is “9999999999”
</code></pre><p>正如我们（几乎）总是要初始化定义为变量的对象一样，在动态创建对象时，（几乎）总是对它做初始化也是一个好办法。</p>
<hr>
<p>动态创建的对象用完后，程序员必须显式地将该对象占用地内存返回给自由存储区。可以使用delete表达式释放指针所指向地地址空间。如：</p>
<pre><code>delete pi；该命令释放pi指向的int型对象占用的内存空间。
</code></pre><p>若指针指向不是用new分配的内存地址，则在该指针上使用delete是不合法的。C++没有明确定义如何释放指向不是用new分配的内存地址的指针。</p>
<hr>
<p>执行语句 delete p；之后，p变成没有定义。在很多机器上，尽管p没有定义，但仍然存放了它之前所指向的地址，然而p所指向的内存已经被释放，因此p不再有效。删除指针后，该指针变成悬垂指针（dangling pointer）。悬垂指针指向曾经存放对象的内存，但该对象已经不再存在了。悬垂指针往往导致程序错误，而且很难检测出来。</p>
<p>一旦删除了指针所指向的对象，立即将指针置为0，这样就非常清楚地表明指针不再指向任何对象。</p>
<hr>
<p>const对象地动态分配和回收</p>
<pre><code>const int *pic = new const int(1024);
</code></pre><p>动态创建的const对象必须在创建时初始化，并且一经初始化，其值就不能修改。</p>
<pre><code>delete pic；// ok: deletes a const object
</code></pre><hr>
<p>将enum对象或枚举成员提升为什么类型由机器定义，并且依赖于枚举成员的最大值。无论其最大值时什么，enum对象或枚举成员至少提升为int型。</p>
<hr>
<p>当使用非const对象初始化const对象的引用时，系统将非const对象转化为const对象。此外，还可以将非const对象的地址（或非const指针）转换为const类型的指针。</p>
<hr>
<p>显式转换也称为强制类型转换（cast），包括以下名字命名的强制类型转换操作符：static_cast、dynamic_cast、const_cast和reinterpret_cast。</p>
<p>虽然有时候确实需要强制类型转换，但是它们本质上是非常危险的。</p>
<hr>
<p>因为要覆盖通常的标准转换，所以需要显式使用强制类型转换</p>
<pre><code>double dval;
int ival;   //这里要先将ival转换称double型，然后再把double型的结果
ival *= dval;   //截取为int型，再赋值给ival。
</code></pre><p>为了去掉这个不必要的转换，可以强制将ival转换为int型<br>    ival *= static_cast<int>(dval);</int></p>
<p>显式使用强制类型转换的另一个原因是可能存在多种转换，需要选择一种特定的类型转换。</p>
<hr>
<p>const_cast，将转换掉表达式的const性质。dynamic_cast支持运行时识别指针或引用所指向的对象。reinterpret_cast通常为操作数的位模式提供较低层次的重新解释。</p>
<p>reinterpret_cast本质上依赖于机器。为了安全地使用reinterpret_cast，要求程序员完全理解所设计地数据类型，以及编译器实现强制类型转换的细节。</p>
<hr>
<p>编译器隐式执行的任何类型转换都可以由static_cast显式完成</p>
<pre><code>double d = 97.0;
char ch = static_cast&lt;char&gt;(d);
</code></pre><p>当需要将一个较大的算术类型赋值给较小的类型时，使用强制转换非常有用。此时强制类型转换告诉程序的读者和编译器：我知道并且不关心潜在的精度损失。这样警告信息就会消失。如果编译器不提供自动转换，使用<code>static_cast</code>来执行类型转换也是很有用的。例如下面的程序使用<code>static_cast</code>找回存放在<code>void*</code>指针中的值：</p>
<pre><code>void *p = &amp;d;
double *dp = static_cast&lt;double*&gt;p;
</code></pre><hr>
<p>强制类型转换关闭或挂起了正常的类型检查。强烈建议程序员避免使用强制类型转换，不依赖强制类型转换也能写出很好的C++程序。这个建议再如何看待<code>reinterpret_cast</code>的使用时非常重要。此类强制转换总是非常危险的。相似地，使用<code>const_cast</code>也总是预示着设计缺陷。设计合理的系统不需要使用强制类型转换抛弃const特性。如果非强制转换不可，则应限制强制转换值的作用域，并且记录所有假定涉及的类型，这样能减少错误发生的机会。</p>
<hr>
<p>如果在程序的某个地方，语法上需要一个语句，但逻辑上并不需要，此时应该使用空余句。这种用法常见于在循环条件判断部分就能完成全部循环工作的情况。</p>
<p>使用空语句时应该加上注释，以便任何读这段代码的人都知道该语句是有意义的。</p>
<hr>
<p>在条件表达式中定义的变量必须初始化，该条件检验的就是初始化对象的值。这种变量的作用域限制在语句体内。通常，语句体本身就是一个块语句，其中也可能包含了其他的块。一个在控制结构里引入的名字是该语句的局部变量，其作用域限在语句内部。</p>
<hr>
<p>很多编辑器和开发环境都提供工具自动根据语句结构缩排源代码。有效地利用这些工具将是一种很好的编程方法。</p>
<hr>
<p>所有语言的if语句普遍存在着潜在的二义性。这种情况往往称为悬垂else（dangling-else）问题，C++中悬垂else问题带来的二义性，通过将else匹配给最后出现的尚未匹配的if子句来解决。</p>
<hr>
<p>尽管没有严格要求在switch结构的最后一个标号之后指定break语句，但是，为了安全起见，最好在每个标号后面提供一个break语句，即使是最后一个标号也一样。如果以后在switch结构的末尾又需要添加一个新的case标号，则不用再前面添加break语句了。</p>
<p>故意省略case后面的break语句是很罕见的，因此应该提供一些注释说明其逻辑。</p>
<hr>
<p>default标号（default label）提供了相当于else子句的功能。如果所有的case标号与switch表达式的值都不匹配，并且default标号存在，则执行default标号后面的语句。哪怕没有语句要在default标号下执行，定义default标号仍然是有用的。定义default标号是为了告诉它的读者，表明这种情况已经考虑到了，只是没有什么要执行的。</p>
<hr>
<p>再循环条件中定义的变量再每次循环里都要经历创建和撤销的过程。</p>
<hr>
<p>do while循环保证循环体至少执行一次，并且总是以分号结束。</p>
<hr>
<p>goto语句提供了函数内部的无条件跳转，实现从goto语句跳转到同一函数内某个带标号的语句。语法规则位：    goto label； 其中label是用于标识带标号的语句的标识符。再任何语句前提供一个标识符和冒号，即得带标号得语句（labeled statement）：</p>
<pre><code>end： return；    // labeled statement, may be target of a goto
</code></pre><p>goto语句不能跨越变量得定义语句向前跳转：</p>
<pre><code>//  ...
goto end;
int ix = 10;        // error: goto bypasses declaration statement

end:
// error: code here could use ix but the goto bypassed its declaration
ix =  42;
</code></pre><p>如果确实需要再goto和其跳转对应得标号之间定义变量，则定义必须放在一个块语句中：</p>
<pre><code>// ...
goto end;
{
    int ix = 10;
    // ...code using ix
}
end: // ix no longer visible here
</code></pre><p>向后跳过已经执行得变量定义语句是合法的。</p>
<p>再涉及各种软件系统的过程中，处理程序中的错误和其他反常行为是最困难的部分之一。异常就是运行时出现的不正常，例如运行时耗尽了内存或遇到意外的非法输入。异常存在于程序的正常功能之外，并要求程序立即处理。在设计良好的系统中，异常是程序错误处理的一部分。当程序代码检查到无法处理的问题时，异常处理就特别有用。在这些情况下，检测出问题的那部分程序需要一种方法把控制权转到可以处理这个问题的那部分程序。错误检测程序还必须指出具体出现了什么问题，并且可能需要提供一些附加信息。</p>
<hr>
<p>异常机制提供程序中错误检测与错误处理部分之间的通信。C++的异常处理中包括：</p>
<p>throw表达式（throw expression），错误检测部分使用这种表达式来说明遇到了不可处理的错误。可以说，throw引发（raise）了异常条件。</p>
<p>try块（try block），错误处理部分使用它来处理异常。try语句块以try关键字开始，并以一个或多个catch子句（catch clause）结束。在try块中执行的代码所抛出（throw）的异常，通常会被其中一个catch子句处理。由于它们“处理”异常，catch子句也称为处理代码（handler）</p>
<p>由标准库定义的一组异常类（exception class），用来在throw和相应的catch之间传递有关的错误信息。</p>
<hr>
<p>系统通过throw表达式抛出异常。throw表达式由关键字throw以及尾随的表达式组成，通常以分号结束，这样它就称为了表达式语句。throw表达式的类型决定了所抛出异常的类型。下面是用throw抛出异常来改写检测代码(判断是否是同一本书，如果不是就输出信息并退出)：</p>
<pre><code>// first check that data is for the same item
if(!item1.same_isbn(item2))
    throw runtime_error(“Data must refer to same ISBN”);
// ok, if we’re still here the ISBNs are the same
std::cout &lt;&lt; item1 + item2 &lt;&lt; std::endl;
</code></pre><p>throw语句使用了一个表达式。这里是用的是runtime_error类型的对象，此类型是标准库异常类中的一种，在stdexcept头文件中定义，这样就可以提供更多相关信息。</p>
<hr>
<p>try块的通用语法形式是：</p>
<pre><code>try{
    program-statements
} catch (exception-specifier){
    handler-statements
} catch (exception-specifier){
    handler-statements
}   //......
</code></pre><p>try块以关键字try开始，后面是用花括号括起来的语句序列块。try块后面是一个或多个catch子句。每个catch子句包括三部分：关键字catch，圆括号内单个类型或者单个对象的声明，称为异常说明符（exception specifier），以及通常用花括号括起来的语句块。如果选择了一个catch子句来处理异常，则执行相关的块语句。一旦catch子句执行结束，程序流程立即继续执行紧随着最后一个catch子句的语句。try语句内的program-statement形成程序的正常逻辑。这里面可以包含任意C++语句，包括变量声明。与其他语句一样，try块引入局部作用域，在try块中声明的变量，包括catch子句中声明的变量，不能在try外面引用。</p>
<hr>
<p>对于111中抛出的错误，与用户交互的部分可能会包括以下代码：</p>
<p>   while(cin &gt;&gt; item1 &gt;&gt; item2 ){<br>        try{<br>        // execute code that will add the two Sales_items<br>        // if the addition fails, the code throws a runtime_error exception<br>    } catch(runtime_error err){<br>        // remind the user that ISBN must match and prompt for another pair<br>        cout &lt;&lt; err.what()<br>                &lt;&lt; “\nTry Again? Enter y or n” &lt;&lt; endl;<br>        char c;<br>        cin &gt;&gt; c;<br>        if(cin &amp;&amp; c == ‘n’)<br>            break;      //break out of the while loop<br>        }<br>    }</p>
<p>通过输出err.what()的返回值提示用户。这里what返回的C风格字符串，是用于初始化runtime_error的string对象的副本。</p>
<hr>
<p>在复杂的系统中，程序的执行路径也许在遇到抛出异常的代码之前，就已经经过了多个try块。例如一个try块可能调用了包含另一try块的函数，它的try块又调用了含有try块的另一函数，如此类推。</p>
<p>寻找处理代码的过程与函数调用链刚好相反。抛出一个异常时，首先要搜索的是抛出异常的函数。如果没有找到匹配的catch，则终止这个函数的执行，并在调用这个函数的函数中寻找相配的catch。如果仍然没有找到相应的处理代码，该函数同样要终止，搜索调用它的函数。如此类推，继续按执行路径回退，直到找到适当类型的catch为止。</p>
<p>如果不存在处理该异常的catch子句，程序的运行就要跳转到名为terminate的标准库函数，该函数在exception头文件中定义。通常情况下，其执行将导致程序非正常退出。</p>
<p>抛出异常的语句要在try中···不然会挂掉的。</p>
<hr>
<p>C++标准库定义了一组类，用于报告在标准库中函数遇到的问题。程序员可在自己编写的程序中使用这些标准异常类。exception头文件定义了最常见的异常类，类名是exception。这个类只通知异常的产生，不会提供更多的信息。stdexcept头文件定义了几种常见的异常类。new头文件定义了bad_alloc异常类型，提供因无法分配内存而由new抛出的异常。type_info头文件定义了bad_cast异常类型。</p>
<p>标准库异常类只提供很少的操作，包括创建、赋值异常类型对象以及异常类型对象的赋值。exception、bad_alloc以及bad_cast类型只定义了默认构造函数，无法在创建这些类型的对象时为它们提供初值。其他的异常类则只定义了一个使用string初始化式的构造函数，用于为所发生的错误提供更多的信息。</p>
<p>异常类型只定义了一个名为what的操作。这个函数不需要任何参数，并且返回const char*类型的值。它返回的指针指向一个C风格字符串，用来提供对异常的更详细的文字描述。</p>
<hr>
<p>C++程序员有时候也会使用预处理技术来有条件地执行用于调试的代码。这种想法是：程序所包含的调试代码仅在开发过程中执行，当应用程序已经完成，并且准备提交时，就会将调试代码关闭。可使用NDEBUG预处理变量实现有条件的调试代码。</p>
<pre><code>int main(){
#ifndef NDEBUG
cerr &lt;&lt; “starting main” &lt;&lt; endl;
#endif
// .......
</code></pre><p>如果NDEBUG未定义，那么程序就会将信息写到cerr中。如果NDEBUG已经定义了，那么程序执行时将会跳过#ifndef和#endif之间的代码。</p>
<hr>
<p>预处理器还定义了其余四在调试时非常有用的常量：</p>
<pre><code>_ _FILE_ _ 文件名              _ _LINE_ _ 当前行号
_ _TIME_ _ 文件被编译的时间     _ _DATE_ _ 文件被编译的日期
</code></pre><p>另一个常见的调试技术是使用NDEBUG预处理变量以及assert（断言）预处理宏（preprocessor macro）。assert宏是在cassert头文件中定义的。预处理宏有点像函数调用。assert宏需要一个表达式作为它的条件： assert（expr）<br>只要NDEBUG未定义，assert宏就求解表达式expr，如果结果为false，assert输出信息并且终止程序的执行。如果该表达式有一个非零，则assert不做任何操作。在成品代码中，assert语句不做任何工作，因此也没有任何运行时的代价。当然，也不会引起任何运行时的检查。assert仅用于检查确实不可能的条件，这只对程序的测试有帮助，但不能用来代替运行时的逻辑检查，也不能代替对程序可能产生的错误检测。</p>
<hr>
<p>函数可以看作程序员定义的操作。与内置操作符相同的是，每个函数都会实现一系列的计算。但与操作符不同的是，函数是有自己的函数名，而且操作数没有数量限制。与操作符一样，函数可以重载，这意味着同样的函数名可以对应多个不同的函数。</p>
<hr>
<p>函数不能返回另一个函数或者内置数组类型，但可以返回指向函数的指针，或者指向数组元素的指针的指针。C++是一种静态强类型语言，对于每一次的函数调用，编译时都会检查其实参。</p>
<hr>
<p>每次调用函数时，都会重新创建该函数所有的形参，此时所传递的实参将会初始化对应的形参。型材的初始化与变量的初始化一样：如果形参具有非引用类型，则赋值实参的值，如果形参为引用类型，则它只是实参的别名。</p>
<hr>
<p>普通的非引用类型的参数通过复制对应的实参实现初始化。当用实参副本初始化形参时，函数并没有访问调用所传递的实参本身，因此不会修改实参的值。非引用形参表示对应实参的局部副本。对这类形参的修改仅仅改变了局部副本的值。一旦函数执行结束，这些局部变量的值也就没有了。</p>
<hr>
<p>指针形参是指向const类型还是非const类型，将影响函数调用所使用的实参。在调用函数时，如果该函数使用非引用的非const形参，则既可给该函数传递const实参，也可传递非const的实参。</p>
<hr>
<p>复制实参并不是在所有的情况下都适合，不适合复制实参的情况包括：<br>当需要在函数中修改实参的值时。</p>
<p>当需要以大型对象作为实参传递时。对实际的应用而言，复制对象所付出的时间和存储空间代价往往过大。</p>
<p>当没有办法实现对象的复制时。</p>
<p>对于上述几种情况，有效的解决办法是将形参定义为引用或指针类型。</p>
<hr>
<p>如果想要在函数中交换实参的值，需要将形参定义为引用类型：</p>
<pre><code>void swap(int &amp;v1,int &amp;v2){
int temp = v2; v2 = v1; v1 =  temp;
}
</code></pre><p>与所有引用一样，引用形参直接关联到其所绑定的对象，而非这些对象的副本。定义引用时，必须用与该引用绑定的对象初始化该引用。引用形参完全以相同的方式工作。每次调用函数，引用形参被创建并与相应实参关联。</p>
<hr>
<p>使用引用形参返回额外的信息。例如，定义一个<code>find_val</code>函数，在一个整型vector对象的元素中搜索某个特定值。如果找到满足要求的元素，则返回指向该元素的迭代器；否则返回一个迭代器，执行该vector对象的end操作返回的元素。此外，如果该值出现了不止一次，我们还希望函数可以返回其出现的次数。在这种情况下，返回的迭代器应该指向具有要寻找的值的第一个元素。</p>
<p>我们可以定义一种包含一个迭代器和一个计数器的新类型。而更简便的解决方案给<code>find_val</code>传递一个额外的引用实参，用于返回出现册数的统计结果。</p>
<pre><code>// returns an iterator that refers to the first occurrence of value
// the reference parameter occurs contains a second return value
vector&lt;int&gt;::const_iterator find_val(
    vector&lt;int&gt;::const_iterator beg,        // first element
    vector&lt;int&gt;::const_iterator end,        // one past last element
    int value,                  // the value we want
    vector&lt;int&gt;::size_type &amp;occurs)     // number of times it occurs
{
    // res_iter will hold first occurrence, if any
    vector&lt;int&gt;::const_iterator res_iter = end;
    occurs = 0;                 // set occurrence count parameter
    for( ; beg != end; ++beg)
        if(*beg == value) {
            // remember first occurrence of value
            if(res_iter == end)
            res_iter = beg;
            ++occurs;               // increment occurrence count
    }
    return res_iter;                // count returned implicitly in occurs
}
</code></pre><p>调用<code>find_val</code>时，需传递四个实参：一对标识vector对象中要搜索的元素范围的迭代器，所查找的值，以及用于存储出现次数的<code>size_type</code>类型对象。假设ivec是vecter<int>类型的对象，it是一个适当类型的迭代器，而ctr则是size_type类型的变量，则可如此调用该函数：  </int></p>
<pre><code>it = find_val(ivec.begin(), ivec.end(), 42, ctr);
</code></pre><p>调用后，ctr的值将是42出现的次数，如果42在ivec中出现了，则it将指向其第一次出现的位置；否则it的值为ivec.end()，而ctr则为0。</p>
<hr>
<p>在向函数传递大型对象时，需要使用引用形参，对于大部分的类类型或者大型数组，复制实参的效率就太低了，此时就可以利用const引用直接访问实参对象，无须复制。</p>
<p>如果使用引用形参的唯一目的是避免复制实参，则应将形参定义为const引用。</p>
<hr>
<p>应该将不需要修改的引用形参定义为const引用。普通的非const引用形参在使用时不太灵活。这样的形参既不能用const对象初始化，也不能用字面值或产生右值的表达式实参初始化。</p>
<hr>
<p>通常，函数不应该有vector或其他标准库容器类型的形参。。调用含有普通的非引用vector形参的函数将会复制vector的每一个元素。从避免复制vector的角度出发，应考虑将形参声明为引用类型。事实上，C++程序员倾向于通过传递指向容器中需要处理的元素的迭代器来传递容器。</p>
<pre><code>// pass iterators to the first and one past the last element to print
void print(vector&lt;int&gt;::const_iterator beg,
    vector&lt;int&gt;::const_iterator end){
    while (beg != end){
        cout &lt;&lt; *beg++;
        if (beg != end)   cout &lt;&lt; “ ”;  // no space after last element
    }
cout &lt;&lt; endl;
}
</code></pre><hr>
<p>通常，将数组形参直接定义为指针要比使用数组语法定义更好。这样就明确地表示，函数操纵的是指向数组元素的指针，而不是数组本身。由于护绿了数组长度，形参定义中如果包含了数组长度则特别容易引起误解。当编译器检查数组形参关联的实参时，它只会检查实参是不是指针、指针的类型和数组元素的类型是否匹配，而不会检查数组的长度。</p>
<hr>
<p>若形参是数组的引用，编译器不会将数组实参抓化为指针，而是传递数组的引用本身。在这种情况下，数组大小称为形参和实参类型的一部分。编译器检查数组实参的大小与形参大小是否相配。</p>
<hr>
<p>和其他数组一样，多为数组以指向0号元素的指针方式传递。多维数组的元素本身就是数组。除了第一维以外的所有维德长度都是元素类型的一部分，必须明确指定：</p>
<pre><code>// first parameter is an array whose elements are arrays of 10 ints
void printValues(int (matrix*)[10], int rowSize);
</code></pre><p>除了第一维以外的所有维德长度都是元素类型的一部分，必须明确指定。我们也可以用数组语法定义多维数组。与一维数组一样，编译器忽略第一维的长度，所以最好不要把它包括在形参表内。</p>
<hr>
<p>非引用数组形参的类型检查只是确保实参是和数组元素具有同样类型的指针，而不会检查实参实际上是否指向指定大小的数组。任何处理数组的程序都要确保程序停留在数组的边界内。</p>
<hr>
<p>有三种常见的编程技巧确保函数的操作部超出数组实参的边界。第一种方法是在数组本身放置一个标记来检测数组的结束。C风格字符串就是采用这种方法的一个例子。第二种方法是传递指向数组第一个和最后一个元素的下一个位置的指针，这样就可以确定一个元素范围，程序就会安全。点钟方法是将第二个形参定义为表示数组的大小，即显示传递表示数组大小的形参。</p>
<hr>
<p>return语句用于结束当前正在执行的函数，并将控制权返回给调用此函数的函数。可以返回值，也可以不返回。不带返回值的return语句只能用于返回类型为void的函数。在返回类型为void的函数中，return返回语句不是必需的，隐式的return发生在函数的最后一个语句完成时。一般情况下，返回类型是void的函数使用return语句是为了引起函数的强制结束。在含有return语句的循环后没有提供return语句是很危险的，因为大部分的编译器不能检测出这个漏洞，运行时会出现什么问题是不确定的。</p>
<hr>
<p>返回类型不是void的函数必需返回一个值，但此规则有一个例外情况：允许主函数main没有返回值就可结束。</p>
<hr>
<p>返回非引用类型的时候，return都会在调用该函数的时候复制返回的对象。而返回引用类型的时候则是不复制的。</p>
<hr>
<p>理解返回引用至关重要的是：千万不能返回局部变量的引用。当函数执行完毕时，将释放分配给局部对象的存储空间。此时，对局部对象的引用就会指向不确定的内存。</p>
<p>确保返回引用安全的一个好方法是：请自问，这个引用指向哪个在此之前存在的对象？</p>
<hr>
<p>函数定义就是写明具体的执行过程，声明就是告诉编译器要使用这个函数。函数声明由函数返回类型、函数名和形参列表组成。形参列表必须包括形参类型，但是不必对形参命名。这三个元素被称为函数原型（function prototype），函数原型描述了函数的接口。</p>
<hr>
<p>函数也应当在头文件中声明，并在源文件中定义。定义函数的源文件应包含声明该函数的头文件。</p>
<hr>
<p>因为char是整形，因此把一个char值传递给int型形参是合法的，反之亦然。</p>
<hr>
<p>在C++语言中，每个名字都有作用域，而每个对象都有生命期（lifetime）。要弄清楚函数是怎么运行的，理解这两个概念十分重要。名字的作用域指的是知道该名字的程序文本区。对象的生命期则是在程序执行过程中对象存在的时间。</p>
<hr>
<p>默认情况下，局部变量的生命期局限于所在函数的每次执行期间。只有当定义它的函数被调用时才存在的对象称为自动对象（automatic object）。自动对象在每次调用函数时创建和撤销。在函数结束后，自动对象和形参的值都不能再访问了。</p>
<hr>
<p>一个变量如果位于函数的作用域内，但是生命期却跨域了这个函数的多次调用，这种变量往往很有用。则应该将这样的对象定义为static（静态的）。static局部对象（static local object）确保不迟于在程序执行流程第一经过该对象的定义语句时进行初始化。这种对象一旦被创建，在程序结束前都不会被撤销。当定义静态局部对象的函数结束时，静态对象不会被撤销。</p>
<pre><code>size_t count_calls(){
    static size_t ctr = 0;  // value will persist across calls
    return ++ctr;
}
int main(){
    for(size_t i = 0; i != 10; ++i)
        cout &lt;&lt; cout_calls() &lt;&lt; endl;
    return 0;
}
</code></pre><p>依次输出1到10（包含10）的整数。</p>
<hr>
<p>内联函数避免函数调用的开销，相当于在调用函数的时候用函数体替换，就可以加快速度。在函数返回类型前加上关键字inline就可以指定为内联函数。内联说明（inline specification）对于编译器来说只是一个建议，编译器可以选择忽略这个建议。一般来说，内联机制适用于优化小的、只有几行而且经常被调用的函数。大多数编译器都不支持递归函数的内联。</p>
<hr>
<p>内联函数应该在头文件中定义，这一点不同于其他函数。在头文件中加入或修改内联函数时，使用了该头文件的所有泊文件都必须得重新编译。</p>
<hr>
<p>成员函数的定义与普通函数的定义类似。和任何函数一样，成员函数也包含下面四个部分：函数返回类型、函数名、用逗号隔开的形参表（也可能是空的）、包含在一对花括号里面的函数体。函数原型必须在类中定义。但是，函数体则既可以在类中也可以在类外定义。类的所有成员都必须在类定义的花括号里声明，此后，就不能再为类增加任何成员。类的成员函数必须如声明的一般定义。类的成员函数既可以在类的定义内也可以在类的定义外定义。编译器隐式地将在类内定义的成员函数当作内联函数。类的成员函数可以访问该类的private成员。</p>
<hr>
<p>每个成员函数（除static成员函数外）都有一个额外的、隐含的形参this。在调用成员函数时，形参this初始化为调用函数的对象的地址。</p>
<hr>
<p>const对象、指向const对象的指针或引用只能调用其const成员函数，如果尝试用它们来调用非const成员函数，则是错误的。</p>
<hr>
<p>在成员函数中，不必显式地使用this指针来访问被调用函数所属对象的成员。对这个类的成员的任何没有前缀的引用，都被假定为通过指针this实现的引用。</p>
<hr>
<p>在类外定义成员函数就必须指明它们是类的成员</p>
<pre><code>double Sales_item::avg_price() const{
if (units_sold)
    return revenue/units_sold;
else
    return 0;
}
</code></pre><p>使用作用域操作符指明函数avg_price是在类Sales_item的作用域范围内定义的。</p>
<hr>
<p>构造函数（constructor）是特殊的成员函数，与其他成员函数不同，构造函数和类同名，而且没有返回类型。而与其他成员函数相同的是，构造函数也有形参表（可能为空）和函数体。一个类可以有多个构造函数，每个构造函数必须有与其他构造函数不同数目或类型的形参。构造函数也必须在类中声明，但是可以在类中或类外定义。构造函数放在类的public部分。</p>
<hr>
<p>如果没有为一个类显式定义任何构造函数，编译器将自动为这个类生成默认构造函数。合成的默认构造函数一般适用于仅包含类类型成员的类。而对于含有内置类型或复合类型成员的类。则通常应该定义他们自己的默认构造函数初始化这些成员。</p>
<hr>
<p>出现在相同作用域中的两个函数，如果具有相同的名字而形参表不同，则成为重载函数（overloaded function）。如果两个函数声明的返回类型和形参表完全匹配，则将第二个函数声明视为第一个的重复声明。如果两个函数的形参表完全相同，但返回类型不同，则第二个声明是错误的。</p>
<hr>
<p>一般作用域规则同样适用于重载函数名。如果局部地声明一个函数，则该函数将屏蔽而不是重载在外层作用域中声明的同名函数。所以，每一个版本的重载函数都应在同一个作用域中声明。一般来说，局部地声明函数时一种不明智的选择。函数的声明应放在头文件中。在C++中，名字查找发生在类型检查之前。</p>
<hr>
<p>函数重载确定（overload resolution，即函数匹配function matching）是将函数调用与重载函数集合中的一个函数相关联的过程。通过自动提取函数调用中实际使用的实参与重载集合中各个函数提供的形参做比较，编译器实现该调用与函数的匹配。</p>
<hr>
<p>为了确定最佳匹配，编译器将实参类型到相应形参类型的转换划分等级。转换等级以降序排列如下：精确匹配（exact match），实参与形参类型相同。通过类型提升（promotion）实现的匹配。通过标准转换（standard conversion）实现的匹配。通过类类型转换（class-type conversion）实现的匹配。</p>
<p>内置类型的提升和转换可能会使函数匹配产生意想不到的结果。但幸运的是，设计良好的系统很少会包含形参类型相当接近的函数。</p>
<hr>
<p>类型提升或转换适用于实参类型可通过某种标准转换提升或转换为适当的形参类型的情况。通过类型提升实现的转换优于其他标准的转换。</p>
<pre><code>void ff(int);
void ff(short);
ff(‘a’);            // char promotes to int, so matches ff(int)
</code></pre><hr>
<p>枚举类型enum的对象只能用同一枚举类型的另一个对象或一个枚举成员（enumerator）进行初始化。整数对象即使具有与枚举元素相同的值也不能用于调用期望获得枚举类型实参的函数。虽然无法将整型值传递给枚举类型的形参，但可以将枚举值传递给整数形参。此时，枚举值被提升为int型或更大的整形。具体的提升类型取决于枚举成员的值。</p>
<hr>
<p>仅当形参是引用或指针时，形参是否为const才有影响。</p>
<hr>
<p>函数指针是指指向函数而非指向对象的指针。像其他指针一样，函数指针也指向某个特定的类型。函数类型由其返回类型以及形参表确定，而与函数名无关。</p>
<pre><code>// pf points to function returning bool that takes two const string references
bool (*pf)(const string &amp;, const string &amp;);
</code></pre><p>其中<code>*pf</code>两侧的括号是必需的。或者是使用typedef为指针类型定义同义词，可将函数指针的使用大大简化。</p>
<pre><code>typedef bool (*cmpFcn) (const string &amp;, const string &amp;);
</code></pre><p>以后使用则直接用cmpFcn即可。</p>
<hr>
<p>在引用函数名但又没有调用该函数时，函数名将被自动解释为指向函数的指针。函数指针只能通过同类型的函数或函数指针或0值常量表达式进行初始化或赋值。</p>
<hr>
<p>指向函数的指针可用于调用它所指向的函数。可以不需要使用解引用操作符，直接通过指针调用函数。函数的形参可以是指向函数的指针。</p>
<hr>
<p>endl操纵符用于输出一个换行符并刷新缓冲区。而flush，用于刷新流，但不在输出中添加任何字符。还有一个比较少用的ends，这个操作符在缓冲区插入空字符null，然后刷新它。如果需要刷新所有输出，最好使用unitbuf操作符。这个操作符在每次执行完写操作后都刷新流： </p>
<pre><code>cout &lt;&lt; unitbuf &lt;&lt; “first” &lt;&lt; “ second” &lt;&lt; nounitbuf;   
</code></pre><p>等价于：</p>
<pre><code>cout &lt;&lt; “first” &lt;&lt; flush &lt;&lt; “second” &lt;&lt; flush;
</code></pre><p>nounitbuf操纵符将流恢复为使用正常的、由系统管理的缓冲区刷新方式。</p>
<hr>
<p>如果程序不正常结束，输出缓冲区将不会刷新。在尝试调试已崩溃的程序时，通常会根据最后的输出找出程序发生错误的区域。如果崩溃出现在某个特定的输出语句后面，则可知是在程序的这个位置之后出错。</p>
<p>调试程序时，必须保证期待写入的每个输出都确实被刷新了。如果需要使用最后的输出给程序错误定位，则必须确定所有要输出地都已经输出。为了确保用户看到程序实际上处理的所有输出，最好的方法是保证所有的输出操作都显式地调用了flush或endl。如果仅因为缓冲区没有刷新，程序员将浪费大量的时间跟踪调试并没有执行的代码。基于这个原因，输出时应多使用endl而非‘\n’。</p>
<hr>
<p>当输入流与输出流绑在一起时，任何读输入流的尝试都将首先刷新其输出流关联的缓冲区。交互式系统通常应确保它们的输入和输出流失绑在一起的。这样做意味着可以保证任何输出，包括给用户的提示，都在试图读之前输出。</p>
<hr>
<p>打开文件后，通常要检验打开是否成功，这是一个好习惯。</p>
<pre><code>// check that the open succeeded
if (!infile){
    cerr &lt;&lt; “error: unable to open input file : ”
        &lt;&lt; ifile &lt;&lt; endl;
    return -1;
}
</code></pre><p>如果程序员需要重用文件流读写多个文件，必须在读另一个文件之前调用clear清楚该流的状态。</p>
<hr>
<p>C++提供了使用抽象进行高效率编程的方式。标准库就是一个很好的例子：标准库定义了许多容器类以及一系列泛型算法，使程序员可以更简洁、抽象和有效地编写程序。这样可以让标准库操心那些繁琐的细节，特别是内存管理，我们的程序只需关注要解决的实际问题就行了。泛型算法中，所谓“泛型(generic)”指的是两个方面：这些算法可作用于各种不同的容器类型，而这些容器又可以容纳多种不同类型的元素。</p>
<p>为容器类型提供通用接口是设计库的目的。容器提供的操作和算法是一致定义的，这使得学习标准库更容易：只需理解一个操作如何工作，就能将该操作应用于其他的容器。更重要的是，接口的一致性使程序变得更灵活。</p>
<hr>
<p>标准库定义了三种顺序容器类型：vector（支持快速随机访问）、list（支持快速插入、删除）和deque（是双端队列“double-ended queue”的简写，发音为 “deck”）。它们的差别在于访问元素的方式，以及添加或删除元素相关操作的运行代价。标准库还提供了三种容器适配器（adaptor）。实际上，适配器是根据原始的容器类型所提供的操作，通过定义新的操作接口，来适应基础的容器类型。顺序容器适配器包括stack（后进先出LIFO栈）、queue（先进先出FIFO）和priority_queue类型（有优先级管理的队列）。容器只定义了少量操作。大多数额外操作则由算法库提供。标准库为由容器类型定义的操作加强了公共的接口。</p>
<hr>
<p>为了定义一个容器类型的对象，必须先包含相关的头文件<vector><list><deque>所有的容器都是类模板。要定义某种特殊的容器，必须在容器名后加一对尖括号，尖括号里面提供容器中存放的元素的类型。所有的容器类型都定义了默认构造函数，用于创建指定类型的空容器对象。为了使程序更清晰、简短，容器类型最常用的构造函数是默认构造函数。在大多数的程序中，使用默认构造函数能达到最佳运行时性能，并且使容器更容易使用。</deque></list></vector></p>
<hr>
<p>将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同。尽管不能将一种容器内的元素复制给另一种容器，但系统允许通过传递一对迭代器间接实现该功能。使用迭代器时，不要求容器类型相同。容器内的元素类型也可以不相同，只要他们相互兼容，能够将要复制的元素转换为所构建的新容器的元素类型，即可实现复制。</p>
<hr>
<p>创建顺序容器时，可显式指定容器大小和一个（可选的）元素初始化式。容器大小可以使常量或非常量表达式，元素初始化式则必须是可用于初始化其元素类型的对象的值。接受容器大小做形参的构造函数只适用于顺序容器，而关联容器不支持这种初始化。</p>
<hr>
<p>C++语言中，大多数类型都可用作容器的元素类型。容器元素类型必须满足以下两个约束：元素类型必须支持赋值运算；元素类型的对象必须可以复制。</p>
<hr>
<p>因为容器受容器元素类型的约束，所以可定义元素是容器类型的容器。例如</p>
<pre><code>vector&lt; vector&lt;string&gt; &gt; lines;     // vector of vectors
</code></pre><p>必须用空格隔开两个相邻的 &gt; 符号，以示这是两个分开的符号，否则，系统会认为&gt;&gt;是单个符号，为右移操作符，并结果导致编译时错误。</p>
<hr>
<p>在整个标准库中，经常使用形参为一对迭代器的构造函数。关系操作符只适用于vector和deque容器，这是因为只有这两种容器为其元素提供快速、随机的访问。它们确保可根据元素位置直接有效地访问指定的容器元素。</p>
<hr>
<p>迭代器范围这个概念是标准库的基础。C++语言使用一对迭代器标记迭代器范围（iterator range），这两个迭代器分别指向同一个容器中的两个元素或超出末端的下一位置，通常将它们命名为first和last，或beg和end，用于标记容器中的一段元素范围。称为左闭合区间（left-inclusive interval），其标准方式为：</p>
<pre><code>// to be read as: includes first and each element up to but not including last
[ first, last )
</code></pre><p>当first与last相等时，迭代器范围为空；</p>
<p>当first与last不相等时，迭代器范围内至少有一个元素，而且first指向该区间中的第一个元素。</p>
<hr>
<p>修改容器的内在状态或移动容器内的元素等操作使所有指向呗移动的元素的迭代器时效，也可能同时使其他迭代器失效。使用无效迭代器时没有定义的，可能会导致与悬垂指针相同的问题。使用迭代器编写程序时，必须留意那些操作会使迭代器失效。使用无效迭代器将会导致严重的运行时错误。</p>
<hr>
<p>使用迭代器时，通常可以编写程序使得要求迭代器有效地代码发内相对较短。然后，在该范围内，严格检查每一条语句，判断是否有元素添加或删除，从而相应地调整迭代器的值。</p>
<hr>
<p>除了push_back运算，list和deque容器类型还提供了类似的操作：push_front。这个操作实现再容器首部插入新元素的功能。</p>
<hr>
<p>再容器中添加元素时，系统是将元素值复制到容器里。类似地，使用一段元素初始化新容器时，新荣期存放的是原始元素的副本。被复制的原始值与新荣期中的元素各不相关，此后，容器内元素值发生变化时，被复制的原值不会收到影响，反之亦然。</p>
<hr>
<p>insert曹走提供了一组更通用的插入方法，实现在容器的任意指定位置插入新元素。</p>
<p>c.insert(p,t) 在迭代器p所指向的元素前面插入值为t的新元素。返回指向新添加元素的迭代器</p>
<p>c.insert(p,n,t) 在迭代器p所指向的元素前面插入n个值为t的新元素。返回void类型</p>
<p>c.insert(p,b,e) 在迭代器p所指向的元素前面插入由迭代器b和e标记的范围内的元素。返回void类型</p>
<hr>
<p>任何insert或push操作都可能导致迭代器失效。当编写循环将元素插入到vector或deque容器中时，程序必须确保迭代器在每次循环后都得到更新。</p>
<hr>
<p>在vector或deque容器中添加元素时，可能会导致某些或全部迭代器失效。假设所有迭代器失效是最安全的做法。这个建议特别适用于由end操作返回的迭代器。在容器的任何位置插入任何元素都会使该迭代器失效。为了避免存储end迭代器，可以在每次做完插入运算后重新计算。</p>
<pre><code>// safer:recalculate end on each trip whenever the loop adds/erases elements
while (first != v.end()){
      // do some processing
      first = v.insert(first, 42); // insert new value
      ++first; // advance first just past the element we added
}
</code></pre><hr>
<p>所有的容器类型都支持用关系操作符来实现两个容器的比较。比较的容器必须具有相同的容器类型，而且其元素类型也必须相同。</p>
<p>如果两个容器具有相同的长度而且所有元素都相等，那么这两个容器就相等；否则，它们就不相等。</p>
<p>如果两个容器的长度不相同，但较短的容器中所有元素都等于较长容器中对应的元素，则称较短的容器小于另一个容器。</p>
<p>如果两个容器都不是对方的初始子序列，则它们的比较结果取决于所比较的第一个不相等的元素。</p>
<hr>
<p>顺序容器大小的操作</p>
<pre><code>c.max_size()      返回容器c可容纳的最多元素个数，返回类型为c::size_type
c.resize(n)          调整容器c的长度大小，使其能容纳n个元素，如果n&lt;c.size()，则删除多出来的元素；否则，添加采用值初始化的新元素
c.resize(n,t)        调整容器c的大小，使其能容纳n个元素。所有新添加的元素值都为t
</code></pre><hr>
<p>resize操作可能会使迭代器失效。在vector或deque容器上做resize操作有可能会使所有的迭代器都失效。对于所有的容器类型，如果resize操作压缩了容器，则指向已删除的元素的迭代器失效。</p>
<hr>
<p>如果容器非空，那么容器类型的front和back成员将返回容器内第一个或最后一个元素的引用。使用越界的下标，或调用空容器的front或back函数，都会导致程序出现严重的错误。使用下标运算的另一个可选方案是at成员函数。这个函数的行为和下标运算相似，但是如果给出的下标无效，at函数将会抛出out_of_range异常。</p>
<hr>
<p>容器类型提供了通用的insert操作在容器的任何位置插入元素，并支持特定的push_front和push_back操作在容器首部或尾部插入新元素。类似地，容器类型提供了通用的erase操作和特定的pop_front和pop_back操作来删除容器内的元素。</p>
<pre><code>c.erase( k )            
</code></pre><p>删除迭代器 k 所指向的元素。返回一个迭代器，它指向被删除元素后面的元素，若 k 指向容器容器内的最后一个元素，则返回的迭代器指向容器的超出末端的下一位置。如果 k 本身就是指向超出末端的下一位置的迭代器，则该函数未定义。</p>
<pre><code>c.erase( b,e )         
</code></pre><p>删除迭代器 b 和 e 所标记的范围内所有的元素。返回一个迭代器，它指向被删除元素段后面的元素。如果 e 本身就是指向超出末端的下一位置的迭代器，那么返回的迭代器也指向容器超出末端的下一位置。</p>
<pre><code>c.clear()                 
</code></pre><p>删除容器 c 内的所有元素。返回void</p>
<pre><code>c.pop_back()         
</code></pre><p>删除容器 c 的最后一个元素。返回void。如果 c 为空容器，则该函数未定义。</p>
<pre><code>c.pop_front()          
</code></pre><p>删除容器 c 的第一个元素。返回void。如果 c 为空容器，则该函数未定义。</p>
<p>以上两个只能用于list或deque容器</p>
<hr>
<p>pop_front操作通常与front操作配套使用，实现以桟的方式处理容器：</p>
<pre><code>while (!ilist.empty()) {
    process(ilist.front());      // do something with the current top of ilist
    ilist.pop_front();       // done;remove first element
}
</code></pre><p>这个循环非常简单：使用front操作获取要处理的元素，然后调用pop_front函数从容器list中删除该元素。pop_front和pop_back函数的返回值并不是删除的元素的值，而是void。要获取删除的元素值，则必须在删除元素之前调用front或back函数。</p>
<hr>
<p>删除一个或一段元素更通用的方法是erase操作。如同其他操作一样，erase操作也不会检查它的参数。必须确保迭代器是有效的。</p>
<hr>
<p>赋值和 assign 操作使得作操作数容器的所有迭代器失效。swap 操作则不会使迭代器失效。完成 swap 后，尽管被交换的元素已经存放在另一容器中，但迭代器仍然指向相同的元素。</p>
<hr>
<p>顺序容器的赋值操作</p>
<pre><code>c1 ＝ c2            删除容器 c1 的所有元素，然后将 c2 的元素复制给 c1。c1 和 c2 的类型（包括容器类型和元素类型）必须相同。
c1.swap(c2)      交换内容：调用完该函数后，c1 中存放的是 c2 原来的元素，c2中存放的则是 c1原来的元素。c1 和 c2 的类型必须相同。该函数的执行速度通常要比将 c2 的元素复制到 c1 的操作快。
c.assign(b,e)     重新设置 c 中的元素：将迭代器 b 和 e 标记的范围内所有的元素复制到 c 中。b 和 e 必须不是指向 c 中元素的迭代器。
c.assign(n,t)      将容器 c 重新设置为存储 n 各值为 t 的元素
</code></pre><hr>
<p>是用 swap 操作以节省删除元素的成本，并且迭代器不会失效，原来指向哪里，现在还是指向哪里。</p>
<hr>
<p>在容器对象中 insert 或压入一个元素时，该对象的大小增加 1。类似地，如果 resize 容器以扩充其容量，则必须在容器中添加额外的元素。比起 list 和 deque 容器，vector 的增长效率通常会更高。会为 vector 预留额外的存储区。</p>
<hr>
<p>capacity 操作获取在容器需要分配更多的存储空间之前能够存储的元素总数，而 reserve 操作则告诉 vector 容器应该预留多少个元素的存储空间。size 指容器当前拥有的元素个数。每当 vector 容器不得不分配新的存储空间时，以加倍当前容量分配策略实现重新分配。vector 的每种实现都可自由地选择自己的内存分配策略。然后，它们都必须提供 reserve 和 capacity 函数，而且必须时到必要时才分配新的内存空间。分配多少内存取决于其实现方式。不同的库采用不同的策略实现。此外，每种实现都要求遵循以下原则：确保 <code>push_back</code> 操作高效地在 vector 中添加元素。从技术上说，在原来为空的 vector 容器上 n 次调用 <code>push_back</code> 函数，从而创建拥有 n 个元素的 vector 容器，其执行时间永远不能超过 n 的常量倍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里是我学习《Thinking in C++》时记录整理的笔记，时间比较久远，不保证时效性。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://wdxtub.com/tags/Cpp/"/>
    
      <category term="笔记" scheme="http://wdxtub.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenMP 入门指南]]></title>
    <link href="http://wdxtub.com/2016/03/20/openmp-guide/"/>
    <id>http://wdxtub.com/2016/03/20/openmp-guide/</id>
    <published>2016-03-20T11:58:43.000Z</published>
    <updated>2016-03-20T12:14:30.000Z</updated>
    <content type="html"><![CDATA[<p>For CMU 18-645 How to write fast code. Learn openmp in an hour!  <a href="http://blog.csdn.net/donhao" target="_blank" rel="external">主要来源</a></p>
<a id="more"></a>
<hr>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><p>这门课作为 ECE 中少有的跟计算机科学相关的课，自然是必上不可。不过无论是 OpenMP 还是 CUDA，对于平时极少接触并行编程的我来说，都是十分吃力的，第一次作业的 OpenMP 编程已经让意识到了个中的差别，当然，在单个核心的计算速度基本达到极致的现在，掌握并行编程可以算是程序员的基本素养，而 OpenMP 其实是一个非常好的开始，简单，易懂，见效飞快。所以我们的旅程，就从这里开始吧。</p>
<h2 id="Hello_OpenMP"><a href="#Hello_OpenMP" class="headerlink" title="Hello OpenMP"></a>Hello OpenMP</h2><p>OpenMP是一种面向共享内存以及分布式共享内存的多处理器多线程并行编程语言。一段简单的代码如下：</p>
<pre><code>#include &lt;omp.h&gt;
#include &lt;iostream&gt;
using namespace std;

int main(){
    #pragma omp parallel for 
    for (int i = 0; i &lt; 10; ++i)
    {
        cout &lt;&lt; i;
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre><p>通过#pragma omp预处理指示符指定要采用OpenMP</p>
<p>通过#pragma omp parallel for来指定下方的for循环采用多线程执行，此时编译器会根据CPU的个数来创建线程数，对于双核系统，编译器会默认创建两个线程执行并行区域的代码。</p>
<p>这段程序的输入如下（省略前面的终端信息）</p>
<pre><code>dawang$ ./a.out
3680479152
dawang$ ./a.out
8603971425
dawang$ ./a.out
3086419752
dawang$ ./a.out
6038714925
</code></pre><h3 id="u5E38_u7528_u7684_u5E93_u51FD_u6570"><a href="#u5E38_u7528_u7684_u5E93_u51FD_u6570" class="headerlink" title="常用的库函数"></a>常用的库函数</h3><p>函数原型 / 功能</p>
<pre><code>返回当前可用的处理器个数
int omp_get_num_procs(void) 

返回当前并行区域中的活动线程个数，如果在并行区域外部调用，返回1
int omp_get_num_threads(void)

返回当前的线程号（个人感觉这里为omp_get_thread_ID好一些）
int omp_get_thread_num(void) 

设置进入并行区域时，将要创建的线程个数
int omp_set_num_threads(void)
</code></pre><p>下面的这个例子演示了四个库函数</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;omp.h&gt;
using namespace std;

int main(){
    cout &lt;&lt; &quot;CPU number: &quot; &lt;&lt; omp_get_num_procs() &lt;&lt; endl;

    cout &lt;&lt; &quot;Parallel area 1: &quot; &lt;&lt; endl;

    #pragma omp parallel //下面大括号内部为并行区域
    {
        cout &lt;&lt; &quot;Num of threads is: &quot; &lt;&lt; omp_get_num_threads();
        cout &lt;&lt; &quot;; This thread ID is &quot; &lt;&lt; omp_get_thread_num() &lt;&lt; endl;
    }

    cout &lt;&lt; &quot;Parallel area 2:&quot; &lt;&lt; endl;
    omp_set_num_threads(4); // 设置为并行区域创建4个线程
    #pragma omp parallel //下面大括号内部为并行区域
    {
        cout &lt;&lt; &quot;Num of threads is: &quot; &lt;&lt; omp_get_num_threads();
        cout &lt;&lt; &quot;; This thread ID is &quot; &lt;&lt; omp_get_thread_num() &lt;&lt; endl;
    }

    return 0;
}
</code></pre><p>大家可以自己运行一次看看自己的输出</p>
<h2 id="u6570_u636E_u76F8_u5173_u6027"><a href="#u6570_u636E_u76F8_u5173_u6027" class="headerlink" title="数据相关性"></a>数据相关性</h2><p>在循环并行化时，由于多个线程同时执行循环，迭代的顺序是不确定的。如果是数据不相关的，则可以采用基本的#pragma omp parallel for预处理器指示符。</p>
<p>如果语句S2与语句S1相关，那么必然存在以下两种情况之一：</p>
<ol>
<li>语句S1在一次迭代中访问存储单元L，而S2在随后的一次迭代中访问统一存储单元，称之为循环迭代相关（Loop-Carried Dependence）；</li>
<li>S1和S2在同一循环迭代中访问统一存储单元L，但S1的执行在S2之前，称之为非循环迭代相关（Loop-Independent Dependence）。</li>
</ol>
<h3 id="for__u5FAA_u73AF_u5E76_u884C_u5316_u7684_u58F0_u660E_u5F62_u5F0F"><a href="#for__u5FAA_u73AF_u5E76_u884C_u5316_u7684_u58F0_u660E_u5F62_u5F0F" class="headerlink" title="for 循环并行化的声明形式"></a>for 循环并行化的声明形式</h3><pre><code>#include &lt;iostream&gt;
#include &lt;omp.h&gt;
using namespace std;

int main(){
    // for 循环并行化声明形式1
    #pragma omp parallel
    {
        #pragma omp for
        for (int i = 0; i &lt; 10; ++i){
            cout &lt;&lt; i &lt;&lt; endl;
        }
    }

    // for 循环并行化声明形式2
    #pragma omp parallel for
    for (int j = 0; j &lt; 10; ++j){
        cout &lt;&lt; j &lt;&lt; endl;
    }
    return 0;
}
</code></pre><p>上边代码的两种声明形式是一样的，很显然第二种声明形式更为简洁紧凑。但是第一种声明形式有一个好处，即可以在并行区域内、for循环以外写其他并行代码。</p>
<h3 id="for__u5FAA_u73AF_u5E76_u884C_u5316_u7684_u7EA6_u675F_u6761_u4EF6"><a href="#for__u5FAA_u73AF_u5E76_u884C_u5316_u7684_u7EA6_u675F_u6761_u4EF6" class="headerlink" title="for 循环并行化的约束条件"></a>for 循环并行化的约束条件</h3><p>尽管OpenMP可以方便地对for循环进行并行化，但并不是所有的for循环都可以进行并行化。以下几种情况不能进行并行化：</p>
<ol>
<li>for循环中的循环变量必须是有符号整形。例如，for (unsigned int i = 0; i &lt; 10; ++i){}会编译不通过；</li>
<li>for循环中比较操作符必须是&lt;, &lt;=, &gt;, &gt;=。例如for (int i = 0; i != 10; ++i){}会编译不通过；</li>
<li>for循环中的第三个表达式，必须是整数的加减，并且加减的值必须是一个循环不变量。例如for (int i = 0; i != 10; i = i + 1){}会编译不通过；感觉只能++i; i++; –i; 或i–；</li>
<li>如果for循环中的比较操作为&lt;或&lt;=，那么循环变量只能增加；反之亦然。例如for (int i = 0; i != 10; –i)会编译不通过；</li>
<li>循环必须是单入口、单出口，也就是说循环内部不允许能够达到循环以外的跳转语句，exit除外。异常的处理也必须在循环体内处理。例如：若循环体内的break或goto会跳转到循环体外，那么会编译不通过。</li>
</ol>
<h3 id="u57FA_u672C_for__u5FAA_u73AF_u5E76_u884C_u5316_u4E3E_u4F8B"><a href="#u57FA_u672C_for__u5FAA_u73AF_u5E76_u884C_u5316_u4E3E_u4F8B" class="headerlink" title="基本 for 循环并行化举例"></a>基本 for 循环并行化举例</h3><pre><code>#include &lt;iostream&gt;
#include &lt;omp.h&gt;

int main(){
    int a[10] = {1};
    int b[10] = {2};
    int c[10] = {0};

    #pragma omp parallel
    {
        #pragma omp for
        for (int i = 0; i &lt; 10; ++i){
            // c[i] 只跟 a[i] 和 b[i] 有关
            c[i] = a[i] + b[i];
        }
    }

    return 0;
}
</code></pre><h3 id="u5D4C_u5957_for__u5FAA_u73AF_u5E76_u884C_u5316_u4E3E_u4F8B"><a href="#u5D4C_u5957_for__u5FAA_u73AF_u5E76_u884C_u5316_u4E3E_u4F8B" class="headerlink" title="嵌套 for 循环并行化举例"></a>嵌套 for 循环并行化举例</h3><pre><code>#include &lt;omp.h&gt;

int main(){
    int a[10][5] = {1};
    int b[10][5] = {2};
    int c[10][5] = {3};

    #pragma omp parallel
    {
        #pragma omp for
        for (int i = 0; i &lt; 10; ++i){
            for (int j = 0; j &lt; 5; ++j){
                // c[i][j] 只跟 a[i][j] 和 b[i][j] 有关
                c[i][j] = a[i][j] + b[i][j];
            }
        }
    }

    return 0;
}
</code></pre><p>对于双核 CPU 来说，编译器会让第一个cpu完成：</p>
<pre><code>for (int i = 0; i &lt; 5; ++i){
    for (int j = 0; j &lt; 5; ++j){
        // c[i][j] 只跟 a[i][j] 和 b[i][j] 有关
        c[i][j] = a[i][j] + b[i][j];
    }
}
</code></pre><p>会让第二个 cpu 完成：</p>
<pre><code>for (int i = 5; i &lt; 10; ++i){
    for (int j = 0; j &lt; 5; ++j){
        // c[i][j] 只跟 a[i][j] 和 b[i][j] 有关
        c[i][j] = a[i][j] + b[i][j];
    }
}
</code></pre><h2 id="u6570_u636E_u7684_u5171_u4EAB_u4E0E_u79C1_u6709_u5316"><a href="#u6570_u636E_u7684_u5171_u4EAB_u4E0E_u79C1_u6709_u5316" class="headerlink" title="数据的共享与私有化"></a>数据的共享与私有化</h2><p>在并行区域中，若多个线程共同访问同一存储单元，并且至少会有一个线程更新数据单元中的内容时，会发送数据竞争。本节的数据共享与私有化对数据竞争做一个初步的探讨，后续会在同步、互斥相关章节中进行进一步描述。</p>
<p>除了以下三种情况外，并行区域中的所有变量都是共享的：</p>
<ol>
<li>并行区域中定义的变量</li>
<li>多个线程用来完成循环的循环变量</li>
<li>private、firstprivate、lastprivate或reduction字句修饰的变量</li>
</ol>
<p>例如：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;omp.h&gt;
using namespace std;

int main(){
    int share_a = 0; // 共享变量
    int share_to_private_b = 1; // 通过 private 子句修饰该变量之后在并行区域内变为私有变量

    #pragma omp parallel
    {
        int private_c = 2;

        #pragma omp for private(share_to_private_b)
        for (int i = 0; i &lt; 10; ++i) //该循环变量是私有的，若为两个线程，则一个线程执行0~4，另一个执行5~9
            cout &lt;&lt; i &lt;&lt; endl;

    }

    return 0;
}
</code></pre><p>声明方法 / 功能</p>
<pre><code>并行区域中变量val是私有的，即每个线程拥有该变量的一个拷贝
private(val1, val2, ...)

与private不同的是，每个线程在开始的时候都会对该变量进行一次初始化。
first_private(val1, val2, ...)      

与private不同的是，并发执行的最后一次循环的私有变量将会拷贝到val
last_private(val1, val2, ...)      

声明val是共享的
shared(val1, val2, ...)              
</code></pre><p>如果使用private，无论该变量在并行区域外是否初始化，在进入并行区域后，该变量均不会初始化。</p>
<h2 id="Reduction__u7684_u7528_u6CD5"><a href="#Reduction__u7684_u7528_u6CD5" class="headerlink" title="Reduction 的用法"></a>Reduction 的用法</h2><p>直接上例子</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;
using namespace std;

int main(){
    int sum = 0;
    cout &lt;&lt; &quot;Before: &quot; &lt;&lt; sum &lt;&lt; endl;

    #pragma omp parallel for reduction(+:sum)
    for (int i = 0; i &lt; 10; ++i){
        sum = sum + i;
        printf(&quot;%d\n&quot;, sum);
    }

    cout &lt;&lt; &quot;After: &quot; &lt;&lt; sum &lt;&lt; endl;

    return 0;
}
</code></pre><p>其中sum是共享的，采用reduction之后，每个线程根据reduction（+: sum）的声明算出自己的sum，然后再将每个线程的sum加起来。</p>
<p>reduction声明可以看作：</p>
<ol>
<li>保证了对sum的原则操作</li>
<li>多个线程的执行结果通过reduction中声明的操作符进行计算，以加法操作符为例：</li>
</ol>
<p>假设sum的初始值为10，reduction（+: sum）声明的并行区域中每个线程的sum初始值为0（规定），并行处理结束之后，会将sum的初始化值10以及每个线程所计算的sum值相加。</p>
<p>我们在上边已经了解了reduction的声明形式，其具体如下：</p>
<p>reduction (operator: var1, val2, …)</p>
<p>其中operator以及约定变量的初始值如下：</p>
<pre><code>运算符            数据类型            默认初始值
  +              整数、浮点             0
  -              整数、浮点             0
  *              整数、浮点             1
  &amp;                整数             所有位均为1
  |                整数                0
  ^                整数                0
  &amp;&amp;               整数                1
  ||               整数                0
</code></pre><h2 id="u7EBF_u7A0B_u540C_u6B65_u4E4B_atomic"><a href="#u7EBF_u7A0B_u540C_u6B65_u4E4B_atomic" class="headerlink" title="线程同步之 atomic"></a>线程同步之 atomic</h2><p>在OpenMP中，线程同步机制包括互斥锁同步机制和事件同步机制。互斥锁同步的概念类似于Windows中的临界区（CriticalSection）以及Windows和Linux中的Mutex，以及VxWorks中的SemTake何SemGive（初始化时信号量为满），即对某一块代码操作进行保护，以保证同时只能有一个线程执行该段代码。</p>
<h3 id="atomic_uFF08_u539F_u5B50_uFF09_u64CD_u4F5C_u8BED_u6CD5"><a href="#atomic_uFF08_u539F_u5B50_uFF09_u64CD_u4F5C_u8BED_u6CD5" class="headerlink" title="atomic（原子）操作语法"></a>atomic（原子）操作语法</h3><pre><code>#pragma omp atomic
x&lt; + or * or - or * or / or &amp; or | or &lt;&lt; or &gt;&gt; &gt;=expr
(例如x &lt;&lt;= 1; or x *=2;)
</code></pre><p>或</p>
<pre><code>#pragma omp atomic
x++ //or x--, --x, ++x
</code></pre><p>可以看到atomic的操作仅适用于两种情况：</p>
<ol>
<li>自加减操作</li>
<li>x&lt;上述列出的操作符&gt;=expr</li>
</ol>
<p>例如</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;omp.h&gt;
using namespace std;

int main(){
    int sum = 0;
    cout &lt;&lt; &quot;Before: &quot; &lt;&lt; sum &lt;&lt; endl;

    #pragma omp parallel for
    for (int i = 0; i &lt; 20000; ++i){
        #pragma omp atomic
        sum++;
    }
    cout &lt;&lt; &quot;Atomic-After: &quot; &lt;&lt; sum &lt;&lt; endl;

    sum = 0;
    #pragma omp parallel for
    for (int i = 0; i &lt; 20000; ++i){
        sum++;
    }
    cout &lt;&lt; &quot;None-atomic-After: &quot; &lt;&lt; sum &lt;&lt; endl;
    return 0;
}
</code></pre><p>输出20000。如果将#pragma omp atomic声明去掉，则输出值不确定。</p>
<h2 id="u7EBF_u7A0B_u540C_u6B65_u4E4B_critical"><a href="#u7EBF_u7A0B_u540C_u6B65_u4E4B_critical" class="headerlink" title="线程同步之 critical"></a>线程同步之 critical</h2><p>这里的临界区与Windows下的CriticalSection类似。<br>临界区声明方法</p>
<pre><code>#pragma omp critical [(name)] //[]表示名字可选
{
//并行程序块，同时只能有一个线程能访问该并行程序块
}
</code></pre><p>例如</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;omp.h&gt;
using namespace std;

int main(){
    int sum = 0;
    cout &lt;&lt; &quot;Before: &quot; &lt;&lt; sum &lt;&lt; endl;

    #pragma omp parallel for
    for (int i = 0; i &lt; 100; ++i){
        #pragma omp critical(a)
        {
            sum = sum + i;
            sum = sum + i * 2;
        }
    }

    cout &lt;&lt; &quot;After: &quot; &lt;&lt; sum &lt;&lt; endl;

    return 0;
}
</code></pre><p>critical 与 atomic 的区别在于，atomic 仅适用于上一节规定的两种类型操作，而且 atomic 所防护的仅为一句代码。critical 可以对某个并行程序块进行防护。</p>
<p>For a simple increment to a shared variable, atomic and critical are semantically equivalent, but atomic allows the compiler more opportunities for optimisation (using hardware instructions, for example). </p>
<p>In other cases, there are differences. If incrementing array elements (e.g. a[i]++ ), atomic allows different threads to update different elements of the array concurrently whereas critical does not. If there is a more complicated expression on the RHS (e.g. a+=foo() ) then the evaluation of foo() is protected from concurrent execution with critical but not with atomic. </p>
<p>Using a critical section is a legitimate way of implementing atomics inside the compiler/runtime, but most current OpenMP compilers do a better job than this. </p>
<h2 id="u7EBF_u7A0B_u540C_u6B65_u4E4B_u4E8B_u4EF6_u540C_u6B65_u673A_u5236"><a href="#u7EBF_u7A0B_u540C_u6B65_u4E4B_u4E8B_u4EF6_u540C_u6B65_u673A_u5236" class="headerlink" title="线程同步之事件同步机制"></a>线程同步之事件同步机制</h2><p>互斥锁同步包括atomic、critical、mutex函数，其机制与普通多线程同步的机制类似。而事件同步则通过nowait、sections、single、master等预处理器指示符声明来完成。</p>
<h3 id="u9690_u5F0F_u6805_u969C"><a href="#u9690_u5F0F_u6805_u969C" class="headerlink" title="隐式栅障"></a>隐式栅障</h3><p>barrier为隐式栅障，即并行区域中所有线程执行完毕之后，主线程才继续执行。</p>
<h3 id="nowait__u7528_u6765_u53D6_u6D88_u6805_u969C"><a href="#nowait__u7528_u6765_u53D6_u6D88_u6805_u969C" class="headerlink" title="nowait 用来取消栅障"></a>nowait 用来取消栅障</h3><p>其用法如下：</p>
<pre><code>#pragma omp for nowait //不能用#pragma omp parallel for nowait
或
#pragma omp single nowait
</code></pre><p>例如</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main(){
    #pragma omp parallel
    {
        #pragma omp for nowait
        for (int i = 0; i &lt; 1000; ++i){
            printf(&quot;%d+\n&quot;, i);
        }

        #pragma omp for
        for (int j = 0; j &lt; 10; ++j){
            printf(&quot;%d-\n&quot;, j);
        }
    }
    return 0;
}
</code></pre><p>第一个 for 循环的两个线程中的一个执行完之后，继续往下执行，因此同时打印出了第一个循环的 + 和第一个循环的 - 。</p>
<p>可以看到，第二个 for 循环的两个线程都执行完之后，才开始同时执行第三个 for 循环，并没有交叉。也就是说，通过 #pragma omp for 声明的 for 循环结束时有一个默认的栅障。</p>
<h3 id="u663E_u5F0F_u540C_u6B65_u6805_u969C__23pragma_omp_barrier"><a href="#u663E_u5F0F_u540C_u6B65_u6805_u969C__23pragma_omp_barrier" class="headerlink" title="显式同步栅障 #pragma omp barrier"></a>显式同步栅障 #pragma omp barrier</h3><pre><code>#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main(){
    #pragma omp parallel
    {
        for (int i = 0; i &lt; 100; ++i){
        printf(&quot;%d+\n&quot;, i);
        }
        #pragma omp barrier
        for (int j = 0; j &lt; 10; ++j){
            printf(&quot;%d-\n&quot;, j);
        }
    }    
}
</code></pre><p>两个线程(具体数目不同 CPU 不同)执行了第一个for循环，当两个线程同时执行完第一个for循环之后，在barrier处进行了同步，然后执行后边的for循环。</p>
<h3 id="master__u901A_u8FC7_23pragma_omp_mater_u6765_u58F0_u660E_u5BF9_u5E94_u7684_u5E76_u884C_u7A0B_u5E8F_u5757_u53EA_u7531_u4E3B_u7EBF_u7A0B_u5B8C_u6210_u3002"><a href="#master__u901A_u8FC7_23pragma_omp_mater_u6765_u58F0_u660E_u5BF9_u5E94_u7684_u5E76_u884C_u7A0B_u5E8F_u5757_u53EA_u7531_u4E3B_u7EBF_u7A0B_u5B8C_u6210_u3002" class="headerlink" title="master 通过#pragma omp mater来声明对应的并行程序块只由主线程完成。"></a>master 通过#pragma omp mater来声明对应的并行程序块只由主线程完成。</h3><pre><code>#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main(){
    #pragma omp parallel
    {
        #pragma omp master
        {
            for (int j = 0; j &lt; 10; ++j){
                printf(&quot;%d-\n&quot;, j);
            }
        }

        printf(&quot;This will be shown two or more times\n&quot;);
    }
    return 0;
}
</code></pre><p>进入 parallel 声明的并行区域之后，创建了两个(或更多)线程，主线程执行了 for 循环，而另一个线程没有执行 for 循环，而直接进入了 for 循环之后的打印语句，然后执行 for 循环的线程随后还会再执行一次后边的打印语句。</p>
<h3 id="section__u7528_u6765_u6307_u5B9A_u4E0D_u540C_u7684_u7EBF_u7A0B_u6267_u884C_u4E0D_u540C_u7684_u90E8_u5206"><a href="#section__u7528_u6765_u6307_u5B9A_u4E0D_u540C_u7684_u7EBF_u7A0B_u6267_u884C_u4E0D_u540C_u7684_u90E8_u5206" class="headerlink" title="section 用来指定不同的线程执行不同的部分"></a>section 用来指定不同的线程执行不同的部分</h3><p>通过一个示例说明其使用方法：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main(){
    #pragma omp parallel sections // 声明该区域分为若干个 section, section 之间的运行顺序为并行的关系
    {
        #pragma omp section // 第一个 section, 由某个线程单独完成
        for (int i = 0; i &lt; 5; ++i){
            printf(&quot;%d+\n&quot;, i);
        }

        #pragma omp section // 另一个 section, 由某个线程单独完成
        for (int j = 0; j &lt; 5; ++j){
            printf(&quot;%d-\n&quot;, j);
        }
    }
    return 0;
}
</code></pre><p>因为并行区域中有两个线程，所以两个section同时执行。</p>
<h2 id="u7EBF_u7A0B_u7684_u8C03_u5EA6_u4F18_u5316"><a href="#u7EBF_u7A0B_u7684_u8C03_u5EA6_u4F18_u5316" class="headerlink" title="线程的调度优化"></a>线程的调度优化</h2><p>通过前边的介绍，知道了并行区域，默认情况下会自动生成与CPU个数相等的线程，然后并行执行并行区域中的代码，对于并行区域中的for循环，有特殊的声明方式，这样不同的线程可以分别运行for循环变量的不同部分。通过锁同步（atomic、critical、mutex函数）或事件同步（nowait、signal、section、master）来实现并行区域的同步控制。</p>
<p>具体的调度策略均由底层完成，本节介绍几种可以在上层对for循环进行控制的调度策略。</p>
<p>determines which iterations are executed by each thread</p>
<ul>
<li>STATIC<ul>
<li>The iteration space is broken in chunks of approximately size N/(num of threads). Then these chunks are assigned to the threads in a Round-Robin fashion.    </li>
</ul>
</li>
<li>STATIC, CHUNK<ul>
<li>The iteration space is broken in chunks of size N. Then these chunks are assigned to the threads in a Round-Robin fashion.</li>
</ul>
</li>
<li>Characteristics of static schedules<ul>
<li>Low overhead</li>
<li>Good locality (usually)</li>
<li>Can have load imbalance problems</li>
</ul>
</li>
<li>DYNAMIC[,chunk]<ul>
<li>Threads dynamically grab chunks of N iterations until all iterations have been executed. If no chunk is specified, N = 1</li>
</ul>
</li>
<li>GUIDED[,chunk]<ul>
<li>Variant of dynamic. The size of the chunks deceases as the threads grab iterations, but it is at least of size N. If no chunk is specified, N = 1.</li>
</ul>
</li>
<li>Characteristics of static schedules<ul>
<li>Higher overhead</li>
<li>Not very good locality (usually)</li>
<li>Can solve imbalance problems</li>
</ul>
</li>
<li>AUTO<ul>
<li>The implementation is allowed to do whatever it wishes. (Do not expect much of it as of now)</li>
</ul>
</li>
<li>RUNTIME<ul>
<li>The decision is delayed until the program is run through the sched-nvar ICV. It can be set with:</li>
<li>The <code>OMP_SCHEDULE</code> environment variable</li>
<li>The <code>omp_set_schedule()</code> API call</li>
</ul>
</li>
</ul>
<p>能看到这里，如果都跑过一遍的话，应该也就差不多了。上课过程中有啥想法再追加吧。我要去改代码了再见。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>For CMU 18-645 How to write fast code. Learn openmp in an hour!  <a href="http://blog.csdn.net/donhao">主要来源</a></p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="OpenMP" scheme="http://wdxtub.com/tags/OpenMP/"/>
    
      <category term="整理" scheme="http://wdxtub.com/tags/%E6%95%B4%E7%90%86/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 19 课 Dynamic Memory Allocation - Advanced Concept]]></title>
    <link href="http://wdxtub.com/2016/03/19/csapp-19/"/>
    <id>http://wdxtub.com/2016/03/19/csapp-19/</id>
    <published>2016-03-19T21:32:34.000Z</published>
    <updated>2016-03-20T03:32:44.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们来看看关于内存分配的延伸话题，包括更加复杂的选择机制以及垃圾回收等相关内容。</p>
<a id="more"></a>
<hr>
<p>这节课主要介绍后面三种方法，都是用来记录未分配空间的，具体如下：</p>
<p><img src="/images/14584386982186.jpg" alt="Keeping Track of Free Blocks"></p>
<h2 id="u663E_u5F0F_free__u5217_u8868"><a href="#u663E_u5F0F_free__u5217_u8868" class="headerlink" title="显式 free 列表"></a>显式 free 列表</h2><p>主要的改动在于，只记录 free block，而不是所有的 block。因为是指针，所以不仅需要记录后一个也需要记录前一个；与此同时，仍然需要 boundary tag 来作为合并的辅助信息。具体的结构如下：</p>
<p><img src="/images/14584389197608.jpg" alt="Explicit Free Lists"></p>
<p>因为是指针，逻辑上是连续的，但实际上可以是无序的，如下图：</p>
<p><img src="/images/14584389533544.jpg" alt="Logically vs Physically"></p>
<p>分配空间的过程就是指针重新指向的过程：</p>
<p><img src="/images/14584389995555.jpg" alt="Allocating From Explicit Free Lists"></p>
<p>然后我们来看看，当释放空间的时候，具体要把刚释放的 block，放在列表中的哪个位置呢？有两种策略：后入先出或按照地址排序。</p>
<p><img src="/images/14584390706378.jpg" alt="Freeing With Explicit Free Lists"></p>
<p>接下来是 LIFO 策略的几个不同的情况，灰色表示已经分配的空间：</p>
<p>Case 1</p>
<p><img src="/images/14584391317448.jpg" alt="Case 1"></p>
<p>Case 2</p>
<p><img src="/images/14584391482644.jpg" alt="Case 2"></p>
<p>Case 3</p>
<p><img src="/images/14584391607445.jpg" alt="Case 3"></p>
<p>Case 4</p>
<p><img src="/images/14584391818093.jpg" alt="Case 4"></p>
<p>总结一下，与隐式列表相比</p>
<ul>
<li>因为只记录 free block，在内存几乎满的时候效率很高</li>
<li>因为需要切分 block 以及维护列表，所以稍微复杂一点</li>
<li>对于每个链接来说需要 2 个额外的 word 来记录前面一个 free block 和后面一个 free block</li>
</ul>
<h2 id="Segregated_free__u5217_u8868"><a href="#Segregated_free__u5217_u8868" class="headerlink" title="Segregated free 列表"></a>Segregated free 列表</h2><blockquote>
<p>Most common use of linked lists is in conjunction with segregated free lists. Keep multiple linked lists of different size classes, or possibly for different types of objects.</p>
</blockquote>
<p>也就是说，每个不同大小 block 会在不同的列表里，对于较小的 size，一般会有单独的列表，对于稍大的 size，列表的范围也会更大，如下图所示：</p>
<p><img src="/images/14584404151349.jpg" alt="Each size class of blocks has its own free list"></p>
<p>要分配一个大小为 n 的 block：</p>
<ul>
<li>搜索比 n 大的 free list 列表</li>
<li>如果找到了合适的，切分 block 并且把剩余的放到对应的列表中（可选）</li>
<li>如果没有合适的 block，找更大的 size</li>
<li>重复上述过程，直到找到为止</li>
</ul>
<p>如果确实找不到：</p>
<ul>
<li>向系统请求额外的堆内存（使用 <code>sbrk()</code>）</li>
<li>在新的内存中分配对应的空间</li>
<li>把剩余的空间放到最大 size 的列表中</li>
</ul>
<p>释放空间时：</p>
<ul>
<li>合并 block 并放到对应的列表中</li>
</ul>
<p>Seglist allocator 的优势：</p>
<ul>
<li>更高的吞吐量(log time for power-of-two size classes)</li>
<li>更好的内存利用率<ul>
<li>First-fit search of segregated free list approximates a best-fit search of entire heap</li>
<li>Extreme case: Giving each block its own size class is equivalent to best-fit</li>
</ul>
</li>
</ul>
<h2 id="u5783_u573E_u56DE_u6536"><a href="#u5783_u573E_u56DE_u6536" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>所谓垃圾回收，就是我们不再需要显式释放所申请内存空间了，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* p block is now garbage*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种机制在许多动态语言中都有实现：Python, Ruby, Java, Perl, ML, Lisp, Mathematica。C 和 C++ 中也有类似的变种，但是需要注意的是，是不可能回收所有的垃圾的。</p>
<p>我们如何知道什么东西才是『垃圾』呢？简单！只要没有任何指针指向的地方，不管有没有用，因为都不可能被使用，当然可以直接清理掉啦。不过这其实是需要一些前提条件的：</p>
<ul>
<li>我们可以知道哪里是指针，哪里不是指针</li>
<li>每个指针都指向 block 的开头</li>
<li>指针不能被隐藏(by coercing them to an <code>int</code>, and then back again)</li>
</ul>
<p>相关的算法如下：</p>
<p><img src="/images/14584417083434.jpg" alt="Classical GC Algorithms"></p>
<p>这里我们主要讨论第一种 Mark-and-sweep collection 算法（居然已经有五十多年的历史了）</p>
<p>内存具体的分布，可以看做是一个有向图，每个 block 相当于一个节点，每个指针相当于一条边。那些不在堆中的且指向堆的指针称为根节点（如寄存器，栈，全局变量等），如下图所示：</p>
<p><img src="/images/14584420668262.jpg" alt="Memory as a Graph"></p>
<h3 id="Mark_and_Sweep_Collecting"><a href="#Mark_and_Sweep_Collecting" class="headerlink" title="Mark and Sweep Collecting"></a>Mark and Sweep Collecting</h3><p>这个机制可以在 malloc/free 的基础上实现。当空间不够的时候， 在每个 block 的头部增加一个额外的 mark bit。</p>
<ul>
<li>Mark: Start at roots and set mark bit on each reachable block</li>
<li>Sweep: Scan all blocks and free blocks that are not marked</li>
</ul>
<p>整个过程如下：</p>
<p><img src="/images/14584422740964.jpg" alt="Mark and Sweep Collecting"></p>
<p>一个简易实现的思路：</p>
<p><img src="/images/14584424812466.jpg" alt="Assumptions For a Simple Iimplementation"></p>
<p>代码如下：</p>
<p><img src="/images/14584426898133.jpg" alt=""></p>
<p>在 C 语言中，我们可以使用 <code>is_ptr()</code> 来判断是否为指针，但我们也知道，C 指针可能指向 block 的中间，这个时候我们要如何找到 block 的开头呢？</p>
<p><img src="/images/14584429046281.jpg" alt="指向中间"></p>
<p> 可以这么做</p>
<ul>
<li>Can use a balanced binary tree to keep track of all allocated blocks (key is start-of-block)</li>
<li>Balanced-tree pointers can be stored in header (use two additional words)</li>
</ul>
<p><img src="/images/14584429821424.jpg" alt="存储结构"></p>
<h2 id="u5185_u5B58_u76F8_u5173_u9677_u9631"><a href="#u5185_u5B58_u76F8_u5173_u9677_u9631" class="headerlink" title="内存相关陷阱"></a>内存相关陷阱</h2><p>关于内存的使用需要注意避免以下问题：</p>
<ul>
<li>Dereferencing bad pointers</li>
<li>Reading uninitialized memory</li>
<li>Overwriting memory</li>
<li>Referencing nonexistent variables</li>
<li>Freeing blocks multiple times</li>
<li>Referencing freed blocks</li>
<li>Failing to free blocks</li>
</ul>
<p>具体看上述问题前，我们先来了解 C 语言中操作符的顺序以及优先级：</p>
<p><img src="/images/14584431989892.jpg" alt="C operators"></p>
<p>下面是一些例子，一定要好好理解（指针什么的真的头疼）</p>
<p><img src="/images/14584433625063.jpg" alt="C Pointer Declarations"></p>
<h3 id="Dereferencing_Bad_Pointers"><a href="#Dereferencing_Bad_Pointers" class="headerlink" title="Dereferencing Bad Pointers"></a>Dereferencing Bad Pointers</h3><p>这是非常常见的例子，没有引用对应的地址，少了 <code>&amp;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, val);</span><br></pre></td></tr></table></figure>
<h3 id="Reading_Uninitialized_Memory"><a href="#Reading_Uninitialized_Memory" class="headerlink" title="Reading Uninitialized Memory"></a>Reading Uninitialized Memory</h3><p>不能假设堆中的数据会自动初始化为 0，下面的代码就会出现奇怪的问题</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* return y = Ax */</span><br><span class="line">int *matvec(int **A, int *x) &#123;</span><br><span class="line">    int *y = malloc(N * sizeof(int));</span><br><span class="line">    int i, j;</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; N; i++)</span><br><span class="line">        for (j = 0; j &lt; N; j++)</span><br><span class="line">            y[i] += A[i][j] * x[j];</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Overwriting_Memory"><a href="#Overwriting_Memory" class="headerlink" title="Overwriting Memory"></a>Overwriting Memory</h3><p>这里有挺多问题，第一种是分配了错误的大小，下面的例子中，一开始不能用 <code>sizeof(int)</code>，因为指针的长度不一定和 int 一样。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int **p;</span><br><span class="line">p = malloc(N * sizeof(int));</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; N; i++) </span><br><span class="line">    p[i] = malloc(M * sizeof(int));</span><br></pre></td></tr></table></figure>
<p>第二个问题是超出了分配的空间，下面代码的 for 循环中，因为使用了 <code>&lt;=</code>，会写入到其他位置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int **p;</span><br><span class="line"></span><br><span class="line">p = malloc(N * sizeof (int *));</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt;= N; i++)</span><br><span class="line">    p[i] = malloc(M * sizeof(int));</span><br></pre></td></tr></table></figure>
<p>第三种是因为没有检查字符串的长度，超出部分就写到其他地方去了（经典的缓冲区溢出攻击也是利用相同的机制）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">gets(s); <span class="comment">/* reads "123456789" from stdin */</span></span><br></pre></td></tr></table></figure>
<p>第四种是没有正确理解指针的大小以及对应的操作，应该使用 <code>sizeof(int *)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">search</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*p &amp;&amp; *p != null)</span><br><span class="line">        p += <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第五种是引用了指针，而不是其指向的对象，下面的例子中，<code>*size--</code> 一句因为 <code>--</code> 的优先级比较高，所以实际上是对指针进行了操作，正确的应该是 <code>(*size)--</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">BinheapDelete</span><span class="params">(<span class="keyword">int</span> **binheap, <span class="keyword">int</span> *size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *packet;</span><br><span class="line">    packet = binheap[<span class="number">0</span>];</span><br><span class="line">    binheap[<span class="number">0</span>] = binheap[*size - <span class="number">1</span>];</span><br><span class="line">    *size--;</span><br><span class="line">    Heapify(binheap, *size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Referencing_Nonexistent_Variables"><a href="#Referencing_Nonexistent_Variables" class="headerlink" title="Referencing Nonexistent Variables"></a>Referencing Nonexistent Variables</h3><p>下面的情况中，没有注意到局部变量会在函数返回的时候失效（所以对应的指针也会无效），这是传引用和返回引用需要注意的，传值的话则不用担心</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Freeing_Blocks_Multiple_Times"><a href="#Freeing_Blocks_Multiple_Times" class="headerlink" title="Freeing Blocks Multiple Times"></a>Freeing Blocks Multiple Times</h3><p>这个不用多说，不能重复搞两次</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = malloc(N * sizeof(int));</span><br><span class="line">//  &lt;manipulate x&gt;</span><br><span class="line">free(x);</span><br><span class="line"></span><br><span class="line">y = malloc(M * sizeof(int));</span><br><span class="line">//  &lt;manipulate y&gt;</span><br><span class="line">free(x);</span><br></pre></td></tr></table></figure>
<h3 id="Referencing_Freed_Blocks"><a href="#Referencing_Freed_Blocks" class="headerlink" title="Referencing Freed Blocks"></a>Referencing Freed Blocks</h3><p>同样是很明显的错误，不要犯</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = malloc(N * sizeof(int));</span><br><span class="line">//  &lt;manipulate x&gt;</span><br><span class="line">free(x);</span><br><span class="line">//  ....</span><br><span class="line"></span><br><span class="line">y = malloc(M * sizeof(int));</span><br><span class="line">for (i = 0; i &lt; M; i++)</span><br><span class="line">    y[i] = x[i]++;</span><br></pre></td></tr></table></figure>
<h3 id="Memory_Leaks"><a href="#Memory_Leaks" class="headerlink" title="Memory Leaks"></a>Memory Leaks</h3><p>用完没有释放，就是内存泄露啦</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo() &#123;</span><br><span class="line">    int *x = malloc(N * sizeof(int));</span><br><span class="line">    // ...</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者只释放了数据结构的一部分：</p>
<p><img src="/images/14584447178117.jpg" alt="Freeing only part of a data structure"></p>
<h3 id="u5BF9_u7B56"><a href="#u5BF9_u7B56" class="headerlink" title="对策"></a>对策</h3><p>我们可以使用下面的工具和方法来处理内存的 bug</p>
<p><img src="/images/14584447590453.jpg" alt="Dealing With Memory Bugs"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们来看看关于内存分配的延伸话题，包括更加复杂的选择机制以及垃圾回收等相关内容。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="内存分配" scheme="http://wdxtub.com/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 18 课 Dynamic Memory Allocation - Basic Concept]]></title>
    <link href="http://wdxtub.com/2016/03/19/csapp-18/"/>
    <id>http://wdxtub.com/2016/03/19/csapp-18/</id>
    <published>2016-03-19T21:32:26.000Z</published>
    <updated>2016-03-20T00:16:19.000Z</updated>
    <content type="html"><![CDATA[<p>前面了解了虚拟内存的相关知识，这节课我们来看看动态内存分配的基本概念，相信这之后就知道诸如 <code>malloc</code> 和 <code>new</code> 这类方法是怎么做的了。</p>
<a id="more"></a>
<hr>
<h2 id="u57FA_u7840_u6982_u5FF5"><a href="#u57FA_u7840_u6982_u5FF5" class="headerlink" title="基础概念"></a>基础概念</h2><p>程序员通过动态内存分配（例如 <code>malloc</code>）来让程序在运行时得到虚拟内存。动态内存分配器会管理一个虚拟内存区域，称为堆(heap)，如下图所示：</p>
<p><img src="/images/14584238419962.jpg" alt="Dynamic Memory Allocation"></p>
<p>分配器以 block 为单位来维护 heap，可以进行 allocate 或 free。有两种类型的分配器：</p>
<ul>
<li>显式分配器：应用分配并且回收空间（C 语言中的 <code>malloc</code> 和 <code>free</code>）</li>
<li>隐式分配器：应用只负责分配，但是不负责回收（Java 中的垃圾收集）</li>
</ul>
<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>我们来看看 <code>malloc</code> 函数：</p>
<p><img src="/images/14584242618725.jpg" alt="The malloc Package"></p>
<p>一个简单的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void foo(int n) &#123;</span><br><span class="line">    int i, *p;</span><br><span class="line">    </span><br><span class="line">    /* Allocate a block of n ints */</span><br><span class="line">    p = (int *) malloc(n * sizeof(int));</span><br><span class="line">    if (p == NULL) &#123;</span><br><span class="line">        perror("malloc");</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* Initialize allocated block */</span><br><span class="line">    for (i=0; i&lt;n; i++)</span><br><span class="line">        p[i] = i;</span><br><span class="line"></span><br><span class="line">    /* Return allocated block to the heap */</span><br><span class="line">    free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这节课中，为了讲述方便，我们做如下假设：</p>
<ul>
<li>Memory is word addressed</li>
<li>Words are int-sized</li>
</ul>
<p><img src="/images/14584252386542.jpg" alt="Assumptions Made in This Lecture"></p>
<p>具体的例子：</p>
<p><img src="/images/14584253826838.jpg" alt="Allocation Example"></p>
<p>程序可以用任意的顺序发送 <code>malloc</code> 和 <code>free</code> 请求，<code>free</code> 请求必须作用与已被分配的 block。</p>
<p>分配器有如下的限制：</p>
<ul>
<li>不能控制已分配 block 的数量和大小</li>
<li>必须立即响应 <code>malloc</code> 请求（不能缓存或者给请求重新排序）</li>
<li>必须在未分配的内存中分配</li>
<li>不同的 block 需要对齐（32 位中 8 byte，64 位中 16 byte）</li>
<li>只能操作和修改未分配的内存</li>
<li>不能移动已分配的 block</li>
</ul>
<h2 id="u6027_u80FD_u6307_u6807"><a href="#u6027_u80FD_u6307_u6807" class="headerlink" title="性能指标"></a>性能指标</h2><p>现在我们可以来看看如何去评测具体的分配算法了。假设给定一个 <code>malloc</code> 和 <code>free</code> 的请求的序列：</p>
 $$R_0, R_1, ..., R_k, ..., R_{n-1}$$ 
<p>目标是尽可能提高吞吐量以及内存利用率（注意，这两个目标常常是冲突的）</p>
<p>吞吐量是在单位时间内完成的请求数量。假设在 10 秒中之内进行了 5000 次 <code>malloc</code> 和 5000 次 <code>free</code> 调用，那么吞吐量是 1000 operations/second</p>
<p>另外一个目标是 Peak Memory Utilization，就是最大的内存利用率，具体如下：</p>
<p><img src="/images/14584265326302.jpg" alt="Peak Memory Utilization"></p>
<p>影响内存利用率的主要因素就是『内存碎片』，有两种类型：</p>
<ul>
<li>internal fragmentation</li>
<li>external fragmentation0</li>
</ul>
<h3 id="u5185_u90E8_u788E_u7247"><a href="#u5185_u90E8_u788E_u7247" class="headerlink" title="内部碎片"></a>内部碎片</h3><p>对于给定的 block，internal fragmentation 主要是因为 payload 小于 block size 造成的，如下图所示：</p>
<p><img src="/images/14584268109274.jpg" alt="internal fragmentation"></p>
<p>主要是由以下原因导致；</p>
<ul>
<li>Overhead of maintaining heap data structures</li>
<li>Padding for alignment purposes</li>
<li>Explicit policy decisions</li>
</ul>
<p>只依赖于上一个请求的具体模式，所以比较容易测量。</p>
<h3 id="u5916_u90E8_u788E_u7247"><a href="#u5916_u90E8_u788E_u7247" class="headerlink" title="外部碎片"></a>外部碎片</h3><p>指的是内存中没有足够的连续空间，如下图所示：</p>
<p><img src="/images/14584269418830.jpg" alt="External Fragmentation"></p>
<p>依赖于未来的请求模式，所以比较难测量。</p>
<h3 id="u5B9E_u73B0_u7EC6_u8282"><a href="#u5B9E_u73B0_u7EC6_u8282" class="headerlink" title="实现细节"></a>实现细节</h3><p>在具体实现之前，需要考虑以下问题：</p>
<ul>
<li>给定一个指针，我们如何知道需要释放多少内存？</li>
<li>如何记录未分配的 block ？</li>
<li>实际需要的空间比未分配的空间要小的时候，剩下的空间怎么办？</li>
<li>如果有多个区域满足条件，如何选择？</li>
<li>释放空间之后如何进行记录？</li>
</ul>
<p>一个标准的方式是在指针的前一个  word 中保存 block 的大小，通常称之为 header field 或 header，这种方式需要额外的一个 word，具体如下：</p>
<p><img src="/images/14584273450722.jpg" alt="Standard method"></p>
<p>这里我们先给出常用的四种方式，这节课主要介绍第一种，下节课会介绍后面的方法：</p>
<p><img src="/images/14584273923045.jpg" alt="Keeping Track of Free Blocks"></p>
<h2 id="u9690_u5F0F_free__u5217_u8868"><a href="#u9690_u5F0F_free__u5217_u8868" class="headerlink" title="隐式 free 列表"></a>隐式 free 列表</h2><p>对于每个 block 来说，我们需要知道大小和具体的状态（已分配/未分配），可以用两个 word 来存储，但是这样太浪费了。</p>
<p>如果一个 block 已经对其，低位地址一定是 0，所以我们可以用来当做 allocated/free 标志，当读入 word 大小的时候，需要标记出这个值。</p>
<p><img src="/images/14584304354717.jpg" alt="Implicit List"></p>
<p><img src="/images/14584304662424.jpg" alt="Detailed Implicit Free List Example"></p>
<p>寻找未分配的空间的方式如下，主要有三种：</p>
<p><img src="/images/14584305912848.jpg" alt="Finding a Free Block"></p>
<p>确定空间之后，具体进行分配如下：</p>
<p><img src="/images/14584306987840.jpg" alt="Allocating in Free Block"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addblock</span><span class="params">(ptr p, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newsize = ((len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;  <span class="comment">// round up to even</span></span><br><span class="line">    <span class="keyword">int</span> oldsize = *p &amp; -<span class="number">2</span>;                <span class="comment">// mask out low bit</span></span><br><span class="line">    *p = newsize | <span class="number">1</span>;                     <span class="comment">// set new length</span></span><br><span class="line">    <span class="keyword">if</span> (newsize &lt; oldsize)</span><br><span class="line">        *(p+newsize) = oldsize - newsize; <span class="comment">// set length in remaining</span></span><br><span class="line">                                          <span class="comment">// part of block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在释放空间的时候如果 block 后面也是未分配的空间，只做基本的处理的话，会出现有足够的位置，但是因为多余的分隔而找不到对应的位置，如下所示：</p>
<p><img src="/images/14584314075261.jpg" alt="Freeing a Block"></p>
<p>解决的办法是 Coalescing：</p>
<p><img src="/images/14584314805605.jpg" alt="coalesce"></p>
<p>另一种方法是双向 coalescing：</p>
<p><img src="/images/14584318651163.jpg" alt="Bidirectional Coalescing"></p>
<p>具体 coalescing 的时候有四种情况：</p>
<p><img src="/images/14584319803616.jpg" alt="Constant Time Coalescing"></p>
<p>下面是四种情况的：</p>
<p>Case 1：</p>
<p><img src="/images/14584322811295.jpg" alt="Case 1"></p>
<p>Case 2：</p>
<p><img src="/images/14584322969946.jpg" alt="Case 2"></p>
<p>Case 3：</p>
<p><img src="/images/14584323407555.jpg" alt="Case 3"></p>
<p>Case 4：</p>
<p><img src="/images/14584323554767.jpg" alt="Case 4"></p>
<p>Boundary Tags 的坏处就是会导致 internal fragmentation。</p>
<p>总结一下：</p>
<p><img src="/images/14584328927396.jpg" alt="Summary of Key Allocator Policies"></p>
<p>最后是 implicit list 的总结：</p>
<p><img src="/images/14584329366933.jpg" alt="Implicit Lists: Summary"></p>
<p>总体来说这一部分还是比较简单的，虽然简单，但是一定要理解清楚，因为下节课会介绍更加复杂的机制。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面了解了虚拟内存的相关知识，这节课我们来看看动态内存分配的基本概念，相信这之后就知道诸如 <code>malloc</code> 和 <code>new</code> 这类方法是怎么做的了。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="内存分配" scheme="http://wdxtub.com/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第十周 - Deacon Blue]]></title>
    <link href="http://wdxtub.com/2016/03/18/deacon-blue/"/>
    <id>http://wdxtub.com/2016/03/18/deacon-blue/</id>
    <published>2016-03-19T02:37:13.000Z</published>
    <updated>2016-03-19T11:55:43.000Z</updated>
    <content type="html"><![CDATA[<p>You can’t control what life presents. Keep it moving man, one day you’ll make it through.</p>
<a id="more"></a>
<hr>
<p>不知不觉就来到了第十周，回顾上个学期的周记，清楚地意识到，恐怕再写六周，就真的要告别『校园生活』了。没有太多不舍，因为已经尽力去体验了校园中的各种角色；没有太多遗憾，因为很多事情已经做到了足够好；甚至没有太多期待，人来人往，熙熙攘攘，桃源室外，锦城何在？</p>
<p>万万没想到，记录一下对于课程的理解，翻译一下逻辑混乱语句不同的课程资料，竟收到了老师的『警告』：因为涉及题目的思路以及相关课程内容，必须把相关日志都删掉，否则老师很生气，后果很严重。我其实没有任何选择，人在屋檐下，不得不低头，二十多篇很用心写的日志不得不『消失』，虽有些气不过，但是更多的是失望。既然都写到这儿了，一不做二不休，来说说所谓的『老师』，和所谓的『课程』：</p>
<ol>
<li>我不知道老师到底干了啥，如果他真的有看课程资料的话，是如何容忍毫无逻辑且经常前后矛盾的作业说明的？</li>
<li>我不知道助教到底是为啥一肚子坏水，说明写得不清不楚就算了，样例代码写得像下水道大学出来的一样就算了，但是拿着鸡毛当令箭真的好吗？</li>
<li>我不知道作业中为啥老师和助教工作的不严谨，要让全体同学的时间来买单，很多明显是故意设置出来『浪费』大家时间的设定，我真心觉得这已经背离了『传道授业解惑』的范畴？</li>
</ol>
<p>日志就是我的武器，用重新组织的逻辑清晰的描述完备的文字，让大家尽可能明白每次的作业到底是要做什么，把时间节约起来，去做自己真正想做的事情。然而这个不知道在哪『梦游』的老师直接用行政压力让我缴械。势单力薄，除了投降我还能做什么？</p>
<p>缺乏基本的语文能力是理工科学生的通病，又或者因为平时的生活学习节奏压根没有太多的表达训练，我真的真的遇到了太多哭笑不得的沟通障碍。举个例子，一旦走到专业之外，文化的范畴中，很多人就成了盲人。他们感受不到不同词汇不同句法背后蕴藏的深意，他们不去思考专业外的东西，眼中只有短期目标，一旦视线离开这个点，就成了无头苍蝇。</p>
<p>跟六七十岁的教授讨论起文化、哲学、历史相关的话题，才真正有『沟通』的体验：一点即通，不会在细枝末节上浪费太多精力；一针见血，直接把最核心的问题拿出来打磨讨论，用思考来切磋。</p>
<p>最近一直在玩《合金装备 5：幻痛》，整个剧情及世界观的设定和《白鲸记》《一九八四》以及《蝇王》有非常深的联系，跟同学聊起，没有人读过这些书，根本没办法进入游戏理念已经具体通过游戏来表达想法的技术讨论。</p>
<p>这真的是很痛苦的事情。聊得来是非常高的标准，至少需要双方有同等水平的思维能力。</p>
<p>最近也慢慢进入了找到工作互相请客的状态，看着大家一路坚持过来到最终实现自己的目标，我还是很开心的。借由自己的疏离感带来的观察，更加深刻理解了『性格即命运』。</p>
<p>各种各样的性格，面对问题的时候也有各种各样的解法。从我的角度来说，除了一种人需要远离之外，其他怎么折腾都行。</p>
<blockquote>
<p>远离那些野心很大，自己却配不上这份野心的人。</p>
</blockquote>
<p>他们是最可能放弃一切尊严和道德，用力把你拉下水或者会为了一丁点微不足道的东西铤而走险的人。</p>
<p>估计是因为没睡够的缘故，整篇周记的风格竟然成了这样，最后当然还是要 look on the bright side。</p>
<p>很久没有聊过这么久的电话，即使特别困也想要多说两句，高质量的沟通真的是非常愉快的事情，找到加速度差不多的人真的不容易。</p>
<p>最后说一句，AI 能取代的终究是那些思维强度太低的人，最好的做法就是多读多写多思考，人类在推动技术发展的同时，技术也在引导着人类进步的方向，跟不上时代的注定要淘汰，物竞天择，优胜劣汰。</p>
<p>Set your goal high. Be sure to stay true.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>You can’t control what life presents. Keep it moving man, one day you’ll make it through.</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="变化" scheme="http://wdxtub.com/tags/%E5%8F%98%E5%8C%96/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="春天" scheme="http://wdxtub.com/tags/%E6%98%A5%E5%A4%A9/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 17 课 Virtual Memory - System]]></title>
    <link href="http://wdxtub.com/2016/03/18/csapp-17/"/>
    <id>http://wdxtub.com/2016/03/18/csapp-17/</id>
    <published>2016-03-18T13:48:57.000Z</published>
    <updated>2016-03-19T02:21:36.000Z</updated>
    <content type="html"><![CDATA[<p>了解了基本的虚拟内存概念，这节课我们来具体看看 Core i7 和 Linux 的内存系统，相信会对虚拟内存这一套机制有更深刻的认识。</p>
<a id="more"></a>
<hr>
<p>开始之前我们还是先复习一下基本的概念：</p>
<p><img src="/images/14583183552533.jpg" alt="Review of Symbols"></p>
<h2 id="u5730_u5740_u7FFB_u8BD1_u5B9E_u4F8B"><a href="#u5730_u5740_u7FFB_u8BD1_u5B9E_u4F8B" class="headerlink" title="地址翻译实例"></a>地址翻译实例</h2><p>然后来看一个简单的例子：</p>
<ul>
<li>14 位的虚拟地址</li>
<li>12 位的物理地址</li>
<li>page size 为 64 字节</li>
</ul>
<p>如下图所示</p>
<p><img src="/images/14583359973808.jpg" alt="Addressing"></p>
<p>TLB 的配置为：</p>
<ul>
<li>16 entries</li>
<li>4-way associative</li>
</ul>
<p>如下图所示</p>
<p><img src="/images/14583376303817.jpg" alt="TLB"></p>
<p>然后来看看 page table，一共有 256 个 entry，这里列出前 16 个：</p>
<p><img src="/images/14583376858566.jpg" alt="Page Table"></p>
<p>最后来看看系统本身缓存：</p>
<ul>
<li>16 lines, 4-byte block size</li>
<li>Physically addressed</li>
<li>Direct mapped</li>
</ul>
<p><img src="/images/14583377349696.jpg" alt="Cache"></p>
<p>一定要注意好不同部分的所代表的位置，这里我也会尽量写得清楚一些，来看第一个例子：</p>
<blockquote>
<p>虚拟地址为 <code>0x03D4</code></p>
</blockquote>
<p>具体的转换过程如下图所示：</p>
<p><img src="/images/14583479163395.jpg" alt="第一个例子"></p>
<p>具体来梳理一次：</p>
<p>先看 TLB 中有没有对应的条目，所以先看虚拟地址的第 6-13 位，在前面的 TLB 表中，根据 TLBI 为 3 这个信息，去看这个 set 中有没有 tag 为 3 的项目，发现有，并且对应的 PPN 是 0x0D，所以对应到物理地址，就是 PPN 加上虚拟地址的 0-5 位，而具体的物理地址又可以在缓存中找到（利用 cache memory 的机制），就可以获取到对应的数据了。</p>
<p>下面的例子同样可以按照这个方法来进行分析</p>
<p><img src="/images/14583493888490.jpg" alt="第二个例子"></p>
<h2 id="u6848_u4F8B_u5B66_u4E60_uFF1ACore_i7"><a href="#u6848_u4F8B_u5B66_u4E60_uFF1ACore_i7" class="headerlink" title="案例学习：Core i7"></a>案例学习：Core i7</h2><p>我们先来看看整体的架构</p>
<p><img src="/images/14583495456299.jpg" alt="Intel Core i7 Memory System"></p>
<p>这里先留意一点，为什么 L1 d-cache 比上 L2 unified cache，和 L1 d-TLB 比上 L2 unified TLB 的比例一样呢？</p>
<p><img src="/images/14583500587332.jpg" alt="End-to-end Core i7 Address Translation"></p>
<p>可以清楚地看到，从 TLB 到 Page table 以及对应 cache 的转换，结合上面的说明仔细体会下。接下来的内容比较偏理论，大家有一个基本的认识即可（因为平时编程理论上也不会涉及到这些）</p>
<p>Core i7 有 4 层的 page table，前 3 层的结构一样，如下图所示</p>
<p><img src="/images/14583503794880.jpg" alt="Core i7 Level 1-3 Page Table Entries"></p>
<p>第四层有少许不同，具体看下面的说明：</p>
<p><img src="/images/14583505732854.jpg" alt="Core i7 Level 4 Page Table Entries"></p>
<p>具体的翻译过程为：</p>
<p><img src="/images/14583506241439.jpg" alt="Core i7 Page Table Translation"></p>
<p>接下来就可以回答前面的问题了，为啥是成比例的呢？原因很简单！用来加速 L1 的访问！</p>
<blockquote>
<p>Virtually indexed, physically tagged</p>
</blockquote>
<p><img src="/images/14583509113693.jpg" alt="Cute Trick for Speeding Up L1 Access"></p>
<h2 id="u6848_u4F8B_u5B66_u4E60_uFF1ALinux_Process"><a href="#u6848_u4F8B_u5B66_u4E60_uFF1ALinux_Process" class="headerlink" title="案例学习：Linux Process"></a>案例学习：Linux Process</h2><p>这一部分也是了解一下即可（具体可以不用太深究）</p>
<p><img src="/images/14583511838723.jpg" alt="Virtual Address Space of a Linux Process"></p>
<p>Linux 以不同的『区域』来组织虚拟内存</p>
<p><img src="/images/14583514430157.jpg" alt="Linux Organizes VM as Collection of &quot;Areas&quot;"></p>
<p>下面是处理 page fault 的机制：</p>
<p><img src="/images/14583519002966.jpg" alt="Linux Page Fault Handling"></p>
<h2 id="u5185_u5B58_u6620_u5C04"><a href="#u5185_u5B58_u6620_u5C04" class="headerlink" title="内存映射"></a>内存映射</h2><p>初始化虚拟内存的过程，实际上就是把对应的虚拟内存和磁盘上的对象关联起来的过程，称之为内存映射(memory mapping)</p>
<p><img src="/images/14583529040142.jpg" alt=""></p>
<p>Linux 中所谓的『交换分区』就是这么来的（我估计）</p>
<p><img src="/images/14583530219645.jpg" alt="Shared Objects"></p>
<ul>
<li>Process 1 maps the shared object</li>
<li>Process 2 maps the shared object</li>
<li>Two processes mapping a <strong>private copy-on-write(COW)</strong> object</li>
<li>Area flagged as private copy-on-write</li>
<li>PTEs in private areas are flagged as read-only</li>
</ul>
<p><img src="/images/14583530323902.jpg" alt="Private Copy-on-write(COW) Objects"></p>
<ul>
<li>Instruction writing to private page triggers protection fault</li>
<li>Handler creates new R/W page</li>
<li>Instruction restarts upon handler return</li>
<li>Copying deferred as long as possible!</li>
</ul>
<p>Fork 函数就是这种机制的一个很好的例子：</p>
<p><img src="/images/14583534506790.jpg" alt="The `fork` Function"></p>
<p>接着来看看 <code>execve</code> 函数</p>
<p><img src="/images/14583535882515.jpg" alt="The `execve` Function"></p>
<p>最后介绍了 <code>mmap</code> 函数，这里不赘述了。</p>
<p>这一部分比较偏向实际，主要还是要理解虚拟内存的机制（具体现代的处理器和操纵系统已经『太』复杂了）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解了基本的虚拟内存概念，这节课我们来具体看看 Core i7 和 Linux 的内存系统，相信会对虚拟内存这一套机制有更深刻的认识。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="虚拟内存" scheme="http://wdxtub.com/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 16 课 Virtual Memory - Concepts]]></title>
    <link href="http://wdxtub.com/2016/03/18/csapp-16/"/>
    <id>http://wdxtub.com/2016/03/18/csapp-16/</id>
    <published>2016-03-18T13:48:52.000Z</published>
    <updated>2016-03-18T16:11:31.000Z</updated>
    <content type="html"><![CDATA[<p>这节课开始，我们会接触到计算机系统中另外一个非常重要的概念：虚拟内存。这个机制提供给了上层应用一个统一的地址空间，而无须操心物理内存的位置。</p>
<a id="more"></a>
<hr>
<p>在具体讲述之前，我们先来看看什么是物理地址，什么是虚拟地址。</p>
<p><img src="/images/14583091815694.jpg" alt="物理地址"></p>
<p>物理地址一般应用在简单的嵌入式微控制器中（汽车、电梯、电子相框等），因为应用的范围有严格的限制，不需要在内存管理中引入过多的复杂度。</p>
<p>但是对于计算机（以及其他智能设备）来说，虚拟地址则是必不可少的，通过 MMU(Memory management unit)把虚拟地址(Virtual Address, VA)转换为物理地址(Physical Address, PA)，再由此进行实际的数据传输。大致的过程如下图所示</p>
<p><img src="/images/14583093850630.jpg" alt="虚拟地址"></p>
<p>使用虚拟内存主要是基于下面三个考虑：</p>
<ol>
<li>可以更有效率的使用内存：使用 DRAM 当做部分的虚拟地址空间的缓存</li>
<li>简化内存管理：每个进程都有统一的线性地址空间</li>
<li>隔离地址控件：进程之间不会相互影响；用户程序不能访问内核信息和代码</li>
</ol>
<h2 id="u4F5C_u4E3A_u7F13_u5B58_u5DE5_u5177"><a href="#u4F5C_u4E3A_u7F13_u5B58_u5DE5_u5177" class="headerlink" title="作为缓存工具"></a>作为缓存工具</h2><p>概念上来说，虚拟内存就是存储在磁盘上的 N 个连续字节的数组。这个数组的部分内容，会缓存在 DRAM 中，在 DRAM 中的每个 cache block 就称为 page（页），具体的大小为 $P=2^p$（这里 p 表示具体的位数），如下图所示：</p>
<p><img src="/images/14583098368523.jpg" alt=""></p>
<p>大致的思路和之前的 cache memory 是类似的，就是利用 DRAM 比较快的特性，把最常用的数据换缓存起来。如果要访问磁盘的话，大约会比访问 DRAM 慢一万倍，所以我们的目标就是尽可能从 DRAM 中拿数据。为此，我们需要：</p>
<ul>
<li>更大的 page size：通常是 4KB，有的时候可以达到 4MB</li>
<li>全相联 Fully associative：每一个 virual page 可以放在任意的 physical page 中，没有限制。</li>
<li>映射函数非常复杂，所以没有办法用硬件实现</li>
<li>通常使用 Write-back 而非 Write-through 机制<ul>
<li>Write-through: 命中后更新缓存，同时写入到内存中</li>
<li>Write-back: 直到这个缓存需要被置换出去，才写入到内存中（需要额外的 dirty bit 来表示缓存中的数据是否和内存中相同，因为可能在其他的时候内存中对应地址的数据已经更新，那么重复写入就会导致原有数据丢失）</li>
</ul>
</li>
</ul>
<p>具体怎么做呢？通过 page table。每个 page table 实际上是一个数组，数组中的每个元素称为 page table entry(PTE)，每个 PTE 负责把 virtual page 映射到 physical page 上。在 DRAM 中，每个进程都有自己的 page table，具体如下</p>
<p><img src="/images/14583104118576.jpg" alt="Page Table"></p>
<p>因为有一个表可以查询，就会遇到两种情况，一种是 Page Hit，另一种则是 Page Fault。</p>
<blockquote>
<p>Page hit: reference to VM word that is in physical memory (DRAM cache hit)</p>
</blockquote>
<p>访问到 page table 中蓝色条目的地址时，因为在 DRAM 中有对应的数据，可以直接访问。</p>
<blockquote>
<p>Page fault: reference to VM word that is not in physical memory (DRAM cache miss)</p>
</blockquote>
<p>访问到 page table 中灰色条目的时候，因为在 DRAM 中并没有对应的数据，所以需要执行一系列操作（从磁盘复制到 DRAM 中），具体为：</p>
<ul>
<li>触发 Page fault，也就是一个异常</li>
<li>Page fault handler 会选择 DRAM 中需要被置换的 page，并把数据从磁盘复制到 DRAM 中</li>
<li>重新执行访问指令，这时候就会是 page hit</li>
</ul>
<p>复制过程中的等待时间称为 demand paging。</p>
<p>仔细留意上面的 page table，会发现有一个条目是 null，也就是没有分配。具体的分配过程（比方说声明了一个大数组），就是让该条目指向虚拟内存（在磁盘上）的某个 page（但并不复制到 DRAM，只有当出现 page fault 的时候才需要赋值）</p>
<p>看起来『多此一举』，但是由于局部性原理，虚拟内存其实是非常高效的机制，这一部分最后提到了 working set 的概念，比较简单，这里不再赘述：</p>
<p><img src="/images/14583113431902.jpg" alt="working set"></p>
<h2 id="u4F5C_u4E3A_u5185_u5B58_u7BA1_u7406_u5DE5_u5177"><a href="#u4F5C_u4E3A_u5185_u5B58_u7BA1_u7406_u5DE5_u5177" class="headerlink" title="作为内存管理工具"></a>作为内存管理工具</h2><p>前面提到，每个进程都有自己的虚拟地址空间，这样一来，对于进程来说，它们看到的就是简单的线性空间（但实际上在物理内存中可能是间隔、支离破碎的），具体的映射过程可以用下图表示：</p>
<p><img src="/images/14583114512897.jpg" alt="maping"></p>
<p>在内存分配中没有太多限制，每个 virtual page 都可以被映射到任何的 physical page 上。这样也带来一个好处，如果两个进程间有共享的数据，那么直接指向同一个 physical page 即可（也就是上图 PP 6 的状况，只读数据）</p>
<p>虚拟内存带来的另一个好处就是可以简化链接和载入的结构（因为有了统一的抽象，不需要纠结细节），如下图所示：</p>
<p><img src="/images/14583116383432.jpg" alt="Simplifying Linking and Loading"></p>
<h2 id="u4F5C_u4E3A_u5185_u5B58_u4FDD_u62A4_u5DE5_u5177"><a href="#u4F5C_u4E3A_u5185_u5B58_u4FDD_u62A4_u5DE5_u5177" class="headerlink" title="作为内存保护工具"></a>作为内存保护工具</h2><p>Page table 中的每个条目的高位部分是表示权限的位，MMU 可以通过检查这些位来进行权限控制（读、写、执行）</p>
<p><img src="/images/14583120873244.jpg" alt="Permission bits"></p>
<h2 id="u5730_u5740_u7FFB_u8BD1"><a href="#u5730_u5740_u7FFB_u8BD1" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>开始之前先来了解以下概念：</p>
<p><img src="/images/14583133332593.jpg" alt="Summary of Address Translation Symbols"></p>
<p>然后我们通过一个具体的例子来说明如何进行地址翻译</p>
<p><img src="/images/14583134329438.jpg" alt="Address Translation With a Page Table"></p>
<p>具体的访问过程为：</p>
<ul>
<li>通过虚拟地址找到 page table 中对应的条目</li>
<li>检查 valid bit，是否需要触发 page fault</li>
<li>然后根据 page table 中的 physical page number 找到内存中的对应地址</li>
<li>最后把 virtual page offset 和前面的实际地址拼起来，就是最终的物理地址了</li>
</ul>
<p>这里又分两种情况：Page Hit 和 Page Fault，具体过程如下：</p>
<p><img src="/images/14583139236125.jpg" alt="Page Hit"></p>
<ol>
<li>Processor sends virtual address to MMU</li>
<li>MMU fetches PTE from page table in memory</li>
<li>MMU fetches PTE from page table in memory</li>
<li>MMU sends physical address to cache/memory</li>
<li>Cache/memory sends data word to processor</li>
</ol>
<p><img src="/images/14583140218329.jpg" alt="Page Fault"></p>
<ol>
<li>Processor sends virtual address to MMU</li>
<li>MMU fetches PTE from page table in memory</li>
<li>MMU fetches PTE from page table in memory</li>
<li>Valid bit is zero, so MMU triggers page fault exception</li>
<li>Handler identifies victim (and, if dirty, pages it out to disk)</li>
<li>Handler pages in new page and updates PTE in memory</li>
<li>Handler returns to original process, restarting faulting instruction</li>
</ol>
<p>把这个和我们前面提到的 cache memory 结合起来就是：</p>
<p><img src="/images/14583153762095.jpg" alt="Integrating VM and Cache"></p>
<ul>
<li>VA: virtual address, PA: physical address</li>
<li>PTE: page table entry, PTEA = PTE address</li>
</ul>
<p>但是我们会发现，这样其实还不够快，L1 cache 虽然快，为什么不能直接在 MMU 进行一部分的工作呢？于是就有了另外一个设计：Translation Lookaside Buffer(TLB)</p>
<ul>
<li>Small set-associative hardware cache in MMU</li>
<li>Maps virtual page numbers to physical page numbers</li>
<li>Contains complete page table entries for small number of pages</li>
</ul>
<p>我们使用 Virtual Page Number 部分当做访问 TLB 的索引，具体如下（和 cache memory 非常相似）：</p>
<p><img src="/images/14583156462414.jpg" alt="Accessing the TLB"></p>
<p>同样分两个情况：TLB Hit 和 TLB Miss</p>
<blockquote>
<p>A TLB hit eliminates a memory access</p>
</blockquote>
<p><img src="/images/14583156886189.jpg" alt="TLB Hit"></p>
<blockquote>
<p>A TLB miss incurs an additional memory access(the PTE)</p>
</blockquote>
<p><img src="/images/14583157195012.jpg" alt="TLB Miss"></p>
<h3 id="Multi-Level_Page_Tables"><a href="#Multi-Level_Page_Tables" class="headerlink" title="Multi-Level Page Tables"></a>Multi-Level Page Tables</h3><p>Page table 的另一个问题就是，因为往往虚拟地址的位数比物理内存的位数要大得多，所以保存 page table entry(PTE) 也是一个问题。举个例子：</p>
<p>假设一个 page 的大小是 4KB($2^12$)，每个地址有 48 位，一条 PTE 记录有 8 个字节，那么要全部保存下来，需要的大小是：</p>
<p>$$2^{48} \times 2^{-12} \times 2^3 = 2^{39} bytes$$</p>
<p>整整 512 GB!</p>
<p>所以解决办法就是，多层的 page table，第一层的 page table 中的条目指向其他的 page table，然后再去寻找具体的地址：</p>
<p><img src="/images/14583164443493.jpg" alt="A Two-Level Page Table Hierarchy"></p>
<p>具体的翻译过程如下：</p>
<p><img src="/images/14583165384715.jpg" alt="Translating with a k-level Page Table"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Programmer’s view of virtual memory<ul>
<li>Each process has its own private linear address space</li>
<li>Cannot be corrupted by other processes</li>
</ul>
</li>
<li>System view of virtual memory<ul>
<li>Use memory efficiently by caching virtual memory pages<ul>
<li>Efficient only because of locality </li>
</ul>
</li>
<li>Simplifies memory management and programming</li>
<li>Simplifies protection by providing a convenient interpositioning point to check permissions</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课开始，我们会接触到计算机系统中另外一个非常重要的概念：虚拟内存。这个机制提供给了上层应用一个统一的地址空间，而无须操心物理内存的位置。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="虚拟内存" scheme="http://wdxtub.com/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 第 20 课 设计模式]]></title>
    <link href="http://wdxtub.com/2016/03/17/sad-20/"/>
    <id>http://wdxtub.com/2016/03/17/sad-20/</id>
    <published>2016-03-17T17:33:55.000Z</published>
    <updated>2016-03-18T01:30:19.000Z</updated>
    <content type="html"><![CDATA[<p>前面讲了这么多『玄学』概念，这一次终于回到软件开发的主战场——设计模式！</p>
<a id="more"></a>
<hr>
<p>设计模式可以算得上是软件架构中最有门道的一部分，也是大家最熟悉却又最陌生的一部分。熟悉是因为任何软件工程的课一定会提到，陌生则是因为『纸上得来终觉浅』，往往在实际应用中，会出现很多问题。总体来说，设计模式可以看作是解决某种特定问题的成功经验的提炼，学习设计模式，等于是站在巨人的肩膀上，能看得更远。</p>
<p>因为自己对这个话题也很有兴趣，所以就不按照老师课堂的讲述来编排了（实话说我觉得她讲的非常一般），课堂上主要介绍了工厂模式、单例模式、建造者模式和原型模式（本文都会涉及）。</p>
<p>本文主要写自己对不同模式，以及模式之间的一些思考。</p>
<h2 id="u5148_u5520_u53E8_u4E24_u53E5"><a href="#u5148_u5520_u53E8_u4E24_u53E5" class="headerlink" title="先唠叨两句"></a>先唠叨两句</h2><p>从前提到『设计模式』，总觉得是特别高大上的东西。随着代码越写越多，接触的事物越来越广泛，慢慢开始意识到这些所谓的『规则』，是保护，也是束缚。也开始怀疑过去不知道为什么就会去『相信』的东西，比如说本文的『设计模式』，以及与之密切相关的『面向对象』。</p>
<p>学术界的一大问题在于，有的时候为了凸现自己的不同，会强行『发明』一些东西。层出不穷的理论与技术，结合不同时代的主题，颇有种『一代补丁一代神』的循环感。最近特别火的 AlphaGO，最终不可避免会遇到 PS4 的尴尬——是在模拟地球，还是在模拟地球仪？</p>
<p>最近几年听到看到的各路流派给自己贴光环的故事已经太多，从 OO 到 SOA，从 Vim 到 Emac，从 Windows 到 Linux/Unix，例子不胜枚举。问题在于，它们都想用一个东西解决所有问题，但是真有这么个东西，早就解决了你想要解决这个解决问题的问题了（是不是被绕了？）。不能只有一种声音，不能只有一种思路，甚至可以从《一九八四》中『偷』来这么个概念——双重思想。</p>
<p>C++ STL 库的作者关于面向对象说过这么一段话（虽有断章取义之嫌，但应该还是能表达出他的理念）：</p>
<blockquote>
<p>I find OOP technically unsound. It attempts to decompose the world in terms of interfaces that vary on a single type. To deal with the real problems you need multisorted algebras – families of interfaces that span multiple types. I find OOP philosophically unsound. It claims that everything is an object. Even if it is true it is not very interesting – saying that everything is an object is saying nothing at all. I find OOP methodologically wrong. It starts with classes. It is as if mathematicians would start with axioms. You do not start with axioms – you start with proofs. Only when you have found a bunch of related proofs, can you come up with axioms. You end with axioms. The same thing is true in programming: you have to start with interesting algorithms. Only when you understand them well, can you come up with an interface that will let them work.</p>
</blockquote>
<p>就拿 Java 来说，所有东西都是对象，这跟所有东西都不是对象又有什么区别呢？纵观《设计模式》一书所说的 23 种设计模式，说白了就是：</p>
<ul>
<li>多组合少继承</li>
<li>面向接口而非实现</li>
<li>高内聚低耦合</li>
</ul>
<p>其实都是平时听得太多以至于不太在意的概念。或者很多时候我们被『想当然』封印住了思考，本能就往 OO 或者 SOA 的方向跳了。</p>
<p>然后说说 SOA，从大三刚开始接触的时候，我就感觉非常不科学。SOA 的想法很好，方向也很好，但是遇到的一个悖论就是，在业务复杂到足以体现 SOA 的优势的时候，往往 SOA 本身已经复杂得没人弄得懂了。因为大家都是提供一个服务给别人调用，那么调用背后发生的事情就是一团乱麻了，基本上一个功能完成后就只有两个命运：用一段时间，需要更新的时候直接重写。</p>
<p>这种时候不妨回过头来看看『传统』的数据驱动编程，就会发现只有一直抓住问题的本质，才不至于人为增加太多复杂度（所以这个学期的云计算课程人为浪费大家时间我真心感受到了助教的恶意）。</p>
<blockquote>
<p>Keep It Simple, Stupid!</p>
</blockquote>
<h2 id="u5E38_u89C1_u6A21_u5F0F"><a href="#u5E38_u89C1_u6A21_u5F0F" class="headerlink" title="常见模式"></a>常见模式</h2><ul>
<li>工厂模式的本质，实际上是以一个统一的角度去理解所有的资源，具体根据特定的标志符来进行对应处理</li>
<li>抽象工厂的本质，其实就是一组配置文件，搞得那么玄乎，真心还就是几个文本文件可以解决的问题</li>
<li>原型模式的本质，Unix 中的 <code>fork</code> 可以说是完美体现，反正我先原样搞出来一个，剩下的自己继续处理</li>
<li>单例模式的本质，更像是中央集权，可以通过穿透层级进行信息的快速传递，减少消耗</li>
<li>适配器模式的本质，就是带面具，和病毒欺骗细胞完成匹配一个意思</li>
</ul>
<p>这样列下去还有很多，术语之所以存在，是为大家提供一个概念上的平台，在平台之上，就可以放开手脚自由发挥，而不是被平台所限制。</p>
<blockquote>
<p>人法地、地法天、天法道、道法自然</p>
</blockquote>
<p>多去观察，多去思考，而不是借由所谓的『权威』代替自己的劳动，才是不断进步的动力。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>那些我们习以为常觉得『自然』的东西，其实才是最重要的『模式』。</p>
<p>（这真是一篇头重脚轻的日志，实在没意思赘述概念了，具体在后面的参考链接都有）</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://design-patterns.readthedocs.org/zh_CN/latest/" target="_blank" rel="external">图说设计模式</a></li>
<li><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="external">Java之美从菜鸟到高手演变之设计模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="external">设计模式</a></li>
<li><a href="http://coolshell.cn/articles/8961.html" target="_blank" rel="external">从面向对象的设计模式看软件设计</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面讲了这么多『玄学』概念，这一次终于回到软件开发的主战场——设计模式！</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高级语法教程 2 The nature of grammar and grammar errors]]></title>
    <link href="http://wdxtub.com/2016/03/17/advanced-grammar-monitoring-2/"/>
    <id>http://wdxtub.com/2016/03/17/advanced-grammar-monitoring-2/</id>
    <published>2016-03-17T16:02:24.000Z</published>
    <updated>2016-03-17T22:06:06.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们通过一些具体的例子，来复习基本的语法概念，以及寻找为什么我们会出现语法错误的原因。</p>
<a id="more"></a>
<hr>
<p>课前回顾了之前的作业，就是一定要意识到自己到底是在哪里不熟悉，然后有针对性的用对自己有意义的事情来练习。并且尽可能多读英文书，找寻多样的表达方式</p>
<h2 id="u540D_u8BCD"><a href="#u540D_u8BCD" class="headerlink" title="名词"></a>名词</h2><blockquote>
<p>Divide this list of nouns into three categoreis, giving a heading to each.</p>
</blockquote>
<p>Word List: elephant, hope, September, delay, Diana, humor, car, marmalade, radio, Poland, truth, telephone, pole, mirror, oak, excitement</p>
<p>仔细查看各个选项之后，直觉的分类就是：抽象名词、具体名词和其他专有名词（月份/名字/国家）</p>
<p>不过除了专有名词之外，还有另一种思路，就是按照『可以当动词』的名词，和『不可以当动词』的名词，具体大家可以查查看</p>
<h2 id="u52A8_u8BCD"><a href="#u52A8_u8BCD" class="headerlink" title="动词"></a>动词</h2><blockquote>
<p>Divide the verbs in these utterances into two categories, stating a reason for your allocation</p>
</blockquote>
<p>这里主要是帮助大家区分及物动词(transitive)和不及物动词(intransitive)</p>
<ol>
<li>You’ve finished your tea.</li>
<li>They are eating cake.</li>
<li>They are eating at home.</li>
<li>She wants to watch TV.</li>
<li>I’m going to bed.</li>
<li>I’m reparing the car.</li>
<li>Cortez conquered Mexico.</li>
<li>Many leading politicians have died violently.</li>
<li>I can’t think clearly!</li>
<li>I hate this exersise!</li>
</ol>
<p>这里还出现了完成时，具体之后会详细说。</p>
<h2 id="u53E5_u5B50_u7ED3_u6784"><a href="#u53E5_u5B50_u7ED3_u6784" class="headerlink" title="句子结构"></a>句子结构</h2><blockquote>
<p>Why do these nonsense sentences sound acceptable</p>
</blockquote>
<p>这里需要注意英语的结构：SVO(Subject + Verb + Object)，想想为什么下面这一堆乱七八糟的也能构成『像样』的句子</p>
<ol>
<li>He crattled his splot and scrot out a neelying groal.</li>
<li>They strentered folicly until a magan veened to famble them.</li>
</ol>
<p>有主语，有类似过去式的动词，有借此，有形容词，有类似的短语结构。</p>
<h2 id="u5F85_u7EED"><a href="#u5F85_u7EED" class="headerlink" title="待续"></a>待续</h2><p>还有下半部分，不过由于今天老师迟到，暂时等下次上课后再补。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们通过一些具体的例子，来复习基本的语法概念，以及寻找为什么我们会出现语法错误的原因。</p>]]>
    
    </summary>
    
      <category term="结构" scheme="http://wdxtub.com/tags/%E7%BB%93%E6%9E%84/"/>
    
      <category term="英语" scheme="http://wdxtub.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="语法" scheme="http://wdxtub.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="错误" scheme="http://wdxtub.com/tags/%E9%94%99%E8%AF%AF/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Presentation Basics 2 展示问题及解决方案]]></title>
    <link href="http://wdxtub.com/2016/03/16/presentation-basics-2/"/>
    <id>http://wdxtub.com/2016/03/16/presentation-basics-2/</id>
    <published>2016-03-17T00:25:23.000Z</published>
    <updated>2016-03-17T01:00:52.000Z</updated>
    <content type="html"><![CDATA[<p>第二课主要是具体实践的过程，我们被要求选取一个自己领域的问题，按照给定的逻辑结构，来完成『背景，问题，解决方案，评估』这样一个完整体系的展示。</p>
<a id="more"></a>
<hr>
<p>因为主要是通过具体的小组练习来进行概念的掌握，所以这里列出相关的概念，感兴趣的同学可以自己找时间练习。老师推荐了一个方法：用手机把自己说话的内容录制下来，再回头看就会发现很多问题（因为我们说的时候是不可能一边说一边听，发现自己的问题的）</p>
<blockquote>
<p>Problem-solution presentations are often organized into the following parts:</p>
</blockquote>
<ul>
<li>Description of the situation or context that the problem exists in<ul>
<li>Give the background and the consequences of the problem, so that the audience will appreciate why the solution is important</li>
</ul>
</li>
<li>Description of the problem<ul>
<li>talk about all relevant parts of the problem so that in the next section the audience will see how your solution solves the problem</li>
</ul>
</li>
<li>Discussion of the solution(s)<ul>
<li>make sure to refer back to the description of the context and the problem in order to link the solution effectively to the previous parts of the presentation</li>
</ul>
</li>
<li>Evaluation of the solution(s)<ul>
<li>you may want to discuss both the positives and the negatives of the solution you are discussing. However, in a persuasive speech, presenters tend to downplay the negatives so that their audience does not focus on the negatives</li>
</ul>
</li>
</ul>
<p>总结起来其实就是下面四个要点：</p>
<ul>
<li>Context：用平易近人的口气和例子来让大家进入节奏</li>
<li>Problem：说明问题的严重性，借此引出解决方案的重要性</li>
<li>Solution：多个角度来说明解决方案如何对应问题的各个方面</li>
<li>Evaluation：正反两面说明，更加可信</li>
</ul>
<p>注意不同要点之间的过渡要自然，并且用明显的转折词和关键字来让受众跟上节奏。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第二课主要是具体实践的过程，我们被要求选取一个自己领域的问题，按照给定的逻辑结构，来完成『背景，问题，解决方案，评估』这样一个完整体系的展示。</p>]]>
    
    </summary>
    
      <category term="展示" scheme="http://wdxtub.com/tags/%E5%B1%95%E7%A4%BA/"/>
    
      <category term="英语" scheme="http://wdxtub.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高级语法教程 1 Challenging your grammar assumptions]]></title>
    <link href="http://wdxtub.com/2016/03/15/advanced-grammar-monitoring-1/"/>
    <id>http://wdxtub.com/2016/03/15/advanced-grammar-monitoring-1/</id>
    <published>2016-03-15T17:09:17.000Z</published>
    <updated>2016-03-15T20:06:32.000Z</updated>
    <content type="html"><![CDATA[<p>最近在上的另一门课程叫做 Advanced Grammar Monitoring。主要是针对英语不是母语的人群，帮助我们了解为什么会出现各类语法错误，以及如何改正它们。</p>
<a id="more"></a>
<hr>
<h2 id="u8BFE_u7A0B_u603B_u89C8"><a href="#u8BFE_u7A0B_u603B_u89C8" class="headerlink" title="课程总览"></a>课程总览</h2><p>这门课主要专注于我们在口语中出现的各类语法错误，帮助我们建立起语法的感觉，以及识别出对应的语法错误。语法在语言中的作用，类似于某种范式，是 guideline（我觉得 trend 也合适）而非 rule。</p>
<p>课程目标是让我们建立起：</p>
<ul>
<li>the way grammar is used in communicative settings</li>
<li>the kins of errors that are commonly made in academic language, and why those errors are made</li>
<li>useful monitoring strategies that allow you to address your own errors</li>
</ul>
<p>具体的上课方式是：</p>
<ul>
<li>learning about the role that grammar plays in language use</li>
<li>identifying, interpreting and correcting grammar errors in written material and from video tapes</li>
<li>monitoring peers and ourselves for grammar errors in discussion</li>
<li>developing strategies to control grammar errors while speaking</li>
</ul>
<p>这个系列课程一共有六次，主题分别是：</p>
<ol>
<li>Challenging your grammar assumptions</li>
<li>The nature of grammar and grammar errors</li>
<li>Patterns of language and the importance of context</li>
<li>Building a greater understanding of grammar usage</li>
<li>What are your own grammar needs</li>
<li>Integration of theory and practice</li>
</ol>
<h2 id="u8BFE_u7A0B_u5185_u5BB9"><a href="#u8BFE_u7A0B_u5185_u5BB9" class="headerlink" title="课程内容"></a>课程内容</h2><p>八十分钟的课上除了小组讨论之外，还是有很多有意思的内容的，这里挑选三个核心问题来进行说明</p>
<h3 id="u8BED_u6CD5_u9519_u8BEF_u662F_u600E_u4E48_u6765_u7684"><a href="#u8BED_u6CD5_u9519_u8BEF_u662F_u600E_u4E48_u6765_u7684" class="headerlink" title="语法错误是怎么来的"></a>语法错误是怎么来的</h3><p>对于母语不是英语的人来说，表达自己的时候通常需要『并行思考』，一面要组织表达的逻辑与句子结构，一面需要选择正确的词语以及合适的语法，正是『鱼与熊掌不可得兼』。用老师的话来说，这属于 “too much cognitive load”，我们没办法在短时间内完美处理好 vocabulary, pronounciation, grammar, intent 这四个项目。</p>
<p>另外一个导致语法错误的原因，是母语本身和英语的差异，比方在中文里时态很多时候是隐含的（或者我们本能理解的），但是对应到英文中，各种不同类型的时态，就很容易选择错误（跟我们一开始学习英语时的习惯有关）。而且在日常的交流中，毕竟主要目的是互相弄懂意思，别人也不会特地去纠正我们的语法错误，也就意味着我们即使很多时候不知道自己说错了。</p>
<p>按照老师的说法，我们在描述复杂概念和想法的时候，说的其实是介于母语与第二语言的 interlanguage，想要跨越这个鸿沟并不简单，需要抛弃从前的习惯，转为养成新的习惯（当然这也不是上几次课就可以解决的，需要『刻意练习』）。不过也有好消息，至少我们可以通过训练，在跨域鸿沟之前也能把话说清楚。</p>
<h3 id="u8BED_u6CD5_u5230_u5E95_u662F_u4EC0_u4E48"><a href="#u8BED_u6CD5_u5230_u5E95_u662F_u4EC0_u4E48" class="headerlink" title="语法到底是什么"></a>语法到底是什么</h3><p>这部分就以判断对错的形式来进行说明（虽然想都不用想肯定都是错的叙述）</p>
<blockquote>
<p>True or false? Grammar is a set of rules, which are defined by experts in grammar books.</p>
</blockquote>
<p>当然是不对的，首先语法不是 rule，而是 guideline(agreement)，并且也不可能有所谓的一群『专家』来决定大家要怎么说话。从概念上来说，作为一种约定俗成的方式，其实不能被定义，只能被描述</p>
<blockquote>
<p>True or false? Most errors in grammar are caused by interference from the first language, so the best way to prevent these errors is for the teacher to contrast the two languages.</p>
</blockquote>
<p>前半句是对的，但是后半句就不对了。首先语言之间的对比是很难的，即使花了大力气对比成功了，似乎也没什么用。作为男生，我了解男生和女生的不同，但这并不意味着我就了解女生。</p>
<blockquote>
<p>True or false? Grammar is a problem for non-native speakers of a language because they are lazy and they didn’t study the rules hard enough.</p>
</blockquote>
<p>也是错的。我觉得问题有二：一是思维过载（前面提过），二是很多时候我们都不知道自己在犯错（所以需要帮助我们建立起意识到自己犯错的能力）</p>
<blockquote>
<p>True or false? Grammar errors always interfere with meaning.</p>
</blockquote>
<p>以偏概全。对于比较简单的描述，哪怕只是蹦几个词出来，对方应该都能够明白意思。但是对于更加细腻的感情和复杂的思维来说，语法错误可能就会导致大问题。</p>
<blockquote>
<p>True or false? In grammar, it is the rules that are most important for correct usage; context and the intent of the speaker are not important.</p>
</blockquote>
<p>这个问题引出了这门课最重要的一个观念：</p>
<p>Context + Intent = Grammar</p>
<p>语法应当是为我们服务的，而不是反过来，重要的是上下文和我们要表达的意思</p>
<blockquote>
<p>True or false? A grammar error occurs when a speaker breaks a rule.</p>
</blockquote>
<p>这里需要注意一个概念到底是 Grammar as Fact 还是 Grammar as Choice 呢？</p>
<p>目前我也没有特别好的答案（或者说知道是 Grammar as Choice 但是没有办法把背后的问题搞清楚）</p>
<p>所谓语法的规则，在初学者阶段需要强制培养出某种刻板的语感，但是到后来就不能拘泥于此了。</p>
<h3 id="u8868_u8FBE_u80FD_u529B_u516C_u5F0F"><a href="#u8868_u8FBE_u80FD_u529B_u516C_u5F0F" class="headerlink" title="表达能力公式"></a>表达能力公式</h3><p>这个其实是我自己想出来的一个公式：</p>
<p>表达能力 = 结构 + 词汇 + 语法 + 思维</p>
<p>暂时先卖个关子，不详细解释，来看下面的例子</p>
<blockquote>
<p>Discuss an interesting event that happened this semester</p>
</blockquote>
<p>需要注意以下三点：</p>
<ol>
<li>Tense: past tense</li>
<li>Finish the sentence</li>
<li>Awkward phrases</li>
</ol>
<p>老师随后举了一个例子，她是这么描述『昨天』的一件事的：</p>
<blockquote>
<p>Yesterday afteroon, I was on a bus. I was reading a book. Then a man punches me in the head!</p>
</blockquote>
<p>这里为什么最后用了现在时而不是继续过去时呢？老师的解释是这样的：动词的时态，其实不单单只是用来表达时间，更可以表示距离。如果我这里的 punch 也用过去时，给人的感觉就是现在已经没什么事儿了，但是如果我要表达即使到现在也非常不爽的感情，就要用动词来明确表示出这种感觉，也就是用现在时。</p>
<hr>
<p>总体来说这个系列课程参与的人数更多，同学也更踊跃，整体氛围更好，希望能多学到一点东西。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在上的另一门课程叫做 Advanced Grammar Monitoring。主要是针对英语不是母语的人群，帮助我们了解为什么会出现各类语法错误，以及如何改正它们。</p>]]>
    
    </summary>
    
      <category term="口语" scheme="http://wdxtub.com/tags/%E5%8F%A3%E8%AF%AD/"/>
    
      <category term="英语" scheme="http://wdxtub.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="语法" scheme="http://wdxtub.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 反思课 3 提高 Web 服务性能的策略与思考]]></title>
    <link href="http://wdxtub.com/2016/03/15/cc-rethink-3/"/>
    <id>http://wdxtub.com/2016/03/15/cc-rethink-3/</id>
    <published>2016-03-15T12:17:53.000Z</published>
    <updated>2016-03-15T13:37:57.000Z</updated>
    <content type="html"><![CDATA[<p>学习是一个不断改进方法论的过程，<a href="http://wdxtub.com/2016/03/11/cc-p6/">课程项目 6 MySQL 和 HBase 配置及测试</a>，因为自己对于搭建基于 NoSQL 数据库的 Web 服务缺乏足够的经验，在具体对前后端进行优化的时候走了很多弯路，也意识到了没有目的的优化很可能是劣化，这里主要整理一下自己对于优化问题的思考。</p>
<a id="more"></a>
<hr>
<h2 id="u5E94_u7528_u573A_u666F"><a href="#u5E94_u7528_u573A_u666F" class="headerlink" title="应用场景"></a>应用场景</h2><p>因为涉及到具体的问题，所以先大概说明一下应用场景，方便之后的叙述。事情大概是这样的：</p>
<ul>
<li>数据是 5100W 条左右带 tag 的 tweet</li>
<li>这些 tweet 有各种语言</li>
<li>只有读请求，每次需要返回指定用户用指定 tag 发送的 tweet</li>
<li>前端使用 Undertow，后端是部署在 Amazon EMR 的 HBase</li>
<li>有一定的预算限制（不能开多台机器来凑）</li>
</ul>
<p>难点在于，优化问题其实是一个涉及多层级多组件的『复杂』问题，需要考虑的东西很多，更纠结的是，整个系统是符合『木桶理论』的，也就是最短板决定了系统的整体性能。那么就牵扯出两个关键问题：短板在哪里？短板怎么解决。</p>
<h2 id="u4E00_u4E9B_u601D_u8003"><a href="#u4E00_u4E9B_u601D_u8003" class="headerlink" title="一些思考"></a>一些思考</h2><p>对于 Web 服务来说，所谓优化，可以简单粗暴分为两个子类，一是增加吞吐量，二是增加并发数。优化的整体思路，按照实施的顺序来看，大概是这样的：</p>
<ol>
<li>充分理解应用场景<ul>
<li>服务具体接收的请求的格式和具体需要返回的内容是什么</li>
<li>是偏向于读，还是偏向于写，亦或者是读写比较均衡</li>
<li>数据量大概是多少，分布式集群（如果要用）的基本配置是什么</li>
</ul>
</li>
<li>数据格式设计<ul>
<li>根据具体的场景，需要思考具体数据库的设计</li>
<li>如果是读比较多，可以考虑对数据进行预处理，用空间换时间</li>
<li>如果是写比较多，则需要尽可能减少冗余，减少改动时需要同步更新的记录</li>
</ul>
</li>
<li>分析服务瓶颈（慢在哪里）<ul>
<li>使用什么工具，监控什么指标来寻找瓶颈</li>
<li>根据输出的日志（这里需要自己决定输出什么）来找寻请求的规律</li>
<li>根据日志的数据统计，找到短板所在</li>
<li>这一步其实并不简单，更可怕的是，如果在这里分析错误，就会把整个优化带入死胡同（去优化并不需要优化的问题）</li>
</ul>
</li>
<li>充分利用硬件资源<ul>
<li>在预算限制下有没有开够机器</li>
<li>对于每台机器，其 CPU，内存，带宽等资源有没有尽可能使用</li>
<li>如果没有尽量利用，就说明钱没有花在刀刃上，可以考虑更换不同类型的机器，Amazon 提供了『通用』，『内存优化』和『计算优化』这几种不同的机器，可以根据监控的数据，根据前后端不同的任务来决定具体使用什么类型的机器</li>
</ul>
</li>
<li>解决木桶效应，不同层优化<ul>
<li>算法 + 数据结构优化</li>
<li>事务处理逻辑优化，尽可能减少单次请求需要的资源（包括计算、内存和带宽资源）</li>
<li>硬件优化，vertical scaling 或者 horizontal scaling</li>
<li>分布式结构优化，采用 ELB 或 Hadoop</li>
</ul>
</li>
</ol>
<h2 id="u4E00_u4E9B_u7B56_u7565"><a href="#u4E00_u4E9B_u7B56_u7565" class="headerlink" title="一些策略"></a>一些策略</h2><p>前面从总体的思路切入，这里因为涉及到具体的指标要求，所以会从细节方面切入。</p>
<p>首先要意识到从我们在浏览器中输入网址，到最后看到显示的内容之间发生了什么。因为这里不是网络分析课（Amazon 的网络我们能调优的范围也有限），所以 DNS 路由之类的内容这里不提，具体可以参考<a href="http://wdxtub.com/2016/02/10/internet-protocol/">计算机网络</a>一文。</p>
<p>那么到底中间的过程是什么呢？其实就 3 步：</p>
<ol>
<li>页面模板根据实际内容渲染成网页。这部分我们不需要考虑，并没有用任何渲染引擎，就是单纯返回一段数据而已</li>
<li>业务逻辑部分。显示内容之前做的预处理，对应配套的缓存，连接池等等内容。这部分理论上是需要考虑的，但是在具体的测试中，影响不算特别大（和后面相比）</li>
<li>数据库与网络传输部分。这部分是主要的瓶颈所在，接下来会细说。</li>
</ol>
<p>网络部分优化，其实是比较简单粗暴的，因为是只读操作，所以不需要考虑一致性问题，努力增加并发数即可，另一个角度则是减少每次传输所需要的带宽，综合来看，有下面的策略：</p>
<ul>
<li>使用 ELB 增加多台前端，多台机器并发请求</li>
<li>每台机器增加线程数（当然要在内存的允许范围内），但是加到一定程度也就足够了（毕竟带宽是有限的）</li>
<li>在后端对数据进行压缩，在前端进行解压缩，这样就减少了需要网络传输的数据</li>
</ul>
<p>（这部分策略我还没有具体尝试，因为用下面的方法已经满足要求了）</p>
<p>后台数据库和前台缓存实际上类似于 Memory Hierarchy，需要利用看似不大存在的 Locality 来获得最快的访问速度（经过测试如果缓存命中基本上可以认为是无延迟）。这里的 Locality，可以认为是具体流量模式的 Locality，而并非是在数据库中顺序访问。</p>
<p>有缓存，那么肯定就有预热，预热的重要性在于，把常用的记录缓存下来，具体缓存要多大呢？我也不知道，反正可能情况下，越大是越好的（这就是为啥最好开一个内存优化的机器，比其他系列多一倍内存）</p>
<p>最后说一下数据库的参数优化，不知道是不是 Amazon EMR 本身根据不同的配置会进行一定的优化，我并没有改动 HBase 的任何设置。这里的问题在于，因为刚接触 HBase，很多内容不熟悉，所以看着网上的教程瞎折腾很容易弄巧成拙，在优化的时候，一定要确定每一步都清楚自己在干嘛，不然就会出现自己以为正确的错误，而这种错误往往是最难解决的（因为自己压根不知道错了）</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>总体来说，这次的任务还是很有趣的，我也已经意识到了优化真心是一个牵一发动全身的问题，还是要有更加清晰的大局观和思路，才不至于迷失方向。不过话说回来，遇到不懂的问题，最好的方法是停下来，把相关的概念都捋一遍（比方说官方文档就不错），思考具体的问题所在，大胆假设小心验证，才更能找到令自己满意的答案。</p>
<p>另外，对于分析 web 服务的各类工具一头雾水（甚至都不知道有啥），还是得抽空研究一下，不然依靠手动输出计算时间效率太低，得到的数据可能也不准确。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>学习是一个不断改进方法论的过程，<a href="http://wdxtub.com/2016/03/11/cc-p6/">课程项目 6 MySQL 和 HBase 配置及测试</a>，因为自己对于搭建基于 NoSQL 数据库的 Web 服务缺乏足够的经验，在具体对前后端进行优化的时候走了很多弯路，也意识到了没有目的的优化很可能是劣化，这里主要整理一下自己对于优化问题的思考。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="优化" scheme="http://wdxtub.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Presentation Basics 1 理解美国式演讲风格]]></title>
    <link href="http://wdxtub.com/2016/03/14/presentation-basics-1/"/>
    <id>http://wdxtub.com/2016/03/14/presentation-basics-1/</id>
    <published>2016-03-14T23:15:12.000Z</published>
    <updated>2016-03-15T01:13:46.000Z</updated>
    <content type="html"><![CDATA[<p>最近开始上一门名为 Presentation Basics 课程，其目标是: Helping nonnative English speakers build the fluency to give successful presentations。虽然风格是比较美式的，但是对于我们平日里沟通和写作都有一定的指导意义。</p>
<a id="more"></a>
<hr>
<h2 id="u8BFE_u7A0B_u603B_u89C8"><a href="#u8BFE_u7A0B_u603B_u89C8" class="headerlink" title="课程总览"></a>课程总览</h2><p>这门课主要是为我们这种外国留学生（英语不是母语）而准备的，会教给我们基本的做展示的技术已经帮助我们在展示中更流畅地表达自己。因为是小班教学（九个人），所以会有充足的展示和反馈的机会。在整个课程中，每个人都需要做 4 次 mini-talk 和 1 次 presentation。课程结束后，我们应该能做到：</p>
<ul>
<li>Becoming more aware of your own speaking strengths and weaknesses and developing a plan for improving your speaking skills</li>
<li>Recognizing the importance of understanding an audience and how to engage that audience</li>
<li>Using organizational language to help guide your audience and emphasize key information</li>
<li>Using non-verbal cues to help convey information successfully</li>
<li>Becoming more comfortable in the role of presenter</li>
</ul>
<p>当站在台前，被大家注视的时候，感觉害羞尴尬不自在都是非常正常的表现，我们需要做的是慢慢去习惯适应，即所谓 comfortable with uncomfortable。</p>
<p>简单来说，一周两节课，第一节课会学习相关技巧，第二节课用来练习和展示，具体的上课方法是：</p>
<ul>
<li>Watching videotaped presentations that can serve as models of strong presenting in the US academic style</li>
<li>Identifying the way key content information is conveyed in presentations</li>
<li>Focusing on the way information is organized so that it is clear for listeners</li>
<li>Practicing presentation techniques through in-class activities and in a prepared presentation</li>
<li>Meeting individually with the instructor for detailed feedback on your videotaped presentation</li>
</ul>
<p>其实从中我们可以总结出交流沟通的几个重要技巧：首先是确定重要信息是什么，然后思考如何去组织这些信息，让受众更容易理解，之后就是通过不断练习来磨练自己的技艺。</p>
<h2 id="u8BFE_u7A0B_u5B89_u6392_u4E0E_u53C2_u8003_u8D44_u6599"><a href="#u8BFE_u7A0B_u5B89_u6392_u4E0E_u53C2_u8003_u8D44_u6599" class="headerlink" title="课程安排与参考资料"></a>课程安排与参考资料</h2><p>下面是具体八次课的安排以及每节课的目标</p>
<ol>
<li>Understanding the US discourse style<ul>
<li>To recognize your audience’s expectations and how to communicate effectively with your audience</li>
</ul>
</li>
<li>First mini-talk: Define a problem and its solution<ul>
<li>To identify the parts of a problem-solution presentation and to practice this organization in a mini-talk</li>
</ul>
</li>
<li>Linking &amp; organizing language<ul>
<li>To practice using linking and organizing language to help structure your presentations</li>
</ul>
</li>
<li>Second mini-talk: Describing a process<ul>
<li>To apply what you know about organization strategies and linking language to clearly explain a process </li>
</ul>
</li>
<li>Attention-getting openers<ul>
<li>To identify qualities of successful introductions and to practice using them</li>
</ul>
</li>
<li>Third mini-talk: Defining a concept<ul>
<li>To identify qualities of clear definitions and to practice defining a term from your field</li>
</ul>
</li>
<li>Pronunciation and presenting<ul>
<li>To understand the importance of stress and intonation to give clarity to your presentations</li>
</ul>
</li>
<li>Videotaped presentations<ul>
<li>To synthesize skills learned in this class to present a concept from your field</li>
</ul>
</li>
</ol>
<p>参考资料</p>
<ul>
<li>Alley, <the craft="" of="" scientific="" presentations=""></the></li>
<li>Reinhart, <giving academic="" presentations=""></giving></li>
<li>Smith, <communicate: strategies="" fro="" international="" teaching="" assistants=""></communicate:></li>
<li>Sterns, Breaking the Accent Barrier(Video)</li>
<li>Winston, How to Speak(<a href="https://vimeo.com/101543862" target="_blank" rel="external">Video</a>)</li>
</ul>
<h2 id="u4E0A_u8BFE_u5185_u5BB9_u53CA_u611F_u60F3"><a href="#u4E0A_u8BFE_u5185_u5BB9_u53CA_u611F_u60F3" class="headerlink" title="上课内容及感想"></a>上课内容及感想</h2><p>具体的上课内容是大家一起看 <a href="https://vimeo.com/101543862" target="_blank" rel="external">How to Speak</a> 这个视频，然后讨论其使用的各种技巧，具体的内容我在 <a href="http://wdxtub.com/2016/02/22/how-to-speak/">How to Speak 日志</a> 中已经有总结，这里不再赘述，主要记录一下我上课时的感想。</p>
<ul>
<li>展示开头直接开门见山，告诉听众可以期待什么，并且列举出接下来要说的要点，有清晰的组织结构</li>
<li>为了解释复杂的问题和概念，尽量使用比喻，来帮助人们建立起基本的认知</li>
<li>如果想要听众印象深刻，可以考虑使用排比句，精炼展示的内容</li>
<li>很多时候我们不欠缺日常生活共同以及专业学术讨论的能力，但是给非本领域的人介绍相关内容时，往往容易出问题，这是我们需要着重去准备的</li>
<li>从纯技术领域开始，进行简化，最后应用 KISS(Keep It Simple &amp; Stupid) 原则</li>
<li>这里的 Stupid 很有意思，不是蠢，而是指 hard to break，例如没有任何机械部分的东西就比有机械部分的东西 stupid，从这个角度来说，静态网站比动态网站 stupid，所以我用静态网站生成器做博客，也算是 stay stupid</li>
<li>除了总体的结构，还需要注意每个段落之间每句话的结构和联系，总而言之，就是通通都是逻辑，不要拐弯抹角，不要随意用『显然』跳过推理过程</li>
</ul>
<p>第一节课的内容就这么多，我们下次再见。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近开始上一门名为 Presentation Basics 课程，其目标是: Helping nonnative English speakers build the fluency to give successful presentations。虽然风格是比较美式的，但是对于我们平日里沟通和写作都有一定的指导意义。</p>]]>
    
    </summary>
    
      <category term="展示" scheme="http://wdxtub.com/tags/%E5%B1%95%E7%A4%BA/"/>
    
      <category term="英语" scheme="http://wdxtub.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第九周 - 怕黑]]></title>
    <link href="http://wdxtub.com/2016/03/11/dark-fear/"/>
    <id>http://wdxtub.com/2016/03/11/dark-fear/</id>
    <published>2016-03-12T01:36:00.000Z</published>
    <updated>2016-03-12T03:18:57.000Z</updated>
    <content type="html"><![CDATA[<p>如果我说我忍住眼泪，如果我说我不会后悔，如果我说我忍住伤悲。因为我会怕黑，因为我厌倦雨打风吹，因为我隐藏我的眼泪。</p>
<a id="more"></a>
<hr>
<p>不知道什么时候开始怕黑，也不知道自己为什么怕黑。但是有句话这么说：Know God, No Fear; No God, Know Fear，想来我就是 No God 的那类人。看不一样的书，想不一样的理，做不一样的事，走不一样的路，自然就少了很多『牵绊』。</p>
<blockquote>
<p>It is no nation that we inhabit, but a language. by Emil Cioran</p>
</blockquote>
<p>倒是可以用这个句式来表达自己的心意：It is no goal that I pursue, but an experiment.</p>
<p>解释一下，对于目标来说，去追逐，意味着很多事情是冲着成功去做；而对于试验来说，更多是期待失败而去做。以目标的心态去做事情，成功开心，失败不开心；以试验的心态去做事情，无论成功还是失败，都算是验证了想法，都是下一次做得更好的基石。</p>
<p>这样去想，往往能放下很多没太多必要的『包袱』，轻装上阵反而更容易超水平发挥。很多人在真正达成目标的时候并没有想象中快乐，因为所谓的『快乐』本身就是虚幻的，即所谓 Phantom Happiness，不到最后，都没办法戳破自己吹的泡泡。不过话说回来，至少也达成了目标，也不是一件坏事儿。</p>
<p>Phantom Happiness 对应的恐怕就是 Phantom Pain 了，也就是 Metal Gear SOLID V 的标题。这要写起来就刹不住车了，还是留到专门的游戏评测里慢慢写个痛快，不过这里提三本相关的，严肃且黑暗的小说，看完这三本应该就对 Phantom Pain 有更深的了解，它们是《白鲸记》《一九八四》和《蝇王》。从无意义复仇，讲到极权统治双重思想，最后到个人意志与集体意志的冲突与湮灭，都是 MGS 这整个系列贯穿讨论的深刻哲学社会学问题。</p>
<p>前两天换了个莫(sha)西(ma)干(te)发型，开始了系统的运动健身计划，希望能以最好的精神面貌回国，现在真是数着日子过日子了。</p>
<blockquote>
<p>Two roads diverged in a wood, and I took the one less traveled by, And that has made all the difference.</p>
</blockquote>
<p>不要把心围上层层堡垒，不要让疲倦的心再枯萎，请不要让这一切变成不对。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果我说我忍住眼泪，如果我说我不会后悔，如果我说我忍住伤悲。因为我会怕黑，因为我厌倦雨打风吹，因为我隐藏我的眼泪。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="静静" scheme="http://wdxtub.com/tags/%E9%9D%99%E9%9D%99/"/>
    
      <category term="黑暗" scheme="http://wdxtub.com/tags/%E9%BB%91%E6%9A%97/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【潜龙谍影系列】故事、剧情与历史]]></title>
    <link href="http://wdxtub.com/2016/03/10/mgs/"/>
    <id>http://wdxtub.com/2016/03/10/mgs/</id>
    <published>2016-03-10T14:07:09.000Z</published>
    <updated>2016-03-10T19:49:33.000Z</updated>
    <content type="html"><![CDATA[<p>如果说这个世界上有第二个系列像 EVA 一样让我如痴如醉的话，那么肯定是 MGS 系列。在玩『潜龙谍影5：幻痛』的时候，每一段磁带（包含大量重要剧情信息）都认真听过之后，对于整个系列的剧情有了大概的认知。这篇文章会比较长，综合了网上的各种资料和我自己的理解，希望能给大家带来一个比较完整的阅读体验。</p>
<a id="more"></a>
<hr>
<p>Here’s to you Nicolas and Bart 尼古拉和巴特，这是献给你们的赞歌</p>
<p>Rest forever here in our hearts 你们将永远被铭记在心</p>
<p>The last and final moment is yours 最终的胜利属于你们</p>
<p>That agony is your triumph 那份痛苦和折磨就是你们的见证</p>
<p>Petals of white 片片白花</p>
<p>Cover fields flowing in grieving tears 漫散在这个被泪水淹没的地方</p>
<p>And all the hearts once new, old and shattered now 一颗颗曾年轻的心，如今也都已苍老破碎</p>
<p>Love can kill,love will die 爱能伤人，爱也会死</p>
<p>Give me wings to fly 给我翅膀去飞吧</p>
<p>Fleeing this world so cold 飞离这个冰冷的世界</p>
<p>I just wonder why 我只是不能理解这一切</p>
<p>Cold as the dark 寒冷如夜</p>
<p>Now my words, are frosted with every breath 话语已随气息而凝结</p>
<p>Still the hate burns wild, growing inside this heart 但那仇恨却越燃越盛，深深扎根于这颗心</p>
<p>When the wind changes course when the star align 若一切物是人非，沧海桑田</p>
<p>I will reach out to you and leave this all behind 我就会破除万难并回到你的身边</p>
<p>When heavens divide 当天堂破碎的时候……</p>
<p>I will see the choices within my hands 我才明了我选择的路</p>
<p>How can we ever protect and fight with our tiny souls 我们渺小的灵魂要怎样去抗争，去奋斗？</p>
<p>Let me shine like the sun through the doubts of fear 让我闪耀，像太阳一样，穿透那些恐惧的阴云</p>
<p>Do you feel the storm approach as the end draws near 而你又是否会感受到这场终结的风暴即将来临</p>
<p>When heavens divide当天堂破碎的时候</p>
<p>Time will come to softly lay me down 时间将会悄悄为我送葬</p>
<p>Then I can see a face that I long to see 这样我才能看到那个，我期盼已久的脸庞</p>
<p>And for you, only you I would give anything 为了你，只为了你，我愿意付出一切</p>
<p>Leaving a trace for love to find a way 筑出一条血路，去追寻你的足迹</p>
<p>When heavens divide当天堂破碎的时候</p>
<p>I will dive into the fire 我会为你赴汤蹈火</p>
<p>Spilling the blood of my desire 撒尽我的每一滴热血</p>
<p>The very last time 在最后的最后</p>
<p>My name scorched into the sky 我的名字将会刻入天际</p>
<h2 id="u5386_u53F2_u80CC_u666F"><a href="#u5386_u53F2_u80CC_u666F" class="headerlink" title="历史背景"></a>历史背景</h2><h3 id="1960__u5E74_u4E4B_u524D"><a href="#1960__u5E74_u4E4B_u524D" class="headerlink" title="1960 年之前"></a>1960 年之前</h3><p>1918 年同盟国（德国、奥匈、土耳其、保加利亚）和协约国（英国、法国、俄国、意大利）进行的世界大战，简称一战，约有6500万人参战，1000万人丧生，2000万人受伤。1918年，这场战争以协约国的胜利告终。</p>
<p>同年，弗拉基米尔·列宁在俄国建立了秘密情报机构格勒乌（GRU）。</p>
<p><img src="/images/14576194971120.jpg" alt=""></p>
<p>一战之后，美国、苏联、中国三大国最富有、最有权力的人——他们被称为智者议会（ Wisemen’s Committee），建立了秘密组织：哲学家（ThePhilosophers）。这些人拥有广泛的社会触角和近乎无限的资源，哲学家组织希望借助他们庞大的资源影响世界局势，让类似一战的大规模全球冲突不再重演。在成立后，哲学家的势力迅速增长，很快成为他们各自的国家政府背后的绝对权力。</p>
<p><strong>引领者出生 1922 年</strong></p>
<p><img src="/images/14576196418920.jpg" alt="引领者，又称 The Boss"></p>
<p>哲学家组织高级成员，智者议会成员的女儿引领者（TheBoss）出生。这个女子会成为美国乃至世界历史中的一位幕后的关键人物。</p>
<p><strong>第二次世界大战开始 1939 年</strong></p>
<p>1939年9月1日，德国集中强大兵力，对波兰发动“闪电战”，第二次世界大战全面爆发。</p>
<p>在二战期间，哲学家的成员收集了大量资源、金钱，总金额超过1000亿美元（大概相当于今天的1万6000亿美元左右）,意在发展新型战争手段：如核武器、眼镜蛇部队等，以终结战争。这笔巨额资产被称为“哲学家的遗产”（the Philosophers’ Legacy），而各国的哲学家组织则达成协议，在击败轴心国后，把这笔巨款返还各国。唯一取得这笔巨款的方式是一套微型胶片——胶片里储存着这些资金在各个银行的交易记录。然而，二战结束后，哲学家的遗产——即微型胶卷却被负责为哲学家洗钱的苏联军官鲍里斯·沃尔金（Boris Volgin）窃取。</p>
<p><img src="/images/14576198651470.jpg" alt="第二次世界大战"></p>
<p><strong>卡廷惨案</strong></p>
<p>第二次世界大战期间苏联秘密警察机关在苏共中央的批准下，于1940年4月至5月间对被俘的波兰战俘、知识分子、警察及其他公务员进行的大屠杀,共杀死2.2万人。因为4421人在卡廷森林被处决，故名卡廷事件。</p>
<p>窃取哲学家遗产的鲍里斯·沃尔金的儿子，时任苏联内务部内卫部队军官的叶夫根尼·鲍里索维奇·沃尔金（Yevgeny Borisovitch Volgin）上校参与了这场惨案。他的惯用手法是，将囚徒的眼罩掀开，再殴打致死。沃尔金还参与过1953年的东德反乱镇压和1956年的匈牙利动乱镇压，其本人曾不无得意地表示，他“处理”过超过10万人。</p>
<p>鲍里斯·沃尔金去世后，哲学家的遗产被其子叶夫根尼·鲍里索维奇·沃尔金继承。</p>
<p><img src="/images/14576200196071.jpg" alt="卡廷惨案"></p>
<p><strong>曼哈顿计划启动·眼镜蛇部队成军 1942 年</strong></p>
<p>二战期间，引领者创建了秘密特殊部队眼镜蛇部队。这支部队集合了联合国军最优秀的士兵，并由引领者亲自编成和训练。眼镜蛇部队所负责的任务一般绝对保密，在死前，该部队成员会用身上装备的小型炸弹进行自爆，以避免泄露秘密。在部队中，代号为苦痛者（The Pain）、恐惧者（The Fear）、末日者（The End）、狂怒者（The Fury）、悲哀者（The Sorrow）几位成员对引领者怀有特殊的情感，后来再次集结到她的身边。引领者本人则代号“欢乐”（The Joy），意为在战场上寻找到无上的欢乐。</p>
<p>同年，开发原子弹的工程曼哈顿计划在美国启动。</p>
<p><img src="/images/14576201575441.jpg" alt="曼哈顿计划"></p>
<p><strong>盟军进行诺曼底登陆行动 1944 年</strong></p>
<p>20世纪最大的登陆战役，盟军调集288万部队，横渡英吉利海峡，让英美军队重返欧洲战场。</p>
<p>由于眼镜蛇部队破坏了德军的V2导弹，在诺曼底登陆中发生了重要作用。引领者和悲哀者者的孩子山猫（Ocelot）在也在这场登陆战役中诞生，并在引领者的腹部留下一道蛇形的疤痕。</p>
<p><img src="/images/14576202257805.jpg" alt="诺曼底登陆"></p>
<p><strong>三一弹试爆，日本遭受原子弹轰炸&amp;修依·艾默里出生 1945 年</strong></p>
<p>第一颗原子弹——三一弹在美国试爆成功。同年，美国在日本投下两颗原子弹——小男孩、胖子。</p>
<p>同年，修依·艾默里克出生。他的父亲参与过曼哈顿计划，他则出生就双腿残疾。后来，他成为一名双足步行兵器的开发者。</p>
<p><strong>CIA成立·眼镜蛇部队解散 1947 年</strong></p>
<p>美国中央情报局（CIA）成立。同年，在二战中功勋卓著的部队“眼镜蛇”，在哲学家组织因为争夺哲学家遗产导致的紧张分裂态势下解散。</p>
<p><strong>朝鲜战争爆发·引领者与大首领相遇 1950 年</strong></p>
<p>1950年6月25日，朝鲜进攻韩国，朝鲜战争爆发。以美国为首的联合国军在当年9月15日从仁川登陆，帮助韩国进行反攻。10月25日，中国人民志愿军赴朝，与朝鲜并肩作战。</p>
<p>一个15岁的少年约翰（John）参与了朝鲜战争，而他将成为美国历史上最优秀的战士：大首领（Big Boss）。同样在这一年，约翰结识了传奇英雄引领者，并向引领者学习战斗、谍报、生存等多种技能超过10年以上，二人的关系和羁绊已经超越简单的师徒。二人一起创立了CQC近身格斗术。</p>
<p><strong>美国进行内华达州核爆实验·引领者暴露于大量核辐射 1951 年</strong></p>
<p>1950年，美国总统杜鲁门签署命令，宣布在内华达州的内利斯空军靶场建立内华达国家安全区。</p>
<p>1951年1月27日，内华达国家安全区在弗伦奇曼平底进行了第一次核试验，爆炸当量相当于1000吨TNT。</p>
<p>1951年11月1日，引领者参与内华达州核爆实验，暴露在大量核辐射下，失去了生育的能力。</p>
<p><img src="/images/14576205637151.jpg" alt="内华达州核爆实验"></p>
<p><strong>美国试爆第一枚氢弹·大首领暴露于大量辐射 1954 年</strong></p>
<p>美国在比基尼环礁上试爆了第一枚氢弹。约翰，即后来的大首领也被牵扯其中。他当时的朋友都因核辐射染上白血病、甲状腺癌等致命疾病，或直接死于辐射，但大首领并没有染上这类病症。尽管如此，大首领还是和他的导师引领者一样，在核辐射下失去了自然生殖的能力。</p>
<p><img src="/images/14576205854028.jpg" alt="试爆第一枚氢弹"></p>
<h3 id="1961__u5E74_-_1970__u5E74"><a href="#1961__u5E74_-_1970__u5E74" class="headerlink" title="1961 年 - 1970 年"></a>1961 年 - 1970 年</h3><p><strong>美政府实行“水星计划”·奇爱博士结识引领者 1961 年</strong></p>
<p>美国在1959年开始载人航天计划“水星计划”。尽管官方历史记载美国航天第一任是1961年5月5日进入太空的艾伦·B·谢泼德，但事实上，第一位进入太空的美国人是引领者，她在“水星计划”中扮演了重要角色，并在1961年4月进入太空，1961年4月12日返回地球。再入大气层时，引领者被宇宙辐射和再入大气层产生的热量严重灼伤，进入了长达6个月的严重昏迷。在太空俯瞰地球的震撼景象，让引领者深信世界应该团结一心，而非分阵营对立。</p>
<p>在水星计划中，引领者结识了水星计划科研人员奇爱博士，奇爱博士对引领者产生了深深的感情。</p>
<p><strong>古巴导弹危机 1962 年</strong></p>
<p>1962年，苏联在古巴秘密部署导弹，并被美国发现。肯尼迪总统大为震怒，宣布封锁古巴，要求苏联撤回已经部署的导弹设施。1962年，10月24日，美国出动90艘军舰，封锁了古巴海峡，所有导弹部队均处于高度戒备状态，全球性的核战争一触即发。最终，赫鲁晓夫同意撤回部署在古巴的导弹设施。</p>
<p>而事实上，赫鲁晓夫同意妥协的不为人知的重要原因，在于肯尼迪同意将逃往至美国的武器开发专家斯特潘诺维奇·索科洛夫遣返至苏联。被遣返回苏联后，这位武器专家被直接送到秘密设计局OKB-754。</p>
<p><img src="/images/14576208423544.jpg" alt="古巴导弹危机"></p>
<p><strong>肯尼迪遇刺身亡·小岛秀夫出生1963</strong></p>
<p>美国总统肯尼迪遇刺，其原因在于哲学家组织不满肯尼迪在猪湾事件中的表现，将其刺杀。</p>
<p>同年，日本人小岛秀夫出生。有传言他与哲学家、引领者、大首领均有神秘的关系，有人甚至认为这个出生晚于哲学家建立的日本人其实是一切的幕后黑手。实际联系至今亦不明朗，尚需进一步调查确认。（这个中二程度不轻啊）</p>
<p><img src="/images/14576209221127.jpg" alt="肯尼迪遇刺身亡"></p>
<p><strong>贞洁行动失败 1964 年 8 月 24 日</strong></p>
<p>美国政府则派出FOX部队——零少校（Major Zero）和引领者建立的CIA秘密行动小组，希望将遣返回美国的武器专家斯特潘诺维奇·索科洛夫再次营救回美国，这次任务的代号即为“贞洁行动”（Virtuous Mission）。约翰（John）,任务代号裸蛇（Naked Snake），FOX部队的第一个探员，被派往苏联丛林带回索科洛夫。</p>
<p>任务进行到一半，原本应是任务支援的引领者却向苏联变节，阻止了整个行动。引领者集结了眼镜蛇部队的一帮原成员，伙同苏联军官，哲学家遗产的拥有者沃尔金，将裸蛇打下吊桥，带走了索科洛夫。引领者将一枚微型核弹头作为见面礼送给了沃尔金，沃尔金则在苏联领土用这枚核弹打击了秘密设计局OKB-754。这枚美国核弹在苏联的引爆，导致美国的非法入侵被苏联指责，核大战危机再次一触即发。当然，贞洁行动也以失败告终。</p>
<p>在贞洁行动中，裸蛇完成了历史首次HALO降落——从高空跳下，并在低空打开降落伞。</p>
<p><img src="/images/14576210570962.jpg" alt="Metal Gear Solid 3 Snake Eater"></p>
<p>这段故事就是『潜龙谍影3：食蛇者』的剧情，于 2004年11月(PS2)/2011年11月(PS3，360版HD)/2012年6月(PSV版HD) 发售。可以看做是游戏系列里最先的一作。</p>
<p><strong>代号食蛇者行动·苏联军官沃尔金意外遭受雷击 1964 年 8 月 30 日</strong></p>
<p>为了抹杀变节者引领者,食蛇者行动展开。裸蛇乘坐单人驾驶式飞机，再次侵入苏联境内。在任务中，他得到了伊娃（Eva）的帮助，她表面上是一个前美国国安局间谍，其实是哲学家和某大国的双重间谍，裸蛇也遭遇了年轻的俄国格勒乌军官左轮山猫，与他数次交手，并在他的枪下失去了右眼，戴上眼罩。在重重的困难之中，裸蛇一一击败了前眼镜蛇部队的成员，并击毁了核搭载战车峡谷虎（Shagohod）。在追逐裸蛇的过程中，沃尔金遭雷劈，疑似死亡。</p>
<p><img src="/images/14576212112140.jpg" alt="代号食蛇者行动"></p>
<p><strong>代号食蛇者行动·引领者在苏联境内逝世</strong></p>
<p>在食蛇者行动的最后，引领者和大首领在一片花海之中展开命定的师徒之战。引领者吐露了自己的梦想，希望世界不要在冷战的阴云下割裂，而应该再次团结一心。大首领只有10分钟击败自己的导师，在时间结束之时，他们的所在地会遭到轰炸。大首领最终打败了自己的导师，在生命的最后时刻，引领者把记载着爱国者遗产交易记录的微缩胶片交给了大首领，并要求大首领杀死自己。枪响，白色的花海一片血红。</p>
<p><img src="/images/14576212725582.jpg" alt="Boss VS Big Boss"></p>
<p><strong>美国总统授予战斗英雄约翰大首领称号 1969 年</strong></p>
<p>由于成功击杀了引领者，裸蛇约翰被美国总统授予大首领的荣誉称号。但随后，他也了解到关于食蛇者行动的真相。引领者其实秘密为美国政府工作。沃尔金从他父亲手中继承了哲学家的遗产，而引领者变节的目的是接近沃尔金，拿回哲学家的遗产，但因为沃尔金意料之外地发射核弹，她的任务变了:她需要死在裸蛇手里，永远作为一个叛徒为世人所知，从而给愤怒的苏联一个交代，引领者也接受了这一任务的变化，最终死在自己门徒手中，并把哲学家遗产交给了美国。裸蛇对美国政府幻想破灭，他拒绝承认大首领的称号，并退出了FOX部队。引领者交给大首领的哲学家遗产只有一半，这一半遗产落入CIA之手，然而CIA的中央情报总监并未上报，只是留在自己的手中。</p>
<p><strong>阿帕网诞生 1969 年</strong></p>
<p>美国高级研究计划署组建了计算机网络：高级研究计划代理网络（Advanced Research Projects Agency Network），简称阿帕网。在阿帕网基础上，现代的互联网逐渐发展而来。信息串流和分享方式的革命给“爱国者”AI后来利用信息统治世界提供了技术基础。</p>
<p>事实上，后来的“爱国者”组织的创始人之一希金特也参与了阿帕网的开发，并在此后不久升任美国国防部高级研究计划局（DARPA）的局长。</p>
<p><img src="/images/14576214023876.jpg" alt="阿帕网"></p>
<p><strong>“爱国者”诞生 1970 年</strong></p>
<p>山猫刺杀了CIA的中央情报总监，取得了哲学家遗产。在哲学家遗产的基础上，大首领、零上校、左轮山猫，和两位参加了食蛇者行动的FOX前成员：空降护理和希金特建立了“爱国者”（The Patriots）组织。爱国者组织实际上是哲学家美国分布的重组。其建立目的是为了实现引领者关于世界大同的梦想。零把这个梦想解读为“没有边界的世界（World Without Borders）”，在一个规则下团结起整个世界。所以零大肆宣扬大首领的传奇，作为一种宣传控制的手段。斯内克相信零是为了自己的利益歪曲了引领者的心愿。</p>
<p><img src="/images/14576214873702.jpg" alt="The Patriots"></p>
<p><strong>黑历史之中的猎狐犬小队成立 1969~1970 年</strong></p>
<p>有着Big Boss称号的Snake早已从FOX小队中退役，开始过着训练新兵的生活。可是突然一天Snake等全部和FOX小队有关系的人员都被逮捕。原来FOX小队的指挥官Gene叛变了，Gene意图建立Army’s Heaven——这个只属于军人的国家，以打破世界的军事平衡。Big Boss在追击Gene的途中将很多人纳为了自己的同伴，比如NULL，Elisa和Johnthan等，同时这些人成立了猎狐犬小队，开始对FOX部队进行反击。最终BB干掉了MetalGear之后打倒了Gene。Gene在死前将手头上的所有资金设备全部交给了BB，并且声称BB以后一定会用到这笔资源。</p>
<p><img src="/images/14576215645424.jpg" alt="Metal Gear Solid : Portable Ops Plus"></p>
<p>这段故事就是 Metal Gear Solid : Portable Ops Plus 中的剧情，于 2006年12月/2007年9月(加强版) 在 PSP 平台发售。</p>
<h3 id="1971__u5E74_-_1980__u5E74"><a href="#1971__u5E74_-_1980__u5E74" class="headerlink" title="1971 年 - 1980 年"></a>1971 年 - 1980 年</h3><p><strong>美政府启动“魔童计划” 1971 年</strong></p>
<p>美国政府开始进行魔童计划（Les Enfants Terribles，法语，糟糕的，可怕的孩子，来自50年代同名电影）。该计划意图制造出传奇战士大首领的克隆体。该计划的幕后资助人是零，克拉克博士带头进行。零的意图不仅是要造出最强的战士，更是要保证如果和大首领分道扬镳，可以制造出另一个可以加以利用的偶像。克拉克博士参与过贞洁行动和食蛇者行动，当时代号空降护理（Para-Medic）。</p>
<p><img src="/images/14576216937761.jpg" alt="魔童计划"></p>
<p><strong>双蛇诞生 1972 年</strong></p>
<p>伊娃作为代孕母亲，魔童计划的成果——双蛇诞生。继承较优秀显性基因的孩子，就来被叫做利奎德·斯内克（Liquid Snake，液体蛇），而继承较劣质隐性基因的孩子，就是后来的索立德·斯内克（Solid Snake，固体蛇）。后来，继承了完美而平衡的基因的第三个克隆体，索利达斯·斯内克（Solidus Snake）诞生，即日后的美国总统乔治·希尔斯（George Sears）。</p>
<p>魔童计划并没有事先知会大首领，大首领为零私下进行这一计划感到愤怒。由于和零不可弥合的理念分歧，同年，大首领离开爱国者，与零分道扬镳。</p>
<p><img src="/images/14576217571827.jpg" alt="双蛇诞生"></p>
<p><strong>和平行者事件·AI核武器“和平行者”被毁 1974 年</strong></p>
<p>某一天，自称是和平大学教授的盖尔维兹与他的学生帕兹（Paz）来到无界之师的驻地，请求大首领前往哥斯达黎加调查一支神秘的武装部队，并许以一个人造浮岛基地，但是遭到了拒绝。最终由于一卷录有引领者声音的录音带，大首领答应了真实身份是为克格勃工作的盖尔维兹。</p>
<p>大首领之后在哥斯达黎加当地游击队桑地诺民族解放阵线（FSLN）的帮助下，发现神秘部队受美国中情局（CIA）指挥，将由AI控制的核武器运入哥斯达黎加。其中有一台搭载了引领者的AI——和平行者，也正是录音带中声音的来源。而这一切都是CIA中美洲站长冦尔德曼（Coldman）为了夺回自己在CIA中的地位，而计划另美苏再次陷入核危机之中。在冦尔德曼死在盖尔维兹（真名扎德尔诺夫）枪下之前，启动了和平行者的核弹发射指令。大首领在与和平行者一番激战之后，引领者的AI控制和平行者自己沉入湖中，再次给了世界一个和平的机会。</p>
<p><img src="/images/14576218515576.jpg" alt="Metal Gear Solid: Peace Walker"></p>
<p>这段故事就是 Metal Gear Solid: Peace Walker 的剧情，于 2010年4月(PSP)/2011年11月(PS3,360版HD) 发售。</p>
<p><strong>和平行者事件·三重间谍帕兹坠海失踪</strong></p>
<p>帕兹的真实身份是一名Cipher（零）的间谍。在“和平行者事件”后，回到无界之师的她开始了真正的任务。在试图破坏Metal Gear ZEKE的动力部时被奇科目击，不得已提前行动。帕兹表明Cipher希望大首领重新回到“爱国者”组织并以向美国东部发射核弹相威胁，但遭到拒绝，只能驾驶Metal Gear ZEKE与大首领开战，后被大首领击败，坠入太平洋中。</p>
<p><img src="/images/14576219542113.jpg" alt="帕兹 Paz"></p>
<p><strong>和平行者事件·雇佣兵团无界之师崛起</strong></p>
<p>通过“和平行者事件”，无界之师获得了“母基地”（Mother Base）作为基地，又说得了不少CIA与苏联的佣兵与人才，无论是兵力还是装备，都已经匹敌一个小国的军事实力，并且开始对外派遣佣兵，已可以称为民间军事企业。从和平行者上回收核弹头并自行开发了Metal Gear ZEKE后，无界之师已经成为“世界第七个核武器保有国”。</p>
<p>在击败帕兹，并再次粉碎Cipher的企图后，大首领发布了无界之师崛起宣言：“我们没有国家，没有信仰，没有意识形态。哪里需要我们我们就去哪里，不为国家，不为政府，我们为自己而战。我们战斗不需要理由，仅仅因为有人需要我们。我们会是那些无助者们的威慑力！我们是没有国界的士兵，我们的目标由我们所处的时代所决定！”</p>
<p><img src="/images/14576220334771.jpg" alt="无界之师"></p>
<p><strong>《自私的基因》发表·海上雇佣兵基地“母基地”被毁 1975 年</strong></p>
<p>修依坚持无界之师（MSF）应该向全世界证明自己的干净清白，于是MSF决定接受相关检查。在检查之夜，米勒和斯内克得到消息，帕兹活下来了，被关在欧米茄（OMEGA）营地——一个美国设在古巴的秘密据点。同时，小男孩奇科也被关在那里。帕兹和奇科都知道合金装备ZEKE，大首领必须在他们泄露信息前救回他们。</p>
<p>大首领侵入基地成功解救二人，返回时却发现母基地被攻击了，攻击者是谜之组织XOF，被神秘的疤面男子Skull Face(骷髅脸)领导。在一片混乱中大首领找到米勒，二人乘直升机逃走，母基地则毁于一片火海。但同时乘机的帕兹体内还有一枚炸弹。在帕兹跳下飞机的一刻，炸弹爆炸，大首领陷入长达9年的昏迷。（这也是 Ground Zero 原爆点的剧情，引发后面的毒蛇，山猫另其以为自己就是 Big Boss）</p>
<p>同年，美国科学作家理查德·道金斯发表著名文章《自私的基因》，首次使用模因（meme）一词，指“在诸如语言、观念、信仰、行为方式等的传递过程中与基因（gene）在生物进化过程中所起的作用相类似的那个东西。”后爱国者的“民智选择计划”和该理念有莫大关系。</p>
<p><img src="/images/14576222758289.jpg" alt="Metal Gear SOLID V: GROUNDZEROES"></p>
<p>去救出 Paz 和 Chico 的故事就是 Metal Gear SOLID V: GROUNDZEROES 的剧情，于 2014年3月20日(PS3,PS4,XBOX360,XBOXONE)，2014年12月18日(PC) 发售。</p>
<p><strong>两伊战争爆发&amp;哈尔·艾默里克出生 1980 年</strong></p>
<p>两伊战争，又称第一次波斯湾战争爆发。同年，苏联入侵阿富汗，新冷战爆发。</p>
<p>弗兰克·耶格在罗得西亚内战中，收养了成为孤儿的内奥米（Naomi）。</p>
<p><img src="/images/14576224704845.jpg" alt="两伊战争爆发"></p>
<h3 id="1981__u5E74_-_1990__u5E74"><a href="#1981__u5E74_-_1990__u5E74" class="headerlink" title="1981 年 - 1990 年"></a>1981 年 - 1990 年</h3><p><strong>1984~198X 年《潜龙谍影V：幻痛》绝密档案</strong></p>
<p>零少校为了保护大首领的安全，把大首领转移到塞浦路斯的一家医院治疗，并把大首领身边的医疗兵整形为大首领的模样，作为大首领的替身以保护大首领，代号毒蛇（Venom Snake），最后还委托山猫秘密保护大首领。大首领先于他的替身苏醒，并保护他的替身在骷髅脸的追杀下逃离医院。表达大首领苏醒的暗号即为“V has come to”。之后，大首领去建设他的军事国家，真正的“世外天堂”。毒蛇则在米勒和山猫的支持下经营壮大名为“钻石狗”的雇佣兵军队。</p>
<p>大首领的替身完成了对骷髅脸的复仇。骷髅脸研发了能携带核武器的新型合金装备：类人猿（Sahelanthropus），意图借此进入危险的核平衡。同时他强令密语者研制了一种声带寄生虫，它们寄生入人体后，如果暴露在一种特定的声音下，就会大量繁殖，杀死宿主的肺部。这种特定声音，就是某种特定的语言，即这种寄生虫能杀死说特定语言的宿主，以达到清除这种语言的目的。骷髅脸阴谋计划利用这种寄生虫杀死所有英语使用者，消灭世界通用语，让世界归于混乱和“自由”。大首领的幻影击败了骷髅脸，粉碎了他的阴谋。在过程中，大首领的幻影也遭遇了童年的魔童计划产物：利奎德·斯内克（就是白曼巴，Eli）和原本奉命杀死“大首领”，最后为了却救了他的命的狙击手“安静”（静静，Quiet）。</p>
<p>静静是Cipher安插到毒蛇身边的卧底，在医院的刺杀行动中她全身烧伤，在寄生虫疗法的帮助下幸存。她身上携带着英语种类的寄生虫，作为后备方案，把寄生虫传播到钻石狗部队和全世界。但静静怀抱着对毒蛇的特殊感情，一直闭口不言。直到静静被苏联军队抓取，毒蛇为了救她而陷入生命危险后，静静才迫不得已开口，指引直升机方向营救毒蛇。这导致了寄生虫在静静体内的爆发繁殖，静静也在开口后选择了离开。</p>
<p>而利奎德·斯内克（就是白曼巴，Eli）也在少年心理螳螂的帮助下，带着类人猿和少年士兵最终离开了钻石狗，并继续秉持着向“父亲”：大首领复仇的欲念。</p>
<p>这部分的故事就是 Metal Gear Solid V: Phantom Pain 的剧情，于 2015 年 9 月 2 日发售（PS4, XBOX ONE, PC）</p>
<p><img src="/images/14576228532142.jpg" alt="Metal Gear Solid V: Phantom Pain"></p>
<p><strong>佣兵国家“世外天堂”建立 198X 年</strong></p>
<p>80年代后期，具体年份未明，大首领利用雇佣兵时代积攒的财富扩张他的武装力量，并在南美建立了一个独立的国家：“世外天堂（Outer Heaven）”。在这个国家内，大首领建立了一个巨大的堡垒，作为他的雇佣兵公司的基地。世外天堂是大首领个人信念的产物，它一度成为了幻想破灭的士兵们的避难所，他们在世外天堂不必被当做政府的爪牙利用，也不会被社会抛弃。为了增强世外天堂的军事力量，大首领准备了TX-55型合金装备（TX-55 Metal Gear），一台两足战车，能在世界上任何一个地方直接发射核弹。</p>
<p><img src="/images/14576229516518.jpg" alt="世外天堂"></p>
<p><strong>利比里亚内战爆发·雷电参加利比里亚内战 1989 年</strong></p>
<p>1989年，利比里亚全国爱国阵线打回国内，利比里亚战争由此爆发。</p>
<p>杰克，代号雷电（Raiden）作为少年士兵参与了这场战争。索利达斯·斯内克杀死雷电的双亲后，作为教父收养了雷电，而雷电则一直被他当做战士训练培养，在战争中杀人无数，被称为“白恶魔”和“开膛手杰克”。</p>
<h3 id="1991__u5E74_-_2000__u5E74"><a href="#1991__u5E74_-_2000__u5E74" class="headerlink" title="1991 年 - 2000 年"></a>1991 年 - 2000 年</h3><p><strong>海湾战争爆发，苏联解体·索立德·斯内克加入猎狐犬部队 1991 年</strong></p>
<p>美国为首的多国部队于1991年1月17日对伊拉克开展的战争，目的是恢复科威特的领土。索立德·斯内克和利奎德·斯内克作为特种部队的成员都参加了这场战争。</p>
<p>在这场战争中，美军向士兵注射研究大首领时得到的“战斗基因”，引发了群体性的副作用。士兵们感觉肌肉疼痛、长期疲乏、失眠、丧失记忆、头晕、情绪低落、身体消瘦以及性功能减退，这些症状被统称为“海湾战争综合症”，被媒体广泛报道，但公众并不知道真正的原因。</p>
<p>同年，索立德·斯内克加入了猎狐犬部队。戈尔巴乔夫卸任苏共中央总书记一职，苏联正式宣告解体，冷战结束。</p>
<p><img src="/images/14576232053406.jpg" alt="海湾战争"></p>
<p><strong>索立德·斯内克突袭世外天堂 1995 年</strong></p>
<p>美国得知了世外天堂的存在，也得知了军事基地里有秘密大规模杀伤性武器TX-55型合金装备。此时大首领还是猎狐犬部队的指挥官，他和世外天堂的关系还不为人知。美政府决定让大首领和他的猎狐犬部队去解决危机。大首领派出了自己的儿子，索立德·斯内克(Solid 斯内克,固体蛇，那时还不知道自己是大首领的克隆儿子)去完成这个任务，但给了他一系列错误线索，让他进入一系列陷阱，不过SS都一一克服。斯内克救出了之前执行任务失败被困的灰狐，并最终打败了大首领。之后，北约对世外天堂进行了地毯式轰炸。大首领在爆炸中幸存，召集了麾下部队的幸存者，准备卷土重来。</p>
<p><img src="/images/14576232862358.jpg" alt="Metal Gear"></p>
<p>这部分的故事就是初代作品 Metal Gear 的剧情，于 1987年(MSX2/FC) 发售。</p>
<p><strong>克隆羊多利诞生·能源科学家马弗博士被绑架杀害 1999 年</strong></p>
<p>面对燃油极速消耗的世界性难题，基奥·马弗（Kio Marv)博士提出了一个解决方案：OILIX，一种综合燃料资源，可以解决潜在的全球危机。也因为此，他被一支叫桑给巴尔岛(Zanzibar Land)的武装力量绑架。罗伊·坎贝尔, 猎狐犬部队的现任头领，再次把已经退休的索立德·斯内克送上战场,营救博士。</p>
<p>在任务过程中，斯内克发现了很多冲击性的事实:灰狐已经成为了他的敌人，大首领还活着，此外——还有另外一台合金装备。马弗博士已经被折磨致死，OILIX的方程式落入灰狐之手。索立德·斯内克打败了灰狐和大首领。离开后，索立德·斯内克隐居在阿拉斯加。爱国者收回了大首领的遗体，利用纳米机器让大首领进入昏迷，其遗体一直被零上校保存。</p>
<p>同年，公众所知的第一个生物克隆体——克隆羊多利诞生</p>
<p><img src="/images/14576233891657.jpg" alt="Metal Gear：SOLID SNAKE"></p>
<p>这部分故事就是 Metal Gear：SOLID SNAKE 的剧情，于 1990年(MSX2平台) 发售。可以看做是 Solid Snake 与 Big Boss 的决战</p>
<h3 id="2001__u5E74_-_2010__u5E74"><a href="#2001__u5E74_-_2010__u5E74" class="headerlink" title="2001 年 - 2010 年"></a>2001 年 - 2010 年</h3><p><strong>911事件爆发 2001 年</strong></p>
<p>2001年9月11日上午，两架被恐怖分子劫持的民航客机分别撞向美国纽约世界贸易中心一号楼和世界贸易中心二号楼，两座建筑在遭到攻击后相继倒塌，世界贸易中心其余5座建筑物也受震而坍塌损毁；9时许，另一架被劫持的客机撞向位于美国华盛顿的美国国防部五角大楼，五角大楼局部结构损坏并坍塌。</p>
<p><img src="/images/14576235050107.jpg" alt="911事件"></p>
<p><strong>影子摩西岛事件·猎狐犬发动叛乱 2005 年</strong></p>
<p>时间已经到了20世纪，SS已在阿拉斯加隐居很久。</p>
<p>猎狐犬部队在影子摩西岛发动了叛乱，其时猎狐犬的指挥官是大首领的另一个克隆体——利奎德·斯内克。影子摩西岛存放着核武器和合金装备霸王（METAL GEAR REX）。利奎德·斯内克，左轮山猫，和其他猎狐犬部队的队友要求政府交出大首领的遗体和10亿美金，不然就要发射核弹。利奎德·斯内克的目的在于，通过大首领的遗体治疗手下基因士兵的怪病，并在影子摩西岛重现大首领的“世外天堂”。</p>
<p><img src="/images/14576235752201.jpg" alt="Metal Gear SOLID"></p>
<p>这一部分故事就是 Metal Gear SOLID 的剧情，是 Solid Snake 身世的首次揭开，也是 Metal Gear SOLID 系列的第一部作品，于 1998年(PS)/1999年(PS平台加强版)/2000(PC平台) 发售。</p>
<p><strong>影子摩西岛事件·索立德·斯内克孤身潜入影子摩西岛</strong></p>
<p>罗伊·坎贝尔再次把再次退休的索立德·斯内克拽上战场，去解救影子摩西岛的一些重要人物，然而，任务过程中，这些人全都死于死狐（FOXDIE）病毒引发的心脏病突发，而病毒是内奥米（Naomi）博士在任务前秘密注射进斯内克体内的。斯内克得知灰狐不仅没死，还被改造成了机械忍者。灰狐斩掉了左轮山猫的一只手。斯内克也在任务中遇到了坎贝尔上校的女儿梅丽尔（Meryl），和霸王的设计者哈尔·艾默里奇（修依博士的儿子），他们帮助了斯内克完成任务。</p>
<p><strong>影子摩西岛事件·利奎德·斯内克死于死狐病毒</strong></p>
<p>击败猎狐犬部队的几位成员后，索立德·斯内克得以面对他的兄弟利奎德·斯内克和合金装备“霸王”（Metal Gear Rex）。灰狐牺牲自己，给索立德·斯内克足够的时间摧毁了霸王。最终，索立德·斯内克和利奎德·斯内克近身决战，击败利奎德后，索立德·斯内克和梅丽尔一起逃出生天。利奎德不依不挠继续追逐，但最终还是死于死狐病毒。</p>
<p>而这一切的幕后黑手是时任的美国总统，这一切都是美国政府的阴谋，让斯内克带着死狐病毒进入基地，以杀死利奎德·斯内克等人。</p>
<p>当时的美国总统就是索利达斯·斯内克，总统时用名乔治·希尔斯。同年，他卸任美国总统一职。</p>
<p><strong>“慈善组织”建立 2006 年</strong></p>
<p>影子摩西岛事件之后，索立德·斯内克和奥塔肯建立了名为“慈善组织”的反合金装备非政府组织。这一组织尝试揭露关于影子摩西岛和“霸王”的真相，并呼吁世界停止建造合金装备。</p>
<p><img src="/images/14576238123776.jpg" alt="“慈善组织”建立 "></p>
<p><strong>曼哈顿油轮沉没事件 2007 年</strong></p>
<p>曼哈顿油轮事件，简称油轮事件。美国海军开发了两栖反合金装备武器“海魔鬼”（Metal Gear Ray），用一艘伪装的油轮途径纽约港运送。索立德·斯内克潜入了这艘游轮，试图拍照向世人揭露“海魔鬼”的存在和真相，呼吁停止建造合金装备。在他潜入的同时，格鲁科维奇上校也带领一队俄国士兵，准备夺去海魔鬼。正当斯内克拍摄过照片准备离开时，左轮山猫现身，杀死了格鲁科维奇上校，奉爱国者之命开走了海魔鬼，油轮被海魔鬼撕裂沉没。爱国者将这一切罪责均栽赃在索立德·斯内克身上。</p>
<p><img src="/images/14576239967912.jpg" alt="Metal Gear SOLID 2: SONS OF LIBERTY"></p>
<p>这部分故事就是 Metal Gear SOLID 2: SONS OF LIBERTY 的剧情，也是雷电首次登场，于 2001年11月(PS2)/2011年11月(PS3，360版HD)/2012年6月(PSV版HD) 发售。</p>
<p><strong>巨壳占据事件·“自由之子”劫持美国总统 2009 年</strong></p>
<p>油轮在纽约港沉没后引发了大量环境污染，美国海军趁此机会，在这里建立了建造了建造“玄武”（Arsenal Gear）的设施——巨壳（Big Shell）。玄武是一艘可潜水的巨大堡垒，为了爱国者的信息控制目的而建。一伙自称“自由之子”的恐怖分子劫持了巨壳，并控制了正在检查巨壳的美国总统詹姆斯·约翰逊。“自由之子”由美国前总统乔治·希尔斯，即索利达斯·斯内克带领，目的是获取“玄武”，并由此获取“爱国者”成员的名单。雷电（Raiden）作为一位没有任何经验的新兵，潜入巨壳营救美国总统。</p>
<p><img src="/images/14576241344850.jpg" alt="这部分同样是 Metal Gear SOLID 2: SONS OF LIBERTY 的剧情"></p>
<p><strong>巨壳占据事件&amp;美国前总统乔治·希尔斯去世</strong></p>
<p>雷电出色地一路战胜了“自由之子”的各个成员，并发现了关于巨壳建造“玄武”的真相。“玄武”守护着爱国者精心建造的大型AI：GW。事实上，在大首领离开后，零对一切失去信任，相信下一代不会明白他的意志，便建造了AI来继续爱国者的统治。爱国者的AI共分为5大部分，中枢JD，和4个分管AI：GW、AL、TR和TJ，它们统治着世界一切经济、信息、军事的运行。左轮山猫伪装成被利奎德·斯内克的右手操纵的样子，将玄武导引向曼哈顿，引发了一场大碰撞。在那里，雷电和索利达斯·斯内克决斗，并取得了胜利。</p>
<p><strong>巨壳占据事件·民智选择计划宣告成功</strong></p>
<p>雷电潜入巨壳的一切，其实都在爱国者的控制之下。爱国者试图用GW建立一个通过情报信息控制来控制人类意志的系统，目标是实现“民智选择”（称为3S计划），为达成社会思想上的健全化而进行选择。雷电潜入巨壳其实是对“影子摩西岛事件”的重演，为了测试GW能否在极限状态下发挥作用，控制雷电的行为。而随着雷电杀死索利达斯·斯内克，民智选择计划也宣告成功。在巨壳事件之后，GW这一AI就被爱国者废弃，并在后来被左轮山猫（液体山猫）重组利用。</p>
<p><strong>美国开始积极使用PMC 2010 年</strong></p>
<p>PMC是民间军事雇用企业的简称，指经营军事业务的法人企业。以玄武撞击曼哈顿事件为契机，美国开始积极使用PMC。由此，PMC在战争中的作用逐渐重要，并引发了一种新的经济模式：战争经济。到2014年，世界已形成5大PMC公司，美国2家，英国1家，法国1家，俄罗斯1家。而这些公司，都属于山猫控制的“世外天堂”。</p>
<h3 id="2011__u5E74_u81F3_u4ECA"><a href="#2011__u5E74_u81F3_u4ECA" class="headerlink" title="2011 年至今"></a>2011 年至今</h3><p><strong>“爱国者之枪”事件&amp;索立德·斯内克刺杀左轮失败2014</strong></p>
<p>为了阻止世界在战争经济中越陷越深，罗伊·坎贝尔再次请斯内克出山，刺杀领导PMC的，貌似已经被利奎德·斯内克彻底侵占意识的左轮山猫（现在被称为利奎德·山猫）。而诞生于魔童计划的斯内克，寿命被设定的极其短暂，此时已经急速衰老，呈现老人的模样，被称为老蛇（Old Snake)。在中东，斯内克和梅丽尔的小队一起行动，找到了山猫，但山猫启动了某种设备，所有体内有纳米机器士兵都陷入癫狂，斯内克本人也无奈倒地，并没有成功地刺杀他。</p>
<p><img src="/images/14576244368025.jpg" alt="Metal Gear Solid 4: Guns of the Patriots"></p>
<p>这部分故事就是 Metal Gear Solid 4: Guns of the Patriots 的剧情，也是 Solid Snake 的最后一个任务，于 2008年6月(PS3) 发售</p>
<p><strong>“爱国者之枪”事件·爱国者AI系统覆灭</strong></p>
<p>之后斯内克来到欧洲，找到了引他来此的伊娃，以及大首领的遗体。然而左轮的军队也追上了伊娃和斯内克，在和左轮部队的追逐战斗中伊娃死去，斯内克重伤，大首领的遗体则焚毁。左轮利用大首领的基因骗过了爱国者的AI网络，夺去了控制全世界武器枪械的“爱国者之子”系统。逃往影子摩西岛偷取了合金装备霸王的核弹头，去毁灭爱国者的中枢AI：JD。在最后的努力中，斯内克和他的战友们进入了左轮的海上基地：“玄武”级战舰，那里承载着被左轮重新利用的GW系统，左轮的阴谋是毁灭JD后，用GW取代JD，从而控制全世界。斯内克破坏了左轮的行动，向GW上传了活狐病毒。“活狐”以GW为跳板，摧毁了所有爱国者AI，世界被从爱国者的统治下解放出来。</p>
<p><strong>大首领死于死狐病毒</strong></p>
<p>SS在任务中遇到了很多熟人，包括给自己植入病毒的Namoi，Roy的女儿Meryl，爱国者的真相，还有在危机时刻舍生救自己的雷电(已被改造为半机械忍者形态)。</p>
<p>在这里简单说一下雷电吧，雷电在结束2代的剧情之后选择和女友Rose一起生活，但是由于雷电作为一个士兵，他无法适应这样和平又幸福的生活，而且他又害怕伤害到Rose，郁闷的雷电只好每日酗酒，再加上Rose说我们的儿子流产了，Rose改嫁Roy离开了雷电，雷电承受不了打击于是重返战场。实际上他们的儿并没有流产，因为雷电引起了爱国者的注意，在他身边不会安全。果然之后爱国者将回到战场的雷电抓了起来同时将它改造成了机械忍者。不甘被爱国者控制的雷电找到机会逃离了爱国者的控制，在路上遇到了Big mama(其实就是MGS3的Eva)，加入了他们的反爱国者组织。</p>
<p>一切结束后，斯内克去拜访引领者的坟墓。当爱国者AI离线后，大首领就从长年的昏迷中醒来。事实上，在欧洲被焚毁的尸体属于索利达斯·斯内克，而左轮被山猫的手侵占意志只是一出戏，目的是不让爱国者发现他真正的目的：唤醒大首领，找出零的位置。在引领者的墓前，大首领切断了垂垂老矣失去意识的零的生命维持设备，一场百年战争就此终结。随后，他和他的儿子——索立德·斯内克度过了一段难得的平静时光。因为和斯内克的接触，大首领感染了死狐病毒，并最终因此结束了生命。</p>
<p><strong>近未来·《合金装备崛起：复仇》时代</strong></p>
<p>其实《崛起》的时间轴是算在正专里面的，但是这是一部彻彻底底的以雷电为主角的动作游戏，所以还是单独挑出来说一下比较好。本作由小岛工作室和合金工作室合作开发，实际上一开始只有小岛工作室在开发，打算这次做一个还是以潜行为核心，但是会更注重战斗场面的游戏;但是之后白金工作室加入把本作核心放在了动作上，虽然变成一个彻头彻尾的动作游戏，但是游戏没有给MGS系列丢人。</p>
<p>主角雷电依然保持着MGS4中的机械忍者形象，而且这一次，玩家要操控他拿起手上的刀，将世界从战争危急中解救出来。游戏中会出现Sunny等一些老人物，同时也会对雷电这个人物做更多的。喜欢帅哥雷电同时又热爱高速爽快战斗的话，本作一定不能错过。
　　</p>
<h2 id="u4F5C_u54C1_u5217_u8868"><a href="#u4F5C_u54C1_u5217_u8868" class="headerlink" title="作品列表"></a>作品列表</h2><p>这里按照剧情时间顺序来介绍，而非作品的序号</p>
<p>《合金装备索利德3：食蛇者》→《合金装备索利德：掌上行动》→《合金装备索利德：和平行者》→《合金装备索利德5：原爆点》→《合金装备索利德5：幻痛》→《合金装备》→《合金装备2 ：索利德斯内克》→《合金装备索利德》→《合金装备索利德2：自由之子》→《合金装备索利德4：爱国者之枪》→《合金装备崛起：复仇》</p>
<ul>
<li>SS: Solid Snake</li>
<li>BB: Big Boss</li>
<li>MG: Metal Gear</li>
<li>MGS: Metal Gear Solid</li>
</ul>
<p><img src="/images/14576193203131.jpg" alt="系列作品年表"></p>
<p><img src="/images/14576193670265.jpg" alt="作品中的 Snake"></p>
<h3 id="MGS_3_3A_Snake_Eater"><a href="#MGS_3_3A_Snake_Eater" class="headerlink" title="MGS 3: Snake Eater"></a>MGS 3: Snake Eater</h3><p>发售日：2004年11月(PS2)/2011年11月(PS3，360版HD)/2012年6月(PSV版HD)</p>
<p>《合金装备》系列剧情的原点——故事的时间在1964年，主人公是一名美国特殊部队Fox Unit的成员，行动代号Naked Snake(裸蛇)。游戏的开场，Snake接到了一个任务——去营救被困在苏联的科学家，这名科学家的发明有着可以引发第三次世界大战的力量。在任务途中，Snake突然被自己的恩师The Boss背叛，Snake被打下山崖，任务自然以失败告终。九死一生的Snake在不久之后接到了新的任务，目的是再次拯救那位科学家，同时干掉背叛国家的The Boss。</p>
<p>最终，Snake与自己的恩师The Boss展开了决战并亲手杀掉了她。在最后我们才知道，The Boss是美国派去苏联的卧底，她的目的是拿到苏联的那份“哲学家的遗产”，但是当时的苏联将军 Volgin(沃尔金)将The Boss带来的核弹头直接在苏联境内发射了(核弹头是美方为了表示诚意以便The Boss成功潜入内部而准备的礼物。)，苏联上层不知情认为是美方所做，美国没有办法只好把锅都甩给TheBoss，决定要将她当作叛徒处理。所以就让Snake去解决掉她。所以The Boss至死都没有背叛过自己的祖国。The Boss在弥留之际说自己希望世界是一个整体而不是东方和西方。之后Snake因为干掉了TheBoss，为国家做出了贡献，被授予Big Boss的称号。</p>
<p>游戏的最后一幕就是成为了Big Boss的Snake在The Boss的无名之墓上敬礼并且留下了眼泪。这一幕在MGS系列乃至整个游戏界中都相当著名。</p>
<p>本作有令人耳目一新的“生存系统”，同时也是游戏的核心系统。玩家可以看到角色的身体状况，吃刚捕获的动物作为充饥的粮食(食物会随着PS2的系统时间的推移而腐化)，玩家需要凭借着自己的实力在森林之中找到食物，而且在中弹之后还需要手动进行包扎止血。游戏还真实的表现出CQC(近身搏斗)技巧，就像是真的潜入作战一样。</p>
<p>而且游戏不仅将“野外生存”这一主题有力地体现出来，游戏中的各种设定也十分有趣。直到现在，可以调整时间来让The End老死的设定依然让玩家津津乐道。</p>
<h3 id="MGS_3A_Portable_Ops_Plus"><a href="#MGS_3A_Portable_Ops_Plus" class="headerlink" title="MGS: Portable Ops Plus"></a>MGS: Portable Ops Plus</h3><p>发售时间：2006年12月(PSP)/2007年9月(加强版)</p>
<p>距离3代的故事已经过去了6年。有着Big Boss称号的Snake早已从FOX小队中退役，开始过着训练新兵的生活。可是突然一天Snake等全部和FOX小队有关系的人员都被逮捕。原来FOX小队的指挥官Gene叛变了，Gene意图建立Army’s Heaven——这个只属于军人的国家，以打破世界的军事平衡。Big Boss在追击Gene的途中将很多人纳为了自己的同伴，比如NULL，Elisa和Johnthan等，同时这些人成立了猎狐犬小队，开始对FOX部队进行反击。最终BB干掉了Metal Gear之后打倒了Gene。Gene在死前将手头上的所有资金设备全部交给了BB，并且声称BB以后一定会用到这笔资源。</p>
<p>作为PSP上第一款MGS作品，掌上行动已经很努力的将《合金装备》的精髓玩法带给了大家，而且大胆尝试了很多新的要素比如联机模式，招募伙伴。但是由于是第一次登陆掌机，各方面还不成熟，所以本作的实际游玩体验会打一些折扣，但是并不怎么影响掌上行动的素质，Fami也给出了39分的高分。虽然小岛没有把本作放在正传列表中，但是BB在故事中遇到的人和事其实都对之后的事件埋下了一些伏笔，所以说这款黑历史之中的《掌上行动》还是值得一玩的。</p>
<h3 id="MGS_3A_Peace_Walker"><a href="#MGS_3A_Peace_Walker" class="headerlink" title="MGS: Peace Walker"></a>MGS: Peace Walker</h3><p>发售时间：2010年4月(PSP)/2011年11月(PS3,360版HD)</p>
<p>不逊色于主机作品的掌机续作——这次故事发生在1974年，这时冷战时期也进入到了末期，形势看似和平，但是在哥斯达黎加，却遭受到了不明军队的袭击，可这里有着和平宪法的保护无法出动任何部队反击。这时在哥斯达黎加和平大学的女学生Paz和她的教授Galevz选择了请求“无国界军队”帮助，而这个部队正是由Big Boss所指挥。而且教授还给Big Boss了一份酷似The Boss声音的录音带，这让Big Boss没有理由拒绝这份委托。然而随着故事的进行，阴谋逐渐浮出水面，代号为Peace Walker的二足步行兵器(MG)已经开发完成并且加上了The Boss的AI，而Paz竟然是“CIPHER”的间谍，而且要毁灭BB全部的军队，最后经过一番苦战终于打败了Paz，Paz也坠入了大海。</p>
<p>FAMI通的满分作品，也是PSP平台非常少见的满分。在吸取了前作《掌上行动》的缺点之后，这次《和平行者》在画面，剧情和游戏性上堪称集大成之作。游戏保留了之前的漫画过场，联机与招募同伴的要素，而且在剧情上为了承上启下大下功夫，可以算是MGS的转折点。同时场景也丰富了很多，再加上成熟的动作与有趣的联动要素（比如和猎人的联动会让蛇叔和轰龙对决）使得本作算是PSP 平台不可多得的佳作。</p>
<h3 id="MGS_5_3A_Ground_Zeros"><a href="#MGS_5_3A_Ground_Zeros" class="headerlink" title="MGS 5: Ground Zeros"></a>MGS 5: Ground Zeros</h3><p>发售日：2014年3月20日(PS3,PS4,XBOX360,XBOXONE)，2014年12月18日(PC)</p>
<p>次世代的第一款MGS——故事发生在上一作《和平行者》事件结束的一段时间之后，依旧在无国界军队执行任务的Big Boss突然收到了消息称Paz没有死，而且偷偷去营救她的Chico也被一个组织抓住了，于是BB必须前去营救他们。但是同时，Huey单方面的同意了一个世界核组织对基地的检查，这就直接引出了开篇的一幕，一个称作Skull Face(骷髅脸)的角色率领了一个叫做XOF(FOX小队的对立面)小队，抓走Paz和Chico，随后他们撕下自己的XOF徽章伪装成世界核组织前去“检查”BB的基地。之后虽然BB成功的解救出了Paz和Chico但是却发现自己的基地已经被毁灭了，Paz也称自己体内还有炸弹于是自己跳下飞机爆炸，BB受重伤昏迷，无国界军队被XOF小队几乎全灭。等到BB苏醒之后，他要去复仇，找到毁灭自己基地的人究竟是谁，Huey等人为什么要背叛自己，只有接下来的《幻痛》能告诉我们真相了。</p>
<p>作为次世代的第一款MGS，《原爆点》只能算是一个《合金装备索利德5》的序章，但是本作的画面等细节方面非常出众，而且也包含了很多额外任务与彩蛋，为了迎接之后的《幻痛》，《原爆点》没有理由不去将它通关一次。</p>
<h3 id="MGS_5_3A_Phantom_Pain"><a href="#MGS_5_3A_Phantom_Pain" class="headerlink" title="MGS 5: Phantom Pain"></a>MGS 5: Phantom Pain</h3><p>故事发生在1984年，此时的游戏中和现实一样也在进行着阿富汗战争。尽管游戏大体和现实相同，但是玩家可以发现游戏内的武器和科技要远远比现实中的冷战时期先进。不光是“合金装备”本身，其他军事技术诸如外骨骼、双足机甲、光学隐形、全息影像都被各国谍报机关所使用着。其他科学技术诸如纳米技术、克隆、人工智能也进入了实用化的阶段。玩家还可以在游戏中发现一些陌生却又熟悉的枪械，例如类似AK74突击步枪的SVG-76突击步枪。而性能相对于现实有些夸张、但却让老玩家怀念的“富尔顿地对空回收系统”也重回作品并在游戏内扮演着举足轻重的角色。</p>
<p>同时，游戏还包含制作人小岛秀夫惯有的幽默气息。比如主角Big Boss可以使用的装备中有被称为“终极隐蔽科技”的道具纸箱子。玩家可以藏在纸箱子里进行移动，并突然钻出纸箱子用消音麻醉手枪击倒敌人。</p>
<p>在一手建立的佣兵组织“无界之师”（Militaires Sans Frontières）于《原爆点》结尾被摧毁后，主角大首领（Big Boss）也陷入了长达九年的昏迷。醒来后，世界发生了翻天覆地的变化，而他重新建立了佣兵组织“钻石狗”（Diamond Dogs）。在名为“毒蛇”（Venom Snake）的代号下，他重新卷入了位于阿富汗的苏联入侵行动中，目的是寻找要为袭击“无界之师”事件而负责的罪人。为了达成复仇，他重新召集了他的劲敌“山猫”（Ocelot）并与一批忠诚的战士们相遇，谱写新的历程。他与米勒（Kazuhira Miller）在复仇的过程中发现了名为“密码”（Cipher）的组织正在开发一款甚至可以超越合金装备的武器，而Big Boss的任务也迅速转变为消灭新的威胁。</p>
<p>毒蛇是本作的主角，玩家主要扮演他来进行任务。通常被称为“大首领”（Big Boss），而“毒蛇”（Venom Snake）是他行动的代号，被视为传奇。他本是“无国界之军”的一名医疗兵，在母基地遭受袭击，PAZ体内的第二颗炸弹爆炸（详情请看后面的PAZ介绍），他挡在了Big Boss前面（这就是为什么Venom Snake身体内有那么多人体碎片而BIGBOSS没有），之后陷入了长达九年的昏迷。苏醒后代替下落不明的大首领（naked snake）组建“钻石狗”，并成为领袖。率部深入阿富汗和非洲，在阿富汗战争中寻找摧毁了“无界之师”要塞的罪人并予以复仇。</p>
<h3 id="Metal_Gear"><a href="#Metal_Gear" class="headerlink" title="Metal Gear"></a>Metal Gear</h3><p>发售日：1987年(MSX2/FC)</p>
<p>包受争议的初代作品——剧情是在1995年左右，Big Boss已经建立了猎狐犬组织，这时突然得知在南非，出现了一个叫做“Outer Heaven”(世外天堂)的要塞国家，并且有消息传出这个国家在生产大杀器——Metal Gear 。于是Big Boss派出手下的一名新兵前去侦查这个国家并且营救之前去侦查结果失去联系的Grey Fox，这个人就是我们之后系列的主角Solid Snake。但是当SS不断深入之后发现Big Boss给自己的通信越来越奇怪，时常将自己引到陷阱之中。原来这个世外天堂的建立者就是自己的上司Big Boss。最终SS摧毁了整个基地，粉碎了Big Boss的野心。</p>
<p><img src="/images/14576254881646.jpg" alt="Metal Gear"></p>
<p>作为全系列的第一部作品，游戏本身的素质堪称上乘，潜入式的玩法在当时给人耳目一新的感觉，但由于MSX2平台只在日本地区发售的原因，本作并未在全球范围内引起热潮放在那个时代本身素质还算过得去，丰富的道具和有趣的游戏模式也算能让人玩的下去，但是这作而由于当时KONAMI错误的市场估计，所以之后在美国并未发行MSX2的初代合金装备(很大一部分原因是因为MSX2主机根本没有在日本以外的地区发售。)，更加糟糕的是，KONAMI在没有令小岛秀夫参与制作的情况下，单方面让美国分部在NES上发行所谓的FC版，而美国的小组则自作主张将游戏内容进行改编，反而使得游戏丧失了原版的精髓，最终BOSS也由Metal Gear变为了庸俗的所谓“控制MG的电脑”。小岛秀夫已经认定FC版的合金装备并非正统，甚至认为就是一款彻头彻尾的垃圾作品。所以本作的争议很大，这也直接导致小岛要出一个为自己正名的续作。</p>
<h3 id="Metal_Gear_2_3A_Solid_Snake"><a href="#Metal_Gear_2_3A_Solid_Snake" class="headerlink" title="Metal Gear 2: Solid Snake"></a>Metal Gear 2: Solid Snake</h3><p>发售日：1990年(MSX2平台)</p>
<p>Solid Snake与Big Boss的决战——故事发生在上作的4年后，Zanzibarland(桑给巴尔岛)上的一个军事政府突然突击了各国的核武器安放库，由于核平等条约的束缚，这个国家反倒成为了唯一可以使用核武器的国家，对世界造成了巨大威胁。这时解决了Outer Heaven危机的SS临危受命，前往这个小岛解救被绑架的Marv博士，这位博士发现了一个可以精炼石油的微生物，所以他对这个小岛统治全球的计划是关键性的人物，SS需要把世界从危急之中解救出来。</p>
<p><img src="/images/14576255533327.jpg" alt="Metal Gear 2：SOLID SNAKE"></p>
<p>在任务的最后，我们会遇到我们的熟人Big Boss，最终决战自然是以Big Boss战败收尾，而Big Boss也结束了他传奇的一生。SS也到阿拉斯加隐居起来，不再参与战事。值得一提的本作实际是只有日版，美版自己做了一款叫做《斯内克的复仇》的游戏，模式是类似于魂斗罗的横版射击，小岛自然无法认同这部被“糟蹋”的作品，再加上本作由于MSX2只有日版，所以《斯内克的复仇》压根没有在日本发售。</p>
<p><img src="/images/14576256407693.jpg" alt="Metal Gear 2：SOLID SNAKE"></p>
<h3 id="MGS"><a href="#MGS" class="headerlink" title="MGS"></a>MGS</h3><p>发售日：1998年(PS)/1999年(PS平台加强版)/2000(PC平台)</p>
<p>Solid Snake身世的首次揭开——时间已经到了20世纪，SS已在阿拉斯加隐居很久，但是突然有个部队占领了一个阿拉斯加的军事基地，并且抢到了正在做演习的Metal Gear Rex，而这个部队正是SS之前所在的猎狐犬小队，这次叛变也就被成为“影子摩西岛事件”。猎狐犬小队仗着自己拥有可以发射核武器的Metal Gear，向美国索要大量金钱，更重要的是他们还要Big Boss的遗体。当时在掌上行动中出现的ROY上校亲自请求SS出马，拯救被猎狐犬绑架的人质，解决这次危机。但是在SS在执行任务的途中，他发现自己要拯救的人质在看到他之后都会莫名其妙的突发心脏病死亡，而且还遇到了不少关系到SS命运的家伙，比如Ocelot(山猫，在与SS决斗的时候被NULL砍掉了一个手臂)，Meryl(ROY上校的侄女，不过实际上是女儿)，NULL(掌上行动时的忍者，也就是灰狐gray fox)，Otacon(MG Rex的设计师)。</p>
<p>最终我们遇到了实施整个事件的头目，他就是Liquid Snake。这个和SS拥有一样长相的人告诉了SS他们的身世：其实他们都是一个叫做魔童计划(Les Enfants Terribles/恐るべき子供达计划) 的产物，这个计划就是利用Big Boss的基因，制造出很多像BB一样伟大的战士，两个人都是克隆体，其实是兄弟。</p>
<p>但是Liquid说自己是继承了的是劣质基因，SS继承了优质基因，由于痛恨自己的基因不足必须干掉SS，而且还要超过Big Boss——重建世外天堂。不过最终Liquid还是败在了SS的手下，但是在最后时刻SS在一场汽车追逐战中翻了车，动弹不得，Liquid拿着枪走了过来却在准备开枪之时突然心脏病突发死亡。SS总归还是完美完成了任务。</p>
<p>实际上，Liquid率领的猎狐犬小队叛乱并不是他一个人的计划，而是在山猫和美国总统Solidus Snake的怂恿下进行的。而Solidus Snake则是BB的完美克隆体。而任务中的那些突发心脏病死亡的人其实是受到SS身上一种叫做死狐病毒(fox die)的影响，这种病毒可以直接引起一些特定基因的人死亡。这个病毒是一个叫Naomi的医学家在SS不知情的情况下为它注射的，Naomi是Gray Fox的妹妹，他知道以为自己的哥哥是被SS所杀所以想利用这个病毒杀掉SS复仇，但是由于期间和SS接触久了之后发现其实自己的哥哥并不恨SS，自己也知道SS当时也不迫不得已，但是由于已经注射了病毒，只好将死狐病毒的发作时间改成了随机发作(实际上一直到4代中才有些发作的体现。)</p>
<p>最后讽刺的是Liquid Snake实际上是优质基因的继承者，他的实力完全是在SS之上，但是最后的失败也正式MGS1想告诉玩家的主题——永远不要被命运或者基因所束缚。</p>
<p>《MGS1》开创3D潜入的先河，同时也率先引领了电影化叙事的潮流，而且剧情全部都是即时演算，这在当时大量依靠文字或者图片叙事的游戏之中，MGS这种表现手法实在让人眼前一亮。而且距离上一作距离8年之久，这样一个回归是非常令人震撼的，成功的为MGS在这个时代的平台树立起自己的招牌。</p>
<h3 id="MGS_2_3A_Sons_Of_Liberty"><a href="#MGS_2_3A_Sons_Of_Liberty" class="headerlink" title="MGS 2: Sons Of Liberty"></a>MGS 2: Sons Of Liberty</h3><p>发售日：2001年11月(PS2)/2011年11月(PS3，360版HD)/2012年6月(PSV版HD)</p>
<p>新主角雷电的初次登场——MGS2的故事大致可以分成前轮篇和Big Shell篇。</p>
<p><strong>油轮篇</strong></p>
<p>发生在MGS1结束后的2年，山猫夺取了MG的数据并且在黑市上兜售，这导致很多国家都可以制造出MG这种危险兵器。SS便和Otacon一起成立了一个反MG的组织——Philanthropy(慈善事业)，两人开始四处摧毁被制造出来的MG。突然他们得到消息，称纽约附近的油轮上有新型的两栖用MG，于是SS立即前去准备破坏它。但是在到达油轮底层之后发现了其实这一切都是山猫在捣鬼，他假装和其他国家的军官合作但最终的目的是为了夺取新型MG。当SS和山猫对峙的时候山猫右臂抽搐然后仿佛换了个人似的说：“好久不见了，兄弟。”原来当初山猫被砍掉右臂之后又移植了Liquid Snake的胳膊，所以Liquid Snake有时就会控制山猫的心智。之后山猫恢复了意识，驾驶MG破坏了游轮后逃走，并且在网上大肆散布SS在游轮上的照片，让大众将SS视作了恐怖分子，同时油轮篇的故事到这里为止了。<br>　　<br><strong>Big Shell篇</strong></p>
<p>雷电在执行这次任务之前也仅仅是一个新兵菜鸟。而这一次他的任务就是去海洋设施拯救人质(《MGS》非常喜欢用解救人质开头)。还记得之前油轮篇的油轮吗?山猫在将它破坏之后石油散落在大海之中，于是建立了一个海洋净化设施Big Shell，而这里明显不单单是一个环保设施。果然，雷电在执行任务的途中遇到了SS和Otacon等人，同时也知道了这个设施其实下面隐藏着一台由爱国者控制的超级数字战舰，而这一切都是由前任美国总统Solidus Snake，现在的恐怖组织头目所策划的，他自称Sons of Liberty(自由之子)，还绑架了即将当选的下任总统，而且Solidus Snake也是雷电的养父，是他将小时候的雷电从战场中捡了回来。<br>　　<br>当剧情进行到全部人员都汇集到超级战舰之上的时候，山猫终于说出了自己的目的：原来这一切都是爱国者计划好的，故事中的一切的事件都与影子摩西事件一模一样，都是为了重现当年的事件（详细可以查看S3计划）。随后山猫进入了Metal Gear Ray的驾驶舱，跳进了大海，SS也随即跳入海中，战舰上只留雷电和Solidus Snake两人。最终战舰撞向了美国纽约，最后在国家纪念堂前才停了下来。</p>
<p>这时Solidus Snake 也说明了自己做这一切的目的：他做的这一切都是为了摆脱爱国者的控制，现在爱国者过于强大了，我们全部的行为都会受到爱国者的保护，但是这样一来我们自己能为后代留下什么遗产?!一般人类还可以通过基因流传，而他和SS等克隆人没有生育的能力，他们最终只会被历史遗忘，他要做的就是永远的被历史所铭记，要战胜爱国者，解放人类，成为“自由之子”。之后雷电接到通信，通信中说明了爱国者现在的状态：爱国者现在其实是一个为了生命数字化而制造的超级电脑，如今人类身上都植入了纳米机器人用来治病或者强化身体，而爱国者正是通过这个机器人收集人类的信息，于是为了人类的未来，他会主动过滤掉一些无用的信息，从而慢慢控制人类的思想，感情。而这整个的事件，不过就是爱国者的试验罢了。<br>　　<br>最终，雷电和Solidus Snake的决战在所难免，雷电靠自己高超的剑术击败了Solidus Snake，Solidus Snake掉下房顶死亡。最终雷电打算加入SS寻找爱国者的所在，但是SS却说还有更重要的事在等着你，原来自己的女友Rose早已在后面等他。</p>
<p>跨入PS2时代的《MGS2》带不仅仅在画面上有了突破，更是正式加入了第一人称的射击视角(其实在MGS1代完全版中，只要你通关一遍即可开启第一人称视角。)，而且本作还有很多有趣的故事，比如用雷电裸奔的剧情，现在也时常会被玩家拿出来开玩笑。<br>　　<br>值得一提的是小岛在游戏发售之前没有任何一次提到过会换主角，宣传视频也一直就是蛇叔，但是当玩家拿到手上玩到雷电的时候，小岛承认是自己骗了大家，希望大家能自己感受到换主角那种惊喜。这款游戏还有一个小插曲，2001年在游戏宣传的时候提到过最后战舰冲向纽约破坏了一群建筑的剧情，其中就是纽约世贸大楼，但是就在之后9.11发生了，为了避免这一个敏感问题小岛只好直接剪掉了那一段动画，剧情也就变成了战舰冲向纽约之后直接切入最终战的样子。</p>
<h3 id="MGS_4_3A_Guns_of_the_Patriots"><a href="#MGS_4_3A_Guns_of_the_Patriots" class="headerlink" title="MGS 4: Guns of the Patriots"></a>MGS 4: Guns of the Patriots</h3><p>发售日：2008年6月(PS3)</p>
<p>老蛇的最后一个任务——故事发生在2014年，在这期间，上次驾驶MG逃走的山猫成立了全球级别的专业的佣兵部队PMC，同时将称为“SOP”(爱国者之子)系统的纳米机器人全部植入PMC之中，包括人和武器，而这个系统目的就是控制士兵情绪，达成降低战争成本的目的。而且山猫这时已经被称为Liquid Ocelot，拥有大量MG，这一切都需要让这位已经略显老态的传奇战士再次出马了。</p>
<p><img src="/images/14576260972014.jpg" alt="Metal Gear Solid 4: Guns of the Patriots"></p>
<p>SS在任务中遇到了很多熟人，包括给自己植入病毒的Namoi，Roy的女儿Meryl，爱国者的真相，还有在危机时刻舍生救自己的雷电。当然，最后我们面对的还是我们的老朋友——山猫。从山猫口中，我们得知其实Liquid并没有控制自己，或者说之前的双重人格都是山猫为了破坏爱国者而演出来的。因为爱国者早已控制了几乎整个世界，所以想骗过爱国者给它植入病毒那就必须先骗过自己，于是通过药物和心理暗示让自己成为Liquid。最终目的达到了，他成功的给爱国者的AI植入了FOXLIVE病毒使爱国者全部崩溃，解放了整个世界。但是最终，我们和山猫那持续了几十年的恩怨，也要在今天划上一个句号。</p>
<p>打败了山猫之后，SS来到了The Boss的墓地，拿出手枪准备了结自己，但在这个时候，我们看到了通过手术复活的Big Boss和已经成为植物人的Zero(爱国者的建立者，BB之前的同伴)，BB对SS说：“我们之前为了The Boss的理想做了那么多事，如今我们时代已经过去了，你一定要活下去。我从来没有把你当作儿子来看待，我一直看作你是一个伟大的战士，我认为即使当时是你面对着The Boss ，你也能扣下扳机。”，之后他拔掉了Zero的氧气管，走进SS自己主动感染他的死狐病毒。SS在帮BB点完一根雪茄之后，选择了坚强活下去，最终和Otacon一起出门旅游，蛇叔的传奇一生也到此为止了。</p>
<p>本作在科学的支持下蛇叔可以使用光学迷彩从而做到像变色龙一样的隐藏在周围的环境之中，带给玩家全新的体验。不过这次最强大的地方就是小岛把这部老蛇的最终作狠狠的玩了一把情怀，特别是当剧情进行到重回影子摩西岛，看到MGS1的故事地点在PS3上再现的时候，系类玩家都会为之感动。而且在最终和山猫决战时，好几个阶段的UI也是从1到4逐渐的变化，不得不说小岛这次真的是把情怀牌打到了极致。</p>
<h2 id="u4EBA_u7269_u4ECB_u7ECD"><a href="#u4EBA_u7269_u4ECB_u7ECD" class="headerlink" title="人物介绍"></a>人物介绍</h2><h3 id="u5F15_u9886_u8005_The_Boss"><a href="#u5F15_u9886_u8005_The_Boss" class="headerlink" title="引领者 The Boss"></a>引领者 The Boss</h3><p>事迹：二战时率领眼镜蛇部队加速结束战争/贞洁行动中做卧底假装背叛/食蛇者行动中死于BB手下</p>
<p>The Boss的一生是一段传奇，她最早是作为二战的眼镜蛇特种部队的队长为美国执行任务，但是在二战结束之后，她发现了这个世界的变化并不是她想象中的那样。虽然表面上战争结束了，但是 “哲学家”却开始了更加残酷的战斗，不仅仅世界四分五裂，连自己之前的部下也都各奔东西，甚至成为了敌人。而为国家一直战斗的The Boss最终被美国所抛弃，原本的间谍被当作叛徒，而亲手杀掉这个“叛徒”的人就是Snake，也就是之后的Big Boss。但是实际上，The Boss至死至终即使牺牲了自己的丈夫，离开了自己的儿子，都不曾背叛自己的国家，是一名伟大的爱国者。</p>
<p>但是在Snake看来，The Boss是自己的老师，她养育了Snake，教给了他知识与战斗的方式，但是他对The Boss更多的是爱，甚至超越了老师或者母亲。(EVA在MGS3领走的时候也说过：自己无法取代The Boss在Snake心中的地位。)所以在Snake击败The Boss之后，他获得了Big Boss的称号，同时也为了实现The Boss的理想走上了另一条道路。</p>
<blockquote>
<p>One must die and one must live. No victory, no defeat. The survivor will carry on the fight. It is our destiny… The one who survives will inherit the title of Boss. And the one who inherits the title of Boss will face an existence of endless battle.” ―The Boss to Naked Snake</p>
</blockquote>
<p>这是The Boss在最终决战的时候对Snake说的：“我们之间必须要死一个，不是为了胜利，也不会有失败，只是单纯的宿命罢了。胜者将会继承boss的名号而且之后也会带着它去面对无尽的战斗。”不得不说The Boss虽然本人只出现在了MGS3代，但是她给BB带来的影响才导致BB之后做的一连串事件，所以The Boss其实从开始一直贯穿到了全部故事的最后。</p>
<p>顺便一提在《和平行者》中，Peace Walker采用的AI就是The Boss，可以说是The Boss在一定意义上的复活，同时Peace Walker最后的自杀也表明着The Boss即使只留下一个思想，也不会背叛自己的祖国。</p>
<h3 id="Big_Boss"><a href="#Big_Boss" class="headerlink" title="Big Boss"></a>Big Boss</h3><p>事迹：食蛇者行动杀掉The Boss，成为Big Boss/成立爱国者组织/创立猎狐犬小队/创立无国界军队/创立世外天国</p>
<p>Big Boss的故事在之前的作品介绍中我们应该都能了解很多了。他是一个连国家都会害怕其力量的战士，Big Boss的一生到底去过哪些地方参加过多少战争已经很难统计了，但是可以确定的是，对于Big Boss，几乎没有不可能完成的任务。BB在3代食蛇者任务完成之后加入了爱国者组织。但是BB的思想其实一直离不开战斗，或者说BB就是一个天生的战士，最终他还是离开了组织，选择自己作为一个战士打开新的道路。</p>
<blockquote>
<p>We have no nation, no philosophy, no ideology. We go where we’re needed, fighting not for country, not for government, but for ourselves. We need no reason to fight. We fight because we are needed. We will be the deterrent for those with no other recourse. We are soldiers without borders, our purpose defined by the era we live in.</p>
</blockquote>
<p>BB的这句话诠释了自己——</p>
<p>“我们不属于任何国家，我们也不会为了任何国家或者政府而战斗。战斗的理由只因为我们自己需要而已。我们是不受国界约束的战士，我们生存的地方要由自己决定。”</p>
<p>当然这种思想也直接导致他后来建立世外天国打算用武力来实现The Boss世界统一的理想。而Big Boss也败在了自己的“儿子”——SS手上。在4代的结尾，年近80的BB已经彻底看开了这一切选择了离开这个世界。</p>
<blockquote>
<p>This is good… Isn’t it?</p>
</blockquote>
<p>这是他的最后一句台词。战斗了一生的Big Boss，这样安静的离开才是最好的结局吧。</p>
<h3 id="Solid_Snake"><a href="#Solid_Snake" class="headerlink" title="Solid Snake"></a>Solid Snake</h3><p>事迹：打败Big Boss，成功化解世外天国危机与桑给巴尔岛危机/化解影子摩西岛事件，打败Liquid/成立反MG组织/协助了MGS2中雷电的行动/打败山猫，破坏爱国者电脑</p>
<p>SS的故事同样是一段传奇，他曾数次将世界从危机之中拯救出来。他打败了自己的“好朋友”，“兄弟”甚至是“父亲”。和Big Boss不一样，SS并不喜欢战斗，相反，他在完成任务之后会选择隐居。但是作为一个战士，他也是无可挑剔的;不过作为一个人，他有一些可悲，SS本身就是为了当作一个战士而克隆出来的，而且当初克隆时为了防止BIG BOSS的基因外流(比如Solid Snake被敌人捕获，克隆出新的BIG BOSS样的战士)而特意设计出会让SS快速老化，所以在经历一定年限之后就会开始迅速老化，是不可遏制的，这些应该已经写进Snake的DNA，无法改变。</p>
<p>而且SS的体内还被注射了死狐病毒这一颗炸弹，他快速老化的身体环境还改变了旧的FOXDIE病毒，有可能传染给非特定基因人群，将成为生物武器。所以他身边人其实是被自己的病毒感染致死。不过在MGS4的最后，SS在和BB对话完了之后放弃了自杀选择在剩下的时间之内周游世界。这样的故事对于SS的一生，也算了令人满意的结局了。</p>
<h3 id="Liquid_Snake"><a href="#Liquid_Snake" class="headerlink" title="Liquid Snake"></a>Liquid Snake</h3><p>事迹：BB的克隆体，SS的兄弟，优质基因继承者/率领猎狐犬小队叛变，实施影子摩西岛事件/借山猫“复活”</p>
<p>Liquid是一个天才，因为他继承了BB的优质基因，所以无论是战斗力还是策略能力都在他的“孪蛇”兄弟SS之上。同时，他实施的影子摩西岛事件也成为了MGS走向的一个巨大转折点。但是这样一个天才，却因为对自己能力的不自信而认为SS才是优质基因继承者，于是他开始嫉妒又憎恨自己的兄弟。在MGS1故事的最后几场战斗，Liquid意外的都输给了SS，虽然在最后关头SS翻车被Liquid找到机会，但是他自己却被死狐病毒感染致死，也就是最终他也不知道其实自己并不是天生比SS弱，自己会输真的是因为基因无法决定命运。Liquid虽然就这么退场了，但是他告诉了SS的身世，幕后的几个黑手也都浮出水面。在《合金装备索利德5：幻痛》的预告片中，我们能看到一个叫做Eli的小男孩，从各方面看来他和Liquid真的是非常相似。同时还有一对双胞胎似的少年，下面写了魔童计划，相信《幻痛》会对这对孪蛇的这段时期有一个交代吧。</p>
<h3 id="Ocelot"><a href="#Ocelot" class="headerlink" title="Ocelot"></a>Ocelot</h3><p>事迹：创建爱国者组织/怂恿Liquid策划影子摩西岛事件/夺取REX设计图并买到黑市/怂恿Solidus Snake开始行动/用Liquid的人格骗过爱国者同时摧毁了爱国者电脑</p>
<p><img src="/images/14576382123468.jpg" alt="Ocelot"></p>
<p>山猫的父亲是The Sorrow(MGS3中出现过他的亡灵)，母亲就是The Boss。如果说BB或者SS是天生的超级战士的话，那么山猫就是天生的完美间谍，简单梳理一下山猫的一生：最早出生的时候就被 “哲学家”组织带走用来当作人质控制The Boss(实际上山猫不知道自己的父母是谁)，之后山猫就由“哲学家”培养成一名间谍安插在当时的CIA身边，而CIA又把他派去苏联在Volgin将军手下当间谍。所以单单在MGS3中，山猫就是一名双面间谍。</p>
<p>随后山猫在MGS3的最后拿到了那笔“哲学家的遗产”，创建了“爱国者”。故事就进行到了MGS1，山猫有作为间谍安插在当时的美国总统Solidus Snake身边，而Solidus Snake却不知道山猫其实就是一直控制自己的爱国者，Solidus Snake又将山猫派去Liquid身边当间谍，主要目的就是怂恿Liquid叛变，试验一下人类能否反抗爱国者。所以说Liquid自己也不过就是一个被利用的棋子罢了。在 MGS1的最后，山猫拿走了REX的设计图，同时之后移植的Liquid的右手之后形成的Liquid人格也成为了他反抗爱国者计划的重要的一环。</p>
<p>在MGS2中，山猫一开始夺取了RAY的原型机(油轮篇的剧情)，假装在Solidus手下帮他做事，实际上他是爱国者安排在Solidus身边收集集S3计划数据的人选。当收集数据的目标完成后，他主动坦白自己其实是爱国者的间谍，如今目的已经达成了。随后他变成Liquid的人格驾驶着原型机RAY逃离了战舰。</p>
<p>山猫组建PMC，同时开始了他最后一段间谍生涯——成为自己的间谍，破坏爱国者。山猫知道爱国者知道自己的想法，想要骗过它就必须骗过自己，于是Liquid，这个通过心理暗示出现的人格成功的骗了自己，也骗了爱国者。等于说是山猫实现了当时The Boss的理想，而最终败在自己一直追赶的偶像——Big Boss的克隆体手上，最后那一句：“You’re pretty good。”也代表着山猫和Snake家族这50多年的恩怨终于了结。</p>
<h3 id="Zero"><a href="#Zero" class="headerlink" title="Zero"></a>Zero</h3><p><img src="/images/14576381904423.jpg" alt="Zero"></p>
<p>事迹：建立“爱国者”组织</p>
<p>Zero其实没有在任何一代游戏之中作为主要人物出场，他一直处在一个幕后的位置，但是他所做的一切，在MGS系列中都有举足轻重的地位。首次登场就是在MGS3，他当时只是一个负责传达命令的配角，和其他人一样，Zero也不过是一个行动代号罢了，而且他还有一个很重要的外号，叫做Cipher(也有零的含义)。</p>
<p>在MGS3的最后，山猫拿到“哲学家遗产”之后就和Zero一起创建了爱国者组织，是爱国者的创始人之一。起初他们的目的就是利用手上的这笔财产实现The Boss当时世界统一的理想，但是之后他和Big Boss之间的理念产生了重大分歧(具体内容可以查看爱国者和魔童计划)，在Big Boss走后Zero变得非常恐惧，他非常害怕这样强大的Big Boss会与自己做对，于是魔童计划的产物孪蛇和solidus出现了。Zero也在bb的身边安插了间谍Paz(《和平行者》中的故事)，在Paz失败之后Zero开始专心着手爱国者AI的研究(期间的空白期5代可能会补充。)，在自己老了之后依靠着生命维持装置苟延残喘，最终被Big Boss拔掉了氧气管死亡。</p>
<h3 id="Paz"><a href="#Paz" class="headerlink" title="Paz"></a>Paz</h3><p>事迹：《和平行者》中BB身边的间谍，《原爆点》中BB需要解救的人质，疑似在《幻痛》之中的死而复生的神秘人物</p>
<p><img src="/images/14576382767731.jpg" alt="Paz"></p>
<p>Paz是Cipher安排在bb身边的间谍，她一开始说自己只有16岁，是一名大学生，当然这些都是伪造的，目的就是夺取MG，杀掉bb。但是这样一个看起来狡猾狠毒的间谍，随着故事的进行却渐渐的被BB一行人所改变。特别是在《和平行者》的后面，部队要举行聚会活动，士兵们都要求Paz上去唱歌，作为一个间谍大可不去理会，但是Paz心理却想先放下任务，去和大家一起庆祝。</p>
<blockquote>
<p>Paz：“士兵们也都很期待.事到如今也无法拒绝了。”<br>Paz：“虽然我没有在人前唱过歌.但是像这样被期待著感觉也不坏。”<br>Paz：“只少我敢保证唱的一定比米穆好。”<br>Paz：“可是ZEKE的改造已经完成了.我必须要达成我的使命不可了。”<br>Paz：“要是背叛了CIPHER.一定会让我尝到比死还恐怖的绝望吧。”<br>Paz：“可是。”<br>Paz：“应该也不是马上就得实施计画不可吧。”<br>Paz：“稍微晚一点实行应该也不是问题吧。”<br>Paz：“难得的和平日…只少等到那天应该没关系吧。”<br>Paz：“说不定.是我自己把问题给快转了也说不定。”<br>Paz：“到了那一天.不管怎麼样我跟Snake一定有一方会死。”<br>Paz：“就算这样…”<br>Paz：“只少在和平之日来临之前.先想办法瞒住CIPHER。”<br>Paz：“不知为何我开始想著这样的事….”</p>
</blockquote>
<p>这是在《和平行者》中Paz的录音记录，可以看出她并不是一个单纯甘心被利用的“机器”。之后，Paz掉入海中，被渔民救起却被XOF部队抓走进行虐待(《原爆点》剧情)。</p>
<h3 id="Chico"><a href="#Chico" class="headerlink" title="Chico"></a>Chico</h3><p><img src="/images/14576384343657.jpg" alt="Chico"></p>
<p>Chico是哥斯达黎加民间反抗组织——Sandinista National Liberation Front的一个少年兵，他有一个父亲，一个姐姐，他的父亲就是这个组织的首领，Chico算是这个组织里面的小少爷。可是之后他的父亲战死，组织的领导就落到了他的姐姐头上。而Chico一直想成为一名独当一面的战士，就像bb那样，于是乎他和姐姐率领这组织一同加入了bb的无国界军队。在军队之中，Chico看到了Paz并且对她一见钟情，当Paz坠海之后，大家都以为她死了。但是随后有人给军队放出消息称Paz没死，在我们手上做人质。Chico听到决定就独自一人触发营救Paz，结果就是《原爆点》的剧情，自己被俘虏还被虐待，最终还当了叛徒告诉了BB基地的所在位置，导致XOF部队能如此快速的对BB进行打击。故事的最后并没有给Chico一个具体的交代，看来只有在《幻痛》中才能知道这个少年的结局了。</p>
<h3 id="Kazuhira_Miller"><a href="#Kazuhira_Miller" class="headerlink" title="Kazuhira Miller"></a>Kazuhira Miller</h3><p>事迹：和BB一同管理无国界军队，一起战斗</p>
<p><img src="/images/14576384591948.jpg" alt="Kazuhira Miller"></p>
<p>Miller其实是在二战期间一位美国将军与一位日本女人生的孩子，在Miller长大之后他的母亲就去世了，他选择了加入日本自卫队保护国家，维护和平，他的名字中的Kazuhira其实就是和平的意思。但是Miller在做了一段之后发现日本自卫队并不能有他心理那种维护和平的感觉，于是他选择离开日本加入佣兵部队。在一次行动中他遇上了BB的小队，结果自己部队被全灭，他想使用手雷和BB同归于尽，但是却被BB救了。从此之后他就死心塌地一直跟随BB成立无国界军队，而自己在军队中处于一个管家的地位，负责后方为bb提供支援。</p>
<p>值得一提的是Miller非常喜欢美女，因为他总是和部队里面的女性扯出一些关系，BB还揍过他。但是在原爆点的最后，基地被炸毁无国界军队随之消失，他和BB之后的故事就只能期待《幻痛》了。</p>
<p>对于他的死其实并没有交代的特别清楚，在MGS2中，会有一名自称Miller的教官一直为你提供情报，关于这个教官官方的设定是：曾在日本陆上自卫队、SAS、陆军特殊部队军団、美国海军陆战队服役，还和Big Boss两度合作成立和经营佣兵组织，最后成为了Foxhound的教官。当时被称为“鬼教官”，队员们对他极为尊敬故称他为“Master Miller”。现在已辞退了教官之职，在阿拉斯加与大自然一起生活。</p>
<p>但是在最后Liquid告诉你那个Miller其实被自己干掉了，也就是说当年那个Miller其实死在了Liquid手下。</p>
<h3 id="Huey"><a href="#Huey" class="headerlink" title="Huey"></a>Huey</h3><p>事迹：开发Peace Walker/协助bb和无国界军队/“背叛”BB导致基地毁灭</p>
<p><img src="/images/14576385384049.jpg" alt="Huey"></p>
<p>Huey有2个很有名的孩子——其中一个就是Otacon，两者长的真的是一模一样，性格也是;还有一个就是Emma，也就是MGS2中制作病毒摧毁爱国者GW的那个妹子。Huey是一名MG的开发人员，Peace Walker就是他和奇爱博士一同开发完成的(他负责机械，奇爱负责AI。)，但是做出Peace Walker并不是他的本愿，他被寇曼所欺骗，认为制作这台机器的原因是为了保护和平。这一点和他儿子Otacon非常相似——都是天真的科学宅。Huey在知道和平行者要发射核弹之后毅然决然的离开了寇曼投奔BB，开始为BB做技术支援，之后也就有了《原爆点》的剧情。但是Huey不知为何私自答应一个所谓的“世界核武器检查”的组织的要求，同意他们来到基地。在这之后基地就被敌人袭击导致毁灭，Huey也被当作叛徒。从《幻痛》的预告来看，其中会有审讯Huey的情节，看来Huey叛变的原因也只能在幻痛中揭晓了。</p>
<h3 id="Punished__u201CVenom_u201D_Snake"><a href="#Punished__u201CVenom_u201D_Snake" class="headerlink" title="Punished “Venom” Snake"></a>Punished “Venom” Snake</h3><p>Venom是以Big Boss之名而存在，却实则并非Big Boss。真实且原先的身份是The Medic，即《潜龙谍影5：原爆点》负责在直升机紧急治疗Paz的医疗兵。根据判断，The Medic很可能是由Kiefer Sutherland配音，而真正的Big Boss仍由David Hayter负责。</p>
<p>The Medic最初是以普通士兵加入Big Boss创建的Militaires Sans Frontières军事无国界组织，并随后成为了Big Boss最为信任的人之一。由于声音的相似，因而成为Big Boss替身的最好选择，并最终在医院完成整容手术。</p>
<p>通过观察The Medic在《潜龙谍影5：原爆点》的直升机爆炸瞬间，可以发现其为保护Big Boss而所处的身位，导致其头部留有金属残片。通过完成任务46，可以发现真正的Big Boss的面部并无金属残片或明显伤痕。</p>
<p>The Medic接受过Eli的DNA测试，却发现与Big Boss的不符。且在随后Huey，Quiet，Liquid Snake都有质疑表现。</p>
<h3 id="Skull_face"><a href="#Skull_face" class="headerlink" title="Skull face"></a>Skull face</h3><p>Skullface是《潜龙谍影5》事件的元凶。其生于匈牙利，父母工作于秘密兵工厂，却皆遭炸弹袭击而受伤。</p>
<p>由于伤情严重且治疗有限，在基本遭到放弃的情况下，终因最新的寄生疗法而存货。然而，这种疗法的副作用影响了他的身理系统，使其不再能感到疼痛。</p>
<p>Skullface随后得到Zero的招募并成立XOF来监控Big Boss来预防其重要任务成功，注入《潜龙谍影3》的噬蛇者行动。多年为Zero工作并监视Big Boss，使其对两人感到愤怒，尤其是Zero。于是，他在1975年通过袭击Big Boss基地并在Paz体内安装炸弹谋求杀死Big Boss。</p>
<p>在其发现Zero与Dr. Strangelove正在研发爱国者AI智能，他便只做了一种寄生感染，能使人类喉咙病变而失声。这种寄生虫由Code Talker研发，也有解药却不愿公开。《潜龙谍影3》的眼镜蛇小队也是寄生感染技术的试验品。</p>
<p>根据《潜龙谍影5：原爆点》最后，Skullface根据Paz所透露的情报，使Zero感染该病毒病逐渐成为植物人状态。而Skullface更想通过ST-84 Metal Gear来传播。</p>
<p>在最后所有计划即将完成之际，The Third Child在Mantis发现Liquid Snake出现在XOF直升机之后，而发怒与Skullface决裂。Skullface因ST-84 Metal Gear受困，而Big Boss和Miller决定弃他而去使其受苦而死，但Hery无视他们的想法而最终杀死了Skullface。</p>
<h3 id="Quiet__u9759_u9759"><a href="#Quiet__u9759_u9759" class="headerlink" title="Quiet 静静"></a>Quiet 静静</h3><p>Quiet便是在医院袭击Big Boss和Venom的女性。因Big Boss的反击而受到重伤，但其特殊能力因寄生治疗而增强。</p>
<p>她的听力是普通士兵的10倍，且视力不受日夜交替影响，但却携带着导致失声的病变寄生源。其肌肤可以通过洗澡或雨水吸收水分，也是其体内寄生虫的影响。然而，水会对Quiet的特殊能力有所削弱。</p>
<p>在通过招募之后，其将会在任务43之后离队。在主要任务全部完成之后，Venom会在一个次要任务寻找其踪迹。在逃脱时，Venom被毒蛇所咬伤。Quiet必须不再沉默并说出实情，来解救Venom。但在最后，她仍然会独自消失于沙漠之中……</p>
<h3 id="Man_on_Fire"><a href="#Man_on_Fire" class="headerlink" title="Man on Fire"></a>Man on Fire</h3><p>The Man on Fire火男，即是《潜龙谍影3》的Volgin，现为The Third Child进行着精神控制。在与Big Boss对决后，Volgin仍然存活却呈脑死状态，其想要向Big Boss复仇的执念使其成为一个恶魔而存在，并被俄罗斯医生作为科学研究而供养。</p>
<p><img src="/images/14576392498262.jpg" alt="Man on Fire"></p>
<p>Venom在随后回收其身体并保存在基地，但因ST-84 Metal Gear袭击而损毁。  </p>
<h2 id="u540D_u8BCD_u89E3_u91CA"><a href="#u540D_u8BCD_u89E3_u91CA" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="u9B54_u7AE5_u8BA1_u5212"><a href="#u9B54_u7AE5_u8BA1_u5212" class="headerlink" title="魔童计划"></a>魔童计划</h3><p>魔童计划【Les Enfants Terribles(法文)/恐るべき子供たち】是由美国政府在20世纪70年代早期着手进行的一项试验，目的是通过基因克隆等手段，制造出更多像Big Boss这样的超级战士。值得一提的是这项计划的赞助者就是爱国者组织的领导——Zero，提供医学技术支持的是Dr. Clark，也是爱国者组织中的一员。在1972年，Zero等人通过提取了Big Boss的基因，再将Eva当作母体的方式成功制作出了2个克隆人。不过其实当时有8个成功的受精卵，但是为了做出最强的而消灭掉了6个来全力强化剩下的那2个。</p>
<p>但是Big Boss在知道这件事后，他愤怒的离开了爱国者组织。最终9个月后，Eva成功产出了2个婴儿，由于他们2个都是用Snake的基因制作出的，所以被称为“Twin Snakes(孪蛇)”。这2个也就是日后我们熟知的Liquid Snake和Solid Snake。而且因为Big Boss的离开，Zero也开始变得不再信任其他人，于是他将孪蛇当作爱国者组织的保险，以防Big Boss将来会与他为敌。随后不久，魔童计划又制作出了一名新蛇，不同于之前的SS和LS，他的名字既不是固体也不是液态，而是Solidus Snake。Solidus Snake是一个完美的克隆体，他不像之前的孪蛇一样分别继承了隐性和显性，而是完美的继承优良基因，所以他也会被爱国者选中成为美国总统。不过魔童计划也在Solidus Snake制作出之后就彻底终结了。所以Solidus可以说是魔童计划的最后一个也是最完美的产物。</p>
<h3 id="u7231_u56FD_u8005"><a href="#u7231_u56FD_u8005" class="headerlink" title="爱国者"></a>爱国者</h3><p>爱国者(The Patriots)最早是由一个当时在MGS3食蛇者行动之中存活下来的人们建立的一个可以控制世界军事，政治和经济形式的一个强大组织，成员有：Zero、Big Boss、Eva、Ocelot、 Sigint(技师，日后的机械忍者骨骼就是他所开发的)、Para-Medic(医生，研究死狐病毒，实行魔童计划的人物)。而让组织运作的资金就是3代最终山猫拿到的那份哲学家的遗产(Philosophers’ Legacy) 。哲学家(或称作“贤人”)是在二战结束之后世界各地的强大领导者聚集在一起形成的一个组织，但是随着世界格局的变化这个组织最终瓦解，但是却留下了一笔非常惊人的财富，也就是这份遗产。在3 代后，山猫拿着这份钱找到了Zero想要建立起一个组织来实现The Boss的理想，同时也极力推荐Big Boss等人的加入，最终这6人也就形成了最早的爱国者组织。</p>
<p>但是这样一个组织没有团结太久，Big Boss和Zero对The Boss的理念有着不同的看法，BB认为应当放任自由，但是不会放弃武力约束;Zero认为应当集权统治，独裁才能统一。最终再加上BB发现了Zero暗地里对自己做的魔童计划，终于分道扬镳。而BB在之后建立了世外天国的武装国家，Zero过于害怕BB的力量于是策划了桑吉巴尔岛事件，利用自己制作的Solid Snake干掉了BB。但是随着Zero的日益老去，再加上爱国者组织的成员不断减少而且Zero也没有增添新的成员，于是他决定利用人工智能电脑来辅佐爱国者的运作。不过随着时间的推移，Zero对AI的约束管理越来越少，再加上拥有高智能和全球人类数据的爱国者电脑不断的进化，结果就是AI自己制作出了一套引领人类进步的系统，也就是MGS4中提到的爱国者之子系统，通过纳米机器人控制人类的情绪，打算自己统领人类。而他对计划的测试就是整个2代的故事，最终在4代里，利用FOX ALIVE病毒才彻底消灭了爱国者。</p>
<p>顺带一提Patriots为了封闭信息，人体内的NANOMACHINE(纳米机器)在本体要说出爱国者这个词的时候会将其转变为LA LI LU LE LO……这也就是为什么在2代的时候，总会听到LA LI LU LE LO的原因。</p>
<h3 id="u6B7B_u72D0_u75C5_u6BD2"><a href="#u6B7B_u72D0_u75C5_u6BD2" class="headerlink" title="死狐病毒"></a>死狐病毒</h3><p>FOXDIE病毒能致死特定基因的人，影子摩西岛事件时被NAOMI注射入Snake身体的FOXDIE对应Liquid Snake\Kenneth Baker以及叛变的FOXHOUND成员，当年实际被FOXDIE致死的人只有Liquid Snake 、Kenneth Baker和Decoy Octopus。这一点，我们在MGS1的故事中都已经说了一些，但是死狐病毒不单单只会对特定人造成致命威胁，还有新的死狐病毒。</p>
<p>新的FOXDIE和FOXALIVE不同，后者是对爱国者的AI系统的，前者是爱国者研制出来由DREBIN893注射到Snake体内，他将FOXDIE的指向人群转为ZERO、BIG BOSS、LIQUID Ocelot、BIG MAMA以及当初发明死狐病毒的Namoi。新的FOXDIE病毒和旧的FOXDIE混合发生变异，DREBIN注射之后其实Snake不会成为生物武器了，所以他无需自杀，BIG BOSS出面告诉他，他才得知。但是他的身体也仍然在急速老化，剩下的时间不多了，因为不能繁衍后代，他将和Otacon、Sunny一起见证自己的存在。</p>
<p>DREBIN是很多人的总称，是战场上的洗枪者。DREBIN893是游戏中的人物，是孤儿，先被爱国者收养，后被反抗组织俘虏并为组织训练为洗枪者，893是一个代号而已。实际上他一直是接受爱国者的命令的。是爱国者特意安排他接近Snake，帮助Snake洗枪，并将新的死狐病毒混合在最新的纳米机器中注射入Snake体内。</p>
<h3 id="S3_u8BA1_u5212"><a href="#S3_u8BA1_u5212" class="headerlink" title="S3计划"></a>S3计划</h3><p>S3计划是由爱国者在MGS2中实施的一个计划，S3有2层含义：</p>
<p>表：“Solid Snake Simulation(模拟Solid Snake)”，即重现MGS1中影子摩西岛的事件，从而找到能再现像当年像SS一样的超级战士。所以之前也说MGS2中整个事件为什么和影子摩西岛那么相似，比如：</p>
<ul>
<li>Raiden ⇔ Snake (主角)</li>
<li>AI上校 ⇔ Roy Campbell上校 (任务指挥官)</li>
<li>伪装成石油分解平台的Big Shell ⇔ 伪装为核废弃储存设施的影子摩西 (背景舞台)</li>
<li>特工Richard Ames ⇔ DARPA局长Donald Anderson (第一个死于“心脏病”的人质)</li>
<li>总统James Johnson ⇔ Arms军工总裁Kenneth Baker (第二个死亡的人质)</li>
<li>Olga Gurlukovich/Mr X ⇔ Gray Fox/Deepthroat (机械忍者)</li>
<li>Emma Emmerich = Sniper Wolf (与Otacon相关且死去的女人)</li>
<li>目击Emma被Vamp刺中 ⇔ 目击Meryl被Wolf击中 (看见女孩受伤却爱莫能助的情况)</li>
<li>Solidus Snake ⇔ Liquid Snake (最终Boss与主角都有亲人般的联系)</li>
<li>电脑病毒 ⇔ 死狐病毒</li>
</ul>
<p>而S3的深层含义则是：“Selection for Societal Sanity(社会健全选择)/社会の思想的健全化のための淘汰”，说白了就是爱国者想要测试在MGS2那种高强度危机事件下，能否靠自己控制住人类的情绪，如果可以，那么之后就不会再担心会再有人反抗自己了。MGS2的那么多牺牲其实就是爱国者的一个实验罢了。S3的过程除了ss和Otacon真的出现之外堪称完美，而且就结果而言，爱国者成功的得到了它想要的结果，这也为MGS4中的事件打下了基础。</p>
<h3 id="Metal_Gear-1"><a href="#Metal_Gear-1" class="headerlink" title="Metal Gear"></a>Metal Gear</h3><p>游戏中的MG其实一种超级武器。其实最早的设计理念仅仅是开发“可移动型核战车”，随之就出现了2条分支，一种以履带驱动，一种是双足站立。其实最初和MG相关的故事就是在MGS3中，一开始的贞洁行动要去拯救的那位科学家索科洛夫(Sokolov)就是在研究可移动型核战车，也就是3代中的BOSS——峡谷虎(Shagohod)，Shagohod采用的是履带行动而非双足，所以在Shagohod战败之后也就舍弃了履带驱动这个分支，之后选择的都是双足站立的MG。</p>
<p>这里额外需要注明一下的就是Shagohod其实并不是MG，Shagohod和MG其实是以“可移动型核战车”为开发理念制作的不同分支，当然也不存在什么原型机一说。</p>
<p>在《合金装备》中有大大小小各种各样的Metal Gear，大到MGS2中的巨型战舰，小到量产型的月光(Gecko)。但是有3种Metal Gear是非常具有代表性的，分别是ZEKE，REX，RAY。</p>
<p>Metal Gear ZEKE，首次出场：《合金装备索利德：和平行者》</p>
<p><img src="/images/14576377622940.jpg" alt="Metal Gear ZEKE"></p>
<p>ZEKE最早是由BB下达指示，让huey着手开发的一台Metal Gear，其最开始的目的只是单纯的作业用辅助机器，但是在经理了和平行者中的事件之后，获得了Peace Walker(和平行者中出现的一台MG)的部分零件，再加上考虑到自己的部队可能也会需要这样的战斗力，于是将其改造成了一台战斗用MG，但是依旧是由AI控制。但是Paz在之后偷走了ZEKE并且将它改造成了人工驾驶，在游戏的最后和BB展开了对决。不过最终即使拥有众多强大武器的ZEKE也没有战胜BB，Paz也随着爆炸掉入海中结果被人俘虏，之后就是《合金装备索利德5：原爆点》的剧情了。</p>
<p>Metal Gear REX，首次出场：《合金装备索利德》</p>
<p><img src="/images/14576377952638.jpg" alt="Metal Gear REX"></p>
<p>REX虽然不是最早的，但是可能是最有名的一台MG。REX是由DARPA(美国国防部先进研究项目局)进行开发，之后在影子摩西岛进行轨道炮演习的时候被叛变的猎狐犬小队夺取，也就是MGS1代中的影子摩西岛事件。值得一提的是REX的主要开发人员就是Otacon，但是他是在不知情的情况下开发的，因为当时上面告诉他这个兵器的目的是为了反导弹，保证核安全，结果最后才知道自己被忽悠了，不过这也让Otacon决定之后走上的反MG道路。</p>
<p>REX的造型非常霸气，而是是第一个以3D形式呈现的MG，当然不仅仅是外表，REX的实力也不容小觑。它厚实的装甲可以抵御反坦克导弹的攻击，同时强大的机动性可以在打击之后快速撤离。最重要的是REX搭载的电磁轨道炮，如果利用其发射核弹的话完全不会被提前侦测到。最终在MGS1结束之时，山猫将REX的设计图偷走并在黑市上售卖，这直接引起了MG的量产，同时也为新一代MG做了准备。</p>
<p>Metal Gear RAY，首次出场：《合金装备索利德2：自由之子》</p>
<p><img src="/images/14576378455276.jpg" alt="Metal Gear RAY"></p>
<p>RAY可以当作是REX的一种进化，甚至可以说RAY的制作目的就是为了破坏REX。RAY在造型上仅仅继承了双足站立这一特点，其余都有非常大的进步。最明显的就是它那1对翅膀，这对翅膀可以帮助 RAY在水下推进，所以RAY是一种水路两栖用MG。RAY的武装也更加强大，它配置了水刀(高压水流切割装置)，威力几乎和激光剑等同，同时它还有标准的机枪和火箭发射器。而且RAY的机械部分采用了生物组织，不仅可以在受伤时分泌出粘性物质自我修复，机动力更是大幅度提高。所以RAY在2,4,乃至最后的《合金装备崛起：复仇》中都充当了相当重要的地位。</p>
<p>在MGS2中，RAY有一台原型机和数台量产机，但是量产机的实力很差，都被雷电全部摆平，最终山猫驾驶着原型机脱离了战场，同时在4代中，有着SS驾驶REX和山猫驾驶的RAY对战的场面，虽然就两者的性能而言剧情设定有些勉强但是还是REX获得了胜利。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.gamersky.com/handbook/201511/680245.shtml" target="_blank" rel="external">《合金装备》系列历史剧情 合金装备全系列历史剧情揭秘</a></li>
<li><a href="http://www.gamersky.com/handbook/201508/657226.shtml" target="_blank" rel="external">《合金装备》全系列回顾 合金装备全系列剧情回顾及人物介绍</a></li>
<li><a href="/"></a></li>
<li></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果说这个世界上有第二个系列像 EVA 一样让我如痴如醉的话，那么肯定是 MGS 系列。在玩『潜龙谍影5：幻痛』的时候，每一段磁带（包含大量重要剧情信息）都认真听过之后，对于整个系列的剧情有了大概的认知。这篇文章会比较长，综合了网上的各种资料和我自己的理解，希望能给大家带来一个比较完整的阅读体验。</p>]]>
    
    </summary>
    
      <category term="BigBOSS" scheme="http://wdxtub.com/tags/BigBOSS/"/>
    
      <category term="Quiet" scheme="http://wdxtub.com/tags/Quiet/"/>
    
      <category term="Snake" scheme="http://wdxtub.com/tags/Snake/"/>
    
      <category term="合金装备" scheme="http://wdxtub.com/tags/%E5%90%88%E9%87%91%E8%A3%85%E5%A4%87/"/>
    
      <category term="幻痛" scheme="http://wdxtub.com/tags/%E5%B9%BB%E7%97%9B/"/>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 习题课 5 Shelllab]]></title>
    <link href="http://wdxtub.com/2016/03/08/csapp-lab5/"/>
    <id>http://wdxtub.com/2016/03/08/csapp-lab5/</id>
    <published>2016-03-08T18:47:44.000Z</published>
    <updated>2016-03-10T00:41:08.000Z</updated>
    <content type="html"><![CDATA[<p>这次的作业，我们需要自己完成一个简单的 shell 程序，通过具体的实现，我们可以更加深入地计算机运行的机制（尤其是 Exceptional Control Flow 和进程）。</p>
<a id="more"></a>
<hr>
<p>在具体开始这次的试验之前，最好先复习一下基本概念（具体的细节可以参考前面的几课），这里放在文末的附录中。</p>
<p>这次的任务不简单！但是老师提供了很多辅助函数，确定先读懂已有代码再开始（注意代码风格），需要仔细查看的 man pages：</p>
<ul>
<li><code>sigemptyset()</code></li>
<li><code>sigaddset()</code></li>
<li><code>sigprocmask()</code></li>
<li><code>sigsuspend()</code></li>
<li><code>waitpid()</code></li>
<li><code>open()</code></li>
<li><code>dup2()</code></li>
<li><code>setpgid()</code></li>
<li><code>kill()</code></li>
</ul>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>先把文件上传到学校的机器中 <code>scp tshlab-handout.tar dawang@shark.ics.cs.cmu.edu:~/513</code>，然后登录上去 <code>ssh -X dawang@shark.ics.cs.cmu.edu</code>，登录成功后解压 <code>tar xvf tshlab-handout.tar</code></p>
<p>因为我比较习惯在本地写代码，所以把文件复制回来：</p>
<ul>
<li>服务器至本地<ul>
<li><code>scp -r dawang@shark.ics.cs.cmu.edu:~/513/tshlab-handout/* ./</code></li>
</ul>
</li>
<li>本地至服务器<ul>
<li><code>scp ./tsh.c dawang@shark.ics.cs.cmu.edu:~/513/tshlab-handout/</code></li>
</ul>
</li>
</ul>
<p>然后需要在 <code>tsh.c</code> 中填写 Andrew ID，这个文件中已经包含了一个基本的 shell 程序，但是还有很多东西没有完成，我们的任务是补全下列空函数：</p>
<ul>
<li><code>void eval(char *cmdline)</code>：解析命令与执行，约 300 行</li>
<li><code>void sigchld_handler(int sig)</code>：捕获 SIGCHLD 信号</li>
<li><code>void sigtstp_handler(int sig)</code>：捕获 SIGTSTP(ctrl-z) 信号</li>
<li><code>void sigint_handler(int sig)</code>：捕获 SIGINT(ctrl-c) 信号</li>
</ul>
<p>测试的时候先 <code>make</code> 然后 <code>./tsh</code> 即可，不过一开始好像没办法退出</p>
<h2 id="Shell__u7B80_u4ECB"><a href="#Shell__u7B80_u4ECB" class="headerlink" title="Shell 简介"></a>Shell 简介</h2><p>简单来说，shell 有两种执行模式：</p>
<ol>
<li>如果用户输入的命令是内置命令，那么 shell 会直接在当前进程执行（例如 <code>jobs</code>）</li>
<li>如果用户输入的是一个可执行程序的路径，那么 shell 会 fork 出一个新进程，并且在这个子进程中执行该程序（例如 <code>/bin/ls -l -d</code>）</li>
</ol>
<p>第二种情况中，每个子进程称为一个 job（当然也可以不止一个，通过管道机制，不过我们这里的实现不需要考虑管道）</p>
<p>如果命令以 <code>&amp;</code> 结束，那么这个 job 会在后台执行（比如 <code>/bin/ls -l -d &amp;</code>），也就是说 shell 本身不会等待 job 执行完成，直接可以继续输入其他命令；而在其他情况下，则是在前台运行，shell 会等待 job 完成，用户才可以继续输入命令。也就是说同一个时间只可能有一个前台任务，但是后台任务可以有任意多个。</p>
<p>程序的入口是 <code>int main(int argc, char *argv[])</code>，对于 <code>/bin/ls -l -d</code> 来说，我们有：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">argc</span> == <span class="number">3</span></span><br><span class="line"><span class="built_in">argv</span>[<span class="number">0</span>] == <span class="string">''</span>/bin/<span class="keyword">ls</span><span class="string">''</span></span><br><span class="line"><span class="built_in">argv</span>[<span class="number">1</span>] == <span class="string">''</span>-<span class="keyword">l</span><span class="string">''</span></span><br><span class="line"><span class="built_in">argv</span>[<span class="number">2</span>] == <span class="string">''</span>-<span class="keyword">d</span><span class="string">''</span></span><br></pre></td></tr></table></figure>
<p>另外两个需要支持功能是：</p>
<ul>
<li>job control：允许用户更改进程的前台/后台状态以及京城的状态(running, stopped, or terminated)<ul>
<li>ctrl-c 会触发 SIGINT 信号并发送给每个前台进程，默认的动作是终止该进程</li>
<li>ctrl-z 会触发 SIGTSTP 信号并发送给每个前台进程，默认的动作是挂起该进程，直到再收到 SIGCONT 信号才继续</li>
<li><code>jobs</code> 命令会列出正在执行和被挂起的后台任务</li>
<li><code>bg job</code> 命令可以让一个被挂起的后台任务继续执行</li>
<li><code>fg job</code> 命令可以让一个被挂起的前台任务继续执行</li>
</ul>
</li>
<li>I/O redirection：重定向输入输出<ul>
<li><code>tsh&gt; /bin/ls &gt; foo</code></li>
<li><code>tsh&gt; /bin/cat &lt; foo</code></li>
</ul>
</li>
</ul>
<h2 id="u4EFB_u52A1_u76EE_u6807"><a href="#u4EFB_u52A1_u76EE_u6807" class="headerlink" title="任务目标"></a>任务目标</h2><p>我们正在使用的 shell 其实包含很多复杂的功能，不过我们自己写的 shell 就简单很多，这里总结一下具体的实现规格：</p>
<ul>
<li>每一行会输出一个 <code>tsh&gt;</code>，然后等待用户输入</li>
<li>用户的输入包括 <code>name</code> 加上零个或多个参数，这些参数之间用一个或多个空格分隔。如果 <code>name</code> 是内置命令，那么直接执行，否则需要新建一个子进程，并在子进程中完成具体的工作</li>
<li>不需要支持管道，但是需要支持输入输出重定向，如 <code>tsh&gt; /bin/cat &lt; foo &gt; bar</code>（必须支持在同一行重定向输入以及输出）<ul>
<li>也需要支持内置命令的重定向，如 <code>tsh&gt; jobs &gt; foo</code> </li>
</ul>
</li>
<li>输入 <code>ctrl-c</code> 或 <code>ctrl-z</code> 会给当前的前台进程（包括其子进程）发送 SIGINT(SIGTSTP) 信号，如果没有前台任务，那么这俩信号没有任何效果</li>
<li>如果输入的命令以 <code>&amp;</code> 结尾，那么就要以后台任务的方式执行，否则按照前台执行</li>
<li>每个 job 都有其进程 ID(PID) 和 job ID(JID)，都是由 tsh 指定的正整数，JID 以 <code>%</code> 开头（如 <code>%5</code> 表示 JID 为 5，而 <code>5</code> 则表示 PID 为 5），这部分已提供了辅助函数</li>
<li>支持的内置命令有<ul>
<li><code>quit</code> 退出 shell</li>
<li><code>jobs</code> 列出所有的后台任务</li>
<li><code>bg job</code> 给后台 <code>job</code> 发送 SIGCONT 信号来继续执行该任务，具体的 <code>job</code> 数值可以是 PID 或 JID</li>
<li><code>fg job</code> 给前台 <code>job</code> 发送 SIGCONT 信号来继续执行该任务，具体的 <code>job</code> 数值可以是 PID 或 JID</li>
</ul>
</li>
<li>tsh 应该回收所有的僵尸进程，如果任何 job 因为接收了没有 catch 的信号而终止，tsh 应该识别出这个时间并且打印出 JID 和相关信号的信息</li>
</ul>
<h2 id="u6D4B_u8BD5_u65B9_u6CD5"><a href="#u6D4B_u8BD5_u65B9_u6CD5" class="headerlink" title="测试方法"></a>测试方法</h2><p>最简单（也是首先应该做的）是直接运行 tsh，然后输入命令试试看。如果需要参考，可以试试 <code>tshref</code> 这个程序。确定无误之后可以进行完整测试。</p>
<p>这里我们用 trace 文件来测试，具体使用命令 <code>./runtrace</code> 来测试，具体用法如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">./runtrace -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试某个特性</span></span><br><span class="line">./runtrace <span class="operator">-f</span> trace05.txt <span class="operator">-s</span> ./tsh</span><br></pre></td></tr></table></figure>
<p>如果想要进行完整的测试，可以使用 <code>./sdriver</code>，具体用法如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">./sdriver -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般来说可以直接使用默认设置测试</span></span><br><span class="line">./sdriver</span><br></pre></td></tr></table></figure>
<p>只需要提交 <code>tsh.c</code> 即可，系统会自动评分，具体每个文件在测试的内容是：</p>
<p><img src="/images/14575490108688.jpg" alt="trace 文件内容"></p>
<h2 id="u63D0_u793A"><a href="#u63D0_u793A" class="headerlink" title="提示"></a>提示</h2><ul>
<li>不要使用 <code>sleep()</code> 来同步</li>
<li>不要使用忙等待 <code>while(1);</code></li>
<li>使用 <code>sigsuspend</code> 来同步</li>
<li>竞争条件</li>
<li>僵尸进程回收（注意竞争条件以及正确处理信号）</li>
<li>等待前台任务（仔细思考怎么样才是好的方式）</li>
<li>不要假定进程的执行顺序</li>
<li>子进程挂掉的时候应该在一个限定时间内被回收</li>
<li>不要在多个地方调用 <code>waitpid</code>，很容易造成竞争条件，也会造成程序过分复杂</li>
<li>不要使用任何系统调用来管理 terminal group</li>
<li><code>waitpid</code>, <code>kill</code>, <code>fork</code>, <code>execve</code>, <code>setpgid</code>, <code>sigprocmask</code> 和 <code>sigsuspend</code> 都非常有用，<code>waitpid</code> 中的 WUNTRACED 和 WNOHANG 选项也是如此。</li>
<li>遇到不清晰的用 <code>man</code> 来查看细节</li>
<li>实现 signal handler 的时候注意给全部的前台进程组发送 SIGINT 和 SIGTSTP 信号</li>
<li>在 <code>kill</code> 函数中使用 <code>-pid</code> 的格式作为参数</li>
<li>在 shell 等待前台工作完成时，需要决定在 <code>eval</code> 及 <code>sigchold handler</code> 具体的分配，这里有一定技巧</li>
<li>在函数 <code>eval</code> 中，在 fork 出子进程之前，必须使用 <code>sigprocmask</code> 来阻塞 SIGCHLD, SIGINT 和 SIGTSTP 信号，完成之后再取消阻塞。调用 <code>addjob</code> 的时候也需要如此。注意，因为子进程也继承了之前的各种状态，所以在子进程中调用 <code>exec</code> 执行新程序的时候注意需要取消阻塞，同样也需要恢复默认的 handler（shell 本身已经忽略了这些信号），具体可以看书本的 8.5.6 节</li>
<li>不要使用 <code>top</code>, <code>less</code>, <code>vi</code>, <code>emacs</code> 之类的复杂程序，使用简单的文本程序如：<code>/bin/cat</code>, <code>/bin/ls</code>, <code>/bin/ps</code>, <code>/bin/echo</code></li>
<li>因为毕竟不是真正的 shell，所以在 fork 之后，execve 之前，子进程需要调用 <code>setpgid(0, 0)</code>，这样就把子进程放到一个新的进程组里。这样就保证我们的 shell 前台进程组中唯一的进程，当按下 ctrl-c 时，应该捕获 SIGINT 信号并发送给对应的前台进程组中。</li>
</ul>
<p>同样提供一个 <code>tshref</code> 参考程序来作为比对输出（除了进程 id 之外其他需要一模一样），具体是通过 <code>runtrace</code> 文件来测试，每个 trace 文件会测试一个特性</p>
<h2 id="u89E3_u9898_u653B_u7565"><a href="#u89E3_u9898_u653B_u7565" class="headerlink" title="解题攻略"></a>解题攻略</h2><p>最开始当时是要先读懂代码，尤其是整个程序到底在干什么，如果有仔细看我前面的介绍和课本的话，应该比较轻松能找到对应（毕竟这是一个简化的版本），所以这里废话不多说，直接开始完成基础工作。我们先来看看如何改动 <code>eval</code> 这个函数。</p>
<p>在这个函数中，我们会先解析命令（具体的解析已经有工具函数），然后得到一系列 token，结构如下</p>
<p><img src="/images/14575497659305.jpg" alt="token 的结构"></p>
<p>目前来说，对我们最有用的是这里面的枚举类型，我们可以先用这个来判断是否是内置函数，据此来决定走哪条分支。我们先把最基本的退出功能做了，这样就不会出现一旦开始就没办法结束的情况，具体方法也很简单，直接 <code>exit(0);</code> 即可，我们测试一下，发现已经可以正确退出了：</p>
<p><img src="/images/14575502436640.jpg" alt="退出程序"></p>
<p>接着我们来实现 <code>jobs</code> 这个命令，因为已经提供了 <code>listjobs</code> 这个函数，所以我们直接围绕着这个函数来做文章即可。留意到 token 结构体中有 <code>infile</code> 和 <code>outfile</code> 两项，这个就是用来重定向的判断（我们不需要担心解析的问题，可以直接用）。同样，我们来判断一下有没有 <code>outfile</code>，对应进行处理即可。注意输出的时候如果不需要重定向，那么就输出到 stdout，如果需要重定向，就输出到对应的 file descriptor 中（打开文件的时候需要设定 flag，具体可以 <code>man open</code> 进行查看）。</p>
<p>接着我们来实现 FG 和 BG 这两个命令，我们需要注意的地方有两个，一个是先根据判断传入的是 JID 还是 PID，然后发送信号之后需要等待进程完成（这里注意使用 <code>sigsuspend</code>）。</p>
<p>这里需要注意 <code>.</code> 和 <code>-&gt;</code> 这两个操作符的不同，简单来说，就是如果左边是一个指向结构体的指针，那么就要用 <code>-&gt;</code>；如果是一个结构体，那么就要用 <code>.</code>。</p>
<p>这些做完之后我们可以先来简单测试一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./runtrace <span class="operator">-f</span> trace00.txt <span class="operator">-s</span> ./tsh</span><br><span class="line">./runtrace <span class="operator">-f</span> trace00.txt <span class="operator">-s</span> ./tshref</span><br><span class="line">./runtrace <span class="operator">-f</span> trace01.txt <span class="operator">-s</span> ./tsh</span><br><span class="line">./runtrace <span class="operator">-f</span> trace01.txt <span class="operator">-s</span> ./tshref</span><br></pre></td></tr></table></figure>
<p><img src="/images/14575550290784.jpg" alt="测试结果"></p>
<p>看到和参考程序输出至少是一致的，我们就可以继续了。</p>
<p>接着我们需要来处理非内置命令的情况，参考课件中的代码，先把需要用到的 mask 之类的弄好，并且我们暂时不考虑重定向的问题。然后需要把对应的 signal handler 补充完整。</p>
<p>这之后我们可以来跑一次测试 <code>./sdriver</code>，最后的得分是 60/100，第一个错误出现在 trace08.txt 这个文件中，查表得知是发送 fatal SIGINT 给前台进程。我自己用 <code>./runtrace -f trace08.txt -s ./tsh</code> 测试了几次，发现有时候可以正确输出，有时候则会超时，说明是处理进程同步的时候出了问题。经过检查发现，阻塞信号的时候需要阻塞全部信号（之前我只阻塞了 SIGCHLD 会出问题），再测试的话，发现已经有了 80/100 分。</p>
<p>继续看看哪里出了问题，在输出的日志中寻找最先出错的地方，发现是 trace22.txt，功能是 I/O redirection(input)，这就对了，毕竟我们还没写这个功能。</p>
<p>我们现在就来写一下。不过在此之前，回答一下前面的问题，前面提到过：</p>
<blockquote>
<p>在 shell 等待前台工作完成时，需要决定在 <code>eval</code> 及 <code>sigchold handler</code> 具体的分配，这里有一定技巧</p>
</blockquote>
<p>那么技巧是什么呢？其实很简单，就是都在 eval 里做，handler 尽量短小精悍。</p>
<p>好，我们继续来做输入输出重定向，同样分为内置函数与其他两个类型，内置函数唯一需要输出的是 <code>jobs</code> 这个函数，不过我们之前已经处理过，这里暂且不管（出问题再说）。所以把主要精力集中在非内置的函数上。具体应该在 <code>setpgid(0,0)</code> 这句之后，且应该在 <code>execve</code> 之前。具体的操作也比较简单，就是打开文件（只读），然后利用 <code>dups</code> 重定向到 STDIN 中即可。对于输出的情况也是类似的，这里不赘述。唯一需要注意的一点是打开文件时候的 flag，设置错误会导致没办法正确重定向。</p>
<p>改完错误之后发现 trace15.txt 又出错了，而且经过测试发现死锁的问题还在，而且是内置函数的问题（果然一开始有小问题），后来发现是搞错了一个变量（但是仍旧有小概率会出现死锁，不过提交的时候似乎一切正常）</p>
<p>最后需要注意的是有些测试会直接修改源代码，所以每次都需要重新解压（还是蛮讨厌的）。总体来说只要理解了整个过程就不算太难，使用 <code>csapp.h</code> 的时候可能需要把代码复制到 <code>tsh.c</code> 中。</p>
<h2 id="u9644_u5F551_3A__u4E2D_u6587_man__u6587_u6863"><a href="#u9644_u5F551_3A__u4E2D_u6587_man__u6587_u6863" class="headerlink" title="附录1: 中文 man 文档"></a>附录1: 中文 man 文档</h2><p>如果觉得看英文太累（虽然建议看英文），可以使用中文的 man 文档，具体的使用步骤如下：</p>
<p>在<a href="http://manpages-zh.googlecode.com/files/manpages-zh-1.5.1.tar.gz" target="_blank" rel="external">这里</a>下载安装包，然后通过如下命令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf manpages-zh-<span class="number">1.5</span>.<span class="number">1</span>.tar.gz</span><br><span class="line"><span class="built_in">cd</span> manpages-zh-<span class="number">1.5</span>.<span class="number">1</span></span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/zhman --disable-zhtw</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>在 Mac 上会乱码，所以需要安装 groff，具体命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install homebrew/dupes/groff</span><br></pre></td></tr></table></figure>
<p>然后打开 <code>/etc/man.conf</code>，把 <code>NROFF</code> 的那一行改为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NROFF preconv <span class="operator">-e</span> UTF8 | /usr/<span class="built_in">local</span>/bin/nroff -Tutf8 -mandoc -c</span><br></pre></td></tr></table></figure>
<p>最后我么加一个别名，方便使用（根据自己使用的 shell 来针对改，bash 的话是 ~/.bashrc，zsh 的话是 ~/.zshrc），在文件中加入这么一句：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias cman='<span class="keyword">man</span> -<span class="keyword">M</span> /usr/<span class="keyword">local</span>/zhman/share/<span class="keyword">man</span>/zh_CN'</span><br></pre></td></tr></table></figure>
<p>然后 <code>source .zshrc</code> 启用，我们就可以通过 <code>cman</code> 命令来查看了，比如说输入 <code>cman kill</code>，就可以看到</p>
<p><img src="/images/14575529137049.jpg" alt="效果"></p>
<p>大功告成。</p>
<h2 id="u9644_u5F552_3A__u57FA_u7840_u77E5_u8BC6"><a href="#u9644_u5F552_3A__u57FA_u7840_u77E5_u8BC6" class="headerlink" title="附录2: 基础知识"></a>附录2: 基础知识</h2><p>开始之前需要理解的内容</p>
<h3 id="u5F02_u6B65_u5F02_u5E38_28_u4E2D_u65AD_29"><a href="#u5F02_u6B65_u5F02_u5E38_28_u4E2D_u65AD_29" class="headerlink" title="异步异常(中断)"></a>异步异常(中断)</h3><p><img src="/images/14574791971112.jpg" alt="Asynchronous Exceptions(Interrupts)"></p>
<h3 id="u540C_u6B65_u5F02_u5E38"><a href="#u540C_u6B65_u5F02_u5E38" class="headerlink" title="同步异常"></a>同步异常</h3><p><img src="/images/14574792452633.jpg" alt="Synchronous Exceptions"></p>
<h3 id="u8FDB_u7A0B"><a href="#u8FDB_u7A0B" class="headerlink" title="进程"></a>进程</h3><p><img src="/images/14574793369863.jpg" alt="Definition"></p>
<p><img src="/images/14574793444040.jpg" alt="Four basic States"></p>
<p><img src="/images/14574793738605.jpg" alt="Control States"></p>
<p>fork 函数详细介绍：</p>
<p><img src="/images/14574794567977.jpg" alt="fork"></p>
<p><img src="/images/14574794700303.jpg" alt="fork"></p>
<p>exec 函数详细介绍</p>
<p><img src="/images/14574794860146.jpg" alt="exec"></p>
<p>exit 函数详细介绍</p>
<p><img src="/images/14574795006407.jpg" alt=""></p>
<p>wait 函数详细介绍</p>
<p><img src="/images/14574795185122.jpg" alt=""></p>
<h3 id="u7B80_u5355_u7684_u8FDB_u7A0B_u4F8B_u5B50"><a href="#u7B80_u5355_u7684_u8FDB_u7A0B_u4F8B_u5B50" class="headerlink" title="简单的进程例子"></a>简单的进程例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (child_pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 这部分只有子进程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Child!\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 父进程通过下面这句等待子进程完成，才继续执行</span></span><br><span class="line">    waitpid(child_pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Parent!\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个使用 execvc 的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"><span class="keyword">char</span>* argv[] = &#123;<span class="string">"/bin/ls"</span>, <span class="string">"-l"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="keyword">char</span>* env[] = &#123;..., <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (child_pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 这部分只有子进程执行</span></span><br><span class="line">    execve(<span class="string">"/bin/ls"</span>, argv, env);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为已经被取代，所以 execve 之后的语句将不会被执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 父进程通过下面这句等待子进程完成，才继续执行</span></span><br><span class="line">    waitpid(child_pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 等待子进程结束之后继续执行父线程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Parent!\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u4FE1_u53F7"><a href="#u4FE1_u53F7" class="headerlink" title="信号"></a>信号</h3><p><img src="/images/14574798651564.jpg" alt="Three possible ways to react"></p>
<p><img src="/images/14574798879407.jpg" alt="Ohter Reaction Options"></p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.yurendu.com/read/install-man-command-chinese-help-documentation-on-mac-and-linux.html" target="_blank" rel="external">Mac/Linux 安装man命令的中文帮助文档</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这次的作业，我们需要自己完成一个简单的 shell 程序，通过具体的实现，我们可以更加深入地计算机运行的机制（尤其是 Exceptional Control Flow 和进程）。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Shelllab" scheme="http://wdxtub.com/tags/Shelllab/"/>
    
      <category term="习题课" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98%E8%AF%BE/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 15 课 System Level I/O]]></title>
    <link href="http://wdxtub.com/2016/03/06/csapp-15/"/>
    <id>http://wdxtub.com/2016/03/06/csapp-15/</id>
    <published>2016-03-06T12:47:39.000Z</published>
    <updated>2016-03-08T18:45:12.000Z</updated>
    <content type="html"><![CDATA[<p>了解完了 Exceptional Control Flow，我们再来看看系统级 IO 的相关内容，完成这一课之后，就可以开始写我们自己的 shell 程序了。</p>
<a id="more"></a>
<hr>
<h2 id="Unix_I/O"><a href="#Unix_I/O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p>在 Linux 中，文件实际上可以看做是字节的序列。更有意思的是，所有的 I/O 设备也是用文件来表示的，比如：</p>
<ul>
<li><code>./dev/sda2</code> (<code>/usr</code> disk partition)</li>
<li><code>/dev/tty2</code> (terminal)</li>
</ul>
<p>甚至连内核也是用文件来表示的：</p>
<ul>
<li><code>/boot/vmlinuz-3.13.0-55-generic</code> (kernel image)</li>
<li><code>/proc</code> (kernel data structures)</li>
</ul>
<p>因为 I/O 设备也是文件，所以内核可以利用称为 Unix I/O 的简单接口来处理输入输出，比如：</p>
<p><img src="/images/14574522789531.jpg" alt="Unix I/O Overview"></p>
<p>为了区别不同文件的类型，会有一个 <code>type</code> 来进行区别：</p>
<ul>
<li>普通文件：包含任意数据</li>
<li>目录：相关一组文件的索引</li>
<li>Socket：和另一台机器上的进程通信的类型</li>
</ul>
<p>其实还有一些比较特别的类型，但是这里提一下，不深入了解：</p>
<ul>
<li>Named pipes(FIFOs)</li>
<li>Symbolic links</li>
<li>Character and block devices</li>
</ul>
<h3 id="Regular_File"><a href="#Regular_File" class="headerlink" title="Regular File"></a>Regular File</h3><p>普通的文件包含任意数据，应用一般来说需要区分出 text files 和 binary files。文本文件只包含 ASCII 或 Unicode 字符。除此之外的都是 binary files(object files, JPEG images, etc)。对于内核来说其实并不能区分出个中的区别。</p>
<p>文本文件就是一系列的文本行，每行以 <code>\n</code> 结尾，新的一行是 <code>0xa</code>，和 ASCII 码中的 line feed 字符(LF) 一样。不同系统用用判断一行结束的符号不同(End of line, EOL)，如：</p>
<ul>
<li>Linux &amp; Mac OS: <code>\n</code>(0xa)<ul>
<li>line feed(LF) </li>
</ul>
</li>
<li>Windows &amp; Internet protocols: <code>\r\n</code> (0xd 0xa)<ul>
<li>Carriage return(CR) followed by line feed(LF)</li>
</ul>
</li>
</ul>
<h3 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a>目录</h3><p>目录包含一个 link 数组，并且每个目录至少包含两条记录：</p>
<ul>
<li><code>.</code>(dot) 当前目录</li>
<li><code>..</code>(dot dot) 上一层目录</li>
</ul>
<p>用来操作目录的命令主要有 <code>mkdir</code>, <code>ls</code>, <code>rmdir</code></p>
<p>目录是以树装结构组织的，跟目录是 <code>/</code>(slash)</p>
<p><img src="/images/14574529458797.jpg" alt="Directory Hierarchy"></p>
<p>内核会为每个进程保存 current working directory (cwd)，可以用 <code>cd</code> 命令来进行更改。</p>
<p>我们通过路径名来确定文件的位置，一般分为绝对路径和相对路径。</p>
<h3 id="u64CD_u4F5C_u6587_u4EF6"><a href="#u64CD_u4F5C_u6587_u4EF6" class="headerlink" title="操作文件"></a>操作文件</h3><p>接下来我们了解一下基本的文件操作。</p>
<p>在使用文件之前需要通知内核打开该文件：</p>
<p><img src="/images/14574530910656.jpg" alt="Opening Files"></p>
<p>返回值是一个小的整型称为 file descriptor（如果这个值等于 -1 则说明发生了错误）。每个由 Linux sheel 创建的进程都会默认打开三个文件：</p>
<ul>
<li>0: standard input(stdin)</li>
<li>1: standard output(stdout)</li>
<li>2: standar error(stderr)</li>
</ul>
<p>使用完毕之后同样需要通知内核关闭文件：</p>
<p><img src="/images/14574532174613.jpg" alt="Closing Files"></p>
<p>如果在此关闭已经关闭了的文件，会出大问题。所以一定要检查返回值，哪怕是 <code>close()</code> 函数（如上面的例子所示）</p>
<p>在打开和关闭之间就是读取文件，实际上就是把文件中对应的字节复制到内存中，并更新文件指针：</p>
<p><img src="/images/14574533193683.jpg" alt="Reading Files"></p>
<p>返回值是读取的字节数量，是一个 <code>ssize_t</code> 类型（其实就是一个 signed integer），如果 <code>nbytes &lt; 0</code> 那么表示出错。<code>nbytes &lt; sizeof(buf)</code> 这种情况(short counts) 是可能发生的，而且并不是错误。</p>
<p>写入文件是把内存中的数据复制到文件中，并更新文件指针：</p>
<p><img src="/images/14574534505640.jpg" alt="Wrting Files"></p>
<p>返回值是写入的字节数量，如果 <code>nbytes &lt; 0</code> 那么表示出错。<code>nbytes &lt; sizeof(buf)</code> 这种情况(short counts) 是可能发生的，而且并不是错误。</p>
<p>综合上面的操作，我们可以来看看 Unix I/O 的例子：</p>
<p><img src="/images/14574535145592.jpg" alt="Copying stdin to stdout, one byte at a time"></p>
<p>前面提到的 short count 会在下面的情形下发生：</p>
<ul>
<li>在读取的时候遇到 EOF(end-of-file)</li>
<li>从终端中读取文本行</li>
<li>读取和写入网络 sockets</li>
</ul>
<p>但是在下面的情况下不会发生</p>
<ul>
<li>从磁盘文件中读取（除 EOF 外）</li>
<li>写入到磁盘文件中</li>
</ul>
<p>最好总是允许 short count，这样就可以避免处理这么多不同的情况。</p>
<h2 id="Robust_I/O"><a href="#Robust_I/O" class="headerlink" title="Robust I/O"></a>Robust I/O</h2><p>RIO 实际上就是一个包装，用来在不同的应用中提供强壮的 IO 接口，主要有一下两类：</p>
<p><img src="/images/14574544870012.jpg" alt="The RIO Package"></p>
<p>可以从<a href="http://csapp.cs.cmu.edu/3e/code.html" target="_blank" rel="external">这里</a> 中下载（<code>src/csapp.c</code> 和  <code>include/csapp.h</code>）</p>
<p>无缓存的输入输出和 Unix 的 <code>read</code> 和 <code>write</code> 接口一致，如果要通过 network sockets 来传输数据，就非常拥有了：</p>
<p><img src="/images/14574546347971.jpg" alt="Unbuffered ROI Input and Output"></p>
<p>具体的实现是：</p>
<p><img src="/images/14574547191767.jpg" alt="Implementation of `rio_readn`"></p>
<p>有缓存的输入在从文件中读取数据的时候通过内置的内存缓冲区提高效率：</p>
<p><img src="/images/14574547952581.jpg" alt="Buffered RIO Input Functions"></p>
<p><img src="/images/14574548277481.jpg" alt=""></p>
<p>具体的实现如下：</p>
<p><img src="/images/14574548545398.jpg" alt="Buffered I/O: Implementation"></p>
<p>对应的结构体是：</p>
<p><img src="/images/14574549507104.jpg" alt=""></p>
<p>这是一个对应的例子：</p>
<p><img src="/images/14574549871674.jpg" alt="Copying the lines of a text file from standar input to standard output"></p>
<h2 id="Metadata_2C_Sharing__26amp_3B_Redirection"><a href="#Metadata_2C_Sharing__26amp_3B_Redirection" class="headerlink" title="Metadata, Sharing &amp; Redirection"></a>Metadata, Sharing &amp; Redirection</h2><p>元数据是用来描述数据的数据，由内核维护，可以通过 <code>stat</code> 和 <code>fstat</code> 函数来访问，其结构是：</p>
<p><img src="/images/14574550707059.jpg" alt="File Metadata"></p>
<p>对应的访问例子：</p>
<p><img src="/images/14574551947810.jpg" alt="Example of Accessing File Metadata"></p>
<p>了解了具体的结构之后，我们来看看内核是如何表示打开的文件的。其实过程很简单，每个进程都有自己的 Descriptor table，然后 Descriptor 1 指向终端，Descriptor 4 指向磁盘文件，如下图所示：</p>
<p><img src="/images/14574553689850.jpg" alt="How the Unix Kernel Represents Open Files"></p>
<p>两个不同的 descriptors 通过两个不同的 open file 记录来共享同一个磁盘文件（对应指向同一个 v-noe table）。</p>
<p>这里有一个需要说明的情况，就是使用 <code>fork</code>。子进程实际上是会继承父进程打开的文件，在调用 <code>fork</code> 之前，我们假设情况是这样的：</p>
<p><img src="/images/14574555865284.jpg" alt="Before fork call"></p>
<p>在 fork 之后，子进程实际上和父进程的指向是一样的，这里需要注意的是会把 <code>refcnt</code> 加上 1（也就是引用计数加 1）</p>
<p><img src="/images/14574556597788.jpg" alt="After fork"></p>
<p>了解了这个，我们我们就可以知道所谓的重定向是怎么实现的了。其实很简单，只要调用 <code>dup2(oldfd, newfd)</code> 函数即可。具体如下：</p>
<p><img src="/images/14574609050965.jpg" alt="I/O Redirection"></p>
<p>Step #1: open file to which stdout should be redirected(happends in child executing shell code, before <code>exec</code>)</p>
<p><img src="/images/14574609981392.jpg" alt="Step #1: open file to which stdout should be redirected"></p>
<p>Step #2: call <code>dup2(4,1)</code> -&gt; cause fd=1(stdout) to refer to disk file pointed at fd=4</p>
<p><img src="/images/14574613741105.jpg" alt="Step #2: call `dup2(4,1)`"></p>
<h2 id="Standar_I/O"><a href="#Standar_I/O" class="headerlink" title="Standar I/O"></a>Standar I/O</h2><p>C 标准库中包含一系列高层的标准 IO 函数，一些具体的函数：</p>
<p><img src="/images/14574614463046.jpg" alt="Examples of standard I/O functions"></p>
<p>标准 IO 会用流的形式打开文件，所谓流(stream)实际上是 file descriptor 和 buffer 在内存中的抽象。C 程序一般以三个流开始，如下所示：</p>
<p><img src="/images/14574615606437.jpg" alt="Standard I/O Streams"></p>
<p>接下来我们详细了解一下为什么需要使用缓冲区，程序经常会一次读入或者写入一个字符，比如 <code>getc</code>, <code>putc</code>, <code>ungetc</code>，同时也会一次读入或者写入一行，比如 <code>gets</code>, <code>fgets</code>。如果用 Unix I/O 的方式来进行调用，是非常昂贵的，比如说 <code>read</code> 和 <code>write</code> 因为需要内核调用，需要大于 10000 个时钟周期。</p>
<p>解决的办法就是利用 <code>read</code> 函数一次读取一块数据，然后再由高层的接口，一次从缓冲区读取一个字符（当缓冲区用完的时候需要重新填充），例如：</p>
<p><img src="/images/14574622326310.jpg" alt="Buffering in Standard I/O"></p>
<p>具体来看看这个例子：</p>
<p><img src="/images/14574622882078.jpg" alt="Standard I/O Buffering in Action"></p>
<p>注意右边的输出，实际上只写入了一次，一次六个字符，而不是程序中写的六次（这里好好感受下）</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>前面介绍了几种不同的 IO，它们的层级如下所示：</p>
<p><img src="/images/14574624849987.jpg" alt="Unix I/O vs. Standard I/O vs. RIO"></p>
<p>Unix I/O 的优劣：</p>
<p><img src="/images/14574625259926.jpg" alt="Pros and Cons of Unix I/O"></p>
<p>Standard I/O 的优劣：</p>
<p><img src="/images/14574625620916.jpg" alt="Pros and Cons of Standard I/O"></p>
<p>具体的选择建议为：</p>
<p><img src="/images/14574626154586.jpg" alt="Choosing I/O Functions"></p>
<p>最后是处理 binary files 的守则：</p>
<p><img src="/images/14574626867246.jpg" alt="Working with Binary Files"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解完了 Exceptional Control Flow，我们再来看看系统级 IO 的相关内容，完成这一课之后，就可以开始写我们自己的 shell 程序了。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="IO" scheme="http://wdxtub.com/tags/IO/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
