<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-04-08T13:47:33.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 习题课 7 Proxylab]]></title>
    <link href="http://wdxtub.com/2016/04/07/csapp-lab7/"/>
    <id>http://wdxtub.com/2016/04/07/csapp-lab7/</id>
    <published>2016-04-08T01:52:23.000Z</published>
    <updated>2016-04-08T13:47:33.000Z</updated>
    <content type="html"><![CDATA[<p>这次，我们来自己实现一个多线程带缓存的代理服务器！</p>
<a id="more"></a>
<hr>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>这次的作业主要分三个部分：</p>
<ol>
<li>Sequential Proxy: 接收客户端发送的 HTTP 请求，解析之后向目标服务器转发，获得响应之后再转发回客户端</li>
<li>Concurrent Proxy: 在第一步的基础上，支持多线程</li>
<li>Cache Web Objects: 使用 LRU 缓存单独的对象，而不是整个页面</li>
</ol>
<p>老套路</p>
<ul>
<li>上传文件 <code>scp proxylab-handout.tar dawang@shark.ics.cs.cmu.edu:~/513</code></li>
<li>登录 <code>ssh -X dawang@shark.ics.cs.cmu.edu</code></li>
<li>解压 <code>tar xvf proxylab-handhout.tar</code></li>
</ul>
<p>因为我比较习惯在本地写代码，所以把文件复制回来：</p>
<ul>
<li>服务器至本地 <code>scp dawang@shark.ics.cs.cmu.edu:~/513/proxylab-handout/proxy.c ./</code></li>
<li>本地至服务器 <code>scp ./proxy.c dawang@shark.ics.cs.cmu.edu:~/513/proxylab-handout/</code></li>
</ul>
<blockquote>
<p>评分标准</p>
</blockquote>
<p>使用 <code>./driver.sh</code> 来进行测试</p>
<ul>
<li>[40] 基本正确性（自动评分）</li>
<li>[15] 并行（自动评分）</li>
<li>[15] 缓存（自动评分）</li>
<li>[20] 实际页面测试<ul>
<li><a href="http://www.cs.cmu.edu/~213" target="_blank" rel="external">http://www.cs.cmu.edu/~213</a></li>
<li><a href="http://csapp.cs.cmu.edu" target="_blank" rel="external">http://csapp.cs.cmu.edu</a></li>
<li><a href="http://www.cs.cmu.edu" target="_blank" rel="external">http://www.cs.cmu.edu</a></li>
<li><a href="http://chalkdinosaur.bandcamp.com" target="_blank" rel="external">http://chalkdinosaur.bandcamp.com</a></li>
</ul>
</li>
<li>[10] 代码风格</li>
</ul>
<p>在工作文件夹中使用 <code>make handin</code> 来生成提交文件，然后交到 autolab 即可。</p>
<h2 id="Sequential_Web_Proxy"><a href="#Sequential_Web_Proxy" class="headerlink" title="Sequential Web Proxy"></a>Sequential Web Proxy</h2><p>第一步是实现一个简单的代理服务器，只处理 <code>HTTP/1.0 GET</code> 请求。具体步骤为</p>
<ul>
<li>端口号在命令行指令中指定<ul>
<li>申请自己的端口 <code>$ ./port-for-user.pl dawang</code>，这里申请的总是偶数，所以如果需要一个额外的端口，直接在端口号 +1 即可</li>
<li>不要随便指定端口，不然很可能干扰到别人</li>
<li><code>$ ./proxy 12345</code></li>
</ul>
</li>
<li>监听从该端口进入的所有请求</li>
<li>解析请求，并转发合法的 HTTP 请求<ul>
<li>假设请求为 <code>GET http://www.cmu.edu/hub/index.html HTTP/1.1</code></li>
<li>则主机名 <code>www.cmu.edu</code></li>
<li>请求的页面 <code>/hub/index.html</code></li>
<li>HTTP 请求每行以 <code>\r\n</code> 结束，以一个空行 <code>\r\n</code> 结尾</li>
<li>需要判断地址里有没有带端口</li>
</ul>
</li>
<li>把从服务器获取到的响应返回给客户端</li>
</ul>
<p>请求的 header 也很重要，一定要有的内容是：</p>
<ul>
<li><code>Host</code>: 如 <code>Host: www.cmu.edu</code></li>
<li><code>User-Agent</code>: 如 <code>User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3</code></li>
<li><code>Connection</code>: 必须发送 <code>Connection: close</code></li>
<li><code>Proxy-Connection</code>: 必须发送 <code>Proxy-Connection: close</code></li>
</ul>
<h2 id="Multiple_Concurrent_Requests"><a href="#Multiple_Concurrent_Requests" class="headerlink" title="Multiple Concurrent Requests"></a>Multiple Concurrent Requests</h2><p>使用 POSIX 线程，最好在线程一开始执行 <code>pthread_detach(pthread_self());</code> 这样就不用自己负责清理线程了。</p>
<p>注意竞争条件，尽量减少共享资源，访问共享资源的时候需要同步。</p>
<p><code>open_clientfd</code> 和 <code>open_listenfd</code> 函数是线程安全的</p>
<h2 id="Caching_Web_Objects"><a href="#Caching_Web_Objects" class="headerlink" title="Caching Web Objects"></a>Caching Web Objects</h2><p>具体缓存的机制是 LRU，一些具体的参数是：</p>
<ul>
<li>缓存大小限制 <code>MAX_CACHE_SIZE = 1 MiB</code>，注意只缓存 web 对象，其他诸如 metadata 应该忽略</li>
<li>单个文件大小限制 <code>MAX_OBJECT_SIZE = 100 KiB</code></li>
<li>如果有 T 个连接，那么最大的空间为 <code>MAX_CACHE_SIZE + T * MAX_OBJECT_SIZE</code></li>
</ul>
<p>同步问题可以参考『读者-写者问题』</p>
<h2 id="u8C03_u8BD5_u5DE5_u5177"><a href="#u8C03_u8BD5_u5DE5_u5177" class="headerlink" title="调试工具"></a>调试工具</h2><ul>
<li>Telnet: 不安全的 ssh，需要手动构造 HTTP 请求，如果想要测试非法的 header，这个功能就很有用<ul>
<li><code>man telnet</code></li>
<li><code>telnet www.wdxtub.com</code></li>
<li><code>GET http://www.wdxtub.com HTTP/1.0</code> </li>
</ul>
</li>
<li>cURL: 会自动构建 HTTP 请求<ul>
<li><code>curl http://www.wdxtub.com</code></li>
<li>代理模式 <code>curl --proxy lemonshar.ics.cs.cmu.edu:3092 http://www.wdxtub.com</code> </li>
</ul>
</li>
<li><code>netcat</code>: 多用途网络工具，用法与 <code>telnet</code> 类似<ul>
<li><code>nc catshark.ics.cs.cmu.edu 12345</code></li>
<li><code>GET http://www.cmu.edu/hub/index.html HTTP/1.0</code></li>
</ul>
</li>
</ul>
<h2 id="u6CE8_u610F_u4E8B_u9879"><a href="#u6CE8_u610F_u4E8B_u9879" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>大端小端</li>
<li>能够处理各种 URL（合法或非法）</li>
<li>不是所有的内容都是 ASCII 码，注意选择对应的函数来处理二进制文件（图像和视频）</li>
<li>所有的请求都用 <code>HTTP/1.0</code> 来转发</li>
<li>需要处理 <code>SIGPIPE</code> 信号，默认的操作是关闭进程，这里应该屏蔽这个信号</li>
<li>使用 Robust I/O package 的 <code>read</code>, <code>write</code>, <code>fread</code>, <code>fwrite</code> 来增加健壮性</li>
<li>如果调用 <code>read</code> 来获取已经被关闭的 socket，会返回 -1，并给出 <code>ECONNRESET</code> 错误，不应该因为这个错误而导致进程终结</li>
<li>如果调用 <code>write</code> 来获取已经被关闭的 socket，会返回 -1，并给出 <code>EPIPE</code> 错误，不应该因为这个错误而导致进程终结</li>
<li>代码注意模块化</li>
<li>因为可以写单独的文件，需要对应更新 Makefile</li>
</ul>
<p><img src="/images/14600850252282.jpg" alt="最终效果"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这次，我们来自己实现一个多线程带缓存的代理服务器！</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="Proxy" scheme="http://wdxtub.com/tags/Proxy/"/>
    
      <category term="习题课" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98%E8%AF%BE/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 24 课 Synchronization - Advanced]]></title>
    <link href="http://wdxtub.com/2016/04/07/csapp-24/"/>
    <id>http://wdxtub.com/2016/04/07/csapp-24/</id>
    <published>2016-04-07T15:30:39.000Z</published>
    <updated>2016-04-08T01:05:30.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们通过『生产者-消费者问题』以及『读者-写者问题』来更深入理解同步机制。</p>
<a id="more"></a>
<hr>
<p>Semaphores 实际上可以认为是线程之间最简单的通知机制，用来控制共享资源的访问。这之中有两个非常经典的问题：</p>
<ul>
<li>The Producer-Consumer Problem</li>
<li>The Readers-Writers Problem</li>
</ul>
<h2 id="u751F_u4EA7_u8005-_u6D88_u8D39_u8005_u95EE_u9898"><a href="#u751F_u4EA7_u8005-_u6D88_u8D39_u8005_u95EE_u9898" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p><img src="/images/14600704484721.jpg" alt="Producer-Consumer Problem"></p>
<p>具体的同步模型为：</p>
<ul>
<li>生产者等待空的 slot，把 item 存储到 buffer，并通知消费者</li>
<li>消费整等待 item，从 buffer 中移除 item，并通知生产者</li>
</ul>
<p>主要用于</p>
<ul>
<li>多媒体处理<ul>
<li>生产者生成 MPEG 视频帧，消费者进行渲染</li>
</ul>
</li>
<li>事件驱动的图形用户界面<ul>
<li>生产者检测到鼠标点击、移动和键盘输入，并把对应的事件插入到 buffer 中</li>
<li>消费者从 buffer 中获取事件，并绘制到到屏幕上</li>
</ul>
</li>
</ul>
<p>接下来我们实现一个有 n 个元素 buffer，为此，我们需要一个 mutex 和两个用来计数的 semaphore：</p>
<ul>
<li><code>mutex</code>: 用来保证对 buffer 的互斥访问</li>
<li><code>slots</code>: 统计 buffer 中可用的 slot 数目</li>
<li><code>items</code>: 统计 buffer 中可用的 item 数目</li>
</ul>
<p>我们直接来看代码，就比较清晰了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 sbuf.h</span></span><br><span class="line"><span class="comment">// 包括几个基本操作</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> *buf;    <span class="comment">// Buffer array</span></span><br><span class="line">    <span class="keyword">int</span> n;       <span class="comment">// Maximum number of slots</span></span><br><span class="line">    <span class="keyword">int</span> front;   <span class="comment">// buf[(front+1)%n] is first item</span></span><br><span class="line">    <span class="keyword">int</span> rear;    <span class="comment">// buf[rear%n] is the last item</span></span><br><span class="line">    <span class="keyword">sem_t</span> mutex; <span class="comment">// Protects accesses to buf</span></span><br><span class="line">    <span class="keyword">sem_t</span> slots; <span class="comment">// Counts available slots</span></span><br><span class="line">    <span class="keyword">sem_t</span> items; <span class="comment">// Counts available items</span></span><br><span class="line">&#125; <span class="keyword">sbuf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_init</span><span class="params">(sbuf_t *sp, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_deinit</span><span class="params">(sbuf_t *sp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(sbuf_t *sp, <span class="keyword">int</span> item)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbuf_remove</span><span class="params">(sbuf_t *sp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>然后是具体的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sbuf.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an empty, bounded, shared FIFO buffer with n slots</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_init</span><span class="params">(sbuf_t *sp, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    sp-&gt;buf = Calloc(n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    sp-&gt;n = n;                  <span class="comment">// Buffer holds max of n items</span></span><br><span class="line">    sp-&gt;front = sp-&gt;rear = <span class="number">0</span>;   <span class="comment">// Empty buffer iff front == rear</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// Binary semaphore for locking</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;slots, <span class="number">0</span>, n); <span class="comment">// Initially, buf has n empty slots</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;items, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// Initially, buf has 0 items</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clean up buffer sp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_deinit</span><span class="params">(sbuf_t *sp)</span></span>&#123;</span><br><span class="line">    Free(sp-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert item onto the rear of shared buffer sp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(sbuf_t *sp, <span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">    P(&amp;sp-&gt;slots);                        <span class="comment">// Wait for available slot</span></span><br><span class="line">    P(&amp;sp-&gt;mutext);                       <span class="comment">// Lock the buffer</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear)%(sp-&gt;n)] = item; <span class="comment">// Insert the item</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);                        <span class="comment">// Unlock the buffer</span></span><br><span class="line">    V(&amp;sp-&gt;items);                        <span class="comment">// Announce available item</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove and return the first tiem from the buffer sp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbuf_remove</span><span class="params">(sbuf_f *sp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    P(&amp;sp-&gt;items);                         <span class="comment">// Wait for available item</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);                         <span class="comment">// Lock the buffer</span></span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front)%(sp-&gt;n)]; <span class="comment">// Remove the item</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);                         <span class="comment">// Unlock the buffer</span></span><br><span class="line">    V(&amp;sp-&gt;slots);                         <span class="comment">// Announce available slot</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u8BFB_u8005-_u5199_u8005_u95EE_u9898"><a href="#u8BFB_u8005-_u5199_u8005_u95EE_u9898" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>是互斥问题的通用描述，具体为：</p>
<ul>
<li>读者线程只读取对象</li>
<li>写者线程修改对象</li>
<li>写者对于对象的访问是互斥的</li>
<li>多个读者可以同时读取对象</li>
</ul>
<p>常见的应用场景是：</p>
<ul>
<li>在线订票系统</li>
<li>多线程缓存 web 代理</li>
</ul>
<p>根据不同的读写策略，又两类读者写者问题，需要注意的是，这两种情况都可能出现 starvation。</p>
<blockquote>
<p>第一类读者写者问题（读者优先）</p>
</blockquote>
<ul>
<li>如果写者没有获取到使用对象的权限，不应该让读者等待</li>
<li>在等待的写者之后到来的读者应该在写者之前处理</li>
<li>也就是说，只有没有读者的情况下，写者才能工作</li>
</ul>
<blockquote>
<p>第二类读者写者问题（写者优先）</p>
</blockquote>
<ul>
<li>一旦写者可以处理的时候，就不应该进行等待</li>
<li>在等待的写者之后到来的读者应该在写者之后处理</li>
</ul>
<p>把前面这些拼到一起，就有了完整的 Server </p>
<p><img src="/images/14600747953883.jpg" alt="Prethreaded Concurrent Server"></p>
<p>具体的代码为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sbuf_t</span> sbuf; <span class="comment">// Shared buffer of connected descriptors</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> byte_cnt;  <span class="comment">// Byte counter</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">sem_t</span> mutex;   <span class="comment">// and the mutex that protects it</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo_cnt</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_once_t</span> once = PTHREAD_ONCE_INIT;</span><br><span class="line">    </span><br><span class="line">    Pthread_once(&amp;once, init_echo_cnt);</span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        byte_cnt += n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread %d received %d (%d total) bytes on fd %d\n"</span>,</span><br><span class="line">                    (<span class="keyword">int</span>) pthread_self(), n, byte_cnt, connfd);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_echo_cnt</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    Sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    byte_cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>&#123;</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> connfd = sbuf_remove(&amp;sbuf); <span class="comment">// Remove connfd from buf</span></span><br><span class="line">        echo_cnt(connfd);                <span class="comment">// Service client</span></span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, listenfd, connfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_storage clientaddr;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    </span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    sbuf_init(&amp;sbuf, SBUFSIZE);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHREADS; i++) <span class="comment">// Create worker threads</span></span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        sbuf_insert(&amp;sbuf, connfd); <span class="comment">// Insert connfd in buffer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7EBF_u7A0B_u5B89_u5168"><a href="#u7EBF_u7A0B_u5B89_u5168" class="headerlink" title="线程安全"></a>线程安全</h2><p>在线程中调用的函数必须是线程安全的，定义为：</p>
<blockquote>
<p>A function is thread-safe iff it will always produce correct results when called repeatedly from multiple concurrent threads</p>
</blockquote>
<p>主要有 4 类线程不安全的函数</p>
<ol>
<li>Functions that do not protect shared variables<ul>
<li>解决办法：使用 P 和 V semaphore 操作</li>
<li>问题：同步操作会影响性能</li>
</ul>
</li>
<li>Functions that keep state across multiple invocations<ul>
<li>Fix: Pass state as part of argument </li>
</ul>
</li>
<li>Functions that return a pointer to a static variable<ul>
<li>Fix 1: Rewrite function so caller passes address of variable to store result</li>
<li>Fix 2: Lock-and-copy</li>
</ul>
</li>
<li>Functions that call thread-unsage functions<ul>
<li>解决办法：只调用线程安全的函数</li>
</ul>
</li>
</ol>
<p>另一个重要的概念是 Reentrant Function，定义为：</p>
<blockquote>
<p>A function is <strong>reentrant</strong> iff it accesses no shared variables when called by multiple threads</p>
</blockquote>
<p><img src="/images/14600771838118.jpg" alt=""></p>
<p>Reentrant Functions 是线程安全函数非常重要的子集，不需要同步操作，对于第二类的函数来说（上面提到的），唯一的办法就是把他们修改成 reentrant 的。</p>
<p>标准 C 库中的函数都是线程安全的（如 <code>malloc</code>, <code>free</code>, <code>printf</code>, <code>scanf</code>），大多数 Unix 的系统调用也都是线程安全的，除了下面这些例外：</p>
<p><img src="/images/14600772808229.jpg" alt=""></p>
<p>最后要提的两点是『竞争条件』和『死锁』，对于前者来说，要避免状态的共享，对于后者来说，要保证共享资源按照顺序进行请求。举个例子：</p>
<p><img src="/images/14600774132333.jpg" alt="Deadlocking With Semaphores"></p>
<p> 留意两个函数中 P 操作的顺序，用 Progress Graph 来表示就是：</p>
<p><img src="/images/14600774554184.jpg" alt="Deadlock Visualized in Progress Graph"></p>
<p>但是如果我们调整顺序：</p>
<p><img src="/images/14600774851875.jpg" alt="Acquire shared resources in same order"></p>
<p>情况就会变成这样</p>
<p><img src="/images/14600775118044.jpg" alt="Avoided Deadlock in Progress Graph"></p>
<p>也就解决了死锁的问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们通过『生产者-消费者问题』以及『读者-写者问题』来更深入理解同步机制。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="同步" scheme="http://wdxtub.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 23 课 Synchronization - Basics]]></title>
    <link href="http://wdxtub.com/2016/04/07/csapp-23/"/>
    <id>http://wdxtub.com/2016/04/07/csapp-23/</id>
    <published>2016-04-07T15:30:32.000Z</published>
    <updated>2016-04-07T20:19:11.000Z</updated>
    <content type="html"><![CDATA[<p>并行编程中最重要的问题就是同步，这节课我们来了解同步相关的基础知识</p>
<a id="more"></a>
<hr>
<h2 id="u5171_u4EAB_u53D8_u91CF"><a href="#u5171_u4EAB_u53D8_u91CF" class="headerlink" title="共享变量"></a>共享变量</h2><p>在介绍同步之前，我们需要弄清楚一个定义，什么是 Shared variable（共享变量）？</p>
<blockquote>
<p>A variable <code>x</code> is <em>shared</em> if and only if multiple threads reference some instance of <code>x</code></p>
</blockquote>
<p>另外一个需要注意的是线程的内存模型，因为概念上的模型和实际的模型有一些差异，非常容易导致错误。</p>
<p>在概念上的模型中：</p>
<ul>
<li>多个线程在一个单独进程的上下文中运行</li>
<li>每个线程有单独的线程上下文（线程 ID，栈，栈指针，PC，条件码，GP 寄存器）</li>
<li>所有的线程共享剩下的进程上下文<ul>
<li>Code, data, heap, and shared library segments of the process virtual address space</li>
<li>Open files and installed handlers</li>
</ul>
</li>
</ul>
<p>在实际的模型中，寄存器的值虽然是隔离且被保护的，但是在栈中的值并不是这样的（其他线程也可以访问）。</p>
<p>我们来看一个简单的例子：</p>
<p><img src="/images/14600480676890.jpg" alt="Example Program to Illustrate Sharing"></p>
<p>这里有几个不同类型的变量，我们一一来看一下：</p>
<ul>
<li>全局变量：在函数外声明的变量<ul>
<li>虚拟内存中有全局唯一的一份实例</li>
</ul>
</li>
<li>局部变量：在函数内声明，且没有用 static 关键字<ul>
<li>每个线程的栈中都保存着对应线程的局部变量</li>
</ul>
</li>
<li>局部静态变量：在函数内用 static 关键字声明的变量<ul>
<li>虚拟内存中有全局唯一的一份实例</li>
</ul>
</li>
</ul>
<p>具体分析下上面例子中的变量，有：</p>
<p><img src="/images/14600483444019.jpg" alt="Mapping Variable Instances to Memory"></p>
<p>具体来分析下，一个变量只有在被多个线程引用的时候才算是共享，在这个例子中，共享变量有 <code>ptr</code>, <code>cnt</code> 和 <code>msgs</code>；非共享变量有 <code>i</code> 和 <code>myid</code>。</p>
<p><img src="/images/14600486014966.jpg" alt="Shared Vairable Analysis"></p>
<p>共享变量看起来不难，但是会导致一个并行编程中最重要的问题——同步问题。</p>
<h2 id="Critical_Section"><a href="#Critical_Section" class="headerlink" title="Critical Section"></a>Critical Section</h2><p>我们直接来看例子</p>
<p><img src="/images/14600488439280.jpg" alt="Improper Synchronization"></p>
<p>为什么运行的时候，会出现不一样的结果呢？我们把操作 <code>cnt</code> 的部分抽出来单独看一看：</p>
<p><img src="/images/14600574108297.jpg" alt="Assembly Code for Counter Loop"></p>
<p>这里有一点需要注意，<code>cnt</code> 使用了 <code>volatile</code> 关键字声明，意思是不要在寄存器中保存值，无论是读取还是写入，都要对内存操作（还记得 write-through 吗？）。这里把具体的步骤分成 5 步：HLUST，尤其要注意的 LUS 这三个操作，后面会继续说。</p>
<p>我们先来看看没有问题的情况：</p>
<p><img src="/images/14600579848706.jpg" alt=""></p>
<p>这里我们可以看到，有颜色的指令连在一起，所以没有问题。但是一旦交叉，就有问题了，如：</p>
<p><img src="/images/14600580383523.jpg" alt=""></p>
<h2 id="Progress_Graph__26amp_3B_Trajectory"><a href="#Progress_Graph__26amp_3B_Trajectory" class="headerlink" title="Progress Graph &amp; Trajectory"></a>Progress Graph &amp; Trajectory</h2><p>为了描述上面这种情况，我们可以用 Progress Graph 来辅助，比如：</p>
<p><img src="/images/14600581230106.jpg" alt="Progress Graph"></p>
<p>不同的轴代表在某线程中的指令执行顺序，每个点对应一个可能的执行状态，比如说图中的红点，表示线程 1 执行完了 L1，而线程 2 执行完了 S2。</p>
<p>Trajectory 的概念也很好理解，即可行的执行顺序，如下图：</p>
<p><img src="/images/14600582550787.jpg" alt="Trajectory"></p>
<p>我们把 critical section 的边界画出来，就可以判断不同的 trajectory 是否是安全的了：</p>
<p><img src="/images/14600583380649.jpg" alt=""></p>
<p>怎么样保证我们的执行不会走到不安全的区域里呢？有几种方法，这里我们只介绍 Semaphores。下面是比较常用的：</p>
<ul>
<li>Semaphores - Edsger Dijkstra</li>
<li>Mutex &amp; condition variables - Pthreads</li>
<li>Monitors - Java</li>
</ul>
<h2 id="Semaphores"><a href="#Semaphores" class="headerlink" title="Semaphores"></a>Semaphores</h2><p>先看定义</p>
<blockquote>
<p>Semaphore: non-negative global integer synchronization vairable. Manipulated by P and V operations.</p>
</blockquote>
<p>具体的操作为：</p>
<p><img src="/images/14600591923220.jpg" alt=""></p>
<p>根据这样的设计，我们可以知道作为 Semaphore 变量其值一定是非负的。另外样例代码中已经封装了 Pthreads 的函数，如下：</p>
<p><img src="/images/14600599945369.jpg" alt="C Semaphore Operations"></p>
<p>用法也很简单，在进入 critical section 之前，用 P 操作锁住，操作完成之后，用 V 才做释放。一些术语为：</p>
<p><img src="/images/14600600984591.jpg" alt="Terminology"></p>
<p>就可以用 Semaphore 来保证前面的程序不会算错数了，但是因为要同步的缘故，速度会慢</p>
<p><img src="/images/14600602184868.jpg" alt="Proper Synchronization"></p>
<p>具体的机制就是给不安全的区域上了个『锁』：</p>
<p><img src="/images/14600602784245.jpg" alt="Why Mutexes Work"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>总结一下，在使用线程时，程序员脑中需要又一个清晰的分享变量的概念，共享变量需要互斥访问，而 Semaphores 是一个基础的机制。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>并行编程中最重要的问题就是同步，这节课我们来了解同步相关的基础知识</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="同步" scheme="http://wdxtub.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 22 课 Concurrent Programming]]></title>
    <link href="http://wdxtub.com/2016/04/06/csapp-22/"/>
    <id>http://wdxtub.com/2016/04/06/csapp-22/</id>
    <published>2016-04-07T02:16:36.000Z</published>
    <updated>2016-04-07T13:12:00.000Z</updated>
    <content type="html"><![CDATA[<p>如果想要充分利用硬件资源，就要尽可能让计算机同时处理多项事务，具体是怎么实现的？又哪些基本的策略？这节课会一一解答。</p>
<a id="more"></a>
<hr>
<p>首先一定要清楚地意识到：『并行编程不简单』！最主要的原因恐怕就是我们自己的大脑，人脑实际上是一个非常精妙的系统，所采取的并行策略是一明一暗两条线，但是对于明线来说，是线性的，于是就和计算机中并行的概念冲突了。另外时间这个概念也是线性的，这就导致了想要处理好并行程序可能出现的各种问题几乎是不可能的（或者常常要出错）。</p>
<p>常见的错误有仨：竞争条件、死锁和活锁，具体如下：</p>
<p><img src="/images/14599962597558.jpg" alt="Classical problem classes"></p>
<h2 id="u670D_u52A1_u5668_u7684_u4F8B_u5B50"><a href="#u670D_u52A1_u5668_u7684_u4F8B_u5B50" class="headerlink" title="服务器的例子"></a>服务器的例子</h2><p>我们前面实现的服务器，一次只能处理一个请求，只有当前的请求处理完了，才能继续处理下一个。</p>
<p><img src="/images/14599976220466.jpg" alt=""></p>
<p>这里具体讲解一下：Client 1 向 Server 发送连接请求(connect)，Server 接受(accept)之后开始等待 Client 1 发送请求（也就是开始 read），这之后 Client 1 发送具体的内容(write)后转为等待响应(call read)，Server 的 read 接收到了内容之后，发送响应(write) 后仅需进入等待(read)，而 Client 1 接收到了响应(ret read)，最后根据用户指令退出(close)。</p>
<p>而只有当 Client 1 断开之后，Server 才会处理 Client 2 的请求，从图中也可以看到这一点。具体是在哪里等待呢？因为 TCP 会缓存，所以实际上 Client 2 在 <code>ret read</code> 之前进行等待，如：</p>
<p><img src="/images/14599992829071.jpg" alt="Where Does Second Client Block"></p>
<p>为了解决这个问题，我们可以使用并行的策略，同时处理不同客户端发来的请求。</p>
<h2 id="u5E76_u884C_u65B9_u6CD5"><a href="#u5E76_u884C_u65B9_u6CD5" class="headerlink" title="并行方法"></a>并行方法</h2><p>总体来说，根据系统机制的层级和实现方式，有下面三大类方法：</p>
<ol>
<li>基于进程<ul>
<li>内核自动管理多个逻辑流</li>
<li>每个进程有其私有的地址空间（也就是说进程切换的时候需要保存和载入数据）</li>
</ul>
</li>
<li>基于事件<ul>
<li>由程序员手动控制多个逻辑流</li>
<li>所有的逻辑流共享同一个地址空间</li>
<li>这个技术称为 I/O multiplexing</li>
</ul>
</li>
<li>基于线程<ul>
<li>内核自动管理多个逻辑流</li>
<li>每个线程共享地址空间</li>
<li>属于基于进程和基于事件的混合体</li>
</ul>
</li>
</ol>
<h3 id="u57FA_u4E8E_u8FDB_u7A0B"><a href="#u57FA_u4E8E_u8FDB_u7A0B" class="headerlink" title="基于进程"></a>基于进程</h3><p>为每个客户端分离出一个单独的进程，是建立了连接之后才开始并行，连接的建立还是串行的。</p>
<p><img src="/images/14600273587521.jpg" alt="Spawn separate process for each client"></p>
<p>具体的代码为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(-<span class="number">1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// Reap all zombie children</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_storage clientaddr;</span><br><span class="line">    </span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            Close(listenfd); <span class="comment">// Child closes its listening socket</span></span><br><span class="line">            echo(connfd); <span class="comment">// Child services client</span></span><br><span class="line">            Close(connfd); <span class="comment">// Child closes connection with client</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// Child exits</span></span><br><span class="line">        &#125;</span><br><span class="line">        Close(connfd); <span class="comment">// Parent closes connected socket (important!)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键步骤(accept)的描述为</p>
<p><img src="/images/14600278440053.jpg" alt="Concurrent Server: `accept` Illustrated"></p>
<p>执行模型为</p>
<p><img src="/images/14600278862489.jpg" alt="Process-based Server Execution Model"></p>
<ul>
<li>每个客户端由独立子进程处理<ul>
<li>必须回收僵尸进程，来避免严重的内存泄露</li>
</ul>
</li>
<li>不同进程之间不共享数据</li>
<li>父进程和子进程都有 <code>listenfd</code> 和 <code>connfd</code>，所以在父进程中需要关闭 <code>connfd</code>，在子进程中需要关闭 <code>listenfd</code><ul>
<li>内核会保存每个 socket 的引用计数，在 fork 之后 <code>refcnt(connfd) = 2</code>，所以在父进程需要关闭 connfd，这样在子进程结束后引用计数才会为零</li>
</ul>
</li>
</ul>
<blockquote>
<p>优劣</p>
</blockquote>
<p><img src="/images/14600282200028.jpg" alt="Pros and Cons of Process-based Servers"></p>
<h3 id="u57FA_u4E8E_u4E8B_u4EF6"><a href="#u57FA_u4E8E_u4E8B_u4EF6" class="headerlink" title="基于事件"></a>基于事件</h3><p>服务器会维护一个 connection 数组，包含若干 <code>connfd</code>，具体的过程为：</p>
<p><img src="/images/14600283355967.jpg" alt=""></p>
<p>这里一个很重要的技术是 I/O Multiplexing，感兴趣的同学可以查阅书中对应章节（具体内容会在习题课中介绍）。</p>
<blockquote>
<p>优劣</p>
</blockquote>
<p><img src="/images/14600283984253.jpg" alt="Pros and Cons of Event-based Servers"></p>
<h3 id="u57FA_u4E8E_u7EBF_u7A0B"><a href="#u57FA_u4E8E_u7EBF_u7A0B" class="headerlink" title="基于线程"></a>基于线程</h3><p>和基于进程的方法非常相似，唯一的区别是这里用线程。进程其实是比较『重』的，一个进程包括：</p>
<p><img src="/images/14600286544772.jpg" alt="Traditional View of a Process"></p>
<p>当然，我们也可以从线程的角度来描述进程：</p>
<p><img src="/images/14600286291425.jpg" alt="Alternate View of a Process"></p>
<p>这两个角度的区别在于，通过线程视角观察，把单独的可执行部分抽离出来了，于是当一个进程有多个线程的时候，看起来像这样：</p>
<p><img src="/images/14600287485774.jpg" alt="A Process With Multiple Threads"></p>
<p>每个线程有自己的线程 id，有自己的逻辑控制流，也有自己的用来保存局部变量的栈（其他线程可以修改）但是会共享所有的代码、数据以及内核上下文。</p>
<p>和进程不同的是，线程没有一个明确的树状结构（使用 <code>fork</code> 是有明确父进程子进程区分的），看起来就像下面这样：</p>
<p><img src="/images/14600293169627.jpg" alt="Logical View of Threads"></p>
<p>和进程中『并行』的概念一样，如果两个线程的控制流在时间上有『重叠』（或者说有交叉），那么就是并行的，例如：</p>
<p><img src="/images/14600295257230.jpg" alt="Concurrent Threads"></p>
<p>单核与多核处理器也有一点点不同：</p>
<p><img src="/images/14600297006546.jpg" alt="Concurrent Thread Execution"></p>
<p>进程和线程的差别已经被说了太多次，这里简单提一下。相同点在于，它们都有自己的逻辑控制流，可以并行，都需要进行上下文切换。不同点在于，线程共享代码和数据（进程通常不会），线程开销比较小（创建和回收）</p>
<h2 id="Posix_Threads__28Pthreads_29_Interface"><a href="#Posix_Threads__28Pthreads_29_Interface" class="headerlink" title="Posix Threads (Pthreads) Interface"></a>Posix Threads (Pthreads) Interface</h2><p>Pthreads 是一个线程库，基本上只要是 C 程序能跑的平台，都会支持这个标准，具体如下；</p>
<p><img src="/images/14600332547386.jpg" alt=""></p>
<p>一个例子</p>
<p><img src="/images/14600332776267.jpg" alt="The Pthreads &quot;hello, world&quot; Program"></p>
<p>这个程序的流程描述为</p>
<p><img src="/images/14600338560676.jpg" alt="Execution of Thread &quot;hello, world&quot;"></p>
<p>我们用线程的方式重写一次之前的 Echo Server</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread routine</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connf = *((<span class="keyword">int</span> *)vargp);</span><br><span class="line">    <span class="comment">// detach 之后不用显式 join，会在执行完毕后自动回收</span></span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    Free(vargp);</span><br><span class="line">    echo(connfd);</span><br><span class="line">    <span class="comment">// 一定要记得关闭！</span></span><br><span class="line">    Close(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, *connfdp;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_storage clientaddr;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    </span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        <span class="comment">// 这里使用新分配的 connected descriptor 来避免竞争条件</span></span><br><span class="line">        connfdp = Malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        *connfdp = Accept(listenfd, (SA *) &amp; clientaddr, &amp;clientlen);</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, connfdp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的执行模型为：</p>
<p><img src="/images/14600343334886.jpg" alt="Thread-based Server Execution Model"></p>
<p>在这个模型中，每个客户端由单独的线程进行处理，这些线程除了线程 id 之外，共享所有的进程状态（但是每个线程有自己的局部变量栈）。需要注意的有：</p>
<p><img src="/images/14600346185454.jpg" alt="Issues With Thread-Based Servers"></p>
<p>说了这么多，其实就是同步问题（后面两节课会专门介绍）</p>
<blockquote>
<p>优劣</p>
</blockquote>
<p><img src="/images/14600346688214.jpg" alt=""></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这里我们了解了三大类方法的特点，具体的会在习题课结合例子说明，这里是一个简单的总结</p>
<p><img src="/images/14600347193577.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果想要充分利用硬件资源，就要尽可能让计算机同时处理多项事务，具体是怎么实现的？又哪些基本的策略？这节课会一一解答。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="并行" scheme="http://wdxtub.com/tags/%E5%B9%B6%E8%A1%8C/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 21 课 Network Programming II]]></title>
    <link href="http://wdxtub.com/2016/04/06/csapp-21/"/>
    <id>http://wdxtub.com/2016/04/06/csapp-21/</id>
    <published>2016-04-06T11:34:02.000Z</published>
    <updated>2016-04-07T00:44:41.000Z</updated>
    <content type="html"><![CDATA[<p>这节课我们来学习如何编写 web 服务器！</p>
<a id="more"></a>
<hr>
<h2 id="u67B6_u6784_u603B_u89C8"><a href="#u67B6_u6784_u603B_u89C8" class="headerlink" title="架构总览"></a>架构总览</h2><p>写服务器，最重要的就是理清思路，上节课我们介绍了诸多概念，尤其是最后提到的 <code>getaddrinfo</code> 和 <code>getnameinfo</code>，都是我们在搭建过程中必不可少的工具。这里先借下图来介绍具体的实现思路：</p>
<p><img src="/images/14599728555354.jpg" alt=""></p>
<p>整个的工作流程有 5 步：</p>
<ol>
<li>开启服务器（<code>open_listenfd</code> 函数，做好接收请求的准备）<ul>
<li><code>getaddrinfo</code>: 设置服务器的相关信息，具体可以参见 图1&amp;2</li>
<li><code>socket</code>: 创建 socket descriptor，也就是之后用来读写的 file descriptor<ul>
<li><code>int socket(int domain, int type, int protocol)</code></li>
<li>例如 <code>int clientfd = socket(AF_INET, SOCK_STREAM, 0);</code></li>
<li><code>AF_INET</code> 表示在使用 32 位 IPv4 地址</li>
<li><code>SOCK_STREAM</code> 表示这个 socket 将是 connection 的 endpoint</li>
<li>前面这种写法是协议相关的，建议使用 <code>getaddrinfo</code> 生成的参数来进行配置，这样就是协议无关的了</li>
</ul>
</li>
<li><code>bind</code>: 请求 kernel 把 socket address 和 socket descriptor 绑定<ul>
<li><code>int bind(int sockfd, SA *addr, socklen_t addrlen);</code></li>
<li>The process can read bytes that arrive on the connection whose endpoint is <code>addr</code> by reading from descriptor <code>sockfd</code></li>
<li>Similarly, writes to <code>sockfd</code> are transferred along connection whose endpoint is <code>addr</code></li>
<li>最好是用 <code>getaddrinfo</code> 生成的参数作为 <code>addr</code> 和 <code>addrlen</code> </li>
</ul>
</li>
<li><code>listen</code>: 默认来说，我们从 <code>socket</code> 函数中得到的 descriptor 默认是 active socket（也就是客户端的连接），调用 <code>listen</code> 函数告诉 kernel 这个 socket 是被服务器使用的<ul>
<li><code>int listen(int sockfd, int backlog);</code></li>
<li>把 <code>sockfd</code> 从 active socket 转换成 listening socket，用来接收客户端的请求</li>
<li><code>backlog</code> 的数值表示 kernel 在接收多少个请求之后（队列缓存起来）开始拒绝请求</li>
</ul>
</li>
<li>[*]<code>accept</code>: 调用 <code>accept</code> 函数，开始等待客户端请求<ul>
<li><code>int accept(int listenfd, SA *addr, int *addrlen);</code></li>
<li>等待绑定到 <code>listenfd</code> 的连接接收到请求，然后把客户端的 socket address 写入到 <code>addr</code>，大小写入到 <code>addrlen</code></li>
<li>返回一个 connected descriptor 用来进行信息传输（类似 Unix I/O）</li>
<li>具体的过程可以参考 图3</li>
</ul>
</li>
</ul>
</li>
<li>开启客户端（<code>open_clientfd</code> 函数，设定访问地址，尝试连接）<ul>
<li><code>getaddrinfo</code>: 设置客户端的相关信息，具体可以参见 图1&amp;2</li>
<li><code>socket</code>: 创建 socket descriptor，也就是之后用来读写的 file descriptor</li>
<li><code>connect</code>: 客户端调用 <code>connect</code> 来建立和服务器的连接<ul>
<li><code>int connect(int clientfd, SA *addr, socklen_t addrlen);</code></li>
<li>尝试与在 socker address <code>addr</code> 的服务器建立连接</li>
<li>如果成功 <code>clientfd</code> 可以进行读写</li>
<li>connection 由 socket 对描述 <code>(x:y, addr.sin_addr:addr.sin_port)</code></li>
<li><code>x</code> 是客户端地址，<code>y</code> 是客户端临时端口，后面的两个是服务器的地址和端口</li>
<li>最好是用 <code>getaddrinfo</code> 生成的参数作为 <code>addr</code> 和 <code>addrlen</code> </li>
</ul>
</li>
</ul>
</li>
<li>交换数据（主要是一个流程循环，客户端向服务器写入，就是发送请求；服务器向客户端写入，就是发送响应）<ul>
<li>[Client]<code>rio_writen</code>: </li>
<li>[Client]<code>rio_readlineb</code>: </li>
<li>[Server]<code>rio_readlineb</code>:</li>
<li>[Server]<code>rio_writen</code>: </li>
</ul>
</li>
<li>关闭客户端（主要是 <code>close</code>）<ul>
<li>[Client]<code>close</code>:</li>
</ul>
</li>
<li>断开客户端（服务接收到客户端发来的 EOF 消息之后，断开已有的和客户端的连接）<ul>
<li>[Server]<code>rio_readlineb</code>:</li>
<li>[Server]<code>close</code>: </li>
</ul>
</li>
</ol>
<p><img src="/images/14599747281009.jpg" alt="图 1 Generic socket address"></p>
<p><img src="/images/14599747501489.jpg" alt="图 2 Socket Address Structures"></p>
<p><img src="/images/14599774536738.jpg" alt="图3 `accept` Illustrated"></p>
<blockquote>
<p>[Client]Connected Descriptor vs. [Server]Listening Descriptors</p>
</blockquote>
<p> 这两个的差别还是需要注意一下：</p>
<p> <img src="/images/14599776259093.jpg" alt=""></p>
<p>之所以要有这样的差别，是因为这样服务器可以同时处理多个请求（只要 fork 即可）</p>
<h2 id="u4EE3_u7801_u8BB2_u89E3"><a href="#u4EE3_u7801_u8BB2_u89E3" class="headerlink" title="代码讲解"></a>代码讲解</h2><blockquote>
<p>[Client] <code>open_clientfd</code></p>
</blockquote>
<p>用来建立和服务器的连接，协议无关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_clientfd</span><span class="params">(<span class="keyword">char</span> *hostname, <span class="keyword">char</span> *port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clientfd;</span><br><span class="line">    <span class="keyword">struct</span> addrinfo hints, *listp, *p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Get a list of potential server address</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">// Open a connection</span></span><br><span class="line">    hints.ai_flags = AI_NUMERICSERV; <span class="comment">// using numeric port arguments</span></span><br><span class="line">    hints.ai_flags |= AI_ADDRCONFIG; <span class="comment">// Recommended for connections</span></span><br><span class="line">    getaddrinfo(hostname, port, &amp;hints, &amp;listp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Walk the list for one that we can successfully connect to</span></span><br><span class="line">    <span class="comment">// 如果全部都失败，才最终返回失败（可能有多个地址）</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">// Create a socket descriptor</span></span><br><span class="line">        <span class="comment">// 这里使用从 getaddrinfo 中得到的参数，实现协议无关</span></span><br><span class="line">        <span class="keyword">if</span> ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</span><br><span class="line">                               p-&gt;ai_protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// Socket failed, try the next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Connect to the server</span></span><br><span class="line">        <span class="comment">// 这里使用从 getaddrinfo 中得到的参数，实现协议无关</span></span><br><span class="line">        <span class="keyword">if</span> (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Success</span></span><br><span class="line">        </span><br><span class="line">        close(clientfd); <span class="comment">// Connect failed, try another</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">// All connections failed</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// The last connect succeeded</span></span><br><span class="line">        <span class="keyword">return</span> clientfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[Server] <code>open_listenfd</code></p>
</blockquote>
<p>创建 listening descriptor，用来接收来自客户端的请求，协议无关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_listenfd</span><span class="params">(<span class="keyword">char</span> *port)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> addrinfo hints, *listp, *p;</span><br><span class="line">    <span class="keyword">int</span> listenfd, optval=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Get a list of potential server addresses</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">// Accept connection</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; <span class="comment">// on any IP address</span></span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV; <span class="comment">// using port number</span></span><br><span class="line">    <span class="comment">// 因为服务器不需要连接，所以原来填写地址的地方直接是 NULL</span></span><br><span class="line">    getaddrinfo(<span class="literal">NULL</span>, port, &amp;hints, &amp;listp); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Walk the list for one that we can successfully connect to</span></span><br><span class="line">    <span class="comment">// 如果全部都失败，才最终返回失败（可能有多个地址）</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">// Create a socket descriptor</span></span><br><span class="line">        <span class="comment">// 这里使用从 getaddrinfo 中得到的参数，实现协议无关</span></span><br><span class="line">        <span class="keyword">if</span> ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</span><br><span class="line">                               p-&gt;ai_protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// Socket failed, try the next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Eliminates "Address already in use" error from bind</span></span><br><span class="line">        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR), </span><br><span class="line">                    (<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;optval, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Bind the descriptor to the address</span></span><br><span class="line">        <span class="keyword">if</span> (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Success</span></span><br><span class="line">        </span><br><span class="line">        close(listenfd); <span class="comment">// Bind failed, try another</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">// No address worked</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Make it a listening socket ready to accept connection requests</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, LISTENQ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(listenfd);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一个简单的 socket 服务器实例</p>
<blockquote>
<p>Echo Client: Main Routine</p>
</blockquote>
<p>这个客户端做得事情很简单，就是把一段用户输入的文字发送到服务器，然后再把从服务器接收到的内容显示到输出中，具体可以参见注释</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// echoclient.c</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clientfd;</span><br><span class="line">    <span class="keyword">char</span> *host, *port, buf[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line">    </span><br><span class="line">    host = argv[<span class="number">1</span>];</span><br><span class="line">    port = argv[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建立连接（前面已经详细介绍）</span></span><br><span class="line">    clientfd = Open_clientfd(host, port);</span><br><span class="line">    Rio_readinitb(&amp;rio, clientfd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (Fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 写入，也就是向服务器发送信息</span></span><br><span class="line">        Rio_writen(clientfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="comment">// 读取，也就是从服务器接收信息</span></span><br><span class="line">        Rio_readlineb(&amp;rio, buf, MAXLINE);</span><br><span class="line">        <span class="comment">// 把从服务器接收的信息显示在输出中</span></span><br><span class="line">        Fputs(buf, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(clientfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative Echo Server: Main Rountine</p>
</blockquote>
<p>服务器做得工作也很简单，接收到从客户端发送的信息，然后返回一个一模一样的。具体参加注释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// echoserveri.c</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_storage clientaddr; <span class="comment">// Enough room for any addr</span></span><br><span class="line">    <span class="keyword">char</span> client_hostname[MAXLINE], client_port[MAXLINE];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启监听端口，注意只开这么一次</span></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要具体的大小</span></span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage); <span class="comment">// Important!</span></span><br><span class="line">        <span class="comment">// 等待连接</span></span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="comment">// 获取客户端相关信息</span></span><br><span class="line">        Getnameinfo((SA *) &amp;clientaddr, clientlen, client_hostname,</span><br><span class="line">                     MAXLINE, client_port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Connected to (%s, %s)\n"</span>, client_hostname, client_port);</span><br><span class="line">        <span class="comment">// 服务器具体完成的工作</span></span><br><span class="line">        echo(coonfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取从客户端传输过来的数据</span></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span>((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server received %d bytes\n"</span>, (<span class="keyword">int</span>)n);</span><br><span class="line">        <span class="comment">// 把从 client 接收到的信息再写回去</span></span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6D4B_u8BD5_u5DE5_u5177"><a href="#u6D4B_u8BD5_u5DE5_u5177" class="headerlink" title="测试工具"></a>测试工具</h2><p>测试的时候，我们可以使用 <code>telnet</code> 应用来测试服务器（只传输 ASCII 字符串的话，命令行工具无法显示图片），例如：</p>
<p>使用方法 <code>$ telnet &lt;host&gt; &lt;portnumber&gt;</code>，例如</p>
<p><img src="/images/14599877200828.jpg" alt="Testing Echo Server with `telnet`"></p>
<h2 id="Web__u670D_u52A1_u5668"><a href="#Web__u670D_u52A1_u5668" class="headerlink" title="Web 服务器"></a>Web 服务器</h2><p>客户端和服务器通过 HyperText Transfer Protocol(HTTP) 协议进行传输，具体的步骤是</p>
<ul>
<li>客户端和服务器建立 TCP 连接</li>
<li>客户端请求内容</li>
<li>服务器响应所请求的内容<ul>
<li>content: a sequence of bytes with an associated MIME (Multipurporse Internet Mail Extensions) types</li>
</ul>
</li>
<li>（最终）客户端和服务器关闭连接</li>
</ul>
<p><img src="/images/14599884494825.jpg" alt="Web Server Basics"></p>
<p>目前的版本是 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html" target="_blank" rel="external">HTTP/1.1 RFC 2616, June, 1999</a></p>
<p>一些 MIME 类型，更详细可见<a href="http://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank" rel="external">这里</a></p>
<ul>
<li><code>text/html</code> HTML document</li>
<li><code>text/plain</code> Unformatted text</li>
<li><code>image/gif</code> Binary image encoded in GIF format</li>
<li><code>image/png</code> Binary image encoded in PNG format</li>
<li><code>imgae/jpeg</code> Binary image encoded in JPEG format</li>
</ul>
<blockquote>
<p>静态内容与动态内容</p>
</blockquote>
<p>这部分比较简单，直接上图</p>
<p><img src="/images/14599890887501.jpg" alt=""></p>
<blockquote>
<p>URL 相关</p>
</blockquote>
<p>这部分比较简单，直接上图</p>
<p><img src="/images/14599891181741.jpg" alt=""></p>
<blockquote>
<p>HTTP Request</p>
</blockquote>
<p>这部分比较简单，直接上图</p>
<p><img src="/images/14599892040565.jpg" alt=""></p>
<blockquote>
<p>HTTP Responses</p>
</blockquote>
<p>这部分比较简单，直接上图</p>
<p><img src="/images/14599892360582.jpg" alt=""></p>
<blockquote>
<p>Example HTTP Transaction</p>
</blockquote>
<p><img src="/images/14599895910357.jpg" alt=""></p>
<p>剩下的概念主要是 CGI 应用，地址中 GET 表达形式，具体会在之后的习题课结合例子进行讲解，这里就不赘述了。不过还是要提一个重要概念：代理</p>
<blockquote>
<p>Proxies</p>
</blockquote>
<p><img src="/images/14599898580384.jpg" alt=""></p>
<p><img src="/images/14599898773522.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节课我们来学习如何编写 web 服务器！</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="网络" scheme="http://wdxtub.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解计算机系统 第 20 课 Network Programming I]]></title>
    <link href="http://wdxtub.com/2016/04/06/csapp-20/"/>
    <id>http://wdxtub.com/2016/04/06/csapp-20/</id>
    <published>2016-04-06T11:33:58.000Z</published>
    <updated>2016-04-06T15:53:03.000Z</updated>
    <content type="html"><![CDATA[<p>网络已经成为了我们『智能』生活中最重要的一部分，这两节课我们会通过 C API 来了解具体的网络相关编程（用更高层次的封装只会更轻松！）</p>
<a id="more"></a>
<hr>
<h2 id="u7F51_u7EDC_u67B6_u6784"><a href="#u7F51_u7EDC_u67B6_u6784" class="headerlink" title="网络架构"></a>网络架构</h2><p>计算机网络的知识可谓是非常『保值』的，因为这么多基础设备还在运行着，基本机制在短时间内很难改变，关于网络的另一个版本的讲解在<a href="/./2016/02/10/internet-protocol/">这里</a>，我觉得也非常不错，大家感兴趣可以看看。</p>
<p>客户端-服务器模型是网络应用最广泛使用的模型，作为耳熟能详的概念，这里不多提，相信通过下图就能大致明白：</p>
<p><img src="/images/14599482011858.jpg" alt=""></p>
<p>网络相关的处理，都是通过网络适配器来完成的，具体在硬件上为：</p>
<p><img src="/images/14599482515878.jpg" alt="Hardware Organization of a Network Host"></p>
<p>根据应用范围和架构层级，可以分成三个部分：</p>
<ul>
<li>SAN - System Area Network<ul>
<li>Switched Ethernet, Quadrics QSW, …</li>
</ul>
</li>
<li>LAN - Local Area Network<ul>
<li>Ethernet, ..</li>
</ul>
</li>
<li>WAN - Wide Area Network<ul>
<li>High speed point-to-point phone lines</li>
</ul>
</li>
</ul>
<blockquote>
<p>最底层 - Ethernet Segment</p>
</blockquote>
<p>Ethernet segment consists of a collection of <strong>hosts</strong> connected by wires (twisted pairs) to a <strong>hub</strong>.</p>
<p>通常范围是房间或一层楼</p>
<p><img src="/images/14599485111822.jpg" alt="Ethernet Segment"></p>
<ul>
<li>每个 Ethernet 适配器有一个唯一的 48 位的地址（也就是 MAC 地址），例如 <code>00:16:ea:e3:54:e6</code></li>
<li>不同主机间发送的数据称为帧(frame)</li>
<li>Hub 会把每个端口发来的所有数据复制到其他的端口<ul>
<li>所有的主机都可以看到所有的数据（注意安全问题）</li>
</ul>
</li>
</ul>
<blockquote>
<p>下一层 - Bridged Ethernet Segment</p>
</blockquote>
<p><img src="/images/14599487658645.jpg" alt="Bridged Ethernet Segment"></p>
<p>通常范围是一层楼，通过不同的 bridge 来连接不同的 ethernet segment。Bridge 知道从某端口出发可达的主机，并有选择的在端口间复制数据。</p>
<p>为了从概念上简化，我们可以认为，所有的 hub, bridge 可以抽象为一条线，如下图所示：</p>
<p><img src="/images/14599488669806.jpg" alt="Conceptual View of LANs"></p>
<blockquote>
<p>下一层 - internets</p>
</blockquote>
<p>不同的（也许不兼容）的 LAN 可以通过 router 来进行物理上的连接，这样连接起来的网络称为 internet（注意是小写，大写的 Internet 可以认为是最著名的 internet）</p>
<p><img src="/images/14599491906184.jpg" alt="internets"></p>
<blockquote>
<p>internet 的逻辑结构</p>
</blockquote>
<p><img src="/images/14599492763163.jpg" alt="Logical Structure of an internet"></p>
<ul>
<li>Ad hoc interconnection of networks<ul>
<li>没有特定的拓扑结构</li>
<li>不同的 router 和 link 差异可能很大</li>
</ul>
</li>
<li>通过在不同的网络间跳转来传递 packet<ul>
<li>Router 是不同网络间的连接</li>
<li>不同的 packet 可能会走不同的路线</li>
</ul>
</li>
</ul>
<h2 id="u7F51_u7EDC_u534F_u8BAE"><a href="#u7F51_u7EDC_u534F_u8BAE" class="headerlink" title="网络协议"></a>网络协议</h2><p>在不同的 LAN 和 WAN 中传输数据，就要守规矩，这个规矩就是协议。协议负责做的事情有：</p>
<ul>
<li>提供 naming scheme<ul>
<li>定义 host address 格式</li>
<li>每个主机和路由器都至少有一个独立的 internet 地址</li>
</ul>
</li>
<li>提供 delivery mechanism<ul>
<li>定义了标准的传输单元 - packet</li>
<li>Packet 包含 header 和 payload<ul>
<li>header 包括 packet size, source 和 destination address</li>
<li>payload 包括需要传输的数据  </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在这样的协议下，具体的数据传输是：</p>
<p><img src="/images/14599502534733.jpg" alt="Transferring internet Data Via Encapsulation"></p>
<p>PH = Internet packet header, FH = LAN frame header</p>
<blockquote>
<p>Globle IP Internet(upper case)</p>
</blockquote>
<p>Internet 是 internet 最为著名的例子。主要基于 TCP/IP 协议族：</p>
<ul>
<li>IP (Internet Protocal)<ul>
<li>Provides <strong>basic naming scheme</strong> and unreliable <strong>delivery capability</strong> of packets (datagrams) from <strong>host-to-host</strong></li>
</ul>
</li>
<li>UDP (Unreliable Datagram Protocol)<ul>
<li>Uses IP to provide <strong>unreliable</strong> datagram delivery from <strong>process-to-process</strong></li>
</ul>
</li>
<li>TCP (Transmission Control Protocol)<ul>
<li>Uses IP to provide <strong>reliable</strong> byte streams from <strong>process-to-process</strong> over <strong>connections</strong></li>
</ul>
</li>
</ul>
<p>Accessed via a mix of Unix file I/O and functions from <strong>sockets interface</strong>.（很多东西不是很好翻译，用原文比较准确）</p>
<p><img src="/images/14599506938536.jpg" alt="Hardware and Software Organization of an Internet Application"></p>
<h2 id="Internet__u7684_u7A0B_u5E8F_u5458_u89C6_u89D2"><a href="#Internet__u7684_u7A0B_u5E8F_u5458_u89C6_u89D2" class="headerlink" title="Internet 的程序员视角"></a>Internet 的程序员视角</h2><ul>
<li>主机有 32 位的 IP 地址 - 23.235.46.133<ul>
<li>IPv4 - 32 位地址，IPv6 - 128 位地址</li>
</ul>
</li>
<li>IP 地址被映射到域名 - 23.235.46.133 映射到 www.wdxtub.com</li>
<li>不同主机之间的进程，可以通过 connection 来交换数据</li>
</ul>
<blockquote>
<p>IP 地址</p>
</blockquote>
<p>我们会用一个叫做 IP address stuct 的东西来存储，并且 IP 地址是以 network byte order（也就是大端）来进行存储的</p>
<p><img src="/images/14599515895838.jpg" alt="IP Address"></p>
<p>为了方便读，一般用下图的形式来进行表示：</p>
<p><img src="/images/14599516332783.jpg" alt=""></p>
<p>具体的转换可以使用 <code>getaddrinfo</code> 和 <code>getnameinfo</code> 函数</p>
<blockquote>
<p>Internet 域名</p>
</blockquote>
<p><img src="/images/14599516793840.jpg" alt="Internet Domain Names"></p>
<p>这里主要需要了解的就是 Domain Naming System(DNS) 的概念，用来做 IP 地址到域名的映射。具体可以用 <code>nslookup</code> 命令来查看，下面是一些例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">wdxtub.local</span><br><span class="line"></span><br><span class="line">$ nslookup www.wdxtub.com</span><br><span class="line">Server:		<span class="number">8.8</span>.<span class="number">8.8</span></span><br><span class="line">Address:	<span class="number">8.8</span>.<span class="number">8.8</span><span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.wdxtub.com	canonical name = wdxtub.github.io.</span><br><span class="line">wdxtub.github.io	canonical name = github.map.fastly.net.</span><br><span class="line">Name:	github.map.fastly.net</span><br><span class="line">Address: <span class="number">23.235</span>.<span class="number">39.133</span></span><br><span class="line"></span><br><span class="line">$ nslookup www.twitter.com</span><br><span class="line">Server:		<span class="number">8.8</span>.<span class="number">8.8</span></span><br><span class="line">Address:	<span class="number">8.8</span>.<span class="number">8.8</span><span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.twitter.com	canonical name = twitter.com.</span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: <span class="number">199.16</span>.<span class="number">156.6</span></span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: <span class="number">199.16</span>.<span class="number">156.198</span></span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: <span class="number">199.16</span>.<span class="number">156.230</span></span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: <span class="number">199.16</span>.<span class="number">156.70</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Internet Connections</p>
</blockquote>
<p>客户端和服务器通过 connection 来发送字节流，特点是：</p>
<ul>
<li>Point-to-point: 连接一对进程</li>
<li>Full-duplex: 数据同时可以在两个方向流动</li>
<li>Reliable: 字节的发送的顺序和收到的一致</li>
</ul>
<p>Socket 则可以认为是 connection 的 endpoint，socket 地址是一个 <code>IPaddress:port</code> 对。</p>
<p>Port（端口）是一个 16 位的整数，用来标识不同的进程：</p>
<ul>
<li>Ephemeral port: Assigned automatically by client kernel when client makes a connection request</li>
<li>Well-known port: Associated with some <strong>service</strong> provided by a server（在 linux 系统上可以在 <code>/etc/services</code> 中查看具体的信息）<ul>
<li>echo server: 7/echo</li>
<li>ssh server: 22/ssh</li>
<li>email server: 25/smtp</li>
<li>web servers: 80/http</li>
</ul>
</li>
</ul>
<blockquote>
<p>Connection 详解</p>
</blockquote>
<p>A connection is uniquely identified by the socket addresses of its endpoints(socket pair - cliaddr:cliport, servaddr: servport)</p>
<p><img src="/images/14599531325600.jpg" alt="Anatomy of a Connection"></p>
<p>利用不同的端口来连接不同的服务：</p>
<p><img src="/images/14599534610996.jpg" alt="Using Ports to Identify Services"></p>
<blockquote>
<p>Socket Interface</p>
</blockquote>
<p>一系列系统级的函数，和 Unix I/O 配合构造网络应用（在所有的现代操作系统上都可用）。</p>
<p>对于 kernel 来说，socket 是 endpoint of communication；对于应用程序来说，socket 是 file descriptor，用来读写（回忆一下，STDIN 和 STDOUT 也是 file descriptor）。客户端和服务器通过读写对应的 socket descriptor 来进行。</p>
<p><img src="/images/14599559864957.jpg" alt=""></p>
<p>The main distinction between regular file I/O and socket I/O is how the application “opens” the socket descriptors.</p>
<blockquote>
<p>Generic socket address</p>
</blockquote>
<p><img src="/images/14599561357752.jpg" alt=""></p>
<blockquote>
<p>Internet-specific socket address</p>
</blockquote>
<p>实际上占用同样的空间，但是有更详细的信息</p>
<p><img src="/images/14599561803255.jpg" alt=""></p>
<p>总体的流程为：</p>
<p><img src="/images/14599565974716.jpg" alt=""></p>
<h2 id="u5E38_u7528_u51FD_u6570"><a href="#u5E38_u7528_u51FD_u6570" class="headerlink" title="常用函数"></a>常用函数</h2><p>接下来直接用 PPT 介绍两个重要函数 <code>getaddrinfo</code> 和 <code>getnameinfo</code></p>
<blockquote>
<p>getaddrinfo</p>
</blockquote>
<p>用来把 hostname, host address, port, service name 的字符串表示转换成 socket address 结构。</p>
<p><img src="/images/14599569037369.jpg" alt=""></p>
<p>函数原型为：</p>
<p><img src="/images/14599569254580.jpg" alt=""></p>
<p>这里具体说一下 <code>result</code> 这个链表：</p>
<p><img src="/images/14599569748746.jpg" alt="Linked List Returned by `getaddrinfo`"></p>
<p> 客户端需要遍历这个列表，按顺序访问每个 socket address，直到 <code>socket</code> 和 <code>connect</code> 函数调用成功。</p>
<p> 服务器需要遍历这个列表，直到 <code>socket</code> 和  <code>bind</code> 函数调用成功</p>
<p>每个 <code>addrinfo</code> 结构体为</p>
<p><img src="/images/14599573080061.jpg" alt="addrinfo Struct"></p>
<blockquote>
<p>getnameinfo</p>
</blockquote>
<p>刚好和 <code>getaddrinfo</code> 相反，把 socket address 转换成对应的字符串信息，函数原型为</p>
<p><img src="/images/14599575876044.jpg" alt=""></p>
<p>举个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hostinfo.c</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> addrinfo *p, *listp, hints;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> rc, flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Get a list of addrinfo records</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_family = AF_INET; <span class="comment">// IPv4 only</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">// Connections only</span></span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(argv[<span class="number">1</span>], <span class="literal">NULL</span>, &amp;hints, &amp;listp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"getaddrinfo error: %s\n"</span>, gai_strerror(rc));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Walk the list and display each IP address</span></span><br><span class="line">    flags = NI_NUMERICHOST; <span class="comment">// Display address instead of name</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        getnameinfo(p-&gt;ai_addr, p-&gt;ai_addrlen, buf, MAXLINE, <span class="literal">NULL</span>, <span class="number">0</span>, flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>网络已经成为了我们『智能』生活中最重要的一部分，这两节课我们会通过 C API 来了解具体的网络相关编程（用更高层次的封装只会更轻松！）</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="组成原理" scheme="http://wdxtub.com/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="网络" scheme="http://wdxtub.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker 碎碎念]]></title>
    <link href="http://wdxtub.com/2016/04/03/docker-gossip/"/>
    <id>http://wdxtub.com/2016/04/03/docker-gossip/</id>
    <published>2016-04-03T19:14:10.000Z</published>
    <updated>2016-04-03T22:35:01.000Z</updated>
    <content type="html"><![CDATA[<p>这篇日志主要来自 Docker 的应用及部署实践，算是从感性的角度来了解 Docker。</p>
<a id="more"></a>
<hr>
<p>以 Docker 为代表的容器技术模糊了 IaaS 与 PaaS 之间的界限，为云计算的服务形式带来了一个开放的未来。</p>
<p>一些言论：</p>
<ul>
<li>对 Docker 大规模应用到生产环境需要谨慎，但是仅考虑测试和开发，是可以真正解决环境部署问题的好办法</li>
<li>将所有服务放在一个容器叫做 Fat Container</li>
<li>Docker 天然适合一个容器只运行一种服务（官方更推荐）<ul>
<li>为每个服务创建单独文件夹，并在每个文件夹下放一个 Dockerfile</li>
</ul>
</li>
<li>每个容器只运行单一服务，容器间的互相通信有两种办法：<ul>
<li>将容器端口绑定到一个本地端口，通过端口通讯</li>
<li>通过 Docker 提供的 Linking 功能，推荐使用 Docker-Compose</li>
</ul>
</li>
<li>当前容器技术面临的最大阻力是安全问题和管理工具</li>
<li>学习 Docker 的三个阶段<ul>
<li>Docker 本身功能的使用</li>
<li>驾驭 Docker 集群（使用 Kubernetes, Shipyard, Machine+Swarm+Compose）</li>
<li>为场景和业务深度定制</li>
</ul>
</li>
<li>Docker 面临的最大阻碍 <ul>
<li>Docker 所属公司本身的强势，想做一揽子事情的态度，这使得 Docker 现在非常臃肿</li>
<li>不要把眼光局限在 Docker 上面，让 Docker 只做容器的事情</li>
</ul>
</li>
</ul>
<blockquote>
<p>除非你不想做，不想做就算了，想做好的话就不可能不劳而获</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">差劲的叛逆者</th>
<th style="text-align:center">优秀的叛逆者</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">抱怨</td>
<td style="text-align:center">创造</td>
</tr>
<tr>
<td style="text-align:center">断言</td>
<td style="text-align:center">质疑</td>
</tr>
<tr>
<td style="text-align:center">关注个人</td>
<td style="text-align:center">关注任务</td>
</tr>
<tr>
<td style="text-align:center">悲观</td>
<td style="text-align:center">乐观</td>
</tr>
<tr>
<td style="text-align:center">愤怒</td>
<td style="text-align:center">热情</td>
</tr>
<tr>
<td style="text-align:center">耗费能量</td>
<td style="text-align:center">生成能量</td>
</tr>
<tr>
<td style="text-align:center">疏离</td>
<td style="text-align:center">吸引</td>
</tr>
<tr>
<td style="text-align:center">问题</td>
<td style="text-align:center">可能性</td>
</tr>
<tr>
<td style="text-align:center">抱怨问题</td>
<td style="text-align:center">寻找机会</td>
</tr>
<tr>
<td style="text-align:center">担心</td>
<td style="text-align:center">希冀</td>
</tr>
<tr>
<td style="text-align:center">指责他人</td>
<td style="text-align:center">指出原因</td>
</tr>
<tr>
<td style="text-align:center">困扰</td>
<td style="text-align:center">反抗</td>
</tr>
<tr>
<td style="text-align:center">说教</td>
<td style="text-align:center">倾听</td>
</tr>
</tbody>
</table>
<p>成功叛逆者的秘密</p>
<table>
<thead>
<tr>
<th style="text-align:left">策略：实现特定目标的行动</th>
<th style="text-align:left">行为：你的行为举止，特别是对他人时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">利用他人的才华，明白没人能独自完成意义重大的改变</td>
<td style="text-align:left">保持乐观，鼓舞他人加入解决问题的行列</td>
</tr>
<tr>
<td style="text-align:left">将自己的想法和组织的目标统一起来</td>
<td style="text-align:left">评论想法，不评论人；讨论想法和想法的价值</td>
</tr>
<tr>
<td style="text-align:left">展现改变带来的好处与代价相称</td>
<td style="text-align:left">从愤怒中学习：思考是什么引发了愤怒，避免陷入情绪闹剧</td>
</tr>
<tr>
<td style="text-align:left">有效利用冲突：探究分歧和冲突，学习如何完善和推进一个想法</td>
<td style="text-align:left">尊重他人并考虑不同的观点</td>
</tr>
<tr>
<td style="text-align:left">不操之过急：给他人实践来接受新想法并思考它的影响</td>
<td style="text-align:left">知道何时该放弃坚持，懂得权衡想法的重要性和固执的代价</td>
</tr>
</tbody>
</table>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.wolonge.com/zhuanlan/detail/117441" target="_blank" rel="external">Docker在PHP项目开发环境中的应用</a></li>
<li><a href="http://news.oneapm.com/mesos-docker-go/" target="_blank" rel="external">通过 Mesos、Docker 和 Go，使用 300 行代码创建一个分布式系统</a></li>
<li>《Docker 开发实践》</li>
<li>《Docker——容器与容器云》</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇日志主要来自 Docker 的应用及部署实践，算是从感性的角度来了解 Docker。</p>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://wdxtub.com/tags/Docker/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="平台" scheme="http://wdxtub.com/tags/%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker 基本概念]]></title>
    <link href="http://wdxtub.com/2016/04/03/docker-basic-concept/"/>
    <id>http://wdxtub.com/2016/04/03/docker-basic-concept/</id>
    <published>2016-04-03T10:03:09.000Z</published>
    <updated>2016-04-03T17:56:32.000Z</updated>
    <content type="html"><![CDATA[<p>在 <a href="/./2016/04/02/docker-first-step/">Docker 快速入门及试验环境配置</a>中我们通过一个例子简单了解了 docker 的使用。这篇文章会从基本概念出发，用实际操作去更加深入理解 docker。</p>
<a id="more"></a>
<hr>
<p>具体的安装部分这里不赘述，可以在 <a href="/./2016/04/02/docker-first-step/">Docker 快速入门及试验环境配置</a> 的『安装』部分找到。</p>
<p>先大概复习一下基本概念：</p>
<p>主要是三个：</p>
<ul>
<li>镜像(Image)<ul>
<li>一个只读的模板，镜像可以用来创建 Docker 容器</li>
<li>可以简单创建或更新现有镜像，或者直接下载使用其他人的</li>
</ul>
</li>
<li>容器(Container)<ul>
<li>容器是从镜像创建的运行实例，在启动的时候创建一层可写层作为最上层（因为镜像是只读的）</li>
<li>可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台</li>
<li>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序</li>
</ul>
</li>
<li>仓库(Repository)<ul>
<li>集中存放镜像文件的场所</li>
<li>最大的公开仓库是 <a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a></li>
<li>国内的公开仓库包括 <a href="http://www.dockerpool.com/" target="_blank" rel="external">Docker Pool</a> 等</li>
<li>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了</li>
<li>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务</li>
</ul>
</li>
</ul>
<h2 id="u955C_u50CF"><a href="#u955C_u50CF" class="headerlink" title="镜像"></a>镜像</h2><p>我们可以使用 <code>docker pull</code> 命令从仓库中获取所需要的镜像。比如说 <code>sudo docker pull ubuntu:12.04</code>，相当于 <code>sudo docker pull registry.hub.docker.com/ubuntu:12.04</code>，即从注册服务器 <code>registry.hub.docker.com</code> 中的 <code>ubuntu</code> 仓库来下载标记为<code>12.04</code> 的镜像。</p>
<p>如果想从其他仓库注册服务器下载，需要输入完成的地址，例如：<code>sudo docker pull dl.dockerpool.com:5000/ubuntu:12.04</code></p>
<p>下载完成之后就可以使用该镜像了，比如下面的语句就会创建容器，其中运行 <code>bash</code>：<code>sudo docker run -t -i ubuntu:12.04 /bin/bash</code></p>
<p>可以使用 <code>dokcer images</code> 来显示本地已有的镜像，如下</p>
<p><img src="/images/14596963929829.jpg" alt="docker images"></p>
<p>具体字段的意思一目了然，这里不再赘述。然后我们来运行官方例子 <code>whalesay</code> 镜像。</p>
<h3 id="u8FD0_u884C_u955C_u50CF"><a href="#u8FD0_u884C_u955C_u50CF" class="headerlink" title="运行镜像"></a>运行镜像</h3><p>打开浏览器，进入 <a href="https://hub.docker.com/?utm_source=getting_started_guide&amp;utm_medium=embedded_Linux&amp;utm_campaign=find_whalesay" target="_blank" rel="external">Docker Hub</a></p>
<p><img src="/images/14596967621449.jpg" alt="Docker Hub"></p>
<p>搜索 <code>whalesay</code> 这个镜像，就可以看到结果，点进去可以看到详细内容（基于 Ubuntu）</p>
<p><img src="/images/14596968187418.jpg" alt="whalesay image"></p>
<p>然后我们来运行一下，使用命令 <code>docker run docker/whalesay cowsay boo</code>，其中 <code>cowsay</code> 是要运行的命令，后面的 <code>boo</code> 是参数。</p>
<p>Docker 会先在本地查找有没有镜像，如果没有就从仓库中下载，具体的运行结果是：</p>
<p><img src="/images/14596971019958.jpg" alt="cowsay boo"></p>
<p>也可以让鲸鱼说不同的话，比如：</p>
<p><img src="/images/14596971443647.jpg" alt=""></p>
<h3 id="u5236_u4F5C_u955C_u50CF"><a href="#u5236_u4F5C_u955C_u50CF" class="headerlink" title="制作镜像"></a>制作镜像</h3><p>如果想要制作自己的镜像，需要自己写 Dockerfile。具体步骤如下</p>
<ol>
<li>创建一个文件夹 <code>mkdir wdxtub; cd wdxtub</code>，构造镜像所需的所有东西都会放在这个文件夹中</li>
<li>创建一个名为 <code>Dockerfile</code> 的文件 <code>gedit Dockerfile</code></li>
<li>添加第一句话 <code>FROM docker/whalesay:latest</code>，表示我们的镜像以 <code>whalesay</code> 为基础</li>
<li>添加需要运行的命令，如 <code>RUN apt-get -y update &amp;&amp; apt-get install -y fortunes</code>（<code>fortunes</code> 这个程序会输出名言警句）</li>
<li>通过 <code>CMD</code> 指定镜像载入之后需要执行的命令，如 <code>CMD /usr/games/fortune -a | cowsay</code></li>
<li>保存并关闭 Dockerfile</li>
<li>使用 <code>sudo docker build -t wdx-whale .</code> 来构造镜像，简单来说就是用 Dockerfile 中的内容按步骤构造</li>
<li>使用 <code>docker images</code> 应该就可以看到我们新创建的镜像</li>
</ol>
<p><img src="/images/14596980285832.jpg" alt="wdx-whale image"></p>
<p>然后我们就可以运行一下看看 <code>docker run wdx-whale</code></p>
<p><img src="/images/14596980932968.jpg" alt="搞笑句"></p>
<p>还有更贱的（感觉可以玩一天）</p>
<p><img src="/images/14596987783177.jpg" alt=""></p>
<p>如果想要把自己的镜像上传到网上，就需要注册一个 Docker Hub 帐号，然后点击 Create Repository，这里我创建了一个名为 <code>wdxtub/demo</code> 的公用仓库。</p>
<p>接下来我们需要打上 tag，目前 <code>docker images</code> 的情况是：</p>
<p><img src="/images/14596980285832.jpg" alt="wdx-whale image"></p>
<p>记住我们的 IMAGE ID 26ac9649d7da。用以下命令打 tag <code>docker tag 26ac9649d7da wdxtub/wdx-whale:latest</code>，然后再 <code>docker images</code> 一次：</p>
<p><img src="/images/14596998719751.jpg" alt=""></p>
<p>然后用这个命令登录 <code>docker login --username=yourhubusername --email=youremail@company.com</code>，对于我来说就是 <code>docker login --username=wdxtub --email=dacrocodilee@gmail.com</code></p>
<p>成功之后大概是这样：</p>
<p><img src="/images/14596999803535.jpg" alt="登录成功"></p>
<p>然后就可以 push 上去了 <code>docker push wdxtub/wdx-whale</code>，像下面这样</p>
<p><img src="/images/14597002872580.jpg" alt="push"></p>
<p>为了测试 pull 自己的镜像，我们先把本地上的 whale 镜像删掉：<code>docker rmi -f wdxtub/wdx-whale; docker rmi -f wdx-whale</code>（如果有其他的用不着的也都删掉），最后剩下（上课要用的镜像）：</p>
<p><img src="/images/14597004851281.jpg" alt=""></p>
<p>接着来运行一下 <code>docker run wdxtub/wdx-whale</code></p>
<h3 id="u7BA1_u7406_u955C_u50CF"><a href="#u7BA1_u7406_u955C_u50CF" class="headerlink" title="管理镜像"></a>管理镜像</h3><p>我们可以把镜像导出到本地文件，使用 <code>docker save</code> 命令即可，比如针对我现在有的镜像 <code>wdxtub/wdx-whale(id:26ac9649d7da)</code>，可以这样：<code>docker save -o wdx-local-whale.tar wdxtub/wdx-whale</code>。如果要载入的话，使用下面的命令即可（会载入相关的元数据信息）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker load --input wdx-local-whale.tar</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker load &lt; wdx-local-whale.tar</span><br></pre></td></tr></table></figure>
<p>在删除镜像之前要先用 <code>docker rm</code> 删掉依赖于这个镜像的所有容器.</p>
<p><code>sudo docker rmi $(docker images -q -f &quot;dangling=true&quot;)</code></p>
<blockquote>
<p>镜像的实现原理</p>
</blockquote>
<p>Docker 镜像是怎么实现增量的修改和维护的？ 每个镜像都由很多层次构成，Docker 使用 <a href="http://en.wikipedia.org/wiki/UnionFS" target="_blank" rel="external">Union FS</a> 将这些不同的层结合到一个镜像中去。</p>
<p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。 Docker 在 AUFS 上构建的容器也是利用了类似的原理。</p>
<h2 id="u5BB9_u5668"><a href="#u5BB9_u5668" class="headerlink" title="容器"></a>容器</h2><p>容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>
<p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器（对于初级应用来说后者更方便）。</p>
<p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<p>可以利用 <code>docker start</code> 命令，直接将一个已经终止的容器启动运行。<br>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p>
<h3 id="u542F_u52A8"><a href="#u542F_u52A8" class="headerlink" title="启动"></a>启动</h3><p>举个例子，我们来创建一个 ubuntu:14.04 的容器 <code>docker run ubuntu:14.04 /bin/echo &#39;Hello wdx!&#39;</code></p>
<p><img src="/images/14597044909422.jpg" alt=""></p>
<p>用 <code>docker run -t -i ubuntu:14.04 /bin/bash</code> 可以启动一个 bash 终端用来交互。其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。我们可以输入一些命令来测试</p>
<p><img src="/images/14597046071804.jpg" alt=""></p>
<p>我们用 <code>ps</code> 或 <code>top</code> 在伪终端中查看进程信息，可以看到：</p>
<p><img src="/images/14597046832387.jpg" alt=""></p>
<p>输入 <code>exit</code> 可以退出 docker</p>
<p>容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p>
<h3 id="u540E_u53F0_u8FD0_u884C"><a href="#u540E_u53F0_u8FD0_u884C" class="headerlink" title="后台运行"></a>后台运行</h3><p>更多的时候，需要让 Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。</p>
<p>下面举两个例子来说明一下。</p>
<p>如果不使用 -d 参数运行容器 <code>docker run ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code> 容器会把输出的结果(STDOUT)打印到宿主机上面</p>
<p><img src="/images/14597048507796.jpg" alt=""></p>
<p>如果使用了 -d 参数运行容器 <code>docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code>，则显示是这样：</p>
<p><img src="/images/14597049156842.jpg" alt=""></p>
<p>使用 <code>docker logs containerid</code> 可以查看输出，如：</p>
<p><img src="/images/14597049744299.jpg" alt=""></p>
<p>使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker ps 命令来查看容器信息。容器是否会长久运行，是和docker run指定的命令有关，和 -d 参数无关</p>
<p>在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作，有很多种方法，包括使用 docker attach 命令或 nsenter 工具等。具体参考<a href="https://yeasy.gitbooks.io/docker_practice/content/container/enter.html" target="_blank" rel="external">这里</a></p>
<h3 id="u7EC8_u6B62_u4E0E_u91CD_u65B0_u542F_u52A8"><a href="#u7EC8_u6B62_u4E0E_u91CD_u65B0_u542F_u52A8" class="headerlink" title="终止与重新启动"></a>终止与重新启动</h3><p>使用 <code>docker stop containerid</code> 来终止容器。终止状态的容器可以用 <code>docker ps -a</code> 命令看到。</p>
<p>另外，<code>docker restart containerid</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h3 id="u5BFC_u5165_u5BFC_u51FA_u4E0E_u5220_u9664"><a href="#u5BFC_u5165_u5BFC_u51FA_u4E0E_u5220_u9664" class="headerlink" title="导入导出与删除"></a>导入导出与删除</h3><p>如果要导出本地某个容器，可以使用 <code>docker export containerid</code> 命令。</p>
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat ubuntu.tar | sudo docker import - <span class="built_in">test</span>/ubuntu:v1.<span class="number">0</span></span><br><span class="line"><span class="comment"># 也可以通过指定 URL 或者某个目录来导入，例如</span></span><br><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>
<p>用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<p>可以使用 <code>docker rm</code> 来删除一个处于终止状态的容器。如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</p>
<p>用 <code>docker ps -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用 <code>docker rm $(docker ps -a -q)</code> 可以全部清理掉。</p>
<p>注意：这个命令其实会试图删除所有的包括还在运行中的容器，不过就像上面提过的<code>docker rm</code> 默认并不会删除运行中的容器。</p>
<h2 id="u4ED3_u5E93"><a href="#u4ED3_u5E93" class="headerlink" title="仓库"></a>仓库</h2><p>仓库（Repository）是集中存放镜像的地方。</p>
<p>一个容易混淆的概念是注册服务器（Registry）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址dl.dockerpool.com/ubuntu 来说，dl.dockerpool.com 是注册服务器地址，ubuntu是仓库名。</p>
<p>大部分时候，并不需要严格区分这两者的概念。相信信息可以直接看教程，这里不赘述了。</p>
<ul>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/dockerhub.html" target="_blank" rel="external">Docker Hub 指南</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/local_repo.html" target="_blank" rel="external">私有仓库指南</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/repository/config.html" target="_blank" rel="external">配置文件指南</a></li>
</ul>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="/Find and run the whalesay image">Find and run the whalesay image</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/image/create.html" target="_blank" rel="external">创建镜像</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/container/enter.html" target="_blank" rel="external">进入容器</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 <a href="/./2016/04/02/docker-first-step/">Docker 快速入门及试验环境配置</a>中我们通过一个例子简单了解了 docker 的使用。这篇文章会从基本概念出发，用实际操作去更加深入理解 docker。</p>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://wdxtub.com/tags/Docker/"/>
    
      <category term="概念" scheme="http://wdxtub.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker 快速入门及试验环境配置]]></title>
    <link href="http://wdxtub.com/2016/04/02/docker-first-step/"/>
    <id>http://wdxtub.com/2016/04/02/docker-first-step/</id>
    <published>2016-04-03T00:11:29.000Z</published>
    <updated>2016-04-04T00:48:18.000Z</updated>
    <content type="html"><![CDATA[<p>借着课程的机会来了解一下 Docker，大部分内容来自官方文档以及课程指引。</p>
<a id="more"></a>
<hr>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Docker 最初 dotCloud 公司内部的一个业余项目</li>
<li>Docker 基于 Go 语言</li>
<li>Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案</li>
<li>Docker 的基础是 Linux 容器（LXC）等技术</li>
<li>Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多</li>
<li>Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器</li>
</ul>
<p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</p>
<p><img src="/images/14596424862659.png" alt=""></p>
<p><img src="/images/14596424920098.png" alt=""></p>
<p>容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。</p>
<p>主要优势为：</p>
<ul>
<li>更快速的交付和部署 - 容器成为了最小单位</li>
<li>更高效的虚拟化 - 内核级虚拟化</li>
<li>更轻松的迁移和拓展</li>
<li>更简单的管理</li>
</ul>
<h2 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h2><p>主要是三个：</p>
<ul>
<li>镜像(Image)<ul>
<li>一个只读的模板，镜像可以用来创建 Docker 容器</li>
<li>可以简单创建或更新现有镜像，或者直接下载使用其他人的</li>
</ul>
</li>
<li>容器(Container)<ul>
<li>容器是从镜像创建的运行实例，在启动的时候创建一层可写层作为最上层（因为镜像是只读的）</li>
<li>可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台</li>
<li>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序</li>
</ul>
</li>
<li>仓库(Repository)<ul>
<li>集中存放镜像文件的场所</li>
<li>最大的公开仓库是 <a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a></li>
<li>国内的公开仓库包括 <a href="http://www.dockerpool.com/" target="_blank" rel="external">Docker Pool</a> 等</li>
<li>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了</li>
<li>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务</li>
</ul>
</li>
</ul>
<h2 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h2><p>官方网站提供了 <a href="https://docs.docker.com/mac/" target="_blank" rel="external">Mac</a>, <a href="https://docs.docker.com/linux/" target="_blank" rel="external">Linux</a> 和 <a href="https://docs.docker.com/windows/" target="_blank" rel="external">Windows</a> 版本的安装教程。因为我打算使用虚拟机进行安装测试，所以这里主要走 Linux 的安装教程，不过其他的应该大同小异。我的 ubuntu 版本是 14.04 LTS, trusty</p>
<p>Docker 目前只能安装在 64 位平台上，并且要求内核版本不低于 3.10，实际上内核越新越好，过低的内核版本容易造成功能的不稳定。可以通过下面的命令来检查内核版本（两个方式，都可以）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parallels@ubuntu:~$ uname <span class="operator">-a</span>Linux ubuntu <span class="number">3.13</span>.<span class="number">0</span>-<span class="number">83</span>-generic <span class="comment">#127-Ubuntu SMP Fri Mar 11 00:25:37 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line">parallels@ubuntu:~$ cat /proc/versionLinux version <span class="number">3.13</span>.<span class="number">0</span>-<span class="number">83</span>-generic (buildd@lgw01-<span class="number">55</span>) (gcc version <span class="number">4.8</span>.<span class="number">2</span> (Ubuntu <span class="number">4.8</span>.<span class="number">2</span>-<span class="number">19</span>ubuntu1) ) <span class="comment">#127-Ubuntu SMP Fri Mar 11 00:25:37 UTC 2016</span></span><br></pre></td></tr></table></figure>
<p>这里我们按照官网的教程，不使用 <code>apt-get</code> 而是使用 <code>curl</code> 来进行安装。</p>
<ol>
<li>如果没有安装 <code>curl</code>，使用 <code>sudo apt-get update; sudo apt-get install curl</code> 来进行安装</li>
<li>下载最新的 Docker 包 <code>curl -fsSL https://get.docker.com/ | sh</code><ul>
<li>如果想要以 non-root 用户的角色来使用，请使用 <code>sudo usermod -aG docker parallels</code>（这里 <code>parallels</code> 是用户名），注意需要注销并重新登录以应用改动</li>
</ul>
</li>
<li>验证安装<ul>
<li>需要先启用 docker <code>sudo service docker start</code></li>
<li>然后可以用 <code>docker version</code> 来查看版本</li>
<li>最后使用 <code>docker run hello-world</code> 来测试</li>
</ul>
</li>
</ol>
<p>版本信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parallels@ubuntu:~$ docker versionClient: Version:      <span class="number">1.10</span><span class="number">.3</span> API version:  <span class="number">1.22</span> Go version:   go1<span class="number">.5</span><span class="number">.3</span> Git commit:   <span class="number">20f</span>81dd Built:        Thu Mar <span class="number">10</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">52</span> <span class="number">2016</span> OS/Arch:      linux/amd64Server: Version:      <span class="number">1.10</span><span class="number">.3</span> API version:  <span class="number">1.22</span> Go version:   go1<span class="number">.5</span><span class="number">.3</span> Git commit:   <span class="number">20f</span>81dd Built:        Thu Mar <span class="number">10</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">52</span> <span class="number">2016</span> OS/Arch:      linux/amd64</span><br></pre></td></tr></table></figure>
<p>成功运行 hello world 的结果</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parallels@ubuntu:~$ docker run hello-worldHello <span class="built_in">from</span> Docker.This message shows that your installation appears <span class="built_in">to</span> be working correctly.To generate this message, Docker took <span class="operator">the</span> following steps: <span class="number">1.</span> The Docker client contacted <span class="operator">the</span> Docker daemon. <span class="number">2.</span> The Docker daemon pulled <span class="operator">the</span> <span class="string">"hello-world"</span> image <span class="built_in">from</span> <span class="operator">the</span> Docker Hub. <span class="number">3.</span> The Docker daemon created <span class="operator">a</span> <span class="built_in">new</span> container <span class="built_in">from</span> that image which runs <span class="operator">the</span>    executable that produces <span class="operator">the</span> output you are currently reading. <span class="number">4.</span> The Docker daemon streamed that output <span class="built_in">to</span> <span class="operator">the</span> Docker client, which sent <span class="keyword">it</span>    <span class="built_in">to</span> your terminal.To <span class="keyword">try</span> something more ambitious, you can run <span class="operator">an</span> Ubuntu container <span class="operator">with</span>: $ docker run -<span class="keyword">it</span> ubuntu bashShare images, automate workflows, <span class="operator">and</span> more <span class="operator">with</span> <span class="operator">a</span> free Docker Hub account: <span class="keyword">https</span>://hub.docker.comFor more examples <span class="operator">and</span> ideas, visit: <span class="keyword">https</span>://docs.docker.com/userguide/</span><br></pre></td></tr></table></figure>
<p>这之后的部分是课程需求。</p>
<p>我们需要安装 docker machine 和 virtual box，具体步骤为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取权限</span></span><br><span class="line">$ sudo su</span><br><span class="line"><span class="comment"># 下载 Docker Machine 的二进制文件 </span></span><br><span class="line">$ curl -L https://github.com/docker/machine/releases/download/v0.<span class="number">6.0</span>/docker-machine-`uname <span class="operator">-s</span>`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-machine &amp;&amp; chmod +x /usr/<span class="built_in">local</span>/bin/docker-machine</span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">$ docker-machine version</span><br><span class="line">docker-machine version <span class="number">0.6</span>.<span class="number">0</span>, build e27fb87</span><br></pre></td></tr></table></figure>
<ul>
<li>添加源<ul>
<li>把这行添加到 <code>/etc/apt/sources.list</code> 文件中 <code>deb http://download.virtualbox.org/virtualbox/debian trusty contrib</code> </li>
<li><code>wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add -</code></li>
</ul>
</li>
<li>更新并安装 <code>sudo apt-get update; sudo apt-get install virtualbox-5.0</code></li>
</ul>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2><p>然后是一些配置，先重设默认的虚拟机 </p>
<ul>
<li>删除原来的默认（如果有的话）<code>docker-machine rm default</code></li>
<li>创建新的默认虚拟机 <code>docker-machine create --driver virtualbox default</code>（这一步可能需要等一下，我用的是 Parallel Desktop 11，还需要在虚拟机设置中开启 CPU 虚拟化，主要是支持 vt-x）</li>
</ul>
<p>然后如果直接在菜单中选择 Virtual Box 的话，就会发现什么都没有，技巧是要在刚才的命令行中输入 <code>virtualbox</code>，然后就可以看到下面的界面：</p>
<p><img src="/images/14596481872848.jpg" alt="default 就是我们刚才创建的虚拟机"></p>
<p>在 Settings - Network 中选择 Port Forwarding，然后按照如图所示添加记录</p>
<p><img src="/images/14596485001418.jpg" alt=""></p>
<p>这里的 Host Port: 9234 记为 A，Guest Port: 9001 记为 B。然后就可以启动 docker 中老师提供的镜像了：</p>
<p>命令为 <code>docker run -it -p 9001:9000 cmusvsc/apachecmda:1.1</code>（需要下载一段时间，然后再解压一段时间），这里 9001 记为 C，9000 记为 D。</p>
<p>接着就会直接连接到 docker 中的虚拟机，从之后的图中可以看到命令行前面的内容也变化了。然后我们输入命令开启前端 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/Spring2016/ApacheCMDA-Frontend</span><br><span class="line">./activator run <span class="comment"># 相当于在 9000 端口开启</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/14596510005751.jpg" alt="开启前端"></p>
<p>不要关现在的终端，开启一个新的终端。仍然 <code>docker run -it -p 9001:9000 cmusvsc/apachecmda:1.1</code></p>
<p>等待一段时间后，继续走以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/Spring2016/ApacheCMDA-Backend</span><br><span class="line">./activator <span class="string">"run 9034"</span></span><br></pre></td></tr></table></figure>
<p>然后可以见到 </p>
<p><img src="/images/14596503095705.jpg" alt="开启后端"></p>
<p>然后等待一段时间（第一运行需要编译），就可以见到主页面了：</p>
<p><img src="/images/14596510450895.jpg" alt="主界面"></p>
<p>还记得前面的端口转发吗？这里解释一下：</p>
<ul>
<li>A，也就是 9234，是用户访问的端口号</li>
<li>B，也就是 9001，我们通过虚拟机的端口转发从 9234 转到了 9001</li>
<li>C，也就是 9001（这个命令中的 <code>docker run -it -p 9001:9000 cmusvsc/apachecmda:1.1</code>），是虚拟机继续转发的端口</li>
<li>D，也就是 9000（这个命令中的 <code>docker run -it -p 9001:9000 cmusvsc/apachecmda:1.1</code>），是 Docker 容器中接收请求的端口。</li>
</ul>
<p>也就是说，B 和 C 一定要一样，A 和 D 可以在命令中设置。至于为什么后端需要运行在 9034 端口，是因为前端和后端通过这个端口通讯（应该是写死在代码里的）</p>
<p>挂载主机数据卷到容器内，可以通过如下命令进行文件夹映射</p>
<p><code>docker run -it -p 9999:9999 -p 9001:9000 -v ~/localFolder:/sharedFolder cmusvsc/apachecmda:1.1</code></p>
<p>从容器内拷贝文件到主机上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出 container</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 复制 这个不知道为啥不行</span></span><br><span class="line">docker cp &lt;containerId&gt;:/file/path/within/container /host/path/target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载映射</span></span><br><span class="line">docker run -it -v /home/parallels/Documents/code:/home/code cmusvsc/apachecmda:<span class="number">1.1</span></span><br><span class="line"><span class="comment"># 复制</span></span><br><span class="line">cp -r Spring2016/* ./code/</span><br></pre></td></tr></table></figure>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/docker/docker" target="_blank" rel="external">开源代码</a></li>
<li><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a></li>
<li><a href="https://docs.docker.com/machine/install-machine/" target="_blank" rel="external">Install Docker Machine</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>借着课程的机会来了解一下 Docker，大部分内容来自官方文档以及课程指引。</p>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://wdxtub.com/tags/Docker/"/>
    
      <category term="容器" scheme="http://wdxtub.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第十二周 - 正趣果上果]]></title>
    <link href="http://wdxtub.com/2016/04/02/the-fun/"/>
    <id>http://wdxtub.com/2016/04/02/the-fun/</id>
    <published>2016-04-02T12:58:28.000Z</published>
    <updated>2016-04-02T14:44:39.000Z</updated>
    <content type="html"><![CDATA[<p>人生在世三万天，趣果有间孤独无解，苦练含笑半步颠。心怀啮雪大志愿，被人称作小可怜。本欲歃血定风月，乌飞兔走光阴只负尾生约。</p>
<a id="more"></a>
<hr>
<p>习惯了没有四季的广州，在四季分明的匹兹堡，真的能感受到生机勃勃的味道。不过这都是用六个月的寒冬换来的，如果可以选的话，我宁愿放弃四季。虽然温差依然可以二十多度，好歹下午是可以开开心心去跑跑步了。离开之前，多看几眼。</p>
<p>对一个地方的感情，其实和在这个地方交到的朋友和自己的改变程度有关。在执信我既经历了自我的重大转变，也交到了许多挚友，理所当然是我感情密度最高的地方。</p>
<p>相对来说，在匹兹堡的这段时间，以另外的方式认识了很多朋友，也真正完成了一直以来想要完成的转身。华丽不华丽不知道，虽然还有这样那样的小问题，总体来说我是满意的。</p>
<p>陆陆续续在收拾行李，发现其实也没有多少要带回去的东西，因为一直都是以『游子』的心态在过日子，大件的东西不买，可能用到=不用，带不走的直接送人，轻轻来轻轻走。年年毕业季，年年卖闲置，我觉得为了几块钱几十块钱劳神费力真不值得，还不如以交朋友的心态直接送给有缘人。</p>
<p>慢慢熟悉了英文歌的套路之后，现在又开始听中文歌了，但是口味变了不少。从陈粒 Jam 程璧常石磊到屠洪刚韩磊刘欢，除了旋律之外，越来越在意歌词讲不讲究。除了标题是陈粒的『正趣果上果』外，我还想安利几首：</p>
<blockquote>
<p>给少年的歌 程璧</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">月亮悄悄蒙上一层纱 夜云悄悄隆起崖</span><br><span class="line">曾经年少的我啊 曾经痴心这么想</span><br><span class="line">如果有一天 如果有一个人</span><br><span class="line">陪我一起看花开 陪我一起看流霞</span><br><span class="line">我就想为谁 为谁唱起这首歌</span><br><span class="line">一首少年的歌 一首为你写的歌</span><br></pre></td></tr></table></figure>
<blockquote>
<p>晴日共剪窗 程璧</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">庭前花木满 院外小径芳</span><br><span class="line">四时常相往 晴日共剪窗</span><br></pre></td></tr></table></figure>
<blockquote>
<p>七月上 Jam</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我想你就站在，站在大漠边疆</span><br><span class="line">我想你就站在，站在七月上</span><br><span class="line">我化尘埃飞扬，追寻赤裸逆翔</span><br><span class="line">奔去七月刑场，时间烧灼滚烫</span><br><span class="line">回忆撕毁臆想，路上行走匆忙</span><br><span class="line">难能可贵世上，散播留香磁场</span><br></pre></td></tr></table></figure>
<blockquote>
<p>老爸 常石磊</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我在牵挂 你也在牵挂 是你引我走天涯</span><br><span class="line">你慢慢老 我渐渐长大 是你让我别想家</span><br><span class="line">你在牵挂 我也在牵挂 是你教我志在四方 什么都别怕 </span><br><span class="line">我不在家 你好好保重吧</span><br></pre></td></tr></table></figure>
<p>未来的选择，和选择的未来，更多是计划之后的顺其自然。</p>
<p>正趣果上果，归依天中天，一道长死生，有无离二边。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>人生在世三万天，趣果有间孤独无解，苦练含笑半步颠。心怀啮雪大志愿，被人称作小可怜。本欲歃血定风月，乌飞兔走光阴只负尾生约。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="反思" scheme="http://wdxtub.com/tags/%E5%8F%8D%E6%80%9D/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="选择" scheme="http://wdxtub.com/tags/%E9%80%89%E6%8B%A9/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Prolog 快速入门]]></title>
    <link href="http://wdxtub.com/2016/04/01/prolog-first-step/"/>
    <id>http://wdxtub.com/2016/04/01/prolog-first-step/</id>
    <published>2016-04-02T01:02:45.000Z</published>
    <updated>2016-04-02T15:45:43.000Z</updated>
    <content type="html"><![CDATA[<p>Prolog 是一门声明式编程语言，也是最早成功的逻辑编程语言之一。只需提供 fact 和 inference，程序会替我们进行推断。甚至不需要知道怎么做，只要告诉计算机要做什么即可。比方说，用不到 20 行代码解决数独问题。</p>
<a id="more"></a>
<hr>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><ul>
<li>1972 年由 Alain Colmerauer 和 Phillipe Roussel 开发完成</li>
<li>基于数据库，数据由逻辑规则和关系组成</li>
<li>包含两个部分：一部分用于描述数据，另一部分用于查询数据</li>
</ul>
<p>在 Prolog 中，数据以逻辑规则的形式存在，下面是基本构建单元：</p>
<ul>
<li>事实：关于真实世界的基本断言（Babe 是一头猪，猪喜欢泥巴）</li>
<li>规则：关于真实世界中的一些事实的推论（如果一个动物是猪，那么它喜欢泥巴）</li>
<li>查询：关于真实世界的一个问题（Babe 喜欢泥巴吗）</li>
</ul>
<p>事实和规则被放入一个知识库(knowledge base)。Prolog 编译器将这个知识库编译成一种适于高效查询的形式。</p>
<p>这里我们在 ubuntu 下做实验，直接 <code>sudo apt-get install gprolog</code> 即可</p>
<h2 id="u7F16_u7A0B_u6A21_u578B"><a href="#u7F16_u7A0B_u6A21_u578B" class="headerlink" title="编程模型"></a>编程模型</h2><p>Prolog 中，一个词以小写字母开头，就是一个原子(atom)——类似于 Ruby 中的符号(symbol)的固定值，如果一个词以大写字母或下划线开头，那么它就是一个变量。变量的值可以改变，原则则不能。</p>
<p>下面是一个简单的例子，先创建一个文件（比如 <code>friends.pl</code>），输入以下内容</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">likes</span>(<span class="atom">wallace</span>, <span class="atom">cheese</span>).</span><br><span class="line"><span class="atom">likes</span>(<span class="atom">grommit</span>, <span class="atom">cheese</span>).</span><br><span class="line"><span class="atom">likes</span>(<span class="atom">wendolene</span>, <span class="atom">sheep</span>).</span><br><span class="line"></span><br><span class="line"><span class="atom">friend</span>(<span class="name">X</span>, <span class="name">Y</span>) :- \+(<span class="name">X</span> = <span class="name">Y</span>), <span class="atom">likes</span>(<span class="name">X</span>, <span class="name">Z</span>), <span class="atom">likes</span>(<span class="name">Y</span>, <span class="name">Z</span>).</span><br></pre></td></tr></table></figure>
<p>上面这个文件就是由事实和规则组成的知识库。前三条语句是事实，最后一条语句是一个规则。<code>wallace</code>, <code>grommit</code> 和 <code>wendolene</code> 都是原子，翻译过来就是</p>
<ul>
<li><code>wallace</code> 喜欢 <code>cheese</code></li>
<li><code>grommit</code> 喜欢 <code>cheese</code></li>
<li><code>wendolene</code> 喜欢 <code>sheep</code></li>
</ul>
<p>具体执行时，先输入 <code>gprolog</code>，然后输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- [<span class="string">'friends.pl'</span>].compiling /home/parallels/Documents/friends.pl <span class="keyword">for</span> byte code.../home/parallels/Documents/friends.pl compiled, <span class="number">5</span> lines <span class="built_in">read</span> - <span class="number">976</span> bytes written, <span class="number">6</span> ms(<span class="number">1</span> ms) yes</span><br></pre></td></tr></table></figure>
<p>除非 Prolog 在等待一个中间结果，否则都会用 <code>yes</code> 或者 <code>no</code> 来回应，这一句里文件加载成功，所以返回 <code>yes</code>。而 <code>| ?-</code> 是命令前面的提示符，类似于命令行前的 <code>$</code>，不过这么有个性的，我还是第一次见</p>
<p>然后我们就可以让计算机自己进行逻辑推断了，比如：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- <span class="atom">likes</span>(<span class="atom">wallace</span>, <span class="atom">sheep</span>).<span class="atom">no</span></span><br></pre></td></tr></table></figure>
<p>通过前面的条件我们知道，并不能推断出 wallace 喜欢 sheep，所以返回 no。</p>
<blockquote>
<p>基本推论和变量</p>
</blockquote>
<p>来测试以下前面的 <code>friend</code> 规则：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| ?- <span class="atom">friend</span>(<span class="atom">wallace</span>, <span class="atom">wallace</span>).<span class="atom">no</span></span><br><span class="line">| ?- <span class="atom">friend</span>(<span class="atom">grommit</span>, <span class="atom">wallace</span>).<span class="atom">yes</span>| ?- <span class="atom">friend</span>(<span class="atom">wallace</span>, <span class="atom">grommit</span>).<span class="atom">yes</span></span><br></pre></td></tr></table></figure>
<p>我们来用自然语言翻译一下 <code>friend</code> 规则</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">friend</span>(<span class="name">X</span>, <span class="name">Y</span>) :- \+(<span class="name">X</span> = <span class="name">Y</span>), <span class="atom">likes</span>(<span class="name">X</span>, <span class="name">Z</span>), <span class="atom">likes</span>(<span class="name">Y</span>, <span class="name">Z</span>).</span><br></pre></td></tr></table></figure>
<p>如果 <code>X</code> 和 <code>Y</code> 是朋友，那么 X 就不能与 Y 相同。<code>:-</code> 右边的称为子目标(subgoal)。<code>\+</code> 是逻辑取反操作，所以第一个子目标 <code>\+(X=Y)</code> 的意思是 <code>X</code> 不等于 <code>Y</code>。后面的 <code>likes</code> 语句表示如果 <code>X</code> 喜欢 <code>Z</code>，并且 <code>Y</code> 也喜欢 <code>Z</code>，所以后面的子目标就是在 <code>X</code> 不等于 <code>Y</code> 的情况下，他们还喜欢同一个 <code>Z</code>。我们可以试验以下其他的组合，来看看 prolog 的工作机制。</p>
<p>上面的代码是一个具有三个变量 <code>X</code>, <code>Y</code> 和 <code>Z</code> 的 Prolog 规则，称为 <code>friend/2</code> 表示参数有 2 个，这个规则有三个子目标（条件）。只有都满足的时候，规则才为真。</p>
<blockquote>
<p>填空</p>
</blockquote>
<p>我们还可以利用 prolog 查询出所有可能的匹配，这时候我们就需要一个变量，打开一个新的文件 <code>food.pl</code>，并填入下面的代码：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">food_type</span>(<span class="atom">velveeta</span>, <span class="atom">cheese</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">ritz</span>, <span class="atom">cracker</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">spam</span>, <span class="atom">meat</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">sausage</span>, <span class="atom">meat</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">jolt</span>, <span class="atom">soda</span>).</span><br><span class="line"><span class="atom">food_type</span>(<span class="atom">twinkie</span>, <span class="atom">dessert</span>).</span><br><span class="line"></span><br><span class="line"><span class="atom">flavor</span>(<span class="atom">sweet</span>, <span class="atom">dessert</span>).</span><br><span class="line"><span class="atom">flavor</span>(<span class="atom">savory</span>, <span class="atom">meat</span>).</span><br><span class="line"><span class="atom">flavor</span>(<span class="atom">savory</span>, <span class="atom">cheese</span>).</span><br><span class="line"><span class="atom">flavor</span>(<span class="atom">sweet</span>, <span class="atom">soda</span>).</span><br><span class="line"></span><br><span class="line"><span class="atom">food_flavor</span>(<span class="name">X</span>, <span class="name">Y</span>) :- <span class="atom">food_type</span>(<span class="name">X</span>, <span class="name">Z</span>), <span class="atom">flavor</span>(<span class="name">Y</span>, <span class="name">Z</span>).</span><br></pre></td></tr></table></figure>
<p>其中 <code>food_type(velveeta, cheese)</code> 意思是 <code>velveeta</code> 属于 <code>cheese</code> 类食物；而 <code>flavor(sweet, dessert)</code> 则表示 <code>sweet</code> 是 <code>dessert</code> 的味道。最后的规则的意思是如果食物 <code>X</code> 属于类别 <code>Z</code> 并且 <code>Z</code> 的味道是 <code>Y</code>，那么食物 <code>X</code> 具有 <code>food_flavor</code> <code>Y</code>。编译一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- [<span class="string">'food.pl'</span>].compiling /home/parallels/Documents/food.pl <span class="keyword">for</span> byte code.../home/parallels/Documents/food.pl compiled, <span class="number">13</span> lines <span class="built_in">read</span> - <span class="number">1536</span> bytes written, <span class="number">5</span> msyes</span><br></pre></td></tr></table></figure>
<p>然后我们来问几个问题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- food_<span class="built_in">type</span>(What, meat).What = spam ? ;What = sausage ? ;no</span><br></pre></td></tr></table></figure>
<p>这里 prolog 会先找到 <code>spam</code>，然后输入 <code>;</code>，prolog 就会继续寻找下一个，也就是返回 <code>sausage</code>，继续输入 <code>;</code>，会发现返回了 <code>no</code>，这表示在未经更多计算的情况下不能判断是否还有更多选项。</p>
<p>另一个问题可以是 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| ?- food_flavor(What, savory).What = velveeta ? ;What = spam ? ;What = sausage ? ;no</span><br></pre></td></tr></table></figure>
<p>这里要注意 <code>food_flavor(X,Y)</code> 是一个规则，而不是事实，逻辑引擎会遍历所有使目标为真的可能组合。</p>
<h2 id="u4E60_u9898"><a href="#u4E60_u9898" class="headerlink" title="习题"></a>习题</h2><h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://fengdidi.github.io/blog/2011/11/15/di-1zhang-pei-zhi-kai-fa-huan-jing/" target="_blank" rel="external">笨办法学Prolog</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Prolog 是一门声明式编程语言，也是最早成功的逻辑编程语言之一。只需提供 fact 和 inference，程序会替我们进行推断。甚至不需要知道怎么做，只要告诉计算机要做什么即可。比方说，用不到 20 行代码解决数独问题。</p>]]>
    
    </summary>
    
      <category term="Prolog" scheme="http://wdxtub.com/tags/Prolog/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="语言" scheme="http://wdxtub.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Io 快速入门]]></title>
    <link href="http://wdxtub.com/2016/04/01/io-first-step/"/>
    <id>http://wdxtub.com/2016/04/01/io-first-step/</id>
    <published>2016-04-01T15:33:13.000Z</published>
    <updated>2016-04-02T01:02:26.000Z</updated>
    <content type="html"><![CDATA[<p>原型语言我接触得其实非常少，Io 和 JavaScript/Lua 一样，每个对象都是另一个对象的复制品。这部分暂时我的兴趣不是特别大，所以简要记录一下，以后有兴趣再学。</p>
<a id="more"></a>
<hr>
<ul>
<li>Io 语言于 2002 年由 Steve Dekorte 发明</li>
<li>基于原型的语言，每个对象都不是类的复制品</li>
<li>带有微型虚拟机和丰富并发特性的可嵌入语言来推广</li>
<li>拥有大量可定制语法和函数，以及强有力的并发模型</li>
<li>万事万物皆为消息，且每条消息都会返回另一接收消息的对象</li>
<li>没有关键字，只有少量在行为上接近于关键字的字符</li>
</ul>
<h2 id="u7F16_u7A0B_u6A21_u578B"><a href="#u7F16_u7A0B_u6A21_u578B" class="headerlink" title="编程模型"></a>编程模型</h2><blockquote>
<p>优势</p>
</blockquote>
<ul>
<li>灵活，可以快速创建出想要的语法</li>
<li>强大的、现代的并发库</li>
<li>占用空间小，但功能强大且灵活，应用在嵌入式领域</li>
<li>语法简洁，灵活</li>
</ul>
<blockquote>
<p>劣势</p>
</blockquote>
<ul>
<li>社区规模小</li>
<li>单线程性能较差</li>
</ul>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://iolanguage.org/" target="_blank" rel="external">官方网站</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>原型语言我接触得其实非常少，Io 和 JavaScript/Lua 一样，每个对象都是另一个对象的复制品。这部分暂时我的兴趣不是特别大，所以简要记录一下，以后有兴趣再学。</p>]]>
    
    </summary>
    
      <category term="Io" scheme="http://wdxtub.com/tags/Io/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="语言" scheme="http://wdxtub.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聪明人的枷锁]]></title>
    <link href="http://wdxtub.com/2016/03/31/smart-lock/"/>
    <id>http://wdxtub.com/2016/03/31/smart-lock/</id>
    <published>2016-03-31T18:31:02.000Z</published>
    <updated>2016-04-01T04:23:31.000Z</updated>
    <content type="html"><![CDATA[<p>小聪明到大智慧之间，有一条看不见的横沟，只能用天赋、坚持和勤奋来填。如果硬要说有技巧，恐怕就是『元学习』、『元思考』、『元实践』和『元创造』。</p>
<a id="more"></a>
<hr>
<h2 id="u806A_u660E_u4E86_u5417_uFF1F"><a href="#u806A_u660E_u4E86_u5417_uFF1F" class="headerlink" title="聪明了吗？"></a>聪明了吗？</h2><p>聪明固然是一件好事，但是一旦被别人被自己贴上了『聪明人』的标签，也就戴上了枷锁。外在的枷锁随着时间的推移逐渐会被移去，但是内在的枷锁，想要解开，就没那么容易了。</p>
<p>内在的枷锁主要体现在以下两个方面：</p>
<ol>
<li>做事情凭借直觉，大多数情况下都能完成得不错。可是直觉也有范围，一旦超出，因为平时没有培养正确做事的能力，往往不尽如人意。</li>
<li>做事情依赖个人，在学生时代作业考试甚至是小组项目都可以自己扛，可是个人能力再大也有范围，一旦超出，因为平时没有培养合作的能力，常常功亏一篑。</li>
</ol>
<p>直觉是可以培养的，合作是可以学习的。小聪明若是想要转变为大智慧，得利用自己的聪明，用不依赖聪明的方法，在正确做事的前提下，扩大自己的直觉范围，优化自己的合作机制。</p>
<p>遗憾的是，市面上大部分的书，到这里就结束了，剩下的不是猛灌鸡汤，就是列举一堆『看起来有用但是实际没用』的技巧，基本属于作者自己都没想明白就出来忽悠。</p>
<p>这篇文章想说的就是各类畅销书没说清楚的东西：</p>
<ol>
<li>正确学习的方法</li>
<li>正确思考的方法</li>
<li>正确实践的方法</li>
<li>正确创造的方法</li>
</ol>
<p>就像大贤得出世再入世一样，想要成为『大智慧』，首先得有点『小聪明』。注意，这里的『小聪明』和大家通常理解的不一样，指的是相对于『大』智慧的『小』聪明，而不是原来略带贬义的意思。成为『小聪明』的第一步，就是认清自己的思维模式，要想以聪明的方式思考问题，就得善用自己的长处，认识并完善自己的弱点。</p>
<p>另外正如《穷查理宝典》中所说的那样：『我们必须掌握许多知识，让它们在头脑中形成一个思维框架，在随后的日子里能自动地运用它们。与之相反，如果不努力去实践这种跨科学的方法，许多最聪明的人只会取得中等成就，甚至生活在阴影中』。</p>
<h2 id="u6B63_u786E_u5B66_u4E60"><a href="#u6B63_u786E_u5B66_u4E60" class="headerlink" title="正确学习"></a>正确学习</h2><blockquote>
<p>Data is not information. Information is not knowledge. Knowledge is not expertise. Expertise is not execution.</p>
</blockquote>
<p>广义来说，所有的学习都是自学，毕竟没有任何一种科技可以直接把知识『灌输』到我们脑中，即使有老师，我们仍然需要自己去学习。当我仔细审视『自学能力』的时候，发现有以下几个重要的组成部分：</p>
<ul>
<li>阅读能力 - 基础技能 <ul>
<li>广泛阅读，略读结合精读</li>
</ul>
</li>
<li>理解能力 - 在阅读能力基础上的初级技能<ul>
<li>提取核心思想，按照章节逻辑堆阅读进行总结</li>
</ul>
</li>
<li>检索能力 - 在理解能力基础上的中级技能<ul>
<li>围绕核心思想，寻找相关材料，从多方面看问题</li>
</ul>
</li>
<li>写作能力 - 由输入到输出的重要技能<ul>
<li>写作实际上是一个思考的过程。把思维中的想法用文字写下来，本身就是一个整理、分类的过程</li>
</ul>
</li>
<li>思考能力 - 在写作能力基础上的高级技能<ul>
<li>勤于琢磨思考该事情的目标、实质、意义，而后再据此去思考做好这件事情的方法，并挖掘出更深层次的意义</li>
</ul>
</li>
<li>实践能力 - 把学习转化为价值的核心技能<ul>
<li>能够举一反三，能把所学应用于实践，并根据实际情况调整前进的方向</li>
</ul>
</li>
</ul>
<p>一定要脱离『学霸/学渣』的思维定式。学校的教育体系本来就是有缺陷的，我们需要做的就是通过自学能力，去弥补那些自己感兴趣但学校从未教授的东西。这样看来，我们应该成为『沙盒游戏』中的『自由探索者』，不要限定自己的角色，也不要被学校、专业所限制。多学科视角的思考方法能产生某种「共奏效应」，发现原本无法发现的深度见解。</p>
<p>学习关于学习本身的知识，就是元学习。</p>
<h2 id="u6B63_u786E_u601D_u8003"><a href="#u6B63_u786E_u601D_u8003" class="headerlink" title="正确思考"></a>正确思考</h2><blockquote>
<p>So avoid the temptation to master all the skills you need before taking on a challenge. </p>
</blockquote>
<p>应试教育，或者说以考试制度为核心的教育体系中，学生会自然而然被灌输『标准答案』的概念，写对有分写错没分，每个问题对应一个标准答案就被植入到我们的脑中。小聪明可能可以每次都填上标准答案，但大智慧会以标准答案为起点，开始探索的旅程。</p>
<p>差异在哪里？在于『思考无固定答案』的习惯。把纸上的问题映射到现实问题中，培养独立思考的能力，得到自己的答案。这里有一点需要强调，就是『独立』。思考时不要依靠网络，毕竟思考是思考，搜索是搜索。如果总是依赖网络，一旦遇到搜不出来的情况，就很难找到解决办法了。</p>
<p>当然，在有了自己的思考之后，还是需要借助搜索的力量，更加全面地看待问题。这个过程中千万不能『囫囵吞枣』，信息需要经过考虑、推敲后才能转化为想法。不同人看待同样的信息角度不同，得出的结论也不同，相信自己的判断，确认信息，独立思考，不能偷懒。我们还需要时刻拥抱不确定性，越是不习惯，越是要让自己站在正反两面去思考分析问题。</p>
<p>思考的时候一定要有的放矢，意识流看起来很美，但是不利于交流，思考的输出应当是他人容易重视、记住和接受的，也就是要有：</p>
<ul>
<li>逻辑推理能力 - 论点分解或总结</li>
<li>时间管理能力 - 区分优先性</li>
<li>交流能力 - 加强说服力</li>
</ul>
<p>至于思考的结果是对是错，反而不是重要的。一旦出现错误时，要学会追踪当初的思维轨迹，找到哪里出了差错，经验——错误的归纳模式是人类最根本也最可靠的学习方法。</p>
<p>思考关于思考本身的东西，就是元思考。</p>
<h2 id="u6B63_u786E_u5B9E_u8DF5"><a href="#u6B63_u786E_u5B9E_u8DF5" class="headerlink" title="正确实践"></a>正确实践</h2><blockquote>
<p>Whenever you can, as long as the water’s not too far over your head, just jump in, and figure it out as you go.</p>
</blockquote>
<p>知行合一，可能是正确实践的终极奥义。在实践的过程中，一定要时不时问自己下面几个问题：</p>
<ul>
<li>正在解决的问题是我需要解决的问题吗？<ul>
<li>沿着正确的方向前行通常并不会花很多时间，方向不清的情况下走冤枉路却是白费工夫</li>
</ul>
</li>
<li>为什么要这样做，这是最好的方式吗？<ul>
<li>实践过程中会出各种小差错，要从这些差错中学习并提高实践能力</li>
</ul>
</li>
<li>能不能利用前辈的经验减少重复劳动？<ul>
<li>太阳底下没有新鲜事，很多经验是共同的</li>
</ul>
</li>
<li>可能会遇到什么困难，对应的尝试思路是什么？<ul>
<li>遇到困难的时候已经有了准备，就不会慌乱</li>
</ul>
</li>
<li>信息流动顺畅吗？是不是团队的每个成员都真正参与了进来？<ul>
<li>让每个人都清楚明白，就是流程的『可视化』，能让工作更简洁、更有效率</li>
</ul>
</li>
</ul>
<p>实践是学习和思考的演戏场，前面提到的各种能力和技巧，都可以运用到实践中来。当我们遇到问题时，最高效的做法是：</p>
<ol>
<li>认识问题。思考问题背后的东西，背景、事物、条件、关系。通过重新定义问题本身来探索问题的本质。</li>
<li>独立思考。先不借助书本和网络，大胆假设，小心求证。试错的目的就是从中得到意外的收获。现实不比理论，遇到的问题往往具体而特殊，几乎没有什么现成的经验，还是那句话：主动思考大胆假设小心求证。书本和网络的资料可能会给人启发，但是也是枷锁，框住想象力。</li>
<li>全面观测。这个时候可以在书本或网络中找寻相关内容，可能的话尽量与他人交换想法。认知本身就是主观的，横看成岭侧成峰，要全面观测，才能得到更接近『真实』的认知。也就是主观的客观化。</li>
<li>形成框架。简单来说，就是要有自己的『套路』，不同类型的问题有不同的解法，通过具体的实践不断迭代优化自己的理论与套路。</li>
<li>魔鬼细节。仰望星空同时也要脚踏实地，实践难免把手弄脏，但也只有把手弄脏才能得到完备的解决方案，继而解决复杂的现实问题。</li>
<li>每次处理问题请重复上述步骤</li>
</ol>
<p>实践是问题导向的，不能为了做而做，面对动态世界的复杂系统，只有以未知作为起点进行思考，才可能拨开迷雾找到答案。</p>
<p>实践关于实践本身的东西，就是元实践。</p>
<h2 id="u6B63_u786E_u521B_u9020"><a href="#u6B63_u786E_u521B_u9020" class="headerlink" title="正确创造"></a>正确创造</h2><blockquote>
<p>The purpose of education is to provide you the toolsets that enable you take the data around you, make sense out of it and find out a way to create something productive out of that. As the amount of data around us explode, the necessity for education grows.</p>
</blockquote>
<p>创造性这个东西，说流淌在血液中一点也不为过。我们骨子里传下来的智慧、毅力、勤勉、奋发当然不能丢，但是更应该再来点浪漫主义，从超越功利的角度找回精神自主性，每个人都要是特立独行的个体，而不是流水线生产出来的千人一面脸谱化。</p>
<p>多元化的生活态度与人生哲学，对生活本身的富于诗情的理解，才能真正让自己『立体』，有广度也有深度，才能创造出更多新东西，而不是循规蹈矩墨守成规。</p>
<p>『当幸福来敲门』这个翻译我觉得特别好，很多东西不是去找就能找得到的，而是把该做好的都做好，然后静静等待那个时刻的到来。创造就是如此，尤其是下面提到的『酝酿』阶段，就是『当创意来敲门』。但是需要注意的是，不同阶段有不同的侧重点：</p>
<ul>
<li>准备阶段。搜集相关信息，缩小问题范围，直到看到障碍</li>
<li>酝酿阶段。将自己完全浸在问题里，运用潜意识思考，不要有寻找解决方案的压力</li>
<li>启发阶段。用直觉或有意识的思考处理问题，用直觉或洞察力来形成可能的解决方案</li>
<li>验证阶段。对可能的解决方案进行合理性检验，验证方案的正确性，并最终打磨完整</li>
</ul>
<p>创造关于创造本身的东西，就是元创造。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>Heroes inspire us for many reasons: they make tough decisions, they keep going and they get done what matters. But there’s another reason we love our heroes. Inside us all, we know we have the power to become one ourselves.</p>
</blockquote>
<p>英雄人物之所以能激励我们，是因为他们能够作出艰难的抉择，他们永不言弃，他们总能做出惊天动地的事情。但我们之所以崇拜英雄还有另一个原因。在内心深处，我们都相信自己有能力成为他们。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>小聪明到大智慧之间，有一条看不见的横沟，只能用天赋、坚持和勤奋来填。如果硬要说有技巧，恐怕就是『元学习』、『元思考』、『元实践』和『元创造』。</p>]]>
    
    </summary>
    
      <category term="创造" scheme="http://wdxtub.com/tags/%E5%88%9B%E9%80%A0/"/>
    
      <category term="感觉" scheme="http://wdxtub.com/tags/%E6%84%9F%E8%A7%89/"/>
    
      <category term="方法" scheme="http://wdxtub.com/tags/%E6%96%B9%E6%B3%95/"/>
    
      <category term="聪明" scheme="http://wdxtub.com/tags/%E8%81%AA%E6%98%8E/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 反思课 5 实时服务测试的策略与思考]]></title>
    <link href="http://wdxtub.com/2016/03/31/cc-rethink-5/"/>
    <id>http://wdxtub.com/2016/03/31/cc-rethink-5/</id>
    <published>2016-03-31T10:02:04.000Z</published>
    <updated>2016-03-31T11:19:15.000Z</updated>
    <content type="html"><![CDATA[<p>昨天我们的 Twitter Analysis Service 采用了新的测试方式，在大约两个半小时的时间内进行各类请求的压力测试，以确保系统能够应对复杂请求。虽然我做的部分表现非常糟糕，但是从中学到了很多东西，知耻而后勇。</p>
<a id="more"></a>
<hr>
<p>总得来说，因为有靠谱的队友（手动重启服务器几十次），整个测试不至于滑铁卢，但是这也暴露了我们在前后端设计处理的各种问题，接下来逐条分析。</p>
<blockquote>
<p>架构设计</p>
</blockquote>
<p>因为整套系统目前有 6 台机器，之前测试的时候使用 1 台前端 + 4 台后端是行得通的。但是因为之前并没有过多留意前后端机器的硬件利用情况（基本凭感觉），所以想当然得觉得后端是瓶颈（对 HBase 的特性不大了解，估计错误）。事实狠狠打了我的脸，前端的 CPU 利用率居高不下（接近满负荷运载）而后端的利用率分布不均（有的节点 60% 的 CPU 使用率，有的节点甚至只有 20%）。</p>
<p>当我意识到这个问题的时候，只能眼睁睁看着唯一的一台前端苦苦支撑，爆内存，和 HBase 的连接断开，每次都只能手动重启服务器（但是因为 CPU 占用满了，重启也需要几分钟）。这极大影响了正确率和吞吐量，最终得到的分数自然少得可怜。</p>
<p>参考其他组的先进经验，前端使用 ELB(负载均衡) + 2 台机器，后端使用 1(master) + 3(slave) 的模式可能是最科学的，这样可以尽可能得减轻前端单机压力。</p>
<blockquote>
<p>硬件监控</p>
</blockquote>
<p>好消息是，在同学的帮助之下，终于意识到了『监控』的重要性。虽然不难（每台机器开着 <code>top</code> 查看使用率即可），但是有没有这个意识就有天壤之别。简单粗暴来说，哪怕只通过 CPU 利用率一个指标，就能大概估计目前的硬件使用情况，可是我之前竟然拍脑袋想当然总觉得硬件不是问题。</p>
<p>这是很好的教训，我要吸取经验。</p>
<p>痛定思痛，至少可以从其他多个角度来利用监控数据：</p>
<ul>
<li>了解不同的监控命令，深入理解不同监控参数的意义，编写脚本抓取重点关注的数据</li>
<li>结合 CPU 利用率 + 内存利用率来优化代码，力求达到充分利用 CPU 以及内存</li>
<li>观察 CPU / 内存 / 网络的相关数据，来确定具体的瓶颈所在，然后对症下药，寻找可能的解决方案</li>
<li>在监控脚本的基础上，可以设定一些阈值，自动化提醒和记录日志（不用自己时刻盯着屏幕了）</li>
<li>提醒内容：CPU / 内存 / 网络满载警报，或者不均衡使用警报等</li>
<li>日志内容：在出现警报的时候，需要记录相关请求，查看日志的时候能够快速掌握上下文</li>
</ul>
<blockquote>
<p>数据统计</p>
</blockquote>
<p>一般来说，不同的 web 服务，用户的请求模式总体来说是有一定规律的。对于 Twitter 数据的分析，就有热门/冷门的用户/hashtag/单词/时间段（比方说有重大事件发生的日子，tweet 的数量可能会更多）</p>
<p>我们应该根据具体的需求，通过统计大致了解数据分布。比方说其中一个请求是返回某用户包含某 hashtag 的 tweet，那么我们最好需要了解哪些用户热门，哪些 hashtag 热门，然后根据这些特点来进行数据库 schema 的设计（就是 rowkey 和 value）以及数据库中不同 region 在不同 regionserver 的平衡。之前的设计方式会导致有些 region 访问次数非常多，有些却非常少，这样就没有充分利用 HBase 的能力。</p>
<p>这部分具体怎么实现还需要通过不断实践来摸索，但是想要获得更好的性能，总是逃不开这步的。</p>
<blockquote>
<p>代码实现</p>
</blockquote>
<p>这一部分就是压力测试下暴露的代码问题了，主要是以下几点：</p>
<ul>
<li>请求的参数要进行检查，很可能为空。但是写起来的语法很麻烦，这个时候就开始怀念 Swift 中的语法糖了</li>
<li>对于 HBase 1.0 来说，连接池几乎没用，因为共用 HConnection 的 HTableInterface 并不会并行</li>
<li>线程池也不大需要，undertow 框架基本能够处理好，就不要画蛇添足（容易爆内存）</li>
</ul>
<p>最后写三句，从错误中学习比实现 web 服务本身更有意义，这是第二句，第三句也写完了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天我们的 Twitter Analysis Service 采用了新的测试方式，在大约两个半小时的时间内进行各类请求的压力测试，以确保系统能够应对复杂请求。虽然我做的部分表现非常糟糕，但是从中学到了很多东西，知耻而后勇。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="优化" scheme="http://wdxtub.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[tmux 指南]]></title>
    <link href="http://wdxtub.com/2016/03/30/tmux-guide/"/>
    <id>http://wdxtub.com/2016/03/30/tmux-guide/</id>
    <published>2016-03-30T22:55:27.000Z</published>
    <updated>2016-03-31T04:01:21.000Z</updated>
    <content type="html"><![CDATA[<p>今天试用了一下 tmux，发现简直是神器！以前还傻傻不停开窗口，现在一个窗口就可以都搞定啦！</p>
<a id="more"></a>
<hr>
<p>Tmux 简单来说就是终端里的『窗口管理器』，如果我使用终端登录到远程主机并运行前台程序，那么这个窗口等于就被占用了，想要看一下 CPU 的使用率，就得再连接一次。但是如果在远程主机上运行 tmux，那么就可以开启多个控制台（类似于窗口），相当高效，比方说可以像下面这样：</p>
<p><img src="/images/14593788571503.jpg" alt="一个面板监视服务器，一个面板查看硬件状况"></p>
<p>需要注意的是，这里是在我本地使用 tmux，最好在远程主机也安装 tmux，这样就只需要连接一次。</p>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>前面提到的窗口管理只是 tmux 功能的一小部分，另一个很有用的功能就是，连接到远程主机之后，一旦断开，那么当前账户登录的任务就被取消了，但是使用 tmux 可以在断开之后继续工作，下次登录可以查看。其他的功能还有：</p>
<ol>
<li>窗口切换，每个窗口里还可以分割面板</li>
<li>配置方便，可以使用脚本</li>
<li>类似 vim 的双层操作逻辑</li>
<li>复制粘贴缓冲区</li>
</ol>
<p>安装的话也很简单，在 mac 下直接 <code>brew install tmux</code>（前提需要安装 homebrew），ubuntu 下则直接 <code>sudo apt-get install tmux</code></p>
<p>在终端中输入 <code>tmux</code> 就可以打开一个新的 tmux session，tmux 的所有操作必须先使用一个前缀键（默认是 <code>ctrl + b</code>）进入命令模式，或者说进入控制台，就像 vim 中的 esc。</p>
<h2 id="u57FA_u672C_u64CD_u4F5C"><a href="#u57FA_u672C_u64CD_u4F5C" class="headerlink" title="基本操作"></a>基本操作</h2><blockquote>
<p>信息查询</p>
</blockquote>
<ul>
<li><code>tmux list-keys</code> 列出所有可以的快捷键和其运行的 tmux 命令</li>
<li><code>tmux list-commands</code> 列出所有的 tmux 命令及其参数</li>
<li><code>tmux info</code> 流出所有的 session, window, pane, 运行的进程号，等。</li>
</ul>
<blockquote>
<p>窗口控制</p>
</blockquote>
<p>先来看看在 tmux 之外如何进行控制</p>
<ul>
<li>session 会话：session是一个特定的终端组合。输入tmux就可以打开一个新的session<ul>
<li><code>tmux new -s session_name</code> 创建一个叫做 <code>session_name</code> 的 tmux session</li>
<li><code>tmux attach -t session_name</code> 重新开启叫做 <code>session_name</code> 的 tmux session</li>
<li><code>tmux switch -t session_name</code> 转换到叫做 <code>session_name</code> 的 tmux session</li>
<li><code>tmux list-sessions</code> / <code>tmux ls</code> 列出现有的所有 session</li>
<li><code>tmux detach</code> 离开当前开启的 session</li>
</ul>
</li>
<li>window 窗口：session 中可以有不同的 window（但是同时只能看到一个 window）<ul>
<li><code>tmux new-window</code> 创建一个新的 window</li>
<li><code>tmux list-windows</code> </li>
<li><code>tmux select-window -t :0-9</code> 根据索引转到该 window</li>
<li><code>tmux rename-window</code> 重命名当前 window</li>
</ul>
</li>
<li>pane 面板：window 中可以有不同的 pane（可以把 window 分成不同的部分）<ul>
<li><code>tmux split-window</code> 将 window 垂直划分为两个 pane</li>
<li><code>tmux split-window -h</code> 将 window 水平划分为两个 pane</li>
<li><code>tmux swap-pane -[UDLR]</code> 在指定的方向交换 pane</li>
<li><code>tmux select-pane -[UDLR]</code> 在指定的方向选择下一个 pane</li>
</ul>
</li>
</ul>
<p>更常用的是在 tmux 中直接通过默认前缀 <code>ctrl + b</code> 之后输入对应命令来操作，具体如下（这里只列出输入默认前缀之后需要输入的操作）：</p>
<blockquote>
<p>基本操作</p>
</blockquote>
<ul>
<li><code>?</code> 列出所有快捷键；按q返回</li>
<li><code>d</code> 脱离当前会话,可暂时返回Shell界面</li>
<li><code>s</code> 选择并切换会话；在同时开启了多个会话时使用</li>
<li><code>D</code> 选择要脱离的会话；在同时开启了多个会话时使用</li>
<li><code>:</code> 进入命令行模式；此时可输入支持的命令，例如 <code>kill-server</code> 关闭所有tmux会话</li>
<li><code>[</code> 复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q/Esc退出</li>
<li><code>]</code> 进入粘贴模式，粘贴之前复制的内容，按q/Esc退出</li>
<li><code>~</code> 列出提示信息缓存；其中包含了之前tmux返回的各种提示信息</li>
<li><code>t</code> 显示当前的时间</li>
<li><code>ctrl + z</code> 挂起当前会话</li>
</ul>
<blockquote>
<p>窗口操作</p>
</blockquote>
<ul>
<li><code>c</code> 创建新窗口</li>
<li><code>&amp;</code> 关闭当前窗口</li>
<li><code>[0-9]</code> 数字键切换到指定窗口</li>
<li><code>p</code> 切换至上一窗口</li>
<li><code>n</code> 切换至下一窗口</li>
<li><code>l</code> 前后窗口间互相切换</li>
<li><code>w</code> 通过窗口列表切换窗口</li>
<li><code>,</code> 重命名当前窗口，便于识别</li>
<li><code>.</code> 修改当前窗口编号，相当于重新排序</li>
<li><code>f</code> 在所有窗口中查找关键词，便于窗口多了切换</li>
</ul>
<blockquote>
<p>面板操作</p>
</blockquote>
<ul>
<li><code>&quot;</code> 将当前面板上下分屏（我自己改成了 <code>|</code>）</li>
<li><code>%</code> 将当前面板左右分屏（我自己改成了 <code>-</code>）</li>
<li><code>x</code> 关闭当前分屏</li>
<li><code>!</code> 将当前面板置于新窗口,即新建一个窗口,其中仅包含当前面板</li>
<li><code>ctrl+方向键</code> 以1个单元格为单位移动边缘以调整当前面板大小</li>
<li><code>alt+方向键</code> 以5个单元格为单位移动边缘以调整当前面板大小</li>
<li><code>q</code> 显示面板编号</li>
<li><code>o</code> 选择当前窗口中下一个面板</li>
<li><code>方向键</code> 移动光标选择对应面板</li>
<li><code>{</code> 向前置换当前面板</li>
<li><code>}</code> 向后置换当前面板</li>
<li><code>alt+o</code> 逆时针旋转当前窗口的面板</li>
<li><code>ctrl+o</code> 顺时针旋转当前窗口的面板</li>
<li><code>z</code> 最大化当前所在面板</li>
<li><code>page up</code> 向上滚动屏幕，q 退出</li>
<li><code>page down</code> 向下滚动屏幕，q 退出</li>
</ul>
<p>因为 iTerm2 的支持，很多切换的操作可以直接用鼠标进行，非常方便。具体大家可以自己尝试一下。</p>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2><p>我们可以先进行一些简单的配置，修改 <code>~/.tmux.conf</code> 即可，让整个使用更方便。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#<span class="comment">-- base --#</span></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">default</span>-terminal <span class="string">"screen-256color"</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> display-<span class="keyword">time</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> history-<span class="keyword">limit</span> <span class="number">10000</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> base-<span class="keyword">index</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> pane-base-<span class="keyword">index</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> -s escape-<span class="keyword">time</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> mouse <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line">#<span class="comment">-- bindkeys --#</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">split</span> windows <span class="keyword">like</span> vim.  - Note: vim<span class="string">'s definition of a horizontal/vertical split is reversed from tmux'</span>s</span><br><span class="line"></span><br><span class="line">unbind s</span><br><span class="line">bind s <span class="keyword">split</span>-window -v</span><br><span class="line">bind S <span class="keyword">split</span>-window -v -<span class="keyword">l</span> <span class="number">40</span></span><br><span class="line">bind v <span class="keyword">split</span>-window -h</span><br><span class="line">bind V <span class="keyword">split</span>-window -h -<span class="keyword">l</span> <span class="number">120</span></span><br><span class="line"></span><br><span class="line"># navigate panes <span class="keyword">with</span> hjkl</span><br><span class="line">bind h <span class="keyword">select</span>-pane -<span class="keyword">L</span></span><br><span class="line">bind j <span class="keyword">select</span>-pane -<span class="keyword">D</span></span><br><span class="line">bind <span class="keyword">k</span> <span class="keyword">select</span>-pane -U</span><br><span class="line">bind <span class="keyword">l</span> <span class="keyword">select</span>-pane -R</span><br><span class="line"></span><br><span class="line"># <span class="keyword">key</span> bindings <span class="keyword">for</span> horizontal <span class="keyword">and</span> vertical panes</span><br><span class="line">unbind %</span><br><span class="line">bind | <span class="keyword">split</span>-window -h      # 使用|竖屏，方便分屏</span><br><span class="line">unbind <span class="string">'"'</span></span><br><span class="line">bind - <span class="keyword">split</span>-window -v      # 使用-横屏，方便分屏</span><br><span class="line"></span><br><span class="line"># swap panes</span><br><span class="line">bind ^u swapp -U</span><br><span class="line">bind ^<span class="keyword">d</span> swapp -<span class="keyword">D</span></span><br><span class="line"></span><br><span class="line">bind q killp</span><br><span class="line">bind ^<span class="keyword">e</span> <span class="keyword">last</span></span><br><span class="line"></span><br><span class="line">unbind r</span><br><span class="line">bind r <span class="keyword">source</span>-<span class="keyword">file</span> ~/.tmux.conf \;</span> display "Configuration Reloaded!"</span><br><span class="line"></span><br><span class="line">#<span class="comment">-- statusbar --#</span></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-justify centre</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">left</span> <span class="string">"#[fg=red]s#S:w#I.p#P#[default]"</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">right</span> <span class="string">'[#(whoami)#(date +" %m-%d %H:%M ")]'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">left</span>-<span class="keyword">attr</span> bright</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">left</span>-<span class="keyword">length</span> <span class="number">120</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">right</span>-<span class="keyword">length</span> <span class="number">120</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-utf8 <span class="keyword">on</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="built_in">interval</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> visual-activity <span class="keyword">on</span></span><br><span class="line">setw -<span class="keyword">g</span> monitor-activity <span class="keyword">on</span></span><br><span class="line">setw -<span class="keyword">g</span> <span class="keyword">automatic</span>-<span class="keyword">rename</span> <span class="keyword">off</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">default</span> statusbar colors</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-bg colour235 #base02</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-fg colour136 #yellow</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-<span class="keyword">attr</span> <span class="keyword">default</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">default</span> window title colors</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-fg colour244</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-bg <span class="keyword">default</span></span><br><span class="line">#setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">attr</span> dim</span><br><span class="line"></span><br><span class="line"># active window title colors</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-fg colour166 #orange</span><br><span class="line">setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-bg <span class="keyword">default</span></span><br><span class="line">#setw -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-<span class="keyword">attr</span> bright</span><br><span class="line"></span><br><span class="line"># window title <span class="keyword">string</span> (uses statusbar <span class="keyword">variables</span>)</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">set</span>-titles-<span class="keyword">string</span> <span class="string">'#T'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> <span class="keyword">status</span>-justify <span class="string">"centre"</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">format</span> <span class="string">'#I #W'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> window-<span class="keyword">status</span>-<span class="keyword">current</span>-<span class="keyword">format</span> <span class="string">' #I #W '</span></span><br><span class="line"></span><br><span class="line"># pane border</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> pane-active-border-fg <span class="string">'#55ff55'</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> pane-border-fg <span class="string">'#555555'</span></span><br><span class="line"></span><br><span class="line"># message <span class="built_in">text</span></span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> message-bg colour235 #base02</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> message-fg colour166 #orange</span><br><span class="line"></span><br><span class="line"># pane <span class="built_in">number</span> display</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> display-panes-active-colour colour33 #blue</span><br><span class="line"><span class="keyword">set</span> -<span class="keyword">g</span> display-panes-colour colour166 #orange</span><br><span class="line"></span><br><span class="line"># clock</span><br><span class="line">setw -<span class="keyword">g</span> clock-<span class="keyword">mode</span>-colour colour64 #green</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 修改进入命令模式按键</span><br><span class="line"># remap prefix <span class="keyword">to</span> Control + a</span><br><span class="line"># <span class="keyword">set</span> -<span class="keyword">g</span> prefix <span class="keyword">C</span>-a</span><br><span class="line"># unbind <span class="keyword">C</span>-b</span><br><span class="line"># bind <span class="keyword">C</span>-a send-prefix</span></span><br></pre></td></tr></table></figure>
<p>最终的效果是</p>
<p><img src="/images/14593965566247.jpg" alt=""></p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://foocoder.com/blog/zhong-duan-huan-jing-zhi-tmux.html/" target="_blank" rel="external">终端环境之tmux</a></li>
<li><a href="http://blog.jeswang.org/blog/2013/06/24/tmux-kuai-su-jiao-cheng/" target="_blank" rel="external">Tmux 快速教程</a></li>
<li><a href="http://kumu-linux.github.io/blog/2013/08/06/tmux/" target="_blank" rel="external">Linux下终端利器tmux</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天试用了一下 tmux，发现简直是神器！以前还傻傻不停开窗口，现在一个窗口就可以都搞定啦！</p>]]>
    
    </summary>
    
      <category term="命令行" scheme="http://wdxtub.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="效率" scheme="http://wdxtub.com/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="窗口" scheme="http://wdxtub.com/tags/%E7%AA%97%E5%8F%A3/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ruby 快速入门]]></title>
    <link href="http://wdxtub.com/2016/03/30/ruby-first-step/"/>
    <id>http://wdxtub.com/2016/03/30/ruby-first-step/</id>
    <published>2016-03-30T13:14:28.000Z</published>
    <updated>2016-04-01T15:07:09.000Z</updated>
    <content type="html"><![CDATA[<p>学编程就好比学有用，再好的理论也不如一头扎下水，扑腾着呼吸新鲜空气管用。这个系列的目的，就是帮助自己跳入水中，这一次我们来学 Ruby。</p>
<a id="more"></a>
<hr>
<p>获得任何新技能的第一步，是先别想着独立解决什么，而是重复一边前人已竟之事，这是最快的方法。每门语言都有自己的一套惯用方法，各有所长，各有所短。通过学习不同的编程语言，你会明白，哪门语言最适宜解决自己当下关注的问题。</p>
<p>精于禅宗的大师会告诉你，拉丁语学得越好，数学也就越好。编程也同样如此。通过研究逻辑式编程或函数式编程，你能领悟到面向对象编程的精华；通过学习汇编语言，你能更透彻地理解函数式编程。</p>
<p>学习新语言的时候，一定要弄清楚以下几个问题：</p>
<ul>
<li>语言的类型模型是什么？<ul>
<li>强类型/弱类型，静态类型/动态类型</li>
<li>类型模型会改变问题的处理方式，控制语言的运行方式</li>
</ul>
</li>
<li>语言的编程范型是什么？<ul>
<li>面向对象、函数式、过程式等等</li>
</ul>
</li>
<li>怎样和语言交互？<ul>
<li>编译、解释</li>
</ul>
</li>
<li>语言的判断结构(decision construct)和核心数据结构是什么？</li>
<li>哪些核心特性让这门语言与众不同？</li>
</ul>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><ul>
<li>由松本行弘(Yukihiro Matsumoto)大约在 1993 年发明</li>
<li>脚本语言、解释型、面向对象、动态类型</li>
</ul>
<p>现在我的机器上安装的 ruby 版本是 2.1，可以使用下面的命令来查询：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -v</span><br><span class="line">ruby <span class="number">2.1</span>.<span class="number">4</span>p265 (<span class="number">2014</span>-<span class="number">10</span>-<span class="number">27</span> revision <span class="number">48166</span>) [x86_64-darwin14.<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>具体的安装不做太多介绍，在<a href="https://www.ruby-lang.org/zh_cn/" target="_blank" rel="external">官方网站</a>查阅不同平台的相关资料即可，下面是一个简单的例子</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> properties = [<span class="string">'good'</span>, <span class="string">'bad'</span>, <span class="string">'clever'</span>, <span class="string">'stupid'</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"good"</span>, <span class="string">"bad"</span>, <span class="string">"clever"</span>, <span class="string">"stupid"</span>]</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> properties.each &#123;|property| puts <span class="string">"I am <span class="subst">#&#123;property&#125;</span>."</span>&#125;</span><br><span class="line"><span class="constant">I</span> am good.</span><br><span class="line"><span class="constant">I</span> am bad.</span><br><span class="line"><span class="constant">I</span> am clever.</span><br><span class="line"><span class="constant">I</span> am stupid.</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"good"</span>, <span class="string">"bad"</span>, <span class="string">"clever"</span>, <span class="string">"stupid"</span>]</span><br></pre></td></tr></table></figure>
<p>留意一下 ruby 是如何进行遍历及值替换的，之后我们也会深入了解。需要注意的是，这种写起来方便的语言，一般来说效率都不会太高。但是开发效率与执行效率常常是鱼与熊掌，很多时候不得不进行选择。</p>
<p>我们再来看一个长一点的例子：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> puts <span class="string">'hello, wdx'</span></span><br><span class="line">hello, wdx</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> friend = <span class="string">'Snake'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Snake"</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> puts <span class="string">"hello, <span class="subst">#&#123;friend&#125;</span>"</span></span><br><span class="line">hello, <span class="constant">Snake</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> friend = <span class="string">'Queit'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Queit"</span></span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> puts <span class="string">"hello, <span class="subst">#&#123;friend&#125;</span>"</span></span><br><span class="line">hello, <span class="constant">Queit</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到以下几点：</p>
<ul>
<li>不用声明变量</li>
<li>每条 ruby 代码都会返回某个值</li>
<li>单引号表示直接解释</li>
<li>双引号包含的字符串会进行字符串替换</li>
</ul>
<h2 id="u7F16_u7A0B_u6A21_u578B"><a href="#u7F16_u7A0B_u6A21_u578B" class="headerlink" title="编程模型"></a>编程模型</h2><p>Ruby 是一门纯面向对象语言。从下面的例子就可以看出来：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="number">233</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">233</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> <span class="number">233</span>.class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">Fixnum</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> <span class="number">233</span> + <span class="number">233</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">466</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> <span class="number">233</span>.methods</span><br><span class="line"><span class="status">=&gt;</span> [<span class="symbol">:to_s</span>, <span class="symbol">:inspect</span>, <span class="symbol">:-@</span>, <span class="symbol">:+</span>, <span class="symbol">:-</span>, <span class="symbol">:*</span>, <span class="symbol">:/</span>, <span class="symbol">:div</span>, <span class="symbol">:%</span>, <span class="symbol">:modulo</span>, <span class="symbol">:divmod</span>, <span class="symbol">:fdiv</span>, <span class="symbol">:**</span>, <span class="symbol">:abs</span>, <span class="symbol">:magnitude</span>, <span class="symbol">:==</span>, <span class="symbol">:===</span>, <span class="symbol">:&lt;=&gt;</span>, <span class="symbol">:&gt;</span>, <span class="symbol">:&gt;=</span>, <span class="symbol">:&lt;</span>, <span class="symbol">:&lt;=</span>, <span class="symbol">:~</span>, <span class="symbol">:&amp;</span>, <span class="symbol">:|</span>, <span class="symbol">:^</span>, <span class="symbol">:[]</span>, <span class="symbol">:&lt;&lt;</span>, <span class="symbol">:&gt;&gt;</span>, <span class="symbol">:to_f</span>, <span class="symbol">:size</span>, <span class="symbol">:bit_length</span>, <span class="symbol">:zero?</span>, <span class="symbol">:odd?</span>, <span class="symbol">:even?</span>, <span class="symbol">:succ</span>, <span class="symbol">:integer?</span>, <span class="symbol">:upto</span>, <span class="symbol">:downto</span>, <span class="symbol">:times</span>, <span class="symbol">:next</span>, <span class="symbol">:pred</span>, <span class="symbol">:chr</span>, <span class="symbol">:ord</span>, <span class="symbol">:to_i</span>, <span class="symbol">:to_int</span>, <span class="symbol">:floor</span>, <span class="symbol">:ceil</span>, <span class="symbol">:truncate</span>, <span class="symbol">:round</span>, <span class="symbol">:gcd</span>, <span class="symbol">:lcm</span>, <span class="symbol">:gcdlcm</span>, <span class="symbol">:numerator</span>, <span class="symbol">:denominator</span>, <span class="symbol">:to_r</span>, <span class="symbol">:rationalize</span>, <span class="symbol">:singleton_method_added</span>, <span class="symbol">:coerce</span>, <span class="symbol">:i</span>, <span class="symbol">:+@</span>, <span class="symbol">:eql?</span>, <span class="symbol">:remainder</span>, <span class="symbol">:real?</span>, <span class="symbol">:nonzero?</span>, <span class="symbol">:step</span>, <span class="symbol">:quo</span>, <span class="symbol">:to_c</span>, <span class="symbol">:real</span>, <span class="symbol">:imaginary</span>, <span class="symbol">:imag</span>, <span class="symbol">:abs2</span>, <span class="symbol">:arg</span>, <span class="symbol">:angle</span>, <span class="symbol">:phase</span>, <span class="symbol">:rectangular</span>, <span class="symbol">:rect</span>, <span class="symbol">:polar</span>, <span class="symbol">:conjugate</span>, <span class="symbol">:conj</span>, <span class="symbol">:between?</span>, <span class="symbol">:nil?</span>, <span class="symbol">:=~</span>, <span class="symbol">:</span>!~, <span class="symbol">:hash</span>, <span class="symbol">:class</span>, <span class="symbol">:singleton_class</span>, <span class="symbol">:clone</span>, <span class="symbol">:dup</span>, <span class="symbol">:taint</span>, <span class="symbol">:tainted?</span>, <span class="symbol">:untaint</span>, <span class="symbol">:untrust</span>, <span class="symbol">:untrusted?</span>, <span class="symbol">:trust</span>, <span class="symbol">:freeze</span>, <span class="symbol">:frozen?</span>, <span class="symbol">:methods</span>, <span class="symbol">:singleton_methods</span>, <span class="symbol">:protected_methods</span>, <span class="symbol">:private_methods</span>, <span class="symbol">:public_methods</span>, <span class="symbol">:instance_variables</span>, <span class="symbol">:instance_variable_get</span>, <span class="symbol">:instance_variable_set</span>, <span class="symbol">:instance_variable_defined?</span>, <span class="symbol">:remove_instance_variable</span>, <span class="symbol">:instance_of?</span>, <span class="symbol">:kind_of?</span>, <span class="symbol">:is_a?</span>, <span class="symbol">:tap</span>, <span class="symbol">:send</span>, <span class="symbol">:public_send</span>, <span class="symbol">:respond_to?</span>, <span class="symbol">:extend</span>, <span class="symbol">:display</span>, <span class="symbol">:method</span>, <span class="symbol">:public_method</span>, <span class="symbol">:singleton_method</span>, <span class="symbol">:define_singleton_method</span>, <span class="symbol">:object_id</span>, <span class="symbol">:to_enum</span>, <span class="symbol">:enum_for</span>, <span class="symbol">:equal?</span>, <span class="symbol">:</span>!, <span class="symbol">:</span>!=, <span class="symbol">:instance_eval</span>, <span class="symbol">:instance_exec</span>, <span class="symbol">:__send__</span>, <span class="symbol">:__id__</span>]</span><br></pre></td></tr></table></figure>
<p>看出来了吗，ruby 中一切皆为对象，比方说数字就是 <code>Fixnum</code> 类型的对象，我们也可以用 <code>.</code> 来调用对象的各种方法。</p>
<blockquote>
<p>判断</p>
</blockquote>
<p>我们同样可以通过例子来研究研究。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> x = <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">4</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> x &lt; <span class="number">5</span></span><br><span class="line"><span class="status">=&gt;</span> true</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> x &lt;= <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> true</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> x &gt; <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> false</span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> false.class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">FalseClass</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> true.class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">TrueClass</span></span><br><span class="line"><span class="prompt">irb(main):007:0&gt;</span> puts <span class="string">'This is false'</span> unless x == <span class="number">4</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):008:0&gt;</span> puts <span class="string">'This is true'</span> if x == <span class="number">4</span></span><br><span class="line"><span class="constant">This</span> is <span class="keyword">true</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):009:0&gt;</span> if x == <span class="number">4</span></span><br><span class="line"><span class="prompt">irb(main):010:1&gt;</span>     puts <span class="string">'This is true'</span></span><br><span class="line"><span class="prompt">irb(main):011:1&gt;</span> end</span><br><span class="line"><span class="constant">This</span> is <span class="keyword">true</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):012:0&gt;</span> unless x == <span class="number">4</span></span><br><span class="line"><span class="prompt">irb(main):013:1&gt;</span>    puts <span class="string">'This is false'</span></span><br><span class="line"><span class="prompt">irb(main):014:1&gt;</span> else</span><br><span class="line">irb(main)<span class="symbol">:</span><span class="number">015</span><span class="symbol">:</span><span class="number">1</span>*    puts <span class="string">'This is true'</span></span><br><span class="line"><span class="prompt">irb(main):016:1&gt;</span> end</span><br><span class="line"><span class="constant">This</span> is <span class="keyword">true</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):017:0&gt;</span> puts <span class="string">'This is true'</span> if not true</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):018:0&gt;</span> puts <span class="string">'This is ture'</span> if !true</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>比较什么的和其他语言大同小异，条件判断的话，主要是 <code>if</code> 和 <code>unless</code>（当然 <code>!</code> 和 <code>not</code> 都可以用，但是建议用 <code>unless</code> 比较清晰），在 Ruby 的语法中可以直接一行搞定判断一句，这样至少写起来很清晰。</p>
<p>除了 <code>nil</code> 和 <code>false</code> 之外，其他值都代表 <code>true</code>，注意！0 也是 <code>true</code>！</p>
<p>循环语句可以使用 <code>while</code> 和 <code>until</code>，比较简单，这里直接看例子，需要注意的是，Ruby 中没种对戏那个都有自己的相等的概念，对于数字来说，值相等就是相等。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> x = <span class="number">2</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> x = x + <span class="number">1</span> while x &lt; <span class="number">10</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> x</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">10</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> x = x - <span class="number">1</span> until x == <span class="number">1</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> x</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> while x &lt; <span class="number">10</span></span><br><span class="line"><span class="prompt">irb(main):007:1&gt;</span>   x = x + <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):008:1&gt;</span>   puts x</span><br><span class="line"><span class="prompt">irb(main):009:1&gt;</span> end</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>逻辑运算符和 C++/Java 有少许不同，<code>and</code>(<code>&amp;&amp;</code>) 是逻辑与，<code>or</code>(<code>||</code>) 是逻辑或，都是短路求值的，如果想要整个表达式都执行的话，使用 <code>&amp;</code> 和 <code>|</code> 来比较，具体为</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> true and false</span><br><span class="line"><span class="status">=&gt;</span> false</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> true or false</span><br><span class="line"><span class="status">=&gt;</span> true</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> false &amp;&amp; false</span><br><span class="line"><span class="status">=&gt;</span> false</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> true &amp;&amp; this_will_cause_an_error</span><br><span class="line"><span class="constant">NameError</span><span class="symbol">:</span> undefined local variable <span class="keyword">or</span> method <span class="string">`this_will_cause_an_error' for main:Object</span><br><span class="line">	from (irb):4</span><br><span class="line">	from /usr/local/bin/irb:11:in `</span>&lt;main&gt;<span class="string">'</span><br><span class="line">irb(main):005:0&gt; false &amp;&amp; this_will_not_cause_an_error</span><br><span class="line">=&gt; false</span><br><span class="line">irb(main):006:0&gt; true or this_will_not_cause_an_error</span><br><span class="line">=&gt; true</span><br><span class="line">irb(main):007:0&gt; true || this_will_not_cause_an_error</span><br><span class="line">=&gt; true</span><br><span class="line">irb(main):008:0&gt; true | this_will_cause_an_error</span><br><span class="line">NameError: undefined local variable or method `this_will_cause_an_error'</span> <span class="keyword">for</span> <span class="symbol">main:</span><span class="constant">Object</span></span><br><span class="line">	from (irb)<span class="symbol">:</span><span class="number">8</span></span><br><span class="line">	from /usr/local/bin/<span class="symbol">irb:</span><span class="number">11</span><span class="symbol">:in</span> <span class="string">`&lt;main&gt;'</span><br><span class="line">irb(main):009:0&gt; true | false</span><br><span class="line">=&gt; true</span></span><br></pre></td></tr></table></figure>
<p>基本来说还是一目了然的，这里不再赘述</p>
<blockquote>
<p>鸭子类型</p>
</blockquote>
<p>Ruby 是强类型语言，直到真正执行代码时，才进行类型检查，称为『动态类型』，但是这也带来了一些好处：多个类不必继承自相同父类，就能以相同方式使用，如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> i = <span class="number">0</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> a = [<span class="string">'100'</span>, <span class="number">100.0</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"100"</span>, <span class="number">100.0</span>]</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> while i &lt; <span class="number">2</span></span><br><span class="line"><span class="prompt">irb(main):004:1&gt;</span>   puts a[i].to_i</span><br><span class="line"><span class="prompt">irb(main):005:1&gt;</span>   i = i + <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:1&gt;</span> end</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>这其实就是面向对象设计思想中的重要原则：对接口编码。举个例子，对象若有 <code>push</code> 和 <code>pop</code>，那么就可以当做栈来使用。</p>
<blockquote>
<p>函数</p>
</blockquote>
<p>函数的定义也和简单，并且，函数也是一个对象</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tell_the_truth</span></span></span><br><span class="line">    <span class="keyword">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组</p>
</blockquote>
<p>同样先来看实例</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> animals = [<span class="string">'lions'</span>, <span class="string">'tigers'</span>, <span class="string">'bears'</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>]</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> puts animals</span><br><span class="line">lions</span><br><span class="line">tigers</span><br><span class="line">bears</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> animals[<span class="number">2</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"bears"</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> animals[<span class="number">3</span>]</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> animals[-<span class="number">1</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"bears"</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> animals[<span class="number">0</span>..<span class="number">2</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>]</span><br><span class="line"><span class="prompt">irb(main):007:0&gt;</span> (<span class="number">0</span>..<span class="number">1</span>).class</span><br><span class="line"><span class="status">=&gt;</span> <span class="constant">Range</span></span><br></pre></td></tr></table></figure>
<p>具体部分比较好明白，唯一需要注意的是 <code>0..1</code> 其实是个对象。另外 <code>[]</code> 是 <code>Array</code> 类的方法，所以 <code>[]</code> 和 <code>[]=</code> 其实是语法糖。想要用的话，必须先在变量里放一个空数组。数组元素不必具有相同类型。</p>
<blockquote>
<p>散列表</p>
</blockquote>
<p>其实就是键值对存储，来看例子</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> numbers = &#123;<span class="number">1</span> =&gt; <span class="string">'one'</span>, <span class="number">2</span> =&gt; <span class="string">'two'</span>&#125;</span><br><span class="line"><span class="status">=&gt;</span> &#123;<span class="number">1</span>=&gt;<span class="string">"one"</span>, <span class="number">2</span>=&gt;<span class="string">"two"</span>&#125;</span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> numbers[<span class="number">1</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"one"</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> stuff = &#123;<span class="symbol">:array</span> =&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="symbol">:string</span> =&gt; <span class="string">'Hi, mom!'</span>&#125;</span><br><span class="line"><span class="status">=&gt;</span> &#123;<span class="symbol">:array=&gt;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="symbol">:string=&gt;<span class="string">"Hi, mom!"</span></span>&#125;</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> stuff[<span class="symbol">:string</span>]</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Hi, mom!"</span></span><br></pre></td></tr></table></figure>
<p>这里尤其需要注意 <code>stuff</code> 这个散列表，我们使用了 symbol 的概念，就是变量名称前面加个冒号。这样做的意义在于，相同的 symbol 会指向相同的物理对象，比如下面的例子，两次 <code>&#39;string&#39;</code> 的 id 值不一样，但是 <code>:string</code> 的值是一样的</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):005:0&gt;</span> <span class="string">'string'</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">70186296639880</span></span><br><span class="line"><span class="prompt">irb(main):006:0&gt;</span> <span class="string">'string'</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">70186296271240</span></span><br><span class="line"><span class="prompt">irb(main):007:0&gt;</span> <span class="symbol">:string</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">156648</span></span><br><span class="line"><span class="prompt">irb(main):008:0&gt;</span> <span class="symbol">:string</span>.object_id</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">156648</span></span><br></pre></td></tr></table></figure>
<p>散列表的一个应用就是模拟命名参数（就是不同的参数有不同的名字，这样可以根据名字来引用，而不是根据预订好的位置类进行引用），例如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="function"><span class="keyword">def</span> <span class="title">tell_the_truth</span><span class="params">(options=&#123;&#125;)</span></span></span><br><span class="line"><span class="prompt">irb(main):002:1&gt;</span>   if options[<span class="symbol">:profession</span>] == <span class="symbol">:lawyer</span></span><br><span class="line"><span class="prompt">irb(main):003:2&gt;</span>     <span class="string">'oh you are a laywer'</span></span><br><span class="line"><span class="prompt">irb(main):004:2&gt;</span>   else</span><br><span class="line">irb(main)<span class="symbol">:</span><span class="number">005</span><span class="symbol">:</span><span class="number">2</span>*     <span class="string">'who you are'</span></span><br><span class="line"><span class="prompt">irb(main):006:2&gt;</span>   end</span><br><span class="line"><span class="prompt">irb(main):007:1&gt;</span> end</span><br><span class="line"><span class="status">=&gt;</span> <span class="symbol">:tell_the_truth</span></span><br><span class="line"><span class="prompt">irb(main):008:0&gt;</span> tell_the_truth</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"who you are"</span></span><br><span class="line"><span class="prompt">irb(main):009:0&gt;</span> tell_the_truth <span class="symbol">:profession</span> =&gt; <span class="symbol">:lawyer</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"oh you are a laywer"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>options</code> 表示可选参数，如果不传入，默认就是空散列表</li>
<li>散列表用作最后一个参数的时候可以省略大括号</li>
</ul>
<blockquote>
<p>代码块和 yield</p>
</blockquote>
<p>代码块就是匿名函数，可以作为参数传递，比如说</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="number">3</span>.times &#123;puts <span class="string">'great day!'</span>&#125;</span><br><span class="line">great day!</span><br><span class="line">great day!</span><br><span class="line">great day!</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">3</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> animals = [<span class="string">'lions'</span>, <span class="string">'tigers'</span>, <span class="string">'bears'</span>, <span class="string">'rabbits'</span>]</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>, <span class="string">"rabbits"</span>]</span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> animals.each &#123;|a| puts a&#125;</span><br><span class="line">lions</span><br><span class="line">tigers</span><br><span class="line">bears</span><br><span class="line">rabbits</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>, <span class="string">"rabbits"</span>]</span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> animals.each do |a| \</span><br><span class="line">irb(main)<span class="symbol">:</span><span class="number">005</span><span class="symbol">:</span><span class="number">1</span>*                 puts a <span class="keyword">end</span></span><br><span class="line">lions</span><br><span class="line">tigers</span><br><span class="line">bears</span><br><span class="line">rabbits</span><br><span class="line"><span class="status">=&gt;</span> [<span class="string">"lions"</span>, <span class="string">"tigers"</span>, <span class="string">"bears"</span>, <span class="string">"rabbits"</span>]</span><br></pre></td></tr></table></figure>
<p>代码块只占一行时用 <code>{ / }</code>，多行的话则使用 <code>do / end</code>。如果我们要实现自己的 <code>times</code> 函数要怎么做呢？其实也很简单，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Fixnum</span></span></span><br><span class="line"><span class="prompt">irb(main):002:1&gt;</span>   <span class="function"><span class="keyword">def</span> <span class="title">my_times</span></span></span><br><span class="line"><span class="prompt">irb(main):003:2&gt;</span>     i = self</span><br><span class="line"><span class="prompt">irb(main):004:2&gt;</span>     while i &gt; <span class="number">0</span></span><br><span class="line"><span class="prompt">irb(main):005:3&gt;</span>       i = i - <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:3&gt;</span>       yield</span><br><span class="line"><span class="prompt">irb(main):007:3&gt;</span>     end</span><br><span class="line"><span class="prompt">irb(main):008:2&gt;</span>   end</span><br><span class="line"><span class="prompt">irb(main):009:1&gt;</span> end</span><br><span class="line"><span class="status">=&gt;</span> <span class="symbol">:my_times</span></span><br><span class="line"><span class="prompt">irb(main):010:0&gt;</span> <span class="number">3</span>.my_times &#123;puts <span class="string">'my own times!'</span>&#125;</span><br><span class="line">my own times!</span><br><span class="line">my own times!</span><br><span class="line">my own times!</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<p>因为代码块可以作为参数，于是类似于函数指针，可以更加灵活进行调用。</p>
<blockquote>
<p>面向对象</p>
</blockquote>
<p>主要是类和模块，这里设计的知识点比较繁杂，可以自行阅读参考链接中的文档，这里不再赘述</p>
<blockquote>
<p>优劣</p>
</blockquote>
<p>使用 Ruby 可以用一致的方向处理对象，还有各种不同的语法糖，可以有效提高编程的效率，不过这也导致一定的性能损失。另外，ruby 在并发条件下会产生严重问题（资源竞争）</p>
<h2 id="u4E60_u9898"><a href="#u4E60_u9898" class="headerlink" title="习题"></a>习题</h2><blockquote>
<p>替换字符串某一部分</p>
</blockquote>
<p>字符串相关的操作可以在<a href="http://ruby-doc.org/core-2.3.0/String.html" target="_blank" rel="external">这里</a>查看（其他的类也可以通过这种方式来学习）</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> title = <span class="string">"This is DaWang."</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"This is DaWang."</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> title[<span class="number">0</span>,<span class="number">3</span>] = <span class="string">"That"</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"That"</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> title</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Thats is DaWang."</span></span><br><span class="line"><span class="prompt">irb(main):004:0&gt;</span> title[<span class="number">0</span>,<span class="number">5</span>] = <span class="string">"That"</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"That"</span></span><br><span class="line"><span class="prompt">irb(main):005:0&gt;</span> title</span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"That is DaWang."</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意字符串的位置索引，具体可以试验一下。</p>
<blockquote>
<p>在字符串 <code>Hello, dawang</code> 中，找到 <code>dawang</code> 所在下标 </p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> s = <span class="string">'Hello, dawang'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"Hello, dawang"</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> i = s.index(<span class="string">'dawang'</span>)</span><br><span class="line"><span class="status">=&gt;</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>打印名字十次，并输出序号</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">irb(main):001:0&gt;</span> name = <span class="string">'dawang'</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="string">"dawang"</span></span><br><span class="line"><span class="prompt">irb(main):002:0&gt;</span> i = <span class="number">0</span></span><br><span class="line"><span class="status">=&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="prompt">irb(main):003:0&gt;</span> while i &lt; <span class="number">10</span></span><br><span class="line"><span class="prompt">irb(main):004:1&gt;</span>   puts <span class="string">"<span class="subst">#&#123;i+<span class="number">1</span>&#125;</span> <span class="subst">#&#123;name&#125;</span>"</span></span><br><span class="line"><span class="prompt">irb(main):005:1&gt;</span>   i = i + <span class="number">1</span></span><br><span class="line"><span class="prompt">irb(main):006:1&gt;</span> end</span><br><span class="line"><span class="number">1</span> dawang</span><br><span class="line"><span class="number">2</span> dawang</span><br><span class="line"><span class="number">3</span> dawang</span><br><span class="line"><span class="number">4</span> dawang</span><br><span class="line"><span class="number">5</span> dawang</span><br><span class="line"><span class="number">6</span> dawang</span><br><span class="line"><span class="number">7</span> dawang</span><br><span class="line"><span class="number">8</span> dawang</span><br><span class="line"><span class="number">9</span> dawang</span><br><span class="line"><span class="number">10</span> dawang</span><br><span class="line"><span class="status">=&gt;</span> nil</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从文件运行 Ruby 程序</p>
</blockquote>
<p>类似 python，直接 <code>ruby filename</code> 即可，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [8:47:56]</span></span><br><span class="line">$ cat test.rb</span><br><span class="line">name = <span class="string">'dawang'</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span></span><br><span class="line">    puts <span class="string">"#&#123;i+1&#125; #&#123;name&#125;"</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [8:48:36]</span></span><br><span class="line">$ ruby test.rb</span><br><span class="line"><span class="number">1</span> dawang</span><br><span class="line"><span class="number">2</span> dawang</span><br><span class="line"><span class="number">3</span> dawang</span><br><span class="line"><span class="number">4</span> dawang</span><br><span class="line"><span class="number">5</span> dawang</span><br><span class="line"><span class="number">6</span> dawang</span><br><span class="line"><span class="number">7</span> dawang</span><br><span class="line"><span class="number">8</span> dawang</span><br><span class="line"><span class="number">9</span> dawang</span><br><span class="line"><span class="number">10</span> dawang</span><br></pre></td></tr></table></figure>
<blockquote>
<p>生成一个 0~9 的随机数，让用户猜，并告知结果</p>
</blockquote>
<p>具体可以直接看代码</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [9:07:47]</span></span><br><span class="line"><span class="variable">$ </span>cat test.rb</span><br><span class="line">puts <span class="string">'Please input a number between 0~9: '</span></span><br><span class="line">numstr = gets</span><br><span class="line">num = numstr.to_i(base=<span class="number">10</span>)</span><br><span class="line">puts <span class="string">'Generating random number..'</span></span><br><span class="line">target = rand(<span class="number">10</span>)</span><br><span class="line">puts <span class="string">"The target number is <span class="subst">#&#123;target&#125;</span>"</span></span><br><span class="line"><span class="keyword">if</span> num == target</span><br><span class="line">    puts <span class="string">'You made it!'</span></span><br><span class="line"><span class="keyword">elsif</span> num &lt; target</span><br><span class="line">    puts <span class="string">'Answer Too Small!'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    puts <span class="string">'Answer Too Large!'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Desktop [9:07:53]</span></span><br><span class="line"><span class="variable">$ </span>ruby test.rb</span><br><span class="line"><span class="constant">Please</span> input a number between <span class="number">0</span>~<span class="number">9</span><span class="symbol">:</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="constant">Generating</span> random number..</span><br><span class="line"><span class="constant">The</span> target number is <span class="number">6</span></span><br><span class="line"><span class="constant">Answer</span> <span class="constant">Too</span> <span class="constant">Small</span>!</span><br></pre></td></tr></table></figure>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://ruby-doc.org/core-2.3.0/" target="_blank" rel="external">Ruby APi</a></li>
<li><a href="http://ruby-doc.com/docs/ProgrammingRuby/" target="_blank" rel="external">Programming Ruby: The Pragmatic Programmer’s Guide</a></li>
<li><a href="http://www.runoob.com/ruby/ruby-regular-expressions.html" target="_blank" rel="external">Ruby 正则表达式</a></li>
<li><a href="http://www.runoob.com/ruby/ruby-range.html" target="_blank" rel="external">Ruby 区间(range)</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>学编程就好比学有用，再好的理论也不如一头扎下水，扑腾着呼吸新鲜空气管用。这个系列的目的，就是帮助自己跳入水中，这一次我们来学 Ruby。</p>]]>
    
    </summary>
    
      <category term="Ruby" scheme="http://wdxtub.com/tags/Ruby/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="语言" scheme="http://wdxtub.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件架构与设计 习题课 6 设计模式进阶练习]]></title>
    <link href="http://wdxtub.com/2016/03/30/sad-r6/"/>
    <id>http://wdxtub.com/2016/03/30/sad-r6/</id>
    <published>2016-03-30T11:11:03.000Z</published>
    <updated>2016-04-02T20:46:16.000Z</updated>
    <content type="html"><![CDATA[<p>接着上次的练习，这次给出具体场景，来进行设计模式的应用，咱们直接看习题。</p>
<a id="more"></a>
<hr>
<blockquote>
<p>简单来说就是不同等级的领导可以批不同价格的订单，超出了价格范围就需要提交给上一级审批，这个时候用什么设计模式呢？如果具体的限制因素不止价格一个呢？</p>
</blockquote>
<p>顾名思义，直接用『责任链模式』。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DecisionMaker.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DecisionMaker</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> director = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> vp = <span class="number">25000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> president = <span class="number">100000</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">protected</span> string title;</span><br><span class="line">    <span class="comment">// next element in the chain</span></span><br><span class="line">    <span class="keyword">protected</span> DecisionMaker nextDM;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextDM</span><span class="params">(DecisionMaker dm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextDM = dm;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeDecision</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.price &gt; <span class="number">0</span> &amp;&amp; price &lt;= <span class="keyword">this</span>.price)&#123;</span><br><span class="line">            System.out.println(title + <span class="string">"can make the decision for price "</span>  + price);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextDM != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Handle to higher level decision maker"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DirectorDM.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectorDM</span> <span class="keyword">extends</span> <span class="title">DecisionMaker</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectorDM</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VPDM.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VPDM</span> <span class="keyword">extends</span> <span class="title">DecisionMaker</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VPDM</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PresidentDM.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PresidentDM</span> <span class="keyword">extends</span> <span class="title">DecisionMaker</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PresidentDM</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExecutiveMeetingDM</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutiveMeetingDM</span> <span class="keyword">extends</span> <span class="title">DecisionMaker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutiveMeetingDM</span><span class="params">(<span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DMDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DMDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DecisionMaker <span class="title">getChainOfDMs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DecisionMaker director = <span class="keyword">new</span> DirectorDM(<span class="number">10000</span>);</span><br><span class="line">        DecisionMaker vp = <span class="keyword">new</span> VPDM(<span class="number">25000</span>);</span><br><span class="line">        DecisionMaker president = <span class="keyword">new</span> PresidentDM(<span class="number">100000</span>);</span><br><span class="line">        <span class="comment">// -1 means infinitive</span></span><br><span class="line">        DecisionMaker exemeet = <span class="keyword">new</span> ExecutiveMeetingDM(-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        director.setNextDM(vp);</span><br><span class="line">        vp.setNextDM(president);</span><br><span class="line">        prsident.setNextDM(exemeet);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> director;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DecisionMaker dmChain = getChainofDMs();</span><br><span class="line">        </span><br><span class="line">        dmChain.makeDecision(<span class="number">5000</span>);</span><br><span class="line">        dmChain.makeDecision(<span class="number">12000</span>);</span><br><span class="line">        dmChain.makeDecision(<span class="number">32000</span>);</span><br><span class="line">        dmChain.makeDecision(<span class="number">302000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>机场一般由塔台统一协调控制，各个飞机之间不会有练习沟通，这里更适合用什么设计模式？</p>
</blockquote>
<p>一般使用中介者模式，用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tower.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Plane plane)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"["</span> + plane.toString() + <span class="string">"] Requested."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Plane.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plane</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String company;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plane</span><span class="params">(String c, String co)</span></span>&#123;</span><br><span class="line">        company = c;</span><br><span class="line">        code = co;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">sendRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Tower.handleRequest(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toSring</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> company + <span class="string">"-"</span> + code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Airport.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Airport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Plane p1 = <span class="keyword">new</span> Plane(<span class="string">"AA"</span>, <span class="string">"1000"</span>);</span><br><span class="line">        Plane p2 = <span class="keyword">new</span> Plane(<span class="string">"Delta"</span>, <span class="string">"2000"</span>);</span><br><span class="line">        </span><br><span class="line">        p1.sendRequest();</span><br><span class="line">        p2.sendRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CPU 的调度算法一般是 Round Robin，什么设计模式比较合适呢？画出类图并写出伪代码。</p>
</blockquote>
<p>（注）这个模式我也不是很确定</p>
<p>前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。</p>
<p>图和伪代码略</p>
<blockquote>
<p>弄一个消息系统，可以广播给所有的订阅者，什么设计模式比较合适呢？画出类图并写出伪代码。</p>
</blockquote>
<p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。</p>
<p>图和伪代码略</p>
<blockquote>
<p>同一个社区的方法除了颜色基本一致，什么设计模式比较合适呢？画出类图并写出伪代码。</p>
</blockquote>
<p>（注）这个模式我也不是很确定</p>
<p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>
<p>图和伪代码略</p>
<blockquote>
<p>给出一个实际生活中使用状态模式的例子</p>
</blockquote>
<p>编译器的词法解析器</p>
<blockquote>
<p>给出一个实际生活中使用状态模式的例子</p>
</blockquote>
<p>JSON 解析器</p>
<blockquote>
<p>给出一个实际生活中使用命令模式的例子</p>
</blockquote>
<p>各种 shell</p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html" target="_blank" rel="external">责任链模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/mediator-pattern.html" target="_blank" rel="external">中介者模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/front-controller-pattern.html" target="_blank" rel="external">前端控制器模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/observer-pattern.html" target="_blank" rel="external">观察者模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/flyweight-pattern.html" target="_blank" rel="external">享元模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/state-pattern.html" target="_blank" rel="external">状态模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/visitor-pattern.html" target="_blank" rel="external">访问者模式</a></li>
<li><a href="http://www.runoob.com/design-pattern/command-pattern.html" target="_blank" rel="external">命令模式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>接着上次的练习，这次给出具体场景，来进行设计模式的应用，咱们直接看习题。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="习题" scheme="http://wdxtub.com/tags/%E4%B9%A0%E9%A2%98/"/>
    
      <category term="架构" scheme="http://wdxtub.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云计算 反思课 4 HBase 优化的策略与思考]]></title>
    <link href="http://wdxtub.com/2016/03/29/cc-rethink-4/"/>
    <id>http://wdxtub.com/2016/03/29/cc-rethink-4/</id>
    <published>2016-03-30T00:18:51.000Z</published>
    <updated>2016-03-30T03:44:46.000Z</updated>
    <content type="html"><![CDATA[<p>优化的最大敌人，是反向优化。</p>
<a id="more"></a>
<hr>
<p>这次的小组作业还是挺费事费时的，虽然我也还没有做到满分，但是这两天的一些尝试还是值得记录一下的，也算是给大家提个醒。一个很深的感触：捷径就是把该走的该经历的都过完，想歪门邪道一步登天的，往往都是绕远路。</p>
<h2 id="u6570_u636E_u5904_u7406"><a href="#u6570_u636E_u5904_u7406" class="headerlink" title="数据处理"></a>数据处理</h2><p>这部分的任务可能是这次作业我做得最不好的地方，主要是因为没有在动手前设计好整个流程思路。因为时间紧，没有仔细分析问题和情境，但最终欲速则不达，像无头苍蝇一样试验各种方法出各种差错。盲目乐观和照搬 MySQL 部分的实现思路（我负责 HBase 部分），遇到问题之后依靠『侥幸』而不是『思考』来解决问题，实在是大失水准。</p>
<p>具体来看，主要有：</p>
<ol>
<li>合并数据时候实现算法不细致，用测试集测试的时候没有检查出错误，到最后导入完数据开始部署好了才发现错，每次导入+部署的半个多小时就因为这里的失误而浪费了</li>
<li>处理数据的流程没有事先规划好，遇到错误拆东墙补西墙，最后全部推倒重来才做好，以后不能再这样</li>
<li>没有设计好测试用例，导致每个步骤都不知道自己对不对，依靠『侥幸』写代码肯定要出大问题</li>
</ol>
<p>时间再紧也要谋定而后动，战略偷懒只会导致战术回旋空间变小，最终导致各种『无用功』。</p>
<h2 id="u5E73_u53F0_u9009_u62E9"><a href="#u5E73_u53F0_u9009_u62E9" class="headerlink" title="平台选择"></a>平台选择</h2><p>原先使用 Amazon EMR 来搭建 HBase，主要有几个问题：</p>
<ol>
<li>HBase 版本较低</li>
<li>没办法随时调整参数（虽然后来意识到参数是浮云）</li>
<li>性能糟糕（当然也可能是我不会用）</li>
<li>贵（除了机器本身的费用，EMR 也是要钱的）</li>
</ol>
<p>所以后来选择使用 Cloudera 来搭建自己的 Hadoop 框架平台。因为老师没有给出太多相关的资料，基本上就是一边看着文档，一个坑一个坑踩过来的。虽然没有 Amazon EMR 这么简单粗暴，但是后来看到性能明显提升，也就值得了。总的来说有以下的感觉：</p>
<ol>
<li>配置的过程其实已经尽可能简化了，基本需要手动操作的就是把交换空间设为 0，其他基本都可以在网络界面上完成（Cloudera 做得还是挺不错的，好顶赞）</li>
<li>根据自己的需要选择合适的服务，多的话用不上还占内存</li>
<li>多多利用 Cloudera 的监控表盘可以得到很多有用的信息，据此可以找到瓶颈所在</li>
<li>RegionServer 中 Region 的分布平衡很重要，Region 不能太少也不能太多，没有所谓定值，需要不断测试和优化（实在不行的话，多 split 几次也没啥问题）</li>
<li>很多参数其实不懂具体的含义，对于这种大的平台还是需要仔细研究才能真正把强大的工具用好</li>
<li>Cloudera 已经进行了一定的参数优化，基本上不用改动（尤其是在自己都不知道自己在干嘛的时候）</li>
</ol>
<p>最后就是想要强调监控数据的重要性，如何挑选需要的数据，如何去分析这些数据里面都有门道，要好好学习。</p>
<h2 id="u53C2_u6570_u8BBE_u7F6E"><a href="#u53C2_u6570_u8BBE_u7F6E" class="headerlink" title="参数设置"></a>参数设置</h2><p>忽然想到这么一句话</p>
<blockquote>
<p>按照大多数人数据库设计和代码实现的糟糕程度，根本轮不到拼参数</p>
</blockquote>
<p>像我这样的初学者，往往过分夸大了参数的重要性，只有当系统达到了瓶颈，然后对应去调整相关参数才是有意义的。按照我之前的做法，既不知道问题在哪，更谈不上硬件的充分利用，就盲目根据网上的教程来进行『优化』，所做的基本都是『反向优化』。</p>
<p>所以这个时候搜索相关网页以及请教同学都是非常有帮助的，有了大致的方向会好很多，不然在一无所知的情况下真的很容易病急乱投医。</p>
<p>不同参数的设置一定要弄清楚具体代表什么，什么时候需要改，改了会有什么影响这一系列问题之后，再进行修改测试。</p>
<p>总的来说还是学到不少东西的，以后早些开始，继续努力。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>优化的最大敌人，是反向优化。</p>]]>
    
    </summary>
    
      <category term="CMU" scheme="http://wdxtub.com/tags/CMU/"/>
    
      <category term="云计算" scheme="http://wdxtub.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="优化" scheme="http://wdxtub.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[范式转移]]></title>
    <link href="http://wdxtub.com/2016/03/27/paradigm-shift/"/>
    <id>http://wdxtub.com/2016/03/27/paradigm-shift/</id>
    <published>2016-03-28T00:18:45.000Z</published>
    <updated>2016-03-28T02:19:32.000Z</updated>
    <content type="html"><![CDATA[<p>所谓范式，是一套非常清晰的概念、思维模式、研究方法、假设和标准。从这些基准出发，我们可以推导演绎出『真理』。但假如有一天，基准改变了，是不是这些『真理』，也就不再『真』了？</p>
<a id="more"></a>
<hr>
<p>前段时间知道了『范式转移』这个概念，感觉很有意思，但是拖着拖着一直到今天才动笔。一是懒，二是最近生活中的一些变化也印证了『范式转移』本身，能够说道说道了。</p>
<p>简单来说，范式转移可以看做是一种根本假设的改变，继而带来翻天覆地的影响。对于我们来说，范式转移更应该接近于『范式升级』，我们要改变的不仅是思维，而是对事物对人情的更准确更基本的认识。</p>
<p>从去年九十月份开始一路面试了半年，了解了许多之前不熟悉的圈子，接触了不同的行业、公司、职位。虽然通过面试官来了解一个公司有些『管中窥豹』，但是至少要比从新闻中得来的要真实。毕竟新闻里说得都是最好的一面，刚入职的话，更可能接触的就是面试官一级的人。大公司选组更像是摇骰子，小公司更多时候是跟着创始人的想法走。我既不想把未来寄托于概率，也不想丢掉太多的自主性，那么正在发展转型期的已经证明自己的公司恐怕是最佳的选择，既可以通过自己的努力主导技术及业务方向，又可以不被各种制度流程所束缚。</p>
<p>从学生向社会人转变，其实就是一个『范式转移』的过程。校园是静态的，成绩、奖项以及几乎固定的同学；只要分数高，很多事儿都不是事儿；社会是动态的，环境、形势一直在变；前行路上难免磕磕碰碰，荣时知辱，逆时知顺。</p>
<p>在选择职业选择公司的时候，重要的是『三观一致』，知道自己的价值，去最能发光发热的地方去。</p>
<blockquote>
<p>一个人的命运，当然要靠自我奋斗，但是也要考虑到历史的行程。</p>
</blockquote>
<p>职业发展一定要从长远的角度思考，慢慢去摸索未来与趋势，顺势而为。俗一点说，在大家都能赚钱的时候才最好赚钱。与人相处，也更应该『职业』一些，以合作为主、待人接物自然（不要凡事都写在脸上），珍惜别人的时间，让身边的人变得更好，从更大的格局去看待问题。</p>
<p>另外，从课程考试向『做成事情』转变，也是重中之重。很多时候，我们是因为没有能力做好手头上的事情，所以才不喜欢。而越是工作做不好的无用之人，就越是会强调自己有多努力。</p>
<p>无论是在学校还是在公司，重要的不是分数的高低还是职位的级别，而是全身心投入，去验证自己的想法。不要专门去做那些证明自己的事情，事实会说明一切。</p>
<p>这也是为什么我决定从 iOS 开发转到后台系统的开发。iOS 实在太火了，各种培训班批量生产学员搞得乌烟瘴气（最近的前端热估计也是这个套路），开发一款基本的应用难度也越来越低。当然，高端人才总是稀缺的，但是有这样的大环境在，又岂能独善其身呢？</p>
<p>做成事情的重点是策略和坚持，而坚持就是最重要的策略。越来越觉得，无论是编程、雕刻还是建筑，都是技术加艺术的结晶，天赋固然重要，但刻苦练习也是不可或缺的。想要做成事情，不把手弄『脏』是不可能的。</p>
<p>于是主题就变成：范式转移了吗？手弄脏了吗？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>所谓范式，是一套非常清晰的概念、思维模式、研究方法、假设和标准。从这些基准出发，我们可以推导演绎出『真理』。但假如有一天，基准改变了，是不是这些『真理』，也就不再『真』了？</p>]]>
    
    </summary>
    
      <category term="改变" scheme="http://wdxtub.com/tags/%E6%94%B9%E5%8F%98/"/>
    
      <category term="范式" scheme="http://wdxtub.com/tags/%E8%8C%83%E5%BC%8F/"/>
    
      <category term="远见" scheme="http://wdxtub.com/tags/%E8%BF%9C%E8%A7%81/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【鸟哥的 Linux 私房菜 - 基础】学习笔记]]></title>
    <link href="http://wdxtub.com/2016/03/26/linux-basic-soup/"/>
    <id>http://wdxtub.com/2016/03/26/linux-basic-soup/</id>
    <published>2016-03-27T01:33:53.000Z</published>
    <updated>2016-03-27T17:20:41.000Z</updated>
    <content type="html"><![CDATA[<p>因为之后更多会涉及后台开发的部分，所以系统学习一下 Linux 还是很有必要的，这里就用《鸟哥的 Linux 私房菜》作为主要的学习材料。不过因为我本身已经有一定基础了，所以这里主要会记录个人觉得比较生疏和重要的地方。</p>
<a id="more"></a>
<hr>
<p>对于计算机的基本了解，可以参考我之前写的『深入理解计算机系统』系列日志。接下来主要是比较零散的知识点，具体可以参见目录。</p>
<h2 id="u5E38_u7528_u6280_u5DE7"><a href="#u5E38_u7528_u6280_u5DE7" class="headerlink" title="常用技巧"></a>常用技巧</h2><ul>
<li>遇到不懂的命令，一定先用 <code>man</code> 命令来了解一下，可以看到详细的介绍<ul>
<li><code>/string</code> 向下搜索 string 这个字符串</li>
<li><code>?string</code> 向上搜索这个字符串</li>
<li>搜索的时候输入 n, N 可以跳到下一个/上一个结果 ，q 可以退出</li>
</ul>
</li>
<li>遇到不懂的命令，可以使用 <code>info</code> 命令来查看<ul>
<li>n（下一个），p（前一个），u（上一层），h（帮助），q（退出）</li>
</ul>
</li>
<li>nano 是非常简单的编辑器，只需要 <code>nano filename</code> 即可，具体的操作会在终端中显示<ul>
<li><code>^</code> 表示 ctrl 按键</li>
</ul>
</li>
<li>改变文件属性与权限的命令<ul>
<li><code>chgrp</code>：改变文件所属群组</li>
<li><code>chown</code>：改变文件拥有者</li>
<li><code>chmod</code>：改变文件权限</li>
</ul>
</li>
<li>目录相关操作<ul>
<li><code>.</code>：代表此层目录</li>
<li><code>..</code>：代表上一层目录</li>
<li><code>-</code>：代表前一个工作目录</li>
<li><code>~</code>：代表“目前使用者身份”所在的主文件夹</li>
<li><code>~account</code>：代表 account 这个使用者的主文件夹（account是个帐号名称）</li>
<li>在所有目录下面都会存在的两个目录，分别是“.”与“..” 分别代表此层与上层目录的意思</li>
<li><code>cd</code>：变化目录</li>
<li><code>pwd</code>：显示目前目录</li>
<li><code>mkdir</code>：创建新目录</li>
<li><code>rmdir</code>：删除一个空的目录</li>
</ul>
</li>
<li>可执行文件路径变量 <code>$PATH</code><ul>
<li>当我们在执行一个指令的时候，举例来说“ls”好了，系统会依照PATH的设置去每个PATH定义的目录下搜寻文件名为ls的可执行文件， 如果在PATH定义的目录中含有多个文件名为ls的可可执行文件，那么先搜寻到的同名指令先被执行！</li>
<li><code>echo $PATH</code> 来查看当前的值</li>
</ul>
</li>
</ul>
<h2 id="u547D_u4EE4_3A_ls_2C_cp_2C_rm_2C_mv"><a href="#u547D_u4EE4_3A_ls_2C_cp_2C_rm_2C_mv" class="headerlink" title="命令: ls, cp, rm, mv"></a>命令: ls, cp, rm, mv</h2><blockquote>
<p>ls 用来查看文件与目录，选项与参数为：</p>
</blockquote>
<ul>
<li><code>-a</code>：全部的文件，连同隐藏文件（ 开头为 . 的文件） 一起列出来（常用）</li>
<li><code>-A</code>：全部的文件，连同隐藏文件，但不包括 . 与 .. 这两个目录</li>
<li><code>-d</code>：仅列出目录本身，而不是列出目录内的文件数据（常用）</li>
<li><code>-f</code>：直接列出结果，而不进行排序 （ls 默认会以文件名排序！）</li>
<li><code>-F</code>：根据文件、目录等信息，给予附加数据结构，例如：<code>*:</code> 代表可可执行文件； <code>/:</code> 代表目录； <code>=:</code> 代表 socket 文件； <code>|:</code> 代表 FIFO 文件；</li>
<li><code>-h</code>：将文件大小以人类较易读的方式（例如 GB, KB 等等）列出来；</li>
<li><code>-i</code>：列出 inode 号码，inode 的意义下一章将会介绍；</li>
<li><code>-l</code>：长数据串行出，包含文件的属性与权限等等数据；（常用）</li>
<li><code>-n</code>：列出 UID 与 GID 而非使用者与群组的名称 （UID与GID会在帐号管理提到！）</li>
<li><code>-r</code>：将排序结果反向输出，例如：原本文件名由小到大，反向则为由大到小；</li>
<li><code>-R</code>：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来；</li>
<li><code>-S</code>：以文件大小大小排序，而不是用文件名排序；</li>
<li><code>-t</code>：依时间排序，而不是用文件名。</li>
<li><code>--color=never</code>：不要依据文件特性给予颜色显示；</li>
<li><code>--color=always</code>：显示颜色</li>
<li><code>--color=auto</code>：让系统自行依据设置来判断是否给予颜色</li>
<li><code>--full-time</code>：以完整时间模式 （包含年、月、日、时、分） 输出</li>
<li><code>--time={atime,ctime}</code>：输出 access 时间或改变权限属性时间 （ctime） 而非内容变更时间 （modification time）</li>
</ul>
<blockquote>
<p>cp 用来复制文件或者创建链接，选项与参数为：</p>
</blockquote>
<ul>
<li><code>-a</code>：相当于 -dr –preserve=all 的意思，至于 dr 请参考下列说明；（常用）</li>
<li><code>-d</code>：若来源文件为链接文件的属性（link file），则复制链接文件属性而非文件本身；</li>
<li><code>-f</code>：为强制（force）的意思，若目标文件已经存在且无法打开，则移除后再尝试一次；</li>
<li><code>-i</code>：若目标文件（destination）已经存在时，在覆盖时会先询问动作的进行（常用）</li>
<li><code>-l</code>：进行硬式链接（hard link）的链接文件创建，而非复制文件本身；</li>
<li><code>-p</code>：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）；</li>
<li><code>-r</code>：递回持续复制，用于目录的复制行为；（常用）</li>
<li><code>-s</code>：复制成为符号链接文件 （symbolic link），亦即“捷径”文件；</li>
<li><code>-u</code>：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制。</li>
<li><code>--preserve=all</code>：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了。最后需要注意的，如果来源文件有两个以上，则最后一个目的文件一定要是“目录”才行！</li>
</ul>
<blockquote>
<p>mv 用来移动文件或者重命名，选项与参数为：</p>
</blockquote>
<ul>
<li><code>-f</code>：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li><code>-i</code>：若目标文件 （destination） 已经存在时，就会询问是否覆盖！</li>
<li><code>-u</code>：若目标文件已经存在，且 source 比较新，才会更新 （update）</li>
</ul>
<blockquote>
<p>rm 用来删除文件，选项与参数为：</p>
</blockquote>
<ul>
<li><code>-f</code>：就是 force 的意思，忽略不存在的文件，不会出现警告讯息；</li>
<li><code>-i</code>：互动模式，在删除前会询问使用者是否动作</li>
<li><code>-r</code>：递回删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
</ul>
<h2 id="u547D_u4EE4_3A_cat_2C_tac_2C_nl_2C_more_2C_less"><a href="#u547D_u4EE4_3A_cat_2C_tac_2C_nl_2C_more_2C_less" class="headerlink" title="命令: cat, tac, nl, more, less"></a>命令: cat, tac, nl, more, less</h2><blockquote>
<p>cat 由第一行开始显示文件内容</p>
</blockquote>
<ul>
<li><code>-A</code>：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li><code>-b</code>：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li><code>-E</code>：将结尾的断行字符 $ 显示出来；</li>
<li><code>-n</code>：打印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li><code>-T</code>：将 [tab] 按键以 ^I 显示出来；</li>
<li><code>-v</code>：列出一些看不出来的特殊字符</li>
</ul>
<blockquote>
<p>tac  从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</p>
</blockquote>
<p>具体的参数和 cat 是一致的，这里不赘述</p>
<blockquote>
<p>nl   显示的时候，顺道输出行号！</p>
</blockquote>
<ul>
<li><code>-b</code>：指定行号指定的方式，主要有两种：<ul>
<li><code>-b a</code>：表示不论是否为空行，也同样列出行号（类似 cat -n）；</li>
<li><code>-b t</code>：如果有空行，空的那一行不要列出行号（默认值）；</li>
</ul>
</li>
<li><code>-n</code>：列出行号表示的方法，主要有三种：<ul>
<li><code>-n ln</code>：行号在屏幕的最左方显示；</li>
<li><code>-n rn</code>：行号在自己字段的最右方显示，且不加 0 ；</li>
<li><code>-n rz</code>：行号在自己字段的最右方显示，且加 0 ；</li>
</ul>
</li>
<li><code>-w</code>：行号字段的占用的字符数。</li>
</ul>
<blockquote>
<p>more 一页一页的显示文件内容，支持的按键有</p>
</blockquote>
<ul>
<li><code>空格</code>：代表向下翻一页；</li>
<li><code>Enter</code>：代表向下翻“一行”；</li>
<li><code>/字串</code>：代表在这个显示的内容当中，向下搜寻“字串”这个关键字；</li>
<li><code>:f</code>：立刻显示出文件名以及目前显示的行数；</li>
<li><code>q</code>：代表立刻离开 more ，不再显示该文件内容。</li>
<li><code>b 或 [ctrl]-b</code>：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<blockquote>
<p>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！支持的按键有</p>
</blockquote>
<ul>
<li><code>空格</code>：向下翻动一页；</li>
<li><code>[pagedown]</code>：向下翻动一页；</li>
<li><code>[pageup]</code>：向上翻动一页；</li>
<li><code>/字串</code>：向下搜寻“字串”的功能；</li>
<li><code>?字串</code>：向上搜寻“字串”的功能；</li>
<li><code>n</code>：重复前一个搜寻 （与 / 或 ? 有关！）</li>
<li><code>N</code>：反向的重复前一个搜寻 （与 / 或 ? 有关！）</li>
<li><code>g</code>：前进到这个数据的第一行去；</li>
<li><code>G</code>：前进到这个数据的最后一行去 （注意大小写）；</li>
<li><code>q</code>：离开 less 这个程序；</li>
</ul>
<p>你是否会觉得 less 使用的画面与环境与 man page 非常的类似呢？没错啦！因为man这个指令就是调用 less 来显示说明文档的内容的！</p>
<h2 id="u547D_u4EE4_3A_head_2C_tail_2C_od_2C_touch"><a href="#u547D_u4EE4_3A_head_2C_tail_2C_od_2C_touch" class="headerlink" title="命令: head, tail, od, touch"></a>命令: head, tail, od, touch</h2><blockquote>
<p>head 只看头几行</p>
</blockquote>
<ul>
<li><code>-n</code>：后面接数字，代表显示几行的意思</li>
<li>另外那个 -n 选项后面的参数较有趣，如果接的是负数，例如上面范例的 -n -100时，代表列前的所有行数， 但不包括后面100行</li>
</ul>
<blockquote>
<p>tail 只看尾巴几行</p>
</blockquote>
<ul>
<li><code>-n</code>：后面接数字，代表显示几行的意思</li>
<li><code>-f</code>：表示持续侦测后面所接的文件名，要等到按下[ctrl]-c才会结束tail的侦测</li>
</ul>
<blockquote>
<p>od 以二进制的方式读取文件内容！</p>
</blockquote>
<ul>
<li><code>-t</code>：后面可以接各种“类型 （TYPE）”的输出，例如：<ul>
<li><code>a</code>：利用默认的字符来输出；</li>
<li><code>c</code>：使用 ASCII 字符来输出</li>
<li><code>d[size]</code>：利用十进制（decimal）来输出数据，每个整数占用 size Bytes ；</li>
<li><code>f[size]</code>：利用浮点数值（floating）来输出数据，每个数占用 size Bytes ；</li>
<li><code>o[size]</code>：利用八进位（octal）来输出数据，每个整数占用 size Bytes ；</li>
<li><code>x[size]</code>：利用十六进制（hexadecimal）来输出数据，每个整数占用 size Bytes ；</li>
</ul>
</li>
</ul>
<blockquote>
<p>touch 修改文件时间或创建新文件</p>
</blockquote>
<p>我们在 ls 这个指令的介绍时，有稍微提到每个文件在linux下面都会记录许多的时间参数， 其实是有三个主要的变动时间，那么三个时间的意义是什么呢？</p>
<ul>
<li>modification time （mtime）：<ul>
<li>当该文件的“内容数据”变更时，就会更新这个时间！内容数据指的是文件的内容，而不是文件的属性或权限喔！</li>
</ul>
</li>
<li>status time （ctime）：<ul>
<li>当该文件的“状态 （status）”改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间啊。</li>
</ul>
</li>
<li>access time （atime）：<ul>
<li>当“该文件的内容被取用”时，就会更新这个读取时间 （access）。举例来说，我们使用 cat 去读取 /etc/man_db.conf ， 就会更新该文件的 atime 了。</li>
</ul>
</li>
</ul>
<p>选项与参数</p>
<ul>
<li><code>-a</code>：仅修订 access time；</li>
<li><code>-c</code>：仅修改文件的时间，若该文件不存在则不创建新文件；</li>
<li><code>-d</code>：后面可以接欲修订的日期而不用目前的日期，也可以使用 –date=”日期或时间”</li>
<li><code>-m</code>：仅修改 mtime ；</li>
<li><code>-t</code>：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]</li>
</ul>
<h2 id="u547D_u4EE4_3A_file_2C_which_2C_whereis_2C_locate/updatedb_2C_find"><a href="#u547D_u4EE4_3A_file_2C_which_2C_whereis_2C_locate/updatedb_2C_find" class="headerlink" title="命令: file, which, whereis, locate/updatedb, find"></a>命令: file, which, whereis, locate/updatedb, find</h2><blockquote>
<p>file 观察文件类型</p>
</blockquote>
<p>如果你想要知道某个文件的基本数据，例如是属于 ASCII 或者是 data 文件，或者是 binary ， 且其中有没有使用到动态函数库 （share library） 等等的信息，就可以利用 file 这个指令来检阅喔！</p>
<blockquote>
<p>which 指令文件名的搜寻 </p>
</blockquote>
<p><code>which [-a] command</code> 选项或参数：</p>
<ul>
<li><code>-a</code>：将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称</li>
</ul>
<blockquote>
<p>whereis 由一些特定的目录中寻找文件文件名</p>
</blockquote>
<p><code>whereis [-bmsu] 文件或目录名</code>  选项或参数：</p>
<ul>
<li><code>-l</code>:可以列出 whereis 会去查询的几个主要目录而已</li>
<li><code>-b</code>:只找 binary 格式的文件</li>
<li><code>-m</code>:只找在说明文档 manual 路径下的文件</li>
<li><code>-s</code>:只找 source 来源文件</li>
<li><code>-u</code>:搜寻不在上述三个项目当中的其他特殊文件</li>
</ul>
<blockquote>
<p>locate 搜索包含指定词的文件</p>
</blockquote>
<p><code>locate [-ir] keyword</code> 选项与参数：</p>
<ul>
<li><code>-i</code>：忽略大小写的差异；</li>
<li><code>-c</code>：不输出文件名，仅计算找到的文件数量</li>
<li><code>-l</code>：仅输出几行的意思，例如输出五行则是 -l 5</li>
<li><code>-S</code>：输出 locate 所使用的数据库文件的相关信息，包括该数据库纪录的文件/目录数量等</li>
<li><code>-r</code>：后面可接正则表达式的显示方式</li>
</ul>
<p>locate 寻找的数据是由“已创建的数据库 /var/lib/mlocate/” 里面的数据所搜寻到的，所以不用直接在去硬盘当中存取数据。那么有什么限制呢？就是因为他是经由数据库来搜寻的，而数据库的创建默认是在每天执行一次 </p>
<p>那能否手动更新数据库哪？当然可以啊！更新 locate 数据库的方法非常简单，直接输入“ updatedb ”就可以了！ updatedb 指令会去读取 /etc/updatedb.conf 这个配置文件的设置，然后再去硬盘里面进行搜寻文件名的动作， 最后就更新整个数据库文件啰！因为 updatedb 会去搜寻硬盘，所以当你执行 updatedb 时，可能会等待数分钟的时间喔！</p>
<blockquote>
<p>find 查找具体文件</p>
</blockquote>
<p><code>find [PATH] [option] [action]</code> 选项与参数：</p>
<ul>
<li>与时间有关的选项：共有 -atime, -ctime 与 -mtime ，以 -mtime 说明<ul>
<li><code>-mtime  n</code>：n 为数字，意义为在 n 天之前的“一天之内”被更动过内容的文件；</li>
<li><code>-mtime +n</code>：列出在 n 天之前（不含 n 天本身）被更动过内容的文件文件名；</li>
<li><code>-mtime -n</code>：列出在 n 天之内（含 n 天本身）被更动过内容的文件文件名。</li>
<li><code>-newer file</code>：file 为一个存在的文件，列出比 file 还要新的文件文件名</li>
</ul>
</li>
<li>与使用者或群组名称有关的参数<ul>
<li><code>-uid n</code>：n 为数字，这个数字是使用者的帐号 ID，亦即 UID ，这个 UID 是记录在 /etc/passwd 里面与帐号名称对应的数字。</li>
<li><code>-gid n</code>：n 为数字，这个数字是群组名称的 ID，亦即 GID，这个 GID 记录在/etc/group</li>
<li><code>-user name</code>：name 为使用者帐号名称喔！例如 dmtsai </li>
<li><code>-group name</code>：name 为群组名称喔，例如 users ；</li>
<li><code>-nouser</code>：寻找文件的拥有者不存在 /etc/passwd 的人！</li>
<li><code>-nogroup</code>：寻找文件的拥有群组不存在于 /etc/group 的文件！</li>
<li>当你自行安装软件时，很可能该软件的属性当中并没有文件拥有者，这是可能的！在这个时候，就可以使用 -nouser 与 -nogroup 搜寻。</li>
</ul>
</li>
<li>与文件权限及名称有关的参数：<ul>
<li><code>-name filename</code>：搜寻文件名称为 filename 的文件；</li>
<li><code>-size [+-]SIZE</code>：搜寻比 SIZE 还要大（+）或小（-）的文件。这个 SIZE 的规格有：<ul>
<li><code>c</code>: 代表 Byte</li>
<li><code>k</code>: 代表 1024Bytes</li>
<li>所以，要找比 50KB 还要大的文件，就是 <code>-size +50k</code></li>
</ul>
</li>
<li><code>-type TYPE</code>：搜寻文件的类型为 TYPE 的，类型主要有：一般正规文件 （f）, 设备文件 （b, c）,目录 （d）, 链接文件 （l）, socket （s）, 及 FIFO （p） 等属性。</li>
<li><code>-perm mode</code>：搜寻文件权限“刚好等于” mode 的文件，这个 mode 为类似 chmod 的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！</li>
<li><code>-perm -mode</code>：搜寻文件权限“必须要全部囊括 mode 的权限”的文件，举例来说，我们要搜寻 <code>-rwxr--r--</code> ，亦即 0744 的文件，使用 <code>-perm -0744</code>，当一个文件的权限为 <code>-rwsr-xr-x</code> ，亦即 4755 时，也会被列出来，因为 <code>-rwsr-xr-x</code> 的属性已经囊括了 <code>-rwxr--r--</code> 的属性了。</li>
<li><code>-perm /mode</code>：搜寻文件权限“包含任一 mode 的权限”的文件，举例来说，我们搜寻 <code>-rwxr-xr-x</code> ，亦即 <code>-perm /755</code> 时，但一个文件属性为 <code>-rw-------</code> 也会被列出来，因为他有 <code>-rw....</code> 的属性存在！</li>
</ul>
</li>
</ul>
<h2 id="u547D_u4EE4_3A_gzip_2C_zcat/zmore/zless/zgrep"><a href="#u547D_u4EE4_3A_gzip_2C_zcat/zmore/zless/zgrep" class="headerlink" title="命令: gzip, zcat/zmore/zless/zgrep"></a>命令: gzip, zcat/zmore/zless/zgrep</h2><p>gzip 可以说是应用度最广的压缩指令了！目前 gzip 可以解开 compress, zip 与 gzip 等软件所压缩的文件。 至于 gzip 所创建的压缩文件为 *.gz 的文件名喔！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip [-cdtv<span class="comment">#] 文件名</span></span><br><span class="line">zcat 文件名.gz</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-c</code>：将压缩的数据输出到屏幕上，可通过数据流重导向来处理；</li>
<li><code>-d</code>：解压缩的参数；</li>
<li><code>-t</code>：可以用来检验一个压缩文件的一致性～看看文件有无错误；</li>
<li><code>-v</code>：可以显示出原文件/压缩文件的压缩比等信息；</li>
<li><code>-#</code>：# 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！默认是 -6</li>
</ul>
<p>当你使用 gzip 进行压缩时，在默认的状态下原本的文件会被压缩成为 .gz 的文件名，原始文件就不再存在了。 </p>
<p>cat/more/less 可以使用不同的方式来读取纯文本文件，那个 zcat/zmore/zless 则可以对应于 cat/more/less 的方式来读取纯文本文件被压缩后的压缩文件！ 由于 gzip 这个压缩指令主要想要用来取代 compress 的，所以不但 compress 的压缩文件可以使用 gzip 来解开，同时 zcat 这个指令可以同时读取 compress 与 gzip 的压缩文件呦！</p>
<h2 id="u547D_u4EE4_3A_bzip2_2C_bzcat/bzmore/bzless/bzgrep"><a href="#u547D_u4EE4_3A_bzip2_2C_bzcat/bzmore/bzless/bzgrep" class="headerlink" title="命令: bzip2, bzcat/bzmore/bzless/bzgrep"></a>命令: bzip2, bzcat/bzmore/bzless/bzgrep</h2><p>若说 gzip 是为了取代 compress 并提供更好的压缩比而成立的，那么 bzip2 则是为了取代 gzip 并提供更佳的压缩比而来的。 bzip2 真是很不错用的东西～这玩意的压缩比竟然比 gzip 还要好～至于 bzip2 的用法几乎与 gzip 相同！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bzip2 [-cdkzv<span class="comment">#] 文件名</span></span><br><span class="line">bzcat 文件名.bz2</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-c</code>：将压缩的过程产生的数据输出到屏幕上！</li>
<li><code>-d</code>：解压缩的参数</li>
<li><code>-k</code>：保留原始文件，而不会删除原始的文件喔！</li>
<li><code>-z</code>：压缩的参数 （默认值，可以不加）</li>
<li><code>-v</code>：可以显示出原文件/压缩文件的压缩比等信息；</li>
<li><code>-#</code>：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！</li>
</ul>
<h2 id="u547D_u4EE4_3A_tar"><a href="#u547D_u4EE4_3A_tar" class="headerlink" title="命令: tar"></a>命令: tar</h2><p>tar 可以将多个目录或文件打包成一个大文件，同时还可以通过 gzip/bzip2/xz 的支持，将该文件同时进行压缩！ 更有趣的是，由于 tar 的使用太广泛了，目前 Windows 的 WinRAR 也支持 .tar.gz 文件名的解压缩呢！</p>
<p>tar 的选项与参数非常的多！我们只讲几个常用的选项，更多选项您可以自行 man tar 查询啰！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar [-z|-j|-J] [cv] [<span class="operator">-f</span> 待创建的新文件名] filename... &lt;==打包与压缩</span><br><span class="line">tar [-z|-j|-J] [tv] [<span class="operator">-f</span> 既有的 tar文件名]             &lt;==察看文件名</span><br><span class="line">tar [-z|-j|-J] [xv] [<span class="operator">-f</span> 既有的 tar文件名] [-C 目录]   &lt;==解压缩</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-c</code>：创建打包文件，可搭配 -v 来察看过程中被打包的文件名（filename）</li>
<li><code>-t</code>：察看打包文件的内容含有哪些文件名，重点在察看“文件名”就是了；</li>
<li><code>-x</code>：解打包或解压缩的功能，可以搭配 -C （大写） 在特定目录解开特别留意的是， -c, -t, -x 不可同时出现在一串指令列中。</li>
<li><code>-z</code>：通过 gzip  的支持进行压缩/解压缩：此时文件名最好为 *.tar.gz</li>
<li><code>-j</code>：通过 bzip2 的支持进行压缩/解压缩：此时文件名最好为 *.tar.bz2</li>
<li><code>-J</code>：通过 xz    的支持进行压缩/解压缩：此时文件名最好为 *.tar.xz 特别留意， -z, -j, -J 不可以同时出现在一串指令列中</li>
<li><code>-v</code>：在压缩/解压缩的过程中，将正在处理的文件名显示出来！</li>
<li><code>-f filename</code>：-f 后面要立刻接要被处理的文件名！建议 -f 单独写一个选项啰！（比较不会忘记）</li>
<li><code>-C 目录</code>：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。</li>
<li><code>-p</code>：保留备份数据的原本权限与属性，常用于备份（-c）重要的配置文件</li>
<li><code>-P</code>：保留绝对路径，亦即允许备份数据中含有根目录存在之意；</li>
<li><code>--exclude=FILE</code>：在压缩的过程中，不要将 FILE 打包！ </li>
</ul>
<p>tar 并不会主动的产生创建的文件名喔！我们要自订啦！ 所以扩展名就显的很重要了！如果不加 <code>[-z|-j|-J]</code> 的话，文件名最好取为 <code>*.tar</code> 即可。如果是 <code>-j</code>选项，代表有 bzip2 的支持，因此文件名最好就取为 <code>*.tar.bz2</code> ，因为 bzip2 会产生 <code>.bz2</code> 的扩展名之故！ 至于如果是加上了 <code>-z</code> 的 gzip 的支持，那文件名最好取为 <code>*.tar.gz</code> 喔！</p>
<p>另外值得一提的是，tar 打包出来的文件有没有进行压缩所得到文件称呼不同喔！ 如果仅是打包而已，就是 <code>tar -cv -f file.tar</code>而已，这个文件我们称呼为 tarfile 。 如果还有进行压缩的支持，例如 <code>tar -jcv -f file.tar.bz2</code> 时，我们就称呼为 tarball （tar 球？）！这只是一个基本的称谓而已，不过很多书籍与网络都会使用到这个 tarball 的名称！所以得要跟您介绍介绍。</p>
<h2 id="u547D_u4EE4_3A_cut_2C_grep"><a href="#u547D_u4EE4_3A_cut_2C_grep" class="headerlink" title="命令: cut, grep"></a>命令: cut, grep</h2><blockquote>
<p>cut</p>
</blockquote>
<p>cut 不就是“切”吗？没错啦！这个指令可以将一段讯息的某一段给他“切”出来～ 处理的讯息是以“行”为单位喔！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cut <span class="operator">-d</span><span class="string">'分隔字符'</span> <span class="operator">-f</span> fields &lt;==用于有特定分隔字符</span><br><span class="line">cut -c 字符区间            &lt;==用于排列整齐的讯息</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-d</code>：后面接分隔字符。与 -f 一起使用；</li>
<li><code>-f</code>：依据 -d 的分隔字符将一段讯息分区成为数段，用 -f 取出第几段的意思；</li>
<li><code>-c</code>：以字符 （characters） 的单位取出固定字符区间；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 PATH 变量取出，我要找出第五个路径。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;PATH&#125;</span> | cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">5</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;PATH&#125;</span> | cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">3</span>,<span class="number">5</span> <span class="comment"># 找第 3 与第 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：将 export 输出的讯息，取得第 12 字符以后的所有字串</span></span><br><span class="line"><span class="built_in">export</span> | cut -c <span class="number">12</span>-</span><br><span class="line"><span class="comment"># 知道怎么回事了吧？用 -c 可以处理比较具有格式的输出数据！</span></span><br><span class="line"><span class="comment"># 我们还可以指定某个范围的值，例如第 12-20 的字符，就是 cut -c 12-20 等等！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：用 last 将显示的登陆者的信息中，仅留下使用者大名</span></span><br><span class="line">last | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 由输出的结果我们可以发现第一个空白分隔的字段代表帐号，所以使用如上指令：</span></span><br><span class="line"><span class="comment"># 但是因为 root   pts/1 之间空格有好几个，并非仅有一个，所以，如果要找出 </span></span><br><span class="line"><span class="comment"># pts/1 其实不能以 cut -d ' ' -f 1,2 喔！输出的结果会不是我们想要的。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>grep</p>
</blockquote>
<p>刚刚的 cut 是将一行讯息当中，取出某部分我们想要的，而 grep 则是分析一行讯息， 若当中有我们所需要的信息，就将该行拿出来～简单的语法是这样的：</p>
<p><code>grep [-acinv] [--color=auto] &#39;搜寻字串&#39; filename</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-a</code>：将 binary 文件以 text 文件的方式搜寻数据</li>
<li><code>-c</code>：计算找到 ‘搜寻字串’ 的次数</li>
<li><code>-i</code>：忽略大小写的不同，所以大小写视为相同</li>
<li><code>-n</code>：顺便输出行号</li>
<li><code>-v</code>：反向选择，亦即显示出没有 ‘搜寻字串’ 内容的那一行！</li>
<li><code>--color=auto</code>：可以将找到的关键字部分加上颜色的显示喔！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 last 当中，有出现 root 的那一行就取出来；</span></span><br><span class="line">last | grep <span class="string">'root'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：与范例一相反，只要没有 root 的就取出！</span></span><br><span class="line">last | grep -v <span class="string">'root'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：在 last 的输出讯息中，只要有 root 就取出，并且仅取第一栏</span></span><br><span class="line">last | grep <span class="string">'root'</span> | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span>1</span><br><span class="line"><span class="comment"># 在取出 root 之后，利用上个指令 cut 的处理，就能够仅取得第一栏啰！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例四：取出 /etc/man_db.conf 内含 MANPATH 的那几行</span></span><br><span class="line">grep --color=auto <span class="string">'MANPATH'</span> /etc/man_db.conf</span><br><span class="line">....（前面省略）....</span><br><span class="line">MANPATH_MAP     /usr/games              /usr/share/man</span><br><span class="line">MANPATH_MAP     /opt/bin                /opt/man</span><br><span class="line">MANPATH_MAP     /opt/sbin               /opt/man</span><br><span class="line"><span class="comment"># 神奇的是，如果加上 --color=auto 的选项，找到的关键字部分会用特殊颜色显示喔！</span></span><br></pre></td></tr></table></figure>
<h2 id="u547D_u4EE4_3A_sort_2C_wc_2C_uniq"><a href="#u547D_u4EE4_3A_sort_2C_wc_2C_uniq" class="headerlink" title="命令: sort, wc, uniq"></a>命令: sort, wc, uniq</h2><blockquote>
<p>sort</p>
</blockquote>
<p>sort 是很有趣的指令，他可以帮我们进行排序，而且可以依据不同的数据型态来排序喔！ 例如数字与文字的排序就不一样。此外，排序的字符与语系的编码有关，因此， 如果您需要排序时，建议使用 <code>LANG=C</code> 来让语系统一，数据排序比较好一些。</p>
<p><code>sort [-fbMnrtuk] [file or stdin]</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-f</code>：忽略大小写的差异，例如 A 与 a 视为编码相同；</li>
<li><code>-b</code>：忽略最前面的空白字符部分；</li>
<li><code>-M</code>：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；</li>
<li><code>-n</code>：使用“纯数字”进行排序（默认是以文字体态来排序的）；</li>
<li><code>-r</code>：反向排序；</li>
<li><code>-u</code>：就是 uniq ，相同的数据中，仅出现一行代表；</li>
<li><code>-t</code>：分隔符号，默认是用 [tab] 键来分隔；</li>
<li><code>-k</code>：以那个区间 （field） 来进行排序的意思</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：个人帐号都记录在 /etc/passwd 下，请将帐号进行排序。</span></span><br><span class="line">cat /etc/passwd | sort</span><br><span class="line"></span><br><span class="line">abrt:x:<span class="number">173</span>:<span class="number">173</span>::/etc/abrt:/sbin/nologin</span><br><span class="line">adm:x:<span class="number">3</span>:<span class="number">4</span>:adm:/var/adm:/sbin/nologin</span><br><span class="line">alex:x:<span class="number">1001</span>:<span class="number">1002</span>::/home/alex:/bin/bash</span><br><span class="line"><span class="comment"># 鸟哥省略很多的输出～由上面的数据看起来， sort 是默认“以第一个”数据来排序，</span></span><br><span class="line"><span class="comment"># 而且默认是以“文字”型态来排序的喔！所以由 a 开始排到最后啰！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：/etc/passwd 内容是以 : 来分隔的，我想以第三栏来排序，该如何？</span></span><br><span class="line">cat /etc/passwd | sort -t <span class="string">':'</span> -k <span class="number">3</span></span><br><span class="line"></span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">dmtsai:x:<span class="number">1000</span>:<span class="number">1000</span>:dmtsai:/home/dmtsai:/bin/bash</span><br><span class="line">alex:x:<span class="number">1001</span>:<span class="number">1002</span>::/home/alex:/bin/bash</span><br><span class="line">arod:x:<span class="number">1002</span>:<span class="number">1003</span>::/home/arod:/bin/bash</span><br><span class="line"><span class="comment"># 看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～</span></span><br><span class="line"><span class="comment"># 如果是以文字体态来排序的话，原本就会是这样，想要使用数字排序：</span></span><br><span class="line"><span class="comment"># cat /etc/passwd | sort -t ':' -k 3 -n</span></span><br><span class="line"><span class="comment"># 这样才行啊！用那个 -n 来告知 sort 以数字来排序啊！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：利用 last ，将输出的数据仅取帐号，并加以排序</span></span><br><span class="line">last | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span>1 | sort</span><br></pre></td></tr></table></figure>
<blockquote>
<p>wc</p>
</blockquote>
<p>如果我想要知道 /etc/man_db.conf 这个文件里面有多少字？多少行？多少字符的话， 可以怎么做呢？其实可以利用 wc 这个指令来达成喔！他可以帮我们计算输出的讯息的整体数据！</p>
<p><code>wc [-lwm]</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-l</code>：仅列出行；</li>
<li><code>-w</code>：仅列出多少字（英文单字）；</li>
<li><code>-m</code>  ：多少字符；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：那个 /etc/man_db.conf 里面到底有多少相关字、行、字符数？</span></span><br><span class="line">cat /etc/man_db.conf | wc </span><br><span class="line">    <span class="number">131</span>     <span class="number">723</span>    <span class="number">5171</span></span><br><span class="line"><span class="comment"># 输出的三个数字中，分别代表： “行、字数、字符数”</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：我知道使用 last 可以输出登陆者，但是 last 最后两行并非帐号内容，那么请问，我该如何以一行指令串取得登陆系统的总人次？</span></span><br><span class="line">last | grep [a-zA-Z] | grep -v <span class="string">'wtmp'</span> | grep -v <span class="string">'reboot'</span> | \</span><br><span class="line">&gt; grep -v <span class="string">'unknown'</span> |wc <span class="operator">-l</span> </span><br><span class="line"><span class="comment"># 由于 last 会输出空白行, wtmp, unknown, reboot 等无关帐号登陆的信息，因此，我利用</span></span><br><span class="line"><span class="comment"># grep 取出非空白行，以及去除上述关键字那几行，再计算行数，就能够了解啰</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>uniq</p>
</blockquote>
<p>如果我排序完成了，想要将重复的数据仅列出一个显示，可以怎么做呢？</p>
<p><code>uniq [-ic]</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-i</code>：忽略大小写字符的不同；</li>
<li><code>-c</code>：进行计数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：使用 last 将帐号列出，仅取出帐号栏，进行排序后仅取出一位；</span></span><br><span class="line">last | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span>1 | sort | uniq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：承上题，如果我还想要知道每个人的登陆总次数呢？</span></span><br><span class="line">last | cut <span class="operator">-d</span> <span class="string">' '</span> <span class="operator">-f</span>1 | sort | uniq -c</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">      <span class="number">6</span> （unknown</span><br><span class="line">     <span class="number">47</span> dmtsai</span><br><span class="line">      <span class="number">4</span> reboot</span><br><span class="line">      <span class="number">7</span> root</span><br><span class="line">      <span class="number">1</span> wtmp</span><br><span class="line"><span class="comment"># 从上面的结果可以发现 reboot 有 4 次， root 登陆则有 7 次！大部分是以 dmtsai 来操作！</span></span><br><span class="line"><span class="comment"># wtmp 与第一行的空白都是 last 的默认字符，那两个可以忽略的！</span></span><br></pre></td></tr></table></figure>
<h2 id="u547D_u4EE4_3A_tee_2C_split_2C_xargs"><a href="#u547D_u4EE4_3A_tee_2C_split_2C_xargs" class="headerlink" title="命令: tee, split, xargs"></a>命令: tee, split, xargs</h2><blockquote>
<p>tee</p>
</blockquote>
<p><img src="/images/14590942194893.jpg" alt="tee 的工作流程示意图"></p>
<p>tee 会同时将数据流分送到文件去与屏幕 （screen）；而输出到屏幕的，其实就是 stdout ，那就可以让下个指令继续处理喔！</p>
<p><code>tee [-a] file</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-a</code>：以累加 （append） 的方式，将数据加入 file 当中！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">last | tee last.list | cut <span class="operator">-d</span> <span class="string">" "</span> <span class="operator">-f</span>1</span><br><span class="line"><span class="comment"># 这个范例可以让我们将 last 的输出存一份到 last.list 文件中；</span></span><br><span class="line"></span><br><span class="line">ls <span class="operator">-l</span> /home | tee ~/homefile | more</span><br><span class="line"><span class="comment"># 这个范例则是将 ls 的数据存一份到 ~/homefile ，同时屏幕也有输出讯息！</span></span><br><span class="line"></span><br><span class="line">ls <span class="operator">-l</span> / | tee <span class="operator">-a</span> ~/homefile | more</span><br><span class="line"><span class="comment"># 要注意！ tee 后接的文件会被覆盖，若加上 -a 这个选项则能将讯息累加。</span></span><br></pre></td></tr></table></figure>
<p>tee 可以让 standard output 转存一份到文件内并将同样的数据继续送到屏幕去处理！ 这样除了可以让我们同时分析一份数据并记录下来之外，还可以作为处理一份数据的中间暂存盘记录之用！</p>
<blockquote>
<p>split 将一个大文件，依据文件大小或行数来分区</p>
</blockquote>
<p><code>split [-bl] file PREFIX</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-b</code>：后面可接欲分区成的文件大小，可加单位，例如 b, k, m 等；</li>
<li><code>-l</code>：以行数来进行分区。</li>
<li><code>PREFIX</code>：代表前置字符的意思，可作为分区文件的前导文字。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：我的 /etc/services 有六百多K，若想要分成 300K 一个文件时？</span></span><br><span class="line"><span class="built_in">cd</span> /tmp; split -b <span class="number">300</span>k /etc/services services</span><br><span class="line">ll -k services*</span><br><span class="line"></span><br><span class="line">-rw-rw-r--. <span class="number">1</span> dmtsai dmtsai <span class="number">307200</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">52</span> servicesaa</span><br><span class="line">-rw-rw-r--. <span class="number">1</span> dmtsai dmtsai <span class="number">307200</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">52</span> servicesab</span><br><span class="line">-rw-rw-r--. <span class="number">1</span> dmtsai dmtsai  <span class="number">55893</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">52</span> servicesac</span><br><span class="line"><span class="comment"># 那个文件名可以随意取的啦！我们只要写上前导文字，小文件就会以</span></span><br><span class="line"><span class="comment"># xxxaa, xxxab, xxxac 等方式来创建小文件的！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：如何将上面的三个小文件合成一个文件，文件名为 servicesback</span></span><br><span class="line">cat services* &gt;&gt; servicesback</span><br><span class="line"><span class="comment"># 很简单吧？就用数据流重导向就好啦！简单！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：使用 ls -al / 输出的信息中，每十行记录成一个文件</span></span><br><span class="line">ls -al / | split <span class="operator">-l</span> <span class="number">10</span> - lsroot</span><br><span class="line">wc <span class="operator">-l</span> lsroot*</span><br><span class="line"></span><br><span class="line">  <span class="number">10</span> lsrootaa</span><br><span class="line">  <span class="number">10</span> lsrootab</span><br><span class="line">   <span class="number">4</span> lsrootac</span><br><span class="line">  <span class="number">24</span> total</span><br><span class="line"><span class="comment"># 重点在那个 - 啦！一般来说，如果需要 stdout/stdin 时，但偏偏又没有文件，</span></span><br><span class="line"><span class="comment"># 有的只是 - 时，那么那个 - 就会被当成 stdin 或 stdout ～</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>xargs 参数代换</p>
</blockquote>
<p>xargs 是在做什么的呢？就以字面上的意义来看， x 是加减乘除的乘号，args 则是 arguments （参数） 的意思，所以说，这个玩意儿就是在产生某个指令的参数的意思！ xargs 可以读入 stdin 的数据，并且以空白字符或断行字符作为分辨，将 stdin 的数据分隔成为 arguments 。 因为是以空白字符作为分隔，所以，如果有一些文件名或者是其他意义的名词内含有空白字符的时候， xargs 可能就会误判了</p>
<p><code>xargs [-0epn] command</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-0</code>：如果输入的 stdin 含有特殊字符，例如 `, \, 空白键等等字符时，这个 -0 参数可以将他还原成一般字符。这个参数可以用于特殊状态喔！</li>
<li><code>-e</code>：这个是 EOF （end of file） 的意思。后面可以接一个字串，当 xargs 分析到这个字串时，就会停止继续工作！</li>
<li><code>-p</code>：在执行每个指令的 argument 时，都会询问使用者的意思；</li>
<li><code>-n</code>：后面接次数，每次 command 指令执行时，要使用几个参数的意思。</li>
<li>当 xargs 后面没有接任何的指令时，默认是以 echo 来进行输出喔！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 /etc/passwd 内的第一栏取出，仅取三行，使用 id 这个指令将每个帐号内容秀出来</span></span><br><span class="line">id root</span><br><span class="line"></span><br><span class="line">uid=<span class="number">0</span>（root） gid=<span class="number">0</span>（root） groups=<span class="number">0</span>（root）   <span class="comment"># 这个 id 指令可以查询使用者的 UID/GID 等信息</span></span><br><span class="line"></span><br><span class="line">id $（cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span>）</span><br><span class="line"><span class="comment"># 虽然使用 $（cmd） 可以预先取得参数，但可惜的是， id 这个指令“仅”能接受一个参数而已！</span></span><br><span class="line"><span class="comment"># 所以上述的这个指令执行会出现错误！根本不会显示用户的 ID 啊！</span></span><br><span class="line"></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | id</span><br><span class="line"></span><br><span class="line">uid=<span class="number">1000</span>（dmtsai） gid=<span class="number">1000</span>（dmtsai） groups=<span class="number">1000</span>（dmtsai）,<span class="number">10</span>（wheel）   <span class="comment"># 我不是要查自己啊！</span></span><br><span class="line"><span class="comment"># 因为 id 并不是管线命令，因此在上面这个指令执行后，前面的东西通通不见！只会执行 id！</span></span><br><span class="line"></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | xargs id</span><br><span class="line"><span class="comment"># 依旧会出现错误！这是因为 xargs 一口气将全部的数据通通丢给 id 处理～但 id 就接受 1 个啊最多！</span></span><br><span class="line"></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | xargs -n <span class="number">1</span> id</span><br><span class="line"></span><br><span class="line">uid=<span class="number">0</span>（root） gid=<span class="number">0</span>（root） groups=<span class="number">0</span>（root）</span><br><span class="line">uid=<span class="number">1</span>（bin） gid=<span class="number">1</span>（bin） groups=<span class="number">1</span>（bin）</span><br><span class="line">uid=<span class="number">2</span>（daemon） gid=<span class="number">2</span>（daemon） groups=<span class="number">2</span>（daemon）</span><br><span class="line"><span class="comment"># 通过 -n 来处理，一次给予一个参数，因此上述的结果就 OK 正常的显示啰！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：同上，但是每次执行 id 时，都要询问使用者是否动作？</span></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | xargs -p -n <span class="number">1</span> id</span><br><span class="line"></span><br><span class="line">id root ?...y</span><br><span class="line">uid=<span class="number">0</span>（root） gid=<span class="number">0</span>（root） groups=<span class="number">0</span>（root）</span><br><span class="line">id bin ?...y</span><br><span class="line">.....（下面省略）.....</span><br><span class="line"><span class="comment"># 呵呵！这个 -p 的选项可以让使用者的使用过程中，被询问到每个指令是否执行！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：将所有的 /etc/passwd 内的帐号都以 id 查阅，但查到 sync 就结束指令串</span></span><br><span class="line">cut <span class="operator">-d</span> <span class="string">':'</span> <span class="operator">-f</span> <span class="number">1</span> /etc/passwd | xargs <span class="operator">-e</span><span class="string">'sync'</span> -n <span class="number">1</span> id</span><br><span class="line"><span class="comment"># 仔细与上面的案例做比较。也同时注意，那个 -e'sync' 是连在一起的，中间没有空白键</span></span><br><span class="line"><span class="comment"># 上个例子当中，第六个参数是 sync 啊，那么我们下达 -e'sync' 后，则分析到 sync 这个字串时，</span></span><br><span class="line"><span class="comment"># 后面的其他 stdin 的内容就会被 xargs 舍弃掉了！</span></span><br></pre></td></tr></table></figure>
<p>其实，在 man xargs 里面就有三四个小范例，您可以自行参考一下内容。 此外， xargs 真的是很好用的一个玩意儿！您真的需要好好的参详参详！会使用 xargs 的原因是， 很多指令其实并不支持管线命令，因此我们可以通过 xargs 来提供该指令引用 standard input 之用！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例四：找出 /usr/sbin 下面具有特殊权限的文件名，并使用 ls -l 列出详细属性</span></span><br><span class="line">find /usr/sbin -perm /<span class="number">7000</span> | xargs ls <span class="operator">-l</span></span><br><span class="line"></span><br><span class="line">-rwx-<span class="operator">-s</span>--x. <span class="number">1</span> root lock      <span class="number">11208</span> Jun <span class="number">10</span>  <span class="number">2014</span> /usr/sbin/lockdev</span><br><span class="line">-rwsr-xr-x. <span class="number">1</span> root root     <span class="number">113400</span> Mar  <span class="number">6</span> <span class="number">12</span>:<span class="number">17</span> /usr/sbin/mount.nfs</span><br><span class="line">-rwxr-sr-x. <span class="number">1</span> root root      <span class="number">11208</span> Mar  <span class="number">6</span> <span class="number">11</span>:<span class="number">05</span> /usr/sbin/netreport</span><br><span class="line">.....（下面省略）.....</span><br><span class="line"><span class="comment"># 聪明的读者应该会想到使用“ ls -l $（find /usr/sbin -perm /7000） ”来处理这个范例！</span></span><br><span class="line"><span class="comment"># 都 OK！能解决问题的方法，就是好方法！</span></span><br></pre></td></tr></table></figure>
<h2 id="u547D_u4EE4_3A_tr_2C_col_2C_join_2C_paste_2C_expand"><a href="#u547D_u4EE4_3A_tr_2C_col_2C_join_2C_paste_2C_expand" class="headerlink" title="命令: tr, col, join, paste, expand"></a>命令: tr, col, join, paste, expand</h2><blockquote>
<p>tr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换！</p>
</blockquote>
<p><code>tr [-ds] SET1 ...</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-d</code>：删除讯息当中的 SET1 这个字串；</li>
<li><code>-s</code>：取代掉重复的字符！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 last 输出的讯息中，所有的小写变成大写字符：</span></span><br><span class="line">last | tr <span class="string">'[a-z]'</span> <span class="string">'[A-Z]'</span></span><br><span class="line"><span class="comment"># 事实上，没有加上单引号也是可以执行的，如：last | tr [a-z] [A-Z]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：将 /etc/passwd 输出的讯息中，将冒号 （:） 删除</span></span><br><span class="line">cat /etc/passwd | tr <span class="operator">-d</span> <span class="string">':'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：将 /etc/passwd 转存成 dos 断行到 /root/passwd 中，再将 ^M 符号删除</span></span><br><span class="line">cp /etc/passwd ~/passwd &amp;&amp; unix2dos ~/passwd</span><br><span class="line">file /etc/passwd ~/passwd</span><br><span class="line"></span><br><span class="line">/etc/passwd:         ASCII text</span><br><span class="line">/home/dmtsai/passwd: ASCII text, with CRLF line terminators  &lt;==就是 DOS 断行</span><br><span class="line"></span><br><span class="line">cat ~/passwd | tr <span class="operator">-d</span> <span class="string">'\r'</span> &gt; ~/passwd.linux</span><br><span class="line"><span class="comment"># 那个 \r 指的是 DOS 的断行字符，关于更多的字符，请参考 man tr</span></span><br><span class="line">ll /etc/passwd ~/passwd*</span><br><span class="line">-rw-r--r--. <span class="number">1</span> root   root   <span class="number">2092</span> Jun <span class="number">17</span> <span class="number">00</span>:<span class="number">20</span> /etc/passwd</span><br><span class="line">-rw-r--r--. <span class="number">1</span> dmtsai dmtsai <span class="number">2133</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">13</span> /home/dmtsai/passwd</span><br><span class="line">-rw-rw-r--. <span class="number">1</span> dmtsai dmtsai <span class="number">2092</span> Jul  <span class="number">9</span> <span class="number">22</span>:<span class="number">13</span> /home/dmtsai/passwd.linux</span><br><span class="line"><span class="comment"># 处理过后，发现文件大小与原本的 /etc/passwd 就一致了！</span></span><br></pre></td></tr></table></figure>
<p>其实这个指令也可以写在“正则表达式”里头！因为他也是由正则表达式的方式来取代数据的！ 以上面的例子来说，使用 [] 可以设置一串字呢！也常常用来取代文件中的怪异符号！ 例如上面第三个例子当中，可以去除 DOS 文件留下来的 <code>^M</code> 这个断行的符号！这东西相当的有用！相信处理 Linux &amp; Windows 系统中的人们最麻烦的一件事就是这个事情啦！亦即是 DOS 下面会自动的在每行行尾加入 <code>^M</code> 这个断行符号！这个时候除了以前讲过的 dos2unix 之外，我们也可以使用这个 tr 来将 <code>^M</code> 去除！ <code>^M</code> 可以使用 <code>\r</code> 来代替之！</p>
<blockquote>
<p>col</p>
</blockquote>
<p><code>col [-xb]</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-x</code>：将 tab 键转换成对等的空白键</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">范例一：利用 cat -A 显示出所有特殊按键，最后以 col 将 [tab] 转成空白</span><br><span class="line"> cat -A /etc/man_db.conf  &lt;==此时会看到很多 ^I 的符号，那就是 tab</span><br><span class="line"> cat /etc/man_db.conf | col -x | cat -A | more</span><br><span class="line"><span class="comment"># 嘿嘿！如此一来， [tab] 按键会被取代成为空白键，输出就美观多了！</span></span><br></pre></td></tr></table></figure>
<p>虽然 col 有他特殊的用途，不过，很多时候，他可以用来简单的处理将 [tab] 按键取代成为空白键！ 例如上面的例子当中，如果使用 cat -A 则 [tab] 会以 <code>^I</code> 来表示。 但经过 col -x 的处理，则会将 [tab] 取代成为对等的空白键！</p>
<blockquote>
<p>join 处理两个文件之间的数据</p>
</blockquote>
<p><code>join [-ti12] file1 file2</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-t</code>：join 默认以空白字符分隔数据，并且比对“第一个字段”的数据，如果两个文件相同，则将两笔数据联成一行，且第一个字段放在第一个</li>
<li><code>-i</code>：忽略大小写的差异；</li>
<li><code>-1</code>：这个是数字的 1 ，代表“第一个文件要用那个字段来分析”的意思；</li>
<li><code>-2</code>：代表“第二个文件要用那个字段来分析”的意思。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：用 root 的身份，将 /etc/passwd 与 /etc/shadow 相关数据整合成一栏</span></span><br><span class="line">head -n <span class="number">3</span> /etc/passwd /etc/shadow</span><br><span class="line">==&gt; /etc/passwd &lt;==</span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin</span><br><span class="line"></span><br><span class="line">==&gt; /etc/shadow &lt;==</span><br><span class="line">root:<span class="variable">$6</span><span class="variable">$wtbCCce</span>/PxMeE5wm<span class="variable">$KE2IfSJr</span>...:<span class="number">16559</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">bin:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">daemon:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line"><span class="comment"># 由输出的数据可以发现这两个文件的最左边字段都是相同帐号！且以 : 分隔</span></span><br><span class="line"></span><br><span class="line">join -t <span class="string">':'</span> /etc/passwd /etc/shadow | head -n <span class="number">3</span></span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash:<span class="variable">$6</span><span class="variable">$wtbCCce</span>/PxMeE5wm<span class="variable">$KE2IfSJr</span>...:<span class="number">16559</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line"><span class="comment"># 通过上面这个动作，我们可以将两个文件第一字段相同者整合成一列！</span></span><br><span class="line"><span class="comment"># 第二个文件的相同字段并不会显示（因为已经在最左边的字段出现了啊！）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：我们知道 /etc/passwd 第四个字段是 GID ，那个 GID 记录在 /etc/group 当中的第三个字段，请问如何将两个文件整合？</span></span><br><span class="line">head -n <span class="number">3</span> /etc/passwd /etc/group</span><br><span class="line">==&gt; /etc/passwd &lt;==</span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin</span><br><span class="line"></span><br><span class="line">==&gt; /etc/group &lt;==</span><br><span class="line">root:x:<span class="number">0</span>:</span><br><span class="line">bin:x:<span class="number">1</span>:</span><br><span class="line">daemon:x:<span class="number">2</span>:</span><br><span class="line"><span class="comment"># 从上面可以看到，确实有相同的部分喔！赶紧来整合一下！</span></span><br><span class="line"></span><br><span class="line">join -t <span class="string">':'</span> -<span class="number">1</span> <span class="number">4</span> /etc/passwd -<span class="number">2</span> <span class="number">3</span> /etc/group | head -n <span class="number">3</span></span><br><span class="line"><span class="number">0</span>:root:x:<span class="number">0</span>:root:/root:/bin/bash:root:x:</span><br><span class="line"><span class="number">1</span>:bin:x:<span class="number">1</span>:bin:/bin:/sbin/nologin:bin:x:</span><br><span class="line"><span class="number">2</span>:daemon:x:<span class="number">2</span>:daemon:/sbin:/sbin/nologin:daemon:x:</span><br><span class="line"><span class="comment"># 同样的，相同的字段部分被移动到最前面了！所以第二个文件的内容就没再显示。</span></span><br><span class="line"><span class="comment"># 请读者们配合上述显示两个文件的实际内容来比对！</span></span><br></pre></td></tr></table></figure>
<p>这个 join 在处理两个相关的数据文件时，就真的是很有帮助的啦！ 例如上面的案例当中，我的 /etc/passwd, /etc/shadow, /etc/group 都是有相关性的， 其中 /etc/passwd, /etc/shadow 以帐号为相关性，至于 /etc/passwd, /etc/group 则以所谓的 GID （帐号的数字定义） 来作为他的相关性。根据这个相关性， 我们可以将有关系的数据放置在一起！这在处理数据可是相当有帮助的！ 但是上面的例子有点难，希望您可以静下心好好的看一看原因喔！</p>
<p>此外，需要特别注意的是，在使用 join 之前，你所需要处理的文件应该要事先经过排序 （sort） 处理！ 否则有些比对的项目会被略过呢！特别注意了！</p>
<blockquote>
<p>paste 直接将两行贴在一起，且中间以 [tab] 键隔开</p>
</blockquote>
<p><code>paste [-d] file1 file2</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-d</code>：后面可以接分隔字符。默认是以 [tab] 来分隔的！</li>
<li><code>-</code>：如果 file 部分写成 - ，表示来自 standard input 的数据的意思。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：用 root 身份，将 /etc/passwd 与 /etc/shadow 同一行贴在一起</span></span><br><span class="line">paste /etc/passwd /etc/shadow</span><br><span class="line"></span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash root:<span class="variable">$6</span><span class="variable">$wtbCCce</span>/PxMeE5wm<span class="variable">$KE2IfSJr</span>...:<span class="number">16559</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin        bin:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin daemon:*:<span class="number">16372</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br><span class="line"><span class="comment"># 注意喔！同一行中间是以 [tab] 按键隔开的！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：先将 /etc/group 读出（用 cat），然后与范例一贴上一起！且仅取出前三行</span></span><br><span class="line">cat /etc/group|paste /etc/passwd /etc/shadow - | head -n <span class="number">3</span></span><br><span class="line"><span class="comment"># 这个例子的重点在那个 - 的使用！那玩意儿常常代表 stdin 喔！</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>expand 将 [tab] 按键转成空白键</p>
</blockquote>
<p><code>expand [-t] file</code></p>
<p>选项与参数：</p>
<ul>
<li><code>-t</code>：后面可以接数字。一般来说，一个 tab 按键可以用 8 个空白键取代。我们也可以自行定义一个 [tab] 按键代表多少个字符呢！</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范例一：将 /etc/man_db.conf 内行首为 MANPATH 的字样就取出；仅取前三行；</span></span><br><span class="line">grep <span class="string">'^MANPATH'</span> /etc/man_db.conf | head -n <span class="number">3</span></span><br><span class="line"></span><br><span class="line">MANPATH_MAP     /bin                    /usr/share/man</span><br><span class="line">MANPATH_MAP     /usr/bin                /usr/share/man</span><br><span class="line">MANPATH_MAP     /sbin                   /usr/share/man</span><br><span class="line"><span class="comment"># 行首的代表标志为 ^ ，这个我们留待下节介绍！先有概念即可！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例二：承上，如果我想要将所有的符号都列出来？（用 cat）</span></span><br><span class="line">grep <span class="string">'^MANPATH'</span> /etc/man_db.conf | head -n <span class="number">3</span> |cat -A</span><br><span class="line"></span><br><span class="line">MANPATH_MAP^I/bin^I^I^I/usr/share/man$</span><br><span class="line">MANPATH_MAP^I/usr/bin^I^I/usr/share/man$</span><br><span class="line">MANPATH_MAP^I/sbin^I^I^I/usr/share/man$</span><br><span class="line"><span class="comment"># 发现差别了吗？没错～ [tab] 按键可以被 cat -A 显示成为 ^I </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例三：承上，我将 [tab] 按键设置成 6 个字符的话？</span></span><br><span class="line">grep <span class="string">'^MANPATH'</span> /etc/man_db.conf | head -n <span class="number">3</span> | expand -t <span class="number">6</span> - | cat -A</span><br><span class="line"></span><br><span class="line">MANPATH_MAP /bin              /usr/share/man$</span><br><span class="line">MANPATH_MAP /usr/bin          /usr/share/man$</span><br><span class="line">MANPATH_MAP /sbin             /usr/share/man$</span><br><span class="line"><span class="number">123456123456123456123456123456123456123456123456</span>...</span><br><span class="line"><span class="comment"># 仔细看一下上面的数字说明，因为我是以 6 个字符来代表一个 [tab] 的长度，所以，</span></span><br><span class="line"><span class="comment"># MAN... 到 /usr 之间会隔 12 （两个 [tab]） 个字符喔！如果 tab 改成 9 的话，</span></span><br><span class="line"><span class="comment"># 情况就又不同了！这里也不好理解～您可以多设置几个数字来查阅就晓得！</span></span><br></pre></td></tr></table></figure>
<h2 id="vi__u4E0E_vim"><a href="#vi__u4E0E_vim" class="headerlink" title="vi 与 vim"></a>vi 与 vim</h2><p>基本上 vi 共分为三种模式，分别是“一般指令模式”、“编辑模式”与“指令列命令模式”。 这三种模式的作用分别是：</p>
<ul>
<li>一般指令模式 （command mode）<ul>
<li>以 vi 打开一个文件就直接进入一般指令模式了（这是默认的模式，也简称为一般模式）。在这个模式中， 你可以使用“上下左右”按键来移动光标，你可以使用“删除字符”或“删除整列”来处理文件内容， 也可以使用“复制、贴上”来处理你的文件数据。</li>
</ul>
</li>
<li>编辑模式 （insert mode）<ul>
<li>在一般指令模式中可以进行删除、复制、贴上等等的动作，但是却无法编辑文件内容的！ 要等到你按下 <code>i, I, o, O, a, A, r, R</code> 等任何一个字母之后才会进入编辑模式。注意了！通常在 Linux 中，按下这些按键时，在画面的左下方会出现“ INSERT 或 REPLACE ”的字样，此时才可以进行编辑。而如果要回到一般指令模式时， 则必须要按下“Esc”这个按键即可退出编辑模式。</li>
</ul>
</li>
<li>指令列命令模式 （command-line mode）<ul>
<li>在一般模式当中，输入 <code>: / ?</code> 三个中的任何一个按钮，就可以将光标移动到最下面那一列。在这个模式当中， 可以提供你“搜寻数据”的动作，而读取、存盘、大量取代字符、离开 vi 、显示行号等等的动作则是在此模式中达成的！</li>
</ul>
</li>
</ul>
<p><img src="/images/14590796988736.jpg" alt=""></p>
<blockquote>
<p>一般指令模式可用的按钮说明</p>
</blockquote>
<ul>
<li>光标移动<ul>
<li><code>h 或 向左方向键（←）</code>：光标向左移动一个字符</li>
<li><code>j 或 向下方向键（↓）</code>：光标向下移动一个字符</li>
<li><code>k 或 向上方向键（↑）</code>：光标向上移动一个字符</li>
<li><code>l 或 向右方向键（→）</code>：光标向右移动一个字符</li>
<li>如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 列，可以使用 <code>30j</code> 或 <code>30↓</code> 的组合按键， 亦即加上想要进行的次数（数字）后，按下动作即可！</li>
<li><code>[Ctrl] + [f]</code>：屏幕“向下”移动一页，相当于 [Page Down]按键 （常用）</li>
<li><code>[Ctrl] + [b]</code>：屏幕“向上”移动一页，相当于 [Page Up] 按键 （常用）</li>
<li><code>[Ctrl] + [d]</code>：屏幕“向下”移动半页</li>
<li><code>[Ctrl] + [u]</code>：屏幕“向上”移动半页</li>
<li><code>+</code>：光标移动到非空白字符的下一列</li>
<li><code>-</code>：光标移动到非空白字符的上一列</li>
<li><code>n&lt;space&gt;</code>：那个 n 表示“数字”，例如 20 。按下数字后再按空白键，光标会向右移动这一列的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</space></li>
<li><code>0 或功能键[Home]</code>：这是数字“ 0 ”：移动到这一列的最前面字符处 （常用）</li>
<li><code>$ 或功能键[End]</code>：移动到这一列的最后面字符处（常用）</li>
<li><code>H</code>：光标移动到这个屏幕的最上方那一列的第一个字符</li>
<li><code>M</code>：光标移动到这个屏幕的中央那一列的第一个字符</li>
<li><code>L</code>：光标移动到这个屏幕的最下方那一列的第一个字符</li>
<li><code>G</code>：移动到这个文件的最后一列（常用）</li>
<li><code>nG</code>：n 为数字。移动到这个文件的第 n 列。例如 20G 则会移动到这个文件的第 20 列（可配合 <code>:set nu</code>）</li>
<li><code>gg</code>：移动到这个文件的第一列，相当于 1G 啊！ （常用）</li>
<li><code>n&lt;Enter&gt;</code>：n 为数字。光标向下移动 n 列（常用）</li>
</ul>
</li>
<li>复制粘贴<ul>
<li><code>x, X</code>：在一列字当中，x 为向后删除一个字符 （相当于 [del] 按键）， X 为向前删除一个字符（相当于 [backspace] 亦即是倒退键） （常用）</li>
<li><code>nx</code>：n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， “10x”</li>
<li><code>dd</code>：删除光标所在的那一整列（常用）</li>
<li><code>ndd</code>：n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列 （常用）</li>
<li><code>d1G</code>：删除光标所在到第一列的所有数据</li>
<li><code>dG</code>：删除光标所在到最后一列的所有数据</li>
<li><code>d$</code>：删除光标所在处，到该列的最后一个字符</li>
<li><code>d0</code>：那个是数字的 0 ，删除光标所在处，到该列的最前面一个字符</li>
<li><code>yy</code>：复制光标所在的那一列（常用）</li>
<li><code>nyy</code>：n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20 列（常用）</li>
<li><code>y1G</code>：复制光标所在列到第一列的所有数据</li>
<li><code>yG</code>：复制光标所在列到最后一列的所有数据</li>
<li><code>y0</code>：复制光标所在的那个字符到该列行首的所有数据</li>
<li><code>y$</code>：复制光标所在的那个字符到该列行尾的所有数据</li>
<li><code>p, P</code>：p 为将已复制的数据在光标下一列贴上，P 则为贴在光标上一列！ 举例来说，我目前光标在第 20 列，且已经复制了 10 列数据。则按下 p 后， 那 10 列数据会贴在原本的 20 列之后，亦即由 21 列开始贴。但如果是按下 P 呢？ 那么原本的第 20 列会被推到变成 30 列。 （常用）</li>
<li><code>J</code>：将光标所在列与下一列的数据结合成同一列</li>
<li><code>c</code>：重复删除多个数据，例如向下删除 10 列，[ 10cj ]</li>
<li><code>u</code>：复原前一个动作。（常用）</li>
<li><code>[Ctrl]+r</code>：重做上一个动作。（常用）这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</li>
<li><code>.</code>：不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点“.”就好了！ （常用）</li>
</ul>
</li>
<li>搜寻取代<ul>
<li><code>/word</code>：向光标之下寻找一个名称为 word 的字串。例如要在文件内搜寻 vbird 这个字串，就输入 <code>/vbird</code> 即可！ （常用）</li>
<li><code>?word</code>：向光标之上寻找一个字串名称为 word 的字串。</li>
<li><code>n</code>：这个 n 是英文按键。代表“重复前一个搜寻的动作”。举例来说， 如果刚刚我们执行 <code>/vbird</code> 去向下搜寻 vbird 这个字串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字串。如果是执行 <code>?vbird</code> 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字串！</li>
<li><code>N</code>：这个 N 是英文按键。与 n 刚好相反，为“反向”进行前一个搜寻动作。 例如 <code>/vbird</code> 后，按下 N 则表示“向上”搜寻 vbird 。</li>
<li>使用 <code>/word</code> 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键字！</li>
<li><code>:n1,n2s/word1/word2/g</code>：n1 与 n2 为数字。在第 n1 与 n2 列之间寻找 word1 这个字串，并将该字串取代为 word2 ！举例来说，在 100 到 200 列之间搜寻 vbird 并取代为 VBIRD 则：<code>:100,200s/vbird/VBIRD/g</code>（常用）</li>
<li><code>:1,$s/word1/word2/g</code>：从第一列到最后一列寻找 word1 字串，并将该字串取代为 word2 ！（常用）</li>
<li><code>:1,$s/word1/word2/gc</code>：从第一列到最后一列寻找 word1 字串，并将该字串取代为 word2 ！且在取代前显示提示字符给使用者确认 （confirm） 是否需要取代！（常用）</li>
</ul>
</li>
</ul>
<blockquote>
<p>进入插入或取代的编辑模式</p>
</blockquote>
<ul>
<li><code>i, I</code>：进入插入模式（Insert mode）<ul>
<li>i 为“从目前光标所在处插入”， I 为“在目前所在列的第一个非空白字符处开始插入”。 （常用）</li>
</ul>
</li>
<li><code>a, A</code>：进入插入模式（Insert mode）<ul>
<li>a 为“从目前光标所在的下一个字符处开始插入”， A 为“从光标所在列的最后一个字符处开始插入”。（常用）</li>
</ul>
</li>
<li><code>o, O</code>：进入插入模式（Insert mode）<ul>
<li>这是英文字母 o 的大小写。o 为“在目前光标所在的下一列处插入新的一列”； O 为在目前光标所在处的上一列插入新的一列！（常用）</li>
</ul>
</li>
<li><code>r, R</code>：进入取代模式（Replace mode）<ul>
<li>r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；（常用）</li>
</ul>
</li>
<li>上面这些按键中，在 vi 画面的左下角处会出现“–INSERT–”或“–REPLACE–”的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在文件里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</li>
<li><code>[Esc]</code>：退出编辑模式，回到一般指令模式中（常用）</li>
</ul>
<blockquote>
<p>一般指令模式切换到指令列模式的可用按钮说明</p>
</blockquote>
<ul>
<li>指令列模式的储存、离开等指令<ul>
<li><code>:w</code>：将编辑的数据写入硬盘文件中（常用）</li>
<li><code>:w!</code>：若文件属性为“只读”时，强制写入该文件。不过，到底能不能写入， 还是跟你对该文件的文件权限有关啊！</li>
<li><code>:q</code>：离开 vi （常用）</li>
<li><code>:q!</code>：若曾修改过文件，又不想储存，使用 ! 为强制离开不储存盘案。</li>
<li><code>:wq</code>：储存后离开，若为 <code>:wq!</code> 则为强制储存后离开 （常用）</li>
<li><code>ZZ</code>：这是大写的 Z 喔！若文件没有更动，则不储存离开，若文件已经被更动过，则储存后离开！</li>
<li><code>:w [filename]</code>：将编辑的数据储存成另一个文件（类似另存新文件）</li>
<li><code>:r [filename]</code>：在编辑的数据中，读入另一个文件的数据。亦即将 “filename” 这个文件内容加到光标所在列后面</li>
<li><code>:n1,n2 w [filename]</code>：将 n1 到 n2 的内容储存成 filename 这个文件。</li>
<li><code>:! command</code>：暂时离开 vi 到指令列模式下执行 command 的显示结果！例如 <code>:! ls /home</code> 即可在 vi 当中察看 /home 下面以 ls 输出的文件信息！</li>
</ul>
</li>
<li>vim 环境的变更<ul>
<li><code>:set nu</code>：显示行号，设置之后，会在每一列的字首显示该列的行号</li>
<li><code>:set nonu</code>：与 set nu 相反，为取消行号！</li>
</ul>
</li>
</ul>
<blockquote>
<p>区块选择（Visual Block）</p>
</blockquote>
<ul>
<li><code>v</code>：字符选择，会将光标经过的地方反白选择！</li>
<li><code>V</code>：列选择，会将光标经过的列反白选择！</li>
<li><code>[Ctrl]+v</code>：区块选择，可以用长方形的方式选择数据</li>
<li><code>y</code>：将反白的地方复制起来</li>
<li><code>d</code>：将反白的地方删除掉</li>
<li><code>p</code>：将刚刚复制的区块，在光标所在处贴上！</li>
</ul>
<blockquote>
<p>多文件编辑</p>
</blockquote>
<p>通过 <code>vim file1 file2</code> 指令来使用一个 vim 打开两个文件</p>
<ul>
<li><code>:n</code>：编辑下一个文件</li>
<li><code>:N</code>：编辑上一个文件</li>
<li><code>:files</code>：列出目前这个 vim 的打开的所有文件</li>
</ul>
<blockquote>
<p>多窗口功能</p>
</blockquote>
<p>如何分区窗口并放入文件呢？ 很简单啊！在指令列模式输入“:sp {filename}”即可！那个 filename 可有可无， 如果想要在新窗口启动另一个文件，就加入文件名，否则仅输入 :sp 时， 出现的则是同一个文件在两个窗口间！</p>
<ul>
<li><code>:sp [filename]</code>：打开一个新窗口，如果有加 filename， 表示在新窗口打开一个新文件，否则表示两个窗口为同一个文件内容（同步显示）。</li>
<li><code>[ctrl]+w+j</code> / <code>[ctrl]+w+↓</code> ：按键的按法是：先按下 [ctrl] 不放， 再按下 w 后放开所有的按键，然后再按下 j （或向下方向键），则光标可移动到下方的窗口。</li>
<li><code>[ctrl]+w+k</code> / <code>[ctrl]+w+↑</code>：同上，不过光标移动到上面的窗口。</li>
<li><code>[ctrl]+w+q</code>：其实就是 :q 结束离开啦！ 举例来说，如果我想要结束下方的窗口，那么利用 <code>[ctrl]+w+↓</code> 移动到下方窗口后，按下 <code>:q</code> 即可离开， 也可以按下 <code>[ctrl]+w+q</code> 啊！</li>
</ul>
<blockquote>
<p>vim 环境设置与记录</p>
</blockquote>
<p>主要是修改 <code>~/.vimrc</code> 和 <code>~/.viminfo</code></p>
<ul>
<li><code>:set nu</code> / <code>:set nonu</code>：就是设置与取消行号啊！</li>
<li><code>:set hlsearch</code> / <code>:set nohlsearch</code>：hlsearch 就是 high light search（高亮度搜寻）。 这个就是设置是否将搜寻的字串反白的设置值。默认值是 hlsearch</li>
<li><code>:set autoindent</code> / <code>:set noautoindent</code>：是否自动缩排？autoindent 就是自动缩排。</li>
<li><code>:set backup</code>：是否自动储存备份文件？一般是 nobackup 的， 如果设置 backup 的话，那么当你更动任何一个文件时，则原始文件会被另存成一个文件名为 filename~ 的文件。 举例来说，我们编辑 hosts ，设置 <code>:set backup</code>，那么当更动 hosts 时，在同目录下，就会产生 hosts~ 文件名的文件，记录原始的 hosts 文件内容</li>
<li><code>:set ruler</code>：还记得我们提到的右下角的一些状态列说明吗？ 这个 ruler 就是在显示或不显示该设置值的啦！</li>
<li><code>:set showmode</code>：这个则是，是否要显示 <code>--INSERT--</code> 之类的字眼在左下角的状态列。</li>
<li><code>:set backspace=（012）</code>：一般来说， 如果我们按下 i 进入编辑模式后，可以利用倒退键 （backspace） 来删除任意字符的。 但是，某些 distribution 则不许如此。此时，我们就可以通过 backspace 来设置啰～ 当 backspace 为 2 时，就是可以删除任意值；0 或 1 时，仅可删除刚刚输入的字符， 而无法删除原本就已经存在的文字了！</li>
<li><code>:set all</code>：显示目前所有的环境参数设置值。</li>
<li><code>:set</code>：显示与系统默认值不同的设置参数， 一般来说就是你有自行变动过的设置参数啦！</li>
<li><code>:syntax on</code> / <code>:syntax off</code>：是否依据程序相关语法显示不同颜色？ 举例来说，在编辑一个纯文本文件时，如果开头是以 # 开始，那么该列就会变成蓝色。 如果你懂得写程序，那么这个 <code>:syntax on</code> 还会主动的帮你除错呢！但是， 如果你仅是编写纯文本，要避免颜色对你的屏幕产生的干扰，则可以取消这个设置 。</li>
<li><code>:set bg=dark</code> / <code>:set bg=light</code>：可用以显示不同的颜色色调，默认是 light 。如果你常常发现注解的字体深蓝色实在很不容易看， 那么这里可以设置为 dark 喔！试看看，会有不同的样式呢！</li>
</ul>
<p>总之，这些设置值很有用处的啦！但是…我是否每次使用 vim 都要重新设置一次各个参数值？ 这不太合理吧？没错啊！所以，我们可以通过配置文件来直接规定我们习惯的 vim 操作环境呢！ 整体 vim 的设置值一般是放置在 <code>/etc/vimrc</code> 这个文件，不过，不建议你修改他！ 你可以修改 <code>~/.vimrc</code> 这个文件 （默认不存在，请你自行手动创建！），将你所希望的设置值写入！ 举例来说，可以是这样的一个文件：</p>
<p><img src="/images/14590898239987.jpg" alt=""></p>
<p>很多朋友常常哀嚎，说他们的 vim 里面怎么无法显示正常的中文啊？其实这很有可能是因为编码的问题！ 因为中文编码有 big5 与 utf8 两种，如果你的文件是使用 big5 编码制作的，但在 vim 的终端接口中你使用的是万国码（utf8）， 由于编码的不同，你的中文文件内容当然就是一堆乱码了！怎么办？这时你得要考虑许多东西啦！有这些：</p>
<ol>
<li>你的 Linux 系统默认支持的语系数据：这与 <code>/etc/locale.conf</code> 有关；</li>
<li>你的终端接口 （bash） 的语系： 这与 <code>LANG</code>, <code>LC_ALL</code> 这几个变量有关；</li>
<li>你的文件原本的编码；</li>
<li>打开终端机的软件，例如在 GNOME 下面的窗口接口。</li>
</ol>
<p>事实上最重要的是上头的第三与第四点，只要这两点的编码一致，你就能够正确的看到与编辑你的中文文件。 否则就会看到一堆乱码啦！</p>
<h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2><p>默认的指令记忆功能可以到达 1000 个！也就是说，你曾经下达过的指令几乎都被记录下来了。<br>这么多的指令记录在哪里呢？在你的主文件夹内的 <code>.bash_history</code> 啦！ 不过，需要留意的是，<code>~/.bash_history</code> 记录的是前一次登陆以前所执行过的指令， 而至于这一次登陆所执行的指令都被暂存在内存中，当你成功的登出系统后，该指令记忆才会记录到 <code>.bash_history</code> 当中！</p>
<p>bash 的配置文件主要分为 login shell 与 non-login shell。login shell 主要读取 <code>/etc/profile</code> 与 <code>~/.bash_profile</code>， non-login shell 则仅读取 <code>~/.bashrc</code></p>
<blockquote>
<p>命令别名设置功能 alias</p>
</blockquote>
<p>假如我需要知道这个目录下面的所有文件 （包含隐藏文件） 及所有的文件属性，那么我就必须要下达 <code>ls -al</code> 这样的指令串，唉！真麻烦，有没有更快的取代方式？呵呵！就使用命令别名呀！例如鸟哥最喜欢直接以 lm 这个自订的命令来取代上面的命令，也就是说， lm 会等于 <code>ls -al</code> 这样的一个功能，嘿！那么要如何作呢？就使用 alias 即可！你可以在指令列输入 alias 就可以知道目前的命令别名有哪些了！也可以直接下达命令来设置别名呦：<code>alias lm=&#39;ls -al&#39;</code></p>
<blockquote>
<p>查询指令是否为 Bash shell 的内置命令 type</p>
</blockquote>
<p><code>type [-tpa] name</code> 选项与参数：</p>
<ul>
<li>不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内置指令</li>
<li><code>-t</code>：当加入 -t 参数时，type 会将 name 以下面这些字眼显示出他的意义：<ul>
<li><code>file</code>：表示为外部指令；</li>
<li><code>alias</code>：表示该指令为命令别名所设置的名称；</li>
<li><code>builtin</code>：表示该指令为 bash 内置的指令功能；</li>
</ul>
</li>
<li><code>-p</code>：如果后面接的 name 为外部指令时，才会显示完整文件名；</li>
<li><code>-a</code>：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 alias</li>
</ul>
<blockquote>
<p>指令的下达与快速编辑按钮</p>
</blockquote>
<p>上面这个指令用途是将三个文件复制到 <code>/root</code> 这个目录下而已。不过，因为指令太长， 于是鸟哥就利用 <code>\[Enter]</code> 来将 [Enter] 这个按键“跳脱！”开来，让 [Enter] 按键不再具有“开始执行”的功能！好让指令可以继续在下一行输入。 需要特别留意， [Enter] 按键是紧接着反斜线 <code>\</code> 的，两者中间没有其他字符。 因为 <code>\</code> 仅跳脱“紧接着的下一个字符”而已！</p>
<p>另外，当你所需要下达的指令特别长，或者是你输入了一串错误的指令时，你想要快速的将这串指令整个删除掉，一般来说，我们都是按下删除键的。 有没有其他的快速组合键可以协助呢？是有的！常见的有下面这些：</p>
<ul>
<li><code>[ctrl]+u</code> / <code>[ctrl]+k</code><ul>
<li>分别是从光标处向前删除指令串 （[ctrl]+u） 及向后删除指令串 （[ctrl]+k）。</li>
</ul>
</li>
<li><code>[ctrl]+a</code> / <code>[ctrl]+e</code><ul>
<li>分别是让光标移动到整个指令串的最前面 （[ctrl]+a） 或最后面 （[ctrl]+e）。</li>
</ul>
</li>
</ul>
<p>Shell 相关的部分会另外进行学习，这里暂时略过</p>
<blockquote>
<p>万用字符</p>
</blockquote>
<ul>
<li><code>*</code>：代表“ 0 个到无穷多个”任意字符</li>
<li><code>?</code>：代表“一定有一个”任意字符</li>
<li><code>[ ]</code>：同样代表“一定有一个在括号内”的字符（非任意字符）。例如 [abcd] 代表“一定有一个字符， 可能是 a, b, c, d 这四个任何一个”</li>
<li><code>[ - ]</code>：若有减号在中括号内时，代表“在编码顺序内的所有字符”。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！</li>
<li><code>[^ ]</code>：若中括号内的第一个字符为指数符号（<code>^</code>），那表示“反向选择”，例如 <code>[^abc]</code> 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。</li>
</ul>
<blockquote>
<p>特殊符号</p>
</blockquote>
<ul>
<li><code>#</code> 注解符号：这个最常被使用在 script 当中，视为说明！在后的数据均不执行</li>
<li><code>\</code> 跳脱符号：将“特殊字符或万用字符”还原成一般字符</li>
<li><code>|</code> 管线 （pipe）：分隔两个管线命令的界定（后两节介绍）；</li>
<li><code>;</code> 连续指令下达分隔符号：连续性命令的界定 （注意！与管线命令并不相同）</li>
<li><code>~</code> 使用者的主文件夹</li>
<li><code>$</code> 取用变量前置字符：亦即是变量之前需要加的变量取代值</li>
<li><code>&amp;</code> 工作控制 （job control）：将指令变成背景下工作</li>
<li><code>!</code> 逻辑运算意义上的“非” not 的意思！</li>
<li><code>/</code> 目录符号：路径分隔的符号</li>
<li><code>&gt;</code>, <code>&gt;&gt;</code> 数据流重导向：输出导向，分别是“取代”与“累加”</li>
<li><code>&lt;</code>, <code>&lt;&lt;</code> 数据流重导向：输入导向 （这两个留待下节介绍）</li>
<li><code>&#39; &#39;</code> 单引号，不具有变量置换的功能（<code>$</code> 变为纯文本）</li>
<li><code>&quot; &quot;</code> 具有变量置换的功能！（<code>$</code> 可保留相关功能）</li>
<li>` ` 两个 ` 中间为可以先执行的指令，亦可使用 $（ ）</li>
<li><code>（ ）</code> 在中间为子 shell 的起始与结束</li>
<li><code>{ }</code> 在中间为命令区块的组合！</li>
</ul>
<blockquote>
<p>重定向</p>
</blockquote>
<p>简单的说，标准输出指的是“指令执行所回传的正确的讯息”，而标准错误输出可理解为“ 指令执行失败后，所回传的错误讯息”。举个简单例子来说，我们的系统默认有 <code>/etc/crontab</code> 但却无 <code>/etc/vbirdsay</code>， 此时若下达 <code>cat /etc/crontab /etc/vbirdsay</code> 这个指令时，cat 会进行：</p>
<ul>
<li>标准输出：读取 <code>/etc/crontab</code> 后，将该文件内容显示到屏幕上；</li>
<li>标准错误输出：因为无法找到 <code>/etc/vbirdsay</code>，因此在屏幕上显示错误讯息</li>
</ul>
<p>不管正确或错误的数据都是默认输出到屏幕上，所以屏幕当然是乱乱的！那能不能通过某些机制将这两股数据分开呢？ 当然可以啊！那就是数据流重导向的功能啊！数据流重导向可以将 standard output （简称 stdout） 与 standard error output （简称 stderr） 分别传送到其他的文件或设备去，而分别传送所用的特殊字符则如下所示：</p>
<ol>
<li>标准输入　　（stdin） ：代码为 0 ，使用 <code>&lt;</code> 或 <code>&lt;&lt;</code> ；</li>
<li>标准输出　　（stdout）：代码为 1 ，使用 <code>&gt;</code>（覆盖） 或 <code>&gt;&gt;</code>（累加） ；</li>
<li>标准错误输出（stderr）：代码为 2 ，使用 <code>2&gt;</code>（覆盖） 或 <code>2&gt;&gt;</code>（累加） ；</li>
</ol>
<p>想像一下，如果我知道错误讯息会发生，所以要将错误讯息忽略掉而不显示或储存呢？ 这个时候黑洞设备 /dev/null 就很重要了！这个 /dev/null 可以吃掉任何导向这个设备的信息喔！</p>
<p>如：<code>find /home -name .bashrc 2&gt; /dev/null</code></p>
<blockquote>
<p>命令执行的判断依据： <code>;</code> , <code>&amp;&amp;</code>, <code>||</code></p>
</blockquote>
<ul>
<li><code>cmd ; cmd</code> 不考虑指令相关性的连续指令下达</li>
<li><code>$? （指令回传值） 与 &amp;&amp; 或 ||</code></li>
</ul>
<blockquote>
<p>管线命令 pipe</p>
</blockquote>
<p>在每个管线后面接的第一个数据必定是“指令”喔！而且这个指令必须要能够接受 standard input 的数据才行，这样的指令才可以是为“管线命令”，例如 less, more, head, tail 等都是可以接受 standard input 的管线命令啦。至于例如 ls, cp, mv 等就不是管线命令了！因为 ls, cp, mv 并不会接受来自 stdin 的数据。 也就是说，管线命令主要有两个比较需要注意的地方：</p>
<ul>
<li>管线命令仅会处理 standard output，对于 standard error output 会予以忽略</li>
<li>管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行。</li>
</ul>
<blockquote>
<p>关于减号 - 的用途</p>
</blockquote>
<p>管线命令在 bash 的连续的处理程序中是相当重要的！另外，在 log file 的分析当中也是相当重要的一环， 所以请特别留意！另外，在管线命令当中，常常会使用到前一个指令的 stdout 作为这次的 stdin ， 某些指令需要用到文件名称 （例如 tar） 来进行处理时，该 stdin 与 stdout 可以利用减号 “-“ 来替代， 举例来说：</p>
<p>``bash<br>mkdir /tmp/homeback<br>tar -cvf - /home | tar -xvf - -C /tmp/homeback<br>```</p>
<p>上面这个例子是说：“我将 /home 里面的文件给他打包，但打包的数据不是纪录到文件，而是传送到 stdout； 经过管线后，将 <code>tar -cvf - /home</code> 传送给后面的 <code>tar -xvf -</code> ”。后面的这个 <code>-</code> 则是取用前一个指令的 <code>stdout</code>，因此，我们就不需要使用 filename 了！这是很常见的例子喔！注意注意！</p>
<h2 id="Linux__u76EE_u5F55_u7684_u542B_u4E49"><a href="#Linux__u76EE_u5F55_u7684_u542B_u4E49" class="headerlink" title="Linux 目录的含义"></a>Linux 目录的含义</h2><ul>
<li><code>bin</code><ul>
<li>系统有很多放置可执行文件的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin下面的指令可以被root与一般帐号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。</li>
</ul>
</li>
<li><code>/boot</code><ul>
<li>这个目录主要在放置开机会使用到的文件，包括Linux核心文件以及开机菜单与开机所需配置文件等等。 Linux kernel常用的文件名为：vmlinuz，如果使用的是grub2这个开机管理程序， 则还会存在/boot/grub2/这个目录喔！</li>
</ul>
</li>
<li><code>/dev</code><ul>
<li>在Linux系统上，任何设备与周边设备都是以文件的型态存在于这个目录当中的。 你只要通过存取这个目录下面的某个文件，就等于存取某个设备啰～ 比要重要的文件有 <code>/dev/null</code>, <code>/dev/zero</code>, <code>/dev/tty</code>, <code>/dev/loop*</code>, <code>/dev/sd*</code> 等等 </li>
</ul>
</li>
<li><code>/etc</code><ul>
<li>系统主要的配置文件几乎都放置在这个目录内，例如人员的帐号密码档、 各种服务的启始档等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的， 但是只有root有权力修改。FHS建议不要放置可可执行文件（binary）在这个目录中喔。比较重要的文件有： /etc/modprobe.d/, /etc/passwd, /etc/fstab, /etc/issue 等等。另外 FHS 还规范几个重要的目录最好要存在 /etc/ 目录下喔：</li>
<li>/etc/opt（必要）：这个目录在放置第三方协力软件 /opt 的相关配置文件</li>
<li>/etc/X11/（建议）：与 X Window 有关的各种配置文件都在这里，尤其是 xorg.conf 这个 X Server 的配置文件。</li>
<li>/etc/sgml/（建议）：与 SGML 格式有关的各项配置文件</li>
<li>/etc/xml/（建议）：与 XML 格式有关的各项配置文件</li>
</ul>
</li>
<li><code>/lib</code><ul>
<li>系统的函数库非常的多，而/lib放置的则是在开机时会用到的函数库， 以及在/bin或/sbin下面的指令会调用的函数库而已。 什么是函数库呢？你可以将他想成是“外挂”，某些指令必须要有这些“外挂”才能够顺利完成程序的执行之意。 另外 FSH 还要求下面的目录必须要存在：</li>
<li>/lib/modules/：这个目录主要放置可抽换式的核心相关模块（驱动程序）喔！</li>
</ul>
</li>
<li><code>/media</code><ul>
<li>media是“媒体”的英文，顾名思义，这个/media下面放置的就是可移除的设备啦！ 包括软盘、光盘、DVD等等设备都暂时挂载于此。常见的文件名有：/media/floppy，/media/cdrom等等。</li>
</ul>
</li>
<li><code>/mnt</code><ul>
<li>如果你想要暂时挂载某些额外的设备，一般建议你可以放置到这个目录中。 在古早时候，这个目录的用途与/media相同啦！只是有了/media之后，这个目录就用来暂时挂载用了。</li>
</ul>
</li>
<li><code>/opt</code><ul>
<li>这个是给第三方协力软件放置的目录。什么是第三方协力软件啊？ 举例来说，KDE这个桌面管理系统是一个独立的计划，不过他可以安装到Linux系统中，因此KDE的软件就建议放置到此目录下了。 另外，如果你想要自行安装额外的软件（非原本的distribution提供的），那么也能够将你的软件安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！ </li>
</ul>
</li>
<li><code>/run</code><ul>
<li>早期的 FHS 规定系统开机后所产生的各项信息应该要放置到 /var/run 目录下，新版的 FHS 则规范到 /run 下面。 由于 /run 可以使用内存来仿真，因此性能上会好很多！</li>
</ul>
</li>
<li><code>/sbin</code><ul>
<li>Linux有非常多指令是用来设置系统环境的，这些指令只有root才能够利用来“设置”系统，其他使用者最多只能用来“查询”而已。 放在/sbin下面的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序，一般则放置到/usr/sbin/当中。至于本机自行安装的软件所产生的系统可执行文件（system binary）， 则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, mkfs等等。</li>
</ul>
</li>
<li><code>/srv</code><ul>
<li>srv可以视为“service”的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如WWW, FTP等等。举例来说，WWW服务器需要的网页数据就可以放置在/srv/www/里面。 不过，系统的服务数据如果尚未要提供给网际网络任何人浏览的话，默认还是建议放置到 /var/lib 下面即可。 </li>
</ul>
</li>
<li><code>/tmp</code><ul>
<li>这是让一般使用者或者是正在执行的程序暂时放置文件的地方。 这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！ 因为FHS甚至建议在开机时，应该要将/tmp下的数据都删除唷！</li>
</ul>
</li>
<li><code>/usr</code><ul>
<li>第二层 FHS 设置，后续介绍</li>
</ul>
</li>
<li><code>/var</code><ul>
<li>第二层 FHS 设置，主要为放置变动性的数据，后续介绍</li>
</ul>
</li>
</ul>
<p>FHS 建议可以存在的目录</p>
<ul>
<li><code>/home</code><ul>
<li>这是系统默认的使用者主文件夹（home directory）。在你新增一个一般使用者帐号时， 默认的使用者主文件夹都会规范到这里来。比较重要的是，主文件夹有两种代号喔：</li>
<li><code>~</code>：代表目前这个使用者的主文件夹</li>
<li><code>~dmtsai</code>：则代表 dmtsai 的主文件夹！</li>
</ul>
</li>
<li><code>/lib&lt;qual&gt;</code><ul>
<li>用来存放与 /lib 不同的格式的二进制函数库，例如支持 64 位的 /lib64 函数库等</li>
</ul>
</li>
<li><code>/root</code><ul>
<li>系统管理员（root）的主文件夹。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有root的主文件夹，所以我们会希望root的主文件夹与根目录放置在同一个分区中。</li>
</ul>
</li>
</ul>
<p>事实上FHS针对根目录所定义的标准就仅有上面的咚咚，不过我们的Linux下面还有许多目录你也需要了解一下的。 下面是几个在Linux当中也是非常重要的目录喔</p>
<ul>
<li><code>/lost+found</code><ul>
<li>这个目录是使用标准的ext2/ext3/ext4文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。不过如果使用的是 xfs 文件系统的话，就不会存在这个目录了！</li>
</ul>
</li>
<li><code>/proc</code><ul>
<li>这个目录本身是一个“虚拟文件系统（virtual filesystem）”喔！他放置的数据都是在内存当中， 例如系统核心、行程信息（process）、周边设备的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的文件例如：<code>/proc/cpuinfo</code>, <code>/proc/dma</code>, <code>/proc/interrupts</code>, <code>/proc/ioports</code>, <code>/proc/net/*</code> 等等。</li>
</ul>
</li>
<li><code>/sys</code><ul>
<li>这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录核心与系统硬件信息较相关的信息。 包括目前已载入的核心模块与核心侦测到的硬件设备信息等等。这个目录同样不占硬盘容量喔！</li>
</ul>
</li>
</ul>
<p>早期 Linux 在设计的时候，若发生问题时，救援模式通常仅挂载根目录而已，因此有五个重要的目录被要求一定要与根目录放置在一起， 那就是 /etc, /bin, /dev, /lib, /sbin 这五个重要目录。现在许多的 Linux distributions 由于已经将许多非必要的文件移出 /usr 之外了， 所以 /usr 也是越来越精简，同时因为 /usr 被建议为“即使挂载成为只读，系统还是可以正常运行”的模样，所以救援模式也能同时挂载 /usr 喔！ </p>
<h3 id="/usr__u4ECB_u7ECD"><a href="#/usr__u4ECB_u7ECD" class="headerlink" title="/usr 介绍"></a>/usr 介绍</h3><p>依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的（shareable, static）。usr是Unix Software Resource的缩写， 也就是“Unix操作系统软件资源”所放置的目录，而不是使用者的数据啦！这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行创建该软件自己独立的目录。</p>
<p>一般来说，/usr的次目录建议有下面这些：</p>
<ul>
<li><code>/usr/bin/</code><ul>
<li>所有一般用户能够使用的指令都放在这里！目前新的 CentOS 7 已经将全部的使用者指令放置于此，而使用链接文件的方式将 /bin 链接至此！ 也就是说， /usr/bin 与 /bin 是一模一样了！另外，FHS 要求在此目录下不应该有子目录！</li>
</ul>
</li>
<li><code>/usr/lib/</code><ul>
<li>基本上，与 /lib 功能相同，所以 /lib 就是链接到此目录中的！</li>
</ul>
</li>
<li><code>/usr/local/</code><ul>
<li>系统管理员在本机自行安装自己下载的软件（非distribution默认提供者），建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦！ 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录喔！</li>
</ul>
</li>
<li><code>/usr/sbin/</code><ul>
<li>非系统正常运行所需要的系统指令。最常见的就是某些网络服务器软件的服务指令（daemon）啰！不过基本功能与 /sbin 也差不多， 因此目前 /sbin 就是链接到此目录中的。</li>
</ul>
</li>
<li><code>/usr/share/</code><ul>
<li>主要放置只读架构的数据文件，当然也包括共享文件。在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文字文件嘛！在此目录下常见的还有这些次目录：</li>
<li>/usr/share/man：线上说明文档</li>
<li>/usr/share/doc：软件杂项的文件说明</li>
<li>/usr/share/zoneinfo：与时区有关的时区文件</li>
</ul>
</li>
</ul>
<p>FHS 建议可以存在的目录</p>
<ul>
<li><code>/usr/games/</code><ul>
<li>与游戏比较相关的数据放置处</li>
</ul>
</li>
<li><code>/usr/include/</code><ul>
<li>c/c++等程序语言的文件开始（header）与包含档（include）放置处，当我们以tarball方式 （<code>*.tar.gz</code> 的方式安装软件）安装某些数据时，会使用到里头的许多包含档喔！</li>
</ul>
</li>
<li><code>/usr/libexec/</code><ul>
<li>某些不被一般使用者惯用的可执行文件或脚本（script）等等，都会放置在此目录中。例如大部分的 X 窗口下面的操作指令， 很多都是放在此目录下的。</li>
</ul>
</li>
<li><code>/usr/lib&lt;qual&gt;/</code><ul>
<li>与 <code>/lib&lt;qual&gt;/</code> 功能相同，因此目前 <code>/lib&lt;qual&gt;</code> 就是链接到此目录中 </li>
</ul>
</li>
<li><code>/usr/src/</code><ul>
<li>一般源代码建议放置到这里，src有source的意思。至于核心源代码则建议放置到/usr/src/linux/目录下。</li>
</ul>
</li>
</ul>
<h3 id="/var__u4ECB_u7ECD"><a href="#/var__u4ECB_u7ECD" class="headerlink" title="/var 介绍"></a>/var 介绍</h3><p>如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运行后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括高速缓存（cache）、登录文件（log file）以及某些软件运行所产生的文件， 包括程序文件（lock file, run file），或者例如MySQL数据库的文件等等。常见的次目录有：</p>
<ul>
<li><code>/var/cache/</code><ul>
<li>应用程序本身运行过程中会产生的一些暂存盘；</li>
</ul>
</li>
<li><code>/var/lib/</code><ul>
<li>程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去！</li>
</ul>
</li>
<li><code>/var/lock/</code><ul>
<li>某些设备或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该设备时， 就可能产生一些错误的状况，因此就得要将该设备上锁（lock），以确保该设备只会给单一软件所使用。 举例来说，烧录机正在烧录一块光盘，你想一下，会不会有两个人同时在使用一个烧录机烧片？ 如果两个人同时烧录，那片子写入的是谁的数据？所以当第一个人在烧录时该烧录机就会被上锁， 第二个人就得要该设备被解除锁定（就是前一个人用完了）才能够继续使用啰。目前此目录也已经挪到 /run/lock 中！</li>
</ul>
</li>
<li><code>/var/log/</code><ul>
<li>重要到不行！这是登录文件放置的目录！里面比较重要的文件如/var/log/messages, /var/log/wtmp（记录登陆者的信息）等。</li>
</ul>
</li>
<li><code>/var/mail/</code><ul>
<li>放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中！ 通常这两个目录是互为链接文件啦！</li>
</ul>
</li>
<li><code>/var/run/</code><ul>
<li>某些程序或者是服务启动后，会将他们的PID放置在这个目录下喔！至于PID的意义我们会在后续章节提到的。 与 /run 相同，这个目录链接到 /run 去了！</li>
</ul>
</li>
<li><code>/var/spool/</code><ul>
<li>这个目录通常放置一些伫列数据，所谓的“伫列”就是排队等待其他程序使用的数据啦！ 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作调度数据（crontab），就会被放置到/var/spool/cron/目录中！</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为之后更多会涉及后台开发的部分，所以系统学习一下 Linux 还是很有必要的，这里就用《鸟哥的 Linux 私房菜》作为主要的学习材料。不过因为我本身已经有一定基础了，所以这里主要会记录个人觉得比较生疏和重要的地方。</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://wdxtub.com/tags/Linux/"/>
    
      <category term="基础" scheme="http://wdxtub.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="服务器" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
